Project Path: arc_pxb1988_dex2jar_719bfqfr

Source Tree:

```txt
arc_pxb1988_dex2jar_719bfqfr
├── LICENSE.txt
├── NOTICE.txt
├── README.md
├── build.gradle
├── d2j-base-cmd
│   ├── build.gradle
│   └── src
│       └── main
│           └── java
│               └── com
│                   └── googlecode
│                       └── dex2jar
│                           └── tools
│                               └── BaseCmd.java
├── d2j-jasmin
│   ├── build.gradle
│   └── src
│       ├── main
│       │   ├── antlr3
│       │   │   └── com
│       │   │       └── googlecode
│       │   │           └── d2j
│       │   │               └── jasmin
│       │   │                   └── Jasmin.g
│       │   └── java
│       │       └── com
│       │           └── googlecode
│       │               └── d2j
│       │                   └── jasmin
│       │                       ├── Jar2JasminCmd.java
│       │                       ├── Jasmin2JarCmd.java
│       │                       ├── JasminDumper.java
│       │                       └── Jasmins.java
│       └── test
│           ├── java
│           │   └── com
│           │       └── googlecode
│           │           └── d2j
│           │               └── tools
│           │                   └── jar
│           │                       └── test
│           │                           └── Jasmin2jTest.java
│           └── resources
│               └── jasmins
│                   └── type.j
├── d2j-smali
│   ├── build.gradle
│   └── src
│       ├── main
│       │   ├── antlr4
│       │   │   └── com
│       │   │       └── googlecode
│       │   │           └── d2j
│       │   │               └── smali
│       │   │                   └── antlr4
│       │   │                       └── Smali.g4
│       │   └── java
│       │       └── com
│       │           └── googlecode
│       │               └── d2j
│       │                   └── smali
│       │                       ├── AntlrSmaliUtil.java
│       │                       ├── Baksmali.java
│       │                       ├── BaksmaliCmd.java
│       │                       ├── BaksmaliCodeDumper.java
│       │                       ├── BaksmaliDexFileVisitor.java
│       │                       ├── BaksmaliDumpOut.java
│       │                       ├── BaksmaliDumper.java
│       │                       ├── Smali.java
│       │                       ├── SmaliCmd.java
│       │                       ├── SmaliCodeVisitor.java
│       │                       └── Utils.java
│       └── test
│           ├── java
│           │   └── a
│           │       ├── BaksmaliTest.java
│           │       └── SmaliTest.java
│           └── resources
│               └── a.smali
├── dex-ir
│   ├── build.gradle
│   └── src
│       ├── main
│       │   └── java
│       │       └── com
│       │           └── googlecode
│       │               └── dex2jar
│       │                   └── ir
│       │                       ├── ET.java
│       │                       ├── IrMethod.java
│       │                       ├── LabelAndLocalMapper.java
│       │                       ├── LocalVar.java
│       │                       ├── StmtSearcher.java
│       │                       ├── StmtTraveler.java
│       │                       ├── TransformerException.java
│       │                       ├── Trap.java
│       │                       ├── TypeClass.java
│       │                       ├── Util.java
│       │                       ├── expr
│       │                       │   ├── AbstractInvokeExpr.java
│       │                       │   ├── ArrayExpr.java
│       │                       │   ├── BinopExpr.java
│       │                       │   ├── CastExpr.java
│       │                       │   ├── Constant.java
│       │                       │   ├── Exprs.java
│       │                       │   ├── FieldExpr.java
│       │                       │   ├── FilledArrayExpr.java
│       │                       │   ├── InvokeCustomExpr.java
│       │                       │   ├── InvokeExpr.java
│       │                       │   ├── InvokePolymorphicExpr.java
│       │                       │   ├── Local.java
│       │                       │   ├── NewExpr.java
│       │                       │   ├── NewMutiArrayExpr.java
│       │                       │   ├── PhiExpr.java
│       │                       │   ├── RefExpr.java
│       │                       │   ├── StaticFieldExpr.java
│       │                       │   ├── TypeExpr.java
│       │                       │   ├── UnopExpr.java
│       │                       │   └── Value.java
│       │                       ├── stmt
│       │                       │   ├── AssignStmt.java
│       │                       │   ├── BaseSwitchStmt.java
│       │                       │   ├── GotoStmt.java
│       │                       │   ├── IfStmt.java
│       │                       │   ├── JumpStmt.java
│       │                       │   ├── LabelStmt.java
│       │                       │   ├── LookupSwitchStmt.java
│       │                       │   ├── NopStmt.java
│       │                       │   ├── ReturnVoidStmt.java
│       │                       │   ├── Stmt.java
│       │                       │   ├── StmtList.java
│       │                       │   ├── Stmts.java
│       │                       │   ├── TableSwitchStmt.java
│       │                       │   ├── UnopStmt.java
│       │                       │   └── VoidInvokeStmt.java
│       │                       └── ts
│       │                           ├── AggTransformer.java
│       │                           ├── Cfg.java
│       │                           ├── CleanLabel.java
│       │                           ├── ConstTransformer.java
│       │                           ├── DeadCodeTransformer.java
│       │                           ├── EndRemover.java
│       │                           ├── ExceptionHandlerTrim.java
│       │                           ├── FixVar.java
│       │                           ├── Ir2JRegAssignTransformer.java
│       │                           ├── JimpleTransformer.java
│       │                           ├── MultiArrayTransformer.java
│       │                           ├── NewTransformer.java
│       │                           ├── NpeTransformer.java
│       │                           ├── RemoveConstantFromSSA.java
│       │                           ├── RemoveLocalFromSSA.java
│       │                           ├── SSATransformer.java
│       │                           ├── StatedTransformer.java
│       │                           ├── Transformer.java
│       │                           ├── TypeTransformer.java
│       │                           ├── UnSSATransformer.java
│       │                           ├── UniqueQueue.java
│       │                           ├── VoidInvokeTransformer.java
│       │                           ├── ZeroTransformer.java
│       │                           ├── an
│       │                           │   ├── AnalyzeValue.java
│       │                           │   ├── BaseAnalyze.java
│       │                           │   ├── SimpleLiveAnalyze.java
│       │                           │   └── SimpleLiveValue.java
│       │                           └── array
│       │                               ├── ArrayElementTransformer.java
│       │                               ├── ArrayNullPointerTransformer.java
│       │                               └── FillArrayTransformer.java
│       └── test
│           └── java
│               └── com
│                   └── googlecode
│                       └── dex2jar
│                           └── ir
│                               └── test
│                                   ├── AggTransformerTest.java
│                                   ├── BaseTransformerTest.java
│                                   ├── ConstTransformerTest.java
│                                   ├── ConstantStringTest.java
│                                   ├── DeadCodeTrnasformerTest.java
│                                   ├── JimpleTransformerTest.java
│                                   ├── RemoveConstantFromSSATest.java
│                                   ├── RemoveLocalFromSSATest.java
│                                   ├── SSATransformerTest.java
│                                   ├── StmtListTest.java
│                                   ├── TypeTransformerTest.java
│                                   ├── UnSSATransformerTransformerTest.java
│                                   └── ZeroTransformerTest.java
├── dex-reader
│   ├── build.gradle
│   └── src
│       ├── main
│       │   └── java
│       │       └── com
│       │           └── googlecode
│       │               └── d2j
│       │                   ├── reader
│       │                   │   ├── BaseDexFileReader.java
│       │                   │   ├── DexFileReader.java
│       │                   │   ├── MultiDexFileReader.java
│       │                   │   └── zip
│       │                   │       └── ZipUtil.java
│       │                   └── util
│       │                       ├── ASMifierAnnotationV.java
│       │                       ├── ASMifierClassV.java
│       │                       ├── ASMifierCodeV.java
│       │                       ├── ASMifierFileV.java
│       │                       ├── ArrayOut.java
│       │                       ├── Escape.java
│       │                       ├── Mutf8.java
│       │                       ├── Out.java
│       │                       ├── Utf8Utils.java
│       │                       └── zip
│       │                           ├── AccessBufByteArrayOutputStream.java
│       │                           ├── AutoSTOREDZipOutputStream.java
│       │                           ├── ZipConstants.java
│       │                           ├── ZipEntry.java
│       │                           └── ZipFile.java
│       └── test
│           ├── java
│           │   └── com
│           │       └── googlecode
│           │           └── d2j
│           │               └── reader
│           │                   └── test
│           │                       ├── AsmfierTest.java
│           │                       ├── BadZipEntryFlagTest.java
│           │                       └── SkipDupMethod.java
│           └── resources
│               ├── bad.zip
│               └── i200.dex
├── dex-reader-api
│   ├── build.gradle
│   └── src
│       └── main
│           └── java
│               └── com
│                   └── googlecode
│                       └── d2j
│                           ├── CallSite.java
│                           ├── DexConstants.java
│                           ├── DexException.java
│                           ├── DexLabel.java
│                           ├── DexType.java
│                           ├── Field.java
│                           ├── Method.java
│                           ├── MethodHandle.java
│                           ├── Proto.java
│                           ├── Visibility.java
│                           ├── node
│                           │   ├── DexAnnotationNode.java
│                           │   ├── DexClassNode.java
│                           │   ├── DexCodeNode.java
│                           │   ├── DexDebugNode.java
│                           │   ├── DexFieldNode.java
│                           │   ├── DexFileNode.java
│                           │   ├── DexMethodNode.java
│                           │   ├── TryCatchNode.java
│                           │   ├── analysis
│                           │   │   ├── DvmFrame.java
│                           │   │   └── DvmInterpreter.java
│                           │   └── insn
│                           │       ├── AbstractMethodStmtNode.java
│                           │       ├── BaseSwitchStmtNode.java
│                           │       ├── ConstStmtNode.java
│                           │       ├── DexLabelStmtNode.java
│                           │       ├── DexStmtNode.java
│                           │       ├── FieldStmtNode.java
│                           │       ├── FillArrayDataStmtNode.java
│                           │       ├── FilledNewArrayStmtNode.java
│                           │       ├── JumpStmtNode.java
│                           │       ├── MethodCustomStmtNode.java
│                           │       ├── MethodPolymorphicStmtNode.java
│                           │       ├── MethodStmtNode.java
│                           │       ├── PackedSwitchStmtNode.java
│                           │       ├── SparseSwitchStmtNode.java
│                           │       ├── Stmt0RNode.java
│                           │       ├── Stmt1RNode.java
│                           │       ├── Stmt2R1NNode.java
│                           │       ├── Stmt2RNode.java
│                           │       ├── Stmt3RNode.java
│                           │       └── TypeStmtNode.java
│                           ├── reader
│                           │   ├── CFG.java
│                           │   ├── InstructionFormat.java
│                           │   ├── InstructionIndexType.java
│                           │   └── Op.java
│                           └── visitors
│                               ├── DexAnnotationAble.java
│                               ├── DexAnnotationVisitor.java
│                               ├── DexClassVisitor.java
│                               ├── DexCodeVisitor.java
│                               ├── DexDebugVisitor.java
│                               ├── DexFieldVisitor.java
│                               ├── DexFileVisitor.java
│                               └── DexMethodVisitor.java
├── dex-tools
│   ├── build.gradle
│   ├── open-source-license.txt
│   └── src
│       ├── main
│       │   ├── assemble
│       │   │   └── package.xml
│       │   ├── bin_gen
│       │   │   ├── bat_template
│       │   │   ├── class.cfg
│       │   │   ├── d2j_invoke.bat
│       │   │   ├── d2j_invoke.sh
│       │   │   └── sh_template
│       │   ├── java
│       │   │   └── com
│       │   │       └── googlecode
│       │   │           ├── d2j
│       │   │           │   ├── signapk
│       │   │           │   │   ├── AbstractJarSign.java
│       │   │           │   │   ├── Base64.java
│       │   │           │   │   ├── SunJarSignImpl.java
│       │   │           │   │   └── TinySignImpl.java
│       │   │           │   ├── tools
│       │   │           │   │   └── jar
│       │   │           │   │       ├── BaseWeaver.java
│       │   │           │   │       ├── ClassInfo.java
│       │   │           │   │       ├── DexWeaver.java
│       │   │           │   │       ├── InitOut.java
│       │   │           │   │       ├── InvocationWeaver.java
│       │   │           │   │       ├── ScanBridgeAdapter.java
│       │   │           │   │       └── WebApp.java
│       │   │           │   └── util
│       │   │           │       └── AccUtils.java
│       │   │           └── dex2jar
│       │   │               ├── bin_gen
│       │   │               │   └── BinGen.java
│       │   │               └── tools
│       │   │                   ├── ApkSign.java
│       │   │                   ├── AsmVerify.java
│       │   │                   ├── BaksmaliBaseDexExceptionHandler.java
│       │   │                   ├── ClassVersionSwitch.java
│       │   │                   ├── DeObfInitCmd.java
│       │   │                   ├── DecryptStringCmd.java
│       │   │                   ├── Dex2jarCmd.java
│       │   │                   ├── Dex2jarMultiThreadCmd.java
│       │   │                   ├── DexRecomputeChecksum.java
│       │   │                   ├── DexWeaverCmd.java
│       │   │                   ├── ExtractOdexFromCoredumpCmd.java
│       │   │                   ├── GenerateCompileStubFromOdex.java
│       │   │                   ├── Jar2Dex.java
│       │   │                   ├── JarAccessCmd.java
│       │   │                   ├── JarWeaverCmd.java
│       │   │                   ├── StdApkCmd.java
│       │   │                   └── to
│       │   │                       └── Do.java
│       │   └── resources
│       │       └── com
│       │           └── googlecode
│       │               └── dex2jar
│       │                   └── tools
│       │                       ├── ApkSign.cer
│       │                       └── ApkSign.private
│       └── test
│           ├── java
│           │   └── com
│           │       └── googlecode
│           │           └── d2j
│           │               └── tools
│           │                   └── jar
│           │                       ├── MethodInvocation.java
│           │                       └── test
│           │                           ├── DexWaveTest.java
│           │                           └── WaveTest.java
│           └── resources
│               └── weave
│                   ├── a-after.j
│                   ├── a-before.j
│                   ├── a-gen.j
│                   ├── b-after.j
│                   ├── b-before.j
│                   ├── b-gen.j
│                   ├── c-after.j
│                   ├── c-before.j
│                   ├── c-gen.j
│                   └── smali
│                       ├── a-after.smali
│                       ├── a-before.smali
│                       ├── a-gen.smali
│                       ├── b-after.smali
│                       ├── b-before.smali
│                       └── b-gen.smali
├── dex-translator
│   ├── build.gradle
│   ├── libs
│   │   └── dx-30.0.2.jar
│   └── src
│       ├── main
│       │   └── java
│       │       ├── com
│       │       │   └── googlecode
│       │       │       └── d2j
│       │       │           ├── asm
│       │       │           │   └── LdcOptimizeAdapter.java
│       │       │           ├── converter
│       │       │           │   ├── Dex2IRConverter.java
│       │       │           │   ├── IR2JConverter.java
│       │       │           │   └── J2IRConverter.java
│       │       │           ├── dex
│       │       │           │   ├── Asm2Dex.java
│       │       │           │   ├── BaseDexExceptionHandler.java
│       │       │           │   ├── ClassVisitorFactory.java
│       │       │           │   ├── Dex2Asm.java
│       │       │           │   ├── Dex2IrAdapter.java
│       │       │           │   ├── Dex2jar.java
│       │       │           │   ├── DexExceptionHandler.java
│       │       │           │   ├── DexFix.java
│       │       │           │   ├── ExDex2Asm.java
│       │       │           │   ├── LambadaNameSafeClassAdapter.java
│       │       │           │   └── V3.java
│       │       │           └── util
│       │       │               └── Types.java
│       │       ├── org
│       │       │   └── objectweb
│       │       │       └── asm
│       │       │           └── AsmBridge.java
│       │       └── res
│       │           └── Hex.java
│       └── test
│           ├── java
│           │   ├── com
│           │   │   └── googlecode
│           │   │       └── dex2jar
│           │   │           └── test
│           │   │               ├── ASMifierTest.java
│           │   │               ├── ArrayTypeTest.java
│           │   │               ├── AutoCastTest.java
│           │   │               ├── D2jErrorZipsTest.java
│           │   │               ├── D2jTest.java
│           │   │               ├── DexTranslatorRunner.java
│           │   │               ├── EmptyTrapTest.java
│           │   │               ├── I101Test.java
│           │   │               ├── I121Test.java
│           │   │               ├── I168Test.java
│           │   │               ├── I63Test.java
│           │   │               ├── Issue71Test.java
│           │   │               ├── OptSyncTest.java
│           │   │               ├── ResTest.java
│           │   │               ├── Smali2jTest.java
│           │   │               ├── TestDexClassV.java
│           │   │               ├── TestUtils.java
│           │   │               └── ZeroTest.java
│           │   ├── dex2jar
│           │   │   └── gen
│           │   │       └── FTPClient__parsePassiveModeReply.java
│           │   └── res
│           │       ├── ArrayRes.java
│           │       ├── ChineseRes.java
│           │       ├── ConstValues.java
│           │       ├── ExceptionRes.java
│           │       ├── Gh28Type.java
│           │       ├── I142_annotation_default.java
│           │       ├── I56_AccessFlag.java
│           │       ├── I71.java
│           │       ├── I73.java
│           │       ├── I88.java
│           │       ├── LongDoubleRes.java
│           │       ├── NoEndRes.java
│           │       ├── NullZero.java
│           │       ├── OptimizeSynchronized.java
│           │       ├── PopRes.java
│           │       ├── ResChild.java
│           │       ├── ResParent.java
│           │       ├── SwitchRes.java
│           │       ├── U0000String.java
│           │       ├── WideRes.java
│           │       └── i55
│           │           ├── AAbstractClass.java
│           │           ├── AClass.java
│           │           └── AInterface.java
│           └── resources
│               ├── d2j-error-zips
│               │   ├── gh477-1.zip
│               │   └── gh495.zip
│               ├── dexes
│               │   ├── dex038.dex
│               │   ├── dex039.dex
│               │   ├── dex040.dex
│               │   └── i_jetty.dex
│               └── smalis
│                   ├── 0zs.smali
│                   ├── ML.smali
│                   ├── bb-1-can-not-merge-z-and-i.smali
│                   ├── bb-5-ArrayIndexOutOfBoundsOnType.smali
│                   ├── empty-try-catch-with-goto-head.smali
│                   ├── gh-issue-186.smali
│                   ├── gh-issue-4.smali
│                   ├── gh501-r4k.smali
│                   ├── goto-first-label.smali
│                   ├── i230.smali
│                   ├── int-or-boolean.smali
│                   ├── issue-220-219-uninit-reg.smali
│                   ├── loop-enclosing-class.smali
│                   ├── method-code-too-large.smali
│                   ├── negative-array-size.smali
│                   ├── npe-cause-trap-fail.smali
│                   ├── opt-lock.smali
│                   ├── useless-new.smali
│                   └── writeString.smali
├── dex-writer
│   ├── build.gradle
│   └── src
│       ├── main
│       │   └── java
│       │       └── com
│       │           └── googlecode
│       │               └── d2j
│       │                   └── dex
│       │                       └── writer
│       │                           ├── AnnotationWriter.java
│       │                           ├── CantNotFixContentException.java
│       │                           ├── ClassWriter.java
│       │                           ├── CodeWriter.java
│       │                           ├── DexFileWriter.java
│       │                           ├── DexWriteException.java
│       │                           ├── FieldWriter.java
│       │                           ├── MethodWriter.java
│       │                           ├── ann
│       │                           │   ├── Alignment.java
│       │                           │   ├── Idx.java
│       │                           │   └── Off.java
│       │                           ├── ev
│       │                           │   ├── EncodedAnnotation.java
│       │                           │   ├── EncodedArray.java
│       │                           │   └── EncodedValue.java
│       │                           ├── insn
│       │                           │   ├── Insn.java
│       │                           │   ├── JumpOp.java
│       │                           │   ├── Label.java
│       │                           │   ├── OpInsn.java
│       │                           │   └── PreBuildInsn.java
│       │                           ├── io
│       │                           │   ├── ByteBufferOut.java
│       │                           │   └── DataOut.java
│       │                           └── item
│       │                               ├── AnnotationItem.java
│       │                               ├── AnnotationSetItem.java
│       │                               ├── AnnotationSetRefListItem.java
│       │                               ├── AnnotationsDirectoryItem.java
│       │                               ├── BaseItem.java
│       │                               ├── CallSiteIdItem.java
│       │                               ├── ClassDataItem.java
│       │                               ├── ClassDefItem.java
│       │                               ├── CodeItem.java
│       │                               ├── ConstPool.java
│       │                               ├── DebugInfoItem.java
│       │                               ├── FieldIdItem.java
│       │                               ├── HeadItem.java
│       │                               ├── MapListItem.java
│       │                               ├── MethodHandleItem.java
│       │                               ├── MethodIdItem.java
│       │                               ├── ProtoIdItem.java
│       │                               ├── SectionItem.java
│       │                               ├── StringDataItem.java
│       │                               ├── StringIdItem.java
│       │                               ├── TypeIdItem.java
│       │                               └── TypeListItem.java
│       └── test
│           └── java
│               └── a
│                   ├── AppWriterTest.java
│                   └── CpStringTest.java
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

```

`LICENSE.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


```

`NOTICE.txt`:

```txt
dex2jar - Tools to work with android .dex and java .class files
Copyright (c) 2009-2014 Panxiaobo

contributors
  - Bob Pan <pxb1988#gmail.com>
  - HyperSpeeed <nico.mexis#kabelmail.de>
  - Enea Stanzani <aeneas.ltr#gmail.com>
  - t3stwhat <t3stwhat#gmail.com>
  - paulhooijenga <paulhooijenga#gmail.com>
  - yyjdelete <yyjdelete#gmail.com>
  - jcmdev0 <jcmdev0#gmail.com>

```

`README.md`:

```md
# dex2jar

**Project move to [GitHub](https://github.com/pxb1988/dex2jar)**

| _ | Mirror | Wiki | Downloads | Issues |
|--:|:-----|:----:|:---------:|:------:|
| gh | https://github.com/pxb1988/dex2jar | [Wiki](https://github.com/pxb1988/dex2jar/wiki) | [Releases](https://github.com/pxb1988/dex2jar/releases) | [Issues](https://github.com/pxb1988/dex2jar/issues) |
| sf | https://sourceforge.net/p/dex2jar | [old](https://sourceforge.net/p/dex2jar/wiki) | [old](https://sourceforge.net/projects/dex2jar/files/) | [old](https://sourceforge.net/p/dex2jar/tickets/) |
| bb | https://bitbucket.org/pxb1988/dex2jar | [old](https://bitbucket.org/pxb1988/dex2jar/wiki) | [old](https://bitbucket.org/pxb1988/dex2jar/downloads) | [old](https://bitbucket.org/pxb1988/dex2jar/issues) |
| gc | https://code.google.com/p/dex2jar | [old](http://code.google.com/p/dex2jar/w/list) | [old](http://code.google.com/p/dex2jar/downloads/list) | [old](http://code.google.com/p/dex2jar/issues/list)|

Tools to work with android .dex and java .class files

1. dex-reader/writer:
    Read/write the Dalvik Executable (.dex) file. It has a [light weight API similar with ASM](https://sourceforge.net/p/dex2jar/wiki/Faq#markdown-header-want-to-read-dex-file-using-dex2jar).
2. d2j-dex2jar:
    Convert .dex file to .class files (zipped as jar)
3. smali/baksmali:
    disassemble dex to smali files and assemble dex from smali files. different implementation to [smali/baksmali](http://code.google.com/p/smali), same syntax, but we support escape in type desc "Lcom/dex2jar\t\u1234;"
4. other tools:
    [d2j-decrypt-string](https://sourceforge.net/p/dex2jar/wiki/DecryptStrings)

## Usage

1. In the root directory run: ./gradlew distZip
2. cd dex-tools/build/distributions
3. Unzip the file dex-tools-2.1-SNAPSHOT.zip (file size should be ~5 MB)
4. Run d2j-dex2jar.sh from the unzipped directory

### Example usage:
> sh d2j-dex2jar.sh -f ~/path/to/apk_to_decompile.apk

And the output file will be `apk_to_decompile-dex2jar.jar`.

## Need help ?
post on issue trackers list above.

## License
[Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0.html)


```

`build.gradle`:

```gradle
allprojects  {
  apply plugin: 'maven'
  apply plugin: 'idea'
  apply plugin: 'eclipse'
  group = 'com.googlecode.d2j'
  version = System.getProperty('GITHUB_REF_NAME', '2.x').replaceAll('[/ ]','-')
}

defaultTasks('clean','distZip')

subprojects {
  apply plugin: 'java'
  apply plugin: 'maven'
  sourceCompatibility = 1.8
  targetCompatibility = 1.8

  task packageSources(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
  }
  artifacts.archives packageSources
  repositories {
    mavenCentral()
    google()
  }

// == support provided scope
  configurations {
    provided
  }
  sourceSets {
      main { compileClasspath += configurations.provided }
      test {
        compileClasspath += configurations.provided
      }
  }
// == end

  [compileJava, compileTestJava]*.options.collect {options ->options.encoding = 'UTF-8'}

  dependencies {
    testCompile group: 'junit', name: 'junit', version:'4.11'
    compile fileTree(dir: 'libs', include: '*.jar')
  }

  jar {
    manifest {
      attributes("Implementation-Title": project.name,
                 "Implementation-Version": project.version,
                 "Build-Time": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                 "Revision":"${getRevision()}",
                 "Build-Number": System.env.BUILD_NUMBER?System.env.BUILD_NUMBER:"-1",
      )
    }
    from (project.parent.projectDir)  {
      include 'NOTICE.txt'
      include 'LICENSE.txt'
      into('META-INF')
    }
  }
}

def getRevision() {
  if (System.env.BUILD_REVISION) {
    return System.env.BUILD_REVISION
  }
  if (System.env.GIT_REVISION) {
    return System.env.GIT_REVISION
  }
  if (System.env.MERCURIAL_REVISION) {
    System.env.MERCURIAL_REVISION
  }

  def ver = null;
  try {
    ver = 'git rev-parse --short HEAD'.execute().text.trim()
  } catch (e) {
    // ignore
  }
  if (!ver) {
    try {
      ver = 'hg id -i -b -t'.execute().text.split(' ')[0];
    } catch (e) {
      // ignore
    }
  }
  if (!ver) {
    ver = "HEAD"
  }
  return ver
}

```

`d2j-base-cmd/build.gradle`:

```gradle
description = 'a simple cmd parser'

dependencies {
}

```

`d2j-base-cmd/src/main/java/com/googlecode/dex2jar/tools/BaseCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.spi.FileSystemProvider;
import java.util.*;

public abstract class BaseCmd {
    public static String getBaseName(String fn) {
        int x = fn.lastIndexOf('.');
        return x >= 0 ? fn.substring(0, x) : fn;
    }

    public static String getBaseName(Path fn) {
        return getBaseName(fn.getFileName().toString());
    }

    public interface FileVisitorX {
        // change the relative from Path to String
        // java.nio.file.ProviderMismatchException on jdk8
        void visitFile(Path file, String relative) throws IOException;
    }

    public static void walkFileTreeX(final Path base, final FileVisitorX fv) throws IOException {
        Files.walkFileTree(base, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                fv.visitFile(file, base.relativize(file).toString());
                return super.visitFile(file, attrs);
            }
        });
    }

    public static void walkJarOrDir(final Path in, final FileVisitorX fv) throws IOException {
        if (Files.isDirectory(in)) {
            walkFileTreeX(in, fv);
        } else {
            try (FileSystem inputFileSystem = openZip(in)) {
                walkFileTreeX(inputFileSystem.getPath("/"), fv);
            }
        }
    }

    public static void createParentDirectories(Path p) throws IOException {
        // merge patch from t3stwhat, fix crash on save to windows path like 'C:\\abc.jar'
        Path parent = p.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
    }

    public static FileSystem createZip(Path output) throws IOException {
        Map<String, Object> env = new HashMap<>();
        env.put("create", "true");
        Files.deleteIfExists(output);

        createParentDirectories(output);

        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if ("jar".equals(s) || "zip".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }
        throw new IOException("cant find zipfs support");
    }

    public static FileSystem openZip(Path in) throws IOException {
        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if ("jar".equals(s) || "zip".equalsIgnoreCase(s)) {
                return p.newFileSystem(in, new HashMap<String, Object>());
            }
        }
        throw new IOException("cant find zipfs support");
    }

    protected static class HelpException extends RuntimeException {

        private static final long serialVersionUID = 5538069795297477488L;

        public HelpException() {
            super();
        }

        public HelpException(String message) {
            super(message);
        }

    }

    @Retention(value = RetentionPolicy.RUNTIME)
    @Target(value = { ElementType.FIELD })
    public @interface Opt {
        String argName() default "";

        String description() default "";

        boolean hasArg() default true;

        String longOpt() default "";

        String opt() default "";

        boolean required() default false;
    }

    static protected class Option implements Comparable<Option> {
        public String argName = "arg";
        public String description;
        public Field field;
        public boolean hasArg = true;
        public String longOpt;
        public String opt;
        public boolean required = false;

        @Override
        public int compareTo(Option o) {
            int result = s(this.opt, o.opt);
            if (result == 0) {
                result = s(this.longOpt, o.longOpt);
                if (result == 0) {
                    result = s(this.argName, o.argName);
                    if (result == 0) {
                        result = s(this.description, o.description);
                    }
                }
            }
            return result;
        }

        private static int s(String a, String b) {
            if (a != null && b != null) {
                return a.compareTo(b);
            } else if (a != null) {
                return 1;
            } else if (b != null) {
                return -1;
            } else {
                return 0;
            }
        }

        public String getOptAndLongOpt() {
            StringBuilder sb = new StringBuilder();
            boolean havePrev = false;
            if (opt != null && opt.length() > 0) {
            sb.append("-").append(opt);
                havePrev = true;
            }
            if (longOpt != null && longOpt.length() > 0) {
                if (havePrev) {
                sb.append(",");
            }
                sb.append("--").append(longOpt);
            }
            return sb.toString();
        }

    }

    @Retention(value = RetentionPolicy.RUNTIME)
    @Target(value = { ElementType.TYPE })
    public @interface Syntax {

        String cmd();

        String desc() default "";

        String onlineHelp() default "";

        String syntax() default "";
    }

    private String cmdLineSyntax;

    private String cmdName;
    private String desc;
    private String onlineHelp;

    protected Map<String, Option> optMap = new HashMap<String, Option>();

    @Opt(opt = "h", longOpt = "help", hasArg = false, description = "Print this help message")
    private boolean printHelp = false;

    protected String[] remainingArgs;
    protected String[] originalArgs;

    public BaseCmd() {
    }

    public BaseCmd(String cmdLineSyntax, String header) {
        super();
        int i = cmdLineSyntax.indexOf(' ');
        if (i > 0) {
            this.cmdName = cmdLineSyntax.substring(0, i);
            this.cmdLineSyntax = cmdLineSyntax.substring(i + 1);
        }
        this.desc = header;
    }

    public BaseCmd(String cmdName, String cmdSyntax, String header) {
        super();
        this.cmdName = cmdName;
        this.cmdLineSyntax = cmdSyntax;
        this.desc = header;
    }

    private Set<Option> collectRequiredOptions(Map<String, Option> optMap) {
        Set<Option> options = new HashSet<>();
        for (Map.Entry<String, Option> e : optMap.entrySet()) {
            Option option = e.getValue();
            if (option.required) {
                options.add(option);
            }
        }
        return options;
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    protected Object convert(String value, Class type) {
        if (type.equals(String.class)) {
            return value;
        }
        if (type.equals(int.class) || type.equals(Integer.class)) {
            return Integer.parseInt(value);
        }
        if (type.equals(long.class) || type.equals(Long.class)) {
            return Long.parseLong(value);
        }
        if (type.equals(float.class) || type.equals(Float.class)) {
            return Float.parseFloat(value);
        }
        if (type.equals(double.class) || type.equals(Double.class)) {
            return Double.parseDouble(value);
        }
        if (type.equals(boolean.class) || type.equals(Boolean.class)) {
            return Boolean.parseBoolean(value);
        }
        if (type.equals(File.class)) {
            return new File(value);
        }
        if (type.equals(Path.class)) {
            return new File(value).toPath();
        }
        try {
            type.asSubclass(Enum.class);
            return Enum.valueOf(type, value);
        } catch (Exception ignored) {
        }

        throw new RuntimeException("can't convert [" + value + "] to type " + type);
    }

    protected abstract void doCommandLine() throws Exception;

    public void doMain(String... args) {
        try {
            initOptions();
            parseSetArgs(args);
            doCommandLine();
        } catch (HelpException e) {
            String msg = e.getMessage();
            if (msg != null && msg.length() > 0) {
                System.err.println("ERROR: " + msg);
            }
            usage();
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
    }

    protected String getVersionString() {
        return getClass().getPackage().getImplementationVersion();
    }

    protected void initOptionFromClass(Class<?> clz) {
        if (clz == null) {
            return;
        } else {
            initOptionFromClass(clz.getSuperclass());
        }

        Syntax syntax = clz.getAnnotation(Syntax.class);
        if (syntax != null) {
            this.cmdLineSyntax = syntax.syntax();
            this.cmdName = syntax.cmd();
            this.desc = syntax.desc();
            this.onlineHelp = syntax.onlineHelp();
        }

        Field[] fs = clz.getDeclaredFields();
        for (Field f : fs) {
            Opt opt = f.getAnnotation(Opt.class);
            if (opt != null) {
                f.setAccessible(true);
                Option option = new Option();
                option.field = f;
                option.description = opt.description();
                option.hasArg = opt.hasArg();
                option.required = opt.required();
                if ("".equals(opt.longOpt()) && "".equals(opt.opt())) {   // into automode
                    option.longOpt = fromCamel(f.getName());
                    if (f.getType().equals(boolean.class)) {
                        option.hasArg=false;
                        try {
                            if (f.getBoolean(this)) {
                                throw new RuntimeException("the value of " + f + " must be false, as it is declared as no args");
                            }
                        } catch (IllegalAccessException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    checkConflict(option, "--" + option.longOpt);
                    continue;
                }
                if (!opt.hasArg()) {
                    if (!f.getType().equals(boolean.class)) {
                        throw new RuntimeException("the type of " + f
                                + " must be boolean, as it is declared as no args");
                    }

                    try {
                        if (f.getBoolean(this)) {
                            throw new RuntimeException("the value of " + f + " must be false, as it is declared as no args");
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                }
                boolean haveLongOpt = false;
                if (!"".equals(opt.longOpt())) {
                    option.longOpt = opt.longOpt();
                    checkConflict(option, "--" + option.longOpt);
                    haveLongOpt = true;
                }
                if (!"".equals(opt.argName())) {
                    option.argName = opt.argName();
                }
                if (!"".equals(opt.opt())) {
                    option.opt = opt.opt();
                    checkConflict(option, "-" + option.opt);
                } else {
                    if (!haveLongOpt) {
                        throw new RuntimeException("opt or longOpt is not set in @Opt(...) " + f);
                    }
                }
            }
        }
    }

    private static String fromCamel(String name) {
        if (name.length() == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        char[] charArray = name.toCharArray();
        sb.append(Character.toLowerCase(charArray[0]));
        for (int i = 1; i < charArray.length; i++) {
            char c = charArray[i];
            if (Character.isUpperCase(c)) {
                sb.append("-").append(Character.toLowerCase(c));
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    private void checkConflict(Option option, String key) {
        if (optMap.containsKey(key)) {
            Option preOption = optMap.get(key);
            throw new RuntimeException(String.format("[@Opt(...) %s] conflict with [@Opt(...) %s]",
                    preOption.field.toString(), option.field
            ));
        }
        optMap.put(key, option);
    }

    protected void initOptions() {
        initOptionFromClass(this.getClass());
    }

    public static void main(String... args) throws Exception {
        if (args.length < 1) {
            System.err.println("d2j-run <class> [args]");
            return;
        }
        Class<?> clz = Class.forName(args[0]);
        String[] newArgs = new String[args.length - 1];
        System.arraycopy(args, 1, newArgs, 0, newArgs.length);
        if (BaseCmd.class.isAssignableFrom(clz)) {
            BaseCmd baseCmd = (BaseCmd) clz.newInstance();
            baseCmd.doMain(newArgs);
        } else {
            Method m = clz.getMethod("main",String[].class);
            m.setAccessible(true);
            m.invoke(null, (Object)newArgs);
        }
    }
    
    protected void parseSetArgs(String... args) throws IllegalArgumentException, IllegalAccessException {
        this.originalArgs = args;
        List<String> remainsOptions = new ArrayList<>();
        Set<Option> requiredOpts = collectRequiredOptions(optMap);
        Option needArgOpt = null;
        for (String s : args) {
            if (needArgOpt != null) {
                needArgOpt.field.set(this, convert(s, needArgOpt.field.getType()));
                needArgOpt = null;
            } else if (s.startsWith("-")) {// it's a short or long option
                Option opt = optMap.get(s);
                requiredOpts.remove(opt);
                if (opt == null) {
                    System.err.println("ERROR: Unrecognized option: " + s);
                    throw new HelpException();
                } else {
                    if (opt.hasArg) {
                        needArgOpt = opt;
                    } else {
                        opt.field.set(this, true);
                    }
                }
            } else {
                remainsOptions.add(s);
            }
        }

        if (needArgOpt != null) {
            System.err.println("ERROR: Option " + needArgOpt.getOptAndLongOpt() + " need an argument value");
            throw new HelpException();
        }
        this.remainingArgs = remainsOptions.toArray(new String[0]);
        if (this.printHelp) {
            throw new HelpException();
        }
        if (!requiredOpts.isEmpty()) {
            StringBuilder sb = new StringBuilder();
            sb.append("ERROR: Options: ");
            boolean first = true;
            for (Option option : requiredOpts) {
                if (first) {
                    first = false;
                } else {
                    sb.append(" and ");
                }
                sb.append(option.getOptAndLongOpt());
            }
            sb.append(" is required");
            System.err.println(sb);
            throw new HelpException();
        }

    }

    protected void usage() {
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8), true);

        final int maxLength = 80;
        final int maxPaLength = 40;
        out.println(this.cmdName + " -- " + desc);
        out.println("usage: " + this.cmdName + " " + cmdLineSyntax);
        if (this.optMap.size() > 0) {
            out.println("options:");
        }
        // [PART.A.........][Part.B
        // .-a,--aa.<arg>...desc1
        // .................desc2
        // .-b,--bb
        TreeSet<Option> options = new TreeSet<>(this.optMap.values());
        int palength = -1;
        for (Option option : options) {
            int pa = 4 + option.getOptAndLongOpt().length();
            if (option.hasArg) {
                pa += 3 + option.argName.length();
            }
            if (pa < maxPaLength) {
                if (pa > palength) {
                    palength = pa;
                }
            }
        }
        int pblength = maxLength - palength;

        StringBuilder sb = new StringBuilder();
        for (Option option : options) {
            sb.setLength(0);
            sb.append(" ").append(option.getOptAndLongOpt());
            if (option.hasArg) {
                sb.append(" <").append(option.argName).append(">");
            }
            String desc = option.description;
            if (desc == null || desc.length() == 0) {// no description
                out.println(sb);
            } else {
                for (int i = palength - sb.length(); i > 0; i--) {
                    sb.append(' ');
                }
                if (sb.length() > maxPaLength) {// to huge part A
                    out.println(sb);
                    sb.setLength(0);
                    for (int i = 0; i < palength; i++) {
                        sb.append(' ');
                    }
                }
                int nextStart = 0;
                while (nextStart < desc.length()) {
                    if (desc.length() - nextStart < pblength) {// can put in one line
                        sb.append(desc.substring(nextStart));
                        out.println(sb);
                        nextStart = desc.length();
                        sb.setLength(0);
                    } else {
                        sb.append(desc, nextStart, nextStart + pblength);
                        out.println(sb);
                        nextStart += pblength;
                        sb.setLength(0);
                        if (nextStart < desc.length()) {
                            for (int i = 0; i < palength; i++) {
                                sb.append(' ');
                            }
                        }
                    }
                }
                if (sb.length() > 0) {
                    out.println(sb);
                    sb.setLength(0);
                }
            }
        }
        String ver = getVersionString();
        if (ver != null && !"".equals(ver)) {
            out.println("version: " + ver);
        }
        if (onlineHelp != null && !"".equals(onlineHelp)) {
            if (onlineHelp.length() + "online help: ".length() > maxLength) {
                out.println("online help: ");
                out.println(onlineHelp);
            } else {
                out.println("online help: " + onlineHelp);
            }
        }
        out.flush();
    }
}

```

`d2j-jasmin/build.gradle`:

```gradle
apply plugin: 'antlr'

dependencies {
  compile(group: 'org.antlr', name: 'antlr-runtime', version:'3.5.2') {
        exclude(module: 'stringtemplate')
  }
  implementation group: 'org.ow2.asm', name: 'asm-tree', version: '9.5'
  implementation group: 'org.ow2.asm', name: 'asm-util', version: '9.5'
  compile project(':d2j-base-cmd')
  antlr "org.antlr:antlr:3.5.2"
}

sourceSets.main.antlr.srcDirs = ['src/main/antlr3']

```

`d2j-jasmin/src/main/antlr3/com/googlecode/d2j/jasmin/Jasmin.g`:

```g
grammar Jasmin;

@header {
package com.googlecode.d2j.jasmin;
import java.util.List;
import java.util.ArrayList;
import java.math.BigInteger;
import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;
import static org.objectweb.asm.Opcodes.*;
}
@lexer::header {
package com.googlecode.d2j.jasmin;
}
@members{
    private static int versions[] = { 0, V1_1, V1_2, V1_3, V1_4, V1_5, V1_6, V1_7, 52 // V1_8 ?
            , 53 // V1_9 ?
    };
    private ClassNode cn;
    private FieldNode fn;
    private MethodNode mn;
    private String tmp;
    private int tmpInt;
    private String tmp2;
    public boolean rebuildLine=false;
    private java.util.Map<String, Label> labelMap = new java.util.HashMap<>();
    private void reset0() {
        cn = new ClassNode(Opcodes.ASM9);
        fn = null;
        mn = null;
    }

    static private int parseInt(String str, int start, int end) {
        int sof = start;
        int x = 1;
        if (str.charAt(sof) == '+') {
            sof++;
        } else if (str.charAt(sof) == '-') {
            sof++;
            x = -1;
        }
        long v;
        if (str.charAt(sof) == '0') {
            sof++;
            if (sof >= end) {
                return 0;
            }
            char c = str.charAt(sof);
            if (c == 'x' || c == 'X') {// hex
                sof++;
                v = Long.parseLong(str.substring(sof, end), 16);
            } else {// oct
                v = Long.parseLong(str.substring(sof, end), 8);
            }
        } else {
            v = Long.parseLong(str.substring(sof, end), 10);
        }
        return (int) (v * x);
    }

    static private int parseInt(String str) {
        return parseInt(str, 0, str.length());
    }

    static private Long parseLong(String str) {
        int sof = 0;
        int end = str.length() - 1;
        int x = 1;
        if (str.charAt(sof) == '+') {
            sof++;
        } else if (str.charAt(sof) == '-') {
            sof++;
            x = -1;
        }
        BigInteger v;
        if (str.charAt(sof) == '0') {
            sof++;
            if (sof >= end) {
                return 0L;
            }
            char c = str.charAt(sof);
            if (c == 'x' || c == 'X') {// hex
                sof++;
                v = new BigInteger(str.substring(sof, end), 16);
            } else {// oct
                v = new BigInteger(str.substring(sof, end), 8);
            }
        } else {
            v = new BigInteger(str.substring(sof, end), 10);
        }
        if (x == -1) {
            return v.negate().longValue();
        } else {
            return v.longValue();
        }
    }

    static private float parseFloat(String str) {
        str = str.toLowerCase();
        int s = 0;
        float x = 1f;
        if (str.charAt(s) == '+') {
            s++;
        } else if (str.charAt(s) == '-') {
            s++;
            x = -1;
        }
        int e = str.length() - 1;
        if (str.charAt(e) == 'f') {
            e--;
        }
        str = str.substring(s, e + 1);
        if (str.equals("floatnan")) {
            return Float.NaN;
        }
        if (str.equals("floatinfinity")) {
            return x < 0 ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;
        }
        return (float) x * Float.parseFloat(str);
    }

    static private double parseDouble(String str) {
        str = str.toLowerCase();
        int s = 0;
        double x = 1;
        if (str.charAt(s) == '+') {
            s++;
        } else if (str.charAt(s) == '-') {
            s++;
            x = -1;
        }
        int e = str.length() - 1;
        if (str.charAt(e) == 'd') {
            e--;
        }
        str = str.substring(s, e + 1);
        if (str.equals("doublenan")) {
            return Double.NaN;
        }
        if (str.equals("doubleinfinity")) {
            return x < 0 ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
        }
        return x * Double.parseDouble(str);
    }

    private void line(int ln){
         if(rebuildLine) {
            Label label=new Label();
            mn.visitLabel(label);
            mn.visitLineNumber(ln, label);
         }
    }
    private static String unEscapeString(String str) {
        return unEscape0(str, 1, str.length() - 1);
    }
    private static String unEscape(String str) {
            return unEscape0(str, 0, str.length());
    }

    private static String unEscape0(String str, int start, int end) {

        StringBuilder sb = new StringBuilder();
        for (int i = start; i < end;) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                // ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
                case 'b':
                    sb.append('\b');
                    i += 2;
                    break;
                case 't':
                    sb.append('\t');
                    i += 2;
                    break;
                case 'n':
                    sb.append('\n');
                    i += 2;
                    break;
                case 'f':
                    sb.append('\f');
                    i += 2;
                    break;
                case 'r':
                    sb.append('\r');
                    i += 2;
                    break;
                case '\"':
                    sb.append('\"');
                    i += 2;
                    break;
                case '\'':
                    sb.append('\'');
                    i += 2;
                    break;
                case '\\':
                    sb.append('\\');
                    i += 2;
                    break;
                case 'u':
                    String sub = str.substring(i + 2, i + 6);
                    sb.append((char) Integer.parseInt(sub, 16));
                    i += 6;
                    break;
                default:
                    int x = 0;
                    while (x < 3) {
                        char e = str.charAt(i + 1 + x);
                        if (e >= '0' && e <= '7') {
                            x++;
                        } else {
                            break;
                        }
                    }
                    if (x == 0) {
                        throw new RuntimeException("can't pase string");
                    }
                    sb.append((char) Integer.parseInt(str.substring(i + 1, i + 1 + x), 8));
                    i += 1 + x;
                }

            } else {
                sb.append(c);
                i++;
            }
        }
        return sb.toString();
    }

    private static int getAcc(String name) {
        if (name.equals("public")) {
            return ACC_PUBLIC;
        } else if (name.equals("private")) {
            return ACC_PRIVATE;
        } else if (name.equals("protected")) {
            return ACC_PROTECTED;
        } else if (name.equals("static")) {
            return ACC_STATIC;
        } else if (name.equals("final")) {
            return ACC_FINAL;
        } else if (name.equals("synchronized")) {
            return ACC_SYNCHRONIZED;
        } else if (name.equals("volatile")) {
            return ACC_VOLATILE;
        } else if (name.equals("bridge")) {
            return ACC_BRIDGE;
        } else if (name.equals("varargs")) {
            return ACC_VARARGS;
        } else if (name.equals("transient")) {
            return ACC_TRANSIENT;
        } else if (name.equals("native")) {
            return ACC_NATIVE;
        } else if (name.equals("interface")) {
            return ACC_INTERFACE;
        } else if (name.equals("abstract")) {
            return ACC_ABSTRACT;
        } else if (name.equals("strict")) {
            return ACC_STRICT;
        } else if (name.equals("strictfp")) {
            return ACC_STRICT;
        } else if (name.equals("synthetic")) {
            return ACC_SYNTHETIC;
        } else if (name.equals("annotation")) {
            return ACC_ANNOTATION;
        } else if (name.equals("enum")) {
            return ACC_ENUM;
        } else if (name.equals("super")) {
            return ACC_SUPER;
        }
        throw new RuntimeException("not support access flags " + name);
    }
    private static int getOp(String str) {
            switch (str) {
            case "nop":
                return Opcodes.NOP;
            case "aconst_null":
                return Opcodes.ACONST_NULL;
            case "iconst_m1":
                return Opcodes.ICONST_M1;
            case "iconst_0":
                return Opcodes.ICONST_0;
            case "iconst_1":
                return Opcodes.ICONST_1;
            case "iconst_2":
                return Opcodes.ICONST_2;
            case "iconst_3":
                return Opcodes.ICONST_3;
            case "iconst_4":
                return Opcodes.ICONST_4;
            case "iconst_5":
                return Opcodes.ICONST_5;
            case "lconst_0":
                return Opcodes.LCONST_0;
            case "lconst_1":
                return Opcodes.LCONST_1;
            case "fconst_0":
                return Opcodes.FCONST_0;
            case "fconst_1":
                return Opcodes.FCONST_1;
            case "fconst_2":
                return Opcodes.FCONST_2;
            case "dconst_0":
                return Opcodes.DCONST_0;
            case "dconst_1":
                return Opcodes.DCONST_1;
            case "bipush":
                return Opcodes.BIPUSH;
            case "sipush":
                return Opcodes.SIPUSH;
            case "ldc_w":
            case "ldc2_w":
            case "ldc":
                return Opcodes.LDC;
            case "iload":
                return Opcodes.ILOAD;
            case "lload":
                return Opcodes.LLOAD;
            case "fload":
                return Opcodes.FLOAD;
            case "dload":
                return Opcodes.DLOAD;
            case "aload":
                return Opcodes.ALOAD;
            case "iaload":
                return Opcodes.IALOAD;
            case "laload":
                return Opcodes.LALOAD;
            case "faload":
                return Opcodes.FALOAD;
            case "daload":
                return Opcodes.DALOAD;
            case "aaload":
                return Opcodes.AALOAD;
            case "baload":
                return Opcodes.BALOAD;
            case "caload":
                return Opcodes.CALOAD;
            case "saload":
                return Opcodes.SALOAD;
            case "istore":
                return Opcodes.ISTORE;
            case "lstore":
                return Opcodes.LSTORE;
            case "fstore":
                return Opcodes.FSTORE;
            case "dstore":
                return Opcodes.DSTORE;
            case "astore":
                return Opcodes.ASTORE;
            case "iastore":
                return Opcodes.IASTORE;
            case "lastore":
                return Opcodes.LASTORE;
            case "fastore":
                return Opcodes.FASTORE;
            case "dastore":
                return Opcodes.DASTORE;
            case "aastore":
                return Opcodes.AASTORE;
            case "bastore":
                return Opcodes.BASTORE;
            case "castore":
                return Opcodes.CASTORE;
            case "sastore":
                return Opcodes.SASTORE;
            case "pop":
                return Opcodes.POP;
            case "pop2":
                return Opcodes.POP2;
            case "dup":
                return Opcodes.DUP;
            case "dup_x1":
                return Opcodes.DUP_X1;
            case "dup_x2":
                return Opcodes.DUP_X2;
            case "dup2":
                return Opcodes.DUP2;
            case "dup2_x1":
                return Opcodes.DUP2_X1;
            case "dup2_x2":
                return Opcodes.DUP2_X2;
            case "swap":
                return Opcodes.SWAP;
            case "iadd":
                return Opcodes.IADD;
            case "ladd":
                return Opcodes.LADD;
            case "fadd":
                return Opcodes.FADD;
            case "dadd":
                return Opcodes.DADD;
            case "isub":
                return Opcodes.ISUB;
            case "lsub":
                return Opcodes.LSUB;
            case "fsub":
                return Opcodes.FSUB;
            case "dsub":
                return Opcodes.DSUB;
            case "imul":
                return Opcodes.IMUL;
            case "lmul":
                return Opcodes.LMUL;
            case "fmul":
                return Opcodes.FMUL;
            case "dmul":
                return Opcodes.DMUL;
            case "idiv":
                return Opcodes.IDIV;
            case "ldiv":
                return Opcodes.LDIV;
            case "fdiv":
                return Opcodes.FDIV;
            case "ddiv":
                return Opcodes.DDIV;
            case "irem":
                return Opcodes.IREM;
            case "lrem":
                return Opcodes.LREM;
            case "frem":
                return Opcodes.FREM;
            case "drem":
                return Opcodes.DREM;
            case "ineg":
                return Opcodes.INEG;
            case "lneg":
                return Opcodes.LNEG;
            case "fneg":
                return Opcodes.FNEG;
            case "dneg":
                return Opcodes.DNEG;
            case "ishl":
                return Opcodes.ISHL;
            case "lshl":
                return Opcodes.LSHL;
            case "ishr":
                return Opcodes.ISHR;
            case "lshr":
                return Opcodes.LSHR;
            case "iushr":
                return Opcodes.IUSHR;
            case "lushr":
                return Opcodes.LUSHR;
            case "iand":
                return Opcodes.IAND;
            case "land":
                return Opcodes.LAND;
            case "ior":
                return Opcodes.IOR;
            case "lor":
                return Opcodes.LOR;
            case "ixor":
                return Opcodes.IXOR;
            case "lxor":
                return Opcodes.LXOR;
            case "iinc":
                return Opcodes.IINC;
            case "i2l":
                return Opcodes.I2L;
            case "i2f":
                return Opcodes.I2F;
            case "i2d":
                return Opcodes.I2D;
            case "l2i":
                return Opcodes.L2I;
            case "l2f":
                return Opcodes.L2F;
            case "l2d":
                return Opcodes.L2D;
            case "f2i":
                return Opcodes.F2I;
            case "f2l":
                return Opcodes.F2L;
            case "f2d":
                return Opcodes.F2D;
            case "d2i":
                return Opcodes.D2I;
            case "d2l":
                return Opcodes.D2L;
            case "d2f":
                return Opcodes.D2F;
            case "i2b":
                return Opcodes.I2B;
            case "i2c":
                return Opcodes.I2C;
            case "i2s":
                return Opcodes.I2S;
            case "lcmp":
                return Opcodes.LCMP;
            case "fcmpl":
                return Opcodes.FCMPL;
            case "fcmpg":
                return Opcodes.FCMPG;
            case "dcmpl":
                return Opcodes.DCMPL;
            case "dcmpg":
                return Opcodes.DCMPG;
            case "ifeq":
                return Opcodes.IFEQ;
            case "ifne":
                return Opcodes.IFNE;
            case "iflt":
                return Opcodes.IFLT;
            case "ifge":
                return Opcodes.IFGE;
            case "ifgt":
                return Opcodes.IFGT;
            case "ifle":
                return Opcodes.IFLE;
            case "if_icmpeq":
                return Opcodes.IF_ICMPEQ;
            case "if_icmpne":
                return Opcodes.IF_ICMPNE;
            case "if_icmplt":
                return Opcodes.IF_ICMPLT;
            case "if_icmpge":
                return Opcodes.IF_ICMPGE;
            case "if_icmpgt":
                return Opcodes.IF_ICMPGT;
            case "if_icmple":
                return Opcodes.IF_ICMPLE;
            case "if_acmpeq":
                return Opcodes.IF_ACMPEQ;
            case "if_acmpne":
                return Opcodes.IF_ACMPNE;
            case "goto":
                return Opcodes.GOTO;
            case "jsr":
                return Opcodes.JSR;
            case "ret":
                return Opcodes.RET;
            case "tableswitch":
                return Opcodes.TABLESWITCH;
            case "lookupswitch":
                return Opcodes.LOOKUPSWITCH;
            case "ireturn":
                return Opcodes.IRETURN;
            case "lreturn":
                return Opcodes.LRETURN;
            case "freturn":
                return Opcodes.FRETURN;
            case "dreturn":
                return Opcodes.DRETURN;
            case "areturn":
                return Opcodes.ARETURN;
            case "return":
                return Opcodes.RETURN;
            case "getstatic":
                return Opcodes.GETSTATIC;
            case "putstatic":
                return Opcodes.PUTSTATIC;
            case "getfield":
                return Opcodes.GETFIELD;
            case "putfield":
                return Opcodes.PUTFIELD;
            case "invokevirtual":
                return Opcodes.INVOKEVIRTUAL;
            case "invokespecial":
                return Opcodes.INVOKESPECIAL;
            case "invokestatic":
                return Opcodes.INVOKESTATIC;
            case "invokeinterface":
                return Opcodes.INVOKEINTERFACE;
            case "invokedynamic":
                return Opcodes.INVOKEDYNAMIC;
            case "new":
                return Opcodes.NEW;
            case "newarray":
                return Opcodes.NEWARRAY;
            case "anewarray":
                return Opcodes.ANEWARRAY;
            case "arraylength":
                return Opcodes.ARRAYLENGTH;
            case "athrow":
                return Opcodes.ATHROW;
            case "checkcast":
                return Opcodes.CHECKCAST;
            case "instanceof":
                return Opcodes.INSTANCEOF;
            case "monitorenter":
                return Opcodes.MONITORENTER;
            case "monitorexit":
                return Opcodes.MONITOREXIT;
            case "multianewarray":
                return Opcodes.MULTIANEWARRAY;
            case "ifnull":
                return Opcodes.IFNULL;
            case "ifnonnull":
                return Opcodes.IFNONNULL;
            case "iload_0":
                return 26;
            case "iload_1":
                return 27;
            case "iload_2":
                return 28;
            case "iload_3":
                return 29;
            case "lload_0":
                return 30;
            case "lload_1":
                return 31;
            case "lload_2":
                return 32;
            case "lload_3":
                return 33;
            case "fload_0":
                return 34;
            case "fload_1":
                return 35;
            case "fload_2":
                return 36;
            case "fload_3":
                return 37;
            case "dload_0":
                return 38;
            case "dload_1":
                return 39;
            case "dload_2":
                return 40;
            case "dload_3":
                return 41;
            case "aload_0":
                return 42;
            case "aload_1":
                return 43;
            case "aload_2":
                return 44;
            case "aload_3":
                return 45;
            case "istore_0":
                return 59;
            case "istore_1":
                return 60;
            case "istore_2":
                return 61;
            case "istore_3":
                return 62;
            case "lstore_0":
                return 63;
            case "lstore_1":
                return 64;
            case "lstore_2":
                return 65;
            case "lstore_3":
                return 66;
            case "fstore_0":
                return 67;
            case "fstore_1":
                return 68;
            case "fstore_2":
                return 69;
            case "fstore_3":
                return 70;
            case "dstore_0":
                return 71;
            case "dstore_1":
                return 72;
            case "dstore_2":
                return 73;
            case "dstore_3":
                return 74;
            case "astore_0":
                return 75;
            case "astore_1":
                return 76;
            case "astore_2":
                return 77;
            case "astore_3":
                return 78;
            }
            return 0;
        }

    private String[] parseOwnerAndName(String str) {
        int x=str.lastIndexOf('/');
        if(x>0){
        return new String[]{ unEscape0(str,0,x), unEscape0(str,x+1,str.length()) };
        }
        throw new RuntimeException("can't get owner and type from '"+str+"'");
    }

    public Object parseValue(String desc, Object v) {
        switch(desc) {
        case "Z": return ((Number)v).intValue()!=0;
        case "B": return ((Number)v).byteValue();
        case "S": return ((Number)v).shortValue();
        case "I": return ((Number)v).intValue();
        case "F": return ((Number)v).floatValue();
        case "D": return ((Number)v).doubleValue();
        case "J": return ((Number)v).longValue();
        case "C": return (char)((Number)v).intValue();
        }
        return v;
    }

    static class AV {
        public AnnotationNode visitAnnotation(final String desc, final boolean visible) {
            return null;
        };

        public AnnotationNode visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {
            return null;
        }
    }

    AV cnv = new AV() {
        public AnnotationNode visitAnnotation(final String desc, final boolean visible) {
            return (AnnotationNode) cn.visitAnnotation(desc, visible);
        }
    };
    AV fnv = new AV() {
        public AnnotationNode visitAnnotation(final String desc, final boolean visible) {
            return (AnnotationNode) fn.visitAnnotation(desc, visible);
        }
    };
    AV mnv = new AV() {
        public AnnotationNode visitAnnotation(final String desc, final boolean visible) {
            return (AnnotationNode) mn.visitAnnotation(desc, visible);
        }

        public AnnotationNode visitParameterAnnotation(final int parameter, final String desc, final boolean visible) {
            return (AnnotationNode) mn.visitParameterAnnotation(parameter, desc, visible);
        }
    };
    private void visitOP0(int op){
    if(op>=26&&op<=45){    // xload_y
            int x=op-26;
            mn.visitVarInsn(ILOAD+x/4,x\%4);
            }else if(op>=59&&op<=78){    // xstore_y
                     int x=op-26;
                     mn.visitVarInsn(ISTORE+x/4,x\%4);
            }else{
        mn.visitInsn(op);
        }
    }
    private void visitIOP(int op, int a){
         // xstore
         // xload
         if(op>=21&&op<=58){
         mn.visitVarInsn(op,a);
         }  else {
         // xipush
         mn.visitIntInsn(op,a);
         }
    }
    private void visitJOP(int op, Label label){
        mn.visitJumpInsn(op,label);
    }
    private void visitIIOP(int op, int a, int b){
        mn.visitIincInsn(a,b);
    }
    private Label getLabel(String name){
    Label label=labelMap.get(name);
    if(label==null){
    label= new Label();
    labelMap.put(name,label);
    }
        return  label;
    }
    public void accept(ClassVisitor cv) throws RecognitionException{
        sFile();
        cn.accept(cv);
    }
    public ClassNode parse() throws RecognitionException {
        sFile();
        ClassNode cn=this.cn;
        reset0();
        return cn;
    }
    AV currentAv;
    AnnotationNode currentAnnotationVisitor;
}



fragment
INT_NENT: ('+'|'-')? (
               '0' 
            | ('1'..'9') ('0'..'9')* 
            | '0' ('0'..'7')+ 
            | ('0x'|'0X') HEX_DIGIT+
         );
fragment
FLOAT_NENT
    : ('+'|'-')?( ('0'..'9')+ '.' ('0'..'9')* EXPONENT?
    |   '.' ('0'..'9')+ EXPONENT?
    |   ('0'..'9')+ EXPONENT)
    ;
fragment
F_FLOAT	:	('f'|'F') ('l'|'L')('o'|'O')('a'|'A')('t'|'T');
fragment
F_DOUBLE	:('d'|'D')('o'|'O')('u'|'U')('b'|'B')('l'|'L')('e'|'E');
fragment
F_NAN : ('N'|'n') ('A'|'a') ('N'|'n');
fragment
F_INFINITY: ('I'|'i') ('N'|'n') ('F'|'f') ('I'|'i') ('N'|'n') ('I'|'i') ('T'|'t') ('Y'|'y') ;

FLOAT	:	((('0'..'9')+|FLOAT_NENT) ('f'|'F')) 
		| ('+'|'-')F_FLOAT F_INFINITY
		| '+' F_FLOAT F_NAN
		;
DOUBLE	:	FLOAT_NENT ('d'|'D')? 
		| ('0'..'9')+ ('d'|'D') 
		| ('+'|'-') F_DOUBLE F_INFINITY
		| '+' F_DOUBLE F_NAN
		;
LONG	:	INT_NENT ('L'|'l');
INT	:	INT_NENT;

COMMENT
    :   ';' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;}
    ;

WS  :   ( ' '
        | '\t'
        | '\r'
        | '\n'
        ) {$channel=HIDDEN;}
    ;

STRING
    :  '"' ( ESC_SEQ | ~('\\'|'"') )* '"'
    ;
DSTRING
    :  '\'' ( ESC_SEQ | ~('\\'|'\'') )* '\''
    ;
	
fragment
EXPONENT : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

fragment
HEX_DIGIT : ('0'..'9'|'a'..'f'|'A'..'F') ;

fragment
ESC_SEQ
    :   '\\' ('b'|'t'|'n'|'f'|'r'|'\''|'\"'|'\\')
    |   '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    |   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7')
    ;

VOID_TYPE:'V';
fragment
FRAGMENT_PRIMITIVE_TYPE:'B'|'Z'|'S'|'C'|'I'|'F'|'J'|'D';
fragment
FRAGMENT_OBJECT_TYPE: 'L' (ESC_SEQ |~(';'|':'|'\\'|' '|'\n'|'\t'|'\r'|'('|')'))+ ';' ;

METHOD_DESC_WITHOUT_RET: '(' ('['*(FRAGMENT_PRIMITIVE_TYPE|FRAGMENT_OBJECT_TYPE))* ')';
OBJECT_TYPE: 'L' (ESC_SEQ |~(';'|':'|'\\'|' '|'\n'|'\t'|'\r'|'('|')'))+ ';' ;
ACC:	'public' | 'private' | 'protected' | 'static' | 'final' | 'synchronized' | 'bridge' | 'varargs' | 'native' |
    'abstract' | 'strictfp' | 'synthetic' | 'constructor' | 'interface' | 'enum' |
    'annotation' | 'volatile' | 'transient' | 'declared-synchronized' | 'super' | 'strict';
ANNOTATION_VISIBLITY: 'visible' | 'invisible' ;
METHOD_ANNOTATION_VISIBLITY: 'visibleparam' | 'invisibleparam';
INNER	:	'inner';
OUTTER	:	'outer';
OP0	:	'nop'|'monitorenter'|'monitorexit'|'pop2'|'pop'
	|	'iconst_m1'
	|('a'|'i')'const_' ('0'..'5')
	|('d'|'l')'const_' ('0'..'1')
	|'fconst_' ('0'..'2')
	|'aconst_null'
	|('a'|'d'|'f'|'i'|'l')? 'return'
	|('a'|'d'|'f'|'i'|'l') ('store'|'load') '_' ('0'..'3')
	|('a'|'b'|'c'|'d'|'f'|'i'|'l') ('astore'|'aload')
	|'dcmpg'|'dcmpl' | 'lcmp' |'fcmpg'|'fcmpl'
	|'athrow'
	|('i'|'f'|'d'|'l')('add'|'div'|'sub'|'mul'|'rem'|'shl'|'shr'|'ushr'|'and'|'or'|'xor'|'neg')
	|'arraylength'
	|'dup'|'dup2'|'dup_x2'|'dup2_x2'|'dup2_x1'
	|'swap'
	|'i2b' | 'i2c' |'i2d' | 'i2f' | 'i2s' | 'i2l'
	| 'f2d' | 'f2i' | 'f2l'
	| 'd2f' | 'd2i' | 'd2l'
	| 'l2d' | 'l2f' | 'l2i'
	;
IOP	:	('a'|'d'|'f'|'i'|'l') 'load'
	|	('a'|'d'|'f'|'i'|'l') 'store'
	|'bipush'|'sipush'
	;
IIOP	:	'iinc'
	;
JOP	:	'goto'
	|	'jsr'
	|	'if' ('null'|'nonnull'|'eq'|'ne'|'gt'|'ge'|'lt'|'le')
	|       'if_' ('a'|'i') 'cmp' ('eq'|'ne'|'gt'|'ge'|'lt'|'le')
	;
LDC	:	'ldc'|'ldc_w'|'ldc2_w'
	;
XFIELD	:	'getstatic'|'putstatic'|'getfield'|'putfield';
XNEWARRAY: 'newarray' ;
XTYPE	:	'checkcast'|'instanceof'|'new'|'anewarray'
	;
MULTIANEWARRAY
	:	'multianewarray'
	;
LOOKUPSWITCH:	'lookupswitch';
TABLESWITCH:	'tableswitch';
XINVOKE	:	'invokestatic'
	|	'invokevirtual'
	|       'invokespecial'
	;
INVOKEINTERFACE  :
	       'invokeinterface'
	;
INVOKEDYNAMIC
	:	'invokedynamic';
HIGH	:	'high';
DEFAULT	:	'default';
FROM	:	'from';
TO	:	'to';
USING	:	'using';
STACK	:	'stack';
LOCALS	:	'locals';
WBOOLEAN: 'boolean';
WBYTE: 'byte';
WSHORT: 'short';
WCHAR: 'char';
WINTEGER: 'int';
WFLOAT: 'float';
WLONG: 'long';
WDOUBLE: 'double';

fragment
F_ID_FOLLOWS: ESC_SEQ| ~('\\'|'\r'|'\n'|'\t'|' '|':'|'-'|'='|','|'{'|'}'|'('|')');
ID  :    FRAGMENT_PRIMITIVE_TYPE F_ID_FOLLOWS+
    |    ESC_SEQ F_ID_FOLLOWS*
    |    ~(FRAGMENT_PRIMITIVE_TYPE| '0'..'9'| '\\' | '\r' | '\n' | '\t' | '\'' | '\"' | ' ' | ':' | '-' | '=' | '.' | ',' | '&' | '@' | '/' | '{'|'['|']'|'}'|'('|')') F_ID_FOLLOWS*
    ;
PARRAY_TYPE
	:	'['+ FRAGMENT_OBJECT_TYPE
	|	'[' '['+ FRAGMENT_PRIMITIVE_TYPE
	;
AT	:	'@';
AND	:	'&';
UP_Z	:	'Z';
UP_B	:	'B';
UP_S	:	'S';
UP_C	:	'C';
UP_I	:	'I';
UP_F	:	'F';
UP_D	:	'D';
UP_J	:	'J';
ARRAY_Z	:	'[Z';
ARRAY_B	:	'[B';
ARRAY_S	:	'[S';
ARRAY_C	:	'[C';
ARRAY_I	:	'[I';
ARRAY_F	:	'[F';
ARRAY_D	:	'[D';
ARRAY_J	:	'[J';
ARRAY_LOW_E	:	'[e';
ARRAY_LOW_S	:	'[s';
ARRAY_LOW_C	:	'[c';
ARRAY_AT	:	'[@';
ARRAY_AND	:	'[&';
LEFT_PAREN: '(';
RIGHT_PAREN: ')';

sFile	: { reset0(); currentAv=cnv; }
sHead+ (sAnnotation|sVisibiltyAnnotation)* (sField|sMethod)*
	;
sHead   :  '.bytecode' ( a=INT { int v=parseInt($a.text); cn.version=versions[v>=45?v-45:v];}
                        |a=DOUBLE {double v=parseDouble($a.text); cn.version=versions[(int)(v<2.0?(v*10)\%10:(v-44))]; }
                       )
        |  '.source' aa4=sAnyIdOrString  { cn.sourceFile=$aa4.str; }
		|  '.class' i=sAccList {cn.access|=$i.acc; if ((cn.access & Opcodes.ACC_INTERFACE) == 0) {cn.access |= Opcodes.ACC_SUPER;} else { cn.access &= ~Opcodes.ACC_SUPER; } } a1=sInternalNameOrDesc { cn.name=Type.getType($a1.desc).getInternalName(); }
		|  '.interface' i=sAccList {cn.access|=ACC_INTERFACE|$i.acc;} a1=sInternalNameOrDesc { cn.name=Type.getType($a1.desc).getInternalName(); }
		|  '.super' a1=sInternalNameOrDescACC  {  cn.superName=Type.getType($a1.desc).getInternalName(); }
		|  '.implements' a1=sInternalNameOrDescACC { if(cn.interfaces==null){cn.interfaces=new ArrayList<>();}  cn.interfaces.add(Type.getType($a1.desc).getInternalName()); }
		|  '.enclosing method' ownerAndName=sOwnerAndName {tmp=null;} (b=sMethodDesc{tmp=$b.text;})? {cn.visitOuterClass($ownerAndName.ownerInternalName,$ownerAndName.memberName,tmp);}
		|  sDeprecateAttr  { cn.access|=ACC_DEPRECATED; }
		|  '.debug' a=STRING  { cn.sourceDebug=unEscapeString($a.text); }
		|  '.attribute' sId STRING     { System.err.println("ignore .attribute"); }
		|  '.inner class' (i=sAccList sId{tmpInt=$i.acc;})? {tmp=null;tmp2=null;} ('inner' a3=sId{tmp=$a3.text;})? ('outer' a4=sId{tmp2=$a4.text;})?   { cn.visitInnerClass(null,tmp2,tmp,tmpInt); }
		|  '.no_super' {cn.superName=null;}
		|  '.class_attribute' sId STRING    { System.err.println("ignore .class_attribute"); }
		|  '.enclosing_method_attr' a=STRING b1=STRING c=STRING   {cn.visitOuterClass($a.text,$b1.text,$c.text);}
		|  '.inner_class_attr' ('.inner_class_spec_attr' a=STRING b2=STRING i=sAccList '.end' '.inner_class_spec_attr' { cn.visitInnerClass(null,unEscape($a.text),unEscape($b2.text),i); } )* '.end' '.inner_class_attr'
		|  s=sSigAttr  { cn.signature=$s.sig; }
		|  sSynthetic   {cn.access|=ACC_SYNTHETIC;}
		;
sSigAttr returns[String sig]:	('.signature_attr' | '.signature') a=STRING{ $sig=unEscapeString($a.text); };
sDeprecateAttr:	'.deprecated';
sSynthetic
	:	'.synthetic'
	;
sArrayType
	:	PARRAY_TYPE|ARRAY_Z|ARRAY_B|ARRAY_S|ARRAY_C|ARRAY_I|ARRAY_F|ARRAY_D|ARRAY_J
	;
sClassDesc
	:	sArrayType|OBJECT_TYPE|UP_Z|UP_B|UP_S|UP_C|UP_I|UP_J|UP_D|UP_F
	;
sId	:	ID|AT|AND|UP_Z|UP_B|UP_S|UP_C|UP_I|UP_F|UP_D|UP_J|ANNOTATION_VISIBLITY|METHOD_ANNOTATION_VISIBLITY|INNER|OUTTER
	|	IIOP|IOP|JOP|OP0|LDC|XFIELD|XTYPE|XINVOKE|INVOKEINTERFACE|MULTIANEWARRAY|LOOKUPSWITCH|TABLESWITCH|DEFAULT|FROM|TO|USING|STACK|LOCALS|HIGH|INVOKEDYNAMIC|VOID_TYPE
	| WBOOLEAN| WBYTE | WSHORT|WCHAR|WINTEGER|WLONG|WFLOAT|WDOUBLE |XNEWARRAY
	;
sWord : sId ;
sAnnotation
	: '.annotation' (b=ANNOTATION_VISIBLITY aInternalOrDesc=sInternalNameOrDescACC { currentAnnotationVisitor= currentAv.visitAnnotation($aInternalOrDesc.desc,!$b.text.contains("invisible")); } |
	                  b=METHOD_ANNOTATION_VISIBLITY c=INT a=sId {currentAnnotationVisitor=currentAv.visitParameterAnnotation(parseInt($c.text),$a.text,!$b.text.contains("invisible"));}
	                )
	    (sAnnotationElement* '.end annotation')?
	;
sVisibiltyAnnotation
	: {boolean visible=false;} ('.runtime_visible_annotation' {visible=true;}|'.runtime_invisible_annotation'{visible=false;}) a=STRING      { currentAnnotationVisitor= currentAv.visitAnnotation(unEscape($a.text),visible); }
	sAnnotationSoot*
	 '.end' '.annotation_attr'
	;
sAnnotationSoot
	: '.annotation' 
	(t=sAnnotationElementSoot {currentAnnotationVisitor.visit($t.nn,$t.v);} )*
	'.end' '.annotation'
	;
sAnnotationElementSoot returns[String nn,Object v]
	:'.elem' ('.bool_kind' a=STRING b=INT          {$nn=unEscapeString($a.text); $v=0!=parseInt($b.text);}
              	    | '.short_kind' a=STRING b=INT        {$nn=unEscapeString($a.text); $v=(short)parseInt($b.text);}
              	    | '.byte_kind' a=STRING b=INT         {$nn=unEscapeString($a.text); $v=(byte)parseInt($b.text);}
              	    | '.char_kind' a=STRING b=INT         {$nn=unEscapeString($a.text); $v=(char)parseInt($b.text);}
              	    | '.int_kind' a=STRING b=INT          {$nn=unEscapeString($a.text); $v=parseInt($b.text);}
              	    | '.long_kind' a=STRING b=(INT|LONG)  {$nn=unEscapeString($a.text); $v=parseLong($b.text);}
              	    | '.float_kind' a=STRING b=INT        {$nn=unEscapeString($a.text); $v=parseFloat($b.text);}
              	    | '.doub_kind' a=STRING b=(INT|LONG)  {$nn=unEscapeString($a.text); $v=parseDouble($b.text);}
              	    | '.str_kind' a=STRING b=STRING       {$nn=unEscapeString($a.text); $v=unEscapeString($b.text);}
              	    | '.enum_kind' a=STRING b=STRING      {$nn=unEscapeString($a.text); String on[]=parseOwnerAndName($b.text);$v=new String[]{on[0],on[1]};}
              	    | '.cls_kind' a=STRING b=STRING       {$nn=unEscapeString($a.text); $v=Type.getType(unEscapeString($b.text));}
              	    | '.arr_kind' a=STRING {List<Object> array=new ArrayList<>();} (t=sAnnotationElementSoot{array.add($t.v);})* '.end'  '.arr_elem'   {$nn=unEscapeString($a.text); $v=array;}
              	    | '.ann_kind' a=STRING q=sSubannotationSoot '.end' '.annot_elem'     {$nn=unEscapeString($a.text); $v=$q.v;})
	;

sSubannotationSoot  returns[AnnotationNode v]
	:	'.annotation' a=STRING   { $v=new AnnotationNode(unEscapeString($a.text)); }
	     (t=sAnnotationElementSoot {$v.visit($t.nn,$t.v);} )*
	    '.end' '.annotation'
	;
sAnnotationElement @init{List<Object> array = new ArrayList<Object>(); AnnotationNode _t= currentAnnotationVisitor;}
    :   a=sId (
             xid=ID { if(!"e".contains($xid.text)){ throw new RecognitionException(input);} }  c=OBJECT_TYPE '=' b=sWord {  _t.visit($a.text,new String[]{$c.text,$b.text}); }
           | AT b2=OBJECT_TYPE '=' {  currentAnnotationVisitor=new AnnotationNode($b2.text);} sSubannotation  { _t.visit($a.text,currentAnnotationVisitor); }
           | xid=ID { if(!"c".contains($xid.text)){ throw new RecognitionException(input);} } '=' b1=sClassDesc { currentAnnotationVisitor.visit($a.text,Type.getType($b1.text)); }
           | xid=ID { if(!"s".contains($xid.text)){ throw new RecognitionException(input);} } '=' b3=STRING      { currentAnnotationVisitor.visit($a.text,unEscapeString($b3.text)); }
           | UP_B  '=' b4=INT  { currentAnnotationVisitor.visit($a.text,(byte)parseInt($b4.text)); }
           | UP_Z  '=' b5=INT  { currentAnnotationVisitor.visit($a.text,0!=parseInt($b5.text)); }
           | UP_S  '=' b6=INT   { currentAnnotationVisitor.visit($a.text,(short)parseInt($b6.text)); }
           | UP_C  '=' b7=INT   { currentAnnotationVisitor.visit($a.text,(char)parseInt($b7.text)); }
           | UP_I  '=' b8=INT   { currentAnnotationVisitor.visit($a.text,parseInt($b8.text)); }
           | UP_J  '=' b9=(INT|LONG)  { currentAnnotationVisitor.visit($a.text,parseLong($b9.text)); }
           | UP_F  '=' b10=(INT|FLOAT|DOUBLE)  { currentAnnotationVisitor.visit($a.text,parseFloat($b10.text)); }
           | UP_D  '=' b11=(INT|FLOAT|DOUBLE)   { currentAnnotationVisitor.visit($a.text,parseDouble($b11.text)); }
           | ARRAY_B '='  (b12=INT {array.add((byte)parseInt($b12.text));} )+    { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_Z '='  (b13=INT {array.add(0!=parseInt($b13.text));} )+       { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_S '='  (b14=INT {array.add((short)parseInt($b14.text));} )+   { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_C '='  (b15=INT {array.add((char)parseInt($b15.text));} )+    { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_I '='  (b16=INT {array.add(parseInt($b16.text));} )+          { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_J '='  (b17=(INT|LONG) {array.add(parseLong($b17.text));} )+  { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_F '='  (b18=(INT|FLOAT|DOUBLE) {array.add(parseFloat($b18.text));} )+  { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_D '='  (b19=(INT|DOUBLE) {array.add(parseDouble($b19.text));} )+       { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_LOW_E c=OBJECT_TYPE '='  ((b1=sWord{  array.add(new String[]{$c.text,unEscape($b1.text)}); }|b2=STRING{  array.add(new String[]{$c.text,unEscapeString($b2.text)}); }|b3=DSTRING{  array.add(new String[]{$c.text,unEscapeString($b3.text)}); })  )+  { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_AND b20=OBJECT_TYPE '=' ARRAY_AT '='  ({currentAnnotationVisitor=new AnnotationNode($b20.text);} sSubannotation{ array.add(currentAnnotationVisitor); })+ { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_LOW_C '='  (b=sClassDesc {array.add(Type.getType($b.text));} )+       { currentAnnotationVisitor.visit($a.text,array); }
           | ARRAY_LOW_S '='  (b21=STRING {array.add(unEscapeString($b21.text));})+   { currentAnnotationVisitor.visit($a.text,array); }
		)
	{ currentAnnotationVisitor=_t; }
;
sSubannotation
	:	'.annotation' 
	     sAnnotationElement*
	    '.end annotation'
	;
sAccList returns[int acc]: {$acc=0;} ( a=ACC {$acc|=getAcc($a.text);})*  ;
sMemberName returns[String name]: a=sId {$name=unEscape($a.text);} | b=STRING {$name=unEscapeString($b.text);}| c=DSTRING {$name=unEscapeString($c.text);};
sField	@init {
                    if(cn.fields==null){
                        cn.fields=new ArrayList<>();
                    }
                    currentAv=fnv;
                    fn=new FieldNode(0,null,null,null,null);
                    cn.fields.add(fn);
              }
    :	'.field' i=sAccList n=sMemberName t=sClassDesc { fn.access|=i;fn.name=$n.name;fn.desc=unEscape($t.text); }
        ( '=' (a=STRING {fn.value=parseValue(fn.desc,unEscapeString($a.text));}
              |a1=INT      {fn.value=parseValue(fn.desc,parseInt($a1.text));}
              |a2=LONG     {fn.value=parseValue(fn.desc,parseLong($a2.text));}
              |a3=FLOAT    {fn.value=parseValue(fn.desc,parseFloat($a3.text));}
              |a4=DOUBLE   {fn.value=parseValue(fn.desc,parseDouble($a4.text));}
              |a5=sClassDesc {fn.value=parseValue(fn.desc,Type.getType(unEscape($a5.text)));}
              )
        )?
            (
            s=sSigAttr{fn.signature=$s.sig;}
            |sDeprecateAttr{ fn.access|=ACC_DEPRECATED; }
            |sSynthetic {cn.access|=ACC_SYNTHETIC;}
            |sVisibiltyAnnotation
            |sAnnotation
            )*
    ('.end field'| '.end' '.field')?
	('.field_attribute' sId STRING {System.err.println("ignore .field_attribute");})*
	;
sMethod	@init{
    if(cn.methods==null){
        cn.methods=new ArrayList<>();
    }
    currentAv=mnv;
    mn=new MethodNode(Opcodes.ASM9);
    cn.methods.add(mn);
    labelMap.clear();
    if(mn.exceptions==null){
        mn.exceptions=new ArrayList<>();
    }
    if(mn.tryCatchBlocks==null){
            mn.tryCatchBlocks=new ArrayList<>();
        }
}
    :	'.method' i=sAccList n=sMemberName t=sMethodDesc {mn.access|=i;mn.name=$n.name;mn.desc=unEscape($t.text);}
            (s=sSigAttr{mn.signature=$s.sig;}
                |sDeprecateAttr{ cn.access|=ACC_DEPRECATED; }
                |sSynthetic {cn.access|=ACC_SYNTHETIC;}
                |sVisibiltyAnnotation
                |sAnnotation
                |'.throws' at=sInternalNameOrDesc {  mn.exceptions.add(Type.getType($at.desc).getInternalName()); }
                |'.annotation_default' (t=sAnnotationElementSoot {currentAnnotationVisitor=(AnnotationNode)mn.visitAnnotationDefault();} )? '.end' '.annotation_default'
                |'.param' ('.runtime_invisible_annotation'|'.runtime_visible_annotation') {int index=0;}
                    ({boolean visible=false;} ('.runtime_visible_annotation' {visible=true;}|'.runtime_invisible_annotation'{visible=false;}) a1=STRING
                    { currentAnnotationVisitor= currentAv.visitParameterAnnotation(index,unEscapeString($a1.text),visible); }
                        sAnnotationSoot*
                       '.end' '.annotation_attr' {index++;}
                    )*
                 '.end' '.param'
                | code
            )*
        '.end method'
	('.method_attribute' sId STRING {System.err.println("ignore method_attribute");})*
	;

sLabel	:	ACC|ID|UP_Z|UP_B|UP_S|UP_C|UP_I|UP_F|UP_D|UP_J|ANNOTATION_VISIBLITY|METHOD_ANNOTATION_VISIBLITY|INNER|OUTTER
	;
code
    :	a=OP0 { line($a.line); visitOP0(getOp($a.text)); }
	|	a=IOP b=INT { line($a.line); visitIOP(getOp($a.text),parseInt($b.text)); }
	|	a=IIOP b=INT c=INT   { line($a.line); visitIIOP(getOp($a.text),parseInt($b.text),parseInt($c.text)); }
	| 	a=LDC  {line($a.line);  } ( c=INT        {mn.visitLdcInsn(parseInt($c.text));}
	                               |c=LONG       {mn.visitLdcInsn(parseLong($c.text));}
	                               |c=FLOAT      {mn.visitLdcInsn(parseFloat($c.text));}
	                               |c=DOUBLE     {mn.visitLdcInsn(parseDouble($c.text));}
	                               |c=STRING     {mn.visitLdcInsn(unEscapeString($c.text));}
	                               |eTV=sInternalNameOrDescNoString {mn.visitLdcInsn(Type.getType($eTV.desc));}
	                              )
	|	a=XFIELD efo=sFieldObject {  line($a.line);  mn.visitFieldInsn(getOp($a.text),$efo.ownerInternalName,$efo.memberName,$efo.type);   }
	|   a=XNEWARRAY {line($a.line); }  (
	               WBOOLEAN{mn.visitIntInsn(NEWARRAY,T_BOOLEAN);}
	               |WBYTE{mn.visitIntInsn(NEWARRAY,T_BYTE);}
	               |WSHORT{mn.visitIntInsn(NEWARRAY,T_SHORT);}
	               |WCHAR{mn.visitIntInsn(NEWARRAY,T_CHAR);}
	               |WINTEGER{mn.visitIntInsn(NEWARRAY,T_INT);}
	               |WLONG{mn.visitIntInsn(NEWARRAY,T_LONG);}
	               |WFLOAT{mn.visitIntInsn(NEWARRAY,T_FLOAT);}
	               |WDOUBLE{mn.visitIntInsn(NEWARRAY,T_DOUBLE);})
	|	a=XTYPE ffTV=sInternalNameOrDescACC {
	                       line($a.line);
	                          mn.visitTypeInsn(getOp($a.text),Type.getType($ffTV.desc).getInternalName());
	            }
	|	a=JOP z=sLabel  { line($a.line); visitJOP(getOp($a.text),getLabel($z.text)); }
	|	a=XINVOKE e1=sMethodObject   {line($a.line);
	                    mn.visitMethodInsn(getOp($a.text),$e1.ownerInternalName,$e1.memberName,$e1.desc, false);
	                  }
	|	a=INVOKEINTERFACE e2=sMethodObject INT?  {line($a.line);
	                    mn.visitMethodInsn(getOp($a.text),$e2.ownerInternalName,$e2.memberName,$e2.desc, true);
	                  }
	|	a=INVOKEDYNAMIC e3=sMethodObject sId sMethodDesc '(' sInvokeDynamicE (',' sInvokeDynamicE)* ')'  {line($a.line); if(1==1) throw new RuntimeException("not support Yet!");}
	|	a=MULTIANEWARRAY ff=sClassDesc c=INT   {line($a.line); mn.visitMultiANewArrayInsn(unEscape($ff.text),parseInt($c.text)); }
	|   z=sLabel ':' { Label label=getLabel($z.text); mn.visitLabel(label); if(rebuildLine) {mn.visitLineNumber($z.start.getLine(),label);}
	 }
	|	'.catch' e=sId 'from' z1=sLabel 'to' z2=sLabel 'using' z3=sLabel { String type="all".equals($e.text)?null:unEscape($e.text); mn.visitTryCatchBlock(getLabel($z1.text),getLabel($z2.text),getLabel($z3.text),type); }
	|	'.limit' 'stack' ('?' { mn.maxStack=-1; } | i1=INT { mn.maxStack=parseInt($i1.text); })
	|	'.limit' 'locals' ('?' {mn.maxLocals=-1;}| i1=INT { mn.maxLocals=parseInt($i1.text);})
	|	'.code_attribute' sId STRING   { System.err.println("ignore .code_attribute"); }
	|	'.line' b=INT  { if(!rebuildLine) { Label label=new Label(); mn.visitLabel(label); mn.visitLineNumber(parseInt($b.text),label); } }
	|   '.var' var=INT 'is' mber=sMemberName desc=sClassDesc ('signature' sig=STRING)? 'from' z1=sLabel 'to' z2=sLabel  { mn.visitLocalVariable($mber.name,unEscape($desc.text),unEscapeString($sig.text),getLabel($z1.text),getLabel($z2.text),parseInt($var.text)); }
    |   sSwitch
	;
sInvokeDynamicE
	:	METHOD_DESC_WITHOUT_RET (INT|LONG|FLOAT|DOUBLE|STRING)
	;
sMethodDesc
	:	METHOD_DESC_WITHOUT_RET (sClassDesc|VOID_TYPE)
	;
sSwitch @init {List<Integer> keys=null;List<Label> labels=null;Label defaultLabel=null;}
	:	a=LOOKUPSWITCH { keys=new ArrayList<>(); labels=new ArrayList<>();  } (c=INT ':' z=sLabel { keys.add(parseInt($c.text)); labels.add(getLabel($z.text)); })* (DEFAULT ':' z=sLabel { defaultLabel=getLabel($z.text); })   {
	        line($a.line);
	        int ts[]=new int[keys.size()];
	        for(int i=0;i<keys.size();i++){
	            ts[i]=keys.get(i);
	        }
	        mn.visitLookupSwitchInsn(defaultLabel, ts, labels.toArray(new Label[labels.size()]));
	        }
	|	a=TABLESWITCH { labels=new ArrayList<>();  } c=INT ';' 'high' '=' d=INT (z=sLabel  {labels.add(getLabel($z.text));} )* (DEFAULT ':' z=sLabel {defaultLabel=getLabel($z.text);})    {
	        line($a.line); mn.visitTableSwitchInsn(parseInt($c.text),parseInt($c.text)+labels.size()-1,defaultLabel,labels.toArray(new Label[labels.size()]));
	        }
	|   a=TABLESWITCH { labels=new ArrayList<>();  } c=INT (z=sLabel  {labels.add(getLabel($z.text));} )* (DEFAULT ':' z=sLabel {defaultLabel=getLabel($z.text);})    {
        	        line($a.line); mn.visitTableSwitchInsn(parseInt($c.text),parseInt($c.text)+labels.size()-1,defaultLabel,labels.toArray(new Label[labels.size()]));
        	        }
    ;
sInternalNameOrDesc returns[String desc]
    : (a=sArrayType { $desc=unEscape($a.text); }|b=OBJECT_TYPE { $desc=unEscape($b.text); })
    | c=sId {  $desc= "L"+unEscape($c.text)+";"; }
    | DSTRING {  $desc= "L"+unEscapeString($DSTRING.text)+";"; }
    | STRING {  $desc= "L"+unEscapeString($STRING.text)+";"; }
    ;
sInternalNameOrDescACC returns[String desc]
        : (a=sArrayType { $desc=unEscape($a.text); }|b=OBJECT_TYPE { $desc=unEscape($b.text); })
        | c=sAnyId {  $desc= "L"+unEscape($c.text)+";"; }
        | DSTRING {  $desc= "L"+unEscapeString($DSTRING.text)+";"; }
        | STRING {  $desc= "L"+unEscapeString($STRING.text)+";"; }
        ;
sInternalNameOrDescNoString returns[String desc]
    : (a=sArrayType { $desc=unEscape($a.text); }|b=OBJECT_TYPE { $desc=unEscape($b.text); })
    | c=sAnyId {  $desc= "L"+unEscape($c.text)+";"; }
    ;
sAnyId
    : ACC | sId
    ;
sAnyIdOrString returns[String str]
    : sAnyId { $str=unEscape($sAnyId.text);}
    | STRING { $str=unEscapeString($STRING.text); }
    | DSTRING { $str=unEscapeString($DSTRING.text); }
    ;
sOwnerAndName returns[String ownerInternalName, String memberName]
    :    a=sArrayType '/' x=sAnyId { if($x.text.contains("/")){ throw new RecognitionException(input);}  $ownerInternalName=unEscape($a.text); $memberName=unEscape($x.text); }
    | b=sClassDesc '->' x=sAnyId { if($x.text.contains("/")){ throw new RecognitionException(input);} $ownerInternalName=Type.getType(unEscape($b.text)).getInternalName(); $memberName=unEscape($x.text);  }
    | c=sId { String cstr=$c.text; int idx=cstr.lastIndexOf('/'); if(idx<=0) { throw new RecognitionException(input); } $ownerInternalName=unEscape(cstr.substring(0,idx)); $memberName=unEscape(cstr.substring(idx+1)); }
    ;
sMethodObject returns[String ownerInternalName, String memberName, String desc]
    :   ( a=sArrayType '/' x=sAnyId { if($x.text.contains("/")){ throw new RecognitionException(input);}  $ownerInternalName=unEscape($a.text); $memberName=unEscape($x.text); }
        | b=sClassDesc '->' x=sAnyId { if($x.text.contains("/")){ throw new RecognitionException(input);} $ownerInternalName=Type.getType(unEscape($b.text)).getInternalName(); $memberName=unEscape($x.text);  }
        | c=sId { String cstr=$c.text; int idx=cstr.lastIndexOf('/'); if(idx<=0) { throw new RecognitionException(input); } $ownerInternalName=unEscape(cstr.substring(0,idx)); $memberName=unEscape(cstr.substring(idx+1)); }
        )
      d=sMethodDesc { $desc=unEscape($d.text);  }
    ;
sFieldObject returns[String ownerInternalName, String memberName, String type]
    :   ( a=sArrayType '/' x=sAnyId { if($x.text.contains("/")){ throw new RecognitionException(input);}  $ownerInternalName=unEscape($a.text); $memberName=unEscape($x.text); }
        | b=sClassDesc '->' x=sAnyId ':' { if($x.text.contains("/")){ throw new RecognitionException(input);} $ownerInternalName=Type.getType(unEscape($b.text)).getInternalName(); $memberName=unEscape($x.text);  }
        | c=sId { String cstr=$c.text; int idx=cstr.lastIndexOf('/'); if(idx<=0) { throw new RecognitionException(input); } $ownerInternalName=unEscape(cstr.substring(0,idx)); $memberName=unEscape(cstr.substring(idx+1)); }
        )
      b=sClassDesc { $type=unEscape($b.text);  }
    ;

```

`d2j-jasmin/src/main/java/com/googlecode/d2j/jasmin/Jar2JasminCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.jasmin;

import com.googlecode.dex2jar.tools.BaseCmd;
import com.googlecode.dex2jar.tools.BaseCmd.Syntax;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.FileSystem;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;

@Syntax(cmd = "d2j-jar2jasmin", syntax = "[options] <jar>", desc = "Disassemble .class in jar file to jasmin file", onlineHelp = "https://sourceforge.net/p/dex2jar/wiki/Jasmin")
public class Jar2JasminCmd extends BaseCmd {
    @Opt(opt = "d", longOpt = "debug", hasArg = false, description = "disassemble debug info")
    private boolean debugInfo = false;
    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output dir of .j files, default is $current_dir/[jar-name]-jar2jasmin/", argName = "out-dir")
    private Path output;
    @Opt(opt = "e", longOpt = "encoding", description = "encoding for .j files, default is UTF-8", argName = "enc")
    private String encoding = "UTF-8";

    public static void main(String... args) {
        new Jar2JasminCmd().doMain(args);
    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length != 1) {
            usage();
            return;
        }

        Path jar = new File(remainingArgs[0]).toPath().toAbsolutePath();
        if (!Files.exists(jar)) {
            System.err.println(jar + " doesn't exist");
            usage();
            return;
        }

        if (output == null) {
            output = new File(getBaseName(jar) + "-jar2jasmin/").toPath();
        }

        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            usage();
            return;
        }

        System.out.println("disassemble " + jar + " -> " + output);

        if (!output.toString().endsWith(".jar") && !output.toString().endsWith(".apk")) {
            disassemble0(jar, output);
        } else {
            try (FileSystem fs = createZip(output)) {
                disassemble0(jar, fs.getPath("/"));
            }
        }
    }

    private void disassemble0(Path in, final Path output) throws IOException {
        if (Files.isDirectory(in)) { // a dir
            travelFileTree(in, output);
        } else if (in.toString().endsWith(".class")) {
            disassemble1(in, output);
        } else {
            try (FileSystem fs = openZip(in)) {
                travelFileTree(fs.getPath("/"), output);
            }
        }
    }

    private void travelFileTree(Path in, final Path output) throws IOException {
        Files.walkFileTree(in, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if (file.getFileName().toString().endsWith(".class")) {
                    disassemble1(file, output);
                }
                return super.visitFile(file, attrs);
            }
        });
    }

    private void disassemble1(Path file, Path output) throws IOException {
        ClassReader r = new ClassReader(Files.readAllBytes(file));
        Path jFile = output.resolve(r.getClassName().replace('.', '/') + ".j");
        createParentDirectories(jFile);
        try (BufferedWriter out = Files.newBufferedWriter(jFile, Charset.forName(encoding))) {
            PrintWriter pw = new PrintWriter(out);
            ClassNode node = new ClassNode();
            r.accept(node, (debugInfo ? 0 : ClassReader.SKIP_DEBUG) | ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);
            new JasminDumper(pw).dump(node);
            pw.flush();
        }
    }
}

```

`d2j-jasmin/src/main/java/com/googlecode/d2j/jasmin/Jasmin2JarCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.jasmin;

import com.googlecode.dex2jar.tools.BaseCmd;
import org.antlr.runtime.ANTLRReaderStream;
import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;

@BaseCmd.Syntax(cmd = "d2j-jasmin2jar", syntax = "[options] <jar>", desc = "Assemble .j files to .class file", onlineHelp = "https://sourceforge.net/p/dex2jar/wiki/Jasmin")
public class Jasmin2JarCmd extends BaseCmd implements Opcodes {
    private static final int[] versions = { 0, V1_1, V1_2, V1_3, V1_4, V1_5, V1_6, V1_7, V1_8, V9, V10, V11, V12, V13, V14, V15, V16, V17, V18 };
    @Opt(opt = "g", longOpt = "autogenerate-linenumbers", hasArg = false, description = "autogenerate-linenumbers")
    boolean autogenLines = false;
    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output .jar file, default is $current_dir/[jar-name]-jasmin2jar.jar", argName = "out-jar-file")
    private Path output;
    @Opt(opt = "e", longOpt = "encoding", description = "encoding for .j files, default is UTF-8", argName = "enc")
    private String encoding = "UTF-8";

    @Opt(opt = "d", longOpt = "dump", description = "dump to stdout", hasArg = false)
    private boolean dump;

    @Opt( longOpt = "no-compute-max", description = "", hasArg = false)
    private boolean noComputeMax;

    @Opt(opt = "cv", longOpt = "class-version", description = "default .class version, [1~9], default 8 for JAVA8")
    private int classVersion = 8;

    public Jasmin2JarCmd() {
    }

    public static void main(String... args) throws ClassNotFoundException, SecurityException {
        new Jasmin2JarCmd().doMain(args);
    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length != 1) {
            usage();
            return;
        }
        if (classVersion < 1 || classVersion > 18) {
            throw new HelpException("-cv,--class-version out of range, 1-18 is supported.");
        }

        Path jar = new File(remainingArgs[0]).toPath().toAbsolutePath();
        if (!Files.exists(jar)) {
            System.err.println(jar + " doesn't exist");
            usage();
            return;
        }

        if (output == null) {
            output = new File(getBaseName(jar) + "-jasmin2jar/").toPath();
        }

        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            usage();
            return;
        }

        System.out.println("assemble " + jar + " -> " + output);

        if (!output.toString().endsWith(".jar") && !output.toString().endsWith(".zip")) {
            assemble0(jar, output);
        } else {
            try (FileSystem fs = createZip(output)) {
                assemble0(jar, fs.getPath("/"));
            }
        }
    }

    private void assemble0(Path in, Path output) throws IOException {
        if (Files.isDirectory(in)) { // a dir
            travelFileTree(in, output);
        } else if (in.toString().endsWith(".j")) {
            assemble1(in, output);
        } else {
            try (FileSystem fs = openZip(in)) {
                travelFileTree(fs.getPath("/"), output);
            }
        }
    }

    private void travelFileTree(Path in, final Path output) throws IOException {
        Files.walkFileTree(in, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if (file.getFileName().toString().endsWith(".j")) {
                    assemble1(file, output);
                }
                return super.visitFile(file, attrs);
            }
        });
    }

    private void assemble1(Path file, Path output) throws IOException {
        try (BufferedReader bufferedReader = Files.newBufferedReader(file, Charset.forName(encoding))) {
            ANTLRStringStream is = new ANTLRReaderStream(bufferedReader);
            is.name = file.toString();
            JasminLexer lexer = new JasminLexer(is);
            CommonTokenStream ts = new CommonTokenStream(lexer);
            JasminParser parser = new JasminParser(ts);
            parser.rebuildLine = autogenLines;
            ClassWriter cw = new ClassWriter(noComputeMax?0:ClassWriter.COMPUTE_MAXS);
            ClassNode cn = parser.parse();
            if (cn.version == 0) {
                cn.version = versions[classVersion];
            }
            if (dump) {
                new JasminDumper(new PrintWriter(new OutputStreamWriter(System.out, StandardCharsets.UTF_8), true)).dump(cn);
            }
            cn.accept(cw);
            Path clzFile = output.resolve(cn.name.replace('.', '/') + ".class");
            createParentDirectories(clzFile);
            Files.write(clzFile, cw.toByteArray());
        } catch (RecognitionException e) {
            System.err.println("Fail to assemble " + file);
            e.printStackTrace();
        }
    }
}

```

`d2j-jasmin/src/main/java/com/googlecode/d2j/jasmin/JasminDumper.java`:

```java
/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2005 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.googlecode.d2j.jasmin;

import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.util.Printer;

import java.io.PrintWriter;
import java.util.*;

/**
 * <b>get from asm example</b>
 * <p>
 * Disassembled view of the classes in Jasmin assembler format.
 * <p>
 * The trace printed when visiting the <tt>Hello</tt> class is the following:
 * <p>
 * <blockquote>
 * 
 * <pre>
 * .bytecode 45.3
 * .class public Hello
 * .super java/lang/Object
 * 
 * .method public <init>()V
 * aload 0
 * invokespecial java/lang/Object/<init>()V
 * return
 * .limit locals 1
 * .limit stack 1
 * .end method
 * 
 * .method public static main([Ljava/lang/String;)V
 * getstatic java/lang/System/out Ljava/io/PrintStream;
 * ldc "hello"
 * invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
 * return
 * .limit locals 2
 * .limit stack 2
 * .end method
 * </pre>
 * 
 * </blockquote> where <tt>Hello</tt> is defined by:
 * <p>
 * <blockquote>
 * 
 * <pre>
 * public class Hello {
 * 
 *     public static void main(String[] args) {
 *         System.out.println(&quot;hello&quot;);
 *     }
 * }
 * </pre>
 * 
 * </blockquote>
 * 
 * @author Eric Bruneton
 */
public class JasminDumper implements Opcodes {
    private static final Set<String> ACCESS_KWS = new HashSet<>(Arrays
            .asList("abstract", "private", "protected", "public", "enum", "final", "interface", "static", "strictfp", "native", "super"));

    public JasminDumper(PrintWriter pw) {
        this.pw = pw;
    }

    /**
     * The print writer to be used to print the class.
     */
    protected PrintWriter pw;

    /**
     * The label names. This map associate String values to Label keys.
     */
    protected final Map<Label, String> labelNames = new HashMap<>();

    static void printIdAfterAccess(PrintWriter out, String id) {
        if (ACCESS_KWS.contains(id)) {
            out.print("\"");
            out.print(id);
            out.print("\"");
        } else {
            out.print(id);
        }
    }

    public void dump(ClassNode cn) {
        labelNames.clear();
        pw.print(".bytecode ");
        pw.print(cn.version & 0xFFFF);
        pw.print('.');
        pw.println(cn.version >>> 16);
        println(".source ", cn.sourceFile);
        pw.print(".class");
        pw.print(access_clz(cn.access));
        pw.print(' ');
        printIdAfterAccess(pw, cn.name);
        pw.println();
        if (cn.superName != null) {
            pw.print(".super ");
            printIdAfterAccess(pw, cn.superName);
            pw.println();
        }
        for (String itf : cn.interfaces) {
            pw.print(".implements ");
            printIdAfterAccess(pw, itf);
            pw.println();
        }
        if (cn.signature != null) {
            println(".signature ", '"' + cn.signature + '"');
        }
        if (cn.outerClass != null) {
            pw.print(".enclosing method ");
            pw.print(cn.outerClass);
            if (cn.outerMethod != null) {
                pw.print('/');
                pw.print(cn.outerMethod);
                pw.println(cn.outerMethodDesc);
            } else {
                pw.println();
            }
        }
        if ((cn.access & Opcodes.ACC_DEPRECATED) != 0) {
            pw.println(".deprecated");
        }
        if (cn.visibleAnnotations != null) {
            for (AnnotationNode an : cn.visibleAnnotations) {
                printAnnotation(an, 1, -1);
            }
        }
        if (cn.invisibleAnnotations != null) {
            for (AnnotationNode an : cn.invisibleAnnotations) {
                printAnnotation(an, 2, -1);
            }
        }

        println(".debug ", cn.sourceDebug == null ? null : '"' + cn.sourceDebug + '"');

        for (InnerClassNode in : cn.innerClasses) {
            pw.print(".inner class");
            pw.print(access_clz(in.access & (~Opcodes.ACC_SUPER)));
            if (in.innerName != null) {
                pw.print(' ');
                printIdAfterAccess(pw, in.innerName);
            }
            if (in.name != null) {
                pw.print(" inner ");
                pw.print(in.name);
            }
            if (in.outerName != null) {
                pw.print(" outer ");
                pw.print(in.outerName);
            }
            pw.println();
        }

        for (FieldNode fn : cn.fields) {
            boolean annotations = fn.visibleAnnotations != null && fn.visibleAnnotations.size() > 0;
            if (fn.invisibleAnnotations != null && fn.invisibleAnnotations.size() > 0) {
                annotations = true;
            }
            boolean deprecated = (fn.access & Opcodes.ACC_DEPRECATED) != 0;
            pw.print("\n.field");
            pw.print(access_fld(fn.access));
            pw.print(' ');
            printIdAfterAccess(pw,fn.name);
            pw.print(' ');
            pw.print(fn.desc);
            if (fn.value instanceof String) {
                StringBuilder buf = new StringBuilder();
                Printer.appendString(buf, (String) fn.value);
                pw.print(" = ");
                pw.print(buf.toString());
            } else if (fn.value != null) {
                pw.print(" = ");
                print(fn.value);
            }
            pw.println();
            if (fn.signature != null) {
                pw.print(".signature \"");
                pw.print(fn.signature);
                pw.println("\"");
            }
            if (deprecated) {
                pw.println(".deprecated");
            }
            if (fn.visibleAnnotations != null) {
                for (AnnotationNode an : fn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (fn.invisibleAnnotations != null) {
                for (AnnotationNode an : fn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (fn.signature != null || deprecated || annotations) {
                pw.println(".end field");
            }
        }

        for (MethodNode mn : cn.methods) {
            pw.print("\n.method");
            pw.print(access_mtd(mn.access));
            pw.print(' ');
            printIdAfterAccess(pw, mn.name);
            pw.println(mn.desc);
            if (mn.signature != null) {
                pw.print(".signature \"");
                pw.print(mn.signature);
                pw.println("\"");
            }
            if (mn.annotationDefault != null) {
                pw.println(".annotation default");
                printAnnotationValue(mn.annotationDefault);
                pw.println(".end annotation");
            }
            if (mn.visibleAnnotations != null) {
                for (AnnotationNode an : mn.visibleAnnotations) {
                    printAnnotation(an, 1, -1);
                }
            }
            if (mn.invisibleAnnotations != null) {
                for (AnnotationNode an : mn.invisibleAnnotations) {
                    printAnnotation(an, 2, -1);
                }
            }
            if (mn.visibleParameterAnnotations != null) {
                for (int j = 0; j < mn.visibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.visibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 1, j + 1);
                        }
                    }
                }
            }
            if (mn.invisibleParameterAnnotations != null) {
                for (int j = 0; j < mn.invisibleParameterAnnotations.length; ++j) {
                    List<AnnotationNode> pas = mn.invisibleParameterAnnotations[j];
                    if (pas != null) {
                        for (AnnotationNode an : pas) {
                            printAnnotation(an, 2, j + 1);
                        }
                    }
                }
            }
            for (String ex : mn.exceptions) {
                println(".throws ", ex);
            }
            if ((mn.access & Opcodes.ACC_DEPRECATED) != 0) {
                pw.println(".deprecated");
            }
            if (mn.instructions != null && mn.instructions.size() > 0) {
                labelNames.clear();
                if (mn.tryCatchBlocks != null) {
                    for (TryCatchBlockNode tcb : mn.tryCatchBlocks) {
                        pw.print(".catch ");
                        pw.print(tcb.type == null ? "all" : "all".equals(tcb.type) ? "\\u0097ll" : tcb.type);
                        pw.print(" from ");
                        print(tcb.start);
                        pw.print(" to ");
                        print(tcb.end);
                        pw.print(" using ");
                        print(tcb.handler);
                        pw.println();
                    }
                }
                for (int j = 0; j < mn.instructions.size(); ++j) {
                    AbstractInsnNode in = mn.instructions.get(j);
                    if (in.getType() != AbstractInsnNode.LINE && in.getType() != AbstractInsnNode.FRAME) {
                       if(in.getType()==AbstractInsnNode.LABEL){
                           pw.print("  ");
                       }else {
                           pw.print("    ");
                       }
                    }
                    in.accept(new MethodVisitor(Opcodes.ASM9) {

                        @Override
                        public void visitInsn(int opcode) {
                            print(opcode);
                            pw.println();
                        }

                        @Override
                        public void visitIntInsn(int opcode, int operand) {
                            print(opcode);
                            if (opcode == Opcodes.NEWARRAY) {
                                switch (operand) {
                                case Opcodes.T_BOOLEAN:
                                    pw.println(" boolean");
                                    break;
                                case Opcodes.T_CHAR:
                                    pw.println(" char");
                                    break;
                                case Opcodes.T_FLOAT:
                                    pw.println(" float");
                                    break;
                                case Opcodes.T_DOUBLE:
                                    pw.println(" double");
                                    break;
                                case Opcodes.T_BYTE:
                                    pw.println(" byte");
                                    break;
                                case Opcodes.T_SHORT:
                                    pw.println(" short");
                                    break;
                                case Opcodes.T_INT:
                                    pw.println(" int");
                                    break;
                                case Opcodes.T_LONG:
                                default:
                                    pw.println(" long");
                                    break;
                                }
                            } else {
                                pw.print(' ');
                                pw.println(operand);
                            }
                        }

                        @Override
                        public void visitVarInsn(int opcode, int var) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(var);
                        }

                        @Override
                        public void visitTypeInsn(int opcode, String type) {
                            print(opcode);
                            pw.print(' ');
                            pw.println(type);
                        }

                        @Override
                        public void visitFieldInsn(int opcode, String owner, String name, String desc) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(' ');
                            pw.println(desc);
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean isInterface) {
                            print(opcode);
                            pw.print(' ');
                            pw.print(owner);
                            pw.print('/');
                            pw.print(name);
                            pw.print(desc);
                            if (isInterface) {
                                pw.print(' ');
                                pw.print((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                            }
                            pw.println();
                        }

                        @Override
                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                            visitMethodInsn(opcode, owner, name, desc, opcode == INVOKEINTERFACE);
                        }

                        @Override
                        public void visitJumpInsn(int opcode, Label label) {
                            print(opcode);
                            pw.print(' ');
                            print(label);
                            pw.println();
                        }

                        @Override
                        public void visitLabel(Label label) {
                            print(label);
                            pw.println(':');
                        }

                        @Override
                        public void visitLdcInsn(Object cst) {

                            if (cst instanceof Integer || cst instanceof Float) {
                                pw.print("ldc_w ");
                                print(cst);
                            } else if (cst instanceof Long || cst instanceof Double) {
                                pw.print("ldc2_w ");
                                print(cst);
                            } else {
                                pw.print("ldc ");
                                if (cst instanceof Type) {
                                    pw.print(((Type) cst).getInternalName());
                                } else {
                                    print(cst);
                                }
                            }
                            pw.println();

                        }

                        @Override
                        public void visitIincInsn(int var, int increment) {
                            pw.print("iinc ");
                            pw.print(var);
                            pw.print(' ');
                            pw.println(increment);
                        }

                        @Override
                        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
                            pw.print("tableswitch ");
                            pw.println(min);
                            for (Label label : labels) {
                                pw.print("      ");
                                print(label);
                                pw.println();
                            }
                            pw.print("      default : ");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
                            pw.println("lookupswitch");
                            for (int i = 0; i < keys.length; ++i) {
                                pw.print("      ");
                                pw.print(keys[i]);
                                pw.print(" : ");
                                print(labels[i]);
                                pw.println();
                            }
                            pw.print("      default : ");
                            print(dflt);
                            pw.println();
                        }

                        @Override
                        public void visitMultiANewArrayInsn(String desc, int dims) {
                            pw.print("multianewarray ");
                            pw.print(desc);
                            pw.print(' ');
                            pw.println(dims);
                        }

                        @Override
                        public void visitLineNumber(int line, Label start) {
                            pw.print(".line ");
                            pw.println(line);
                        }
                    });
                }
                if (mn.localVariables != null) {
                    for (LocalVariableNode lv : mn.localVariables) {
                        pw.print("  .var ");
                        pw.print(lv.index);
                        pw.print(" is '");
                        pw.print(lv.name);
                        pw.print("' ");
                        pw.print(lv.desc);
                        if (lv.signature != null) {
                            pw.print(" signature \"");
                            pw.print(lv.signature);
                            pw.print("\"");
                        }
                        pw.print(" from ");
                        print(lv.start);
                        pw.print(" to ");
                        print(lv.end);
                        pw.println();
                    }
                }
                println("  .limit locals ", Integer.toString(mn.maxLocals));
                println("  .limit stack ", Integer.toString(mn.maxStack));
            }
            pw.println(".end method");
        }
    }

    protected void println(final String directive, final String arg) {
        if (arg != null) {
            pw.print(directive);
            pw.println(arg);
        }
    }
    protected String access_clz(final int access) {
        StringBuilder b = new StringBuilder();
        if ((access & Opcodes.ACC_PUBLIC) != 0) {
            b.append(" public");
        }
        if ((access & Opcodes.ACC_PRIVATE) != 0) {
            b.append(" private");
        }
        if ((access & Opcodes.ACC_PROTECTED) != 0) {
            b.append(" protected");
        }
        if ((access & Opcodes.ACC_FINAL) != 0) {
            b.append(" final");
        }
        if ((access & Opcodes.ACC_SUPER) != 0) {
            b.append(" super");
        }
        if ((access & Opcodes.ACC_ABSTRACT) != 0) {
            b.append(" abstract");
        }
        if ((access & Opcodes.ACC_INTERFACE) != 0) {
            b.append(" interface");
        }
        if ((access & Opcodes.ACC_SYNTHETIC) != 0) {
            b.append(" synthetic");
        }
        if ((access & Opcodes.ACC_ANNOTATION) != 0) {
            b.append(" annotation");
        }
        if ((access & Opcodes.ACC_ENUM) != 0) {
            b.append(" enum");
        }
        return b.toString();
    }
    protected String access_fld(final int access) {
        StringBuilder b = new StringBuilder();
        if ((access & Opcodes.ACC_PUBLIC) != 0) {
            b.append(" public");
        }
        if ((access & Opcodes.ACC_PRIVATE) != 0) {
            b.append(" private");
        }
        if ((access & Opcodes.ACC_PROTECTED) != 0) {
            b.append(" protected");
        }
        if ((access & Opcodes.ACC_STATIC) != 0) {
            b.append(" static");
        }
        if ((access & Opcodes.ACC_FINAL) != 0) {
            b.append(" final");
        }
        if ((access & Opcodes.ACC_VOLATILE) != 0) {
            b.append(" volatile");
        }
        if ((access & Opcodes.ACC_TRANSIENT) != 0) {
            b.append(" transient");
        }
        if ((access & Opcodes.ACC_SYNTHETIC) != 0) {
            b.append(" synthetic");
        }
        if ((access & Opcodes.ACC_ENUM) != 0) {
            b.append(" enum");
        }
        return b.toString();
    }
    protected String access_mtd(final int access) {
        StringBuilder b = new StringBuilder();
        if ((access & Opcodes.ACC_PUBLIC) != 0) {
            b.append(" public");
        }
        if ((access & Opcodes.ACC_PRIVATE) != 0) {
            b.append(" private");
        }
        if ((access & Opcodes.ACC_PROTECTED) != 0) {
            b.append(" protected");
        }
        if ((access & Opcodes.ACC_STATIC) != 0) {
            b.append(" static");
        }
        if ((access & Opcodes.ACC_FINAL) != 0) {
            b.append(" final");
        }
        if ((access & Opcodes.ACC_SYNCHRONIZED) != 0) {
            b.append(" synchronized");
        }
        if ((access & Opcodes.ACC_BRIDGE) != 0) {
            b.append(" bridge");
        }
        if ((access & Opcodes.ACC_VARARGS) != 0) {
            b.append(" varargs");
        }
        if ((access & Opcodes.ACC_NATIVE) != 0) {
            b.append(" native");
        }
        if ((access & Opcodes.ACC_ABSTRACT) != 0) {
            b.append(" abstract");
        }
        if ((access & Opcodes.ACC_STRICT) != 0) {
            b.append(" strict");
        }
        if ((access & Opcodes.ACC_SYNTHETIC) != 0) {
            b.append(" synthetic");
        }
        return b.toString();
    }

    protected void print(final int opcode) {
        pw.print(Printer.OPCODES[opcode].toLowerCase());
    }

    protected void print(final Object cst) {
        if (cst instanceof String) {
            StringBuilder buf = new StringBuilder();
            Printer.appendString(buf, (String) cst);
            pw.print(buf.toString());
        } else if (cst instanceof Float) {
            Float f = (Float) cst;
            if (!f.isNaN() && !f.isInfinite()) {
                pw.print(cst + "F");
            } else if (f.isNaN()) {
                pw.print("floatnan");
            } else {
                double v = f;
                if ((v == Float.POSITIVE_INFINITY)) {
                    pw.print("+floatinfinity");
                } else {
                    pw.print("-floatinfinity");
                }
            }
        } else if (cst instanceof Double) {
            Double d = (Double) cst;

            if (!d.isNaN() && !d.isInfinite()) {
                pw.print(cst + "D");
            } else if (d.isNaN()) {
                pw.print("doublenan");
            } else {
                double v = d;
                if ((v == Double.POSITIVE_INFINITY)) {
                    pw.print("+doubleinfinity");
                } else {
                    pw.print("-doubleinfinity");
                }
            }
        } else if (cst instanceof Long) {
            pw.print(cst + "L");
        } else {
            pw.print(cst);
        }
    }

    protected void print(final Label l) {
        String name = labelNames.get(l);
        if (name == null) {
            name = "L" + labelNames.size();
            labelNames.put(l, name);
        }
        pw.print(name);
    }

    protected void print(final LabelNode l) {
        print(l.getLabel());
    }

    protected void printAnnotation(final AnnotationNode n, final int visible, final int param) {
        pw.print(".annotation ");
        if (visible > 0) {
            if (param == -1) {
                pw.print(visible == 1 ? "visible " : "invisible ");
            } else {
                pw.print(visible == 1 ? "visibleparam " : "invisibleparam ");
                pw.print(param);
                pw.print(' ');
            }
            pw.print(n.desc);
        }
        pw.println();
        if (n.values != null) {
            for (int i = 0; i < n.values.size(); i += 2) {
                pw.print(n.values.get(i));
                pw.print(' ');
                printAnnotationValue(n.values.get(i + 1));
            }
        }
        pw.println(".end annotation");
    }

    protected void printAnnotationValue(final Object value) {
        if (value instanceof String[]) {
            pw.print("e ");
            pw.print(((String[]) value)[0]);
            pw.print(" = ");
            pw.print(((String[]) value)[1]);
            pw.println();
        } else if (value instanceof AnnotationNode) {
            pw.print("@ ");
            pw.print(((AnnotationNode) value).desc);
            pw.print(" = ");
            printAnnotation((AnnotationNode) value, 0, -1);
        } else if (value instanceof byte[]) {
            pw.print("[B = ");
            byte[] v = (byte[]) value;
            for (byte element : v) {
                pw.print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof boolean[]) {
            pw.print("[Z = ");
            boolean[] v = (boolean[]) value;
            for (boolean element : v) {
                pw.print(element ? '1' : '0');
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof short[]) {
            pw.print("[S = ");
            short[] v = (short[]) value;
            for (short element : v) {
                pw.print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof char[]) {
            pw.print("[C = ");
            char[] v = (char[]) value;
            for (char element : v) {
                pw.print(new Integer(element));
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof int[]) {
            pw.print("[I = ");
            int[] v = (int[]) value;
            for (int element : v) {
                pw.print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof long[]) {
            pw.print("[J = ");
            long[] v = (long[]) value;
            for (long element : v) {
                pw.print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof float[]) {
            pw.print("[F = ");
            float[] v = (float[]) value;
            for (float element : v) {
                print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof double[]) {
            pw.print("[D = ");
            double[] v = (double[]) value;
            for (double element : v) {
                print(element);
                pw.print(' ');
            }
            pw.println();
        } else if (value instanceof List) {
            List l = (List) value;
            if (l.size() > 0) {
                Object o = l.get(0);
                if (o instanceof String[]) {
                    pw.print("[e ");
                    pw.print(((String[]) o)[0]);
                    pw.print(" = ");
                } else if (o instanceof AnnotationNode) {
                    pw.print("[& ");
                    pw.print(((AnnotationNode) o).desc);
                    pw.print(" = ");
                    pw.print("[@ = ");
                } else if (o instanceof String) {
                    pw.print("[s = ");
                } else if (o instanceof Byte) {
                    pw.print("[B = ");
                } else if (o instanceof Boolean) {
                    pw.print("[Z = ");
                } else if (o instanceof Character) {
                    pw.print("[C = ");
                } else if (o instanceof Short) {
                    pw.print("[S = ");
                } else if (o instanceof Type) {
                    pw.print("[c = ");
                } else if (o instanceof Integer) {
                    pw.print("[I = ");
                } else if (o instanceof Float) {
                    pw.print("[F = ");
                } else if (o instanceof Long) {
                    pw.print("[J = ");
                } else if (o instanceof Double) {
                    pw.print("[D = ");
                }
                for (Object aL : l) {
                    printAnnotationArrayValue(aL);
                    pw.print(' ');
                }
            } else {
                pw.print("; empty array annotation value");
            }
            pw.println();
        } else if (value instanceof String) {
            pw.print("s = ");
            print(value);
            pw.println();
        } else if (value instanceof Byte) {
            pw.print("B = ");
            pw.println(((Byte) value).intValue());
        } else if (value instanceof Boolean) {
            pw.print("Z = ");
            pw.println((Boolean) value ? 1 : 0);
        } else if (value instanceof Character) {
            pw.print("C = ");
            pw.println(new Integer((Character) value));
        } else if (value instanceof Short) {
            pw.print("S = ");
            pw.println(((Short) value).intValue());
        } else if (value instanceof Type) {
            pw.print("c = ");
            pw.println(((Type) value).getDescriptor());
        } else if (value instanceof Integer) {
            pw.print("I = ");
            print(value);
            pw.println();
        } else if (value instanceof Float) {
            pw.print("F = ");
            print(value);
            pw.println();
        } else if (value instanceof Long) {
            pw.print("J = ");
            print(value);
            pw.println();
        } else if (value instanceof Double) {
            pw.print("D = ");
            print(value);
            pw.println();
        } else {
            throw new RuntimeException();
        }
    }

    protected void printAnnotationArrayValue(final Object value) {
        if (value instanceof String[]) {
            print(((String[]) value)[1]);
        } else if (value instanceof AnnotationNode) {
            printAnnotation((AnnotationNode) value, 0, -1);
        } else if (value instanceof String) {
            print(value);
        } else if (value instanceof Byte) {
            pw.print(((Byte) value).intValue());
        } else if (value instanceof Boolean) {
            pw.print((Boolean) value ? 1 : 0);
        } else if (value instanceof Character) {
            pw.print(new Integer((Character) value));
        } else if (value instanceof Short) {
            pw.print(((Short) value).intValue());
        } else if (value instanceof Type) {
            pw.print(((Type) value).getDescriptor());
        } else {
            print(value);
        }
    }

    protected void printFrameType(final Object type) {
        if (type == Opcodes.TOP) {
            pw.print("Top");
        } else if (type == Opcodes.INTEGER) {
            pw.print("Integer");
        } else if (type == Opcodes.FLOAT) {
            pw.print("Float");
        } else if (type == Opcodes.LONG) {
            pw.print("Long");
        } else if (type == Opcodes.DOUBLE) {
            pw.print("Double");
        } else if (type == Opcodes.NULL) {
            pw.print("Null");
        } else if (type == Opcodes.UNINITIALIZED_THIS) {
            pw.print("UninitializedThis");
        } else if (type instanceof Label) {
            pw.print("Uninitialized ");
            print((Label) type);
        } else {
            pw.print("Object ");
            pw.print(type);
        }
    }
}

```

`d2j-jasmin/src/main/java/com/googlecode/d2j/jasmin/Jasmins.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.jasmin;

import org.antlr.runtime.ANTLRReaderStream;
import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.objectweb.asm.tree.ClassNode;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

public class Jasmins {
    public static ClassNode parse(Path file) throws IOException {
        try (BufferedReader bufferedReader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {
            return parse(file.toString(), bufferedReader);
        } catch (RecognitionException e) {
            throw new RuntimeException("Fail to assemble " + file, e);
        }
    }

    public static ClassNode parse(String fileName, Reader bufferedReader) throws IOException, RecognitionException {
        ANTLRStringStream is = new ANTLRReaderStream(bufferedReader);
        is.name = fileName;
        JasminLexer lexer = new JasminLexer(is);
        CommonTokenStream ts = new CommonTokenStream(lexer);
        JasminParser parser = new JasminParser(ts);
        return parser.parse();
    }

    public static ClassNode parse(String fileName, InputStream is) throws IOException, RecognitionException {
        return parse(fileName, new InputStreamReader(is, StandardCharsets.UTF_8));
    }
}

```

`d2j-jasmin/src/test/java/com/googlecode/d2j/tools/jar/test/Jasmin2jTest.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2015 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.tools.jar.test;

import com.googlecode.d2j.jasmin.JasminDumper;
import com.googlecode.d2j.jasmin.Jasmins;
import org.junit.Assert;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;
import org.objectweb.asm.tree.ClassNode;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URL;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;

@RunWith(Jasmin2jTest.S.class)
public class Jasmin2jTest {

    public static class S extends ParentRunner<Path> {

        public S(Class<?> klass) throws InitializationError {
            super(klass);
            init(klass);
        }

        Path basePath;
        List<Path> runners = new ArrayList<>();

        public void init(final Class<?> testClass) throws InitializationError {
            URL url = testClass.getResource("/jasmins/type.j");
            Assert.assertNotNull(url);

            final String file = url.getFile();
            Assert.assertNotNull(file);

            basePath = new File(file).toPath().getParent();

            System.out.println("jasmins dir is " + basePath);

            try {
                Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().endsWith(".j")) {
                            runners.add(basePath.relativize(file));
                        }
                        return super.visitFile(file, attrs);
                    }
                });
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        protected List<Path> getChildren() {
            return runners;
        }

        @Override
        protected Description describeChild(Path child) {
            return Description.createTestDescription(getTestClass().getJavaClass(), child.toString());
        }

        @Override
        protected void runChild(final Path child, RunNotifier notifier) {
            runLeaf(new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    ClassNode cn= Jasmins.parse(basePath.resolve(child));
                    JasminDumper dumper=new JasminDumper(new PrintWriter(System.out,true));
                    dumper.dump(cn);
                }
            }, describeChild(child), notifier);
        }
    }
}

```

`d2j-jasmin/src/test/resources/jasmins/type.j`:

```j
.class public 'public'
.implements A
.implements interface
.implements public

.annotation visible Ljava/lang/A;
.annotation visible java/lang/B
.end annotation

.annotation visible Ljava/lang/annotation/Retention;
value e Ljava/lang/annotation/RetentionPolicy; = CLASS
value [e LR; = CLASS 'CLASS2' "CLASS3"
.end annotation

.method public ldc()V
ldc 0
ldc 1L
ldc "abc"
ldc I                ;;;;;;; equals to LI;
ldc Ljava/lang/Object;
ldc [I
ldc [[Ljava/lang/Object;
.end method

.method public checkcast()V
invokeinterface android/content/DialogInterface/dismiss()V 0
checkcast Ljava/lang/Object;
checkcast [I
checkcast [[Ljava/lang/Object;
checkcast I
invokestatic LB;->clone()V
invokestatic B/clone()V
invokestatic [B->clone()V
invokestatic [B/clone()V
getstatic LB;->a:I
getstatic B/a I
getstatic [B->a:I
getstatic [B/a I


getstatic B/public I

.end method
.method public "public"()V
.end method
.method public 'static'()V
.end method

```

`d2j-smali/build.gradle`:

```gradle
apply plugin: 'antlr'

dependencies {
  compile 'org.antlr:antlr4-runtime:4.9.3' // Newer versions only for Java 11+
  compile project(':dex-reader')
  antlr 'org.antlr:antlr4:4.9.3' // Newer versions only for Java 11+
  compile project(':d2j-base-cmd')
  compile project(':dex-writer')
    testImplementation "com.android.tools.smali:smali-baksmali:3.0.3"
}

generateGrammarSource {
    arguments += ['-no-listener', '-visitor','-package','com.googlecode.d2j.smali.antlr4']
}

sourceSets {
    test.output.resourcesDir = "build/classes/test"
    main.antlr.srcDirs = ['src/main/antlr4']
}

```

`d2j-smali/src/main/antlr4/com/googlecode/d2j/smali/antlr4/Smali.g4`:

```g4
grammar Smali;

fragment
INT_NENT: ('+'|'-')? (
               '0'
            | ('1'..'9') ('0'..'9')*
            | '0' ('0'..'7')+
            | ('0x'|'0X') HEX_DIGIT+
         );
fragment
FLOAT_NENT
    : (('+'|'-')?( ('0'..'9')+ '.' ('0'..'9')* EXPONENT?
    |   '.' ('0'..'9')+ EXPONENT?
    |   ('0'..'9')+ EXPONENT)| ( ('+'|'-') F_INFINITY) )
    ;
fragment
F_NAN : ('N'|'n') ('A'|'a') ('N'|'n');

COMMENT
    :   ('//' ~('\n'|'\r')* '\r'? '\n'
    |   '#' ~('\n'|'\r')* '\r'? '\n'
    |   '/*' .*? '*/' ) -> skip
    ;

WS  :   [ \t\r\n]+ -> skip
    ;

fragment
EXPONENT : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

fragment
HEX_DIGIT : ('0'..'9'|'a'..'f'|'A'..'F') ;

fragment
ESC_SEQ
    :   '\\' ('b'|'t'|'n'|'f'|'r'|'\''|'"'|'\\')
    |   UNICODE_ESC
    |   OCTAL_ESC
    ;

fragment
OCTAL_ESC
    :   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7')
    ;

fragment
UNICODE_ESC
    :   '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    ;
VOID_TYPE:'V';
fragment
FRAGMENT_PRIMITIVE_TYPE:'B'|'Z'|'S'|'C'|'I'|'F'|'J'|'D';
fragment
FRAGMENT_OBJECT_TYPE: 'L' (ESC_SEQ |~(';'|':'|'\\'|' '|'\n'|'\t'|'\r'|'('|')'))+ ';' ;
fragment
FRAGMENT_ARRAY_TYPE: ('[')+ (FRAGMENT_PRIMITIVE_TYPE|FRAGMENT_OBJECT_TYPE);

fragment
FRAGMENT_ID: (ESC_SEQ| ~('\\'|'\r'|'\n'|'\t'|' '|':'|'-'|'='|','|'{'|'}'|'('|')'|'+'|'"'|'\''|'#'|'/'|'.'|';'|'@'))+;
fragment
FRAGMENT_METHOD_PROTO: '(' (FRAGMENT_OBJECT_TYPE|FRAGMENT_ARRAY_TYPE|FRAGMENT_PRIMITIVE_TYPE)* ')' ('V' | FRAGMENT_OBJECT_TYPE|FRAGMENT_ARRAY_TYPE|FRAGMENT_PRIMITIVE_TYPE)
;
fragment
FRAGMENT_FIELD_PART:
 FRAGMENT_ID
 ':' (FRAGMENT_OBJECT_TYPE|FRAGMENT_ARRAY_TYPE|FRAGMENT_PRIMITIVE_TYPE)
;


METHOD_FULL: (FRAGMENT_OBJECT_TYPE|FRAGMENT_ARRAY_TYPE) '->' FRAGMENT_ID FRAGMENT_METHOD_PROTO;
METHOD_PART: FRAGMENT_ID FRAGMENT_METHOD_PROTO;
METHOD_PROTO: FRAGMENT_METHOD_PROTO;

FIELD_FULL: (FRAGMENT_OBJECT_TYPE|FRAGMENT_ARRAY_TYPE) '->' FRAGMENT_FIELD_PART;
FIELD_PART: FRAGMENT_FIELD_PART;
LABEL: ':' FRAGMENT_ID;

SMALI_V2_LOCAL_NAME_TYPE : '"' ( ESC_SEQ | ~('\\'|'"') )* '"' ':' (FRAGMENT_OBJECT_TYPE|FRAGMENT_ARRAY_TYPE|FRAGMENT_PRIMITIVE_TYPE)
                         ;

F_INFINITY: ('I'|'i') ('N'|'n') ('F'|'f') ('I'|'i') ('N'|'n') ('I'|'i') ('T'|'t') ('Y'|'y') ;
FLOAT_NAN : F_NAN ('f'|'F');
DOUBLE_NAN: F_NAN ('d'|'D')?;
FLOAT_INFINITY: F_INFINITY ('f'|'F');
DOUBLE_INFINITY: F_INFINITY ('d'|'D')?;
BASE_FLOAT	:	(('0'..'9')+|FLOAT_NENT) ('f'|'F');
BASE_DOUBLE	:	FLOAT_NENT ('d'|'D')? | ('0'..'9')+ ('d'|'D') ;
CHAR	:	'\''  ( ESC_SEQ | ~('\\'|'\'') ) '\'';
LONG	:	INT_NENT ('L'|'l');
SHORT	:	INT_NENT ('S'|'s');
BYTE	:	INT_NENT ('T'|'t');
INT	:	INT_NENT;
BOOLEAN	:	'true'|'false';


STRING
    :  '"' ( ESC_SEQ | ~('\\'|'"') )* '"'
    ;

OBJECT_TYPE: FRAGMENT_OBJECT_TYPE;
ARRAY_TYPE: FRAGMENT_ARRAY_TYPE;
PRIMITIVE_TYPE: FRAGMENT_PRIMITIVE_TYPE;

ACC:	'public' | 'private' | 'protected' | 'static' | 'final' | 'synchronized' | 'bridge' | 'varargs' | 'native' |
    'abstract' | 'strictfp' | 'synthetic' | 'constructor' | 'interface' | 'enum' |
    'annotation' | 'volatile' | 'transient' | 'declared-synchronized' ;
ANN_VISIBLE
	:	'build' | 'runtime' | 'system';
REGISTER:	('v'|'V'|'p'|'P') '0'..'9'+;
NOP	:	'nop';
MOVE	:	'move';
RETURN	:	'return';
CONST	:	'const';
THROW	:	'throw';
GOTO	:	'goto';
AGET	:	'aget';
APUT	:	'aput';
IGET	:	'iget';
IPUT	:	'iput';
SGET	:	'sget';
SPUT	:	'sput';
NULL    :   'null';
ID  :	FRAGMENT_ID
    ;
DPARAMETER:'.parameter';
DENUM:'.enum';
DPARAM: '.param';
DLINENUMBER: '.line';
DLOCAL:'.local';
DENDLOCAL:'.end local';
DRESTARTLOCAL:'.restart local';
DPROLOGUE:'.prologue';
DEPIOGUE:'.epiogue';

sFiles: sFile+;
sFile	:	'.class' sAccList className=OBJECT_TYPE
    ( sSuper | sInterface|sSource|sMethod|sField|sAnnotation)*
             '.end class'?
    	;
sSource :	'.source' src=STRING;
sSuper	:	'.super' name=OBJECT_TYPE;
sInterface:	'.implements' name=OBJECT_TYPE;
sMethod
	:	'.method' sAccList methodObj=(METHOD_FULL|METHOD_PART)
		(  sAnnotation
		  | sParameter
		  | sInstruction
		 )*
		'.end method';
sField	: '.field' sAccList fieldObj=(FIELD_FULL|FIELD_PART) ('=' sBaseValue)?
		(sAnnotation*
		'.end field')?
	;
sAccList: ACC*;
sAnnotation
	: 	'.annotation' visibility=ANN_VISIBLE type=OBJECT_TYPE
		(sAnnotationKeyName '=' sAnnotationValue)*
		 '.end annotation'
	;
sSubannotation
	:	'.subannotation' type=OBJECT_TYPE (sAnnotationKeyName '=' sAnnotationValue )* '.end subannotation'
	;
sParameter
	:	parameter=DPARAMETER (name=STRING)?  ( (sAnnotation)* '.end parameter')?
		| param=DPARAM r=REGISTER (',' name=STRING )? (sAnnotation* '.end param')?
	;
sAnnotationKeyName
	:	PRIMITIVE_TYPE |VOID_TYPE
        	|ANN_VISIBLE|REGISTER|BOOLEAN|ID | NULL
        	|FLOAT_INFINITY|DOUBLE_INFINITY|FLOAT_NAN|DOUBLE_NAN
        	|NOP|MOVE|RETURN|CONST|THROW|GOTO|AGET|APUT|IGET|IPUT|SGET|SPUT|ACC;
sAnnotationValue
	:sSubannotation
	|sBaseValue
	|sArrayValue
	| method_handler
	;// field,method,array,subannotation
sBaseValue
	:STRING
	|BOOLEAN|BYTE|SHORT|CHAR|INT|LONG
	|BASE_FLOAT| FLOAT_INFINITY | FLOAT_NAN
	|BASE_DOUBLE|DOUBLE_INFINITY|DOUBLE_NAN
	|METHOD_FULL
	|METHOD_PROTO
	|OBJECT_TYPE
	|ARRAY_TYPE
	|PRIMITIVE_TYPE
	|VOID_TYPE
	|NULL
	|DENUM FIELD_FULL
	;
sArrayValue: '{' sAnnotationValue? (',' sAnnotationValue)* '}';

method_handler
    : type=('static-get'|'static-put'|'instance-get'|'instance-put') '@' fld=FIELD_FULL
    | type=('invoke-static'|'invoke-instance'|'invoke-direct'|'invoke-interface'|'invoke-constructor') '@' mtd=METHOD_FULL
    ;

// FIXME samli syntax only write out method_handler's method field
call_site
    : name=sAnnotationKeyName '(' method_name=STRING ',' method_type=METHOD_PROTO (',' sBaseValue)* ')' '@' bsm=METHOD_FULL
    ;

sInstruction
    :fline
    |flocal
    |fend
    |frestart
    |fprologue
    |fepiogue
    |fregisters
	|flocals
	|fcache
	|fcacheall
	|f0x
	|f0t
	|f1t
	|f2t
	|f1x
	|fconst
	|ft2c
	|ff1c
	|ff2c
	|f2x
	|f3x
	|ft5c
	|fm5c
	|fmrc
	|fm45cc
	|fm4rcc
	|fmcustomc
	|fmcustomrc
	|ftrc
	|sLabel
	|f2sb
	|f31t
	|fpackageswitch
	|fspareswitch
	|farraydata
	;
fline:'.line' line=INT;
flocal:'.local' r=REGISTER ','
            (
                    (name1=sAnnotationKeyName |  name2=STRING) ':' type=(OBJECT_TYPE | PRIMITIVE_TYPE | ARRAY_TYPE) // normal case
                |   v1=FIELD_PART // smali 1.x
                |   v2=SMALI_V2_LOCAL_NAME_TYPE // smali 2.x
            )
         (',' sig=STRING)?
        ;
fend:'.end local' r=REGISTER;
frestart:'.restart local'  r=REGISTER;
fprologue:'.prologue';
fepiogue:'.epiogue';
fregisters:'.registers' xregisters=INT;
flocals: '.locals' xlocals=INT;
fcache:'.catch' type=OBJECT_TYPE '{' start=LABEL '..' end=LABEL  '}' handle=LABEL;
fcacheall:'.catchall' '{' start=LABEL '..' end=LABEL  '}' handle=LABEL;
sLabel: label=LABEL;
fpackageswitch:'.packed-switch' start=INT LABEL+ '.end packed-switch';
fspareswitch:'.sparse-switch' (INT '->' LABEL)* '.end sparse-switch';
farraydata:'.array-data' size=INT (sBaseValue)+ '.end array-data';
f0x	:	op=(NOP
	|	'return-void')
	;
f0t	:	op=(GOTO|'goto/16'|'goto/32') target=LABEL
	;
f1x	:	op=('move-result'|'move-result-wide'|'move-result-object'
	|	'move-exception'
	|	RETURN|'return-wide'|'return-object'
	|	THROW
	|	'monitor-enter' | 'monitor-exit' ) r1=REGISTER
	;
fconst
    : op=('const/4'|'const/16'|CONST|'const/high16'|'const-wide/16'|'const-wide/32'|'const-wide/high16'|'const-wide')
                                                      r1=REGISTER ',' cst=(INT|LONG)
	| op=('const-string'|'const-string/jumbo')        r1=REGISTER ','  cst=STRING
    | op=('const-class'|'check-cast'|'new-instance')  r1=REGISTER ','  cst=(OBJECT_TYPE|ARRAY_TYPE)
    | op='const-method-type'  r1=REGISTER ',' cst=METHOD_PROTO
    | op='const-method-handle'  r1=REGISTER ',' h=method_handler
	;
ff1c	:	op=(SGET
	|'sget-wide'
	|'sget-object'
	|'sget-boolean'
	|'sget-byte'
	|'sget-char'
	|'sget-short'
	|SPUT
	|'sput-wide'
	|'sput-object'
	|'sput-boolean'
	|'sput-byte'
	|'sput-char'
	|'sput-short' ) r1=REGISTER ',' fld=FIELD_FULL
	;
ft2c	:	op=('instance-of'|'new-array') r1=REGISTER ',' r2=REGISTER ',' type=(OBJECT_TYPE|ARRAY_TYPE);
ff2c	:	op=(IGET
	|'iget-wide'
	|'iget-object'
	|'iget-boolean'
	|'iget-byte'
	|'iget-char'
	|'iget-short'
	|	IPUT
	|'iput-wide'
	|'iput-object'
	|'iput-boolean'
	|'iput-byte'
	|'iput-char'
	|'iput-short' ) r1=REGISTER ',' r2=REGISTER ',' fld=FIELD_FULL
	;
f2x	:	op=(MOVE|'move/from16'|'move/16'
	|	'move-wide'|'move-wide/from16'|'move-wide/16'
	|	'move-object'|'move-object/from16'|'move-object/16'
	|	'array-length'
	|'neg-int'
|'not-int'
|'neg-long'
|'not-long'
|'neg-float'
|'neg-double'
|'int-to-long'
|'int-to-float'
|'int-to-double'
|'long-to-int'
|'long-to-float'
|'long-to-double'
|'float-to-int'
|'float-to-long'
|'float-to-double'
|'double-to-int'
|'double-to-long'
|'double-to-float'
|'int-to-byte'
|'int-to-char'
|'int-to-short'
|'add-int/2addr'
|'sub-int/2addr'
|'mul-int/2addr'
|'div-int/2addr'
|'rem-int/2addr'
|'and-int/2addr'
|'or-int/2addr'
|'xor-int/2addr'
|'shl-int/2addr'
|'shr-int/2addr'
|'ushr-int/2addr'
|'add-long/2addr'
|'sub-long/2addr'
|'mul-long/2addr'
|'div-long/2addr'
|'rem-long/2addr'
|'and-long/2addr'
|'or-long/2addr'
|'xor-long/2addr'
|'shl-long/2addr'
|'shr-long/2addr'
|'ushr-long/2addr'
|'add-float/2addr'
|'sub-float/2addr'
|'mul-float/2addr'
|'div-float/2addr'
|'rem-float/2addr'
|'add-double/2addr'
|'sub-double/2addr'
|'mul-double/2addr'
|'div-double/2addr'
|'rem-double/2addr') r1=REGISTER ',' r2=REGISTER
	;
f3x	:	op=('cmpl-float'|'cmpg-float'|'cmpl-double'|'cmpg-double'|'cmp-long'
	|	AGET|'aget-wide'|'aget-object'|'aget-boolean'|'aget-byte'|'aget-char'|'aget-short'
	|	APUT|'aput-wide'|'aput-object'|'aput-boolean'|'aput-byte'|'aput-char'|'aput-short'
	|'add-int'
|'sub-int'
|'mul-int'
|'div-int'
|'rem-int'
|'and-int'
|'or-int'
|'xor-int'
|'shl-int'
|'shr-int'
|'ushr-int'
|'add-long'
|'sub-long'
|'mul-long'
|'div-long'
|'rem-long'
|'and-long'
|'or-long'
|'xor-long'
|'shl-long'
|'shr-long'
|'ushr-long'
|'add-float'
|'sub-float'
|'mul-float'
|'div-float'
|'rem-float'
|'add-double'
|'sub-double'
|'mul-double'
|'div-double'
|'rem-double') r1=REGISTER ',' r2=REGISTER ',' r3=REGISTER
	;
ft5c	:	op='filled-new-array' '{' (REGISTER (',' REGISTER)* )? '}' ',' type=ARRAY_TYPE;
fm5c	:	op=('invoke-virtual'|'invoke-super'|'invoke-direct'
              |'invoke-static'|'invoke-interface'
            )  '{' (REGISTER (',' REGISTER)* )? '}' ',' method=METHOD_FULL
	;
fmrc	:	op=('invoke-virtual/range'|'invoke-super/range'
              |'invoke-direct/range'|'invoke-static/range'
              |'invoke-interface/range'
            )  '{' (rstart=REGISTER '..' rend=REGISTER)? '}' ',' method=METHOD_FULL
	;
fm45cc	:	op='invoke-polymorphic'  '{' (REGISTER (',' REGISTER)* )? '}' ',' method=METHOD_FULL ',' proto=METHOD_PROTO
	;
fm4rcc	:	op='invoke-polymorphic/range'  '{' (rstart=REGISTER '..' rend=REGISTER)? '}' ',' method=METHOD_FULL ',' proto=METHOD_PROTO
	;
fmcustomc	:	op='invoke-custom'  '{' (REGISTER (',' REGISTER)* )? '}' ',' call_site
	;
fmcustomrc	:	op='invoke-custom/range'  '{' (rstart=REGISTER '..' rend=REGISTER)? '}' ',' call_site
	;
ftrc	:	op='filled-new-array/range' '{' (rstart=REGISTER '..' rend=REGISTER)? '}' ',' type=(OBJECT_TYPE|ARRAY_TYPE);
f31t: op=('fill-array-data'|'packed-switch'|'sparse-switch') r1=REGISTER ',' label=LABEL;
f1t	:op=('if-eqz'|'if-nez'|'if-ltz'|'if-gez'|'if-gtz'|'if-lez')  r1=REGISTER ',' label=LABEL
	;
f2t	:op=('if-eq'|'if-ne'|'if-lt'|'if-ge'|'if-gt'|'if-le') r1=REGISTER ',' r2=REGISTER ',' label=LABEL
	;
f2sb	:op=('add-int/lit16'|'rsub-int'|'mul-int/lit16'|'div-int/lit16'|'rem-int/lit16'|'and-int/lit16'
             |'or-int/lit16'|'xor-int/lit16'|'add-int/lit8'|'rsub-int/lit8'|'mul-int/lit8'
             |'div-int/lit8'|'rem-int/lit8'|'and-int/lit8'|'or-int/lit8'|'xor-int/lit8'|'shl-int/lit8'|'shr-int/lit8'
             |'ushr-int/lit8'
          ) r1=REGISTER ',' r2=REGISTER ',' lit=INT
	;
```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/AntlrSmaliUtil.java`:

```java
package com.googlecode.d2j.smali;

import com.googlecode.d2j.*;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.smali.antlr4.SmaliBaseVisitor;
import com.googlecode.d2j.smali.antlr4.SmaliLexer;
import com.googlecode.d2j.smali.antlr4.SmaliParser;
import com.googlecode.d2j.visitors.*;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.googlecode.d2j.smali.Utils.*;

public class AntlrSmaliUtil {
    public static void acceptFile(SmaliParser.SFileContext ctx, DexFileVisitor dexFileVisitor) {
        DexClassVisitor dexClassVisitor;
        String className = Utils.unEscapeId(ctx.className.getText());
        int access = collectAccess(ctx.sAccList());
        List<SmaliParser.SSuperContext> superContexts = ctx.sSuper();
        String superClass = null;
        if (superContexts.size() > 0) {
            superClass = Utils.unEscapeId(superContexts.get(superContexts.size() - 1).name.getText());
        }
        List<SmaliParser.SInterfaceContext> itfs = ctx.sInterface();
        String[] interfaceNames = null;
        if (itfs.size() > 0) {
            interfaceNames = new String[itfs.size()];
            for (int i = 0; i < itfs.size(); i++) {
                interfaceNames[i] = Utils.unEscapeId(itfs.get(i).name.getText());
            }
        }

        dexClassVisitor = dexFileVisitor.visit(access, className, superClass, interfaceNames);

        List<SmaliParser.SSourceContext> sources = ctx.sSource();
        if (sources.size() > 0) {
            dexClassVisitor.visitSource(
                    Utils.unescapeStr(sources.get(sources.size() - 1).src.getText())
            );
        }
        acceptAnnotations(ctx.sAnnotation(), dexClassVisitor);
        acceptField(ctx.sField(), className, dexClassVisitor);
        acceptMethod(ctx.sMethod(), className, dexClassVisitor);

        dexClassVisitor.visitEnd();
    }

    private static void acceptMethod(List<SmaliParser.SMethodContext> sMethodContexts, String className, DexClassVisitor dexClassVisitor) {
        if (dexClassVisitor == null || sMethodContexts == null || sMethodContexts.size() == 0) {
            return;
        }
        for (SmaliParser.SMethodContext ctx : sMethodContexts) {
            acceptMethod(ctx, className, dexClassVisitor);
        }
    }

    public static void acceptMethod(SmaliParser.SMethodContext ctx, String className, DexClassVisitor dexClassVisitor) {
        Method method;
        Token methodObj = ctx.methodObj;
        if (methodObj.getType() == SmaliLexer.METHOD_FULL) {
            method = Utils.parseMethodAndUnescape(methodObj.getText());
        } else {// PART
            method = Utils.parseMethodAndUnescape(className, methodObj.getText());
        }
        int access = collectAccess(ctx.sAccList());
        boolean isStatic = 0 != (access & DexConstants.ACC_STATIC);
        DexMethodVisitor dexMethodVisitor = dexClassVisitor.visitMethod(access, method);
        if (dexMethodVisitor != null) {
            acceptAnnotations(ctx.sAnnotation(), dexMethodVisitor);
            int ins = Utils.methodIns(method, isStatic);
            int totalRegisters = findTotalRegisters(ctx, ins);
            if (totalRegisters < 0) {
                totalRegisters = ins;
            }
            M m = new M(method, totalRegisters, ins, isStatic);
            acceptParameter(ctx.sParameter(), m, dexMethodVisitor);
            acceptCode(ctx, m, dexMethodVisitor);
            dexMethodVisitor.visitEnd();
        }
    }

    private static class M {
        int locals;
        String[] paramNames;
        int[] map;
        public int total;

        void setNameByIdx(int index, String name) {
            if (index >= 0 && index < paramNames.length) {
                paramNames[index] = name;
            }
        }

        int regToParamIdx(int reg) {
            int x = reg - locals;
            if (x >= 0 && x < map.length) {
                return map[x];
            }
            return 0;
        }

        int pareReg(String str) {
            char f = Character.toLowerCase(str.charAt(0));
            if (f == 'p') {
                return parseInt(str.substring(1)) + locals;
            } else {
                return parseInt(str.substring(1));
            }
        }

        M(Method method, int totals, int ins, boolean isStatic) {
            this.locals = totals - ins;
            this.total = totals;
            String[] paramTypes = method.getParameterTypes();
            paramNames = new String[paramTypes.length];
            map = new int[ins];
            int start = 0;
            if (!isStatic) {
                map[start] = -1;
                start++;
            }

            for (int i = 0; i < paramTypes.length; i++) {
                char t = paramTypes[i].charAt(0);
                map[start++] = i;
                if (t == 'J' || t == 'D') {
                    map[start++] = i;
                }
            }
        }
    }

    private static void acceptCode(SmaliParser.SMethodContext ctx, final M m, DexMethodVisitor dexMethodVisitor) {
        if (ctx == null || dexMethodVisitor == null) {
            return;
        }
        final DexCodeVisitor dexCodeVisitor = dexMethodVisitor.visitCode();
        if (dexCodeVisitor == null) {
            return;
        }
        final SmaliCodeVisitor scv = new SmaliCodeVisitor(dexCodeVisitor);
        final DexDebugVisitor dexDebugVisitor = scv.visitDebug();
        final List<SmaliParser.SInstructionContext> instructionContexts = ctx.sInstruction();
        final SmaliBaseVisitor v = new SmaliBaseVisitor() {
            @Override
            public Object visitFregisters(SmaliParser.FregistersContext ctx) {
                return null;
            }

            @Override
            public Object visitFlocals(SmaliParser.FlocalsContext ctx) {
                return null;
            }

            @Override
            public Object visitFline(SmaliParser.FlineContext ctx) {
                if (dexDebugVisitor != null) {
                    DexLabel dexLabel = new DexLabel();
                    scv.visitLabel(dexLabel);
                    dexDebugVisitor.visitLineNumber(Utils.parseInt(ctx.line.getText()), dexLabel);
                }
                return null;
            }

            @Override
            public Object visitFend(SmaliParser.FendContext ctx) {
                if (dexDebugVisitor != null) {
                    DexLabel dexLabel = new DexLabel();
                    scv.visitLabel(dexLabel);
                    int reg = m.pareReg(ctx.r.getText());
                    dexDebugVisitor.visitEndLocal(reg, dexLabel);
                }
                return null;
            }

            @Override
            public Object visitFlocal(SmaliParser.FlocalContext ctx) {
                if (dexDebugVisitor != null) {
                    DexLabel dexLabel = new DexLabel();
                    scv.visitLabel(dexLabel);
                    int reg = m.pareReg(ctx.r.getText());
                    String name;
                    String type;
                    if (ctx.v1 != null) {
                        Field fld = parseFieldAndUnescape("Lt;", ctx.v1.getText());
                        name = fld.getName();
                        type = fld.getType();
                    } else if (ctx.v2 != null) {
                        String txt = ctx.v2.getText();
                        int i = findString(txt, 1, txt.length(), '\"');
                        name = unescapeStr(txt.substring(0, i + 1));
                        type = unEscapeId(txt.substring(i + 2));
                    } else {
                        if (ctx.name2 != null) {
                            name = unescapeStr(ctx.name2.getText());
                        } else {
                            name = unEscapeId(ctx.name1.getText());
                        }
                        type = unEscapeId(ctx.type.getText());
                    }
                    String sig = ctx.sig == null ? null : unescapeStr(ctx.sig.getText());
                    dexDebugVisitor.visitStartLocal(reg, dexLabel, name, type, sig);
                }
                return null;
            }

            @Override
            public Object visitFrestart(SmaliParser.FrestartContext ctx) {
                if (dexDebugVisitor != null) {
                    DexLabel dexLabel = new DexLabel();
                    scv.visitLabel(dexLabel);
                    int reg = m.pareReg(ctx.r.getText());
                    dexDebugVisitor.visitRestartLocal(reg, dexLabel);
                }
                return null;
            }

            @Override
            public Object visitFprologue(SmaliParser.FprologueContext ctx) {
                if (dexDebugVisitor != null) {
                    DexLabel dexLabel = new DexLabel();
                    scv.visitLabel(dexLabel);
                    dexDebugVisitor.visitPrologue(dexLabel);
                }
                return null;
            }

            Map<String, DexLabel> labelMap = new HashMap<>();

            @Override
            public Object visitSLabel(SmaliParser.SLabelContext ctx) {
                scv.visitLabel(getLabel(ctx.label.getText()));
                return null;
            }

            @Override
            public Object visitFspareswitch(SmaliParser.FspareswitchContext ctx) {
                List<TerminalNode> ints = ctx.INT();
                List<TerminalNode> ts = ctx.LABEL();
                int[] cases = new int[ts.size()];
                DexLabel[] labels = new DexLabel[ts.size()];
                for (int i = 0; i < ts.size(); i++) {
                    cases[i] = parseInt(ints.get(i).getSymbol().getText());
                    labels[i] = getLabel(ts.get(i).getSymbol().getText());
                }
                scv.dSparseSwitch(cases, labels);
                return null;
            }

            @Override
            public Object visitFarraydata(SmaliParser.FarraydataContext ctx) {
                int size = parseInt(ctx.size.getText());
                List<SmaliParser.SBaseValueContext> ts = ctx.sBaseValue();
                byte[] ps = new byte[ts.size()];
                for (int i = 0; i < ts.size(); i++) {
                    ps[i] = ((Number) parseBaseValue(ts.get(i))).byteValue();
                }
                scv.dArrayData(size, ps);
                return null;
            }

            Op getOp(Token t) {
                return Utils.getOp(t.getText());
            }

            @Override
            public Object visitF0x(SmaliParser.F0xContext ctx) {
                scv.visitStmt0R(getOp(ctx.op));
                return null;
            }

            @Override
            public Object visitF0t(SmaliParser.F0tContext ctx) {
                scv.visitJumpStmt(getOp(ctx.op), 0, 0, getLabel(ctx.target.getText()));
                return null;
            }

            @Override
            public Object visitF1x(SmaliParser.F1xContext ctx) {
                scv.visitStmt1R(getOp(ctx.op), m.pareReg(ctx.r1.getText()));
                return null;
            }

            @Override
            public Object visitFconst(SmaliParser.FconstContext ctx) {
                Op op = getOp(ctx.op);
                int r = m.pareReg(ctx.r1.getText());
                Token cst = ctx.cst;

                switch (op) {
                    case CONST_STRING:
                    case CONST_STRING_JUMBO:
                        scv.visitConstStmt(op, r, unescapeStr(cst.getText()));
                        break;
                    case CONST_CLASS:
                        scv.visitConstStmt(op, r, new DexType(unEscapeId(cst.getText())));
                        break;
                    case CHECK_CAST:
                    case NEW_INSTANCE:
                        scv.visitTypeStmt(op, r, 0, unEscapeId(cst.getText()));
                        break;
                    case CONST_WIDE:
                        scv.visitConstStmt(op, r, cst.getType() == SmaliLexer.INT ? ((long) parseInt(cst.getText())) : parseLong(cst.getText()));
                        break;
                    case CONST_WIDE_16: {
                        long v;
                        if (cst.getType() == SmaliLexer.LONG) {
                            v = parseLong(cst.getText());
                        } else {

                            v = (short) parseInt(cst.getText());
                        }
                        scv.visitConstStmt(op, r, v);
                    }
                    break;
                    case CONST_WIDE_32: {
                        long v;
                        if (cst.getType() == SmaliLexer.LONG) {
                            v = parseLong(cst.getText());
                        } else {
                            v = parseInt(cst.getText());
                        }
                        scv.visitConstStmt(op, r, v);
                    }
                    break;
                    case CONST_WIDE_HIGH16: {
                        long v;
                        if (cst.getType() == SmaliLexer.LONG) {
                            v = parseLong(cst.getText());
                        } else {
                            v = (short) parseInt(cst.getText());
                            v <<= 48;
                        }
                        scv.visitConstStmt(op, r, v);
                    }
                    break;
                    case CONST:
                    case CONST_4:
                    case CONST_16: {
                        int v = parseInt(cst.getText());
                        scv.visitConstStmt(op, r, v);
                    }
                    break;
                    case CONST_HIGH16: {
                        int v = parseInt(cst.getText());
                        v <<= 16;
                        scv.visitConstStmt(op, r, v);
                    }
                    break;
                    case CONST_METHOD_HANDLE:
                        scv.visitConstStmt(op, r, parseMethodHandler(ctx.h));
                        break;
                    case CONST_METHOD_TYPE:
                        scv.visitConstStmt(op, r, parseProtoAndUnescape(ctx.cst.getText()));
                        break;
                    default:
                        throw new RuntimeException();
                }
                return null;
            }

            @Override
            public Object visitFf1c(SmaliParser.Ff1cContext ctx) {
                int r = m.pareReg(ctx.r1.getText());
                Field field = parseFieldAndUnescape(ctx.fld.getText());
                scv.visitFieldStmt(getOp(ctx.op), r, 0, field);
                return null;
            }

            @Override
            public Object visitFt2c(SmaliParser.Ft2cContext ctx) {
                int r1 = m.pareReg(ctx.r1.getText());
                int r2 = m.pareReg(ctx.r2.getText());
                scv.visitTypeStmt(getOp(ctx.op), r1, r2, unEscapeId(ctx.type.getText()));
                return null;
            }

            @Override
            public Object visitFf2c(SmaliParser.Ff2cContext ctx) {
                int r1 = m.pareReg(ctx.r1.getText());
                int r2 = m.pareReg(ctx.r2.getText());
                scv.visitFieldStmt(getOp(ctx.op), r1, r2, parseFieldAndUnescape(ctx.fld.getText()));
                return null;
            }

            @Override
            public Object visitF2x(SmaliParser.F2xContext ctx) {
                int r1 = m.pareReg(ctx.r1.getText());
                int r2 = m.pareReg(ctx.r2.getText());
                scv.visitStmt2R(getOp(ctx.op), r1, r2);
                return null;
            }

            @Override
            public Object visitF3x(SmaliParser.F3xContext ctx) {
                int r1 = m.pareReg(ctx.r1.getText());
                int r2 = m.pareReg(ctx.r2.getText());
                int r3 = m.pareReg(ctx.r3.getText());
                scv.visitStmt3R(getOp(ctx.op), r1, r2, r3);
                return null;
            }

            @Override
            public Object visitFt5c(SmaliParser.Ft5cContext ctx) {
                Op op = getOp(ctx.op);

                List<TerminalNode> ts = ctx.REGISTER();
                int[] rs = new int[ts.size()];
                for (int i = 0; i < ts.size(); i++) {
                    rs[i] = m.pareReg(ts.get(i).getSymbol().getText());
                }
                scv.visitFilledNewArrayStmt(op, rs, unEscapeId(ctx.type.getText()));
                return null;
            }

            @Override
            public Object visitFm5c(SmaliParser.Fm5cContext ctx) {
                Op op = getOp(ctx.op);

                List<TerminalNode> ts = ctx.REGISTER();
                int[] rs = new int[ts.size()];
                for (int i = 0; i < ts.size(); i++) {
                    rs[i] = m.pareReg(ts.get(i).getSymbol().getText());
                }
                scv.visitMethodStmt(op, rs, parseMethodAndUnescape(ctx.method.getText()));
                return null;
            }

            @Override
            public Object visitFm4rcc(SmaliParser.Fm4rccContext ctx) {
                if (ctx.rstart != null) {
                    int start = m.pareReg(ctx.rstart.getText());
                    int end = m.pareReg(ctx.rend.getText());
                    int size = end - start + 1;
                    int[] rs = new int[size];
                    for (int i = 0; i < size; i++) {
                        rs[i] = start + i;
                    }
                    scv.visitMethodStmt(getOp(ctx.op), rs, parseMethodAndUnescape(ctx.method.getText()), parseProtoAndUnescape(ctx.proto.getText()));
                } else {
                    scv.visitMethodStmt(getOp(ctx.op), new int[0], parseMethodAndUnescape(ctx.method.getText()), parseProtoAndUnescape(ctx.proto.getText()));
                }
                return null;
            }

            @Override
            public Object visitFm45cc(SmaliParser.Fm45ccContext ctx) {
                Op op = getOp(ctx.op);
                List<TerminalNode> ts = ctx.REGISTER();
                int[] rs = new int[ts.size()];
                for (int i = 0; i < ts.size(); i++) {
                    rs[i] = m.pareReg(ts.get(i).getSymbol().getText());
                }
                scv.visitMethodStmt(op, rs, parseMethodAndUnescape(ctx.method.getText()), parseProtoAndUnescape(ctx.proto.getText()));
                return null;
            }

            @Override
            public Object visitFmcustomc(SmaliParser.FmcustomcContext ctx) {
                Op op = getOp(ctx.op);

                List<TerminalNode> ts = ctx.REGISTER();
                int[] rs = new int[ts.size()];
                for (int i = 0; i < ts.size(); i++) {
                    rs[i] = m.pareReg(ts.get(i).getSymbol().getText());
                }
                scv.visitMethodStmt(op, rs, parseCallSite(ctx.call_site()));
                return null;
            }

            @Override
            public Object visitFmcustomrc(SmaliParser.FmcustomrcContext ctx) {
                if (ctx.rstart != null) {
                    int start = m.pareReg(ctx.rstart.getText());
                    int end = m.pareReg(ctx.rend.getText());
                    int size = end - start + 1;
                    int[] rs = new int[size];
                    for (int i = 0; i < size; i++) {
                        rs[i] = start + i;
                    }
                    scv.visitMethodStmt(getOp(ctx.op), rs, parseCallSite(ctx.call_site()));
                } else {
                    scv.visitMethodStmt(getOp(ctx.op), new int[0], parseCallSite(ctx.call_site()));
                }
                return null;
            }

            @Override
            public Object visitFmrc(SmaliParser.FmrcContext ctx) {
                if (ctx.rstart != null) {
                    int start = m.pareReg(ctx.rstart.getText());
                    int end = m.pareReg(ctx.rend.getText());
                    int size = end - start + 1;
                    int[] rs = new int[size];
                    for (int i = 0; i < size; i++) {
                        rs[i] = start + i;
                    }
                    scv.visitMethodStmt(getOp(ctx.op), rs, parseMethodAndUnescape(ctx.method.getText()));
                } else {
                    scv.visitMethodStmt(getOp(ctx.op), new int[0], parseMethodAndUnescape(ctx.method.getText()));
                }
                return null;
            }

            @Override
            public Object visitFtrc(SmaliParser.FtrcContext ctx) {
                if (ctx.rstart != null) {
                    int start = m.pareReg(ctx.rstart.getText());
                    int end = m.pareReg(ctx.rend.getText());
                    int size = end - start + 1;
                    int[] rs = new int[size];
                    for (int i = 0; i < size; i++) {
                        rs[i] = start + i;
                    }
                    scv.visitFilledNewArrayStmt(getOp(ctx.op), rs, unEscapeId(ctx.type.getText()));
                } else {
                    scv.visitFilledNewArrayStmt(getOp(ctx.op), new int[0], unEscapeId(ctx.type.getText()));
                }
                return null;
            }

            @Override
            public Object visitF31t(SmaliParser.F31tContext ctx) {
                scv.visitF31tStmt(getOp(ctx.op), m.pareReg(ctx.r1.getText()), getLabel(ctx.label.getText()));
                return null;
            }

            @Override
            public Object visitF1t(SmaliParser.F1tContext ctx) {
                scv.visitJumpStmt(getOp(ctx.op), m.pareReg(ctx.r1.getText()), 0, getLabel(ctx.label.getText()));
                return null;
            }

            @Override
            public Object visitF2t(SmaliParser.F2tContext ctx) {
                scv.visitJumpStmt(getOp(ctx.op), m.pareReg(ctx.r1.getText()), m.pareReg(ctx.r2.getText()), getLabel(ctx.label.getText()));
                return null;
            }

            @Override
            public Object visitF2sb(SmaliParser.F2sbContext ctx) {
                scv.visitStmt2R1N(getOp(ctx.op), m.pareReg(ctx.r1.getText()), m.pareReg(ctx.r2.getText()), parseInt(ctx.lit.getText()));
                return null;
            }

            @Override
            public Object visitFpackageswitch(SmaliParser.FpackageswitchContext ctx) {
                int start = parseInt(ctx.start.getText());
                List<TerminalNode> ts = ctx.LABEL();
                DexLabel[] labels = new DexLabel[ts.size()];
                for (int i = 0; i < ts.size(); i++) {
                    labels[i] = getLabel(ts.get(i).getSymbol().getText());
                }
                scv.dPackedSwitch(start, labels);
                return null;
            }

            @Override
            public Object visitFcache(SmaliParser.FcacheContext ctx) {
                scv.visitTryCatch(getLabel(ctx.start.getText()), getLabel(ctx.end.getText()),
                        new DexLabel[]{getLabel(ctx.handle.getText())},
                        new String[]{unEscapeId(ctx.type.getText())}
                );
                return null;
            }

            @Override
            public Object visitFcacheall(SmaliParser.FcacheallContext ctx) {
                scv.visitTryCatch(getLabel(ctx.start.getText()), getLabel(ctx.end.getText()),
                        new DexLabel[]{getLabel(ctx.handle.getText())},
                        new String[]{null}
                );
                return null;
            }

            DexLabel getLabel(String name) {
                DexLabel dexLabel = labelMap.get(name);
                if (dexLabel == null) {
                    dexLabel = new DexLabel();
                    labelMap.put(name, dexLabel);
                }
                return dexLabel;
            }

            @Override
            public Object visitFepiogue(SmaliParser.FepiogueContext ctx) {
                if (dexDebugVisitor != null) {
                    DexLabel dexLabel = new DexLabel();
                    scv.visitLabel(dexLabel);
                    dexDebugVisitor.visitEpiogue(dexLabel);
                }
                return null;
            }
        };
        scv.visitRegister(m.total);
        if (dexDebugVisitor != null) {
            for (int i = 0; i < m.paramNames.length; i++) {
                String name = m.paramNames[i];
                if (name != null) {
                    dexDebugVisitor.visitParameterName(i, name);
                }
            }
        }
        for (SmaliParser.SInstructionContext instructionContext : instructionContexts) {
            ParserRuleContext parserRuleContext = (ParserRuleContext) instructionContext.getChild(0);
            parserRuleContext.accept(v);
        }
        scv.visitEnd();
    }

    private static CallSite parseCallSite(SmaliParser.Call_siteContext callSiteContext) {

        List<SmaliParser.SBaseValueContext> sBaseValueContexts = callSiteContext.sBaseValue();
        Object[] args = new Object[sBaseValueContexts.size()];
        int i = 0;
        for (SmaliParser.SBaseValueContext baseValueContext : sBaseValueContexts) {
            args[i] = parseBaseValue(baseValueContext);
            i++;
        }

        return new CallSite(
                unEscapeId(callSiteContext.name.getText()),
                new MethodHandle(MethodHandle.INVOKE_STATIC, parseMethodAndUnescape(callSiteContext.bsm.getText())),
                unescapeStr(callSiteContext.method_name.getText()),
                parseProtoAndUnescape(callSiteContext.method_type.getText()),
                args
        );
    }

    private static MethodHandle parseMethodHandler(SmaliParser.Method_handlerContext methodHandlerContext) {
        MethodHandle value;
        switch (methodHandlerContext.type.getText()) {
            case "static-get":
                value = new MethodHandle(MethodHandle.STATIC_GET, parseFieldAndUnescape(methodHandlerContext.fld.getText()));
                break;
            case "static-put":
                value = new MethodHandle(MethodHandle.STATIC_PUT, parseFieldAndUnescape(methodHandlerContext.fld.getText()));
                break;
            case "instance-get":
                value = new MethodHandle(MethodHandle.INSTANCE_GET, parseFieldAndUnescape(methodHandlerContext.fld.getText()));
                break;
            case "instance-put":
                value = new MethodHandle(MethodHandle.INSTANCE_PUT, parseFieldAndUnescape(methodHandlerContext.fld.getText()));
                break;
            case "invoke-static":
                value = new MethodHandle(MethodHandle.INVOKE_STATIC, parseMethodAndUnescape(methodHandlerContext.mtd.getText()));
                break;
            case "invoke-instance":
                value = new MethodHandle(MethodHandle.INVOKE_INSTANCE, parseMethodAndUnescape(methodHandlerContext.mtd.getText()));
                break;
            case "invoke-direct":
                value = new MethodHandle(MethodHandle.INVOKE_DIRECT, parseMethodAndUnescape(methodHandlerContext.mtd.getText()));
                break;
            case "invoke-interface":
                value = new MethodHandle(MethodHandle.INVOKE_INTERFACE, parseMethodAndUnescape(methodHandlerContext.mtd.getText()));
                break;
            case "invoke-constructor":
                value = new MethodHandle(MethodHandle.INVOKE_CONSTRUCTOR, parseMethodAndUnescape(methodHandlerContext.mtd.getText()));
                break;
            default:
                throw new RuntimeException("not support yet: " + methodHandlerContext.type);
        }
        return value;
    }

    private static int findTotalRegisters(SmaliParser.SMethodContext ctx, int ins) {
        int totalRegisters = -1;
        List<SmaliParser.SInstructionContext> instructionContexts = ctx.sInstruction();
        for (SmaliParser.SInstructionContext instructionContext : instructionContexts) {
            ParserRuleContext parserRuleContext = (ParserRuleContext) instructionContext.getChild(0);
            if (parserRuleContext != null) {
                int ruleIndex = parserRuleContext.getRuleIndex();
                if (ruleIndex == SmaliParser.RULE_fregisters) {
                    totalRegisters = parseInt(((SmaliParser.FregistersContext) parserRuleContext).xregisters.getText());
                    break;
                } else if (ruleIndex == SmaliParser.RULE_flocals) {
                    totalRegisters = ins + parseInt(((SmaliParser.FlocalsContext) parserRuleContext).xlocals.getText());
                    break;
                }
            }
        }
        return totalRegisters;
    }

    private static void acceptParameter(List<SmaliParser.SParameterContext> sParameterContexts, M m, DexMethodVisitor dexMethodVisitor) {
        if (sParameterContexts == null || sParameterContexts.size() == 0 || dexMethodVisitor == null) {
            return;
        }
        boolean hasParam = false;
        boolean hasParamter = false;
        for (SmaliParser.SParameterContext ctx : sParameterContexts) {
            if (ctx.param != null) {
                hasParam = true;
            }
            if (ctx.parameter != null) {
                hasParamter = true;
            }
        }
        if (hasParam && hasParamter) {
            throw new RuntimeException("cant mix use .param and .parameter on method");
        }
        for (int i = 0; i < sParameterContexts.size(); i++) {
            SmaliParser.SParameterContext ctx = sParameterContexts.get(i);
            int index;
            if (ctx.param != null) {
                index = m.regToParamIdx(m.pareReg(ctx.r.getText()));
            } else {
                index = i;
            }
            if (ctx.name != null) {
                m.setNameByIdx(index, unescapeStr(ctx.name.getText()));
            }
            List<SmaliParser.SAnnotationContext> annotationContexts = ctx.sAnnotation();
            if (annotationContexts.size() > 0) {
                acceptAnnotations(annotationContexts, dexMethodVisitor.visitParameterAnnotation(index));
            }
        }


    }

    private static void acceptField(List<SmaliParser.SFieldContext> sFieldContexts, String className, DexClassVisitor dexClassVisitor) {
        if (sFieldContexts == null || sFieldContexts.size() == 0 || dexClassVisitor == null) {
            return;
        }
        for (SmaliParser.SFieldContext ctx : sFieldContexts) {
            acceptField(ctx, className, dexClassVisitor);
        }
    }

    public static void acceptField(SmaliParser.SFieldContext ctx, String className, DexClassVisitor dexClassVisitor) {
        Field field;
        Token fieldObj = ctx.fieldObj;
        if (fieldObj.getType() == SmaliLexer.FIELD_FULL) {
            field = Utils.parseFieldAndUnescape(fieldObj.getText());
        } else {
            field = Utils.parseFieldAndUnescape(className, fieldObj.getText());
        }
        int access = collectAccess(ctx.sAccList());
        Object value = null;
        SmaliParser.SBaseValueContext vctx = ctx.sBaseValue();
        if (vctx != null) {
            value = parseBaseValue(vctx);
        }
        DexFieldVisitor dexFieldVisitor = dexClassVisitor.visitField(access, field, value);
        if (dexFieldVisitor != null) {
            acceptAnnotations(ctx.sAnnotation(), dexFieldVisitor);
            dexFieldVisitor.visitEnd();
        }
    }

    private static Object parseBaseValue(SmaliParser.SBaseValueContext ctx) {
        Token value;
        if (ctx.getChildCount() == 1) {
            TerminalNode tn = (TerminalNode) ctx.getChild(0);
            value = tn.getSymbol();
        } else {
            TerminalNode tn = (TerminalNode) ctx.getChild(1);
            value = tn.getSymbol();
        }
        switch (value.getType()) {
            case SmaliLexer.STRING:
                return unescapeStr(value.getText());
            case SmaliLexer.BOOLEAN:
                return "true".equals(value.getText());
            case SmaliLexer.BYTE:
                return parseByte(value.getText());
            case SmaliLexer.SHORT:
                return parseShort(value.getText());
            case SmaliLexer.CHAR:
                return unescapeChar(value.getText());
            case SmaliLexer.INT:
                return parseInt(value.getText());
            case SmaliLexer.LONG:
                return parseLong(value.getText());

            case SmaliLexer.BASE_FLOAT:
            case SmaliLexer.FLOAT_INFINITY:
            case SmaliLexer.FLOAT_NAN:
                return parseFloat(value.getText());
            case SmaliLexer.BASE_DOUBLE:
            case SmaliLexer.DOUBLE_INFINITY:
            case SmaliLexer.DOUBLE_NAN:
                return parseDouble(value.getText());

            case SmaliLexer.METHOD_FULL:
                return parseMethodAndUnescape(value.getText());
            case SmaliLexer.OBJECT_TYPE:
                return new DexType(unEscapeId(value.getText()));
            case SmaliLexer.NULL:
                return null;
            case SmaliLexer.FIELD_FULL:
                return parseFieldAndUnescape(value.getText());
        }
        return null;
    }

    private static void acceptAnnotations(List<SmaliParser.SAnnotationContext> sAnnotationContexts, DexAnnotationAble dexAnnotationAble) {
        if (dexAnnotationAble == null) {
            return;
        }
        if (sAnnotationContexts.size() > 0) {
            for (SmaliParser.SAnnotationContext ctx : sAnnotationContexts) {
                Visibility visibility = Utils.getAnnVisibility(ctx.visibility.getText());
                String type = Utils.unEscapeId(ctx.type.getText());
                DexAnnotationVisitor dexAnnotationVisitor = dexAnnotationAble.visitAnnotation(type, visibility);
                if (dexAnnotationVisitor != null) {
                    List<SmaliParser.SAnnotationKeyNameContext> keys = ctx.sAnnotationKeyName();
                    if (keys.size() > 0) {
                        List<SmaliParser.SAnnotationValueContext> values = ctx.sAnnotationValue();
                        for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(dexAnnotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }
                    }
                    dexAnnotationVisitor.visitEnd();
                }
            }
        }
    }

    private static void acceptAnnotation(DexAnnotationVisitor dexAnnotationVisitor, String name, SmaliParser.SAnnotationValueContext ctx) {
        ParserRuleContext t = (ParserRuleContext) ctx.getChild(0);
        switch (t.getRuleIndex()) {
            case SmaliParser.RULE_sSubannotation: {
                SmaliParser.SSubannotationContext subannotationContext = (SmaliParser.SSubannotationContext) t;
                DexAnnotationVisitor annotationVisitor = dexAnnotationVisitor.visitAnnotation(name, Utils
                        .unEscapeId(subannotationContext.type.getText()));
                if (annotationVisitor != null) {
                    List<SmaliParser.SAnnotationKeyNameContext> keys = subannotationContext.sAnnotationKeyName();
                    if (keys.size() > 0) {
                        List<SmaliParser.SAnnotationValueContext> values = subannotationContext.sAnnotationValue();
                        for (int i = 0; i < keys.size(); i++) {
                            acceptAnnotation(annotationVisitor, Utils.unEscapeId(keys.get(i).getText()), values.get(i));
                        }
                    }
                    annotationVisitor.visitEnd();
                }
                break;
            }
            case SmaliParser.RULE_sArrayValue: {
                SmaliParser.SArrayValueContext arrayValueContext = (SmaliParser.SArrayValueContext) t;
                DexAnnotationVisitor annotationVisitor = dexAnnotationVisitor.visitArray(name);
                if (annotationVisitor != null) {
                    for (SmaliParser.SAnnotationValueContext annotationValueContext : arrayValueContext
                            .sAnnotationValue()) {
                        acceptAnnotation(annotationVisitor, null, annotationValueContext);
                    }
                    annotationVisitor.visitEnd();
                }
                break;
            }
            case SmaliParser.RULE_sBaseValue:
                SmaliParser.SBaseValueContext baseValueContext = (SmaliParser.SBaseValueContext) t;
                Object value = parseBaseValue(baseValueContext);
                dexAnnotationVisitor.visit(name, value);
                break;
            case SmaliParser.RULE_method_handler:
                MethodHandle methodHandle = parseMethodHandler((SmaliParser.Method_handlerContext) t);
                dexAnnotationVisitor.visit(name, methodHandle);
                break;
        }
    }


    static private int collectAccess(SmaliParser.SAccListContext ctx) {
        int access = 0;
        for (TerminalNode acc : ctx.ACC()) {
            access |= Utils.getAcc(acc.getSymbol().getText());
        }
        return access;
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/Baksmali.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.smali;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.file.Path;

import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.zip.ZipUtil;

public class Baksmali {
    private Baksmali() {
    }

    public static Baksmali from(byte[] in) throws IOException {
        return from(new DexFileReader(in));
    }

    public static Baksmali from(ByteBuffer in) throws IOException {
        return from(new DexFileReader(in));
    }

    public static Baksmali from(DexFileReader reader) {
        return new Baksmali(reader);
    }

    public static Baksmali from(File in) throws IOException {
        return from(ZipUtil.readDex(in));
    }

    public static Baksmali from(Path in) throws IOException {
        return from(ZipUtil.readDex(in));
    }

    public static Baksmali from(InputStream in) throws IOException {
        return from(ZipUtil.readDex(in));
    }

    public static Baksmali from(String in) throws IOException {
        return from(new File(in));
    }

    boolean noDebug = false;
    boolean parameterRegisters = true;
    DexFileReader reader;
    boolean useLocals = false;

    private Baksmali(DexFileReader reader) {
        this.reader = reader;
    }

    /**
     * <pre>
     * -b,--no-debug-info don't write out debug info (.local, .param, .line, etc.)
     * </pre>
     * 
     * @return
     */
    public Baksmali noDebug() {
        this.noDebug = true;
        return this;
    }

    /**
     * <pre>
     *  -p,--no-parameter-registers use the v<n> syntax instead of the p<n> syntax for registers mapped to method parameters
     * </pre>
     * 
     * @return
     */
    public Baksmali noParameterRegisters() {
        this.parameterRegisters = false;
        return this;
    }

    public void to(final File dir) {
        to(dir.toPath());
    }

    public void to(final Path base) {
        final BaksmaliDumper bs = new BaksmaliDumper(parameterRegisters, useLocals);
        reader.accept(new BaksmaliDexFileVisitor(base, bs), this.noDebug ? DexFileReader.SKIP_CODE : 0);
    }

    /**
     * <pre>
     *  -l,--use-locals output the .locals directive with the number of non-parameter registers, rather than the .register
     * </pre>
     * 
     * @return
     */
    public Baksmali useLocals() {
        this.useLocals = true;
        return this;
    }

}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/BaksmaliCmd.java`:

```java
package com.googlecode.d2j.smali;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;

import com.googlecode.dex2jar.tools.BaseCmd;
import com.googlecode.dex2jar.tools.BaseCmd.Syntax;

@Syntax(cmd = "d2j-baksmali", syntax = "[options] <dex>", desc = "disassembles and/or dumps a dex file", onlineHelp = "https://sourceforge.net/p/dex2jar/wiki/Smali")
public class BaksmaliCmd extends BaseCmd {
    @Opt(opt = "b", longOpt = "no-debug-info", hasArg = false, description = "[not impl] don't write out debug info (.local, .param, .line, etc.)")
    private boolean noDebug;
    @Opt(opt = "p", longOpt = "no-parameter-registers", hasArg = false, description = "use the v<n> syntax instead of the p<n> syntax for registers mapped to method parameters")
    private boolean noParameterRegisters;
    @Opt(opt = "l", longOpt = "use-locals", hasArg = false, description = "output the .locals directive with the number of non-parameter registers, rather than the .register")
    private boolean useLocals;
    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output dir of .smali files, default is $current_dir/[jar-name]-out/", argName = "out")
    private Path output;

    public static void main(String[] args) {
        new BaksmaliCmd().doMain(args);
    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length < 1) {
            System.err.println("ERRPR: no file to process");
            return;
        } else if (remainingArgs.length > 1) {
            System.err.println("ERRPR: too many files to process");
            return;
        }

        File dex = new File(remainingArgs[0]);
        if (!dex.exists()) {
            System.err.println("ERROR: " + dex + " doesn't exist");
            return;
        }
        if (output == null) {
            output = new File(getBaseName(dex.getName()) + "-out").toPath();
        }
        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            return;
        }
        Baksmali b = Baksmali.from(dex);
        if (noDebug) {
            b.noDebug();
        }
        if (noParameterRegisters) {
            b.noParameterRegisters();
        }
        if (useLocals) {
            b.useLocals();
        }
        System.err.println("baksmali " + dex + " -> " + output);
        b.to(output);
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/BaksmaliCodeDumper.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.smali;

import com.googlecode.d2j.*;
import com.googlecode.d2j.node.DexDebugNode;
import com.googlecode.d2j.reader.InstructionFormat;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.util.Out;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexDebugVisitor;

import java.util.*;

/*package*/class BaksmaliCodeDumper extends DexCodeVisitor {
    private boolean useParameterRegisters;
    private boolean useLocals;
    private int nextLabelNumber;
    private Out out;
    final int startParamR;
    final Set<DexLabel> usedLabel;
    final Map<DexLabel, List<DexDebugNode.DexDebugOpNode>> debugLabelMap;

    public BaksmaliCodeDumper(Out out, boolean useParameterRegisters, boolean useLocals, int nextLabelNumber,
            int startParamR, Set<DexLabel> usedLabel, Map<DexLabel, List<DexDebugNode.DexDebugOpNode>> debugLabelMap) {
        super();
        this.out = out;
        this.useParameterRegisters = useParameterRegisters;
        this.useLocals = useLocals;
        this.nextLabelNumber = nextLabelNumber;
        this.startParamR = startParamR;
        this.usedLabel = usedLabel;
        this.debugLabelMap = debugLabelMap;
    }

    static class PackedSwitchStmt {
        int first_case;

        DexLabel[] labels;

        public PackedSwitchStmt(int first_case, DexLabel[] labels) {
            super();
            this.first_case = first_case;
            this.labels = labels;
        }
    }

    static class SparseSwitchStmt {
        int[] cases;

        DexLabel[] labels;

        public SparseSwitchStmt(int[] cases, DexLabel[] labels) {
            super();
            this.cases = cases;
            this.labels = labels;
        }
    }

    List<Map.Entry<DexLabel, Object>> appendLast = new ArrayList<>();

    String reg(int rdx) {
        if (useParameterRegisters && rdx >= this.startParamR) {
            return "p" + (rdx - this.startParamR);
        }
        return "v" + rdx;
    }

    @Override
    public void visitFillArrayDataStmt(Op op, int ra, Object array) {
        DexLabel dx = new DexLabel();
        dx.displayName = "L" + nextLabelNumber++;
        usedLabel.add(dx);
        out.s("%s %s, %s", op.displayName, reg(ra), xLabel(dx));
        appendLast.add(new AbstractMap.SimpleEntry<>(dx, array));
    }

    @SuppressWarnings("incomplete-switch")
    @Override
    public void visitConstStmt(Op op, int ra, Object value) {
        switch (op) {
        case CONST_WIDE_16: {
            Long v = (Long) value;
            value = (int) v.shortValue();
            break;
        }
        case CONST_WIDE_HIGH16: {
            Long v = (Long) value;
            value = (int) ((short) (v >> 48));
            break;
        }
        case CONST_WIDE_32: {
            Long v = (Long) value;
            value = v.intValue();
            break;
        }
        case CONST_HIGH16: {
            Integer v = (Integer) value;
            value = v >> 16;
            break;
        }
        }
        out.s("%s %s, %s", op.displayName, reg(ra), BaksmaliDumper.escapeValue(value));
        super.visitConstStmt(op, ra, value);
    }

    @Override
    public void visitEnd() {
        for (Map.Entry<DexLabel, Object> e : this.appendLast) {
            visitLabel(e.getKey());
            Object v = e.getValue();
            if (v instanceof SparseSwitchStmt) {
                SparseSwitchStmt ss = (SparseSwitchStmt) v;
                out.s(".sparse-switch");
                out.push();
                for (int i = 0; i < ss.cases.length; i++) {
                    out.s("%d -> %s", ss.cases[i], xLabel(ss.labels[i]));
                }
                out.pop();
                out.s(".end sparse-switch");
            } else if (v instanceof PackedSwitchStmt) {
                PackedSwitchStmt ps = (PackedSwitchStmt) v;
                out.s(".packed-switch %d", ps.first_case);
                out.push();
                for (DexLabel label : ps.labels) {
                    out.s(xLabel(label));
                }
                out.pop();
                out.s(".end packed-switch");
            } else {
                Object array = e.getValue();
                if (array instanceof byte[]) {
                    out.s(".array-data 1");
                    out.push();
                    byte[] vs = (byte[]) array;
                    for (byte b : vs) {
                        out.s(BaksmaliDumper.escapeValue(b));
                    }
                    out.pop();
                    out.s(".end array-data");
                } else if (array instanceof short[]) {
                    out.s(".array-data 2");
                    out.push();
                    short[] vs = (short[]) array;
                    for (short a : vs) {
                        out.s("%s %s", BaksmaliDumper.escapeValue((byte) (a & 0xFF)),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 8))));
                    }
                    out.pop();
                    out.s(".end array-data");
                } else if (array instanceof int[]) {
                    out.s(".array-data 4");
                    out.push();
                    int[] vs = (int[]) array;
                    for (int a : vs) {
                        out.s("%s %s %s %s", BaksmaliDumper.escapeValue((byte) (a & 0xFF)),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 8))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 16))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 24))));
                    }
                    out.pop();
                    out.s(".end array-data");
                } else if (array instanceof float[]) {
                    out.s(".array-data 4");
                    out.push();
                    float[] vs = (float[]) array;
                    for (float value : vs) {
                        int a = Float.floatToIntBits(value);
                        out.s("%s %s %s %s", BaksmaliDumper.escapeValue((byte) (a & 0xFF)),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 8))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 16))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 24))));
                    }
                    out.pop();
                    out.s(".end array-data");
                } else if (array instanceof long[]) {
                    out.s(".array-data 8");
                    out.push();
                    long[] vs = (long[]) array;
                    for (long ttt : vs) {
                        int a = (int) ttt;
                        int b = (int) (ttt >>> 32);
                        out.s("%s %s %s %s %s %s %s %s", BaksmaliDumper.escapeValue((byte) (a & 0xFF)),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 8))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 16))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 24))),
                                BaksmaliDumper.escapeValue((byte) (b & 0xFF)),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (b >> 8))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (b >> 16))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (b >> 24))));
                    }
                    out.pop();
                    out.s(".end array-data");
                } else if (array instanceof double[]) {
                    out.s(".array-data 8");
                    out.push();
                    double[] vs = (double[]) array;
                    for (double value : vs) {
                        long ttt = Double.doubleToLongBits(value);
                        int a = (int) ttt;
                        int b = (int) (ttt >>> 32);
                        out.s("%s %s %s %s %s %s %s %s", BaksmaliDumper.escapeValue((byte) (a & 0xFF)),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 8))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 16))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (a >> 24))),
                                BaksmaliDumper.escapeValue((byte) (b & 0xFF)),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (b >> 8))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (b >> 16))),
                                BaksmaliDumper.escapeValue((byte) (0xFF & (b >> 24))));
                    }
                    out.pop();
                    out.s(".end array-data");
                }
            }
        }
    }

    @Override
    public void visitFieldStmt(Op op, int a, int b, Field field) {
        if (op.format == InstructionFormat.kFmt22c) {// iget,iput
            out.s("%s %s, %s, %s", op.displayName, reg(a), reg(b), BaksmaliDumper.escapeField(field));
        } else {
            out.s("%s %s, %s", op.displayName, reg(a), BaksmaliDumper.escapeField(field));
        }
    }

    @Override
    public void visitFilledNewArrayStmt(Op op, int[] args, String type) {
        if (args.length > 0) {
            if (op.format == InstructionFormat.kFmt3rc) { // invoke-x/range
                out.s("%s { %s .. %s }, %s", op.displayName, reg(args[0]), reg(args[args.length - 1]),
                        BaksmaliDumper.escapeType(type));
            } else {
                StringBuilder buff = new StringBuilder();
                boolean first = true;
                for (int i : args) {
                    if (first) {
                        first = false;
                    } else {
                        buff.append(", ");
                    }
                    buff.append(reg(i));
                }
                out.s("%s { %s }, %s", op.displayName, buff, BaksmaliDumper.escapeType(type));
            }
        } else {
            out.s("%s { }, %s", op.displayName, BaksmaliDumper.escapeType(type));
        }

    }

    @Override
    public void visitJumpStmt(Op op, int a, int b, DexLabel label) {
        if (op.format == InstructionFormat.kFmt21t || op.format == InstructionFormat.kFmt31t) {
            out.s(op.displayName + " " + reg(a) + ", " + xLabel(label));
        } else if (op.format == InstructionFormat.kFmt22t) {
            out.s(op.displayName + " " + reg(a) + ", " + reg(b) + ", " + xLabel(label));
        } else {
            out.s(op.displayName + " " + xLabel(label));
        }
    }

    DexDebugVisitor debugDumper = new DexDebugVisitor() {
        @Override
        public void visitStartLocal(int reg, DexLabel label, String name, String type, String signature) {
            super.visitStartLocal(reg, label, name, type, signature);
            if (signature == null) {
                out.s(".local %s, %s:%s", reg(reg), BaksmaliDumper.escapeValue(name), type);
            } else {
                out.s(".local %s, %s:%s, %s", reg(reg), BaksmaliDumper.escapeValue(name), type, BaksmaliDumper.escapeValue(signature));
            }
        }

        @Override
        public void visitPrologue(DexLabel dexLabel) {
            out.s(".prologue");
        }

        @Override
        public void visitEpiogue(DexLabel dexLabel) {
            out.s(".epiogue");
        }

        @Override
        public void visitLineNumber(int line, DexLabel label) {
            out.s(".line %d", line);
        }

        @Override
        public void visitEndLocal(int reg, DexLabel label) {
            out.s(".end local %s", reg(reg));
        }

        @Override
        public void visitRestartLocal(int reg, DexLabel label) {
            out.s(".restart local %s", reg(reg));
        }
    };

    @Override
    public void visitLabel(DexLabel label) {
        if (usedLabel.contains(label)) {
            out.s(xLabel(label));
        }
        List<DexDebugNode.DexDebugOpNode> dOps = debugLabelMap.get(label);
        if (dOps != null) {
            for (DexDebugNode.DexDebugOpNode dOp : dOps) {
                dOp.accept(debugDumper);
            }
        }
    }

    @Override
    final public DexDebugVisitor visitDebug() {
        return null;
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, Method method) {

        if (args.length > 0) {
            if (op.format == InstructionFormat.kFmt3rc) { // invoke-x/range
                out.s("%s { %s .. %s }, %s", op.displayName, reg(args[0]), reg(args[args.length - 1]),
                        BaksmaliDumper.escapeMethod(method));
            } else {
                boolean first = true;
                StringBuilder buff = new StringBuilder();
                for (int i : args) {
                    if (first) {
                        first = false;
                    } else {
                        buff.append(", ");
                    }
                    buff.append(reg(i));
                }
                out.s("%s { %s }, %s", op.displayName, buff, BaksmaliDumper.escapeMethod(method));
            }
        } else {
            out.s("%s { }, %s", op.displayName, BaksmaliDumper.escapeMethod(method));
        }

    }

    @Override
    public void visitMethodStmt(Op op, int[] args, Method method, Proto proto) {
        if (args.length > 0) {
            if (op.format == InstructionFormat.kFmt4rcc) { // invoke-x/range
                out.s("%s { %s .. %s }, %s, %s", op.displayName, reg(args[0]), reg(args[args.length - 1]),
                        BaksmaliDumper.escapeMethod(method), BaksmaliDumper.escapeMethodDesc(proto));
            } else {
                boolean first = true;
                StringBuilder buff = new StringBuilder();
                for (int i : args) {
                    if (first) {
                        first = false;
                    } else {
                        buff.append(", ");
                    }
                    buff.append(reg(i));
                }
                out.s("%s { %s }, %s, %s", op.displayName, buff, BaksmaliDumper.escapeMethod(method),
                        BaksmaliDumper.escapeMethodDesc(proto));
            }
        } else {
            out.s("%s { }, %s, %s", op.displayName, BaksmaliDumper.escapeMethod(method),
                    BaksmaliDumper.escapeMethodDesc(proto));
        }
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, CallSite callSite) {
        StringBuilder sb = new StringBuilder();
        Object[] extraArguments = callSite.getExtraArguments();

        //     invoke-custom/range {v0 .. v5}, call_site_1("runDynamic", (IIIIII)V, 0x378)@L038;->bsm(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;I)Ljava/lang/invoke/CallSite;

        sb
                .append(BaksmaliDumper.escapeId(callSite.getName()))
                .append('(')
                .append(BaksmaliDumper.escapeValue(callSite.getMethodName()))
                .append(", ")
                .append(BaksmaliDumper.escapeMethodDesc(callSite.getMethodProto()));
        if (extraArguments != null && extraArguments.length > 0) {
            for (Object o : extraArguments) {
                sb.append(", ").append(BaksmaliDumper.escapeValue(o));
            }
        }
        // FIXME samli syntax only write out method_handler's method field
        sb.append(")@").append(BaksmaliDumper.escapeMethod(callSite.getBootstrapMethodHandler().getMethod()));

        if (args.length > 0) {
            if (op.format == InstructionFormat.kFmt3rc) { // invoke-x/range
                out.s("%s { %s .. %s }, %s", op.displayName, reg(args[0]), reg(args[args.length - 1]),
                        sb);
            } else {
                boolean first = true;
                StringBuilder buff = new StringBuilder();
                for (int i : args) {
                    if (first) {
                        first = false;
                    } else {
                        buff.append(", ");
                    }
                    buff.append(reg(i));
                }
                out.s("%s { %s }, %s", op.displayName, buff, sb);
            }
        } else {
            out.s("%s { }, %s", op.displayName, sb);
        }
    }

    @Override
    public void visitPackedSwitchStmt(Op op, int ra, int first_case, DexLabel[] labels) {
        DexLabel dx = new DexLabel();
        dx.displayName = "L" + nextLabelNumber++;
        usedLabel.add(dx);
        out.s(op.displayName + " " + reg(ra) + ", " + xLabel(dx));
        appendLast.add(new AbstractMap.SimpleEntry<DexLabel, Object>(dx, new PackedSwitchStmt(first_case, labels)));
    }

    @Override
    public void visitRegister(int total) {
        if (useLocals) {
            out.s(".locals %d", startParamR);
        } else {
            out.s(".registers %d", total);
        }

    }

    @Override
    public void visitSparseSwitchStmt(Op op, int ra, int[] cases, DexLabel[] labels) {
        DexLabel dx = new DexLabel();
        dx.displayName = "L" + nextLabelNumber++;
        usedLabel.add(dx);
        out.s(op.displayName + " " + reg(ra) + ", " + xLabel(dx));
        appendLast.add(new AbstractMap.SimpleEntry<DexLabel, Object>(dx, new SparseSwitchStmt(cases, labels)));
    }

    @Override
    public void visitStmt0R(Op op) {
        if (op == Op.BAD_OP) {
            out.s("%s # bad op", Op.NOP.displayName);
        } else {
            out.s(op.displayName);
        }
    }

    @Override
    public void visitStmt1R(Op op, int a) {
        out.s(op.displayName + " " + reg(a));
    }

    @Override
    public void visitStmt2R(Op op, int a, int b) {
        out.s(op.displayName + " " + reg(a) + ", " + reg(b));
    }

    @Override
    public void visitStmt2R1N(Op op, int a, int b, int content) {
        out.s("%s %s, %s, %s", op.displayName, reg(a), reg(b), content);
    }

    @Override
    public void visitStmt3R(Op op, int a, int b, int c) {
        out.s("%s %s, %s, %s", op.displayName, reg(a), reg(b), reg(c));
    }

    @Override
    public void visitTryCatch(DexLabel start, DexLabel end, DexLabel[] handler, String[] type) {
        for (int i = 0; i < type.length; i++) {
            String t = type[i];
            if (t == null) {
                out.s(".catchall { %s .. %s } %s", xLabel(start), xLabel(end), xLabel(handler[i]));
            } else {
                out.s(".catch %s { %s .. %s } %s", t, xLabel(start), xLabel(end), xLabel(handler[i]));
            }
        }

    }

    @Override
    public void visitTypeStmt(Op op, int a, int b, String type) {
        if (op.format == InstructionFormat.kFmt21c) {
            out.s("%s %s, %s", op.displayName, reg(a), BaksmaliDumper.escapeType(type));
        } else {
            out.s("%s %s, %s, %s", op.displayName, reg(a), reg(b), BaksmaliDumper.escapeType(type));
        }
    }

    String xLabel(DexLabel d) {
        return ":" + d.displayName;
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/BaksmaliDexFileVisitor.java`:

```java
package com.googlecode.d2j.smali;

import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexFileVisitor;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashSet;
import java.util.Set;

public class BaksmaliDexFileVisitor extends DexFileVisitor {
    private final Path dir;
    private final BaksmaliDumper bs;
    private final Set<String> hashes;
    private int i;

    public BaksmaliDexFileVisitor(Path dir, BaksmaliDumper bs) {
        this.dir = dir;
        this.bs = bs;
        hashes = new HashSet<>();
        i = 1;
    }

    protected String rebuildFileName(String s) {
        s = BaksmaliDumper.escapeId(s);
        s = s.replace('\\', '-');
        String low = s.toLowerCase();
        if (hashes.contains(low)) {
            return s + "_d2j" + i++;
        } else {
            hashes.add(low);
        }
        return s;
    }

    @Override
    public DexClassVisitor visit(int access_flags, String className, String superClass, String[] interfaceNames) {
        return new DexClassNode(access_flags, className, superClass, interfaceNames) {

            @Override
            public void visitEnd() {
                super.visitEnd();

                Path smaliFile = dir
                        .resolve(rebuildFileName(className.substring(1, className.length() - 1)) + ".smali");

                try {
                    Path parent = smaliFile.getParent();
                    if (parent != null && !Files.exists(parent)) {
                        Files.createDirectories(parent);
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }

                try (BufferedWriter writer = Files.newBufferedWriter(smaliFile, StandardCharsets.UTF_8)) {
                    BaksmaliDumpOut out = new BaksmaliDumpOut(writer);
                    bs.baksmaliClass(this, out);
                    writer.flush();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }

            }
        };
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/BaksmaliDumpOut.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.smali;

import com.googlecode.d2j.util.Out;

import java.io.BufferedWriter;
import java.io.IOException;

public class BaksmaliDumpOut implements Out {
    private final BufferedWriter writer;
    int i;
    final String indent;

    public BaksmaliDumpOut(BufferedWriter writer) {
        this("  ", writer);
    }

    public BaksmaliDumpOut(String indent, BufferedWriter writer) {
        this.writer = writer;
        i = 0;
        this.indent = indent;
    }

    @Override
    public void pop() {
        i--;
    }

    @Override
    public void push() {
        i++;
    }

    @Override
    public void s(String s) {
        try {
            for (int i = 0; i < this.i; i++) {
                writer.append(indent);
            }
            writer.append(s);
            writer.newLine();
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }

    @Override
    public void s(String format, Object... arg) {
        try {
            for (int i = 0; i < this.i; i++) {
                writer.append(indent);
            }
            writer.append(String.format(format, arg));
            writer.newLine();
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/BaksmaliDumper.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.smali;

import java.io.BufferedWriter;
import java.util.*;

import com.googlecode.d2j.*;
import com.googlecode.d2j.node.*;
import com.googlecode.d2j.node.DexAnnotationNode.Item;
import com.googlecode.d2j.node.insn.DexLabelStmtNode;
import com.googlecode.d2j.node.insn.DexStmtNode;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.util.Out;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexDebugVisitor;

public class BaksmaliDumper implements DexConstants {
    private static final int ACCESS_FIELD = 1 << 31;
    private final static String[] accessWords = new String[]{"public", "private", "protected", "static", "final",
            "synchronized", "bridge", "varargs", "native", "abstract", "strictfp", "synthetic", "constructor",
            "interface", "enum", "annotation", "volatile", "transient"};

    static {
        Arrays.sort(accessWords);
    }

    private final StringBuilder buff = new StringBuilder();
    private boolean useParameterRegisters = true;
    private boolean useLocals = false;

    public BaksmaliDumper() {
    }

    public BaksmaliDumper(boolean useParameterRegisters, boolean useLocals) {
        this.useParameterRegisters = useParameterRegisters;
        this.useLocals = useLocals;
    }

    private static boolean isAccessWords(String name) {
        return Arrays.binarySearch(accessWords, name) >= 0;
    }

    static void escape0(final StringBuilder buf, char c) {
        if (c == '\n') {
            buf.append("\\n");
        } else if (c == '\r') {
            buf.append("\\r");
        } else if (c == '\t') {
            buf.append("\\t");
        } else if (c == '\\') {
            buf.append("\\\\");
        } else if (c == '"') {
            buf.append("\\\"");
        } else if (c < 0x20 || c > 0x7f) {
            buf.append("\\u");
            if (c < 0x10) {
                buf.append("000");
            } else if (c < 0x100) {
                buf.append("00");
            } else if (c < 0x1000) {
                buf.append('0');
            }
            buf.append(Integer.toString(c, 16));
        } else {
            buf.append(c);
        }
    }

    static String escapeType(String id) {
        StringBuilder escapeBuff = new StringBuilder();
        escapeType0(escapeBuff, id);
        return escapeBuff.toString();
    }

    static void escapeId0(StringBuilder sb, String id) {
        for (int i = 0; i < id.length(); ++i) {
            char c = id.charAt(i);
            escape1(sb, c);
        }
    }

    static String escapeId(String id) {
        StringBuilder escapeBuff = new StringBuilder();
        escapeId0(escapeBuff, id);
        return escapeBuff.toString();
    }

    static void escape1(final StringBuilder buf, char c) {
        if (c == ' ' || c == '-' || c == ':' | c == '=' || c == ',' || c == '{' || c == '}' || c == '(' || c == ')') {
            buf.append(String.format("\\u%04x", (int) c));
        } else {
            escape0(buf, c);
        }
    }

    static void escapeType0(StringBuilder sb, String id) {
        for (int i = 0; i < id.length(); ++i) {
            char c = id.charAt(i);
            if (c == '-') {
                sb.append('-');
            } else {
                escape1(sb, c);
            }
        }
    }

    static String escapeMethod(Method method) {
        return BaksmaliDumper.escapeType(method.getOwner()) + "->" + BaksmaliDumper.escapeId(method.getName()) + BaksmaliDumper.escapeMethodDesc(method);
    }
    static String escapeMethodDesc(Method m) {
        return escapeMethodDesc(m.getProto());
    }
    static String escapeMethodDesc(Proto m) {
        StringBuilder escapeBuff = new StringBuilder();
        escapeBuff.append("(");
        for (String t : m.getParameterTypes()) {
            escapeType0(escapeBuff, t);
        }
        escapeBuff.append(")");
        escapeType0(escapeBuff, m.getReturnType());
        return escapeBuff.toString();
    }

    static void appendAccess(final int access, final StringBuilder sb) {
        if ((access & ACC_PUBLIC) != 0) {
            sb.append("public ");
        }
        if ((access & ACC_PRIVATE) != 0) {
            sb.append("private ");
        }
        if ((access & ACC_PROTECTED) != 0) {
            sb.append("protected ");
        }
        if ((access & ACC_FINAL) != 0) {
            sb.append("final ");
        }
        if ((access & ACC_STATIC) != 0) {
            sb.append("static ");
        }
        if ((access & ACC_VOLATILE) != 0) {
            if ((access & ACCESS_FIELD) == 0) {
                sb.append("bridge ");
            } else {
                sb.append("volatile ");
            }
        }
        if ((access & ACC_TRANSIENT) != 0) {
            if ((access & ACCESS_FIELD) == 0) {
                sb.append("varargs ");
            } else {
                sb.append("transient ");
            }
        }
        if ((access & ACC_NATIVE) != 0) {
            sb.append("native ");
        }
        if ((access & ACC_STRICT) != 0) {
            sb.append("strict ");
        }
        if ((access & ACC_INTERFACE) != 0) {
            sb.append("interface ");
        }
        if ((access & ACC_ABSTRACT) != 0) {
            sb.append("abstract ");
        }
        if ((access & ACC_SYNTHETIC) != 0) {
            sb.append("synthetic ");
        }
        if ((access & ACC_ANNOTATION) != 0) {
            sb.append("annotation ");
        }
        if ((access & ACC_ENUM) != 0) {
            sb.append("enum ");
        }
        if ((access & ACC_DECLARED_SYNCHRONIZED) != 0) {
            sb.append("declared-synchronized ");
        }
        if ((access & ACC_CONSTRUCTOR) != 0) {
            sb.append("constructor ");
        }
    }

    static void escape(final StringBuilder buf, final String s) {
        buf.append("\"");
        for (int i = 0; i < s.length(); ++i) {
            escape0(buf, s.charAt(i));
        }
        buf.append("\"");
    }

    static String escapeValue(Object obj) {
        if (obj == null) {
            return "null";
        }

        if (obj instanceof String) {
            StringBuilder buf = new StringBuilder();
            escape(buf, (String) obj);
            return buf.toString();
        }

        if (obj instanceof DexType) {
            return escapeType(((DexType) obj).desc);
        }
        if(obj instanceof Proto) {
            return escapeMethodDesc((Proto) obj);
        }
        if(obj instanceof MethodHandle) {
            return escapeMethodHandle((MethodHandle) obj);
        }
        if (obj instanceof Field) {
            Field f = ((Field) obj);
            String owner = f.getOwner();
            if (owner == null) {
                owner = f.getType();
            }
            return ".enum " + escapeType(owner) + "->" + f.getName() + ":" + escapeType(f.getType());
        }

        if (obj instanceof Integer) {
            int i = ((Integer) obj);
            if (i == Integer.MIN_VALUE) {
                return "0x" + Integer.toHexString(Integer.MIN_VALUE);
            }
            return obj.toString();
        }
        if (obj instanceof Long) {
            long v = ((Long) obj);
            if (v == Long.MIN_VALUE) {
                return "0x" + Long.toHexString(Long.MIN_VALUE) + "L";
            } else {
                return obj + "L";
            }
        }
        if (obj instanceof Float) {
            return obj + "F";
        }
        if (obj instanceof Double) {
            return obj + "D";
        }
        if (obj instanceof Short) {
            return obj + "S";
        }
        if (obj instanceof Byte) {
            return ((Byte) obj).toString() + 't';
        }
        if (obj instanceof Character) {
            StringBuilder buf = new StringBuilder();
            buf.append("'");
            escape0(buf, (Character) obj);
            buf.append("'");
            return buf.toString();
        }
        if (obj instanceof Boolean) {
            return ((Boolean) obj).toString();
        }
        if (obj instanceof Method) {
            return escapeMethod((Method) obj);
        }
        return null;
    }

    private static String escapeMethodHandle(MethodHandle obj) {
        switch (obj.getType()) {
        case MethodHandle.INSTANCE_GET:
            return "instance-get@" + escapeField(obj.getField());
        case MethodHandle.INSTANCE_PUT:
            return "instance-put@" + escapeField(obj.getField());
        case MethodHandle.STATIC_GET:
            return "static-get@" + escapeField(obj.getField());
        case MethodHandle.STATIC_PUT:
            return "static-put@" + escapeField(obj.getField());

        case MethodHandle.INVOKE_INSTANCE:
            return "invoke-instance@" + escapeMethod(obj.getMethod());
        case MethodHandle.INVOKE_STATIC:
            return "invoke-static@" + escapeMethod(obj.getMethod());
        case MethodHandle.INVOKE_CONSTRUCTOR:
            return "invoke-constructor@" + escapeMethod(obj.getMethod());
        case MethodHandle.INVOKE_DIRECT:
            return "invoke-direct@" + escapeMethod(obj.getMethod());
        case MethodHandle.INVOKE_INTERFACE:
            return "invoke-interface@" + escapeMethod(obj.getMethod());
        default:
        }
        return "?";
    }

    public static String escapeField(Field f) {
        String owner = f.getOwner();
        if (owner == null) {
            owner = f.getType();
        }
        return escapeType(owner) + "->" + f.getName() + ":" + escapeType(f.getType());
    }

    private static void dumpAnns(List<DexAnnotationNode> anns, Out out) {
        for (DexAnnotationNode ann : anns) {
            dumpAnn(ann, out);
        }
    }

    private static void dumpItem(String name, Object o, Out out, boolean array) {

        if (o instanceof Object[]) {
            Object[] vs = (Object[]) o;
            if (name != null) {
                out.s(escapeId(name) + " = {");
            } else {
                out.s("{");
            }
            out.push();
            for (int i = 0; i < vs.length; i++) {
                Object v = vs[i];
                dumpItem(null, v, out, i != vs.length - 1);
            }
            out.pop();
            if (array) {
                out.s("},");
            } else {
                out.s("}");
            }
        } else if (o instanceof DexAnnotationNode) {
            DexAnnotationNode dexAnnotationNode = (DexAnnotationNode) o;
            if (name != null) {
                out.s(escapeId(name) + " = .subannotation " + escapeType(dexAnnotationNode.type));
            } else {
                out.s(".subannotation " + escapeType(dexAnnotationNode.type));
            }
            out.push();
            for (Item item : dexAnnotationNode.items) {
                dumpItem(item.name, item.value, out, false);
            }
            out.pop();
            if (array) {
                out.s(".end subannotation,");
            } else {
                out.s(".end subannotation");
            }
        } else {
            StringBuilder sb = new StringBuilder();
            if (name != null) {
                sb.append(escapeId(name)).append(" = ");
            }
            sb.append(escapeValue(o));
            if (array) {
                sb.append(",");
            }
            out.s(sb.toString());
        }
    }

    private static void dumpAnn(DexAnnotationNode ann, Out out) {
        out.s(".annotation %s %s", ann.visibility.displayName(), escapeType(ann.type));
        out.push();
        for (Item item : ann.items) {
            dumpItem(item.name, item.value, out, false);
        }
        out.pop();
        out.s(".end annotation");
    }

    public void baksmaliClass(DexClassNode n, BufferedWriter writer) {
        baksmaliClass(n, new BaksmaliDumpOut(writer));
    }

    public void baksmaliClass(DexClassNode n, Out out) {

        buff.setLength(0);
        buff.append(".class ");
        appendAccess(n.access, buff);
        buff.append(escapeType(n.className));
        out.s(buff.toString());
        if (n.superClass != null) {
            out.s(".super %s", escapeType(n.superClass));
        }
        if (n.interfaceNames != null && n.interfaceNames.length > 0) {
            for (String itf : n.interfaceNames) {
                out.s(".implements %s", escapeType(itf));
            }
        }
        if (n.source != null) {
            out.s(".source " + escapeValue(n.source));
        }
        if (n.anns != null) {
            out.s("");
            dumpAnns(n.anns, out);
        }
        if (n.fields != null) {
            for (DexFieldNode f : n.fields) {
                out.s("");
                buff.setLength(0);
                buff.append(".field ");
                appendAccess(f.access | ACCESS_FIELD, buff);
                Field field = f.field;
                buff.append(escapeId(f.field.getName())).append(":").append(escapeType(field.getType()));
                if (f.cst != null) {
                    buff.append(" = ");
                    buff.append(escapeValue(f.cst));
                }
                out.s(buff.toString());

                if (f.anns != null) {
                    out.push();
                    dumpAnns(f.anns, out);
                    out.pop();
                    out.s(".end field");
                }
            }
        }
        if (n.methods != null) {
            for (DexMethodNode m : n.methods) {
                baksmaliMethod(m, out);
            }
        }
    }

    public void baksmaliMethod(DexMethodNode m, BufferedWriter writer) {
        baksmaliMethod(m, new BaksmaliDumpOut(writer));
    }

    public void baksmaliMethod(DexMethodNode m, Out out) {
        out.s("");
        buff.setLength(0);
        buff.append(".method ");
        Method method = m.method;
        appendAccess(m.access, buff);
        buff.append(escapeId(method.getName())).append(escapeMethodDesc(method));
        out.s(buff.toString());
        out.push();
        if (m.anns != null) {
            dumpAnns(m.anns, out);
        }

        int paramMax = 0;
        List<String> parameterNames = null;
        if (m.codeNode != null && m.codeNode.debugNode != null) {
            parameterNames = m.codeNode.debugNode.parameterNames;
            if (parameterNames != null) {
                paramMax = parameterNames.size();
            }
        }
        int annoMax = 0;
        if (m.parameterAnns != null) {
            for (int i = 0; i < m.parameterAnns.length; i++) {
                List<DexAnnotationNode> ps = m.parameterAnns[i];
                if (ps != null && ps.size() > 0) {
                    annoMax = i + 1;
                }
            }
        }

        int max = Math.max(paramMax, annoMax);
        for (int i = 0; i < max; i++) {
            String type = method.getParameterTypes()[i];
            String debugName = parameterNames == null ? null : i < parameterNames.size() ? parameterNames.get(i) : null;
            if (debugName != null) {
                out.s(".parameter \"" + escapeId(debugName) + "\" # " + type);
            } else {
                out.s(".parameter # " + type);
            }
            List<DexAnnotationNode> ps = m.parameterAnns == null ? null : m.parameterAnns[i];
            if (ps != null && ps.size() != 0) {
                out.push();
                dumpAnns(ps, out);
                out.pop();
                out.s(".end parameter");
            }
            // FIXME support '.param' REGISTER, STRING
        }

        if (m.codeNode != null) {
            baksmaliCode(m, m.codeNode, out);
        }

        out.pop();
        out.s(".end method");
    }

    public void baksmaliCode(DexMethodNode methodNode, DexCodeNode codeNode, Out out) {

        final List<DexLabel> allLabel = new ArrayList<>();
        final Set<DexLabel> usedLabel = new HashSet<>();
        codeNode.accept(new DexCodeVisitor() {
            @Override
            public void visitJumpStmt(Op op, int a, int b, DexLabel label) {
                usedLabel.add(label);
            }

            @Override
            public void visitPackedSwitchStmt(Op op, int aA, int first_case, DexLabel[] labels) {
                usedLabel.addAll(Arrays.asList(labels));
            }

            @Override
            public void visitTryCatch(DexLabel start, DexLabel end, DexLabel[] handler, String[] type) {
                usedLabel.add(start);
                usedLabel.add(end);
                usedLabel.addAll(Arrays.asList(handler));
            }

            @Override
            public void visitLabel(DexLabel label) {
                allLabel.add(label);
            }

            @Override
            public void visitSparseSwitchStmt(Op op, int ra, int[] cases, DexLabel[] labels) {
                usedLabel.addAll(Arrays.asList(labels));
            }
        });
        Map<DexLabel, List<DexDebugNode.DexDebugOpNode>> debugLabelMap = new HashMap<>();
        if (codeNode.debugNode != null) {
            DexDebugNode debugNode = codeNode.debugNode;
            for (DexDebugNode.DexDebugOpNode opNode : debugNode.debugNodes) {
                List<DexDebugNode.DexDebugOpNode> list = debugLabelMap.get(opNode.label);
                if (list == null) {
                    list = new ArrayList<>(3);
                    debugLabelMap.put(opNode.label, list);
                }
                list.add(opNode);
            }
        }
        int nextLabelNumber = 0;
        for (DexLabel label : allLabel) {
            if (usedLabel.contains(label)) {
                label.displayName = "L" + nextLabelNumber++;
            }
        }

        int inRegs = Utils.methodIns(methodNode.method, (methodNode.access & ACC_STATIC) != 0);

        DexCodeVisitor dexCodeVisitor = new BaksmaliCodeDumper(out, useParameterRegisters, useLocals, nextLabelNumber,
                codeNode.totalRegister - inRegs, usedLabel, debugLabelMap);
        accept(out, codeNode, dexCodeVisitor);
        dexCodeVisitor.visitEnd();
    }

    void accept(Out out, DexCodeNode code, DexCodeVisitor v) {
        if (code.tryStmts != null) {
            for (TryCatchNode n : code.tryStmts) {
                n.accept(v);
            }
        }
        if (code.debugNode != null) {
            DexDebugVisitor ddv = v.visitDebug();
            if (ddv != null) {
                code.debugNode.accept(ddv);
                ddv.visitEnd();
            }
        }
        if (code.totalRegister >= 0 && code.stmts.size() > 0) {
            v.visitRegister(code.totalRegister);
        }
        for (DexStmtNode n : code.stmts) {
            if (n instanceof DexLabelStmtNode) {
                n.accept(v);
            } else {
                out.push();
                n.accept(v);
                out.pop();
            }

        }
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/Smali.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.smali;

import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.smali.antlr4.SmaliLexer;
import com.googlecode.d2j.smali.antlr4.SmaliParser;
import com.googlecode.d2j.visitors.DexFileVisitor;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CodePointCharStream;
import org.antlr.v4.runtime.CommonTokenStream;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

public class Smali {
    public static void smaliFile(Path path, DexFileVisitor dcv) throws IOException {
        try (Reader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
            CodePointCharStream is = CharStreams.fromReader(reader, path.toString());
            smali0(dcv, is);
        }
    }

    public static void smaliFile(String name, String buff, DexFileVisitor dcv) {
        CodePointCharStream is = CharStreams.fromString(buff, name);
        smali0(dcv, is);
    }

    public static void smaliFile(String name, InputStream in, DexFileVisitor dcv) throws IOException {
        try (InputStreamReader reader = new InputStreamReader(in, StandardCharsets.UTF_8)) {
            CodePointCharStream is = CharStreams.fromReader(reader, name);
            smali0(dcv, is);
        }
    }

    public static DexClassNode smaliFile2Node(String name, InputStream in) throws IOException {
        DexFileNode dfn = new DexFileNode();
        smaliFile(name, in, dfn);
        return dfn.clzs.size() > 0 ? dfn.clzs.get(0) : null;
    }

    public static DexClassNode smaliFile2Node(String name, String buff) {
        DexFileNode dfn = new DexFileNode();
        smaliFile(name, buff, dfn);
        return dfn.clzs.size() > 0 ? dfn.clzs.get(0) : null;
    }

    private static void smali0(DexFileVisitor dcv, CharStream is) {
        SmaliLexer lexer = new SmaliLexer(is);
        CommonTokenStream ts = new CommonTokenStream(lexer);
        SmaliParser parser = new SmaliParser(ts);

        for (SmaliParser.SFileContext ctx : parser.sFiles().sFile()) {
            AntlrSmaliUtil.acceptFile(ctx, dcv);
        }
    }

    public static void smaliFile(String fileName, char[] data, DexFileVisitor dcv) {
        // System.err.println("parsing " + f.getAbsoluteFile());
        CodePointCharStream is = CharStreams.fromString(new String(data), fileName);
        smali0(dcv, is);
    }

    public static void smali(Path base, final DexFileVisitor dfv) throws IOException {
        if (Files.isDirectory(base)) {
            Files.walkFileTree(base, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                    Path fn = dir.getFileName();
                    if (fn != null && fn.toString().startsWith(".")) {
                        return FileVisitResult.SKIP_SUBTREE;
                    }
                    return super.preVisitDirectory(dir, attrs);
                }

                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    smaliFile(file, dfv);
                    return super.visitFile(file, attrs);
                }
            });
        } else if (Files.isRegularFile(base)) {
            smaliFile(base, dfv);
        }
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/SmaliCmd.java`:

```java
package com.googlecode.d2j.smali;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;

import com.googlecode.d2j.dex.writer.DexFileWriter;
import com.googlecode.d2j.visitors.DexFileVisitor;
import com.googlecode.dex2jar.tools.BaseCmd;
import com.googlecode.dex2jar.tools.BaseCmd.Syntax;

@Syntax(cmd = "d2j-smali", syntax = "[options] [--] [<smali-file>|folder]*", desc = "assembles a set of smali files into a dex file", onlineHelp = "https://sourceforge.net/p/dex2jar/wiki/Smali")
public class SmaliCmd extends BaseCmd {
    @Opt(opt = "x", longOpt = "allow-odex-instructions", hasArg = false, description = "[not impl] allow odex instructions to be compiled into the dex file. Only a few instructions are supported - the ones that can exist in a dead code path and not cause dalvik to reject the class")
    private boolean allowOdexInstructions;
    @Opt(opt = "a", longOpt = "api-level", description = "[not impl] The numeric api-level of the file to generate, e.g. 14 for ICS. If not specified, it defaults to 14 (ICS).", argName = "API_LEVEL")
    private int apiLevel = 14;
    @Opt(opt = "v", longOpt = "version", hasArg = false, description = "prints the version then exits")
    private boolean showVersionThenExits;
    @Opt(opt = "o", longOpt = "output", description = "the name of the dex file that will be written. The default is out.dex", argName = "FILE")
    private Path output;
    @Opt(opt = "-", hasArg = false, description = "read smali from stdin")
    private boolean readSmaliFromStdin;

    public static void main(String[] args) {
        new SmaliCmd().doMain(args);
    }

    @Override
    protected void doCommandLine() throws Exception {

        if (showVersionThenExits) {
            System.out.println("smali 1.4.2p (https://sourceforge.net/p/dex2jar)");
            System.out.println("Copyright (c) 2009-2013 Panxiaobo (pxb1988@gmail.com)");
            System.out.println("Apache license (https://www.apache.org/licenses/LICENSE-2.0)");
            return;
        }

        if (!readSmaliFromStdin && remainingArgs.length < 1) {
            System.err.println("ERROR: no file to process");
            return;
        }

        if (output == null) {
            output = new File("out.dex").toPath();
        }

        DexFileWriter fw = new DexFileWriter();

        DexFileVisitor fv = new DexFileVisitor(fw) {
            @Override
            public void visitEnd() {// intercept the call to super
            }
        };

        if (readSmaliFromStdin) {
            Smali.smaliFile("<stdin>", System.in, fv);
            System.err.println("smali <stdin> -> " + output);
        }

        for (String s : remainingArgs) {
            Path file = new File(s).toPath();
            if (!Files.exists(file)) {
                System.err.println("skip " + file + ", it is not a dir or a file");
            } else {
                System.err.println("smali " + s + " -> " + output);
                Smali.smali(file, fv);
            }
        }

        fw.visitEnd();
        byte[] data = fw.toByteArray();
        Files.write(output, data);
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/SmaliCodeVisitor.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.smali;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.node.DexCodeNode;
import com.googlecode.d2j.node.insn.DexLabelStmtNode;
import com.googlecode.d2j.node.insn.DexStmtNode;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class SmaliCodeVisitor extends DexCodeNode {

    public SmaliCodeVisitor(DexCodeVisitor visitor) {
        super(visitor);
    }

    @Override
    public void visitConstStmt(Op op, int ra, Object value) {
        switch (op) {
        case CONST_WIDE_16: {
            if(value instanceof Integer) {
                short v = ((Number) value).shortValue();
                super.visitConstStmt(op, ra, (long) v);
            } else {
                super.visitConstStmt(op, ra, value);
            }
        }
            break;
        case CONST_WIDE_HIGH16: {
            if(value instanceof Integer) {
                short v = ((Number) value).shortValue();
                super.visitConstStmt(op, ra, ((long) v) << 48);
            } else {
                super.visitConstStmt(op, ra, value);
            }
        }
            break;
        case CONST_WIDE_32: {
            if(value instanceof Integer) {
                int v = ((Number) value).intValue();
                super.visitConstStmt(op, ra, (long) v);
            } else {
                super.visitConstStmt(op, ra, value);
            }
        }
            break;
        case CONST_HIGH16: {
            int v = ((Number) value).intValue();
            if(0 != (v & 0xFFff0000)){
                super.visitConstStmt(op, ra, v);
            } else {
                super.visitConstStmt(op, ra, v << 16);
            }
        }
            break;
        default:
            super.visitConstStmt(op, ra, value);
            break;
        }
    }

    public static class ArrayDataStmt extends DexStmtNode {
        int length;
        byte[] objs;

        public ArrayDataStmt(int length, byte[] obj) {
            super(null);
            this.length = length;
            this.objs = obj;
        }

        @Override
        public void accept(DexCodeVisitor cv) {
        }

    }

    public static class PackedSwitchStmt extends DexStmtNode {
        int firstCase;
        DexLabel[] labels;

        public PackedSwitchStmt(int reg, DexLabel[] labels) {
            super(null);
            this.firstCase = reg;
            this.labels = labels;
        }

        @Override
        public void accept(DexCodeVisitor cv) {
        }
    }

    public static class SparseSwitchStmt extends DexStmtNode {
        int[] cases;
        DexLabel[] labels;

        public SparseSwitchStmt(int[] cases, DexLabel[] labels) {
            super(null);
            this.cases = cases;
            this.labels = labels;
        }

        @Override
        public void accept(DexCodeVisitor cv) {
        }
    }

    private List<DexStmtNode> needCareStmts = new ArrayList<>();

    @Override
    public void visitEnd() {
        if (super.visitor != null) {
            super.accept(super.visitor);
        }
        needCareStmts = null;
        stmts = null;
        tryStmts = null;
        super.visitEnd();
    }

    private void addCare(DexStmtNode stmt) {
        needCareStmts.add(stmt);
        super.add(stmt);
    }

    /* package */void dArrayData(int length, byte[] obj) {
        addCare(new ArrayDataStmt(length, obj));
    }

    void dPackedSwitch(int first, DexLabel[] labels) {
        addCare(new PackedSwitchStmt(first, labels));
    }

    /* package */void dSparseSwitch(int[] cases, DexLabel[] labels) {
        addCare(new SparseSwitchStmt(cases, labels));
    }

    int findLabelIndex(DexLabel label) {
        int labelIndex = -1;
        for (int i = 0; i < needCareStmts.size(); i++) {
            DexStmtNode s = needCareStmts.get(i);
            if (s instanceof DexLabelStmtNode) {
                DexLabelStmtNode ss = (DexLabelStmtNode) s;
                if (ss.label == label) {
                    labelIndex = i;
                }
            }
        }
        return labelIndex;
    }

    /* package */void visitF31tStmt(final Op op, final int reg, final DexLabel label) {
        add(new DexStmtNode(op) {

            @Override
            public void accept(DexCodeVisitor cv) {
                int labelIndex = findLabelIndex(label);
                if (labelIndex < 0 || labelIndex >= needCareStmts.size()) {
                    throw new RuntimeException("can't find label for " + op + " " + label);
                }

                switch (op) {
                case PACKED_SWITCH:
                    PackedSwitchStmt packedSwitchStmt = (PackedSwitchStmt) needCareStmts.get(labelIndex + 1);
                    cv.visitPackedSwitchStmt(op, reg, packedSwitchStmt.firstCase, packedSwitchStmt.labels);
                    break;
                case SPARSE_SWITCH:
                    SparseSwitchStmt sparseSwitchStmt = (SparseSwitchStmt) needCareStmts.get(labelIndex + 1);
                    cv.visitSparseSwitchStmt(op, reg, sparseSwitchStmt.cases, sparseSwitchStmt.labels);
                    break;
                case FILL_ARRAY_DATA:
                    ArrayDataStmt arrayDataStmt = (ArrayDataStmt) needCareStmts.get(labelIndex + 1);
                    Object v;
                    byte[] vs = arrayDataStmt.objs;
                    switch (arrayDataStmt.length) {
                    case 1: {
                        v = vs;
                    }
                        break;
                    case 2: {
                        short[] vs1 = new short[vs.length / 2];
                        for (int i = 0; i < vs1.length; i++) {
                            vs1[i] = (short) ((vs[i * 2] & 0xFF) | ((vs[i * 2 + 1] & 0xFF) << 8));
                        }
                        v = vs1;
                    }
                        break;
                    case 4: {
                        int[] vs1 = new int[vs.length / 4];
                        for (int i = 0; i < vs1.length; i++) {
                            int base = i * 4;
                            vs1[i] = (vs[base] & 0xFF) | ((vs[base + 1] & 0xFF) << 8)
                                    | ((vs[base + 2] & 0xFF) << 16) | ((vs[base + 3] & 0xFF) << 24);
                        }
                        v = vs1;
                    }
                        break;
                    case 8: {
                        long[] vs1 = new long[vs.length / 8];
                        for (int i = 0; i < vs1.length; i++) {
                            int base = i * 8;
                            int a = ((vs[base] & 0xFF)) | ((vs[base + 1] & 0xFF) << 8)
                                    | ((vs[base + 2] & 0xFF) << 16) | ((vs[base + 3] & 0xFF) << 24);
                            int b = ((vs[base + 4] & 0xFF)) | ((vs[base + 5] & 0xFF) << 8)
                                    | ((vs[base + 6] & 0xFF) << 16) | ((vs[base + 7] & 0xFF) << 24);
                            vs1[i] = (((long) b) << 32) | a;
                        }
                        v = vs1;
                    }
                        break;
                    default:
                        throw new RuntimeException();
                    }
                    cv.visitFillArrayDataStmt(Op.FILL_ARRAY_DATA, reg, v);
                    break;
                default:
                    throw new RuntimeException();
                }
            }
        });
    }

    @Override
    public void visitLabel(final DexLabel label) {
        addCare(new DexLabelStmtNode(label));
    }
}

```

`d2j-smali/src/main/java/com/googlecode/d2j/smali/Utils.java`:

```java
package com.googlecode.d2j.smali;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Utils implements DexConstants {

    public static void doAccept(DexAnnotationVisitor dexAnnotationVisitor, String k, Object value) {
        if (value instanceof ArrayList) {
            DexAnnotationVisitor a = dexAnnotationVisitor.visitArray(k);
            for (Object o : (ArrayList) value) {
                doAccept(a, null, o);
            }
            a.visitEnd();
        } else if (value instanceof Ann) {
            Ann ann = (Ann) value;
            DexAnnotationVisitor a = dexAnnotationVisitor.visitAnnotation(k, ann.name);
            for (Map.Entry<String, Object> e : ann.elements) {
                doAccept(a, e.getKey(), e.getValue());
            }
            a.visitEnd();
        } else if (value instanceof Field) {
            Field f = (Field) value;
            dexAnnotationVisitor.visitEnum(k, f.getOwner(), f.getName());
        } else {
            dexAnnotationVisitor.visit(k, value);
        }
    }

    public static int getAcc(String name) {
        switch (name) {
        case "public":
            return ACC_PUBLIC;
        case "private":
            return ACC_PRIVATE;
        case "protected":
            return ACC_PROTECTED;
        case "static":
            return ACC_STATIC;
        case "final":
            return ACC_FINAL;
        case "synchronized":
            return ACC_SYNCHRONIZED;
        case "volatile":
            return ACC_VOLATILE;
        case "bridge":
            return ACC_BRIDGE;
        case "varargs":
            return ACC_VARARGS;
        case "transient":
            return ACC_TRANSIENT;
        case "native":
            return ACC_NATIVE;
        case "interface":
            return ACC_INTERFACE;
        case "abstract":
            return ACC_ABSTRACT;
        case "strict":
            return ACC_STRICT;
        case "synthetic":
            return ACC_SYNTHETIC;
        case "annotation":
            return ACC_ANNOTATION;
        case "enum":
            return ACC_ENUM;
        case "constructor":
            return ACC_CONSTRUCTOR;
        case "declared-synchronized":
            return ACC_DECLARED_SYNCHRONIZED;
        }
        return 0;
    }

    public static List<String> listDesc(String desc) {
        List<String> list = new ArrayList<>(5);
        if (desc == null) {
            return list;
        }
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
                case 'V':
                case 'Z':
                case 'C':
                case 'B':
                case 'S':
                case 'I':
                case 'F':
                case 'J':
                case 'D':
                    list.add(Character.toString(chars[i]));
                    i++;
                    break;
                case '[': {
                    int count = 1;
                    while (chars[i + count] == '[') {
                        count++;
                    }
                    if (chars[i + count] == 'L') {
                        count++;
                        while (chars[i + count] != ';') {
                            count++;
                        }
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }
                case 'L': {
                    int count = 1;
                    while (chars[i + count] != ';') {
                        ++count;
                    }
                    count++;
                    list.add(new String(chars, i, count));
                    i += count;
                    break;
                }
                default:
                    throw new RuntimeException("can't parse type list: " + desc);
            }
        }
        return list;
    }

    public static String[] toTypeList(String s) {
        return listDesc(s).toArray(new String[0]);
    }

    static public Byte parseByte(String str) {
        return (byte) parseInt(str.substring(0, str.length() - 1));
    }

    static public Short parseShort(String str) {
        return (short) parseInt(str.substring(0, str.length() - 1));
    }

    static public Long parseLong(String str) {
        int sof = 0;
        int end = str.length() - 1;
        int x = 1;
        if (str.charAt(sof) == '+') {
            sof++;
        } else if (str.charAt(sof) == '-') {
            sof++;
            x = -1;
        }
        BigInteger v;
        if (str.charAt(sof) == '0') {
            sof++;
            if (sof >= end) {
                return 0L;
            }
            char c = str.charAt(sof);
            if (c == 'x' || c == 'X') {// hex
                sof++;
                v = new BigInteger(str.substring(sof, end), 16);
            } else {// oct
                v = new BigInteger(str.substring(sof, end), 8);
            }
        } else {
            v = new BigInteger(str.substring(sof, end), 10);
        }
        if (x == -1) {
            return v.negate().longValue();
        } else {
            return v.longValue();
        }
    }

    static public float parseFloat(String str) {
        str = str.toLowerCase();
        int s = 0;
        float x = 1f;
        if (str.charAt(s) == '+') {
            s++;
        } else if (str.charAt(s) == '-') {
            s++;
            x = -1;
        }
        int e = str.length() - 1;
        if (str.charAt(e) == 'f') {
            e--;
        }
        str = str.substring(s, e + 1);
        if (str.equals("nan")) {
            return Float.NaN;
        }
        if (str.equals("infinity")) {
            return x < 0 ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;
        }
        return x * Float.parseFloat(str);
    }

    static public double parseDouble(String str) {
        str = str.toLowerCase();
        int s = 0;
        double x = 1;
        if (str.charAt(s) == '+') {
            s++;
        } else if (str.charAt(s) == '-') {
            s++;
            x = -1;
        }
        int e = str.length() - 1;
        if (str.charAt(e) == 'd') {
            e--;
        }
        str = str.substring(s, e + 1);
        if (str.equals("nan")) {
            return Double.NaN;
        }
        if (str.equals("infinity")) {
            return x < 0 ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
        }
        return x * Double.parseDouble(str);
    }

    static public int parseInt(String str, int start, int end) {
        int sof = start;
        int x = 1;
        if (str.charAt(sof) == '+') {
            sof++;
        } else if (str.charAt(sof) == '-') {
            sof++;
            x = -1;
        }
        long v;
        if (str.charAt(sof) == '0') {
            sof++;
            if (sof >= end) {
                return 0;
            }
            char c = str.charAt(sof);
            if (c == 'x' || c == 'X') {// hex
                sof++;
                v = Long.parseLong(str.substring(sof, end), 16);
            } else {// oct
                v = Long.parseLong(str.substring(sof, end), 8);
            }
        } else {
            v = Long.parseLong(str.substring(sof, end), 10);
        }
        return (int) (v * x);
    }

    static public int parseInt(String str) {
        return parseInt(str, 0, str.length());
    }

    public static String unescapeStr(String str) {
        return unEscape(str);
    }

    public static Character unescapeChar(String str) {
        return unEscape(str).charAt(0);
    }

    public static int[] toIntArray(List<String> ss) {
        int[] vs = new int[ss.size()];
        for (int i = 0; i < ss.size(); i++) {
            vs[i] = parseInt(ss.get(i));
        }
        return vs;
    }

    public static byte[] toByteArray(List<Object> ss) {
        byte[] vs = new byte[ss.size()];
        for (int i = 0; i < ss.size(); i++) {
            vs[i] = ((Number) (ss.get(i))).byteValue();
        }
        return vs;
    }

    static Map<String, Op> ops = new HashMap<>();

    static {
        for (Op op : Op.values()) {
            ops.put(op.displayName, op);
        }
    }

    static public Op getOp(String name) {
        return ops.get(name);
    }

    public static String unEscape(String str) {
        return unEscape0(str, 1, str.length() - 1);
    }

    public static String unEscapeId(String str) {
        return unEscape0(str, 0, str.length());
    }

    public static int findString(String str, int start, int end, char dEnd) {
        for (int i = start; i < end; ) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                    // ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
                    case 'b':
                    case 't':
                    case 'n':
                    case 'f':
                    case 'r':
                    case '\"':
                    case '\'':
                    case '\\':
                        i += 2;
                        break;
                    case 'u':
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException("can't pase string");
                        }
                        i += 1 + x;
                }

            } else {
                if (c == dEnd) {
                    return i;
                }
                i++;
            }
        }
        return end;
    }

    public static String unEscape0(String str, int start, int end) {

        StringBuilder sb = new StringBuilder();
        for (int i = start; i < end; ) {
            char c = str.charAt(i);
            if (c == '\\') {
                char d = str.charAt(i + 1);
                switch (d) {
                    // ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
                    case 'b':
                        sb.append('\b');
                        i += 2;
                        break;
                    case 't':
                        sb.append('\t');
                        i += 2;
                        break;
                    case 'n':
                        sb.append('\n');
                        i += 2;
                        break;
                    case 'f':
                        sb.append('\f');
                        i += 2;
                        break;
                    case 'r':
                        sb.append('\r');
                        i += 2;
                        break;
                    case '\"':
                        sb.append('\"');
                        i += 2;
                        break;
                    case '\'':
                        sb.append('\'');
                        i += 2;
                        break;
                    case '\\':
                        sb.append('\\');
                        i += 2;
                        break;
                    case 'u':
                        String sub = str.substring(i + 2, i + 6);
                        sb.append((char) Integer.parseInt(sub, 16));
                        i += 6;
                        break;
                    default:
                        int x = 0;
                        while (x < 3) {
                            char e = str.charAt(i + 1 + x);
                            if (e >= '0' && e <= '7') {
                                x++;
                            } else {
                                break;
                            }
                        }
                        if (x == 0) {
                            throw new RuntimeException("can't pase string");
                        }
                        sb.append((char) Integer.parseInt(str.substring(i + 1, i + 1 + x), 8));
                        i += 1 + x;
                }

            } else {
                sb.append(c);
                i++;
            }
        }
        return sb.toString();
    }

    public static class Ann {
        public String name;
        public List<Map.Entry<String, Object>> elements = new ArrayList<>();

        public void put(String name, Object value) {
            elements.add(new java.util.AbstractMap.SimpleEntry<>(name, value));
        }
    }

    public static Visibility getAnnVisibility(String name) {
        return Visibility.valueOf(name.toUpperCase());
    }

    public static int methodIns(Method m, boolean isStatic) {
        int a = isStatic ? 0 : 1;
        for (String t : m.getParameterTypes()) {
            switch (t.charAt(0)) {
                case 'J':
                case 'D':
                    a += 2;
                    break;
                default:
                    a += 1;
                    break;
            }
        }
        return a;
    }

    public static int reg2ParamIdx(Method m, int reg, int locals, boolean isStatic) {
        int x = reg - locals;
        if (x < 0) {
            return -1;
        }
        int a = isStatic ? 0 : 1;
        String[] parameterTypes = m.getParameterTypes();
        for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {

            if (x == a) {
                return i;
            }

            String t = parameterTypes[i];
            switch (t.charAt(0)) {
                case 'J':
                case 'D':
                    a += 2;
                    break;
                default:
                    a += 1;
                    break;
            }
        }
        return -1;
    }

    public static Proto parseProtoAndUnescape(String part) throws RuntimeException {
        int x = 0;
        int y = part.indexOf(')', x);
        if (y < 0) {
            throw new RuntimeException();
        }

        String[] params = toTypeList(part.substring(x + 1, y));
        for (int i = 0; i < params.length; i++) {
            params[i] = unEscapeId(params[i]);
        }
        String ret = unEscapeId(part.substring(y + 1));
        return new Proto(params, ret);
    }

    public static Method parseMethodAndUnescape(String owner, String part) throws RuntimeException {
        int x = part.indexOf('(');
        if (x < 0) {
            throw new RuntimeException();
        }

        String methodName = unEscapeId(part.substring(0, x));

        return new Method(owner, methodName, parseProtoAndUnescape(part.substring(x)));
    }

    public static Method parseMethodAndUnescape(String full) throws RuntimeException {

        int x = full.indexOf("->");
        if (x <= 0) {
            throw new RuntimeException();
        }
        return parseMethodAndUnescape(unEscapeId(full.substring(0, x)), full.substring(x + 2));
    }

    public static Field parseFieldAndUnescape(String owner, String part) throws RuntimeException {
        int x = part.indexOf(':');
        if (x < 0) {
            throw new RuntimeException();
        }
        return new Field(owner, unEscapeId(part.substring(0, x)), unEscapeId(part.substring(x + 1)));
    }

    public static Field parseFieldAndUnescape(String full) throws RuntimeException {
        int x = full.indexOf("->");
        if (x <= 0) {
            throw new RuntimeException();
        }
        return parseFieldAndUnescape(unEscapeId(full.substring(0, x)), full.substring(x + 2));
    }
}

```

`d2j-smali/src/test/java/a/BaksmaliTest.java`:

```java
package a;

import com.googlecode.d2j.smali.Baksmali;
import com.googlecode.d2j.smali.BaksmaliDexFileVisitor;
import com.googlecode.d2j.smali.BaksmaliDumper;
import com.googlecode.d2j.smali.Smali;
import com.googlecode.dex2jar.tools.BaseCmd;
import org.junit.Test;

import java.io.File;
import java.nio.file.FileSystem;
import java.nio.file.Path;

public class BaksmaliTest {


    @Test
    public void t() throws Exception {
        File dir = new File("../dex-translator/src/test/resources/dexes");
        File[] fs = dir.listFiles();
        if (fs != null) {
            for (File f : fs) {
                if (f.getName().endsWith(".dex") || f.getName().endsWith(".apk")) {
                    dotest(f.toPath());
                }
            }
        }
    }

    private void dotest(Path f) throws Exception {
        Path smali0 = new File("target/" + f.getFileName() + "-smali0.zip").toPath();
        try (FileSystem fs0 = BaseCmd.createZip(smali0)) {
            Baksmali.from(f).to(fs0.getPath("/"));
        }
        Path smali1 = new File("target/" + f.getFileName() + "-smali1.zip").toPath();
        try (FileSystem fs0 = BaseCmd.openZip(smali0); FileSystem fs1 = BaseCmd.createZip(smali1)) {
            BaksmaliDumper baksmaliDumper = new BaksmaliDumper();
            BaksmaliDexFileVisitor v = new BaksmaliDexFileVisitor(fs1.getPath("/"), baksmaliDumper);
            Smali.smali(fs0.getPath("/"), v);
        }
    }
}

```

`d2j-smali/src/test/java/a/SmaliTest.java`:

```java
package a;

import com.android.tools.smali.baksmali.Adaptors.ClassDefinition;
import com.android.tools.smali.baksmali.BaksmaliOptions;
import com.android.tools.smali.baksmali.formatter.BaksmaliWriter;
import com.android.tools.smali.dexlib2.DexFileFactory;
import com.android.tools.smali.dexlib2.Opcodes;
import com.android.tools.smali.dexlib2.dexbacked.DexBackedClassDef;
import com.android.tools.smali.dexlib2.dexbacked.DexBackedDexFile;
import com.android.tools.smali.dexlib2.util.SyntheticAccessorResolver;
import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.dex.writer.DexFileWriter;
import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.zip.ZipUtil;
import com.googlecode.d2j.smali.BaksmaliDumpOut;
import com.googlecode.d2j.smali.BaksmaliDumper;
import com.googlecode.d2j.smali.Smali;

import org.junit.Assert;
import org.junit.Test;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class SmaliTest {
    @Test
    public void test() throws IOException {
        DexFileNode dfn = new DexFileNode();
        try (InputStream is = SmaliTest.class.getResourceAsStream("/a.smali")) {
            Smali.smaliFile("a.smali", is, dfn);
        }
        for (DexClassNode dcn : dfn.clzs) {
            BufferedWriter w = new BufferedWriter(new OutputStreamWriter(System.out));
            new BaksmaliDumper(true, true).baksmaliClass(dcn, new BaksmaliDumpOut(w));
            w.flush();
        }
    }

    Map<String, DexClassNode> readDex(File path) throws IOException {
        DexFileReader dexFileReader = new DexFileReader(ZipUtil.readDex(path));
        DexFileNode dexFileNode = new DexFileNode();
        dexFileReader.accept(dexFileNode);
        Map<String, DexClassNode> map = new HashMap<>();
        for (DexClassNode c : dexFileNode.clzs) {
            map.put(c.className, c);
        }
        return map;
    }

    @Test
    public void test2() throws IOException {
        File dir = new File("../dex-translator/src/test/resources/dexes");
        File[] fs = dir.listFiles();
        if (fs != null) {
            for (File f : fs) {
                if (f.getName().endsWith(".dex") || f.getName().endsWith(".apk")) {
                    System.out.println(f.getName());
                    if (f.getName().equals("dex040.dex")) {
                        // FIXME smali 3.0.3 not support space in SimpleName
                        continue;
                    }
                    dotest(f);
                }
            }
        }
    }

    private void dotest(File dexFile) throws IOException {
        int dexVersion = new DexFileReader(dexFile).getDexVersion();
        Opcodes opcodes = Opcodes.forApi(DexConstants.toMiniAndroidApiLevel(dexVersion));
        DexBackedDexFile dex;
        try {
            dex = DexFileFactory.loadDexFile(dexFile, opcodes);
        } catch (DexBackedDexFile.NotADexFile ex) {
            ex.printStackTrace();
            return;
        }
        Map<String, DexClassNode> map = readDex(dexFile);

        for (DexBackedClassDef def : dex.getClasses()) {
            String type = def.getType();
            System.out.println(type);
            DexClassNode dexClassNode = map.get(type);
            Assert.assertNotNull(dexClassNode);
            String smali = baksmali(def); // original

            Smali.smaliFile2Node("fake.smali", smali);

            {
                byte[] data = toDex(dexClassNode);
                DexBackedClassDef def2 = new DexBackedDexFile(opcodes, data).getClasses().iterator().next();
                String baksmali3 = baksmali(def2); // original
                Assert.assertEquals(smali, baksmali3);
            }

            String psmali = pbaksmali(dexClassNode);
            DexClassNode dexClassNode2 = Smali.smaliFile2Node("fake.smali", psmali);
            Assert.assertEquals("cmp smalip", psmali, pbaksmali(dexClassNode2));

            {
                byte[] data = toDex(dexClassNode2);
                DexBackedClassDef def2 = new DexBackedDexFile(opcodes, data).getClasses().iterator().next();
                String baksmali3 = baksmali(def2); // original
                Assert.assertEquals(smali, baksmali3);
            }
        }
    }

    private byte[] toDex(DexClassNode dexClassNode2) {
        DexFileWriter w = new DexFileWriter();
        dexClassNode2.accept(w);
        w.visitEnd();
        return w.toByteArray();
    }

    private static String pbaksmali(DexClassNode dcn) throws IOException {
        StringWriter bufWriter = new StringWriter();
        BufferedWriter w = new BufferedWriter(bufWriter);
        new BaksmaliDumper(true, true).baksmaliClass(dcn, new BaksmaliDumpOut(w));
        w.flush();
        bufWriter.flush();
        return bufWriter.toString();
    }

    private static String baksmali(DexBackedClassDef def) throws IOException {
        BaksmaliOptions opts = new BaksmaliOptions();
        opts.debugInfo = false;
        opts.syntheticAccessorResolver = new SyntheticAccessorResolver(def.dexFile.getOpcodes(), Collections.EMPTY_LIST);
        ClassDefinition classDefinition = new ClassDefinition(opts, def);
        StringWriter bufWriter = new StringWriter();
        BaksmaliWriter writer = new BaksmaliWriter(bufWriter);
        classDefinition.writeTo(writer);
        writer.flush();
        return bufWriter.toString();
    }
}

```

`d2j-smali/src/test/resources/a.smali`:

```smali
.class public La;
.super Ljava/lang/Object;
.implements Lj; .implements Lq; 
.source "aaa"
.source "aa\u1234a"

.field private a:Ljava/lang/String; = NAN
.field private a:Ljava/lang/String; = NANf
.field private a:Ljava/lang/String; = NANd
.field private a:Ljava/lang/String; = nan
.field private a:Ljava/lang/String; = -infinityF
.field private a:Ljava/lang/String; = +infinityF
.field private a:Ljava/lang/String; = -infinityD
.field private a:Ljava/lang/String; = +infinityD
.field private a:Ljava/lang/String; = -infinity
.field private a:Ljava/lang/String; = +infinity
.field private a:Ljava/lang/String; = nan
.field private a:Ljava/lang/String; = nanf
.field private a:Ljava/lang/String; = nand
.field private a:Ljava/lang/String; = 0.2
.field private a:Ljava/lang/String; = 0.2f
.field private a:Ljava/lang/String; = 0x1
.field private a:Ljava/lang/String; = +0x1
.field private a:Ljava/lang/String; = -0x1
.field private a:Ljava/lang/String; = 0
.field private a:Ljava/lang/String; = 001
.field private a:Ljava/lang/String; = 123
.field private a:Ljava/lang/String; = 123t
.field private a:Ljava/lang/String; = 123s
.field private a:Ljava/lang/String; = 123f
.field private a:Ljava/lang/String; = 123d
.field private a:Ljava/lang/String; = .enum La;->d:I
.field private a:Ljava/lang/String; = 't'
.field private a:Ljava/lang/String; = '\t'
.field private a:Ljava/lang/String; = '\u1234'
.field private a:Ljava/lang/String; = true
.field private a:Ljava/lang/String; = 0x7fffffff
.annotation system La;
.end annotation
.end field
.method public I(II)V
.parameter "AAAA"
.annotation system La;
.end annotation
.end parameter
.parameter
.registers 4
.local v2, a : I
.local v2, a:I
.local v2, "a":I
.end local v2
.restart local v2
.end method
.method private Lggg;->static([Z)V
.end method
.method private static([Z)V
.end method
.method private Lg>gg;->static([Z)V
.end method
```

`dex-ir/build.gradle`:

```gradle
description = 'Dex Translator'

dependencies {
  compile project(':dex-reader-api')
}


```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ET.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir;

import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt;

/**
 * The number of argument
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 * @see Stmt
 * @see Value
 */
public enum ET {

    /**
     * no argument
     */
    E0,
    /**
     * 1 argument
     */
    E1,
    /**
     * 2 argument
     */
    E2,
    /**
     * 3+ argument
     */
    En
}
```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/IrMethod.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.StmtList;

/**
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class IrMethod {

    public boolean isStatic;
    public String[] args;
    public List<Local> locals = new ArrayList<Local>();
    public String name;

    public String owner;

    public String ret;

    public StmtList stmts = new StmtList();

    public List<Trap> traps = new ArrayList<Trap>();
    public List<LocalVar> vars = new ArrayList<LocalVar>();
    public List<LabelStmt> phiLabels;

    public IrMethod clone() {
        IrMethod n = new IrMethod();
        LabelAndLocalMapper mapper = new LabelAndLocalMapper();
        n.name = name;
        n.args = args;
        n.isStatic = isStatic;
        n.owner = owner;
        n.ret = ret;
        n.stmts = stmts.clone(mapper);
        for (Trap trap : traps) {
            n.traps.add(trap.clone(mapper));
        }
        for (LocalVar var : vars) {
            n.vars.add(var.clone(mapper));
        }
        if (phiLabels != null) {
            List<LabelStmt> nPhiLabels = new ArrayList<>(phiLabels.size());
            for (LabelStmt labelStmt : phiLabels) {
                nPhiLabels.add(labelStmt.clone(mapper));
            }
            n.phiLabels = nPhiLabels;
        }
        for(Local local:locals){
            n.locals.add((Local) local.clone(mapper));
        }
        return n;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("// ").append(this.owner).append("\n");
        if (isStatic) {
            sb.append(" static ");
        }
        sb.append(ret == null ? null : Util.toShortClassName(ret)).append(' ').append(this.name).append('(');
        if (args != null) {
            boolean first = true;
            for (String arg : args) {
                if (first) {
                    first = false;
                } else {
                    sb.append(',');
                }
                sb.append(Util.toShortClassName(arg));
            }
        }
        sb.append(") {\n\n").append(stmts).append("\n");
        if (traps.size() > 0 || vars.size() > 0) {
            sb.append("=============\n");
            for (Trap trap : traps) {
                sb.append(trap).append('\n');
            }
            for (LocalVar var : vars) {
                sb.append(var).append('\n');
            }
        }
        sb.append("}");
        return sb.toString();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/LabelAndLocalMapper.java`:

```java
package com.googlecode.dex2jar.ir;

import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmts;

import java.util.HashMap;
import java.util.Map;

public class LabelAndLocalMapper {
    Map<LabelStmt, LabelStmt> labels = new HashMap<>();
    Map<Local, Local> locals = new HashMap<>();

    public LabelStmt map(LabelStmt label) {
        LabelStmt nTarget = labels.get(label);
        if (nTarget == null) {
            nTarget = Stmts.nLabel();
            labels.put(label, nTarget);
        }
        return nTarget;
    }

    public Local map(Local local) {
        Local nTarget = locals.get(local);
        if (nTarget == null) {
            nTarget = (Local) local.clone();
            locals.put(local, nTarget);
        }
        return nTarget;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/LocalVar.java`:

```java
package com.googlecode.dex2jar.ir;

import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;

public class LocalVar {

    public LabelStmt start, end;
    public String name, type, signature;
    public Local reg;

    public LocalVar(String name, String type, String signature, LabelStmt start, LabelStmt end, Local reg) {
        this.name = name;
        this.start = start;
        this.end = end;
        this.type = type;
        this.signature = signature;
        this.reg = reg;
    }

    public LocalVar clone(LabelAndLocalMapper map) {
        return new LocalVar(name, type, signature, start.clone(map), end.clone(map), (Local) reg.clone());
    }

    @Override
    public String toString() {
        return String.format(".var %s ~ %s %s -> %s //%s", start.getDisplayName(), end.getDisplayName(), reg, name,
                type);
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/StmtSearcher.java`:

```java
package com.googlecode.dex2jar.ir;

import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.StmtList;

public class StmtSearcher {
    public void travel(StmtList stmts) {
        for (Stmt stmt : stmts) {
            travel(stmt);
        }
    }

    public void travel(Stmt stmt) {
        switch (stmt.et) {
            case E0:
                break;
            case E1:
               travel(stmt.getOp());
                break;
            case E2:
                travel(stmt.getOp1());
                travel(stmt.getOp2());
                break;
            case En:
                Value[] ops = stmt.getOps();
                for (Value op : ops) {
                    travel(op);
                }
                break;
        }
    }

    public void travel(Value op) {
        switch (op.et) {
            case E0:
                break;
            case E1:
                travel(op.getOp());
                break;
            case E2:
                travel(op.getOp1());
                travel(op.getOp2());
                break;
            case En:
                Value[] ops = op.getOps();
                for (Value op1 : ops) {
                    travel(op1);
                }
                break;
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/StmtTraveler.java`:

```java
package com.googlecode.dex2jar.ir;

import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.StmtList;

import java.util.Iterator;

public class StmtTraveler {
    public void travel(IrMethod method) {
        travel(method.stmts);
    }
    public void travel(StmtList stmts) {
        for (Iterator<Stmt> it = stmts.iterator(); it.hasNext(); ) {
            Stmt stmt = it.next();
            Stmt n = travel(stmt);
            if (n != stmt) {
                stmts.insertBefore(stmt, n);
                it.remove();
            }
        }
    }

    public Stmt travel(Stmt stmt) {
        switch (stmt.et) {
            case E0:
                break;
            case E1:
                stmt.setOp(travel(stmt.getOp()));
                break;
            case E2:
                stmt.setOp1(travel(stmt.getOp1()));
                stmt.setOp2(travel(stmt.getOp2()));
                break;
            case En:
                Value[] ops = stmt.getOps();
                for (int i = 0; i < ops.length; i++) {
                    ops[i] = travel(ops[i]);
                }
                break;
        }
        return stmt;
    }

    public Value travel(Value op) {
        switch (op.et) {
            case E0:
                break;
            case E1:
                op.setOp(travel(op.getOp()));
                break;
            case E2:
                op.setOp1(travel(op.getOp1()));
                op.setOp2(travel(op.getOp2()));
                break;
            case En:
                Value[] ops = op.getOps();
                for (int i = 0; i < ops.length; i++) {
                    ops[i] = travel(ops[i]);
                }
                break;
        }

        return op;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/TransformerException.java`:

```java
package com.googlecode.dex2jar.ir;

public class TransformerException extends RuntimeException {

    /**
     * 
     */
    private static final long serialVersionUID = -5074963043184589213L;

    public TransformerException() {
        super();
    }

    public TransformerException(String arg0, Throwable arg1) {
        super(arg0, arg1);
    }

    public TransformerException(String arg0) {
        super(arg0);
    }

    public TransformerException(Throwable arg0) {
        super(arg0);
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/Trap.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir;

import com.googlecode.dex2jar.ir.stmt.LabelStmt;

/**
 * TODO DOC
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Trap {
    public LabelStmt start, end, handlers[];
    public String types[];

    public Trap() {
        super();
    }

    public Trap(LabelStmt start, LabelStmt end, LabelStmt handlers[], String types[]) {
        super();
        this.start = start;
        this.end = end;
        this.handlers = handlers;
        this.types = types;
    }

    public Trap clone(LabelAndLocalMapper mapper) {
        int size = handlers.length;
        LabelStmt[] cloneHandlers = new LabelStmt[size];
        String[] cloneTypes = new String[size];
        for (int i = 0; i < size; i++) {
            cloneHandlers[i] = handlers[i].clone(mapper);
            cloneTypes[i] = types[i];
        }
        return new Trap(start.clone(mapper), end.clone(mapper), cloneHandlers, cloneTypes);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(String.format(".catch %s - %s : ", start.getDisplayName(),
                end.getDisplayName()));
        for (int i = 0; i < handlers.length; i++) {
            sb.append(types[i] == null ? "all" : types[i]).append(" > ").append(handlers[i].getDisplayName())
                    .append(",");
        }
        return sb.toString();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/TypeClass.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir;

public enum TypeClass {

    BOOLEAN("Z", true), //
    INT("I", true), //
    FLOAT("F", true), //
    DOUBLE("D", true), //
    LONG("J", true), //
    OBJECT("L", true), //
    VOID("V", true), //
    UNKNOWN("?"), //
    ZIL("s"), //
    ZIFL("z"), //
    ZIF("m"), //
    ZI("n"), //
    IF("i"), //
    JD("w"); //

    public String name;
    public boolean fixed;

    TypeClass(String use, boolean fixed) {
        this.name = use;
        this.fixed = fixed;
    }

    TypeClass(String use) {
        this.name = use;
        this.fixed = false;
    }

    public static TypeClass clzOf(String desc) {
        switch (desc.charAt(0)) {
        case 'Z':
            return BOOLEAN;
        case 'B':
        case 'C':
        case 'S':
        case 'I':
            return INT;
        case 'F':
            return FLOAT;
        case 'D':
            return DOUBLE;
        case 'J':
            return LONG;
        case 'L':
        case '[':
            return OBJECT;
        case 'V':
            return VOID;
        case 'z':
            return ZIFL;
        case 's':
            return ZIL;
        case 'i':
            return IF;
        case 'm':
            return ZIF;
        case 'n':
            return ZI;
        case 'w':
            return JD;
        default:
            return UNKNOWN;
        }
    }

    public static TypeClass merge(TypeClass thizCls, TypeClass clz) {
        if (thizCls == clz) {
            return thizCls;
        }
        if (thizCls == TypeClass.UNKNOWN) {
            return clz;
        } else if (clz == TypeClass.UNKNOWN) {
            // do nothing
            return thizCls;
        } else {
            if (thizCls.fixed) {
                if (clz.fixed) {
                    // special case for merge I and Z
                    // https://bitbucket.org/pxb1988/dex2jar/issues/1/javalangruntimeexception-can-not-merge-i
                    // http://sourceforge.net/p/dex2jar/tickets/237/
                    if ((thizCls == INT && clz == BOOLEAN) || (thizCls == BOOLEAN || clz == INT)) {
                        return INT;
                    }
                    throw new RuntimeException("Can't merge " + thizCls + " and " + clz);
                } else {
                    return thizCls;
                }
            } else if (clz.fixed) {
                return clz;
            } else { // both not fixed
                return merge0(thizCls, clz);
            }
        }
    }

    /**
     * X     ZIL   ZIFL ZIF  ZI  IF
     * ZIL   X     ZIL  ZI   ZI  I
     * ZIFL  ZIL   X    ZIF  ZI  IF
     * ZIF   ZI    ZIF  X    ZI  IF
     * ZI    ZI    ZI   ZI   X   I
     * IF    I     IF   IF   I   X
     */
    private static TypeClass merge0(TypeClass a, TypeClass b) {
        if (a == JD || b == JD) {
            throw new RuntimeException("Can't merge " + a + " and " + b);
        }
        switch (a) {
            case ZIL:
                switch (b) {
                    case ZIFL:
                        return ZIL;
                    case IF:
                        return INT;
                    case ZIF:
                    case ZI:
                        return ZI;
                    default:
                }
            case ZIFL:
                return b;
            case IF:
                switch (b) {
                    case ZIL:
                    case ZI:
                        return INT;
                    case ZIFL:
                    case ZIF:
                        return IF;
                    default:
                }
            case ZIF:
                switch (b) {
                    case IF:
                        return IF;
                    case ZIL:
                    case ZI:
                        return ZI;
                    case ZIFL:
                        return ZIF;
                    default:
                }
            case ZI:
                if (b == TypeClass.IF) {
                    return INT;
                } else {
                    return ZI;
                }
            default:
        }
        throw new RuntimeException();
    }

    public String toString() {
        return name;
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/Util.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir;

import java.util.ArrayList;
import java.util.List;

/**
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Util {
    public static List<String> listDesc(String desc) {
        List<String> list = new ArrayList<String>(5);
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
            case 'V':
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
            case 'F':
            case 'J':
            case 'D':
                list.add(Character.toString(chars[i]));
                i++;
                break;
            case '[': {
                int count = 1;
                while (chars[i + count] == '[') {
                    count++;
                }
                if (chars[i + count] == 'L') {
                    count++;
                    while (chars[i + count] != ';') {
                        count++;
                    }
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }
            case 'L': {
                int count = 1;
                while (chars[i + count] != ';') {
                    ++count;
                }
                count++;
                list.add(new String(chars, i, count));
                i += count + 1;
                break;
            }
            default:
            }
        }
        return list;
    }

    /**
     * Appends a quoted string to a given buffer.
     * 
     * @param buf
     *            the buffer where the string must be added.
     * @param s
     *            the string to be added.
     */
    public static void appendString(final StringBuffer buf, final String s) {
        buf.append('\"');
        for (int i = 0; i < s.length(); ++i) {
            char c = s.charAt(i);
            if (c == '\n') {
                buf.append("\\n");
            } else if (c == '\r') {
                buf.append("\\r");
            } else if (c == '\\') {
                buf.append("\\\\");
            } else if (c == '"') {
                buf.append("\\\"");
            } else if (c < 0x20 || c > 0x7f) {
                buf.append("\\u");
                if (c < 0x10) {
                    buf.append("000");
                } else if (c < 0x100) {
                    buf.append("00");
                } else if (c < 0x1000) {
                    buf.append('0');
                }
                buf.append(Integer.toString(c, 16));
            } else {
                buf.append(c);
            }
        }
        buf.append('\"');
    }

    public static String toShortClassName(String desc) {
        switch (desc.charAt(0)) {
        case 'Z':
            return "boolean";
        case 'B':
            return "byte";
        case 'C':
            return "char";
        case 'S':
            return "short";
        case 'I':
            return "int";
        case 'J':
            return "long";
        case 'F':
            return "float";
        case 'D':
            return "double";
        case 'V':
            return "void";
        case 'L': {
            int i = desc.lastIndexOf('/');
            return desc.substring(i < 0 ? 1 : i + 1, desc.length() - 1);
        }
        case '[':
            int d = 1;
            for (; d < desc.length(); d++) {
                if (desc.charAt(d) != '[') {
                    break;
                }
            }
            StringBuilder sb = new StringBuilder().append(toShortClassName(desc.substring(d)));
            for (int t = 0; t < d; t++) {
                sb.append("[]");
            }
            return sb.toString();
        }
        throw new UnsupportedOperationException();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/AbstractInvokeExpr.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;


import com.googlecode.d2j.Proto;
import com.googlecode.dex2jar.ir.expr.Value.EnExpr;

public abstract class AbstractInvokeExpr extends EnExpr {
    @Override
    protected void releaseMemory() {
        super.releaseMemory();
    }

    public abstract Proto getProto();

    public AbstractInvokeExpr(VT type, Value[] args) {
        super(type, args);
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/ArrayExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value.E2Expr;

/**
 * Represent an Array expression
 * 
 * @see VT#ARRAY
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class ArrayExpr extends E2Expr {

    public ArrayExpr() {
        super(VT.ARRAY, null, null);
    }

    public String elementType;

    public ArrayExpr(Value base, Value index, String elementType) {
        super(VT.ARRAY, base, index);
        this.elementType = elementType;
    }

    @Override
    public Value clone() {
        return new ArrayExpr(op1.trim().clone(), op2.trim().clone(), this.elementType);
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new ArrayExpr(op1.clone(mapper), op2.clone(mapper), this.elementType);
    }

    @Override
    public String toString0() {
        return op1 + "[" + op2 + "]";
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/BinopExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value.E2Expr;

/**
 * Represent a Binop expression, value = op1 vt op2
 * 
 * @see VT#ADD
 * @see VT#AND
 * @see VT#LCMP
 * @see VT#FCMPG
 * @see VT#DCMPG
 * @see VT#FCMPL
 * @see VT#DCMPL
 * @see VT#DIV
 * @see VT#EQ
 * @see VT#GE
 * @see VT#GT
 * @see VT#LE
 * @see VT#LT
 * @see VT#MUL
 * @see VT#NE
 * @see VT#OR
 * @see VT#REM
 * @see VT#SHL
 * @see VT#SHR
 * @see VT#SUB
 * @see VT#USHR
 * @see VT#XOR
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class BinopExpr extends E2Expr {
    public String type;

    public BinopExpr(VT vt, Value op1, Value op2, String type) {
        super(vt, op1, op2);
        this.type = type;
    }

    @Override
    protected void releaseMemory() {
        type = null;
        super.releaseMemory();
    }

    @Override
    public Value clone() {
        return new BinopExpr(vt, op1.trim().clone(), op2.trim().clone(), type);
    }
    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new BinopExpr(vt, op1.clone(mapper), op2.clone(mapper), type);
    }
    @Override
    public String toString0() {
        return "(" + op1 + " " + super.vt + " " + op2 + ")";
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/CastExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;
import com.googlecode.dex2jar.ir.expr.Value.E1Expr;

/**
 * * @see VT#CAST
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class CastExpr extends E1Expr {
    public String from;
    public String to;

    public CastExpr(Value value, String from, String to) {
        super(VT.CAST, value);
        this.from = from;
        this.to = to;
    }

    @Override
    protected void releaseMemory() {
        from = to = null;
        super.releaseMemory();
    }

    @Override
    public Value clone() {
        return new CastExpr(op.trim().clone(), from, to);
    }
    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new CastExpr(op.clone(mapper), from, to);
    }
    @Override
    public String toString0() {
        return "((" + Util.toShortClassName(to) + ")" + op + ")";
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/Constant.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.d2j.DexType;
import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;
import com.googlecode.dex2jar.ir.expr.Value.E0Expr;

import java.lang.reflect.Array;

/**
 * Represent a constant, number/string/type
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Constant extends E0Expr {

    public static final Object Null = new Object();

    public Object value;

    public Constant(Object value) {
        super(VT.CONSTANT);
        this.value = value;
    }

    @Override
    public Value clone() {
        return new Constant(value);
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new Constant(value);
    }

    @Override
    public String toString0() {
        if (Null == value) {
            return "null";
        } else if (value == null) {
            return "NULL";
        } else if (value instanceof Number) {
            if (value instanceof Float) {
                return value.toString() + "F";
            }
            if (value instanceof Long) {
                return value.toString() + "L";
            }
            return value.toString();
        } else if (value instanceof String) {
            StringBuffer buf = new StringBuffer();
            Util.appendString(buf, (String) value);
            return buf.toString();
        } else if (value instanceof DexType) {
            return Util.toShortClassName(((DexType) value).desc) + ".class";
        } else if (value.getClass().isArray()) {
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            int size = Array.getLength(value);
            for (int i = 0; i < size; i++) {
                sb.append(Array.get(value, i)).append(",");
            }
            if (size > 0) {
                sb.setLength(sb.length() - 1);
            }
            sb.append("]");
            return sb.toString();
        }
        return "" + value;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/Exprs.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.d2j.CallSite;
import com.googlecode.d2j.DexType;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.MethodHandle;
import com.googlecode.d2j.Proto;
import com.googlecode.dex2jar.ir.expr.Value.VT;

public final class Exprs {
    public static Value[] copy(Value[] v) {
        if (v == null) {
            return new Value[0];
        }
        Value vb[] = new Value[v.length];
        for (int i = 0; i < v.length; i++) {
            vb[i] = v[i].trim();
        }
        return vb;
    }

    public static Constant nByte(byte i) {
        return new Constant(i);
    }

    public static Constant nChar(char i) {
        return new Constant(i);
    }

    public static Constant nType(String desc) {
        return new Constant(new DexType(desc));
    }
    public static Constant nType(DexType t) {
        return new Constant(t);
    }

    public static Constant nDouble(double i) {
        return new Constant(i);
    }

    public static Constant nFloat(float i) {
        return new Constant(i);
    }

    public static Constant nInt(int i) {
        return new Constant(i);
    }

    public static Constant nLong(long i) {
        return new Constant(i);
    }

    public static Constant nNull() {
        return new Constant(Constant.Null);
    }

    public static Constant nShort(short i) {
        return new Constant(i);
    }

    public static Constant nString(String i) {
        return new Constant(i);
    }
    public static Constant nMethodHandle(MethodHandle i) {
        return new Constant(i);
    }
    public static Constant nProto(Proto i) {
        return new Constant(i);
    }
    public static BinopExpr nAdd(Value a, Value b, String type) {
        return new BinopExpr(VT.ADD, a, b, type);
    }

    public static BinopExpr niAdd(Value a, Value b) {
        return new BinopExpr(VT.ADD, a, b, "I");
    }

    public static BinopExpr nAnd(Value a, Value b, String type) {
        return new BinopExpr(VT.AND, a, b, type);
    }

    public static ArrayExpr nArray(Value base, Value index, String elementType) {
        return new ArrayExpr(base, index, elementType);
    }

    public static Constant nArrayValue(Object array) {
        return new Constant(array);
    }

    public static CastExpr nCast(Value obj, String from, String to) {
        return new CastExpr(obj, from, to);
    }

    public static TypeExpr nCheckCast(Value obj, String type) {
        return new TypeExpr(VT.CHECK_CAST, obj, type);
    }

    public static BinopExpr nDCmpg(Value a, Value b) {
        return new BinopExpr(VT.DCMPG, a, b, "D");
    }

    public static BinopExpr nDCmpl(Value a, Value b) {
        return new BinopExpr(VT.DCMPL, a, b, "D");
    }

    public static BinopExpr nDiv(Value a, Value b, String type) {
        switch (type){
            case "I":
                return new BinopExpr(VT.IDIV, a, b, type);
            case "J":
                return new BinopExpr(VT.LDIV, a, b, type);
            case "F":
                return new BinopExpr(VT.FDIV, a, b, type);
            case "D":
                return new BinopExpr(VT.DDIV, a, b, type);
            default:
                throw new RuntimeException("type must set to one of I/J/F/D");
        }
    }

    public static BinopExpr nEq(Value a, Value b, String type) {
        return new BinopExpr(VT.EQ, a, b, type);
    }

    public static BinopExpr niEq(Value a, Value b) {
        return nEq(a, b, "I");
    }

    public static RefExpr nExceptionRef(String type) {
        return new RefExpr(VT.EXCEPTION_REF, type, -1);
    }

    public static BinopExpr nFCmpg(Value a, Value b) {
        return new BinopExpr(VT.FCMPG, a, b, "F");
    }

    public static BinopExpr nFCmpl(Value a, Value b) {
        return new BinopExpr(VT.FCMPL, a, b, "F");
    }

    public static FieldExpr nField(Value object, String ownerType, String fieldName, String fieldType) {
        return new FieldExpr(object, ownerType, fieldName, fieldType);
    }

    public static BinopExpr nGe(Value a, Value b, String type) {
        return new BinopExpr(VT.GE, a, b, type);
    }

    public static BinopExpr nGt(Value a, Value b, String type) {
        return new BinopExpr(VT.GT, a, b, type);
    }

    public static BinopExpr njGt(Value a, Value b) {
        return new BinopExpr(VT.GT, a, b, "J");
    }

    public static BinopExpr niGt(Value a, Value b) {
        return new BinopExpr(VT.GT, a, b, "I");
    }

    public static TypeExpr nInstanceOf(Value value, String type) {
        return new TypeExpr(VT.INSTANCE_OF, value, type);
    }

    public static InvokeExpr nInvokeInterface(Value[] regs, String owner, String name, String[] argmentTypes,
            String returnType) {
        return new InvokeExpr(VT.INVOKE_INTERFACE, regs, owner, name, argmentTypes, returnType);
    }

    public static InvokeExpr nInvokeNew(Value[] regs, String[] argmentTypes, String owner) {
        return new InvokeExpr(VT.INVOKE_NEW, regs, owner, "<init>", argmentTypes, owner);
    }

    public static InvokeExpr nInvokeSpecial(Value[] regs, String owner, String name, String[] argmentTypes,
            String returnType) {
        return new InvokeExpr(VT.INVOKE_SPECIAL, regs, owner, name, argmentTypes, returnType);
    }

    public static InvokeExpr nInvokeStatic(Value[] regs, String owner, String name, String[] argmentTypes,
            String returnType) {
        return new InvokeExpr(VT.INVOKE_STATIC, regs, owner, name, argmentTypes, returnType);
    }

    public static InvokeExpr nInvokeVirtual(Value[] regs, String owner, String name, String[] argmentTypes,
            String returnType) {
        return new InvokeExpr(VT.INVOKE_VIRTUAL, regs, owner, name, argmentTypes, returnType);
    }

    public static InvokeCustomExpr nInvokeCustom(Value[] regs, CallSite callSite) {
        return new InvokeCustomExpr(VT.INVOKE_CUSTOM, regs , callSite);
    }

    public static InvokePolymorphicExpr nInvokePolymorphic(Value[] regs, Proto proto, Method method) {
        return new InvokePolymorphicExpr(VT.INVOKE_POLYMORPHIC, regs , proto, method);
    }

    public static BinopExpr nLCmp(Value a, Value b) {
        return new BinopExpr(VT.LCMP, a, b, "J");
    }

    public static BinopExpr nLe(Value a, Value b, String type) {
        return new BinopExpr(VT.LE, a, b, type);
    }

    public static UnopExpr nLength(Value array) {
        return new UnopExpr(VT.LENGTH, array, null);
    }

    public static Local nLocal(int index) {
        return new Local(index);
    }

    public static Local nLocal(String debugName) {
        return new Local(debugName);
    }

    public static Local nLocal(int index, String debugName) {
        return new Local(index, debugName);
    }

    public static BinopExpr nLt(Value a, Value b, String type) {
        return new BinopExpr(VT.LT, a, b, type);
    }

    public static BinopExpr nMul(Value a, Value b, String type) {
        return new BinopExpr(VT.MUL, a, b, type);
    }

    public static BinopExpr nNe(Value a, Value b, String type) {
        return new BinopExpr(VT.NE, a, b, type);
    }

    public static UnopExpr nNeg(Value array, String type) {
        return new UnopExpr(VT.NEG, array, type);
    }

    public static NewExpr nNew(String type) {
        return new NewExpr(type);
    }

    public static TypeExpr nNewArray(String elementType, Value size) {
        return new TypeExpr(VT.NEW_ARRAY, size, elementType);
    }

    public static TypeExpr nNewIntArray(Value size) {
        return nNewArray("I", size);
    }

    public static TypeExpr nNewLongArray(Value size) {
        return nNewArray("J", size);
    }

    public static FilledArrayExpr nFilledArray(String elementType, Value[] datas) {
        return new FilledArrayExpr(datas, elementType);
    }

    public static NewMutiArrayExpr nNewMutiArray(String base, int dim, Value[] sizes) {
        return new NewMutiArrayExpr(base, dim, sizes);
    }

    public static UnopExpr nNot(Value array, String type) {
        return new UnopExpr(VT.NOT, array, type);
    }

    public static BinopExpr nOr(Value a, Value b, String type) {
        return new BinopExpr(VT.OR, a, b, type);
    }

    public static RefExpr nParameterRef(String type, int index) {
        return new RefExpr(VT.PARAMETER_REF, type, index);
    }

    public static BinopExpr nRem(Value a, Value b, String type) {
        return new BinopExpr(VT.REM, a, b, type);
    }

    public static BinopExpr nShl(Value a, Value b, String type) {
        return new BinopExpr(VT.SHL, a, b, type);
    }

    public static BinopExpr nShr(Value a, Value b, String type) {
        return new BinopExpr(VT.SHR, a, b, type);
    }

    public static StaticFieldExpr nStaticField(String ownerType, String fieldName, String fieldType) {
        return new StaticFieldExpr(ownerType, fieldName, fieldType);
    }

    public static BinopExpr nSub(Value a, Value b, String type) {
        return new BinopExpr(VT.SUB, a, b, type);
    }

    public static RefExpr nThisRef(String type) {
        return new RefExpr(VT.THIS_REF, type, -1);
    }

    public static BinopExpr nUshr(Value a, Value b, String type) {
        return new BinopExpr(VT.USHR, a, b, type);
    }

    public static BinopExpr nXor(Value a, Value b, String type) {
        return new BinopExpr(VT.XOR, a, b, type);
    }

    private Exprs() {
    }

    public static PhiExpr nPhi(Value... ops) {
        return new PhiExpr(ops);
    }

    public static Constant nConstant(Object cst) {
        return new Constant(cst);
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/FieldExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value.E1Expr;

/**
 * Represent a non-static Field expression.
 * 
 * @see VT#FIELD
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 9fd8005bbaa4 $
 */
public class FieldExpr extends E1Expr {

    /**
     * Field name
     */
    public String name;
    /**
     * Field owner type descriptor
     */
    public String owner;
    /**
     * Field type descriptor
     */
    public String type;

    public FieldExpr(Value object, String ownerType, String fieldName, String fieldType) {
        super(VT.FIELD, object);
        this.type = fieldType;
        this.name = fieldName;
        this.owner = ownerType;
    }

    @Override
    protected void releaseMemory() {
        name = null;
        owner = type = null;
        super.releaseMemory();
    }

    @Override
    public Value clone() {
        return new FieldExpr(op.trim().clone(), owner, name, type);
    }
    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new FieldExpr(op.clone(mapper), owner, name, type);
    }

    @Override
    public String toString0() {
        return op + "." + name;
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/FilledArrayExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;
import com.googlecode.dex2jar.ir.expr.Value.EnExpr;

/**
 * Represent a FILLED_ARRAY expression.
 *
 * @see VT#FILLED_ARRAY
 */
public class FilledArrayExpr extends EnExpr {

    public String type;
    @Override
    protected void releaseMemory() {
        type = null;
        super.releaseMemory();
    }
    public FilledArrayExpr(Value[] datas, String type) {
        super(VT.FILLED_ARRAY, datas);
        this.type = type;
    }

    @Override
    public Value clone() {
        return new FilledArrayExpr(cloneOps(), type);
    }
    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new FilledArrayExpr(cloneOps(mapper), type);
    }

    @Override
    public String toString0() {
        StringBuilder sb = new StringBuilder().append("new ").append(Util.toShortClassName(type)).append("[]{");
        for (int i = 0; i < ops.length; i++) {
            sb.append(ops[i]).append(", ");
        }
        if (ops.length > 0) {
            sb.setLength(sb.length() - 2); // remove tail ", "
        }
        sb.append('}');
        return sb.toString();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/InvokeCustomExpr.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.d2j.CallSite;
import com.googlecode.d2j.Proto;
import com.googlecode.dex2jar.ir.LabelAndLocalMapper;

public class InvokeCustomExpr extends AbstractInvokeExpr {
    public CallSite callSite;

    @Override
    protected void releaseMemory() {
        callSite = null;
        super.releaseMemory();
    }

    @Override
    public Proto getProto() {
        return callSite.getMethodProto();
    }

    public InvokeCustomExpr(VT type, Value[] args, CallSite callSite) {
        super(type, args);
        this.callSite = callSite;
    }

    @Override
    public Value clone() {
        return new InvokeCustomExpr(vt, cloneOps(), callSite);
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new InvokeCustomExpr(vt, cloneOps(mapper), callSite);
    }

    @Override
    public String toString0() {
        StringBuilder sb = new StringBuilder();

        sb.append("InvokeCustomExpr(....)");
        return sb.toString();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/InvokeExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.Proto;
import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;
import com.googlecode.dex2jar.ir.expr.Value.EnExpr;

/**
 * Represent a method invocation expression. To represent a {@link VT#INVOKE_INTERFACE},{@link VT#INVOKE_SPECIAL} or
 * {@link VT#INVOKE_VIRTUAL} the first element of ops is the owner object,To represent a {@link VT#INVOKE_NEW} or
 * {@link VT#INVOKE_STATIC} all ops are arguments. The return type of {@link VT#INVOKE_NEW} is owner instead of ret
 *
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 9fd8005bbaa4 $
 * @see VT#INVOKE_INTERFACE
 * @see VT#INVOKE_NEW
 * @see VT#INVOKE_SPECIAL
 * @see VT#INVOKE_STATIC
 * @see VT#INVOKE_VIRTUAL
 */
public class InvokeExpr extends AbstractInvokeExpr {

    public Method method;

    @Override
    protected void releaseMemory() {
        method = null;
        super.releaseMemory();
    }

    @Override
    public Proto getProto() {
        return method.getProto();
    }

    public InvokeExpr(VT type, Value[] args, String ownerType, String methodName, String[] argmentTypes,
                      String returnType) {
        super(type, args);
        this.method = new Method(ownerType, methodName, argmentTypes, returnType);
    }

    public InvokeExpr(VT type, Value[] args, Method method) {
        super(type, args);
        this.method = method;
    }

    @Override
    public Value clone() {
        return new InvokeExpr(vt, cloneOps(), method);
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new InvokeExpr(vt, cloneOps(mapper), method);
    }

    @Override
    public String toString0() {
        StringBuilder sb = new StringBuilder();

        int i = 0;
        if (super.vt == VT.INVOKE_NEW) {
            sb.append("new ").append(Util.toShortClassName(method.getOwner()));
        } else if (super.vt == VT.INVOKE_STATIC) {
            sb.append(Util.toShortClassName(method.getOwner())).append('.')
                    .append(this.method.getName());
        } else {
            sb.append(ops[i++]).append('.').append(this.method.getName());
        }
        sb.append('(');
        boolean first = true;
        for (; i < ops.length; i++) {
            if (first) {
                first = false;
            } else {
                sb.append(',');
            }
            sb.append(ops[i]);
        }
        sb.append(')');
        return sb.toString();
    }

    public String getOwner() {
        return method.getOwner();
    }

    public String getRet() {
        return method.getReturnType();
    }

    public String getName() {
        return method.getName();
    }

    public String[] getArgs() {
        return method.getParameterTypes();
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/InvokePolymorphicExpr.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.Proto;
import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;

public class InvokePolymorphicExpr extends AbstractInvokeExpr {
    public Proto proto;
    public Method method;

    @Override
    protected void releaseMemory() {
        method = null;
        proto = null;
        super.releaseMemory();
    }

    @Override
    public Proto getProto() {
        return proto;
    }

    public InvokePolymorphicExpr(VT type, Value[] args, Proto proto, Method method) {
        super(type, args);
        this.proto = proto;
        this.method = method;
    }

    @Override
    public Value clone() {
        return new InvokePolymorphicExpr(vt, cloneOps(), proto, method);
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new InvokePolymorphicExpr(vt, cloneOps(mapper), proto, method);
    }

    @Override
    public String toString0() {
        StringBuilder sb = new StringBuilder();
        int i = 0;
        sb.append(ops[i++]).append('.').append(this.method.getName());
        String[] argTypes = getProto().getParameterTypes();
        sb.append('(');
        int j = 0;
        boolean first = true;
        for (; i < ops.length; i++) {
            if (first) {
                first = false;
            } else {
                sb.append(',');
            }
            sb.append("(").append(Util.toShortClassName(argTypes[j++])).append(")").append(ops[i]);
        }
        sb.append(')');

        return sb.toString();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/Local.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value.E0Expr;

/**
 * TODO DOC
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Local extends E0Expr {
    public int _ls_index;
    public String signature;
    public String debugName;

    public Local(String debugName) {
        super(Value.VT.LOCAL);
        this.debugName = debugName;
    }

    public Local(int index, String debugName) {
        super(Value.VT.LOCAL);
        this.debugName = debugName;
        this._ls_index = index;
    }

    public Local() {
        super(Value.VT.LOCAL);
    }

    public Local(int index) {
        super(Value.VT.LOCAL);
        this._ls_index = index;
    }

    @Override
    public Value clone() {
        Local clone = new Local(_ls_index);
        clone.debugName = debugName;
        clone.signature = this.signature;
        clone.valueType = this.valueType;
        return clone;
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return mapper.map(this);
    }

    @Override
    public String toString0() {
        if (debugName == null) {
            return "a" + _ls_index;
        } else {
            return debugName + "_" + _ls_index;
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/NewExpr.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;
import com.googlecode.dex2jar.ir.expr.Value.E0Expr;

/**
 * @author Panxiaobo
 */
public class NewExpr extends E0Expr {

    public String type;

    public NewExpr(String type) {
        super(VT.NEW);
        this.type = type;
    }

    @Override
    public Value clone() {
        return new NewExpr(type);
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new NewExpr(type);
    }

    @Override
    protected void releaseMemory() {
        type = null;
        super.releaseMemory();
    }

    @Override
    public String toString0() {
        return "NEW " + Util.toShortClassName(type);
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/NewMutiArrayExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;
import com.googlecode.dex2jar.ir.expr.Value.EnExpr;

/**
 * Represent a NEW_MUTI_ARRAY expression.
 *
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 9fd8005bbaa4 $
 * @see VT#NEW_MUTI_ARRAY
 */
public class NewMutiArrayExpr extends EnExpr {

    /**
     * the basic type, ZBSCIFDJL, no [
     */
    public String baseType;
    /**
     * the dimension of the array,
     * <p/>
     * for baseType: I, dimension 4, the result type is int[][][][];
     * <p/>
     * NOTICE, not all dimension are init in ops, so ops.length <= dimension
     */
    public int dimension;

    public NewMutiArrayExpr(String base, int dimension, Value[] sizes) {
        super(VT.NEW_MUTI_ARRAY, sizes);
        this.baseType = base;
        this.dimension = dimension;
    }

    @Override
    protected void releaseMemory() {
        baseType = null;
        super.releaseMemory();
    }

    @Override
    public Value clone() {
        return new NewMutiArrayExpr(baseType, dimension, cloneOps());
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new NewMutiArrayExpr(baseType, dimension, cloneOps(mapper));
    }

    @Override
    public String toString0() {
        StringBuilder sb = new StringBuilder();
        sb.append("new ").append(Util.toShortClassName(baseType));
        for (Value op : ops) {
            sb.append('[').append(op).append(']');
        }
        for (int i = ops.length; i < dimension; i++) {
            sb.append("[]");
        }
        return sb.toString();
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/PhiExpr.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value.EnExpr;

public class PhiExpr extends EnExpr {

    public PhiExpr(Value[] ops) {
        super(VT.PHI, ops);
    }

    @Override
    public Value clone() {
        return new PhiExpr(cloneOps());
    }
    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new PhiExpr(cloneOps(mapper));
    }
    @Override
    public String toString0() {
        StringBuilder sb = new StringBuilder("φ(");
        boolean first = true;
        for (Value vb : ops) {
            if (first) {
                first = false;
            } else {
                sb.append(", ");
            }
            sb.append(vb);
        }
        sb.append(")");
        return sb.toString();
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/RefExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value.E0Expr;

/**
 * Represent a Reference expression
 * 
 * @see VT#THIS_REF
 * @see VT#PARAMETER_REF
 * @see VT#EXCEPTION_REF
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class RefExpr extends E0Expr {

    public int parameterIndex;

    public String type;

    @Override
    protected void releaseMemory() {
        type = null;
        super.releaseMemory();
    }

    public RefExpr(VT vt, String refType, int index) {
        super(vt);
        this.type = refType;
        this.parameterIndex = index;
    }

    @Override
    public Value clone() {
        return new RefExpr(vt, type, parameterIndex);
    }
    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new RefExpr(vt, type, parameterIndex);
    }

    @Override
    public String toString0() {
        switch (vt) {
        case THIS_REF:
            return "@this";
        case PARAMETER_REF:
            return "@parameter_" + parameterIndex;
        case EXCEPTION_REF:
            return "@Exception";
        default:
        }
        return super.toString();
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/StaticFieldExpr.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;
import com.googlecode.dex2jar.ir.expr.Value.E0Expr;

/**
 * Represent a StaticField expression
 * 
 * @see VT#STATIC_FIELD
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 9fd8005bbaa4 $
 */
public class StaticFieldExpr extends E0Expr {

    /**
     * Field name
     */
    public String name;
    /**
     * Field owner type
     */
    public String owner;
    /**
     * Field type
     */
    public String type;

    @Override
    protected void releaseMemory() {
        name = null;
        owner = type = null;
        super.releaseMemory();
    }

    public StaticFieldExpr(String ownerType, String fieldName, String fieldType) {
        super(VT.STATIC_FIELD);
        this.type = fieldType;
        this.name = fieldName;
        this.owner = ownerType;
    }

    @Override
    public Value clone() {
        return new StaticFieldExpr(owner, name, type);
    }
    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new StaticFieldExpr(owner, name, type);
    }

    @Override
    public String toString0() {
        return Util.toShortClassName(owner) + "." + name;
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/TypeExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Util;
import com.googlecode.dex2jar.ir.expr.Value.E1Expr;

/**
 * Represent a Type expression
 * 
 * @see VT#CHECK_CAST
 * @see VT#INSTANCE_OF
 * @see VT#NEW_ARRAY
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class TypeExpr extends E1Expr {

    public String type;

    @Override
    protected void releaseMemory() {
        type = null;
        super.releaseMemory();
    }

    public TypeExpr(VT vt, Value value, String desc) {
        super(vt, value);
        this.type = desc;

    }

    @Override
    public Value clone() {
        return new TypeExpr(vt, op.trim().clone(), type);
    }

    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new TypeExpr(vt, op.clone(mapper), type);
    }


    @Override
    public String toString0() {
        switch (super.vt) {
        case CHECK_CAST:
            return "((" + Util.toShortClassName(type) + ")" + op + ")";
        case INSTANCE_OF:
            return "(" + op + " instanceof " + Util.toShortClassName(type) + ")";
        case NEW_ARRAY:
            if (type.charAt(0) == '[') {
                int dimension = 1;
                while (type.charAt(dimension) == '[') {
                    dimension++;
                }
                StringBuilder sb = new StringBuilder("new ")
                        .append(Util.toShortClassName(type.substring(dimension))).append("[").append(op)
                        .append("]");
                for (int i = 0; i < dimension; i++) {
                    sb.append("[]");
                }
                return sb.toString();
            }
            return "new " + Util.toShortClassName(type) + "[" + op + "]";
        default:
        }
        return "UNKNOW";
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/UnopExpr.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value.E1Expr;

/**
 * Represent a LENGTH,NEG expression
 * 
 * @see VT#LENGTH
 * @see VT#NEG
 * @see VT#NOT
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class UnopExpr extends E1Expr {
    public String type;

    @Override
    protected void releaseMemory() {
        type = null;
        super.releaseMemory();
    }

    /**
     * @param vt
     * @param value
     * @param type
     */
    public UnopExpr(VT vt, Value value, String type) {
        super(vt, value);
        this.type = type;
    }

    @Override
    public Value clone() {
        return new UnopExpr(vt, op.trim().clone(), type);
    }
    @Override
    public Value clone(LabelAndLocalMapper mapper) {
        return new UnopExpr(vt, op.clone(mapper), type);
    }

    @Override
    public String toString0() {
        switch (vt) {
        case LENGTH:
            return op + ".length";
        case NEG:
            return "(-" + op + ")";
        case NOT:
            return "(!" + op + ")";
        default:
        }
        return super.toString();
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/Value.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.expr;

import com.googlecode.dex2jar.ir.ET;
import com.googlecode.dex2jar.ir.LabelAndLocalMapper;

/**
 * Represent a local/constant/expression
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public abstract class Value implements Cloneable {
    public void setOp(Value op) {
    }

    public void setOp1(Value op) {
    }

    public void setOp2(Value op) {
    }

    public void setOps(Value[] op) {
    }

    /**
     * Represent an expression with no argument
     * 
     * @see ET#E0
     */
    public static abstract class E0Expr extends Value {

        public E0Expr(VT vt) {
            super(vt, ET.E0);
        }

    }

    /**
     * Represent an expression with 1 argument
     * 
     * @see ET#E1
     */
    public static abstract class E1Expr extends Value {

        public Value op;

        public void setOp(Value op) {
            this.op = op;
        }

        /**
         * @param vt
         * @param op
         *            the value should be trimmed
         */
        public E1Expr(VT vt, Value op) {
            super(vt, ET.E1);
            this.op = op;
        }

        @Override
        public Value getOp() {
            return op;
        }

        @Override
        protected void releaseMemory() {
            op = null;
        }
    }

    /**
     * Represent an expression with 2 arguments
     * 
     * @see ET#E2
     */
    public static abstract class E2Expr extends Value {

        public Value op1;
        public Value op2;

        public void setOp1(Value op1) {
            this.op1 = op1;
        }

        public void setOp2(Value op2) {
            this.op2 = op2;
        }

        public E2Expr(VT vt, Value op1, Value op2) {
            super(vt, ET.E2);
            this.op1 = op1;
            this.op2 = op2;
        }

        @Override
        public Value getOp1() {
            return op1;
        }

        @Override
        public Value getOp2() {
            return op2;
        }

        @Override
        protected void releaseMemory() {
            op1 = op2 = null;
        }
    }

    /**
     * Represent an expression with 3+ arguments
     * 
     * @see ET#En
     */
    public static abstract class EnExpr extends Value {

        public Value[] ops;

        public void setOps(Value[] ops) {
            this.ops = ops;
        }

        public EnExpr(VT vt, Value[] ops) {
            super(vt, ET.En);
            this.ops = ops;
        }

        protected Value[] cloneOps() {
            Value[] nOps = new Value[ops.length];
            for (int i = 0; i < nOps.length; i++) {
                nOps[i] = ops[i].trim().clone();
            }
            return nOps;
        }
        protected Value[] cloneOps(LabelAndLocalMapper mapper) {
            Value[] nOps = new Value[ops.length];
            for (int i = 0; i < nOps.length; i++) {
                nOps[i] = ops[i].clone(mapper);
            }
            return nOps;
        }

        @Override
        public Value[] getOps() {
            return ops;
        }

        @Override
        protected void releaseMemory() {
            ops = null;
        }
    }
    public static final int CAN_THROW = 1 << 3;
    public static final int MAY_THROW=1<<4;

    /**
     * Value Type
     */
    public static enum VT {

        ADD("+", MAY_THROW), AND("&", MAY_THROW), ARRAY(MAY_THROW), CAST(MAY_THROW), CHECK_CAST(CAN_THROW), CONSTANT(0), DCMPG(
                MAY_THROW), DCMPL(MAY_THROW), IDIV("/", CAN_THROW), LDIV("/", CAN_THROW), FDIV("/", MAY_THROW), DDIV("/", MAY_THROW), EQ("==", MAY_THROW), EXCEPTION_REF(0), FCMPG(
                MAY_THROW), FCMPL(MAY_THROW), FIELD(CAN_THROW), FILLED_ARRAY(CAN_THROW), GE(">=", MAY_THROW), GT(">",
                MAY_THROW), INSTANCE_OF(CAN_THROW), INVOKE_INTERFACE(CAN_THROW), //
        INVOKE_NEW(CAN_THROW), INVOKE_SPECIAL(CAN_THROW), INVOKE_STATIC(CAN_THROW), INVOKE_VIRTUAL(CAN_THROW), INVOKE_CUSTOM(CAN_THROW), INVOKE_POLYMORPHIC(CAN_THROW), LCMP(
                MAY_THROW), //
        LE("<=", MAY_THROW), LENGTH(CAN_THROW), LOCAL(0), LT("<", MAY_THROW), MUL("*", MAY_THROW), NE("!=", MAY_THROW), NEG(
                MAY_THROW), //
        NEW(CAN_THROW), NEW_ARRAY(CAN_THROW), NEW_MUTI_ARRAY(CAN_THROW), NOT(MAY_THROW), OR("|", MAY_THROW), PARAMETER_REF(
                0), PHI(0), REM("%", MAY_THROW), SHL("<<", MAY_THROW), SHR(">>", MAY_THROW), STATIC_FIELD(CAN_THROW), SUB(
                "-", MAY_THROW), THIS_REF(MAY_THROW), USHR(">>>", MAY_THROW), XOR("^", MAY_THROW);
        private String name;
        private int flags;

        VT(int flags) {
            this(null, flags);
        }

        VT(String name, int flags) {
            this.name = name;
            this.flags = flags;
        }

        @Override
        public String toString() {
            return name == null ? super.toString() : name;
        }

        public boolean canThrow() {
            return CAN_THROW == flags;
        }

        public boolean mayThrow() {
            return MAY_THROW == flags;
        }
    }

    /**
     * The number of argument
     */
    final public ET et;

    private Value next;

    public String valueType;
    public Object tag;
    /**
     * Value Type
     */
    final public VT vt;

    /**
     * 
     * @param vt
     *            Value Type
     * @param et
     *            The number of argument
     */
    protected Value(VT vt, ET et) {
        super();
        this.vt = vt;
        this.et = et;
    }

    @Override
    public abstract Value clone();

    public abstract Value clone(LabelAndLocalMapper mapper);

    public Value getOp() {
        return null;
    }

    public Value getOp1() {
        return null;
    }

    public Value getOp2() {
        return null;
    }

    public Value[] getOps() {
        return null;
    }

    /**
     * clean resource used by this value,release memory
     */
    protected void releaseMemory() {
    }

    public final String toString() {
        return trim().toString0();
    }

    protected abstract String toString0();

    public Value trim() {
        Value a = this;
        while (a.next != null) {
            Value b = a.next;
            a.next = b;
            a = b;
        }
        return a;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/AssignStmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt.E2Stmt;

/**
 * Represent an Assign statement
 * 
 * @see ST#ASSIGN
 * @see ST#IDENTITY
 * @see ST#FILL_ARRAY_DATA
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 8da5a5faa6bd $
 */
public class AssignStmt extends E2Stmt {

    public AssignStmt(ST type, Value left, Value right) {
        super(type, left, right);
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        return new AssignStmt(st, op1.clone(mapper), op2.clone(mapper));
    }

    @Override
    public String toString() {
        switch (st) {
        case ASSIGN:
            return op1 + " = " + op2;
        case LOCAL_START:
        case IDENTITY:
            return op1 + " := " + op2;
        case FILL_ARRAY_DATA:
            return op1 + " <- " + op2;
        default:
        }
        return super.toString();
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/BaseSwitchStmt.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt.E1Stmt;

/**
 * Parent class of {@link LookupSwitchStmt} and {@link TableSwitchStmt}
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public abstract class BaseSwitchStmt extends E1Stmt {
    public BaseSwitchStmt(ST type, Value op) {
        super(type, op);
    }

    public LabelStmt[] targets;
    public LabelStmt defaultTarget;
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/GotoStmt.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.stmt.Stmt.E0Stmt;

/**
 * Represent a GOTO statement
 * 
 * @see ST#GOTO
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class GotoStmt extends E0Stmt implements JumpStmt {
    public LabelStmt target;

    public LabelStmt getTarget() {
        return target;
    }

    public void setTarget(LabelStmt target) {
        this.target = target;
    }

    public GotoStmt(LabelStmt target) {
        super(ST.GOTO);
        this.target = target;
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        LabelStmt nTarget = mapper.map(target);
        return new GotoStmt(nTarget);
    }

    @Override
    public String toString() {
        return "GOTO " + target.getDisplayName();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/IfStmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt.E1Stmt;

/**
 * Represent a IF statement
 * 
 * @see ST#IF
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 9fd8005bbaa4 $
 */
public class IfStmt extends E1Stmt implements JumpStmt {

    public LabelStmt target;

    public LabelStmt getTarget() {
        return target;
    }

    public void setTarget(LabelStmt target) {
        this.target = target;
    }

    /**
     * IF
     * 
     * @param type
     * @param condition
     * @param target
     */
    public IfStmt(ST type, Value condition, LabelStmt target) {
        super(type, condition);
        this.target = target;
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        LabelStmt nTarget = mapper.map(target);
        return new IfStmt(st, op.clone(mapper), nTarget);
    }

    @Override
    public String toString() {
        return "if " + op + " GOTO " + target.getDisplayName();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/JumpStmt.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

public interface JumpStmt {

    LabelStmt getTarget();

    void setTarget(LabelStmt labelStmt);
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/LabelStmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.stmt.Stmt.E0Stmt;

/**
 * Represent a Label statement
 * 
 * @see ST#LABEL
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class LabelStmt extends E0Stmt {

    public String displayName;
    public int lineNumber = -1;
    public List<AssignStmt> phis;
    public Object tag;

    public LabelStmt() {
        super(ST.LABEL);
    }

    @Override
    public LabelStmt clone(LabelAndLocalMapper mapper) {
        LabelStmt labelStmt = mapper.map(this);
        if (phis != null && labelStmt.phis == null) {
            labelStmt.phis = new ArrayList<>(phis.size());
            for (AssignStmt phi : phis) {
                labelStmt.phis.add((AssignStmt) phi.clone(mapper));
            }
        }
        return labelStmt;
    }

    public String getDisplayName() {
        if (displayName != null) {
            return displayName;
        }
        int x = hashCode();
        return String.format("L%08x", x);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(getDisplayName()).append(":");

        if (phis != null && phis.size() > 0) {
            sb.append(" // ").append(phis);
        }
        if (lineNumber >= 0) {
            sb.append(" // line ").append(lineNumber);
        }
        return sb.toString();
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/LookupSwitchStmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value;

/**
 * Represent a LOOKUP_SWITCH statement
 * 
 * @see ST#LOOKUP_SWITCH
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 9fd8005bbaa4 $
 */
public class LookupSwitchStmt extends BaseSwitchStmt {

    public int[] lookupValues;

    public LookupSwitchStmt(Value key, int[] lookupValues, LabelStmt[] targets, LabelStmt defaultTarget) {
        super(ST.LOOKUP_SWITCH, key);
        this.lookupValues = lookupValues;
        this.targets = targets;
        this.defaultTarget = defaultTarget;
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        LabelStmt[] nTargets = new LabelStmt[targets.length];
        for (int i = 0; i < nTargets.length; i++) {
            nTargets[i] = mapper.map(targets[i]);
        }
        int nLookupValues[] = new int[lookupValues.length];
        System.arraycopy(lookupValues, 0, nLookupValues, 0, nLookupValues.length);

        return new LookupSwitchStmt(op.clone(mapper), nLookupValues, nTargets, mapper.map(defaultTarget));
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("switch(").append(op).append(") {");

        for (int i = 0; i < lookupValues.length; i++) {
            sb.append("\n case ").append(lookupValues[i]).append(": GOTO ").append(targets[i].getDisplayName())
                    .append(";");
        }
        sb.append("\n default : GOTO ").append(defaultTarget.getDisplayName()).append(";");
        sb.append("\n}");
        return sb.toString();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/NopStmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.stmt.Stmt.E0Stmt;

/**
 * Represent a NOP statement
 * 
 * @see ST#NOP
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class NopStmt extends E0Stmt {

    public NopStmt() {
        super(ST.NOP);
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        return new NopStmt();
    }

    @Override
    public String toString() {
        return "NOP";
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/ReturnVoidStmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.stmt.Stmt.E0Stmt;

/**
 * Represent a RETURN_VOID statement
 * 
 * @see ST#RETURN_VOID
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class ReturnVoidStmt extends E0Stmt {

    public ReturnVoidStmt() {
        super(ST.RETURN_VOID);
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        return new ReturnVoidStmt();
    }

    @Override
    public String toString() {
        return "return";
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/Stmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import java.util.Set;
import java.util.TreeSet;

import com.googlecode.dex2jar.ir.ET;
import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value;

/**
 * Represent a statement
 * 
 * @see ST
 * @see ET
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public abstract class Stmt {

    /**
     * Represent a statement with no argument
     * 
     * @see ET#E0
     */
    public static abstract class E0Stmt extends Stmt {

        public E0Stmt(ST type) {
            super(type, ET.E0);
        }
    }

    /**
     * Represent a statement with 1 argument
     * 
     * @see ET#E1
     */
    public static abstract class E1Stmt extends Stmt {

        public Value op;

        public E1Stmt(ST type, Value op) {
            super(type, ET.E1);
            this.op = op;
        }

        @Override
        public Value getOp() {
            return op;
        }

        public void setOp(Value op) {
            this.op = op;
        }

    }

    /**
     * Represent a statement with 2 arguments
     * 
     * @see ET#E2
     */
    public static abstract class E2Stmt extends Stmt {

        public Value op1;
        public Value op2;

        public E2Stmt(ST type, Value op1, Value op2) {
            super(type, ET.E2);
            this.op1 = op1;
            this.op2 = op2;
        }

        @Override
        public Value getOp1() {
            return op1;
        }

        @Override
        public Value getOp2() {
            return op2;
        }

        public void setOp1(Value op1) {
            this.op1 = op1;
        }

        public void setOp2(Value op2) {
            this.op2 = op2;
        }

    }

    public static final int CAN_CONTINUE = 1 << 0;
    public static final int CAN_BRNANCH = 1 << 1;
    public static final int CAN_SWITCH = 1 << 2;
    public static final int CAN_THROW = 1 << 3;
    public static final int MAY_THROW=1<<4;

    /**
     * Statement Type
     * 
     */
    public static enum ST {

        LOCAL_START(CAN_CONTINUE), // same as ASSIGN but left must keep and must be local
        LOCAL_END(CAN_CONTINUE), // must keep and op must be local
        ASSIGN(CAN_CONTINUE | MAY_THROW), IDENTITY(CAN_CONTINUE), LABEL(CAN_CONTINUE), LOCK(CAN_CONTINUE | CAN_THROW), NOP(
                CAN_CONTINUE), UNLOCK(CAN_CONTINUE | CAN_THROW), VOID_INVOKE(CAN_CONTINUE | CAN_THROW), FILL_ARRAY_DATA(
                CAN_CONTINUE | CAN_THROW), //
        RETURN(MAY_THROW), RETURN_VOID(0), THROW(CAN_THROW), //
        GOTO(CAN_BRNANCH), IF(CAN_CONTINUE | CAN_BRNANCH | MAY_THROW), //
        LOOKUP_SWITCH(CAN_SWITCH | MAY_THROW), TABLE_SWITCH(CAN_SWITCH | MAY_THROW), ;
        private int config;

        ST(int config) {
            this.config = config;
        }

        public boolean canBranch() {
            return 0 != (CAN_BRNANCH & config);
        }

        public boolean canContinue() {
            return 0 != (CAN_CONTINUE & config);
        }

        public boolean canSwitch() {
            return 0 != (CAN_SWITCH & config);
        }

        public boolean mayThrow() {
            return 0 != (MAY_THROW & config);
        }

        public boolean canThrow() {
            return 0 != (CAN_THROW & config);
        }
    }

    /**
     * Used in construct of a method CFG, Previous {@link Stmt} nodes
     */
    public Set<Stmt> _cfg_froms;

    /**
     * Used in construct of a method CFG, After {@link Stmt} nodes
     */
    public Set<LabelStmt> exceptionHandlers;

    /**
     * Used in visit the method CFG
     */
    public boolean visited;

    /**
     * Used in Local Split, forward frame of the {@link Stmt}
     */
    public Object frame;

    public Stmt _ts_default_next;

    /**
     * The number of argument
     */
    public final ET et;
    /**
     * Used in ordering statements in a {@link TreeSet}, id of the {@link Stmt} in its {@link StmtList}
     */
    public int id;

    /**
     * Owner of the statement
     */
    /* default */
    StmtList list;

    /**
     * Next statement in {@link StmtList}
     */
    /* default */
    Stmt next;

    /**
     * Previous statement in {@link StmtList}
     */
    /* default */
    Stmt pre;
    /**
     * Statement Type
     */
    public final ST st;

    /**
     * 
     * @param st
     *            Statement Type
     * @param et
     *            The number of argument
     */
    protected Stmt(ST st, ET et) {
        this.st = st;
        this.et = et;
    }

    public abstract Stmt clone(LabelAndLocalMapper mapper);

    /**
     * 
     * @return Next statement in {@link StmtList}, null if it is the last statement in {@link StmtList}
     */
    public final Stmt getNext() {
        return next;
    }

    public Value getOp() {
        return null;
    }

    public Value getOp1() {
        return null;
    }

    public Value getOp2() {
        return null;
    }

    public Value[] getOps() {
        return null;
    }

    /**
     * 
     * @return Previous statement in {@link StmtList}, null if it is the first statement in {@link StmtList}
     */
    public final Stmt getPre() {
        return pre;
    }

    public void setOp(Value op) {
    }

    public void setOp1(Value op) {
    }

    public void setOp2(Value op) {
    }

    public void setOps(Value[] op) {
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/StmtList.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;

/**
 * Represent a list of statement.
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class StmtList implements Iterable<Stmt>, java.util.Comparator<Stmt> {

    private static class StmtListIterator implements Iterator<Stmt> {
        private Stmt current, next;
        private final StmtList list;

        /**
         * @param list
         * @param next
         */
        public StmtListIterator(StmtList list, Stmt next) {
            super();
            this.list = list;
            this.next = next;
        }

        @Override
        public boolean hasNext() {
            return next != null;
        }

        @Override
        public Stmt next() {
            Stmt x = current = next;
            if (x != null) {
                next = x.next;
            } else {
                next = null;
            }
            return x;
        }

        @Override
        public void remove() {
            if (current != null) {
                list.remove(current);
                current = null;
            }
        }
    }

    private Stmt first, last;

    private int index = 1;
    private int size = 0;

    public void add(Stmt stmt) {
        insertLast(stmt);
    }

    public void addAll(Collection<Stmt> list) {
        for (Stmt stmt : list) {
            insertLast(stmt);
        }
    }

    public StmtList clone(LabelAndLocalMapper mapper) {
        StmtList nList = new StmtList();
        for (Stmt stmt : this) {
            nList.add(stmt.clone(mapper));
        }
        return nList;
    }

    @Override
    public int compare(Stmt o1, Stmt o2) {
        return o1.id - o2.id;
    }

    public boolean contains(Stmt stmt) {
        return stmt.list == this;
    }

    public Stmt getFirst() {
        return first;
    }

    public Stmt getLast() {
        return last;
    }

    public int getSize() {
        return size;
    }

    private void indexIt(Stmt stmt) {
        if (stmt.id <= 0) {
            stmt.id = this.index;
            this.index++;
        }
    }

    public void insertAfter(Stmt position, Stmt stmt) {
        if (position.list == this) {
            indexIt(stmt);
            stmt.list = this;
            size++;
            stmt.next = position.next;
            stmt.pre = position;
            if (position.next == null) {
                last = stmt;
            } else {
                position.next.pre = stmt;
            }
            position.next = stmt;
        }
    }

    public void insertBefore(Stmt position, Stmt stmt) {
        if (position.list == this) {
            indexIt(stmt);
            stmt.list = this;
            size++;
            stmt.pre = position.pre;
            stmt.next = position;
            if (position.pre == null) {
                first = stmt;
            } else {
                position.pre.next = stmt;
            }
            position.pre = stmt;
        }
    }

    public void insertFirst(Stmt stmt) {
        indexIt(stmt);
        stmt.list = this;
        size++;
        if (first == null) {// empty
            first = last = stmt;
            stmt.pre = stmt.next = null;
        } else {
            stmt.pre = null;
            stmt.next = first;
            first.pre = stmt;
            first = stmt;
        }
    }

    public void insertLast(Stmt stmt) {
        indexIt(stmt);
        stmt.list = this;
        size++;
        if (first == null) {// empty
            first = last = stmt;
            stmt.pre = stmt.next = null;
        } else {
            stmt.next = null;
            stmt.pre = last;
            last.next = stmt;
            last = stmt;
        }
    }

    @Override
    public Iterator<Stmt> iterator() {
        return new StmtListIterator(this, first);
    };

    public void remove(Stmt stmt) {
        if (stmt.list == this) {
            size--;
            stmt.list = null;
            if (stmt.pre == null) {
                first = stmt.next;
            } else {
                stmt.pre.next = stmt.next;
            }
            if (stmt.next == null) {
                last = stmt.pre;
            } else {
                stmt.next.pre = stmt.pre;
            }
            stmt.pre = null;
            stmt.next = null;
        }
    }

    public void replace(Stmt stmt, Stmt nas) {
        if (stmt.list == this) {
            indexIt(nas);
            nas.list = this;
            nas.next = stmt.next;
            nas.pre = stmt.pre;
            if (stmt.next != null) {
                stmt.next.pre = nas;
            } else {
                this.last = nas;
            }
            if (stmt.pre != null) {
                stmt.pre.next = nas;
            } else {
                this.first = nas;
            }
            stmt.next = null;
            stmt.pre = null;
            stmt.list = null;
        }
    }

    @Override
    public String toString() {
        if (this.size == 0) {
            return "[Empty]";
        }
        StringBuilder sb = new StringBuilder();
        for (Stmt s : this) {
            if (s.st == ST.LABEL) {
                sb.append("\n");
            }
            sb.append(s).append("\n");
        }
        return sb.toString();
    }

    public void move(Stmt start, Stmt end, Stmt dist) {
        if (start.pre == null) {
            this.first = end.next;
        } else {
            start.pre.next = end.next;
        }
        if (end.next == null) {
            this.last = start.pre;
        } else {
            end.next.pre = start.pre;
        }

        if (dist.next == null) {
            this.last = end;
            end.next = null;
        } else {
            dist.next.pre = end;
            end.next = dist.next;
        }
        dist.next = start;
        start.pre = dist;
    }

    public void clear() {
        size = 0;
        first = null;
        last = null;
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/Stmts.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;

public final class Stmts {

    public static AssignStmt nAssign(Value left, Value right) {
        return new AssignStmt(ST.ASSIGN, left, right);
    }

    public static AssignStmt nFillArrayData(Value left, Value arrayData) {
        return new AssignStmt(ST.FILL_ARRAY_DATA, left, arrayData);
    }

    public static GotoStmt nGoto(LabelStmt target) {
        return new GotoStmt(target);
    }

    public static AssignStmt nIdentity(Value local, Value identityRef) {
        return new AssignStmt(ST.IDENTITY, local, identityRef);
    }

    public static IfStmt nIf(Value a, LabelStmt target) {
        return new IfStmt(ST.IF, a, target);
    }

    public static LabelStmt nLabel() {
        return new LabelStmt();
    }

    public static UnopStmt nLock(Value op) {
        return new UnopStmt(ST.LOCK, op);
    }

    public static LookupSwitchStmt nLookupSwitch(Value key, int[] lookupValues, LabelStmt[] targets, LabelStmt target) {
        return new LookupSwitchStmt(key, lookupValues, targets, target);
    }

    public static NopStmt nNop() {
        return new NopStmt();
    }

    public static UnopStmt nReturn(Value op) {
        return new UnopStmt(ST.RETURN, op);
    }

    public static ReturnVoidStmt nReturnVoid() {
        return new ReturnVoidStmt();
    }

    public static TableSwitchStmt nTableSwitch(Value key, int lowIndex, LabelStmt[] targets,
            LabelStmt target) {
        return new TableSwitchStmt(key, lowIndex, targets, target);
    }

    public static UnopStmt nThrow(Value op) {
        return new UnopStmt(ST.THROW, op);
    }

    public static UnopStmt nUnLock(Value op) {
        return new UnopStmt(ST.UNLOCK, op);
    }

    public static VoidInvokeStmt nVoidInvoke(Value op) {
        return new VoidInvokeStmt(op);
    }

    private Stmts() {
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/TableSwitchStmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value;

/**
 * Represent a TABLE_SWITCH statement
 * 
 * @see ST#TABLE_SWITCH
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 9fd8005bbaa4 $
 */
public class TableSwitchStmt extends BaseSwitchStmt {

    public int lowIndex;

    public TableSwitchStmt() {
        super(ST.TABLE_SWITCH, null);
    }

    public TableSwitchStmt(Value key, int lowIndex, LabelStmt[] targets, LabelStmt defaultTarget) {
        super(ST.TABLE_SWITCH, key);
        this.lowIndex = lowIndex;
        this.targets = targets;
        this.defaultTarget = defaultTarget;
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        LabelStmt[] nTargets = new LabelStmt[targets.length];
        for (int i = 0; i < nTargets.length; i++) {
            nTargets[i] = mapper.map(targets[i]);
        }
        return new TableSwitchStmt(op.clone(mapper), lowIndex, nTargets, mapper.map(defaultTarget));
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("switch(").append(op).append(") {");

        for (int i = 0; i < targets.length; i++) {
            sb.append("\n case ").append(lowIndex + i).append(": GOTO ").append(targets[i].getDisplayName())
                    .append(";");
        }
        sb.append("\n default : GOTO ").append(defaultTarget.getDisplayName()).append(";");
        sb.append("\n}");
        return sb.toString();
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/UnopStmt.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt.E1Stmt;

public class UnopStmt extends E1Stmt {

    public UnopStmt(ST type, Value op) {
        super(type, op);
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        return new UnopStmt(st, op.clone(mapper));
    }

    @Override
    public String toString() {
        switch (super.st) {
        case LOCK:
            return "lock " + op;
        case UNLOCK:
            return "unlock " + op;
        case THROW:
            return "throw " + op;
        case RETURN:
            return "return " + op;
        case LOCAL_END:
            return op + " ::END";
        default:
        }
        return super.toString();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/stmt/VoidInvokeStmt.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.stmt;

import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt.E1Stmt;

/**
 * Represent a void-expr: the expr result is ignored.
 * possible op type: AbstractInvokeExpr, FieldExpr, or others
 * 
 * @see ST#VOID_INVOKE
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev: 8da5a5faa6bd $
 */
public class VoidInvokeStmt extends E1Stmt {

    public VoidInvokeStmt(Value op) {
        super(ST.VOID_INVOKE, op);
    }

    @Override
    public Stmt clone(LabelAndLocalMapper mapper) {
        return new VoidInvokeStmt(op.clone(mapper));
    }

    @Override
    public String toString() {
        return "void " + op;
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/AggTransformer.java`:

```java
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.InvokeExpr;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;

import java.util.*;

public class AggTransformer extends StatedTransformer {
    @Override
    public boolean transformReportChanged(IrMethod method) {
        boolean changed = false;


        Set<Stmt> locationSensitiveStmts = new HashSet<>();
        // 1. merge location Insensitive stmts
        changed = simpleMergeLocals(method, changed, locationSensitiveStmts);

        if (locationSensitiveStmts.size() == 0) {
            return changed;
        }

        ReplaceX replaceX = new ReplaceX();
        Queue<Stmt> q = new UniqueQueue<>();
        q.addAll(locationSensitiveStmts);

        // 2. merge location sensitive stmts
        while (!q.isEmpty()) {
            Stmt stmt = q.poll();
            Local local = (Local) stmt.getOp1();
            Stmt next = stmt.getNext();

            switch (next.st) {
                case LABEL:
                case GOTO:
                case IDENTITY:
                case FILL_ARRAY_DATA:
                case NOP:
                case RETURN_VOID:
                    continue;
                default:
            }
            try {
                localCanExecFirst(local, next);
                throw new RuntimeException(); // impossible here
            } catch (MergeResult e) {
                if (e == SUCCESS) {
                    replaceX.local = local;
                    replaceX.replaceWith = stmt.getOp2();
                    method.locals.remove(local);
                    method.stmts.remove(stmt);

                    Cfg.travelMod(next, replaceX, false);

                    Stmt pre = next.getPre();
                    if (pre != null && locationSensitiveStmts.contains(pre)) {
                        q.add(pre);
                    }

                }
            }
        }


        return changed;
    }

    /**
     * dfs find find local and the first locationInsensitive Value
     * // TODO if can not merge, try adjust the stmt to fit the local
     */
    private static void localCanExecFirst(Local local, Stmt target) throws MergeResult {

        switch (target.et) {
            case E0: // impossible
            case En: // no EnStmt yet
                throw FAIL;
            case E1:
                localCanExecFirst(local, target.getOp());
                break;
            case E2:
                AssignStmt as = (AssignStmt) target;
                Value op1 = as.getOp1();
                Value op2 = as.getOp2();
                switch (op1.vt) {
                    case LOCAL:
                        localCanExecFirst(local, op2);
                        break;
                    case FIELD:
                        localCanExecFirst(local, op1.getOp());
                        // pass through
                    case STATIC_FIELD:
                        localCanExecFirst(local, op2);
                        break;
                    case ARRAY:
                        localCanExecFirst(local, op1.getOp1());
                        localCanExecFirst(local, op1.getOp2());
                        localCanExecFirst(local, op2);
                        break;
                    default:
                }
                break;
        }
        throw FAIL;
    }

    private static MergeResult FAIL = new MergeResult();
    private static MergeResult SUCCESS = new MergeResult();

    /**
     * dfs searching, if local is appear before first location-insensitive value, throws SUCCESS, or throws FAIL
     */
    private static void localCanExecFirst(Local local, Value op) throws MergeResult {
        switch (op.et) {
            case E0:
                if (local.vt == Value.VT.LOCAL) {
                    if (op == local) {
                        throw SUCCESS;
                    }
                }
                break;
            case E1:
                localCanExecFirst(local, op.getOp());
                break;
            case E2:
                localCanExecFirst(local, op.getOp1());
                localCanExecFirst(local, op.getOp2());
                break;
            case En:
                for (Value v : op.getOps()) {
                    localCanExecFirst(local, v);
                }
        }

        boolean shouldExclude = false;
        if (op.vt == Value.VT.INVOKE_STATIC) {
            InvokeExpr ie = (InvokeExpr) op;
            if (ie.getName().equals("valueOf") && ie.getOwner().startsWith("Ljava/lang/") && ie.getArgs().length == 1 && ie.getArgs()[0].length() == 1) {
                shouldExclude = true;
            }
        }

        if (!isLocationInsensitive(op.vt) && !shouldExclude) {  // this is the first insensitive Value
            throw FAIL;
        }
    }

    static class MergeResult extends Throwable {
        private static final long serialVersionUID = -1563502983848655360L;
    }

    static class ReplaceX implements Cfg.TravelCallBack {
        Local local;
        Value replaceWith;

        @Override
        public Value onAssign(Local v, AssignStmt as) {
            return v;
        }

        @Override
        public Value onUse(Local v) {
            if (v == local) {
                return replaceWith;
            }
            return v;
        }
    }

    /**
     * if a local is only used in one place, and the value is isLocationInsensitive,
     * remove the local and replace it with its value
     * <pre>
     *     a=b+c
     *     d=a+e
     * </pre>
     * to
     * <pre>
     *     d=(b+c)+e
     * </pre>
     */
    private boolean simpleMergeLocals(IrMethod method, boolean changed, Set<Stmt> locationSensitiveStmts) {
        if (method.locals.size() == 0) {
            return false;
        }
        final int[] readCounts = Cfg.countLocalReads(method);
        Set<Local> useInPhi = collectLocalUsedInPhi(method);
        final Map<Local, Value> toReplace = new HashMap<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == Stmt.ST.ASSIGN && p.getOp1().vt == Value.VT.LOCAL) {
                Local local = (Local) p.getOp1();
                if (useInPhi.contains(local)) {
                    continue;
                }
                if (readCounts[local._ls_index] < 2) {
                    Value op2 = p.getOp2();
                    if (isLocationInsensitive(op2)) {
                        method.locals.remove(local);
                        toReplace.put(local, op2);
                        it.remove();
                        changed = true;
                    } else {
                        locationSensitiveStmts.add(p);
                    }
                }
            }
        }
        Cfg.TravelCallBack tcb = new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value v2 = toReplace.get(v);
                if (v2 != null) {
                    return v2;
                }
                return v;
            }
        };

        modReplace(toReplace, tcb);

        Cfg.travelMod(method.stmts, tcb, false);
        return changed;
    }

    private Set<Local> collectLocalUsedInPhi(IrMethod method) {
        Set<Local> useInPhi = new HashSet<>();
        if (method.phiLabels != null) {
            for (LabelStmt labelStmt : method.phiLabels) {
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        useInPhi.add((Local) phi.getOp1());
                        for (Value op : phi.getOp2().getOps()) {
                            useInPhi.add((Local) op);
                        }
                    }
                }
            }
        }
        return useInPhi;
    }

    private void modReplace(Map<Local, Value> toReplace, Cfg.TravelCallBack tcb) {
        for (Map.Entry<Local, Value> e : toReplace.entrySet()) {
            Value v = e.getValue();
            if (v.vt == Value.VT.LOCAL) {
                while (true) {
                    Value v2 = toReplace.get(v);
                    if (v2 == null) {
                        break;
                    }
                    v = v2;
                    if (v.vt != Value.VT.LOCAL) {
                        break;
                    }
                }
                e.setValue(v);
            } else {
                Cfg.travelMod(v, tcb);
            }
        }
    }

    static boolean isLocationInsensitive(Value.VT vt) {
        switch (vt) {
            case LOCAL:
            case CONSTANT:
                // +-*/
            case ADD:
            case SUB:
            case MUL:
                // case DIV:   // div is not
            case REM:
                // logical
            case AND:
            case OR:
            case XOR:

            case SHL:
            case SHR:
            case USHR:
                //cmp
            case GE:
            case GT:
            case LE:
            case LT:
            case EQ:
            case NE:
            case DCMPG:
            case DCMPL:
            case LCMP:
            case FCMPG:
            case FCMPL:
            case NOT:
                return true;
            default:
        }
        return false;
    }

    static boolean isLocationInsensitive(Value op) {
        switch (op.et) {
            case E0:
                return isLocationInsensitive(op.vt);
            case E1:
                return isLocationInsensitive(op.vt) && isLocationInsensitive(op.getOp());
            case E2:
                return isLocationInsensitive(op.vt) && isLocationInsensitive(op.getOp1()) && isLocationInsensitive(op.getOp2());
            case En:
                if (op.vt == Value.VT.INVOKE_STATIC) {
                    InvokeExpr ie = (InvokeExpr) op;
                    if (ie.getName().equals("valueOf") && ie.getOwner().startsWith("Ljava/lang/") && ie.getArgs().length == 1 && ie.getArgs()[0].length() == 1) {
                        for (Value v : op.getOps()) {
                            if (!isLocationInsensitive(v)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                }
                if (isLocationInsensitive(op.vt)) {
                    for (Value v : op.getOps()) {
                        if (!isLocationInsensitive(v)) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
        }
        return false;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/Cfg.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import java.util.Collections;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;

import com.googlecode.dex2jar.ir.ET;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.*;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;

/**
 * TODO DOC
 *
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Cfg {

    public static int[] countLocalReads(IrMethod method) {
        int size = reIndexLocal(method);
        final int[] readCounts = new int[size];
        travel(method.stmts, new TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                readCounts[v._ls_index]++;
                return v;
            }
        }, true);
        return readCounts;
    }

    public static void reIndexLocalAndLabel(IrMethod irMethod) {
        reIndexLocal(irMethod);
        reIndexLabel(irMethod);
    }

    private static void reIndexLabel(IrMethod irMethod) {
        int i = 0;
        for (Stmt stmt : irMethod.stmts) {
            if (stmt.st == ST.LABEL) {
                ((LabelStmt) stmt).displayName = "L" + i++;
            }
        }
    }

    public interface FrameVisitor<T> {
        T merge(T srcFrame, T distFrame, Stmt src, Stmt dist);

        T initFirstFrame(Stmt first);

        T exec(T frame, Stmt stmt);
    }


    public static boolean notThrow(Stmt s) {
        return !isThrow(s);
    }

    public static boolean isThrow(Stmt s) {
        ST st = s.st;
        if (st.canThrow()) {
            return true;
        } else if (st.mayThrow()) {
            ET et = s.et;
            if (et == ET.E1) {
                return isThrow(s.getOp());
            } else if (et == ET.E2) {
                return isThrow(s.getOp1()) || isThrow(s.getOp2());
            } else {
                throw new RuntimeException();
            }
        } else {
            return false;
        }
    }

    private static boolean isThrow(Value op) {
        VT vt = op.vt;
        if (vt.canThrow()) {
            return true;
        } else if (vt.mayThrow()) {
            switch (op.et) {
            case E1:
                return isThrow(op.getOp());
            case E2:
                return isThrow(op.getOp1()) || isThrow(op.getOp2());
            default:
            case En:
            case E0:
                throw new RuntimeException();
            }
        } else {
            return false;
        }
    }

    public static void createCfgWithoutEx(IrMethod jm) {
        for (Stmt st : jm.stmts) {
            st.frame = null;
            st.exceptionHandlers = null;
            if (st._cfg_froms == null) {
                st._cfg_froms = new TreeSet<>(jm.stmts);
            } else {
                st._cfg_froms.clear();
            }
        }

        for (Stmt st : jm.stmts) {
            if (st.st.canBranch()) {
                link(st, ((JumpStmt) st).getTarget());
            }
            if (st.st.canContinue()) {
                link(st, st.getNext());
            }
            if (st.st.canSwitch()) {
                BaseSwitchStmt bss = (BaseSwitchStmt) st;
                link(st, bss.defaultTarget);
                for (Stmt target : bss.targets) {
                    link(st, target);
                }
            }
        }
    }

    public static void createCFG(IrMethod jm) {
        createCfgWithoutEx(jm);
        for (Trap t : jm.traps) {
            for (Stmt s = t.start; s != t.end; s = s.getNext()) {
                if (isThrow(s)) {
                    Set<LabelStmt> hs = s.exceptionHandlers;
                    if (hs == null) {
                        hs = new TreeSet<>(jm.stmts);
                        s.exceptionHandlers = hs;
                    }
                    for (LabelStmt handler : t.handlers) {
                        link(s, handler);
                        hs.add(handler);
                    }
                }
            }
        }

    }

    public interface DfsVisitor {
        void onVisit(Stmt p);
    }

    public static void dfsVisit(IrMethod method, DfsVisitor visitor) {
        for (Stmt st : method.stmts) {
            st.visited = false;
        }
        Stack<Stmt> stack = new Stack<>();
        stack.add(method.stmts.getFirst());
        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    stack.push(labelStmt);
                }
            }
            if (visitor != null) {
                visitor.onVisit(currentStmt);
            }
            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                Collections.addAll(stack, bs.targets);
                LabelStmt target = bs.defaultTarget;
                stack.add(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                stack.add(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                stack.add(target);
            }
        }
    }
    @SuppressWarnings("unchecked")
    public static <T> void dfs(StmtList stmts, FrameVisitor<T> sv) {
        if (stmts.getSize() == 0) {
            return;
        }
        // clean
        for (Stmt st : stmts) {
            st.visited = false;
            st.frame = null;
        }

        Stack<Stmt> stack = new Stack<>();
        Stmt first = stmts.getFirst();
        Stmt nop = null;
        if (first.st == ST.LABEL && first._cfg_froms.size() > 0) {
            nop = Stmts.nNop();
            // for
            // L0:
            // ...
            // GOTO L0:
            // make sure the first Label has one more super
            first._cfg_froms.add(nop);
        }
        stack.add(first);
        first.frame = sv.initFirstFrame(first);

        while (!stack.isEmpty()) {
            Stmt currentStmt = stack.pop();
            if (currentStmt == null || currentStmt.visited) {
                continue;
            } else {
                currentStmt.visited = true;
            }

            T beforeExecFrame = (T) currentStmt.frame;
            
            if (currentStmt.exceptionHandlers != null) {
                for (LabelStmt labelStmt : currentStmt.exceptionHandlers) {
                    labelStmt.frame = sv.merge(beforeExecFrame, (T) labelStmt.frame, currentStmt, labelStmt);
                    stack.push(labelStmt);
                }
            }
            
            T afterExecFrame = sv.exec(beforeExecFrame, currentStmt);

            if (currentStmt.st.canSwitch()) {
                BaseSwitchStmt bs = (BaseSwitchStmt) currentStmt;
                for (LabelStmt target : bs.targets) {
                    target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                    stack.push(target);
                }
                LabelStmt target = bs.defaultTarget;
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canBranch()) {
                Stmt target = ((JumpStmt) currentStmt).getTarget();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
            if (currentStmt.st.canContinue()) {
                Stmt target = currentStmt.getNext();
                target.frame = sv.merge(afterExecFrame, (T) target.frame, currentStmt, target);
                stack.push(target);
            }
        }

        if (nop != null) {
            first._cfg_froms.remove(nop);
        }      
    }

    private static void link(Stmt from, Stmt to) {
        if (to == null) {// last stmt is a LabelStmt
            return;
        }
        to._cfg_froms.add(from);
    }

    public interface OnUseCallBack {
        Value onUse(Local v);
    }

    public interface OnAssignCallBack {
        Value onAssign(Local v, AssignStmt as);
    }

    public interface TravelCallBack extends OnUseCallBack, OnAssignCallBack {

    }

    public static Value travelMod(Value value, OnUseCallBack callback) {
        switch (value.et) {
        case E0:
            if (value.vt == VT.LOCAL) {
                return callback.onUse((Local) value);
            }
            break;
        case E1:
            value.setOp(travelMod(value.getOp(), callback));
            break;
        case E2:
            value.setOp1(travelMod(value.getOp1(), callback));
            value.setOp2(travelMod(value.getOp2(), callback));
            break;
        case En:
            Value[] ops = value.getOps();
            for (int i = 0; i < ops.length; i++) {
                ops[i] = travelMod(ops[i], callback);
            }
            break;
        }
        return value;
    }

    public static void travel(Value value, OnUseCallBack callback) {
        switch (value.et) {
        case E0:
            if (value.vt == VT.LOCAL) {
                callback.onUse((Local) value);
            }
            break;
        case E1:
            travel(value.getOp(), callback);
            break;
        case E2:
            travel(value.getOp1(), callback);
            travel(value.getOp2(), callback);
            break;
        case En:
            Value[] ops = value.getOps();
            for (Value op : ops) {
                travel(op, callback);
            }
            break;
        }
    }

    public static void travelMod(Stmt p, TravelCallBack callback, boolean travelPhi) {
        switch (p.et) {
        case E1:
            p.setOp(travelMod(p.getOp(), callback));
            break;
        case E2:
            Value e2op1 = p.getOp1();
            if (e2op1.vt == VT.LOCAL && (p.st == ST.ASSIGN || p.st == ST.IDENTITY)) {
                p.setOp2(travelMod(p.getOp2(), callback));
                p.setOp1(callback.onAssign((Local) e2op1, (AssignStmt) p));
            } else {
                p.setOp1(travelMod(p.getOp1(), callback));
                p.setOp2(travelMod(p.getOp2(), callback));
            }
            break;
        case En:
        case E0:
            if (travelPhi && p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        travelMod(phi, callback, false);
                    }
                }
            }
            break;
        }
    }

    public static void travel(Stmt p, TravelCallBack callback, boolean travelPhi) {
        switch (p.et) {
        case E1:
            travel(p.getOp(), callback);
            break;
        case E2:
            Value e2op1 = p.getOp1();
            if (e2op1.vt == VT.LOCAL && (p.st == ST.ASSIGN || p.st == ST.IDENTITY)) {
                travel(p.getOp2(), callback);
                callback.onAssign((Local) e2op1, (AssignStmt) p);
            } else {
                travel(p.getOp1(), callback);
                travel(p.getOp2(), callback);
            }
            break;
        case En:
        case E0:
            if (travelPhi && p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        travel(phi, callback, false);
                    }
                }
            }
            break;
        }
    }

    public static void travel(StmtList stmts, TravelCallBack callback, boolean travelPhi) {
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            travel(p, callback, travelPhi);
        }
    }

    public static void travelMod(StmtList stmts, TravelCallBack callback, boolean travelPhi) {
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            travelMod(p, callback, travelPhi);
        }
    }

    /**
     * @param method
     * @return size of locals
     */
    public static int reIndexLocal(IrMethod method) {
        int i = 0;
        for (Local local : method.locals) {
            local._ls_index = i++;
        }
        return i;
    }

    public static void collectTos(Stmt stmt, Set<Stmt> tos) {
        if (stmt.st.canBranch()) {
            tos.add(((JumpStmt) stmt).getTarget());
        }
        if (stmt.st.canContinue()) {
            tos.add(stmt.getNext());
        }
        if (stmt.st.canSwitch()) {
            BaseSwitchStmt bss = (BaseSwitchStmt) stmt;
            tos.add(bss.defaultTarget);

            Collections.addAll(tos, bss.targets);
        }
        if (stmt.exceptionHandlers != null) {
            tos.addAll(stmt.exceptionHandlers);
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/CleanLabel.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.LocalVar;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.stmt.*;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;

/**
 * Clean unused {@link LabelStmt}
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class CleanLabel implements Transformer {

    @Override
    public void transform(IrMethod irMethod) {
        Set<LabelStmt> uselabels = new HashSet<LabelStmt>();
        addTrap(irMethod.traps, uselabels);
        addVars(irMethod.vars, uselabels);
        addStmt(irMethod.stmts, uselabels);
        if (irMethod.phiLabels != null) {
            uselabels.addAll(irMethod.phiLabels);
        }
        rmUnused(irMethod.stmts, uselabels);
    }

    private void addVars(List<LocalVar> vars, Set<LabelStmt> uselabels) {
        if (vars != null) {
            for (LocalVar var : vars) {
                uselabels.add(var.start);
                uselabels.add(var.end);
            }
        }

    }

    private void rmUnused(StmtList stmts, Set<LabelStmt> uselabels) {
        for (Stmt p = stmts.getFirst(); p != null;) {
            if (p.st == ST.LABEL) {
                if (!uselabels.contains(p)) {
                    Stmt q = p.getNext();
                    stmts.remove(p);
                    p = q;
                    continue;
                }
            }
            p = p.getNext();
        }
    }

    private void addStmt(StmtList stmts, Set<LabelStmt> labels) {
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p instanceof JumpStmt) {
                labels.add(((JumpStmt) p).getTarget());
            } else if (p instanceof BaseSwitchStmt) {
                BaseSwitchStmt stmt = (BaseSwitchStmt) p;
                labels.add(stmt.defaultTarget);
                for (LabelStmt t : stmt.targets) {
                    labels.add(t);
                }
            }
        }
    }

    private void addTrap(List<Trap> traps, Set<LabelStmt> labels) {
        if (traps != null) {
            for (Trap trap : traps) {
                labels.add(trap.start);
                labels.add(trap.end);
                for (LabelStmt h : trap.handlers) {
                    labels.add(h);
                }
            }
        }
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/ConstTransformer.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.*;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.E2Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import com.googlecode.dex2jar.ir.ts.Cfg.TravelCallBack;

import java.util.HashSet;
import java.util.Queue;
import java.util.Set;

/**
 * Replace must-be-constant local to constant
 * <p/>
 * Require a SSA form, usually run after {@link SSATransformer}
 *
 * @author Panxiaobo
 */
@SuppressWarnings({"unchecked", "rawtypes"})
public class ConstTransformer implements Transformer {
    @Override
    public void transform(IrMethod m) {

        // 1. init
        init(m);

        // 2. collect
        collect(m);

        // 3. mark constant
        markConstant(m);
        markReplacable(m);
        // 4. replace
        replace(m);

        // 5. clean
        clean(m);
    }

    private void clean(IrMethod m) {
        for (Local local : m.locals) {
            local.tag = null;
        }
    }

    private void replace(IrMethod m) {
        Cfg.travelMod(m.stmts, new TravelCallBack() {

            @Override
            public Value onUse(Local v) {
                ConstAnalyzeValue cav = (ConstAnalyzeValue) v.tag;
                if (cav.replacable) {
                    return Exprs.nConstant(cav.cst);
                }
                return v;
            }

            @Override
            public Value onAssign(Local v, AssignStmt as) {
                ConstAnalyzeValue cav = (ConstAnalyzeValue) v.tag;
                if (cav.replacable) {
                    if (as.op2.trim().vt != VT.CONSTANT) {
                        as.op2 = Exprs.nConstant(cav.cst);
                    }
                }
                return v;
            }

        }, true);
    }

    private void markReplacable(IrMethod m) {
        for (Local local : m.locals) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) local.tag;
            if (Boolean.TRUE.equals(cav.isConst)) {
                boolean allTosAreCst = true;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.TRUE.equals(c.isConst)) {
                        allTosAreCst = false;
                        break;
                    }
                }
                if (allTosAreCst) {
                    cav.replacable = true;
                }
            }
        }
    }

    private void markConstant(IrMethod m) {
        Queue<Local> queue = new UniqueQueue<>();
        queue.addAll(m.locals);
        while (!queue.isEmpty()) {
            ConstAnalyzeValue cav = (ConstAnalyzeValue) queue.poll().tag;

            Object cst = cav.cst;

            if (cav.isConst == null) {
                if (cst != null) {// we have a cst
                    boolean allCstEquals = true;
                    for (ConstAnalyzeValue p0 : cav.assignFrom) {
                        if (!cst.equals(p0.cst)) {
                            allCstEquals = false;
                            break;
                        }
                    }
                    if (allCstEquals) {
                        cav.isConst = true;

                    }
                }
            }

            if (cst != null || Boolean.TRUE.equals(cav.isConst)) {
                for (ConstAnalyzeValue p0 : cav.assignTo) {
                    if (p0.isConst == null) {
                        if (p0.cst == null) {
                            p0.cst = cst;
                        }
                        queue.add(p0.local);
                    }
                }
            }

            if (Boolean.FALSE.equals(cav.isConst)) {
                cav.cst = null;
                for (ConstAnalyzeValue c : cav.assignTo) {
                    if (!Boolean.FALSE.equals(c.isConst)) {
                        c.cst = null;
                        c.isConst = false;
                        queue.add(c.local);
                    }
                }
            }
        }
    }

    private void collect(IrMethod m) {
        for (Stmt p = m.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.ASSIGN || p.st == ST.IDENTITY) {
                E2Stmt e2 = (E2Stmt) p;
                Value op1 = e2.op1.trim();
                Value op2 = e2.op2.trim();
                if (op1.vt == VT.LOCAL) {
                    ConstAnalyzeValue cav = (ConstAnalyzeValue) ((Local) op1).tag;
                    if (op2.vt == VT.CONSTANT) {
                        Constant c = (Constant) op2;
                        cav.isConst = true;
                        cav.cst = c.value;
                    } else if (op2.vt == VT.LOCAL) {
                        Local local2 = (Local) op2;
                        ConstAnalyzeValue zaf2 = (ConstAnalyzeValue) local2.tag;
                        cav.assignFrom.add(zaf2);
                        zaf2.assignTo.add(cav);
                    } else if (op2.vt == VT.PHI) {
                        PhiExpr pe = (PhiExpr) op2;
                        for (Value v : pe.ops) {
                            ConstAnalyzeValue zaf2 = (ConstAnalyzeValue) ((Local) v.trim()).tag;
                            cav.assignFrom.add(zaf2);
                            zaf2.assignTo.add(cav);
                        }
                    } else {
                        cav.isConst = Boolean.FALSE;
                    }
                }
            }
        }
    }

    private void init(IrMethod m) {
        for (Local local : m.locals) {
            local.tag = new ConstAnalyzeValue(local);
        }
    }

    static class ConstAnalyzeValue {
        private static final Integer ZERO = Integer.valueOf(0);
        public final Local local;
        public Boolean isConst = null;
        public boolean replacable = false;
        public Object cst;
        public Set<ConstAnalyzeValue> assignFrom = new HashSet(3);
        public Set<ConstAnalyzeValue> assignTo = new HashSet(3);

        public ConstAnalyzeValue(Local local) {
            super();
            this.local = local;
        }

        public boolean isZero() {
            if (isConst == null) {
                return false;
            }
            return isConst && (ZERO.equals(cst));
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/DeadCodeTransformer.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.PhiExpr;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;

import java.util.*;

public class DeadCodeTransformer implements Transformer {
    @Override
    public void transform(IrMethod method) {
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, null);
        if (method.traps != null) {
            for (Iterator<Trap> it = method.traps.iterator(); it.hasNext();) {
                Trap t = it.next();
                boolean allNotThrow = true;
                for (Stmt p = t.start; p != t.end; p = p.getNext()) {
                    if (p.visited && Cfg.isThrow(p)) {
                        allNotThrow = false;
                        break;
                    }
                }
                if (allNotThrow) {
                    it.remove();
                    continue;
                }

                boolean allNotVisited = true;
                boolean allVisited = true;
                for (LabelStmt labelStmt : t.handlers) {
                    if (labelStmt.visited) {
                        allNotVisited = false;
                    } else {
                        allVisited = false;
                    }
                }
                if (allNotVisited) {
                    it.remove();
                } else {
                    // keep start and end
                    t.start.visited = true;
                    t.end.visited = true;
                    if (!allVisited) { // part visited
                        List<String> types = new ArrayList<>(t.handlers.length);
                        List<LabelStmt> labelStmts = new ArrayList<>(t.handlers.length);
                        for (int i = 0; i < t.handlers.length; i++) {
                            labelStmts.add(t.handlers[i]);
                            types.add(t.types[i]);
                        }
                        t.handlers = labelStmts.toArray(new LabelStmt[labelStmts.size()]);
                        t.types = types.toArray(new String[types.size()]);
                    }
                }
            }
        }
        Set<Local> definedLocals = new HashSet<>();
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {
            Stmt p = it.next();
            if (!p.visited) {
                it.remove();
                continue;
            }
            if (p.st == Stmt.ST.ASSIGN || p.st == Stmt.ST.IDENTITY) {
                if (p.getOp1().vt == Value.VT.LOCAL) {
                    definedLocals.add((Local) p.getOp1());
                }
            }
        }
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (!labelStmt.visited) {
                    it.remove();
                    continue;
                }
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        definedLocals.add((Local) phi.getOp1());
                    }
                }
            }
        }

        method.locals.clear();
        method.locals.addAll(definedLocals);
        Set<Value> tmp = new HashSet<>();
        if (method.phiLabels != null) {
            for (Iterator<LabelStmt> it = method.phiLabels.iterator(); it.hasNext();) {
                LabelStmt labelStmt = it.next();
                if (labelStmt.phis != null) {
                    for (AssignStmt phi : labelStmt.phis) {
                        PhiExpr phiExpr = (PhiExpr) phi.getOp2();
                        boolean needRebuild = false;
                        for (Value v : phiExpr.getOps()) {
                            if (!definedLocals.contains(v)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        if (needRebuild) {
                            for (Value v : phiExpr.getOps()) {
                                if (definedLocals.contains(v)) {
                                    tmp.add(v);
                                }
                            }
                            phiExpr.setOps(tmp.toArray(new Value[tmp.size()]));
                            tmp.clear();
                        }
                    }
                }
            }
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/EndRemover.java`:

```java
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.stmt.*;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;

import java.util.ArrayList;

/**
 * Try to clean following between a {@link Trap}
 * <ol>
 * <li>Move {@link Stmt}s outside a {@link Trap} if {@link Stmt}s are not throw</li>
 * <li>Remove {@link Trap} if all {@link Stmt}s are not throw</li>
 * <li>...;GOTO L2; ... ; L2: ; return; => ...;return ; ... ; L2: ; return;</li>
 * </ol>
 * 
 * @author bob
 * 
 */
public class EndRemover implements Transformer {

    private static final LabelAndLocalMapper keepLocal = new LabelAndLocalMapper() {
        @Override
        public Local map(Local local) {
            return local;
        }
    };

    @Override
    public void transform(IrMethod irMethod) {
        for (Trap trap : new ArrayList<Trap>(irMethod.traps)) {// copy the list and we can remove one from original list
            LabelStmt start = null;
            boolean removeTrap = true;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end;) {
                boolean notThrow = Cfg.notThrow(p);
                if (!notThrow) {
                    start = null;
                    p = p.getNext();
                    removeTrap = false;
                    continue;
                }
                switch (p.st) {
                case LABEL:
                    if (start != null) {
                        move4Label(irMethod.stmts, start, p.getPre(), (LabelStmt) p);
                    }
                    start = (LabelStmt) p;
                    p = p.getNext();

                    break;
                case GOTO:
                case RETURN:
                case RETURN_VOID:
                    if (start != null) {
                        Stmt tmp = p.getNext();
                        move4End(irMethod.stmts, start, p);
                        start = null;
                        p = tmp;
                    } else {
                        p = p.getNext();
                    }
                    break;
                default:
                    p = p.getNext();
                }
            }
            if (removeTrap) {
                irMethod.traps.remove(trap);
            }
        }
        StmtList stmts = irMethod.stmts;
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.GOTO) {
                LabelStmt target = ((GotoStmt) p).target;
                Stmt next = target.getNext();
                if (next != null && (next.st == ST.RETURN || next.st == ST.RETURN_VOID)) {
                    Stmt nnext = next.clone(keepLocal);
                    stmts.insertAfter(p, nnext);
                    stmts.remove(p);
                    p = nnext;
                }
            }
        }

    }

    private void move4Label(StmtList stmts, LabelStmt start, Stmt end, LabelStmt label) {
        move4End(stmts, start, end);
        stmts.insertAfter(end, Stmts.nGoto(label));
    }

    private void move4End(StmtList stmts, LabelStmt start, Stmt end) {
        Stmt g1 = Stmts.nGoto(start);
        stmts.insertBefore(start, g1);
        Stmt last = stmts.getLast();
        while (last.st == ST.GOTO && ((GotoStmt) last).target == start) {
            stmts.remove(last);
            last = stmts.getLast();
        }
        stmts.move(start, end, last);

    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/ExceptionHandlerTrim.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.LabelAndLocalMapper;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import com.googlecode.dex2jar.ir.stmt.Stmts;

import java.util.ArrayList;
import java.util.List;

/**
 * Trim Exception handler.
 * 
 * before:
 * 
 * <pre>
 * L1
 * STMTs
 * throwableSTMTs
 * STMTs
 * throwableSTMTs
 * L2
 * ...
 * L3
 * ...
 * 
 * L1 - L2 : all > L3
 * 
 * </pre>
 * 
 * after:
 * 
 * <pre>
 * L1
 * STMTs
 * L4
 * throwableSTMTs
 * L5
 * STMTs
 * L6
 * throwableSTMTs
 * L2
 * ...
 * L3
 * ...
 * 
 * L4 - L5 : all > L3
 * L6 - L2 : all > L3
 * </pre>
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class ExceptionHandlerTrim implements Transformer {

    @SuppressWarnings({ "unchecked", "rawtypes" })
    @Override
    public void transform(IrMethod irMethod) {
        List<Trap> trips = irMethod.traps;
        irMethod.traps = new ArrayList();
        LabelAndLocalMapper map=new LabelAndLocalMapper(){
            @Override
            public LabelStmt map(LabelStmt label) {
                return label;
            }
        };
        for (Trap trap : trips) {
            Trap ntrap = trap.clone(map);
            int status = 0;
            for (Stmt p = trap.start.getNext(); p != trap.end; p = p.getNext()) {
                if (!Cfg.notThrow(p)) {
                    if (status == 0) {
                        Stmt pre = p.getPre();
                        if (pre == null || pre.st != ST.LABEL) {
                            pre = Stmts.nLabel();
                            irMethod.stmts.insertBefore(p, pre);
                        }
                        ntrap.start = (LabelStmt) pre;
                        status = 1;
                    } else if (status == 1) {
                        // continue;
                    }

                } else if (status == 1) {
                    Stmt pre = p.getPre();
                    if (pre == null || pre.st != ST.LABEL) {
                        pre = Stmts.nLabel();
                        irMethod.stmts.insertBefore(p, pre);
                    }

                    ntrap.end = (LabelStmt) pre;
                    irMethod.traps.add(ntrap);
                    status = 0;
                    ntrap = trap.clone(map);
                }
            }
            if (status == 1) {
                ntrap.end = trap.end;
                irMethod.traps.add(ntrap);
                status = 0;
            }
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/FixVar.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.LocalVar;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.Stmts;

/**
 * the {@link LocalVar#reg} in {@link LocalVar} may be replace to a constant value in {@link ConstTransformer}. This
 * class try to insert a new local before {@link LocalVar#start}.
 * 
 * <p>
 * before:
 * </p>
 * 
 * <pre>
 *   ...
 * L0:
 *   return a0
 * L1:
 * ======
 * .var L0 ~ L1 1 -> test // int
 * </pre>
 * <p>
 * after:
 * </p>
 * 
 * <pre>
 *   ...
 *   d1 = 1
 * L0:
 *   return a0
 * L1:
 * ======
 * .var L0 ~ L1 d1 -> test // int
 * </pre>
 * 
 * @author Panxiaobo
 * 
 */
public class FixVar implements Transformer {

    @Override
    public void transform(IrMethod irMethod) {
        int i = 0;
        for (LocalVar var : irMethod.vars) {
            if (var.reg.trim().vt != VT.LOCAL) {
                if (var.reg.trim().vt == VT.CONSTANT) {
                    Local n = new Local(i++);
                    Value old = var.reg.trim();
                    irMethod.stmts.insertBefore(var.start, Stmts.nAssign(n, old));
                    var.reg = n;
                    irMethod.locals.add(n);
                } else {
                    // throw new DexExcpeption("not support");
                }
            }
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/Ir2JRegAssignTransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import java.util.*;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.RefExpr;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import com.googlecode.dex2jar.ir.ts.an.SimpleLiveAnalyze;
import com.googlecode.dex2jar.ir.ts.an.SimpleLiveValue;

/**
 * <ol>
 * <li>Share same reg between locals with same type.</li>
 * <li>@This always assign as 0, and not share with others.</li>
 * <li>long/double tasks two index</li>
 * </ol>
 *
 * @author bob
 */
public class Ir2JRegAssignTransformer implements Transformer {

    public static class Reg {
        public Set<Reg> excludes = new HashSet<>(4);
        public Set<Reg> prefers = new HashSet<>(3);
        int reg = -1;
        public char type;
    }

    private static final Comparator<Reg> OrderRegAssignByPreferredSizeDesc = new Comparator<Reg>() {

        @Override
        public int compare(Reg o1, Reg o2) {
            int x = o2.prefers.size() - o1.prefers.size();
            if (x == 0) {
                x = o2.excludes.size() - o1.excludes.size();
            }
            return x;
        }
    };

    private Reg[] genGraph(IrMethod method, final Reg[] regs) {
        Reg args[];
        if (method.isStatic) {
            args = new Reg[method.args.length];
        } else {
            args = new Reg[method.args.length + 1];
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if (stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) {
                if (stmt.getOp1().vt == VT.LOCAL) {
                    Local left = (Local) stmt.getOp1();
                    Value op2 = stmt.getOp2();
                    int idx = left._ls_index;
                    Reg leftReg = regs[idx];

                    // a new local can't effect next value live in next frame
                    Cfg.collectTos(stmt, tos);
                    for (Stmt next : tos) {
                        SimpleLiveValue[] frame = (SimpleLiveValue[]) next.frame;
                        if (frame == null) {
                            continue;
                        }
                        for (int i = 0; i < frame.length; i++) {
                            if (i == idx) {
                                continue;
                            }
                            SimpleLiveValue v = frame[i];
                            if (v != null && v.used) {
                                Reg rightReg = regs[i];
                                leftReg.excludes.add(rightReg);
                                rightReg.excludes.add(leftReg);
                            }
                        }
                    }
                    tos.clear();

                    // Preferred same reg can save load-store
                    if (op2.vt == VT.LOCAL) {
                        Reg rightReg = regs[((Local) op2)._ls_index];
                        leftReg.prefers.add(rightReg);
                        rightReg.prefers.add(leftReg);
                    }

                    // record @this @parameter_x
                    if (op2.vt == VT.THIS_REF) {
                        args[0] = leftReg;
                    } else if (op2.vt == VT.PARAMETER_REF) {
                        RefExpr refExpr = (RefExpr) op2;
                        if (method.isStatic) {
                            args[refExpr.parameterIndex] = leftReg;
                        } else {
                            args[refExpr.parameterIndex + 1] = leftReg;
                        }
                    }
                }
            }
        }
        // remove the link between itself
        for (Reg reg : regs) {
            reg.excludes.remove(reg);
            reg.prefers.remove(reg);
        }
        return args;
    }

   Map<Character, List<Reg>> groupAndCleanUpByType(Reg[] regs) {
        Map<Character, List<Reg>> groups = new HashMap<>();
        for (Reg reg : regs) {
            char simpleType = reg.type;
            List<Reg> group = groups.get(simpleType);
            if (group == null) {
                group = new ArrayList<>();
                groups.put(simpleType, group);
            }
            group.add(reg);

            for (Iterator<Reg> it = reg.excludes.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }
            for (Iterator<Reg> it = reg.prefers.iterator(); it.hasNext(); ) {
                Reg ex = it.next();
                if (ex.type != reg.type) {
                    it.remove();
                }
            }
        }
        return groups;
    }

    private void initExcludeColor(BitSet excludeColor, Reg as) {
        excludeColor.clear();
        for (Reg ex : as.excludes) {
            if (ex.reg >= 0) {
                excludeColor.set(ex.reg);
                if (ex.type == 'J' || ex.type == 'D') {
                    excludeColor.set(ex.reg + 1);
                }
            }
        }
    }

    private void initSuggestColor(BitSet suggestColor, Reg as) {
        suggestColor.clear();
        for (Reg ex : as.prefers) {
            if (ex.reg >= 0) {
                suggestColor.set(ex.reg);
            }
        }
    }

    @Override
    public void transform(IrMethod method) {
        if (method.locals.size() == 0) {
            return;
        }
        SimpleLiveAnalyze sa = new SimpleLiveAnalyze(method, true);
        sa.analyze();

        // init regs
        int maxLocalSize = sa.getLocalSize();
        final Reg regs[] = new Reg[maxLocalSize];
        for (Local local : method.locals) {
            Reg reg = new Reg();
            char type = local.valueType.charAt(0);
            if (type == '[') {
                type = 'L';
            }
            reg.type = type;
            local.tag = reg;
            regs[local._ls_index] = reg;
        }

        // gen graph
        Reg[] args = genGraph(method, regs);

        // fix up the graph, make sure @this is not share index with others
        if (!method.isStatic) {
            Reg atThis = args[0];
            for (Reg reg : regs) {
                if (reg == atThis) {
                    continue;
                }
                reg.excludes.add(atThis);
                atThis.excludes.add(reg);
            }
        }

        { // assgin @this, @parameter_x from index 0
            int i = 0;
            int index = 0;
            if (!method.isStatic) {
                args[i++].reg = index++;
            }
            for (int j = 0; j < method.args.length; j++) {
                Reg reg = args[i++];
                String type = method.args[j];
                if (reg == null) {
                    index++;
                } else {
                    reg.reg = index++;
                }
                if ("J".equals(type) || "D".equals(type)) {
                    index++;
                }
            }
        }

        Map<Character, List<Reg>> groups = groupAndCleanUpByType(regs);
        // type each group
        BitSet excludeColor = new BitSet();
        BitSet suggestColor = new BitSet();
        BitSet globalExcludes = new BitSet();
        BitSet usedInOneType = new BitSet();
        for (Map.Entry<Character, List<Reg>> e : groups.entrySet()) {
            List<Reg> assigns = e.getValue();
            Collections.sort(assigns, OrderRegAssignByPreferredSizeDesc);
            char type = e.getKey();
            boolean doubleOrLong = type == 'J' || type == 'D';
            for (Reg as : assigns) {
                if (as.reg < 0) {// need color

                    initExcludeColor(excludeColor, as);
                    excludeParameters(excludeColor, args, type);

                    excludeColor.or(globalExcludes); // exclude index used by other types

                    initSuggestColor(suggestColor, as);

                    // first find a preferred color
                    for (int i = suggestColor.nextSetBit(0); i >= 0; i = suggestColor.nextSetBit(i + 1)) {
                        if (doubleOrLong) { // need 2
                            if (!excludeColor.get(i) && !excludeColor.get(i + 1)) {
                                as.reg = i;
                                break;
                            }
                        } else {
                            if (!excludeColor.get(i)) {
                                as.reg = i;
                                break;
                            }
                        }
                    }
                    if (as.reg < 0) {
                        if (doubleOrLong) {
                            int reg = -1;
                            do {
                                reg++;
                                reg = excludeColor.nextClearBit(reg);
                            } while (excludeColor.get(reg + 1));
                            as.reg = reg;
                        } else {
                            int reg = excludeColor.nextClearBit(0);
                            as.reg = reg;
                        }
                    }
                }
                usedInOneType.set(as.reg);
                if (doubleOrLong) {
                    usedInOneType.set(as.reg + 1);
                }
            }
            globalExcludes.or(usedInOneType);
            usedInOneType.clear();
        }

        for (Local local : method.locals) {
            Reg as = (Reg) local.tag;
            local._ls_index = as.reg;
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }

    private void excludeParameters(BitSet excludeColor, Reg[] args, char type) {
        for (Reg arg : args) {
            if (arg.type != type) {
                excludeColor.set(arg.reg);
                if (arg.type == 'J' || arg.type == 'D') {
                    excludeColor.set(arg.reg + 1);
                }
            }
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/JimpleTransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.DexType;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Constant;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import com.googlecode.dex2jar.ir.stmt.Stmts;

/**
 * transforme IR to simple 3-addr format
 * 
 * a=b+c+d; => e=b+c; a=e+d;
 * 
 * @author bob
 * 
 */
public class JimpleTransformer implements Transformer {

    static class N {
        public List<Stmt> tmp;
        int nextIdx;
        private List<Local> locals;

        public N(List<Stmt> tmp, List<Local> locals) {
            super();
            this.tmp = tmp;
            this.locals = locals;
            nextIdx = locals.size();
        }

        Value newAssign(Value x) {
            Local loc = Exprs.nLocal(nextIdx++);
            loc.valueType = x.valueType;
            locals.add(loc);
            tmp.add(Stmts.nAssign(loc, x));
            return loc;
        }

    }

    @Override
    public void transform(IrMethod method) {
        List<Stmt> tmp = new ArrayList<>();
        N n = new N(tmp, method.locals);
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            tmp.clear();
            convertStmt(p, n);
            for (Stmt t : tmp) {
                method.stmts.insertBefore(p, t);
            }

        }
    }

    private Value convertExpr(Value x, boolean keep, N tmp) {
        switch (x.et) {
        case E0:
            if (!keep) {
                switch (x.vt) {
                case CONSTANT:
                    Constant cst = (Constant) x;
                    if (cst.value instanceof String || cst.value instanceof DexType
                            || cst.value.getClass().isArray()) {
                        return tmp.newAssign(x);
                    }
                    break;
                case NEW:
                case STATIC_FIELD:
                    return tmp.newAssign(x);
                default:
                }
            }
            break;
        case E1:
            x.setOp(convertExpr(x.getOp(), false, tmp));
            if (!keep) {
                return tmp.newAssign(x);
            }
            break;
        case E2:
            x.setOp1(convertExpr(x.getOp1(), false, tmp));
            x.setOp2(convertExpr(x.getOp2(), false, tmp));
            if (!keep) {
                return tmp.newAssign(x);
            }
            break;
        case En:
            Value[] ops = x.getOps();
            for (int i = 0; i < ops.length; i++) {
                ops[i] = convertExpr(ops[i], false, tmp);
            }
            if (!keep) {
                return tmp.newAssign(x);
            }
            break;
        }

        return x;
    }

    private void convertStmt(Stmt p, N tmp) {
        switch (p.et) {
        case E0:
            return;
        case E1:
            boolean keep;
            switch (p.st) {
            case LOOKUP_SWITCH:
            case TABLE_SWITCH:
            case RETURN:
            case THROW:
                keep = false;
                break;
            default:
                keep = true;
                break;
            }
            p.setOp(convertExpr(p.getOp(), keep, tmp));
            break;
        case E2:
            if (p.st == ST.IDENTITY) {
                return;
            } else if (p.st == ST.FILL_ARRAY_DATA) {
                p.setOp1(convertExpr(p.getOp1(), false, tmp));
                p.setOp2(convertExpr(p.getOp2(), true, tmp));
            } else {
                p.setOp1(convertExpr(p.getOp1(), true, tmp));
                p.setOp2(convertExpr(p.getOp2(), p.getOp1().vt == VT.LOCAL, tmp));
            }
            break;
        case En:
            Value[] ops = p.getOps();
            for (int i = 0; i < ops.length; i++) {
                ops[i] = convertExpr(ops[i], true, tmp);
            }
            break;
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/MultiArrayTransformer.java`:

```java
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.d2j.DexType;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.StmtTraveler;
import com.googlecode.dex2jar.ir.expr.*;

/**
 * dex does have the instruction to create a multi-array. the implement is to
 * using the Array.newInstance().
 * transform
 * <pre>
 * ((String[][][])Array.newInstance(String.class,new int[]{4, 5, 6}))
 * </pre>
 * to
 * <pre>
 * new String[4][5][6]
 * </pre>
 */
public class MultiArrayTransformer extends StatedTransformer {
    @Override
    public boolean transformReportChanged(IrMethod method) {
        final boolean changed[] = {false};
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                if (op.vt == Value.VT.CHECK_CAST) {
                    TypeExpr te = (TypeExpr) op;
                    if (te.op.vt == Value.VT.CHECK_CAST) {
                        TypeExpr te2 = (TypeExpr) te.op;
                        if (te.type.equals(te2.type)) {
                            op = te2;
                        }
                    }
                }
                op = super.travel(op);


                if (op.vt == Value.VT.CHECK_CAST) {
                    TypeExpr te = (TypeExpr) op;
                    if (te.type.charAt(0) == '[') {
                        Value from = te.getOp();
                        if (from.vt == Value.VT.INVOKE_STATIC) {
                            InvokeExpr invokeExpr = (InvokeExpr) from;
                            if (invokeExpr.getName().equals("newInstance")
                                    && invokeExpr.getOwner().equals("Ljava/lang/reflect/Array;")
                                    && invokeExpr.getArgs().length == 2
                                    && invokeExpr.getArgs()[0].equals("Ljava/lang/Class;")) {
                                Value arg0 = invokeExpr.getOps()[0];
                                String elementType = null;
                                if (arg0.vt == Value.VT.CONSTANT) {
                                    elementType = ((DexType) ((Constant) invokeExpr.getOps()[0]).value).desc;
                                } else {
                                    if (arg0.vt == Value.VT.STATIC_FIELD) {
                                        StaticFieldExpr sfe = (StaticFieldExpr) arg0;
                                        if (sfe.owner.startsWith("Ljava/lang/") && sfe.name.equals("TYPE")) {
                                            switch (sfe.owner) {
                                                case "Ljava/lang/Boolean;":
                                                    elementType = "Z";
                                                    break;
                                                case "Ljava/lang/Byte;":
                                                    elementType = "B";
                                                    break;
                                                case "Ljava/lang/Short;":
                                                    elementType = "S";
                                                    break;
                                                case "Ljava/lang/Character;":
                                                    elementType = "C";
                                                    break;
                                                case "Ljava/lang/Integer;":
                                                    elementType = "I";
                                                    break;
                                                case "Ljava/lang/Long;":
                                                    elementType = "J";
                                                    break;
                                                case "Ljava/lang/Float;":
                                                    elementType = "F";
                                                    break;
                                                case "Ljava/lang/Double;":
                                                    elementType = "D";
                                                    break;
                                                case "Ljava/lang/Void;":
                                                    elementType = "V";
                                                    break;
                                                default:
                                            }
                                        }
                                    }
                                }
                                if (elementType != null) {
                                    Value dt = invokeExpr.getOps()[1];
                                    if (invokeExpr.getArgs()[1].equals("I")) {
                                        if (te.type.equals("[" + elementType)) {
                                            int d = 0;
                                            while (elementType.charAt(d) == '[') {
                                                d++;
                                            }
                                            changed[0] = true;
                                            if (d > 0) {
                                                return Exprs.nNewMutiArray(elementType.substring(d), d + 1, new Value[]{dt});
                                            } else {
                                                return Exprs.nNewArray(elementType, dt);
                                            }
                                        }
                                    } else {// [I
                                        if (dt.vt == Value.VT.FILLED_ARRAY) {
                                            FilledArrayExpr filledArrayExpr = (FilledArrayExpr) dt;
                                            int d = filledArrayExpr.getOps().length;
                                            if (te.type.length() > d && te.type.substring(d).equals(elementType)) {
                                                int d1 = 0;
                                                while (elementType.charAt(d1) == '[') {
                                                    d1++;
                                                }
                                                changed[0] = true;
                                                return Exprs.nNewMutiArray(elementType.substring(d1), d1 + d, filledArrayExpr.getOps());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return op;
            }
        }.travel(method);

        return changed[0];
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/NewTransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.ET;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.StmtTraveler;
import com.googlecode.dex2jar.ir.expr.*;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmts;

import java.util.*;

import static com.googlecode.dex2jar.ir.expr.Value.VT.*;
import static com.googlecode.dex2jar.ir.stmt.Stmt.ST.*;

/**
 * simply merge
 * <p/>
 * <pre>
 *     a=NEW Labc;
 *     a.<init>();
 * </pre>
 * <p/>
 * to
 * <p/>
 * <pre>
 * a = new abc();
 * </pre>
 * <p/>
 * Run after [SSATransformer, RemoveLocalFromSSA]
 */
public class NewTransformer implements Transformer {

    static Vx IGNORED = new Vx(null, true);

    @Override
    public void transform(IrMethod method) {

        // 1. replace
        // =========
        // a=NEW Abc;
        // b=a
        // b.<init>()
        // to ======
        // a=new Abc();
        // b=a;
        // =========
        replaceX(method);

        // 2. replace NEW Abc;.<init>() -> new Abc();
        replaceAST(method);

    }

    void replaceX(IrMethod method) {
        final Map<Local, TObject> init = new HashMap<>();
        for (Stmt p : method.stmts) {
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL && p.getOp2().vt == NEW) {
                // the stmt is a new assign stmt
                Local local = (Local) p.getOp1();
                init.put(local, new TObject(local, (AssignStmt) p));
            }
        }

        if (init.size() > 0) {
            final int size = Cfg.reIndexLocal(method);
            makeSureUsedBeforeConstructor(method, init, size);
            if (init.size() > 0) {
                replace0(method, init, size);
            }
            for (Stmt stmt : method.stmts) {
                stmt.frame = null;
            }
        }
    }

    void replaceAST(IrMethod method) {
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();

            InvokeExpr ie = findInvokeExpr(p);

            if (ie != null) {
                if ("<init>".equals(ie.getName()) && "V".equals(ie.getRet())) {
                    Value[] orgOps = ie.getOps();
                    if (orgOps[0].vt == NEW) {
                        NewExpr newExpr = (NewExpr) ie.getOps()[0];
                        if (newExpr != null) {
                            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
                            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
                            method.stmts.insertBefore(p, Stmts.nVoidInvoke(invokeNew));
                            it.remove();
                        }
                    }
                }
            }
        }
    }

    void replace0(IrMethod method, Map<Local, TObject> init, int size) {
        Set<Local> toDelete = new HashSet<>();

        Local locals[] = new Local[size];
        for (Local local : method.locals) {
            locals[local._ls_index] = local;
        }

        // find all locals to delete
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    toDelete.add(locals[i]);
                }
            }
        }
        // delete the locals
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt p = it.next();
            if (p.st == ASSIGN && p.getOp1().vt == LOCAL) {
                if (toDelete.contains((Local) p.getOp1())) {
                    it.remove();
                }
            }
        }
        // add the locals back
        for (TObject obj : init.values()) {
            Vx[] frame = (Vx[]) obj.invokeStmt.frame;
            for (int i = 0; i < frame.length; i++) {
                Vx s = frame[i];
                if (s != null && s.obj == obj) {
                    Local b = locals[i];
                    if (b != obj.local) {
                        method.stmts.insertAfter(obj.invokeStmt, Stmts.nAssign(b, obj.local));
                    }
                }
            }
            InvokeExpr ie = findInvokeExpr(obj.invokeStmt);
            Value[] orgOps = ie.getOps();
            Value[] nOps = Arrays.copyOfRange(orgOps, 1, orgOps.length);
            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.getArgs(), ie.getOwner());
            method.stmts.replace(obj.invokeStmt, Stmts.nAssign(obj.local, invokeNew));
        }
    }

    void makeSureUsedBeforeConstructor(IrMethod method, final Map<Local, TObject> init, final int size) {
        Cfg.createCFG(method);
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<Vx[]>() {

            boolean keepFrame = false;
            Vx[] tmp = new Vx[size];
            StmtTraveler stmtTraveler = new StmtTraveler() {
                Stmt current;

                @Override
                public Stmt travel(Stmt stmt) {

                    this.current = stmt;
                    if (stmt.et == ET.E2) {
                        if (stmt.getOp1().vt == LOCAL) {
                            Local op1 = (Local) stmt.getOp1();
                            if (stmt.getOp2().vt == LOCAL) {
                                Local op2 = (Local) stmt.getOp2();
                                tmp[op1._ls_index] = tmp[op2._ls_index];
                                return stmt;
                            } else if (stmt.getOp2().vt == NEW) {
                                tmp[op1._ls_index] = new Vx(init.get(op1), false);
                                return stmt;
                            } else {
                                travel(stmt.getOp2());
                                tmp[op1._ls_index] = IGNORED;
                                return stmt;
                            }
                        }
                    }
                    if (stmt.st == LABEL) {
                        LabelStmt labelStmt = (LabelStmt) stmt;
                        if (labelStmt.phis != null) {
                            for (AssignStmt phi : labelStmt.phis) {
                                Local local = (Local) phi.getOp1();
                                tmp[local._ls_index] = IGNORED;
                            }
                        }
                        return stmt;
                    }
                    return super.travel(stmt);
                }

                @Override
                public Value travel(Value op) {
                    if (op.vt == INVOKE_SPECIAL) {
                        if (op.getOps().length >= 1) {
                            InvokeExpr ie = (InvokeExpr) op;
                            if ("<init>".equals(ie.getName())) {
                                Value thiz = op.getOps()[0];
                                if (thiz.vt == LOCAL) {
                                    Local local = (Local) thiz;
                                    Vx vx = tmp[local._ls_index];
                                    TObject object = vx.obj;
                                    if (object != null) {
                                        if (object.invokeStmt != null) {
                                            object.useBeforeInit = true;
                                        } else {
                                            vx.init = true;
                                            object.invokeStmt = current;
                                            for (int i = 0; i < tmp.length; i++) {
                                                Vx s = tmp[i];
                                                if (s != null && s.obj == object) {
                                                    tmp[i] = IGNORED;
                                                }
                                            }
                                            keepFrame = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    op = super.travel(op);

                    if (op.vt == LOCAL) {
                        use((Local) op);
                    }

                    return op;
                }
            };

            @Override
            public Vx[] merge(Vx[] srcFrame, Vx[] distFrame, Stmt src, Stmt dist) {
                if (distFrame == null) {
                    distFrame = new Vx[size];
                    System.arraycopy(srcFrame, 0, distFrame, 0, size);
                } else {
                    for (int i = 0; i < size; i++) {
                        Vx s = srcFrame[i];
                        Vx d = distFrame[i];
                        if (s != null) {
                            if (d == null) {
                                distFrame[i] = s;
                            } else {
                                if (s != d) {
                                    TObject obj = s.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                    obj = d.obj;
                                    if (obj != null) {
                                        obj.useBeforeInit = true;
                                    }
                                }
                            }
                        }
                    }
                }

                if (dist.st == LABEL) {
                    List<AssignStmt> phis = ((LabelStmt) dist).phis;
                    if (phis != null && phis.size() > 0) {
                        for (AssignStmt phi : phis) {
                            for (Value value : phi.getOp2().getOps()) {
                                Local local = (Local) value;
                                int i = local._ls_index;
                                Vx s = srcFrame[i];
                                Vx d = distFrame[i];
                                if (d != null) {
                                    if (!d.init) {
                                        TObject obj = d.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                } else if (s != null) {
                                    if (!s.init) {
                                        TObject obj = s.obj;
                                        if (obj != null) {
                                            obj.useBeforeInit = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public Vx[] initFirstFrame(Stmt first) {
                return new Vx[size];
            }

            @Override
            public Vx[] exec(Vx[] frame, Stmt stmt) {
                keepFrame = false;
                System.arraycopy(frame, 0, tmp, 0, size);
                stmtTraveler.travel(stmt);
                if (stmt._cfg_froms.size() > 1) {
                    keepFrame = true;
                }

                if (!keepFrame) {
                    stmt.frame = null;
                }
                return tmp;
            }

            void use(Local local) {
                Vx vx = tmp[local._ls_index];
                if (!vx.init) {
                    TObject object = vx.obj;
                    if (object != null) {
                        object.useBeforeInit = true;
                    }

                    tmp[local._ls_index] = IGNORED;
                }

            }
        });
        for (Iterator<Map.Entry<Local, TObject>> iterator = init.entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry<Local, TObject> e = iterator.next();
            boolean keep = true;
            TObject obj = e.getValue();
            if (obj.useBeforeInit) {
                keep = false;
            }
            if (obj.invokeStmt == null) {
                keep = false;
            }
            if (!keep) {
                iterator.remove();
            }
        }
    }

    InvokeExpr findInvokeExpr(Stmt p) {
        InvokeExpr ie = null;
        if (p.st == ASSIGN) {
            if (p.getOp2().vt == INVOKE_SPECIAL) {
                ie = (InvokeExpr) p.getOp2();
            }
        } else if (p.st == VOID_INVOKE) {
            Value op = p.getOp();
            if (op instanceof InvokeExpr) {
                ie = (InvokeExpr) op;
            }
        }
        return ie;
    }

    static class TObject {
        public Stmt invokeStmt;
        Local local;
        boolean useBeforeInit;
        private AssignStmt init;

        TObject(Local local, AssignStmt init) {
            this.local = local;
            this.init = init;
        }
    }

    static class Vx {
        boolean init;
        TObject obj;


        public Vx(TObject obj, boolean init) {
            this.obj = obj;
            this.init = init;
        }
    }


}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/NpeTransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.StmtSearcher;
import com.googlecode.dex2jar.ir.StmtTraveler;
import com.googlecode.dex2jar.ir.expr.Constant;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmts;

/**
 * Replace MUST be NullPointerException stmt to 'throw new NullPointerException()'
 *
 * Replace MUST be 'divide by zero' stmt to 'throw new ArithmeticException("divide by zero")'
 */
public class NpeTransformer extends StatedTransformer {
    private static class MustThrowException extends RuntimeException {
        private static final long serialVersionUID = 7501197864919305696L;
    }

    private static final MustThrowException NPE = new MustThrowException();
    private static final MustThrowException DIVE = new MustThrowException();
    private static final MustThrowException NEGATIVE_ARRAY_SIZE = new MustThrowException();

    @Override
    public boolean transformReportChanged(IrMethod method) {
        boolean changed = false;
        if (method.locals.size() == 0) {
            return false;
        }
        StmtSearcher st = new StmtSearcher() {
            @Override
            public void travel(Stmt stmt) {
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (isNull(stmt.getOp1())) {
                        throw NPE;
                    }
                }
                super.travel(stmt);
            }

            @Override
            public void travel(Value op) {
                switch (op.vt) {
                case INVOKE_VIRTUAL:
                case INVOKE_SPECIAL:
                case INVOKE_INTERFACE: {
                    if (isNull(op.getOps()[0])) {
                        throw NPE;
                    }
                }
                    break;
                case ARRAY: {
                    if (isNull(op.getOp1())) {
                        throw NPE;
                    }
                }
                    break;
                case FIELD: {
                    if (isNull(op.getOp())) {
                        throw NPE;
                    }
                }
                    break;
                    case IDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).intValue() == 0) {
                                throw DIVE;
                            }
                        }
                        break;
                    case LDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).longValue() == 0) {
                                throw DIVE;
                            }
                        }
                        break;
                    case NEW_ARRAY:
                        if (op.getOp().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp();
                            if (((Number) constant.value).intValue() < 0) {
                                throw NEGATIVE_ARRAY_SIZE;
                            }
                        }
                        break;
                    case NEW_MUTI_ARRAY:
                        for (Value size : op.getOps()) {
                            if (size.vt == Value.VT.CONSTANT) {
                                Constant constant = (Constant) size;
                                if (((Number) constant.value).intValue() < 0) {
                                    throw NEGATIVE_ARRAY_SIZE;
                                }
                            }
                        }
                        break;
                default:
                }
            }

        };
        for (Stmt p = method.stmts.getFirst(); p != null;) {
            try {
                st.travel(p);
                p = p.getNext();
            } catch (MustThrowException e) {
                replace(method, p);
                Stmt q = p.getNext();
                method.stmts.remove(p);
                changed = true;
                p = q;
            }
        }
        return changed;
    }

    private void replace(final IrMethod m, final Stmt p) {
        StmtTraveler traveler = new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                switch (op.vt) {
                case INVOKE_VIRTUAL:
                case INVOKE_SPECIAL:
                case INVOKE_INTERFACE: {
                    Value ops[] = op.getOps();
                    if (isNull(ops[0])) {
                        for (int i = 1; i < ops.length; i++) {
                            travel(ops[i]);
                        }
                        throw NPE;
                    }
                }
                    break;
                case ARRAY: {
                    if (isNull(op.getOp1())) {
                        travel(op.getOp2());
                        throw NPE;
                    }
                }
                    break;
                case FIELD: {
                    if (isNull(op.getOp())) {
                        throw NPE;
                    }
                }
                    break;
                    case IDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).intValue() == 0) {
                                travel(op.getOp1());
                                throw DIVE;
                            }
                        }
                        break;
                    case LDIV:
                        if (op.getOp2().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp2();
                            if (((Number) constant.value).longValue() == 0) {
                                travel(op.getOp1());
                                throw DIVE;
                            }
                        }
                        break;
                    case NEW_ARRAY:
                        if (op.getOp().vt == Value.VT.CONSTANT) {
                            Constant constant = (Constant) op.getOp();
                            if (((Number) constant.value).intValue() < 0) {
                                throw NEGATIVE_ARRAY_SIZE;
                            }
                        }
                        break;
                    case NEW_MUTI_ARRAY:
                        for (Value size : op.getOps()) {
                            if (size.vt == Value.VT.CONSTANT) {
                                Constant constant = (Constant) size;
                                if (((Number) constant.value).intValue() < 0) {
                                    throw NEGATIVE_ARRAY_SIZE;
                                }else {
                                    travel(size);
                                }
                            }
                        }
                        break;
                default:
                }
                Value sop = super.travel(op);
                if (sop.vt == Value.VT.LOCAL || sop.vt == Value.VT.CONSTANT) {
                    return sop;
                } else {
                    Local local = new Local();
                    m.locals.add(local);
                    m.stmts.insertBefore(p, Stmts.nAssign(local, sop));
                    return local;
                }
            }
        };
        try {
            switch (p.et) {
            case E0:
                // impossible
                break;
            case E1:
                traveler.travel(p.getOp());
                break;
            case E2:
                if (p.st == Stmt.ST.ASSIGN) {
                    switch (p.getOp1().vt) {
                    case ARRAY:
                        traveler.travel(p.getOp1().getOp1());
                        traveler.travel(p.getOp1().getOp2());
                        traveler.travel(p.getOp2());
                        break;
                    case FIELD:
                        traveler.travel(p.getOp1().getOp());
                        traveler.travel(p.getOp2());
                        break;
                    case STATIC_FIELD:
                    case LOCAL:
                        traveler.travel(p.getOp2());
                        break;
                    default:
                        // impossible
                    }
                } else if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (isNull(p.getOp1())) {
                        throw NPE;
                    } else {
                        traveler.travel(p.getOp1());
                    }
                }
                break;
            case En:
            }
        } catch (MustThrowException e) {
            if (e == NPE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], "Ljava/lang/NullPointerException;")));
            } else if (e == DIVE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[]{Exprs.nString("divide by zero")}, new String[]{"Ljava/lang/String;"}, "Ljava/lang/ArithmeticException;")));
            } else if (e == NEGATIVE_ARRAY_SIZE) {
                m.stmts.insertBefore(p,
                        Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], "Ljava/lang/NegativeArraySizeException;")));
            }
        }
    }

    static boolean isNull(Value v) {
        if (v.vt == Value.VT.CONSTANT) {
            Constant cst = (Constant) v;
            if (Constant.Null.equals(cst.value)) {
                return true;
            } else if (cst.value instanceof Number) {
                return ((Number) cst.value).intValue() == 0;
            }
        }
        return false;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/RemoveConstantFromSSA.java`:

```java
package com.googlecode.dex2jar.ir.ts;

import java.util.*;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Constant;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;

/**
 * 1. Remove constant AssignStmt.
 * 
 * <pre>
 * a = &quot;123&quot;;
 * return a;
 * </pre>
 * 
 * to
 * 
 * <pre>
 * return &quot;123&quot;;
 * </pre>
 * 
 * 2. Remove Phi if all value are equal
 * 
 * <pre>
 * a = &quot;123&quot;;
 * // ...
 * b = &quot;123&quot;;
 * // ...
 * c = PHI(a, b);
 * return c;
 * </pre>
 * 
 * to
 * 
 * <pre>
 * // ...
 * return &quot;123&quot;;
 * </pre>
 */
public class RemoveConstantFromSSA extends StatedTransformer {

    public static final Comparator<Local> LOCAL_COMPARATOR = Comparator.comparingInt(local -> local._ls_index);

    @Override
    public boolean transformReportChanged(IrMethod method) {
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        Map<Local, Object> cstMap = new HashMap<>();
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL) {
                    if (as.getOp2().vt == Value.VT.CONSTANT) {
                        assignStmtList.add(as);
                        cstMap.put((Local) as.getOp1(), ((Constant) as.getOp2()).value);
                    } else if (as.getOp2().vt == Value.VT.LOCAL) {
                        cstMap.put((Local) as.getOp1(), as.getOp2());
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        RemoveLocalFromSSA.fixReplace(cstMap);
        final Map<Local, Value> toReplace = new HashMap<>();
        Set<Value> usedInPhi = new HashSet<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            boolean loopAgain = true;
            while (loopAgain) {
                loopAgain = false;
                usedInPhi.clear();
                for (Iterator<LabelStmt> it = phiLabels.iterator(); it.hasNext();) {
                    LabelStmt labelStmt = it.next();
                    if (labelStmt.phis != null) {
                        for (Iterator<AssignStmt> it2 = labelStmt.phis.iterator(); it2.hasNext();) {
                            AssignStmt phi = it2.next();
                            Value[] vs = phi.getOp2().getOps();
                            Object sameCst = null;
                            boolean allEqual = true;
                            for (Value p : vs) {
                                Object cst = cstMap.get(p);
                                if (cst == null) {
                                    allEqual = false;
                                    break;
                                }
                                if (sameCst == null) {
                                    sameCst = cst;
                                } else if (!sameCst.equals(cst)) {
                                    allEqual = false;
                                    break;
                                }
                            }
                            if (allEqual) { // all are same constant
                                cstMap.put((Local) phi.getOp1(), sameCst);
                                if (sameCst instanceof Local) {
                                    phi.setOp2((Value) sameCst);
                                } else {
                                    phi.setOp2(Exprs.nConstant(sameCst));
                                    assignStmtList.add(phi);
                                }
                                it2.remove();
                                method.stmts.insertAfter(labelStmt, phi);
                                changed = true;
                                loopAgain = true; // loop again
                            } else {
                                usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                            }
                        }
                        if (labelStmt.phis.size() == 0) {
                            it.remove();
                        }
                    }
                }
            }
        }

        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext();) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                method.stmts.remove(as);
                method.locals.remove(as.getOp1());
                changed = true;
            }
            toReplace.put((Local) as.getOp1(), as.getOp2());

        }

        Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                return v;
            }

            @Override
            public Value onUse(Local v) {
                Value n = toReplace.get(v);
                return n == null ? v : n.clone();
            }
        }, false);
        return changed;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/RemoveLocalFromSSA.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import java.util.*;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.StmtList;

public class RemoveLocalFromSSA extends StatedTransformer {
    static <T extends Value> void replaceAssign(List<AssignStmt> assignStmtList, Map<Local, T> toReplace) {
        for (AssignStmt as : assignStmtList) {
            Value right = as.getOp2();
            T to = toReplace.get(right);
            if (to != null) {
                as.setOp2(to);
            }
        }
    }

    private boolean simpleAssign(List<LabelStmt> phiLabels, List<AssignStmt> assignStmtList,
                                 Map<Local, Local> toReplace, StmtList stmts) {
        Set<Value> usedInPhi = new HashSet<>();
        if (phiLabels != null) {
            for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    usedInPhi.addAll(Arrays.asList(phi.getOp2().getOps()));
                }
            }
        }
        boolean changed = false;
        for (Iterator<AssignStmt> it = assignStmtList.iterator(); it.hasNext(); ) {
            AssignStmt as = it.next();
            if (!usedInPhi.contains(as.getOp1())) {
                it.remove();
                stmts.remove(as);
                toReplace.put((Local) as.getOp1(), (Local) as.getOp2());
                changed = true;
            }
        }

        return changed;
    }

    private void replacePhi(List<LabelStmt> phiLabels, Map<Local, Local> toReplace, Set<Value> set) {
        if (phiLabels != null) {
            for (LabelStmt labelStmt : phiLabels) {
                for (AssignStmt phi : labelStmt.phis) {
                    Value[] ops = phi.getOp2().getOps();
                    for (Value op : ops) {
                        Value n = toReplace.get(op);
                        if (n != null) {
                            set.add(n);
                        } else {
                            set.add(op);
                        }
                    }
                    set.remove(phi.getOp1());
                    phi.getOp2().setOps(set.toArray(new Value[0]));
                    set.clear();
                }
            }
        }
    }

    static class PhiObject {
        Set<PhiObject> parent = new HashSet<>();
        Set<PhiObject> children = new HashSet<>();
        Local local;
        boolean isInitByPhi = false;
    }

    public static PhiObject getOrCreate(Map<Local, PhiObject> map, Local local) {
        PhiObject po = map.get(local);
        if (po == null) {
            po = new PhiObject();
            po.local = local;
            map.put(local, po);
        }
        return po;
    }

    public static void linkPhiObject(PhiObject parent, PhiObject child) {
        parent.children.add(child);
        child.parent.add(parent);
    }


    private boolean simplePhi(List<LabelStmt> phiLabels, Map<Local, Local> toReplace, Set<Value> set) {
        boolean changed = false;
        if (phiLabels != null) {
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                for (Iterator<AssignStmt> it = labelStmt.phis.iterator(); it.hasNext(); ) {
                    AssignStmt phi = it.next();
                    set.addAll(Arrays.asList(phi.getOp2().getOps()));
                    set.remove(phi.getOp1());
                    if (set.size() == 1) {
                        it.remove();
                        changed = true;
                        toReplace.put((Local) phi.getOp1(), (Local) set.iterator().next());
                    }
                    set.clear();
                }
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }

    private boolean removeLoopFromPhi(List<LabelStmt> phiLabels, Map<Local, Local> toReplace) {
        boolean changed = false;
        if (phiLabels != null) {
            Set<Local> toDeletePhiAssign = new HashSet<>();
            Map<Local, PhiObject> phis;
            // detect loop init in phi
            phis = collectPhiObjects(phiLabels);
            Queue<PhiObject> q = new UniqueQueue<>();
            q.addAll(phis.values());
            while (!q.isEmpty()) {
                PhiObject po = q.poll();
                for (PhiObject child : po.children) {
                    if (child.isInitByPhi) {
                        if (child.parent.addAll(po.parent)) {
                            q.add(child);
                        }
                    }
                }
            }
            for (PhiObject po : phis.values()) {
                if (po.isInitByPhi) {
                    Local local = null;
                    for (PhiObject p : po.parent) {
                        if (!p.isInitByPhi) {
                            if (local == null) { // the first non-phi value
                                local = p.local;
                            } else {
                                local = null;
                                break;
                            }
                        }
                    }
                    if (local != null) {
                        toReplace.put(po.local, local);
                        toDeletePhiAssign.add(po.local);
                        changed = true;
                    }
                }
            }
            for (Iterator<LabelStmt> itLabel = phiLabels.iterator(); itLabel.hasNext(); ) {
                LabelStmt labelStmt = itLabel.next();
                labelStmt.phis.removeIf(phi -> toDeletePhiAssign.contains(phi.getOp1()));
                if (labelStmt.phis.size() == 0) {
                    labelStmt.phis = null;
                    itLabel.remove();
                }
            }
        }
        return changed;
    }

    private Map<Local, PhiObject> collectPhiObjects(List<LabelStmt> phiLabels) {
        Map<Local, PhiObject> phis;
        phis = new HashMap<>();
        for (LabelStmt labelStmt : phiLabels) {
            for (AssignStmt as : labelStmt.phis) {
                Local local = (Local) as.getOp1();
                PhiObject child = getOrCreate(phis, local);
                child.isInitByPhi = true;
                for (Value op : as.getOp2().getOps()) {
                    if (op == local) {
                        continue;
                    }
                    PhiObject parent = getOrCreate(phis, (Local) op);
                    linkPhiObject(parent, child);
                }
            }
        }
        return phis;
    }

    static <T> void fixReplace(Map<Local, T> toReplace) {
        List<Map.Entry<Local, T>> set = new ArrayList<>(toReplace.entrySet());
        set.sort(Comparator.comparingInt(localTEntry -> localTEntry.getKey()._ls_index));

        boolean changed = true;
        while (changed) {
            changed = false;
            for (Map.Entry<Local, T> e : set) {
                T b = e.getValue();
                if(b instanceof  Local) {
                    T n = toReplace.get(b);
                    if (n != null && b != n) {
                        changed = true;
                        e.setValue(n);
                    }
                }
            }
        }
    }

    @Override
    public boolean transformReportChanged(IrMethod method) {
        boolean irChanged = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();
        List<LabelStmt> phiLabels = method.phiLabels;
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.LOCAL) {
                    assignStmtList.add(as);
                }
            }
        }
        final Map<Local, Local> toReplace = new HashMap<>();
        Set<Value> set = new HashSet<>();
        boolean changed = true;
        while (changed) {
            changed = false;

            if (removeLoopFromPhi(phiLabels, toReplace)) {
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }

            while (simplePhi(phiLabels, toReplace, set)) {// remove a = phi(b)
                fixReplace(toReplace);
                replacePhi(phiLabels, toReplace, set);
            }
            while (simpleAssign(phiLabels, assignStmtList, toReplace, method.stmts)) {// remove a=b
                fixReplace(toReplace);
                replaceAssign(assignStmtList, toReplace);
                changed = true;
                irChanged = true;
            }
            replacePhi(phiLabels, toReplace, set);
        }

        for (Local local : toReplace.keySet()) {
            method.locals.remove(local);
            irChanged = true;
        }
        if (toReplace.size() > 0) {
            Cfg.travelMod(method.stmts, new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    Local n = toReplace.get(v);
                    return n == null ? v : n;
                }
            }, true);
        }
        return irChanged;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/SSATransformer.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.*;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import com.googlecode.dex2jar.ir.ts.Cfg.TravelCallBack;
import com.googlecode.dex2jar.ir.ts.an.AnalyzeValue;
import com.googlecode.dex2jar.ir.ts.an.BaseAnalyze;

import java.util.*;

/**
 * Transform Stmt to SSA form and count local read
 *
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class SSATransformer implements Transformer {

    private void cleanTagsAndReIndex(IrMethod method) {
        int i = 0;
        for (Local local : method.locals) {
            local.tag = null;
            local._ls_index = i++;
        }
    }

    private void deleteDeadCode(IrMethod method) {
        for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext(); ) {
            Stmt stmt = it.next();
            if (!stmt.visited && stmt.st != ST.LABEL) {
                it.remove();
            }
        }
    }

    private void replaceLocalsWithSSA(final IrMethod method) {
        final List<Local> locals = method.locals;
        locals.clear();
        StmtList stmts = method.stmts;

        TravelCallBack tcb = new TravelCallBack() {

            @Override
            public Value onAssign(Local a, AssignStmt as) {
                if (a._ls_index < 0) {
                    locals.add(a);
                    return a;
                }
                SSAValue lsv = (SSAValue) a.tag;
                Local b = lsv.local;
                locals.add(b);
                return b;
            }

            @Override
            public Value onUse(Local a) {
                if (a._ls_index < 0) {
                    return a;
                }
                SSAValue lsv = (SSAValue) a.tag;
                Local b = lsv.local;
                return b;
            }

        };
        Set<Value> froms = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        // 2. we are looking for Phis and insert Phi node to the code
        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                List<AssignStmt> phis = null;
                SSAValue[] frame = (SSAValue[]) p.frame;
                if (frame != null) {
                    for (SSAValue v : frame) {
                        if (v == null || !v.used) {
                            continue;
                        }
                        if (v.parent != null) {
                            froms.add(v.parent.local);
                        }
                        if (v.otherParents != null) {
                            for (SSAValue parent : v.otherParents) {
                                froms.add(parent.local);
                            }
                        }
                        froms.remove(v.local);
                        if (phis == null) {
                            phis = new ArrayList<>();
                        }
                        locals.add(v.local);
                        phis.add(Stmts.nAssign(v.local, Exprs.nPhi(froms.toArray(new Value[froms.size()]))));
                        froms.clear();
                    }
                }
                labelStmt.phis = phis;
                if (phis != null) {
                    phiLabels.add(labelStmt);
                }
            } else {
                Cfg.travelMod(p, tcb, true);
            }
            p.frame = null;
        }
        if (phiLabels.size() > 0) {
            method.phiLabels = phiLabels;
        }
    }

    @Override
    public void transform(final IrMethod method) {

        boolean needSSA = prepare(method);
        if (needSSA) {
            // 1. analyze and build value graph
            new SSAAnalyze(method).analyze();
            // 2. delete dead code
            deleteDeadCode(method);
            // 3. replace locals with SSA-locals
            replaceLocalsWithSSA(method);
        }

        // 4. clean tags on Local
        cleanTagsAndReIndex(method);
    }

    private boolean prepare(final IrMethod method) {
        int index = Cfg.reIndexLocal(method);

        final int readCounts[] = new int[index];
        final int writeCounts[] = new int[index];
        Cfg.travel(method.stmts, new TravelCallBack() {
            @Override
            public Value onAssign(Local v, AssignStmt as) {
                writeCounts[v._ls_index]++;
                return v;
            }

            @Override
            public Value onUse(Local v) {
                readCounts[v._ls_index]++;
                return v;
            }
        }, true);

        boolean needTravel = false;
        boolean needSSAAnalyze = false;
        index = 0;
        List<Local> oldLocals = method.locals;
        List<Local> locals = new ArrayList<>(oldLocals);
        oldLocals.clear();

        for (Local local : locals) {
            int idx = local._ls_index;
            int read = readCounts[idx];
            int write = writeCounts[idx];
            if (read > 0 && write == 0) {
                // TODO if we need throw exception ?
                // or the code is dead?
            }

            if (read == 0 && write == 0) {
                // ignore the local
            } else {
                if (write <= 1) {
                    // no phi require
                    local._ls_index = -1;
                    oldLocals.add(local);
                } else if (read == 0) {
                    local._ls_index = -2;
                    needTravel = true;
                    // we are going to duplicate each usage of the local and add to method.locals,
                    // so not add the original local to method.locals
                } else {
                    needSSAAnalyze = true;
                    local._ls_index = index++;
                    oldLocals.add(local);
                }
            }
        }
        if (needSSAAnalyze || needTravel) {
            Cfg.travelMod(method.stmts, new TravelCallBack() {

                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    if (v._ls_index == -1) {
                        return v;
                    } else if (v._ls_index == -2) {
                        Local n = (Local) v.clone();
                        method.locals.add(n);
                        return n;
                    }
                    // others
                    return v.clone();
                }

                @Override
                public Value onUse(Local v) {
                    if (v._ls_index == -1) {
                        return v;
                    }
                    return v.clone();
                }
            }, true);
        }
        return needSSAAnalyze;
    }

    static class SSAAnalyze extends BaseAnalyze<SSAValue> {
        public int nextIndex;

        public SSAAnalyze(IrMethod method) {
            super(method, false);
        }

        @Override
        protected void afterExec(SSAValue[] frame, Stmt stmt) {
            if (!DEBUG) {
                // remove frame to save memory
                if (stmt._cfg_froms.size() < 2) {
                    // we only care stmt only has one or less parent,
                    // the parent must be visited already.
                    // if more than 1 parent, the other may not been visited at
                    // the moment
                    setFrame(stmt, null);
                }
            }
        }

        @Override
        public Local onUse(Local local) {
            if (local._ls_index < 0) {
                return local;
            }
            return super.onUse(local);
        }

        @Override
        public Local onAssign(Local local, AssignStmt as) {
            if (local._ls_index < 0) {
                return local;
            }
            return super.onAssign(local, as);
        }

        @Override
        protected void analyzeValue() {
            Set<SSAValue> set = markUsed();
            aValues.clear();
            aValues = null;
            if (DEBUG) {
                clearLsEmptyValueFromFrame();
            }
            for (SSAValue v0 : set) {
                SSAValue v = v0;
                if (v.used && v.local == null) {
                    v.local = new Local(nextIndex++);
                }
            }
        }

        protected void clearLsEmptyValueFromFrame() {
            for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                SSAValue[] frame = (SSAValue[]) p.frame;
                if (frame != null) {
                    for (int i = 0; i < frame.length; i++) {
                        SSAValue r = frame[i];
                        if (r != null && !r.used) {
                            frame[i] = null;
                        }
                    }
                }
            }
        }

        @Override
        protected void init() {
            super.init();
            nextIndex = method.locals.size();
        }

        @Override
        protected void initCFG() {
            Cfg.createCFG(this.method);
        }

        protected Set<SSAValue> markUsed() {
            Set<SSAValue> used = new HashSet<SSAValue>(aValues.size() / 2);
            Queue<SSAValue> q = new UniqueQueue<>();
            q.addAll(aValues);
            while (!q.isEmpty()) {
                SSAValue v = q.poll();
                if (v.used) {
                    used.add(v);
                    {
                        SSAValue p = v.parent;
                        if (p != null) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }
                    if (v.otherParents != null) {
                        for (SSAValue p : v.otherParents) {
                            if (!p.used) {
                                p.used = true;
                                q.add(p);
                            }
                        }
                    }

                }
            }
            return used;
        }

        @Override
        public SSAValue[] merge(SSAValue[] frame, SSAValue[] distFrame, Stmt src, Stmt dist) {
            if (distFrame != null) {
                relationMerge(frame, dist, distFrame);
            } else {
                if (dist._cfg_froms.size() > 1) {// detail mode
                    distFrame = newFrame();
                    relationMerge(frame, dist, distFrame);
                } else if (needCopyFrame(src)) {
                    distFrame = newFrame();
                    System.arraycopy(frame, 0, distFrame, 0, distFrame.length);
                } else {
                    distFrame = frame;
                }
            }
            return distFrame;
        }

        private static boolean needCopyFrame(Stmt src) {
            int c = 0;
            if (src.exceptionHandlers != null) {
                c += src.exceptionHandlers.size();
                if (c > 1) {
                    return true;
                }
            }
            if (src.st.canContinue()) {
                c += 1;
                if (c > 1) {
                    return true;
                }
            }
            if (src.st.canBranch()) {
                c += 1;
                if (c > 1) {
                    return true;
                }
            }
            if (src.st.canSwitch()) {
                c += 1;
                BaseSwitchStmt bss = (BaseSwitchStmt) src;
                c += bss.targets.length;
            }
            return c > 1;
        }

        @Override
        protected SSAValue[] newFrame(int size) {
            return new SSAValue[size];
        }

        @Override
        protected SSAValue newValue() {
            return new SSAValue();
        }

        @Override
        protected SSAValue onAssignLocal(Local local, Value value) {
            SSAValue aValue = newValue();
            aValue.local = local;
            local.tag = aValue;
            return aValue;
        }

        @Override
        protected void onUseLocal(SSAValue aValue, Local local) {
            local.tag = aValue;
            aValue.used = true;
        }

        protected void relationMerge(SSAValue[] frame, Stmt dist, SSAValue[] distFrame) {
            for (int i = 0; i < localSize; i++) {
                SSAValue srcValue = (SSAValue) frame[i];
                if (srcValue != null) {
                    SSAValue distValue = (SSAValue) distFrame[i];
                    if (distValue == null) {
                        if (!dist.visited) {
                            distValue = newValue();
                            aValues.add(distValue);
                            distFrame[i] = distValue;
                            linkParentChildren(srcValue, distValue);
                        }
                    } else {
                        linkParentChildren(srcValue, distValue);
                    }
                }
            }
        }

        private void linkParentChildren(SSAValue p, SSAValue c) {
            if (c.parent == null) {
                c.parent = p;
            } else if (c.parent == p) {
                return;
            } else {
                Set<SSAValue> ps = c.otherParents;
                if (ps == null) {
                    c.otherParents = ps = new HashSet<>(3);
                }
                ps.add(p);
            }
        }
    }

    private static class SSAValue implements AnalyzeValue {
        public Local local;
        public Set<SSAValue> otherParents;
        public boolean used = false;
        public SSAValue parent;

        @Override
        public char toRsp() {
            return used ? 'x' : '.';
        }

        @Override
        public String toString() {
            if (local != null) {
                return local.toString();
            } else {
                return "N";
            }
        }
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/StatedTransformer.java`:

```java
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;

public abstract class StatedTransformer implements Transformer {
    public abstract boolean transformReportChanged(IrMethod method);

    @Override
    public void transform(IrMethod method) {
        transformReportChanged(method);
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/Transformer.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;

/**
 * TODO DOC
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public interface Transformer {

    void transform(IrMethod method);
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/TypeTransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.d2j.DexType;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.TypeClass;
import com.googlecode.dex2jar.ir.expr.*;
import com.googlecode.dex2jar.ir.expr.Value.*;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.E1Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.E2Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;

import java.util.*;

/**
 * Type and correct Exprs
 *
 * @author Bob Pan
 */
public class TypeTransformer implements Transformer {

    private static final String[] possibleIntTypes = new String[]{"B", "S", "C", "I"};

    @Override
    public void transform(IrMethod irMethod) {
        TypeAnalyze ta = new TypeAnalyze(irMethod);
        List<TypeRef> refs = ta.analyze();

        for (TypeRef ref : refs) {
            String type = ref.getType();

            if (type == null) {
                System.err.println(ref);
                continue;
            }

            if (ref.value.vt == VT.CONSTANT) {
                Constant cst = (Constant) ref.value;
                switch (type.charAt(0)) {
                    case '[':
                    case 'L':
                        if (Integer.valueOf(0).equals(cst.value)) {
                            cst.value = Constant.Null;
                        }
                        if (type.equals("[F") && cst.value instanceof int[]) {
                            int[] x = (int[]) cst.value;
                            float[] f = new float[x.length];
                            for (int i = 0; i < x.length; i++) {
                                f[i] = Float.intBitsToFloat(x[i]);
                            }
                            cst.value = f;
                        }
                        if (type.equals("[D") && cst.value instanceof long[]) {
                            long[] x = (long[]) cst.value;
                            double[] f = new double[x.length];
                            for (int i = 0; i < x.length; i++) {
                                f[i] = Double.longBitsToDouble(x[i]);
                            }
                            cst.value = f;
                        }
                        break;
                    case 'F':
                        if (!(cst.value instanceof Float)) {
                            cst.value = Float.intBitsToFloat(((Number) cst.value).intValue());
                        }
                        break;
                    case 'D':
                        if (!(cst.value instanceof Double)) {
                            cst.value = Double.longBitsToDouble(((Number) cst.value).longValue());
                        }
                        break;
                    default:
                }
            }
            Value value = ref.value;
            value.valueType = type;
            value.tag = null;
            ref.clear();
        }
    }

    enum Relation {

        R_sameValues {
            @Override
            Set<TypeRef> get(TypeRef obj) {
                return obj.sameValues;
            }

            @Override
            void set(TypeRef obj, Set<TypeRef> v) {
                obj.sameValues = v;
            }
        }, R_gArrayValues {
            @Override
            Set<TypeRef> get(TypeRef obj) {
                return obj.gArrayValues;
            }

            @Override
            void set(TypeRef obj, Set<TypeRef> v) {
                obj.gArrayValues = v;
            }
        }, R_sArrayValues {
            @Override
            Set<TypeRef> get(TypeRef obj) {
                return obj.sArrayValues;
            }

            @Override
            void set(TypeRef obj, Set<TypeRef> v) {
                obj.sArrayValues = v;
            }
        }, R_arrayRoots {
            @Override
            Set<TypeRef> get(TypeRef obj) {
                return obj.arrayRoots;
            }

            @Override
            void set(TypeRef obj, Set<TypeRef> v) {
                obj.arrayRoots = v;
            }
        }, R_parents {
            @Override
            Set<TypeRef> get(TypeRef obj) {
                return obj.parents;
            }

            @Override
            void set(TypeRef obj, Set<TypeRef> v) {
                obj.parents = v;
            }
        }, R_children {
            @Override
            Set<TypeRef> get(TypeRef obj) {
                return obj.children;
            }

            @Override
            void set(TypeRef obj, Set<TypeRef> v) {
                obj.children = v;
            }
        };

        abstract Set<TypeRef> get(TypeRef obj);

        abstract void set(TypeRef obj, Set<TypeRef> v);
    }

    public static class TypeRef {

        public final Value value;
        /**
         * same use, have same
         */
        public Set<TypeRef> sameValues = null;
        /**
         * reference to values
         */
        public Set<TypeRef> gArrayValues = null;
        public Set<TypeRef> sArrayValues = null;
        /**
         * reference to root
         */
        public Set<TypeRef> arrayRoots = null;

        public Set<TypeRef> parents = null;
        public Set<TypeRef> children = null;

        public TypeClass clz = TypeClass.UNKNOWN;
        public String provideDesc = null;
        public Set<String> uses;

        private TypeRef next;

        public void merge(TypeRef other) {
            assert this.next == null;
            TypeRef a = this;
            TypeRef b = other.getReal();
            if (a == b) {
                return;
            }

            b.next = a;

            relationMerge(a, b, Relation.R_sameValues);
            relationMerge(a, b, Relation.R_gArrayValues);
            relationMerge(a, b, Relation.R_sArrayValues);
            relationMerge(a, b, Relation.R_arrayRoots);
            relationMerge(a, b, Relation.R_parents);
            relationMerge(a, b, Relation.R_children);

            if (a.provideDesc == null) {
                a.provideDesc = b.provideDesc;
            } else if (b.provideDesc != null) {
                a.provideDesc = TypeAnalyze.mergeProviderType(a.provideDesc, b.provideDesc);
            }
            b.provideDesc = null;
            if (b.uses != null) {
                if (a.uses == null) {
                    a.uses = b.uses;
                } else {
                    a.uses.addAll(b.uses);
                }
                b.uses = null;
            }

        }

        private static void relationMerge(TypeRef a, TypeRef b, Relation r) {
            Set<TypeRef> bv = r.get(b);
            if (bv != null) {
                Set<TypeRef> av = r.get(a);
                Set<TypeRef> merged;
                if (av == null) {
                    merged = bv;
                    r.set(a, merged);
                } else {
                    merged = av;
                    merged.addAll(bv);
                }
                merged.remove(a);
                merged.remove(b);
                r.set(b, null);
            }
        }

        private TypeRef getReal() {
            TypeRef x = this;
            while (x.next != null) {
                x = x.next;
            }
            if (x != this) {
                this.next = x;
            }
            return x;
        }

        public TypeRef(Value value) {
            super();
            this.value = value;
        }

        @Override
        public String toString() {
            TypeRef real = getReal();
            String p = real.uses == null ? "[]" : real.uses.toString();
            return real.clz + "::" + value + ": " + real.provideDesc + " > {" + p.substring(1, p.length() - 1) + "}";
        }

        public String getType() {
            TypeRef thiz = getReal();
            TypeClass clz = thiz.clz;
            if (clz == TypeClass.OBJECT) {
                if (thiz.provideDesc.length() == 1) {
                    return "Ljava/lang/Object;";
                } else {
                    return thiz.provideDesc;
                }
            }
            if (clz.fixed && clz != TypeClass.INT) {
                if (thiz.provideDesc == null) {
                    throw new RuntimeException();
                }
                return thiz.provideDesc;
            }
            if (clz == TypeClass.JD) { // prefer Long if wide
                return "J";
            }
            if (thiz.uses != null) {
                for (String t : possibleIntTypes) {
                    if (thiz.uses.contains(t)) {
                        return t;
                    }
                }
            }

            switch (clz) {
                case ZI:
            case INT:
            case IF:
                return "I";
            case ZIFL:
            case ZIF:
            case ZIL:
                return "Z";
            default:
            }
            throw new RuntimeException();
        }

        public boolean updateTypeClass(TypeClass clz) {
            assert this.next == null;
            TypeClass thizClz = this.clz;
            TypeClass merged = TypeClass.merge(thizClz, clz);
            if (merged == thizClz) {
                return false;
            }
            this.clz = merged;
            return true;
        }

        public void clear() {
            this.sArrayValues = null;
            this.gArrayValues = null;
            this.arrayRoots = null;
            this.parents = null;
            this.children = null;
            this.sameValues = null;
        }

        String getProvideDesc() {
            return getReal().provideDesc;
        }

        public boolean addUses(String ele) {
            assert this.next == null;
            if (this.uses == null) {
                this.uses = new HashSet<>();
            }
            return this.uses.add(ele);
        }

        public boolean addAllUses(Set<String> uses) {
            assert this.next == null;
            if (this.uses == null) {
                this.uses = new HashSet<>();
            }
            return this.uses.addAll(uses);
        }
    }

    private static class TypeAnalyze {
        protected IrMethod method;
        private final List<TypeRef> refs = new ArrayList<>();

        public TypeAnalyze(IrMethod method) {
            super();
            this.method = method;
        }

        public List<TypeRef> analyze() {
            sxStmt();
            fixTypes();
            return refs;
        }

        private void fixTypes() {
            // 1. collect all Array Roots
            Set<TypeRef> arrayRoots = new HashSet<>();
            for (TypeRef ref : refs) {
                ref = ref.getReal();
                if (ref.gArrayValues != null || ref.sArrayValues != null) {
                    arrayRoots.add(ref);
                }
                mergeArrayRelation(ref, Relation.R_gArrayValues);
                mergeArrayRelation(ref, Relation.R_sArrayValues);
                mergeArrayRelation(ref, Relation.R_arrayRoots);
            }

            UniqueQueue<TypeRef> q = new UniqueQueue<>();
            q.addAll(refs);
            while (!q.isEmpty()) {
                // 2. merge provided type to children. merge uses to parent. merge TypeClass to sameValues
                while (!q.isEmpty()) {
                    TypeRef ref = q.poll();
                    copyTypes(q, ref);
                }
                // 3. merge type from Array Roots to Array Values
                for (TypeRef ref : arrayRoots) {
                    ref = ref.getReal();
                    String provideDesc = ref.provideDesc;
                    if (provideDesc != null && provideDesc.charAt(0) == '[') {
                        String ele = provideDesc.substring(1);

                        TypeClass clz = TypeClass.clzOf(ele);
                        if (ref.gArrayValues != null) {
                            for (TypeRef p : ref.gArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                mergeTypeToArrayGetValue(ele, p, q);
                            }
                        }
                        if (ref.sArrayValues != null) {
                            for (TypeRef p : ref.sArrayValues) {
                                p = p.getReal();
                                if (p.updateTypeClass(clz)) {
                                    q.add(p);
                                }
                                if (p.addUses(ele)) {
                                    q.add(p);
                                }
                            }
                        }
                    }
                }
            }
        }

        private void mergeArrayRelation(TypeRef ref, Relation r) {
            Set<TypeRef> v = r.get(ref);
            if (v != null && v.size() > 1) {
                List<TypeRef> copy = new ArrayList<>(v);
                TypeRef mergeTo = copy.get(0).getReal();
                for (int i = 1; i < copy.size(); i++) {
                    mergeTo.merge(copy.get(i));
                }
            }
        }

        private static void mergeTypeToArrayGetValue(String type, TypeRef target, UniqueQueue<TypeRef> q) {
            target = target.getReal();
            if (target.provideDesc == null) {
                target.provideDesc = type;
                q.add(target);
            } else {
                String mergedType = mergeTypeEx(type, target.provideDesc);
                if (!mergedType.equals(target.provideDesc)) {
                    target.provideDesc = mergedType;
                    q.add(target);
                }
            }
        }

        private static void mergeTypeToSubRef(String type, TypeRef target, UniqueQueue<TypeRef> q) {
            if (target.provideDesc == null) {
                target.provideDesc = type;
                q.add(target);
            } else {
                String mergedType = mergeProviderType(type, target.provideDesc);
                if (!mergedType.equals(target.provideDesc)) {
                    target.provideDesc = mergedType;
                    q.add(target);
                }
            }
        }

        /**
         * [[B + [[D -> [L
         * [B + L -> [B
         * [[B + [B -> [[B
         *
         * @param a
         * @param b
         * @return
         */
        private static String mergeTypeEx(String a, String b) {
            if (a.equals(b)) {
                return a;
            }
            int as = countArrayDim(a);
            int bs = countArrayDim(b);
            if (as > bs) {
                return a;
            } else if (bs > as) {
                return b;
            } else { // as==bs;
                String elementTypeA = a.substring(as);
                String elementTypeB = b.substring(bs);
                TypeClass ta = TypeClass.clzOf(elementTypeA);
                TypeClass tb = TypeClass.clzOf(elementTypeB);
                if (ta.fixed && !tb.fixed) {
                    return a;
                } else if (!ta.fixed && tb.fixed) {
                    return b;
                } else if (ta.fixed) {
                    if (ta != tb) {
                        if (as == 0) {
                            throw new RuntimeException();
                        }
                        return buildArray(as - 1, "L");
                    }
                    if (ta == TypeClass.INT) {
                        String chooseType = "I";
                        for (int i = possibleIntTypes.length - 1; i >= 0; i--) {
                            String t = possibleIntTypes[i];
                            if (a.equals(t) || b.equals(t)) {
                                chooseType = t;
                                break;
                            }
                        }
                        return buildArray(as, chooseType);
                    } else {
                        return buildArray(as, "L");
                    }
                } else { // !ta.fixed && !tb.fixed
                    return buildArray(as, TypeClass.merge(ta, tb).name);
                }
            }
        }

        private void copyTypes(UniqueQueue<TypeRef> q, TypeRef ref) {
            ref = ref.getReal();
            TypeClass clz = ref.clz;

            switch (clz) {
                case BOOLEAN:
                case FLOAT:
                case LONG:
                case DOUBLE:
                case VOID:
                    ref.provideDesc = clz.name;
                    break;
                default:
            }
            String provideDesc = ref.provideDesc;
            if (provideDesc == null && ref.parents != null && ref.parents.size() > 1) {
                if (isAllParentSetted(ref)) {
                    ref.provideDesc = provideDesc = mergeParentType(ref.parents);
                }
            }
            if (ref.parents != null) {
                for (TypeRef p : ref.parents) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }
                    if (ref.uses != null) {
                        if (p.addAllUses(ref.uses)) {
                            q.add(p);
                        }
                    }
                }
            }
            if (ref.children != null) {
                for (TypeRef p : ref.children) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }

                    if (provideDesc != null) {
                        mergeTypeToSubRef(provideDesc, p, q);
                    }
                }
            }
            if (ref.sameValues != null) {
                for (TypeRef p : ref.sameValues) {
                    p = p.getReal();
                    if (p.updateTypeClass(clz)) {
                        q.add(p);
                    }
                }
            }
        }

        private boolean isAllParentSetted(TypeRef ref) {
            boolean allAreSet = true;
            for (TypeRef p : ref.parents) {
                if (p.getProvideDesc() == null) {
                    allAreSet = false;
                    break;
                }
            }
            return allAreSet;
        }

        private static String mergeObjectType(String a, String b) {
            if (a.equals(b)) {
                return a;
            }
            if ("L".endsWith(a)) {
                return b;
            } else if ("L".equals(b)) {
                return a;
            }
            if (a.compareTo(b) > 0) {
                return a;
            } else {
                return b;
            }
        }

        private static String mergeProviderType(String a, String b) {
            if (a.equals(b)) {
                return a;
            }
            TypeClass ta = TypeClass.clzOf(a);
            TypeClass tb = TypeClass.clzOf(b);
            if (ta.fixed && !tb.fixed) {
                return a;
            } else if (!ta.fixed && tb.fixed) {
                return b;
            } else if (ta.fixed) {
                // special allow merge of Z and I
                if ((ta == TypeClass.INT && tb == TypeClass.BOOLEAN) || (tb == TypeClass.INT && ta == TypeClass.BOOLEAN)) {
                    return "I";
                }
                if (ta != tb) {
                    throw new RuntimeException();
                }
                if (ta == TypeClass.INT) {
                    for (int i = possibleIntTypes.length - 1; i >= 0; i--) {
                        String t = possibleIntTypes[i];
                        if (a.equals(t) || b.equals(t)) {
                            return t;
                        }
                    }
                    return "I";
                } else if (ta == TypeClass.OBJECT) {
                    // [[B + [[C = [Ljava/langObject;
                    int as = countArrayDim(a);
                    int bs = countArrayDim(b);
                    if (as == 0 || bs == 0) {
                        return mergeObjectType(a, b);
                    } else {
                        String elementTypeA = a.substring(as);
                        String elementTypeB = b.substring(bs);
                        if (as < bs) {
                            return buildArray(elementTypeB.charAt(0) == 'L' ? bs : bs - 1, "L");
                        } else if (as > bs) {
                            return buildArray(elementTypeA.charAt(0) == 'L' ? as : as - 1, "L");
                        } else { // as==bs
                            if (elementTypeA.charAt(0) != 'L' || elementTypeB.charAt(0) != 'L') {
                                return buildArray(as - 1, "L");
                            } else {
                                return buildArray(as, "L");
                            }
                        }
                    }
                } else {
                    throw new RuntimeException();
                }
            } else { // !ta.fixed && !tb.fixed
                return TypeClass.merge(ta, tb).name;
            }
        }

        private static String buildArray(int dim, String s) {
            if (dim == 0) {
                return s;
            }
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < dim; i++) {
                sb.append('[');
            }
            sb.append(s);
            return sb.toString();
        }

        private static int countArrayDim(String a) {
            int i = 0;
            while (a.charAt(i) == '[') {
                i++;
            }
            return i;
        }

        private String mergeParentType(Set<TypeRef> parents) {
            Iterator<TypeRef> it = parents.iterator();
            String a = it.next().getProvideDesc();
            while (it.hasNext()) {
                a = mergeProviderType(a, it.next().getProvideDesc());
            }
            return a;
        }

        private void e0expr(E0Expr op, boolean getValue) {
            switch (op.vt) {
                case LOCAL:
                    break;
                case NEW:
                    NewExpr newExpr = (NewExpr) op;
                    provideAs(newExpr, newExpr.type);
                    break;
                case THIS_REF:
                case PARAMETER_REF:
                case EXCEPTION_REF:
                    RefExpr refExpr = (RefExpr) op;
                    String refType = refExpr.type;
                    if (refType == null && op.vt == VT.EXCEPTION_REF) {
                        refType = "Ljava/lang/Throwable;";
                    }
                    provideAs(refExpr, refType);
                    break;
                case STATIC_FIELD:
                    StaticFieldExpr fe = (StaticFieldExpr) op;
                    if (getValue) {// getfield
                        provideAs(fe, fe.type);
                    } else {// putfield
                        useAs(fe, fe.type);
                    }
                    break;
                case CONSTANT:
                    Constant cst = (Constant) op;
                    Object value = cst.value;
                    if (value instanceof String) {
                        provideAs(cst, "Ljava/lang/String;");
                    } else if (value instanceof DexType) {
                        provideAs(cst, "Ljava/lang/Class;");
                    } else if (value instanceof Number) {
                        if (value instanceof Integer || value instanceof Byte || value instanceof Short) {
                            int a = ((Number) value).intValue();
                            if (a == 0) {
                                provideAs(cst, TypeClass.ZIFL.name); // zero, false or, float
                            } else if (a == 1) {
                                provideAs(cst, TypeClass.ZIF.name);
                            } else {
                                provideAs(cst, TypeClass.IF.name);
                            }
                        } else if (value instanceof Long) {
                            provideAs(cst, "w");
                        } else if (value instanceof Float) {
                            provideAs(cst, "F");
                        } else if (value instanceof Double) {
                            provideAs(cst, "D");
                        }
                    } else if (value instanceof Character) {
                        provideAs(cst, "C");
                    } else {
                        provideAs(cst, "L");
                    }
                    break;
                default:
            }
        }

        private void e1expr(E1Expr e1, boolean getValue) {
            Value v = e1.op;
            switch (e1.vt) {
                case CAST:
                    CastExpr ce = (CastExpr) e1;
                    if (ce.to.equals("B")) { // special case for I2B
                        useAs(v, TypeClass.ZI.name);
                        provideAs(e1, TypeClass.ZI.name);
                    } else {
                        useAs(v, ce.from);
                        provideAs(e1, ce.to);
                    }
                    break;
                case FIELD:
                    FieldExpr fe = (FieldExpr) e1;
                    if (getValue) {// getfield
                        provideAs(fe, fe.type);
                    } else {// putfield
                        useAs(fe, fe.type);
                    }
                    if (v != null) {
                        useAs(v, fe.owner);
                    }
                    break;

                case CHECK_CAST: {
                    TypeExpr te = (TypeExpr) e1;
                    provideAs(te, te.type);
                    useAs(v, "L");
                }
                break;
                case INSTANCE_OF: {
                    TypeExpr te = (TypeExpr) e1;
                    provideAs(te, "Z");
                    useAs(v, "L");
                }
                break;
                case NEW_ARRAY: {
                    TypeExpr te = (TypeExpr) e1;
                    provideAs(te, "[" + te.type);
                    useAs(v, "I");
                }
                break;
                case LENGTH: {
                    UnopExpr ue = (UnopExpr) e1;
                    provideAs(ue, "I");
                    useAs(v, "[?");
                }
                break;
                case NEG:
                case NOT: {
                    UnopExpr ue = (UnopExpr) e1;
                    provideAs(ue, ue.type);
                    useAs(v, ue.type);
                }
                break;
                default:
            }
            if (v != null) {
                exExpr(v);
            }
        }

        private void e2expr(E2Expr e2, boolean getValue) {
            Value a = e2.op1.trim();
            Value b = e2.op2.trim();
            switch (e2.vt) {
                case ARRAY:
                    useAs(b, "I");
                    String elementType = ((ArrayExpr) e2).elementType;
                    // TypeClass ts = TypeClass.clzOf(elementType);
                    useAs(a, "[" + elementType);
                    if (getValue) {
                        provideAs(e2, elementType);

                        linkGetArray(a, e2);
                    } else {
                        useAs(e2, elementType);

                        linkSetArray(a, e2);
                    }
                    break;
                case LCMP:
                case FCMPG:
                case FCMPL:
                case DCMPG:
                case DCMPL: {
                    BinopExpr be = (BinopExpr) e2;
                    useAs(a, be.type);
                    useAs(b, be.type);
                    provideAs(e2, "I");
                }
                break;
                case EQ:
                case NE: {
                    useAs(e2.getOp2(), TypeClass.ZIL.name);
                    useAs(e2.getOp1(), TypeClass.ZIL.name);
                    linkSameAs(e2.getOp1(), e2.getOp2());
                    provideAs(e2, "Z");
                }
                break;
                case GE:
                case GT:
                case LE:
                case LT: {
                    BinopExpr be = (BinopExpr) e2;
                    useAs(a, be.type);
                    useAs(b, be.type);
                    provideAs(e2, "Z");
                }
                break;
                case ADD:
                case SUB:
                case IDIV:
                case LDIV:
                case FDIV:
                case DDIV:
                case MUL:
                case REM: {
                    BinopExpr be = (BinopExpr) e2;
                    useAs(a, be.type);
                    useAs(b, be.type);
                    provideAs(e2, be.type);
                }
                break;
                case OR:
                case AND:
                case XOR: {
                    BinopExpr be = (BinopExpr) e2;
                    useAs(a, be.type);
                    useAs(b, be.type);
                    // linkSameAs(a, b);
                    if ("J".equals(be.type) || "w".equals(be.type)) {
                        provideAs(e2, be.type);
                    } else {
                        provideAs(e2, TypeClass.ZI.name);
                    }
                }
                break;
                case SHL:
                case SHR:
                case USHR: {
                    BinopExpr be = (BinopExpr) e2;
                    useAs(a, be.type);
                    useAs(b, "I");
                    provideAs(e2, be.type);
                }
                break;
                default:
                    throw new UnsupportedOperationException();
            }
            if (a != null) {
                exExpr(a);
            }
            if (b != null) {
                exExpr(b);
            }
        }

        private void linkSameAs(Value a, Value b) {
            TypeRef aa = getDefTypeRef(a);
            TypeRef bb = getDefTypeRef(b);
            if (aa.sameValues == null) {
                aa.sameValues = new HashSet<>(3);
            }
            if (bb.sameValues == null) {
                bb.sameValues = new HashSet<>(3);
            }
            aa.sameValues.add(bb);
            bb.sameValues.add(aa);
        }

        private void enexpr(EnExpr enExpr) {
            Value[] vbs = enExpr.ops;
            switch (enExpr.vt) {
                case INVOKE_NEW:
                case INVOKE_INTERFACE:
                case INVOKE_SPECIAL:
                case INVOKE_STATIC:
                case INVOKE_VIRTUAL:
                case INVOKE_POLYMORPHIC:
                case INVOKE_CUSTOM: {
                    AbstractInvokeExpr ice = (AbstractInvokeExpr) enExpr;
                    String type = ice.getProto().getReturnType();
                    provideAs(enExpr, type);
                    useAs(enExpr, type); // no one else will use it

                    String[] argTypes = ice.getProto().getParameterTypes();
                    if (argTypes.length == vbs.length) {
                        for (int i = 0; i < vbs.length; i++) {
                            useAs(vbs[i], argTypes[i]);
                        }
                    } else if (argTypes.length + 1 == vbs.length) {
                        useAs(vbs[0], "L");
                        for (int i = 1; i < vbs.length; i++) {
                            useAs(vbs[i], argTypes[i - 1]);
                        }
                    } else {
                        throw new RuntimeException();
                    }
                }
                break;

                case FILLED_ARRAY:
                    FilledArrayExpr fae = (FilledArrayExpr) enExpr;
                    for (Value vb : vbs) {
                        useAs(vb, fae.type);
                    }
                    provideAs(fae, "[" + fae.type);
                    break;
                case NEW_MUTI_ARRAY:
                    NewMutiArrayExpr nmae = (NewMutiArrayExpr) enExpr;
                    for (Value vb : vbs) {
                        useAs(vb, "I");
                    }
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < nmae.dimension; i++) {
                        sb.append('[');
                    }
                    sb.append(nmae.baseType);
                    provideAs(nmae, sb.toString());
                    break;
                case PHI:
                    for (Value vb : vbs) {
                        linkFromTo(vb, enExpr);
                    }
                    break;
                default:
            }
            for (Value vb : enExpr.ops) {
                exExpr(vb);
            }
        }

        private void exExpr(Value op) {
            exExpr(op, true);
        }

        private void exExpr(Value op, boolean getValue) {

            switch (op.et) {
                case E0:
                    e0expr((E0Expr) op, getValue);
                    break;
                case E1:
                    e1expr((E1Expr) op, getValue);
                    break;
                case E2:
                    e2expr((E2Expr) op, getValue);
                    break;
                case En:
                    enexpr((EnExpr) op);
                    break;
            }
        }

        private TypeRef getDefTypeRef(Value v) {
            Object object = v.tag;
            TypeRef typeRef;
            if (!(object instanceof TypeRef)) {
                typeRef = new TypeRef(v);
                refs.add(typeRef);
                v.tag = typeRef;
            } else {
                typeRef = (TypeRef) object;
            }
            return typeRef;
        }

        private void linkGetArray(Value array, Value v) {
            TypeRef root = getDefTypeRef(array);
            TypeRef value = getDefTypeRef(v);
            if (root.gArrayValues == null) {
                root.gArrayValues = new HashSet<>(3);
            }
            root.gArrayValues.add(value);
            if (value.arrayRoots == null) {
                value.arrayRoots = new HashSet<>(3);
            }
            value.arrayRoots.add(root);
        }

        private void linkSetArray(Value array, Value v) {
            TypeRef root = getDefTypeRef(array);
            TypeRef value = getDefTypeRef(v);
            if (root.sArrayValues == null) {
                root.sArrayValues = new HashSet<>(3);
            }
            root.sArrayValues.add(value);
            if (value.arrayRoots == null) {
                value.arrayRoots = new HashSet<>(3);
            }
            value.arrayRoots.add(root);
        }

        private void linkFromTo(Value from, Value to) {
            TypeRef tFrom = getDefTypeRef(from);
            TypeRef tTo = getDefTypeRef(to);
            if (tFrom.children == null) {
                tFrom.children = new HashSet<>();
            }
            tFrom.children.add(tTo);
            if (tTo.parents == null) {
                tTo.parents = new HashSet<>();
            }
            tTo.parents.add(tFrom);
        }

        private void provideAs(Value op, String type) {
            TypeRef typeRef = getDefTypeRef(op).getReal();
            typeRef.provideDesc = (type);
            typeRef.updateTypeClass(TypeClass.clzOf(type));
        }

        private void s1stmt(E1Stmt s) {
            if (s.st == ST.GOTO) {
                return;
            }
            Value op = s.op;
            switch (s.st) {
                case LOOKUP_SWITCH:
                case TABLE_SWITCH:
                    useAs(op, "I");
                    break;
                case IF:
                    useAs(op, "Z");
                    break;
                case LOCK:
                case UNLOCK:
                    useAs(op, "L");
                    break;
                case THROW:
                    useAs(op, "Ljava/lang/Throwable;");
                    break;
                case RETURN:
                    useAs(op, method.ret);
                    break;
                default:
            }
            exExpr(op);
        }

        private void s2stmt(E2Stmt s) {
            if (s.st == ST.FILL_ARRAY_DATA) {
                linkFromTo(s.op1, s.op2);
            } else {
                Value from = s.op2;
                Value to = s.op1;
                linkFromTo(from, to);
                exExpr(from);
                exExpr(to, false);
            }
        }

        private void sxStmt() {
            for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                switch (p.et) {
                    case E0:
                        // label, nop and return-void
                        if (p.st == ST.LABEL) {
                            LabelStmt labelStmt = (LabelStmt) p;
                            if (labelStmt.phis != null) {
                                for (AssignStmt phi : labelStmt.phis) {
                                    s2stmt(phi);
                                }
                            }
                        }
                        break;
                    case E1:
                        s1stmt((E1Stmt) p);
                        break;
                    case E2:
                        s2stmt((E2Stmt) p);
                        break;
                    case En:
                        // no stmt yet
                        // enstmt((EnStmt) p, refs, relationRefs);
                        break;
                }
            }
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            for (TypeRef ref : refs) {
                sb.append(ref).append("\n");
            }
            return sb.toString();
        }

        private void useAs(Value op, String type) {
            TypeRef typeRef = getDefTypeRef(op);
            typeRef.addUses(type);
            typeRef.updateTypeClass(TypeClass.clzOf(type));
        }
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/UnSSATransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.PhiExpr;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.JumpStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import com.googlecode.dex2jar.ir.stmt.StmtList;
import com.googlecode.dex2jar.ir.stmt.Stmts;
import com.googlecode.dex2jar.ir.ts.an.AnalyzeValue;
import com.googlecode.dex2jar.ir.ts.an.BaseAnalyze;

/**
 * Remove {@link PhiExpr}s, add a=x to each CFG from.
 * 
 * TODO clean frame
 * 
 * @author bob
 */
public class UnSSATransformer implements Transformer {

    private static final boolean DEBUG = false;

    protected static final Comparator<RegAssign> OrderRegAssignByExcludeSizeDesc = new Comparator<RegAssign>() {

        @Override
        public int compare(RegAssign o1, RegAssign o2) {
            return o2.excludes.size() - o1.excludes.size();
        }
    };

    public UnSSATransformer() {
        super();
    }

    /**
     * there is somewhere both a and its possible x is both live, insert a=x, will change the meaning for example
     * 
     * <pre>
     *                      L0:
     *                      a = phi(b, ... )
     *                      b = 234;
     *                      if a>0 goto L0: // a, b both live here
     *                      ...
     * </pre>
     * 
     * after insert a=b before the if stmt, the programe change to
     * 
     * <pre>
     *                      L0:
     *                      // a = phi(b, ... )
     *                      b = 234;
     *                      a = b
     *                      if a>0 goto L0:
     *                      ...
     * </pre>
     * 
     * the solution is by introduce a new local x
     * 
     * <pre>
     *                      L0:
     *                      x = phi(b, ... )
     *                      a = x
     *                      b = 234;
     *                      if a>0 goto L0: // a, b both live here
     *                      ...
     * </pre>
     * 
     * insert x = b is ok now
     * 
     * <pre>
     *                      L0:
     *                      // x = phi(b, ... )
     *                      a = x
     *                      b = 234;
     *                      x = b
     *                      if a>0 goto L0: // a, b both live here
     *                      ...
     * </pre>
     * 
     * @param phiLabels
     */
    private void fixPhi(IrMethod method, Collection<LabelStmt> phiLabels) {
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;

            for (AssignStmt phi : phis) {

                Local a = (Local) phi.getOp1();
                PhiExpr b = (PhiExpr) phi.getOp2();
                boolean introduceNewLocal = false;
                RegAssign aReg = (RegAssign) a.tag;
                for (Value op : b.getOps()) {
                    RegAssign bReg = (RegAssign) ((Local) op).tag;
                    if (aReg.excludes.contains(bReg)) {
                        introduceNewLocal = true;
                        break;
                    }
                }
                if (introduceNewLocal) {
                    Local newLocal = (Local) a.clone();
                    if (DEBUG) {
                        newLocal.debugName = "x" + method.locals.size();
                    }
                    phi.op1 = newLocal;
                    RegAssign newRegAssign = new RegAssign();
                    newLocal.tag = newRegAssign;

                    method.locals.add(newLocal);
                    Stmt newAssigStmt = Stmts.nAssign(a, newLocal);
                    Stmt next = labelStmt.getNext();
                    if (next != null && next.st == ST.IDENTITY && next.getOp2().vt == VT.EXCEPTION_REF) {
                        // it's a handler, insert after the exception ref
                        method.stmts.insertAfter(next, newAssigStmt);
                    } else {
                        method.stmts.insertAfter(labelStmt, newAssigStmt);
                    }
                    LiveV[] frame = (LiveV[]) labelStmt.frame;
                    if (DEBUG) {
                        LiveV[] copy = frame.clone();
                        LiveV n = new LiveV();
                        n.local = a;
                        n.used = true;
                        copy[a._ls_index] = new LiveV();
                        newAssigStmt.frame = copy;
                    }
                    LiveV thePhi = frame[a._ls_index];
                    thePhi.local = newLocal;
                    for (LiveV v : frame) {
                        if (v != null && v.used) {
                            RegAssign s = (RegAssign) v.local.tag;
                            s.excludes.add(newRegAssign);
                            newRegAssign.excludes.add(s);
                        }
                    }

                }
            }
        }
    }

    private void insertAssignPath(IrMethod method, Collection<LabelStmt> phiLabels) {
        // FIXME the phi in Exception handler is buggy
        List<AssignStmt> buff = new ArrayList<>();
        for (LabelStmt labelStmt : phiLabels) {
            List<AssignStmt> phis = (List<AssignStmt>) labelStmt.phis;
            LiveV[] frame = (LiveV[]) labelStmt.frame;
            for (Stmt from : labelStmt._cfg_froms) {
                if (from.visited) { // at lease it is reached by cfg
                    for (AssignStmt phi : phis) {
                        Local a = (Local) phi.getOp1();
                        LiveV v = frame[a._ls_index];
                        Local local = v.stmt2regMap.get(from);
                        if (local != a) {
                            buff.add(Stmts.nAssign(a, local));
                        }
                    }
                    insertAssignPath(method.stmts, from, labelStmt, buff);
                    buff.clear();
                }
            }
        }
    }

    private void insertAssignPath(StmtList stmts, Stmt from, LabelStmt labelStmt, List<AssignStmt> buff) {
        boolean insertBeforeFromStmt;
        if (from.exceptionHandlers != null && from.exceptionHandlers.contains(labelStmt)) {
            insertBeforeFromStmt = true;
        } else {
            switch (from.st) {
            case GOTO:
            case IF:
                JumpStmt jumpStmt = (JumpStmt) from;
                insertBeforeFromStmt = jumpStmt.getTarget().equals(labelStmt); //
                break;
            case TABLE_SWITCH:
            case LOOKUP_SWITCH:
                insertBeforeFromStmt = true;
                break;
            default:
                insertBeforeFromStmt = false;
                break;
            }
        }
        if (insertBeforeFromStmt) {
            for (AssignStmt as : buff) {
                stmts.insertBefore(from, as);
            }
        } else {
            for (AssignStmt as : buff) {
                stmts.insertAfter(from, as);
            }
        }
        LiveV[] frame = (LiveV[]) from.frame;
        List<LiveV> newLiveVs = new ArrayList<>(buff.size());
        for (AssignStmt as : buff) {
            Local left = (Local) as.getOp1();
            {
                LiveV liveV = new LiveV();
                liveV.local = left;
                liveV.used = true;
                newLiveVs.add(liveV);
            }
            RegAssign leftRegAssign = (RegAssign) left.tag;
            Local right = (Local) as.getOp2();
            int toSkip = right._ls_index;
            for (int i = 0; i < frame.length; i++) {
                if (i == toSkip) {
                    continue;
                }
                LiveV v = frame[i];
                if (v != null && v.used) {
                    RegAssign assign = (RegAssign) v.local.tag;
                    assign.excludes.add(leftRegAssign);
                    leftRegAssign.excludes.add(assign);
                }
            }
            for (AssignStmt as2 : buff) {
                RegAssign assign = (RegAssign) ((Local) as2.getOp1()).tag;
                assign.excludes.add(leftRegAssign);
                leftRegAssign.excludes.add(assign);
            }
        }

        LiveV[] newFrame = new LiveV[frame.length + newLiveVs.size()];
        System.arraycopy(frame, 0, newFrame, 0, frame.length);
        for (int i = 0; i < newLiveVs.size(); i++) {
            newFrame[i + frame.length] = newLiveVs.get(i);
        }

    }

    @Override
    public void transform(IrMethod method) {
        if (method.phiLabels == null || method.phiLabels.size() == 0) {
            return;
        }

        // fix issue in github 186
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [a15 = φ(a4, a23), a17 = φ(a5, a20)]
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        // the local a15 is fixed to x15 in fixPhi
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]
        //  after that, when demote a2, it is inserted after L24e82f43, which will cause a15 undefined
        // .?.....?.?.?.x?x.x..?x.?.??.x.... | L24e82f43: // [x15 = φ(a4, a23), a17 = φ(a5, a20)]
        //                                   | a2 = a15
        //                                   | a15 = x15
        // .?x....?.?.?.x?x.x..?x.?.??.x.... | L16e1a441: // [a2 = φ(a4, a15)]

        // this is simple fix to github 186
        // insert a Nop between two LabelStmt if both have phis
        for (LabelStmt phiLabel : method.phiLabels) {
            Stmt stmt = phiLabel.getNext();
            if (stmt.st == ST.LABEL) {
                LabelStmt labelStmt2 = (LabelStmt) stmt;
                if (labelStmt2.phis != null && labelStmt2.phis.size() > 0) {
                    method.stmts.insertAfter(phiLabel, Stmts.nNop());
                }
            }
        }

        // 1. Live analyze the method,
        // a. remove Phi,
        // b. record parameter reference
        LiveA liveA = new LiveA(method);
        liveA.analyze();

        genRegGraph(method, liveA);

        // 2. insert x=y
        fixPhi(method, method.phiLabels);
        insertAssignPath(method, method.phiLabels);

        // 4. clean up
        for (Local local : method.locals) {
            local.tag = null;
        }
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
        for (LabelStmt labelStmt : method.phiLabels) {
            labelStmt.phis = null;
        }
        method.phiLabels = null;
    }

    private void genRegGraph(IrMethod method, LiveA liveA) {
        for (Local local : method.locals) {
            local.tag = new RegAssign();
        }

        Set<Stmt> tos = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if ((stmt.st == ST.ASSIGN || stmt.st == ST.IDENTITY) && stmt.getOp1().vt == VT.LOCAL) {
                Local localAssignTo = (Local) stmt.getOp1();
                RegAssign regAssignTo = (RegAssign) localAssignTo.tag;
                Set<Integer> excludeIdx = new HashSet<>();
                Cfg.collectTos(stmt, tos);
                for (Stmt target : tos) {
                    LiveV frame[] = (LiveV[]) target.frame;
                    if (frame == null) {
                        continue;
                    }
                    // exclude thisReg and phiReg
                    excludeIdx.clear();
                    excludeIdx.add(localAssignTo._ls_index);
                    if (target.st == ST.LABEL) {
                        LabelStmt label = (LabelStmt) target;
                        if (label.phis != null) {
                            for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                                Local phiLocal = (Local) phiAssignStmt.getOp1();
                                excludeIdx.add(phiLocal._ls_index);
                            }
                        }
                    }
                    for (int i = 0; i < frame.length; i++) {
                        if (excludeIdx.contains(i)) {
                            continue;
                        }
                        LiveV v = frame[i];
                        if (v != null && v.used) {
                            RegAssign b = (RegAssign) v.local.tag;
                            regAssignTo.excludes.add(b);
                            b.excludes.add(regAssignTo);
                        }
                    }
                }
                tos.clear();
            } else if (stmt.st == ST.LABEL) { //
                // https://github.com/pxb1988/dex2jar/issues/477
                // the exception handler is dead and stmt.frame is null
                LabelStmt label = (LabelStmt) stmt;
                if (label.phis != null && stmt.frame != null) {
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        RegAssign a = (RegAssign) phiLocal.tag;
                        LiveV frame[] = (LiveV[]) stmt.frame;
                        for (LiveV v : frame) {
                            if (v != null && v.used) {
                                RegAssign b = (RegAssign) v.local.tag;
                                a.excludes.add(b);
                                b.excludes.add(a);
                            }
                        }
                    }
                }
            }
        }
        if (DEBUG) {
            System.out.println(liveA.toString());
        }
    }

    protected static class LiveA extends BaseAnalyze<LiveV> {
        static Comparator<LiveV> sortByHopsASC = new Comparator<LiveV>() {

            @Override
            public int compare(LiveV arg0, LiveV arg1) {
                return arg0.hops - arg1.hops;
            }
        };

        public LiveA(IrMethod method) {
            super(method);
        }

        @Override
        protected void analyzeValue() {
            markUsed();

            if (UnSSATransformer.DEBUG) {
                clearUnUsedFromFrame();
            }

        }

        protected void clearUnUsedFromFrame() {
            for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
                LiveV[] frame = (LiveV[]) p.frame;
                if (frame != null) {
                    for (int i = 0; i < frame.length; i++) {
                        LiveV r = frame[i];
                        if (r != null) {
                            if (!r.used) {
                                frame[i] = null;
                            }
                        }
                    }
                }
            }
        }

        protected Set<LiveV> markUsed() {
            Set<LiveV> used = new HashSet<LiveV>(aValues.size() / 2);
            Queue<LiveV> q = new UniqueQueue<>();
            q.addAll(aValues);

            while (!q.isEmpty()) {
                LiveV v = q.poll();
                if (v.used) {
                    if (used.contains(v)) {
                        continue;
                    }
                    used.add(v);
                    {
                        LiveV parent = v.parent;
                        if (parent != null && !parent.used) {
                            parent.used = true;
                            q.add(parent);
                        }
                    }
                    {
                        List<LiveV> otherParent = v.otherParents;
                        if (otherParent != null && otherParent.size() > 0) {
                            for (LiveV parent : otherParent) {
                                if (parent != null && !parent.used) {
                                    parent.used = true;
                                    q.add(parent);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
            for (LiveV v : aValues) {
                v.parent = null;
            }
            aValues = null;

            return used;
        }

        @SuppressWarnings({ "unchecked", "rawtypes" })
        @Override
        public LiveV[] merge(LiveV[] srcFrame, LiveV[] distFrame, Stmt src, Stmt dist) {

            Map<Integer, AssignStmt> phiLives = new HashMap<>();
            if (dist.st == ST.LABEL) {
                LabelStmt label = (LabelStmt) dist;
                if (label.phis != null) {// we got phis here
                    // travel each phi assignment, find where the phiLocal from
                    for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {
                        Local phiLocal = (Local) phiAssignStmt.getOp1();
                        phiLives.put(phiLocal._ls_index, phiAssignStmt);
                    }
                }
            }
            // relationship
            boolean firstMerge = false;
            if (distFrame == null) { // distFrame is not visited
                distFrame = newFrame(); // init the distFrame
                firstMerge = true;

                // merge each value to distFrame if value is not null;
                for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) { // skip phi
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    if (srcV != null) {
                        LiveV distV = newValue();
                        aValues.add(distV);
                        distV.parent = srcV;
                        distV.hops = srcV.hops + 1;
                        distV.local = srcV.local;
                        distFrame[i] = distV;
                    }
                }
            }

            if (!firstMerge) {
                // skip merge phi
                for (int i = 0; i < distFrame.length; i++) {
                    if (phiLives.containsKey(i)) {
                        continue;
                    }
                    LiveV srcV = srcFrame[i];
                    LiveV distV = distFrame[i];
                    if (srcV != null && distV != null) {
                        if (distV.otherParents == null) {
                            distV.otherParents = new ArrayList(5);
                        }
                        distV.otherParents.add(srcV);
                    }
                }
            }

            // deal with phi
            for (AssignStmt phiAssignStmt : phiLives.values()) {
                Local phiLocal = (Local) phiAssignStmt.getOp1();

                LiveV distValue;
                if (firstMerge) {
                    distValue = new LiveV();
                    distValue.local = phiLocal;
                    distValue.stmt2regMap = new HashMap<>();
                    distFrame[phiLocal._ls_index] = distValue;
                } else {
                    distValue = distFrame[phiLocal._ls_index];
                }

                List<LiveV> liveVs = new ArrayList();

                LiveV possiblePhiLocal = srcFrame[phiLocal._ls_index];
                if (possiblePhiLocal != null) {
                    liveVs.add(possiblePhiLocal);
                }

                for (Value p0 : phiAssignStmt.getOp2().getOps()) {
                    Local srcLocal = (Local) p0;
                    LiveV s = srcFrame[srcLocal._ls_index];
                    if (s != null) {
                        liveVs.add(s);
                    }
                }
                Collections.sort(liveVs, sortByHopsASC);
                LiveV a = liveVs.get(0); // this value assign to
                                         // phiLocal in srcFrame
                a.used = true;
                distValue.stmt2regMap.put(src, a.local);
            }
            return distFrame;
        }

        @Override
        protected LiveV[] newFrame(int size) {
            return new LiveV[size];
        }

        @Override
        protected LiveV newValue() {
            return new LiveV();
        }

        @Override
        protected LiveV onAssignLocal(Local local, Value value) {
            LiveV v = super.onAssignLocal(local, value);
            v.local = local;
            v.used = true;
            return v;
        }

        @Override
        protected void onUseLocal(LiveV aValue, Local local) {
            aValue.used = true;
        }

    }

    private static class LiveV implements AnalyzeValue {
        public int hops;
        public Local local;
        public LiveV parent;
        public boolean used;
        public List<LiveV> otherParents;
        /**
         * for a Phi local, record where the this assigned from, for
         * 
         * <pre>
         *     s0: a0=1
         *     s1: if x goto s3
         *     s2: a1=2
         *     s3: a= phi(a0, a1)
         * </pre>
         * 
         * the value is s0 : a0 s2 : a1
         */
        Map<Stmt, Local> stmt2regMap;

        @Override
        public char toRsp() {
            return used ? 'x' : '?';
        }

        @Override
        public String toString() {
            return local + "|" + hops;
        }
    }

    /**
     * designed for assign index to Local, each Object is related to a Local
     */
    protected static class RegAssign {
        /**
         * can not have same index with
         */
        public Set<RegAssign> excludes = new HashSet<RegAssign>();

    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/UniqueQueue.java`:

```java
package com.googlecode.dex2jar.ir.ts;

import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

public class UniqueQueue<T> extends LinkedList<T> {

    private static final long serialVersionUID = 7578371020752763662L;

    Set<T> set = new HashSet<>();

    public UniqueQueue() {
    }

    @Override
    public boolean addAll(Collection<? extends T> c) {
        boolean result = false;
        for (T t : c) {
            if (add(t)) {
                result = true;
            }
        }
        return result;

    }

    @Override
    public boolean add(T t) {
        if (set.add(t)) {
            super.add(t);
        }
        return true;
    }

    public T poll() {
        T t = super.poll();
        set.remove(t);
        return t;
    }

    @Override
    public T pop() {
        T t = super.pop();
        set.remove(t);
        return t;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/VoidInvokeTransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.AbstractInvokeExpr;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmts;

/**
 * convert
 * 
 * <pre>
 * a = b.get();
 * </pre>
 * 
 * to
 * 
 * <pre>
 * b.get();
 * </pre>
 * 
 * if a is not used in other place.
 */
public class VoidInvokeTransformer extends StatedTransformer {
    @Override
    public boolean transformReportChanged(IrMethod method) {
        if (method.locals.size() == 0) {
            return false;
        }
        int reads[] = Cfg.countLocalReads(method);
        boolean changed = false;
        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN && p.getOp1().vt == Value.VT.LOCAL) {
                Local left = (Local) p.getOp1();
                if (reads[left._ls_index] == 0) {
                    Value op2 = p.getOp2();
                    if (op2 instanceof AbstractInvokeExpr) {
                        method.locals.remove(left);
                        Stmt nVoidInvoke = Stmts.nVoidInvoke(op2);
                        method.stmts.replace(p, nVoidInvoke);
                        p = nVoidInvoke;
                        changed = true;
                    }
                }
            }
        }
        return changed;
    }

    @Override
    public void transform(IrMethod method) {
        transformReportChanged(method);

    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/ZeroTransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Constant;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmts;

import java.util.ArrayList;
import java.util.List;

/**
 * dex mix use as integer 0 and object null. the following code is validate in dex, but invalidate in .class
 * 
 * <pre>
 *     a=0
 *     if x>0 goto L1
 *     L2: [b=phi(a,c)]
 *     useAsObject(b);
 *     c=getAnotherObject();
 *     goto L2:
 *     L1: [d=phi(a,e)]
 *     useAsInt(d);
 *     e=123
 *     goto L1:
 * </pre>
 * 
 * we transform the code to
 * 
 * <pre>
 *     a1=0
 *     a=0
 *     if x>0 goto L1
 *     a2=0
 *     L2: [b=phi(a1,c)]
 *     useAsObject(b);
 *     c=getAnotherObject();
 *     goto L2:
 *     L1: [d=phi(a,e)]
 *     useAsInt(d);
 *     e=123
 *     goto L1:
 * </pre>
 */
public class ZeroTransformer extends StatedTransformer {

    @Override
    public boolean transformReportChanged(IrMethod method) {
        boolean changed = false;
        List<AssignStmt> assignStmtList = new ArrayList<>();

        for (Stmt p = method.stmts.getFirst(); p != null; p = p.getNext()) {
            if (p.st == Stmt.ST.ASSIGN) {
                AssignStmt as = (AssignStmt) p;
                if (as.getOp1().vt == Value.VT.LOCAL && as.getOp2().vt == Value.VT.CONSTANT) {
                    Constant cst = (Constant) as.getOp2();
                    Object value = cst.value;
                    if (value instanceof Number && !((value instanceof Long) || (value instanceof Double))) {
                        int v = ((Number) value).intValue();
                        if (v == 0 || v == 1) {
                            assignStmtList.add(as);
                        }
                    }
                }
            }
        }
        if (assignStmtList.size() == 0) {
            return false;
        }
        List<LabelStmt> phiLabels = method.phiLabels;
        if (phiLabels != null) {
            for (AssignStmt as : assignStmtList) {
                Local local = (Local) as.getOp1();
                boolean first = true;
                for (LabelStmt labelStmt : phiLabels) {
                    for (AssignStmt phi : labelStmt.phis) {
                        Value[] vs = phi.getOp2().getOps();
                        for (int i = 0; i < vs.length; i++) {
                            Value v = vs[i];
                            if (v == local) {
                                if (first) {
                                    first = false;
                                } else {
                                    Local nLocal = Exprs.nLocal(-1);
                                    method.locals.add(nLocal);
                                    changed = true;
                                    method.stmts.insertBefore(as, Stmts.nAssign(nLocal, as.getOp2().clone()));
                                    vs[i] = nLocal;
                                }
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }
}
```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/an/AnalyzeValue.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts.an;

public interface AnalyzeValue {

    public char toRsp();
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/an/BaseAnalyze.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts.an;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.ts.Cfg;
import com.googlecode.dex2jar.ir.ts.Cfg.FrameVisitor;
import com.googlecode.dex2jar.ir.ts.Cfg.TravelCallBack;

import java.util.ArrayList;
import java.util.List;

@SuppressWarnings({"unchecked"})
public abstract class BaseAnalyze<T extends AnalyzeValue> implements FrameVisitor<T[]>, TravelCallBack {
    protected static final boolean DEBUG = false;

    public List<T> aValues = new ArrayList<T>();
    private boolean reindexLocal;
    private T[] currentFrame;

    protected int localSize;

    protected IrMethod method;

    private T[] tmpFrame;

    public BaseAnalyze(IrMethod method) {
        this(method,true);
    }

    public BaseAnalyze(IrMethod method, boolean reindexLocal) {
        super();
        this.method = method;
        if (!reindexLocal) {
            // override the localSize value to the max local index+1
            int maxReg = -1;
            for (Local local : method.locals) {
                if (local._ls_index > maxReg) {
                    maxReg = local._ls_index;
                }
            }
            this.localSize = maxReg + 1;
        } else {
            this.localSize = method.locals.size();
        }
        this.reindexLocal = reindexLocal;
    }

    public void analyze() {
        init();
        analyze0();
        analyzeValue();
    }

    protected void analyze0() {
        tmpFrame = newFrame(localSize);
        Cfg.dfs(method.stmts, this);
        tmpFrame = null;
    }

    protected void analyzeValue() {
    }

    protected void afterExec(T[] frame, Stmt stmt) {

    }

    @Override
    public T[] exec(T[] frame, Stmt stmt) {
        this.currentFrame = frame;
        try {
            Cfg.travel(stmt, this, false);
        } catch (Exception ex) {
            throw new RuntimeException("fail exe " + stmt, ex);
        }
        frame = this.currentFrame;
        this.currentFrame = null;
        afterExec(frame, stmt);
        return frame;
    }

    protected T getFromFrame(int idx) {
        return (T) currentFrame[idx];
    }

    protected T[] getFrame(Stmt stmt) {
        return (T[]) stmt.frame;
    }

    protected void setFrame(Stmt stmt, T[] frame) {
        stmt.frame = frame;
    }

    protected void init() {
        if (reindexLocal) {
            int index = 0;
            for (Local local : method.locals) {
                local._ls_index = index;
                index++;
            }
        }
        if (DEBUG) {
            int idx = 0;
            for (Stmt s : method.stmts) {
                if (s.st == Stmt.ST.LABEL) {
                    LabelStmt label = (LabelStmt) s;
                    label.displayName = "L" + idx++;
                }
            }
        }
        initCFG();
    }

    protected void initCFG() {
        Cfg.createCFG(method);
    }

    protected T[] newFrame() {
        return newFrame(localSize);
    }

    @Override
    public T[] initFirstFrame(Stmt first) {
        return newFrame(localSize);
    }

    protected abstract T[] newFrame(int size);

    protected abstract T newValue();

    @Override
    public Local onAssign(Local local, AssignStmt as) {
        System.arraycopy(currentFrame, 0, tmpFrame, 0, localSize);
        currentFrame = tmpFrame;
        T aValue = onAssignLocal(local, as.op2);
        aValues.add(aValue);
        currentFrame[local._ls_index] = aValue;
        return local;
    }

    protected T onAssignLocal(Local local, Value value) {
        return newValue();
    }

    @Override
    public Local onUse(Local local) {
        T aValue = (T) currentFrame[local._ls_index];
        onUseLocal(aValue, local);
        return local;
    }

    protected void onUseLocal(T aValue, Local local) {
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Stmt stmt = method.stmts.getFirst(); stmt != null; stmt = stmt.getNext()) {
            T[] frame = (T[]) stmt.frame;
            if (frame != null) {
                for (T p : frame) {
                    if (p == null) {
                        sb.append('.');
                    } else {
                        sb.append(p.toRsp());
                    }
                }
                sb.append(" | ");
            }
            sb.append(stmt.toString()).append('\n');
        }
        return sb.toString();
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/an/SimpleLiveAnalyze.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts.an;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.ts.UniqueQueue;

import java.util.*;

public class SimpleLiveAnalyze extends BaseAnalyze<SimpleLiveValue> {
    protected Set<SimpleLiveValue> markUsed() {
        Set<SimpleLiveValue> used = new HashSet<SimpleLiveValue>(aValues.size() / 2);
        Queue<SimpleLiveValue> q = new UniqueQueue<>();
        for (SimpleLiveValue sv : aValues) {
            if (sv.used) {
                q.add(sv);
                while (!q.isEmpty()) {
                    SimpleLiveValue v = q.poll();
                    if (v.used) {
                        if (used.contains(v)) {
                            continue;
                        }
                        used.add(v);
                        {
                            SimpleLiveValue p = v.parent;
                            if (p != null) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                        }
                        if (v.otherParents != null) {
                            for (SimpleLiveValue p : v.otherParents) {
                                if (!p.used) {
                                    p.used = true;
                                    q.add(p);
                                }
                            }
                            v.otherParents = null;
                        }
                    }
                }
            }
        }

        return used;
    }

    @Override
    protected void analyzeValue() {
        markUsed();
    }

    public int getLocalSize() {
        return localSize;
    }

    public SimpleLiveAnalyze(IrMethod method, boolean reindexLocal) {
        super(method, reindexLocal);
    }

    @Override
    protected SimpleLiveValue onAssignLocal(Local local, Value value) {
        SimpleLiveValue v = super.onAssignLocal(local, value);
        v.used = true;
        return v;
    }

    @Override
    protected void onUseLocal(SimpleLiveValue aValue, Local local) {
        aValue.used = true;
        super.onUseLocal(aValue, local);
    }

    @Override
    public SimpleLiveValue[] merge(SimpleLiveValue[] srcFrame, SimpleLiveValue[] distFrame, Stmt src, Stmt dist) {
        if (distFrame == null) {
            distFrame = new SimpleLiveValue[this.localSize];
            for (int i = 0; i < srcFrame.length; i++) {
                SimpleLiveValue sV = srcFrame[i];
                if (sV != null) {
                    SimpleLiveValue dV = new SimpleLiveValue();
                    aValues.add(dV);
                    dV.parent = sV;
                    distFrame[i] = dV;
                }
            }
        } else {
            for (int i = 0; i < srcFrame.length; i++) {
                SimpleLiveValue sV = srcFrame[i];
                SimpleLiveValue dV = distFrame[i];
                if (sV != null && dV != null) {
                    List<SimpleLiveValue> ps = dV.otherParents;
                    if (ps == null) {
                        dV.otherParents = ps = new ArrayList<>(3);
                    }
                    ps.add(sV);
                }
            }
        }
        return distFrame;
    }

    @Override
    protected SimpleLiveValue[] newFrame(int size) {
        return new SimpleLiveValue[size];
    }

    @Override
    protected SimpleLiveValue newValue() {
        return new SimpleLiveValue();
    }
}
```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/an/SimpleLiveValue.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts.an;

import java.util.List;

public class SimpleLiveValue implements AnalyzeValue {
    public boolean used = false;

    public SimpleLiveValue parent;
    public List<SimpleLiveValue> otherParents;

    @Override
    public char toRsp() {
        return used ? 'x' : '.';
    }
}
```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/array/ArrayElementTransformer.java`:

```java
package com.googlecode.dex2jar.ir.ts.array;


import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.StmtTraveler;
import com.googlecode.dex2jar.ir.expr.*;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmts;
import com.googlecode.dex2jar.ir.ts.Cfg;
import com.googlecode.dex2jar.ir.ts.StatedTransformer;

import java.lang.reflect.Array;
import java.util.*;

/**
 * require SSA, element index are const
 * <p/>
 * transformer
 * <pre>
 *     ...
 *     a[4]="abc"
 *     return a[4]
 * </pre>
 * to
 * <pre>
 *     ...
 *     a[4]="abc"
 *     return "abc"
 * </pre>
 */
public class ArrayElementTransformer extends StatedTransformer {
    @Override
    public boolean transformReportChanged(IrMethod method) {

        Set<Local> arrays = searchForArrayObject(method);
        if (arrays.size() == 0) {
            return false;
        }
        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        int i = 0;
        for (Local local : arrays) {
            local._ls_index = i++;
        }
        final int size = i;
        Cfg.createCFG(method);
        final List<ArrayValue> values = new ArrayList<>();
        final List<Stmt> used = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayValue[]>() {

            Set<Integer> phis = new HashSet<>();

            @Override
            public ArrayValue[] merge(ArrayValue[] srcFrame, ArrayValue[] distFrame, Stmt src, Stmt dist) {
                if (dist.st == Stmt.ST.LABEL) {
                    LabelStmt labelStmt = (LabelStmt) dist;
                    if (labelStmt.phis != null) {
                        for (AssignStmt phi : labelStmt.phis) {
                            int idx = ((Local) phi.getOp1())._ls_index;
                            if (idx >= 0) {
                                phis.add(idx);
                            }
                        }
                    }
                }
                if (distFrame == null) {
                    distFrame = new ArrayValue[size];
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            ArrayValue aov = new ArrayValue();
                            values.add(aov);
                            aov.s = ArrayValue.S.UNKNOWN;
                            aov.indexType = ArrayValue.IndexType.NONE;
                            aov.stmt = dist;
                            distFrame[i] = aov;
                        } else {
                            ArrayValue arc = srcFrame[i];
                            if (arc != null) {
                                ArrayValue aov = new ArrayValue();
                                values.add(aov);
                                aov.s = ArrayValue.S.INHERIT;
                                aov.indexType = ArrayValue.IndexType.NONE;
                                aov.stmt = dist;
                                aov.parent = arc;
                                distFrame[i] = aov;
                            }
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        if (phis.contains(i)) {
                            continue;
                        }
                        ArrayValue arc = srcFrame[i];
                        ArrayValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.parent == null) {
                                aov.parent = arc;
                            } else if (!aov.parent.equals(arc)) {
                                if (aov.otherParents == null) {
                                    aov.otherParents = new HashSet<>();
                                }
                                aov.otherParents.add(arc);
                            }
                        }
                    }
                }
                phis.clear();
                return distFrame;
            }

            @Override
            public ArrayValue[] initFirstFrame(Stmt first) {
                return new ArrayValue[size];
            }

            ArrayValue[] tmp = new ArrayValue[size];
            Stmt currentStmt;


            @Override
            public ArrayValue[] exec(ArrayValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.ASSIGN) {
                    // create an array
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        use(stmt.getOp2());
                        if (local._ls_index >= 0) {
                            Value op2 = stmt.getOp2();
                            if (op2.vt == Value.VT.NEW_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.size = op2.getOp();
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.FILLED_ARRAY) {
                                ArrayValue av = new ArrayValue();
                                av.s = ArrayValue.S.DEFAULT;
                                av.indexType = ArrayValue.IndexType.CONST;
                                av.stmt = stmt;
                                FilledArrayExpr fae = (FilledArrayExpr) stmt.getOp2();
                                av.size = Exprs.nInt(fae.getOps().length);
                                Value[] ops = fae.getOps();
                                for (int i = 0; i < ops.length; i++) {
                                    av.elements1.put(i, ops[i]);
                                }
                                values.add(av);
                                tmp[local._ls_index] = av;
                            } else if (op2.vt == Value.VT.CONSTANT) {
                                Object cst = ((Constant) op2).value;
                                if (cst != null && !cst.equals(Constant.Null) && cst.getClass().isArray()) {
                                    ArrayValue av = new ArrayValue();
                                    av.s = ArrayValue.S.DEFAULT;
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.stmt = stmt;
                                    int size = Array.getLength(cst);
                                    av.size = Exprs.nInt(size);
                                    for (int i = 0; i < size; i++) {
                                        av.elements1.put(i, Exprs.nConstant(Array.get(cst, size)));
                                    }
                                    values.add(av);
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                ArrayValue av = new ArrayValue();
                                values.add(av);
                                av.s = ArrayValue.S.UNKNOWN;
                                av.indexType = ArrayValue.IndexType.NONE;
                                av.stmt = stmt;
                                tmp[local._ls_index] = av;
                            }
                        }
                        // assign index1
                    } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                        use(stmt.getOp2());
                        ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            Value index = ae.getOp2();
                            if (local._ls_index >= 0) {
                                if (index.vt == Value.VT.CONSTANT) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(((Number) (((Constant) index).value)).intValue(), stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.CONST;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else if (index.vt == Value.VT.LOCAL) {
                                    ArrayValue parent = tmp[local._ls_index];
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.parent = parent;
                                    av.elements1.put(index, stmt.getOp2());
                                    av.indexType = ArrayValue.IndexType.LOCAL;
                                    av.s = ArrayValue.S.INHERIT;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                } else {
                                    ArrayValue av = new ArrayValue();
                                    values.add(av);
                                    av.s = ArrayValue.S.UNKNOWN;
                                    av.indexType = ArrayValue.IndexType.NONE;
                                    av.stmt = stmt;
                                    tmp[local._ls_index] = av;
                                }
                            } else {
                                use(stmt.getOp1());
                            }
                        } else {
                            use(stmt.getOp1());
                        }

                    } else {
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                    }
                    // assign index2
                } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            Object array = ((Constant) stmt.getOp2()).value;
                            ArrayValue parent = tmp[local._ls_index];
                            ArrayValue av = new ArrayValue();
                            values.add(av);
                            av.parent = parent;
                            int size = Array.getLength(array);
                            av.size = Exprs.nInt(size);
                            for (int i = 0; i < size; i++) {
                                av.elements1.put(i, Exprs.nConstant(Array.get(array, i)));
                            }
                            av.indexType = ArrayValue.IndexType.CONST;
                            av.s = ArrayValue.S.INHERIT;
                            av.stmt = stmt;
                            tmp[local._ls_index] = av;
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else {
                    switch (stmt.et) {
                        case E0:
                            break;
                        case E1:
                            use(stmt.getOp());
                            break;
                        case E2:
                            use(stmt.getOp1());
                            use(stmt.getOp2());
                            break;
                        case En:
                            throw new RuntimeException();
                    }
                }

                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                    case E0:
                        break;
                    case E1:
                        use(v.getOp());
                        break;
                    case E2:
                        Value op1 = v.getOp1();
                        Value op2 = v.getOp2();
                        use(op1);
                        use(op2);
                        if (v.vt == Value.VT.ARRAY) {
                            if (op1.vt == Value.VT.LOCAL && (op2.vt == Value.VT.LOCAL || op2.vt == Value.VT.CONSTANT)) {
                                Local local = (Local) op1;
                                if (local._ls_index > 0) {
                                    used.add(currentStmt);
                                }
                            }
                        }
                        break;
                    case En:
                        for (Value op : v.getOps()) {
                            use(op);
                        }
                        break;
                }
            }
        });


        // TODO travel stmt to find must-be array element

        for (Stmt p : method.stmts) {

        }
        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.ARRAY) {

                }
                return op;
            }
        }.travel(method.stmts);

        return false;
    }

    public static void main(String... args) {
        IrMethod m = new IrMethod();
        m.isStatic = true;
        m.name = "a";
        m.args = new String[0];
        m.ret = "[Ljava/lang/String;";
        m.owner = "La;";

        Local array = Exprs.nLocal(1);
        m.locals.add(array);

        m.stmts.add(Stmts.nAssign(array, Exprs.nNewArray("Ljava/lang/String;", Exprs.nInt(2))));
        m.stmts.add(Stmts.nAssign(Exprs.nArray(array, Exprs.nInt(1), "Ljava/lang/String;"), Exprs.nString("123")));
        m.stmts.add(Stmts.nAssign(Exprs.nArray(array, Exprs.nInt(0), "Ljava/lang/String;"), Exprs.nString("456")));
        m.stmts.add(Stmts.nReturn(array));
        new ArrayElementTransformer().transform(m);
    }

    private Set<Local> searchForArrayObject(IrMethod method) {
        final Set<Local> arrays = new HashSet<>();
        for (Stmt stmt : method.stmts) {
            if (stmt.st == Stmt.ST.ASSIGN) {
                // create an array
                if (stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    if (stmt.getOp2().vt == Value.VT.NEW_ARRAY || stmt.getOp2().vt == Value.VT.FILLED_ARRAY) {
                        arrays.add(local);
                    }
                    // assign index1
                } else if (stmt.getOp1().vt == Value.VT.ARRAY) {
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        arrays.add(local);
                    }

                }
                // assign index2
            } else if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                if (stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    arrays.add(local);
                }
            }
        }
        return arrays;
    }

    static class ArrayValue {
        enum S {
            /**
             * all element are default value. that is null for object and 0 for primitive
             */
            DEFAULT,
            /**
             * all element are unknown value
             */
            UNKNOWN,
            /**
             * the element value is based on its parent
             */
            INHERIT
        }

        enum IndexType {
            CONST, LOCAL, NONE
        }


        IndexType indexType = IndexType.NONE;
        S s = S.INHERIT;
        ArrayValue parent;
        Value size;
        Set<ArrayValue> otherParents;
        Map<Object, Value> elements1 = new HashMap<>();
        Stmt stmt;
    }
}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/array/ArrayNullPointerTransformer.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.ts.array;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.ArrayExpr;
import com.googlecode.dex2jar.ir.expr.Constant;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.FieldExpr;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.expr.Value.E1Expr;
import com.googlecode.dex2jar.ir.expr.Value.E2Expr;
import com.googlecode.dex2jar.ir.expr.Value.EnExpr;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.E1Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.E2Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import com.googlecode.dex2jar.ir.stmt.StmtList;
import com.googlecode.dex2jar.ir.stmt.Stmts;
import com.googlecode.dex2jar.ir.ts.Transformer;

/**
 * run after {@link com.googlecode.dex2jar.ir.ts.ConstTransformer}, to deal with following code
 * 
 * <pre>
 * int[] a = null;
 * int b = a[1];
 * </pre>
 * 
 * replace {@code int b = a[1];} to {@code throw new NullPointException()}, and we get
 * 
 * <pre>
 * int[] a = null;
 * throw new NullPointException();
 * </pre>
 * 
 * @author Panxiaobo
 * 
 */
public class ArrayNullPointerTransformer implements Transformer {

    @Override
    public void transform(IrMethod irMethod) {
        for (Stmt p = irMethod.stmts.getFirst(); p != null;) {
            if (arrayNPE(p)) {
                Stmt q = p.getNext();
                replaceNPE(irMethod.stmts, irMethod.locals, p);
                p = q;
                continue;
            }
            p = p.getNext();
        }
    }

    private void replaceNPE(StmtList stmts, List<Local> locals, Stmt p) {
        List<Value> values = new ArrayList<Value>();
        switch (p.et) {
        case E1:
            tryAdd(((E1Stmt) p).op.trim(), values);
            break;
        case E2:
            E2Stmt e2 = (E2Stmt) p;
            switch (e2.op1.trim().vt) {
            case LOCAL:
                tryAdd(e2.op2.trim(), values);
                break;
            case ARRAY:
                ArrayExpr ae = (ArrayExpr) e2.op1.trim();
                if (tryAdd(ae.op1.trim(), values)) {
                    if (tryAdd(ae.op2.trim(), values)) {
                        tryAdd(e2.op2.trim(), values);
                    }
                }
                break;
            case FIELD:// putfield
                FieldExpr fe = (FieldExpr) e2.op1.trim();
                if (fe.op == null || fe.op.trim() == null || tryAdd(fe.op.trim(), values)) {
                    tryAdd(e2.op2.trim(), values);
                }
                break;
            default:
                if (tryAdd(e2.op2.trim(), values)) {
                    tryAdd(e2.op1.trim(), values);
                }
            }
        default:
        }
        for (Value value : values) {
            switch (value.vt) {
            case CONSTANT:
            case LOCAL:
                break;
            default:
                Local n = Exprs.nLocal("xxx");
                locals.add(n);
                stmts.insertBefore(p, Stmts.nAssign(n, value));
            }
        }
        stmts.insertBefore(p,
                Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], "Ljava/lang/NullPointerException;")));
        stmts.remove(p);
    }

    private boolean tryAdd(Value value, List<Value> values) {
        if (!arrayNPE(value)) {
            values.add(value);
            return true;
        } else {
            switch (value.et) {
            case E0:
                values.add(value);
                break;
            case E1:
                E1Expr e1 = (E1Expr) value;
                if (e1.op == null || e1.op.trim() == null) {
                    return false;
                }
                tryAdd(e1.op.trim(), values);
                break;
            case E2:
                E2Expr e2 = (E2Expr) value;
                if (e2.vt == VT.ARRAY && e2.op1.trim().vt == VT.CONSTANT) {
                    Constant cst = (Constant) e2.op1.trim();
                    if (cst.value.equals(Integer.valueOf(0))) {
                        tryAdd(e2.op2.trim(), values);
                        return false;
                    }
                }
                if (tryAdd(e2.op1.trim(), values)) {
                    tryAdd(e2.op2.trim(), values);
                }

            case En:
                for (Value vb : ((EnExpr) value).ops) {
                    if (!tryAdd(vb.trim(), values)) {
                        break;
                    }
                }
            }
        }
        return false;
    }

    private boolean arrayNPE(Stmt p) {
        switch (p.et) {
        case E0:
            return false;
        case E1:
            if (p.st == ST.GOTO) {
                return false;
            }
            return arrayNPE(((E1Stmt) p).op.trim());
        case E2:
            E2Stmt e2 = (E2Stmt) p;
            switch (e2.op1.trim().vt) {
            case ARRAY:
            case FIELD:
                return arrayNPE(e2.op1.trim()) || arrayNPE(e2.op2.trim());
            default:
                return arrayNPE(e2.op2.trim()) || arrayNPE(e2.op1.trim());
            }
        case En:
            return false;
        }
        return false;
    }

    private boolean arrayNPE(Value value) {
        switch (value.et) {
        case E0:
            return false;
        case E1:
            E1Expr e1 = (E1Expr) value;
            if (e1.op == null || e1.op.trim() == null) {
                return false;
            }
            return arrayNPE(e1.op.trim());
        case E2:
            E2Expr e2 = (E2Expr) value;
            if (e2.vt == VT.ARRAY && e2.op1.trim().vt == VT.CONSTANT) {
                Constant cst = (Constant) e2.op1.trim();
                if (cst.value.equals(Integer.valueOf(0))) {
                    return true;
                }
            }
            return arrayNPE(e2.op1.trim()) || arrayNPE(e2.op2.trim());

        case En:
            for (Value vb : ((EnExpr) value).ops) {
                if (arrayNPE(vb.trim())) {
                    return true;
                }
            }
        }
        return false;
    }

}

```

`dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/array/FillArrayTransformer.java`:

```java
package com.googlecode.dex2jar.ir.ts.array;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.*;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmts;
import com.googlecode.dex2jar.ir.ts.Cfg;
import com.googlecode.dex2jar.ir.ts.StatedTransformer;
import com.googlecode.dex2jar.ir.ts.UniqueQueue;

import java.lang.reflect.Array;
import java.util.*;

/**
 * require SSA, usually run after ConstTransformer 1. array is fixed size. 2. array object init and use once, (exclude
 * the element assignment) 3. all elements are init with fixed index before use. 4. the array is not in PhiExpr 5. and
 * for array object init at A, use at B; A and B must in same loop/path, so G(A->B), G(A->C->B), G(A->C,A->D,C->B,D->B),
 * G(A->C,C->D,D->C,C->B) and G(A->C,C->A,C->B) is ok to transform, but for G(A->C,C->B,B->D,D->C), B is in a loop
 * (B->D->C->B), should not transformed.
 * <p/>
 * transform
 * 
 * <pre>
 *     a=new String[3]
 *     a[0]="123"
 *     a[2]="1234"
 *     a[1]="12345"
 *     return a
 * </pre>
 * 
 * to
 * 
 * <pre>
 *     return new String[3] { "123", "12345", "1234" }
 * </pre>
 * 
 * 1. This Transformer is useful when cleanup the tool-injected reflection code
 * 
 * <pre>
 *     // before transform
 *     ...
 *     Class a[]=new Class[2]
 *     a[0]=String.class
 *     a[1]=int.class
 *     Method m=x.getMethod("methodA",a)
 *     Object b[]=new Object[2]
 *     b[0]="123";
 *     b[1]=Integer.valueOf(1);
 *     m.invoke(c,b)
 *     // after transform
 *     Method m=x.getMethod("methodA", new Class[2] { String.class ,int.class });
 *     m.invoke(b,new Object[]{"123",Integer.valueOf(1)})
 * </pre>
 * 
 * 2. Suggest decompilers generate better code
 * 
 * <pre>
 *     // for following code, before transform, the decompiler generate same source
 *     Object[]a=new Object[2];
 *     a[0]=b;
 *     a[1]=c
 *     String.format("b is %s, c is %s",a)
 *     // after transform, then decompile generate the following source
 *     String.format("b is %s, c is %s",b,c)
 * </pre>
 * 
 * FIXME also handle not full filled array
 * 
 * <pre>
 * int a[] = new int[5];
 * // a[0]=0;
 * a[1] = 1;
 * a[2] = 3;
 * a[3] = 4;
 * a[4] = 7;
 * </pre>
 */
public class FillArrayTransformer extends StatedTransformer {
    private static class ArrayObject {
        int size;
        String type;
        AssignStmt init;
        List<Stmt> putItem = new ArrayList<>();
        List<Stmt> used = new ArrayList<>();

        private ArrayObject(int size, String type, AssignStmt init) {
            this.size = size;
            this.type = type;
            this.init = init;
        }
    }

    public static void main(String... args) {
        IrMethod m = new IrMethod();
        m.isStatic = true;
        m.name = "a";
        m.args = new String[0];
        m.ret = "[Ljava/lang/String;";
        m.owner = "La;";

        Local array = Exprs.nLocal(1);
        m.locals.add(array);
        m.stmts.add(Stmts.nAssign(array, Exprs.nNewArray("Ljava/lang/String;", Exprs.nInt(2))));
        m.stmts.add(Stmts.nAssign(Exprs.nArray(array, Exprs.nInt(1), "Ljava/lang/String;"), Exprs.nString("123")));
        m.stmts.add(Stmts.nAssign(Exprs.nArray(array, Exprs.nInt(0), "Ljava/lang/String;"), Exprs.nString("456")));
        m.stmts.add(Stmts.nReturn(array));
        new FillArrayTransformer().transform(m);
        System.out.println(m);
    }

    @Override
    public boolean transformReportChanged(IrMethod method) {

        // find array match fixed size,fixed index, not in phi
        final Map<Local, ArrayObject> arraySizes = searchForArrayObject(method);

        if (arraySizes.size() == 0) {
            return false;
        }

        makeSureAllElementAreAssigned(arraySizes);
        if (arraySizes.size() == 0) {
            return false;
        }

        makeSureArrayUsedAfterAllElementAssigned(method, arraySizes);

        if (arraySizes.size() == 0) {
            return false;
        }

        replace(method, arraySizes);

        return true;
    }

    private void replace(IrMethod method, Map<Local, ArrayObject> arraySizes) {
        final List<FilledArrayExpr> filledArrayExprs = new ArrayList<>();
        for (Map.Entry<Local, ArrayObject> e : arraySizes.entrySet()) {
            final Local local0 = e.getKey();
            final ArrayObject ao = e.getValue();
            final Value t[] = new Value[ao.size];
            for (Iterator<Stmt> it = ao.putItem.iterator(); it.hasNext();) {
                Stmt p = it.next();
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    Local local = (Local) p.getOp1();
                    if (local == local0) {
                        Object vs = ((Constant) p.getOp2()).value;
                        int endPos = Array.getLength(vs);
                        for (int j = 0; j < endPos; j++) {
                            t[j] = Exprs.nConstant(Array.get(vs, j));
                        }
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    Local local = (Local) ae.getOp1();
                    if (local == local0) {
                        int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                        Value op2 = p.getOp2();
                        if (op2.vt != Value.VT.LOCAL && op2.vt != Value.VT.CONSTANT) {
                            Local n = new Local(-1);
                            method.locals.add(n);
                            method.stmts.insertBefore(p, Stmts.nAssign(n, op2));
                            op2 = n;
                        }
                        t[idx] = op2;
                    }
                }
            }

            // for code
            // b=new Object[1]
            // b[0]=null
            // a =new Object[1]
            // a =b;
            // use(a)
            // if a is replace before b, the code
            // b=new Object[1]
            // b[0]=null
            // use(new Object[]{b})
            // the used stmt of b is outdated, so we have to search pre replaced arrays

            method.locals.remove(local0);
            method.stmts.remove(ao.init);
            for (Stmt p : ao.putItem) {
                method.stmts.remove(p);
            }
            Cfg.TravelCallBack tcb = new Cfg.TravelCallBack() {
                @Override
                public Value onAssign(Local v, AssignStmt as) {
                    return v;
                }

                @Override
                public Value onUse(Local v) {
                    if (local0 == v) {
                        FilledArrayExpr fae = Exprs.nFilledArray(ao.type, t);
                        filledArrayExprs.add(fae);
                        return fae;
                    }
                    return v;
                }
            };

            if (ao.used.size() == 1) {
                Stmt stmt = ao.used.get(0);
                if (method.stmts.contains(stmt)) { // the stmt is not removed by pre array replacement
                    Cfg.travelMod(stmt, tcb, false);
                } else {
                    int size = filledArrayExprs.size();
                    for (int i = 0; i < size; i++) {
                        Cfg.travelMod(filledArrayExprs.get(i), tcb);
                    }
                }
            } else if (ao.used.size() == 0) {
                // the array is never used, ignore
            } else {
                throw new RuntimeException("array is used multiple times");
            }
        }
    }

    // FIXME poor performance
    private void makeSureArrayUsedAfterAllElementAssigned(IrMethod method, final Map<Local, ArrayObject> arraySizes) {

        for (Local local : method.locals) {
            local._ls_index = -1;
        }
        final int MAX = 50;
        if (arraySizes.size() < MAX) {
            makeSureArrayUsedAfterAllElementAssigned0(method, arraySizes);
        } else {

            // this method consumes too many memory, case 'java.lang.OutOfMemoryError: Java heap space', we have to cut
            // it
            Map<Local, ArrayObject> keptInAll = new HashMap<>();
            Map<Local, ArrayObject> keptInPart = new HashMap<>();
            List<Local> arrays = new ArrayList<>(MAX);

            Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator();
            while (it.hasNext()) {
                for (int i = 0; i < MAX && it.hasNext(); i++) {
                    Map.Entry<Local, ArrayObject> e = it.next();
                    keptInPart.put(e.getKey(), e.getValue());
                    it.remove();
                    arrays.add(e.getKey());
                }
                makeSureArrayUsedAfterAllElementAssigned0(method, keptInPart);
                for (Local local : arrays) {
                    local._ls_index = -1;
                }
                arrays.clear();
                keptInAll.putAll(keptInPart);
                keptInPart.clear();
            }
            arraySizes.putAll(keptInAll);
        }

        Cfg.reIndexLocal(method);

    }

    private void makeSureArrayUsedAfterAllElementAssigned0(IrMethod method, final Map<Local, ArrayObject> arraySizes) {
        int i = 0;
        for (Local local : arraySizes.keySet()) {
            local._ls_index = i++;
        }

        final int size = i;
        final List<ArrayObjectValue> values = new ArrayList<>();
        Cfg.dfs(method.stmts, new Cfg.FrameVisitor<ArrayObjectValue[]>() {

            @Override
            public ArrayObjectValue[] merge(ArrayObjectValue[] srcFrame, ArrayObjectValue[] distFrame, Stmt src,
                    Stmt dist) {
                if (distFrame == null) {
                    distFrame = new ArrayObjectValue[size];
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        if (arc != null) {
                            ArrayObjectValue aov = new ArrayObjectValue(arc.local);
                            values.add(aov);
                            aov.array = arc.array;
                            aov.parent = arc;
                            aov.pos = (BitSet) arc.pos.clone();
                            distFrame[i] = aov;
                        }
                    }
                } else {
                    for (int i = 0; i < size; i++) {
                        ArrayObjectValue arc = srcFrame[i];
                        ArrayObjectValue aov = distFrame[i];
                        if (arc != null && aov != null) {
                            if (aov.otherParent == null) {
                                aov.otherParent = new HashSet<>();
                            }
                            aov.otherParent.add(arc);
                        }
                    }
                }
                return distFrame;
            }

            @Override
            public ArrayObjectValue[] initFirstFrame(Stmt first) {
                return new ArrayObjectValue[size];
            }

            ArrayObjectValue tmp[] = initFirstFrame(null);
            Stmt currentStmt;

            @Override
            public ArrayObjectValue[] exec(ArrayObjectValue[] frame, Stmt stmt) {
                currentStmt = stmt;
                System.arraycopy(frame, 0, tmp, 0, size);
                if (stmt.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (stmt.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) stmt.getOp1();
                        if (local._ls_index >= 0) {
                            ArrayObjectValue av = tmp[local._ls_index];
                            Constant cst = (Constant) stmt.getOp2();
                            int endPos = Array.getLength(cst.value);
                            av.pos.set(0, endPos);
                        }
                    } else {
                        use(stmt.getOp1());
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.ARRAY) {
                    use(stmt.getOp2());
                    ArrayExpr ae = (ArrayExpr) stmt.getOp1();
                    if (ae.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) ae.getOp1();
                        if (local._ls_index >= 0) {
                            int index = ((Number) ((Constant) ae.getOp2()).value).intValue();
                            ArrayObjectValue av = tmp[local._ls_index];
                            av.pos.set(index);
                        } else {
                            use(ae);
                        }
                    } else {
                        use(ae);
                    }
                } else if (stmt.st == Stmt.ST.ASSIGN && stmt.getOp1().vt == Value.VT.LOCAL) {
                    Local local = (Local) stmt.getOp1();
                    use(stmt.getOp2());

                    if (local._ls_index >= 0) {
                        ArrayObjectValue aov = new ArrayObjectValue(local);
                        aov.array = arraySizes.get(local);
                        aov.pos = new BitSet();
                        values.add(aov);
                        tmp[local._ls_index] = aov;
                    }
                } else {
                    switch (stmt.et) {
                    case E0:
                        break;
                    case E1:
                        use(stmt.getOp());
                        break;
                    case E2:
                        use(stmt.getOp1());
                        use(stmt.getOp2());
                        break;
                    case En:
                        throw new RuntimeException();
                    }
                }
                return tmp;
            }

            private void use(Value v) {
                switch (v.et) {
                case E0:
                    if (v.vt == Value.VT.LOCAL) {
                        Local local = (Local) v;
                        if (local._ls_index >= 0) {
                            ArrayObjectValue aov = tmp[local._ls_index];
                            aov.array.used.add(currentStmt);
                            aov.used = true;
                        }
                    }
                    break;
                case E1:
                    use(v.getOp());
                    break;
                case E2:
                    use(v.getOp1());
                    use(v.getOp2());
                    break;
                case En:
                    for (Value op : v.getOps()) {
                        use(op);
                    }
                    break;
                }
            }
        });

        Set<ArrayObjectValue> used = markUsed(values);

        // check if ArrayObjectValue have different parent assignment
        for (ArrayObjectValue avo : used) {
            if (avo.array.used.size() > 1) {
                arraySizes.remove(avo.local);
            } else {
                if (avo.parent != null && avo.otherParent != null) {
                    // BitSet bs = avo.pos;
                    BitSet p = avo.parent.pos;
                    for (ArrayObjectValue ps : avo.otherParent) {
                        if (!p.equals(ps.pos)) {
                            arraySizes.remove(avo.local);
                            break;
                        }
                    }
                }
            }
        }
        // check for un full init array
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            Local local = e.getKey();
            ArrayObject arrayObject = e.getValue();
            for (Stmt use : arrayObject.used) {
                ArrayObjectValue frame[] = (ArrayObjectValue[]) use.frame;
                ArrayObjectValue aov = frame[local._ls_index];
                BitSet pos = aov.pos;
                if (pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                    it.remove();
                    break;
                }
            }
        }

        // clean up
        for (Stmt stmt : method.stmts) {
            stmt.frame = null;
        }
    }

    protected Set<ArrayObjectValue> markUsed(Collection<ArrayObjectValue> values) {
        Set<ArrayObjectValue> used = new HashSet<>(values.size() / 2);
        Queue<ArrayObjectValue> q = new UniqueQueue<>();
        q.addAll(values);
        values.clear();
        while (!q.isEmpty()) {
            ArrayObjectValue v = q.poll();
            if (v.used) {
                if (used.contains(v)) {
                    continue;
                }
                used.add(v);
                {
                    ArrayObjectValue p = v.parent;
                    if (p != null) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }
                if (v.otherParent != null) {
                    for (ArrayObjectValue p : v.otherParent) {
                        if (!p.used) {
                            p.used = true;
                            q.add(p);
                        }
                    }
                }
            }
        }

        return used;
    }

    private void makeSureAllElementAreAssigned(Map<Local, ArrayObject> arraySizes) {
        BitSet pos = new BitSet();
        for (Iterator<Map.Entry<Local, ArrayObject>> it = arraySizes.entrySet().iterator(); it.hasNext();) {
            Map.Entry<Local, ArrayObject> e = it.next();
            ArrayObject arrayObject = e.getValue();
            boolean needRemove = false;
            for (Stmt p : arrayObject.putItem) {
                if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    int endPos = Array.getLength(((Constant) p.getOp2()).value);
                    int next = pos.nextSetBit(0);
                    if (next < 0 || next >= endPos) {// not set in range
                        pos.set(0, endPos);
                    } else {// setted in range
                        needRemove = true;
                        break;
                    }
                } else { // ASSIGN
                    ArrayExpr ae = (ArrayExpr) p.getOp1();
                    int idx = ((Number) ((Constant) ae.getOp2()).value).intValue();
                    if (!pos.get(idx)) {
                        pos.set(idx);
                    } else {
                        needRemove = true;
                        break;
                    }
                }
            }
            if (needRemove || pos.nextClearBit(0) < arrayObject.size || pos.nextSetBit(arrayObject.size) >= 0) {
                it.remove();
            }
            pos.clear();
        }
    }

    private Map<Local, ArrayObject> searchForArrayObject(IrMethod method) {

        final Map<Local, ArrayObject> arraySizes = new HashMap<>();
        if (method.locals.size() == 0) {
            return arraySizes;
        }
        Cfg.createCFG(method);
        Cfg.dfsVisit(method, new Cfg.DfsVisitor() {
            @Override
            public void onVisit(Stmt p) {
                if (p.st == Stmt.ST.ASSIGN) {
                    if (p.getOp2().vt == Value.VT.NEW_ARRAY && p.getOp1().vt == Value.VT.LOCAL) {
                        TypeExpr ae = (TypeExpr) p.getOp2();
                        if (ae.getOp().vt == Value.VT.CONSTANT) {
                            int size = ((Number) ((Constant) ae.getOp()).value).intValue();

                            // https://bitbucket.org/pxb1988/dex2jar/issues/2/decompiler-error
                            // the following code may used in a java
                            // try{
                            //   new int[-1];
                            // } catch(Exception e) {
                            //   ...
                            // }
                            if (size >= 0) {
                                arraySizes.put((Local) p.getOp1(), new ArrayObject(size, ae.type, (AssignStmt) p));
                            }
                        }
                    } else if (p.getOp1().vt == Value.VT.ARRAY) {
                        ArrayExpr ae = (ArrayExpr) p.getOp1();
                        if (ae.getOp1().vt == Value.VT.LOCAL) {
                            Local local = (Local) ae.getOp1();
                            ArrayObject arrayObject = arraySizes.get(local);
                            if (arrayObject != null) {
                                if (ae.getOp2().vt == Value.VT.CONSTANT) {
                                    arrayObject.putItem.add(p);
                                } else {
                                    arraySizes.remove(local);
                                }
                            }
                        }
                    }
                } else if (p.st == Stmt.ST.FILL_ARRAY_DATA) {
                    if (p.getOp1().vt == Value.VT.LOCAL) {
                        Local local = (Local) p.getOp1();
                        ArrayObject arrayObject = arraySizes.get(local);
                        if (arrayObject != null) {
                            arrayObject.putItem.add(p);
                        }
                    }
                }
            }
        });
        if (arraySizes.size() > 0) {
            Set<Local> set = new HashSet<Local>();
            if (method.phiLabels != null) {
                for (LabelStmt labelStmt : method.phiLabels) {
                    if (labelStmt.phis != null) {
                        for (AssignStmt as : labelStmt.phis) {
                            set.add((Local) as.getOp1());
                            for (Value v : as.getOp2().getOps()) {
                                set.add((Local) v);
                            }
                        }
                    }
                }
            }
            if (set.size() > 0) {
                for (Local local : set) {
                    arraySizes.remove(local);
                }
            }
        }
        return arraySizes;
    }

    static class ArrayObjectValue {
        BitSet pos;
        Local local;
        ArrayObject array;
        ArrayObjectValue parent;
        Set<ArrayObjectValue> otherParent;
        boolean used;

        public ArrayObjectValue(Local local) {
            this.local = local;
        }
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/AggTransformerTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import static com.googlecode.dex2jar.ir.expr.Exprs.*;
import static com.googlecode.dex2jar.ir.stmt.Stmts.*;

import org.junit.Assert;
import org.junit.Test;

import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.ts.AggTransformer;
import com.googlecode.dex2jar.ir.ts.SSATransformer;

public class AggTransformerTest extends BaseTransformerTest<AggTransformer> {
    @Test
    public void t001() {
        Local a = addLocal("a");
        addStmt(nAssign(a, nNewIntArray(nInt(5))));
        addStmt(nReturn(a));
        transform();
        Assert.assertEquals("only `return new int[5]` should left.", 1, stmts.getSize());
        Assert.assertEquals("no local should left", 0, locals.size());
    }

    @Test
    public void t002() {

        Local a = addLocal("a");
        Local b = addLocal("b");
        Local c = addLocal("c");

        addStmt(nAssign(a, nNewIntArray(nInt(5))));
        addStmt(nAssign(b, nInt(2)));
        addStmt(nAssign(c, nArray(a, b, "I")));
        addStmt(nReturn(c));
        transform();
        Assert.assertTrue(stmts.getSize() == 1);
        Assert.assertTrue(locals.size() == 0);
    }

    @Test
    public void test04() {

        Local array = addLocal("array");
        Local index = addLocal("index");
        Local value = addLocal("value");

        addStmt(nAssign(array, nNewIntArray(nInt(5))));
        addStmt(nAssign(index, niAdd(nInt(1999), nInt(3))));
        addStmt(nAssign(value, niAdd(index, nInt(4))));
        addStmt(nAssign(nArray(array, index, "I"), value));
        addStmt(nReturnVoid());

        transform();

        Assert.assertTrue(method.locals.size() >= 2);
    }

    @Test
    public void test05() {
        String sbType = "Ljava/lang/StringBuilder;";
        String sType = "Ljava/lang/String;";

        Local b = addLocal("b");
        Local ex = addLocal("ex");
        Local c = addLocal("c");
        Local d = addLocal("d");
        Local e = addLocal("e");
        Local cst = addLocal("cst");

        addStmt(nAssign(b, nString("123")));
        addStmt(nAssign(c, Exprs.nInvokeNew(new Value[0], new String[0], sbType)));
        addStmt(nAssign(d, c));
        addStmt(nAssign(cst, nString("p1")));
        addStmt(nAssign(c,
                Exprs.nInvokeVirtual(new Value[] { d, cst }, sbType, "append", new String[] { sType }, sbType)));
        addStmt(nAssign(e, c));
        addStmt(nAssign(cst, nString("p2")));
        addStmt(nAssign(c,
                Exprs.nInvokeVirtual(new Value[] { e, cst }, sbType, "append", new String[] { sType }, sbType)));
        addStmt(nAssign(c, Exprs.nInvokeVirtual(new Value[] { c }, sbType, "toString", new String[0], sType)));

        addStmt(nReturn(c));
        new SSATransformer().transform(method);
        transform();
        Assert.assertTrue(stmts.getSize() == 1);
        Assert.assertTrue(locals.size() == 0);
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/BaseTransformerTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.List;

import com.googlecode.dex2jar.ir.stmt.*;
import org.junit.After;
import org.junit.Before;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.ts.Transformer;

public abstract class BaseTransformerTest<T extends Transformer> {

    protected void transform() {
        transformer.transform(this.method);
    }

    @Override
    public String toString() {
        return method.toString();
    }

    int labelIndex = 0;

    protected LabelStmt newLabel() {
        LabelStmt label = Stmts.nLabel();
        label.displayName = "L" + labelIndex++;
        return label;
    }

    public BaseTransformerTest() {
        super();
        Class<?> clz = getClass();
        ParameterizedType t = (ParameterizedType) clz.getGenericSuperclass();
        Class<?> transformerType = (Class<?>) t.getActualTypeArguments()[0];

        try {
            this.transformer = (Transformer) transformerType.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    final protected Transformer transformer;
    protected IrMethod method = new IrMethod();
    protected StmtList stmts;
    protected List<Local> locals;


    public Local addLocal(String name) {
        Local local = Exprs.nLocal(name);
        method.locals.add(local);
        return local;
    }

    public <D extends Stmt> D addStmt(D stmt) {
        method.stmts.add(stmt);
        return stmt;
    }

    public AssignStmt attachPhi(LabelStmt labelStmt, AssignStmt phi) {
        List<AssignStmt> s = labelStmt.phis;
        if (s == null) {
            labelStmt.phis = s = new ArrayList<>();
        }
        s.add(phi);
        if (method.phiLabels == null) {
            method.phiLabels = new ArrayList<>();
        }
        if (!method.phiLabels.contains(labelStmt)) {
            method.phiLabels.add(labelStmt);
        }
        return phi;
    }
    
    public void initMethod(boolean isStatic, String ret, String... args) {
        method.ret = ret;
        method.args = args;
        method.isStatic = isStatic;
    }

    @After
    public void reset() {
        method = null;
        stmts = null;
        locals = null;
        labelIndex = 0;
    }

    @Before
    public void setup() {
        method = new IrMethod();
        method.owner = "La/Clz;";
        method.name = "call";
        method.ret = "V";
        method.isStatic = true;
        method.args = new String[0];
        stmts = method.stmts;
        locals = method.locals;
    }

}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/ConstTransformerTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import static com.googlecode.dex2jar.ir.expr.Exprs.nLocal;
import static com.googlecode.dex2jar.ir.expr.Exprs.nString;
import static com.googlecode.dex2jar.ir.stmt.Stmts.nAssign;
import static com.googlecode.dex2jar.ir.stmt.Stmts.nReturn;

import org.junit.Assert;
import org.junit.Test;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Constant;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.UnopStmt;
import com.googlecode.dex2jar.ir.ts.ConstTransformer;

public class ConstTransformerTest {

    @Test
    public void test00() {
        IrMethod jm = new IrMethod();

        Local a = nLocal("a");
        jm.locals.add(a);
        jm.stmts.add(nAssign(a, nString("a String")));
        UnopStmt retStmt = nReturn(a);
        jm.stmts.add(retStmt);
        new ConstTransformer().transform(jm);

        Assert.assertTrue(jm.locals.size() == 1);
        Assert.assertTrue(jm.stmts.getSize() == 2);
        Assert.assertEquals("a String", ((Constant) retStmt.op.trim()).value);
    }

    @Test
    public void test01() {// local in phi
        IrMethod jm = new IrMethod();

        Local a = nLocal("a");
        Local p = nLocal("p");
        jm.locals.add(a);
        jm.locals.add(p);
        jm.stmts.add(nAssign(a, nString("a String")));
        jm.stmts.add(nAssign(p, Exprs.nPhi(a)));
        UnopStmt retStmt = nReturn(p);
        jm.stmts.add(retStmt);
        new ConstTransformer().transform(jm);

        Assert.assertTrue(jm.locals.size() == 2);
        Assert.assertTrue(jm.stmts.getSize() == 3);
        Assert.assertEquals("a String", ((Constant) retStmt.op.trim()).value);
    }

    @Test
    public void test02() {// test local loop
        IrMethod jm = new IrMethod();

        Local a = nLocal("a");
        Local p = nLocal("p");
        Local q = nLocal("q");
        jm.locals.add(a);
        jm.locals.add(p);
        jm.locals.add(q);
        jm.stmts.add(nAssign(a, nString("a String")));
        jm.stmts.add(nAssign(p, Exprs.nPhi(a, q)));
        jm.stmts.add(nAssign(q, Exprs.nPhi(p)));
        UnopStmt retStmt = nReturn(q);
        jm.stmts.add(retStmt);
        new ConstTransformer().transform(jm);

        Assert.assertTrue(jm.locals.size() == 3);
        Assert.assertTrue(jm.stmts.getSize() == 4);
        Assert.assertEquals("a String", ((Constant) retStmt.op.trim()).value);
    }

    @Test
    public void test03() {// test local loop
        IrMethod jm = new IrMethod();

        Local a = nLocal("a");
        Local b = nLocal("b");
        Local p = nLocal("p");
        jm.locals.add(a);
        jm.locals.add(b);
        jm.locals.add(p);
        jm.stmts.add(nAssign(a, nString("a String")));
        jm.stmts.add(nAssign(b, nString("b String")));
        jm.stmts.add(nAssign(p, Exprs.nPhi(a, b)));
        UnopStmt retStmt = nReturn(p);
        jm.stmts.add(retStmt);
        new ConstTransformer().transform(jm);

        Assert.assertTrue(jm.locals.size() == 3);
        Assert.assertTrue(jm.stmts.getSize() == 4);
        Assert.assertEquals(p, retStmt.op.trim());
    }

    @Test
    public void test04() {
        IrMethod jm = new IrMethod();

        Local a = nLocal("a");
        Local b = nLocal("b");
        Local p = nLocal("p");
        jm.locals.add(a);
        jm.locals.add(b);
        jm.locals.add(p);
        jm.stmts.add(nAssign(a, nString(new String("a String"))));
        jm.stmts.add(nAssign(b, nString(new String("a String"))));
        jm.stmts.add(nAssign(p, Exprs.nPhi(a, b)));
        UnopStmt retStmt = nReturn(p);
        jm.stmts.add(retStmt);
        new ConstTransformer().transform(jm);

        Assert.assertTrue(jm.locals.size() == 3);
        Assert.assertTrue(jm.stmts.getSize() == 4);
        Assert.assertEquals(VT.CONSTANT, retStmt.op.vt);
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/ConstantStringTest.java`:

```java
package com.googlecode.dex2jar.ir.test;


import com.googlecode.dex2jar.ir.expr.Exprs;
import org.junit.Assert;
import org.junit.Test;

public class ConstantStringTest {
    @Test
    public void test() {
        String s = Exprs.nString("a\nb").toString();
        Assert.assertEquals("\"a\\nb\"", s);
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/DeadCodeTrnasformerTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmts;
import com.googlecode.dex2jar.ir.ts.DeadCodeTransformer;
import org.junit.Assert;
import org.junit.Test;

public class DeadCodeTrnasformerTest extends BaseTransformerTest<DeadCodeTransformer> {
    @Test
    public void test09DeadCode() {
        Stmt ret = addStmt(Stmts.nReturnVoid());
        Stmt lb = addStmt(newLabel());
        addStmt(Stmts.nReturnVoid());
        transform();
        Assert.assertSame(ret, method.stmts.getFirst());
        Assert.assertSame(ret, method.stmts.getLast());
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/JimpleTransformerTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import static com.googlecode.dex2jar.ir.expr.Exprs.nAdd;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInt;
import static com.googlecode.dex2jar.ir.stmt.Stmts.nReturn;

import org.junit.Assert;
import org.junit.Test;

import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.Stmts;
import com.googlecode.dex2jar.ir.ts.JimpleTransformer;

public class JimpleTransformerTest extends BaseTransformerTest<JimpleTransformer> {

    /**
     * test for return 1+2+3;
     */
    @Test
    public void test00Base() {
        initMethod(true, "I");
        addStmt(nReturn(nAdd(nAdd(nInt(1), nInt(2), "I"), nInt(3), "I")));
        transform();

        Assert.assertEquals("should expends to 3 stmts", 3, method.stmts.getSize());
        Assert.assertEquals("should expends to 2 locals", 2, method.locals.size());

        // System.out.println(super.method);
    }

    /**
     * test for System.out.print("Hello JNI");
     */
    @Test
    public void test01HelloWord() {
        initMethod(true, "V");
        addStmt(Stmts.nVoidInvoke(Exprs.nInvokeVirtual(
                new Value[] {//
                Exprs.nStaticField("Ljava/lang/System;", "out", "Ljava/io/PrintStream;"),//
                        Exprs.nString("Hello JNI") }, "Ljava/io/PrintStream;", "println",
                new String[] { "Ljava/lang/String;" }, "V")));
        transform();
        Assert.assertEquals("should expends to 3 stmts", 3, method.stmts.getSize());
        Assert.assertEquals("should expends to 2 locals", 2, method.locals.size());

        // System.out.println(super.method);
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/RemoveConstantFromSSATest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.StmtList;
import com.googlecode.dex2jar.ir.ts.AggTransformer;
import com.googlecode.dex2jar.ir.ts.RemoveConstantFromSSA;
import org.junit.Assert;
import org.junit.Test;

import static com.googlecode.dex2jar.ir.expr.Exprs.*;
import static com.googlecode.dex2jar.ir.stmt.Stmts.*;

public class RemoveConstantFromSSATest extends BaseTransformerTest<RemoveConstantFromSSA> {
    @Test
    public void t001() {
        Local a = addLocal("a");
        Local b = addLocal("b");
        Local c1 = addLocal("c1");
        Local c2 = addLocal("c2");
        Local cphi = addLocal("cphi");
        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();

        Stmt sa = addStmt(nAssign(a, nInt(5)));
        Stmt sb = addStmt(nAssign(b, nInt(6)));
        addStmt(nIf(niGt(a, b), L1));
        addStmt(nAssign(c1, a));
        addStmt(nGoto(L2));
        addStmt(L1);
        addStmt(nAssign(c2, b));
        addStmt(L2);
        attachPhi(L2, nAssign(cphi, Exprs.nPhi(c1, c2)));
        addStmt(nReturn(cphi));

        transform();
        Assert.assertFalse("SA should remove from method", method.stmts.contains(sa));
        Assert.assertFalse("SB should remove from method", method.stmts.contains(sb));
    }

    @Test
    public void t002() {
        Local a = addLocal("a");
        addStmt(nAssign(a, nInt(5)));
        addStmt(nReturn(a));

        transform();
        Assert.assertTrue("no local should kept", locals.size() == 0);
    }

    @Test
    public void t003() {

        Local a = addLocal("a");
        Local b = addLocal("b");
        Local c = addLocal("c");

        addStmt(nAssign(a, nNewIntArray(nInt(5))));
        addStmt(nAssign(b, nInt(2)));
        addStmt(nAssign(c, nArray(a, b, "I")));
        addStmt(nReturn(c));
        transform();
        Assert.assertTrue("local b should removed", !locals.contains(b));
        Assert.assertTrue(locals.size() == 2);
    }

    @Test
    public void t004() {

        Local a0 = addLocal("a0");
        Local a1 = addLocal("a1");
        Local ax = addLocal("aX");

        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();
        addStmt(nIf(niGt(nInt(100), nInt(0)), L1));
        addStmt(nAssign(a0, nString("123")));
        addStmt(nGoto(L2));
        addStmt(L1);
        addStmt(nAssign(a1, nNull()));
        addStmt(L2);
        attachPhi(L2, nAssign(ax, Exprs.nPhi(a0, a1)));
        addStmt(nReturn(ax));

        transform();
        Assert.assertEquals("all local should kept", 3, locals.size());
    }

    @Test
    public void t005PhiValueEqual() {

        Local a0 = addLocal("a0");
        Local a1 = addLocal("a1");
        Local ax = addLocal("aX");

        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();
        addStmt(nIf(niGt(nInt(100), nInt(0)), L1));
        addStmt(nAssign(a0, nString("123")));
        addStmt(nGoto(L2));
        addStmt(L1);
        addStmt(nAssign(a1, nString("123")));
        addStmt(L2);
        attachPhi(L2, nAssign(ax, Exprs.nPhi(a0, a1)));
        Stmt ret = addStmt(nReturn(ax));

        transform();
        Assert.assertTrue("should return '123'", ret.getOp().vt == Value.VT.CONSTANT);
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/RemoveLocalFromSSATest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.ts.RemoveLocalFromSSA;
import org.junit.Assert;
import org.junit.Test;

import static com.googlecode.dex2jar.ir.expr.Exprs.nInt;
import static com.googlecode.dex2jar.ir.stmt.Stmts.nAssign;
import static com.googlecode.dex2jar.ir.stmt.Stmts.nReturn;

public class RemoveLocalFromSSATest extends BaseTransformerTest<RemoveLocalFromSSA> {
    @Test
    public void t001() {

        Local a = addLocal("a");
        Local b = addLocal("b");
        Local c = addLocal("c");

        Stmt sa = addStmt(nAssign(a, nInt(0)));
        addStmt(nAssign(b, a));
        addStmt(nAssign(c, b));
        Stmt sb = addStmt(nReturn(c));
        transform();
        Assert.assertEquals(sa.getOp1(), sb.getOp());
        Assert.assertEquals("1 local should left", 1, locals.size());
    }


}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/SSATransformerTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import static com.googlecode.dex2jar.ir.expr.Exprs.*;
import static com.googlecode.dex2jar.ir.stmt.Stmts.*;

import org.junit.Assert;
import org.junit.Test;

import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.*;
import com.googlecode.dex2jar.ir.ts.RemoveLocalFromSSA;
import com.googlecode.dex2jar.ir.ts.SSATransformer;

public class SSATransformerTest extends BaseTransformerTest<SSATransformer> {

    /**
     * base test
     */
    @Test
    public void test00Base() {

        Local b = addLocal("b");

        AssignStmt st1 = addStmt(nAssign(b, nString("123")));
        AssignStmt st2 = addStmt(nAssign(b, nNull()));
        UnopStmt st3 = addStmt(nReturn(b));

        transform();

        Assert.assertSame(st2.op1, st3.op);
        Assert.assertNotSame("st1 and st1 must be cut", st1.op1, st2.op1);
        Assert.assertTrue(method.locals.size() == 2);
    }

    /**
     * Test for huge local and stmt size
     */
    @Test
    public void test01HugeLocalStmt() {
        for (int i = 0; i < 2000; i++) {
            Local b = addLocal("a");
            addStmt(nAssign(b, nString("123")));
        }
        Local b = addLocal("a");
        for (int i = 0; i < 20000; i++) {
            addStmt(nAssign(b, nString("123")));
        }
        addStmt(nReturn(b));
        transform();
    }

    /**
     * test for Phi insert
     */
    @Test
    public void test05PhiInGoto() {

        Local b = addLocal("a");

        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();
        addStmt(nIf(niGt(nInt(100), nInt(0)), L1));
        addStmt(nAssign(b, nString("123")));
        addStmt(nGoto(L2));
        addStmt(L1);
        addStmt(nAssign(b, nNull()));
        addStmt(L2);
        addStmt(nReturn(b));

        transform();
        Assert.assertEquals(3, method.locals.size());// phi inserted
        assertPhiStmt(L2);
    }

    @Test
    public void test06PhiInTrap() {
        String exType = "Ljava/lang/Exception;";
        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();
        LabelStmt L3 = newLabel();
        LabelStmt L4 = newLabel();
        method.traps.add(new Trap(L1, L2, new LabelStmt[] { L3 }, new String[] { exType }));

        Local b = addLocal("a");
        Local ex = addLocal("ex");

        addStmt(L1);
        addStmt(nAssign(b, nString("123")));
        addStmt(Stmts.nLock(b));
        addStmt(L2);
        addStmt(nGoto(L4));
        addStmt(L3);
        addStmt(nIdentity(ex, nExceptionRef(exType)));
        addStmt(nAssign(b, nNull()));
        addStmt(L4);
        addStmt(nReturn(b));

        transform();
        Assert.assertEquals(4, method.locals.size());// phi inserted
        assertPhiStmt(L4);
    }

    public void transform(){
        super.transform();
        new RemoveLocalFromSSA().transform(method);
    }

    @Test
    public void test07MergeAtFirst() {

        LabelStmt L0 = newLabel();
        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();
        LabelStmt L3 = newLabel();

        Local b = addLocal("b");
        Local c = addLocal("c");

        addStmt(Stmts.nIf(Exprs.niEq(nInt(1), nInt(2)), L0));
        addStmt(nAssign(b, nInt(3)));
        addStmt(nGoto(L1));
        addStmt(L0);
        addStmt(nAssign(b, nInt(4)));
        addStmt(L1);
        addStmt(Stmts.nIf(Exprs.niEq(nInt(1), nInt(2)), L2));
        addStmt(Stmts.nReturnVoid());
        addStmt(L2);
        addStmt(Stmts.nIf(Exprs.niEq(nInt(1), nInt(2)), L3));
        addStmt(Stmts.nAssign(c,
                Exprs.nInvokeStatic(new Value[] { b }, "Ljava/lang/String;", "someMethod", new String[] { "I" }, "V")));
        addStmt(Stmts.nReturnVoid());
        addStmt(L3);

        addStmt(Stmts.nReturnVoid());

        transform();

        Assert.assertEquals(4, method.locals.size());
        assertPhiStmt(L1);

    }

    @Test
    public void test03NotInsertPhiInLoop() {

        Local b = addLocal("a");

        addStmt(nAssign(b, nString("123")));
        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();
        addStmt(L1);
        addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L2));
        addStmt(Stmts.nNop());
        addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L1));
        addStmt(L2);
        addStmt(nReturn(b));

        transform();
        Assert.assertEquals(1, method.locals.size());
    }

    @Test
    public void test04NotInsertPhiLoop2() {

        Local b = addLocal("a");

        addStmt(nAssign(b, nString("123")));
        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();
        addStmt(L1);
        addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L2));
        addStmt(Stmts.nNop());
        addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L1));
        addStmt(Stmts.nNop());
        addStmt(L2);
        addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L1));
        addStmt(Stmts.nNop());

        addStmt(nReturn(b));

        transform();
        Assert.assertTrue("no phi should add", method.locals.size() == 1);
    }

    @Test
    public void test02NotInsertPhi() {

        Local b = addLocal("a");
        addStmt(nAssign(b, nString("123")));
        LabelStmt L1 = newLabel();
        addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L1));
        addStmt(Stmts.nNop());
        addStmt(L1);
        addStmt(nReturn(b));

        transform();
        Assert.assertEquals(1, method.locals.size());
    }

    /**
     * test for
     * 
     * <pre>
     * if (xxx) {
     *     a = 1;
     * } else {
     *     a = 2;
     * }// phi here
     * 
     * if (xxx) {
     *     if (xxx) {
     *         a = 3;
     *     }// phi here
     *     return a;
     * } else {
     *     if (xxx) {
     *         a = 4;
     *     } // phi here
     *     return a;
     * }
     * </pre>
     */
    @Test
    public void test08() {

        Local a = addLocal("a");
        LabelStmt L0 = newLabel();
        LabelStmt L1 = newLabel();
        LabelStmt L2 = newLabel();
        LabelStmt L3 = newLabel();
        LabelStmt L4 = newLabel();
        LabelStmt L5 = newLabel();
        {// if-else
            addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L0));
            {
                addStmt(nAssign(a, nString("1")));
            }
            addStmt(Stmts.nGoto(L1));
            addStmt(L0);
            {
                addStmt(nAssign(a, nString("2")));
            }
            addStmt(L1);// expect a phi here
        }

        {// if-else
            addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L2));
            {
                { // if
                    addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L4));
                    addStmt(nAssign(a, nString("3")));
                    addStmt(L4);
                }
                addStmt(nReturn(a));
            }
            addStmt(Stmts.nGoto(L3));
            addStmt(L2);
            {
                { // if
                    addStmt(Stmts.nIf(Exprs.niEq(nInt(0), nInt(9)), L5));
                    addStmt(nAssign(a, nString("4")));
                    addStmt(L5);
                }
                addStmt(nReturn(a));
            }
            addStmt(L3);
        }
        transform();

        assertPhiStmt(L1);
        assertPhiStmt(L4);
        assertPhiStmt(L5);
        Assert.assertEquals(7, method.locals.size());// 4 assign + 3 phi
    }

    private void assertPhiStmt(LabelStmt label) {
        Assert.assertNotNull(label.phis);
        Assert.assertTrue(label.phis.size() > 0);
    }

    /**
     * for
     * 
     * <pre>
     *     a=12;
     *     b=34;
     *     c=a;
     *     if c1=0 goto L1:
     *     c=b;
     *     L1:
     *     return c;
     * 
     * </pre>
     * 
     */
    @Test
    public void test11NotDeleteAssignWherePhiIsConfused() {
        Local a = addLocal("a");
        Local b = addLocal("b");
        Local c = addLocal("c");
        LabelStmt L1 = nLabel();
        addStmt(nAssign(a, nString("12")));
        addStmt(nAssign(b, nString("34")));
        addStmt(nAssign(c, a));
        Stmt jmp = addStmt(nIf(njGt(c, nInt(0)), L1));
        addStmt(nAssign(c, b));
        addStmt(L1);
        addStmt(Stmts.nReturn(c));
        transform();

        Assert.assertNotSame("the c=b should not deleted", jmp.getNext(), L1);
    }

}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/StmtListTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import static com.googlecode.dex2jar.ir.expr.Exprs.nCast;
import static com.googlecode.dex2jar.ir.expr.Exprs.nGt;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInt;
import static com.googlecode.dex2jar.ir.expr.Exprs.nLocal;
import static com.googlecode.dex2jar.ir.expr.Exprs.nParameterRef;
import static com.googlecode.dex2jar.ir.expr.Exprs.nThisRef;

import org.junit.Test;

import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.StmtList;
import com.googlecode.dex2jar.ir.stmt.Stmts;

public class StmtListTest {
    @Test
    public void toStringTest() {

        StmtList list = new StmtList();
        Local a = nLocal("this");
        Local b = nLocal("b");
        Local c = nLocal("c");
        Local d = nLocal("d");
        LabelStmt L1 = Stmts.nLabel();

        list.add(Stmts.nIdentity(a, nThisRef("La/Some;")));
        list.add(Stmts.nIdentity(b, nParameterRef("I", 0)));
        list.add(Stmts.nIdentity(c, nParameterRef("J", 1)));
        list.add(Stmts.nIdentity(d, nParameterRef("F", 2)));
        list.add(Stmts.nIf(nGt(b, nInt(0), "I"), L1));
        list.add(Stmts.nAssign(c, nCast(d, "F", "J")));
        list.add(L1);
        list.toString();
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/TypeTransformerTest.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.ir.test;

import com.googlecode.dex2jar.ir.TypeClass;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.AssignStmt;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.UnopStmt;
import com.googlecode.dex2jar.ir.ts.TypeTransformer;
import org.junit.Assert;
import org.junit.Test;

import static com.googlecode.dex2jar.ir.expr.Exprs.*;
import static com.googlecode.dex2jar.ir.stmt.Stmts.*;

public class TypeTransformerTest extends BaseTransformerTest<TypeTransformer> {
    /**
     * base test
     */
    @Test
    public void test00Base() {
        initMethod(true, "Ljava/lang/Object;");
        Local b = addLocal("b");

        addStmt(nAssign(b, nString("123")));
        addStmt(nReturn(b));

        transform();
        Assert.assertEquals("", "L", b.valueType.substring(0, 1));
    }

    @Test
    public void test1Const() {
        initMethod(true, "F");
        Local b = addLocal("b");

        AssignStmt st1 = addStmt(nAssign(b, nInt(0)));
        UnopStmt st3 = addStmt(nReturn(b));
        transform();
        Assert.assertEquals("", b.valueType, "F");
    }

    @Test
    public void test2byte() {
        initMethod(true, "V");
        Local b = addLocal("b");

        addStmt(nAssign(b, nStaticField("La;", "z", "B")));
        addStmt(nVoidInvoke(nInvokeStatic(new Value[] { b }, "La;", "y", new String[] { "I" }, "V")));
        addStmt(nAssign(nStaticField("La;", "z", "B"), b));
        addStmt(nReturnVoid());
        transform();
        // FIXME fix type detect
        // Assert.assertEquals("", "I", b.valueType);
    }

    @Test
    public void test2char() {
        initMethod(true, "V");
        Local b = addLocal("b");

        addStmt(nAssign(b, nInt(255)));
        addStmt(nVoidInvoke(nInvokeStatic(new Value[] { b }, "La;", "y", new String[] { "I" }, "V")));
        addStmt(nAssign(nStaticField("La;", "z", "C"), b));
        addStmt(nReturnVoid());
        transform();
        // FIXME fix type detect
        // Assert.assertEquals("", "I", b.valueType);
    }

    // @Ignore("type b to Int is ok to this context")
    @Test
    public void test3() {
        initMethod(true, "V");
        Local b = addLocal("b");

        addStmt(nAssign(b, nInt(456)));
        LabelStmt L0 = newLabel();
        addStmt(nIf(nEq(b, nInt(0), TypeClass.ZIFL.name), L0));
        addStmt(L0);
        addStmt(nReturnVoid());
        transform();
        Assert.assertEquals("", "I", b.valueType);
    }

    @Test
    public void test3Z() {
        initMethod(true, "V");
        Local b = addLocal("b");

        addStmt(nAssign(b, nInt(1)));
        LabelStmt L0 = newLabel();
        addStmt(nIf(nEq(b, nInt(0), TypeClass.ZIFL.name), L0));
        addStmt(L0);
        addStmt(nReturnVoid());
        transform();
        // FIXME local should type to Z but I works as well
        // Assert.assertEquals("", "Z", b.valueType);
    }

    @Test
    public void test2arrayF() {
        initMethod(true, "V");
        Local b = addLocal("b");
        Local c = addLocal("c");

        addStmt(nAssign(b, nNewMutiArray("F", 1, new Value[]{nInt(2)})));
        addStmt(nFillArrayData(b, nConstant(new int[]{5, 6})));
        addStmt(nAssign(c, nArray(b, nInt(3), TypeClass.IF.name)));
        addStmt(nReturnVoid());
        transform();
        Assert.assertEquals("", b.valueType, "[F");
    }

    @Test
    public void testDefaultZI() {
        initMethod(true, "V");
        Local b = addLocal("b");
        Local c = addLocal("c");

        addStmt(nAssign(b, nInt(5)));
        addStmt(nAssign(c, nOr(b, nInt(6), TypeClass.ZI.name)));

        addStmt(nReturnVoid());
        transform();
        Assert.assertEquals("I", c.valueType);
    }


    @Test
    public void testGithubIssue28() {
        initMethod(true, "V");
        Local b = addLocal("b");

        addStmt(nAssign(b, nNewMutiArray("D", 2, new Value[]{nInt(2), nInt(3)})));
        addStmt(nAssign(nArray(nArray(b, nInt(5), TypeClass.OBJECT.name), nInt(1), TypeClass.JD.name), nLong(0)));
        addStmt(nReturnVoid());
        transform();
        Assert.assertEquals("", b.valueType, "[[D");
    }

    @Test
    public void testGithubIssue28x() {
        initMethod(true, "V");
        Local b = addLocal("b");

        addStmt(nAssign(b, nInt(0)));
        addStmt(nAssign(nArray(nArray(b, nInt(5), TypeClass.OBJECT.name), nInt(1), TypeClass.JD.name), nLong(0)));
        addStmt(nReturnVoid());
        transform();
        // this case is ok to fail as the NPE transformer cover this
        // Assert.assertEquals("", "[[D", b.valueType);
    }
}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/UnSSATransformerTransformerTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import static com.googlecode.dex2jar.ir.expr.Exprs.*;
import static com.googlecode.dex2jar.ir.stmt.Stmts.*;

import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.stmt.Stmts;
import org.junit.Assert;
import org.junit.Test;

import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import com.googlecode.dex2jar.ir.ts.UnSSATransformer;

public class UnSSATransformerTransformerTest extends BaseTransformerTest<UnSSATransformer> {

    @Test
    public void test00Base() {
        initMethod(true, "V");
        Local a = addLocal("a");
        Local b = addLocal("b");
        Local phi = addLocal("p");
        LabelStmt L1 = newLabel();
        Stmt s1 = addStmt(nAssign(a, nString("123")));
        addStmt(nIf(niGt(nInt(100), nInt(0)), L1));
        Stmt s2 = addStmt(nAssign(b, nString("456")));
        addStmt(L1);
        attachPhi(L1,nAssign(phi, nPhi(a, b)));
        addStmt(nReturn(phi));
        transform();
        Assert.assertEquals("insert assign after s1", ST.ASSIGN, s1.getNext().st);
        Assert.assertEquals("insert assign after s1", ST.ASSIGN, s2.getNext().st);
        // Assert.assertEquals("local should index to 0", 0, b._ls_index);
    }

    @Test
    public void test01SSAProblem() {
        initMethod(true, "I");
        Local a = addLocal("a");
        Local b = addLocal("b");
        Local phi = addLocal("p");
        LabelStmt L0 = newLabel();
        addStmt(nAssign(a, nInt(2)));
        addStmt(L0);
        attachPhi(L0, nAssign(phi, nPhi(a, b)));
        Stmt stmt = addStmt(nAssign(b, niAdd(phi, nInt(0))));
        addStmt(nIf(niGt(nInt(100), nInt(0)), L0));
        addStmt(nReturn(phi));
        transform();
        Assert.assertTrue("a new local should introduced to solve the problem", stmt.getPre() != L0);
    }

    @Test
    public void test02_3branches() {
        initMethod(true, "I");
        Local a = addLocal("a");
        Local b = addLocal("b");
        Local c = addLocal("c");
        Local d = addLocal("d");
        Local phi = addLocal("p");
        LabelStmt L0 = newLabel();
        LabelStmt L1 = newLabel();
        addStmt(nAssign(a, nInt(2)));
        addStmt(nIf(niGt(nInt(100), nInt(0)), L1));
        addStmt(nAssign(b, nInt(3)));
        addStmt(nIf(niGt(nInt(100), nInt(0)), L0));
        addStmt(nAssign(c, nInt(4)));
        addStmt(nLock(c));
        addStmt(nGoto(L1));
        addStmt(L0);
        addStmt(nAssign(d, nInt(5)));
        addStmt(nLock(d));
        addStmt(L1);
        attachPhi(L1, nAssign(phi, nPhi(a, b)));
        addStmt(nReturn(phi));
        transform();
    }

    @Test
    public void test04OneInPhi() {
        initMethod(true, "V");
        Local a = addLocal("a");
        Local b = addLocal("b");
        Local phi = addLocal("p");
        LabelStmt L1 = newLabel();
        Stmt s1 = addStmt(nAssign(a, nString("123")));
        Stmt j = addStmt(nIf(niGt(nInt(100), nInt(0)), L1));
        Stmt s2 = addStmt(nAssign(b, nString("456")));
        addStmt(L1);
        attachPhi(L1, nAssign(phi, nPhi(a)));
        addStmt(nReturn(phi));
        transform();
        Assert.assertTrue("p=a should inserted", j.getPre() != s1);

    }

    @Test
    public void test05OneInPhiLoop() {
        initMethod(true, "V");
        Local a = addLocal("a");
        Local b = addLocal("b");
        Local phi = addLocal("p");

        Stmt s1 = addStmt(nAssign(a, nString("123")));
        LabelStmt L1 = newLabel();
        addStmt(L1);
        attachPhi(L1, nAssign(phi, nPhi(a)));
        addStmt(nVoidInvoke(nInvokeStatic(new Value[] { phi }, "LAAA;", "bMethod",
                new String[] { "Ljava/lang/String;" }, "V")));
        addStmt(nAssign(b, nString("456")));

        // phi is still live here
        Stmt s2 = addStmt(nVoidInvoke(nInvokeStatic(new Value[] { b }, "LBBB;", "cMethod",
                new String[] { "Ljava/lang/String;" }, "V")));
        addStmt(nIf(niGt(nInt(100), nInt(0)), L1));
        addStmt(nReturnVoid());
        transform();

        Assert.assertTrue("p=a should inserted", s1.getPre() != L1);

    }

    @Test
    public void test06TwoJump() {
        initMethod(true, "V");
        Local a1 = addLocal("a1");
        Local a2 = addLocal("a2");
        Local a = addLocal("a");

        Local b1 = addLocal("b1");
        Local b2 = addLocal("b2");
        Local b = addLocal("b");

        addStmt(nAssign(a1, nString("123")));
        addStmt(nAssign(b1, nString("123")));
        LabelStmt L1 = newLabel();
        addStmt(L1);
        attachPhi(L1, nAssign(a, nPhi(a1, a2)));
        attachPhi(L1, nAssign(b, nPhi(b1, b2)));

        addStmt(nAssign(a2, nString("456")));

        addStmt(nIf(niGt(nInt(100), nInt(0)), L1));
        addStmt(nAssign(b2, nString("456")));
        addStmt(nIf(niGt(nInt(100), nInt(0)), L1));

        addStmt(nReturnVoid());
        transform();
        // Assert.assertTrue("must assign different index", ls1._ls_index != ls2._ls_index);

    }

    @Test
    public void test07PhiInHandler() {
        initMethod(true, "I");
        Local a1 = addLocal("a1");
        Local a2 = addLocal("a2");
        Local a = addLocal("a");
        Local ex = addLocal("ex");
        addStmt(Stmts.nAssign(a1, nInt(1)));
        LabelStmt L0 = newLabel();
        LabelStmt L2 = newLabel();
        LabelStmt L3 = newLabel();
        addStmt(L0);
        addStmt(Stmts.nVoidInvoke(Exprs.nInvokeStatic(new Value[0], "La;", "m", new String[0], "V")));
        addStmt(Stmts.nAssign(a2, nInt(2)));
        addStmt(Stmts.nVoidInvoke(Exprs.nInvokeStatic(new Value[0], "La;", "m", new String[0], "V")));
        addStmt(L2);
        addStmt(Stmts.nReturn(a2));
        addStmt(L3);
        Stmt ref = addStmt(Stmts.nIdentity(ex, Exprs.nExceptionRef("Ljava/lang/Exception;")));
        attachPhi(L3, Stmts.nAssign(a, nPhi(a1, a2)));
        addStmt(Stmts.nVoidInvoke(Exprs.nInvokeStatic(new Value[] { a1 }, "La;", "m", new String[] { "I" }, "V")));
        addStmt(Stmts.nReturn(a));
        method.traps.add(new Trap(L0, L2, new LabelStmt[] { L3 }, new String[] { "Ljava/lang/Exception" }));
        transform();
        Assert.assertTrue("the fix assign should insert after x=@ExceptionRef", L3.getNext() == ref);
    }

}

```

`dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/ZeroTransformerTest.java`:

```java
package com.googlecode.dex2jar.ir.test;

import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.ts.RemoveConstantFromSSA;
import com.googlecode.dex2jar.ir.ts.ZeroTransformer;
import org.junit.Assert;
import org.junit.Test;

import static com.googlecode.dex2jar.ir.expr.Exprs.nInt;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInvokeStatic;
import static com.googlecode.dex2jar.ir.expr.Exprs.nPhi;
import static com.googlecode.dex2jar.ir.stmt.Stmts.nAssign;
import static com.googlecode.dex2jar.ir.stmt.Stmts.nReturn;

public class ZeroTransformerTest extends BaseTransformerTest<ZeroTransformer> {
    @Test
    public void t001() {

        Local a = addLocal("a");
        Local c = addLocal("c");
        Local p = addLocal("p");
        Local q = addLocal("q");

        addStmt(nAssign(a, nInt(0)));
        addStmt(nAssign(c, nInvokeStatic(new Value[0], "La;", "a", new String[0], "I")));
        LabelStmt L1 = newLabel();
        addStmt(L1);
        Stmt sa = attachPhi(L1, nAssign(q, nPhi(a, c)));
        Stmt sb = attachPhi(L1, nAssign(p, nPhi(a, c)));
        addStmt(nReturn(p));
        transform();
        Assert.assertNotEquals("a is split to 2 local", sb.getOp2().getOps()[0], sa.getOp2().getOps()[0]);
        Assert.assertEquals("c is keep same", sb.getOp2().getOps()[1], sa.getOp2().getOps()[1]);
    }
}

```

`dex-reader-api/build.gradle`:

```gradle
description = 'Dex Reader API'

```

`dex-reader-api/src/main/java/com/googlecode/d2j/CallSite.java`:

```java
package com.googlecode.d2j;

public class CallSite {
    private String name;
    private MethodHandle bootstrapMethodHandler;
    private String methodName;
    private Proto methodProto;
    private Object[] extraArguments;

    public CallSite(String name, MethodHandle bootstrapMethodHandler, String methodName, Proto methodProto, Object... extraArguments) {
        this.name = name;
        this.bootstrapMethodHandler = bootstrapMethodHandler;
        this.methodName = methodName;
        this.methodProto = methodProto;
        this.extraArguments = extraArguments;
    }

    public String getName() {
        return name;
    }

    public MethodHandle getBootstrapMethodHandler() {
        return bootstrapMethodHandler;
    }

    public String getMethodName() {
        return methodName;
    }

    public Proto getMethodProto() {
        return methodProto;
    }

    public Object[] getExtraArguments() {
        return extraArguments;
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/DexConstants.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

/**
 * constants in dex file
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public interface DexConstants {

    int ACC_PUBLIC = 0x0001; // class, field, method
    int ACC_PRIVATE = 0x0002; // class, field, method
    int ACC_PROTECTED = 0x0004; // class, field, method
    int ACC_STATIC = 0x0008; // field, method
    int ACC_FINAL = 0x0010; // class, field, method
    // int ACC_SUPER = 0x0020; // class
    int ACC_SYNCHRONIZED = 0x0020; // method
    int ACC_VOLATILE = 0x0040; // field
    int ACC_BRIDGE = 0x0040; // method
    int ACC_VARARGS = 0x0080; // method
    int ACC_TRANSIENT = 0x0080; // field
    int ACC_NATIVE = 0x0100; // method
    int ACC_INTERFACE = 0x0200; // class
    int ACC_ABSTRACT = 0x0400; // class, method
    int ACC_STRICT = 0x0800; // method
    int ACC_SYNTHETIC = 0x1000; // class, field, method
    int ACC_ANNOTATION = 0x2000; // class
    int ACC_ENUM = 0x4000; // class(?) field inner
    int ACC_CONSTRUCTOR = 0x10000;// constructor method (class or instance initializer)
    int ACC_DECLARED_SYNCHRONIZED = 0x20000;

    int ACC_VISIBILITY_FLAGS = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED;
    int ACC_DEX_HIDDEN_BIT = 0x00000020; // field, method (not native)
    int ACC_DEX_HIDDEN_BIT_NATIVE = 0x00000200; // method (native)

    String ANNOTATION_DEFAULT_TYPE = "Ldalvik/annotation/AnnotationDefault;";
    String ANNOTATION_SIGNATURE_TYPE = "Ldalvik/annotation/Signature;";
    String ANNOTATION_THROWS_TYPE = "Ldalvik/annotation/Throws;";
    String ANNOTATION_ENCLOSING_CLASS_TYPE = "Ldalvik/annotation/EnclosingClass;";
    String ANNOTATION_ENCLOSING_METHOD_TYPE = "Ldalvik/annotation/EnclosingMethod;";
    String ANNOTATION_INNER_CLASS_TYPE = "Ldalvik/annotation/InnerClass;";
    String ANNOTATION_MEMBER_CLASSES_TYPE = "Ldalvik/annotation/MemberClasses;";

    static int toMiniAndroidApiLevel(int dexVersion) {
        if (dexVersion <= DEX_035 || dexVersion <= DEX_036) {
            return 0;
        } else if (dexVersion == DEX_037) {
            return 24;
        } else if (dexVersion == DEX_038) {
            return 26;
        } else {
            return 28;
        }
    }
    int DEX_035 = 0x00303335;
    @Deprecated
    int DEX_036 = 0x00303336;
    // android 7.0, api 24
    int DEX_037 = 0x00303337;
    // android 8.0, api 26
    int DEX_038 = 0x00303338;
    // android 9.0, api 28
    int DEX_039 = 0x00303339;
    int DEX_040 = 0x00303340;
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/DexException.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

/**
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class DexException extends RuntimeException {

    /**
     * 
     */
    private static final long serialVersionUID = 6294916997539922829L;

    /**
     * 
     */
    public DexException() {
    }

    /**
     * @param message
     */
    public DexException(String message) {
        super(message);
    }

    /**
     * @param cause
     */
    public DexException(Throwable cause) {
        super(cause);
    }

    /**
     * @param message
     * @param cause
     */
    public DexException(String message, Throwable cause) {
        super(message, cause);
    }

    /**
     * this is equals to
     * 
     * <b> new DexException(String.format(messageFormat, args), cause); </b>
     * 
     * @param cause
     * @param messageFormat
     * @param args
     */
    public DexException(Throwable cause, String messageFormat, Object... args) {
        this(String.format(messageFormat, args), cause);
    }

    /**
     * this is equals to
     * 
     * <b> new DexException(String.format(messageFormat, args)); </b>
     * 
     * @param messageFormat
     * @param args
     */
    public DexException(String messageFormat, Object... args) {
        this(String.format(messageFormat, args));
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/DexLabel.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

/**
 * a light weight version of org.objectweb.asm.Label
 * 
 * @author Panxiaobo
 * @version $Rev$
 */
public class DexLabel {
    public String displayName;
    private int offset = -1;

    /**
     * 
     * @param offset
     *            the offset of the label
     */
    public DexLabel(int offset) {
        super();
        this.offset = offset;
    }

    public DexLabel() {
        super();
    }

    @Override
    public String toString() {
        if (displayName != null) {
            return displayName;
        }
        if (offset >= 0) {
            return String.format("L%04x", offset);
        }
        return String.format("L%08x", this.hashCode());
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/DexType.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

/**
 * a light weight version of org.objectweb.asm.Type
 * 
 * @author Panxiaobo
 * @version $Rev$
 * 
 */
public class DexType {
    public DexType(String desc) {
        this.desc = desc;
    }

    /**
     * type descriptor, in TypeDescriptor format
     */
    final public String desc;

    @Override
    public String toString() {
        return desc;
    }
}
```

`dex-reader-api/src/main/java/com/googlecode/d2j/Field.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

/**
 * represent a field_id_item in dex file format
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Field {
    /**
     * name of the field.
     */
    private String name;
    /**
     * owner class of the field, in TypeDescriptor format.
     */
    private String owner;
    /**
     * type of the field, in TypeDescriptor format.
     */
    private String type;

    public Field(String owner, String name, String type) {
        this.owner = owner;
        this.type = type;
        this.name = name;
    }

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @return the owner
     */
    public String getOwner() {
        return owner;
    }

    /**
     * @return the type
     */
    public String getType() {
        return type;
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return this.getOwner() + "->" + this.getName() + ":" + this.getType();
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/Method.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

import java.util.Arrays;

/**
 * represent a method_id_item in dex file format
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Method {
    /**
     * name of the method.
     */
    private String name;
    /**
     * owner class of the method, in TypeDescriptor format.
     */
    private String owner;
    /**
     * parameter types of the method, in TypeDescriptor format.
     */
    private Proto proto;

    public Proto getProto() {
        return proto;
    }

    public Method(String owner, String name, String[] parameterTypes, String returnType) {
        this.owner = owner;
        this.name = name;
        this.proto = new Proto(parameterTypes, returnType);
    }
    public Method(String owner, String name, Proto proto) {
        this.owner = owner;
        this.name = name;
        this.proto = proto;
    }
    public String getDesc() {
        return proto.getDesc();
    }

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @return the owner
     */
    public String getOwner() {
        return owner;
    }

    /**
     * @return the parameterTypes
     */
    public String[] getParameterTypes() {
        return proto.getParameterTypes();
    }

    public String getReturnType() {
        return proto.getReturnType();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Method method = (Method) o;

        if (name != null ? !name.equals(method.name) : method.name != null) return false;
        if (owner != null ? !owner.equals(method.owner) : method.owner != null) return false;
        return proto.equals(method.proto);
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + (owner != null ? owner.hashCode() : 0);
        result = 31 * result + proto.hashCode();
        return result;
    }

    /*
         * (non-Javadoc)
         *
         * @see java.lang.Object#toString()
         */
    @Override
    public String toString() {
        return this.getOwner() + "->" + this.getName() + this.getDesc();
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/MethodHandle.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

public class MethodHandle {
    public static final int STATIC_PUT = 0x00;
    public static final int STATIC_GET = 0x01;
    public static final int INSTANCE_PUT = 0x02;
    public static final int INSTANCE_GET = 0x03;
    public static final int INVOKE_STATIC = 0x04;
    public static final int INVOKE_INSTANCE = 0x05;
    public static final int INVOKE_CONSTRUCTOR = 0x06;
    public static final int INVOKE_DIRECT = 0x07;
    public static final int INVOKE_INTERFACE = 0x08;

    private int type;
    private Field field;
    private Method method;

    public MethodHandle(int type, Field field) {
        this.type = type;
        this.field = field;
    }

    public MethodHandle(int type, Method method) {
        this.type = type;
        this.method = method;
    }

    public MethodHandle(int type, Field field, Method method) {
        this.type = type;
        this.field = field;
        this.method = method;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        MethodHandle that = (MethodHandle) o;

        if (type != that.type) return false;
        if (field != null ? !field.equals(that.field) : that.field != null) return false;
        return method != null ? method.equals(that.method) : that.method == null;
    }

    @Override
    public int hashCode() {
        int result = type;
        result = 31 * result + (field != null ? field.hashCode() : 0);
        result = 31 * result + (method != null ? method.hashCode() : 0);
        return result;
    }

    public int getType() {
        return type;
    }

    public Field getField() {
        return field;
    }

    public Method getMethod() {
        return method;
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/Proto.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

import java.util.Arrays;

public class Proto {
    public Proto(String[] parameterTypes, String returnType) {
        this.parameterTypes = parameterTypes;
        this.returnType = returnType;
    }

    /**
     * descriptor of the method, this will build after {@link #getDesc()}.
     */
    private String desc;
    /**
     * parameter types of the method, in TypeDescriptor format.
     */
    private String[] parameterTypes;

    /**
     * return type of the method, in TypeDescriptor format.
     */
    private String returnType;

    /**
     * @return the parameterTypes
     */
    public String[] getParameterTypes() {
        return parameterTypes;
    }

    public String getReturnType() {
        return returnType;
    }

    public String getDesc() {
        if (desc == null) {
            StringBuilder ps = new StringBuilder("(");
            if (parameterTypes != null) {
                for (String t : parameterTypes) {
                    ps.append(t);
                }
            }
            ps.append(")").append(returnType);
            desc = ps.toString();
        }
        return desc;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Proto proto = (Proto) o;

        // Probably incorrect - comparing Object[] arrays with Arrays.equals
        if (!Arrays.equals(parameterTypes, proto.parameterTypes)) return false;
        return returnType != null ? returnType.equals(proto.returnType) : proto.returnType == null;
    }

    @Override
    public int hashCode() {
        int result = Arrays.hashCode(parameterTypes);
        result = 31 * result + (returnType != null ? returnType.hashCode() : 0);
        return result;
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/Visibility.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j;

/**
 * @author bob
 */
public enum Visibility {
    BUILD(0), RUNTIME(1), SYSTEM(2);
    public int value;

    // int VISIBILITY_BUILD = 0;
    // int VISIBILITY_RUNTIME = 1;
    // int VISIBILITY_SYSTEM = 2;
    Visibility(int v) {
        this.value = v;
    }

    public String displayName() {
        return name().toLowerCase();
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/DexAnnotationNode.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.Field;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.visitors.DexAnnotationAble;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;

/**
 * 
 * @author Bob Pan
 * 
 */
public class DexAnnotationNode extends DexAnnotationVisitor {
    private abstract static class AV extends DexAnnotationVisitor {
        List<Object> objs = new ArrayList<Object>();

        @Override
        public void visit(String name, Object value) {
            objs.add(value);
        }

        @Override
        public DexAnnotationVisitor visitAnnotation(String name, String desc) {
            DexAnnotationNode annotation = new DexAnnotationNode(desc, Visibility.RUNTIME);
            objs.add(annotation);
            return annotation;
        }

        @Override
        public DexAnnotationVisitor visitArray(String name) {
            return new AV() {

                @Override
                public void visitEnd() {
                    AV.this.objs.add(this.objs.toArray());
                    super.visitEnd();
                }

            };
        }

        @Override
        public void visitEnd() {
            objs = null;
            super.visitEnd();
        }

        @Override
        public void visitEnum(String name, String desc, String value) {
            objs.add(new Field(null, value, desc));
        }
    }

    public static class Item {
        public String name;

        public Object value;

        public Item(String name, Object value) {
            super();
            this.name = name;
            this.value = value;
        }
    }

    public static void acceptAnnotationItem(DexAnnotationVisitor dav, String name, Object o) {
        if (o instanceof Object[]) {
            DexAnnotationVisitor arrayVisitor = dav.visitArray(name);
            if (arrayVisitor != null) {
                Object[] array = (Object[]) o;
                for (Object e : array) {
                    acceptAnnotationItem(arrayVisitor, null, e);
                }
                arrayVisitor.visitEnd();
            }
        } else if (o instanceof DexAnnotationNode) {
            DexAnnotationNode ann = (DexAnnotationNode) o;
            DexAnnotationVisitor av = dav.visitAnnotation(name, ann.type);
            if (av != null) {
                for (DexAnnotationNode.Item item : ann.items) {
                    acceptAnnotationItem(av, item.name, item.value);
                }
                av.visitEnd();
            }
        } else if (o instanceof Field) {
            Field f = (Field) o;
            dav.visitEnum(name, f.getType(), f.getName());
        } else {
            dav.visit(name, o);
        }
    }

    public List<Item> items = new ArrayList<Item>(5);

    public String type;
    public Visibility visibility;

    public DexAnnotationNode(String type, Visibility visibility) {
        super();
        this.type = type;
        this.visibility = visibility;
    }

    public void accept(DexAnnotationAble av) {
        DexAnnotationVisitor av1 = av.visitAnnotation(type, visibility);
        if (av1 != null) {
            for (Item item : items) {
                acceptAnnotationItem(av1, item.name, item.value);
            }
            av1.visitEnd();
        }
    }

    @Override
    public void visit(String name, Object value) {
        items.add(new Item(name, value));
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name, String desc) {
        DexAnnotationNode annotation = new DexAnnotationNode(desc, Visibility.RUNTIME);
        items.add(new Item(name, annotation));
        return annotation;
    }

    @Override
    public DexAnnotationVisitor visitArray(final String name) {
        return new AV() {

            @Override
            public void visitEnd() {
                items.add(new Item(name, objs.toArray()));
                super.visitEnd();
            }
        };
    }

    @Override
    public void visitEnum(String name, String desc, String value) {
        items.add(new Item(name, new Field(desc, value, desc)));
    }
}
```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/DexClassNode.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexFieldVisitor;
import com.googlecode.d2j.visitors.DexFileVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

/**
 * @author Bob Pan
 * 
 */
public class DexClassNode extends DexClassVisitor {
    public int access;
    public List<DexAnnotationNode> anns;
    public String className;
    public List<DexFieldNode> fields;
    public String[] interfaceNames;
    public List<DexMethodNode> methods;
    public String source;
    public String superClass;

    public DexClassNode(DexClassVisitor v, int access, String className, String superClass, String[] interfaceNames) {
        super(v);
        this.access = access;
        this.className = className;
        this.superClass = superClass;
        this.interfaceNames = interfaceNames;
    }

    public DexClassNode(int access, String className, String superClass, String[] interfaceNames) {
        super();
        this.access = access;
        this.className = className;
        this.superClass = superClass;
        this.interfaceNames = interfaceNames;
    }

    public void accept(DexClassVisitor dcv) {
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(dcv);
            }
        }
        if (methods != null) {
            for (DexMethodNode m : methods) {
                m.accept(dcv);
            }
        }
        if (fields != null) {
            for (DexFieldNode f : fields) {
                f.accept(dcv);
            }
        }
        if (source != null) {
            dcv.visitSource(source);
        }
    }

    public void accept(DexFileVisitor dfv) {
        DexClassVisitor dcv = dfv.visit(access, className, superClass, interfaceNames);
        if (dcv != null) {
            accept(dcv);
            dcv.visitEnd();
        }
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
        if (anns == null) {
            anns = new ArrayList<DexAnnotationNode>(5);
        }
        DexAnnotationNode annotation = new DexAnnotationNode(name, visibility);
        anns.add(annotation);
        return annotation;
    }

    @Override
    public DexFieldVisitor visitField(int accessFlags, Field field, Object value) {
        if (fields == null) {
            fields = new ArrayList<DexFieldNode>();
        }
        DexFieldNode fieldNode = new DexFieldNode(accessFlags, field, value);
        fields.add(fieldNode);
        return fieldNode;
    }

    @Override
    public DexMethodVisitor visitMethod(int accessFlags, Method method) {
        if (methods == null) {
            methods = new ArrayList<DexMethodNode>();
        }
        DexMethodNode methodNode = new DexMethodNode(accessFlags, method);
        methods.add(methodNode);
        return methodNode;
    }

    @Override
    public void visitSource(String file) {
        this.source = file;
    }

}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/DexCodeNode.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.*;
import com.googlecode.d2j.node.insn.*;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexDebugVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

public class DexCodeNode extends DexCodeVisitor {

    public List<DexStmtNode> stmts = new ArrayList<DexStmtNode>();
    public List<TryCatchNode> tryStmts = null;
    public DexDebugNode debugNode;
    public int totalRegister = -1;

    public DexCodeNode() {
        super();
    }

    public DexCodeNode(DexCodeVisitor visitor) {
        super(visitor);
    }

    public void accept(DexCodeVisitor v) {
        if (tryStmts != null) {
            for (TryCatchNode n : tryStmts) {
                n.accept(v);
            }
        }
        if (debugNode != null) {
            DexDebugVisitor ddv = v.visitDebug();
            if (ddv != null) {
                debugNode.accept(ddv);
                ddv.visitEnd();
            }
        }
        if (totalRegister >= 0) {
            v.visitRegister(this.totalRegister);
        }
        for (DexStmtNode n : stmts) {
            n.accept(v);
        }
    }

    public void accept(DexMethodVisitor v) {
        DexCodeVisitor cv = v.visitCode();
        if (cv != null) {
            accept(cv);
            cv.visitEnd();
        }
    }

    protected void add(DexStmtNode stmt) {
        stmts.add(stmt);
    }

    @Override
    public void visitConstStmt(final Op op, final int ra, final Object value) {
        add(new ConstStmtNode(op, ra, value));
    }

    @Override
    public void visitFillArrayDataStmt(final Op op, final int ra, final Object array) {
        add(new FillArrayDataStmtNode(op, ra, array));
    }

    @Override
    public void visitFieldStmt(final Op op, final int a, final int b, final Field field) {
        add(new FieldStmtNode(op, a, b, field));
    }

    @Override
    public void visitFilledNewArrayStmt(final Op op, final int[] args, final String type) {
        add(new FilledNewArrayStmtNode(op, args, type));
    }

    @Override
    public void visitJumpStmt(final Op op, final int a, final int b, final DexLabel label) {
        add(new JumpStmtNode(op, a, b, label));
    }

    @Override
    public void visitLabel(final DexLabel label) {
        add(new DexLabelStmtNode(label));
    }

    @Override
    public void visitMethodStmt(final Op op, final int[] args, final Method method) {
        add(new MethodStmtNode(op, args, method));
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, CallSite callSite) {
        add(new MethodCustomStmtNode(op, args, callSite));
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, Method bsm, Proto proto) {
        add(new MethodPolymorphicStmtNode(op, args, bsm, proto));
    }

    @Override
    public void visitPackedSwitchStmt(final Op op, final int aA, final int first_case, final DexLabel[] labels) {
        add(new PackedSwitchStmtNode(op, aA, first_case, labels));
    }

    @Override
    public void visitRegister(final int total) {
        this.totalRegister = total;
    }

    @Override
    public void visitSparseSwitchStmt(final Op op, final int ra, final int[] cases, final DexLabel[] labels) {
        add(new SparseSwitchStmtNode(op, ra, cases, labels));
    }

    @Override
    public void visitStmt0R(final Op op) {
        add(new Stmt0RNode(op));
    }

    @Override
    public void visitStmt1R(final Op op, final int reg) {
        add(new Stmt1RNode(op, reg));
    }

    @Override
    public void visitStmt2R(final Op op, final int a, final int b) {
        add(new Stmt2RNode(op, a, b));
    }

    @Override
    public void visitStmt2R1N(final Op op, final int distReg, final int srcReg, final int content) {
        add(new Stmt2R1NNode(op, distReg, srcReg, content));
    }

    @Override
    public void visitStmt3R(final Op op, final int a, final int b, final int c) {
        add(new Stmt3RNode(op, a, b, c));
    }

    @Override
    public void visitTryCatch(final DexLabel start, final DexLabel end, final DexLabel[] handler, final String[] type) {
        if (tryStmts == null) {
            tryStmts = new ArrayList<>(3);
        }
        tryStmts.add(new TryCatchNode(start, end, handler, type));
    }

    @Override
    public void visitTypeStmt(final Op op, final int a, final int b, final String type) {
        add(new TypeStmtNode(op, a, b, type));
    }

    @Override
    public DexDebugVisitor visitDebug() {
        DexDebugNode dexDebugNode = new DexDebugNode();
        this.debugNode = dexDebugNode;
        return dexDebugNode;
    }

}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/DexDebugNode.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.visitors.DexDebugVisitor;

public class DexDebugNode extends DexDebugVisitor {
    public List<DexDebugOpNode> debugNodes = new ArrayList<>();
    public List<String> parameterNames;
    public String fineName;

    protected void addDebug(DexDebugOpNode dexDebugNode) {
        debugNodes.add(dexDebugNode);
    }

    @Override
    public void visitSetFile(String file) {
        this.fineName = file;
    }

    @Override
    public void visitRestartLocal(int reg, DexLabel label) {
        addDebug(new DexDebugOpNode.RestartLocal(label, reg));
    }

    @Override
    public void visitParameterName(final int parameterIndex, final String name) {
        if (parameterNames == null) {
            parameterNames = new ArrayList<>();
        }
        while (parameterNames.size() <= parameterIndex) {
            parameterNames.add(null);
        }
        parameterNames.set(parameterIndex, name);
    }

    @Override
    public void visitLineNumber(final int line, final DexLabel label) {
        addDebug(new DexDebugOpNode.LineNumber(label, line));
    }

    @Override
    public void visitStartLocal(int reg, DexLabel label, String name, String type, String signature) {
        addDebug(new DexDebugOpNode.StartLocalNode(label, reg, name, type, signature));
    }

    @Override
    public void visitEndLocal(int reg, DexLabel label) {
        addDebug(new DexDebugOpNode.EndLocal(label, reg));
    }

    public void accept(DexDebugVisitor v) {
        if (parameterNames != null) {
            for (int i = 0; i < parameterNames.size(); i++) {
                String name = parameterNames.get(i);
                if (name != null) {
                    v.visitParameterName(i, name);
                }
            }
        }
        if (debugNodes != null) {
            for (DexDebugOpNode n : debugNodes) {
                n.accept(v);
            }
        }
        if (fineName != null) {
            v.visitSetFile(fineName);
        }
    }

    @Override
    public void visitPrologue(DexLabel dexLabel) {
        addDebug(new DexDebugOpNode.Prologue(dexLabel));
    }

    @Override
    public void visitEpiogue(DexLabel dexLabel) {
        addDebug(new DexDebugOpNode.Epiogue(dexLabel));
    }

    public abstract static class DexDebugOpNode {
        public DexLabel label;

        protected DexDebugOpNode(DexLabel label) {
            this.label = label;
        }

        public abstract void accept(DexDebugVisitor cv);

        public static class StartLocalNode extends DexDebugOpNode {
            public int reg;
            public String name;
            public String type;
            public String signature;

            public StartLocalNode(DexLabel label, int reg, String name, String type, String signature) {
                super(label);
                this.reg = reg;
                this.name = name;
                this.type = type;
                this.signature = signature;
            }

            @Override
            public void accept(DexDebugVisitor cv) {
                cv.visitStartLocal(reg, label, name, type, signature);
            }
        }

        public static class EndLocal extends DexDebugOpNode {
            public int reg;

            public EndLocal(DexLabel label, int reg) {
                super(label);
                this.reg = reg;
            }

            @Override
            public void accept(DexDebugVisitor cv) {
                cv.visitEndLocal(reg, label);
            }
        }

        public static class Epiogue extends DexDebugOpNode {

            public Epiogue(DexLabel label) {
                super(label);
            }

            @Override
            public void accept(DexDebugVisitor cv) {
                cv.visitEpiogue(label);
            }
        }

        public static class Prologue extends DexDebugOpNode {

            public Prologue(DexLabel label) {
                super(label);
            }

            @Override
            public void accept(DexDebugVisitor cv) {
                cv.visitPrologue(label);
            }
        }

        public static class RestartLocal extends DexDebugOpNode {
            public int reg;

            public RestartLocal(DexLabel label, int reg) {
                super(label);
                this.reg = reg;
            }

            @Override
            public void accept(DexDebugVisitor cv) {
                cv.visitRestartLocal(reg, label);
            }
        }

        public static class LineNumber extends DexDebugOpNode {
            public int line;

            public LineNumber(DexLabel label, int line) {
                super(label);
                this.line = line;
            }

            @Override
            public void accept(DexDebugVisitor cv) {
                cv.visitLineNumber(line, label);
            }
        }
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/DexFieldNode.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.Field;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexFieldVisitor;

/**
 * @author Bob Pan
 * 
 */
public class DexFieldNode extends DexFieldVisitor {
    public int access;
    public List<DexAnnotationNode> anns;
    public Object cst;
    public Field field;

    public DexFieldNode(DexFieldVisitor visitor, int access, Field field, Object cst) {
        super(visitor);
        this.access = access;
        this.field = field;
        this.cst = cst;
    }

    public DexFieldNode(int access, Field field, Object cst) {
        super();
        this.access = access;
        this.field = field;
        this.cst = cst;
    }

    public void accept(DexClassVisitor dcv) {
        DexFieldVisitor fv = dcv.visitField(access, field, cst);
        if (fv != null) {
            accept(fv);
            fv.visitEnd();
        }
    }

    public void accept(DexFieldVisitor fv) {
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(fv);
            }
        }
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
        if (anns == null) {
            anns = new ArrayList<DexAnnotationNode>(5);
        }
        DexAnnotationNode annotation = new DexAnnotationNode(name, visibility);
        anns.add(annotation);
        return annotation;
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/DexFileNode.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexFileVisitor;

import java.util.ArrayList;
import java.util.List;

public class DexFileNode extends DexFileVisitor {
    public List<DexClassNode> clzs = new ArrayList<>();
    public int dexVersion = DexConstants.DEX_035;

    @Override
    public void visitDexFileVersion(int version) {
        this.dexVersion = version;
        super.visitDexFileVersion(version);
    }

    @Override
    public DexClassVisitor visit(int access_flags, String className, String superClass, String[] interfaceNames) {
        DexClassNode cn = new DexClassNode(access_flags, className, superClass, interfaceNames);
        clzs.add(cn);
        return cn;
    }

    public void accept(DexClassVisitor dcv) {
        for (DexClassNode cn : clzs) {
            cn.accept(dcv);
        }
    }

    public void accept(DexFileVisitor dfv) {
        for (DexClassNode cn : clzs) {
            cn.accept(dfv);
        }
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/DexMethodNode.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.visitors.DexAnnotationAble;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

public class DexMethodNode extends DexMethodVisitor {
    public int access;
    public List<DexAnnotationNode> anns;
    public DexCodeNode codeNode;
    public Method method;
    public List<DexAnnotationNode> parameterAnns[];

    public DexMethodNode(DexMethodVisitor mv, int access, Method method) {
        super(mv);
        this.access = access;
        this.method = method;
    }

    public DexMethodNode(int access, Method method) {
        super();
        this.access = access;
        this.method = method;
    }

    public void accept(DexClassVisitor dcv) {
        DexMethodVisitor mv = dcv.visitMethod(access, method);
        if (mv != null) {
            accept(mv);
            mv.visitEnd();
        }

    }

    public void accept(DexMethodVisitor mv) {
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                ann.accept(mv);
            }
        }

        if (parameterAnns != null) {
            for (int i = 0; i < parameterAnns.length; i++) {
                List<DexAnnotationNode> ps = parameterAnns[i];
                if (ps != null) {
                    DexAnnotationAble av = mv.visitParameterAnnotation(i);
                    if (av != null) {
                        for (DexAnnotationNode p : ps) {
                            p.accept(av);
                        }
                    }
                }
            }
        }
        if (codeNode != null) {
            codeNode.accept(mv);
        }
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
        if (anns == null) {
            anns = new ArrayList<DexAnnotationNode>(5);
        }
        DexAnnotationNode annotation = new DexAnnotationNode(name, visibility);
        anns.add(annotation);
        return annotation;
    }

    @Override
    public DexCodeVisitor visitCode() {
        DexCodeNode codeNode = new DexCodeNode(super.visitCode());
        this.codeNode = codeNode;
        return codeNode;
    }

    @SuppressWarnings("unchecked")
    @Override
    public DexAnnotationAble visitParameterAnnotation(final int index) {
        if (parameterAnns == null) {
            parameterAnns = new List[method.getParameterTypes().length];
        }


        // https://github.com/pxb1988/dex2jar/issues/485
        // skip param annotation if out of range
        if (index >= parameterAnns.length) {
            System.err.println("WARN: parameter out-of-range in " + method);
            return null;
        }

        return new DexAnnotationAble() {

            @Override
            public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
                List<DexAnnotationNode> pas = parameterAnns[index];
                if (pas == null) {
                    pas = new ArrayList<DexAnnotationNode>(5);
                    parameterAnns[index] = pas;
                }
                DexAnnotationNode annotation = new DexAnnotationNode(name, visibility);
                pas.add(annotation);
                return annotation;
            }
        };
    }

}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/TryCatchNode.java`:

```java
package com.googlecode.d2j.node;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class TryCatchNode {

    public final DexLabel start;
    public final DexLabel end;
    public final DexLabel[] handler;
    public final String[] type;

    public TryCatchNode(DexLabel start, DexLabel end, DexLabel[] handler, String[] type) {
        this.start = start;
        this.end = end;
        this.handler = handler;
        this.type = type;
    }

    public void accept(DexCodeVisitor cv) {
        cv.visitTryCatch(start, end, handler, type);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/analysis/DvmFrame.java`:

```java
package com.googlecode.d2j.node.analysis;

import com.googlecode.d2j.MethodHandle;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.node.insn.*;
import com.googlecode.d2j.reader.Op;

import java.util.ArrayList;
import java.util.List;

public class DvmFrame<V> {
    public V[] values;
    public V tmp;

    public DvmFrame(int totalRegister) {
        values = (V[]) new Object[totalRegister];
    }


    public void setReg(int i, V v) {
        if (i > values.length || i < 0) {
            return;
        }
        values[i] = v;
    }

    public DvmFrame<V> init(DvmFrame<? extends V> src) {
        this.tmp = src.tmp;
        System.arraycopy(src.values, 0, this.values, 0, this.values.length);
        return this;
    }

    public void execute(DexStmtNode insn, DvmInterpreter<V> interpreter) {
        if (insn.op == null) {// label or others
            return;
        }
        switch (insn.op) {
            case CONST:
            case CONST_4:
            case CONST_16:
            case CONST_HIGH16:
            case CONST_WIDE:
            case CONST_WIDE_16:
            case CONST_WIDE_32:
            case CONST_WIDE_HIGH16:
            case CONST_STRING:
            case CONST_STRING_JUMBO:
            case CONST_CLASS:
            case CONST_METHOD_HANDLE:
            case CONST_METHOD_TYPE:
                setReg(((ConstStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case SGET:
            case SGET_BOOLEAN:
            case SGET_BYTE:
            case SGET_CHAR:
            case SGET_OBJECT:
            case SGET_SHORT:
            case SGET_WIDE:
                setReg(((FieldStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case NEW_INSTANCE:
                setReg(((TypeStmtNode) insn).a, interpreter.newOperation(insn));
                setTmp(null);
                break;
            case MOVE:
            case MOVE_16:
            case MOVE_FROM16:
            case MOVE_OBJECT:
            case MOVE_OBJECT_16:
            case MOVE_OBJECT_FROM16:
            case MOVE_WIDE:
            case MOVE_WIDE_FROM16:
            case MOVE_WIDE_16:
                Stmt2RNode stmt2RNode = (Stmt2RNode) insn;
                setReg(stmt2RNode.a, interpreter.copyOperation(insn, getReg(stmt2RNode.b)));
                setTmp(null);
                break;
            case MOVE_RESULT:
            case MOVE_RESULT_WIDE:
            case MOVE_RESULT_OBJECT:
            case MOVE_EXCEPTION:
                setReg(((Stmt1RNode) insn).a, interpreter.copyOperation(insn, getTmp()));
                setTmp(null);
                break;
            case NOT_INT:
            case NOT_LONG:
            case NEG_DOUBLE:
            case NEG_FLOAT:
            case NEG_INT:
            case NEG_LONG:
            case INT_TO_BYTE:
            case INT_TO_CHAR:
            case INT_TO_DOUBLE:
            case INT_TO_FLOAT:
            case INT_TO_LONG:
            case INT_TO_SHORT:
            case FLOAT_TO_DOUBLE:
            case FLOAT_TO_INT:
            case FLOAT_TO_LONG:
            case DOUBLE_TO_FLOAT:
            case DOUBLE_TO_INT:
            case DOUBLE_TO_LONG:
            case LONG_TO_DOUBLE:
            case LONG_TO_FLOAT:
            case LONG_TO_INT:
            case ARRAY_LENGTH:
                Stmt2RNode stmt2RNode1 = (Stmt2RNode) insn;
                setReg(stmt2RNode1.a, interpreter.unaryOperation(insn, getReg(stmt2RNode1.b)));
                setTmp(null);
                break;
            case IF_EQZ:
            case IF_GEZ:
            case IF_GTZ:
            case IF_LEZ:
            case IF_LTZ:
            case IF_NEZ:
                interpreter.unaryOperation(insn, getReg(((JumpStmtNode) insn).a));
                setTmp(null);
                break;
            case SPARSE_SWITCH:
                interpreter.unaryOperation(insn, getReg(((SparseSwitchStmtNode) insn).a));
                setTmp(null);
                break;
            case PACKED_SWITCH:
                interpreter.unaryOperation(insn, getReg(((PackedSwitchStmtNode) insn).a));
                setTmp(null);
                break;
            case SPUT:
            case SPUT_BOOLEAN:
            case SPUT_BYTE:
            case SPUT_CHAR:
            case SPUT_OBJECT:
            case SPUT_SHORT:
            case SPUT_WIDE:
                interpreter.unaryOperation(insn, getReg(((FieldStmtNode) insn).a));
                setTmp(null);
                break;
            case IGET:
            case IGET_BOOLEAN:
            case IGET_BYTE:
            case IGET_CHAR:
            case IGET_OBJECT:
            case IGET_SHORT:
            case IGET_WIDE:
                FieldStmtNode fieldStmtNode = (FieldStmtNode) insn;
                setReg(fieldStmtNode.a, interpreter.unaryOperation(insn, getReg(fieldStmtNode.b)));
                setTmp(null);
                break;
            case NEW_ARRAY:
            case INSTANCE_OF: {
                TypeStmtNode typeStmtNode = (TypeStmtNode) insn;
                setReg(typeStmtNode.a, interpreter.unaryOperation(insn, getReg(typeStmtNode.b)));
                setTmp(null);
            }
            break;
            case CHECK_CAST: {
                TypeStmtNode typeStmtNode = (TypeStmtNode) insn;
                setReg(typeStmtNode.a, interpreter.unaryOperation(insn, getReg(typeStmtNode.a)));
                setTmp(null);
            }
            break;
            case MONITOR_ENTER:
            case MONITOR_EXIT:
            case THROW:
                interpreter.unaryOperation(insn, getReg(((Stmt1RNode) insn).a));
                setTmp(null);
                break;
            case RETURN:
            case RETURN_WIDE:
            case RETURN_OBJECT:
                interpreter.returnOperation(insn, getReg(((Stmt1RNode) insn).a));
                setTmp(null);
                break;
            case AGET:
            case AGET_BOOLEAN:
            case AGET_BYTE:
            case AGET_CHAR:
            case AGET_OBJECT:
            case AGET_SHORT:
            case AGET_WIDE:
            case CMP_LONG:
            case CMPG_DOUBLE:
            case CMPG_FLOAT:
            case CMPL_DOUBLE:
            case CMPL_FLOAT:
            case ADD_DOUBLE:
            case ADD_FLOAT:
            case ADD_INT:
            case ADD_LONG:
            case SUB_DOUBLE:
            case SUB_FLOAT:
            case SUB_INT:
            case SUB_LONG:
            case MUL_DOUBLE:
            case MUL_FLOAT:
            case MUL_INT:
            case MUL_LONG:
            case DIV_DOUBLE:
            case DIV_FLOAT:
            case DIV_INT:
            case DIV_LONG:
            case REM_DOUBLE:
            case REM_FLOAT:
            case REM_INT:
            case REM_LONG:
            case AND_INT:
            case AND_LONG:
            case OR_INT:
            case OR_LONG:
            case XOR_INT:
            case XOR_LONG:
            case SHL_INT:
            case SHL_LONG:
            case SHR_INT:
            case SHR_LONG:
            case USHR_INT:
            case USHR_LONG:
                Stmt3RNode stmt3RNode = (Stmt3RNode) insn;
                setReg(stmt3RNode.a, interpreter.binaryOperation(insn, getReg(stmt3RNode.b), getReg(stmt3RNode.c)));
                setTmp(null);
                break;
            case IF_EQ:
            case IF_GE:
            case IF_GT:
            case IF_LE:
            case IF_LT:
            case IF_NE:
                JumpStmtNode jumpStmtNode = (JumpStmtNode) insn;
                interpreter.binaryOperation(insn, getReg(jumpStmtNode.a), getReg(jumpStmtNode.b));
                setTmp(null);
                break;
            case IPUT:
            case IPUT_BOOLEAN:
            case IPUT_BYTE:
            case IPUT_CHAR:
            case IPUT_OBJECT:
            case IPUT_SHORT:
            case IPUT_WIDE:
                FieldStmtNode fieldStmtNode1 = (FieldStmtNode) insn;
                interpreter.binaryOperation(insn, getReg(fieldStmtNode1.b), getReg(fieldStmtNode1.a));
                setTmp(null);
                break;
            case APUT:
            case APUT_BOOLEAN:
            case APUT_BYTE:
            case APUT_CHAR:
            case APUT_OBJECT:
            case APUT_SHORT:
            case APUT_WIDE:
                Stmt3RNode stmt3RNode1 = (Stmt3RNode) insn;
                interpreter.ternaryOperation(insn, getReg(stmt3RNode1.b), getReg(stmt3RNode1.c), getReg(stmt3RNode1.a));
                setTmp(null);
                break;
            case INVOKE_VIRTUAL_RANGE:
            case INVOKE_VIRTUAL:
            case INVOKE_SUPER_RANGE:
            case INVOKE_DIRECT_RANGE:
            case INVOKE_SUPER:
            case INVOKE_DIRECT:
            case INVOKE_STATIC_RANGE:
            case INVOKE_STATIC:
            case INVOKE_INTERFACE_RANGE:
            case INVOKE_INTERFACE:
            case INVOKE_CUSTOM:
            case INVOKE_CUSTOM_RANGE:
            case INVOKE_POLYMORPHIC:
            case INVOKE_POLYMORPHIC_RANGE: {
                int i = 0;
                AbstractMethodStmtNode methodStmtNode = (AbstractMethodStmtNode) insn;
                List<V> v;
                Proto proto = methodStmtNode.getProto();
                boolean isStatic = false;
                if (insn.op == Op.INVOKE_STATIC || insn.op == Op.INVOKE_STATIC_RANGE) {
                    isStatic = true;
                } else if (insn.op == Op.INVOKE_CUSTOM || insn.op == Op.INVOKE_CUSTOM_RANGE) {
                    isStatic = true;
                }
                if (isStatic) {
                    v = new ArrayList<>(proto.getParameterTypes().length);
                } else {
                    v = new ArrayList<>(proto.getParameterTypes().length + 1);
                    v.add(getReg(methodStmtNode.args[i++]));
                }

                for (String type : proto.getParameterTypes()) {
                    v.add(getReg(methodStmtNode.args[i]));
                    char t = type.charAt(0);
                    if (t == 'J' || t == 'D') {
                        i += 2;
                    } else {
                        i += 1;
                    }
                }
                setTmp(interpreter.naryOperation(insn, v));
            }
            break;
            case FILLED_NEW_ARRAY:
            case FILLED_NEW_ARRAY_RANGE: {
                FilledNewArrayStmtNode filledNewArrayStmtNode = (FilledNewArrayStmtNode) insn;
                List<V> v = new ArrayList<>(filledNewArrayStmtNode.args.length);
                for (int i = 0; i < filledNewArrayStmtNode.args.length; i++) {
                    v.add(getReg(filledNewArrayStmtNode.args[i]));
                }
                setTmp(interpreter.naryOperation(insn, v));
            }
            break;


            case ADD_DOUBLE_2ADDR:
            case ADD_FLOAT_2ADDR:
            case ADD_INT_2ADDR:
            case ADD_LONG_2ADDR:
            case SUB_DOUBLE_2ADDR:
            case SUB_FLOAT_2ADDR:
            case SUB_INT_2ADDR:
            case SUB_LONG_2ADDR:
            case MUL_DOUBLE_2ADDR:
            case MUL_FLOAT_2ADDR:
            case MUL_INT_2ADDR:
            case MUL_LONG_2ADDR:
            case DIV_DOUBLE_2ADDR:
            case DIV_FLOAT_2ADDR:
            case DIV_INT_2ADDR:
            case DIV_LONG_2ADDR:
            case REM_DOUBLE_2ADDR:
            case REM_FLOAT_2ADDR:
            case REM_INT_2ADDR:
            case REM_LONG_2ADDR:
            case AND_INT_2ADDR:
            case AND_LONG_2ADDR:
            case OR_INT_2ADDR:
            case OR_LONG_2ADDR:
            case XOR_INT_2ADDR:
            case XOR_LONG_2ADDR:
            case SHL_INT_2ADDR:
            case SHL_LONG_2ADDR:
            case SHR_INT_2ADDR:
            case SHR_LONG_2ADDR:
            case USHR_INT_2ADDR:
            case USHR_LONG_2ADDR:
                Stmt2RNode stmt2RNode2 = (Stmt2RNode) insn;
                setReg(stmt2RNode2.a, interpreter.binaryOperation(insn, getReg(stmt2RNode2.a), getReg(stmt2RNode2.b)));
                setTmp(null);
                break;
            case ADD_INT_LIT16:
            case ADD_INT_LIT8:
            case RSUB_INT_LIT8:
            case RSUB_INT:
            case MUL_INT_LIT8:
            case MUL_INT_LIT16:
            case DIV_INT_LIT16:
            case DIV_INT_LIT8:
            case REM_INT_LIT16:
            case REM_INT_LIT8:
            case AND_INT_LIT16:
            case AND_INT_LIT8:
            case OR_INT_LIT16:
            case OR_INT_LIT8:
            case XOR_INT_LIT16:
            case XOR_INT_LIT8:
            case SHL_INT_LIT8:
            case SHR_INT_LIT8:
            case USHR_INT_LIT8:
                Stmt2R1NNode stmt2R1NNode = (Stmt2R1NNode) insn;
                setReg(stmt2R1NNode.distReg, interpreter.unaryOperation(insn, getReg(stmt2R1NNode.srcReg)));
                setTmp(null);
                break;
            case FILL_ARRAY_DATA:
                interpreter.unaryOperation(insn,getReg(((FillArrayDataStmtNode)insn).ra));
                setTmp(null);
                break;
            case GOTO:
            case GOTO_16:
            case GOTO_32:
            case RETURN_VOID:
            case BAD_OP:
                setTmp(null);
                break;
            default:
                throw new RuntimeException("not support " + insn.op);
        }
    }

    public V getTmp() {
        return tmp;
    }

    public void setTmp(V v) {
        this.tmp = v;
    }

    public V getReg(int b) {
        if (b > values.length || b < 0) {
            return null;
        }
        return values[b];
    }

    public int getTotalRegisters() {
        return values.length;
    }

}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/analysis/DvmInterpreter.java`:

```java
package com.googlecode.d2j.node.analysis;

import com.googlecode.d2j.node.insn.DexStmtNode;

import java.util.List;

public abstract class DvmInterpreter<V> {
    
    /**
     * CONST*
     * SGET*
     * NEW
     *
     *
     */
    public abstract V newOperation(DexStmtNode insn) ;

    /**
     * MOVE*
     */
    public abstract V copyOperation(DexStmtNode insn, V value) ;

    /**
     * NEG*
     * *_TO_*
     * IF_*Z
     * *SWITCH
     * IGET*
     * NEW_ARRAY
     * MONITOR_*
     * CHECK_CAST
     * INSTANCEOF

     */
    public abstract V unaryOperation(DexStmtNode insn, V value);

    /**
     * AGET*
     * IPUT*
     *
     */
    public abstract V binaryOperation(DexStmtNode insn, V value1, V value2);

    /**
     * APUT
     */
    public abstract V ternaryOperation(DexStmtNode insn, V value1,
                                       V value2, V value3) ;

    /**
     * INVOKE*
     * MULTIANEWARRAY
     * FilledNewArrayStmt
     */
    public abstract V naryOperation(DexStmtNode insn,
                                    List<? extends V> values) ;

    /**
     * RETURN*
     */
    public abstract void returnOperation(DexStmtNode insn, V value);
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/AbstractMethodStmtNode.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.Proto;
import com.googlecode.d2j.reader.Op;

public abstract class AbstractMethodStmtNode extends DexStmtNode {
    public final int[] args;

    public AbstractMethodStmtNode(Op op, int[] args) {
        super(op);
        this.args = args;
    }

    public abstract Proto getProto();
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/BaseSwitchStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.reader.Op;

public abstract class BaseSwitchStmtNode extends DexStmtNode {

    public final int a;
    public final DexLabel[] labels;

    protected BaseSwitchStmtNode(Op op, int a, DexLabel[] labels) {
        super(op);
        this.a = a;
        this.labels = labels;
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/ConstStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;


public class ConstStmtNode extends DexStmtNode {
    public final int a;
    public final Object value;

    public ConstStmtNode(Op op, int a, Object value) {
        super(op);
        this.a = a;
        this.value = value;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitConstStmt(op, a, value);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/DexLabelStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class DexLabelStmtNode extends DexStmtNode {
    public DexLabel label;

    public DexLabelStmtNode(DexLabel label) {
        super(null);
        this.label = label;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitLabel(label);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/DexStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;


public abstract class DexStmtNode {
    public final Op op;

    public int __index;

    protected DexStmtNode(Op op) {
        this.op = op;
    }

    public abstract void accept(DexCodeVisitor cv);
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/FieldStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.Field;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class FieldStmtNode extends DexStmtNode {

    public final int a;
    public final int b;
    public final Field field;

    public FieldStmtNode(Op op, int a, int b, Field field) {
        super(op);
        this.a = a;
        this.b = b;
        this.field = field;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitFieldStmt(op, a, b, field);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/FillArrayDataStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class FillArrayDataStmtNode extends DexStmtNode {

    public final int ra;
    public final Object array;

    public FillArrayDataStmtNode(Op op, int ra, Object array) {
        super(op);
        this.ra = ra;
        this.array = array;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitFillArrayDataStmt(op, ra, array);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/FilledNewArrayStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class FilledNewArrayStmtNode extends DexStmtNode {

    public final int[] args;
    public final String type;

    public FilledNewArrayStmtNode(Op op, int[] args, String type) {
        super(op);
        this.args = args;
        this.type = type;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitFilledNewArrayStmt(op, args, type);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/JumpStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class JumpStmtNode extends DexStmtNode {
    public final int a;
    public final int b;
    public final DexLabel label;

    public JumpStmtNode(Op op, int a, int b, DexLabel label) {
        super(op);
        this.a = a;
        this.b = b;
        this.label = label;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitJumpStmt(op, a, b, label);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/MethodCustomStmtNode.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.CallSite;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class MethodCustomStmtNode extends AbstractMethodStmtNode {
    public final CallSite callSite;

    public MethodCustomStmtNode(Op op, int[] args, CallSite callSite) {
        super(op, args);
        this.callSite = callSite;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitMethodStmt(op, args, callSite);
    }

    @Override
    public Proto getProto() {
        return callSite.getMethodProto();
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/MethodPolymorphicStmtNode.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class MethodPolymorphicStmtNode extends AbstractMethodStmtNode {
    public final Method method;
    public final Proto proto;

    public MethodPolymorphicStmtNode(Op op, int[] args, Method method, Proto proto) {
        super(op, args);
        this.method = method;
        this.proto = proto;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitMethodStmt(op, args, method, proto);
    }

    @Override
    public Proto getProto() {
        return proto;
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/MethodStmtNode.java`:

```java
/*
 * Copyright (c) 2009-2017 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class MethodStmtNode extends AbstractMethodStmtNode {
    public final Method method;

    public MethodStmtNode(Op op, int[] args, Method method) {
        super(op, args);
        this.method = method;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitMethodStmt(op, args, method);
    }

    @Override
    public Proto getProto() {
        return method.getProto();
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/PackedSwitchStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class PackedSwitchStmtNode extends BaseSwitchStmtNode {

    public final int first_case;

    public PackedSwitchStmtNode(Op op, int a, int first_case, DexLabel[] labels) {
        super(op, a,labels);
        this.first_case = first_case;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitPackedSwitchStmt(op, a, first_case, labels);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/SparseSwitchStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class SparseSwitchStmtNode extends BaseSwitchStmtNode {

    public final int[] cases;

    public SparseSwitchStmtNode(Op op, int a, int[] cases, DexLabel[] labels) {
        super(op, a, labels);
        this.cases = cases;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitSparseSwitchStmt(op, a, cases, labels);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/Stmt0RNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class Stmt0RNode extends DexStmtNode {
    public Stmt0RNode(Op op) {
        super(op);
    }
    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitStmt0R(op);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/Stmt1RNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class Stmt1RNode extends DexStmtNode {

    public final int a;

    public Stmt1RNode(Op op, int a) {
        super(op);
        this.a = a;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitStmt1R(op, a);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/Stmt2R1NNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class Stmt2R1NNode extends DexStmtNode {

    public final int distReg;
    public final int srcReg;
    public final int content;

    public Stmt2R1NNode(Op op, int distReg, int srcReg, int content) {
        super(op);
        this.distReg = distReg;
        this.srcReg = srcReg;
        this.content = content;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitStmt2R1N(op, distReg, srcReg, content);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/Stmt2RNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class Stmt2RNode extends DexStmtNode {
    public final int a;
    public final int b;

    public Stmt2RNode(Op op, int a, int b) {
        super(op);
        this.a = a;
        this.b = b;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitStmt2R(op, a, b);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/Stmt3RNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class Stmt3RNode extends DexStmtNode {
    public final int a;
    public final int b;
    public final int c;

    public Stmt3RNode(Op op, int a, int b, int c) {
        super(op);
        this.a = a;
        this.b = b;
        this.c = c;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitStmt3R(op, a, b, c);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/node/insn/TypeStmtNode.java`:

```java
package com.googlecode.d2j.node.insn;

import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

public class TypeStmtNode extends DexStmtNode {

    public final int a;
    public final int b;
    public final String type;

    public TypeStmtNode(Op op, int a, int b, String type) {
        super(op);
        this.a = a;
        this.b = b;
        this.type = type;
    }

    @Override
    public void accept(DexCodeVisitor cv) {
        cv.visitTypeStmt(op, a, b, type);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/reader/CFG.java`:

```java
package com.googlecode.d2j.reader;

public interface CFG {
    public static final int kInstrCanBranch = 1; // conditional or unconditional branch
    public static final int kInstrCanContinue = 1 << 1; // flow can continue to next statement
    public static final int kInstrCanSwitch = 1 << 2; // switch
    public static final int kInstrCanThrow = 1 << 3; // could cause an exception to be thrown
    public static final int kInstrCanReturn = 1 << 4; // returns, no additional statements
    public static final int kInstrInvoke = 1 << 5; // a flavor of invoke

}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/reader/InstructionFormat.java`:

```java
package com.googlecode.d2j.reader;

public enum InstructionFormat {
    // kFmt00x(0), // unknown format (also used for "breakpoint" opcode)
    kFmt10x(1), // op
    kFmt12x(1), // op vA, vB
    kFmt11n(1), // op vA, #+B
    kFmt11x(1), // op vAA
    kFmt10t(1), // op +AA
    // kFmt20bc(2), // [opt] op AA, thing@BBBB
    kFmt20t(2), // op +AAAA
    kFmt22x(2), // op vAA, vBBBB
    kFmt21t(2), // op vAA, +BBBB
    kFmt21s(2), // op vAA, #+BBBB
    kFmt21h(2), // op vAA, #+BBBB00000[00000000]
    kFmt21c(2), // op vAA, thing@BBBB
    kFmt23x(2), // op vAA, vBB, vCC
    kFmt22b(2), // op vAA, vBB, #+CC
    kFmt22t(2), // op vA, vB, +CCCC
    kFmt22s(2), // op vA, vB, #+CCCC
    kFmt22c(2), // op vA, vB, thing@CCCC
    // kFmt22cs(2), // [opt] op vA, vB, field offset CCCC
    kFmt30t(3), // op +AAAAAAAA
    kFmt32x(3), // op vAAAA, vBBBB
    kFmt31i(3), // op vAA, #+BBBBBBBB
    kFmt31t(3), // op vAA, +BBBBBBBB
    kFmt31c(3), // op vAA, string@BBBBBBBB
    kFmt35c(3), // op {vC,vD,vE,vF,vG}, thing@BBBB
    // kFmt35ms(3), // [opt] invoke-virtual+super
    kFmt3rc(3), // op {vCCCC .. v(CCCC+AA-1)}, thing@BBBB
    // kFmt3rms(3), // [opt] invoke-virtual+super/range
    kFmt45cc(4), // op {vC,vD,vE,vF,vG}, meth@BBBB, proto@HHHH
    kFmt4rcc(4), // op {vCCCC .. vNNNNN}, meth@BBBB, proto@HHHH
    kFmt51l(5), // op vAA, #+BBBBBBBBBBBBBBBB
    // kFmt35mi(3), // [opt] inline invoke
    // kFmt3rmi(3), // [opt] inline invoke/range

    ;
    public int size;

    InstructionFormat(int size) {
        this.size = size;
    }
};

```

`dex-reader-api/src/main/java/com/googlecode/d2j/reader/InstructionIndexType.java`:

```java
package com.googlecode.d2j.reader;

/* package */enum InstructionIndexType {
    kIndexUnknown, //
    kIndexNone, // has no index
    kIndexVaries, // "It depends." Used for throw-verification-error
    kIndexTypeRef, // type reference index
    kIndexStringRef, // string reference index
    kIndexMethodRef, // method reference index
    kIndexFieldRef, // field reference index
    kIndexInlineMethod, // inline method index (for inline linked methods)
    kIndexVtableOffset, // vtable offset (for static linked methods)
    kIndexFieldOffset, // field offset (for static linked fields)
    kIndexMethodAndProtoRef, // 038,
    kIndexCallSiteRef, // 038,
    kIndexMethodHandleRef,    // 039, constant method handle reference index
    kIndexProtoRef,           // 039, prototype reference index
};
```

`dex-reader-api/src/main/java/com/googlecode/d2j/reader/Op.java`:

```java
package com.googlecode.d2j.reader;

import static com.googlecode.d2j.reader.InstructionFormat.*;
import static com.googlecode.d2j.reader.InstructionIndexType.*;

public enum Op implements CFG {
    NOP(0x00, "nop", kFmt10x, kIndexNone, kInstrCanContinue, false), //
    MOVE(0x01, "move", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    MOVE_FROM16(0x02, "move/from16", kFmt22x, kIndexNone, kInstrCanContinue, true), //
    MOVE_16(0x03, "move/16", kFmt32x, kIndexNone, kInstrCanContinue, true), //
    MOVE_WIDE(0x04, "move-wide", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    MOVE_WIDE_FROM16(0x05, "move-wide/from16", kFmt22x, kIndexNone, kInstrCanContinue, true), //
    MOVE_WIDE_16(0x06, "move-wide/16", kFmt32x, kIndexNone, kInstrCanContinue, true), //
    MOVE_OBJECT(0x07, "move-object", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    MOVE_OBJECT_FROM16(0x08, "move-object/from16", kFmt22x, kIndexNone, kInstrCanContinue, true), //
    MOVE_OBJECT_16(0x09, "move-object/16", kFmt32x, kIndexNone, kInstrCanContinue, true), //
    MOVE_RESULT(0x0a, "move-result", kFmt11x, kIndexNone, kInstrCanContinue, true), //
    MOVE_RESULT_WIDE(0x0b, "move-result-wide", kFmt11x, kIndexNone, kInstrCanContinue, true), //
    MOVE_RESULT_OBJECT(0x0c, "move-result-object", kFmt11x, kIndexNone, kInstrCanContinue, true), //
    MOVE_EXCEPTION(0x0d, "move-exception", kFmt11x, kIndexNone, kInstrCanContinue, true), //
    RETURN_VOID(0x0e, "return-void", kFmt10x, kIndexNone, kInstrCanReturn, false), //
    RETURN(0x0f, "return", kFmt11x, kIndexNone, kInstrCanReturn, false), //
    RETURN_WIDE(0x10, "return-wide", kFmt11x, kIndexNone, kInstrCanReturn, false), //
    RETURN_OBJECT(0x11, "return-object", kFmt11x, kIndexNone, kInstrCanReturn, false), //
    CONST_4(0x12, "const/4", kFmt11n, kIndexNone, kInstrCanContinue, true), //
    CONST_16(0x13, "const/16", kFmt21s, kIndexNone, kInstrCanContinue, true), //
    CONST(0x14, "const", kFmt31i, kIndexNone, kInstrCanContinue, true), //
    CONST_HIGH16(0x15, "const/high16", kFmt21h, kIndexNone, kInstrCanContinue, true), //
    CONST_WIDE_16(0x16, "const-wide/16", kFmt21s, kIndexNone, kInstrCanContinue, true), //
    CONST_WIDE_32(0x17, "const-wide/32", kFmt31i, kIndexNone, kInstrCanContinue, true), //
    CONST_WIDE(0x18, "const-wide", kFmt51l, kIndexNone, kInstrCanContinue, true), //
    CONST_WIDE_HIGH16(0x19, "const-wide/high16", kFmt21h, kIndexNone, kInstrCanContinue, true), //
    CONST_STRING(0x1a, "const-string", kFmt21c, kIndexStringRef, kInstrCanContinue | kInstrCanThrow, true), //
    CONST_STRING_JUMBO(0x1b, "const-string/jumbo", kFmt31c, kIndexStringRef, kInstrCanContinue | kInstrCanThrow, true), //
    CONST_CLASS(0x1c, "const-class", kFmt21c, kIndexTypeRef, kInstrCanContinue | kInstrCanThrow, true), //
    MONITOR_ENTER(0x1d, "monitor-enter", kFmt11x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    MONITOR_EXIT(0x1e, "monitor-exit", kFmt11x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    CHECK_CAST(0x1f, "check-cast", kFmt21c, kIndexTypeRef, kInstrCanContinue | kInstrCanThrow, true), //
    INSTANCE_OF(0x20, "instance-of", kFmt22c, kIndexTypeRef, kInstrCanContinue | kInstrCanThrow, true), //
    ARRAY_LENGTH(0x21, "array-length", kFmt12x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    NEW_INSTANCE(0x22, "new-instance", kFmt21c, kIndexTypeRef, kInstrCanContinue | kInstrCanThrow, true), //
    NEW_ARRAY(0x23, "new-array", kFmt22c, kIndexTypeRef, kInstrCanContinue | kInstrCanThrow, true), //
    FILLED_NEW_ARRAY(0x24, "filled-new-array", kFmt35c, kIndexTypeRef, kInstrCanContinue | kInstrCanThrow, true), //
    FILLED_NEW_ARRAY_RANGE(0x25, "filled-new-array/range", kFmt3rc, kIndexTypeRef, kInstrCanContinue | kInstrCanThrow,
            true), //
    FILL_ARRAY_DATA(0x26, "fill-array-data", kFmt31t, kIndexNone, kInstrCanContinue, false), //
    THROW(0x27, "throw", kFmt11x, kIndexNone, kInstrCanThrow, false), //
    GOTO(0x28, "goto", kFmt10t, kIndexNone, kInstrCanBranch, false), //
    GOTO_16(0x29, "goto/16", kFmt20t, kIndexNone, kInstrCanBranch, false), //
    GOTO_32(0x2a, "goto/32", kFmt30t, kIndexNone, kInstrCanBranch, false), //
    PACKED_SWITCH(0x2b, "packed-switch", kFmt31t, kIndexNone, kInstrCanContinue | kInstrCanSwitch, false), //
    SPARSE_SWITCH(0x2c, "sparse-switch", kFmt31t, kIndexNone, kInstrCanContinue | kInstrCanSwitch, false), //
    CMPL_FLOAT(0x2d, "cmpl-float", kFmt23x, kIndexNone, kInstrCanContinue, false), //
    CMPG_FLOAT(0x2e, "cmpg-float", kFmt23x, kIndexNone, kInstrCanContinue, false), //
    CMPL_DOUBLE(0x2f, "cmpl-double", kFmt23x, kIndexNone, kInstrCanContinue, false), //
    CMPG_DOUBLE(0x30, "cmpg-double", kFmt23x, kIndexNone, kInstrCanContinue, false), //
    CMP_LONG(0x31, "cmp-long", kFmt23x, kIndexNone, kInstrCanContinue, false), //
    IF_EQ(0x32, "if-eq", kFmt22t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_NE(0x33, "if-ne", kFmt22t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_LT(0x34, "if-lt", kFmt22t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_GE(0x35, "if-ge", kFmt22t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_GT(0x36, "if-gt", kFmt22t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_LE(0x37, "if-le", kFmt22t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_EQZ(0x38, "if-eqz", kFmt21t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_NEZ(0x39, "if-nez", kFmt21t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_LTZ(0x3a, "if-ltz", kFmt21t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_GEZ(0x3b, "if-gez", kFmt21t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_GTZ(0x3c, "if-gtz", kFmt21t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
    IF_LEZ(0x3d, "if-lez", kFmt21t, kIndexNone, kInstrCanBranch | kInstrCanContinue, false), //
//    UNUSED_3E(0x3e, "unused-3e", null, kIndexUnknown, 0, false), //
//    UNUSED_3F(0x3f, "unused-3f", null, kIndexUnknown, 0, false), //
//    UNUSED_40(0x40, "unused-40", null, kIndexUnknown, 0, false), //
//    UNUSED_41(0x41, "unused-41", null, kIndexUnknown, 0, false), //
//    UNUSED_42(0x42, "unused-42", null, kIndexUnknown, 0, false), //
//    UNUSED_43(0x43, "unused-43", null, kIndexUnknown, 0, false), //
    AGET(0x44, "aget", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AGET_WIDE(0x45, "aget-wide", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AGET_OBJECT(0x46, "aget-object", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AGET_BOOLEAN(0x47, "aget-boolean", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AGET_BYTE(0x48, "aget-byte", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AGET_CHAR(0x49, "aget-char", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AGET_SHORT(0x4a, "aget-short", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    APUT(0x4b, "aput", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    APUT_WIDE(0x4c, "aput-wide", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    APUT_OBJECT(0x4d, "aput-object", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    APUT_BOOLEAN(0x4e, "aput-boolean", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    APUT_BYTE(0x4f, "aput-byte", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    APUT_CHAR(0x50, "aput-char", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    APUT_SHORT(0x51, "aput-short", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, false), //
    IGET(0x52, "iget", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    IGET_WIDE(0x53, "iget-wide", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    IGET_OBJECT(0x54, "iget-object", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    IGET_BOOLEAN(0x55, "iget-boolean", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    IGET_BYTE(0x56, "iget-byte", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    IGET_CHAR(0x57, "iget-char", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    IGET_SHORT(0x58, "iget-short", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    IPUT(0x59, "iput", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    IPUT_WIDE(0x5a, "iput-wide", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    IPUT_OBJECT(0x5b, "iput-object", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    IPUT_BOOLEAN(0x5c, "iput-boolean", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    IPUT_BYTE(0x5d, "iput-byte", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    IPUT_CHAR(0x5e, "iput-char", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    IPUT_SHORT(0x5f, "iput-short", kFmt22c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    SGET(0x60, "sget", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    SGET_WIDE(0x61, "sget-wide", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    SGET_OBJECT(0x62, "sget-object", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    SGET_BOOLEAN(0x63, "sget-boolean", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    SGET_BYTE(0x64, "sget-byte", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    SGET_CHAR(0x65, "sget-char", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    SGET_SHORT(0x66, "sget-short", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, true), //
    SPUT(0x67, "sput", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    SPUT_WIDE(0x68, "sput-wide", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    SPUT_OBJECT(0x69, "sput-object", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    SPUT_BOOLEAN(0x6a, "sput-boolean", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    SPUT_BYTE(0x6b, "sput-byte", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    SPUT_CHAR(0x6c, "sput-char", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    SPUT_SHORT(0x6d, "sput-short", kFmt21c, kIndexFieldRef, kInstrCanContinue | kInstrCanThrow, false), //
    INVOKE_VIRTUAL(0x6e, "invoke-virtual", kFmt35c, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow | kInstrInvoke,
            true), //

    /**
     *  Behavior changed in 037, interface method is allowed
     */
    INVOKE_SUPER(0x6f, "invoke-super", kFmt35c, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow | kInstrInvoke,
            true), //
    INVOKE_DIRECT(0x70, "invoke-direct", kFmt35c, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow | kInstrInvoke,
            true), //
    INVOKE_STATIC(0x71, "invoke-static", kFmt35c, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow | kInstrInvoke,
            true), //
    INVOKE_INTERFACE(0x72, "invoke-interface", kFmt35c, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
//    UNUSED_73(0x73, "unused-73", null, kIndexUnknown, 0, false), //
    INVOKE_VIRTUAL_RANGE(0x74, "invoke-virtual/range", kFmt3rc, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
    INVOKE_SUPER_RANGE(0x75, "invoke-super/range", kFmt3rc, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
    INVOKE_DIRECT_RANGE(0x76, "invoke-direct/range", kFmt3rc, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
    INVOKE_STATIC_RANGE(0x77, "invoke-static/range", kFmt3rc, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
    INVOKE_INTERFACE_RANGE(0x78, "invoke-interface/range", kFmt3rc, kIndexMethodRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
//    UNUSED_79(0x79, "unused-79", null, kIndexUnknown, 0, false), //
//    UNUSED_7A(0x7a, "unused-7a", null, kIndexUnknown, 0, false), //
    NEG_INT(0x7b, "neg-int", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    NOT_INT(0x7c, "not-int", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    NEG_LONG(0x7d, "neg-long", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    NOT_LONG(0x7e, "not-long", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    NEG_FLOAT(0x7f, "neg-float", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    NEG_DOUBLE(0x80, "neg-double", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    INT_TO_LONG(0x81, "int-to-long", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    INT_TO_FLOAT(0x82, "int-to-float", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    INT_TO_DOUBLE(0x83, "int-to-double", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    LONG_TO_INT(0x84, "long-to-int", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    LONG_TO_FLOAT(0x85, "long-to-float", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    LONG_TO_DOUBLE(0x86, "long-to-double", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    FLOAT_TO_INT(0x87, "float-to-int", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    FLOAT_TO_LONG(0x88, "float-to-long", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    FLOAT_TO_DOUBLE(0x89, "float-to-double", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    DOUBLE_TO_INT(0x8a, "double-to-int", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    DOUBLE_TO_LONG(0x8b, "double-to-long", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    DOUBLE_TO_FLOAT(0x8c, "double-to-float", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    INT_TO_BYTE(0x8d, "int-to-byte", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    INT_TO_CHAR(0x8e, "int-to-char", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    INT_TO_SHORT(0x8f, "int-to-short", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    ADD_INT(0x90, "add-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    SUB_INT(0x91, "sub-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    MUL_INT(0x92, "mul-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    DIV_INT(0x93, "div-int", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    REM_INT(0x94, "rem-int", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AND_INT(0x95, "and-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    OR_INT(0x96, "or-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    XOR_INT(0x97, "xor-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    SHL_INT(0x98, "shl-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    SHR_INT(0x99, "shr-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    USHR_INT(0x9a, "ushr-int", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    ADD_LONG(0x9b, "add-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    SUB_LONG(0x9c, "sub-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    MUL_LONG(0x9d, "mul-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    DIV_LONG(0x9e, "div-long", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    REM_LONG(0x9f, "rem-long", kFmt23x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AND_LONG(0xa0, "and-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    OR_LONG(0xa1, "or-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    XOR_LONG(0xa2, "xor-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    SHL_LONG(0xa3, "shl-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    SHR_LONG(0xa4, "shr-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    USHR_LONG(0xa5, "ushr-long", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    ADD_FLOAT(0xa6, "add-float", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    SUB_FLOAT(0xa7, "sub-float", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    MUL_FLOAT(0xa8, "mul-float", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    DIV_FLOAT(0xa9, "div-float", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    REM_FLOAT(0xaa, "rem-float", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    ADD_DOUBLE(0xab, "add-double", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    SUB_DOUBLE(0xac, "sub-double", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    MUL_DOUBLE(0xad, "mul-double", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    DIV_DOUBLE(0xae, "div-double", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    REM_DOUBLE(0xaf, "rem-double", kFmt23x, kIndexNone, kInstrCanContinue, true), //
    ADD_INT_2ADDR(0xb0, "add-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    SUB_INT_2ADDR(0xb1, "sub-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    MUL_INT_2ADDR(0xb2, "mul-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    DIV_INT_2ADDR(0xb3, "div-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    REM_INT_2ADDR(0xb4, "rem-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AND_INT_2ADDR(0xb5, "and-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    OR_INT_2ADDR(0xb6, "or-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    XOR_INT_2ADDR(0xb7, "xor-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    SHL_INT_2ADDR(0xb8, "shl-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    SHR_INT_2ADDR(0xb9, "shr-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    USHR_INT_2ADDR(0xba, "ushr-int/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    ADD_LONG_2ADDR(0xbb, "add-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    SUB_LONG_2ADDR(0xbc, "sub-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    MUL_LONG_2ADDR(0xbd, "mul-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    DIV_LONG_2ADDR(0xbe, "div-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    REM_LONG_2ADDR(0xbf, "rem-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AND_LONG_2ADDR(0xc0, "and-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    OR_LONG_2ADDR(0xc1, "or-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    XOR_LONG_2ADDR(0xc2, "xor-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    SHL_LONG_2ADDR(0xc3, "shl-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    SHR_LONG_2ADDR(0xc4, "shr-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    USHR_LONG_2ADDR(0xc5, "ushr-long/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    ADD_FLOAT_2ADDR(0xc6, "add-float/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    SUB_FLOAT_2ADDR(0xc7, "sub-float/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    MUL_FLOAT_2ADDR(0xc8, "mul-float/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    DIV_FLOAT_2ADDR(0xc9, "div-float/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    REM_FLOAT_2ADDR(0xca, "rem-float/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    ADD_DOUBLE_2ADDR(0xcb, "add-double/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    SUB_DOUBLE_2ADDR(0xcc, "sub-double/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    MUL_DOUBLE_2ADDR(0xcd, "mul-double/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    DIV_DOUBLE_2ADDR(0xce, "div-double/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    REM_DOUBLE_2ADDR(0xcf, "rem-double/2addr", kFmt12x, kIndexNone, kInstrCanContinue, true), //
    ADD_INT_LIT16(0xd0, "add-int/lit16", kFmt22s, kIndexNone, kInstrCanContinue, true), //
    RSUB_INT(0xd1, "rsub-int", kFmt22s, kIndexNone, kInstrCanContinue, true), //
    MUL_INT_LIT16(0xd2, "mul-int/lit16", kFmt22s, kIndexNone, kInstrCanContinue, true), //
    DIV_INT_LIT16(0xd3, "div-int/lit16", kFmt22s, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    REM_INT_LIT16(0xd4, "rem-int/lit16", kFmt22s, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AND_INT_LIT16(0xd5, "and-int/lit16", kFmt22s, kIndexNone, kInstrCanContinue, true), //
    OR_INT_LIT16(0xd6, "or-int/lit16", kFmt22s, kIndexNone, kInstrCanContinue, true), //
    XOR_INT_LIT16(0xd7, "xor-int/lit16", kFmt22s, kIndexNone, kInstrCanContinue, true), //
    ADD_INT_LIT8(0xd8, "add-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    RSUB_INT_LIT8(0xd9, "rsub-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    MUL_INT_LIT8(0xda, "mul-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    DIV_INT_LIT8(0xdb, "div-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    REM_INT_LIT8(0xdc, "rem-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue | kInstrCanThrow, true), //
    AND_INT_LIT8(0xdd, "and-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    OR_INT_LIT8(0xde, "or-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    XOR_INT_LIT8(0xdf, "xor-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    SHL_INT_LIT8(0xe0, "shl-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    SHR_INT_LIT8(0xe1, "shr-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    USHR_INT_LIT8(0xe2, "ushr-int/lit8", kFmt22b, kIndexNone, kInstrCanContinue, true), //
    INVOKE_POLYMORPHIC(0xfa, "invoke-polymorphic", kFmt45cc, kIndexMethodAndProtoRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
    INVOKE_POLYMORPHIC_RANGE(0xfb, "invoke-polymorphic/range", kFmt4rcc, kIndexMethodAndProtoRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
    INVOKE_CUSTOM(0xfc, "invoke-custom", kFmt35c, kIndexCallSiteRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
    INVOKE_CUSTOM_RANGE(0xfd, "invoke-custom/range", kFmt3rc, kIndexCallSiteRef, kInstrCanContinue | kInstrCanThrow
            | kInstrInvoke, true), //
    CONST_METHOD_HANDLE(0xfe, "const-method-handle", kFmt21c, kIndexMethodHandleRef, kInstrCanContinue | kInstrCanThrow
            , true), //
    CONST_METHOD_TYPE(0xff, "const-method-type", kFmt21c, kIndexProtoRef, kInstrCanContinue | kInstrCanThrow
            , true), //
    BAD_OP(-1, "bad-opcode", null, kIndexNone, 0, false), //
    ;
    public int opcode;
    public InstructionFormat format;
    /* package */InstructionIndexType indexType;
    /* package */int flags;
    public String displayName;
    public final static Op ops[] = new Op[256];
    public boolean changeFrame;
    static {
        Op[] ops = Op.ops;
        for (Op op : Op.values()) {
            if (op.opcode >= 0) {
                ops[op.opcode] = op;
            }
        }
    }

    public boolean canBranch() {
        return 0 != (flags & kInstrCanBranch);
    }

    public boolean canContinue() {
        return 0 != (flags & kInstrCanContinue);
    }

    public boolean canReturn() {
        return 0 != (flags & kInstrCanReturn);
    }

    public boolean canSwitch() {
        return 0 != (flags & kInstrCanSwitch);
    }

    public boolean canThrow() {
        return 0 != (flags & kInstrCanThrow);
    }

    Op(int op, String displayName, InstructionFormat fmt, InstructionIndexType indexType, int flags, boolean changeFrame) {
        this.opcode = op;
        this.displayName = displayName;
        this.format = fmt;
        this.indexType = indexType;
        this.flags = flags;
    }

    public String toString() {
        return displayName;
    }
}
```

`dex-reader-api/src/main/java/com/googlecode/d2j/visitors/DexAnnotationAble.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.visitors;

import com.googlecode.d2j.Visibility;

/**
 * 用于访问注解
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public interface DexAnnotationAble {

    /**
     * 访问注解
     * 
     * @param name
     *            注解名
     * @param visibility
     *            是否运行时可见
     * @return
     */
    DexAnnotationVisitor visitAnnotation(String name, Visibility visibility);
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/visitors/DexAnnotationVisitor.java`:

```java
/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2007 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.googlecode.d2j.visitors;

import com.googlecode.d2j.DexType;

/**
 * A visitor to visit a Java annotation. The methods of this interface must be called in the following order: (
 * <tt>visit</tt> | <tt>visitEnum</tt> | <tt>visitAnnotation</tt> | <tt>visitArray</tt>)* <tt>visitEnd</tt>.
 * 
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
public class DexAnnotationVisitor {
    protected DexAnnotationVisitor visitor;

    public DexAnnotationVisitor() {
        super();
    }

    public DexAnnotationVisitor(DexAnnotationVisitor visitor) {
        super();
        this.visitor = visitor;
    }

    /**
     * Visits a primitive value of the annotation.
     * 
     * @param name
     *            the value name.
     * @param value
     *            the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link Character}, {@link Short},
     *            {@link Integer}, {@link Long}, {@link Float}, {@link Double}, {@link String} or {@link DexType}.
     */
    public void visit(String name, Object value) {
        if (visitor != null) {
            visitor.visit(name, value);
        }
    }

    /**
     * Visits an enumeration value of the annotation.
     * 
     * @param name
     *            the value name.
     * @param desc
     *            the class descriptor of the enumeration class.
     * @param value
     *            the actual enumeration value.
     */
    public void visitEnum(String name, String desc, String value) {
        if (this.visitor != null) {
            visitor.visitEnum(name, desc, value);
        }
    }

    /**
     * Visits a nested annotation value of the annotation.
     * 
     * @param name
     *            the value name.
     * @param desc
     *            the class descriptor of the nested annotation class.
     * @return a visitor to visit the actual nested annotation value, or <tt>null</tt> if this visitor is not interested
     *         in visiting this nested annotation. <i>The nested annotation value must be fully visited before calling
     *         other methods on this annotation visitor</i>.
     */
    public DexAnnotationVisitor visitAnnotation(String name, String desc) {
        if (this.visitor != null) {
            return this.visitor.visitAnnotation(name, desc);
        }
        return null;
    }

    public DexAnnotationVisitor visitArray(String name) {
        if (visitor != null) {
            return visitor.visitArray(name);
        }
        return null;
    }

    /**
     * Visits the end of the annotation.
     */
    public void visitEnd() {
        if (this.visitor != null) {
            visitor.visitEnd();
        }
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/visitors/DexClassVisitor.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.visitors;

import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.Visibility;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 */
public class DexClassVisitor implements DexAnnotationAble {
    protected DexClassVisitor visitor;

    public DexClassVisitor() {
        super();
    }

    /**
     * @param dcv
     */
    public DexClassVisitor(DexClassVisitor dcv) {
        super();
        this.visitor = dcv;
    }

    public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
        if (visitor == null) {
            return null;
        }
        return visitor.visitAnnotation(name, visibility);
    }

    public void visitEnd() {
        if (visitor == null) {
            return;
        }
        visitor.visitEnd();
    }

    public DexFieldVisitor visitField(int accessFlags, Field field, Object value) {
        if (visitor == null) {
            return null;
        }
        return visitor.visitField(accessFlags, field, value);
    }

    public DexMethodVisitor visitMethod(int accessFlags, Method method) {
        if (visitor == null) {
            return null;
        }
        return visitor.visitMethod(accessFlags, method);
    }

    public void visitSource(String file) {
        if (visitor == null) {
            return;
        }
        visitor.visitSource(file);
    }

}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/visitors/DexCodeVisitor.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.visitors;

import com.googlecode.d2j.*;
import com.googlecode.d2j.reader.Op;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class DexCodeVisitor {
    protected DexCodeVisitor visitor;

    public DexCodeVisitor() {
        super();
    }

    public DexCodeVisitor(DexCodeVisitor visitor) {
        super();
        this.visitor = visitor;
    }

    public void visitRegister(int total) {
        if (visitor != null) {
            visitor.visitRegister(total);
        }
    }

    /**
     * <pre>
     * OP_X_INT_LIT8
     * </pre>
     * 
     * @param op
     * @param distReg
     * @param srcReg
     * @param content
     */
    public void visitStmt2R1N(Op op, int distReg, int srcReg, int content) {
        if (visitor != null) {
            visitor.visitStmt2R1N(op, distReg, srcReg, content);
        }
    }

    /**
     * <pre>
     * 
     * OP_ADD
     * OP_SUB
     * OP_MUL
     * OP_DIV
     * OP_REM
     * OP_AND
     * OP_OR
     * OP_XOR
     * OP_SHL
     * OP_SHR
     * OP_USHR
     * OP_CMPL
     * OP_CMPG
     * OP_CMP
     * OP_AGETX
     * OP_APUTX
     * </pre>
     * 
     */
    public void visitStmt3R(Op op, int a, int b, int c) {
        if (visitor != null) {
            visitor.visitStmt3R(op, a, b, c);
        }
    }

    /**
     * <pre>
     * OP_INSTANCE_OF
     * OP_NEW_ARRAY
     * OP_CHECK_CAST
     * OP_NEW_INSTANCE
     * </pre>
     * 
     * @param op
     * @param a
     * @param b
     * @param type
     */
    public void visitTypeStmt(Op op, int a, int b, String type) {
        if (visitor != null) {
            visitor.visitTypeStmt(op, a, b, type);
        }
    }

    /**
     * @see Op#CONST
     * @see Op#CONST_4
     * @see Op#CONST_16
     * @see Op#CONST_HIGH16
     * @see Op#CONST_WIDE
     * @see Op#CONST_WIDE_16
     * @see Op#CONST_WIDE_32
     * @see Op#CONST_WIDE_HIGH16
     * @see Op#CONST_STRING
     * @see Op#CONST_STRING_JUMBO
     * @see Op#CONST_CLASS
     * @see Op#CONST_METHOD_HANDLE
     * @see Op#CONST_METHOD_TYPE
     * @param op CONST*
     * @param ra register
     * @param value
     *            Integer,Long,DexType,MethodHandle,Proto
     */
    public void visitConstStmt(Op op, int ra, Object value) {
        if (visitor != null) {
            visitor.visitConstStmt(op, ra, value);
        }
    }

    public void visitFillArrayDataStmt(Op op, int ra, Object array) {
        if (visitor != null) {
            visitor.visitFillArrayDataStmt(op, ra, array);
        }
    }

    public void visitEnd() {
        if (visitor != null) {
            visitor.visitEnd();
        }
    }

    /**
     * <pre>
     * OP_IGETX a,b field
     * OP_IPUTX a,b field
     * OP_SGETX a field
     * OP_SPUTX a field
     * </pre>
     * 
     * @param op
     * @param a
     * @param b
     * @param field
     */
    public void visitFieldStmt(Op op, int a, int b, Field field) {
        if (visitor != null) {
            visitor.visitFieldStmt(op, a, b, field);
        }
    }

    /**
     * <pre>
     * OP_FILLED_NEW_ARRAY
     * </pre>
     * 
     * @param op
     * @param args
     * @param type
     */
    public void visitFilledNewArrayStmt(Op op, int[] args, String type) {
        if (visitor != null) {
            visitor.visitFilledNewArrayStmt(op, args, type);
        }
    }

    /**
     * <pre>
     * OP_IF_EQ
     * OP_IF_NE
     * OP_IF_LT
     * OP_IF_GE
     * OP_IF_GT
     * OP_IF_LE
     * OP_GOTO
     * OP_IF_EQZ
     * OP_IF_NEZ
     * OP_IF_LTZ
     * OP_IF_GEZ
     * OP_IF_GTZ
     * OP_IF_LEZ
     * </pre>
     * 
     * @param op
     * @param a
     * @param b
     * @param label
     */
    public void visitJumpStmt(Op op, int a, int b, DexLabel label) {
        if (visitor != null) {
            visitor.visitJumpStmt(op, a, b, label);
        }
    }

    public void visitLabel(DexLabel label) {
        if (visitor != null) {
            visitor.visitLabel(label);
        }
    }

    public void visitSparseSwitchStmt(Op op, int ra, int[] cases, DexLabel[] labels) {
        if (visitor != null) {
            visitor.visitSparseSwitchStmt(op, ra, cases, labels);
        }
    }

    /**
     * <pre>
     * OP_INVOKE_VIRTUAL
     * OP_INVOKE_SUPER
     * OP_INVOKE_DIRECT
     * OP_INVOKE_STATIC
     * OP_INVOKE_INTERFACE
     * </pre>
     * 
     * @param op
     * @param args
     * @param method
     */
    public void visitMethodStmt(Op op, int[] args, Method method) {
        if (visitor != null) {
            visitor.visitMethodStmt(op, args, method);
        }
    }

    /**
     * <pre>
     * OP_INVOKE_CUSTOM
     * </pre>
     */
    public void visitMethodStmt(Op op, int[] args, CallSite callSite) {
        if (visitor != null) {
            visitor.visitMethodStmt(op, args, callSite);
        }
    }

    /**
     * <pre>
     * OP_INVOKE_POLYMORPHIC
     * </pre>
     *
     */
    public void visitMethodStmt(Op op, int[] args, Method bsm, Proto proto) {
        if (visitor != null) {
            visitor.visitMethodStmt(op, args, bsm, proto);
        }
    }

    /**
     * <pre>
     * OP_MOVE*
     * a = a X b
     * OP_ARRAY_LENGTH
     * a=Xb
     * X_TO_Y
     * </pre>
     * 
     * @param op
     * @param a
     * @param b
     */
    public void visitStmt2R(Op op, int a, int b) {
        if (visitor != null) {
            visitor.visitStmt2R(op, a, b);
        }
    }

    /**
     * 
     * {@link Op#RETURN_VOID} {@link Op#NOP} {@link Op#BAD_OP}
     * 
     * @param op
     */
    public void visitStmt0R(Op op) {
        if (visitor != null) {
            visitor.visitStmt0R(op);
        }
    }

    /**
     * <pre>
     * OP_RETURN_X
     * OP_THROW_X
     * OP_MONITOR_ENTER
     * OP_MONITOR_EXIT
     * OP_MOVE_RESULT_X
     * OP_MOVE_EXCEPTION_X
     * </pre>
     * 
     * @param op
     * @param reg
     */
    public void visitStmt1R(Op op, int reg) {
        if (visitor != null) {
            visitor.visitStmt1R(op, reg);
        }
    }

    public void visitPackedSwitchStmt(Op op, int aA, int first_case, DexLabel[] labels) {
        if (visitor != null) {
            visitor.visitPackedSwitchStmt(op, aA, first_case, labels);
        }
    }

    public void visitTryCatch(DexLabel start, DexLabel end, DexLabel handler[], String type[]) {
        if (visitor != null) {
            visitor.visitTryCatch(start, end, handler, type);
        }
    }

    public DexDebugVisitor visitDebug() {
        if (visitor != null) {
            return visitor.visitDebug();
        }
        return null;
    }

}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/visitors/DexDebugVisitor.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.visitors;

import com.googlecode.d2j.DexLabel;

public class DexDebugVisitor {
    protected DexDebugVisitor visitor;

    public DexDebugVisitor() {
    }

    public DexDebugVisitor(DexDebugVisitor visitor) {
        this.visitor = visitor;
    }

    /**
     * 
     * @param parameterIndex
     *            start with the first index of DexMethod.getParameterTypes(), no 'this'
     * @param name
     */
    public void visitParameterName(int parameterIndex, String name) {
        if (visitor != null) {
            visitor.visitParameterName(parameterIndex, name);
        }
    }

    public void visitStartLocal(int reg, DexLabel label, String name, String type, String signature) {
        if (visitor != null) {
            visitor.visitStartLocal(reg, label, name, type, signature);
        }
    }

    public void visitLineNumber(int line, DexLabel label) {
        if (visitor != null) {
            visitor.visitLineNumber(line, label);
        }
    }

    public void visitEndLocal(int reg, DexLabel label) {
        if (visitor != null) {
            visitor.visitEndLocal(reg, label);
        }
    }

    public void visitSetFile(String file) {
        if (visitor != null) {
            visitor.visitSetFile(file);
        }
    }

    public void visitPrologue(DexLabel dexLabel) {
        if (visitor != null) {
            visitor.visitPrologue(dexLabel);
        }
    }

    public void visitEpiogue(DexLabel dexLabel) {
        if (visitor != null) {
            visitor.visitEpiogue(dexLabel);
        }
    }

    public void visitRestartLocal(int reg, DexLabel label) {
        if (visitor != null) {
            visitor.visitRestartLocal(reg, label);
        }
    }

    public void visitEnd() {
        if (visitor != null) {
            visitor.visitEnd();
        }
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/visitors/DexFieldVisitor.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.googlecode.d2j.visitors;

import com.googlecode.d2j.Visibility;

/**
 * @author bob
 * 
 */
public class DexFieldVisitor implements DexAnnotationAble {
    protected DexFieldVisitor visitor;

    public DexFieldVisitor(DexFieldVisitor visitor) {
        super();
        this.visitor = visitor;
    }

    public DexFieldVisitor() {
    }

    public void visitEnd() {
        if (visitor == null) {
            return;
        }
        visitor.visitEnd();
    }

    public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
        if (visitor == null) {
            return null;
        }
        return visitor.visitAnnotation(name, visibility);
    }
}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/visitors/DexFileVisitor.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.visitors;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class DexFileVisitor {
    protected DexFileVisitor visitor;

    public DexFileVisitor() {
        super();
    }

    public DexFileVisitor(DexFileVisitor visitor) {
        super();
        this.visitor = visitor;
    }

    public void visitDexFileVersion(int version) {
        if (visitor != null) {
            visitor.visitDexFileVersion(version);
        }
    }

    public DexClassVisitor visit(int access_flags, String className, String superClass, String[] interfaceNames) {
        if (visitor == null) {
            return null;
        }
        return visitor.visit(access_flags, className, superClass, interfaceNames);
    }

    public void visitEnd() {
        if (visitor == null) {
            return;
        }
        visitor.visitEnd();
    }

}

```

`dex-reader-api/src/main/java/com/googlecode/d2j/visitors/DexMethodVisitor.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.visitors;

import com.googlecode.d2j.Visibility;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class DexMethodVisitor implements DexAnnotationAble {
    protected DexMethodVisitor visitor;

    public DexMethodVisitor() {
        super();
    }

    /**
     * @param mv
     */
    public DexMethodVisitor(DexMethodVisitor mv) {
        super();
        this.visitor = mv;
    }

    public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
        if (visitor == null) {
            return null;
        }
        return visitor.visitAnnotation(name, visibility);
    }

    public DexCodeVisitor visitCode() {
        if (visitor == null) {
            return null;
        }
        return visitor.visitCode();
    }

    public void visitEnd() {
        if (visitor == null) {
            return;
        }
        visitor.visitEnd();
    }

    public DexAnnotationAble visitParameterAnnotation(int index) {
        if (visitor == null) {
            return null;
        }
        return visitor.visitParameterAnnotation(index);
    }

}

```

`dex-reader/build.gradle`:

```gradle
description = 'Dex Reader'

dependencies {
    compile project(':dex-reader-api')
    testCompile (group: 'org.apache.commons', name: 'commons-compress', version:'1.4.1')
}



```

`dex-reader/src/main/java/com/googlecode/d2j/reader/BaseDexFileReader.java`:

```java
package com.googlecode.d2j.reader;

import com.googlecode.d2j.visitors.DexFileVisitor;

import java.util.List;

public interface BaseDexFileReader {

    int getDexVersion();

    void accept(DexFileVisitor dv);

    List<String> getClassNames();

    void accept(DexFileVisitor dv, int config);

    void accept(DexFileVisitor dv, int classIdx, int config);
}

```

`dex-reader/src/main/java/com/googlecode/d2j/reader/DexFileReader.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.reader;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

import com.googlecode.d2j.*;
import com.googlecode.d2j.node.DexAnnotationNode;
import com.googlecode.d2j.util.Mutf8;
import com.googlecode.d2j.visitors.*;

import static com.googlecode.d2j.DexConstants.*;

/**
 * Open and read a dex file.this is the entrance of dex-reader. to read a dex/odex, use the following code:
 * 
 * <pre>
 * DexFileVisitor visitor = new xxxFileVisitor();
 * DexFileReader reader = new DexFileReader(dexFile);
 * reader.accept(visitor);
 * </pre>
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class DexFileReader implements BaseDexFileReader {
    /**
     * skip debug infos in dex file.
     */
    public static final int SKIP_DEBUG = 1;
    /**
     * skip code info in dex file, this indicate {@link #SKIP_DEBUG}
     */
    public static final int SKIP_CODE = 1 << 2;
    /**
     * skip annotation info in dex file.
     */
    public static final int SKIP_ANNOTATION = 1 << 3;
    /**
     * skip field constant in dex file.
     */
    public static final int SKIP_FIELD_CONSTANT = 1 << 4;
    /**
     * ingore read exception
     */
    public static final int IGNORE_READ_EXCEPTION = 1 << 5;
    /**
     * read all methods, even if they are glitch
     */
    public static final int KEEP_ALL_METHODS = 1 << 6;
    /**
     * keep clinit method when {@link #SKIP_DEBUG}
     */
    public static final int KEEP_CLINIT = 1 << 7;

    /**
     * keep clinit method when {@link #SKIP_DEBUG}
     */
    public static final int SKIP_EXCEPTION = 1 << 8;

    // private static final int REVERSE_ENDIAN_CONSTANT = 0x78563412;

    static final int DBG_END_SEQUENCE = 0x00;
    static final int DBG_ADVANCE_PC = 0x01;
    static final int DBG_ADVANCE_LINE = 0x02;
    static final int DBG_START_LOCAL = 0x03;
    static final int DBG_START_LOCAL_EXTENDED = 0x04;
    static final int DBG_END_LOCAL = 0x05;
    static final int DBG_RESTART_LOCAL = 0x06;
    static final int DBG_SET_PROLOGUE_END = 0x07;
    static final int DBG_SET_EPILOGUE_BEGIN = 0x08;
    static final int DBG_SET_FILE = 0x09;
    static final int DBG_FIRST_SPECIAL = 0x0a;
    static final int DBG_LINE_BASE = -4;
    static final int DBG_LINE_RANGE = 15;

    private static final int ENDIAN_CONSTANT = 0x12345678;
    private static final int VALUE_BYTE = 0x00;
    private static final int VALUE_SHORT = 0x02;
    private static final int VALUE_CHAR = 0x03;
    private static final int VALUE_INT = 0x04;
    private static final int VALUE_LONG = 0x06;
    private static final int VALUE_FLOAT = 0x10;
    private static final int VALUE_DOUBLE = 0x11;
    private static final int VALUE_METHOD_TYPE = 0x15;
    private static final int VALUE_METHOD_HANDLE = 0x16;
    private static final int VALUE_STRING = 0x17;
    private static final int VALUE_TYPE = 0x18;
    private static final int VALUE_FIELD = 0x19;
    private static final int VALUE_METHOD = 0x1a;
    private static final int VALUE_ENUM = 0x1b;
    private static final int VALUE_ARRAY = 0x1c;
    private static final int VALUE_ANNOTATION = 0x1d;
    private static final int VALUE_NULL = 0x1e;
    private static final int VALUE_BOOLEAN = 0x1f;

    private static final int TYPE_CALL_SITE_ID_ITEM = 0x0007;
    private static final int TYPE_METHOD_HANDLE_ITEM = 0x0008;

    final ByteBuffer annotationSetRefListIn;
    final ByteBuffer annotationsDirectoryItemIn;
    final ByteBuffer annotationSetItemIn;
    final ByteBuffer annotationItemIn;
    final ByteBuffer classDataIn;
    final ByteBuffer codeItemIn;
    final ByteBuffer encodedArrayItemIn;
    final ByteBuffer stringIdIn;
    final ByteBuffer typeIdIn;
    final ByteBuffer protoIdIn;
    final ByteBuffer fieldIdIn;
    final ByteBuffer methoIdIn;
    final ByteBuffer classDefIn;
    final ByteBuffer typeListIn;
    final ByteBuffer stringDataIn;
    final ByteBuffer debugInfoIn;
    final ByteBuffer callSiteIdIn;
    final ByteBuffer methodHandleIdIn;
    final int string_ids_size;
    final int type_ids_size;
    final int proto_ids_size;
    final int field_ids_size;
    final int method_ids_size;
    final private int class_defs_size;
    final int call_site_ids_size;
    final int method_handle_ids_size;
    final int dex_version;

    /**
     * read dex from a {@link ByteBuffer}.
     * 
     * @param in
     */
    public DexFileReader(ByteBuffer in) {
        in.position(0);
        in = in.asReadOnlyBuffer().order(ByteOrder.BIG_ENDIAN);
        int magic = in.getInt() & 0xFFFFFF00;

        final int MAGIC_DEX = 0x6465780A & 0xFFFFFF00;// hex for 'dex ', ignore the 0A
        final int MAGIC_ODEX = 0x6465790A & 0xFFFFFF00;// hex for 'dey ', ignore the 0A

        if (magic == MAGIC_DEX) {
            // ok
        } else if (magic == MAGIC_ODEX) {
            throw new DexException("Odex unsupported.");
        } else {
            throw new DexException("Magic unsupported.");
        }
        int version = in.getInt() >> 8;
        if (version < DEX_035 || version > DEX_040) {
            System.err.println("Unknown DEX version. Trying anyway...");
        }
        this.dex_version = version;
        in.order(ByteOrder.LITTLE_ENDIAN);

        // skip uint checksum
        // and 20 bytes signature
        // and uint file_size
        // and uint header_size 0x70
        skip(in, 4 + 20 + 4 + 4);

        int endian_tag = in.getInt();
        if (endian_tag != ENDIAN_CONSTANT) {
            throw new DexException("Endian_tag unsupported");
        }

        // skip uint link_size
        // and uint link_off
        skip(in, 4 + 4);

        int map_off = in.getInt();

        string_ids_size = in.getInt();
        int string_ids_off = in.getInt();
        type_ids_size = in.getInt();
        int type_ids_off = in.getInt();
        proto_ids_size = in.getInt();
        int proto_ids_off = in.getInt();
        field_ids_size = in.getInt();
        int field_ids_off = in.getInt();
        method_ids_size = in.getInt();
        int method_ids_off = in.getInt();
        class_defs_size = in.getInt();
        int class_defs_off = in.getInt();
        // skip uint data_size data_off

        int call_site_ids_off = 0;
        int call_site_ids_size = 0;
        int method_handle_ids_off = 0;
        int method_handle_ids_size = 0;
        if (dex_version >= DEX_038) {
            in.position(map_off);
            int size = in.getInt();
            for (int i = 0; i < size; i++) {
                int type = in.getShort() & 0xFFFF;
                in.getShort(); // unused;
                int item_size = in.getInt();
                int item_offset = in.getInt();
                switch (type) {
                case TYPE_CALL_SITE_ID_ITEM:
                    call_site_ids_off = item_offset;
                    call_site_ids_size = item_size;
                    break;
                case TYPE_METHOD_HANDLE_ITEM:
                    method_handle_ids_off = item_offset;
                    method_handle_ids_size = item_size;
                    break;
                default:
                    break;
                }
            }
        }
        this.call_site_ids_size = call_site_ids_size;
        this.method_handle_ids_size = method_handle_ids_size;

        stringIdIn = slice(in, string_ids_off, string_ids_size * 4);
        typeIdIn = slice(in, type_ids_off, type_ids_size * 4);
        protoIdIn = slice(in, proto_ids_off, proto_ids_size * 12);
        fieldIdIn = slice(in, field_ids_off, field_ids_size * 8);
        methoIdIn = slice(in, method_ids_off, method_ids_size * 8);
        classDefIn = slice(in, class_defs_off, class_defs_size * 32);
        callSiteIdIn = slice(in, call_site_ids_off, call_site_ids_size * 4);
        methodHandleIdIn = slice(in, method_handle_ids_off, method_handle_ids_size * 8);

        in.position(0);
        annotationsDirectoryItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        annotationSetItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        annotationItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        annotationSetRefListIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        classDataIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        codeItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        stringDataIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        encodedArrayItemIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        typeListIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        debugInfoIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
    }

    /**
     * 
     * @param data
     *            the byte array of dex
     * @return
     */
    public DexFileReader(byte[] data) {
        this(ByteBuffer.wrap(data));
    }

    /**
     * 
     * @param file
     *            the dex file
     * @throws IOException
     */
    public DexFileReader(File file) throws IOException {
        this(file.toPath());
    }

    public DexFileReader(Path file) throws IOException {
        this(Files.readAllBytes(file));
    }

    public DexFileReader(InputStream is) throws IOException {
        this(toByteArray(is));
    }

    /**
     * Reads a string index. String indices are offset by 1, and a 0 value in the stream (-1 as returned by this
     * method) means "null"
     * 
     * @return index into file's string ids table, -1 means null
     */
    private static int readStringIndex(ByteBuffer bs) {
        int offsetIndex = readULeb128i(bs);
        return offsetIndex - 1;
    }

    private static byte[] toByteArray(InputStream is) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buff = new byte[1024];
        for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }
        return out.toByteArray();
    }

    private static ByteBuffer slice(ByteBuffer in, int offset, int length) {
        in.position(offset);
        ByteBuffer b = in.slice();
        b.limit(length);
        b.order(ByteOrder.LITTLE_ENDIAN);
        return b;
    }

    private static void skip(ByteBuffer in, int bytes) {
        in.position(in.position() + bytes);
    }

    public static void niceExceptionMessage(Throwable t, int deep) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < deep + 1; i++) {
            sb.append(".");
        }
        sb.append(' ');
        if (t instanceof DexException) {
            sb.append(t.getMessage());
            System.err.println(sb);
            if (t.getCause() != null) {
                niceExceptionMessage(t.getCause(), deep + 1);
            }
        } else {
            if (t != null) {
                System.err.println(sb.append("ROOT cause:"));
                t.printStackTrace(System.err);
            }
        }
    }

    private static long readIntBits(ByteBuffer in, int before) {
        int length = ((before >> 5) & 0x7) + 1;
        long value = 0;
        for (int j = 0; j < length; j++) {
            value |= ((long) (0xFF & in.get())) << (j * 8);
        }
        int shift = (8 - length) * 8;
        return value << shift >> shift;
    }

    private static long readUIntBits(ByteBuffer in, int before) {
        int length = ((before >> 5) & 0x7) + 1;
        long value = 0;
        for (int j = 0; j < length; j++) {
            value |= ((long) (0xFF & in.get())) << (j * 8);
        }
        return value;
    }

    private static long readFloatBits(ByteBuffer in, int before) {
        int bytes = ((before >> 5) & 0x7) + 1;
        long result = 0L;
        for (int i = 0; i < bytes; ++i) {
            result |= ((long) (0xFF & in.get())) << (i * 8);
        }
        result <<= (8 - bytes) * 8L;
        return result;
    }

    static int sshort(byte[] data, int offset) {
        return (data[offset + 1] << 8) | (0xFF & data[offset]);
    }

    static int ushort(byte[] data, int offset) {
        return ((0xFF & data[offset + 1]) << 8) | (0xFF & data[offset]);
    }

    static int sint(byte[] data, int offset) {
        return (data[offset + 3] << 24) | ((0xFF & data[offset + 2]) << 16) | ((0xFF & data[offset + 1]) << 8)
                | ((0xFF & data[offset]));
    }

    static int uint(byte[] data, int offset) {
        return sint(data, offset);
    }

    static void WARN(String fmt, Object... args) {
        System.err.printf((fmt) + "%n", args);
    }

    static int ubyte(byte[] insns, int offset) {
        return 0xFF & insns[offset];
    }

    static int sbyte(byte[] insns, int offset) {
        return insns[offset];
    }

    private static void order(Map<Integer, DexLabel> labelsMap, int offset) {
        if (!labelsMap.containsKey(offset)) {
            labelsMap.put(offset, new DexLabel(offset));
        }
    }

    public static int readULeb128i(ByteBuffer in) {
        int value = 0;
        int count = 0;
        int b = in.get();
        while ((b & 0x80) != 0) {
            value |= (b & 0x7f) << count;
            count += 7;
            b = in.get();
        }
        value |= (b & 0x7f) << count;
        return value;
    }

    public static int readLeb128i(ByteBuffer in) {
        int bitpos = 0;
        int vln = 0;
        do {
            int inp = in.get();
            vln |= (inp & 0x7F) << bitpos;
            bitpos += 7;
            if ((inp & 0x80) == 0) {
                break;
            }
        } while (true);
        if (((1L << (bitpos - 1)) & vln) != 0) {
            vln -= (1L << bitpos);
        }
        return vln;
    }

    private static void DEBUG_DEBUG(String fmt, Object... args) {
        // System.out.println(String.format(fmt, args));
    }

    private void read_debug_info(int offset, int regSize, boolean isStatic, Method method,
            Map<Integer, DexLabel> labelMap, DexDebugVisitor dcv) {
        ByteBuffer in = debugInfoIn;
        in.position(offset);
        int address = 0;
        int line = readULeb128i(in);
        int szParams = readULeb128i(in);
        LocalEntry[] lastEntryForReg = new LocalEntry[regSize];
        int argsSize = 0;
        for (String paramType : method.getParameterTypes()) {
            if (paramType.equals("J") || paramType.equals("D")) {
                argsSize += 2;
            } else {
                argsSize += 1;
            }
        }
        int curReg = regSize - argsSize;
        if (!isStatic) {
            // Start off with implicit 'this' entry
            LocalEntry thisEntry = new LocalEntry("this", method.getOwner(), null);
            lastEntryForReg[curReg - 1] = thisEntry;
            // dcv.visitParameterName(curReg - 1, "this");
            DEBUG_DEBUG("v%d :%s, %s", curReg - 1, "this", method.getOwner());
        }

        String[] params = method.getParameterTypes();
        for (int i = 0; i < szParams; i++) {
            String paramType = params[i];
            LocalEntry le;

            int nameIdx = readStringIndex(in);
            String name = getString(nameIdx);
            le = new LocalEntry(name, paramType);
            lastEntryForReg[curReg] = le;
            if (name != null) {
                dcv.visitParameterName(i, name);
            }
            DEBUG_DEBUG("v%d :%s, %s", curReg, name, paramType);
            curReg += 1;
            if (paramType.equals("J") || paramType.equals("D")) {
                curReg += 1;
            }
        }

        for (;;) {
            int opcode = in.get() & 0xff;

            switch (opcode) {
            case DBG_START_LOCAL: {
                int reg = readULeb128i(in);
                int nameIdx = readStringIndex(in);
                int typeIdx = readStringIndex(in);
                String name = getString(nameIdx);
                String type = getType(typeIdx);
                DEBUG_DEBUG("Start: v%d :%s, %s", reg, name, type);
                LocalEntry le = new LocalEntry(name, type);
                lastEntryForReg[reg] = le;
                order(labelMap, address);
                dcv.visitStartLocal(reg, labelMap.get(address), name, type, null);
            }
                break;

            case DBG_START_LOCAL_EXTENDED: {
                int reg = readULeb128i(in);
                int nameIdx = readStringIndex(in);
                int typeIdx = readStringIndex(in);
                int sigIdx = readStringIndex(in);
                String name = getString(nameIdx);
                String type = getType(typeIdx);
                String signature = getString(sigIdx);
                DEBUG_DEBUG("Start: v%d :%s, %s // %s", reg, name, type, signature);
                LocalEntry le = new LocalEntry(name, type, signature);
                order(labelMap, address);
                dcv.visitStartLocal(reg, labelMap.get(address), name, type, signature);
                lastEntryForReg[reg] = le;
            }
                break;

            case DBG_RESTART_LOCAL: {
                int reg = readULeb128i(in);
                LocalEntry le = lastEntryForReg[reg];
                if (le == null) {
                    throw new RuntimeException("Encountered RESTART_LOCAL on new v" + reg);
                }
                if (le.signature == null) {
                    DEBUG_DEBUG("Start: v%d :%s, %s", reg, le.name, le.type);
                } else {
                    DEBUG_DEBUG("Start: v%d :%s, %s // %s", reg, le.name, le.type, le.signature);
                }
                order(labelMap, address);
                dcv.visitRestartLocal(reg, labelMap.get(address));
            }
                break;

            case DBG_END_LOCAL: {
                int reg = readULeb128i(in);
                LocalEntry le = lastEntryForReg[reg];
                if (le == null) {
                    throw new RuntimeException("Encountered RESTART_LOCAL on new v" + reg);
                }
                if (le.signature == null) {
                    DEBUG_DEBUG("End: v%d :%s, %s", reg, le.name, le.type);
                } else {
                    DEBUG_DEBUG("End: v%d :%s, %s // %s", reg, le.name, le.type, le.signature);
                }
                order(labelMap, address);
                dcv.visitEndLocal(reg, labelMap.get(address));
            }
                break;

            case DBG_END_SEQUENCE:
                // all done
                return;

            case DBG_ADVANCE_PC:
                address += readULeb128i(in);
                break;

            case DBG_ADVANCE_LINE:
                line += readLeb128i(in);
                break;

            case DBG_SET_PROLOGUE_END:
                order(labelMap, address);
                dcv.visitPrologue(labelMap.get(address));
                break;
            case DBG_SET_EPILOGUE_BEGIN:
                order(labelMap, address);
                dcv.visitEpiogue(labelMap.get(address));
                break;
            case DBG_SET_FILE:
                // skip
                break;

            default:
                if (opcode < DBG_FIRST_SPECIAL) {
                    throw new RuntimeException("Invalid extended opcode encountered " + opcode);
                }

                int adjopcode = opcode - DBG_FIRST_SPECIAL;

                address += adjopcode / DBG_LINE_RANGE;
                line += DBG_LINE_BASE + (adjopcode % DBG_LINE_RANGE);

                order(labelMap, address);
                dcv.visitLineNumber(line, labelMap.get(address));
                break;

            }
        }
    }

    @Override
    public int getDexVersion() {
        return dex_version;
    }

    /**
     * equals to {@link #accept(DexFileVisitor, int)} with 0 as config
     * 
     * @param dv
     */
    @Override
    public void accept(DexFileVisitor dv) {
        this.accept(dv, 0);
    }

    @Override
    public List<String> getClassNames() {
        List<String> names = new ArrayList<>(class_defs_size);
        ByteBuffer in = classDefIn;
        for (int cid = 0; cid < class_defs_size; cid++) {
            in.position(cid * 32);
            String className = this.getType(in.getInt());
            names.add(className);
        }
        return names;
    }

    /**
     * Makes the given visitor visit the dex file.
     * 
     * @param dv
     *            visitor
     * @param config
     *            config flags, {@link #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_ANNOTATION},
     *            {@link #SKIP_FIELD_CONSTANT}
     */
    @Override
    public void accept(DexFileVisitor dv, int config) {
        dv.visitDexFileVersion(this.dex_version);
        for (int cid = 0; cid < class_defs_size; cid++) {
            accept(dv, cid, config);
        }
        dv.visitEnd();
    }

    /**
     * Makes the given visitor visit the dex file. Notice the
     * {@link com.googlecode.d2j.visitors.DexFileVisitor#visitEnd()} is not called
     * 
     * @param dv
     *            visitor
     * @param classIdx
     *            index of class_def
     * @param config
     *            config flags, {@link #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_ANNOTATION},
     *            {@link #SKIP_FIELD_CONSTANT}
     */
    @Override
    public void accept(DexFileVisitor dv, int classIdx, int config) {
        classDefIn.position(classIdx * 32);
        int class_idx = classDefIn.getInt();
        int access_flags = classDefIn.getInt();
        int superclass_idx = classDefIn.getInt();
        int interfaces_off = classDefIn.getInt();
        int source_file_idx = classDefIn.getInt();
        int annotations_off = classDefIn.getInt();
        int class_data_off = classDefIn.getInt();
        int static_values_off = classDefIn.getInt();

        String className = getType(class_idx);
        if(ignoreClass(className)) return;
        String superClassName = getType(superclass_idx);
        String[] interfaceNames = getTypeList(interfaces_off);
        try {
            DexClassVisitor dcv = dv.visit(access_flags, className, superClassName, interfaceNames);
            if (dcv != null)// 不处理
            {
                acceptClass(dcv, source_file_idx, annotations_off, class_data_off, static_values_off, config);
                dcv.visitEnd();
            }
        } catch (Exception ex) {
            DexException dexException = new DexException(ex, "Error process class: [%d]%s", class_idx, className);
            if (0 != (config & IGNORE_READ_EXCEPTION)) {
                niceExceptionMessage(dexException, 0);
            } else {
                throw dexException;
            }
        }
    }

    public Boolean ignoreClass(String className){
       return false;
    }

    private Object readEncodedValue(ByteBuffer in) {
        int b = 0xFF & in.get();
        int type = b & 0x1f;
        switch (type) {
        case VALUE_BYTE:
            return (byte) readIntBits(in, b);

        case VALUE_SHORT:
            return (short) readIntBits(in, b);

        case VALUE_CHAR:
            return (char) readUIntBits(in, b);

        case VALUE_INT:
            return (int) readIntBits(in, b);

        case VALUE_LONG:
            return readIntBits(in, b);

        case VALUE_FLOAT:
            return Float.intBitsToFloat((int) (readFloatBits(in, b) >> 32));

        case VALUE_DOUBLE:
            return Double.longBitsToDouble(readFloatBits(in, b));
        case VALUE_METHOD_TYPE:
            return getProto((int) readUIntBits(in, b));
        case VALUE_METHOD_HANDLE:
            return getMethodHandle((int) readUIntBits(in, b));

        case VALUE_STRING:
            return getString((int) readUIntBits(in, b));

        case VALUE_TYPE: {
            int type_id = (int) readUIntBits(in, b);
            return new DexType(getType(type_id));
        }
        case VALUE_FIELD: {
            int field_id = (int) readUIntBits(in, b);
            return getField(field_id);
        }
        case VALUE_METHOD: {
            int method_id = (int) readUIntBits(in, b);
            return getMethod(method_id);

        }
        case VALUE_ENUM: {
            return getField((int) readUIntBits(in, b));
        }
        case VALUE_ARRAY: {
            return read_encoded_array(in);
        }
        case VALUE_ANNOTATION: {
            return read_encoded_annotation(in);
        }
        case VALUE_NULL:
            return null;
        case VALUE_BOOLEAN: {
            return ((b >> 5) & 0x3) != 0;
        }
        default:
            throw new DexException("Not support yet.");
        }
    }

    private MethodHandle getMethodHandle(int i) {
        methodHandleIdIn.position(i * 8);
        int method_handle_type = methodHandleIdIn.getShort() & 0xFFFF;
        methodHandleIdIn.getShort();//unused
        int field_or_method_id = methodHandleIdIn.getShort() & 0xFFFF;

        switch (method_handle_type) {
        case MethodHandle.INSTANCE_GET:
        case MethodHandle.INSTANCE_PUT:
        case MethodHandle.STATIC_GET:
        case MethodHandle.STATIC_PUT:
            return new MethodHandle(method_handle_type, getField(field_or_method_id));

        case MethodHandle.INVOKE_INSTANCE:
        case MethodHandle.INVOKE_STATIC:
        case MethodHandle.INVOKE_CONSTRUCTOR:
        case MethodHandle.INVOKE_DIRECT:
        case MethodHandle.INVOKE_INTERFACE:
            return new MethodHandle(method_handle_type, getMethod(field_or_method_id));
        default:
            throw new RuntimeException();
        }
    }

    private void acceptClass(DexClassVisitor dcv, int source_file_idx, int annotations_off, int class_data_off,
            int static_values_off, int config) {
        if ((config & SKIP_DEBUG) == 0) {
            // 获取源文件
            if (source_file_idx != -1) {
                dcv.visitSource(this.getString(source_file_idx));
            }
        }

        Map<Integer, Integer> fieldAnnotationPositions;
        Map<Integer, Integer> methodAnnotationPositions;
        Map<Integer, Integer> paramAnnotationPositions;
        if ((config & SKIP_ANNOTATION) == 0) {
            // 获取注解
            fieldAnnotationPositions = new HashMap<>();
            methodAnnotationPositions = new HashMap<>();
            paramAnnotationPositions = new HashMap<>();
            if (annotations_off != 0) { // annotations_directory_item

                annotationsDirectoryItemIn.position(annotations_off);

                int class_annotations_off = annotationsDirectoryItemIn.getInt();
                int field_annotation_size = annotationsDirectoryItemIn.getInt();
                int method_annotation_size = annotationsDirectoryItemIn.getInt();
                int parameter_annotation_size = annotationsDirectoryItemIn.getInt();

                for (int i = 0; i < field_annotation_size; i++) {
                    int field_idx = annotationsDirectoryItemIn.getInt();
                    int field_annotations_offset = annotationsDirectoryItemIn.getInt();
                    fieldAnnotationPositions.put(field_idx, field_annotations_offset);
                }
                for (int i = 0; i < method_annotation_size; i++) {
                    int method_idx = annotationsDirectoryItemIn.getInt();
                    int method_annotation_offset = annotationsDirectoryItemIn.getInt();
                    methodAnnotationPositions.put(method_idx, method_annotation_offset);
                }
                for (int i = 0; i < parameter_annotation_size; i++) {
                    int method_idx = annotationsDirectoryItemIn.getInt();
                    int parameter_annotation_offset = annotationsDirectoryItemIn.getInt();
                    paramAnnotationPositions.put(method_idx, parameter_annotation_offset);
                }

                if (class_annotations_off != 0) {
                    try {
                        read_annotation_set_item(class_annotations_off, dcv);
                    } catch (Exception e) {
                        throw new DexException("error on reading Annotation of class ", e);
                    }
                }
            }
        } else {
            fieldAnnotationPositions = null;
            methodAnnotationPositions = null;
            paramAnnotationPositions = null;
        }

        if (class_data_off != 0) {
            ByteBuffer in = classDataIn;
            in.position(class_data_off);

            int static_fields = readULeb128i(in);
            int instance_fields = readULeb128i(in);
            int direct_methods = readULeb128i(in);
            int virtual_methods = readULeb128i(in);
            {
                int lastIndex = 0;
                {
                    Object[] constant = null;
                    if ((config & SKIP_FIELD_CONSTANT) == 0) {
                        if (static_values_off != 0) {
                            constant = read_encoded_array_item(static_values_off);
                        }
                    }
                    for (int i = 0; i < static_fields; i++) {
                        Object value = null;
                        if (constant != null && i < constant.length) {
                            value = constant[i];
                        }
                        lastIndex = acceptField(in, lastIndex, dcv, fieldAnnotationPositions, value, config);
                    }
                }
                lastIndex = 0;
                for (int i = 0; i < instance_fields; i++) {
                    lastIndex = acceptField(in, lastIndex, dcv, fieldAnnotationPositions, null, config);
                }
                lastIndex = 0;
                boolean firstMethod = true;
                for (int i = 0; i < direct_methods; i++) {
                    lastIndex = acceptMethod(in, lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,
                            config, firstMethod);
                    firstMethod = false;
                }
                lastIndex = 0;
                firstMethod = true;
                for (int i = 0; i < virtual_methods; i++) {
                    lastIndex = acceptMethod(in, lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,
                            config, firstMethod);
                    firstMethod = false;
                }
            }

        }
    }

    private Object[] read_encoded_array_item(int static_values_off) {
        encodedArrayItemIn.position(static_values_off);
        return read_encoded_array(encodedArrayItemIn);
    }

    private Object[] read_encoded_array(ByteBuffer in) {
        int size = readULeb128i(in);
        Object[] constant = new Object[size];
        for (int i = 0; i < size; i++) {
            constant[i] = readEncodedValue(in);
        }
        return constant;
    }

    private void read_annotation_set_item(int offset, DexAnnotationAble daa) { // annotation_set_item
        ByteBuffer in = annotationSetItemIn;
        in.position(offset);
        int size = in.getInt();
        for (int j = 0; j < size; j++) {
            int annotation_off = in.getInt();
            read_annotation_item(annotation_off, daa);
        }
    }

    private void read_annotation_item(int annotation_off, DexAnnotationAble daa) {
        ByteBuffer in = annotationItemIn;
        in.position(annotation_off);
        int visibility = 0xFF & in.get();
        DexAnnotationNode annotation = read_encoded_annotation(in);
        annotation.visibility = Visibility.values()[visibility];
        annotation.accept(daa);
    }

    private DexAnnotationNode read_encoded_annotation(ByteBuffer in) {
        int type_idx = readULeb128i(in);
        int size = readULeb128i(in);
        String _typeString = getType(type_idx);
        DexAnnotationNode ann = new DexAnnotationNode(_typeString, Visibility.RUNTIME);
        for (int i = 0; i < size; i++) {
            int name_idx = readULeb128i(in);
            String nameString = getString(name_idx);
            Object value = readEncodedValue(in);
            ann.items.add(new DexAnnotationNode.Item(nameString, value));
        }
        return ann;
    }

    private Field getField(int id) {
        fieldIdIn.position(id * 8);
        int owner_idx = 0xFFFF & fieldIdIn.getShort();
        int type_idx = 0xFFFF & fieldIdIn.getShort();
        int name_idx = fieldIdIn.getInt();
        return new Field(getType(owner_idx), getString(name_idx), getType(type_idx));
    }

    private String[] getTypeList(int offset) {
        if (offset == 0) {
            return new String[0];
        }
        typeListIn.position(offset);
        int size = typeListIn.getInt();
        String[] types = new String[size];
        for (int i = 0; i < size; i++) {
            types[i] = getType(0xFFFF & typeListIn.getShort());
        }
        return types;
    }

    private Proto getProto(int proto_idx) {
        String[] parameterTypes;
        String returnType;

        protoIdIn.position(proto_idx * 12 + 4); // move to position and skip shorty_idx

        int return_type_idx = protoIdIn.getInt();
        int parameters_off = protoIdIn.getInt();

        returnType = getType(return_type_idx);

        parameterTypes = getTypeList(parameters_off);
        return new Proto(parameterTypes, returnType);
    }

    private Method getMethod(int id) {
        methoIdIn.position(id * 8);
        int owner_idx = 0xFFFF & methoIdIn.getShort();
        int proto_idx = 0xFFFF & methoIdIn.getShort();
        int name_idx = methoIdIn.getInt();
        return new Method(getType(owner_idx), getString(name_idx), getProto(proto_idx));
    }

    private String getString(int id) {
        if (id == -1) {
            return null;
        }
        int offset = stringIdIn.getInt(id * 4);
        stringDataIn.position(offset);
        int length = readULeb128i(stringDataIn);
        try {
            StringBuilder buff = new StringBuilder((int) (length * 1.5));
            return Mutf8.decode(stringDataIn, buff);
        } catch (UTFDataFormatException e) {
            throw new DexException(e, "fail to load string %d@%08x", id, offset);
        }
    }

    private String getType(int id) {
        if (id == -1) {
            return null;
        }
        return getString(typeIdIn.getInt(id * 4));
    }

    private int acceptField(ByteBuffer in, int lastIndex, DexClassVisitor dcv,
            Map<Integer, Integer> fieldAnnotationPositions, Object value, int config) {
        int diff = readULeb128i(in);
        int field_access_flags = readULeb128i(in);
        int field_id = lastIndex + diff;
        Field field = getField(field_id);
        // //////////////////////////////////////////////////////////////
        DexFieldVisitor dfv = dcv.visitField(field_access_flags, field, value);
        if (dfv != null) {
            if ((config & SKIP_ANNOTATION) == 0) {
                Integer annotation_offset = fieldAnnotationPositions.get(field_id);
                if (annotation_offset != null) {
                    try {
                        read_annotation_set_item(annotation_offset, dfv);
                    } catch (Exception e) {
                        throw new DexException(e, "while accept annotation in field:%s.", field.toString());
                    }
                }
            }
            dfv.visitEnd();
        }
        // //////////////////////////////////////////////////////////////
        return field_id;
    }

    private int acceptMethod(ByteBuffer in, int lastIndex, DexClassVisitor cv, Map<Integer, Integer> methodAnnos,
            Map<Integer, Integer> parameterAnnos, int config, boolean firstMethod) {
        int offset = in.position();
        int diff = readULeb128i(in);
        int method_access_flags = readULeb128i(in);
        int code_off = readULeb128i(in);
        int method_id = lastIndex + diff;
        Method method = getMethod(method_id);

        // issue 200, methods may have same signature, we only need to keep the first one
        if (!firstMethod && diff == 0) { // detect a duplicated method
            WARN("GLITCH: duplicated method %s @%08x", method.toString(), offset);
            if ((config & KEEP_ALL_METHODS) == 0) {
                WARN("WARN: skip method %s @%08x", method.toString(), offset);
                return method_id;
            }
        }

        // issue 195, a <clinit> or <init> but not marked as ACC_CONSTRUCTOR,
        if (0 == (method_access_flags & DexConstants.ACC_CONSTRUCTOR)
                && (method.getName().equals("<init>") || method.getName().equals("<clinit>"))) {
            WARN("GLITCH: method %s @%08x not marked as ACC_CONSTRUCTOR", method.toString(), offset);
        }

        try {
            DexMethodVisitor dmv = cv.visitMethod(method_access_flags, method);
            if (dmv != null) {
                if ((config & SKIP_ANNOTATION) == 0) {
                    Integer annotation_offset = methodAnnos.get(method_id);
                    if (annotation_offset != null) {
                        try {
                            read_annotation_set_item(annotation_offset, dmv);
                        } catch (Exception e) {
                            throw new DexException(e, "while accept annotation in method:%s.", method.toString());
                        }
                    }
                    Integer parameter_annotation_offset = parameterAnnos.get(method_id);
                    if (parameter_annotation_offset != null) {
                        try {
                            read_annotation_set_ref_list(parameter_annotation_offset, dmv);
                        } catch (Exception e) {
                            throw new DexException(e, "while accept parameter annotation in method:%s.",
                                    method.toString());
                        }
                    }
                }
                if (code_off != 0) {
                    boolean keep = true;
                    if (0 != (SKIP_CODE & config)) {
                        keep = 0 != (KEEP_CLINIT & config) && method.getName().equals("<clinit>");
                    }
                    if(keep) {
                        DexCodeVisitor dcv = dmv.visitCode();
                        if (dcv != null) {
                            try {
                                acceptCode(code_off, dcv, config, (method_access_flags & DexConstants.ACC_STATIC) != 0,
                                        method);
                            } catch (Exception e) {
                                throw new DexException(e, "while accept code in method:[%s] @%08x", method.toString(),
                                        code_off);
                            }
                        }
                    }
                }
                dmv.visitEnd();
            }
        } catch (Exception e) {
            throw new DexException(e, "while accept method:[%s]", method.toString());
        }

        return method_id;
    }

    private void read_annotation_set_ref_list(int parameter_annotation_offset, DexMethodVisitor dmv) {
        ByteBuffer in = annotationSetRefListIn;
        in.position(parameter_annotation_offset);

        int size = in.getInt();
        for (int j = 0; j < size; j++) {
            int param_annotation_offset = in.getInt();
            if (param_annotation_offset == 0) {
                continue;
            }
            DexAnnotationAble dpav = dmv.visitParameterAnnotation(j);
            try {
                if (dpav != null) {
                    read_annotation_set_item(param_annotation_offset, dpav);
                }
            } catch (Exception e) {
                throw new DexException(e, "While accepting parameter annotation in parameter: [%d]", j);
            }
        }
    }

    /**
     * the size of class in dex file
     * 
     * @return class_defs_size
     */
    public final int getClassSize() {
        return class_defs_size;
    }

    static class BadOpException extends RuntimeException {

        private static final long serialVersionUID = 5354839427958139635L;

        public BadOpException(String fmt, Object... args) {
            super(String.format(fmt, args));
        }
    }

    private void findLabels(byte[] insns, BitSet nextBit, BitSet badOps, Map<Integer, DexLabel> labelsMap, Set<Integer> handlers,
            Method method) {
        Queue<Integer> q = new LinkedList<>();
        q.add(0);
        q.addAll(handlers);
        handlers.clear();
        while (!q.isEmpty()) {
            int offset = q.poll();
            if (nextBit.get(offset)) {
                continue;
            } else {
                nextBit.set(offset);
            }
            try {
                travelInsn(labelsMap, q, insns, offset);
            } catch (IndexOutOfBoundsException indexOutOfRange){
                badOps.set(offset);
                WARN("GLITCH: %04x %s | not enough space for reading instruction", offset, method.toString());
            } catch (BadOpException badOp){
                badOps.set(offset);
                WARN("GLITCH: %04x %s | %s", offset, method.toString(), badOp.getMessage());
            }
        }
    }

    private void travelInsn(Map<Integer, DexLabel> labelsMap, Queue<Integer> q, byte[] insns, int offset) {
        int u1offset = offset * 2;
        if (u1offset >= insns.length) {
            throw new IndexOutOfBoundsException();
        }
        int opcode = 0xFF & insns[u1offset];
        Op op = Op.ops[opcode];
        if (op == null || op.format == null) {
            throw new BadOpException("zero-width instruction op=0x%02x", opcode);
        }
        int target;
        boolean canContinue = true;
        if (op.canBranch()) {
            switch (op.format) {
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                if (target < 0 || target * 2 > insns.length ) {
                    throw new BadOpException("jump out of insns %s -> %04x", op, target);
                }
                q.add(target);
                order(labelsMap, target);
                break;
            case kFmt20t:
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                if (target < 0 || target * 2 > insns.length ) {
                    throw new BadOpException("jump out of insns %s -> %04x", op, target);
                }
                q.add(target);
                order(labelsMap, target);
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);

                int u = ubyte(insns, u1offset + 1);
                boolean cmpSameReg = (u & 0x0F) == ((u >> 4) & 0x0F);
                boolean skipTarget = false;
                if (cmpSameReg) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        canContinue = false;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        skipTarget = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!skipTarget) {
                    if (target < 0 || target * 2 > insns.length ) {
                        throw new BadOpException("jump out of insns %s -> %04x", op, target);
                    }
                    q.add(target);
                    order(labelsMap, target);
                }
                break;
            case kFmt30t:
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                if (target < 0 || target * 2 > insns.length ) {
                    throw new BadOpException("jump out of insns %s -> %04x", op, target);
                }
                q.add(target);
                order(labelsMap, target);
                break;
            default:
                break;
            }
        }
        if (op.canSwitch()) {
            order(labelsMap, offset + op.format.size);// default
            int u1SwitchData = 2 * (offset + sint(insns, u1offset + 2));
            if (u1SwitchData + 2 < insns.length) {

                    switch (insns[u1SwitchData + 1]) {
                        case 0x01: // packed-switch-data
                        {
                            int size = ushort(insns, u1SwitchData + 2);
                            int b = u1SwitchData + 8;// targets
                            for (int i = 0; i < size; i++) {
                                target = offset + sint(insns, b + i * 4);
                                if (target < 0 || target * 2 > insns.length ) {
                                    throw new BadOpException("jump out of insns %s -> %04x", op, target);
                                }
                                q.add(target);
                                order(labelsMap, target);
                            }
                            break;
                        }
                        case 0x02:// sparse-switch-data
                        {
                            int size = ushort(insns, u1SwitchData + 2);
                            int b = u1SwitchData + 4 + 4 * size;// targets
                            for (int i = 0; i < size; i++) {
                                target = offset + sint(insns, b + i * 4);
                                if (target < 0 || target * 2 > insns.length ) {
                                    throw new BadOpException("jump out of insns %s -> %04x", op, target);
                                }
                                q.add(target);
                                order(labelsMap, target);
                            }
                            break;
                        }
                        default:
                            throw new BadOpException("bad payload for %s", op);
                    }
            } else {
                throw new BadOpException("bad payload offset for %s", op);
            }
        }

        if (canContinue) {
            int idx = Integer.MAX_VALUE;
            switch (op.indexType) {
            case kIndexStringRef:
                if (op.format == InstructionFormat.kFmt31c) {
                    idx = uint(insns, u1offset + 2);
                } else {// other
                    idx = ushort(insns, u1offset + 2);
                }
                canContinue = idx >= 0 && idx < string_ids_size;
                break;
            case kIndexTypeRef:
                idx = ushort(insns, u1offset + 2);
                canContinue = idx < type_ids_size;
                break;
            case kIndexMethodRef:
                idx = ushort(insns, u1offset + 2);
                canContinue = idx < method_ids_size;
                break;
            case kIndexFieldRef:
                idx = ushort(insns, u1offset + 2);
                canContinue = idx < field_ids_size;
                break;
            case kIndexCallSiteRef:
                idx = ushort(insns, u1offset + 2);
                canContinue = idx < call_site_ids_size;
                break;
            case kIndexMethodAndProtoRef:
                idx = ushort(insns, u1offset + 2);
                int idx2 = ushort(insns, u1offset + 6);
                canContinue = idx < method_ids_size && idx2 < proto_ids_size;
                break;
            default:
            }
            if (!canContinue) {
                throw new BadOpException("index-out-of-range for %s index: %d", op, idx);
            }
        }

        if (canContinue && op.canContinue()) {
            if (op == Op.NOP) {
                switch (insns[u1offset + 1]) {
                case 0x00:
                    q.add(offset + Op.NOP.format.size);
                    break;
                case 0x01: {
                    int size = ushort(insns, u1offset + 2);
                    q.add(offset + (size * 2) + 4);
                    break;
                }
                case 0x02: {
                    int size = ushort(insns, u1offset + 2);
                    q.add(offset + (size * 4) + 2);
                    break;
                }
                case 0x03: {
                    int element_width = ushort(insns, u1offset + 2);
                    int size = uint(insns, u1offset + 4);
                    q.add(offset + (size * element_width + 1) / 2 + 4);
                    break;
                }
                }
            } else {
                q.add(offset + op.format.size);
            }
        }
    }

    private void findTryCatch(ByteBuffer in, DexCodeVisitor dcv, int tries_size, int insn_size,
            Map<Integer, DexLabel> labelsMap, Set<Integer> handlers) {
        int encoded_catch_handler_list = in.position() + tries_size * 8;
        ByteBuffer handlerIn = in.duplicate().order(ByteOrder.LITTLE_ENDIAN);
        for (int i = 0; i < tries_size; i++) { // try_item
            int start_addr = in.getInt();
            int insn_count = 0xFFFF & in.getShort();
            int handler_offset = 0xFFFF & in.getShort();
            if (start_addr > insn_size) {
                continue;
            }
            order(labelsMap, start_addr);
            int end = start_addr + insn_count;
            order(labelsMap, end);

            handlerIn.position(encoded_catch_handler_list + handler_offset);// move to encoded_catch_handler

            boolean catchAll = false;
            int listSize = readLeb128i(handlerIn);
            int handlerCount = listSize;
            if (listSize <= 0) {
                listSize = -listSize;
                handlerCount = listSize + 1;
                catchAll = true;
            }
            DexLabel[] labels = new DexLabel[handlerCount];
            String[] types = new String[handlerCount];
            for (int k = 0; k < listSize; k++) {
                int type_id = readULeb128i(handlerIn);
                int handler = readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                types[k] = getType(type_id);
                labels[k] = labelsMap.get(handler);
            }
            if (catchAll) {
                int handler = readULeb128i(handlerIn);
                order(labelsMap, handler);
                handlers.add(handler);
                labels[listSize] = labelsMap.get(handler);
            }
            dcv.visitTryCatch(labelsMap.get(start_addr), labelsMap.get(end), labels, types);
        }
    }

    /* package */void acceptCode(int code_off, DexCodeVisitor dcv, int config, boolean isStatic, Method method) {
        ByteBuffer in = codeItemIn;
        in.position(code_off);
        int registers_size = 0xFFFF & in.getShort();
        in.getShort();// ins_size ushort
        in.getShort();// outs_size ushort
        int tries_size = 0xFFFF & in.getShort();
        int debug_info_off = in.getInt();
        int insns = in.getInt();

        byte[] insnsArray = new byte[insns * 2];
        in.get(insnsArray);
        dcv.visitRegister(registers_size);
        BitSet nextInsn = new BitSet();
        Map<Integer, DexLabel> labelsMap = new TreeMap<>();
        Set<Integer> handlers = new HashSet<>();
        // 处理异常处理
        if (tries_size > 0) {
            if ((insns & 0x01) != 0) {// skip padding
                in.getShort();
            }
            if (0 == (config & SKIP_EXCEPTION)) {
                findTryCatch(in, dcv, tries_size, insns, labelsMap, handlers);
            }
        }
        // 处理debug信息
        if (debug_info_off != 0 && (0 == (config & SKIP_DEBUG))) {
            DexDebugVisitor ddv = dcv.visitDebug();
            if (ddv != null) {
                read_debug_info(debug_info_off, registers_size, isStatic, method, labelsMap, ddv);
                ddv.visitEnd();
            }
        }

        BitSet badOps = new BitSet();
        findLabels(insnsArray, nextInsn, badOps, labelsMap, handlers, method);
        acceptInsn(insnsArray, dcv, nextInsn, badOps, labelsMap);
        dcv.visitEnd();
    }

    // 处理指令
    private void acceptInsn(byte[] insns, DexCodeVisitor dcv, BitSet nextInsn, BitSet badOps, Map<Integer, DexLabel> labelsMap) {
        Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();
        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
        Op[] values = Op.ops;
        for (int offset = nextInsn.nextSetBit(0); offset >= 0; offset = nextInsn.nextSetBit(offset + 1)) {
            // issue 65, a label may `inside` an instruction
            // visit all label with offset <= currentOffset
            while (nextLabelOffset != null) {
                if (nextLabelOffset <= offset) {
                    dcv.visitLabel(labelsMap.get(nextLabelOffset));
                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;
                } else {
                    // the label is after this instruction
                    break;
                }
            }

            if(badOps.get(offset)){
                dcv.visitStmt0R(Op.BAD_OP);
                continue;
            }

            int u1offset = offset * 2;
            int opcode = 0xFF & insns[u1offset];

            Op op = values[opcode];

            int a, b, c, target;
            switch (op.format) {
            // case kFmt00x: break;
            case kFmt10x:
                dcv.visitStmt0R(op);
                break;

            case kFmt11x:
                dcv.visitStmt1R(op, 0xFF & insns[u1offset + 1]);
                break;
            case kFmt12x:
                a = ubyte(insns, u1offset + 1);
                dcv.visitStmt2R(op, a & 0xF, a >> 4);
                break;
            // case kFmt20bc:break;
            case kFmt10t:
                target = offset + insns[u1offset + 1];
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt20t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt21t:
                target = offset + sshort(insns, u1offset + 2);
                dcv.visitJumpStmt(op, ubyte(insns, u1offset + 1), -1, labelsMap.get(target));
                break;
            case kFmt22t:
                target = offset + sshort(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                b = a & 0x0F;
                c = a >> 4;
                boolean ignore = false;
                if (b == c) {
                    switch (op) {
                    case IF_EQ:
                    case IF_GE:
                    case IF_LE:
                        // means always jump, equals to goto
                        dcv.visitJumpStmt(Op.GOTO, 0, 0, labelsMap.get(target));
                        ignore = true;
                        break;
                    case IF_NE:
                    case IF_GT:
                    case IF_LT:
                        // means always not jump
                        ignore = true;
                        break;
                    default:
                        break;
                    }
                }
                if (!ignore) {
                    dcv.visitJumpStmt(op, b, c, labelsMap.get(target));
                }
                break;
            case kFmt30t:
                target = offset + sint(insns, u1offset + 2);
                dcv.visitJumpStmt(op, -1, -1, labelsMap.get(target));
                break;
            case kFmt31t:
                target = offset + sint(insns, u1offset + 2);
                a = ubyte(insns, u1offset + 1);
                int u1SwitchData = 2 * target;
                if (op == Op.FILL_ARRAY_DATA) {
                    int element_width = ushort(insns, u1SwitchData + 2);
                    int size = uint(insns, u1SwitchData + 4);
                    switch (element_width) {
                    case 1: {
                        byte[] data = new byte[size];
                        System.arraycopy(insns, u1SwitchData + 8, data, 0, size);
                        dcv.visitFillArrayDataStmt(Op.FILL_ARRAY_DATA, a, data);
                    }
                        break;
                    case 2: {
                        short[] data = new short[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = (short) sshort(insns, u1SwitchData + 8 + 2 * i);
                        }
                        dcv.visitFillArrayDataStmt(Op.FILL_ARRAY_DATA, a, data);
                    }
                        break;
                    case 4: {
                        int[] data = new int[size];
                        for (int i = 0; i < size; i++) {
                            data[i] = sint(insns, u1SwitchData + 8 + 4 * i);
                        }
                        dcv.visitFillArrayDataStmt(Op.FILL_ARRAY_DATA, a, data);
                    }
                        break;
                    case 8: {
                        long[] data = new long[size];
                        for (int i = 0; i < size; i++) {
                            int t = u1SwitchData + 8 + 8 * i;
                            long z = 0;
                            z |= (ushort(insns, t));
                            z |= ((long) ushort(insns, t + 2)) << 16;
                            z |= ((long) ushort(insns, t + 4)) << 32;
                            z |= ((long) ushort(insns, t + 6)) << 48;
                            data[i] = z;
                        }
                        dcv.visitFillArrayDataStmt(Op.FILL_ARRAY_DATA, a, data);
                    }
                        break;
                    }
                } else if (op == Op.SPARSE_SWITCH) {
                    int size = sshort(insns, u1SwitchData + 2);
                    int[] keys = new int[size];
                    DexLabel[] labels = new DexLabel[size];
                    int z = u1SwitchData + 4;
                    for (int i = 0; i < size; i++) {
                        keys[i] = sint(insns, z + i * 4);
                    }
                    z += size * 4;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z + i * 4));
                    }
                    dcv.visitSparseSwitchStmt(Op.SPARSE_SWITCH, a, keys, labels);
                } else {
                    int size = sshort(insns, u1SwitchData + 2);
                    int first_key = sint(insns, u1SwitchData + 4);
                    DexLabel[] labels = new DexLabel[size];
                    int z = u1SwitchData + 8;
                    for (int i = 0; i < size; i++) {
                        labels[i] = labelsMap.get(offset + sint(insns, z));
                        z += 4;
                    }
                    dcv.visitPackedSwitchStmt(op, a, first_key, labels);
                }
                break;
            case kFmt21c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexStringRef:
                    dcv.visitConstStmt(op, a, getString(b));
                    break;
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a, -1, getField(b));
                    break;
                case kIndexTypeRef:
                    if (op == Op.CONST_CLASS) {
                        dcv.visitConstStmt(Op.CONST_CLASS, a, new DexType(getType(b)));
                    } else {
                        dcv.visitTypeStmt(op, a, -1, getType(b));
                    }
                    break;
                case kIndexMethodHandleRef:
                    dcv.visitConstStmt(op, a, getMethodHandle(b));
                    break;
                case kIndexProtoRef:
                    dcv.visitConstStmt(op, a, getProto(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt22c:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                switch (op.indexType) {
                case kIndexFieldRef:
                    dcv.visitFieldStmt(op, a & 0xF, a >> 4, getField(b));
                    break;
                case kIndexTypeRef:
                    dcv.visitTypeStmt(op, a & 0xF, a >> 4, getType(b));
                    break;
                default:
                    break;
                }
                break;
            case kFmt31c:
                if (op.indexType == InstructionIndexType.kIndexStringRef) {
                    a = ubyte(insns, u1offset + 1);
                    b = uint(insns, u1offset + 2);
                    dcv.visitConstStmt(op, a, getString(b));
                }
                break;
            case kFmt35c: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE

                int[] regs = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc);// C
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    dcv.visitMethodStmt(op, regs, getCallSite(b));
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt3rc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int[] regs = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                if (op.indexType == InstructionIndexType.kIndexTypeRef) {
                    dcv.visitFilledNewArrayStmt(op, regs, getType(b));
                } else if (op.indexType == InstructionIndexType.kIndexCallSiteRef) {
                    dcv.visitMethodStmt(op, regs, getCallSite(b));
                } else {
                    dcv.visitMethodStmt(op, regs, getMethod(b));
                }
            }
                break;
            case kFmt45cc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                int dc = ubyte(insns, u1offset + 4); // DC
                int fe = ubyte(insns, u1offset + 5); // FE
                int h = ushort(insns, u1offset + 6);

                int[] regs = new int[a >> 4];
                switch (a >> 4) {
                case 5:
                    regs[4] = a & 0xF;// G
                case 4:
                    regs[3] = 0xF & (fe >> 4);// F
                case 3:
                    regs[2] = 0xF & (fe);// E
                case 2:
                    regs[1] = 0xF & (dc >> 4);// D
                case 1:
                    regs[0] = 0xF & (dc);// C
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt4rcc: {
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                c = ushort(insns, u1offset + 4);
                int h = ushort(insns, u1offset + 6);
                int[] regs = new int[a];
                for (int i = 0; i < a; i++) {
                    regs[i] = c + i;
                }
                dcv.visitMethodStmt(op, regs, getMethod(b), getProto(h));
            }
            break;
            case kFmt22x:
                a = ubyte(insns, u1offset + 1);
                b = ushort(insns, u1offset + 2);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt23x:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = ubyte(insns, u1offset + 3);
                dcv.visitStmt3R(op, a, b, c);
                break;
            case kFmt32x:
                a = ushort(insns, u1offset + 2);
                b = ushort(insns, u1offset + 4);
                dcv.visitStmt2R(op, a, b);
                break;
            case kFmt11n:
                a = insns[u1offset + 1];
                dcv.visitConstStmt(op, a & 0xF, a >> 4);
                break;
            case kFmt21h:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_HIGH16) {
                    dcv.visitConstStmt(Op.CONST_HIGH16, a, b << 16);
                } else {
                    dcv.visitConstStmt(op, a, ((long) b) << 48);
                }
                break;
            case kFmt21s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                if (op == Op.CONST_16) {
                    dcv.visitConstStmt(Op.CONST_16, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt22b:
                a = ubyte(insns, u1offset + 1);
                b = ubyte(insns, u1offset + 2);
                c = sbyte(insns, u1offset + 3);
                dcv.visitStmt2R1N(op, a, b, c);
                break;
            case kFmt22s:
                a = ubyte(insns, u1offset + 1);
                b = sshort(insns, u1offset + 2);
                dcv.visitStmt2R1N(op, a & 0xF, a >> 4, b);
                break;
            // case kFmt22cs:break;
            case kFmt31i:
                a = ubyte(insns, u1offset + 1);
                b = sint(insns, u1offset + 2);
                if (op == Op.CONST) {
                    dcv.visitConstStmt(Op.CONST, a, b);
                } else {
                    dcv.visitConstStmt(op, a, (long) b);
                }
                break;
            case kFmt51l:
                a = ubyte(insns, u1offset + 1);
                long z = 0;
                z |= ushort(insns, u1offset + 2);
                z |= ((long) ushort(insns, u1offset + 4)) << 16;
                z |= ((long) ushort(insns, u1offset + 6)) << 32;
                z |= ((long) ushort(insns, u1offset + 8)) << 48;
                dcv.visitConstStmt(op, a, z);
                break;
            }
        }

        while (nextLabelOffset != null) {
            dcv.visitLabel(labelsMap.get(nextLabelOffset));
            if (labelOffsetIterator.hasNext()) {
                nextLabelOffset = labelOffsetIterator.next();
            } else {
                break;
            }
        }
    }

    private CallSite getCallSite(int b) {
        callSiteIdIn.position(b * 4);
        int call_site_off = callSiteIdIn.getInt();

        Object[] call_site_items = read_encoded_array_item(call_site_off);
        Object[] constArgs;
        if (call_site_items.length > 3) {
            constArgs = Arrays.copyOfRange(call_site_items, 3, call_site_items.length);
        } else {
            constArgs = new Object[0];
        }

        return new CallSite(
                String.format("call_site_%d", b),
                (MethodHandle) call_site_items[0],
                (String) call_site_items[1],
                (Proto) call_site_items[2],
                constArgs);
    }

    /**
     * An entry in the resulting locals table
     */
    static private class LocalEntry {
        public String name, type, signature;

        private LocalEntry(String name, String type) {
            this.name = name;
            this.type = type;
        }

        private LocalEntry(String name, String type, String signature) {
            this.name = name;
            this.type = type;
            this.signature = signature;
        }
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/reader/MultiDexFileReader.java`:

```java
package com.googlecode.d2j.reader;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.util.zip.AccessBufByteArrayOutputStream;
import com.googlecode.d2j.util.zip.ZipEntry;
import com.googlecode.d2j.util.zip.ZipFile;
import com.googlecode.d2j.visitors.DexFileVisitor;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class MultiDexFileReader implements BaseDexFileReader {
    final private List<DexFileReader> readers = new ArrayList<>();
    final private List<Item> items = new ArrayList<>();

    public MultiDexFileReader(Collection<DexFileReader> readers) {
        this.readers.addAll(readers);
        init();
    }

    private static byte[] toByteArray(InputStream is) throws IOException {
        AccessBufByteArrayOutputStream out = new AccessBufByteArrayOutputStream();
        byte[] buff = new byte[1024];
        for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }
        return out.getBuf();
    }

    public static BaseDexFileReader open(byte[] data) throws IOException {
        if (data.length < 3) {
            throw new IOException("File too small to be a dex/zip");
        }
        if ("dex".equals(new String(data, 0, 3, StandardCharsets.ISO_8859_1))) {// dex
            return new DexFileReader(data);
        } else if ("PK".equals(new String(data, 0, 2, StandardCharsets.ISO_8859_1))) {// ZIP
            TreeMap<String, DexFileReader> dexFileReaders = new TreeMap<>();
            try (ZipFile zipFile = new ZipFile(data)) {
                for (ZipEntry e : zipFile.entries()) {
                    String entryName = e.getName();
                    if (entryName.startsWith("classes") && entryName.endsWith(".dex")) {
                        if (!dexFileReaders.containsKey(entryName)) { // only the first one
                            dexFileReaders.put(entryName, new DexFileReader(toByteArray(zipFile.getInputStream(e))));
                        }
                    }
                }
            }
            if (dexFileReaders.size() == 0) {
                throw new IOException("Can not find classes.dex in zip file");
            } else if (dexFileReaders.size() == 1) {
                return dexFileReaders.firstEntry().getValue();
            } else {
                return new MultiDexFileReader(dexFileReaders.values());
            }
        }
        throw new IOException("The source file is not a .dex or .zip file");
    }

    void init() {
        Set<String> classes = new HashSet<>();
        for (DexFileReader reader : readers) {
            List<String> classNames = reader.getClassNames();
            for (int i = 0; i < classNames.size(); i++) {
                String className = classNames.get(i);
                if (classes.add(className)) {
                    items.add(new Item(i, reader, className));
                }
            }
        }
    }

    @Override
    public int getDexVersion() {
        int max = DexConstants.DEX_035;
        for (DexFileReader r : readers) {
            int v = r.getDexVersion();
            if (v > max) {
                max = v;
            }
        }
        return max;
    }

    @Override
    public void accept(DexFileVisitor dv) {
        accept(dv, 0);
    }

    @Override
    public List<String> getClassNames() {
        return new AbstractList<String>() {
            @Override
            public String get(int index) {
                return items.get(index).className;
            }

            @Override
            public int size() {
                return items.size();
            }
        };
    }

    @Override
    public void accept(DexFileVisitor dv, int config) {
        int size = items.size();
        for (int i = 0; i < size; i++) {
            accept(dv, i, config);
        }
    }

    @Override
    public void accept(DexFileVisitor dv, int classIdx, int config) {
        Item item = items.get(classIdx);
        item.reader.accept(dv, item.idx, config);
    }

    static class Item {
        int idx;
        DexFileReader reader;
        String className;

        public Item(int i, DexFileReader reader, String className) {
            idx = i;
            this.reader = reader;
            this.className = className;
        }
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/reader/zip/ZipUtil.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.googlecode.d2j.reader.zip;

import com.googlecode.d2j.util.zip.AccessBufByteArrayOutputStream;
import com.googlecode.d2j.util.zip.ZipEntry;
import com.googlecode.d2j.util.zip.ZipFile;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * @author bob
 * 
 */
public class ZipUtil {
    public static byte[] toByteArray(InputStream is) throws IOException {
        AccessBufByteArrayOutputStream out = new AccessBufByteArrayOutputStream();
        byte[] buff = new byte[1024];
        for (int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }
        return out.getBuf();
    }

    /**
     * read the dex file from file, if the file is a zip file, it will return the content of classes.dex in the zip
     * file.
     * 
     * @param file
     * @return
     * @throws IOException
     */
    public static byte[] readDex(File file) throws IOException {
        return readDex(file.toPath());
    }

    public static byte[] readDex(Path file) throws IOException {
        return readDex(Files.readAllBytes(file));
    }

    public static byte[] readDex(InputStream in) throws IOException {
        return readDex(toByteArray(in));
    }

    /**
     * read the dex file from byte array, if the byte array is a zip stream, it will return the content of classes.dex
     * in the zip stream.
     * 
     * @param data
     * @return the content of classes.dex
     * @throws IOException
     */
    public static byte[] readDex(byte[] data) throws IOException {
        if (data.length < 3) {
            throw new IOException("File too small to be a dex/zip");
        }
        if ("dex".equals(new String(data, 0, 3, StandardCharsets.ISO_8859_1))) {// dex
            return data;
        } else if ("PK".equals(new String(data, 0, 2, StandardCharsets.ISO_8859_1))) {// ZIP
            try (ZipFile zipFile = new ZipFile(data)) {
                ZipEntry classes = zipFile.findFirstEntry("classes.dex");
                if (classes != null) {
                    return toByteArray(zipFile.getInputStream(classes));
                } else {
                    throw new IOException("Can not find classes.dex in zip file");
                }
            }
        }
        throw new IOException("the src file not a .dex or zip file");
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/ASMifierAnnotationV.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class ASMifierAnnotationV extends DexAnnotationVisitor implements DexConstants {
    ArrayOut out;
    int i = 0;

    public ASMifierAnnotationV(String objName, ArrayOut out, String name, Visibility visibility) {
        this.out = out;
        out.s("if(%s!=null){", objName);
        out.push();

        out.s("DexAnnotationVisitor av%02d = %s.visitAnnotation(%s, Visibility.%s);", i, objName, Escape.v(name),
                visibility.name());
        out.s("if(av%02d != null) {", i);
        out.push();
    }

    @Override
    public void visit(String name, Object value) {
        out.s("av%02d.visit(%s, %s);", i, Escape.v(name), Escape.v(value));
    }

    @Override
    public void visitEnum(String name, String desc, String value) {
        out.s("av%02d.visitEnum(%s, %s, %s);", i, Escape.v(name), Escape.v(desc), Escape.v(value));
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name, String desc) {
        out.s("{");
        out.push();
        int old = i;
        int n = ++i;
        out.s("DexAnnotationVisitor av%02d = av%02d.visitAnnotation(%s, %s);", n, old, Escape.v(name), Escape.v(desc));
        out.s("if(av%02d != null) {", i);
        out.push();
        return this;
    }

    @Override
    public DexAnnotationVisitor visitArray(String name) {
        out.s("{");
        out.push();
        int old = i;
        int n = ++i;
        out.s("DexAnnotationVisitor av%02d = av%02d.visitArray(%s);", n, old, Escape.v(name));
        out.s("if(av%02d != null) {", i);
        out.push();
        return this;
    }

    @Override
    public void visitEnd() {
        out.s("av%02d.visitEnd();", i);
        i--;
        out.pop();
        out.s("}");
        out.pop();
        out.s("}");
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/ASMifierClassV.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util;

import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.visitors.DexAnnotationAble;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexFieldVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class ASMifierClassV extends DexClassVisitor {
    protected ArrayOut out = new ArrayOut();
    private List<ArrayOut> methodOuts = new ArrayList<ArrayOut>();
    private List<ArrayOut> fieldOuts = new ArrayList<ArrayOut>();

    int fCount = 0;
    int mCount = 0;

    public ASMifierClassV(String pkgName, String javaClassName, int access_flags, String className, String superClass,
            String[] interfaceNames) {
        super();
        out.s("package %s;", pkgName);
        out.s("import com.googlecode.d2j.*;");
        out.s("import com.googlecode.d2j.visitors.*;");
        out.s("import static com.googlecode.d2j.DexConstants.*;");
        out.s("import static com.googlecode.d2j.reader.Op.*;");
        out.s("public class %s {", javaClassName);
        out.push();
        out.s("public static void accept(DexFileVisitor v) {");
        out.push();
        out.s("DexClassVisitor cv=v.visit(%s,%s,%s,%s);", Escape.classAcc(access_flags), Escape.v(className),
                Escape.v(superClass), Escape.v(interfaceNames));
        out.s("if(cv!=null) {");
        out.push();
        out.s("accept(cv);");
        out.s("cv.visitEnd();");
        out.pop();
        out.s("}");
        out.pop();
        out.s("}");
        out.s("public static void accept(DexClassVisitor cv) {");
        out.push();
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
        return new ASMifierAnnotationV("cv", out, name, visibility);
    }

    @Override
    public void visitSource(String file) {
        out.s("cv.visitSource(\"%s\");", Utf8Utils.escapeString(file));
    }

    @Override
    public DexFieldVisitor visitField(int accessFlags, Field field, Object value) {
        String fieldName = String.format("f%03d_%s", fCount++, field.getName());
        out.s("%s(cv);", fieldName);

        final ArrayOut f = new ArrayOut();
        fieldOuts.add(f);
        f.s("public static void %s(DexClassVisitor cv) {", fieldName);
        f.push();
        f.s("DexFieldVisitor fv=cv.visitField(%s, %s, %s);", Escape.fieldAcc(accessFlags), Escape.v(field),
                Escape.v(value));
        f.s("if(fv != null) {");
        f.push();
        return new DexFieldVisitor() {

            @Override
            public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
                return new ASMifierAnnotationV("fv", f, name, visibility);
            }

            @Override
            public void visitEnd() {
                f.s("fv.visitEnd();");
                f.pop();
                f.s("}");
                f.pop();
                f.s("}");
            }
        };
    }

    @Override
    public DexMethodVisitor visitMethod(int accessFlags, Method method) {
        String methodName = String.format("m%03d_%s", mCount++, method.getName().replace('<', '_').replace('>', '_'));
        out.s("%s(cv);", methodName);

        final ArrayOut m = new ArrayOut();
        methodOuts.add(m);
        m.s("public static void %s(DexClassVisitor cv) {", methodName);
        m.push();
        m.s("DexMethodVisitor mv=cv.visitMethod(%s, %s);", Escape.methodAcc(accessFlags), Escape.v(method));
        m.s("if(mv != null) {");
        m.push();

        return new DexMethodVisitor() {

            @Override
            public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
                return new ASMifierAnnotationV("mv", m, name, visibility);
            }

            @Override
            public DexAnnotationAble visitParameterAnnotation(final int index) {
                m.s("DexAnnotationAble pv%02d = mv.visitParameterAnnotation(%s);", index, index);
                return new DexAnnotationAble() {

                    @Override
                    public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility) {
                        return new ASMifierAnnotationV(String.format("pv%02d", index), m, name, visibility);
                    }
                };
            }

            @Override
            public DexCodeVisitor visitCode() {
                m.s("DexCodeVisitor code=mv.visitCode();");
                m.s("if(code != null) {");
                m.push();
                return new ASMifierCodeV(m) {

                    @Override
                    public void visitEnd() {
                        super.visitEnd();

                        m.pop();
                        m.s("}");
                    }
                };
            }

            @Override
            public void visitEnd() {
                m.s("mv.visitEnd();");
                m.pop();
                m.s("}");
                m.pop();
                m.s("}");
            }

        };
    }

    @Override
    public void visitEnd() {
        out.pop();
        out.s("}");
        for (ArrayOut o : fieldOuts) {
            out.array.addAll(o.array);
            for (int i : o.is) {
                out.is.add(out.i + i);
            }
        }
        fieldOuts = null;
        for (ArrayOut o : methodOuts) {
            out.array.addAll(o.array);
            for (int i : o.is) {
                out.is.add(out.i + i);
            }
        }
        methodOuts = null;
        out.pop();
        out.s("}");
    }

}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/ASMifierCodeV.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util;

import java.util.HashMap;
import java.util.Map;

import com.googlecode.d2j.*;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexDebugVisitor;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class ASMifierCodeV extends DexCodeVisitor implements DexConstants {
    Out m;
    Map<DexLabel, String> labelMap = new HashMap<>();

    public ASMifierCodeV(Out m) {
        this.m = m;
    }

    @Override
    public void visitStmt2R1N(Op op, int distReg, int srcReg, int content) {
        m.s("code.visitStmt2R1N(%s,%s,%s,%s);", op(op), distReg, srcReg, content);
    }

    @Override
    public void visitRegister(int total) {
        m.s("code.visitRegister(%s);", total);

    }

    @Override
    public void visitStmt3R(Op op, int a, int b, int c) {
        m.s("code.visitStmt3R(%s,%s,%s,%s);", op(op), a, b, c);

    }

    @Override
    public void visitStmt2R(Op op, int a, int b) {
        m.s("code.visitStmt2R(%s,%s,%s);", op(op), a, b);

    }

    @Override
    public void visitStmt0R(Op op) {
        m.s("code.visitStmt0R(%s);", op(op));

    }

    @Override
    public void visitStmt1R(Op op, int reg) {
        m.s("code.visitStmt1R(%s,%s);", op(op), reg);

    }

    @Override
    public void visitTypeStmt(Op op, int a, int b, String type) {
        m.s("code.visitTypeStmt(%s,%s,%s,%s);", op(op), a, b, Escape.v(type));
    }

    @Override
    public void visitConstStmt(Op op, int toReg, Object value) {
        if (value instanceof Integer) {
            m.s("code.visitConstStmt(%s,%s,%s); // int: 0x%08x  float:%f", op(op), toReg, Escape.v(value), value,
                    Float.intBitsToFloat((Integer) value));
        } else if (value instanceof Long) {
            m.s("code.visitConstStmt(%s,%s,%s); // long: 0x%016x  double:%f", op(op), toReg, Escape.v(value), value,
                    Double.longBitsToDouble((Long) value));
        } else {
            m.s("code.visitConstStmt(%s,%s,%s);", op(op), toReg, Escape.v(value));
        }

    }

    @Override
    public void visitFieldStmt(Op op, int fromOrToReg, int objReg, Field field) {
        m.s("code.visitFieldStmt(%s,%s,%s,%s);", op(op), fromOrToReg, objReg, Escape.v(field));
    }

    @Override
    public void visitFilledNewArrayStmt(Op op, int[] args, String type) {
        m.s("code.visitFilledNewArrayStmt(%s,%s,%s);", op(op), Escape.v(args), Escape.v(type));
    }

    int i = 0;

    public String v(DexLabel[] labels) {
        StringBuilder sb = new StringBuilder("new DexLabel[]{");
        boolean first = true;
        for (DexLabel dexLabel : labels) {
            if (first) {
                first = false;
            } else {
                sb.append(",");
            }
            sb.append(v(dexLabel));
        }
        return sb.append("}").toString();
    }

    private Object v(DexLabel l) {
        String name = labelMap.get(l);
        if (name == null) {
            name = "L" + i++;
            m.s("DexLabel %s=new DexLabel();", name);
            labelMap.put(l, name);
        }
        return name;
    }

    String op(Op op) {
        return op.name();
    }

    @Override
    public void visitJumpStmt(Op op, int a, int b, DexLabel label) {
        m.s("code.visitJumpStmt(%s,%s,%s,%s);", op(op), a, b, v(label));
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, CallSite callSite) {
        m.s("code.visitMethodStmt(%s,%s,%s);", op(op), Escape.v(args), Escape.v(callSite));
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, Method bsm, Proto proto) {
        m.s("code.visitMethodStmt(%s,%s,%s,%s);", op(op), Escape.v(args), Escape.v(bsm), Escape.v(proto));
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, Method method) {
        m.s("code.visitMethodStmt(%s,%s,%s);", op(op), Escape.v(args), Escape.v(method));
    }

    @Override
    public void visitSparseSwitchStmt(Op op, int ra, int[] cases, DexLabel[] labels) {
        m.s("code.visitSparseSwitchStmt(%s,%s,%s,%s);", op(op), ra, Escape.v(cases), v(labels));
    }

    @Override
    public void visitPackedSwitchStmt(Op op, int ra, int first_case, DexLabel[] labels) {
        m.s("code.visitSparseSwitchStmt(%s,%s,%s,%s);", op(op), ra, first_case, v(labels));
    }

    @Override
    public void visitTryCatch(DexLabel start, DexLabel end, DexLabel[] handlers, String[] types) {
        m.s("code.visitTryCatch(%s,%s,%s,%s);", v(start), v(end), v(handlers), Escape.v(types));
    }

    @Override
    public void visitEnd() {
        m.s("code.visitEnd();");
    }

    @Override
    public void visitLabel(DexLabel label) {
        m.s("code.visitLabel(%s);", v(label));
    }

    @Override
    public void visitFillArrayDataStmt(Op op, int ra, Object array) {
        // FIXME
        super.visitFillArrayDataStmt(op, ra, array);
    }

    @Override
    public DexDebugVisitor visitDebug() {
        m.s("DexDebugVisitor ddv=new DexDebugVisitor(code.visitDebug());");
        return new DexDebugVisitor() {
            @Override
            public void visitParameterName(int reg, String name) {
                m.s("ddv.visitParameterName(%d,%s);", reg, Escape.v(name));
            }

            @Override
            public void visitStartLocal(int reg, DexLabel label, String name, String type, String signature) {
                m.s("ddv.visitStartLocal(%d,%s,%s,%s,%s);", reg, v(label), Escape.v(name), Escape.v(type),
                        Escape.v(signature));
            }

            @Override
            public void visitLineNumber(int line, DexLabel label) {
                m.s("ddv.visitLineNumber(%d,%s);", line, v(label));
            }

            @Override
            public void visitPrologue(DexLabel dexLabel) {
                m.s("ddv.visitPrologue(%s);", v(dexLabel));
            }

            @Override
            public void visitEpiogue(DexLabel dexLabel) {
                m.s("ddv.visitEpiogue(%s);", v(dexLabel));
            }

            @Override
            public void visitEndLocal(int reg, DexLabel label) {
                m.s("ddv.visitEndLocal(%d,%s);", reg, v(label));
            }

            @Override
            public void visitSetFile(String file) {
                m.s("ddv.visitSetFile(%s);", Escape.v(file));
            }

            @Override
            public void visitRestartLocal(int reg, DexLabel label) {
                m.s("ddv.visitRestartLocal(%d,%s);", reg, v(label));
            }
        };
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/ASMifierFileV.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.zip.ZipUtil;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexFileVisitor;

/**
 * similar with org.objectweb.asm.util.ASMifierClassVisitor
 * 
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 */
public class ASMifierFileV extends DexFileVisitor {

    String pkgName = "dex2jar.gen";
    Path dir;
    ArrayOut file = new ArrayOut();
    int i = 0;

    public static void doData(byte[] data, Path destdir) throws IOException {
        new DexFileReader(data).accept(new ASMifierFileV(destdir, null));
    }

    public static void doFile(Path srcDex) throws IOException {
        String distName = srcDex.getFileName() + "_asmifier";
        doFile(srcDex, srcDex.resolveSibling(distName));
    }

    public static void doFile(Path srcDex, Path dest) throws IOException {
        doData(ZipUtil.readDex(srcDex), dest);
    }

    public static void main(String... args) throws IOException {
        if (args.length < 1) {
            System.out.println("ASMifier 1.dex 2.dex ... n.dex");
            return;
        }
        for (String s : args) {
            System.out.println("asmifier " + s);
            doFile(new File(s).toPath());
        }
    }

    public ASMifierFileV(Path dir, String pkgName) {
        super();
        if (dir == null) {
            this.dir = new File(".").toPath();
        } else {
            this.dir = dir;
        }
        if (pkgName != null) {
            this.pkgName = pkgName;
        }
        file.s("package %s;", this.pkgName);
        file.s("import com.googlecode.d2j.*;");
        file.s("import com.googlecode.dj2.visitors.*;");
        file.s("public class Main {");
        file.push();
        file.s("public static void accept(DexFileVisitor v) {");
        file.push();

    }

    static void write(ArrayOut out, Path file) {
        StringBuilder sb = new StringBuilder();
        List<String> list = new ArrayList<String>(out.array.size());
        for (int i = 0; i < out.array.size(); i++) {
            sb.setLength(0);
            int p = out.is.get(i);
            for (int j = 0; j < p; j++) {
                sb.append("    ");
            }
            sb.append(out.array.get(i));
            list.add(sb.toString());
        }
        try {
            Path parent = file.getParent();
            if (parent != null && !Files.exists(parent)) {
                Files.createDirectories(parent);
            }
            Files.write(file, list, StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public DexClassVisitor visit(int access_flags, String className, String superClass, String[] interfaceNames) {
        final String n = String.format("C%04d_", i++)
                + className.substring(1, className.length() - 1).replace('/', '_').replace('$', '_');
        file.s("%s.accept(v);", n);
        return new ASMifierClassV(pkgName, n, access_flags, className, superClass, interfaceNames) {

            @Override
            public void visitEnd() {
                super.visitEnd();
                write(out, dir.resolve(pkgName.replace('.', '/') + '/' + n + ".java"));
            }

        };
    }

    @Override
    public void visitEnd() {
        file.pop();
        file.s("}");
        file.pop();
        file.s("}");
        write(file, dir.resolve(pkgName.replace('.', '/') + "/Main.java"));
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/ArrayOut.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util;

import java.util.ArrayList;
import java.util.List;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class ArrayOut implements Out {

    int i = 0;

    public List<String> array = new ArrayList<String>();
    public List<Integer> is = new ArrayList<Integer>();

    @Override
    public void push() {
        i++;
    }

    @Override
    public void s(String s) {
        is.add(i);
        array.add(s);
    }

    @Override
    public void s(String format, Object... arg) {
        s(String.format(format, arg));
    }

    @Override
    public void pop() {
        i--;
    }

}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/Escape.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util;

import com.googlecode.d2j.*;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Escape implements DexConstants {

    static boolean contain(int a, int b) {
        return (a & b) != 0;
    }

    public static String classAcc(int acc) {
        if (acc == 0) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        if (contain(acc, ACC_PUBLIC)) {
            sb.append("ACC_PUBLIC|");
        }
        if (contain(acc, ACC_PRIVATE)) {
            sb.append("ACC_PRIVATE|");
        }
        if (contain(acc, ACC_PROTECTED)) {
            sb.append("ACC_PROTECTED|");
        }
        if (contain(acc, ACC_STATIC)) {
            sb.append("ACC_STATIC|");
        }
        if (contain(acc, ACC_FINAL)) {
            sb.append("ACC_FINAL|");
        }
        if (contain(acc, ACC_INTERFACE)) {
            sb.append("ACC_INTERFACE|");
        }
        if (contain(acc, ACC_ABSTRACT)) {
            sb.append("ACC_ABSTRACT|");
        }
        if (contain(acc, ACC_SYNTHETIC)) {
            sb.append("ACC_SYNTHETIC|");
        }
        if (contain(acc, ACC_ANNOTATION)) {
            sb.append("ACC_ANNOTATION|");
        }
        if (contain(acc, ACC_ENUM)) {
            sb.append("ACC_ENUM|");
        }
        if (sb.length() > 0) {
            sb.setLength(sb.length() - 1);
        }
        return sb.toString();
    }

    public static String methodAcc(int acc) {
        if (acc == 0) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        if (contain(acc, ACC_PUBLIC)) {
            sb.append("ACC_PUBLIC|");
        }
        if (contain(acc, ACC_PRIVATE)) {
            sb.append("ACC_PRIVATE|");
        }
        if (contain(acc, ACC_PROTECTED)) {
            sb.append("ACC_PROTECTED|");
        }
        if (contain(acc, ACC_STATIC)) {
            sb.append("ACC_STATIC|");
        }
        if (contain(acc, ACC_FINAL)) {
            sb.append("ACC_FINAL|");
        }
        if (contain(acc, ACC_BRIDGE)) {
            sb.append("ACC_BRIDGE|");
        }
        if (contain(acc, ACC_VARARGS)) {
            sb.append("ACC_VARARGS|");
        }
        if (contain(acc, ACC_NATIVE)) {
            sb.append("ACC_NATIVE|");
        }
        if (contain(acc, ACC_ABSTRACT)) {
            sb.append("ACC_ABSTRACT|");
        }
        if (contain(acc, ACC_STRICT)) {
            sb.append("ACC_STRICT|");
        }
        if (contain(acc, ACC_SYNTHETIC)) {
            sb.append("ACC_SYNTHETIC|");
        }
        if (contain(acc, ACC_CONSTRUCTOR)) {
            sb.append("ACC_CONSTRUCTOR|");
        }
        if (sb.length() > 0) {
            sb.setLength(sb.length() - 1);
        }
        return sb.toString();
    }

    public static String fieldAcc(int acc) {
        if (acc == 0) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        if (contain(acc, ACC_PUBLIC)) {
            sb.append("ACC_PUBLIC|");
        }
        if (contain(acc, ACC_PRIVATE)) {
            sb.append("ACC_PRIVATE|");
        }
        if (contain(acc, ACC_PROTECTED)) {
            sb.append("ACC_PROTECTED|");
        }
        if (contain(acc, ACC_STATIC)) {
            sb.append("ACC_STATIC|");
        }
        if (contain(acc, ACC_FINAL)) {
            sb.append("ACC_FINAL|");
        }
        if (contain(acc, ACC_VOLATILE)) {
            sb.append("ACC_VOLATILE|");
        }
        if (contain(acc, ACC_TRANSIENT)) {
            sb.append("ACC_TRANSIENT|");
        }

        if (contain(acc, ACC_SYNTHETIC)) {
            sb.append("ACC_SYNTHETIC|");
        }
        if (contain(acc, ACC_ENUM)) {
            sb.append("ACC_ENUM|");
        }
        if (sb.length() > 0) {
            sb.setLength(sb.length() - 1);
        }
        return sb.toString();
    }

    public static String v(Field f) {
        return String.format("new Field(%s,%s,%s)", v(f.getOwner()), v(f.getName()), v(f.getType()));
    }

    public static String v(Method m) {
        return String.format("new Method(%s,%s,%s,%s)", v(m.getOwner()), v(m.getName()), v(m.getParameterTypes()),
                v(m.getReturnType()));
    }
    public static String v(Proto m) {
        return String.format("new Proto(%s,%s)", v(m.getParameterTypes()), v(m.getReturnType()));
    }

    public static String v(MethodHandle m) {
        switch (m.getType()) {
        case MethodHandle.INSTANCE_GET:
            return String.format("new MethodHandle(MethodHandle.INSTANCE_GET,%s)", v(m.getField()));
        case MethodHandle.INSTANCE_PUT:
            return String.format("new MethodHandle(MethodHandle.INSTANCE_PUT,%s)", v(m.getField()));
        case MethodHandle.STATIC_GET:
            return String.format("new MethodHandle(MethodHandle.STATIC_GET,%s)", v(m.getField()));
        case MethodHandle.STATIC_PUT:
            return String.format("new MethodHandle(MethodHandle.STATIC_PUT,%s)", v(m.getField()));

        case MethodHandle.INVOKE_INSTANCE:
            return String.format("new MethodHandle(MethodHandle.INVOKE_INSTANCE,%s)", v(m.getMethod()));
        case MethodHandle.INVOKE_STATIC:
            return String.format("new MethodHandle(MethodHandle.INVOKE_STATIC,%s)", v(m.getMethod()));
        case MethodHandle.INVOKE_CONSTRUCTOR:
            return String.format("new MethodHandle(MethodHandle.INVOKE_CONSTRUCTOR,%s)", v(m.getMethod()));
        case MethodHandle.INVOKE_DIRECT:
            return String.format("new MethodHandle(MethodHandle.INVOKE_DIRECT,%s)", v(m.getMethod()));
        case MethodHandle.INVOKE_INTERFACE:
            return String.format("new MethodHandle(MethodHandle.INVOKE_INTERFACE,%s)", v(m.getMethod()));
        default:
            throw new RuntimeException();
        }
    }

    public static String v(String s) {
        if (s == null) {
            return "null";
        }
        return "\"" + Utf8Utils.escapeString(s) + "\"";
    }

    public static String v(DexType t) {
        return "new DexType(" + v(t.desc) + ")";

    }

    public static String v(int[] vs) {
        StringBuilder sb = new StringBuilder("new int[]{ ");
        boolean first = true;
        for (int obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append(",");
            }
            sb.append(obj);
        }
        return sb.append("}").toString();
    }

    public static String v(byte[] vs) {
        StringBuilder sb = new StringBuilder("new byte[]{ ");
        boolean first = true;
        for (byte obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append(",");
            }
            sb.append("(byte)").append(obj);
        }
        return sb.append("}").toString();
    }

    public static String v(String[] vs) {
        if (vs == null) {
            return "null";
        }
        StringBuilder sb = new StringBuilder("new String[]{ ");
        boolean first = true;
        for (String obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append(",");
            }
            sb.append(v(obj));
        }
        return sb.append("}").toString();
    }

    public static String v(Object[] vs) {
        StringBuilder sb = new StringBuilder("new Object[]{ ");
        boolean first = true;
        for (Object obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append(",");
            }
            sb.append(v(obj));
        }
        return sb.append("}").toString();
    }

    public static String v(CallSite callSite) {
        StringBuilder sb = new StringBuilder()
                .append("new CallSite(")
                .append(v(callSite.getName()))
                .append(", ")
                .append(v(callSite.getBootstrapMethodHandler()))
                .append(", ")
                .append(v(callSite.getMethodName()))
                .append(", ")
                .append(v(callSite.getMethodProto()));
        Object[] extraArguments = callSite.getExtraArguments();
        if (extraArguments != null && extraArguments.length > 0) {
            for (Object arg : extraArguments) {
                sb.append(", ").append(v(arg));
            }
        }
        sb.append(")");
        return sb.toString();
    }

    public static String v(Object obj) {
        if (obj == null) {
            return "null";
        }
        if (obj instanceof String) {
            return v((String) obj);
        }

        if (obj instanceof DexType) {
            return v((DexType) obj);
        }

        if (obj instanceof Method) {
            return v((Method) obj);
        }
        if (obj instanceof Field) {
            return v((Field) obj);
        }
        if (obj instanceof Proto) {
            return v((Proto) obj);
        }
        if (obj instanceof MethodHandle) {
            return v((MethodHandle) obj);
        }
        if (obj instanceof CallSite) {
            return v((CallSite) obj);
        }

        if (obj instanceof Integer) {
            return " Integer.valueOf(" + obj + ")";
        }
        if (obj instanceof Long) {
            return "Long.valueOf(" + obj + "L)";
        }
        if (obj instanceof Float) {
            return "Float.valueOf(" + obj + "F)";
        }
        if (obj instanceof Double) {
            return "Double.valueOf(" + obj + "D)";
        }
        if (obj instanceof Short) {
            return "Short.valueOf((short)" + obj + ")";
        }
        if (obj instanceof Byte) {
            return "Byte.valueOf((byte)" + obj + ")";
        }
        if (obj instanceof Character) {
            return "Character.valueOf('" + obj + "')";
        }
        if (obj instanceof Boolean) {
            return "Boolean.valueOf(" + obj + ")";
        }
        if (obj instanceof int[]) {
            StringBuilder sb = new StringBuilder("new int[]{ ");
            boolean first = true;
            for (int i : (int[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append(",");
                }
                sb.append(i);
            }
            return sb.append("}").toString();
        }
        if (obj instanceof short[]) {
            StringBuilder sb = new StringBuilder("new short[]{ ");
            boolean first = true;
            for (int i : (short[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append(",");
                }
                sb.append("(short)").append(i);
            }
            return sb.append("}").toString();
        }
        if (obj instanceof long[]) {
            StringBuilder sb = new StringBuilder("new long[]{ ");
            boolean first = true;
            for (long i : (long[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append(",");
                }
                sb.append(i).append("L");
            }
            return sb.append("}").toString();
        }
        if (obj instanceof float[]) {
            StringBuilder sb = new StringBuilder("new float[]{ ");
            boolean first = true;
            for (float i : (float[]) obj) {
                if (first) {
                    first = false;
                } else {
                    sb.append(",");
                }
                sb.append(i).append("F");
            }
            return sb.append("}").toString();
        }
        return null;
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/Mutf8.java`:

```java
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.googlecode.d2j.util;

import java.io.UTFDataFormatException;
import java.nio.ByteBuffer;

/**
 * Modified UTF-8 as described in the dex file format spec.
 * 
 * <p>
 * Derived from libcore's MUTF-8 encoder at java.nio.charset.ModifiedUtf8.
 */
public final class Mutf8 {
    private Mutf8() {
    }

    /**
     * Decodes bytes from {@code in} into {@code sb} until a delimiter 0x00 is encountered. Returns a new string
     * containing the decoded characters.
     */
    public static String decode(ByteBuffer in, StringBuilder sb) throws UTFDataFormatException {
        while (true) {
            char a = (char) (in.get() & 0xff);
            if (a == 0) {
                return sb.toString();
            }

            if (a < '\u0080') {
                sb.append(a);
            } else if ((a & 0xe0) == 0xc0) {
                int b = in.get() & 0xff;
                if ((b & 0xC0) != 0x80) {
                    throw new UTFDataFormatException("bad second byte");
                }
                sb.append((char) (((a & 0x1F) << 6) | (b & 0x3F)));
            } else if ((a & 0xf0) == 0xe0) {
                int b = in.get() & 0xff;
                int c = in.get() & 0xff;
                if (((b & 0xC0) != 0x80) || ((c & 0xC0) != 0x80)) {
                    throw new UTFDataFormatException("bad second or third byte");
                }
                sb.append((char) (((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F)));
            } else {
                throw new UTFDataFormatException("bad byte");
            }
        }
    }

    /**
     * Returns the number of bytes the modified UTF8 representation of 's' would take.
     */
    private static long countBytes(String s, boolean shortLength) throws UTFDataFormatException {
        long result = 0;
        final int length = s.length();
        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                ++result;
            } else if (ch <= 2047) {
                result += 2;
            } else {
                result += 3;
            }
            if (shortLength && result > 65535) {
                throw new UTFDataFormatException("String more than 65535 UTF bytes long");
            }
        }
        return result;
    }

    /**
     * Encodes the modified UTF-8 bytes corresponding to {@code s} into {@code dst}, starting at {@code offset}.
     */
    public static void encode(byte[] dst, int offset, String s) {
        final int length = s.length();
        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                dst[offset++] = (byte) ch;
            } else if (ch <= 2047) {
                dst[offset++] = (byte) (0xc0 | (0x1f & (ch >> 6)));
                dst[offset++] = (byte) (0x80 | (0x3f & ch));
            } else {
                dst[offset++] = (byte) (0xe0 | (0x0f & (ch >> 12)));
                dst[offset++] = (byte) (0x80 | (0x3f & (ch >> 6)));
                dst[offset++] = (byte) (0x80 | (0x3f & ch));
            }
        }
    }

    /**
     * Returns an array containing the <i>modified UTF-8</i> form of {@code s}.
     */
    public static byte[] encode(String s) throws UTFDataFormatException {
        int utfCount = (int) countBytes(s, true);
        byte[] result = new byte[utfCount];
        encode(result, 0, s);
        return result;
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/Out.java`:

```java
package com.googlecode.d2j.util;

public interface Out {
    void push();

    void s(String s);

    void s(String format, Object... arg);

    void pop();
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/Utf8Utils.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * As per the Apache license requirements, this file has been modified
 * from its original state.
 *
 * Such modifications are Copyright (C) 2010 Ben Gruver, and are released
 * under the original license
 */

package com.googlecode.d2j.util;

import java.io.IOException;
import java.io.Writer;

/**
 * Constants of type <code>CONSTANT_Utf8_info</code>.
 */
public final class Utf8Utils {

    /**
     * Converts a string into its Java-style UTF-8 form. Java-style UTF-8 differs from normal UTF-8 in the handling of
     * character '\0' and surrogate pairs.
     * 
     * @param string
     *            non-null; the string to convert
     * @return non-null; the UTF-8 bytes for it
     */
    public static byte[] stringToUtf8Bytes(String string) {
        int len = string.length();
        byte[] bytes = new byte[len * 3]; // Avoid having to reallocate.
        int outAt = 0;

        for (int i = 0; i < len; i++) {
            char c = string.charAt(i);
            if ((c != 0) && (c < 0x80)) {
                bytes[outAt] = (byte) c;
                outAt++;
            } else if (c < 0x800) {
                bytes[outAt] = (byte) (((c >> 6) & 0x1f) | 0xc0);
                bytes[outAt + 1] = (byte) ((c & 0x3f) | 0x80);
                outAt += 2;
            } else {
                bytes[outAt] = (byte) (((c >> 12) & 0x0f) | 0xe0);
                bytes[outAt + 1] = (byte) (((c >> 6) & 0x3f) | 0x80);
                bytes[outAt + 2] = (byte) ((c & 0x3f) | 0x80);
                outAt += 3;
            }
        }

        byte[] result = new byte[outAt];
        System.arraycopy(bytes, 0, result, 0, outAt);
        return result;
    }

    private static char[] tempBuffer = null;

    /**
     * Converts an array of UTF-8 bytes into a string.
     * 
     * This method uses a global buffer to avoid having to allocate one every time, so it is *not* thread-safe
     * 
     * @param bytes
     *            non-null; the bytes to convert
     * @param start
     *            the start index of the utf8 string to convert
     * @param length
     *            the length of the utf8 string to convert, not including any null-terminator that might be present
     * @return non-null; the converted string
     */
    public static String utf8BytesToString(byte[] bytes, int start, int length) {
        if (tempBuffer == null || tempBuffer.length < length) {
            tempBuffer = new char[length];
        }
        char[] chars = tempBuffer;
        int outAt = 0;

        for (int at = start; length > 0; /* at */) {
            int v0 = bytes[at] & 0xFF;
            char out;
            switch (v0 >> 4) {
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07: {
                // 0XXXXXXX -- single-byte encoding
                length--;
                if (v0 == 0) {
                    // A single zero byte is illegal.
                    return throwBadUtf8(v0, at);
                }
                out = (char) v0;
                at++;
                break;
            }
            case 0x0c:
            case 0x0d: {
                // 110XXXXX -- two-byte encoding
                length -= 2;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int value = ((v0 & 0x1f) << 6) | (v1 & 0x3f);
                if ((value != 0) && (value < 0x80)) {
                    /*
                     * This should have been represented with one-byte encoding.
                     */
                    return throwBadUtf8(v1, at + 1);
                }
                out = (char) value;
                at += 2;
                break;
            }
            case 0x0e: {
                // 1110XXXX -- three-byte encoding
                length -= 3;
                if (length < 0) {
                    return throwBadUtf8(v0, at);
                }
                int v1 = bytes[at + 1] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v1, at + 1);
                }
                int v2 = bytes[at + 2] & 0xFF;
                if ((v1 & 0xc0) != 0x80) {
                    return throwBadUtf8(v2, at + 2);
                }
                int value = ((v0 & 0x0f) << 12) | ((v1 & 0x3f) << 6) | (v2 & 0x3f);
                if (value < 0x800) {
                    /*
                     * This should have been represented with one- or two-byte encoding.
                     */
                    return throwBadUtf8(v2, at + 2);
                }
                out = (char) value;
                at += 3;
                break;
            }
            default: {
                // 10XXXXXX, 1111XXXX -- illegal
                return throwBadUtf8(v0, at);
            }
            }
            chars[outAt] = out;
            outAt++;
        }

        return new String(chars, 0, outAt);
    }

    /**
     * Helper for {@link #utf8BytesToString}, which throws the right exception for a bogus utf-8 byte.
     * 
     * @param value
     *            the byte value
     * @param offset
     *            the file offset
     * @return never
     * @throws IllegalArgumentException
     *             always thrown
     */
    private static String throwBadUtf8(int value, int offset) {
        throw new IllegalArgumentException("bad utf-8 byte " + String.format("%02x", value) + " at offset "
                + String.format("%08x", offset));
    }

    public static void writeEscapedChar(Writer writer, char c) throws IOException {
        if ((c >= ' ') && (c < 0x7f)) {
            if ((c == '\'') || (c == '\"') || (c == '\\')) {
                writer.write('\\');
            }
            writer.write(c);
            return;
        } else if (c <= 0x7f) {
            switch (c) {
            case '\n':
                writer.write("\\n");
                return;
            case '\r':
                writer.write("\\r");
                return;
            case '\t':
                writer.write("\\t");
                return;
            }
        }

        writer.write("\\u");
        writer.write(Character.forDigit(c >> 12, 16));
        writer.write(Character.forDigit((c >> 8) & 0x0f, 16));
        writer.write(Character.forDigit((c >> 4) & 0x0f, 16));
        writer.write(Character.forDigit(c & 0x0f, 16));

    }

    public static void writeEscapedString(Writer writer, String value) throws IOException {
        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);

            if ((c >= ' ') && (c < 0x7f)) {
                if ((c == '\'') || (c == '\"') || (c == '\\')) {
                    writer.write('\\');
                }
                writer.write(c);
                continue;
            } else if (c <= 0x7f) {
                switch (c) {
                case '\n':
                    writer.write("\\n");
                    continue;
                case '\r':
                    writer.write("\\r");
                    continue;
                case '\t':
                    writer.write("\\t");
                    continue;
                }
            }

            writer.write("\\u");
            writer.write(Character.forDigit(c >> 12, 16));
            writer.write(Character.forDigit((c >> 8) & 0x0f, 16));
            writer.write(Character.forDigit((c >> 4) & 0x0f, 16));
            writer.write(Character.forDigit(c & 0x0f, 16));
        }
    }

    public static String escapeString(String value) {
        int len = value.length();
        StringBuilder sb = new StringBuilder(len * 3 / 2);

        for (int i = 0; i < len; i++) {
            char c = value.charAt(i);

            if ((c >= ' ') && (c < 0x7f)) {
                if ((c == '\'') || (c == '\"') || (c == '\\')) {
                    sb.append('\\');
                }
                sb.append(c);
                continue;
            } else if (c <= 0x7f) {
                switch (c) {
                case '\n':
                    sb.append("\\n");
                    continue;
                case '\r':
                    sb.append("\\r");
                    continue;
                case '\t':
                    sb.append("\\t");
                    continue;
                }
            }

            sb.append("\\u");
            sb.append(Character.forDigit(c >> 12, 16));
            sb.append(Character.forDigit((c >> 8) & 0x0f, 16));
            sb.append(Character.forDigit((c >> 4) & 0x0f, 16));
            sb.append(Character.forDigit(c & 0x0f, 16));
        }

        return sb.toString();
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/zip/AccessBufByteArrayOutputStream.java`:

```java
package com.googlecode.d2j.util.zip;

import java.io.ByteArrayOutputStream;

public class AccessBufByteArrayOutputStream extends ByteArrayOutputStream {
    public byte[] getBuf() {
        return buf;
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/zip/AutoSTOREDZipOutputStream.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util.zip;

import java.io.IOException;
import java.io.OutputStream;
import java.util.zip.*;
import java.util.zip.ZipEntry;

/**
 * Auto calc size/crc for STORED
 */
public class AutoSTOREDZipOutputStream extends ZipOutputStream {
    public AutoSTOREDZipOutputStream(OutputStream out) {
        super(out);
    }

    private CRC32 crc = new CRC32();
    private ZipEntry delayedEntry;
    private AccessBufByteArrayOutputStream delayedOutputStream;

    @Override
    public void putNextEntry(ZipEntry e) throws IOException {
        if (e.getMethod() != ZipEntry.STORED) {
            super.putNextEntry(e);
        } else {
            delayedEntry = e;
            if (delayedOutputStream == null) {
                delayedOutputStream = new AccessBufByteArrayOutputStream();
            }
        }
    }

    @Override
    public void closeEntry() throws IOException {
        ZipEntry delayedEntry = this.delayedEntry;
        if (delayedEntry != null) {
            AccessBufByteArrayOutputStream delayedOutputStream = this.delayedOutputStream;
            byte[] buf = delayedOutputStream.getBuf();
            int size = delayedOutputStream.size();
            delayedEntry.setSize(size);
            delayedEntry.setCompressedSize(size);
            crc.reset();
            crc.update(buf, 0, size);
            delayedEntry.setCrc(crc.getValue());
            super.putNextEntry(delayedEntry);
            super.write(buf, 0, size);
            this.delayedEntry = null;
            delayedOutputStream.reset();
        }
        super.closeEntry();
    }

    @Override
    public synchronized void write(byte[] b, int off, int len) throws IOException {
        if (delayedEntry != null) {
            delayedOutputStream.write(b, off, len);
        } else {
            super.write(b, off, len);
        }
    }

    @Override
    public void write(int b) throws IOException {
        if (delayedEntry != null) {
            delayedOutputStream.write(b);
        } else {
            super.write(b);
        }
    }

    @Override
    public void write(byte[] b) throws IOException {
        if (delayedEntry != null) {
            delayedOutputStream.write(b);
        } else {
            super.write(b);
        }
    }

    @Override
    public void close() throws IOException {
        delayedOutputStream = null;
        super.close();
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/zip/ZipConstants.java`:

```java
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util.zip;

/**
 * Do not add constants to this interface! It's implemented by the classes in this package whose names start "Zip", and
 * the constants are thereby public API.
 */
interface ZipConstants {

    public static final long LOCSIG = 0x4034b50, EXTSIG = 0x8074b50, CENSIG = 0x2014b50, ENDSIG = 0x6054b50;

    public static final int LOCHDR = 30, EXTHDR = 16, CENHDR = 46, ENDHDR = 22, LOCVER = 4, LOCFLG = 6, LOCHOW = 8,
            LOCTIM = 10, LOCCRC = 14, LOCSIZ = 18, LOCLEN = 22, LOCNAM = 26, LOCEXT = 28, EXTCRC = 4, EXTSIZ = 8,
            EXTLEN = 12, CENVEM = 4, CENVER = 6, CENFLG = 8, CENHOW = 10, CENTIM = 12, CENCRC = 16, CENSIZ = 20,
            CENLEN = 24, CENNAM = 28, CENEXT = 30, CENCOM = 32, CENDSK = 34, CENATT = 36, CENATX = 38, CENOFF = 42,
            ENDSUB = 8, ENDTOT = 10, ENDSIZ = 12, ENDOFF = 16, ENDCOM = 20;
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/zip/ZipEntry.java`:

```java
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util.zip;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.util.Calendar;
import java.util.GregorianCalendar;

/**
 * An entry within a zip file. An entry has attributes such as its name (which is actually a path) and the uncompressed
 * size of the corresponding data. An entry does not contain the data itself, but can be used as a key with
 * {@link java.util.zip.ZipFile#getInputStream}. The class documentation for {@link java.util.zip.ZipInputStream} and
 * {@link java.util.zip.ZipOutputStream} shows how {@code android.ZipEntry} is used in conjunction with those two
 * classes.
 */
public final class ZipEntry implements ZipConstants, Cloneable {
    String name;
    String comment;

    long crc = -1; // Needs to be a long to distinguish -1 ("not set") from the 0xffffffff CRC32.

    long compressedSize = -1;
    long size = -1;

    int compressionMethod = -1;
    int time = -1;
    int modDate = -1;

    byte[] extra;

    int nameLength = -1;
    long localHeaderRelOffset = -1;

    /**
     * Zip entry state: Deflated.
     */
    public static final int DEFLATED = 8;

    /**
     * Zip entry state: Stored.
     */
    public static final int STORED = 0;

    /**
     * Returns the comment for this {@code android.ZipEntry}, or {@code null} if there is no comment. If we're reading a
     * zip file using {@code ZipInputStream}, the comment is not available.
     */
    public String getComment() {
        return comment;
    }

    /**
     * Gets the compressed size of this {@code android.ZipEntry}.
     * 
     * @return the compressed size, or -1 if the compressed size has not been set.
     */
    public long getCompressedSize() {
        return compressedSize;
    }

    /**
     * Gets the checksum for this {@code android.ZipEntry}.
     * 
     * @return the checksum, or -1 if the checksum has not been set.
     */
    public long getCrc() {
        return crc;
    }

    /**
     * Gets the extra information for this {@code android.ZipEntry}.
     * 
     * @return a byte array containing the extra information, or {@code null} if there is none.
     */
    public byte[] getExtra() {
        return extra;
    }

    /**
     * Gets the compression method for this {@code android.ZipEntry}.
     * 
     * @return the compression method, either {@code DEFLATED}, {@code STORED} or -1 if the compression method has not
     *         been set.
     */
    public int getMethod() {
        return compressionMethod;
    }

    /**
     * Gets the name of this {@code android.ZipEntry}.
     * 
     * @return the entry name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the uncompressed size of this {@code android.ZipEntry}.
     * 
     * @return the uncompressed size, or {@code -1} if the size has not been set.
     */
    public long getSize() {
        return size;
    }

    /**
     * Gets the last modification time of this {@code android.ZipEntry}.
     * 
     * @return the last modification time as the number of milliseconds since Jan. 1, 1970.
     */
    public long getTime() {
        if (time != -1) {
            GregorianCalendar cal = new GregorianCalendar();
            cal.set(Calendar.MILLISECOND, 0);
            cal.set(1980 + ((modDate >> 9) & 0x7f), ((modDate >> 5) & 0xf) - 1, modDate & 0x1f, (time >> 11) & 0x1f,
                    (time >> 5) & 0x3f, (time & 0x1f) << 1);
            return cal.getTime().getTime();
        }
        return -1;
    }

    /**
     * Determine whether or not this {@code android.ZipEntry} is a directory.
     * 
     * @return {@code true} when this {@code android.ZipEntry} is a directory, {@code false} otherwise.
     */
    public boolean isDirectory() {
        return name.charAt(name.length() - 1) == '/';
    }

    /**
     * Returns the string representation of this {@code android.ZipEntry}.
     * 
     * @return the string representation of this {@code android.ZipEntry}.
     */
    @Override
    public String toString() {
        return name;
    }

    /**
     * Returns a deep copy of this zip entry.
     */
    @Override
    public Object clone() {
        try {
            ZipEntry result = (ZipEntry) super.clone();
            result.extra = extra != null ? extra.clone() : null;
            return result;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(e);
        }
    }

    ZipEntry(ByteBuffer it0, boolean skipCommentsAndExtra) throws IOException {
        ByteBuffer it = (ByteBuffer) it0.slice().order(ByteOrder.LITTLE_ENDIAN).limit(CENHDR);
        ZipFile.skip(it0, CENHDR);
        int sig = it.getInt();
        if (sig != CENSIG) {
            ZipFile.throwZipException("Central Directory Entry", sig);
        }

        it.position(8);
        int gpbf = it.getShort() & 0xffff;

        compressionMethod = it.getShort() & 0xffff;
        time = it.getShort() & 0xffff;
        modDate = it.getShort() & 0xffff;

        // These are 32-bit values in the file, but 64-bit fields in this object.
        crc = ((long) it.getInt()) & 0xffffffffL;
        compressedSize = ((long) it.getInt()) & 0xffffffffL;
        size = ((long) it.getInt()) & 0xffffffffL;

        nameLength = it.getShort() & 0xffff;
        int extraLength = it.getShort() & 0xffff;
        int commentByteCount = it.getShort() & 0xffff;

        // This is a 32-bit value in the file, but a 64-bit field in this object.
        it.position(42);
        localHeaderRelOffset = ((long) it.getInt()) & 0xffffffffL;

        byte[] nameBytes = new byte[nameLength];
        it0.get(nameBytes);
        // if (containsNulByte(nameBytes)) {
        // throw new ZipException("Filename contains NUL byte: " + Arrays.toString(nameBytes));
        // }
        name = new String(nameBytes, 0, nameBytes.length, StandardCharsets.UTF_8);

        if (extraLength > 0) {
            if (skipCommentsAndExtra) {
                ZipFile.skip(it0, extraLength);
            } else {
                extra = new byte[extraLength];
                it.get(extra);
            }
        }

        // The RI has always assumed UTF-8. (If GPBF_UTF8_FLAG isn't set, the encoding is
        // actually IBM-437.)
        if (commentByteCount > 0) {
            if (skipCommentsAndExtra) {
                ZipFile.skip(it0, commentByteCount);
            } else {
                byte[] commentBytes = new byte[commentByteCount];
                it0.get(commentBytes);
                comment = new String(commentBytes, 0, commentBytes.length, StandardCharsets.UTF_8);
            }
        }
    }

    private static boolean containsNulByte(byte[] bytes) {
        for (byte b : bytes) {
            if (b == 0) {
                return true;
            }
        }
        return false;
    }
}

```

`dex-reader/src/main/java/com/googlecode/d2j/util/zip/ZipFile.java`:

```java
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.util.zip;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.Inflater;
import java.util.zip.InflaterInputStream;
import java.util.zip.ZipException;

/**
 * This is code is get from Android 4.4.2 intent to read as more zip as possible
 * 
 * Ignore GPBF_ENCRYPTED_FLAG
 * 
 * Allow duplicate ZipEntry
 * 
 * Allow Nul byte in ZipEntry name
 * 
 */
public class ZipFile implements AutoCloseable, ZipConstants {
    /**
     * General Purpose Bit Flags, Bit 0. If set, indicates that the file is encrypted.
     */
    static final int GPBF_ENCRYPTED_FLAG = 1 << 0;

    /**
     * General Purpose Bit Flags, Bit 3. If this bit is set, the fields crc-32, compressed size and uncompressed size
     * are set to zero in the local header. The correct values are put in the data descriptor immediately following the
     * compressed data. (Note: PKZIP version 2.04g for DOS only recognizes this bit for method 8 compression, newer
     * versions of PKZIP recognize this bit for any compression method.)
     */
    static final int GPBF_DATA_DESCRIPTOR_FLAG = 1 << 3;

    /**
     * General Purpose Bit Flags, Bit 11. Language encoding flag (EFS). If this bit is set, the filename and comment
     * fields for this file must be encoded using UTF-8.
     */
    static final int GPBF_UTF8_FLAG = 1 << 11;

    /**
     * Supported General Purpose Bit Flags Mask. Bit mask of bits not supported. Note: The only bit that we will enforce
     * at this time is the encrypted bit. Although other bits are not supported, we must not enforce them as this could
     * break some legitimate use cases (See http://b/8617715).
     */
    static final int GPBF_UNSUPPORTED_MASK = GPBF_ENCRYPTED_FLAG;

    private List<ZipEntry> entries;

    private String comment;
    final ByteBuffer raf;
    RandomAccessFile file;

    public ZipFile(ByteBuffer in) throws IOException {
        raf = in.asReadOnlyBuffer().order(ByteOrder.LITTLE_ENDIAN);
        readCentralDir();
    }

    public ZipFile(File fd) throws IOException {
        RandomAccessFile randomAccessFile = new RandomAccessFile(fd, "r");
        file = randomAccessFile;
        raf = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, fd.length());
        readCentralDir();
    }

    public ZipFile(byte[] data) throws IOException {
        this(ByteBuffer.wrap(data));
    }

    public List<? extends ZipEntry> entries() {
        return entries;
    }

    /**
     * Returns this file's comment, or null if it doesn't have one. See {@link java.util.zip.ZipOutputStream#setComment}
     * .
     * 
     * @throws IllegalStateException
     *             if this zip file has been closed.
     * @since 1.7
     */
    public String getComment() {
        return comment;
    }

    public ZipEntry findFirstEntry(String entryName) {
        if (entryName == null) {
            throw new NullPointerException("entryName == null");
        }

        ZipEntry ze = findFirstEntry0(entryName);
        if (ze == null) {
            ze = findFirstEntry0(entryName + "/");
        }
        return ze;
    }

    private ZipEntry findFirstEntry0(String entryName) {
        for (ZipEntry e : entries) {
            if (e.getName().equals(entryName)) {
                return e;
            }
        }
        return null;
    }

    public long getEntryDataStart(ZipEntry entry) {
        int fileNameLength = raf.getShort((int) (entry.localHeaderRelOffset + 26)) & 0xffff;
        int extraFieldLength = raf.getShort((int) (entry.localHeaderRelOffset + 28)) & 0xffff;
        return entry.localHeaderRelOffset + 30 + fileNameLength + extraFieldLength;
    }

    /**
     * Returns an input stream on the data of the specified {@code android.ZipEntry}.
     * 
     * @param entry
     *            the android.ZipEntry.
     * @return an input stream of the data contained in the {@code android.ZipEntry}.
     * @throws java.io.IOException
     *             if an {@code IOException} occurs.
     * @throws IllegalStateException
     *             if this zip file has been closed.
     */
    public InputStream getInputStream(ZipEntry entry) throws IOException {
        long entryDataStart = getEntryDataStart(entry);
        ByteBuffer is = (ByteBuffer) raf.duplicate().position((int) entryDataStart);

        if (entry.compressionMethod == ZipEntry.STORED) {
            final ByteBuffer buf = (ByteBuffer) is.slice().order(ByteOrder.LITTLE_ENDIAN).limit((int) entry.size);
            return new ByteBufferBackedInputStream(buf);
        } else {
            final ByteBuffer buf = (ByteBuffer) is.slice().order(ByteOrder.LITTLE_ENDIAN)
                    .limit((int) entry.compressedSize);
            int bufSize = Math.max(1024, (int) Math.min(entry.getSize(), 65535L));
            return new ZipInflaterInputStream(new ByteBufferBackedInputStream(buf), new Inflater(true), bufSize, entry);
        }
    }

    static void skip(ByteBuffer is, int i) {
        is.position(is.position() + i);
    }

    /**
     * Returns the number of {@code ZipEntries} in this {@code android.ZipFile}.
     * 
     * @return the number of entries in this file.
     * @throws IllegalStateException
     *             if this zip file has been closed.
     */
    public int size() {
        return entries.size();
    }

    /**
     * Find the central directory and read the contents.
     * 
     * <p>
     * The central directory can be followed by a variable-length comment field, so we have to scan through it
     * backwards. The comment is at most 64K, plus we have 18 bytes for the end-of-central-dir stuff itself, plus
     * apparently sometimes people throw random junk on the end just for the fun of it.
     * 
     * <p>
     * This is all a little wobbly. If the wrong value ends up in the EOCD area, we're hosed. This appears to be the way
     * that everybody handles it though, so we're in good company if this fails.
     */
    private void readCentralDir() throws IOException {
        ByteBuffer raf = this.raf;
        // Scan back, looking for the End Of Central Directory field. If the zip file doesn't
        // have an overall comment (unrelated to any per-entry comments), we'll hit the EOCD
        // on the first try.
        // No need to synchronize raf here -- we only do this when we first open the zip file.
        long scanOffset = raf.limit() - ENDHDR;
        if (scanOffset < 0) {
            throw new ZipException("File too short to be a zip file: " + raf.limit());
        }

        // not check Magic
        // raf.position(0);
        // final int headerMagic = raf.getInt();
        // if (headerMagic != LOCSIG) {
        // throw new ZipException("Not a zip archive");
        // }

        long stopOffset = scanOffset - 65536;
        if (stopOffset < 0) {
            stopOffset = 0;
        }

        while (true) {
            raf.position((int) scanOffset);
            if (raf.getInt() == ENDSIG) {
                break;
            }

            scanOffset--;
            if (scanOffset < stopOffset) {
                throw new ZipException("End Of Central Directory signature not found");
            }
        }

        // Read the End Of Central Directory. ENDHDR includes the signature bytes,
        // which we've already read.

        // Pull out the information we need.
        int diskNumber = raf.getShort() & 0xffff;
        int diskWithCentralDir = raf.getShort() & 0xffff;
        int numEntries = raf.getShort() & 0xffff;
        int totalNumEntries = raf.getShort() & 0xffff;
        skip(raf, 4); // Ignore centralDirSize.
        long centralDirOffset = ((long) raf.getInt()) & 0xffffffffL;
        int commentLength = raf.getShort() & 0xffff;

        if (numEntries != totalNumEntries || diskNumber != 0 || diskWithCentralDir != 0) {
            throw new ZipException("Spanned archives not supported");
        }
        boolean skipCommentsAndExtra = true;

        if (commentLength > 0) {
            if (commentLength > raf.remaining()) {
                System.err.println("WARN: the zip comment exceed the zip content");
            } else {
                if (skipCommentsAndExtra) {
                    skip(raf, commentLength);
                } else {
                    byte[] commentBytes = new byte[commentLength];
                    raf.get(commentBytes);
                    comment = new String(commentBytes, 0, commentBytes.length, StandardCharsets.UTF_8);
                }
            }
        }

        // Seek to the first CDE and read all entries.
        // We have to do this now (from the constructor) rather than lazily because the
        // public API doesn't allow us to throw IOException except from the constructor
        // or from getInputStream.
        ByteBuffer buf = (ByteBuffer) raf.duplicate().order(ByteOrder.LITTLE_ENDIAN).position((int) centralDirOffset);
        entries = new ArrayList<>(numEntries);
        for (int i = 0; i < numEntries; ++i) {
            ZipEntry newEntry = new ZipEntry(buf, skipCommentsAndExtra);
            if (newEntry.localHeaderRelOffset >= centralDirOffset) {
                // Ignore the entry
                // throw new ZipException("Local file header offset is after central directory");
            } else {
                entries.add(newEntry);
            }
        }
    }

    static void throwZipException(String msg, int magic) throws ZipException {
        final String hexString = String.format("0x%08x", magic);
        throw new ZipException(msg + " signature not found; was " + hexString);
    }

    @Override
    public void close() throws IOException {
        if(file!=null){
            file.close();
        }
    }

    static class ZipInflaterInputStream extends InflaterInputStream {
        private final ZipEntry entry;
        private long bytesRead = 0;

        public ZipInflaterInputStream(InputStream is, Inflater inf, int bsize, ZipEntry entry) {
            super(is, inf, bsize);
            this.entry = entry;
        }

        @Override
        public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
            final int i;
            try {
                i = super.read(buffer, byteOffset, byteCount);
            } catch (IOException e) {
                throw new IOException("Error reading data for " + entry.getName() + " near offset " + bytesRead, e);
            }
            if (i == -1) {
                if (entry.size != bytesRead) {
                    throw new IOException("Size mismatch on inflated file: " + bytesRead + " vs " + entry.size);
                }
            } else {
                bytesRead += i;
            }
            return i;
        }

        @Override
        public int available() throws IOException {
            return super.available() == 0 ? 0 : (int) (entry.getSize() - bytesRead);
        }
    }

    private static class ByteBufferBackedInputStream extends InputStream {
        private final ByteBuffer buf;

        public ByteBufferBackedInputStream(ByteBuffer buf) {
            this.buf = buf;
        }

        @Override
        public int read() throws IOException {
            if (!buf.hasRemaining()) {
                return -1;
            }
            return buf.get() & 0xFF;
        }

        @Override
        public int read(byte[] b, int off, int len) throws IOException {
            if (!buf.hasRemaining()) {
                return -1;
            }
            len = Math.min(len, buf.remaining());
            buf.get(b, off, len);
            return len;
        }
    }
}

```

`dex-reader/src/test/java/com/googlecode/d2j/reader/test/AsmfierTest.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.googlecode.d2j.reader.test;

import java.io.File;

import org.junit.Test;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.util.ASMifierFileV;
import com.googlecode.d2j.visitors.DexAnnotationAble;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexFieldVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

/**
 * @author bob
 * 
 */
public class AsmfierTest implements DexConstants {
    @Test
    public void test() {
        ASMifierFileV fv = new ASMifierFileV(new File("target/asmftest").toPath(), "a.b");
        DexClassVisitor cv = fv.visit(ACC_PUBLIC, "La/f;", "Ljava/lang/Object;", null);
        DexFieldVisitor f2v = cv.visitField(ACC_PUBLIC, new Field("La/f;", "abc", "I"), null);
        f2v.visitEnd();
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La/f;", "zz", new String[0], "I"));

        DexAnnotationAble pv = mv.visitParameterAnnotation(2);
        DexAnnotationVisitor dav = pv.visitAnnotation("Leeeff;", Visibility.BUILD);
        dav.visitEnd();
        DexCodeVisitor dcv = mv.visitCode();
        dcv.visitConstStmt(Op.FILL_ARRAY_DATA, 0, new int[] { 1, 2, 3 });
        dcv.visitStmt0R(Op.RETURN_VOID);
        dcv.visitEnd();
        mv.visitEnd();
        cv.visitEnd();
        fv.visitEnd();
    }
}

```

`dex-reader/src/test/java/com/googlecode/d2j/reader/test/BadZipEntryFlagTest.java`:

```java
package com.googlecode.d2j.reader.test;

import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import com.googlecode.d2j.reader.zip.ZipUtil;
import com.googlecode.d2j.util.zip.ZipFile;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.junit.Test;

/**
 * Test case for issue 169
 * 
 * @author bob
 * 
 */
public class BadZipEntryFlagTest {
    @Test
    public void test1() throws IOException {
        ZipArchiveInputStream zis = new ZipArchiveInputStream(BadZipEntryFlagTest.class.getResourceAsStream("/bad.zip"));
        for (ZipArchiveEntry e = zis.getNextZipEntry(); e != null; e = zis.getNextZipEntry()) {
            e.getGeneralPurposeBit().useEncryption(false);
            if (!e.isDirectory()) {
                zis.read();
                System.out.println(e.getName());
            }
        }
    }

    @Test
    public void test0() throws IOException {
        byte[] data = ZipUtil.toByteArray(BadZipEntryFlagTest.class.getResourceAsStream("/bad.zip"));
        try (ZipFile zip = new ZipFile(data)) {
            for (com.googlecode.d2j.util.zip.ZipEntry e : zip.entries()) {
                System.out.println(e);
                if (!e.isDirectory()) {
                    zip.getInputStream(e).read();
                }
            }
        }
    }

    // @Ignore("the way to build bad zip")
    // @Test
    // public void test2() throws IOException {
    // ArchiveOutputStream zis = new ZipArchiveOutputStreamHack(new
    // FileOutputStream("src/test/resources/bad.zip"));
    // ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
    // zis.putArchiveEntry(entry);
    // zis.write("Test!".getBytes("UTF-8"));
    // zis.closeArchiveEntry();
    // zis.close();
    // }

}

```

`dex-reader/src/test/java/com/googlecode/d2j/reader/test/SkipDupMethod.java`:

```java
package com.googlecode.d2j.reader.test;


import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.reader.DexFileReader;
import org.junit.Assert;
import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;

public class SkipDupMethod {
    @Test
    public void test() throws IOException {
        InputStream is = SkipDupMethod.class.getClassLoader().getResourceAsStream("i200.dex");
        Assert.assertNotNull(is);
        DexFileReader reader = new DexFileReader(is);
        DexFileNode dfn1 = new DexFileNode();
        reader.accept(dfn1, DexFileReader.KEEP_ALL_METHODS);
        DexFileNode dfn2 = new DexFileNode();
        reader.accept(dfn2, 0);
        Assert.assertTrue(dfn1.clzs.get(0).methods.size() > dfn2.clzs.get(0).methods.size());

    }
}

```

`dex-tools/build.gradle`:

```gradle
description = 'Dex Tools'
apply plugin:'application'

mainClassName="com.googlecode.dex2jar.tools.BaseCmd"

dependencies {
  compile project(':dex-translator')
  compile project(':d2j-smali')
  compile project(':d2j-jasmin')
  compile project(':dex-writer')
  compile project(':d2j-base-cmd')
    implementation group: 'org.ow2.asm', name: 'asm-tree', version: '9.5'
    implementation group: 'org.ow2.asm', name: 'asm-util', version: '9.5'
    implementation group: 'org.ow2.asm', name: 'asm-commons', version: '9.5'
}

task bin_gen(type: JavaExec) {
    dependsOn jar
    classpath sourceSets.main.runtimeClasspath
    ext.binDir="$buildDir/generated-sources/bin"
    outputs.dir file(ext.binDir)
    main='com.googlecode.dex2jar.bin_gen.BinGen'
    args=["$projectDir/src/main/bin_gen","$ext.binDir"]
}
applicationDistribution.from(bin_gen)
//applicationDistribution.from('src/main/jars') {
//  into("lib")
//}
applicationDistribution.from('open-source-license.txt') {
  into("lib")
}
applicationDistribution.from("$parent.rootDir") {
  include("NOTICE.txt")
  include("LICENSE.txt")
}

startScripts.dependsOn bin_gen

artifacts.archives distZip


```

`dex-tools/open-source-license.txt`:

```txt
==== dx-*.jar
Apache 2.0 http://www.apache.org/licenses/LICENSE-2.0.html


==== antlr-*.jar
[The BSD License]
Copyright (c) 2003-2007, Terence Parr
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.
* Neither the name of the author nor the names of its contributors
  may be used to endorse or promote products derived from this
  software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.


==== asm-*.jar

 ASM: a very small and fast Java bytecode manipulation framework
 Copyright (c) 2000-2005 INRIA, France Telecom
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. Neither the name of the copyright holders nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 THE POSSIBILITY OF SUCH DAMAGE.


```

`dex-tools/src/main/assemble/package.xml`:

```xml
<assembly
    xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
    <id>distribution</id>
    <formats>
        <format>zip</format>
    </formats>

    <fileSets>
        <fileSet>
            <directory>target/bin/</directory>
            <includes>
                <include>*.sh</include>
                <include>*.bat</include>
            </includes>
            <outputDirectory>/</outputDirectory>
        </fileSet>
    </fileSets>
    <files>
        <file>
            <source>../LICENSE.txt</source>
            <fileMode>664</fileMode>
            <outputDirectory>/</outputDirectory>
        </file>
        <file>
            <source>../NOTICE.txt</source>
            <fileMode>664</fileMode>
            <outputDirectory>/</outputDirectory>
        </file>
        <file>
            <source>open-source-license.txt</source>
            <fileMode>664</fileMode>
            <outputDirectory>/lib</outputDirectory>
        </file>
    </files>
    <dependencySets>
        <dependencySet>
            <outputDirectory>/lib</outputDirectory>
            <scope>runtime</scope>
        </dependencySet>
    </dependencySets>
</assembly>

```

`dex-tools/src/main/bin_gen/bat_template`:

```
@echo off

REM
REM dex2jar - Tools to work with android .dex and java .class files
REM Copyright (c) 2009-2013 Panxiaobo
REM 
REM Licensed under the Apache License, Version 2.0 (the "License");
REM you may not use this file except in compliance with the License.
REM You may obtain a copy of the License at
REM 
REM      http://www.apache.org/licenses/LICENSE-2.0
REM 
REM Unless required by applicable law or agreed to in writing, software
REM distributed under the License is distributed on an "AS IS" BASIS,
REM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
REM See the License for the specific language governing permissions and
REM limitations under the License.
REM

REM call d2j_invoke.bat to setup java environment
@"%~dp0d2j_invoke.bat" __@class_name@__ %*

```

`dex-tools/src/main/bin_gen/class.cfg`:

```cfg

# from dex-reader
#d2j-dex-asmifier=com.googlecode.dex2jar.util.ASMifierFileV
#d2j-dex-dump=com.googlecode.dex2jar.util.Dump

# from dex-tool
d2j-dex2jar=com.googlecode.dex2jar.tools.Dex2jarCmd
d2j-jar2dex=com.googlecode.dex2jar.tools.Jar2Dex
d2j-asm-verify=com.googlecode.dex2jar.tools.AsmVerify
d2j-jar2jasmin=com.googlecode.d2j.jasmin.Jar2JasminCmd
d2j-jasmin2jar=com.googlecode.d2j.jasmin.Jasmin2JarCmd

d2j-apk-sign=com.googlecode.dex2jar.tools.ApkSign

#d2j-init-deobf=com.googlecode.dex2jar.tools.DeObfInitCmd
#d2j-jar-remap=com.googlecode.dex2jar.tools.JarRemap
d2j-jar-access=com.googlecode.dex2jar.tools.JarAccessCmd
d2j-decrypt-string=com.googlecode.dex2jar.tools.DecryptStringCmd
d2j-smali=com.googlecode.d2j.smali.SmaliCmd
d2j-baksmali=com.googlecode.d2j.smali.BaksmaliCmd
d2j-dex2smali=com.googlecode.d2j.smali.BaksmaliCmd
#d2j-dex-remap=com.googlecode.dex2jar.tools.DexRemapCmd


d2j-dex-recompute-checksum=com.googlecode.dex2jar.tools.DexRecomputeChecksum
d2j-std-apk=com.googlecode.dex2jar.tools.StdApkCmd

d2j-dex-weaver=com.googlecode.dex2jar.tools.DexWeaverCmd
d2j-jar-weaver=com.googlecode.dex2jar.tools.JarWeaverCmd

d2j-class-version-switch=com.googlecode.dex2jar.tools.ClassVersionSwitch

#EOF

```

`dex-tools/src/main/bin_gen/d2j_invoke.bat`:

```bat
@echo off
REM better invocation scripts for windows from lanchon, release in public domain. thanks!
REM https://code.google.com/p/dex2jar/issues/detail?id=192

setlocal enabledelayedexpansion

set LIB=%~dp0lib

set CP=
for %%X in ("%LIB%"\*.jar) do (
    set CP=!CP!%%X;
)

java -Xms512m -Xmx2048m -cp "%CP%" %*

```

`dex-tools/src/main/bin_gen/d2j_invoke.sh`:

```sh
#!/bin/sh

#
# dex2jar - Tools to work with android .dex and java .class files
# Copyright (c) 2009-2013 Panxiaobo
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# copy from $Tomcat/bin/startup.sh
# resolve links - $0 may be a softlink
PRG="$0"
while [ -h "$PRG" ] ; do
  ls=`ls -ld "$PRG"`
  link=`expr "$ls" : '.*-> \(.*\)$'`
  if expr "$link" : '/.*' > /dev/null; then
    PRG="$link"
  else
    PRG=`dirname "$PRG"`/"$link"
  fi
done
PRGDIR=`dirname "$PRG"`
#

_classpath="."
if [ `uname -a | grep -i -c cygwin` -ne 0 ]; then # Cygwin, translate the path
    for k in "$PRGDIR"/lib/*.jar
    do
        _classpath="${_classpath};`cygpath -w ${k}`"
    done
else
    for k in "$PRGDIR"/lib/*.jar
    do
        _classpath="${_classpath}:${k}"
    done
fi

java -Xms512m -Xmx2048m -classpath "${_classpath}" "$@"

```

`dex-tools/src/main/bin_gen/sh_template`:

```
#!/bin/sh

#
# dex2jar - Tools to work with android .dex and java .class files
# Copyright (c) 2009-2013 Panxiaobo
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# copy from $Tomcat/bin/startup.sh
# resolve links - $0 may be a softlink
PRG="$0"
while [ -h "$PRG" ] ; do
  ls=`ls -ld "$PRG"`
  link=`expr "$ls" : '.*-> \(.*\)$'`
  if expr "$link" : '/.*' > /dev/null; then
    PRG="$link"
  else
    PRG=`dirname "$PRG"`/"$link"
  fi
done
PRGDIR=`dirname "$PRG"`
#

_classpath="."
if [ `uname -a | grep -i -c cygwin` -ne 0 ]; then # Cygwin, translate the path
    for k in "$PRGDIR"/lib/*.jar
    do
        _classpath="${_classpath};`cygpath -w ${k}`"
    done
else
    for k in "$PRGDIR"/lib/*.jar
    do
        _classpath="${_classpath}:${k}"
    done
fi

java -Xms512m -Xmx2048m -classpath "${_classpath}" "__@class_name@__" "$@"

```

`dex-tools/src/main/java/com/googlecode/d2j/signapk/AbstractJarSign.java`:

```java
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.googlecode.d2j.signapk;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.security.DigestOutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.SignatureException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.jar.Attributes;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.regex.Pattern;

public abstract class AbstractJarSign {
    /** Write to another stream and also feed it to the Signature object. */
    private static class SignatureOutputStream extends FilterOutputStream {
        private int mCount;
        private Signature mSignature;

        public SignatureOutputStream(OutputStream out, Signature sig) {
            super(out);
            mSignature = sig;
            mCount = 0;
        }

        public int size() {
            return mCount;
        }

        @Override
        public void write(byte[] b) throws IOException {
            try {
                mSignature.update(b, 0, b.length);
            } catch (SignatureException e) {
                throw new IOException("SignatureException: " + e);
            }
            out.write(b);
            mCount += b.length;
        }

        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            try {
                mSignature.update(b, off, len);
            } catch (SignatureException e) {
                throw new IOException("SignatureException: " + e);
            }
            out.write(b, off, len);
            mCount += len;
        }

        @Override
        public void write(int b) throws IOException {
            try {
                mSignature.update((byte) b);
            } catch (SignatureException e) {
                throw new IOException("SignatureException: " + e);
            }
            out.write(b);
            mCount++;
        }
    }

    // Files matching this pattern are not copied to the output.
    private static Pattern stripPattern = Pattern.compile("^META-INF/(.*)[.](SF|RSA|DSA)$");
    private static final byte[] EOL = "\r\n".getBytes(StandardCharsets.UTF_8);
    private static final byte[] COL = ": ".getBytes(StandardCharsets.UTF_8);
    private static final byte[] NAMES = "Name: ".getBytes(StandardCharsets.UTF_8);

    /**
     * Copy all the files in a manifest from input to output. We set the
     * modification times in the output to a fixed time, so as to reduce
     * variation in the output file and make incremental OTAs more efficient.
     */
    private static void copyFiles(Manifest manifest, JarFile in, JarOutputStream out, long timestamp)
            throws IOException {
        byte[] buffer = new byte[4096];
        int num;

        Map<String, Attributes> entries = manifest.getEntries();
        List<String> names = new ArrayList<>(entries.keySet());
        Collections.sort(names);
        for (String name : names) {
            JarEntry inEntry = in.getJarEntry(name);
            JarEntry outEntry = null;
            if (inEntry.getMethod() == JarEntry.STORED) {
                // Preserve the STORED method of the input entry.
                outEntry = new JarEntry(inEntry);
            } else {
                // Create a new entry so that the compressed len is recomputed.
                outEntry = new JarEntry(name);
            }
            outEntry.setTime(timestamp);
            out.putNextEntry(outEntry);

            InputStream data = in.getInputStream(inEntry);
            while ((num = data.read(buffer)) > 0) {
                out.write(buffer, 0, num);
            }
            out.flush();
        }
    }

    final protected String digestAlg;

    final protected PrivateKey privateKey;

    public AbstractJarSign(PrivateKey privateKey) {
        this(privateKey, "SHA1", "SHA1withRSA");
    }

    public AbstractJarSign(PrivateKey privateKey, String digestAlg, String signAlg) {
        super();

        this.privateKey = privateKey;
        this.digestAlg = digestAlg;
        this.signAlg = signAlg;
    }

    final protected String signAlg;

    /** Add the SHA1 of every file to the manifest, creating it if necessary. */
    private Manifest addDigestsToManifest(JarFile jar) throws IOException, GeneralSecurityException {
        Manifest input = jar.getManifest();
        Manifest output = new Manifest();
        Attributes main = output.getMainAttributes();
        if (input != null) {
            main.putAll(input.getMainAttributes());
        }
        main.putValue("Manifest-Version", "1.0");
        main.putValue("Created-By", "1.6.0_21 (d2j-" + AbstractJarSign.class.getPackage().getImplementationVersion() + ")");

        MessageDigest md = MessageDigest.getInstance(digestAlg);
        byte[] buffer = new byte[4096];
        int num;

        // We sort the input entries by name, and add them to the
        // output manifest in sorted order. We expect that the output
        // map will be deterministic.

        TreeMap<String, JarEntry> byName = new TreeMap<String, JarEntry>();

        for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements();) {
            JarEntry entry = e.nextElement();
            byName.put(entry.getName(), entry);
        }

        String digName = digestAlg + "-Digest";
        for (JarEntry entry : byName.values()) {
            String name = entry.getName();
            if (!entry.isDirectory() && !name.equals(JarFile.MANIFEST_NAME) && !stripPattern.matcher(name).matches()) {
                InputStream data = jar.getInputStream(entry);
                while ((num = data.read(buffer)) > 0) {
                    md.update(buffer, 0, num);
                }

                Attributes attr = null;
                if (input != null) {
                    attr = input.getAttributes(name);
                }
                attr = attr != null ? new Attributes(attr) : new Attributes();
                attr.putValue(digName, encodeBase64(md.digest()));
                output.getEntries().put(name, attr);
            }
        }

        return output;
    }

    protected String encodeBase64(byte[] data) {
       return Base64.encodeToString(data, Base64.NO_WRAP);
    }

    public void sign(File in, File out) throws IOException, GeneralSecurityException {

        JarFile inputJar = null;
        JarOutputStream outputJar = null;
        FileOutputStream outputFile = null;

        try {

            // Assume the certificate is valid for at least an hour.
            long timestamp = System.currentTimeMillis();

            inputJar = new JarFile(in, false); // Don't verify.

            OutputStream outputStream = outputFile = new FileOutputStream(out);
            outputJar = new JarOutputStream(outputStream);
            outputJar.setLevel(9);

            JarEntry je;

            // MANIFEST.MF
            Manifest manifest = addDigestsToManifest(inputJar);
            je = new JarEntry(JarFile.MANIFEST_NAME);
            je.setTime(timestamp);
            outputJar.putNextEntry(je);
            manifest.write(outputJar);

            // CERT.SF
            Signature signature = Signature.getInstance(signAlg);
            signature.initSign(privateKey);
            je = new JarEntry("META-INF/CERT.SF");
            je.setTime(timestamp);
            outputJar.putNextEntry(je);
            writeSignatureFile(manifest, new SignatureOutputStream(outputJar, signature));

            int i = digestAlg.toLowerCase().indexOf("with");
            String ext;
            if (i > 0) {
                ext = digestAlg.substring(i + 4);
            } else {
                ext = "RSA";
            }
            // CERT.RSA
            je = new JarEntry("META-INF/CERT." + ext);
            je.setTime(timestamp);
            outputJar.putNextEntry(je);

            writeSignatureBlock(signature.sign(), outputJar);

            // Everything else
            copyFiles(manifest, inputJar, outputJar, timestamp);

            outputJar.close();
            outputJar = null;
            outputStream.flush();

        } finally {
            try {
                if (inputJar != null) {
                    inputJar.close();
                }
                if (outputFile != null) {
                    outputFile.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /** Write a .RSA file with a digital signature. */
    protected abstract void writeSignatureBlock(byte[] signature, OutputStream out) throws IOException;

    /** Write a .SF file with a digest of the specified manifest. */
    private void writeSignatureFile(Manifest manifest, SignatureOutputStream out) throws IOException,
            GeneralSecurityException {
        Manifest sf = new Manifest();
        Attributes main = sf.getMainAttributes();
        main.putValue("Signature-Version", "1.0");
        main.putValue("Created-By", "1.6.0_21 (d2j-" + AbstractJarSign.class.getPackage().getImplementationVersion() + ")");

        MessageDigest md = MessageDigest.getInstance(digestAlg);
        DigestOutputStream print = new DigestOutputStream(new OutputStream() {

            @Override
            public void write(byte[] b) throws IOException {

            }

            @Override
            public void write(byte[] b, int off, int len) throws IOException {

            }

            @Override
            public void write(int b) throws IOException {

            }
        }, md);

        // Digest of the entire manifest
        manifest.write(print);
        print.flush();
        main.putValue(digestAlg + "-Digest-Manifest", encodeBase64(md.digest()));

        // digest main attribute
        Manifest m2 = new Manifest();
        m2.getMainAttributes().putAll(manifest.getMainAttributes());
        m2.write(print);
        main.putValue(digestAlg + "-Digest-Manifest-Main-Attributes", encodeBase64(md.digest()));

        String digName = digestAlg + "-Digest";
        Map<String, Attributes> entries = manifest.getEntries();

        for (Map.Entry<String, Attributes> entry : entries.entrySet()) {
            // Digest of the manifest stanza for this entry.
            print.write(NAMES);
            print.write(entry.getKey().getBytes(StandardCharsets.UTF_8));
            print.write(EOL);
            for (Map.Entry<Object, Object> att : entry.getValue().entrySet()) {
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(COL);
                print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));
                print.write(EOL);
            }
            print.write(EOL);
            print.flush();

            Attributes sfAttr = new Attributes();
            sfAttr.putValue(digName, encodeBase64(md.digest()));
            sf.getEntries().put(entry.getKey(), sfAttr);
        }

        sf.write(out);

        // A bug in the java.util.jar implementation of Android platforms
        // up to version 1.6 will cause a spurious IOException to be thrown
        // if the length of the signature file is a multiple of 1024 bytes.
        // As a workaround, add an extra CRLF in this case.
        if ((out.size() % 1024) == 0) {
            out.write(EOL);
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/d2j/signapk/Base64.java`:

```java
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.signapk;
import java.io.UnsupportedEncodingException;

/**
 * Utilities for encoding and decoding the Base64 representation of
 * binary data.  See RFCs <a
 * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
 * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
 */
public class Base64 {
    /**
     * Default values for encoder/decoder flags.
     */
    public static final int DEFAULT = 0;

    /**
     * Encoder flag bit to omit the padding '=' characters at the end
     * of the output (if any).
     */
    public static final int NO_PADDING = 1;

    /**
     * Encoder flag bit to omit all line terminators (i.e., the output
     * will be on one long line).
     */
    public static final int NO_WRAP = 2;

    /**
     * Encoder flag bit to indicate lines should be terminated with a
     * CRLF pair instead of just an LF.  Has no effect if {@code
     * NO_WRAP} is specified as well.
     */
    public static final int CRLF = 4;

    /**
     * Encoder/decoder flag bit to indicate using the "URL and
     * filename safe" variant of Base64 (see RFC 3548 section 4) where
     * {@code -} and {@code _} are used in place of {@code +} and
     * {@code /}.
     */
    public static final int URL_SAFE = 8;

    /**
     * Flag to pass to {@link Base64OutputStream} to indicate that it
     * should not close the output stream it is wrapping when it
     * itself is closed.
     */
    public static final int NO_CLOSE = 16;

    //  --------------------------------------------------------
    //  shared code
    //  --------------------------------------------------------

    /* package */ static abstract class Coder {
        public byte[] output;
        public int op;

        /**
         * Encode/decode another block of input data.  this.output is
         * provided by the caller, and must be big enough to hold all
         * the coded data.  On exit, this.opwill be set to the length
         * of the coded data.
         *
         * @param finish true if this is the final call to process for
         *        this object.  Will finalize the coder state and
         *        include any final bytes in the output.
         *
         * @return true if the input so far is good; false if some
         *         error has been detected in the input stream..
         */
        public abstract boolean process(byte[] input, int offset, int len, boolean finish);

        /**
         * @return the maximum number of bytes a call to process()
         * could produce for the given number of input bytes.  This may
         * be an overestimate.
         */
        public abstract int maxOutputSize(int len);
    }

    //  --------------------------------------------------------
    //  decoding
    //  --------------------------------------------------------

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param str    the input String to decode, which is converted to
     *               bytes using the default charset
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(String str, int flags) {
        return decode(str.getBytes(), flags);
    }

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param input the input array to decode
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(byte[] input, int flags) {
        return decode(input, 0, input.length, flags);
    }

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param input  the data to decode
     * @param offset the position within the input array at which to start
     * @param len    the number of bytes of input to decode
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(byte[] input, int offset, int len, int flags) {
        // Allocate space for the most data the input could represent.
        // (It could contain less if it contains whitespace, etc.)
        Decoder decoder = new Decoder(flags, new byte[len*3/4]);

        if (!decoder.process(input, offset, len, true)) {
            throw new IllegalArgumentException("bad base-64");
        }

        // Maybe we got lucky and allocated exactly enough output space.
        if (decoder.op == decoder.output.length) {
            return decoder.output;
        }

        // Need to shorten the array, so allocate a new one of the
        // right size and copy.
        byte[] temp = new byte[decoder.op];
        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
        return temp;
    }

    /* package */ static class Decoder extends Coder {
        /**
         * Lookup table for turning bytes into their position in the
         * Base64 alphabet.
         */
        private static final int DECODE[] = {
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        /**
         * Decode lookup table for the "web safe" variant (RFC 3548
         * sec. 4) where - and _ replace + and /.
         */
        private static final int DECODE_WEBSAFE[] = {
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        /** Non-data values in the DECODE arrays. */
        private static final int SKIP = -1;
        private static final int EQUALS = -2;

        /**
         * States 0-3 are reading through the next input tuple.
         * State 4 is having read one '=' and expecting exactly
         * one more.
         * State 5 is expecting no more data or padding characters
         * in the input.
         * State 6 is the error state; an error has been detected
         * in the input and no future input can "fix" it.
         */
        private int state;   // state number (0 to 6)
        private int value;

        final private int[] alphabet;

        public Decoder(int flags, byte[] output) {
            this.output = output;

            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
            state = 0;
            value = 0;
        }

        /**
         * @return an overestimate for the number of bytes {@code
         * len} bytes could decode to.
         */
        public int maxOutputSize(int len) {
            return len * 3/4 + 10;
        }

        /**
         * Decode another block of input data.
         *
         * @return true if the state machine is still healthy.  false if
         *         bad base-64 data has been detected in the input stream.
         */
        public boolean process(byte[] input, int offset, int len, boolean finish) {
            if (this.state == 6) return false;

            int p = offset;
            len += offset;

            // Using local variables makes the decoder about 12%
            // faster than if we manipulate the member variables in
            // the loop.  (Even alphabet makes a measurable
            // difference, which is somewhat surprising to me since
            // the member variable is final.)
            int state = this.state;
            int value = this.value;
            int op = 0;
            final byte[] output = this.output;
            final int[] alphabet = this.alphabet;

            while (p < len) {
                // Try the fast path:  we're starting a new tuple and the
                // next four bytes of the input stream are all data
                // bytes.  This corresponds to going through states
                // 0-1-2-3-0.  We expect to use this method for most of
                // the data.
                //
                // If any of the next four bytes of input are non-data
                // (whitespace, etc.), value will end up negative.  (All
                // the non-data values in decode are small negative
                // numbers, so shifting any of them up and or'ing them
                // together will result in a value with its top bit set.)
                //
                // You can remove this whole block and the output should
                // be the same, just slower.
                if (state == 0) {
                    while (p+4 <= len &&
                           (value = ((alphabet[input[p] & 0xff] << 18) |
                                     (alphabet[input[p+1] & 0xff] << 12) |
                                     (alphabet[input[p+2] & 0xff] << 6) |
                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        p += 4;
                    }
                    if (p >= len) break;
                }

                // The fast path isn't available -- either we've read a
                // partial tuple, or the next four input bytes aren't all
                // data, or whatever.  Fall back to the slower state
                // machine implementation.

                int d = alphabet[input[p++] & 0xff];

                switch (state) {
                case 0:
                    if (d >= 0) {
                        value = d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 1:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 2:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect exactly one more padding character.
                        output[op++] = (byte) (value >> 4);
                        state = 4;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 3:
                    if (d >= 0) {
                        // Emit the output triple and return to state 0.
                        value = (value << 6) | d;
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        state = 0;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect no further data or padding characters.
                        output[op+1] = (byte) (value >> 2);
                        output[op] = (byte) (value >> 10);
                        op += 2;
                        state = 5;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 4:
                    if (d == EQUALS) {
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 5:
                    if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;
                }
            }

            if (!finish) {
                // We're out of input, but a future call could provide
                // more.
                this.state = state;
                this.value = value;
                this.op = op;
                return true;
            }

            // Done reading input.  Now figure out where we are left in
            // the state machine and finish up.

            switch (state) {
            case 0:
                // Output length is a multiple of three.  Fine.
                break;
            case 1:
                // Read one extra input byte, which isn't enough to
                // make another output byte.  Illegal.
                this.state = 6;
                return false;
            case 2:
                // Read two extra input bytes, enough to emit 1 more
                // output byte.  Fine.
                output[op++] = (byte) (value >> 4);
                break;
            case 3:
                // Read three extra input bytes, enough to emit 2 more
                // output bytes.  Fine.
                output[op++] = (byte) (value >> 10);
                output[op++] = (byte) (value >> 2);
                break;
            case 4:
                // Read one padding '=' when we expected 2.  Illegal.
                this.state = 6;
                return false;
            case 5:
                // Read all the padding '='s we expected and no more.
                // Fine.
                break;
            }

            this.state = state;
            this.op = op;
            return true;
        }
    }

    //  --------------------------------------------------------
    //  encoding
    //  --------------------------------------------------------

    /**
     * Base64-encode the given data and return a newly allocated
     * String with the result.
     *
     * @param input  the data to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static String encodeToString(byte[] input, int flags) {
        try {
            return new String(encode(input, flags), "US-ASCII");
        } catch (UnsupportedEncodingException e) {
            // US-ASCII is guaranteed to be available.
            throw new AssertionError(e);
        }
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * String with the result.
     *
     * @param input  the data to encode
     * @param offset the position within the input array at which to
     *               start
     * @param len    the number of bytes of input to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static String encodeToString(byte[] input, int offset, int len, int flags) {
        try {
            return new String(encode(input, offset, len, flags), "US-ASCII");
        } catch (UnsupportedEncodingException e) {
            // US-ASCII is guaranteed to be available.
            throw new AssertionError(e);
        }
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * byte[] with the result.
     *
     * @param input  the data to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static byte[] encode(byte[] input, int flags) {
        return encode(input, 0, input.length, flags);
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * byte[] with the result.
     *
     * @param input  the data to encode
     * @param offset the position within the input array at which to
     *               start
     * @param len    the number of bytes of input to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static byte[] encode(byte[] input, int offset, int len, int flags) {
        Encoder encoder = new Encoder(flags, null);

        // Compute the exact length of the array we will produce.
        int output_len = len / 3 * 4;

        // Account for the tail of the data and the padding bytes, if any.
        if (encoder.do_padding) {
            if (len % 3 > 0) {
                output_len += 4;
            }
        } else {
            switch (len % 3) {
                case 0: break;
                case 1: output_len += 2; break;
                case 2: output_len += 3; break;
            }
        }

        // Account for the newlines, if any.
        if (encoder.do_newline && len > 0) {
            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
                (encoder.do_cr ? 2 : 1);
        }

        encoder.output = new byte[output_len];
        encoder.process(input, offset, len, true);

        assert encoder.op == output_len;

        return encoder.output;
    }

    /* package */ static class Encoder extends Coder {
        /**
         * Emit a new line every this many output tuples.  Corresponds to
         * a 76-character line length (the maximum allowable according to
         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
         */
        public static final int LINE_GROUPS = 19;

        /**
         * Lookup table for turning Base64 alphabet positions (6 bits)
         * into output bytes.
         */
        private static final byte ENCODE[] = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
        };

        /**
         * Lookup table for turning Base64 alphabet positions (6 bits)
         * into output bytes.
         */
        private static final byte ENCODE_WEBSAFE[] = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
        };

        final private byte[] tail;
        /* package */ int tailLen;
        private int count;

        final public boolean do_padding;
        final public boolean do_newline;
        final public boolean do_cr;
        final private byte[] alphabet;

        public Encoder(int flags, byte[] output) {
            this.output = output;

            do_padding = (flags & NO_PADDING) == 0;
            do_newline = (flags & NO_WRAP) == 0;
            do_cr = (flags & CRLF) != 0;
            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;

            tail = new byte[2];
            tailLen = 0;

            count = do_newline ? LINE_GROUPS : -1;
        }

        /**
         * @return an overestimate for the number of bytes {@code
         * len} bytes could encode to.
         */
        public int maxOutputSize(int len) {
            return len * 8/5 + 10;
        }

        public boolean process(byte[] input, int offset, int len, boolean finish) {
            // Using local variables makes the encoder about 9% faster.
            final byte[] alphabet = this.alphabet;
            final byte[] output = this.output;
            int op = 0;
            int count = this.count;

            int p = offset;
            len += offset;
            int v = -1;

            // First we need to concatenate the tail of the previous call
            // with any input bytes available now and see if we can empty
            // the tail.

            switch (tailLen) {
                case 0:
                    // There was no tail.
                    break;

                case 1:
                    if (p+2 <= len) {
                        // A 1-byte tail with at least 2 bytes of
                        // input available now.
                        v = ((tail[0] & 0xff) << 16) |
                            ((input[p++] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    };
                    break;

                case 2:
                    if (p+1 <= len) {
                        // A 2-byte tail with at least 1 byte of input.
                        v = ((tail[0] & 0xff) << 16) |
                            ((tail[1] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    }
                    break;
            }

            if (v != -1) {
                output[op++] = alphabet[(v >> 18) & 0x3f];
                output[op++] = alphabet[(v >> 12) & 0x3f];
                output[op++] = alphabet[(v >> 6) & 0x3f];
                output[op++] = alphabet[v & 0x3f];
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            // At this point either there is no tail, or there are fewer
            // than 3 bytes of input available.

            // The main loop, turning 3 input bytes into 4 output bytes on
            // each iteration.
            while (p+3 <= len) {
                v = ((input[p] & 0xff) << 16) |
                    ((input[p+1] & 0xff) << 8) |
                    (input[p+2] & 0xff);
                output[op] = alphabet[(v >> 18) & 0x3f];
                output[op+1] = alphabet[(v >> 12) & 0x3f];
                output[op+2] = alphabet[(v >> 6) & 0x3f];
                output[op+3] = alphabet[v & 0x3f];
                p += 3;
                op += 4;
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            if (finish) {
                // Finish up the tail of the input.  Note that we need to
                // consume any bytes in tail before any bytes
                // remaining in input; there should be at most two bytes
                // total.

                if (p-tailLen == len-1) {
                    int t = 0;
                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (p-tailLen == len-2) {
                    int t = 0;
                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 12) & 0x3f];
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                }

                assert tailLen == 0;
                assert p == len;
            } else {
                // Save the leftovers in tail to be consumed on the next
                // call to encodeInternal.

                if (p == len-1) {
                    tail[tailLen++] = input[p];
                } else if (p == len-2) {
                    tail[tailLen++] = input[p];
                    tail[tailLen++] = input[p+1];
                }
            }

            this.op = op;
            this.count = count;

            return true;
        }
    }

    private Base64() { }   // don't instantiate
}

```

`dex-tools/src/main/java/com/googlecode/d2j/signapk/SunJarSignImpl.java`:

```java
package com.googlecode.d2j.signapk;

import java.io.IOException;
import java.io.OutputStream;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;

import sun.security.pkcs.ContentInfo;
import sun.security.pkcs.PKCS7;
import sun.security.pkcs.SignerInfo;
import sun.security.x509.AlgorithmId;
import sun.security.x509.X500Name;

public class SunJarSignImpl extends AbstractJarSign {
    final protected X509Certificate cert;

    public SunJarSignImpl(X509Certificate cert, PrivateKey privateKey) {
        super(privateKey);
        this.cert = cert;
    }

    /** Write a .RSA file with a digital signature. */
    @SuppressWarnings("all")
    protected void writeSignatureBlock(byte[] signature, OutputStream out) throws IOException {
        try {
            SignerInfo signerInfo = new SignerInfo(new X500Name(cert.getIssuerX500Principal().getName()),
                    cert.getSerialNumber(), AlgorithmId.get(digestAlg), AlgorithmId.get("RSA"), signature);

            PKCS7 pkcs7 = new PKCS7(new AlgorithmId[] { AlgorithmId.get(digestAlg) }, new ContentInfo(
                    ContentInfo.DATA_OID, null), new X509Certificate[] { cert }, new SignerInfo[] { signerInfo });

            pkcs7.encodeSignedData(out);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/d2j/signapk/TinySignImpl.java`:

```java
package com.googlecode.d2j.signapk;

import java.io.IOException;
import java.io.OutputStream;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;

/**
 * get from
 * https://code.google.com/p/tiny-sign/source/browse/src/main/java/pxb/android
 * /tinysign/TinySign.java
 * 
 * @author bob
 * 
 */
public final class TinySignImpl extends AbstractJarSign {

    private static PrivateKey buildPrivateKey() {

        PrivateKey privateKey;
        try {
            privateKey = KeyFactory.getInstance("RSA").generatePrivate(
                    new PKCS8EncodedKeySpec(Base64.decode(sPrivateKey,0)));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        return privateKey;
    }

    public TinySignImpl() {
        super(buildPrivateKey(), "SHA1", "SHA1withRSA");
    }

    private static final String sPrivateKey = "MIIBVgIBADANBgkqhkiG9w0BAQEFAASCAUAwggE8AgEAAkEAoiZSqWnFDHA5sXKoDiUUO9JuL7cm/2dCck5MKumVvv+WfSg0jsovnywsFN0pifmdRSLmOdUkh0d0J+tOnSgtsQIDAQABAkEAihag5u3Qhds9BsViIUmqhZebhr8vUuqZR8cuTo1GnbSoOHIPbAgD3J8TDbC/CVqae8NrgwLp325Pem1Tuof/0QIhAN1hqft1K307bsljgw3iYKopGVZBHRXsjRnNL4edV9QrAiEAu4F+XtS1wohGLz5QtfuMFsQNo4l31mCjt6WpBDmSi5MCIQCB++YijxmJ3mueM5+vd0vqnVcTHghF5y6yB5fwuKHpIQIgInnS1Hjj2prX3MPmby+LOHxfzZvvDtnCAHhTNVWonkUCIQCvV8l+SpL6Vh1nQ/2EKFJo2dbZB3wKG/BEYsFkPFbn9w==";
    private static final String sSigPrefix = "MIIB5gYJKoZIhvcNAQcCoIIB1zCCAdMCAQExCzAJBgUrDgMCGgUAMAsGCSqGSIb3DQEHAaCCATYwggEyMIHdoAMCAQICBCunMokwDQYJKoZIhvcNAQELBQAwDzENMAsGA1UEAxMEVGVzdDAeFw0xMjA0MjIwODQ1NDdaFw0xMzA0MjIwODQ1NDdaMA8xDTALBgNVBAMTBFRlc3QwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAoiZSqWnFDHA5sXKoDiUUO9JuL7cm/2dCck5MKumVvv+WfSg0jsovnywsFN0pifmdRSLmOdUkh0d0J+tOnSgtsQIDAQABoyEwHzAdBgNVHQ4EFgQUVL2yOinUwpARE1tOPxc1bf4WrTgwDQYJKoZIhvcNAQELBQADQQAnj/eZwhqwb2tgSYNvgRo5bBNNCpJbQ4alEeP/MLSIWf2nZpAix8T3oS9X2affQtAgctPATcKQaiH2B4L7FKlVMXoweAIBATAXMA8xDTALBgNVBAMTBFRlc3QCBCunMokwCQYFKw4DAhoFADANBgkqhkiG9w0BAQEFAARA";


    @Override
    protected void writeSignatureBlock(byte[] signature, OutputStream out) throws IOException {
        out.write(Base64.decode(sSigPrefix, 0));
        out.write(signature);
    }

}

```

`dex-tools/src/main/java/com/googlecode/d2j/tools/jar/BaseWeaver.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2015 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.tools.jar;

import org.objectweb.asm.Type;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;


public class BaseWeaver {
    protected String invocationInterfaceDesc = "Lcom/googlecode/d2j/tools/jar/MethodInvocation;";
    protected String invocationTypePrefix = "d2j/gen/MI_";

    protected static final String DEFAULT_RET_TYPE = "L888;";
    protected static final String DEFAULT_DESC = "(L;)" + DEFAULT_RET_TYPE;
    protected List<Callback> callbacks = new ArrayList<Callback>();
    protected int currentInvocationIdx = 0;
    protected int seqIndex = 1;
    protected MtdInfo key = new MtdInfo();
    protected Set<String> ignores = new HashSet<String>();
    protected Map<String, String> clzDescMap = new HashMap<String, String>();
    protected Map<MtdInfo, MtdInfo> mtdMap = new HashMap<MtdInfo, MtdInfo>();
    protected Map<MtdInfo, MtdInfo> defMap = new HashMap<MtdInfo, MtdInfo>();

    protected String buildMethodAName(String oldName) {
        return String.format("%s_A%03d", oldName, seqIndex++);
    }

    protected String buildCallbackMethodName(String oldName) {
        return String.format("%s_CB%03d", oldName, seqIndex++);
    }

    protected MtdInfo findDefinedTargetMethod(String owner, String name, String desc) {
        return findTargetMethod0(defMap, owner, name, desc);
    }

    protected MtdInfo findTargetMethod(String owner, String name, String desc) {
        return findTargetMethod0(mtdMap, owner, name, desc);
    }

    protected MtdInfo findTargetMethod0(Map<MtdInfo, MtdInfo> map, String owner, String name, String desc) {
        MtdInfo v = map.get(buildKey(owner, name, desc));
        if (v != null) {
            return v;
        }

        // try with default ret
        key.desc = Type.getMethodDescriptor(Type.getType(DEFAULT_RET_TYPE), Type.getArgumentTypes(desc));
        v = map.get(key);
        if (v != null) {
            return v;
        }
        // try with default desc
        key.desc = DEFAULT_DESC;
        v = map.get(key);
        if (v != null) {
            return v;
        }
        if (!name.equals("*")) {
            return findTargetMethod0(map, owner, "*", desc);
        }
        return v;
    }

    protected MtdInfo buildKey(String owner, String name, String desc) {
        key.name = name;
        key.owner = owner;
        key.desc = desc;
        return key;
    }

    public BaseWeaver withConfig(Path is) throws IOException {
        return withConfig(Files.readAllLines(is, StandardCharsets.UTF_8));
    }

    public BaseWeaver withConfig(InputStream is) throws IOException {
        try (BufferedReader r = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
            List<String> list = new ArrayList<>();
            for (String ln = r.readLine(); ln != null; ln = r.readLine()) {
                list.add(ln);
            }
            return withConfig(list);
        }
    }

    public BaseWeaver withConfig(List<String> lines) {
        for (String ln : lines) {
            withConfig(ln);
        }
        return this;
    }

    public void withConfig(String ln) {
        if ("".equals(ln) || ln.startsWith("#")) {
            return;
        }
        switch (Character.toLowerCase(ln.charAt(0))) {
            case 'i':
                ignores.add(ln.substring(2));
                break;
            case 'c':
                int index = ln.lastIndexOf('=');
                if (index > 0) {
                    String key = toInternal(ln.substring(2, index));
                    String value = toInternal(ln.substring(index + 1));
                    clzDescMap.put(key, value);
                    ignores.add(value);
                }
                break;
            case 'r':
                index = ln.lastIndexOf('=');
                if (index > 0) {
                    String key = ln.substring(2, index);
                    String value = ln.substring(index + 1);
                    MtdInfo mi = buildMethodInfo(key);

                    index = value.indexOf('.');
                    MtdInfo mtdValue = new MtdInfo();
                    mtdValue.owner = value.substring(0, index);

                    int index2 = value.indexOf('(', index);
                    mtdValue.name = value.substring(index + 1, index2);
                    mtdValue.desc = value.substring(index2);

                    mtdMap.put(mi, mtdValue);

                }
                break;
            case 'd':
                index = ln.lastIndexOf('=');
                if (index > 0) {
                    String key = ln.substring(2, index);
                    String value = ln.substring(index + 1);
                    MtdInfo mi = buildMethodInfo(key);

                    index = value.indexOf('.');
                    MtdInfo mtdValue = new MtdInfo();
                    mtdValue.owner = value.substring(0, index);

                    int index2 = value.indexOf('(', index);
                    mtdValue.name = value.substring(index + 1, index2);
                    mtdValue.desc = value.substring(index2);

                    defMap.put(mi, mtdValue);
                }
                break;

            case 'o':
                setInvocationInterfaceDesc(ln.substring(2));
                break;
            case 'p':
                invocationTypePrefix = ln.substring(2);
                break;
        }
    }

    public void setInvocationInterfaceDesc(String invocationInterfaceDesc) {
        this.invocationInterfaceDesc = invocationInterfaceDesc;
    }

    protected static String toInternal(String key) {
        if (key.endsWith(";")) {
            key = key.substring(1, key.length() - 1);
        }
        return key;
    }

    protected MtdInfo buildMethodInfo(String value) {
        int index = value.indexOf('.');
        MtdInfo mtdValue = new MtdInfo();
        mtdValue.owner = value.substring(0, index);
        int index2 = value.indexOf('(', index);
        if (index2 >= 0) {
            mtdValue.name = value.substring(index + 1, index2);
            int index3 = value.indexOf(')');
            if (index3 == value.length() - 1) {
                mtdValue.desc = value.substring(index2) + DEFAULT_RET_TYPE;
            } else {
                mtdValue.desc = value.substring(index2);
            }
        } else {
            mtdValue.name = value.substring(index + 1);
            mtdValue.desc = DEFAULT_DESC;
        }
        return mtdValue;
    }

    // internal name
    public String getCurrentInvocationName() {
        return String.format("%s_%03d", invocationTypePrefix, currentInvocationIdx);
    }

    protected void nextInvocationName() {
        currentInvocationIdx++;
        callbacks.clear();
    }

    public static class Callback {
        int idx;
        Object callback;
        Object target;
        boolean isSpecial;
        boolean isStatic;
    }

    public static class MtdInfo {
        public String desc;
        public String name;
        public String owner;

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;

            MtdInfo mtdInfo = (MtdInfo) o;

            if (!desc.equals(mtdInfo.desc))
                return false;
            if (!name.equals(mtdInfo.name))
                return false;
            if (!owner.equals(mtdInfo.owner))
                return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = desc.hashCode();
            result = 31 * result + name.hashCode();
            result = 31 * result + owner.hashCode();
            return result;
        }
    }

}

```

`dex-tools/src/main/java/com/googlecode/d2j/tools/jar/ClassInfo.java`:

```java
package com.googlecode.d2j.tools.jar;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class ClassInfo {

    final public String name;
    public List<MemberInfo> members = new ArrayList<MemberInfo>(5);
    public Set<String> parent = new HashSet<String>();

    public ClassInfo(String name) {
        this.name = name;
    }

    public boolean equals(Object o) {
        return name.equals(((ClassInfo) o).name);
    }

    public int hashCode() {
        return name.hashCode();
    }

    public String toString() {
        return name;
    }

    public static class MemberInfo {
        public int access;
        public String desc;
        public String name;
    }
}

```

`dex-tools/src/main/java/com/googlecode/d2j/tools/jar/DexWeaver.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2015 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.tools.jar;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.node.DexCodeNode;
import com.googlecode.d2j.node.DexMethodNode;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexFileVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.objectweb.asm.Type;

import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

/**
 * only implement sub set of InvocationWeaver
 * 2. Replace method A to another method B, parameter of B must be MethodInvocation
 * 3. Replace Methods Implementations
 */
public class DexWeaver extends BaseWeaver {
    interface CB {
        String getKey(Method mtd);
    }

    public String buildInvocationClz(DexFileVisitor dfv) {
        String typeName = getCurrentInvocationName();
        String typeNameDesc = "L" + typeName + ";";
        DexClassVisitor dcv = dfv.visit(DexConstants.ACC_PUBLIC, typeNameDesc, "Ljava/lang/Object;", new String[]{
                invocationInterfaceDesc});

        dcv.visitField(DexConstants.ACC_PRIVATE | DexConstants.ACC_FINAL,
                new Field(typeNameDesc, "thiz", "Ljava/lang/Object;"), null).visitEnd();
        dcv.visitField(DexConstants.ACC_PRIVATE | DexConstants.ACC_FINAL, new Field(typeNameDesc, "args", "[Ljava/lang/Object;"), null)
                .visitEnd();
        dcv.visitField(DexConstants.ACC_PRIVATE | DexConstants.ACC_FINAL, new Field(typeNameDesc, "idx", "I"), null)
                .visitEnd();


        {
            DexMethodVisitor mv = dcv
                    .visitMethod(DexConstants.ACC_PUBLIC | DexConstants.ACC_CONSTRUCTOR, new Method(typeNameDesc, "<init>", new String[]{
                            "Ljava/lang/Object;", "[Ljava/lang/Object;", "I"}, "V"));
            DexCodeVisitor codeVisitor = mv.visitCode();
            codeVisitor.visitRegister(4);
            codeVisitor.visitFieldStmt(Op.IPUT_OBJECT, 1, 0, new Field(typeNameDesc, "thiz", "Ljava/lang/Object;"));
            codeVisitor.visitFieldStmt(Op.IPUT_OBJECT, 2, 0, new Field(typeNameDesc, "args", "[Ljava/lang/Object;"));
            codeVisitor.visitFieldStmt(Op.IPUT, 3, 0, new Field(typeNameDesc, "idx", "I"));
            codeVisitor.visitStmt0R(Op.RETURN_VOID);
            codeVisitor.visitEnd();
            mv.visitEnd();
        }
        {
            genSwitchMethod(dcv, typeNameDesc, "getMethodOwner", new CB() {
                @Override
                public String getKey(Method mtd) {
                    return toInternal(mtd.getOwner());
                }
            });
            genSwitchMethod(dcv, typeNameDesc, "getMethodName", new CB() {
                @Override
                public String getKey(Method mtd) {
                    return mtd.getName();
                }
            });
            genSwitchMethod(dcv, typeNameDesc, "getMethodDesc", new CB() {
                @Override
                public String getKey(Method mtd) {
                    return mtd.getDesc();
                }
            });
        }

        {
            DexMethodVisitor mv = dcv
                    .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, "getArguments", new String[0], "[Ljava/lang/Object;"));
            DexCodeVisitor code = mv.visitCode();
            code.visitRegister(2);
            code.visitFieldStmt(Op.IGET, 0, 1, new Field(typeNameDesc, "args", "[Ljava/lang/Object;"));
            code.visitStmt1R(Op.RETURN_OBJECT, 0);

            code.visitEnd();
            mv.visitEnd();
        }

        {
            DexMethodVisitor mv = dcv
                    .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, "getThis", new String[0], "Ljava/lang/Object;"));
            DexCodeVisitor code = mv.visitCode();
            code.visitRegister(2);
            code.visitFieldStmt(Op.IGET, 0, 1, new Field(typeNameDesc, "thiz", "Ljava/lang/Object;"));
            code.visitStmt1R(Op.RETURN_OBJECT, 0);
            code.visitEnd();
            mv.visitEnd();
        }
        {
            DexMethodVisitor mv = dcv
                    .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, "proceed", new String[0], "Ljava/lang/Object;"));
            DexCodeVisitor code = mv.visitCode();
            code.visitRegister(4);


            code.visitFieldStmt(Op.IGET, 0, 3, new Field(typeNameDesc, "thiz", "Ljava/lang/Object;"));
            code.visitFieldStmt(Op.IGET, 1, 3, new Field(typeNameDesc, "args", "[Ljava/lang/Object;"));
            code.visitFieldStmt(Op.IGET, 2, 3, new Field(typeNameDesc, "idx", "I"));

            DexLabel labels[] = new DexLabel[callbacks.size()];
            for (int i = 0; i < labels.length; i++) {
                labels[i] = new DexLabel();
            }
            code.visitPackedSwitchStmt(Op.PACKED_SWITCH, 2, 0, labels);
            code.visitTypeStmt(Op.NEW_INSTANCE, 0, 0, "Ljava/lang/RuntimeException;");
            code.visitConstStmt(Op.CONST_STRING, 1, "invalid idx");
            code.visitMethodStmt(Op.INVOKE_DIRECT, new int[]{0,
                    1}, new Method("Ljava/lang/RuntimeException;", "<init>", new String[]{"Ljava/lang/String;"}, "V"));
            code.visitStmt1R(Op.THROW, 0);

            for (int i = 0; i < labels.length; i++) {
                code.visitLabel(labels[i]);
                Callback callback = callbacks.get(i);
                Method mCallback = (Method) callback.callback;
                if (callback.isStatic) {
                    code.visitMethodStmt(Op.INVOKE_STATIC, new int[]{1}, mCallback);
                } else if (callback.isSpecial) {
                    code.visitTypeStmt(Op.CHECK_CAST, 0, -1, mCallback.getOwner());
                    code.visitMethodStmt(Op.INVOKE_VIRTUAL, new int[]{0, 1}, mCallback);
                } else {
                    code.visitMethodStmt(Op.INVOKE_STATIC, new int[]{0, 1}, mCallback);
                }
                code.visitStmt1R(Op.MOVE_RESULT_OBJECT, 0);
                code.visitStmt1R(Op.RETURN_OBJECT, 0);
            }

            code.visitEnd();
            mv.visitEnd();
        }

        dcv.visitEnd();
        return typeName;
    }

    private void genSwitchMethod(DexClassVisitor dcv, String typeNameDesc, String methodName, CB callback) {
        DexMethodVisitor dmv = dcv
                .visitMethod(DexConstants.ACC_PUBLIC, new Method(typeNameDesc, methodName, new String[0], "Ljava/lang/String;"));
        DexCodeVisitor code = dmv.visitCode();
        code.visitRegister(3);
        code.visitFieldStmt(Op.IGET, 0, 2, new Field(typeNameDesc, "idx", "I"));

        DexLabel labels[] = new DexLabel[callbacks.size()];

        Map<String, DexLabel> strMap = new TreeMap<>();
        for (int i = 0; i < labels.length; i++) {
            Callback cb = callbacks.get(i);
            String key = callback.getKey((Method) cb.target);
            DexLabel label = strMap.get(key);
            if (label == null) {
                label = new DexLabel();
                strMap.put(key, label);
            }
            labels[i] = label;
        }
        code.visitPackedSwitchStmt(Op.PACKED_SWITCH, 0, 0, labels);
        code.visitTypeStmt(Op.NEW_INSTANCE, 0, 0, "Ljava/lang/RuntimeException;");
        code.visitConstStmt(Op.CONST_STRING, 1, "invalid idx");
        code.visitMethodStmt(Op.INVOKE_DIRECT, new int[]{0,
                1}, new Method("Ljava/lang/RuntimeException;", "<init>", new String[]{"Ljava/lang/String;"}, "V"));
        code.visitStmt1R(Op.THROW, 0);

        for (Map.Entry<String, DexLabel> e : strMap.entrySet()) {
            code.visitLabel(e.getValue());
            code.visitConstStmt(Op.CONST_STRING, 0, e.getKey());
            code.visitStmt1R(Op.RETURN_OBJECT, 0);
        }
        code.visitEnd();
        dmv.visitEnd();
    }

    public DexFileVisitor wrap(DexFileVisitor dcv) {
        return dcv == null ? null : new DexFileVisitor(dcv) {
            @Override
            public DexClassVisitor visit(int access_flags, String className, String superClass, String[] interfaceNames) {
                return wrap(className, super.visit(access_flags, className, superClass, interfaceNames));
            }
        };
    }

    public DexClassVisitor wrap(final String classNameDesc, final DexClassVisitor dcv) {

        return dcv == null ? null : new DexClassVisitor(dcv) {
            Map<MtdInfo, Method> cache = new HashMap<>();

            @Override
            public DexMethodVisitor visitMethod(final int accessFlags, Method method) {
                final DexMethodVisitor dmv = superVisitDexMethod(accessFlags, method);
                final MtdInfo mapTo = findDefinedTargetMethod(method.getOwner(), method.getName(), method.getDesc());
                if (mapTo != null) {
                    final Method t = new Method(
                            method.getOwner(), buildMethodAName(method.getName()), method.getParameterTypes(), method
                            .getReturnType()
                    );
                    final Method src = method;
                    return new DexMethodNode(accessFlags, method) {
                        @Override
                        public void visitEnd() {
                            super.visitEnd();
                            DexCodeNode code = this.codeNode;
                            this.codeNode = null;
                            accept(dmv);
                            Op opcode;
                            if (Modifier.isStatic(access)) {
                                opcode = Op.INVOKE_STATIC_RANGE;
                            } else {
                                opcode = Op.INVOKE_VIRTUAL_RANGE;
                            }
                            generateMtdACode(opcode, t, mapTo, dmv, src);

                            int newAccess = (access & ~(DexConstants.ACC_PRIVATE | DexConstants.ACC_PROTECTED)) | DexConstants.ACC_PUBLIC; // make sure public
                            code.accept(wrap(superVisitDexMethod(newAccess, t), dcv));
                        }
                    };
                } else {
                    return wrap(dmv, dcv);
                }
            }

            private DexMethodVisitor wrap(DexMethodVisitor dmv, final DexClassVisitor classVisitor) {
                return dmv == null ? null : new DexMethodVisitor(dmv) {
                    @Override
                    public DexCodeVisitor visitCode() {
                        return wrap(super.visitCode(), classVisitor);
                    }
                };
            }

            private DexCodeVisitor wrap(DexCodeVisitor dcv, final DexClassVisitor classVisitor) {
                return dcv == null ? null : new DexCodeVisitor(dcv) {
                    @Override
                    public void visitMethodStmt(Op op, int[] args, Method method) {
                        MtdInfo mapTo = findTargetMethod(method.getOwner(), method.getName(), method.getDesc());
                        if (mapTo != null) {

                            Method methodA = cache.get(buildKey(method.getOwner(), method.getName(), method.getDesc()));
                            if (methodA == null) {
                                if (isStatic(op)) {
                                    methodA = new Method(classNameDesc, buildMethodAName(method.getName()), method
                                            .getParameterTypes(), method.getReturnType());
                                } else {
                                    methodA = new Method(classNameDesc, buildMethodAName(method.getName()), join(method
                                            .getOwner(), method.getParameterTypes()), method.getReturnType());
                                }
                                DexMethodVisitor dmv = classVisitor
                                        .visitMethod(DexConstants.ACC_PRIVATE | DexConstants.ACC_STATIC, methodA);
                                generateMtdACode(op, method, mapTo, dmv, method);
                                dmv.visitEnd();
                                cache.put(buildKey(method.getOwner(), method.getName(), method.getDesc()), methodA);
                            }
                            super.visitMethodStmt(isRange(op) ? Op.INVOKE_STATIC_RANGE : Op.INVOKE_STATIC, args, methodA);
                        } else {
                            super.visitMethodStmt(op, args, method);
                        }
                    }
                };
            }

            private void generateMtdACode(Op opcode, Method t, MtdInfo mapTo, DexMethodVisitor dmv, Method src) {

                DexCodeVisitor dcv = dmv.visitCode();
                int countArge = countArgs(t);
                boolean haveThis = haveThis(opcode);

                int registers = 4 + (haveThis ? 1 : 0) + countArge;
                dcv.visitRegister(registers);
                int argStart = 4;
                if (haveThis) {
                    dcv.visitStmt2R(Op.MOVE_OBJECT, 0, argStart);
                    argStart++;
                } else {
                    dcv.visitConstStmt(Op.CONST_4, 0, 0);
                }
                if (t.getParameterTypes().length == 0) {
                    dcv.visitConstStmt(Op.CONST_4, 1, 0);
                } else {
                    dcv.visitConstStmt(Op.CONST, 1, t.getParameterTypes().length);
                    dcv.visitTypeStmt(Op.NEW_ARRAY, 1, 1, "[Ljava/lang/Object;");
                    for (int i = 0; i < t.getParameterTypes().length; i++) {
                        char type = t.getParameterTypes()[i].charAt(0);
                        dcv.visitConstStmt(Op.CONST, 2, i);
                        box(type, argStart, 3, dcv);
                        dcv.visitStmt3R(Op.APUT_OBJECT, 3, 1, 2);
                        if (type == 'J' || type == 'D') {
                            argStart += 2;
                        } else {
                            argStart += 1;
                        }
                    }
                }
                int nextIdx = callbacks.size();
                dcv.visitConstStmt(Op.CONST, 2, nextIdx);
                String miTypeDesc = "L" + getCurrentInvocationName() + ";";
                dcv.visitTypeStmt(Op.NEW_INSTANCE, 3, 0, miTypeDesc);
                dcv.visitMethodStmt(Op.INVOKE_DIRECT, new int[]{3, 0, 1,
                        2}, new Method(miTypeDesc, "<init>", new String[]{
                        "Ljava/lang/Object;", "[Ljava/lang/Object;", "I"
                }, "V"));
                Method call = build(mapTo);
                dcv.visitMethodStmt(Op.INVOKE_STATIC, new int[]{3}, call);
                if (!"V".equals(t.getReturnType())) {
                    switch (call.getReturnType().charAt(0)) {
                        case '[':
                        case 'L':
                            dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, 0);
                            break;
                        case 'J':
                        case 'D':
                            dcv.visitStmt1R(Op.MOVE_RESULT_WIDE, 0);
                            break;
                        default:
                            dcv.visitStmt1R(Op.MOVE_RESULT, 0);
                            break;
                    }
                    unbox(t.getReturnType(), 0, dcv);
                    switch (t.getReturnType().charAt(0)) {
                        case '[':
                        case 'L':
                            dcv.visitStmt1R(Op.RETURN_OBJECT, 0);
                            break;
                        case 'J':
                        case 'D':
                            dcv.visitStmt1R(Op.RETURN_WIDE, 0);
                            break;
                        default:
                            dcv.visitStmt1R(Op.RETURN, 0);
                            break;
                    }
                } else {
                    dcv.visitStmt0R(Op.RETURN_VOID);
                }

                Callback cb = new Callback();
                cb.idx = nextIdx;
                cb.callback = newMethodCallback(opcode, t);
                cb.target = src;
                cb.isSpecial = isSuper(opcode);
                cb.isStatic = isStatic(opcode);
                callbacks.add(cb);
            }

            private Method newMethodCallback(Op opcode, Method t) {
                boolean isStatic = !haveThis(opcode);
                boolean isSuper = isSuper(opcode);
                Method m;
                if (isSuper || isStatic) {
                    m = new Method(t.getOwner(), buildCallbackMethodName(t.getName()), new String[]{
                            "[Ljava/lang/Object;"
                    }, "Ljava/lang/Object;");
                } else {
                    m = new Method(t.getOwner(), buildCallbackMethodName(t.getName()), new String[]{
                            "Ljava/lang/Object;", "[Ljava/lang/Object;"
                    }, "Ljava/lang/Object;");
                }

                DexMethodVisitor dmv = superVisitDexMethod(
                        DexConstants.ACC_PUBLIC | (isSuper ? 0 : DexConstants.ACC_STATIC), m);
                DexCodeVisitor dcv = dmv.visitCode();
                int totalRegs;
                int argStart;
                if (isStatic) {
                    totalRegs = 1 + countArgs(t) + 1;
                    argStart = totalRegs - 1;
                } else {
                    totalRegs = 1 + countArgs(t) + 2;
                    argStart = totalRegs - 2;
                }
                dcv.visitRegister(totalRegs);
                int args[] = new int[countArgs(t) + (isStatic ? 0 : 1)];
                int args_index = 0;
                int i = 1;
                if (!isStatic) {
                    if (i != argStart) {
                        dcv.visitStmt2R(Op.MOVE_OBJECT, i, argStart);
                    }
                    if(!isSuper) {
                        dcv.visitTypeStmt(Op.CHECK_CAST, i, -1, t.getOwner());
                    }
                    args[args_index++] = i;
                    i++;
                    argStart++;
                }

                String[] parameterTypes = t.getParameterTypes();
                for (int i1 = 0; i1 < parameterTypes.length; i1++) {
                    String argType = parameterTypes[i1];
                    dcv.visitConstStmt(Op.CONST, 0, i1);
                    dcv.visitStmt3R(Op.AGET_OBJECT, i, argStart, 0);
                    unbox(argType, i, dcv);
                    args[args_index++] = i;
                    if (argType.charAt(0) == 'J' || argType.charAt(0) == 'D') {
                        args[args_index++] = i + 1;
                        i += 2;
                    } else {
                        i += 1;
                    }
                }

                dcv.visitMethodStmt(opcode, args, t);
                if ("V".equals(t.getReturnType())) {
                    dcv.visitConstStmt(Op.CONST, 0, 0);
                } else {
                    switch (t.getReturnType().charAt(0)) {
                        case '[':
                        case 'L':
                            dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, 0);
                            break;
                        case 'J':
                        case 'D':
                            dcv.visitStmt1R(Op.MOVE_RESULT_WIDE, 0);
                            break;
                        default:
                            dcv.visitStmt1R(Op.MOVE_RESULT, 0);
                            break;
                    }
                    box(t.getReturnType().charAt(0), 0, 0, dcv);
                }
                dcv.visitStmt1R(Op.RETURN_OBJECT, 0);

                return m;
            }

            private DexMethodVisitor superVisitDexMethod(int accessFlags, Method method) {
                return super.visitMethod(accessFlags, method);
            }
        };
    }

    private String[] join(String a, String[] b) {
        String joined[] = new String[b.length + 1];
        joined[0] = a;
        System.arraycopy(b, 0, joined, 1, b.length);
        return joined;
    }

    private boolean isStatic(Op op) {
        return op == Op.INVOKE_STATIC || op == Op.INVOKE_STATIC_RANGE;
    }

    private boolean isRange(Op op) {
        switch (op) {
            case INVOKE_STATIC_RANGE:
            case INVOKE_DIRECT_RANGE:
            case INVOKE_INTERFACE_RANGE:
            case INVOKE_SUPER_RANGE:
            case INVOKE_VIRTUAL_RANGE:
                return true;
            default:
                return false;
        }
    }

    private void unbox(String argType, int i, DexCodeVisitor dcv) {
        switch (argType.charAt(0)) {
            case '[':
            case 'L':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, argType);
                break;
            case 'Z':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, "Ljava/lang/Boolean;");
                dcv.visitMethodStmt(Op.INVOKE_VIRTUAL_RANGE, new int[]{
                        i}, new Method("Ljava/lang/Boolean;", "booleanValue", new String[]{}, "Z"));
                dcv.visitStmt1R(Op.MOVE_RESULT, i);
                break;
            case 'B':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, "Ljava/lang/Byte;");
                dcv.visitMethodStmt(Op.INVOKE_VIRTUAL_RANGE, new int[]{
                        i}, new Method("Ljava/lang/Byte;", "byteValue", new String[]{}, "B"));
                dcv.visitStmt1R(Op.MOVE_RESULT, i);
                break;
            case 'S':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, "Ljava/lang/Short;");
                dcv.visitMethodStmt(Op.INVOKE_VIRTUAL_RANGE, new int[]{
                        i}, new Method("Ljava/lang/Short;", "shortValue", new String[]{}, "S"));
                dcv.visitStmt1R(Op.MOVE_RESULT, i);
                break;
            case 'C':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, "Ljava/lang/Character;");
                dcv.visitMethodStmt(Op.INVOKE_VIRTUAL_RANGE, new int[]{
                        i}, new Method("Ljava/lang/Character;", "charValue", new String[]{}, "C"));
                dcv.visitStmt1R(Op.MOVE_RESULT, i);
                break;
            case 'I':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, "Ljava/lang/Integer;");
                dcv.visitMethodStmt(Op.INVOKE_VIRTUAL_RANGE, new int[]{
                        i}, new Method("Ljava/lang/Integer;", "intValue", new String[]{}, "I"));
                dcv.visitStmt1R(Op.MOVE_RESULT, i);
                break;
            case 'F':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, "Ljava/lang/Float;");
                dcv.visitMethodStmt(Op.INVOKE_VIRTUAL_RANGE, new int[]{
                        i}, new Method("Ljava/lang/Float;", "floatValue", new String[]{}, "F"));
                dcv.visitStmt1R(Op.MOVE_RESULT, i);
                break;
            case 'D':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, "Ljava/lang/Double;");
                dcv.visitMethodStmt(Op.INVOKE_VIRTUAL_RANGE, new int[]{
                        i}, new Method("Ljava/lang/Double;", "doubleValue", new String[]{}, "D"));
                dcv.visitStmt1R(Op.MOVE_RESULT_WIDE, i);
                break;
            case 'J':
                dcv.visitTypeStmt(Op.CHECK_CAST, i, i, "Ljava/lang/Long;");
                dcv.visitMethodStmt(Op.INVOKE_VIRTUAL_RANGE, new int[]{
                        i}, new Method("Ljava/lang/Long;", "longValue", new String[]{}, "J"));
                dcv.visitStmt1R(Op.MOVE_RESULT_WIDE, i);
                break;
        }
    }

    private boolean isSuper(Op opcode) {
        return opcode == Op.INVOKE_SUPER || opcode == Op.INVOKE_SUPER_RANGE;
    }

    private Method build(MtdInfo mapTo) {
        Type[] ts = Type.getArgumentTypes(mapTo.desc);
        String ss[] = new String[ts.length];
        for (int i = 0; i < ss.length; i++) {
            ss[i] = ts[i].getDescriptor();
        }
        return new Method(mapTo.owner, mapTo.name, ss, Type.getReturnType(mapTo.desc).getDescriptor());
    }

    private void box(char type, int from, int to, DexCodeVisitor dcv) {
        switch (type) {
            case 'L':
            case '[':
                dcv.visitStmt2R(Op.MOVE_OBJECT, from, to);
                break;
            case 'Z':
                dcv.visitMethodStmt(Op.INVOKE_STATIC_RANGE, new int[]{
                        from}, new Method("Ljava/lang/Boolean;", "valueOf", new String[]{"Z"}, "Ljava/lang/Boolean;"));
                dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, to);
                break;
            case 'B':
                dcv.visitMethodStmt(Op.INVOKE_STATIC_RANGE, new int[]{
                        from}, new Method("Ljava/lang/Byte;", "valueOf", new String[]{"B"}, "Ljava/lang/Byte;"));
                dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, to);
                break;
            case 'S':
                dcv.visitMethodStmt(Op.INVOKE_STATIC_RANGE, new int[]{
                        from}, new Method("Ljava/lang/Short;", "valueOf", new String[]{"S"}, "Ljava/lang/Short;"));
                dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, to);
                break;
            case 'C':
                dcv.visitMethodStmt(Op.INVOKE_STATIC_RANGE, new int[]{
                        from}, new Method("Ljava/lang/Character;", "valueOf", new String[]{
                        "C"}, "Ljava/lang/Character;"));
                dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, to);
                break;
            case 'I':
                dcv.visitMethodStmt(Op.INVOKE_STATIC_RANGE, new int[]{
                        from}, new Method("Ljava/lang/Integer;", "valueOf", new String[]{"I"}, "Ljava/lang/Integer;"));
                dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, to);
                break;
            case 'F':
                dcv.visitMethodStmt(Op.INVOKE_STATIC_RANGE, new int[]{
                        from}, new Method("Ljava/lang/Float;", "valueOf", new String[]{"F"}, "Ljava/lang/Float;"));
                dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, to);
                break;
            case 'D':
                dcv.visitMethodStmt(Op.INVOKE_STATIC_RANGE, new int[]{
                        from, from + 1}, new Method("Ljava/lang/Double;", "valueOf", new String[]{
                        "D"}, "Ljava/lang/Double;"));
                dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, to);
                break;
            case 'J':
                dcv.visitMethodStmt(Op.INVOKE_STATIC_RANGE, new int[]{
                        from, from + 1}, new Method("Ljava/lang/Long;", "valueOf", new String[]{
                        "J"}, "Ljava/lang/Long;"));
                dcv.visitStmt1R(Op.MOVE_RESULT_OBJECT, to);
                break;
        }
    }

    private boolean haveThis(Op opcode) {
        return opcode != Op.INVOKE_STATIC && opcode != Op.INVOKE_STATIC_RANGE;
    }

    static int countArgs(Method t) {
        int i = 0;
        for (String arg : t.getParameterTypes()) {
            char type = arg.charAt(0);
            if (type == 'J' || type == 'D') {
                i += 2;
            } else {
                i += 1;
            }
        }
        return i;
    }


}

```

`dex-tools/src/main/java/com/googlecode/d2j/tools/jar/InitOut.java`:

```java
package com.googlecode.d2j.tools.jar;

import com.googlecode.dex2jar.tools.BaseCmd;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

import static com.googlecode.d2j.util.AccUtils.*;
import static org.objectweb.asm.Opcodes.*;

public class InitOut {
    private static final Set<String> keywords = new HashSet<String>(Arrays.asList("abstract", "continue", "for", "new",
            "switch", "assert", "default", "goto", "package", "synchronized", "boolean", "do", "if", "private", "this",
            "break", "double", "implements", "protected", "throw", "byte", "else", "import", "public", "throws",
            "case", "enum", "instanceof", "return", "transient", "catch", "extends", "int", "short", "try", "char",
            "final", "interface", "static", "void", "class", "finally", "long", "strictfp", "volatile", "const",
            "float", "native", "super", "while"));
    private int clzIndex = 0;
    private Set<String> clzMap = new TreeSet<>();
    private Set<String> clzSet = new TreeSet<>();
    private Path from;
    private int maxLength = 40;
    private Set<String> memberMap = new TreeSet<>();
    private int minLength = 2;
    private int pkgIndex = 0;
    private Set<String> pkgMap = new TreeSet<>();
    private Set<String> pkgSet = new TreeSet<>();
    private boolean initEnumNames = false;
    private boolean initSourceNames = false;
    private boolean initAssertionNames = false;

    public InitOut initEnumNames() {
        this.initEnumNames = true;
        return this;
    }

    public InitOut initSourceNames() {
        this.initSourceNames = true;
        return this;
    }

    public InitOut initAssertionNames() {
        this.initAssertionNames = true;
        return this;
    }

    private void doClass0(String clz) {
        if (clzSet.contains(clz)) {
            return;
        }
        clzSet.add(clz);

        int index = clz.lastIndexOf('$');
        if (index > 0) {
            doClass0(clz.substring(0, index));
            String cName = clz.substring(index + 1);
            try {
                Integer.parseInt(cName);
            } catch (Exception ex) {
                if (shouldRename(cName)) {
                    clzMap.add(String.format("c %s=CI%03d%s", clz, clzIndex++, short4LongName(cName)));
                }
            }
        } else {
            index = clz.lastIndexOf('/');
            if (index > 0) {
                doPkg(clz.substring(0, index));
                String cName = clz.substring(index + 1);
                if (shouldRename(cName)) {
                    clzMap.add(String.format("c %s=C%03d%s", clz, clzIndex++, short4LongName(cName)));
                }
            } else {
                if (shouldRename(clz)) {
                    clzMap.add(String.format("c %s=CI_%03d%s", clz, clzIndex++, short4LongName(clz)));
                }
            }
        }
    }

    private String short4LongName(String name) {
        if (name.length() > maxLength) {
            return "x" + Integer.toHexString(name.hashCode());
        } else {
            return name;
        }
    }

    private void doMember(String owner, MemberInfo member, final int x) {
        // TODO use suggested name
        if (x > 0 || shouldRename(member.name)) {
            if (member.desc.indexOf('(') >= 0) {
                StringBuilder sb = new StringBuilder();
                sb.append(isStatic(member.access) ? "M" : "m");
                if (isPrivate(member.access)) {
                    sb.append("p");
                } else if (isPublic(member.access)) {
                    sb.append("P");
                }
                if (x > 0) {
                    sb.append(x);
                }
                sb.append(short4LongName(member.name));
                if (x > 0) {
                    memberMap.add("m " + owner + "." + member.name + member.desc + "=" + sb);
                } else {
                    memberMap.add("m " + owner + "." + member.name
                            + member.desc.substring(0, member.desc.indexOf(')') + 1) + "=" + sb);
                }
            } else {
                StringBuilder sb = new StringBuilder();
                sb.append(isStatic(member.access) ? "F" : "f");
                if (isPrivate(member.access)) {
                    sb.append("p");
                } else if (isPublic(member.access)) {
                    sb.append("P");
                }
                if (x > 0) {
                    sb.append(x);
                }
                sb.append(short4LongName(member.name));
                if (x > 0) {
                    memberMap.add("m " + owner + "." + member.name + "[" + member.desc + "]" + "=" + sb);
                } else {
                    memberMap.add("m " + owner + "." + member.name + "=" + sb);
                }
            }
        }
    }

    private List<ClassInfo> collect(Path file) throws IOException {
        final List<ClassInfo> clzList = new ArrayList<>();
        final ClassVisitor collectVisitor = new ClassVisitor(Opcodes.ASM9) {
            private static final String ASSERTION_DISABLED_FIELD_NAME = "$assertionsDisabled";
            private static final String ENUM_VALUES_FIELD_NAME = "ENUM$VALUES";
            ClassInfo clz;
            boolean isEnum = false;
            Map<String, String> enumFieldMap = new HashMap<>();

            @Override
            public void visitSource(String source, String debug) {
                if (initSourceNames && !clz.name.contains("$") && source.endsWith(".java")) {
                    clz.suggestName = source.substring(0, source.length() - 5);
                }
            }

            @Override
            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
                clz.addMethod(access, name, desc);
                if (initEnumNames && isEnum && name.equals("<clinit>")) {
                    final String thisDesc = "L" + clz.name + ";";
                    return new MethodNode(ASM9, access, name, desc, signature, exceptions) {
                        @Override
                        public void visitEnd() {
                            if (this.instructions != null) {
                                int status = 0;
                                String eFieldName = null;
                                for (AbstractInsnNode p = this.instructions.getFirst(); p != null; p = p.getNext()) {
                                    //looking for  NEW,DUP,LDC,PUTSTATUS

                                    if (status == 0) {  // init
                                        if (p.getOpcode() == NEW) {
                                            TypeInsnNode ti = (TypeInsnNode) p;
                                            if (thisDesc.equals(ti.desc)) {
                                                status = 1;
                                            }
                                        }
                                    } else if (status == 1) {  // find NEW
                                        if (p.getOpcode() == DUP) {
                                            status = 2;
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 2) {  //find DUP
                                        if (p.getOpcode() == LDC) {
                                            LdcInsnNode ldc = (LdcInsnNode) p;
                                            if (ldc.cst instanceof String) {
                                                eFieldName = (String) ldc.cst;
                                                status = 3;
                                            } else {
                                                status = 0;
                                            }
                                        } else {
                                            status = 0;
                                        }
                                    } else if (status == 3) {  //find LDC
                                        if (p.getOpcode() == PUTSTATIC) {
                                            FieldInsnNode fin = (FieldInsnNode) p;
                                            if (fin.owner.equals(thisDesc) && fin.desc.equals(thisDesc)) {
                                                if (!fin.name.equals(eFieldName)) {
                                                    enumFieldMap.put(fin.name, eFieldName);
                                                }
                                                eFieldName = null;
                                                status = 0;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                }
                return null;
            }

            @Override
            public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
                MemberInfo mi = clz.addField(access, name, desc);
                if (initEnumNames && isEnum
                        && isPrivate(access) && isFinal(access) && isSynthetic(access)
                        && !ENUM_VALUES_FIELD_NAME.equals(name)
                        && ("[L" + clz.name + ";").equals(desc)) {
                    mi.suggestName = ENUM_VALUES_FIELD_NAME;
                }
                if (initAssertionNames && isSynthetic(access) && isStatic(access)
                        && !isPrivate(access) && !isPublic(access) && !isProtected(access)
                        && desc.equals("Z") && !ASSERTION_DISABLED_FIELD_NAME.equals(name)) {
                    mi.suggestName = ASSERTION_DISABLED_FIELD_NAME;
                }

                return null;
            }

            @Override
            public void visitEnd() {
                if (initEnumNames) {
                    final String thisDesc = "L" + clz.name + ";";
                    for (Map.Entry<String, String> e : enumFieldMap.entrySet()) {
                        String name = e.getKey();
                        String suggestName = e.getValue();
                        for (MemberInfo mi : clz.fields) {
                            if (isFinal(mi.access) && isStatic(mi.access)
                                    && mi.name.equals(name) && mi.desc.equals(thisDesc)) {
                                mi.suggestName = suggestName;
                            }
                        }
                    }
                }
                clzList.add(clz);
                clz = null;
                isEnum = false;
                enumFieldMap.clear();
            }

            @Override
            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
                this.clz = new ClassInfo(name);
                isEnum = isEnum(access);
            }
        };

      try(FileSystem fs = BaseCmd.openZip(file)) {
          BaseCmd.walkJarOrDir(fs.getPath("/"), (file1, relative) -> {
              if (relative.endsWith(".class")) {
                  byte[] data = Files.readAllBytes(file1);
                  new ClassReader(data).accept(collectVisitor, ClassReader.EXPAND_FRAMES);
              }
          });
      }
        return clzList;
    }

    private void doPkg(String pkg) {
        if (pkgSet.contains(pkg)) {
            return;
        }
        pkgSet.add(pkg);
        int index = pkg.lastIndexOf('/');
        if (index > 0) {
            doPkg(pkg.substring(0, index));
            String cName = pkg.substring(index + 1);
            if (shouldRename(cName)) {
                pkgMap.add(String.format("p %s=p%02d%s", pkg, pkgIndex++, short4LongName(cName)));
            }
        } else {
            if (shouldRename(pkg)) {
                pkgMap.add(String.format("p %s=p%02d%s", pkg, pkgIndex++, short4LongName(pkg)));
            }
        }
    }

    public InitOut from(Path from) {
        this.from = from;
        return this;
    }

    public InitOut maxLength(int m) {
        this.maxLength = m;
        return this;
    }

    public InitOut minLength(int m) {
        this.minLength = m;
        return this;
    }

    private boolean shouldRename(String s) {
        return s.length() > maxLength || s.length() < minLength || keywords.contains(s);
    }

    public void to(Path config) throws IOException {
        List<ClassInfo> classInfoList = collect(from);
        transform(classInfoList);
        List<String> list = new ArrayList<>();
        list.addAll(pkgMap);
        list.addAll(clzMap);
        list.addAll(memberMap);
        Files.write(config,list, StandardCharsets.UTF_8);
    }

    private void transformerMember(String owner, List<MemberInfo> members) {
        Iterator<MemberInfo> it = members.iterator();
        if (it.hasNext()) {
            MemberInfo current = it.next();
            while (true) {
                if (it.hasNext()) {
                    MemberInfo next = it.next();
                    if (current.name.equals(next.name)) {
                        int x = 1;
                        doMember(owner, current, x++);
                        doMember(owner, next, x++);
                        while (it.hasNext()) {
                            next = it.next();
                            if (current.name.equals(next.name)) {
                                doMember(owner, next, x++);
                            } else {
                                current = next;
                                break;
                            }
                        }
                    } else {
                        doMember(owner, current, 0);
                        current = next;
                    }
                } else {
                    doMember(owner, current, 0);
                    break;
                }
            }
        }
    }

    private void transform(List<ClassInfo> classInfoList) {
        MemberInfoComparator comparator = new MemberInfoComparator();
        for (ClassInfo ci : classInfoList) {
            doClass0(ci.name);
            ci.fields.sort(comparator);
            transformerMember(ci.name, ci.fields);
            ci.methods.sort(comparator);
            transformerMember(ci.name, ci.methods);
        }

    }

    static private class ClassInfo {

        final public String name;
        public List<MemberInfo> fields = new ArrayList<>(5);
        public List<MemberInfo> methods = new ArrayList<>(5);
        public String suggestName;

        public ClassInfo(String name) {
            this.name = name;
        }

        public MemberInfo addField(int access, String name, String type) {
            MemberInfo mi = new MemberInfo(access, name, type);
            fields.add(mi);
            return mi;
        }

        public MemberInfo addMethod(int access, String name, String desc) {
            MemberInfo mi = new MemberInfo(access, name, desc);
            methods.add(mi);
            return mi;
        }

        public String toString() {
            return name;
        }
    }

    private static class MemberInfo {
        public int access;
        public String desc;
        public String name;
        public String suggestName;

        public MemberInfo(int access, String name, String desc) {
            this.name = name;
            this.access = access;
            this.desc = desc;
        }
    }

    private static class MemberInfoComparator implements Comparator<MemberInfo> {
        @Override
        public int compare(MemberInfo memberInfo, MemberInfo memberInfo2) {
            int x = memberInfo.name.compareTo(memberInfo2.name);
            if (x != 0) {
                return x;
            }
            return memberInfo.desc.compareTo(memberInfo2.desc);
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/d2j/tools/jar/InvocationWeaver.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2015 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.tools.jar;

import com.googlecode.dex2jar.tools.BaseCmd;

import org.objectweb.asm.*;
import org.objectweb.asm.commons.ClassRemapper;
import org.objectweb.asm.commons.Remapper;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LocalVariableNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TryCatchBlockNode;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Modifier;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.jar.Attributes.Name;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

/**
 * 1. Replace class A to another class B, include superclass, new for
 * <p/>
 * <pre>
 *     class Test1 extends A ...
 *     class Test2 implements A ...
 *     void amethod(A a) ...
 * </pre>
 * <p/>
 * after
 * <p/>
 * <pre>
 *     class Test1 extends B ...
 *     class Test2 extends B ...
 *     void amethod(B a) ...
 * </pre>
 * <p/>
 * 2. Replace method A to another method B, method B must be public static, and in either 'public static RET b(ARGs)' or
 * 'public RET b(Invocation inv)' RET: same return type with method A or Object ARGs: if method A is static, ARGs is
 * same with method A, if method A is non-static the ARGs is 'thiz, arguments in methodA'
 * <p/>
 * <pre>
 * public int a() {
 *     Test t = new Test();
 *     return t.test(1, 2);
 * }
 * </pre>
 * <p/>
 * after
 * <p/>
 * <pre>
 *     // direct replace
 *     public int a(){
 *         Test t=new Test();
 *         return B(t,1,2);
 *     }
 *     // or by MethodInvocation
 *     public int a(){
 *         Test t=new Test();
 *         return test_$$$_A_(t,1,2)
 *     }
 *     // the replaced invoke method
 *     public static int test$$$_A_(Test t, int a, int b){
 *         MethodInvocation i=new MethodInvocation(t, new Object[]{a.b})
 *         return B(i).intValue();
 *     }
 *     // the callback if MethodInvocation.proceed() is invoked
 *     public static Object test$$$$_callback(Test t, Object[]args) {
 *        return box(t.test(args[0].intValue(),args[1].intValue()));
 *     }
 * </pre>
 * <p/>
 * 3. Replace Methods Implementations
 * <p/>
 * <pre>
 * public int test() {
 *         ...
 * }
 * </pre>
 * <p/>
 * after
 * <p/>
 * <pre>
 *     public int test(){
 *          MethodInvocation i=new MethodInvocation(t, new Object[]{a.b})
 *          return B(i).intValue();
 *     }
 *     public int org_test(){
 *         ...
 *     }
 * </pre>
 */
public class InvocationWeaver extends BaseWeaver implements Opcodes {
    private static final Type OBJECT_TYPE = Type.getType(Object.class);
    private final Remapper remapper = new Remapper() {

        @Override
        public String mapDesc(String desc) {
            if (desc.length() == 1) {
                return desc;
            }
            String nDesc = clzDescMap.get(desc);
            return nDesc == null ? desc : nDesc;
        }
    };

    static private void box(Type arg, MethodVisitor mv) {
        switch (arg.getSort()) {
            case Type.OBJECT:
            case Type.ARRAY:
                return;
            case Type.INT:
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
                break;
            case Type.LONG:
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;", false);
                break;
            case Type.FLOAT:
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Floag", "valueOf", "(F)Ljava/lang/Floag;", false);
                break;
            case Type.DOUBLE:
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double;", false);
                break;
            case Type.SHORT:
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short;", false);
                break;
            case Type.CHAR:
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character;", false);
                break;
            case Type.BOOLEAN:
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;", false);
                break;
            case Type.BYTE:
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte;", false);
                break;
            case Type.VOID:
                mv.visitInsn(ACONST_NULL);
                break;
        }
    }

    static private void unBox(Type orgRet, Type nRet, MethodVisitor mv) {
        if (orgRet.equals(nRet)) {
            return;
        }
        if (orgRet.getSort() == Type.VOID) {
            mv.visitInsn(nRet.getSize() == 1 ? POP : POP2);
        }
        if (nRet.getSort() != Type.OBJECT) {
            throw new RuntimeException("invalid ret type:" + nRet);
        }
        switch (orgRet.getSort()) {
            case Type.OBJECT:
            case Type.ARRAY:
                mv.visitTypeInsn(CHECKCAST, orgRet.getInternalName());
                break;
            case Type.INT:
                mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false);
                break;
            case Type.FLOAT:
                mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false);
                break;
            case Type.LONG:
                mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false);
                break;
            case Type.DOUBLE:
                mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false);
                break;
            case Type.BYTE:
                mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "byteValue", "()B", false);
                break;
            case Type.SHORT:
                mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "shortValue", "()S", false);
                break;
            case Type.CHAR:
                mv.visitTypeInsn(CHECKCAST, "java/lang/Character");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false);
                break;
            case Type.BOOLEAN:
                mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false);
                break;
        }
    }

    public byte[] wave0(byte[] data) {
        final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        wave0(data, cw);
        return cw.toByteArray();
    }

    public void wave0(byte[] data, final ClassVisitor cv) {
        new ClassReader(data).accept(wrapper(cv), ClassReader.EXPAND_FRAMES);
    }

    public ClassVisitor wrapper(final ClassVisitor cv) {
        return new ClassRemapper(cv, remapper) {
            final Map<MtdInfo, MtdInfo> toCreate = new HashMap<>();
            String clzName;

            private MtdInfo newMethodA(int opcode, MtdInfo t, MtdInfo mapTo) {
                MtdInfo n = toCreate.get(t);
                if (n != null) {
                    return n;
                }
                n = new MtdInfo();
                n.owner = t.owner;
                n.name = buildMethodAName(t.name);
                boolean hasThis = opcode != INVOKESTATIC;

                if (hasThis) {
                    Type[] args = Type.getArgumentTypes(t.desc);
                    Type ret = Type.getReturnType(t.desc);
                    List<Type> ts = new ArrayList<>(args.length + 1);
                    ts.add(Type.getType(t.owner));
                    ts.addAll(Arrays.asList(args));
                    n.desc = Type.getMethodDescriptor(ret, ts.toArray(new Type[0]));
                } else {
                    n.desc = t.desc;
                }

                toCreate.put(t, n);
                MethodVisitor mv = cv.visitMethod(ACC_SYNTHETIC | ACC_PRIVATE | ACC_STATIC, n.name, n.desc, null, null);
                mv.visitCode();
                genMethodACode(opcode, t, mapTo, mv, t);

                return n;
            }

            private void genMethodACode(int opcode, MtdInfo t, MtdInfo mapTo, MethodVisitor mv, MtdInfo src) {
                boolean hasThis = opcode != INVOKESTATIC;
                Type[] args = Type.getArgumentTypes(t.desc);
                Type ret = Type.getReturnType(t.desc);


                final int start;
                mv.visitTypeInsn(NEW, getCurrentInvocationName());
                mv.visitInsn(DUP);
                if (hasThis) {
                    mv.visitVarInsn(ALOAD, 0);
                    start = 1;
                } else {
                    mv.visitInsn(ACONST_NULL);
                    start = 0;
                }
                if (args.length == 0) {
                    mv.visitInsn(ACONST_NULL);
                } else {
                    mv.visitLdcInsn(args.length);
                    mv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
                    for (int i = 0; i < args.length; i++) {
                        mv.visitInsn(DUP);
                        mv.visitLdcInsn(i);
                        mv.visitVarInsn(args[i].getOpcode(ILOAD), i + start);
                        box(args[i], mv);
                        mv.visitInsn(AASTORE);
                    }
                }
                int nextIdx = callbacks.size();
                mv.visitLdcInsn(nextIdx);
                mv.visitMethodInsn(INVOKESPECIAL, getCurrentInvocationName(), "<init>",
                        "(Ljava/lang/Object;[Ljava/lang/Object;I)V", false);

                mv.visitMethodInsn(INVOKESTATIC, toInternal(mapTo.owner), mapTo.name, mapTo.desc, false);
                unBox(ret, Type.getReturnType(mapTo.desc), mv);
                mv.visitInsn(ret.getOpcode(IRETURN));
                mv.visitMaxs(-1, -1);
                mv.visitEnd();

                Callback cb = new Callback();
                cb.idx = nextIdx;
                cb.callback = newMethodCallback(opcode, t);
                cb.target = src;
                cb.isSpecial = opcode == INVOKESPECIAL;
                cb.isStatic = opcode == INVOKESTATIC;
                callbacks.add(cb);
            }

            private MtdInfo newMethodCallback(int opcode, MtdInfo t) {
                MtdInfo n = new MtdInfo();
                n.owner = "L" + className + ";";
                n.name = buildCallbackMethodName(t.name) ;
                if (opcode == INVOKESPECIAL || opcode == INVOKESTATIC) {
                    n.desc = "([Ljava/lang/Object;)Ljava/lang/Object;";
                } else {
                    n.desc = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
                }
                MethodVisitor mv = cv.visitMethod(opcode == INVOKESPECIAL ? ACC_PUBLIC : ACC_PUBLIC
                        | ACC_STATIC, n.name, n.desc, null, null);
                mv.visitCode();
                int start;
                if (opcode != INVOKESTATIC) {
                    mv.visitVarInsn(ALOAD, 0);
                    if (opcode != INVOKESPECIAL) {
                        mv.visitTypeInsn(CHECKCAST, toInternal(t.owner));
                    }
                    start = 1;
                } else {
                    start = 0;
                }
                Type[] args = Type.getArgumentTypes(t.desc);

                for (int i = 0; i < args.length; i++) {
                    mv.visitVarInsn(ALOAD, start);
                    mv.visitLdcInsn(i);
                    mv.visitInsn(AALOAD);
                    unBox(args[i], OBJECT_TYPE, mv);
                }
                mv.visitMethodInsn(opcode, toInternal(t.owner), t.name, t.desc, opcode == INVOKEINTERFACE);
                Type ret = Type.getReturnType(t.desc);
                box(ret, mv);
                mv.visitInsn(ARETURN);
                mv.visitMaxs(-1, -1);
                mv.visitEnd();
                return n;
            }

            @Override
            public void visit(int version, int access, String name, String signature, String superName,
                              String[] interfaces) {
                super.visit(version, access, name, signature, superName, interfaces);
                clzName = name;
            }

            public MethodVisitor visitMethod(int access, final String name, String desc, String signature,
                                             String[] exceptions) {

                final MethodVisitor superMv = superMethodVisitor(access, name, desc, signature, exceptions);
                final MtdInfo mapTo = findDefinedTargetMethod("L" + clzName + ";", name, desc);
                if (mapTo != null) {
                    final MtdInfo t1 = new MtdInfo();
                    t1.owner = "L" + clzName + ";";
                    t1.name = buildMethodAName(name) ;
                    t1.desc = desc;
                    final MtdInfo src = new MtdInfo();
                    src.owner = t1.owner;
                    src.name = name;
                    src.desc = desc;
                    return new MethodNode(ASM9, access, name, desc, signature, exceptions) {
                        @Override
                        public void visitEnd() {

                            InsnList instructions = this.instructions;
                            List<TryCatchBlockNode> tryCatchBlocks = this.tryCatchBlocks;
                            List<LocalVariableNode> localVariables = this.localVariables;

                            this.instructions = new InsnList();
                            this.tryCatchBlocks = new ArrayList<>();
                            this.localVariables = new ArrayList<>();
                            this.maxLocals = -1;
                            this.maxStack = -1;
                            accept(superMv);
                            int opcode;
                            if (Modifier.isStatic(access)) {
                                opcode = Opcodes.INVOKESTATIC;
                            } else {
                                opcode = Opcodes.INVOKEVIRTUAL;
                            }
                            genMethodACode(opcode, t1, mapTo, superMv, src);

                            int newAccess = (access & ~(ACC_PRIVATE | ACC_PROTECTED)) | ACC_PUBLIC; // make sure public
                            MethodVisitor rmv = wrap(superMethodVisitor(newAccess, t1.name, desc, null, null));
                            if(rmv!=null) {
                                rmv.visitCode();
                                int n, i;
                                n = tryCatchBlocks == null ? 0 : tryCatchBlocks.size();

                                for (i = 0; i < n; ++i) {
                                    tryCatchBlocks.get(i).accept(rmv);
                                }
                                instructions.accept(rmv);
                                n = localVariables == null ? 0 : localVariables.size();

                                for (i = 0; i < n; ++i) {
                                    localVariables.get(i).accept(rmv);
                                }
                                rmv.visitMaxs(-1, -1);
                                rmv.visitEnd();
                            }
                        }
                    };
                } else {
                    return wrap(superMv);
                }
            }

            private MethodVisitor superMethodVisitor(int access, String name, String desc, String signature, String[] exceptions) {
                return super.visitMethod(access, name, desc, signature, exceptions);
            }

            MethodVisitor wrap(MethodVisitor mv){
                return  mv==null?null: new ReplaceMethodVisitor(mv);
            }
            class ReplaceMethodVisitor extends MethodVisitor {
                public ReplaceMethodVisitor(MethodVisitor mv) {
                    super(ASM9, mv);
                }

                @Override
                public void visitMethodInsn(int opcode, String owner, String name, String desc,
                                            boolean isInterface) {
                    MtdInfo mapTo = findTargetMethod("L" + owner + ";", name, desc);
                    if (mapTo != null) {
                        boolean isStatic = opcode == INVOKESTATIC;
                        Type orgRet = Type.getReturnType(desc);
                        Type[] orgArgs = Type.getArgumentTypes(desc);
                        Type nRet = Type.getReturnType(mapTo.desc);
                        Type[] nArgs = Type.getArgumentTypes(mapTo.desc);
                        if (orgRet.getSort() != Type.VOID && nRet.getSort() == Type.VOID) {
                            throw new RuntimeException("can't cast " + nRet + " to " + orgRet);
                        }

                        if (nArgs.length == 1 && nArgs[0].getDescriptor().equals(invocationInterfaceDesc)) {
                            MtdInfo t = new MtdInfo();
                            t.owner = "L" + owner + ";";
                            t.name = name;
                            t.desc = desc;
                            MtdInfo n = newMethodA(opcode, t, mapTo);
                            super.visitMethodInsn(INVOKESTATIC, clzName, n.name, n.desc, isInterface);
                        } else { // simple replace
                            // checking for invalid replace
                            if (isStatic) {
                                if (!Arrays.deepEquals(orgArgs, nArgs)) {
                                    throw new RuntimeException("arguments not equal: " + owner + "." + name + desc
                                            + " <> " + mapTo.owner + "." + mapTo.name + mapTo.desc);
                                }
                            } else {
                                if (nArgs.length != orgArgs.length + 1) {
                                    throw new RuntimeException("arguments not equal: " + owner + "." + name + desc
                                            + " <> " + mapTo.owner + "." + mapTo.name + mapTo.desc);
                                }
                                if (orgArgs.length > 0) {
                                    for (int i = 0; i < orgArgs.length; i++) {
                                        if (!orgArgs[i].equals(nArgs[i + 1])) {
                                            throw new RuntimeException("arguments not equal: " + owner + "." + name
                                                    + desc + " <> " + mapTo.owner + "." + mapTo.name + mapTo.desc);
                                        }
                                    }
                                }
                            }
                            // replace it!
                            super.visitMethodInsn(INVOKESTATIC, toInternal(mapTo.owner), mapTo.name, mapTo.desc, isInterface);
                            unBox(orgRet, nRet, this.mv);
                        }

                    } else {
                        super.visitMethodInsn(opcode, owner, name, desc, isInterface);
                    }
                }

                @Override
                public void visitMethodInsn(int opcode, String owner, String name, String desc) {
                    visitMethodInsn(opcode, owner, name, desc, opcode == INVOKEINTERFACE);
                }
            }

        };
    }

    public void wave(Path from, final Path to) throws IOException {

        BaseCmd.walkJarOrDir(from, (file, relative) -> {
            Path targetPath = to.resolve(relative);
            BaseCmd.createParentDirectories(targetPath);
            if (relative.endsWith(".class")) {
                String clzName = relative.substring(0, relative.length() - ".class".length());
                if (ignores.contains(clzName)) {
                    Files.copy(file, targetPath);
                } else {
                    byte[] out = wave0(Files.readAllBytes(file));
                    Files.write(targetPath, out);
                }
            } else {
                if (relative.startsWith("META-INF/")) {
                    if (relative.equals(JarFile.MANIFEST_NAME)) {
                        try (InputStream in = Files.newInputStream(file)) {
                            Manifest mf = new Manifest(in);
                            mf.getMainAttributes().put(new Name("X-NOTICE"), "Modified");
                            mf.getEntries().clear();

                            ByteArrayOutputStream baos = new ByteArrayOutputStream();
                            mf.write(baos);
                            baos.flush();
                            Files.write(targetPath, baos.toByteArray());
                        }
                    } else if (relative.endsWith(".DSA") || relative.endsWith(".RSA") || relative.endsWith(".SF")
                            || relative.endsWith(".ECDSA")) {
                        // ignored
                    } else {
                        Files.copy(file, targetPath);
                    }
                } else {
                    Files.copy(file, targetPath);
                }
            }
        });

        if (callbacks.size() > 0) {
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
            String type = buildInvocationClz(cw);
            byte[] data = cw.toByteArray();
            Path target = to.resolve(type + ".class");
            BaseCmd.createParentDirectories(target);
            Files.write(target, data);
            nextInvocationName();
        }

    }

    public String buildInvocationClz(ClassVisitor cw) {
        String typeName = getCurrentInvocationName();
        cw.visit(V1_6, ACC_PUBLIC, typeName, null, "java/lang/Object", new String[]{
                toInternal(invocationInterfaceDesc)});
        cw.visitField(ACC_PRIVATE | ACC_FINAL, "thiz", "Ljava/lang/Object;", null, null).visitEnd();
        cw.visitField(ACC_PRIVATE | ACC_FINAL, "args", "[Ljava/lang/Object;", null, null).visitEnd();
        cw.visitField(ACC_PRIVATE | ACC_FINAL, "idx", "I", null, null).visitEnd();
        {
            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "(Ljava/lang/Object;[Ljava/lang/Object;I)V", null,
                    null);
            mv.visitCode();
            mv.visitVarInsn(ALOAD, 0);
            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
            mv.visitVarInsn(ALOAD, 0);
            mv.visitVarInsn(ALOAD, 1);
            mv.visitFieldInsn(PUTFIELD, typeName, "thiz", "Ljava/lang/Object;");
            mv.visitVarInsn(ALOAD, 0);
            mv.visitVarInsn(ALOAD, 2);
            mv.visitFieldInsn(PUTFIELD, typeName, "args", "[Ljava/lang/Object;");
            mv.visitVarInsn(ALOAD, 0);
            mv.visitVarInsn(ILOAD, 3);
            mv.visitFieldInsn(PUTFIELD, typeName, "idx", "I");
            mv.visitInsn(RETURN);
            mv.visitMaxs(-1, -1);
            mv.visitEnd();
        }
        {
            genSwitchMethod(cw, typeName, "getMethodOwner", mtd -> toInternal(mtd.owner));
            genSwitchMethod(cw, typeName, "getMethodName", mtd -> mtd.name);
            genSwitchMethod(cw, typeName, "getMethodDesc", mtd -> mtd.desc);
        }
        {
            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "getArguments", "()[Ljava/lang/Object;", null, null);
            mv.visitCode();
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, typeName, "args", "[Ljava/lang/Object;");
            mv.visitInsn(ARETURN);
            mv.visitMaxs(-1, -1);
            mv.visitEnd();
        }

        {
            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "getThis", "()Ljava/lang/Object;", null, null);
            mv.visitCode();
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, typeName, "thiz", "Ljava/lang/Object;");
            mv.visitInsn(ARETURN);
            mv.visitMaxs(-1, -1);
            mv.visitEnd();
        }

        {
            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "proceed", "()Ljava/lang/Object;", null,
                    new String[]{"java/lang/Throwable"});
            mv.visitCode();
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, typeName, "idx", "I");
            Label def = new Label();
            Label[] labels = new Label[callbacks.size()];
            for (int i = 0; i < labels.length; i++) {
                labels[i] = new Label();
            }
            mv.visitTableSwitchInsn(0, callbacks.size() - 1, def, labels);

            for (int i = 0; i < labels.length; i++) {
                mv.visitLabel(labels[i]);
                Callback cb = callbacks.get(i);
                MtdInfo m = (MtdInfo) cb.callback;
                if (cb.isStatic) {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, "args", "[Ljava/lang/Object;");
                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc, false);
                } else if (cb.isSpecial) {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, "thiz", "Ljava/lang/Object;");
                    mv.visitTypeInsn(CHECKCAST, toInternal(m.owner));
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, "args", "[Ljava/lang/Object;");
                    mv.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.owner), m.name, m.desc, false);
                } else {
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, "thiz", "Ljava/lang/Object;");
                    mv.visitVarInsn(ALOAD, 0);
                    mv.visitFieldInsn(GETFIELD, typeName, "args", "[Ljava/lang/Object;");
                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc, false);
                }
                Type ret = Type.getReturnType(m.desc);
                box(ret, mv);
                mv.visitInsn(ret.getOpcode(IRETURN));
            }
            mv.visitLabel(def);
            mv.visitTypeInsn(NEW, "java/lang/RuntimeException");
            mv.visitInsn(DUP);
            mv.visitLdcInsn("invalid idx");
            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V", false);
            mv.visitInsn(ATHROW);
            mv.visitMaxs(-1, -1);
            mv.visitEnd();
        }
        return typeName;
    }

    interface CB {
        String getKey(MtdInfo mtd);
    }

    private void genSwitchMethod(ClassVisitor cw, String typeName, String methodName, CB callback) {
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, methodName, "()Ljava/lang/String;", null, null);
        mv.visitCode();
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, typeName, "idx", "I");
        Label def = new Label();
        Label[] labels = new Label[callbacks.size()];

        Map<String, Label> strMap = new TreeMap<>();
        for (int i = 0; i < labels.length; i++) {
            Callback cb = callbacks.get(i);
            String key = callback.getKey((MtdInfo) cb.target);
            Label label = strMap.get(key);
            if (label == null) {
                label = new Label();
                strMap.put(key, label);
            }
            labels[i] = label;
        }

        mv.visitTableSwitchInsn(0, callbacks.size() - 1, def, labels);

        for (Map.Entry<String, Label> e : strMap.entrySet()) {
            mv.visitLabel(e.getValue());
            mv.visitLdcInsn(e.getKey());
            mv.visitInsn(ARETURN);
        }
        mv.visitLabel(def);
        mv.visitTypeInsn(NEW, "java/lang/RuntimeException");
        mv.visitInsn(DUP);
        mv.visitLdcInsn("invalid idx");
        mv.visitMethodInsn(INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V", false);
        mv.visitInsn(ATHROW);
        mv.visitMaxs(-1, -1);
        mv.visitEnd();
    }


}

```

`dex-tools/src/main/java/com/googlecode/d2j/tools/jar/ScanBridgeAdapter.java`:

```java
package com.googlecode.d2j.tools.jar;

import com.googlecode.d2j.tools.jar.ClassInfo.MemberInfo;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static com.googlecode.d2j.util.AccUtils.isBridge;
import static com.googlecode.d2j.util.AccUtils.isSynthetic;

public class ScanBridgeAdapter extends ClassVisitor implements Opcodes {

    private Map<String, MemberInfo> bridge = new HashMap<String, MemberInfo>();

    public ScanBridgeAdapter(ClassVisitor cv) {
        super(ASM9, cv);
    }

    // private String currentName;
    //
    // @Override
    // public void visit(int version, int access, String name, String signature,
    // String superName, String[] interfaces) {
    // super.visit(version, access, name, signature, superName, interfaces);
    // this.currentName = name;
    // }

    public Map<String, MemberInfo> getBridge() {
        return Collections.unmodifiableMap(bridge);
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
        if (isBridge(access) && isSynthetic(access)) {
            if (mv == null) {
                mv = new MethodVisitor(ASM9) {
                };
            }
            final MemberInfo member = new MemberInfo();
            member.access = access;
            member.desc = desc;
            member.name = name;
            mv = new MethodVisitor(ASM9, mv) {

                @Override
                public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean isInterface) {
                    super.visitMethodInsn(opcode, owner, name, desc, isInterface);
                    if (!name.equals(member.name)) {
                        bridge.put(owner + '.' + name + desc.substring(0, desc.lastIndexOf(')') + 1), member);
                    }
                }
            };
        }
        return mv;
    }

}

```

`dex-tools/src/main/java/com/googlecode/d2j/tools/jar/WebApp.java`:

```java
package com.googlecode.d2j.tools.jar;

import com.googlecode.dex2jar.tools.BaseCmd;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.HashSet;
import java.util.Set;

public class WebApp {

    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println("webapp pathToWebApp config [ignoreJarConfig]");
            return;
        }

        File webApp = new File(args[0]);
        File config = new File(args[1]);
        Path jarIgnore = args.length > 2 ? new File(args[2]).toPath() : null;

        Path clz = new File(webApp, "WEB-INF/classes").toPath();
        Path tmpClz = new File(webApp, "WEB-INF/tmp-classes").toPath();
        final InvocationWeaver ro = (InvocationWeaver) new InvocationWeaver().withConfig(config.toPath());
        Files.deleteIfExists(tmpClz);
        copyDirectory(clz, tmpClz);

        System.out.println("InvocationWeaver from [" + tmpClz + "] to [" + clz + "]");
        ro.wave(tmpClz, clz);
        Files.deleteIfExists(tmpClz);

        final File lib = new File(webApp, "WEB-INF/lib");
        Path tmpLib = new File(webApp, "WEB-INF/Nlib").toPath();

        final Set<String> ignores = new HashSet<String>();
        if (jarIgnore != null && Files.exists(jarIgnore)) {
            ignores.addAll(Files.readAllLines(jarIgnore, StandardCharsets.UTF_8));
        } else {
            System.out.println("ignoreJarConfig ignored");
        }

        Files.deleteIfExists(tmpLib);
        copyDirectory(lib.toPath(), tmpLib);

        Files.walkFileTree(tmpLib, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if (file.getFileName().toString().endsWith(".jar")) {
                    final String s = file.getFileName().toString();
                    boolean ignore = false;
                    for (String i : ignores) {
                        if (s.startsWith(i)) {
                            ignore = true;
                            break;
                        }
                    }
                    if (!ignore) {
                        Path nJar = new File(lib, s).toPath();
                        System.out.println("InvocationWeaver from [" + file + "] to [" + nJar + "]");
                        ro.wave(file, nJar);
                    }
                }
                return super.visitFile(file, attrs);
            }
        });
        Files.deleteIfExists(tmpLib);
    }

    private static void copyDirectory(final Path clz, final Path tmpClz) throws IOException {
        Files.walkFileTree(clz, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Path n = clz.relativize(file);
                Path target = tmpClz.resolve(n);
                BaseCmd.createParentDirectories(target);
                Files.copy(file, target);
                return super.visitFile(file, attrs);
            }
        });
    }
}

```

`dex-tools/src/main/java/com/googlecode/d2j/util/AccUtils.java`:

```java
package com.googlecode.d2j.util;

import org.objectweb.asm.Opcodes;

public class AccUtils {
    public static boolean isBridge(int acc) {
        return (acc & Opcodes.ACC_BRIDGE) != 0;
    }

    public static boolean isEnum(int acc) {
        return (acc & Opcodes.ACC_ENUM) != 0;
    }

    public static boolean isFinal(int acc) {
        return (acc & Opcodes.ACC_FINAL) != 0;
    }

    public static boolean isPrivate(int acc) {
        return (acc & Opcodes.ACC_PRIVATE) != 0;
    }

    public static boolean isProtected(int acc) {
        return (acc & Opcodes.ACC_PROTECTED) != 0;
    }

    public static boolean isPublic(int acc) {
        return (acc & Opcodes.ACC_PUBLIC) != 0;
    }

    public static boolean isStatic(int acc) {
        return (acc & Opcodes.ACC_STATIC) != 0;
    }

    public static boolean isSynthetic(int acc) {
        return (acc & Opcodes.ACC_SYNTHETIC) != 0;
    }

}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/bin_gen/BinGen.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.bin_gen;

import com.googlecode.dex2jar.tools.BaseCmd;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.Properties;

public class BinGen {

    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.err.println("bin-gen cfg-dir out-dir");
            return;
        }
        final Path cfg = new File(args[0]).toPath();
        final Path out = new File(args[1]).toPath();
        Properties p = new Properties();
        try (InputStream is = Files.newInputStream(cfg.resolve("class.cfg"))) {
            p.load(is);
        }

        String bat = new String(Files.readAllBytes(cfg.resolve("bat_template")), StandardCharsets.UTF_8);

        String sh = new String(Files.readAllBytes(cfg.resolve("sh_template")), StandardCharsets.UTF_8);

        Files.walkFileTree(cfg, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                String fileName = file.getFileName().toString();
                if (fileName.endsWith(".sh") || fileName.endsWith(".bat")) {
                    Path f = out.resolve(cfg.relativize(file));
                    BaseCmd.createParentDirectories(f);
                    Files.copy(file, f, StandardCopyOption.REPLACE_EXISTING);
                    if (fileName.endsWith(".sh")) {
                        setExec(f);
                    }
                }
                return super.visitFile(file, attrs);
            }
        });

        for (Object key : p.keySet()) {
            String name = key.toString();
            Path path = out.resolve(key.toString() + ".sh");
            BaseCmd.createParentDirectories(path);
            try (BufferedWriter bw = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.CREATE,
                    StandardOpenOption.WRITE)) {
                String s = sh.replaceAll("__@class_name@__", p.getProperty(name));
                bw.append(s);
            }

            setExec(path);

            path = out.resolve(key.toString() + ".bat");
            BaseCmd.createParentDirectories(path);
            try (BufferedWriter bw = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.CREATE,
                    StandardOpenOption.WRITE)) {
                String s = bat.replaceAll("__@class_name@__", p.getProperty(name));
                bw.append(s);
            }
        }
    }

    private static void setExec(Path path) {
        try {
            path.toFile().setExecutable(true);
            Files.setPosixFilePermissions(path, PosixFilePermissions.fromString("rwxr-xr-x"));
        } catch (Exception ex) {
            // ignored
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/ApkSign.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.PKCS8EncodedKeySpec;

import com.googlecode.d2j.reader.zip.ZipUtil;
import com.googlecode.d2j.signapk.AbstractJarSign;
import com.googlecode.d2j.signapk.SunJarSignImpl;
import com.googlecode.d2j.signapk.TinySignImpl;

@BaseCmd.Syntax(cmd = "d2j-apk-sign", syntax = "[options] <apk>", desc = "Sign an android apk file use a test certificate.")
public class ApkSign extends BaseCmd {
    public static void main(String... args) {
        new ApkSign().doMain(args);
    }

    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output .apk file, default is $current_dir/[apk-name]-signed.apk", argName = "out-apk-file")
    private Path output;
    @Opt(opt = "t", longOpt = "tiny", hasArg = false, description = "use tiny sign")
    private boolean tiny = false;

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length != 1) {
            usage();
            return;
        }

        Path apkIn = new File(remainingArgs[0]).toPath();
        if (!Files.exists(apkIn)) {
            System.err.println(apkIn + " doesn't exist");
            usage();
            return;
        }

        if (output == null) {
            if (Files.isDirectory(apkIn)) {
                output = new File(apkIn.getFileName() + "-signed.apk").toPath();
            } else {
                output = new File(getBaseName(apkIn.getFileName().toString()) + "-signed.apk").toPath();
            }
        }

        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            usage();
            return;
        }
        Path tmp = null;
        try {
            final Path realJar;
            if (Files.isDirectory(apkIn)) {
                realJar = Files.createTempFile("d2j", ".jar");
                tmp = realJar;
                System.out.println("zipping " + apkIn + " -> " + realJar);
                try (FileSystem fs = createZip(realJar)) {
                    final Path outRoot = fs.getPath("/");
                    walkJarOrDir(apkIn, new FileVisitorX() {
                        @Override
                        public void visitFile(Path file, String relative) throws IOException {
                            Path target = outRoot.resolve(relative);
                            createParentDirectories(target);
                            Files.copy(file, target);
                        }
                    });
                }
            } else {
                realJar = apkIn;
            }

            AbstractJarSign signer;

            if (tiny) {
                signer = new TinySignImpl();
            } else {
                try {
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    X509Certificate cert = (X509Certificate) certificateFactory.generateCertificate(ApkSign.class
                            .getResourceAsStream("ApkSign.cer"));
                    KeyFactory rSAKeyFactory = KeyFactory.getInstance("RSA");
                    PrivateKey privateKey = rSAKeyFactory.generatePrivate(new PKCS8EncodedKeySpec(ZipUtil
                            .toByteArray(ApkSign.class.getResourceAsStream("ApkSign.private"))));

                    signer = new SunJarSignImpl(cert, privateKey);
                } catch (Exception cnfe) {
                    signer = new TinySignImpl();
                }
            }
            signer.sign(apkIn.toFile(), output.toFile());

            System.out.println("sign " + realJar + " -> " + output);
        } finally {
            if (tmp != null) {
                Files.deleteIfExists(tmp);
            }
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/AsmVerify.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TryCatchBlockNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.BasicValue;
import org.objectweb.asm.tree.analysis.BasicVerifier;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.Printer;
import org.objectweb.asm.util.Textifier;
import org.objectweb.asm.util.TraceMethodVisitor;

import com.googlecode.dex2jar.tools.BaseCmd.Syntax;

@Syntax(cmd = "d2j-asm-verify", syntax = "[options] <jar0> [jar1 ... jarN]", desc = "Verify .class in jar")
public class AsmVerify extends BaseCmd {

    private static String getShortName(final String name) {
        int n = name.lastIndexOf('/');
        return n == -1 ? name : "o";
    }

    public static void main(String... args) {
        new AsmVerify().doMain(args);
    }

    static Field buf;
    static {
        try {
            buf = Printer.class.getDeclaredField("buf");
        } catch (NoSuchFieldException | SecurityException e) {
            e.printStackTrace();
        }
        buf.setAccessible(true);
    }

    static void printAnalyzerResult(MethodNode method, Analyzer a, final PrintWriter pw)
            throws IllegalArgumentException {
        Frame[] frames = a.getFrames();
        Textifier t = new Textifier();
        TraceMethodVisitor mv = new TraceMethodVisitor(t);
        String format = "%05d %-" + (method.maxStack + method.maxLocals + 6) + "s|%s";
        for (int j = 0; j < method.instructions.size(); ++j) {
            method.instructions.get(j).accept(mv);

            StringBuffer s = new StringBuffer();
            Frame f = frames[j];
            if (f == null) {
                s.append('?');
            } else {
                for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }
                s.append(" : ");
                for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }
            }
            try {
                pw.printf(format, j, s, buf.get(t)); // mv.text.get(j));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        for (TryCatchBlockNode tryCatchBlockNode: method.tryCatchBlocks) {
            tryCatchBlockNode.accept(mv);
            try {
                pw.print(" " + buf.get(t));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        pw.println();
        pw.flush();
    }

    @Opt(opt = "d", longOpt = "detail", hasArg = false, description = "Print detail error message")
    boolean detail = false;

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length < 1) {
            usage();
            return;
        }

        List<Path> files = new ArrayList<>();
        for (String fn : remainingArgs) {
            Path file = new File(fn).toPath();
            if (!Files.exists(file)) {
                System.err.println(fn + " doesn't exist");
                usage();
                return;
            }
            files.add(file);
        }

        for (Path file : files) {
            System.out.println("verify " + file);
            walkJarOrDir(file, new FileVisitorX() {
                @Override
                public void visitFile(Path file, String relative) throws IOException {
                    if (file.getFileName().toString().endsWith(".class")) {
                        ClassReader cr = new ClassReader(Files.readAllBytes(file));
                        ClassNode cn = new ClassNode();
                        cr.accept(new CheckClassAdapter(cn, false),
                                ClassReader.SKIP_DEBUG | ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);
                        for (MethodNode method : cn.methods) {
                            BasicVerifier verifier = new BasicVerifier();
                            Analyzer<BasicValue> a = new Analyzer<>(verifier);
                            try {
                                a.analyze(cn.name, method);
                            } catch (Exception ex) {
                                System.err.println("Error verify method " + cr.getClassName() + "." + method.name + " "
                                        + method.desc);
                                if (detail) {
                                    ex.printStackTrace(System.err);
                                    printAnalyzerResult(method, a, new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8)));
                                }
                            }
                        }
                    }
                }
            });
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/BaksmaliBaseDexExceptionHandler.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.dex.BaseDexExceptionHandler;
import com.googlecode.d2j.dex.Dex2jar;
import com.googlecode.d2j.node.DexMethodNode;
import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.smali.BaksmaliDumper;
import com.googlecode.d2j.smali.Smali;
import com.googlecode.dex2jar.ir.ET;
import org.objectweb.asm.MethodVisitor;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.zip.GZIPOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class BaksmaliBaseDexExceptionHandler extends BaseDexExceptionHandler {
    public static final String REPORT_MESSAGE = "Please report this file to https://github.com/pxb1988/dex2jar/issues if possible.";

    private Map<DexMethodNode, Exception> exceptionMap = new HashMap<>();
    private List<Exception> fileExceptions = new ArrayList<>();

    public boolean hasException() {
        return exceptionMap.size() > 0 || fileExceptions.size() > 0;
    }

    @Override
    public void handleFileException(Exception e) {
        super.handleFileException(e);
        fileExceptions.add(e);
    }

    @Override
    public void handleMethodTranslateException(Method method, DexMethodNode methodNode, MethodVisitor mv, Exception e) {
        super.handleMethodTranslateException(method, methodNode, mv, e);
        exceptionMap.put(methodNode, e);
    }

    public static String getVersionString() {
        List<String> vs = new ArrayList<>();
        doAddVersion(vs, "dex-reader", DexFileReader.class);
        doAddVersion(vs, "dex-reader-api", Method.class);
        doAddVersion(vs, "dex-ir", ET.class);
        doAddVersion(vs, "d2j-smali", Smali.class);
        doAddVersion(vs, "d2j-base-cmd", BaseCmd.class);
        doAddVersion(vs, "dex-tools", Dex2jarCmd.class);
        doAddVersion(vs, "dex-translator", Dex2jar.class);
        return vs.toString();
    }

    private static void doAddVersion(List<String> vs, String pkg, Class<?> clz) {
        try {
            vs.add(pkg + "-" + clz.getPackage().getImplementationVersion());
        } catch (Exception ignore) {
            // ignored
        }
    }

    public void dump(Path exFile, String[] originalArgs) {
        String fileName = exFile.getFileName().toString().toLowerCase();
        try {
            if (fileName.endsWith(".zip")) {
                dumpZip(exFile, originalArgs);
            } else if (fileName.endsWith(".gz")) {
                dumGZip(exFile, originalArgs);
            } else {
                dumpTxt(exFile, originalArgs);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void dumpTxt(Path exFile, String[] originalArgs) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(Files
                .newOutputStream(exFile), StandardCharsets.UTF_8))) {
            dumpTxt0(writer, originalArgs);
        }
    }

    private void dumGZip(Path exFile, String[] originalArgs) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new GZIPOutputStream(Files
                .newOutputStream(exFile)), StandardCharsets.UTF_8))) {
            dumpTxt0(writer, originalArgs);
        }
    }

    private void dumpTxt0(BufferedWriter writer, String[] originalArgs) throws IOException {
        dumpSummary(originalArgs, writer);
        int i = 0;
        for (Map.Entry<DexMethodNode, Exception> e : exceptionMap.entrySet()) {
            DexMethodNode dexMethodNode = e.getKey();
            Exception ex = e.getValue();
            writer.newLine();
            writer.write("================= " + i++ + " ===================");
            writer.newLine();
            dumpMethod(writer, dexMethodNode, ex);
        }
    }

    public void dumpZip(Path exFile, String[] originalArgs) throws IOException {
        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(exFile))) {
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(zos, StandardCharsets.UTF_8));

            zos.putNextEntry(new ZipEntry("summary.txt"));
            dumpTxt0(writer, originalArgs);
            zos.closeEntry();
            zos.flush();
        }
    }

    // dump each method
    private void dumpMethod(BufferedWriter writer, DexMethodNode dexMethodNode, Exception ex) throws IOException {
        writer.append(dexMethodNode.method.toString());
        writer.newLine();
        writer.flush();
        ex.printStackTrace(new PrintWriter(writer, true));
        writer.newLine();
        try {
            new BaksmaliDumper().baksmaliMethod(dexMethodNode, writer);
        } catch (Exception e) {
            // https://github.com/pxb1988/dex2jar/issues/500
            // dump out the exception
            PrintWriter s = new PrintWriter(writer);
            e.printStackTrace(s);
            s.flush();
        }
        writer.flush();
    }

    // dump summary: timestamp, version, cmdline
    private void dumpSummary(String[] originalArgs, BufferedWriter writer) throws IOException {
        writer.write("#This file is generated by dex2jar");
        writer.newLine();
        writer.write(REPORT_MESSAGE);
        writer.newLine();
        writer.newLine();
        if (fileExceptions.size() > 0) {
            writer.append(String.format("There are %d fails.", fileExceptions.size()));
            writer.newLine();
        }
        if (exceptionMap.size() > 0) {
            writer.append(String.format("There are %d methods fail to translate.", exceptionMap.size()));
            writer.newLine();
        }
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        writer.append(sdf.format(new Date()));
        writer.newLine();
        writer.append("version: ");
        writer.append(getVersionString());
        writer.newLine();
        writer.append("cmdline: ");
        writer.append(Arrays.asList(originalArgs).toString());
        writer.newLine();

        writer.append("env:");
        writer.newLine();
        Properties properties = System.getProperties();
        for (String key : properties.stringPropertyNames()) {
            if (key.startsWith("java.") && !key.toLowerCase().contains("pass")) {
                writer.append(key).append(": ").append(properties.getProperty(key));
                writer.newLine();
            }
        }
        PrintWriter p = new PrintWriter(writer, true);
        for (Exception ex : fileExceptions) {
            ex.printStackTrace(p);
        }
        writer.flush();
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/ClassVersionSwitch.java`:

```java
package com.googlecode.dex2jar.tools;


import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class ClassVersionSwitch {
    static final int jVersions[] = new int[]{
            0,
            Opcodes.V1_1,
            Opcodes.V1_2,
            Opcodes.V1_3,
            Opcodes.V1_4,
            Opcodes.V1_5,
            Opcodes.V1_6,
            Opcodes.V1_7,
            52,
            53,
    };

    public static void main(String... args) throws IOException {
        if (args.length < 3) {
            System.out.println("Usage: clz-version-switch version old.jar new.jar");
            System.exit(1);
        }
        int version = Integer.parseInt(args[0]);
        if (version < 1 || version > 9) {
            throw new RuntimeException("version not support yet!");
        }
        File old = new File(args[1]);
        File n = new File(args[2]);
        byte[] buff = new byte[1024 * 50];
        final int jVersion = jVersions[version];
        try (ZipFile zip = new ZipFile(old); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(n));) {

            for (Enumeration<? extends ZipEntry> e = zip.entries(); e.hasMoreElements(); ) {
                ZipEntry zipEntry = e.nextElement();
                zos.putNextEntry(new ZipEntry(zipEntry.getName()));
                if (!zipEntry.isDirectory()) {
                    try (InputStream is = zip.getInputStream(zipEntry)) {
                        if (zipEntry.getName().endsWith(".class")) {
                            ClassReader cr = new ClassReader(is);
                            ClassWriter cw = new ClassWriter(0);
                            ClassVisitor cv = new ClassVisitor(Opcodes.ASM9, cw) {
                                @Override
                                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
                                    super.visit(jVersion, access, name, signature, superName, interfaces);
                                }
                            };
                            cr.accept(cv, ClassReader.EXPAND_FRAMES|ClassReader.SKIP_FRAMES);
                            zos.write(cw.toByteArray());
                        } else {
                            for (int c = is.read(buff); c > 0; c = is.read(buff)) {
                                zos.write(buff, 0, c);
                            }
                        }
                    }

                }
                zos.closeEntry();
            }
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/DeObfInitCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import com.googlecode.d2j.tools.jar.InitOut;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;

public class DeObfInitCmd extends BaseCmd {
    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output .jar file, default is $current_dir/[file-name]-deobf-init.txt", argName = "out-file")
    private Path output;
    @Opt(opt = "min", longOpt = "min-length", description = "do the rename if the length < MIN, default is 2", argName = "MIN")
    private int min = 2;
    @Opt(opt = "max", longOpt = "max-length", description = "do the rename if the length > MIN, default is 40", argName = "MAX")
    private int max = 40;

    public DeObfInitCmd() {
        super("d2j-init-deobf [options] <jar>", "generate an init config file for deObfuscate a jar");
    }

    public static void main(String... args) {
        new DeObfInitCmd().doMain(args);
    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length != 1) {
            usage();
            return;
        }

        Path jar = new File(remainingArgs[0]).toPath();
        if (!Files.exists(jar)) {
            System.err.println(jar + " doesn't exist");
            usage();
            return;
        }
        if (output == null) {
            if (Files.isDirectory(jar)) {
                output = new File(jar.getFileName().toString() + "-deobf-init.txt").toPath();
            } else {
                output = new File(getBaseName(jar.getFileName().toString()) + "-deobf-init.txt").toPath();
            }
        }

        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            usage();
            return;
        }
        System.out.println("generate " + jar + " -> " + output);
        new InitOut().from(jar).maxLength(max).minLength(min).to(output);
    }

}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/DecryptStringCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import com.googlecode.d2j.converter.IR2JConverter;
import com.googlecode.d2j.converter.J2IRConverter;
import com.googlecode.d2j.util.Escape;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.StmtTraveler;
import com.googlecode.dex2jar.ir.expr.*;
import com.googlecode.dex2jar.ir.ts.*;
import com.googlecode.dex2jar.ir.ts.array.FillArrayTransformer;
import com.googlecode.dex2jar.tools.BaseCmd.Syntax;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

@Syntax(cmd = "d2j-decrypt-string", syntax = "[options] <jar>", desc = "Decrypt in class file", onlineHelp = "https://sourceforge.net/p/dex2jar/wiki/DecryptStrings\nhttps://bitbucket.org/pxb1988/dex2jar/wiki/DecryptStrings")
public class DecryptStringCmd extends BaseCmd {
    public static void main(String... args) {
        new DecryptStringCmd().doMain(args);
    }

    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output of .jar files, default is $current_dir/[jar-name]-decrypted.jar", argName = "out")
    private Path output;
    @Opt(opt = "m", longOpt = "methods", description = "a file contain a list of methods, each line like: La/b;->decrypt(III)Ljava/lang/String;", argName = "cfg")
    private Path method;
    @Opt(opt = "mo", longOpt = "decrypt-method-owner", description = "the owner of the method which can decrypt the stings, example: java.lang.String", argName = "owner")
    private String methodOwner;
    @Opt(opt = "mn", longOpt = "decrypt-method-name", description = "the owner of the method which can decrypt the stings, the method's signature must be static (parameter-type)Ljava/lang/String;. Please use -pt,--parameter-type to set the argument descrypt.", argName = "name")
    private String methodName;
    @Opt(opt = "cp", longOpt = "classpath", description = "add extra lib to classpath", argName = "cp")
    private String classpath;
    //extended parameter option: e.g. '-t int,byte,string' to specify a routine such as decryptionRoutine(int a, byte b, String c)
    @Opt(opt = "t", longOpt = "arg-types", description = "comma-separated list of types:boolean,byte,short,char,int,long,float,double,string. Default is string", argName = "type")
    private String parameterJTypes;
    @Opt(opt = "pd", longOpt = "parameters-descriptor", description = "the descriptor for the method which can decrypt the stings, example1: Ljava/lang/String; example2: III, default is Ljava/lang/String;", argName = "type")
    private String parametersDescriptor;
    @Opt(opt = "d", longOpt = "delete", hasArg = false, description = "delete the method which can decrypt the stings")
    private boolean deleteMethod = false;
    @Opt(opt = "da", longOpt = "deep-analyze", hasArg = false, description = "use dex2jar IR to static analyze and find more values like byte[]")
    private boolean deepAnalyze = false;
    @Opt(opt = "v", longOpt = "verbose", hasArg = false, description = "show more on output")
    private boolean verbose = false;

    static class MethodConfig {
        Method jmethod;
        /**
         * in java/lang/String format
         */
        String owner;
        String name;
        String desc;

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((desc == null) ? 0 : desc.hashCode());
            result = prime * result + ((name == null) ? 0 : name.hashCode());
            result = prime * result + ((owner == null) ? 0 : owner.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            MethodConfig other = (MethodConfig) obj;
            if (desc == null) {
                if (other.desc != null)
                    return false;
            } else if (!desc.equals(other.desc))
                return false;
            if (name == null) {
                if (other.name != null)
                    return false;
            } else if (!name.equals(other.name))
                return false;
            if (owner == null) {
                if (other.owner != null)
                    return false;
            } else if (!owner.equals(other.owner))
                return false;
            return true;
        }
    }

    MethodConfig build(String line) {
        int idx = line.indexOf("->");
        if (idx < 0) {
            throw new RuntimeException("Can't read line:" + line);
        }
        String owner = line.substring(0, idx);

        if (owner.startsWith("L") && owner.endsWith(";")) {
            owner = owner.substring(1, owner.length() - 1);
        }

        int idx2 = line.indexOf('(', idx);
        if (idx2 < 0) {
            throw new RuntimeException("Can't read line:" + line);
        }

        String name = line.substring(idx + 2, idx2);

        String desc = line.substring(idx2);
        if (desc.endsWith(")")) {
            desc = desc + "Ljava/lang/String;";
        }

        MethodConfig config = new MethodConfig();
        config.owner = owner;
        config.desc = desc;
        config.name = name;
        return config;

    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length == 0) {
            throw new HelpException("One <jar> file is required");
        } else if (remainingArgs.length > 1) {
            throw new HelpException("Only one <jar> file is required, But we found " + remainingArgs.length);
        }

        final Path jar = new File(remainingArgs[0]).toPath();
        if (!Files.exists(jar)) {
            System.err.println(jar + " doesn't exist");
            return;
        }
        if (output == null) {
            if (Files.isDirectory(jar)) {
                output = new File(jar.getFileName() + "-decrypted.jar").toPath();
            } else {
                output = new File(getBaseName(jar.getFileName().toString()) + "-decrypted.jar").toPath();
            }
        }

        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            return;
        }

        System.err.println(jar + " -> " + output);

        List<MethodConfig> methodConfigs = collectMethodConfigs();
        if (methodConfigs == null || methodConfigs.size() == 0) {
            System.err.println("No method selected !");
            return;
        }

        final Map<MethodConfig, MethodConfig> map = loadMethods(jar, methodConfigs);
        try (FileSystem outputFileSystem = createZip(output)) {
            final Path outputBase = outputFileSystem.getPath("/");
            walkJarOrDir(jar, new FileVisitorX() {
                @Override
                public void visitFile(Path file, String relative) throws IOException {
                    if (file.getFileName().toString().endsWith(".class")) {
                        Path dist1 = outputBase.resolve(relative);
                        createParentDirectories(dist1);
                        byte[] data = Files.readAllBytes(file);
                        ClassNode cn = readClassNode(data);

                        if (decrypt(cn, map)) {
                            byte[] data2 = toByteArray(cn);
                            Files.write(dist1, data2);
                        } else {
                            Files.write(dist1, data);
                        }
                    } else {
                        Path dist1 = outputBase.resolve(relative);
                        createParentDirectories(dist1);
                        Files.copy(file, dist1);
                    }
                }
            });
        }
    }

    private byte[] toByteArray(ClassNode cn) {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        cn.accept(cw);
        return cw.toByteArray();
    }

    private ClassNode readClassNode(byte[] data) {
        ClassReader cr = new ClassReader(data);
        ClassNode cn = new ClassNode();
        cr.accept(cn, ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);
        return cn;
    }

    private boolean decrypt(ClassNode cn, Map<MethodConfig, MethodConfig> map) {
        if (deepAnalyze) {
            return decryptByIr(cn, map);
        } else {
            return decryptByStack(cn, map);
        }
    }

    private boolean decryptByIr(ClassNode cn, Map<MethodConfig, MethodConfig> map) {
        MethodConfig key = this.key;
        boolean changed = false;
        for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }


            if (false && verbose) {
                System.out.println();
                System.out.println("===============");
                System.out.println("on method " + cn.name + ";->" + m.name + m.desc);
            }

            boolean find = false;
            // search for the decrypt method
            for (AbstractInsnNode p = m.instructions.getFirst(); p != null; p = p.getNext()) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        find = true;
                    }
                }
            }
            if (find) {
                try {
                    // copy m to m2 for cleanup debug info
                    MethodNode m2 = new MethodNode();
                    m2.tryCatchBlocks = new ArrayList<>();
                    m2.name = m.name;
                    m2.access = m.access;
                    m2.desc = m.desc;
                    m.accept(m2);
                    cleanDebug(m2);
                    // convert m2 to ir
                    IrMethod irMethod = J2IRConverter.convert(cn.name, m2);
                    // opt and decrypt
                    optAndDecrypt(irMethod, map);

                    // convert ir to m3
                    MethodNode m3 = new MethodNode();
                    m3.tryCatchBlocks = new ArrayList<>();
                    new IR2JConverter()
                            .ir(irMethod)
                            .asm(m3)
                            .convert();

                    // copy back m3 to m
                    m.maxLocals = -1;
                    m.maxLocals = -1;
                    m.instructions = m3.instructions;
                    m.tryCatchBlocks = m3.tryCatchBlocks;
                    m.localVariables = null;
                    changed = true;
                } catch (Exception ex) {
                    if(verbose) {
                        ex.printStackTrace();
                    }
                }
            }
        }
        return changed;
    }

    MethodConfig key = new MethodConfig();

    private boolean decryptByStack(ClassNode cn, Map<MethodConfig, MethodConfig> map) {
        MethodConfig key = this.key;
        boolean changed = false;
        for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {
            MethodNode m = it.next();
            if (m.instructions == null) {
                continue;
            }
            key.owner = cn.name;
            key.name = m.name;
            key.desc = m.desc;
            if (map.containsKey(key)) {
                if (deleteMethod) {
                    it.remove();
                }
                continue;
            }

            if (false && verbose) {
                System.out.println();
                System.out.println("===============");
                System.out.println("on method " + cn.name + ";->" + m.name + m.desc);
            }

            AbstractInsnNode p = m.instructions.getFirst();
            while (p != null) {
                if (p.getOpcode() == Opcodes.INVOKESTATIC) {
                    MethodInsnNode mn = (MethodInsnNode) p;
                    key.owner = mn.owner;
                    key.name = mn.name;
                    key.desc = mn.desc;
                    MethodConfig config = map.get(key);
                    if (config != null) {
                        //here we are, given that the decryption method is successfully recognised
                        Method jmethod = config.jmethod;
                        try {
                            int pSize = jmethod.getParameterTypes().length;
                            // arguments' list. each parameter's value is retrieved by reading bytecode backwards, starting from the INVOKESTATIC statement
                            Object[] as = readArgumentValues(mn, jmethod, pSize);
                            if (verbose) {
                                System.out.println(" > calling " + jmethod + " with arguments " + v(as));
                            }
                            //decryption routine invocation
                            String newValue = (String) jmethod.invoke(null, as);
                            if (verbose) {
                                System.out.println("  -> " + Escape.v(newValue));
                            }
                            //LDC statement generation
                            LdcInsnNode nLdc = new LdcInsnNode(newValue);
                            //insertion of the decrypted string's LDC statement, after INVOKESTATIC statement
                            m.instructions.insert(mn, nLdc);
                            //removal of INVOKESTATIC and previous push statements
                            removeInsts(m, mn, pSize);
                            p = nLdc;
                            changed = true;
                        } catch (InvocationTargetException ex){
                            if(verbose){
                                ex.getTargetException().printStackTrace();
                            }
                        } catch (Exception ex) {
                            if (verbose) {
                                ex.printStackTrace();
                            }
                        }
                    }
                }
                p = p.getNext();
            }
        }
        return changed;
    }

    protected final CleanLabel T_cleanLabel = new CleanLabel();
    protected final Ir2JRegAssignTransformer T_ir2jRegAssign = new Ir2JRegAssignTransformer();
    protected final NewTransformer T_new = new NewTransformer();
    protected final RemoveConstantFromSSA T_removeConst = new RemoveConstantFromSSA();
    protected final RemoveLocalFromSSA T_removeLocal = new RemoveLocalFromSSA();
    protected final ExceptionHandlerTrim T_trimEx = new ExceptionHandlerTrim();
    protected final TypeTransformer T_type = new TypeTransformer();
    protected final DeadCodeTransformer T_deadCode = new DeadCodeTransformer();
    protected final FillArrayTransformer T_fillArray = new FillArrayTransformer();
    protected final AggTransformer T_agg = new AggTransformer();
    protected final UnSSATransformer T_unssa = new UnSSATransformer();
    protected final ZeroTransformer T_zero = new ZeroTransformer();
    protected final VoidInvokeTransformer T_voidInvoke = new VoidInvokeTransformer();
    protected final NpeTransformer T_npe = new NpeTransformer();

    public void optAndDecrypt(IrMethod irMethod, final Map<MethodConfig, MethodConfig> map) {
        T_deadCode.transform(irMethod);
        T_cleanLabel.transform(irMethod);
        T_removeLocal.transform(irMethod);
        T_removeConst.transform(irMethod);
        T_zero.transform(irMethod);
        if (T_npe.transformReportChanged(irMethod)) {
            T_deadCode.transform(irMethod);
            T_removeLocal.transform(irMethod);
            T_removeConst.transform(irMethod);
        }
        T_new.transform(irMethod);
        T_fillArray.transform(irMethod);
        T_agg.transform(irMethod);
        T_voidInvoke.transform(irMethod);

        new StmtTraveler() {
            @Override
            public Value travel(Value op) {
                op = super.travel(op);
                if (op.vt == Value.VT.INVOKE_STATIC) {
                    InvokeExpr ie = (InvokeExpr) op;
                    MethodConfig key = DecryptStringCmd.this.key;
                    key.owner = ie.getOwner().substring(1, ie.getOwner().length() - 1);
                    key.name = ie.getName();
                    key.desc = buildMethodDesc(ie.getArgs(), ie.getRet());

                    MethodConfig c = map.get(key);
                    if (c != null) {
                        try {
                            Method jmethod = c.jmethod;
                            if (ie.getArgs().length != jmethod.getParameterTypes().length) {
                                throw new RuntimeException();
                            }

                            Object args[] = new Object[ie.getArgs().length];
                            for (int i = 0; i < args.length; i++) {
                                args[i] = convertIr2Jobj(ie.getOps()[i], ie.getArgs()[i]);
                            }
                            if (verbose) {
                                System.out.println(" > calling " + jmethod + " with arguments " + v(args));
                            }
                            String str = (String) jmethod.invoke(null, args);
                            if (verbose) {
                                System.out.println("  -> " + Escape.v(str));
                            }
                            return Exprs.nString(str);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }

                    }
                }
                return op;
            }
        }.travel(irMethod.stmts);

        T_type.transform(irMethod);
        T_unssa.transform(irMethod);
        T_trimEx.transform(irMethod);
        T_ir2jRegAssign.transform(irMethod);
    }

    public static String v(Object[] vs) {
        StringBuilder sb = new StringBuilder("[");
        boolean first = true;
        for (Object obj : vs) {
            if (first) {
                first = false;
            } else {
                sb.append(",");
            }
            if(obj instanceof String) {
                sb.append(Escape.v(obj));
            }else {
                sb.append(obj);
            }
        }
        return sb.append("]").toString();
    }

    private Object convertIr2Jobj(Value value, String type) {
        if (value instanceof Constant) {
            if (Constant.Null.equals(((Constant) value).value)) {
                return null;
            }
        }
        switch (type) {
            case "Z": {
                Object obj = ((Constant) value).value;
                return obj instanceof Boolean ? obj : ((Number) obj).intValue() != 0;
            }
            case "B": {
                Object obj = ((Constant) value).value;
                return ((Number) obj).byteValue();
            }
            case "S": {
                Object obj = ((Constant) value).value;
                return ((Number) obj).shortValue();
            }
            case "C": {
                Object obj = ((Constant) value).value;
                return obj instanceof Character ? obj : (char) ((Number) obj).intValue();
            }
            case "I": {
                Object obj = ((Constant) value).value;
                return ((Number) obj).intValue();
            }
            case "J": {
                Object obj = ((Constant) value).value;
                return ((Number) obj).longValue();
            }
            case "F": {
                Object obj = ((Constant) value).value;
                return obj instanceof Float ? obj : Float.intBitsToFloat(((Number) obj).intValue());
            }
            case "D": {
                Object obj = ((Constant) value).value;
                return obj instanceof Double ? obj : Double.longBitsToDouble(((Number) obj).longValue());
            }
            case "Ljava/lang/String;":
                return (String) ((Constant) value).value;
            case "[Z":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof boolean[]) {
                        return obj;
                    } else {

                        boolean[] b = new boolean[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).intValue() != 0;
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    boolean b[] = new boolean[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        if (obj instanceof Boolean) {
                            b[i] = ((Boolean) obj).booleanValue();
                        } else {
                            b[i] = ((Number) obj).intValue() != 0;
                        }
                    }
                    return b;
                }
                throw new RuntimeException();
            case "[B":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof byte[]) {
                        return obj;
                    } else {
                        byte[] b = new byte[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).byteValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    byte b[] = new byte[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).byteValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case "[S":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof short[]) {
                        return obj;
                    } else {
                        short[] b = new short[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).shortValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    short b[] = new short[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).shortValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case "[C":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof char[]) {
                        return obj;
                    } else {
                        char[] b = new char[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    char b[] = new char[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Character ? ((Character) obj).charValue() : (char) ((Number) obj).intValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case "[I":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof int[]) {
                        return obj;
                    } else {
                        int[] b = new int[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).intValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    int b[] = new int[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).intValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case "[J":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof long[]) {
                        return obj;
                    } else {
                        long[] b = new long[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = ((Number) Array.get(obj, i)).longValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    long b[] = new long[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = ((Number) obj).longValue();
                    }
                    return b;
                }
                throw new RuntimeException();
            case "[F":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof float[]) {
                        return obj;
                    } else {
                        float[] b = new float[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    float b[] = new float[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Float ? ((Float) obj).floatValue() : Float.intBitsToFloat(((Number) obj).intValue());
                    }
                    return b;
                }
                throw new RuntimeException();
            case "[D":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof double[]) {
                        return obj;
                    } else {
                        double[] b = new double[Array.getLength(obj)];
                        for (int i = 0; i < b.length; i++) {
                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();
                        }
                        return b;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    double b[] = new double[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        b[i] = obj instanceof Double ? ((Double) obj).doubleValue() : Double.longBitsToDouble(((Number) obj).longValue());
                    }
                    return b;
                }
                throw new RuntimeException();
            case "[Ljava/lang/String;":
                if (value instanceof Constant) {
                    Object obj = ((Constant) value).value;
                    if (obj instanceof String[]) {
                        return obj;
                    }
                } else if (value instanceof FilledArrayExpr) {
                    String b[] = new String[value.getOps().length];
                    for (int i = 0; i < b.length; i++) {
                        Object obj = ((Constant) value.getOps()[i]).value;
                        if (obj instanceof String) {
                            b[i] = (String) obj;
                        } else if (Constant.Null.equals(obj)) {
                            b[i] = null;
                        } else {
                            throw new RuntimeException();
                        }
                    }
                    return b;
                }
                throw new RuntimeException();
        }
        throw new RuntimeException();
    }

    private String buildMethodDesc(String[] args, String ret) {
        StringBuilder sb = new StringBuilder();
        sb.append('(');
        for (String s : args) {
            sb.append(s);
        }
        return sb.append(')').append(ret).toString();
    }

    private void cleanDebug(MethodNode mn) {
        for (AbstractInsnNode p = mn.instructions.getFirst(); p != null; ) {
            if (p.getType() == AbstractInsnNode.LINE) {
                AbstractInsnNode q = p.getNext();
                mn.instructions.remove(p);
                p = q;
            } else {
                p = p.getNext();
            }
        }
        mn.localVariables = null;
    }

    void removeInsts(MethodNode m, MethodInsnNode mn, int pSize) {
        // remove args
        for (int i = 0; i < pSize; i++) {
            m.instructions.remove(mn.getPrevious());
        }
        // remove INVOKESTATIC
        m.instructions.remove(mn);
    }

    Object[] readArgumentValues(MethodInsnNode mn, Method jmethod, int pSize) {
        AbstractInsnNode q = mn;
        Object[] as = new Object[pSize];
        for (int i = pSize - 1; i >= 0; i--) {
            q = q.getPrevious();
            Object object = readCst(q);
            as[i] = convert(object, jmethod.getParameterTypes()[i]);
        }
        return as;
    }

    Object convert(Object object, Class<?> type) {
        if (int.class.equals(type)) {
            return ((Number) object).intValue();
        }
        if (byte.class.equals(type)) {
            return ((Number) object).byteValue();
        }
        if (short.class.equals(type)) {
            return ((Number) object).shortValue();
        }
        if (char.class.equals(type)) {
            return (char) ((Number) object).intValue();
        }
        if (boolean.class.equals(type)) {
            return (char) ((Number) object).intValue() != 0;
        }
        if (long.class.equals(type)) {
            return (char) ((Number) object).longValue();
        }
        if (float.class.equals(type)) {
            return (char) ((Number) object).floatValue();
        }
        if (double.class.equals(type)) {
            return (char) ((Number) object).doubleValue();
        }
        return object;
    }

    /**
     * load java methods from jar and --classpath
     *
     * @param jar
     * @param methodConfigs
     * @return
     * @throws Exception
     */
    private Map<MethodConfig, MethodConfig> loadMethods(Path jar, List<MethodConfig> methodConfigs) throws Exception {
        final Map<MethodConfig, MethodConfig> map = new HashMap<>();
        List<String> list = new ArrayList<>();
        if (classpath != null) {
            list.addAll(Arrays.asList(classpath.split(";|:")));
        }
        list.add(jar.toAbsolutePath().toString());
        URL[] urls = new URL[list.size()];
        for (int i = 0; i < list.size(); i++) {
            urls[i] = new File(list.get(i)).toURI().toURL();
        }

        URLClassLoader cl = new URLClassLoader(urls);
        for (MethodConfig config : methodConfigs) {
            Method jmethod;
            try {
                Class<?> clz = cl.loadClass(config.owner.replace('/', '.'));
                if (clz == null) {
                    System.err.println("clz is null:" + config.owner);
                }
                jmethod = findAnyMethodMatch(clz, config.name,
                        toJavaType(Type.getArgumentTypes(config.desc)));
            } catch (Exception ex) {
                System.err.println("can't load method: L" + config.owner + ";->" + config.name + config.desc);
                throw ex;
            }
            if (jmethod != null) {
                jmethod.setAccessible(true);
                config.jmethod = jmethod;
                map.put(config, config);
            } else {
                throw new NoSuchMethodException("can't find method " + config.name + config.desc + " on class " + config.owner + " or its parent");
            }
        }
        return map;
    }

    /**
     * collect methods from --methods and --method-owner,--method-name
     *
     * @return
     * @throws IOException
     */
    private List<MethodConfig> collectMethodConfigs() throws IOException {
        List<MethodConfig> methodConfigs = new ArrayList<>();
        if (this.method != null) {
            for (String line : Files.readAllLines(this.method, StandardCharsets.UTF_8)) {
                if (line.length() == 0 || line.startsWith("#")) {
                    continue;
                }
                methodConfigs.add(this.build(line));
            }
        }
        if (methodOwner != null && methodName != null) {
            if (this.parametersDescriptor != null) {
                methodConfigs.add(this.build("L" + methodOwner.replace('.', '/') + ";->" + methodName + "("
                        + this.parametersDescriptor + ")Ljava/lang/String;"));
            } else if (this.parameterJTypes != null) {

                //parameterJTypes is a comma-separated list of the decryption method's parameters
                String[] type_list = parameterJTypes.split(",|;|:");
                //switch for all the supported types. String is default
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < type_list.length; i++) {
                    switch (type_list[i]) {
                        case "boolean":
                            sb.append("Z");
                            break;
                        case "byte":
                            sb.append("B");
                            break;
                        case "short":
                            sb.append("S");
                            break;
                        case "char":
                            sb.append("C");
                            break;
                        case "int":
                            sb.append("I");
                            break;
                        case "long":
                            sb.append("J");
                            break;
                        case "float":
                            sb.append("F");
                            break;
                        case "double":
                            sb.append("D");
                            break;
                        case "string":
                            sb.append("Ljava/lang/String;");
                            break;

                        default:
                            throw new RuntimeException("not support type " + type_list[i] + " on -t/--arg-types");
                    }
                }
                methodConfigs.add(this.build("L" + methodOwner.replace('.', '/') + ";->" + methodName + "("
                        + sb + ")Ljava/lang/String;"));
            } else {
                methodConfigs.add(this.build("L" + methodOwner.replace('.', '/') + ";->" + methodName + "(Ljava/lang/String;)Ljava/lang/String;"));
            }
        }
        return methodConfigs;
    }

    /**
     * fix for issue 216, travel all the parent of class and use getDeclaredMethod to find methods
     */
    private Method findAnyMethodMatch(Class<?> clz, String name, Class<?>[] classes) {
        try {
            Method m = clz.getDeclaredMethod(name, classes);
            if (m != null) {
                return m;
            }
        } catch (NoSuchMethodException ignored) {
            // https://github.com/pxb1988/dex2jar/issues/51
            // mute exception stack
        }
        Class<?> sup = clz.getSuperclass();
        if (sup != null) {
            Method m = findAnyMethodMatch(sup, name, classes);
            if (m != null) {
                return m;
            }
        }
        Class<?>[] itfs = clz.getInterfaces();
        if (itfs != null && itfs.length > 0) {
            for (Class<?> itf : itfs) {
                Method m = findAnyMethodMatch(itf, name, classes);
                if (m != null) {
                    return m;
                }
            }
        }
        return null;
    }

    Object readCst(AbstractInsnNode q) {

        switch (q.getOpcode()) {
            case Opcodes.LDC:
                // LDC: String, integer, long and double cases (Opcodes.LDC comprehends LDC_W and LDC2_W)
                // push 32bit or 64bit int/float
                // push string/type
                LdcInsnNode ldc = (LdcInsnNode) q;
                if (ldc.cst instanceof Type) {
                    throw new RuntimeException("not support .class value yet!");
                }
                return ldc.cst;

            case Opcodes.BIPUSH:
            case Opcodes.SIPUSH:
                // INT_INSN ("instruction with a single int operand")
                // push 8bit or 16bit int
                IntInsnNode in = (IntInsnNode) q;
                return in.operand;

            case Opcodes.ICONST_M1:
            case Opcodes.ICONST_0:
            case Opcodes.ICONST_1:
            case Opcodes.ICONST_2:
            case Opcodes.ICONST_3:
            case Opcodes.ICONST_4:
            case Opcodes.ICONST_5:
                // ICONST_*: push a tiny int, -1 <= value <= 5
                return q.getOpcode() - Opcodes.ICONST_0;
            case Opcodes.LCONST_0:
            case Opcodes.LCONST_1:
                return (long) (q.getOpcode() - Opcodes.LCONST_0);
            case Opcodes.FCONST_0:
            case Opcodes.FCONST_1:
            case Opcodes.FCONST_2:
                return (float) (q.getOpcode() - Opcodes.FCONST_0);
            case Opcodes.DCONST_0:
            case Opcodes.DCONST_1:
                return (double) (q.getOpcode() - Opcodes.DCONST_0);
            case Opcodes.ACONST_NULL:
                return null;
        }

        throw new RuntimeException();
    }

    Class<?>[] toJavaType(Type[] pt) throws ClassNotFoundException {
        Class<?> jt[] = new Class<?>[pt.length];
        for (int i = 0; i < pt.length; i++) {
            jt[i] = toJavaType(pt[i]);
        }
        return jt;
    }

    Class<?> toJavaType(Type t) throws ClassNotFoundException {
        switch (t.getSort()) {
            case Type.BOOLEAN:
                return boolean.class;
            case Type.BYTE:
                return byte.class;
            case Type.SHORT:
                return short.class;
            case Type.CHAR:
                return char.class;
            case Type.INT:
                return int.class;
            case Type.FLOAT:
                return float.class;
            case Type.LONG:
                return long.class;
            case Type.DOUBLE:
                return double.class;
            case Type.OBJECT:
                return Class.forName(t.getClassName());
            case Type.ARRAY:
                return Class.forName(t.getDescriptor());
            case Type.VOID:
                return void.class;
        }
        throw new RuntimeException();
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/Dex2jarCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import com.googlecode.d2j.dex.Dex2jar;
import com.googlecode.d2j.reader.BaseDexFileReader;
import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.MultiDexFileReader;
import com.googlecode.dex2jar.ir.ET;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;

@BaseCmd.Syntax(cmd = "d2j-dex2jar", syntax = "[options] <file0> [file1 ... fileN]", desc = "convert dex to jar")
public class Dex2jarCmd extends BaseCmd {

    public static void main(String... args) {
        new Dex2jarCmd().doMain(args);
    }

    @Opt(opt = "e", longOpt = "exception-file", description = "detail exception file, default is $current_dir/[file-name]-error.zip", argName = "file")
    private Path exceptionFile;
    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "n", longOpt = "not-handle-exception", hasArg = false, description = "not handle any exceptions thrown by dex2jar")
    private boolean notHandleException = false;
    @Opt(opt = "o", longOpt = "output", description = "output .jar file, default is $current_dir/[file-name]-dex2jar.jar", argName = "out-jar-file")
    private Path output;

    @Opt(opt = "r", longOpt = "reuse-reg", hasArg = false, description = "reuse register while generate java .class file")
    private boolean reuseReg = false;

    @Opt(opt = "s", hasArg = false, description = "same with --topological-sort/-ts")
    private boolean topologicalSort1 = false;

    @Opt(opt = "ts", longOpt = "topological-sort", hasArg = false, description = "sort block by topological, that will generate more readable code, default enabled")
    private boolean topologicalSort = false;

    @Opt(opt = "d", longOpt = "debug-info", hasArg = false, description = "translate debug info")
    private boolean debugInfo = false;

    @Opt(opt = "p", longOpt = "print-ir", hasArg = false, description = "print ir to System.out")
    private boolean printIR = false;

    @Opt(opt = "os", longOpt = "optmize-synchronized", hasArg = false, description = "optimize-synchronized")
    private boolean optmizeSynchronized = false;

    @Opt(longOpt = "skip-exceptions", hasArg = false, description = "skip-exceptions")
    private boolean skipExceptions = false;

    @Opt(opt = "nc", longOpt = "no-code", hasArg = false, description = "")
    private boolean noCode = false;

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length == 0) {
            usage();
            return;
        }

        if ((exceptionFile != null || output != null) && remainingArgs.length != 1) {
            System.err.println("-e/-o can only used with one file");
            return;
        }
        if (debugInfo && reuseReg) {
            System.err.println("-d/-r can not use together");
            return;
        }

        Path currentDir = new File(".").toPath();

        if (output != null) {
            if (Files.exists(output) && !forceOverwrite) {
                System.err.println(output + " exists, use --force to overwrite");
                return;
            }
        } else {
            for (String fileName : remainingArgs) {
                Path file = currentDir.resolve(getBaseName(new File(fileName).toPath()) + "-dex2jar.jar");
                if (Files.exists(file) && !forceOverwrite) {
                    System.err.println(file + " exists, use --force to overwrite");
                    return;
                }
            }
        }

        for (String fileName : remainingArgs) {
            // long baseTS = System.currentTimeMillis();
            String baseName = getBaseName(new File(fileName).toPath());
            Path file = output == null ? currentDir.resolve(baseName + "-dex2jar.jar") : output;
            System.err.println("dex2jar " + fileName + " -> " + file);

            BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(new File(fileName).toPath()));
            BaksmaliBaseDexExceptionHandler handler = notHandleException ? null : new BaksmaliBaseDexExceptionHandler();
            Dex2jar.from(reader).withExceptionHandler(handler).reUseReg(reuseReg).topoLogicalSort()
                    .skipDebug(!debugInfo).optimizeSynchronized(this.optmizeSynchronized).printIR(printIR)
                    .noCode(noCode).skipExceptions(skipExceptions).to(file);

            if (!notHandleException) {
                if (handler.hasException()) {
                    Path errorFile = exceptionFile == null ? currentDir.resolve(baseName + "-error.zip")
                            : exceptionFile;
                    System.err.println("Detail Error Information in File " + errorFile);
                    System.err.println(BaksmaliBaseDexExceptionHandler.REPORT_MESSAGE);
                    handler.dump(errorFile, originalArgs);
                }
            }
            // long endTS = System.currentTimeMillis();
            // System.err.println(String.format("%.2f", (float) (endTS - baseTS) / 1000));
        }
    }

    @Override
    protected String getVersionString() {
        return "reader-" + DexFileReader.class.getPackage().getImplementationVersion() + ", translator-"
                + Dex2jar.class.getPackage().getImplementationVersion() + ", ir-"
                + ET.class.getPackage().getImplementationVersion();
    }

}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/Dex2jarMultiThreadCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.*;

import com.googlecode.d2j.dex.LambadaNameSafeClassAdapter;
import com.googlecode.d2j.reader.BaseDexFileReader;
import com.googlecode.d2j.reader.MultiDexFileReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;

import com.googlecode.d2j.dex.ClassVisitorFactory;
import com.googlecode.d2j.dex.ExDex2Asm;
import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.reader.DexFileReader;

@BaseCmd.Syntax(cmd = "d2j-mt-dex2jar", syntax = "[options] <file0> [file1 ... fileN]", desc = "convert dex to jar")
public class Dex2jarMultiThreadCmd extends BaseCmd {
    public static void main(String... args) {
        new Dex2jarMultiThreadCmd().doMain(args);
    }

    @Opt(opt = "mt", longOpt = "multi-thread", description = "concurrent process, default is 4 thread")
    private int multiThread = 4;

    @Opt(opt = "fl", longOpt = "file-list", description = "a file contains a list of dex to process")
    private Path fileList;

    @Override
    protected void doCommandLine() throws Exception {
        List<String> f = new ArrayList<>(Arrays.asList(remainingArgs));
        if (fileList != null) {
            f.addAll(Files.readAllLines(fileList, StandardCharsets.UTF_8));
        }
        if (f.size() < 1) {
            throw new HelpException();
        }

        final ExecutorService executorService = Executors.newFixedThreadPool(multiThread);

        final Iterator<String> fileIt = f.iterator();
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                if (fileIt.hasNext()) {
                    String fileName = fileIt.next();
                    try {
                        run0(fileName, executorService);
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        executorService.submit(this); // run this job again
                    }
                } else {
                    executorService.shutdown();
                }
            }
        });
        executorService.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
    }

    private void run0(String fileName, final ExecutorService executorService) throws IOException {
        // long baseTS = System.currentTimeMillis();
        String baseName = getBaseName(new File(fileName).toPath());
        Path currentDir = new File(".").toPath();
        Path file = currentDir.resolve(baseName + "-dex2jar.jar");
        final Path errorFile = currentDir.resolve(baseName + "-error.zip");
        System.err.println("dex2jar " + fileName + " -> " + file);
        final BaksmaliBaseDexExceptionHandler exceptionHandler = new BaksmaliBaseDexExceptionHandler();
        BaseDexFileReader reader = MultiDexFileReader.open(Files.readAllBytes(new File(fileName).toPath()));
        DexFileNode fileNode = new DexFileNode();
        try {
            reader.accept(fileNode, DexFileReader.SKIP_DEBUG | DexFileReader.IGNORE_READ_EXCEPTION);
        } catch (Exception ex) {
            exceptionHandler.handleFileException(ex);
            throw ex;
        }
        final FileSystem fs = createZip(file);
        final Path dist = fs.getPath("/");
        ClassVisitorFactory cvf = new ClassVisitorFactory() {
            @Override
            public ClassVisitor create(final String name) {
                final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
                final LambadaNameSafeClassAdapter rca = new LambadaNameSafeClassAdapter(cw);
                return new ClassVisitor(Opcodes.ASM9, rca) {
                    @Override
                    public void visitEnd() {
                        super.visitEnd();
                        String className = rca.getClassName();
                        byte[] data;
                        try {
                            // FIXME handle 'java.lang.RuntimeException: Method code too large!'
                            data = cw.toByteArray();
                        } catch (Exception ex) {
                            System.err.printf("ASM fail to generate .class file: %s%n", className);
                            exceptionHandler.handleFileException(ex);
                            return;
                        }
                        try {
                            Path dist1 = dist.resolve(className + ".class");
                            BaseCmd.createParentDirectories(dist1);
                            Files.write(dist1, data);
                        } catch (IOException e) {
                            exceptionHandler.handleFileException(e);
                        }
                    }
                };
            }
        };

        new ExDex2Asm(exceptionHandler) {

            @Override
            public void convertDex(final DexFileNode fileNode, final ClassVisitorFactory cvf) {
                if (fileNode.clzs != null) {
                    final Map<String, Clz> classes = collectClzInfo(fileNode);
                    final List<Future<?>> results = new ArrayList<>(fileNode.clzs.size());
                    for (final DexClassNode classNode : fileNode.clzs) {
                        results.add(executorService.submit(new Runnable() {
                            @Override
                            public void run() {
                                convertClass(fileNode, classNode, cvf, classes);
                            }
                        }));
                    }
                    executorService.submit(new Runnable() {
                        @Override
                        public void run() {
                            for (Future<?> result : results) {
                                try {
                                    result.get();
                                } catch (InterruptedException | ExecutionException e) {
                                    e.printStackTrace();
                                }
                            }
                            BaksmaliBaseDexExceptionHandler exceptionHandler1 = (BaksmaliBaseDexExceptionHandler) exceptionHandler;
                            if (exceptionHandler1.hasException()) {
                                exceptionHandler1.dump(errorFile, new String[0]);
                            }
                            try {
                                fs.close();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    });
                }
            }
        }.convertDex(fileNode, cvf);
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/DexRecomputeChecksum.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import com.googlecode.d2j.dex.writer.DexFileWriter;

import java.io.File;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.Files;
import java.nio.file.Path;

@BaseCmd.Syntax(cmd = "d2j-dex-recompute-checksum", syntax = "[options] dex", desc = "recompute crc and sha1 of dex.")
public class DexRecomputeChecksum extends BaseCmd {
    public static void main(String... args) {
        new DexRecomputeChecksum().doMain(args);
    }

    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output .dex file, default is [dex-name]-rechecksum.dex", argName = "out-dex-file")
    private Path output;

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length != 1) {
            usage();
            return;
        }

        Path jar = new File(remainingArgs[0]).toPath();
        if (!Files.exists(jar)) {
            System.err.println(jar + " doesn't exist");
            usage();
            return;
        }

        if (output == null) {
            if (Files.isDirectory(jar)) {
                output = new File(jar.getFileName() + "-rechecksum.dex").toPath();
            } else {
                output = new File(getBaseName(jar.getFileName().toString()) + "-rechecksum.dex").toPath();
            }
        }

        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            usage();
            return;
        }

        byte[] data = Files.readAllBytes(jar);

        ByteBuffer b = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN);
        b.putInt(32, data.length);
        DexFileWriter.updateChecksum(b, data.length);
        Files.write(output, data);

    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/DexWeaverCmd.java`:

```java
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.dex.writer.DexFileWriter;
import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.reader.zip.ZipUtil;
import com.googlecode.d2j.smali.Utils;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexFileVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

@BaseCmd.Syntax(cmd = "d2j-dex-weaver", syntax = "[options] dex", desc = "replace invoke in dex", onlineHelp = "https://sourceforge.net/p/dex2jar/wiki/DexWeaver")
public class DexWeaverCmd extends BaseCmd {
    @Opt(opt = "o", longOpt = "output", description = "output .dex file", argName = "out-dex-file")
    private Path output;
    @Opt(opt = "c", longOpt = "config", description = "config file", argName = "config")
    private Path config;
    @Opt(opt = "s", longOpt = "stub-dex", description = "stub dex", argName = "stub")
    private Path stub;

    static Method parseMethod(String str) {
        int i = str.indexOf('.');
        String owner = str.substring(0, i);
        int j = str.indexOf('(', i);
        String name = str.substring(i + 1, j);
        i = str.indexOf(')', j);
        String args = str.substring(j + 1, i);
        String ret = str.substring(i + 1);
        return new Method(owner, name, Utils.toTypeList(args), ret);
    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length == 0) {
            throw new HelpException("no odex");
        }

        final Map<String, Method> map = new HashMap<>();
        for (String ln : Files.readAllLines(config, StandardCharsets.UTF_8)) {
            if (ln.startsWith("#") || ln.length() == 0) {
                continue;
            }
            String[] x = ln.split("=");
            map.put(x[0], parseMethod(x[1]));
        }

        DexFileWriter out = new DexFileWriter();
        DexFileVisitor fv = new DexFileVisitor(out) {
            @Override
            public DexClassVisitor visit(int access_flags, String className, String superClass, String[] interfaceNames) {
                DexClassVisitor dcv = super.visit(access_flags, className, superClass, interfaceNames);
                if (dcv != null) {
                    return new DexClassVisitor(dcv) {
                        @Override
                        public DexMethodVisitor visitMethod(int accessFlags, Method method) {
                            DexMethodVisitor dmv = super.visitMethod(accessFlags, method);
                            if (dmv != null) {
                                return new DexMethodVisitor(dmv) {
                                    @Override
                                    public DexCodeVisitor visitCode() {
                                        DexCodeVisitor code = super.visitCode();
                                        if (code != null) {
                                            return new DexCodeVisitor(code) {
                                                @Override
                                                public void visitMethodStmt(Op op, int[] args, Method method) {
                                                    Method replaceTo = map.get(method.toString());
                                                    if (replaceTo != null) {
                                                        switch (op) {
                                                        case INVOKE_DIRECT:
                                                        case INVOKE_INTERFACE:
                                                        case INVOKE_STATIC:
                                                        case INVOKE_SUPER:
                                                        case INVOKE_VIRTUAL:
                                                            super.visitMethodStmt(Op.INVOKE_STATIC, args, replaceTo);
                                                            break;
                                                        case INVOKE_DIRECT_RANGE:
                                                        case INVOKE_INTERFACE_RANGE:
                                                        case INVOKE_STATIC_RANGE:
                                                        case INVOKE_SUPER_RANGE:
                                                        case INVOKE_VIRTUAL_RANGE:
                                                            super.visitMethodStmt(Op.INVOKE_STATIC_RANGE, args, replaceTo);
                                                            break;
                                                        default:
                                                            // impossible here
                                                        }
                                                    } else {
                                                        super.visitMethodStmt(op, args, method);
                                                    }
                                                }
                                            };
                                        }
                                        return code;
                                    }
                                };
                            }
                            return dmv;
                        }
                    };
                }
                return dcv;
            }

            @Override
            public void visitEnd() {

            }
        };
        for (String f : remainingArgs) {
            byte[] data = ZipUtil.readDex(new File(f).toPath());
            DexFileReader r = new DexFileReader(data);
            r.accept(fv);
        }
        if (stub != null) {
            byte[] data = ZipUtil.readDex(stub);
            DexFileReader r = new DexFileReader(data);
            r.accept(new DexFileVisitor(out) {
                @Override
                public void visitEnd() {

                }
            });
        }

        out.visitEnd();

        byte[] data = out.toByteArray();
        Files.write(output, data);

    }

    public static void main(String[] args) {
        new DexWeaverCmd().doMain(args);
    }

}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/ExtractOdexFromCoredumpCmd.java`:

```java
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;

@BaseCmd.Syntax(cmd = "extract-odex-from-coredump", syntax = "<core.xxxx>", desc = "Extract odex from dalvik memery core dump")
public class ExtractOdexFromCoredumpCmd extends BaseCmd {
    public static void main(String... args) {
        new ExtractOdexFromCoredumpCmd().doMain(args);
    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length < 1) {
            throw new HelpException("<core.xxxx> is required.");
        }
        Path core = new File(remainingArgs[0]).toPath();
        try (SeekableByteChannel channel = FileChannel.open(core, StandardOpenOption.READ);) {
            List<Long> possibleOdexs = findPossibleOdexLocation(channel);
            extractDex(channel, possibleOdexs, core.getFileName().toString());
        }
    }

    private static void extractDex(SeekableByteChannel channel, List<Long> possibleOdexs, String namePrefix) throws IOException {
        int dexIndex = 0;
        ByteBuffer odexHead = ByteBuffer.allocate(0x28).order(ByteOrder.LITTLE_ENDIAN);
        ByteBuffer copyBuff = ByteBuffer.allocate(512 * 1024).order(ByteOrder.LITTLE_ENDIAN);
        final int buffSize = 0x28 + 0x70;
        ByteBuffer head = ByteBuffer.allocate(buffSize).order(ByteOrder.LITTLE_ENDIAN); // odex+dex head
        for (long pos : possibleOdexs) {
            System.err.println(String.format(">> Check for %08x", pos));
            channel.position(pos);
            head.position(0);
            int c = channel.read(head);
            head.position(0);
            if (c == buffSize) {
                int version = head.getInt(4);
                if (version == 0x00363330 || version == 0x00353330) { // odexVersion
                    int dexOffset = head.getInt(8);
                    int dexLength = head.getInt(12);
                    int depsOffset = head.getInt(16);
                    int depsLength = head.getInt(20);
                    int optOffset = head.getInt(24);
                    int optLength = head.getInt(28);
                    int flags = head.getInt(32);
                    int checksum = head.getInt(36);
                    if (dexOffset != 0x28) {
                        System.err.println(String.format(">>> dex offset is not 0x28"));
                    } else {
                        int dexMagic = head.getInt(dexOffset + 0);
                        int dexVersion = head.getInt(dexOffset + 4);
                        if (dexMagic != 0x0a786564 || !(dexVersion == 0x00363330 || dexVersion == 0x00353330)) {
                            System.err.println(String.format(">>> dex magic is not dex.036 or dex.035: 0x%08x 0x%08x", dexMagic, dexVersion));
                        } else {
                            int fileSize = head.getInt(dexOffset + 32);
                            if (fileSize != dexLength) {
                                System.err.println(String.format(">>> dex file size is same with dexLength in odex %d vs %d", fileSize, dexLength));
                            } else {
                                int endian = head.getInt(dexOffset + 40);
                                if (endian != 0x12345678) {
                                    System.err.println(String.format(">>> dex endian is not 0x12345678"));
                                } else {
                                    // find new dex
                                    Path nFile = new File(String.format("%s-%02d.odex", namePrefix, dexIndex++)).toPath();
                                    System.out.println(String.format(">>>> extract 0x%08x to %s", pos, nFile));
                                    try (SeekableByteChannel channel2 = Files.newByteChannel(nFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE);) {

                                        odexHead.rewind();
                                        odexHead.putInt(0x0a796564);// dey
                                        odexHead.putInt(0x00363330);// 036
                                        odexHead.putInt(0x28);
                                        odexHead.putInt(fileSize);
                                        int nDepsOffset = 0x28 + fileSize;
                                        int nDepsPadding = 0;
                                        if (nDepsOffset % 8 != 0) {
                                            nDepsPadding = 8 - (nDepsOffset % 8);
                                            nDepsOffset += nDepsPadding;
                                        }
                                        odexHead.putInt(nDepsOffset);
                                        odexHead.putInt(depsLength);
                                        int nOptOffset = nDepsOffset + depsLength;
                                        int nOptPadding = 0;
                                        if (nOptOffset % 8 != 0) {
                                            nOptPadding = 8 - (nOptOffset % 8);
                                            nOptOffset += nOptPadding;
                                        }
                                        odexHead.putInt(nOptOffset);
                                        odexHead.putInt(optLength);
                                        odexHead.putInt(flags);
                                        odexHead.putInt(checksum);
                                        odexHead.position(0);
                                        channel2.write(odexHead);

                                        // copy dex
                                        channel.position(pos + dexOffset);
                                        copy(channel, channel2, copyBuff, fileSize);

                                        if (nDepsPadding != 0) {
                                            channel2.write(ByteBuffer.allocate(nDepsPadding));
                                        }
                                        // copy deps
                                        channel.position(pos + depsOffset);
                                        copy(channel, channel2, copyBuff, depsLength);

                                        if (nOptPadding != 0) {
                                            channel2.write(ByteBuffer.allocate(nOptPadding));
                                        }
                                        // copy opts
                                        channel.position(pos + optOffset);
                                        copy(channel, channel2, copyBuff, optLength);
                                    }
                                }
                            }
                        }
                    }

                }
            }
        }
    }

    private static void copy(SeekableByteChannel channel, SeekableByteChannel channel2, ByteBuffer copyBuff, int fileSize) throws IOException {
        int remain = fileSize;

        while (remain > 0) {
            copyBuff.rewind();
            copyBuff.limit(Math.min(remain, copyBuff.capacity()));
            int read = channel.read(copyBuff);
            copyBuff.position(0);
            channel2.write(copyBuff);
            remain -= read;
        }

    }

    private static List<Long> findPossibleOdexLocation(SeekableByteChannel channel) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(1024 * 512).order(ByteOrder.LITTLE_ENDIAN);
        IntBuffer intBuffer = buffer.asIntBuffer();
        List<Long> possibleOdexs = new ArrayList<>();
        while (true) {
            long position = channel.position();
            //System.out.printf("load @%x\n", position);
            int count = channel.read(buffer);
            if (count <= 0) {
                break;
            }
            int s = count / 4;
            for (int i = 0; i < s; i++) {
                int u4 = intBuffer.get(i);
                if (u4 == 0x0a796564) {// dey
                    if (i + 1 < s) {
                        int v4 = intBuffer.get(i + 1);
                        if (v4 == 0x00363330 || v4 == 0x00353330) {
                            possibleOdexs.add(position + 4 * i);
                            System.err.println(String.format("> Possible %08x | %08x %08x", position + i * 4, u4, v4));
                        }
                    } else {
                        possibleOdexs.add(position + 4 * i);
                        System.err.println(String.format("> Possible %08x | %08x", position + i * 4, u4));
                    }
                }
            }
            buffer.position(0);
            intBuffer.position(0);
        }
        return possibleOdexs;
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/GenerateCompileStubFromOdex.java`:

```java
package com.googlecode.dex2jar.tools;

import com.googlecode.d2j.dex.ClassVisitorFactory;
import com.googlecode.d2j.dex.Dex2Asm;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.reader.DexFileReader;
import org.objectweb.asm.*;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;

@BaseCmd.Syntax(cmd = "d2j-generate-stub-from-odex", syntax = "[options] <odex0> [odex1 ... odexN]", desc =
        "Generate no-code jar from odex")
public class GenerateCompileStubFromOdex extends BaseCmd {
    private static final int MAGIC_ODEX = 0x0A796564 & 0x00FFFFFF;// hex for 'dey ', ignore the 0A
    private static final int MAGIC_DEX = 0x0A786564 & 0x00FFFFFF;// hex for 'dex ', ignore the 0A

    public static void main(String... args) {
        new GenerateCompileStubFromOdex().doMain(args);
    }

    @Opt(opt = "o", longOpt = "output", description = "output .jar file, default is stub.jar", argName = "out-jar-file")
    private Path output;
    @Opt(opt = "npri", longOpt = "no-private", description = "", hasArg = false)
    private boolean noPrivate;

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length == 0) {
            throw new HelpException("No odex");
        }
        if (output == null) {
            output = new File("stub.jar").toPath();
        }

        try (FileSystem fs = createZip(output)) {
            Path out = fs.getPath("/");
            for (String x : remainingArgs) {
                System.err.println("Processing " + x + " ...");
                ByteBuffer bs = ByteBuffer.wrap(Files.readAllBytes(new File(x).toPath()))
                        .order(ByteOrder.LITTLE_ENDIAN);
                int magic = bs.getInt(0) & 0x00FFFFFF;
                if (magic == MAGIC_ODEX) {
                    int offset = bs.getInt(8);
                    int length = bs.getInt(12);
                    bs.position(offset);
                    ByteBuffer n = (ByteBuffer) bs.slice().limit(length);
                    doDex(n, out);
                } else if (magic == MAGIC_DEX) {
                    doDex(bs, out);
                } else {
                    throw new RuntimeException("File " + x + " is not an dex or odex");
                }

            }
        }
    }

    private void doDex(ByteBuffer bs, final Path out) {
        DexFileReader reader = new DexFileReader(bs);
        DexFileNode fileNode = new DexFileNode();
        reader.accept(fileNode, DexFileReader.SKIP_CODE);
        Dex2Asm dex2Asm = new Dex2Asm();
        dex2Asm.convertDex(fileNode, new ClassVisitorFactory() {
            @Override
            public ClassVisitor create(final String classInternalName) {
                final Path target = out.resolve(classInternalName + ".class");
                if (Files.exists(target)) {
                    System.err.println("Class " + classInternalName + " already exists, skipping.");
                    return null;
                }
                return new ClassVisitor(Opcodes.ASM9, new ClassWriter(ClassWriter.COMPUTE_MAXS)) {
                    @Override
                    public void visitEnd() {
                        super.visitEnd();
                        ClassWriter cw = (ClassWriter) cv;
                        byte[] data = cw.toByteArray();
                        try {
                            BaseCmd.createParentDirectories(target);
                            Files.write(target, data);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }

                    @Override
                    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
                        if (noPrivate && 0 != (access & Opcodes.ACC_PRIVATE)) {
                            return null;
                        }
                        return super.visitField(access, name, desc, signature, value);
                    }

                    @Override
                    public MethodVisitor visitMethod(int access, String name, String desc, String signature,
                            String[] exceptions) {
                        if (noPrivate && 0 != (access & Opcodes.ACC_PRIVATE)) {
                            return null;
                        }
                        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
                        if (0 != ((Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT) & access)) {
                            return mv;
                        }
                        mv.visitTypeInsn(Opcodes.NEW, "java/lang/RuntimeException");
                        mv.visitInsn(Opcodes.DUP);
                        mv.visitLdcInsn("stub");
                        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/RuntimeException", "<init>",
                                "(Ljava/lang/String;)V", false);
                        mv.visitInsn(Opcodes.ATHROW);
                        return mv;
                    }
                };
            }
        });
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/Jar2Dex.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@BaseCmd.Syntax(cmd = "d2j-jar2dex", syntax = "[options] <dir>", desc = "Convert jar to dex by invoking dx.")
public class Jar2Dex extends BaseCmd {
    public static void main(String... args) {
        new Jar2Dex().doMain(args);
    }

    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output .dex file, default is $current_dir/[jar-name]-jar2dex.dex", argName = "out-dex-file")
    private Path output;

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length != 1) {
            usage();
            return;
        }

        Path jar = new File(remainingArgs[0]).toPath();
        if (!Files.exists(jar)) {
            System.err.println(jar + " is not exists");
            usage();
            return;
        }

        if (output == null) {
            if (Files.isDirectory(jar)) {
                output = new File(jar.getFileName() + "-jar2dex.dex").toPath();
            } else {
                output = new File(getBaseName(jar.getFileName().toString()) + "-jar2dex.dex").toPath();
            }
        }

        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            usage();
            return;
        }

        Path tmp = null;
        final Path realJar;
        try {
            if (Files.isDirectory(jar)) {
                realJar = Files.createTempFile("d2j", ".jar");
                tmp = realJar;
                System.out.println("zipping " + jar + " -> " + realJar);
                try (FileSystem fs = createZip(realJar)) {
                    final Path outRoot = fs.getPath("/");
                    walkJarOrDir(jar, new FileVisitorX() {
                        @Override
                        public void visitFile(Path file, String relative) throws IOException {
                            if (file.getFileName().toString().endsWith(".class")) {
                                Files.copy(file, outRoot.resolve(relative));
                            }
                        }
                    });
                }
            } else {
                realJar = jar;
            }

            System.out.println("jar2dex " + realJar + " -> " + output);

            Class<?> c = Class.forName("com.android.dx.command.Main");
            Method m = c.getMethod("main", String[].class);

            List<String> ps = new ArrayList<>(Arrays.asList("--dex", "--no-strict",
                    "--output=" + output.toAbsolutePath(), realJar
                    .toAbsolutePath().toString()));
            System.out.println("call com.android.dx.command.Main.main" + ps);
            m.invoke(null, new Object[] { ps.toArray(new String[0]) });
        } finally {
            if (tmp != null) {
                Files.deleteIfExists(tmp);
            }
        }

    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/JarAccessCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;

import org.objectweb.asm.*;

@BaseCmd.Syntax(cmd = "d2j-jar-access", syntax = "[options] <jar>", desc = "add or remove class/method/field access in jar file")
public class JarAccessCmd extends BaseCmd implements Opcodes {
    public static void main(String... args) {
        new JarAccessCmd().doMain(args);
    }

    @Opt(opt = "f", longOpt = "force", hasArg = false, description = "force overwrite")
    private boolean forceOverwrite = false;
    @Opt(opt = "o", longOpt = "output", description = "output dir of .j files, default is $current_dir/[jar-name]-access.jar", argName = "out-dir")
    private Path output;

    @Opt(opt = "rd", longOpt = "remove-debug", hasArg = false, description = "remove debug info")
    private boolean removeDebug = false;

    @Opt(opt = "rf", longOpt = "remove-field-access", description = "remove access from field", argName = "ACC")
    private String removeFieldAccess;
    @Opt(opt = "rm", longOpt = "remove-method-access", description = "remove access from method", argName = "ACC")
    private String removeMethodAccess;
    @Opt(opt = "rc", longOpt = "remove-class-access", description = "remove access from class", argName = "ACC")
    private String removeClassAccess;
    @Opt(opt = "af", longOpt = "add-field-access", description = "add access from field", argName = "ACC")
    private String addFieldAccess;
    @Opt(opt = "am", longOpt = "add-method-access", description = "add access from method", argName = "ACC")
    private String addMethodAccess;
    @Opt(opt = "ac", longOpt = "add-class-access", description = "add access from class", argName = "ACC")
    private String addClassAccess;

    static int str2acc(String s) {
        if (s == null) {
            return 0;
        }
        int result = 0;
        s = s.toLowerCase();
        if (s.contains("public")) {
            result |= Opcodes.ACC_PUBLIC;
        }
        if (s.contains("private")) {
            result |= Opcodes.ACC_PRIVATE;
        }
        if (s.contains("protected")) {
            result |= Opcodes.ACC_PROTECTED;
        }
        if (s.contains("final")) {
            result |= Opcodes.ACC_FINAL;
        }
        if (s.contains("static")) {
            result |= Opcodes.ACC_STATIC;
        }
        if (s.contains("super")) {
            result |= Opcodes.ACC_SUPER;
        }
        if (s.contains("synchronized")) {
            result |= Opcodes.ACC_SYNCHRONIZED;
        }
        if (s.contains("volatile")) {
            result |= Opcodes.ACC_VOLATILE;
        }
        if (s.contains("bridge")) {
            result |= Opcodes.ACC_BRIDGE;
        }
        if (s.contains("transient")) {
            result |= Opcodes.ACC_TRANSIENT;
        }
        if (s.contains("varargs")) {
            result |= Opcodes.ACC_VARARGS;
        }
        if (s.contains("native")) {
            result |= Opcodes.ACC_NATIVE;
        }
        if (s.contains("strict")) {
            result |= Opcodes.ACC_STRICT;
        }
        if (s.contains("interface")) {
            result |= Opcodes.ACC_INTERFACE;
        }
        if (s.contains("abstract")) {
            result |= Opcodes.ACC_ABSTRACT;
        }
        if (s.contains("synthetic")) {
            result |= Opcodes.ACC_SYNTHETIC;
        }
        if (s.contains("annotation")) {
            result |= Opcodes.ACC_ANNOTATION;
        }
        if (s.contains("enum")) {
            result |= Opcodes.ACC_ENUM;
        }
        if (s.contains("deprecated")) {
            result |= Opcodes.ACC_DEPRECATED;
        }
        return result;
    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length != 1) {
            usage();
            return;
        }

        Path jar = new File(remainingArgs[0]).toPath();
        if (!Files.exists(jar)) {
            System.err.println(jar + " doesn't exist");
            usage();
            return;
        }

        if (output == null) {
            if (Files.isDirectory(jar)) {
                output = new File(jar.getFileName() + "-access.jar").toPath();
            } else {
                output = new File(getBaseName(jar.getFileName().toString()) + "-access.jar").toPath();
            }
        }

        if (Files.exists(output) && !forceOverwrite) {
            System.err.println(output + " exists, use --force to overwrite");
            usage();
            return;
        }

        final int rf = ~str2acc(removeFieldAccess);
        final int rm = ~str2acc(removeMethodAccess);
        final int rc = ~str2acc(removeClassAccess);

        final int af = str2acc(addFieldAccess);
        final int am = str2acc(addMethodAccess);
        final int ac = str2acc(addClassAccess);

        final int flags = removeDebug ? ClassReader.SKIP_DEBUG : 0;

        try (FileSystem outFileSystem = createZip(output)) {
            final Path outRoot = outFileSystem.getPath("/");
            walkJarOrDir(jar, new FileVisitorX() {
                @Override
                public void visitFile(Path file, String relative) throws IOException {
                    if (file.getFileName().toString().endsWith(".class")) {

                        final ClassReader r = new ClassReader(Files.readAllBytes(file));

                        ClassWriter cr = new ClassWriter(0);
                        r.accept(new ClassVisitor(ASM9, cr) {

                            @Override
                            public void visit(int version, int access, String name, String signature, String superName,
                                    String[] interfaces) {
                                int na = (access & rc) | ac;
                                if (access != na) {
                                    System.out.println("c " + name);
                                }
                                super.visit(version, na, name, signature, superName, interfaces);
                            }

                            @Override
                            public FieldVisitor visitField(int access, String name, String desc, String signature,
                                    Object value) {
                                int na = (access & rf) | af;
                                if (na != access) {
                                    System.out.println("f " + r.getClassName() + "." + name);
                                }
                                return super.visitField(na, name, desc, signature, value);
                            }

                            @Override
                            public MethodVisitor visitMethod(int access, String name, String desc, String signature,
                                    String[] exceptions) {
                                int na = (access & rm) | am;
                                if (na != access) {
                                    System.out.println("m " + r.getClassName() + "." + name + desc);
                                }
                                return super.visitMethod(na, name, desc, signature, exceptions);
                            }

                        }, flags | ClassReader.EXPAND_FRAMES);
                        Files.write(outRoot.resolve(relative), cr.toByteArray());

                    } else {
                        Files.copy(file, outRoot.resolve(relative));
                    }
                }
            });
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/JarWeaverCmd.java`:

```java
package com.googlecode.dex2jar.tools;

import com.googlecode.d2j.tools.jar.InvocationWeaver;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;

@BaseCmd.Syntax(cmd = "d2j-jar-weaver", syntax = "[options] jar", desc = "replace invoke in jar", onlineHelp = "https://sourceforge.net/p/dex2jar/wiki/JarWeaver")
public class JarWeaverCmd extends BaseCmd {
    @Opt(opt = "o", longOpt = "output", description = "output .jar file", argName = "out-jar-file", required = true)
    private Path output;
    @Opt(opt = "c", longOpt = "config", description = "config file", argName = "config", required = true)
    private Path config;
    @Opt(opt = "s", longOpt = "stub-jar", description = "stub jar", argName = "stub")
    private Path stub;

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length == 0) {
            throw new HelpException("no jar");
        }

        InvocationWeaver invocationWeaver = (InvocationWeaver) new InvocationWeaver().withConfig(config);

        try (FileSystem fs = createZip(output)) {
            final Path outRoot = fs.getPath("/");
            for (String str : remainingArgs) {
                Path p = new File(str).toPath();
                System.err.println(p + " -> " + output);
                if (Files.isDirectory(p)) {
                    invocationWeaver.wave(p, outRoot);
                } else {
                    try (FileSystem fs2 = openZip(p)) {
                        invocationWeaver.wave(fs2.getPath("/"), outRoot);
                    }
                }
            }
            if (stub != null) {
                System.err.println(stub + " -> " + output);
                walkJarOrDir(stub, new FileVisitorX() {
                    @Override
                    public void visitFile(Path file, String relative) throws IOException {
                        Path out = outRoot.resolve(relative);
                        if (Files.exists(out)) {
                            System.err.println("skip " + relative + " in " + stub);
                        } else {
                            createParentDirectories(out);
                            Files.copy(file, out);
                        }
                    }
                });
            }
        }
    }

    public static void main(String[] args) {
        new JarWeaverCmd().doMain(args);
    }

}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/StdApkCmd.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.tools;

import java.io.File;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import com.googlecode.d2j.util.zip.AutoSTOREDZipOutputStream;
import com.googlecode.dex2jar.tools.BaseCmd.Syntax;

@Syntax(cmd = "d2j-std-zip", syntax = "[options] <zip>", desc = "clean up apk to standard zip")
public class StdApkCmd extends BaseCmd {

    @Opt(opt = "o", longOpt = "output", description = "The output file", argName = "out", required = true)
    private Path output;

    public static void main(String... args) {
        new StdApkCmd().doMain(args);
    }

    @Override
    protected void doCommandLine() throws Exception {
        if (remainingArgs.length < 1) {
            System.err.println("ERROR: no file to process");
            return;
        }

        System.err.printf("fix %s -> %s\n", remainingArgs[0], output);

        byte[] buffer = new byte[1000];
        try (ZipOutputStream zos = new AutoSTOREDZipOutputStream(Files.newOutputStream(output))) {
            byte[] data = Files.readAllBytes(new File(remainingArgs[0]).toPath());
            try(com.googlecode.d2j.util.zip.ZipFile zipFile = new com.googlecode.d2j.util.zip.ZipFile(data)) {
                for (com.googlecode.d2j.util.zip.ZipEntry e : zipFile.entries()) {
                    ZipEntry nEntry = new ZipEntry(e.getName());

                    nEntry.setMethod(e.getMethod() == com.googlecode.d2j.util.zip.ZipEntry.STORED ? ZipEntry.STORED
                            : ZipEntry.DEFLATED);
                    zos.putNextEntry(nEntry);

                    if (!nEntry.isDirectory()) {
                        try (InputStream is = zipFile.getInputStream(e)) {
                            while (true) {
                                int c = is.read(buffer);
                                if (c < 0) {
                                    break;
                                }
                                zos.write(buffer, 0, c);
                            }
                        }
                    }
                    zos.closeEntry();
                }
            }
            zos.finish();
        }
    }
}

```

`dex-tools/src/main/java/com/googlecode/dex2jar/tools/to/Do.java`:

```java
package com.googlecode.dex2jar.tools.to;

public class Do {

    /**
     * @param args
     */
    public static void main(String[] args) {
        System.out.println("This is not support!");
    }

}

```

`dex-tools/src/test/java/com/googlecode/d2j/tools/jar/MethodInvocation.java`:

```java
package com.googlecode.d2j.tools.jar;


public interface MethodInvocation {
    Object proceed() throws Throwable;

    String getMethodOwner();

    String getMethodName();

    String getMethodDesc();

    Object getThis();
    // @Nullale
    Object[] getArguments();
}

```

`dex-tools/src/test/java/com/googlecode/d2j/tools/jar/test/DexWaveTest.java`:

```java
package com.googlecode.d2j.tools.jar.test;

import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.smali.BaksmaliDumpOut;
import com.googlecode.d2j.smali.BaksmaliDumper;
import com.googlecode.d2j.smali.Smali;
import com.googlecode.d2j.tools.jar.DexWeaver;
import org.antlr.runtime.RecognitionException;
import org.junit.Assert;
import org.junit.Test;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.StringWriter;

public class DexWaveTest {
    @Test
    public void testA() throws IOException, RecognitionException {

        DexWeaver iw = new DexWeaver();
        iw.setInvocationInterfaceDesc("Lp;");
        iw.withConfig("d LA;.m()V=LB;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("d LA;.m1()I=LB;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("d LA;.m2()J=LB;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("d LA;.m3(J)V=LB;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("d LA;.m4()V=LB;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("d LA;.m5(J)V=LB;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("d LA;.m6(J)J=LB;.t(Lp;)Ljava/lang/Object;");
        test0(iw, "a");
    }

    @Test
    public void testB() throws IOException, RecognitionException {

        DexWeaver iw = new DexWeaver();
        iw.setInvocationInterfaceDesc("Lp;");
        iw.withConfig("r LB;.b=LX;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("r LB;.c=LX;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("r LB;.d=LX;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("r LB;.e=LX;.t(Lp;)Ljava/lang/Object;");
        iw.withConfig("r LB;.f=LX;.t(Lp;)Ljava/lang/Object;");
        test0(iw, "b");
    }

    private void test0(DexWeaver iw, String prefix) throws IOException, RecognitionException {
        DexClassNode before = Smali.smaliFile2Node(prefix + "-before.smali", getClass()
                .getResourceAsStream("/weave/smali/" + prefix + "-before.smali"));
        DexClassNode expectedAfter = Smali.smaliFile2Node(prefix + "-after.smali", getClass()
                .getResourceAsStream("/weave/smali/" + prefix + "-after.smali"));

        DexFileNode dfn = new DexFileNode();

        before.accept(iw.wrap(dfn));

        assertEqual(expectedAfter, dfn.clzs.get(0));

        DexClassNode expectedGen = Smali.smaliFile2Node(prefix + "-gen.j", getClass()
                .getResourceAsStream("/weave/smali/" + prefix + "-gen.smali"));

        dfn.clzs.clear();
        iw.buildInvocationClz(dfn);

        assertEqual(expectedGen, dfn.clzs.get(0));

    }

    private void assertEqual(DexClassNode expected, DexClassNode actual) throws IOException {
        String stdExpect = toStd(expected);
        String stdActual = toStd(actual);
        Assert.assertEquals(stdExpect, stdActual);
    }

    public static String toStd(DexClassNode expected) throws IOException {
        StringWriter stringWriter = new StringWriter();
        BufferedWriter bufferedWriter = new BufferedWriter(stringWriter);
        BaksmaliDumpOut out = new BaksmaliDumpOut(bufferedWriter);
        final BaksmaliDumper bs = new BaksmaliDumper(true, false);
        bs.baksmaliClass(expected, out);
        bufferedWriter.close();
        return stringWriter.toString();
    }
}

```

`dex-tools/src/test/java/com/googlecode/d2j/tools/jar/test/WaveTest.java`:

```java
package com.googlecode.d2j.tools.jar.test;

import com.googlecode.d2j.asm.LdcOptimizeAdapter;
import com.googlecode.d2j.jasmin.JasminDumper;
import com.googlecode.d2j.jasmin.Jasmins;
import com.googlecode.d2j.tools.jar.InvocationWeaver;

import org.antlr.runtime.RecognitionException;
import org.junit.Assert;
import org.junit.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;

public class WaveTest {
    @Test
    public void testA() throws IOException, RecognitionException {

        InvocationWeaver iw = new InvocationWeaver();
        iw.setInvocationInterfaceDesc("Lp;");
        iw.withConfig("d LA;.m()V=LB;.t(Lp;)Ljava/lang/Object;");

        test0(iw, "a");
    }

    @Test
    public void testB() throws IOException, RecognitionException {

        InvocationWeaver iw = new InvocationWeaver();
        iw.setInvocationInterfaceDesc("Lp;");
        iw.withConfig("r Ljava/util/ArrayList;.size=Lcom/googlecode/d2j/tools/jar/test/WaveTest;.size(Lp;)Ljava/lang/Object;");
        iw.withConfig("r Ljava/util/ArrayList;.add=Lcom/googlecode/d2j/tools/jar/test/WaveTest;.add(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        iw.withConfig("r Ljava/io/PrintStream;.append(Ljava/lang/CharSequence;)Ljava/io/PrintStream;=Lcom/googlecode/d2j/tools/jar/test/WaveTest;.append(Lp;)Ljava/lang/Object;");
        iw.withConfig("r Ljava/io/PrintStream;.println(Ljava/lang/String;)V=Lcom/googlecode/d2j/tools/jar/test/WaveTest;.println(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;");

        test0(iw, "b");
    }

    @Test
    public void testC() throws IOException, RecognitionException {

        InvocationWeaver iw = new InvocationWeaver();
        iw.setInvocationInterfaceDesc("Lp;");
        iw.withConfig("r LT;.a()V=LB;.a(Lp;)Ljava/lang/Object;");
        iw.withConfig("r LT;.b()V=LB;.b(Lp;)V");
        iw.withConfig("r LT;.c()I=LB;.c(Lp;)Ljava/lang/Object;");
        // iw.withConfig("r LT;.d()I=LB;.d(Lp;)V");
        test0(iw, "c");
    }

    private void test0(InvocationWeaver iw, String prefix) throws IOException, RecognitionException {
        ClassNode before = Jasmins
                .parse(prefix + "-before.j", getClass().getResourceAsStream("/weave/" + prefix + "-before.j"));
        ClassNode expectedAfter = Jasmins
                .parse(prefix + "-after.j", getClass().getResourceAsStream("/weave/" + prefix + "-after.j"));
        ClassNode expectedGen = Jasmins
                .parse(prefix + "-gen.j", getClass().getResourceAsStream("/weave/" + prefix + "-gen.j"));

        ClassNode after = new ClassNode();

        before.accept(iw.wrapper(after));

        assertEqual(expectedAfter, after);

        ClassNode gen = new ClassNode();
        iw.buildInvocationClz(LdcOptimizeAdapter.wrap(gen));

        assertEqual(expectedGen, gen);
    }

    private void assertEqual(ClassNode expected, ClassNode actual) throws IOException {
        String stdExpect = toStd(expected);
        String stdActual = toStd(actual);
        Assert.assertEquals(stdExpect, stdActual);
    }

    public static String toStd(ClassNode expected) throws IOException {
        expected.access &= ~Opcodes.ACC_SUPER;
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        expected.accept(LdcOptimizeAdapter.wrap(cw));

        ClassReader cr = new ClassReader(cw.toByteArray());
        ClassNode n = new ClassNode(Opcodes.ASM9);
        cr.accept(n, ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);

        StringWriter stringWriter = new StringWriter();
        new JasminDumper(new PrintWriter(stringWriter, true)).dump(n);
        return stringWriter.toString();
    }

}

```

`dex-tools/src/test/resources/weave/a-after.j`:

```j
.bytecode 50.0
.class A
.super java/lang/Object

.method m()V
    new d2j/gen/MI__000
    dup
    aload 0
    aconst_null
    iconst_0
    invokespecial d2j/gen/MI__000/<init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invokestatic B/t(Lp;)Ljava/lang/Object;
    pop
    return
  .limit locals 1
  .limit stack 5
.end method

.method public static m_A001_CB002(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    aload 0
    checkcast A
    invokevirtual A/m_A001()V
    aconst_null
    areturn
  .limit locals 2
  .limit stack 1
.end method

.method public m_A001()V
    return
  .limit locals 1
  .limit stack 0
.end method

```

`dex-tools/src/test/resources/weave/a-before.j`:

```j
.bytecode 50.0
.class A
.super java/lang/Object

.method m()V
    return
  .limit locals -1
  .limit stack -1
.end method

```

`dex-tools/src/test/resources/weave/a-gen.j`:

```j
.bytecode 50.0
.class public d2j/gen/MI__000
.super java/lang/Object
.implements p

.field private final 'thiz' Ljava/lang/Object;

.field private final 'args' [Ljava/lang/Object;

.field private final 'idx' I

.method public <init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    aload 0
    invokespecial java/lang/Object/<init>()V
    aload 0
    aload 1
    putfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    aload 0
    aload 2
    putfield d2j/gen/MI__000/args [Ljava/lang/Object;
    aload 0
    iload 3
    putfield d2j/gen/MI__000/idx I
    return
  .limit locals 4
  .limit stack 2
.end method

.method public getMethodOwner()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      default : L1
  L0:
    ldc "A"
    areturn
  L1:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getMethodName()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      default : L1
  L0:
    ldc "m"
    areturn
  L1:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getMethodDesc()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      default : L1
  L0:
    ldc "()V"
    areturn
  L1:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getArguments()[Ljava/lang/Object;
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    areturn
  .limit locals 1
  .limit stack 1
.end method

.method public getThis()Ljava/lang/Object;
    aload 0
    getfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    areturn
  .limit locals 1
  .limit stack 1
.end method

.method public proceed()Ljava/lang/Object;
.throws java/lang/Throwable
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      default : L1
  L0:
    aload 0
    getfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    invokestatic A/m_A001_CB002(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    areturn
  L1:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

```

`dex-tools/src/test/resources/weave/b-after.j`:

```j
.bytecode 50.0
.class public com/googlecode/d2j/tools/jar/test/res/Res
.super java/util/ArrayList

.method public <init>()V
    aload 0
    invokespecial java/util/ArrayList/<init>()V
    return
  .limit locals 1
  .limit stack 1
.end method

.method public static varargs main([Ljava/lang/String;)V
    getstatic java/lang/System/out Ljava/io/PrintStream;
    ldc ""
    invokestatic com/googlecode/d2j/tools/jar/test/res/Res/append_A001(Ljava/io/PrintStream;Ljava/lang/CharSequence;)Ljava/io/PrintStream;
    pop
    getstatic java/lang/System/out Ljava/io/PrintStream;
    ldc "test"
    invokestatic com/googlecode/d2j/tools/jar/test/WaveTest/println(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;
    pop
    return
  .limit locals 1
  .limit stack 2
.end method

.method private static synthetic append_A001(Ljava/io/PrintStream;Ljava/lang/CharSequence;)Ljava/io/PrintStream;
    new d2j/gen/MI__000
    dup
    aload 0
    iconst_1
    anewarray java/lang/Object
    dup
    iconst_0
    aload 1
    aastore
    iconst_0
    invokespecial d2j/gen/MI__000/<init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invokestatic com/googlecode/d2j/tools/jar/test/WaveTest/append(Lp;)Ljava/lang/Object;
    checkcast java/io/PrintStream
    areturn
  .limit locals 2
  .limit stack 7
.end method

.method public static append_CB002(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    aload 0
    checkcast java/io/PrintStream
    aload 1
    iconst_0
    aaload
    checkcast java/lang/CharSequence
    invokevirtual java/io/PrintStream/append(Ljava/lang/CharSequence;)Ljava/io/PrintStream;
    areturn
  .limit locals 2
  .limit stack 3
.end method

.method public size()I
    aload 0
    invokestatic com/googlecode/d2j/tools/jar/test/res/Res/size_A003(Ljava/util/ArrayList;)I
    ireturn
  .limit locals 1
  .limit stack 1
.end method

.method private static synthetic size_A003(Ljava/util/ArrayList;)I
    new d2j/gen/MI__000
    dup
    aload 0
    aconst_null
    iconst_1
    invokespecial d2j/gen/MI__000/<init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invokestatic com/googlecode/d2j/tools/jar/test/WaveTest/size(Lp;)Ljava/lang/Object;
    checkcast java/lang/Number
    invokevirtual java/lang/Number/intValue()I
    ireturn
  .limit locals 1
  .limit stack 5
.end method

.method public size_CB004([Ljava/lang/Object;)Ljava/lang/Object;
    aload 0
    invokespecial java/util/ArrayList/size()I
    invokestatic java/lang/Integer/valueOf(I)Ljava/lang/Integer;
    areturn
  .limit locals 2
  .limit stack 1
.end method

.method public add(Ljava/lang/Object;)Z
    aload 0
    aload 1
    invokestatic com/googlecode/d2j/tools/jar/test/WaveTest/add(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    checkcast java/lang/Boolean
    invokevirtual java/lang/Boolean/booleanValue()Z
    ireturn
  .limit locals 2
  .limit stack 2
.end method

```

`dex-tools/src/test/resources/weave/b-before.j`:

```j
.bytecode 50.0
.class public super com/googlecode/d2j/tools/jar/test/res/Res
.super java/util/ArrayList

.method public <init>()V
    aload 0
    invokespecial java/util/ArrayList/<init>()V
    return
  .limit locals 1
  .limit stack 1
.end method

.method public static varargs main([Ljava/lang/String;)V
    getstatic java/lang/System/out Ljava/io/PrintStream;
    ldc ""
    invokevirtual java/io/PrintStream/append(Ljava/lang/CharSequence;)Ljava/io/PrintStream;
    pop
    getstatic java/lang/System/out Ljava/io/PrintStream;
    ldc "test"
    invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
    return
  .limit locals 1
  .limit stack 2
.end method

.method public size()I
    aload 0
    invokespecial java/util/ArrayList/size()I
    ireturn
  .limit locals 1
  .limit stack 1
.end method

.method public add(Ljava/lang/Object;)Z
    aload 0
    aload 1
    invokespecial java/util/ArrayList/add(Ljava/lang/Object;)Z
    ireturn
  .limit locals 2
  .limit stack 2
.end method

```

`dex-tools/src/test/resources/weave/b-gen.j`:

```j
.bytecode 50.0
.class public d2j/gen/MI__000
.super java/lang/Object
.implements p

.field private final 'thiz' Ljava/lang/Object;

.field private final 'args' [Ljava/lang/Object;

.field private final 'idx' I

.method public <init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    aload 0
    invokespecial java/lang/Object/<init>()V
    aload 0
    aload 1
    putfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    aload 0
    aload 2
    putfield d2j/gen/MI__000/args [Ljava/lang/Object;
    aload 0
    iload 3
    putfield d2j/gen/MI__000/idx I
    return
  .limit locals 4
  .limit stack 2
.end method

.method public getMethodOwner()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      L1
      default : L2
  L0:
    ldc "java/io/PrintStream"
    areturn
  L1:
    ldc "java/util/ArrayList"
    areturn
  L2:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getMethodName()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      L1
      default : L2
  L0:
    ldc "append"
    areturn
  L1:
    ldc "size"
    areturn
  L2:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getMethodDesc()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      L1
      default : L2
  L1:
    ldc "()I"
    areturn
  L0:
    ldc "(Ljava/lang/CharSequence;)Ljava/io/PrintStream;"
    areturn
  L2:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getArguments()[Ljava/lang/Object;
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    areturn
  .limit locals 1
  .limit stack 1
.end method

.method public getThis()Ljava/lang/Object;
    aload 0
    getfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    areturn
  .limit locals 1
  .limit stack 1
.end method

.method public proceed()Ljava/lang/Object;
.throws java/lang/Throwable
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      L1
      default : L2
  L0:
    aload 0
    getfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    invokestatic com/googlecode/d2j/tools/jar/test/res/Res/append_CB002(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    areturn
  L1:
    aload 0
    getfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    checkcast com/googlecode/d2j/tools/jar/test/res/Res
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    invokevirtual com/googlecode/d2j/tools/jar/test/res/Res/size_CB004([Ljava/lang/Object;)Ljava/lang/Object;
    areturn
  L2:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

```

`dex-tools/src/test/resources/weave/c-after.j`:

```j
.bytecode 50.0
.class A
.super java/lang/Object

.method m()V
    invokestatic A/a_A001()V
    invokestatic A/b_A003()V
    invokestatic A/c_A005()I
    pop
    invokestatic T/d()I
    pop
    return
  .limit locals 1
  .limit stack 1
.end method

.method private static synthetic a_A001()V
    new d2j/gen/MI__000
    dup
    aconst_null
    aconst_null
    iconst_0
    invokespecial d2j/gen/MI__000/<init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invokestatic B/a(Lp;)Ljava/lang/Object;
    pop
    return
  .limit locals 0
  .limit stack 5
.end method

.method public static a_CB002([Ljava/lang/Object;)Ljava/lang/Object;
    invokestatic T/a()V
    aconst_null
    areturn
  .limit locals 1
  .limit stack 1
.end method

.method private static synthetic b_A003()V
    new d2j/gen/MI__000
    dup
    aconst_null
    aconst_null
    iconst_1
    invokespecial d2j/gen/MI__000/<init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invokestatic B/b(Lp;)V
    return
  .limit locals 0
  .limit stack 5
.end method

.method public static b_CB004([Ljava/lang/Object;)Ljava/lang/Object;
    invokestatic T/b()V
    aconst_null
    areturn
  .limit locals 1
  .limit stack 1
.end method

.method private static synthetic c_A005()I
    new d2j/gen/MI__000
    dup
    aconst_null
    aconst_null
    iconst_2
    invokespecial d2j/gen/MI__000/<init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invokestatic B/c(Lp;)Ljava/lang/Object;
    checkcast java/lang/Number
    invokevirtual java/lang/Number/intValue()I
    ireturn
  .limit locals 0
  .limit stack 5
.end method

.method public static c_CB006([Ljava/lang/Object;)Ljava/lang/Object;
    invokestatic T/c()I
    invokestatic java/lang/Integer/valueOf(I)Ljava/lang/Integer;
    areturn
  .limit locals 1
  .limit stack 1
.end method

```

`dex-tools/src/test/resources/weave/c-before.j`:

```j
.bytecode 50.0
.class A
.super java/lang/Object

.method m()V
    invokestatic T/a()V
    invokestatic T/b()V
    invokestatic T/c()I
    pop
    invokestatic T/d()I
    pop
    return
  .limit locals -1
  .limit stack -1
.end method

```

`dex-tools/src/test/resources/weave/c-gen.j`:

```j
.bytecode 50.0
.class public d2j/gen/MI__000
.super java/lang/Object
.implements p

.field private final 'thiz' Ljava/lang/Object;

.field private final 'args' [Ljava/lang/Object;

.field private final 'idx' I

.method public <init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    aload 0
    invokespecial java/lang/Object/<init>()V
    aload 0
    aload 1
    putfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    aload 0
    aload 2
    putfield d2j/gen/MI__000/args [Ljava/lang/Object;
    aload 0
    iload 3
    putfield d2j/gen/MI__000/idx I
    return
  .limit locals 4
  .limit stack 2
.end method

.method public getMethodOwner()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      L0
      L0
      default : L1
  L0:
    ldc "T"
    areturn
  L1:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getMethodName()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      L1
      L2
      default : L3
  L0:
    ldc "a"
    areturn
  L1:
    ldc "b"
    areturn
  L2:
    ldc "c"
    areturn
  L3:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getMethodDesc()Ljava/lang/String;
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      L0
      L1
      default : L2
  L1:
    ldc "()I"
    areturn
  L0:
    ldc "()V"
    areturn
  L2:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

.method public getArguments()[Ljava/lang/Object;
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    areturn
  .limit locals 1
  .limit stack 1
.end method

.method public getThis()Ljava/lang/Object;
    aload 0
    getfield d2j/gen/MI__000/thiz Ljava/lang/Object;
    areturn
  .limit locals 1
  .limit stack 1
.end method

.method public proceed()Ljava/lang/Object;
.throws java/lang/Throwable
    aload 0
    getfield d2j/gen/MI__000/idx I
    tableswitch 0
      L0
      L1
      L2
      default : L3
  L0:
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    invokestatic A/a_CB002([Ljava/lang/Object;)Ljava/lang/Object;
    areturn
  L1:
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    invokestatic A/b_CB004([Ljava/lang/Object;)Ljava/lang/Object;
    areturn
  L2:
    aload 0
    getfield d2j/gen/MI__000/args [Ljava/lang/Object;
    invokestatic A/c_CB006([Ljava/lang/Object;)Ljava/lang/Object;
    areturn
  L3:
    new java/lang/RuntimeException
    dup
    ldc "invalid idx"
    invokespecial java/lang/RuntimeException/<init>(Ljava/lang/String;)V
    athrow
  .limit locals 1
  .limit stack 3
.end method

```

`dex-tools/src/test/resources/weave/smali/a-after.smali`:

```smali
.class LA;
.super Ljava/lang/Object;

.method static m()V
    .registers 4
    const/4 v0, 0
    const/4 v1, 0
    const v2, 0
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LB;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static m_A001_CB002([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 2
    invoke-static/range { }, LA;->m_A001()V
    const v0, 0
    return-object v0
.end method

.method public static m_A001()V
    .registers 0
    invoke-static { }, LB;->b()V
    return-void
.end method

.method static m1()I
    .registers 4
    const/4 v0, 0
    const/4 v1, 0
    const v2, 1
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LB;->t(Lp;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Integer;
    invoke-virtual/range { v0 .. v0 }, Ljava/lang/Integer;->intValue()I
    move-result v0
    return v0
.end method

.method public static m1_A003_CB004([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 2
    invoke-static/range { }, LA;->m1_A003()I
    move-result v0
    invoke-static/range { v0 .. v0 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v0
    return-object v0
.end method

.method public static m1_A003()I
    .registers 1
    invoke-static { }, LB;->b()V
    const v0, 0
    return v0
.end method

.method static m2()J
    .registers 4
    const/4 v0, 0
    const/4 v1, 0
    const v2, 2
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LB;->t(Lp;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Long;
    invoke-virtual/range { v0 .. v0 }, Ljava/lang/Long;->longValue()J
    move-result-wide v0
    return-wide v0
.end method

.method public static m2_A005_CB006([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 2
    invoke-static/range { }, LA;->m2_A005()J
    move-result-wide v0
    invoke-static/range { v0 .. p0 }, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;
    move-result-object v0
    return-object v0
.end method

.method public static m2_A005()J
    .registers 2
    invoke-static { }, LB;->b()V
    const-wide v0, 0
    return-wide v0
.end method

.method static m3(J)V
    .registers 6
    const/4 v0, 0
    const v1, 1
    new-array v1, v1, [Ljava/lang/Object;
    const v2, 0
    invoke-static/range { p0 .. p1 }, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;
    move-result-object v3
    aput-object v3, v1, v2
    const v2, 3
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LB;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static m3_A007_CB008([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 4
    const v0, 0
    aget-object v1, p0, v0
    check-cast v1, Ljava/lang/Long;
    invoke-virtual/range { v1 .. v1 }, Ljava/lang/Long;->longValue()J
    move-result-wide v1
    invoke-static/range { v1 .. v2 }, LA;->m3_A007(J)V
    const v0, 0
    return-object v0
.end method

.method public static m3_A007(J)V
    .registers 2
    invoke-static { }, LB;->b()V
    return-void
.end method

.method m4()V
    .registers 5
    move-object v0, p0
    const/4 v1, 0
    const v2, 4
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LB;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static m4_A009_CB010(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    .registers 3
    check-cast p0, LA;
    invoke-virtual/range { p0 .. p0 }, LA;->m4_A009()V
    const v0, 0
    return-object v0
.end method

.method public m4_A009()V
    .registers 1
    invoke-static { }, LB;->b()V
    return-void
.end method

.method m5(J)V
    .registers 7
    move-object v0, p0
    const v1, 1
    new-array v1, v1, [Ljava/lang/Object;
    const v2, 0
    invoke-static/range { p1 .. p2 }, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;
    move-result-object v3
    aput-object v3, v1, v2
    const v2, 5
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LB;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static m5_A011_CB012(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    .registers 5
    move-object v1, p0
    check-cast v1, LA;
    const v0, 0
    aget-object v2, p1, v0
    check-cast v2, Ljava/lang/Long;
    invoke-virtual/range { v2 .. v2 }, Ljava/lang/Long;->longValue()J
    move-result-wide v2
    invoke-virtual/range { v1 .. p0 }, LA;->m5_A011(J)V
    const v0, 0
    return-object v0
.end method

.method public m5_A011(J)V
    .registers 3
    invoke-static { }, LB;->b()V
    return-void
.end method

.method m6(J)J
    .registers 7
    move-object v0, p0
    const v1, 1
    new-array v1, v1, [Ljava/lang/Object;
    const v2, 0
    invoke-static/range { p1 .. p2 }, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;
    move-result-object v3
    aput-object v3, v1, v2
    const v2, 6
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LB;->t(Lp;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Long;
    invoke-virtual/range { v0 .. v0 }, Ljava/lang/Long;->longValue()J
    move-result-wide v0
    return-wide v0
.end method

.method public static m6_A013_CB014(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    .registers 5
    move-object v1, p0
    check-cast v1, LA;
    const v0, 0
    aget-object v2, p1, v0
    check-cast v2, Ljava/lang/Long;
    invoke-virtual/range { v2 .. v2 }, Ljava/lang/Long;->longValue()J
    move-result-wide v2
    invoke-virtual/range { v1 .. p0 }, LA;->m6_A013(J)J
    move-result-wide v0
    invoke-static/range { v0 .. v1 }, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;
    move-result-object v0
    return-object v0
.end method

.method public m6_A013(J)J
    .registers 3
    invoke-static { }, LB;->b()V
    return-wide p1
.end method

```

`dex-tools/src/test/resources/weave/smali/a-before.smali`:

```smali
.class LA;
.super Ljava/lang/Object;

.method static m()V
.registers 0
    invoke-static {}, LB;->b()V
    return-void
.end method

.method static m1()I
.registers 1
    invoke-static {}, LB;->b()V
    const v0, 0
    return v0
.end method

.method static m2()J
.registers 2
    invoke-static {}, LB;->b()V
    const-wide v0,0
    return-wide v0
.end method

.method static m3(J)V
.registers 2
    invoke-static {}, LB;->b()V
    return-void
.end method

.method m4()V
.registers 1
    invoke-static {}, LB;->b()V
    return-void
.end method

.method m5(J)V
.registers 3
    invoke-static {}, LB;->b()V
    return-void
.end method

.method m6(J)J
.registers 3
    invoke-static {}, LB;->b()V
    return-wide p1
.end method

```

`dex-tools/src/test/resources/weave/smali/a-gen.smali`:

```smali
.class public Ld2j/gen/MI__000;
.super Ljava/lang/Object;
.implements Lp;

.field private final thiz:Ljava/lang/Object;

.field private final args:[Ljava/lang/Object;

.field private final idx:I

.method public constructor <init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    .registers 4
    iput-object p1, p0, Ld2j/gen/MI__000;->thiz:Ljava/lang/Object;
    iput-object p2, p0, Ld2j/gen/MI__000;->args:[Ljava/lang/Object;
    iput p3, p0, Ld2j/gen/MI__000;->idx:I
    return-void
.end method

.method public getMethodOwner()Ljava/lang/String;
    .registers 3
    iget v0, p0, Ld2j/gen/MI__000;->idx:I
    packed-switch v0, :L1
    new-instance v0, Ljava/lang/RuntimeException;
    const-string v1, "invalid idx"
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
    :L0
    const-string v0, "A"
    return-object v0
    :L1
    .packed-switch 0
        :L0
        :L0
        :L0
        :L0
        :L0
        :L0
        :L0
    .end packed-switch
.end method

.method public getMethodName()Ljava/lang/String;
    .registers 3
    iget v0, p0, Ld2j/gen/MI__000;->idx:I
    packed-switch v0, :L7
    new-instance v0, Ljava/lang/RuntimeException;
    const-string v1, "invalid idx"
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
    :L0
    const-string v0, "m"
    return-object v0
    :L1
    const-string v0, "m1"
    return-object v0
    :L2
    const-string v0, "m2"
    return-object v0
    :L3
    const-string v0, "m3"
    return-object v0
    :L4
    const-string v0, "m4"
    return-object v0
    :L5
    const-string v0, "m5"
    return-object v0
    :L6
    const-string v0, "m6"
    return-object v0
    :L7
    .packed-switch 0
        :L0
        :L1
        :L2
        :L3
        :L4
        :L5
        :L6
    .end packed-switch
.end method

.method public getMethodDesc()Ljava/lang/String;
    .registers 3
    iget v0, p0, Ld2j/gen/MI__000;->idx:I
    packed-switch v0, :L5
    new-instance v0, Ljava/lang/RuntimeException;
    const-string v1, "invalid idx"
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
    :L0
    const-string v0, "()I"
    return-object v0
    :L1
    const-string v0, "()J"
    return-object v0
    :L2
    const-string v0, "()V"
    return-object v0
    :L3
    const-string v0, "(J)J"
    return-object v0
    :L4
    const-string v0, "(J)V"
    return-object v0
    :L5
    .packed-switch 0
        :L2
        :L0
        :L1
        :L4
        :L2
        :L4
        :L3
    .end packed-switch
.end method

.method public getArguments()[Ljava/lang/Object;
    .registers 2
    iget v0, p0, Ld2j/gen/MI__000;->args:[Ljava/lang/Object;
    return-object v0
.end method

.method public getThis()Ljava/lang/Object;
    .registers 2
    iget v0, p0, Ld2j/gen/MI__000;->thiz:Ljava/lang/Object;
    return-object v0
.end method

.method public proceed()Ljava/lang/Object;
    .registers 4
    iget v0, p0, Ld2j/gen/MI__000;->thiz:Ljava/lang/Object;
    iget v1, p0, Ld2j/gen/MI__000;->args:[Ljava/lang/Object;
    iget v2, p0, Ld2j/gen/MI__000;->idx:I
    packed-switch v2, :L7
    new-instance v0, Ljava/lang/RuntimeException;
    const-string v1, "invalid idx"
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
    :L0
    invoke-static { v1 }, LA;->m_A001_CB002([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L1
    invoke-static { v1 }, LA;->m1_A003_CB004([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L2
    invoke-static { v1 }, LA;->m2_A005_CB006([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L3
    invoke-static { v1 }, LA;->m3_A007_CB008([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L4
    invoke-static { v0, v1 }, LA;->m4_A009_CB010(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L5
    invoke-static { v0, v1 }, LA;->m5_A011_CB012(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L6
    invoke-static { v0, v1 }, LA;->m6_A013_CB014(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L7
    .packed-switch 0
        :L0
        :L1
        :L2
        :L3
        :L4
        :L5
        :L6
    .end packed-switch
.end method

```

`dex-tools/src/test/resources/weave/smali/b-after.smali`:

```smali
.class LA;
.super Ljava/lang/Object;

.method static m()V
    .registers 2
    invoke-static { }, LA;->b_A001()V
    invoke-static { }, LA;->b_A001()V
    const v0, 1
    invoke-static { v0 }, LA;->c_A003(I)V
    const-wide v0, 0
    invoke-static { v0, v1 }, LA;->d_A005(J)V
    return-void
.end method

.method private static b_A001()V
    .registers 4
    const/4 v0, 0
    const/4 v1, 0
    const v2, 0
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LX;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static b_CB002([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 2
    invoke-static { }, LB;->b()V
    const v0, 0
    return-object v0
.end method

.method private static c_A003(I)V
    .registers 5
    const/4 v0, 0
    const v1, 1
    new-array v1, v1, [Ljava/lang/Object;
    const v2, 0
    invoke-static/range { p0 .. p0 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v3
    aput-object v3, v1, v2
    const v2, 1
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LX;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static c_CB004([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 3
    const v0, 0
    aget-object v1, p0, v0
    check-cast v1, Ljava/lang/Integer;
    invoke-virtual/range { v1 .. v1 }, Ljava/lang/Integer;->intValue()I
    move-result v1
    invoke-static { v1 }, LB;->c(I)V
    const v0, 0
    return-object v0
.end method

.method private static d_A005(J)V
    .registers 6
    const/4 v0, 0
    const v1, 1
    new-array v1, v1, [Ljava/lang/Object;
    const v2, 0
    invoke-static/range { p0 .. p1 }, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;
    move-result-object v3
    aput-object v3, v1, v2
    const v2, 2
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LX;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static d_CB006([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 4
    const v0, 0
    aget-object v1, p0, v0
    check-cast v1, Ljava/lang/Long;
    invoke-virtual/range { v1 .. v1 }, Ljava/lang/Long;->longValue()J
    move-result-wide v1
    invoke-static { v1, v2 }, LB;->d(J)V
    const v0, 0
    return-object v0
.end method

.method m()V
    .registers 3
    const v0, 0
    invoke-static { p0 }, LA;->e_A007(LB;)V
    invoke-static { p0 }, LA;->f_A009(LB;)V
    invoke-static { p0, v0 }, LA;->e_A011(LB;I)V
    invoke-static { p0, v0 }, LA;->f_A013(LB;I)V
    return-void
.end method

.method private static e_A007(LB;)V
    .registers 5
    move-object v0, p0
    const/4 v1, 0
    const v2, 3
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LX;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static e_CB008(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    .registers 3
    check-cast p0, LB;
    invoke-virtual { p0 }, LB;->e()V
    const v0, 0
    return-object v0
.end method

.method private static f_A009(LB;)V
    .registers 5
    move-object v0, p0
    const/4 v1, 0
    const v2, 4
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LX;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public f_CB010([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 3
    invoke-super { p0 }, LB;->f()V
    const v0, 0
    return-object v0
.end method

.method private static e_A011(LB;I)V
    .registers 6
    move-object v0, p0
    const v1, 1
    new-array v1, v1, [Ljava/lang/Object;
    const v2, 0
    invoke-static/range { p1 .. p1 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v3
    aput-object v3, v1, v2
    const v2, 5
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LX;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public static e_CB012(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    .registers 4
    move-object v1, p0
    check-cast v1, LB;
    const v0, 0
    aget-object p0, p1, v0
    check-cast p0, Ljava/lang/Integer;
    invoke-virtual/range { p0 .. p0 }, Ljava/lang/Integer;->intValue()I
    move-result p0
    invoke-virtual { v1, p0 }, LB;->e(I)V
    const v0, 0
    return-object v0
.end method

.method private static f_A013(LB;I)V
    .registers 6
    move-object v0, p0
    const v1, 1
    new-array v1, v1, [Ljava/lang/Object;
    const v2, 0
    invoke-static/range { p1 .. p1 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v3
    aput-object v3, v1, v2
    const v2, 6
    new-instance v3, Ld2j/gen/MI__000;
    invoke-direct { v3, v0, v1, v2 }, Ld2j/gen/MI__000;-><init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    invoke-static { v3 }, LX;->t(Lp;)Ljava/lang/Object;
    return-void
.end method

.method public f_CB014([Ljava/lang/Object;)Ljava/lang/Object;
    .registers 4
    move-object v1, p0
    const v0, 0
    aget-object p0, p1, v0
    check-cast p0, Ljava/lang/Integer;
    invoke-virtual/range { p0 .. p0 }, Ljava/lang/Integer;->intValue()I
    move-result p0
    invoke-super { v1, p0 }, LB;->f(I)V
    const v0, 0
    return-object v0
.end method

```

`dex-tools/src/test/resources/weave/smali/b-before.smali`:

```smali
.class LA;
.super Ljava/lang/Object;

.method static m()V
.registers 2
    invoke-static {}, LB;->b()V
    invoke-static {}, LB;->b()V
    const v0, 1
    invoke-static {v0}, LB;->c(I)V
    const-wide v0, 0
    invoke-static {v0,v1}, LB;->d(J)V
    return-void
.end method

.method m()V
.registers 3
    const v0, 0
    invoke-virtual {v2}, LB;->e()V
    invoke-super {v2}, LB;->f()V
    invoke-virtual {v2,v0}, LB;->e(I)V
    invoke-super {v2,v0}, LB;->f(I)V
    return-void
.end method

```

`dex-tools/src/test/resources/weave/smali/b-gen.smali`:

```smali
.class public Ld2j/gen/MI__000;
.super Ljava/lang/Object;
.implements Lp;

.field private final thiz:Ljava/lang/Object;

.field private final args:[Ljava/lang/Object;

.field private final idx:I

.method public constructor <init>(Ljava/lang/Object;[Ljava/lang/Object;I)V
    .registers 4
    iput-object p1, p0, Ld2j/gen/MI__000;->thiz:Ljava/lang/Object;
    iput-object p2, p0, Ld2j/gen/MI__000;->args:[Ljava/lang/Object;
    iput p3, p0, Ld2j/gen/MI__000;->idx:I
    return-void
.end method

.method public getMethodOwner()Ljava/lang/String;
    .registers 3
    iget v0, p0, Ld2j/gen/MI__000;->idx:I
    packed-switch v0, :L1
    new-instance v0, Ljava/lang/RuntimeException;
    const-string v1, "invalid idx"
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
    :L0
    const-string v0, "B"
    return-object v0
    :L1
    .packed-switch 0
        :L0
        :L0
        :L0
        :L0
        :L0
        :L0
        :L0
    .end packed-switch
.end method

.method public getMethodName()Ljava/lang/String;
    .registers 3
    iget v0, p0, Ld2j/gen/MI__000;->idx:I
    packed-switch v0, :L5
    new-instance v0, Ljava/lang/RuntimeException;
    const-string v1, "invalid idx"
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
    :L0
    const-string v0, "b"
    return-object v0
    :L1
    const-string v0, "c"
    return-object v0
    :L2
    const-string v0, "d"
    return-object v0
    :L3
    const-string v0, "e"
    return-object v0
    :L4
    const-string v0, "f"
    return-object v0
    :L5
    .packed-switch 0
        :L0
        :L1
        :L2
        :L3
        :L4
        :L3
        :L4
    .end packed-switch
.end method

.method public getMethodDesc()Ljava/lang/String;
    .registers 3
    iget v0, p0, Ld2j/gen/MI__000;->idx:I
    packed-switch v0, :L3
    new-instance v0, Ljava/lang/RuntimeException;
    const-string v1, "invalid idx"
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
    :L0
    const-string v0, "()V"
    return-object v0
    :L1
    const-string v0, "(I)V"
    return-object v0
    :L2
    const-string v0, "(J)V"
    return-object v0
    :L3
    .packed-switch 0
        :L0
        :L1
        :L2
        :L0
        :L0
        :L1
        :L1
    .end packed-switch
.end method

.method public getArguments()[Ljava/lang/Object;
    .registers 2
    iget v0, p0, Ld2j/gen/MI__000;->args:[Ljava/lang/Object;
    return-object v0
.end method

.method public getThis()Ljava/lang/Object;
    .registers 2
    iget v0, p0, Ld2j/gen/MI__000;->thiz:Ljava/lang/Object;
    return-object v0
.end method

.method public proceed()Ljava/lang/Object;
    .registers 4
    iget v0, p0, Ld2j/gen/MI__000;->thiz:Ljava/lang/Object;
    iget v1, p0, Ld2j/gen/MI__000;->args:[Ljava/lang/Object;
    iget v2, p0, Ld2j/gen/MI__000;->idx:I
    packed-switch v2, :L7
    new-instance v0, Ljava/lang/RuntimeException;
    const-string v1, "invalid idx"
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
    :L0
    invoke-static { v1 }, LB;->b_CB002([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L1
    invoke-static { v1 }, LB;->c_CB004([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L2
    invoke-static { v1 }, LB;->d_CB006([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L3
    invoke-static { v0, v1 }, LB;->e_CB008(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L4
    check-cast v0, LB;
    invoke-virtual { v0, v1 }, LB;->f_CB010([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L5
    invoke-static { v0, v1 }, LB;->e_CB012(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L6
    check-cast v0, LB;
    invoke-virtual { v0, v1 }, LB;->f_CB014([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    return-object v0
    :L7
    .packed-switch 0
        :L0
        :L1
        :L2
        :L3
        :L4
        :L5
        :L6
    .end packed-switch
.end method

```

`dex-translator/build.gradle`:

```gradle
description = 'Dex Translator'

dependencies {
  compile project(':dex-reader')
  compile project(':dex-ir')
  compile project(':d2j-base-cmd')
  implementation group: 'org.ow2.asm', name: 'asm-tree', version: '9.5'
  implementation group: 'org.ow2.asm', name: 'asm-util', version: '9.5'
  implementation group: 'org.ow2.asm', name: 'asm-commons', version: '9.5'
  testCompile project(':d2j-smali')
  testCompile project(':d2j-jasmin')
}


```

`dex-translator/src/main/java/com/googlecode/d2j/asm/LdcOptimizeAdapter.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.asm;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class LdcOptimizeAdapter extends MethodVisitor implements Opcodes {

    /**
     * @param mv
     */
    public LdcOptimizeAdapter(MethodVisitor mv) {
        super(ASM9, mv);
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.objectweb.asm.MethodAdapter#visitLdcInsn(java.lang.Object)
     */
    @Override
    public void visitLdcInsn(Object cst) {
        if (cst == null) {
            this.visitInsn(ACONST_NULL);
        } else if (cst instanceof Integer) {
            int value = (Integer) cst;
            if (value >= -1 && value <= 5) {
                super.visitInsn(ICONST_0 + value);
            } else if (value <= Byte.MAX_VALUE && value >= Byte.MIN_VALUE) {
                super.visitIntInsn(BIPUSH, value);
            } else if (value <= Short.MAX_VALUE && value >= Short.MIN_VALUE) {
                super.visitIntInsn(SIPUSH, value);
            } else {
                super.visitLdcInsn(cst);
            }
        } else if (cst instanceof Long) {
            long value = (Long) cst;
            if (value == 0L || value == 1L) {
                super.visitInsn(LCONST_0 + ((int) value));
            } else {
                super.visitLdcInsn(cst);
            }
        } else if (cst instanceof Float) {
            float value = (Float) cst;
            if (value == 0.0F) {
                super.visitInsn(FCONST_0);
            } else if (value == 1.0F) {
                super.visitInsn(FCONST_1);
            } else if (value == 2.0F) {
                super.visitInsn(FCONST_2);
            } else {
                super.visitLdcInsn(cst);
            }
        } else if (cst instanceof Double) {
            double value = (Double) cst;
            if (value == 0.0D) {
                super.visitInsn(DCONST_0);
            } else if (value == 1.0D) {
                super.visitInsn(DCONST_1);
            } else {
                super.visitLdcInsn(cst);
            }
        } else if(cst instanceof Type){
            Type t= (Type) cst;
            switch (t.getSort()) {
                case Type.BOOLEAN:
                    super.visitFieldInsn(GETSTATIC, "java/lang/Boolean", "TYPE", "Ljava/lang/Class;");
                    break;
                case Type.BYTE:
                    super.visitFieldInsn(GETSTATIC, "java/lang/Byte", "TYPE", "Ljava/lang/Class;");
                    break;
                case Type.CHAR:
                    super.visitFieldInsn(GETSTATIC, "java/lang/Character", "TYPE", "Ljava/lang/Class;");
                    break;
                case Type.DOUBLE:
                    super.visitFieldInsn(GETSTATIC, "java/lang/Double", "TYPE", "Ljava/lang/Class;");
                    break;
                case Type.FLOAT:
                    super.visitFieldInsn(GETSTATIC, "java/lang/Float", "TYPE", "Ljava/lang/Class;");
                    break;
                case Type.INT:
                    super.visitFieldInsn(GETSTATIC, "java/lang/Integer", "TYPE", "Ljava/lang/Class;");
                    break;
                case Type.LONG:
                    super.visitFieldInsn(GETSTATIC, "java/lang/Long", "TYPE", "Ljava/lang/Class;");
                    break;
                case Type.SHORT:
                    super.visitFieldInsn(GETSTATIC, "java/lang/Short", "TYPE", "Ljava/lang/Class;");
                    break;
                default:
                    super.visitLdcInsn(cst);
            }
        } else {
            super.visitLdcInsn(cst);
        }
    }

    public static MethodVisitor wrap(MethodVisitor mv) {
        return mv == null ? null : new LdcOptimizeAdapter(mv);
    }

    public static ClassVisitor wrap(ClassVisitor cv) {
        return cv == null ? null : new ClassVisitor(ASM9, cv) {
            @Override
            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
                return wrap(super.visitMethod(access, name, desc, signature, exceptions));
            }
        };
    }

}

```

`dex-translator/src/main/java/com/googlecode/d2j/converter/Dex2IRConverter.java`:

```java
package com.googlecode.d2j.converter;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.DexType;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.MethodHandle;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.node.DexCodeNode;
import com.googlecode.d2j.node.TryCatchNode;
import com.googlecode.d2j.node.analysis.DvmFrame;
import com.googlecode.d2j.node.analysis.DvmInterpreter;
import com.googlecode.d2j.node.insn.*;
import com.googlecode.d2j.reader.Op;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.TypeClass;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.*;
import com.googlecode.dex2jar.ir.ts.UniqueQueue;

import java.util.*;

import static com.googlecode.dex2jar.ir.expr.Exprs.*;
import static com.googlecode.dex2jar.ir.stmt.Stmts.*;

public class Dex2IRConverter {
    Map<DexLabel, DexLabelStmtNode> labelMap = new HashMap<>();
    List<DexStmtNode> insnList;
    int[] parentCount;
    IrMethod target;
    DexCodeNode dexCodeNode;
    List<Stmt> preEmit = new ArrayList<>();
    List<Stmt> currentEmit;
    Map<DexLabel, LabelStmt> map = new HashMap<>();
    private Dex2IrFrame[] frames;
    private ArrayList<Stmt>[] emitStmts;
    boolean initAllToZero = true;

    static int sizeofType(String s) {
        char t = s.charAt(0);
        if (t == 'J' || t == 'D') {
            return 2;
        } else {
            return 1;
        }
    }

    static class Dex2IrFrame extends DvmFrame<DvmValue> {
        public Dex2IrFrame(int totalRegister) {
            super(totalRegister);
        }
    }

    static int methodArgCount(String[] args) {
        int i = 0;
        for (String s : args) {
            i += sizeofType(s);
        }
        return i;
    }

    public IrMethod convert(boolean isStatic, Method method, DexCodeNode dexCodeNode) {
        this.dexCodeNode = dexCodeNode;
        IrMethod irMethod = new IrMethod();
        irMethod.args = method.getParameterTypes();
        irMethod.ret = method.getReturnType();
        irMethod.owner = method.getOwner();
        irMethod.name = method.getName();
        irMethod.isStatic = isStatic;
        target = irMethod;


        insnList = dexCodeNode.stmts;
        for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode stmtNode = insnList.get(i);
            stmtNode.__index = i;
            if (stmtNode instanceof DexLabelStmtNode) {
                DexLabelStmtNode dexLabelStmtNode = (DexLabelStmtNode) stmtNode;
                labelMap.put(dexLabelStmtNode.label, dexLabelStmtNode);
            }
        }

        fixExceptionHandlers();

        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];
        initParentCount(parentCount);

        BitSet handlers = new BitSet(insnList.size());
        initExceptionHandlers(dexCodeNode, exBranch, handlers);

        DvmInterpreter<DvmValue> interpreter = buildInterpreter();
        frames = new Dex2IrFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);


        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            DexStmtNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p instanceof DexLabelStmtNode) {
                    stmts.add(getLabel(((DexLabelStmtNode) p).label));
                }
            }
        }
        emitStmts = null;


        // https://github.com/pxb1988/dex2jar/issues/501
        // too many Object put to Q, make the object unique in Q
        Queue<DvmValue> queue = new UniqueQueue<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            Dex2IrFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addToQueue(queue, v);
                }
            }

        }

        while (!queue.isEmpty()) {
            DvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (DvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            Dex2IrFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                DexStmtNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel(((DexLabelStmtNode) p).label);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getTotalRegisters(); j++) {
                    DvmValue v = frame.getReg(j);
                    addPhi(v, phiValues, phis);
                }

                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;
    }

    /**
     * issue 63
     * <pre>
     * L1:
     *    STMTs
     * L2:
     *    RETURN
     * L1~L2 > L2 Exception
     * </pre>
     * <p/>
     * fix to
     * <p/>
     * <pre>
     * L1:
     *    STMTs
     * L2:
     *    RETURN
     * L3:
     *    goto L2
     * L1~L2 > L3 Exception
     * </pre>
     */
    private void fixExceptionHandlers() {
        if (dexCodeNode.tryStmts == null) {
            return;
        }
        Queue<Integer> q = new LinkedList<>();
        Set<Integer> handlers = new TreeSet<>();
        for (TryCatchNode tcb : dexCodeNode.tryStmts) {
            for (DexLabel h : tcb.handler) {
                int index = indexOf(h);
                q.add(index + 1); // add the next insn after label
                handlers.add(index);
            }
        }

        q.add(0);

        Map<Integer, DexLabel> needChange = new HashMap<>();

        BitSet access = new BitSet(insnList.size());
        while (!q.isEmpty()) {
            Integer key = q.poll();
            int index = key;
            if (access.get(index)) {
                continue;
            } else {
                access.set(index);
            }
            if (handlers.contains(key)) { // the cfg goes to a exception handler
                needChange.put(key, null);
            }
            DexStmtNode node = insnList.get(key);
            if (node.op == null) {
                q.add(index + 1);
            } else {
                Op op = node.op;
                if (op.canContinue()) {
                    q.add(index + 1);
                }
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) node;
                    q.add(indexOf(jump.label));
                }
                if (op.canSwitch()) {
                    for (DexLabel dexLabel : ((BaseSwitchStmtNode) node).labels) {
                        q.add(indexOf(dexLabel));
                    }
                }
            }
        }

        if (needChange.size() > 0) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                DexLabel[] handler = tcb.handler;
                for (int i = 0; i < handler.length; i++) {
                    DexLabel h = handler[i];
                    int index = indexOf(h);
                    if (needChange.containsKey(index)) {
                        DexLabel n = needChange.get(index);
                        if (n == null) {
                            n = new DexLabel();
                            needChange.put(index, n);
                            DexLabelStmtNode dexStmtNode = new DexLabelStmtNode(n);
                            dexStmtNode.__index = insnList.size();
                            insnList.add(dexStmtNode);
                            labelMap.put(n, dexStmtNode);
                            JumpStmtNode jumpStmtNode = new JumpStmtNode(Op.GOTO, 0, 0, h);
                            jumpStmtNode.__index = insnList.size();
                            insnList.add(jumpStmtNode);
                        }
                        handler[i] = n;
                    }
                }
            }
        }
    }

    private void initExceptionHandlers(DexCodeNode dexCodeNode, BitSet[] exBranch, BitSet handlers) {
        if (dexCodeNode.tryStmts != null) {
            for (TryCatchNode tcb : dexCodeNode.tryStmts) {
                for (DexLabel h : tcb.handler) {
                    handlers.set(indexOf(h));
                }
                boolean hasEx = false;
                int endIndex = indexOf(tcb.end);
                for (int p = indexOf(tcb.start) + 1; p < endIndex; p++) {
                    DexStmtNode stmt = insnList.get(p);
                    if (stmt.op != null && stmt.op.canThrow()) {
                        hasEx = true;
                        BitSet x = exBranch[p];
                        if (x == null) {
                            x = exBranch[p] = new BitSet(insnList.size());
                        }
                        for (DexLabel h : tcb.handler) {
                            int hIndex = indexOf(h);
                            x.set(hIndex);
                            parentCount[hIndex]++;
                        }
                    }
                }
                if (hasEx) {
                    target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), getLabels(tcb.handler),
                            tcb.type));
                }
            }
        }
    }

    private void addPhi(DvmValue v, Set<com.googlecode.dex2jar.ir.expr.Value> phiValues, List<AssignStmt> phis) {
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    phiValues.add(getLocal(v.parent));
                }
                if (v.otherParent != null) {
                    for (DvmValue v2 : v.otherParent) {
                        phiValues.add(getLocal(v2));
                    }
                }
                if (phiValues.size() > 0) {
                    phis.add(Stmts.nAssign(v.local, Exprs
                            .nPhi(phiValues.toArray(new com.googlecode.dex2jar.ir.expr.Value[phiValues.size()]))));
                    phiValues.clear();
                }
            }
        }
    }

    Local getLocal(DvmValue value) {
        Local local = value.local;
        if (local == null) {
            local = value.local = newLocal();
        }
        return local;
    }

    private void addToQueue(Queue<DvmValue> queue, DvmValue v) {
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    if (v.parent.local == null) {
                        queue.add(v.parent);
                    }
                }
                if (v.otherParent != null) {
                    for (DvmValue v2 : v.otherParent) {
                        if (v2.local == null) {
                            queue.add(v2);
                        }
                    }
                }
            }
        }
    }

    private void setCurrentEmit(int index) {
        currentEmit = emitStmts[index];
        if (currentEmit == null) {
            currentEmit = emitStmts[index] = new ArrayList<>(1);
        }
    }

    private void dfs(BitSet[] exBranch, BitSet handlers, BitSet access, DvmInterpreter<DvmValue> interpreter) {
        currentEmit = preEmit;

        Dex2IrFrame first = initFirstFrame(dexCodeNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<DexStmtNode> stack = new Stack<>();
        stack.push(insnList.get(0));
        Dex2IrFrame tmp = new Dex2IrFrame(dexCodeNode.totalRegister);


        while (!stack.isEmpty()) {
            DexStmtNode p = stack.pop();
            int index = p.__index;
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            Dex2IrFrame frame = frames[index];
            setCurrentEmit(index);

            if (p instanceof DexLabelStmtNode) {
                emit(getLabel(((DexLabelStmtNode) p).label));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef("Ljava/lang/Throwable;")));
                    frame.setTmp(new DvmValue(ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    merge(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            try {
                if (p.op != null) {
                    switch (p.op) {
                        case RETURN_VOID:
                            emit(nReturnVoid());
                            break;
                        case GOTO:
                        case GOTO_16:
                        case GOTO_32:
                            emit(nGoto(getLabel(((JumpStmtNode) p).label)));
                            break;
                        case NOP:
                            emit(nNop());
                            break;
                        case BAD_OP:
                            emit(nThrow(nInvokeNew(new Value[]{nString("bad dex opcode")}, new String[]{
                                            "Ljava/lang/String;"},
                                    "Ljava/lang/VerifyError;")));
                            break;
                        default:
                            tmp.execute(p, interpreter);
                            break;
                    }
                }
            } catch (Exception exception) {
                throw new RuntimeException("Fail on Op " + p.op + " index " + index, exception);
            }


            if (p.op != null) {
                Op op = p.op;
                if (op.canBranch()) {
                    JumpStmtNode jump = (JumpStmtNode) p;
                    int targetIndex = indexOf(jump.label);
                    stack.push(insnList.get(targetIndex));
                    merge(tmp, targetIndex);
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        int targetIndex = indexOf(label);
                        stack.push(insnList.get(targetIndex));
                        merge(tmp, targetIndex);
                    }
                }
                if (op.canContinue()) {
                    stack.push(insnList.get(index + 1));
                    merge(tmp, index + 1);
                }
            } else {

                stack.push(insnList.get(index + 1));
                merge(tmp, index + 1);

            }
            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }

    }

    private void relate(DvmValue parent, DvmValue child) {
        if (child.parent == null) {
            child.parent = parent;
        } else if (child.parent == parent) {
            //
        } else {
            if (child.otherParent == null) {
                child.otherParent = new HashSet<>(5);
            }
            child.otherParent.add(parent);
        }
    }

    void merge(Dex2IrFrame src, int dst) {
        Dex2IrFrame distFrame = frames[dst];
        if (distFrame == null) {
            distFrame = frames[dst] = new Dex2IrFrame(dexCodeNode.totalRegister);
        }
        if (parentCount[dst] > 1) {
            for (int i = 0; i < src.getTotalRegisters(); i++) {
                DvmValue p = src.getReg(i);
                DvmValue q = distFrame.getReg(i);
                if (p != null) {
                    if (q == null) {
                        q = new DvmValue();
                        distFrame.setReg(i, q);
                    }
                    relate(p, q);
                }
            }
        } else {
            distFrame.init(src);
        }
    }

    private Local newLocal() {
        Local thiz = Exprs.nLocal(target.locals.size());
        target.locals.add(thiz);
        return thiz;
    }

    void emit(Stmt stmt) {
        currentEmit.add(stmt);
    }

    private Dex2IrFrame initFirstFrame(DexCodeNode methodNode, IrMethod target) {
        Dex2IrFrame first = new Dex2IrFrame(methodNode.totalRegister);
        int x = methodNode.totalRegister - methodArgCount(target.args);
        if (!target.isStatic) {// not static
            Local thiz = newLocal();
            emit(Stmts.nIdentity(thiz, Exprs.nThisRef(target.owner)));
            first.setReg(x - 1, new DvmValue(thiz));
        }
        for (int i = 0; i < target.args.length; i++) {
            Local p = newLocal();
            emit(Stmts.nIdentity(p, Exprs.nParameterRef(target.args[i], i)));
            first.setReg(x, new DvmValue(p));
            x += sizeofType(target.args[i]);
        }

        if (initAllToZero) {
            for (int i = 0; i < first.getTotalRegisters(); i++) {
                if (first.getReg(i) == null) {
                    Local p = newLocal();
                    emit(nAssign(p, nInt(0)));
                    first.setReg(i, new DvmValue(p));
                }
            }
        }

        return first;
    }

    private DvmInterpreter<DvmValue> buildInterpreter() {
        return new DvmInterpreter<DvmValue>() {
            DvmValue b(com.googlecode.dex2jar.ir.expr.Value value) {
                Local local = newLocal();
                emit(Stmts.nAssign(local, value));
                return new DvmValue(local);
            }

            @Override
            public DvmValue newOperation(DexStmtNode insn) {
                switch (insn.op) {
                    case CONST:
                    case CONST_16:
                    case CONST_4:
                    case CONST_HIGH16:
                        return b(nInt((Integer) ((ConstStmtNode) insn).value));
                    case CONST_WIDE:
                    case CONST_WIDE_16:
                    case CONST_WIDE_32:
                    case CONST_WIDE_HIGH16:
                        return b(nLong((Long) ((ConstStmtNode) insn).value));
                    case CONST_CLASS:
                        return b(nType((DexType) ((ConstStmtNode) insn).value));
                    case CONST_STRING:
                    case CONST_STRING_JUMBO:
                        return b(nString((String) ((ConstStmtNode) insn).value));
                    case CONST_METHOD_HANDLE:
                        return b(nMethodHandle((MethodHandle) ((ConstStmtNode) insn).value));
                    case CONST_METHOD_TYPE:
                        return b(nProto((Proto) ((ConstStmtNode) insn).value));
                    case SGET:
                    case SGET_BOOLEAN:
                    case SGET_BYTE:
                    case SGET_CHAR:
                    case SGET_OBJECT:
                    case SGET_SHORT:
                    case SGET_WIDE:
                        Field field = ((FieldStmtNode) insn).field;
                        return b(nStaticField(field.getOwner(), field.getName(), field.getType()));
                    case NEW_INSTANCE:
                        return b(nNew(((TypeStmtNode) insn).type));
                    default:
                }
                return null;
            }

            @Override
            public DvmValue copyOperation(DexStmtNode insn, DvmValue value) {
                if (value == null) {
                    emitNotFindOperand(insn);
                    return b(nInt(0));
                }
                return b(getLocal(value));
            }

            @Override
            public DvmValue unaryOperation(DexStmtNode insn, DvmValue value) {
                if (value == null) {
                    emitNotFindOperand(insn);
                    return b(nInt(0));
                }
                Local local = getLocal(value);
                switch (insn.op) {
                    case NOT_INT:
                        return b(nNot(local, "I"));
                    case NOT_LONG:
                        return b(nNot(local, "J"));

                    case NEG_DOUBLE:
                        return b(nNeg(local, "D"));

                    case NEG_FLOAT:
                        return b(nNeg(local, "F"));

                    case NEG_INT:
                        return b(nNeg(local, "I"));

                    case NEG_LONG:
                        return b(nNeg(local, "J"));
                    case INT_TO_BYTE:
                        return b(nCast(local, "I", "B"));

                    case INT_TO_CHAR:
                        return b(nCast(local, "I", "C"));

                    case INT_TO_DOUBLE:
                        return b(nCast(local, "I", "D"));

                    case INT_TO_FLOAT:
                        return b(nCast(local, "I", "F"));

                    case INT_TO_LONG:
                        return b(nCast(local, "I", "J"));

                    case INT_TO_SHORT:
                        return b(nCast(local, "I", "S"));

                    case FLOAT_TO_DOUBLE:
                        return b(nCast(local, "F", "D"));

                    case FLOAT_TO_INT:
                        return b(nCast(local, "F", "I"));

                    case FLOAT_TO_LONG:
                        return b(nCast(local, "F", "J"));

                    case DOUBLE_TO_FLOAT:
                        return b(nCast(local, "D", "F"));

                    case DOUBLE_TO_INT:
                        return b(nCast(local, "D", "I"));

                    case DOUBLE_TO_LONG:
                        return b(nCast(local, "D", "J"));

                    case LONG_TO_DOUBLE:
                        return b(nCast(local, "J", "D"));

                    case LONG_TO_FLOAT:
                        return b(nCast(local, "J", "F"));

                    case LONG_TO_INT:
                        return b(nCast(local, "J", "I"));

                    case ARRAY_LENGTH:
                        return b(nLength(local));

                    case IF_EQZ:
                        emit(nIf(Exprs
                                .nEq(local, nInt(0), TypeClass.ZIL.name), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_GEZ:
                        emit(nIf(Exprs.nGe(local, nInt(0), "I"), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_GTZ:
                        emit(nIf(Exprs.nGt(local, nInt(0), "I"), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_LEZ:
                        emit(nIf(Exprs.nLe(local, nInt(0), "I"), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_LTZ:
                        emit(nIf(Exprs.nLt(local, nInt(0), "I"), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_NEZ:
                        emit(nIf(Exprs
                                .nNe(local, nInt(0), TypeClass.ZIL.name), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case PACKED_SWITCH:
                    case SPARSE_SWITCH:
                        DexLabel[] labels = ((BaseSwitchStmtNode) insn).labels;
                        LabelStmt[] lss = new LabelStmt[labels.length];
                        for (int i = 0; i < labels.length; i++) {
                            lss[i] = getLabel(labels[i]);
                        }
                        LabelStmt d = new LabelStmt();
                        if (insn.op == Op.PACKED_SWITCH) {
                            emit(nTableSwitch(local, ((PackedSwitchStmtNode) insn).first_case, lss, d));
                        } else {
                            emit(nLookupSwitch(local, ((SparseSwitchStmtNode) insn).cases, lss, d));
                        }
                        emit(d);
                        return null;

                    case SPUT:
                    case SPUT_BOOLEAN:
                    case SPUT_BYTE:
                    case SPUT_CHAR:
                    case SPUT_OBJECT:
                    case SPUT_SHORT:
                    case SPUT_WIDE: {
                        Field field = ((FieldStmtNode) insn).field;
                        emit(nAssign(nStaticField(field.getOwner(), field.getName(), field.getType()), local));
                        return null;
                    }
                    case IGET:
                    case IGET_BOOLEAN:
                    case IGET_BYTE:
                    case IGET_CHAR:
                    case IGET_OBJECT:
                    case IGET_SHORT:
                    case IGET_WIDE: {
                        Field field = ((FieldStmtNode) insn).field;
                        return b(nField(local, field.getOwner(), field.getName(), field.getType()));
                    }
                    case INSTANCE_OF:
                        return b(nInstanceOf(local, ((TypeStmtNode) insn).type));

                    case NEW_ARRAY:
                        return b(nNewArray(((TypeStmtNode) insn).type.substring(1), local));

                    case CHECK_CAST:
                        return b(nCheckCast(local, ((TypeStmtNode) insn).type));

                    case MONITOR_ENTER:
                        emit(nLock(local));
                        return null;
                    case MONITOR_EXIT:
                        emit(nUnLock(local));
                        return null;
                    case THROW:
                        emit(nThrow(local));
                        return null;
                    case ADD_INT_LIT16:
                    case ADD_INT_LIT8:
                        return b(nAdd(local, nInt(((Stmt2R1NNode) insn).content), "I"));

                    case RSUB_INT_LIT8:
                    case RSUB_INT://
                        return b(nSub(nInt(((Stmt2R1NNode) insn).content), local, "I"));

                    case MUL_INT_LIT8:
                    case MUL_INT_LIT16:
                        return b(nMul(local, nInt(((Stmt2R1NNode) insn).content), "I"));

                    case DIV_INT_LIT16:
                    case DIV_INT_LIT8:
                        return b(nDiv(local, nInt(((Stmt2R1NNode) insn).content), "I"));

                    case REM_INT_LIT16:
                    case REM_INT_LIT8:
                        return b(nRem(local, nInt(((Stmt2R1NNode) insn).content), "I"));

                    case AND_INT_LIT16:
                    case AND_INT_LIT8:
                        return b(nAnd(local, nInt(((Stmt2R1NNode) insn).content), ((Stmt2R1NNode) insn).content < 0 || ((Stmt2R1NNode) insn).content > 1 ? "I" : TypeClass.ZI.name));

                    case OR_INT_LIT16:
                    case OR_INT_LIT8:
                        return b(nOr(local, nInt(((Stmt2R1NNode) insn).content), ((Stmt2R1NNode) insn).content < 0 || ((Stmt2R1NNode) insn).content > 1 ? "I" : TypeClass.ZI.name));

                    case XOR_INT_LIT16:
                    case XOR_INT_LIT8:
                        return b(nXor(local, nInt(((Stmt2R1NNode) insn).content), ((Stmt2R1NNode) insn).content < 0 || ((Stmt2R1NNode) insn).content > 1 ? "I" : TypeClass.ZI.name));

                    case SHL_INT_LIT8:
                        return b(nShl(local, nInt(((Stmt2R1NNode) insn).content), "I"));

                    case SHR_INT_LIT8:
                        return b(nShr(local, nInt(((Stmt2R1NNode) insn).content), "I"));

                    case USHR_INT_LIT8:
                        return b(nUshr(local, nInt(((Stmt2R1NNode) insn).content), "I"));
                    case FILL_ARRAY_DATA:
                        emit(nFillArrayData(local, nArrayValue(((FillArrayDataStmtNode) insn).array)));
                        return null;
                }
                throw new RuntimeException();
            }

            @Override
            public DvmValue binaryOperation(DexStmtNode insn, DvmValue value1, DvmValue value2) {
                if (value1 == null || value2 == null) {
                    emitNotFindOperand(insn);
                    return b(nInt(0));
                }
                Local local1 = getLocal(value1);
                Local local2 = getLocal(value2);
                switch (insn.op) {
                    case AGET:
                        return b(nArray(local1, local2, TypeClass.IF.name));

                    case AGET_BOOLEAN:
                        return b(nArray(local1, local2, "Z"));

                    case AGET_BYTE:
                        return b(nArray(local1, local2, "B"));

                    case AGET_CHAR:
                        return b(nArray(local1, local2, "C"));

                    case AGET_OBJECT:
                        return b(nArray(local1, local2, "L"));

                    case AGET_SHORT:
                        return b(nArray(local1, local2, "S"));

                    case AGET_WIDE:
                        return b(nArray(local1, local2, TypeClass.JD.name));

                    case CMP_LONG:
                        return b(nLCmp(local1, local2));

                    case CMPG_DOUBLE:
                        return b(nDCmpg(local1, local2));

                    case CMPG_FLOAT:
                        return b(nFCmpg(local1, local2));

                    case CMPL_DOUBLE:
                        return b(nDCmpl(local1, local2));

                    case CMPL_FLOAT:
                        return b(nFCmpl(local1, local2));

                    case ADD_DOUBLE:
                        return b(nAdd(local1, local2, "D"));

                    case ADD_FLOAT:
                        return b(nAdd(local1, local2, "F"));

                    case ADD_INT:
                        return b(nAdd(local1, local2, "I"));

                    case ADD_LONG:
                        return b(nAdd(local1, local2, "J"));

                    case SUB_DOUBLE:
                        return b(nSub(local1, local2, "D"));

                    case SUB_FLOAT:
                        return b(nSub(local1, local2, "F"));

                    case SUB_INT:
                        return b(nSub(local1, local2, "I"));

                    case SUB_LONG:
                        return b(nSub(local1, local2, "J"));

                    case MUL_DOUBLE:
                        return b(nMul(local1, local2, "D"));

                    case MUL_FLOAT:
                        return b(nMul(local1, local2, "F"));

                    case MUL_INT:
                        return b(nMul(local1, local2, "I"));

                    case MUL_LONG:
                        return b(nMul(local1, local2, "J"));

                    case DIV_DOUBLE:
                        return b(nDiv(local1, local2, "D"));

                    case DIV_FLOAT:
                        return b(nDiv(local1, local2, "F"));

                    case DIV_INT:
                        return b(nDiv(local1, local2, "I"));

                    case DIV_LONG:
                        return b(nDiv(local1, local2, "J"));

                    case REM_DOUBLE:
                        return b(nRem(local1, local2, "D"));

                    case REM_FLOAT:
                        return b(nRem(local1, local2, "F"));

                    case REM_INT:
                        return b(nRem(local1, local2, "I"));

                    case REM_LONG:
                        return b(nRem(local1, local2, "J"));

                    case AND_INT:
                        return b(nAnd(local1, local2, TypeClass.ZI.name));

                    case AND_LONG:
                        return b(nAnd(local1, local2, "J"));

                    case OR_INT:
                        return b(nOr(local1, local2, TypeClass.ZI.name));

                    case OR_LONG:
                        return b(nOr(local1, local2, "J"));

                    case XOR_INT:
                        return b(nXor(local1, local2, TypeClass.ZI.name));

                    case XOR_LONG:
                        return b(nXor(local1, local2, "J"));

                    case SHL_INT:
                        return b(nShl(local1, local2, "I"));

                    case SHL_LONG:
                        return b(nShl(local1, local2, "J"));

                    case SHR_INT:
                        return b(nShr(local1, local2, "I"));

                    case SHR_LONG:
                        return b(nShr(local1, local2, "J"));

                    case USHR_INT:
                        return b(nUshr(local1, local2, "I"));

                    case USHR_LONG:
                        return b(nUshr(local1, local2, "J"));

                    case IF_EQ:
                        emit(nIf(Exprs
                                .nEq(local1, local2, TypeClass.ZIL.name), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_GE:
                        emit(nIf(Exprs.nGe(local1, local2, "I"), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_GT:
                        emit(nIf(Exprs.nGt(local1, local2, "I"), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_LE:
                        emit(nIf(Exprs.nLe(local1, local2, "I"), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_LT:
                        emit(nIf(Exprs.nLt(local1, local2, "I"), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IF_NE:
                        emit(nIf(Exprs
                                .nNe(local1, local2, TypeClass.ZIL.name), getLabel(((JumpStmtNode) insn).label)));
                        return null;

                    case IPUT:
                    case IPUT_BOOLEAN:
                    case IPUT_BYTE:
                    case IPUT_CHAR:
                    case IPUT_OBJECT:
                    case IPUT_SHORT:
                    case IPUT_WIDE:
                        Field field = ((FieldStmtNode) insn).field;
                        emit(nAssign(nField(local1, field.getOwner(), field.getName(), field.getType()), local2));
                        return null;

                    case ADD_DOUBLE_2ADDR:
                        return b(nAdd(local1, local2, "D"));

                    case ADD_FLOAT_2ADDR:
                        return b(nAdd(local1, local2, "F"));

                    case ADD_INT_2ADDR:
                        return b(nAdd(local1, local2, "I"));

                    case ADD_LONG_2ADDR:
                        return b(nAdd(local1, local2, "J"));

                    case SUB_DOUBLE_2ADDR:
                        return b(nSub(local1, local2, "D"));

                    case SUB_FLOAT_2ADDR:
                        return b(nSub(local1, local2, "F"));

                    case SUB_INT_2ADDR:
                        return b(nSub(local1, local2, "I"));

                    case SUB_LONG_2ADDR:
                        return b(nSub(local1, local2, "J"));

                    case MUL_DOUBLE_2ADDR:
                        return b(nMul(local1, local2, "D"));

                    case MUL_FLOAT_2ADDR:
                        return b(nMul(local1, local2, "F"));

                    case MUL_INT_2ADDR:
                        return b(nMul(local1, local2, "I"));

                    case MUL_LONG_2ADDR:
                        return b(nMul(local1, local2, "J"));

                    case DIV_DOUBLE_2ADDR:
                        return b(nDiv(local1, local2, "D"));

                    case DIV_FLOAT_2ADDR:
                        return b(nDiv(local1, local2, "F"));

                    case DIV_INT_2ADDR:
                        return b(nDiv(local1, local2, "I"));

                    case DIV_LONG_2ADDR:
                        return b(nDiv(local1, local2, "J"));

                    case REM_DOUBLE_2ADDR:
                        return b(nRem(local1, local2, "D"));

                    case REM_FLOAT_2ADDR:
                        return b(nRem(local1, local2, "F"));

                    case REM_INT_2ADDR:
                        return b(nRem(local1, local2, "I"));

                    case REM_LONG_2ADDR:
                        return b(nRem(local1, local2, "J"));

                    case AND_INT_2ADDR:
                        return b(nAnd(local1, local2, TypeClass.ZI.name));

                    case AND_LONG_2ADDR:
                        return b(nAnd(local1, local2, "J"));

                    case OR_INT_2ADDR:
                        return b(nOr(local1, local2, TypeClass.ZI.name));

                    case OR_LONG_2ADDR:
                        return b(nOr(local1, local2, "J"));

                    case XOR_INT_2ADDR:
                        return b(nXor(local1, local2, TypeClass.ZI.name));

                    case XOR_LONG_2ADDR:
                        return b(nXor(local1, local2, "J"));

                    case SHL_INT_2ADDR:
                        return b(nShl(local1, local2, "I"));

                    case SHL_LONG_2ADDR:
                        return b(nShl(local1, local2, "J"));

                    case SHR_INT_2ADDR:
                        return b(nShr(local1, local2, "I"));

                    case SHR_LONG_2ADDR:
                        return b(nShr(local1, local2, "J"));

                    case USHR_INT_2ADDR:
                        return b(nUshr(local1, local2, "I"));

                    case USHR_LONG_2ADDR:
                        return b(nUshr(local1, local2, "J"));

                }
                throw new RuntimeException();
            }

            @Override
            public DvmValue ternaryOperation(DexStmtNode insn, DvmValue value1, DvmValue value2, DvmValue value3) {
                if (value1 == null || value2 == null || value3 == null) {
                    emitNotFindOperand(insn);
                    return b(nInt(0));
                }
                Local localArray = getLocal(value1);
                Local localIndex = getLocal(value2);
                Local localValue = getLocal(value3);
                switch (insn.op) {
                    case APUT:
                        emit(nAssign(nArray(localArray, localIndex, TypeClass.IF.name), localValue));
                        break;
                    case APUT_BOOLEAN:
                        emit(nAssign(nArray(localArray, localIndex, "Z"), localValue));
                        break;
                    case APUT_BYTE:
                        emit(nAssign(nArray(localArray, localIndex, "B"), localValue));
                        break;
                    case APUT_CHAR:
                        emit(nAssign(nArray(localArray, localIndex, "C"), localValue));
                        break;
                    case APUT_OBJECT:
                        emit(nAssign(nArray(localArray, localIndex, "L"), localValue));
                        break;
                    case APUT_SHORT:
                        emit(nAssign(nArray(localArray, localIndex, "S"), localValue));
                        break;
                    case APUT_WIDE:
                        emit(nAssign(nArray(localArray, localIndex, TypeClass.JD.name), localValue));
                        break;
                }
                return null;
            }

            @Override
            public DvmValue naryOperation(DexStmtNode insn, List<? extends DvmValue> values) {
                for (DvmValue v : values) {
                    if (v == null) {
                        emitNotFindOperand(insn);
                        return b(nInt(0));
                    }
                }


                switch (insn.op) {
                    case FILLED_NEW_ARRAY:
                    case FILLED_NEW_ARRAY_RANGE:
                        DvmValue value = new DvmValue();
                        FilledNewArrayStmtNode filledNewArrayStmtNode = (FilledNewArrayStmtNode) insn;
                        String type = filledNewArrayStmtNode.type;

                        String elem = type.substring(1);
                        emit(nAssign(getLocal(value), nNewArray(elem, nInt(values.size()))));
                        for (int i = 0; i < values.size(); i++) {
                            emit(nAssign(nArray(getLocal(value), nInt(i), elem), getLocal(values.get(i))));
                        }

                        return value;
                    case INVOKE_CUSTOM:
                    case INVOKE_CUSTOM_RANGE: {
                        Value[] vs = new Value[values.size()];
                        for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }
                        MethodCustomStmtNode n = (MethodCustomStmtNode) insn;
                        Value invoke = nInvokeCustom(vs, n.callSite);
                        if ("V".equals(n.getProto().getReturnType())) {
                            emit(nVoidInvoke(invoke));
                            return null;
                        } else {
                            return b(invoke);
                        }
                    }
                    case INVOKE_POLYMORPHIC:
                    case INVOKE_POLYMORPHIC_RANGE: {
                        Value[] vs = new Value[values.size()];
                        for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }
                        MethodPolymorphicStmtNode n = (MethodPolymorphicStmtNode) insn;
                        Value invoke = nInvokePolymorphic(vs, n.proto, n.method);
                        if ("V".equals(n.getProto().getReturnType())) {
                            emit(nVoidInvoke(invoke));
                            return null;
                        } else {
                            return b(invoke);
                        }
                    }
                    default:
                        Op op = insn.op;
                        Value[] vs = new Value[values.size()];
                        for (int i = 0; i < vs.length; i++) {
                            vs[i] = getLocal(values.get(i));
                        }

                        Method method = ((MethodStmtNode) insn).method;
                        Value invoke = null;
                        switch (op) {
                            case INVOKE_VIRTUAL_RANGE:
                            case INVOKE_VIRTUAL:
                                invoke = nInvokeVirtual(vs, method.getOwner(), method.getName(), method
                                                .getParameterTypes(),
                                        method.getReturnType());
                                break;
                            case INVOKE_SUPER_RANGE:
                            case INVOKE_DIRECT_RANGE:
                            case INVOKE_SUPER:
                            case INVOKE_DIRECT:
                                invoke = nInvokeSpecial(vs, method.getOwner(), method.getName(), method
                                                .getParameterTypes(),
                                        method.getReturnType());
                                break;
                            case INVOKE_STATIC_RANGE:
                            case INVOKE_STATIC:
                                invoke = nInvokeStatic(vs, method.getOwner(), method.getName(), method
                                                .getParameterTypes(),
                                        method.getReturnType());
                                break;
                            case INVOKE_INTERFACE_RANGE:
                            case INVOKE_INTERFACE:
                                invoke = nInvokeInterface(vs, method.getOwner(), method.getName(), method
                                                .getParameterTypes(),
                                        method.getReturnType());
                                break;
                            default:
                                throw new RuntimeException();
                        }
                        if ("V".equals(method.getReturnType())) {
                            emit(nVoidInvoke(invoke));
                            return null;
                        } else {
                            return b(invoke);
                        }

                }


            }

            void emitNotFindOperand(DexStmtNode insn) {
                String msg;
                switch (insn.op) {
                    case MOVE_RESULT:
                    case MOVE_RESULT_OBJECT:
                    case MOVE_RESULT_WIDE:
                        msg = "can't get operand(s) for " + insn.op + ", wrong position ?";
                        break;
                    default:
                        msg = "can't get operand(s) for " + insn.op + ", out-of-range or not initialized ?";
                        break;
                }

                System.err.println("WARN: " + msg);
                emit(nThrow(nInvokeNew(new Value[]{nString("d2j: " + msg)},
                        new String[]{"Ljava/lang/String;"}, "Ljava/lang/VerifyError;")));
            }

            @Override
            public void returnOperation(DexStmtNode insn, DvmValue value) {
                if (value == null) {
                    emitNotFindOperand(insn);
                    return;
                }

                emit(nReturn(getLocal(value)));
            }
        };
    }

    private LabelStmt[] getLabels(DexLabel[] handler) {
        LabelStmt[] ts = new LabelStmt[handler.length];
        for (int i = 0; i < handler.length; i++) {
            ts[i] = getLabel(handler[i]);
        }
        return ts;
    }

    LabelStmt getLabel(DexLabel label) {
        LabelStmt ls = map.get(label);
        if (ls == null) {
            ls = Stmts.nLabel();
            map.put(label, ls);
        }
        return ls;
    }

    private void initParentCount(int[] parentCount) {
        parentCount[0] = 1; // first stmt always have one parent
        for (DexStmtNode p : insnList) {
            Op op = p.op;
            if (op == null) {
                if (p.__index < parentCount.length - 1) { // not the last label
                    parentCount[p.__index + 1]++;
                }
            } else {
                if (op.canBranch()) {
                    parentCount[indexOf(((JumpStmtNode) p).label)]++;
                }
                if (op.canSwitch()) {
                    BaseSwitchStmtNode switchStmtNode = (BaseSwitchStmtNode) p;
                    for (DexLabel label : switchStmtNode.labels) {
                        parentCount[indexOf(label)]++;
                    }
                }
                if (op.canContinue()) {
                    parentCount[p.__index + 1]++;
                }
            }
        }
    }

    int indexOf(DexLabel label) {
        DexLabelStmtNode dexLabelStmtNode = labelMap.get(label);
        return dexLabelStmtNode.__index;
    }

    static class DvmValue {
        public DvmValue parent;
        public Set<DvmValue> otherParent;
        Local local;

        public DvmValue(Local thiz) {
            this.local = thiz;
        }

        public DvmValue() {

        }
    }


}

```

`dex-translator/src/main/java/com/googlecode/d2j/converter/IR2JConverter.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.converter;

import com.googlecode.d2j.CallSite;
import com.googlecode.d2j.DexType;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.MethodHandle;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.asm.LdcOptimizeAdapter;
import com.googlecode.d2j.dex.Dex2Asm;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.expr.*;
import com.googlecode.dex2jar.ir.expr.Value.E1Expr;
import com.googlecode.dex2jar.ir.expr.Value.E2Expr;
import com.googlecode.dex2jar.ir.expr.Value.EnExpr;
import com.googlecode.dex2jar.ir.expr.Value.VT;
import com.googlecode.dex2jar.ir.stmt.*;
import com.googlecode.dex2jar.ir.stmt.Stmt.E2Stmt;
import com.googlecode.dex2jar.ir.stmt.Stmt.ST;
import org.objectweb.asm.*;

import java.lang.reflect.Array;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.HashMap;
import java.util.Map;

@SuppressWarnings("incomplete-switch")
public class IR2JConverter implements Opcodes {

    public static final int MAX_FILL_ARRAY_BYTES = 500;
    private boolean optimizeSynchronized = false;
    Dex2Asm.ClzCtx clzCtx;
    IrMethod ir;
    MethodVisitor asm;
    public IR2JConverter() {
        super();
    }

    public IR2JConverter optimizeSynchronized(boolean optimizeSynchronized) {
        this.optimizeSynchronized = optimizeSynchronized;
        return this;
    }

    public IR2JConverter clzCtx(Dex2Asm.ClzCtx clzCtx) {
        this.clzCtx = clzCtx;
        return this;
    }

    public IR2JConverter ir(IrMethod ir) {
        this.ir = ir;
        return this;
    }

    public IR2JConverter asm(MethodVisitor asm) {
        this.asm = asm;
        return this;
    }

    public void convert() {
        mapLabelStmt(ir);
        reBuildInstructions(ir, asm);
        reBuildTryCatchBlocks(ir, asm);
    }

    private void mapLabelStmt(IrMethod ir) {
        for (Stmt p : ir.stmts) {
            if (p.st == ST.LABEL) {
                LabelStmt labelStmt = (LabelStmt) p;
                labelStmt.tag = new Label();
            }
        }
    }

    /**
     * an empty try-catch block will cause other crash, we check this by finding non-label stmts between
     * {@link Trap#start} and {@link Trap#end}. if find we add the try-catch or we drop the try-catch.
     *
     * @param ir
     * @param asm
     */
    private void reBuildTryCatchBlocks(IrMethod ir, MethodVisitor asm) {
        for (Trap trap : ir.traps) {
            boolean needAdd = false;
            for (Stmt p = trap.start.getNext(); p != null && p != trap.end; p = p.getNext()) {
                if (p.st != ST.LABEL) {
                    needAdd = true;
                    break;
                }
            }
            if (needAdd) {
                for (int i = 0; i < trap.handlers.length; i++) {
                    String type = trap.types[i];
                    asm.visitTryCatchBlock((Label) trap.start.tag, (Label) trap.end.tag, (Label) trap.handlers[i].tag,
                            type == null ? null : toInternal(type));
                }
            }
        }
    }

    static String toInternal(String n) {
        // TODO replace
        return Type.getType(n).getInternalName();
    }



    private void reBuildInstructions(IrMethod ir, MethodVisitor asm) {
        asm = new LdcOptimizeAdapter(asm);
        int maxLocalIndex = 0;
        for (Local local : ir.locals) {
            maxLocalIndex = Math.max(maxLocalIndex, local._ls_index);
        }
        Map<String, Integer> lockMap = new HashMap<String, Integer>();
        for (Stmt st : ir.stmts) {
            switch (st.st) {
            case LABEL:
                LabelStmt labelStmt = (LabelStmt) st;
                Label label = (Label) labelStmt.tag;
                asm.visitLabel(label);
                if (labelStmt.lineNumber >= 0) {
                    asm.visitLineNumber(labelStmt.lineNumber, label);
                }
                break;
            case ASSIGN: {
                E2Stmt e2 = (E2Stmt) st;
                Value v1 = e2.op1;
                Value v2 = e2.op2;
                switch (v1.vt) {
                case LOCAL:

                    Local local = ((Local) v1);
                    int i = local._ls_index;

                    boolean skipOrg = false;
                    if (v2.vt == VT.LOCAL && (i == ((Local) v2)._ls_index)) {// check for a=a
                        skipOrg = true;
                    } else if (v1.valueType.charAt(0) == 'I') {// check for IINC
                        if (v2.vt == VT.ADD) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a+1;
                                int increment = (Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            } else if (isLocalWithIndex(v2.getOp2(), i) && v2.getOp1().vt == VT.CONSTANT) { // a=1+a;
                                int increment = (Integer) ((Constant) v2.getOp1()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        } else if (v2.vt == VT.SUB) {
                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a-1;
                                int increment = -(Integer) ((Constant) v2.getOp2()).value;
                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {
                                    asm.visitIincInsn(i, increment);
                                    skipOrg = true;
                                }
                            }
                        }
                    }
                    if (!skipOrg) {
                        accept(v2, asm);
                        if (i >= 0) {
                            asm.visitVarInsn(getOpcode(v1, ISTORE), i);
                        } else if (!v1.valueType.equals("V")) { // skip void type locals
                            switch (v1.valueType.charAt(0)) {
                            case 'J':
                            case 'D':
                                asm.visitInsn(POP2);
                                break;
                            default:
                                asm.visitInsn(POP);
                                break;
                            }
                        }
                    }
                    break;
                case STATIC_FIELD: {
                    StaticFieldExpr fe = (StaticFieldExpr) v1;
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTSTATIC, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case FIELD: {
                    FieldExpr fe = (FieldExpr) v1;
                    accept(fe.op, asm);
                    accept(v2, asm);
                    insertI2x(v2.valueType, fe.type, asm);
                    asm.visitFieldInsn(PUTFIELD, toInternal(fe.owner), fe.name, fe.type);
                    break;
                }
                case ARRAY:
                    ArrayExpr ae = (ArrayExpr) v1;
                    accept(ae.op1, asm);
                    accept(ae.op2, asm);
                    accept(v2, asm);
                    String tp1 = ae.op1.valueType;
                    String tp2 = ae.valueType;
                    if (tp1.charAt(0) == '[') {
                        String arrayElementType = tp1.substring(1);
                        insertI2x(v2.valueType, arrayElementType, asm);
                        asm.visitInsn(getOpcode(arrayElementType, IASTORE));
                    } else {
                        asm.visitInsn(getOpcode(tp2, IASTORE));
                    }
                    break;
                }
            }
                break;
            case IDENTITY: {
                E2Stmt e2 = (E2Stmt) st;
                if (e2.op2.vt == VT.EXCEPTION_REF) {
                    int index = ((Local) e2.op1)._ls_index;
                    if (index >= 0) {
                        asm.visitVarInsn(ASTORE, index);
                    } else {
                        asm.visitInsn(POP);
                    }
                }
            }
                break;

            case FILL_ARRAY_DATA:{
                E2Stmt e2 = (E2Stmt) st;
                if (e2.getOp2().vt == VT.CONSTANT) {
                    Object arrayData = ((Constant) e2.getOp2()).value;
                    int arraySize = Array.getLength(arrayData);
                    String arrayValueType = e2.getOp1().valueType;
                    String elementType;
                    if (arrayValueType.charAt(0) == '[') {
                        elementType = arrayValueType.substring(1);
                    } else {
                        elementType = "I";
                    }
                    boolean genBig = false;
                    try {
                        if (this.clzCtx != null
                                && "BSIJ".contains(elementType)) {

                            byte[] data = toLittleEndianArray(arrayData);

                            if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                                accept(e2.getOp1(), asm);
                                asm.visitLdcInsn(0);
                                constLargeArray(asm, data, elementType);
                                asm.visitLdcInsn(0);
                                asm.visitLdcInsn(arraySize);

                                asm.visitMethodInsn(Opcodes.INVOKESTATIC,
                                        "java/lang/System",
                                        "arraycopy",
                                        "(Ljava/lang/Object;ILjava/lang/Object;II)V",
                                        false
                                );
                                genBig = true;
                            }

                        }
                    } catch (Exception ignore) {
                        // any exception, revert to normal
                    }

                    if (!genBig) {
                        int iastoreOP = getOpcode(elementType, IASTORE);
                        accept(e2.getOp1(), asm);
                        for (int i = 0; i < arraySize; i++) {
                            asm.visitInsn(DUP);
                            asm.visitLdcInsn(i);
                            asm.visitLdcInsn(Array.get(arrayData, i));
                            asm.visitInsn(iastoreOP);
                        }
                        asm.visitInsn(POP);
                    }
                } else {
                    FilledArrayExpr filledArrayExpr = (FilledArrayExpr) e2.getOp2();
                    int arraySize = filledArrayExpr.ops.length;
                    String arrayValueType = e2.getOp1().valueType;
                    String elementType;
                    if (arrayValueType.charAt(0) == '[') {
                        elementType = arrayValueType.substring(1);
                    } else {
                        elementType = "I";
                    }

                    boolean genBig = false;
                    try {
                        if (this.clzCtx != null
                                && "BSIJ".contains(elementType)
                                && isConstant(filledArrayExpr.ops)) {
                            // create a 500-len byte array, may cause 'Method code too large!'
                            // convert it to a base64 decoding
                            byte[] data = collectDataAsByteArray(filledArrayExpr.ops, elementType);
                            if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                                accept(e2.getOp1(), asm);
                                asm.visitLdcInsn(0);
                                constLargeArray(asm, data, elementType);
                                asm.visitLdcInsn(0);
                                asm.visitLdcInsn(arraySize);

                                asm.visitMethodInsn(INVOKESTATIC,
                                        "java/lang/System",
                                        "arraycopy",
                                        "(Ljava/lang/Object;ILjava/lang/Object;II)V",
                                        false
                                );

                                genBig = true;
                            }
                        }
                    } catch (Exception ignore) {
                        // any exception, revert to normal
                    }

                    if (!genBig) {
                        int iastoreOP = getOpcode(elementType, IASTORE);
                        accept(e2.getOp1(), asm);
                        for (int i = 0; i < arraySize; i++) {
                            asm.visitInsn(DUP);
                            asm.visitLdcInsn(i);
                            accept(filledArrayExpr.ops[i], asm);
                            asm.visitInsn(iastoreOP);
                        }
                        asm.visitInsn(POP);
                    }
                }
            }
            break;
            case GOTO:
                asm.visitJumpInsn(GOTO, (Label) ((GotoStmt) st).target.tag);
                break;
            case IF:
                reBuildJumpInstructions((IfStmt) st, asm);
                break;
            case LOCK: {
                Value v = ((UnopStmt) st).op;
                accept(v, asm);
                if (optimizeSynchronized) {
                    switch (v.vt) {
                    case LOCAL:
                        // FIXME do we have to disable local due to OptSyncTest ?
                        // break;
                    case CONSTANT: {
                        String key;
                        if (v.vt == VT.LOCAL) {
                            key = "L" + ((Local) v)._ls_index;
                        } else {
                            key = "C" + ((Constant) v).value;
                        }
                        Integer integer = lockMap.get(key);
                        int nIndex = integer != null ? integer : ++maxLocalIndex;
                        asm.visitInsn(DUP);
                        asm.visitVarInsn(getOpcode(v, ISTORE), nIndex);
                        lockMap.put(key, nIndex);
                    }
                        break;
                    default:
                        throw new RuntimeException();
                    }
                }
                asm.visitInsn(MONITORENTER);
            }
                break;
            case UNLOCK: {
                Value v = ((UnopStmt) st).op;
                if (optimizeSynchronized) {
                    switch (v.vt) {
                    case LOCAL:
                    case CONSTANT: {
                        String key;
                        if (v.vt == VT.LOCAL) {
                            key = "L" + ((Local) v)._ls_index;
                        } else {
                            key = "C" + ((Constant) v).value;
                        }
                        Integer integer = lockMap.get(key);
                        if (integer != null) {
                            asm.visitVarInsn(getOpcode(v, ILOAD), integer);
                        } else {
                            accept(v, asm);
                        }
                    }
                        break;
                    // TODO other
                    default: {
                        accept(v, asm);
                        break;
                    }
                    }
                } else {
                    accept(v, asm);
                }
                asm.visitInsn(MONITOREXIT);
            }
                break;
            case NOP:
                break;
            case RETURN: {
                Value v = ((UnopStmt) st).op;
                accept(v, asm);
                insertI2x(v.valueType, ir.ret, asm);
                asm.visitInsn(getOpcode(v, IRETURN));
            }
                break;
            case RETURN_VOID:
                asm.visitInsn(RETURN);
                break;
            case LOOKUP_SWITCH: {
                LookupSwitchStmt lss = (LookupSwitchStmt) st;
                accept(lss.op, asm);
                Label targets[] = new Label[lss.targets.length];
                for (int i = 0; i < targets.length; i++) {
                    targets[i] = (Label) lss.targets[i].tag;
                }
                asm.visitLookupSwitchInsn((Label) lss.defaultTarget.tag, lss.lookupValues, targets);
            }
                break;
            case TABLE_SWITCH: {
                TableSwitchStmt tss = (TableSwitchStmt) st;
                accept(tss.op, asm);
                Label targets[] = new Label[tss.targets.length];
                for (int i = 0; i < targets.length; i++) {
                    targets[i] = (Label) tss.targets[i].tag;
                }
                asm.visitTableSwitchInsn(tss.lowIndex, tss.lowIndex + targets.length - 1,
                        (Label) tss.defaultTarget.tag, targets);
            }
                break;
            case THROW:
                accept(((UnopStmt) st).op, asm);
                asm.visitInsn(ATHROW);
                break;
            case VOID_INVOKE:
                Value op = st.getOp();
                accept(op, asm);

                String ret = op.valueType;
                if (op.vt == VT.INVOKE_NEW) {
                    asm.visitInsn(POP);
                } else if (!"V".equals(ret)) {
                    switch (ret.charAt(0)) {
                        case 'J':
                        case 'D':
                            asm.visitInsn(POP2);
                            break;
                        default:
                            asm.visitInsn(POP);
                            break;
                    }
                }
                break;
            default:
                throw new RuntimeException("not support st: " + st.st);
            }

        }
    }

    private void constLargeArray(MethodVisitor asm, byte[] data, String elementType) {
        String cst = hexEncode(data);
        if (cst.length() > 65535) { // asm have the limit
            asm.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder");
            asm.visitInsn(Opcodes.DUP);
            asm.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);

            for (int i = 0; i < cst.length(); i += 65500) {
                int a = Math.min(65500, cst.length() - i);
                asm.visitLdcInsn(cst.substring(i, i + a));
                asm.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder",
                        "append",
                        "(Ljava/lang/String;)Ljava/lang/StringBuilder;",
                        false
                );
            }
            asm.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder",
                    "toString",
                    "()Ljava/lang/String;",
                    false
            );
        } else {
            asm.visitLdcInsn(cst);
        }

        asm.visitMethodInsn(Opcodes.INVOKESTATIC, toInternal(this.clzCtx.classDescriptor),
                this.clzCtx.buildHexDecodeMethodName(elementType), "(Ljava/lang/String;)[" + elementType, false);
    }

    private static boolean isLocalWithIndex(Value v, int i) {
        return v.vt == VT.LOCAL && ((Local) v)._ls_index == i;
    }

    /**
     * insert I2x instruction
     *
     * @param tos
     * @param expect
     * @param mv
     */
    private static void insertI2x(String tos, String expect, MethodVisitor mv) {
        switch (expect.charAt(0)) {
        case 'B':
            switch (tos.charAt(0)) {
            case 'S':
            case 'C':
            case 'I':
                mv.visitInsn(I2B);
            }
            break;
        case 'S':
            switch (tos.charAt(0)) {
            case 'C':
            case 'I':
                mv.visitInsn(I2S);
            }
            break;
        case 'C':
            switch (tos.charAt(0)) {
            case 'I':
                mv.visitInsn(I2C);
            }
            break;
        }
    }

    static boolean isZeroOrNull(Value v1) {
        if (v1.vt == VT.CONSTANT) {
            Object v = ((Constant) v1).value;
            return Integer.valueOf(0).equals(v) || Constant.Null.equals(v);
        }
        return false;
    }

    private void reBuildJumpInstructions(IfStmt st, MethodVisitor asm) {
        Label target = (Label) st.target.tag;
        Value v = st.op;
        Value v1 = v.getOp1();
        Value v2 = v.getOp2();

        String type = v1.valueType;

        switch (type.charAt(0)) {
        case '[':
        case 'L':
            // IF_ACMPx
            // IF[non]null
            if (isZeroOrNull(v1) || isZeroOrNull(v2)) { // IF[non]null
                if (isZeroOrNull(v2)) {// v2 is null
                    accept(v1, asm);
                } else {
                    accept(v2, asm);
                }
                asm.visitJumpInsn(v.vt == VT.EQ ? IFNULL : IFNONNULL, target);
            } else {
                accept(v1, asm);
                accept(v2, asm);
                asm.visitJumpInsn(v.vt == VT.EQ ? IF_ACMPEQ : IF_ACMPNE, target);
            }
            break;
        default:
            // IFx
            // IF_ICMPx
            if (isZeroOrNull(v1) || isZeroOrNull(v2)) { // IFx
                if (isZeroOrNull(v2)) {// v2 is zero
                    accept(v1, asm);
                } else {
                    accept(v2, asm);
                }
                switch (v.vt) {
                case NE:
                    asm.visitJumpInsn(IFNE, target);
                    break;
                case EQ:
                    asm.visitJumpInsn(IFEQ, target);
                    break;
                case GE:
                    asm.visitJumpInsn(IFGE, target);
                    break;
                case GT:
                    asm.visitJumpInsn(IFGT, target);
                    break;
                case LE:
                    asm.visitJumpInsn(IFLE, target);
                    break;
                case LT:
                    asm.visitJumpInsn(IFLT, target);
                    break;
                }
            } else { // IF_ICMPx
                accept(v1, asm);
                accept(v2, asm);
                switch (v.vt) {
                case NE:
                    asm.visitJumpInsn(IF_ICMPNE, target);
                    break;
                case EQ:
                    asm.visitJumpInsn(IF_ICMPEQ, target);
                    break;
                case GE:
                    asm.visitJumpInsn(IF_ICMPGE, target);
                    break;
                case GT:
                    asm.visitJumpInsn(IF_ICMPGT, target);
                    break;
                case LE:
                    asm.visitJumpInsn(IF_ICMPLE, target);
                    break;
                case LT:
                    asm.visitJumpInsn(IF_ICMPLT, target);
                    break;
                }
            }
            break;
        }
    }

    /**
     *
     * @param v
     * @param op
     *            DUP
     * @return
     */
    static int getOpcode(Value v, int op) {
        return getOpcode(v.valueType, op);
    }

    static int getOpcode(String v, int op) {
        switch (v.charAt(0)) {
            case 'L':
            case '[':
                return Type.getType("La;").getOpcode(op);
            case 'Z':
                return Type.BOOLEAN_TYPE.getOpcode(op);
            case 'B':
                return Type.BYTE_TYPE.getOpcode(op);
            case 'S':
                return Type.SHORT_TYPE.getOpcode(op);
            case 'C':
                return Type.CHAR_TYPE.getOpcode(op);
            case 'I':
                return Type.INT_TYPE.getOpcode(op);
            case 'F':
                return Type.FLOAT_TYPE.getOpcode(op);
            case 'J':
                return Type.LONG_TYPE.getOpcode(op);
            case 'D':
                return Type.DOUBLE_TYPE.getOpcode(op);
            default:
                // FIXME handle undetected types
                return Type.INT_TYPE.getOpcode(op); // treat other as int
        }
    }

    private void accept(Value value, MethodVisitor asm) {

        switch (value.et) {
        case E0:
            switch (value.vt) {
            case LOCAL:
                asm.visitVarInsn(getOpcode(value, ILOAD), ((Local) value)._ls_index);
                break;
            case CONSTANT:
                Constant cst = (Constant) value;
                if (cst.value.equals(Constant.Null)) {
                    asm.visitInsn(ACONST_NULL);
                } else if (cst.value instanceof DexType || cst.value instanceof MethodHandle || cst.value instanceof Proto) {
                    asm.visitLdcInsn(Dex2Asm.convertConstantValue(cst.value));
                } else {
                    asm.visitLdcInsn(cst.value);
                }
                break;
            case NEW:
                asm.visitTypeInsn(NEW, toInternal(((NewExpr) value).type));
                break;
            case STATIC_FIELD:
                StaticFieldExpr sfe= (StaticFieldExpr) value;
                asm.visitFieldInsn(GETSTATIC,toInternal(sfe.owner),sfe.name,sfe.type);
                break;
            }
            break;
        case E1:
            reBuildE1Expression((E1Expr) value, asm);
            break;
        case E2:
            reBuildE2Expression((E2Expr) value, asm);
            break;
        case En:
            reBuildEnExpression((EnExpr) value, asm);
            break;
        }
    }

    public static String hexEncode(byte[] data) {
        StringBuilder sb = new StringBuilder();
        for (byte b : data) {
            sb.append(String.format("%02x", b & 0xFF));
        }
        return sb.toString();
    }

    private void reBuildEnExpression(EnExpr value, MethodVisitor asm) {
        if (value.vt == VT.FILLED_ARRAY) {
            FilledArrayExpr fae = (FilledArrayExpr) value;
            String tp1 = fae.valueType;
            int xastore = IASTORE;
            String elementType = null;
            if (tp1.charAt(0) == '[') {
                elementType = tp1.substring(1);
                xastore = getOpcode(elementType, IASTORE);
            }

            try {
                if (this.clzCtx != null
                        && elementType != null
                        && "BSIJ".contains(elementType)
                        && isConstant(fae.ops)) {

                    byte[] data = collectDataAsByteArray(fae.ops, elementType);
                    if (data != null && data.length > MAX_FILL_ARRAY_BYTES) {
                        constLargeArray(asm, data, elementType);
                        return;
                    }
                }
            } catch (Exception ignore) {
                // any exception, revert to normal
            }

            reBuildE1Expression(Exprs.nNewArray(fae.type, Exprs.nInt(fae.ops.length)), asm);


            for (int i = 0; i < fae.ops.length; i++) {
                if (fae.ops[i] == null)
                    continue;
                asm.visitInsn(DUP);
                asm.visitLdcInsn(i);
                accept(fae.ops[i], asm);
                String tp2 = fae.ops[i].valueType;
                if (elementType != null) {
                    insertI2x(tp2, elementType, asm);
                }
                asm.visitInsn(xastore);
            }
            return;
        }

        switch (value.vt) {
        case NEW_MUTI_ARRAY:
            for (Value vb : value.ops) {
                accept(vb, asm);
            }
            NewMutiArrayExpr nmae = (NewMutiArrayExpr) value;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < nmae.dimension; i++) {
                sb.append('[');
            }
            sb.append(nmae.baseType);
            asm.visitMultiANewArrayInsn(sb.toString(), value.ops.length);
            break;
        case INVOKE_NEW:
            asm.visitTypeInsn(NEW, toInternal(((InvokeExpr) value).getOwner()));
            asm.visitInsn(DUP);
            // pass through
        case INVOKE_INTERFACE:
        case INVOKE_SPECIAL:
        case INVOKE_STATIC:
        case INVOKE_VIRTUAL: {
            InvokeExpr ie = (InvokeExpr) value;
            int i = 0;
            if (value.vt != VT.INVOKE_STATIC && value.vt != VT.INVOKE_NEW) {
                i = 1;
                accept(value.ops[0], asm);
            }
            for (int j = 0; i < value.ops.length; i++, j++) {
                Value vb = value.ops[i];
                accept(vb, asm);
                insertI2x(vb.valueType, ie.getArgs()[j], asm);
            }

            int opcode;
            switch (value.vt) {
            case INVOKE_VIRTUAL:
                opcode = INVOKEVIRTUAL;
                break;
            case INVOKE_INTERFACE:
                opcode = INVOKEINTERFACE;
                break;
            case INVOKE_NEW:
            case INVOKE_SPECIAL:
                opcode = INVOKESPECIAL;
                break;
            case INVOKE_STATIC:
                opcode = INVOKESTATIC;
                break;
            default:
                opcode = -1;
            }

            Proto p = ie.getProto();
            if (ie.vt == VT.INVOKE_NEW) {
                p = new Proto(p.getParameterTypes(), "V");
            }
            asm.visitMethodInsn(opcode, toInternal(ie.getOwner()), ie.getName(), p.getDesc(), opcode == INVOKEINTERFACE);
        }
        break;
        case INVOKE_CUSTOM: {
            InvokeCustomExpr ice = (InvokeCustomExpr) value;
            String argTypes[] = ice.getProto().getParameterTypes();
            Value[] vbs = ice.getOps();
            if (argTypes.length == vbs.length) {
                for (int i = 0; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i], asm);
                }
            } else if (argTypes.length + 1 == vbs.length) {
                accept(vbs[0], asm);
                for (int i = 1; i < vbs.length; i++) {
                    Value vb = vbs[i];
                    accept(vb, asm);
                    insertI2x(vb.valueType, argTypes[i - 1], asm);
                }
            } else {
                throw new RuntimeException();
            }
            CallSite callSite = ice.callSite;
            asm.visitInvokeDynamicInsn(callSite.getMethodName(), callSite.getMethodProto().getDesc(),
                    Dex2Asm.convertHandler(callSite.getBootstrapMethodHandler()),
                    Dex2Asm.convertConstantValues(callSite.getExtraArguments()));
        }
        break;
        case INVOKE_POLYMORPHIC: {
            InvokePolymorphicExpr ipe = (InvokePolymorphicExpr) value;
            Method m = ipe.method;
            String argTypes[] = ipe.getProto().getParameterTypes();
            Value[] vbs = ipe.getOps();
            accept(vbs[0], asm);
            for (int i = 1; i < vbs.length; i++) {
                Value vb = vbs[i];
                accept(vb, asm);
                insertI2x(vb.valueType, argTypes[i - 1], asm);
            }
            asm.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.getOwner()), m.getName(), ipe.getProto().getDesc(), false);
        }
        }
    }

    private static byte[] collectDataAsByteArray(Value[] ops, String t) {
        switch (t) {
            case "B": {
                byte[] d = new byte[ops.length];
                for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).byteValue();
                }
                return d;
            }
            case "S": {
                short[] d = new short[ops.length];
                for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).shortValue();
                }
                return toLittleEndianArray(d);
            }
            case "I": {
                int[] d = new int[ops.length];
                for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).intValue();
                }
                return toLittleEndianArray(d);
            }
            case "J": {
                long[] d = new long[ops.length];
                for (int i = 0, opsLength = ops.length; i < opsLength; i++) {
                    Value op = ops[i];
                    Constant cst = (Constant) op;
                    d[i] = ((Number) cst.value).longValue();
                }
                return toLittleEndianArray(d);
            }
        }
        return null;
    }

    private static byte[] toLittleEndianArray(Object d) {
        if (d instanceof byte[]) {
            return (byte[]) d;
        } else if (d instanceof short[]) {
            return toLittleEndianArray((short[]) d);
        } else if (d instanceof int[]) {
            return toLittleEndianArray((int[]) d);
        } else if (d instanceof long[]) {
            return toLittleEndianArray((long[]) d);
        }
        return null;
    }

    private static byte[] toLittleEndianArray(long[] d) {
        ByteBuffer b = ByteBuffer.allocate(d.length *8);
        b.order(ByteOrder.LITTLE_ENDIAN);
        b.asLongBuffer().put(d);
        return b.array();
    }

    private static byte[] toLittleEndianArray(int[] d) {
        ByteBuffer b = ByteBuffer.allocate(d.length *4);
        b.order(ByteOrder.LITTLE_ENDIAN);
        b.asIntBuffer().put(d);
        return b.array();
    }

    private static byte[] toLittleEndianArray(short[] d) {
        ByteBuffer b = ByteBuffer.allocate(d.length *2);
        b.order(ByteOrder.LITTLE_ENDIAN);
        b.asShortBuffer().put(d);
        return b.array();
    }

    private static boolean isConstant(Value[] ops) {
        for (Value op : ops) {
            if (op.vt != VT.CONSTANT) {
                return false;
            }
        }
        return true;
    }

    private static void box(String provideType, String expectedType, MethodVisitor asm) {
        if(provideType.equals(expectedType)){
            return;
        }
        if(expectedType.equals("V")){
            switch (provideType.charAt(0)) {
            case 'J':
            case 'D':
                asm.visitInsn(POP2);
                break;
            default:
                asm.visitInsn(POP);
                break;
            }
            return;
        }

        char p = provideType.charAt(0);
        char e = expectedType.charAt(0);

        if (expectedType.equals("Ljava/lang/Object;") && (p == '[' || p == 'L')) {
            return;
        }
        if (provideType.equals("Ljava/lang/Object;") && (e == '[' || e == 'L')) {
            asm.visitTypeInsn(CHECKCAST, toInternal(expectedType));
            return;
        }

        switch (provideType + expectedType) {
        case "ZLjava/lang/Object;":
        case "ZLjava/lang/Boolean;":
            asm.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;", false);
            break;
        case "BLjava/lang/Object;":
        case "BLjava/lang/Byte;":
            asm.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte;", false);
            break;
        case "SLjava/lang/Object;":
        case "SLjava/lang/Short;":
            asm.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short;", false);
            break;
        case "CLjava/lang/Object;":
        case "CLjava/lang/Character;":
            asm.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character;", false);
            break;
        case "ILjava/lang/Object;":
        case "ILjava/lang/Integer;":
            asm.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
            break;
        case "FLjava/lang/Object;":
        case "FLjava/lang/Float;":
            asm.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float;", false);
            break;
        case "JLjava/lang/Object;":
        case "JLjava/lang/Long;":
            asm.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;", false);
            break;
        case "DLjava/lang/Object;":
        case "DLjava/lang/Double;":
            asm.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double;", false);
            break;

        case "Ljava/lang/Object;Z":
            asm.visitTypeInsn(CHECKCAST, "java/lang/Boolean");
            // pass through
        case "Ljava/lang/Boolean;Z":
            asm.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false);
            break;


        case "Ljava/lang/Object;B":
            asm.visitTypeInsn(CHECKCAST, "java/lang/Byte");
            // pass through
        case "Ljava/lang/Byte;B":
            asm.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false);
            break;


        case "Ljava/lang/Object;S":
            asm.visitTypeInsn(CHECKCAST, "java/lang/Short");
            // pass through
        case "Ljava/lang/Short;S":
            asm.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false);
            break;


        case "Ljava/lang/Object;C":
            asm.visitTypeInsn(CHECKCAST, "java/lang/Character");
            // pass through
        case "Ljava/lang/Character;C":
            asm.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false);
            break;


        case "Ljava/lang/Object;I":
            asm.visitTypeInsn(CHECKCAST, "java/lang/Integer");
            // pass through
        case "Ljava/lang/Integer;I":
            asm.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
            break;

        case "Ljava/lang/Object;F":
            asm.visitTypeInsn(CHECKCAST, "java/lang/Float");
            // pass through
        case "Ljava/lang/Float;F":
            asm.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false);
            break;


        case "Ljava/lang/Object;J":
            asm.visitTypeInsn(CHECKCAST, "java/lang/Long");
            // pass through
        case "Ljava/lang/Long;J":
            asm.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false);
            break;

        case "Ljava/lang/Object;D":
            asm.visitTypeInsn(CHECKCAST, "java/lang/Double");
            // pass through
        case "Ljava/lang/Double;D":
            asm.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false);
            break;

        default:
            throw new RuntimeException("i have trouble to auto convert from " + provideType + " to " + expectedType + " currently");
        }
    }

    private void reBuildE1Expression(E1Expr e1, MethodVisitor asm) {
        accept(e1.getOp(), asm);
        switch (e1.vt) {
        case STATIC_FIELD: {
            FieldExpr fe = (FieldExpr) e1;
            asm.visitFieldInsn(GETSTATIC, toInternal(fe.owner), fe.name, fe.type);
            break;
        }
        case FIELD: {
            FieldExpr fe = (FieldExpr) e1;
            asm.visitFieldInsn(GETFIELD, toInternal(fe.owner), fe.name, fe.type);
            break;
        }
        case NEW_ARRAY: {
            TypeExpr te = (TypeExpr) e1;
            switch (te.type.charAt(0)) {
            case '[':
            case 'L':
                asm.visitTypeInsn(ANEWARRAY, toInternal(te.type));
                break;
            case 'Z':
                asm.visitIntInsn(NEWARRAY, T_BOOLEAN);
                break;
            case 'B':
                asm.visitIntInsn(NEWARRAY, T_BYTE);
                break;
            case 'S':
                asm.visitIntInsn(NEWARRAY, T_SHORT);
                break;
            case 'C':
                asm.visitIntInsn(NEWARRAY, T_CHAR);
                break;
            case 'I':
                asm.visitIntInsn(NEWARRAY, T_INT);
                break;
            case 'F':
                asm.visitIntInsn(NEWARRAY, T_FLOAT);
                break;
            case 'J':
                asm.visitIntInsn(NEWARRAY, T_LONG);
                break;
            case 'D':
                asm.visitIntInsn(NEWARRAY, T_DOUBLE);
                break;
            }
        }
            break;
        case CHECK_CAST:
        case INSTANCE_OF: {
            TypeExpr te = (TypeExpr) e1;
            asm.visitTypeInsn(e1.vt == VT.CHECK_CAST ? CHECKCAST : INSTANCEOF, toInternal(te.type));
        }
            break;
        case CAST: {
            CastExpr te = (CastExpr) e1;
            cast2(e1.op.valueType, te.to, asm);
        }
            break;
        case LENGTH:
            asm.visitInsn(ARRAYLENGTH);
            break;
        case NEG:
            asm.visitInsn(getOpcode(e1, INEG));
            break;
        case NOT: // fix issue#207 missing ~ bitwise complement operator
            if (e1.getOp().valueType.equals("I")) {
                asm.visitLdcInsn(-1);
                asm.visitInsn(getOpcode(e1, IXOR));
            } else if (e1.getOp().valueType.equals("J")) {
                asm.visitLdcInsn(-1L);
                asm.visitInsn(getOpcode(e1, IXOR));
            }
            break;
        }
    }

    private void reBuildE2Expression(E2Expr e2, MethodVisitor asm) {
        String type = e2.op2.valueType;
        accept(e2.op1, asm);
        if ((e2.vt == VT.ADD || e2.vt == VT.SUB) && e2.op2.vt == VT.CONSTANT) {
            // [x + (-1)] to [x - 1]
            // [x - (-1)] to [x + 1]
            Constant constant = (Constant) e2.op2;
            String t = constant.valueType;
            switch (t.charAt(0)) {
            case 'S':
            case 'B':
            case 'I': {
                int s = (Integer) constant.value;
                if (s < 0) {
                    asm.visitLdcInsn(-s);
                    asm.visitInsn(getOpcode(type, e2.vt == VT.ADD ? ISUB : IADD));
                    return;
                }
            }
                break;
            case 'F': {
                float s = (Float) constant.value;
                if (s < 0) {
                    asm.visitLdcInsn(-s);
                    asm.visitInsn(getOpcode(type, e2.vt == VT.ADD ? ISUB : IADD));
                    return;
                }
            }
                break;
            case 'J': {
                long s = (Long) constant.value;
                if (s < 0) {
                    asm.visitLdcInsn(-s);
                    asm.visitInsn(getOpcode(type, e2.vt == VT.ADD ? ISUB : IADD));
                    return;
                }
            }
                break;
            case 'D': {
                double s = (Double) constant.value;
                if (s < 0) {
                    asm.visitLdcInsn(-s);
                    asm.visitInsn(getOpcode(type, e2.vt == VT.ADD ? ISUB : IADD));
                    return;
                }
            }
                break;
            }
        }

        accept(e2.op2, asm);

        String tp1 = e2.op1.valueType;
        switch (e2.vt) {
        case ARRAY:
            String tp2 = e2.valueType;
            if (tp1.charAt(0) == '[') {
                asm.visitInsn(getOpcode(tp1.substring(1), IALOAD));
            } else {
                asm.visitInsn(getOpcode(tp2, IALOAD));
            }
            break;
        case ADD:
            asm.visitInsn(getOpcode(type, IADD));
            break;
        case SUB:
            asm.visitInsn(getOpcode(type, ISUB));
            break;
        case IDIV:
        case LDIV:
        case FDIV:
        case DDIV:
            asm.visitInsn(getOpcode(type, IDIV));
            break;
        case MUL:
            asm.visitInsn(getOpcode(type, IMUL));
            break;
        case REM:
            asm.visitInsn(getOpcode(type, IREM));
            break;
        case AND:
            asm.visitInsn(getOpcode(type, IAND));
            break;
        case OR:
            asm.visitInsn(getOpcode(type, IOR));
            break;
        case XOR:
            asm.visitInsn(getOpcode(type, IXOR));
            break;

        case SHL:
            asm.visitInsn(getOpcode(tp1, ISHL));
            break;
        case SHR:
            asm.visitInsn(getOpcode(tp1, ISHR));
            break;
        case USHR:
            asm.visitInsn(getOpcode(tp1, IUSHR));
            break;
        case LCMP:
            asm.visitInsn(LCMP);
            break;
        case FCMPG:
            asm.visitInsn(FCMPG);
            break;
        case DCMPG:
            asm.visitInsn(DCMPG);
            break;
        case FCMPL:
            asm.visitInsn(FCMPL);
            break;
        case DCMPL:
            asm.visitInsn(DCMPL);
            break;
        }
    }

    private static void cast2(String t1, String t2, MethodVisitor asm) {
        if (t1.equals(t2)) {
            return;
        }
        switch (t1.charAt(0)) {
        case 'Z':
        case 'B':
        case 'C':
        case 'S':
        case 'I': {
            switch (t2.charAt(0)) {
            case 'F':
                asm.visitInsn(I2F);
                break;
            case 'J':
                asm.visitInsn(I2L);
                break;
            case 'D':
                asm.visitInsn(I2D);
                break;
            case 'C':
                asm.visitInsn(I2C);
                break;
            case 'B':
                asm.visitInsn(I2B);
                break;
            case 'S':
                asm.visitInsn(I2S);
                break;
            }
        }
            break;
        case 'J': {
            switch (t2.charAt(0)) {
            case 'I':
                asm.visitInsn(L2I);
                break;
            case 'F':
                asm.visitInsn(L2F);
                break;
            case 'D':
                asm.visitInsn(L2D);
                break;
            }
        }
            break;
        case 'D': {
            switch (t2.charAt(0)) {
            case 'I':
                asm.visitInsn(D2I);
                break;
            case 'F':
                asm.visitInsn(D2F);
                break;
            case 'J':
                asm.visitInsn(D2L);
                break;
            }
        }
            break;
        case 'F': {
            switch (t2.charAt(0)) {
            case 'I':
                asm.visitInsn(F2I);
                break;
            case 'J':
                asm.visitInsn(F2L);
                break;
            case 'D':
                asm.visitInsn(F2D);
                break;
            }
            break;
        }
        }
    }
}

```

`dex-translator/src/main/java/com/googlecode/d2j/converter/J2IRConverter.java`:

```java
package com.googlecode.d2j.converter;

import com.googlecode.d2j.CallSite;
import com.googlecode.d2j.MethodHandle;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.dex.Asm2Dex;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.InvokeCustomExpr;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.NewMutiArrayExpr;
import com.googlecode.dex2jar.ir.stmt.*;

import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.Interpreter;
import org.objectweb.asm.tree.analysis.Value;

import java.util.*;

import static org.objectweb.asm.Opcodes.*;

public class J2IRConverter {
    Map<Label, LabelStmt> map = new HashMap<>();
    InsnList insnList;
    int[] parentCount;
    JvmFrame[] frames;
    MethodNode methodNode;
    IrMethod target;
    List<Stmt> emitStmts[];
    List<Stmt> preEmit = new ArrayList<>();
    List<Stmt> currentEmit;

    private J2IRConverter() {
    }

    public static IrMethod convert(String owner, MethodNode methodNode) throws AnalyzerException {
        return new J2IRConverter().convert0(owner, methodNode);
    }

    LabelStmt getLabel(LabelNode labelNode) {
        Label label = labelNode.getLabel();
        LabelStmt ls = map.get(label);
        if (ls == null) {
            ls = Stmts.nLabel();
            map.put(label, ls);
        }
        return ls;
    }

    void emit(Stmt stmt) {
        currentEmit.add(stmt);
    }

    IrMethod populate(String owner, MethodNode source) {
        IrMethod target = new IrMethod();
        target.name = source.name;
        target.owner = "L" + owner + ";";
        target.ret = Type.getReturnType(source.desc).getDescriptor();
        Type[] args = Type.getArgumentTypes(source.desc);
        String sArgs[] = new String[args.length];
        target.args = sArgs;
        for (int i = 0; i < args.length; i++) {
            sArgs[i] = args[i].getDescriptor();
        }
        target.isStatic = 0 != (source.access & Opcodes.ACC_STATIC);
        return target;
    }

    IrMethod convert0(String owner, MethodNode methodNode) throws AnalyzerException {
        this.methodNode = methodNode;
        target = populate(owner, methodNode);
        if (methodNode.instructions.size() == 0) {
            return target;
        }

        insnList = methodNode.instructions;
        BitSet[] exBranch = new BitSet[insnList.size()];
        parentCount = new int[insnList.size()];

        initParentCount(parentCount);


        BitSet handlers = new BitSet(insnList.size());
        if (methodNode.tryCatchBlocks != null) {
            for (TryCatchBlockNode tcb : methodNode.tryCatchBlocks) {
                target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), new LabelStmt[]{getLabel(tcb.handler)},
                        new String[]{tcb.type == null ? null : Type.getObjectType(tcb.type).getDescriptor()}));
                int handlerIdx = insnList.indexOf(tcb.handler);
                handlers.set(handlerIdx);

                for (AbstractInsnNode p = tcb.start.getNext(); p != tcb.end; p = p.getNext()) {

                    BitSet x = exBranch[insnList.indexOf(p)];
                    if (x == null) {
                        x = exBranch[insnList.indexOf(p)] = new BitSet(insnList.size());
                    }
                    x.set(handlerIdx);
                    parentCount[handlerIdx]++;
                }
            }
        }

        Interpreter<JvmValue> interpreter = buildInterpreter();
        frames = new JvmFrame[insnList.size()];
        emitStmts = new ArrayList[insnList.size()];
        BitSet access = new BitSet(insnList.size());

        dfs(exBranch, handlers, access, interpreter);

        StmtList stmts = target.stmts;
        stmts.addAll(preEmit);
        for (int i = 0; i < insnList.size(); i++) {
            AbstractInsnNode p = insnList.get(i);
            if (access.get(i)) {
                List<Stmt> es = emitStmts[i];
                if (es != null) {
                    stmts.addAll(es);
                }
            } else {
                if (p.getType() == AbstractInsnNode.LABEL) {
                    stmts.add(getLabel((LabelNode) p));
                }
            }
        }
        emitStmts = null;


        Queue<JvmValue> queue = new LinkedList<>();

        for (int i1 = 0; i1 < frames.length; i1++) {
            JvmFrame frame = frames[i1];
            if (parentCount[i1] > 1 && frame != null && access.get(i1)) {
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addToQueue(queue, v);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addToQueue(queue, frame.getStack(j));
                }
            }

        }

        while (!queue.isEmpty()) {
            JvmValue v = queue.poll();
            getLocal(v);
            if (v.parent != null) {
                if (v.parent.local == null) {
                    queue.add(v.parent);
                }
            }
            if (v.otherParent != null) {
                for (JvmValue v2 : v.otherParent) {
                    if (v2.local == null) {
                        queue.add(v2);
                    }
                }
            }
        }

        Set<com.googlecode.dex2jar.ir.expr.Value> phiValues = new HashSet<>();
        List<LabelStmt> phiLabels = new ArrayList<>();
        for (int i = 0; i < frames.length; i++) {
            JvmFrame frame = frames[i];
            if (parentCount[i] > 1 && frame != null && access.get(i)) {
                AbstractInsnNode p = insnList.get(i);
                LabelStmt labelStmt = getLabel((LabelNode) p);
                List<AssignStmt> phis = new ArrayList<>();
                for (int j = 0; j < frame.getLocals(); j++) {
                    JvmValue v = frame.getLocal(j);
                    addPhi(v, phiValues, phis);
                }
                for (int j = 0; j < frame.getStackSize(); j++) {
                    addPhi(frame.getStack(j), phiValues, phis);
                }
                labelStmt.phis = phis;
                phiLabels.add(labelStmt);
            }
        }
        if (phiLabels.size() > 0) {
            target.phiLabels = phiLabels;
        }

        return target;

    }

    private void addPhi(JvmValue v, Set<com.googlecode.dex2jar.ir.expr.Value> phiValues, List<AssignStmt> phis) {
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    phiValues.add(getLocal(v.parent));
                }
                if (v.otherParent != null) {
                    for (JvmValue v2 : v.otherParent) {
                        phiValues.add(getLocal(v2));
                    }
                }
                if (phiValues.size() > 0) {
                    phis.add(Stmts.nAssign(v.local, Exprs.nPhi(phiValues.toArray(new com.googlecode.dex2jar.ir.expr.Value[phiValues.size()]))));
                    phiValues.clear();
                }
            }
        }
    }

    private void addToQueue(Queue<JvmValue> queue, JvmValue v) {
        if (v != null) {
            if (v.local != null) {
                if (v.parent != null) {
                    if (v.parent.local == null) {
                        queue.add(v.parent);
                    }
                }
                if (v.otherParent != null) {
                    for (JvmValue v2 : v.otherParent) {
                        if (v2.local == null) {
                            queue.add(v2);
                        }
                    }
                }
            }
        }
    }

    private void dfs(BitSet[] exBranch, BitSet handlers, BitSet access, Interpreter<JvmValue> interpreter) throws AnalyzerException {
        currentEmit = preEmit;
        JvmFrame first = initFirstFrame(methodNode, target);
        if (parentCount[0] > 1) {
            merge(first, 0);
        } else {
            frames[0] = first;
        }
        Stack<AbstractInsnNode> stack = new Stack<>();
        stack.push(insnList.getFirst());

        JvmFrame tmp = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);

        while (!stack.isEmpty()) {
            AbstractInsnNode p = stack.pop();
            int index = insnList.indexOf(p);
            if (!access.get(index)) {
                access.set(index);
            } else {
                continue;
            }
            JvmFrame frame = frames[index];
            setCurrentEmit(index);

            if (p.getType() == AbstractInsnNode.LABEL) {
                emit(getLabel((LabelNode) p));
                if (handlers.get(index)) {
                    Local ex = newLocal();
                    emit(Stmts.nIdentity(ex, Exprs.nExceptionRef("Ljava/lang/Throwable;")));
                    frame.clearStack();
                    frame.push(new JvmValue(1, ex));
                }
            }
            BitSet ex = exBranch[index];
            if (ex != null) {
                for (int i = ex.nextSetBit(0); i >= 0; i = ex.nextSetBit(i + 1)) {
                    mergeEx(frame, i);
                    stack.push(insnList.get(i));
                }
            }

            tmp.init(frame);
            tmp.execute(p, interpreter);

            int op = p.getOpcode();
            if (p.getType() == AbstractInsnNode.JUMP_INSN) {
                JumpInsnNode jump = (JumpInsnNode) p;
                stack.push(jump.label);
                merge(tmp, insnList.indexOf(jump.label));
            }

            if (op == Opcodes.TABLESWITCH || op == Opcodes.LOOKUPSWITCH) {
                if (op == Opcodes.TABLESWITCH) {
                    TableSwitchInsnNode tsin = (TableSwitchInsnNode) p;
                    for (LabelNode label : tsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }
                    stack.push(tsin.dflt);
                    merge(tmp, insnList.indexOf(tsin.dflt));

                } else {
                    LookupSwitchInsnNode lsin = (LookupSwitchInsnNode) p;
                    for (LabelNode label : lsin.labels) {
                        stack.push(label);
                        merge(tmp, insnList.indexOf(label));
                    }
                    stack.push(lsin.dflt);
                    merge(tmp, insnList.indexOf(lsin.dflt));
                }
            }
            if ((op >= Opcodes.GOTO && op <= Opcodes.RETURN) || op == Opcodes.ATHROW) {
                // can't continue
            } else {
                stack.push(p.getNext());
                merge(tmp, index + 1);
            }

            // cleanup frame it is useless
            if (parentCount[index] <= 1) {
                frames[index] = null;
            }

        }
    }

    private void setCurrentEmit(int index) {
        currentEmit = emitStmts[index];
        if (currentEmit == null) {
            currentEmit = emitStmts[index] = new ArrayList<>(1);
        }
    }

    private Interpreter<JvmValue> buildInterpreter() {
        return new Interpreter<JvmValue>(ASM9) {
            @Override
            public JvmValue newValue(Type type) {
                return null;
            }

            @Override
            public JvmValue newOperation(AbstractInsnNode insn) throws AnalyzerException {
                switch (insn.getOpcode()) {
                    case ACONST_NULL:
                        return b(1, Exprs.nNull());
                    case ICONST_M1:
                    case ICONST_0:
                    case ICONST_1:
                    case ICONST_2:
                    case ICONST_3:
                    case ICONST_4:
                    case ICONST_5:
                        return b(1, Exprs.nInt(insn.getOpcode() - ICONST_0));
                    case LCONST_0:
                    case LCONST_1:
                        return b(2, Exprs.nLong(insn.getOpcode() - LCONST_0));
                    case FCONST_0:
                    case FCONST_1:
                    case FCONST_2:
                        return b(1, Exprs.nFloat(insn.getOpcode() - FCONST_0));
                    case DCONST_0:
                    case DCONST_1:
                        return b(2, Exprs.nDouble(insn.getOpcode() - DCONST_0));
                    case BIPUSH:
                    case SIPUSH:
                        return b(1, Exprs.nInt(((IntInsnNode) insn).operand));
                    case LDC:
                        Object cst = ((LdcInsnNode) insn).cst;
                        if (cst instanceof Integer) {
                            return b(1, Exprs.nInt((Integer) cst));
                        } else if (cst instanceof Float) {
                            return b(1, Exprs.nFloat((Float) cst));
                        } else if (cst instanceof Long) {
                            return b(2, Exprs.nLong((Long) cst));
                        } else if (cst instanceof Double) {
                            return b(2, Exprs.nDouble((Double) cst));
                        } else if (cst instanceof String) {
                            return b(1, Exprs.nString((String) cst));
                        } else if (cst instanceof Type) {
                            Type type = (Type) cst;
                            int sort = type.getSort();
                            if (sort == Type.OBJECT || sort == Type.ARRAY) {
                                return b(1, Exprs.nType(type.getDescriptor()));
                            } else if (sort == Type.METHOD) {
                                throw new UnsupportedOperationException("Not supported yet.");
                            } else {
                                throw new IllegalArgumentException("Illegal LDC constant " + cst);
                            }
                        } else if (cst instanceof Handle) {
                            throw new UnsupportedOperationException("Not supported yet.");
                        } else {
                            throw new IllegalArgumentException("Illegal LDC constant " + cst);
                        }
                    case JSR:
                        throw new UnsupportedOperationException("Not supported yet.");
                    case GETSTATIC:
                        FieldInsnNode fin = (FieldInsnNode) insn;
                        return b(Type.getType(fin.desc).getSize(), Exprs.nStaticField("L" + fin.owner + ";", fin.name,
                                fin.desc));
                    case NEW:
                        return b(1, Exprs.nNew("L" + ((TypeInsnNode) insn).desc + ";"));
                    default:
                        throw new Error("Internal error.");
                }
            }

            @Override
            public JvmValue copyOperation(AbstractInsnNode insn, JvmValue value) throws AnalyzerException {
                return b(value.getSize(), getLocal(value));
            }

            @Override
            public JvmValue unaryOperation(AbstractInsnNode insn, JvmValue value0) throws AnalyzerException {
                Local local = value0 == null ? null : getLocal(value0);
                switch (insn.getOpcode()) {
                    case INEG:
                        return b(1, Exprs.nNeg(local, "I"));
                    case IINC:
                        return b(1, Exprs.nAdd(local, Exprs.nInt(((IincInsnNode) insn).incr), "I"));
                    case L2I:
                        return b(1, Exprs.nCast(local, "J", "I"));
                    case F2I:
                        return b(1, Exprs.nCast(local, "F", "I"));
                    case D2I:
                        return b(1, Exprs.nCast(local, "D", "I"));
                    case I2B:
                        return b(1, Exprs.nCast(local, "I", "B"));
                    case I2C:
                        return b(1, Exprs.nCast(local, "I", "C"));
                    case I2S:
                        return b(1, Exprs.nCast(local, "I", "S"));
                    case FNEG:
                        return b(1, Exprs.nNeg(local, "F"));
                    case I2F:
                        return b(1, Exprs.nCast(local, "I", "F"));
                    case L2F:
                        return b(1, Exprs.nCast(local, "J", "F"));
                    case D2F:
                        return b(1, Exprs.nCast(local, "D", "F"));
                    case LNEG:
                        return b(2, Exprs.nNeg(local, "J"));
                    case I2L:
                        return b(2, Exprs.nCast(local, "I", "J"));
                    case F2L:
                        return b(2, Exprs.nCast(local, "F", "J"));
                    case D2L:
                        return b(2, Exprs.nCast(local, "D", "J"));
                    case DNEG:
                        return b(2, Exprs.nNeg(local, "D"));
                    case I2D:
                        return b(2, Exprs.nCast(local, "I", "D"));
                    case L2D:
                        return b(2, Exprs.nCast(local, "J", "D"));
                    case F2D:
                        return b(2, Exprs.nCast(local, "F", "D"));
                    case IFEQ:
                        emit(Stmts.nIf(Exprs.nEq(local, Exprs.nInt(0), "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IFNE:
                        emit(Stmts.nIf(Exprs.nNe(local, Exprs.nInt(0), "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IFLT:
                        emit(Stmts.nIf(Exprs.nLt(local, Exprs.nInt(0), "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IFGE:
                        emit(Stmts.nIf(Exprs.nGe(local, Exprs.nInt(0), "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IFGT:
                        emit(Stmts.nIf(Exprs.nGt(local, Exprs.nInt(0), "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IFLE:
                        emit(Stmts.nIf(Exprs.nLe(local, Exprs.nInt(0), "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case TABLESWITCH: {
                        TableSwitchInsnNode ts = (TableSwitchInsnNode) insn;
                        LabelStmt targets[] = new LabelStmt[ts.labels.size()];
                        for (int i = 0; i < ts.labels.size(); i++) {
                            targets[i] = getLabel((LabelNode) ts.labels.get(i));
                        }
                        emit(Stmts.nTableSwitch(local, ts.min, targets, getLabel(ts.dflt)));
                        return null;
                    }
                    case LOOKUPSWITCH: {
                        LookupSwitchInsnNode ls = (LookupSwitchInsnNode) insn;
                        LabelStmt targets[] = new LabelStmt[ls.labels.size()];
                        int[] lookupValues = new int[ls.labels.size()];
                        for (int i = 0; i < ls.labels.size(); i++) {
                            targets[i] = getLabel((LabelNode) ls.labels.get(i));
                            lookupValues[i] = (Integer) ls.keys.get(i);
                        }
                        emit(Stmts.nLookupSwitch(local, lookupValues, targets, getLabel(ls.dflt)));
                        return null;
                    }
                    case IRETURN:
                    case LRETURN:
                    case FRETURN:
                    case DRETURN:
                    case ARETURN:
                        // skip, move to returnOperation
                        return null;
                    case PUTSTATIC: {
                        FieldInsnNode fin = (FieldInsnNode) insn;
                        emit(Stmts.nAssign(Exprs.nStaticField("L" + fin.owner + ";", fin.name, fin.desc), local));
                        return null;
                    }
                    case GETFIELD: {
                        FieldInsnNode fin = (FieldInsnNode) insn;
                        Type fieldType = Type.getType(fin.desc);
                        return b(fieldType.getSize(), Exprs.nField(local, "L" + fin.owner + ";", fin.name, fin.desc));
                    }
                    case NEWARRAY:
                        switch (((IntInsnNode) insn).operand) {
                            case T_BOOLEAN:
                                return b(1, Exprs.nNewArray("Z", local));
                            case T_CHAR:
                                return b(1, Exprs.nNewArray("C", local));
                            case T_BYTE:
                                return b(1, Exprs.nNewArray("B", local));
                            case T_SHORT:
                                return b(1, Exprs.nNewArray("S", local));
                            case T_INT:
                                return b(1, Exprs.nNewArray("I", local));
                            case T_FLOAT:
                                return b(1, Exprs.nNewArray("F", local));
                            case T_DOUBLE:
                                return b(1, Exprs.nNewArray("D", local));
                            case T_LONG:
                                return b(1, Exprs.nNewArray("J", local));
                            default:
                                throw new AnalyzerException(insn, "Invalid array type");
                        }
                    case ANEWARRAY:
                        String desc = "L" + ((TypeInsnNode) insn).desc + ";";
                        return b(1, Exprs.nNewArray(desc, local));
                    case ARRAYLENGTH:
                        return b(1, Exprs.nLength(local));
                    case ATHROW:
                        emit(Stmts.nThrow(local));
                        return null;
                    case CHECKCAST:
                        String orgDesc = ((TypeInsnNode) insn).desc;
                        desc = orgDesc.startsWith("[") ? orgDesc : ("L" + orgDesc + ";");
                        return b(1, Exprs.nCheckCast(local, desc));
                    case INSTANCEOF:
                        return b(1, Exprs.nInstanceOf(local, "L" + ((TypeInsnNode) insn).desc + ";"));
                    case MONITORENTER:
                        emit(Stmts.nLock(local));
                        return null;
                    case MONITOREXIT:
                        emit(Stmts.nUnLock(local));
                        return null;
                    case IFNULL:
                        emit(Stmts.nIf(Exprs.nEq(local, Exprs.nNull(), "L"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IFNONNULL:
                        emit(Stmts.nIf(Exprs.nNe(local, Exprs.nNull(), "L"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case GOTO: // special case
                        emit(Stmts.nGoto(getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    default:
                        throw new Error("Internal error.");
                }
            }

            JvmValue b(int size, com.googlecode.dex2jar.ir.expr.Value value) {
                Local local = newLocal();
                emit(Stmts.nAssign(local, value));
                return new JvmValue(size, local);
            }

            @Override
            public JvmValue binaryOperation(AbstractInsnNode insn, JvmValue value10, JvmValue value20)
                    throws AnalyzerException {
                Local local1 = getLocal(value10);
                Local local2 = getLocal(value20);
                switch (insn.getOpcode()) {

                    case IALOAD:
                        return b(1, Exprs.nArray(local1, local2, "I"));
                    case BALOAD:
                        return b(1, Exprs.nArray(local1, local2, "B"));
                    case CALOAD:
                        return b(1, Exprs.nArray(local1, local2, "C"));
                    case SALOAD:
                        return b(1, Exprs.nArray(local1, local2, "S"));
                    case FALOAD:
                        return b(1, Exprs.nArray(local1, local2, "F"));
                    case AALOAD:
                        return b(1, Exprs.nArray(local1, local2, "L"));
                    case DALOAD:
                        return b(1, Exprs.nArray(local1, local2, "D"));
                    case LALOAD:
                        return b(1, Exprs.nArray(local1, local2, "J"));
                    case IADD:
                        return b(1, Exprs.nAdd(local1, local2, "I"));
                    case ISUB:
                        return b(1, Exprs.nSub(local1, local2, "I"));
                    case IMUL:
                        return b(1, Exprs.nMul(local1, local2, "I"));
                    case IDIV:
                        return b(1, Exprs.nDiv(local1, local2, "I"));
                    case IREM:
                        return b(1, Exprs.nRem(local1, local2, "I"));
                    case ISHL:
                        return b(1, Exprs.nShl(local1, local2, "I"));
                    case ISHR:
                        return b(1, Exprs.nShr(local1, local2, "I"));
                    case IUSHR:
                        return b(1, Exprs.nUshr(local1, local2, "I"));
                    case IAND:
                        return b(1, Exprs.nAnd(local1, local2, "I"));
                    case IOR:
                        return b(1, Exprs.nOr(local1, local2, "I"));
                    case IXOR:
                        return b(1, Exprs.nXor(local1, local2, "I"));
                    case FADD:
                        return b(1, Exprs.nAdd(local1, local2, "F"));
                    case FSUB:
                        return b(1, Exprs.nSub(local1, local2, "F"));
                    case FMUL:
                        return b(1, Exprs.nMul(local1, local2, "F"));
                    case FDIV:
                        return b(1, Exprs.nDiv(local1, local2, "F"));
                    case FREM:
                        return b(1, Exprs.nRem(local1, local2, "F"));
                    case LADD:
                        return b(2, Exprs.nAdd(local1, local2, "J"));
                    case LSUB:
                        return b(2, Exprs.nSub(local1, local2, "J"));
                    case LMUL:
                        return b(2, Exprs.nMul(local1, local2, "J"));
                    case LDIV:
                        return b(2, Exprs.nDiv(local1, local2, "J"));
                    case LREM:
                        return b(2, Exprs.nRem(local1, local2, "J"));
                    case LSHL:
                        return b(2, Exprs.nShl(local1, local2, "J"));
                    case LSHR:
                        return b(2, Exprs.nShr(local1, local2, "J"));
                    case LUSHR:
                        return b(2, Exprs.nUshr(local1, local2, "J"));
                    case LAND:
                        return b(2, Exprs.nAnd(local1, local2, "J"));
                    case LOR:
                        return b(2, Exprs.nOr(local1, local2, "J"));
                    case LXOR:
                        return b(2, Exprs.nXor(local1, local2, "J"));

                    case DADD:
                        return b(2, Exprs.nAdd(local1, local2, "D"));
                    case DSUB:
                        return b(2, Exprs.nSub(local1, local2, "D"));
                    case DMUL:
                        return b(2, Exprs.nMul(local1, local2, "D"));
                    case DDIV:
                        return b(2, Exprs.nDiv(local1, local2, "D"));
                    case DREM:
                        return b(2, Exprs.nRem(local1, local2, "D"));

                    case LCMP:
                        return b(2, Exprs.nLCmp(local1, local2));
                    case FCMPL:
                        return b(1, Exprs.nFCmpl(local1, local2));
                    case FCMPG:
                        return b(1, Exprs.nFCmpg(local1, local2));
                    case DCMPL:
                        return b(2, Exprs.nDCmpl(local1, local2));
                    case DCMPG:
                        return b(2, Exprs.nDCmpg(local1, local2));

                    case IF_ICMPEQ:
                        emit(Stmts.nIf(Exprs.nEq(local1, local2, "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IF_ICMPNE:
                        emit(Stmts.nIf(Exprs.nNe(local1, local2, "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IF_ICMPLT:
                        emit(Stmts.nIf(Exprs.nLt(local1, local2, "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IF_ICMPGE:
                        emit(Stmts.nIf(Exprs.nGe(local1, local2, "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IF_ICMPGT:
                        emit(Stmts.nIf(Exprs.nGt(local1, local2, "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IF_ICMPLE:
                        emit(Stmts.nIf(Exprs.nLe(local1, local2, "I"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IF_ACMPEQ:
                        emit(Stmts.nIf(Exprs.nEq(local1, local2, "L"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case IF_ACMPNE:
                        emit(Stmts.nIf(Exprs.nNe(local1, local2, "L"),
                                getLabel(((JumpInsnNode) insn).label)));
                        return null;
                    case PUTFIELD:
                        FieldInsnNode fin = (FieldInsnNode) insn;
                        emit(Stmts.nAssign(Exprs.nField(local1, "L" + fin.owner + ";", fin.name, fin.desc), local2));
                        return null;
                    default:
                        throw new Error("Internal error.");
                }
            }

            @Override
            public JvmValue ternaryOperation(AbstractInsnNode insn, JvmValue value1, JvmValue value2, JvmValue value3)
                    throws AnalyzerException {
                Local local1 = getLocal(value1);
                Local local2 = getLocal(value2);
                Local local3 = getLocal(value3);
                switch (insn.getOpcode()) {
                    case IASTORE:
                        emit(Stmts.nAssign(Exprs.nArray(local1, local2, "I"),
                                local3));
                        break;
                    case LASTORE:
                        emit(Stmts.nAssign(Exprs.nArray(local1, local2, "J"),
                                local3));
                        break;
                    case FASTORE:
                        emit(Stmts.nAssign(Exprs.nArray(local1, local2, "F"),
                                local3));
                        break;
                    case DASTORE:
                        emit(Stmts.nAssign(Exprs.nArray(local1, local2, "D"),
                                local3));
                        break;
                    case AASTORE:
                        emit(Stmts.nAssign(Exprs.nArray(local1, local2, "L"),
                                local3));
                        break;
                    case BASTORE:
                        emit(Stmts.nAssign(Exprs.nArray(local1, local2, "B"),
                                local3));
                        break;
                    case CASTORE:
                        emit(Stmts.nAssign(Exprs.nArray(local1, local2, "C"),
                                local3));
                        break;
                    case SASTORE:
                        emit(Stmts.nAssign(Exprs.nArray(local1, local2, "S"),
                                local3));
                        break;
                }

                return null;
            }

            @Override
            public JvmValue naryOperation(AbstractInsnNode insn, List<? extends JvmValue> xvalues) throws AnalyzerException {

                com.googlecode.dex2jar.ir.expr.Value values[] = new com.googlecode.dex2jar.ir.expr.Value[xvalues.size()];
                for (int i = 0; i < xvalues.size(); i++) {
                    values[i] = getLocal(xvalues.get(i));
                }
                if (insn.getOpcode() == MULTIANEWARRAY) {
                    MultiANewArrayInsnNode multi = (MultiANewArrayInsnNode) insn;
                    NewMutiArrayExpr n = Exprs.nNewMutiArray(multi.desc.replaceAll("\\[+", ""), multi.dims, values);
                    return b(Type.getType(multi.desc).getSize(), n);
                } else if (insn.getOpcode() == INVOKEDYNAMIC) {
                    InvokeDynamicInsnNode mi = (InvokeDynamicInsnNode) insn;
                    MethodHandle methodHandle = Asm2Dex.toMethodHandle(mi.bsm);
                    Proto methodType = Asm2Dex.toMethodType(mi.desc);
                    Object[] extraObjects = Asm2Dex.convertConstObjects(mi.bsmArgs);
                    InvokeCustomExpr d = Exprs.nInvokeCustom(values, new CallSite(null, methodHandle, mi.name, methodType, extraObjects));
                    return b(Type.getReturnType(mi.desc).getSize(), d);
                } else {
                    MethodInsnNode mi = (MethodInsnNode) insn;
                    com.googlecode.dex2jar.ir.expr.Value v = null;
                    String ret = Type.getReturnType(mi.desc).getDescriptor();
                    String owner = "L" + mi.owner + ";";
                    String ps[] = Asm2Dex.toDescArray(Type.getArgumentTypes(mi.desc));
                    switch (insn.getOpcode()) {
                        case INVOKEVIRTUAL:
                            v = Exprs.nInvokeVirtual(values, owner, mi.name, ps, ret);
                            break;
                        case INVOKESPECIAL:
                            v = Exprs.nInvokeSpecial(values, owner, mi.name, ps, ret);
                            break;
                        case INVOKESTATIC:
                            v = Exprs.nInvokeStatic(values, owner, mi.name, ps, ret);
                            break;
                        case INVOKEINTERFACE:
                            v = Exprs.nInvokeInterface(values, owner, mi.name, ps, ret);
                            break;
                    }
                    if ("V".equals(ret)) {
                        emit(Stmts.nVoidInvoke(v));
                        return null;
                    } else {
                        return b(Type.getReturnType(mi.desc).getSize(), v);
                    }
                }
            }

            @Override
            public JvmValue merge(JvmValue v, JvmValue w) {
                throw new UnsupportedOperationException("Not supported yet.");
            }

            @Override
            public void returnOperation(AbstractInsnNode insn, JvmValue value, JvmValue expected) throws AnalyzerException {
                switch (insn.getOpcode()) {
                    case IRETURN:
                    case LRETURN:
                    case FRETURN:
                    case DRETURN:
                    case ARETURN:
                        emit(Stmts.nReturn(getLocal(value)));
                        break;
                    case RETURN:
                        emit(Stmts.nReturnVoid());
                        break;
                }

            }
        };
    }

    Local getLocal(JvmValue value) {
        Local local = value.local;
        if (local == null) {
            local = value.local = newLocal();
        }
        return local;
    }

    private void initParentCount(int[] parentCount) {
        parentCount[0] = 1;
        for (AbstractInsnNode p = insnList.getFirst(); p != null; p = p.getNext()) {
            if (p.getType() == AbstractInsnNode.JUMP_INSN) {
                JumpInsnNode jump = (JumpInsnNode) p;
                parentCount[insnList.indexOf(jump.label)]++;
            }
            int op = p.getOpcode();
            if (op == Opcodes.TABLESWITCH || op == Opcodes.LOOKUPSWITCH) {
                if (op == Opcodes.TABLESWITCH) {
                    TableSwitchInsnNode tsin = (TableSwitchInsnNode) p;
                    for (LabelNode label : tsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }
                    parentCount[insnList.indexOf(tsin.dflt)]++;
                } else {
                    LookupSwitchInsnNode lsin = (LookupSwitchInsnNode) p;
                    for (LabelNode label : lsin.labels) {
                        parentCount[insnList.indexOf(label)]++;
                    }
                    parentCount[insnList.indexOf(lsin.dflt)]++;
                }
            }
            if ((op >= Opcodes.GOTO && op <= Opcodes.RETURN) || op == Opcodes.ATHROW) {
                // can't continue
            } else {
                AbstractInsnNode next = p.getNext();
                if(next!=null) {
                    parentCount[insnList.indexOf(p.getNext())]++;
                }
            }
        }
    }

    private void mergeEx(JvmFrame src, int dst) {
        JvmFrame distFrame = frames[dst];
        if (distFrame == null) {
            distFrame = frames[dst] = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);
        }
        for (int i = 0; i < src.getLocals(); i++) {
            JvmValue p = src.getLocal(i);
            JvmValue q = distFrame.getLocal(i);
            if (p != null) {
                if (q == null) {
                    q = new JvmValue(p.getSize());
                    distFrame.setLocal(i, q);
                }
                relate(p, q);
            }
        }
    }

    private void merge(JvmFrame src, int dst) {
        JvmFrame distFrame = frames[dst];
        if (distFrame == null) {
            distFrame = frames[dst] = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);
        }
        if (parentCount[dst] > 1) {
            for (int i = 0; i < src.getLocals(); i++) {
                JvmValue p = src.getLocal(i);
                JvmValue q = distFrame.getLocal(i);
                if (p != null) {
                    if (q == null) {
                        q = new JvmValue(p.getSize());
                        distFrame.setLocal(i, q);
                    }
                    relate(p, q);
                }
            }
            if (src.getStackSize() > 0) {
                if (distFrame.getStackSize() == 0) {
                    for (int i = 0; i < src.getStackSize(); i++) {
                        distFrame.push(new JvmValue(src.getStack(i).getSize()));
                    }
                } else if (distFrame.getStackSize() != src.getStackSize()) {
                    throw new RuntimeException("stack not balanced");
                }
                for (int i = 0; i < src.getStackSize(); i++) {
                    JvmValue p = src.getStack(i);
                    JvmValue q = distFrame.getStack(i);
                    relate(p, q);
                }
            }
        } else {
            distFrame.init(src);
        }
    }

    private void relate(JvmValue parent, JvmValue child) {
        if (child.parent == null) {
            child.parent = parent;
        } else if (child.parent == parent) {
            //
        } else {
            if (child.otherParent == null) {
                child.otherParent = new HashSet<>(5);
            }
            child.otherParent.add(parent);
        }
    }

    private JvmFrame initFirstFrame(MethodNode methodNode, IrMethod target) {
        JvmFrame first = new JvmFrame(methodNode.maxLocals, methodNode.maxStack);
        int x = 0;
        if (!target.isStatic) {// not static
            Local thiz = newLocal();
            emit(Stmts.nIdentity(thiz, Exprs.nThisRef(target.owner)));
            first.setLocal(x++, new JvmValue(1, thiz));
        }
        for (int i = 0; i < target.args.length; i++) {
            Local p = newLocal();
            emit(Stmts.nIdentity(p, Exprs.nParameterRef(target.args[i], i)));
            int sizeOfType = sizeOfType(target.args[i]);
            first.setLocal(x, new JvmValue(sizeOfType, p));
            x += sizeOfType;
        }
        return first;
    }

    private int sizeOfType(String arg) {
        switch (arg.charAt(0)) {
            case 'J':
            case 'D':
                return 2;
            default:
                return 1;
        }
    }

    private Local newLocal() {
        Local thiz = Exprs.nLocal(target.locals.size());
        target.locals.add(thiz);
        return thiz;
    }

    static class JvmFrame extends Frame<JvmValue> {

        public JvmFrame(int nLocals, int nStack) {
            super(nLocals, nStack);
        }

        @Override
        public void execute(AbstractInsnNode insn, Interpreter<JvmValue> interpreter) throws AnalyzerException {
            if (insn.getType() == AbstractInsnNode.FRAME || insn.getType() == AbstractInsnNode.LINE || insn.getType() == AbstractInsnNode.LABEL) {
                return;
            }
            if (insn.getOpcode() == Opcodes.RETURN) {
                interpreter.returnOperation(insn, null, null);
            } else if (insn.getOpcode() == Opcodes.GOTO) {
                interpreter.unaryOperation(insn, null);
            } else if (insn.getOpcode() == RET) {
                throw new RuntimeException("not support yet!");
            } else {
                super.execute(insn, interpreter);
            }
        }
    }

    public static class JvmValue implements Value {
        private final int size;
        public JvmValue parent;
        public Set<JvmValue> otherParent;
        Local local;

        public JvmValue(int size, Local local) {
            this.size = size;
            this.local = local;
        }

        public JvmValue(int size) {
            this.size = size;
        }

        @Override
        public int getSize() {
            return size;
        }
    }

}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/Asm2Dex.java`:

```java
package com.googlecode.d2j.dex;

import com.googlecode.d2j.DexType;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.MethodHandle;
import com.googlecode.d2j.Proto;

import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import java.util.Arrays;

public class Asm2Dex {
    public static Object convertConstantValue(Object ele) {
        if (ele instanceof Type) {
            Type type = (Type) ele;
            if (type.getSort() == Type.METHOD) {
                return new Proto(toDescArray(type.getArgumentTypes()), type.getReturnType().getDescriptor());
            }
            return new DexType(type.getDescriptor());
        } else if (ele instanceof Handle) {
            return toMethodHandle((Handle) ele);
        }
        return ele;
    }

    public static Object[] convertConstObjects(Object[] bsmArgs) {
        if (bsmArgs == null) {
            return null;
        }
        Object[] copy = Arrays.copyOf(bsmArgs, bsmArgs.length);
        for (int i = 0; i < copy.length; i++) {
            Object ele = copy[i];
            ele = convertConstantValue(ele);
            copy[i] = ele;
        }
        return copy;
    }

    public static Proto toMethodType(String desc) {
        return new Proto(toDescArray(Type.getArgumentTypes(desc)), Type.getReturnType(desc).getDescriptor());
    }

    public static MethodHandle toMethodHandle(Handle bsm) {
        switch (bsm.getTag()) {
            case Opcodes.H_GETFIELD:
                return new MethodHandle(MethodHandle.INSTANCE_GET, toField(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            case Opcodes.H_GETSTATIC:
                return new MethodHandle(MethodHandle.STATIC_GET, toField(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            case Opcodes.H_PUTFIELD:
                return new MethodHandle(MethodHandle.INSTANCE_PUT, toField(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            case Opcodes.H_PUTSTATIC:
                return new MethodHandle(MethodHandle.STATIC_PUT, toField(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            case Opcodes.H_INVOKEVIRTUAL:
                return new MethodHandle(MethodHandle.INVOKE_INSTANCE, toMethod(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            case Opcodes.H_INVOKESTATIC:
                return new MethodHandle(MethodHandle.INVOKE_STATIC, toMethod(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            case Opcodes.H_INVOKESPECIAL:
                return new MethodHandle(MethodHandle.INVOKE_DIRECT, toMethod(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            case Opcodes.H_NEWINVOKESPECIAL:
                return new MethodHandle(MethodHandle.INVOKE_CONSTRUCTOR, toMethod(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            case Opcodes.H_INVOKEINTERFACE:
                return new MethodHandle(MethodHandle.INVOKE_INTERFACE, toMethod(bsm.getOwner(), bsm.getName(), bsm.getDesc()));
            default:
                throw new RuntimeException("Not supported yet.");
        }
    }

    static  private Method toMethod(String internalName, String name, String desc) {
        return new Method("L" + internalName + ";", name, toMethodType(desc));
    }

    static private Field toField(String internalName, String name, String desc) {
        return new Field("L" + internalName + ";", name, desc);
    }

    public static String[] toDescArray(Type[] ts) {
        String[] ds = new String[ts.length];
        for (int i = 0; i < ts.length; i++) {
            ds[i] = ts[i].getDescriptor();
        }
        return ds;
    }
}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/BaseDexExceptionHandler.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.node.DexMethodNode;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import java.io.PrintWriter;
import java.io.StringWriter;

public class BaseDexExceptionHandler implements DexExceptionHandler {
    @Override
    public void handleFileException(Exception e) {
        e.printStackTrace(System.err);
    }

    @Override
    public void handleMethodTranslateException(Method method, DexMethodNode methodNode, MethodVisitor mv, Exception e) {
        // replace the generated code with
        // 'return new RuntimeException("D2jFail translate: xxxxxxxxxxxxx");'
        StringWriter s = new StringWriter();
        s.append("d2j fail translate: ");
        e.printStackTrace(new PrintWriter(s));
        String msg = s.toString();
        mv.visitTypeInsn(Opcodes.NEW, "java/lang/RuntimeException");
        mv.visitInsn(Opcodes.DUP);
        mv.visitLdcInsn(msg);
        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V", false);
        mv.visitInsn(Opcodes.ATHROW);
    }
}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/ClassVisitorFactory.java`:

```java
package com.googlecode.d2j.dex;

import org.objectweb.asm.ClassVisitor;

public interface ClassVisitorFactory {

    /**
     * 
     * @param classInternalName
     *            class name
     * @return a ClassVisitor, to generate validate .class file, ClassWriter.COMPUTE_MAXS is required for ClassWriter
     */
    ClassVisitor create(String classInternalName);

}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2Asm.java`:

```java
package com.googlecode.d2j.dex;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.DexType;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.MethodHandle;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.converter.Dex2IRConverter;
import com.googlecode.d2j.converter.IR2JConverter;
import com.googlecode.d2j.node.DexAnnotationNode;
import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFieldNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.node.DexMethodNode;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.ts.AggTransformer;
import com.googlecode.dex2jar.ir.ts.CleanLabel;
import com.googlecode.dex2jar.ir.ts.DeadCodeTransformer;
import com.googlecode.dex2jar.ir.ts.EndRemover;
import com.googlecode.dex2jar.ir.ts.ExceptionHandlerTrim;
import com.googlecode.dex2jar.ir.ts.Ir2JRegAssignTransformer;
import com.googlecode.dex2jar.ir.ts.MultiArrayTransformer;
import com.googlecode.dex2jar.ir.ts.NewTransformer;
import com.googlecode.dex2jar.ir.ts.NpeTransformer;
import com.googlecode.dex2jar.ir.ts.RemoveConstantFromSSA;
import com.googlecode.dex2jar.ir.ts.RemoveLocalFromSSA;
import com.googlecode.dex2jar.ir.ts.TypeTransformer;
import com.googlecode.dex2jar.ir.ts.UnSSATransformer;
import com.googlecode.dex2jar.ir.ts.VoidInvokeTransformer;
import com.googlecode.dex2jar.ir.ts.ZeroTransformer;
import com.googlecode.dex2jar.ir.ts.array.FillArrayTransformer;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Handle;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.signature.SignatureReader;
import org.objectweb.asm.signature.SignatureWriter;
import org.objectweb.asm.tree.InnerClassNode;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.Stack;

public class Dex2Asm {
    private static boolean isPowerOfTwo(int i) {
        return (i & (i - 1)) == 0;
    }

    private static int removeHiddenAccess(int accessFlags) {
        // Refer to art/libdexfile/dex/hidden_api_access_flags.h
        if (!isPowerOfTwo(accessFlags & DexConstants.ACC_VISIBILITY_FLAGS)) {
            accessFlags ^= DexConstants.ACC_VISIBILITY_FLAGS;
        }
        accessFlags &= ~((accessFlags & DexConstants.ACC_NATIVE) != 0 ?
                DexConstants.ACC_DEX_HIDDEN_BIT_NATIVE : DexConstants.ACC_DEX_HIDDEN_BIT);
        return accessFlags;
    }

    public static class ClzCtx {
        public String classDescriptor;
        public String hexDecodeMethodNamePrefix;

        public String buildHexDecodeMethodName(String x) {
            if (hexDecodeMethodNamePrefix == null) {
                byte[] d = new byte[4];
                new Random().nextBytes(d);
                hexDecodeMethodNamePrefix = "$d2j$hex$" + IR2JConverter.hexEncode(d);
            }
            return hexDecodeMethodNamePrefix + "$decode_" + x;
        }
    }
    protected static class Clz {
        public int access;
        public Clz enclosingClass;
        public Method enclosingMethod;
        public String innerName;
        public Set<Clz> inners = null;
        public final String name;

        public Clz(String name) {
            super();
            this.name = name;
        }

        void addInner(Clz clz) {
            if (inners == null) {
                inners = new HashSet<>();
            }
            inners.add(clz);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            Clz other = (Clz) obj;
            if (name == null) {
                return other.name == null;
            } else {
                return name.equals(other.name);
            }
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((name == null) ? 0 : name.hashCode());
            return result;
        }

        public String toString() {
            return "" + name;
        }
    }

    protected static final int ACC_INTERFACE_ABSTRACT = (Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT);

    private static final int NO_CODE_MASK = DexConstants.ACC_ABSTRACT | DexConstants.ACC_NATIVE
            | DexConstants.ACC_ANNOTATION;

    protected static final CleanLabel T_cleanLabel = new CleanLabel();
    protected static final EndRemover T_endRemove = new EndRemover();
    protected static final Ir2JRegAssignTransformer T_ir2jRegAssign = new Ir2JRegAssignTransformer();
    protected static final NewTransformer T_new = new NewTransformer();
    protected static final RemoveConstantFromSSA T_removeConst = new RemoveConstantFromSSA();
    protected static final RemoveLocalFromSSA T_removeLocal = new RemoveLocalFromSSA();
    protected static final ExceptionHandlerTrim T_trimEx = new ExceptionHandlerTrim();
    protected static final TypeTransformer T_type = new TypeTransformer();
    // protected static final TopologicalSort T_topologicalSort = new TopologicalSort();
    protected static final DeadCodeTransformer T_deadCode = new DeadCodeTransformer();
    protected static final FillArrayTransformer T_fillArray = new FillArrayTransformer();
    protected static final AggTransformer T_agg = new AggTransformer();
    protected static final UnSSATransformer T_unssa = new UnSSATransformer();
    protected static final ZeroTransformer T_zero = new ZeroTransformer();
    protected static final VoidInvokeTransformer T_voidInvoke = new VoidInvokeTransformer();
    protected static final NpeTransformer T_npe = new NpeTransformer();
    protected static final MultiArrayTransformer T_multiArray = new MultiArrayTransformer();

    static private int clearClassAccess(boolean isInner, int access) {
        if ((access & Opcodes.ACC_INTERFACE) == 0) { // issue 55
            access |= Opcodes.ACC_SUPER;// 解决生成的class文件使用dx重新转换时使用的指令与原始指令不同的问题
        }
        // access in class has no acc_static or acc_private
        access &= ~(Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE);
        if (isInner && (access & Opcodes.ACC_PROTECTED) != 0) {// protected inner class are public
            access &= ~Opcodes.ACC_PROTECTED;
            access |= Opcodes.ACC_PUBLIC;
        }
        access &= ~DexConstants.ACC_DECLARED_SYNCHRONIZED; // clean ACC_DECLARED_SYNCHRONIZED
        return access;
    }

    static private int clearInnerAccess(int access) {
        access &= (~Opcodes.ACC_SUPER);// inner class attr has no acc_super
        if (0 != (access & Opcodes.ACC_PRIVATE)) {// clear public/protected if it is private
            access &= ~(Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED);
        } else if (0 != (access & Opcodes.ACC_PROTECTED)) {// clear public if it is protected
            access &= ~(Opcodes.ACC_PUBLIC);
        }
        return access;
    }

    protected static String toInternalName(DexType type) {
        return toInternalName(type.desc);
    }

    protected static String toInternalName(String desc) {
        // TODO without creating object
        return Type.getType(desc).getInternalName();
    }

    public static void accept(DexAnnotationNode ann, ClassVisitor v) {
        AnnotationVisitor av = v.visitAnnotation(ann.type, ann.visibility != Visibility.BUILD);
        if (av != null) {
            accept(ann.items, av);
            av.visitEnd();
        }
    }

    public static void accept(List<DexAnnotationNode> anns, ClassVisitor cv) {
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, cv);
                }
            }
        }
    }

    public static void accept(List<DexAnnotationNode> anns, FieldVisitor fv) {
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, fv);
                }
            }
        }
    }

    public static void accept(List<DexAnnotationNode> anns, MethodVisitor mv) {
        if (anns != null) {
            for (DexAnnotationNode ann : anns) {
                if (ann.visibility != Visibility.SYSTEM) {
                    accept(ann, mv);
                }
            }
        }
    }

    public static void accept(DexAnnotationNode ann, MethodVisitor v) {
        AnnotationVisitor av = v.visitAnnotation(ann.type, ann.visibility != Visibility.BUILD);
        if (av != null) {
            accept(ann.items, av);
            av.visitEnd();
        }
    }

    public static void acceptParameter(DexAnnotationNode ann, int index, MethodVisitor v) {
        AnnotationVisitor av = v.visitParameterAnnotation(index, ann.type, ann.visibility != Visibility.BUILD);
        if (av != null) {
            accept(ann.items, av);
            av.visitEnd();
        }
    }

    public static void accept(DexAnnotationNode ann, FieldVisitor v) {
        AnnotationVisitor av = v.visitAnnotation(ann.type, ann.visibility != Visibility.BUILD);
        if (av != null) {
            accept(ann.items, av);
            av.visitEnd();
        }
    }

    public static void accept(List<DexAnnotationNode.Item> items, AnnotationVisitor av) {
        for (DexAnnotationNode.Item item : items) {
            accept(av, item.name, item.value);
        }
    }

    private static void accept(AnnotationVisitor dav, String name, Object o) {
        if (o instanceof Object[]) {
            AnnotationVisitor arrayVisitor = dav.visitArray(name);
            if (arrayVisitor != null) {
                Object[] array = (Object[]) o;
                for (Object e : array) {
                    accept(arrayVisitor, null, e);
                }
                arrayVisitor.visitEnd();
            }
        } else if (o instanceof DexAnnotationNode) {
            DexAnnotationNode ann = (DexAnnotationNode) o;
            AnnotationVisitor av = dav.visitAnnotation(name, ann.type);
            if (av != null) {
                for (DexAnnotationNode.Item item : ann.items) {
                    accept(av, item.name, item.value);
                }
                av.visitEnd();
            }
        } else if (o instanceof Field) {
            Field f = (Field) o;
            dav.visitEnum(name, f.getType(), f.getName());
        } else if (o instanceof DexType) {
            dav.visit(name, Type.getType(((DexType) o).desc));
        } else if (o instanceof Method) {
            System.err.println("WARN: ignored method annotation value");
        } else {
            if (o == null) {
                System.err.println("WARN: ignored null annotation value");
            } else {
                dav.visit(name, o);
            }
        }
    }

    private static MethodVisitor collectBasicMethodInfo(DexMethodNode methodNode, ClassVisitor cv) {
        String[] xthrows = null;
        String signature = null;
        if (methodNode.anns != null) {
            for (DexAnnotationNode ann : methodNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_THROWS_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, "value");
                        if (strs != null) {
                            xthrows = new String[strs.length];
                            for (int i = 0; i < strs.length; i++) {
                                DexType type = (DexType) strs[i];
                                xthrows[i] = toInternalName(type);
                            }
                        }
                    }
                        break;
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, "value");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        if (isSignatureNotValid(signature, false)) {
            System.err.println("Applying workaround to method "
                    + methodNode.method
                    + " with original signature " + signature
                    + " by changing its signature to null");
            signature = null;
        }

        // HiddenApiAccessFlags is valid for .dex but not for .class
        int access = removeHiddenAccess(methodNode.access);
        // clear ACC_DECLARED_SYNCHRONIZED and ACC_CONSTRUCTOR from method flags
        final int cleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | DexConstants.ACC_CONSTRUCTOR));
        access &= cleanFlag;
        return cv.visitMethod(access, methodNode.method.getName(), methodNode.method.getDesc(), signature, xthrows);
    }

    protected static Map<String, Clz> collectClzInfo(DexFileNode fileNode) {
        Map<String, Clz> classes = new HashMap<>();
        for (DexClassNode classNode : fileNode.clzs) {
            Clz clz = get(classes, classNode.className);
            clz.access = (clz.access & ~ACC_INTERFACE_ABSTRACT) | classNode.access;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM) {
                        switch (ann.type) {
                        case DexConstants.ANNOTATION_ENCLOSING_CLASS_TYPE: {
                            DexType type = (DexType) findAnnotationAttribute(ann, "value");
                            Clz enclosingClass = get(classes, type.desc);
                            clz.enclosingClass = enclosingClass;

                            // apply patch from ChaeHoon Lim,
                            // obfuscated code may declare itself as enclosing class
                            // which cause dex2jar to endless loop
                            //if(!clz.name.equals(clz.enclosingClass.name)) {
                            //    enclosingClass.addInner(clz);
                            //}
                            enclosingClass.addInner(clz);

                        }
                            break;
                        case DexConstants.ANNOTATION_ENCLOSING_METHOD_TYPE: {
                            Method m = (Method) findAnnotationAttribute(ann, "value");
                            Clz enclosingClass = get(classes, m.getOwner());
                            clz.enclosingClass = enclosingClass;
                            clz.enclosingMethod = m;
                            enclosingClass.addInner(clz);
                        }
                            break;
                        case DexConstants.ANNOTATION_INNER_CLASS_TYPE: {
                            for (DexAnnotationNode.Item it : ann.items) {
                                if ("accessFlags".equals(it.name)) {
                                    clz.access |= (Integer) it.value & ~ACC_INTERFACE_ABSTRACT;
                                } else if ("name".equals(it.name)) {
                                    clz.innerName = (String) it.value;
                                }
                            }
                        }
                            break;
                        case DexConstants.ANNOTATION_MEMBER_CLASSES_TYPE: {
                            Object[] ts = (Object[]) findAnnotationAttribute(ann, "value");
                            for (Object v : ts) {
                                DexType type = (DexType) v;
                                Clz inner = get(classes, type.desc);
                                clz.addInner(inner);
                                inner.enclosingClass = clz;
                            }
                        }
                            break;
                        }
                    }
                }
            }
        }
        return classes;
    }

    public void convertClass(DexClassNode classNode, ClassVisitorFactory cvf, DexFileNode fileNode) {
        convertClass(fileNode.dexVersion, classNode, cvf, collectClzInfo(fileNode));
    }

    public void convertClass(DexClassNode classNode, ClassVisitorFactory cvf) {
        convertClass(DexConstants.DEX_035, classNode, cvf);
    }
    public void convertClass(int dexVersion, DexClassNode classNode, ClassVisitorFactory cvf) {
        convertClass(dexVersion, classNode, cvf, new HashMap<String, Clz>());
    }

    private static boolean isJavaIdentifier(String str) {
        if (str.length() < 1) {
            return false;
        }
        if (!Character.isJavaIdentifierStart(str.charAt(0))) {
            return false;
        }
        for (int i = 1; i < str.length(); i++) {
            if (!Character.isJavaIdentifierPart(str.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    public void convertClass(DexClassNode classNode, ClassVisitorFactory cvf, Map<String, Clz> classes) {
        convertClass(DexConstants.DEX_035, classNode, cvf, classes);
    }
    public void convertClass(DexFileNode dfn, DexClassNode classNode, ClassVisitorFactory cvf, Map<String, Clz> classes) {
        convertClass(dfn.dexVersion, classNode, cvf, classes);
    }
    public void convertClass(int dexVersion, DexClassNode classNode, ClassVisitorFactory cvf, Map<String, Clz> classes) {
        ClassVisitor cv = cvf.create(toInternalName(classNode.className));
        if (cv == null) {
            return;
        }
        // the default value of static-final field are omitted by dex, fix it
        DexFix.fixStaticFinalFieldValue(classNode);

        String signature = null;
        if (classNode.anns != null) {
            for (DexAnnotationNode ann : classNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE: {
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, "value");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                    }
                        break;
                    }
                }
            }
        }
        String[] interfaceInterNames = null;
        if (classNode.interfaceNames != null) {
            interfaceInterNames = new String[classNode.interfaceNames.length];
            for (int i = 0; i < classNode.interfaceNames.length; i++) {
                interfaceInterNames[i] = toInternalName(classNode.interfaceNames[i]);
            }
        }

        Clz clzInfo = classes.get(classNode.className);
        int access = classNode.access;
        boolean isInnerClass = false;
        if (clzInfo != null) {
            isInnerClass = clzInfo.enclosingClass != null || clzInfo.enclosingMethod != null;
        }
        access = clearClassAccess(isInnerClass, access);

        if (isSignatureNotValid(signature, false)) {
            System.err.println("Applying workaround to class "
                    + classNode.className
                    + " with original signature " + signature
                    + " by changing its signature to null.");
            signature = null;
        }

        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_8 : Opcodes.V1_6;
        cv.visit(version, access, toInternalName(classNode.className), signature,
                classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);

        List<InnerClassNode> innerClassNodes = new ArrayList<>(5);
        if (clzInfo != null) {
            searchInnerClass(clzInfo, innerClassNodes, classNode.className);
        }
        if (isInnerClass) {
            // build Outer Clz
            if (clzInfo.innerName == null) {// anonymous Innerclass
                Method enclosingMethod = clzInfo.enclosingMethod;
                if (enclosingMethod != null) {
                    cv.visitOuterClass(toInternalName(enclosingMethod.getOwner()), enclosingMethod.getName(),
                            enclosingMethod.getDesc());
                } else {
                    Clz enclosingClass = clzInfo.enclosingClass;
                    cv.visitOuterClass(toInternalName(enclosingClass.name), null, null);
                }
            }
            searchEnclosing(clzInfo, innerClassNodes);
        }
        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);
        for (InnerClassNode icn : innerClassNodes) {
            if (icn.innerName != null && !isJavaIdentifier(icn.innerName)) {
                System.err.println("WARN: ignored invalid inner class name " + ", treat as anonymous inner class.");
                icn.innerName = null;
                icn.outerName = null;
            }
            icn.accept(cv);
        }

        accept(classNode.anns, cv);

        if (classNode.fields != null) {
            for (DexFieldNode fieldNode : classNode.fields) {
                convertField(classNode, fieldNode, cv);
            }
        }
        if (classNode.methods != null) {
            ClzCtx clzCtx = new ClzCtx();
            clzCtx.classDescriptor = classNode.className;
            for (DexMethodNode methodNode : classNode.methods) {
                convertMethod(classNode, methodNode, cv, clzCtx);
            }
            if (clzCtx.hexDecodeMethodNamePrefix != null) {
                addHexDecodeMethod(cv, classNode.className.replaceFirst("^L", "").replaceAll(";$", ""),
                        clzCtx.hexDecodeMethodNamePrefix);
            }
        }
        cv.visitEnd();
    }

    private static final String HEX_CLASS_LOCATION = "res/Hex";

    private static final Set<String> HEX_DECODE_METHODS =
            new HashSet<>(Arrays.asList("decode_J", "decode_I", "decode_S", "decode_B"));

    protected InputStream getHexClassAsStream() {
        return Dex2Asm.class.getResourceAsStream("/" + HEX_CLASS_LOCATION + ".class");
    }

    private void addHexDecodeMethod(ClassVisitor outCV, String className, String hexDecodeMethodNameBase) {
        InputStream hexClassStream = getHexClassAsStream();
        if (hexClassStream == null) {
            return;
        }

        try (InputStream is = hexClassStream) {
            ClassReader cr = new ClassReader(is);
            cr.accept(new ClassVisitor(Opcodes.ASM9) {
                @Override
                public MethodVisitor visitMethod(int access, String name, String desc, String signature,
                                                 String[] exceptions) {
                    if (HEX_DECODE_METHODS.contains(name)) {
                        return new MethodVisitor(Opcodes.ASM9,
                                outCV.visitMethod(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC,
                                        hexDecodeMethodNameBase + "$" + name, desc, signature, exceptions)) {
                            @Override
                            public void visitMethodInsn(int opcode, String owner, String name, String descriptor,
                                                        boolean isInterface) {
                                if (owner.equals(HEX_CLASS_LOCATION)) {
                                    super.visitMethodInsn(opcode, className, hexDecodeMethodNameBase + "$" + name,
                                            descriptor, isInterface);
                                } else {
                                    super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
                                }
                            }
                        };
                    } else {
                        return super.visitMethod(access, name, desc, signature, exceptions);
                    }
                }
            }, ClassReader.EXPAND_FRAMES);
        } catch (Throwable t) {
            throw new RuntimeException("Failed to add " + HEX_CLASS_LOCATION + ".decode_*", t);
        }
    }
    public void convertCode(DexMethodNode methodNode, MethodVisitor mv, ClzCtx clzCtx) {
        IrMethod irMethod = dex2ir(methodNode);
        optimize(irMethod);
        ir2j(irMethod, mv, clzCtx);
    }

    public void convertDex(DexFileNode fileNode, ClassVisitorFactory cvf) {
        if (fileNode.clzs != null) {
            Map<String, Clz> classes = collectClzInfo(fileNode);
            for (DexClassNode classNode : fileNode.clzs) {
                convertClass(fileNode, classNode, cvf, classes);
            }
        }
    }

    public void convertField(DexClassNode classNode, DexFieldNode fieldNode, ClassVisitor cv) {
        String signature = null;
        if (fieldNode.anns != null) {
            for (DexAnnotationNode ann : fieldNode.anns) {
                if (ann.visibility == Visibility.SYSTEM) {
                    switch (ann.type) {
                    case DexConstants.ANNOTATION_SIGNATURE_TYPE:
                        Object[] strs = (Object[]) findAnnotationAttribute(ann, "value");
                        if (strs != null) {
                            StringBuilder sb = new StringBuilder();
                            for (Object str : strs) {
                                sb.append(str);
                            }
                            signature = sb.toString();
                        }
                        break;
                    }
                }
            }
        }
        Object value = convertConstantValue(fieldNode.cst);

        // https://github.com/pxb1988/dex2jar/issues/455
        // try validate signature before call visitField
        if (isSignatureNotValid(signature, true)) {
            System.err.println("Applying workaround to field "
                    + fieldNode.field
                    + " with original signature " + signature
                    + " by changing its signature to null.");
            signature = null;
        }

        // HiddenApiAccessFlags is valid for .dex but not for .class
        int access = removeHiddenAccess(fieldNode.access);
        final int fieldCleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | Opcodes.ACC_SYNTHETIC));
        FieldVisitor fv = cv.visitField(access & fieldCleanFlag, fieldNode.field.getName(),
                fieldNode.field.getType(), signature, value);

        if (fv == null) {
            return;
        }
        accept(fieldNode.anns, fv);
        fv.visitEnd();
    }

    /**
     * @see org.objectweb.asm.commons.Remapper#mapSignature(String, boolean)
     */
    private static boolean isSignatureNotValid(String signature, boolean typeSignature) {
        if (signature == null) {
            return false;
        }
        try {
            SignatureReader r = new SignatureReader(signature);
            SignatureWriter a = new SignatureWriter();

            if (typeSignature) {
                r.acceptType(a);
            } else {
                r.accept(a);
            }
        } catch (Exception ignore) {
            return true;
        }
        return false;
    }

    public static Object[] convertConstantValues(Object[] v) {
        if (v == null) {
            return null;
        }
        Object[] copy = Arrays.copyOf(v, v.length);
        for (int i = 0; i < copy.length; i++) {
            Object ele = copy[i];
            ele = convertConstantValue(ele);
            copy[i] = ele;
        }
        return copy;
    }

    public static Object convertConstantValue(Object ele) {
        if (ele instanceof DexType) {
            ele = Type.getType(((DexType) ele).desc);
        } else if (ele instanceof MethodHandle) {
            ele = convertHandler((MethodHandle) ele);
        } else if (ele instanceof Proto) {
            ele = Type.getMethodType(((Proto) ele).getDesc());
        }
        return ele;
    }

    public static Handle convertHandler(MethodHandle ele) {
        Handle h = null;
        switch (ele.getType()) {
            case MethodHandle.INSTANCE_GET:
                h = new Handle(Opcodes.H_GETFIELD, toInternalName(ele.getField().getOwner()), ele.getField().getName(), ele.getField().getType(), false);
                break;
            case MethodHandle.INSTANCE_PUT:
                h = new Handle(Opcodes.H_PUTFIELD, toInternalName(ele.getField().getOwner()), ele.getField().getName(), ele.getField().getType(), false);
                break;
            case MethodHandle.STATIC_GET:
                h = new Handle(Opcodes.H_GETSTATIC, toInternalName(ele.getField().getOwner()), ele.getField().getName(), ele.getField().getType(), false);
                break;
            case MethodHandle.STATIC_PUT:
                h = new Handle(Opcodes.H_PUTSTATIC, toInternalName(ele.getField().getOwner()), ele.getField().getName(), ele.getField().getType(), false);
                break;
            case MethodHandle.INVOKE_INSTANCE:
                h = new Handle(Opcodes.H_INVOKEVIRTUAL, toInternalName(ele.getMethod().getOwner()), ele.getMethod().getName(), ele.getMethod().getDesc(), false);
                break;
            case MethodHandle.INVOKE_STATIC:
                h = new Handle(Opcodes.H_INVOKESTATIC, toInternalName(ele.getMethod().getOwner()), ele.getMethod().getName(), ele.getMethod().getDesc(), false);
                break;
            case MethodHandle.INVOKE_CONSTRUCTOR:
                h = new Handle(Opcodes.H_NEWINVOKESPECIAL, toInternalName(ele.getMethod().getOwner()), ele.getMethod().getName(), ele.getMethod().getDesc(), false);
                break;
            case MethodHandle.INVOKE_DIRECT:
                h = new Handle(Opcodes.H_INVOKESPECIAL, toInternalName(ele.getMethod().getOwner()), ele.getMethod().getName(), ele.getMethod().getDesc(), false);
                break;
            case MethodHandle.INVOKE_INTERFACE:
                h = new Handle(Opcodes.H_INVOKEINTERFACE, toInternalName(ele.getMethod().getOwner()), ele.getMethod().getName(), ele.getMethod().getDesc(), true);
                break;
        }
        return h;
    }

    public void convertMethod(DexClassNode classNode, DexMethodNode methodNode, ClassVisitor cv, ClzCtx clzCtx) {

        MethodVisitor mv = collectBasicMethodInfo(methodNode, cv);

        if (mv == null) {
            return;
        }
        if (0 != (classNode.access & DexConstants.ACC_ANNOTATION)) { // its inside an annotation
            Object defaultValue = null;
            if (classNode.anns != null) {
                for (DexAnnotationNode ann : classNode.anns) {
                    if (ann.visibility == Visibility.SYSTEM && ann.type.equals(DexConstants.ANNOTATION_DEFAULT_TYPE)) {
                        DexAnnotationNode node = (DexAnnotationNode) findAnnotationAttribute(ann, "value");
                        if (node != null) {
                            defaultValue = findAnnotationAttribute(node, methodNode.method.getName());
                        }
                        break;
                    }
                }
            }
            if (defaultValue != null) {
                AnnotationVisitor av = mv.visitAnnotationDefault();
                if (av != null) {
                    accept(av, null, defaultValue);
                    av.visitEnd();
                }
            }
        }

        accept(methodNode.anns, mv);

        if (methodNode.parameterAnns != null) {
            for (int i = 0; i < methodNode.parameterAnns.length; i++) {
                List<DexAnnotationNode> anns = methodNode.parameterAnns[i];
                if (anns != null) {
                    for (DexAnnotationNode ann : anns) {
                        if (ann.visibility != Visibility.SYSTEM) {
                            acceptParameter(ann, i, mv);
                        }
                    }
                }
            }
        }

        if ((NO_CODE_MASK & methodNode.access) == 0) { // has code
            if (methodNode.codeNode != null) {
                mv.visitCode();
                convertCode(methodNode, mv, clzCtx);
            }
        }

        mv.visitEnd();

    }

    public IrMethod dex2ir(DexMethodNode methodNode) {
        return new Dex2IRConverter()
                .convert(0 != (methodNode.access & DexConstants.ACC_STATIC), methodNode.method, methodNode.codeNode);
    }

    protected static Object findAnnotationAttribute(DexAnnotationNode ann, String name) {
        for (DexAnnotationNode.Item item : ann.items) {
            if (item.name.equals(name)) {
                return item.value;
            }
        }
        return null;
    }

    private static Clz get(Map<String, Clz> classes, String name) {
        Clz clz = classes.get(name);
        if (clz == null) {
            clz = new Clz(name);
            classes.put(name, clz);
        }
        return clz;
    }

    public void ir2j(IrMethod irMethod, MethodVisitor mv, ClzCtx clzCtx) {
        new IR2JConverter()
                .optimizeSynchronized(false)
                .clzCtx(clzCtx)
                .ir(irMethod)
                .asm(mv)
                .convert();
        mv.visitMaxs(-1, -1);
    }

    public void optimize(IrMethod irMethod) {
        T_cleanLabel.transform(irMethod);
        T_deadCode.transform(irMethod);
        T_removeLocal.transform(irMethod);
        T_removeConst.transform(irMethod);
        T_zero.transform(irMethod);
        if (T_npe.transformReportChanged(irMethod)) {
            T_deadCode.transform(irMethod);
            T_removeLocal.transform(irMethod);
            T_removeConst.transform(irMethod);
        }
        T_new.transform(irMethod);
        T_fillArray.transform(irMethod);
        T_agg.transform(irMethod);
        T_multiArray.transform(irMethod);
        T_voidInvoke.transform(irMethod);

        {
            // https://github.com/pxb1988/dex2jar/issues/477
            // dead code found in unssa, clean up
            T_deadCode.transform(irMethod);
            T_removeLocal.transform(irMethod);
            T_removeConst.transform(irMethod);
        }
        T_type.transform(irMethod);
        T_unssa.transform(irMethod);
        T_trimEx.transform(irMethod);
        T_ir2jRegAssign.transform(irMethod);
    }

    /**
     * For structure
     * 
     * <pre>
     * class A {
     *     class B {
     *         class WeAreHere {
     *         }
     *     }
     * }
     * </pre>
     * 
     * this method will add
     * 
     * <pre>
     * InnerClass  Outter
     * A$B$WeAreHere A$B
     * A$B           A
     * </pre>
     * 
     * to WeAreHere.class
     * 
     */
    private static void searchEnclosing(Clz clz, List<InnerClassNode> innerClassNodes) {
        Set<Clz> visitedClz = new HashSet<>();
        for (Clz p = clz; p != null; p = p.enclosingClass) {
            if (!visitedClz.add(p)) { // prevent endless loop
                break;
            }
            Clz enclosingClass = p.enclosingClass;
            if (enclosingClass == null) {
                break;
            }
            if (enclosingClass == clz) {
                // enclosing itself, that is impossible
                break;
            }
            int accessInInner = clearInnerAccess(p.access);
            if (p.innerName != null) {// non-anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name),
                        toInternalName(enclosingClass.name), p.innerName, accessInInner));
            } else {// anonymous Innerclass
                innerClassNodes.add(new InnerClassNode(toInternalName(p.name), null, null, accessInInner));
            }
        }
    }

    /**
     * For structure
     * 
     * <pre>
     * class WeAreHere {
     *     class A {
     *         class B {
     * 
     *         }
     *     }
     * }
     * </pre>
     * 
     * this method will add
     * 
     * <pre>
     * InnerClass      Outter
     * WeAreHere$A$B   WeAreHere$A
     * WeAreHere$A     WeAreHere
     * </pre>
     * 
     * to WeAreHere.class
     * 
     * @param clz
     */
    private static void searchInnerClass(Clz clz, List<InnerClassNode> innerClassNodes, String className) {
        Set<Clz> visited = new HashSet<>();
        Stack<Clz> stack = new Stack<>();
        stack.push(clz);
        while (!stack.empty()) {
            clz = stack.pop();
            if (visited.contains(clz)) {
                continue;
            } else {
                visited.add(clz);
            }
            if (clz.inners != null) {
                for (Clz inner : clz.inners) {
                    if (inner.innerName == null) {// anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), null, null,
                                clearInnerAccess(inner.access)));
                    } else {// non-anonymous Innerclass
                        innerClassNodes.add(new InnerClassNode(toInternalName(inner.name), toInternalName(className),
                                inner.innerName, clearInnerAccess(inner.access)));
                    }
                    stack.push(inner);
                }
            }
        }
    }

    private static final Comparator<InnerClassNode> INNER_CLASS_NODE_COMPARATOR = new Comparator<InnerClassNode>() {
        @Override
        public int compare(InnerClassNode o1, InnerClassNode o2) {
            return o1.name.compareTo(o2.name);
        }
    };

}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2IrAdapter.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex;

import static com.googlecode.dex2jar.ir.expr.Exprs.nAdd;
import static com.googlecode.dex2jar.ir.expr.Exprs.nAnd;
import static com.googlecode.dex2jar.ir.expr.Exprs.nArray;
import static com.googlecode.dex2jar.ir.expr.Exprs.nArrayValue;
import static com.googlecode.dex2jar.ir.expr.Exprs.nCast;
import static com.googlecode.dex2jar.ir.expr.Exprs.nCheckCast;
import static com.googlecode.dex2jar.ir.expr.Exprs.nDCmpg;
import static com.googlecode.dex2jar.ir.expr.Exprs.nDCmpl;
import static com.googlecode.dex2jar.ir.expr.Exprs.nDiv;
import static com.googlecode.dex2jar.ir.expr.Exprs.nExceptionRef;
import static com.googlecode.dex2jar.ir.expr.Exprs.nFCmpg;
import static com.googlecode.dex2jar.ir.expr.Exprs.nFCmpl;
import static com.googlecode.dex2jar.ir.expr.Exprs.nField;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInstanceOf;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInt;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInvokeInterface;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInvokeNew;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInvokeSpecial;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInvokeStatic;
import static com.googlecode.dex2jar.ir.expr.Exprs.nInvokeVirtual;
import static com.googlecode.dex2jar.ir.expr.Exprs.nLCmp;
import static com.googlecode.dex2jar.ir.expr.Exprs.nLength;
import static com.googlecode.dex2jar.ir.expr.Exprs.nLong;
import static com.googlecode.dex2jar.ir.expr.Exprs.nMul;
import static com.googlecode.dex2jar.ir.expr.Exprs.nNeg;
import static com.googlecode.dex2jar.ir.expr.Exprs.nNew;
import static com.googlecode.dex2jar.ir.expr.Exprs.nNewArray;
import static com.googlecode.dex2jar.ir.expr.Exprs.nNot;
import static com.googlecode.dex2jar.ir.expr.Exprs.nOr;
import static com.googlecode.dex2jar.ir.expr.Exprs.nRem;
import static com.googlecode.dex2jar.ir.expr.Exprs.nShl;
import static com.googlecode.dex2jar.ir.expr.Exprs.nShr;
import static com.googlecode.dex2jar.ir.expr.Exprs.nStaticField;
import static com.googlecode.dex2jar.ir.expr.Exprs.nString;
import static com.googlecode.dex2jar.ir.expr.Exprs.nSub;
import static com.googlecode.dex2jar.ir.expr.Exprs.nType;
import static com.googlecode.dex2jar.ir.expr.Exprs.nUshr;
import static com.googlecode.dex2jar.ir.expr.Exprs.nXor;
import static com.googlecode.dex2jar.ir.stmt.Stmts.*;

import java.util.*;

import com.googlecode.d2j.node.DexCodeNode;
import com.googlecode.d2j.node.TryCatchNode;
import com.googlecode.d2j.node.insn.DexLabelStmtNode;
import com.googlecode.d2j.node.insn.FilledNewArrayStmtNode;
import com.googlecode.d2j.node.insn.DexStmtNode;
import com.googlecode.d2j.node.insn.MethodStmtNode;
import com.googlecode.d2j.visitors.DexDebugVisitor;
import com.googlecode.dex2jar.ir.TypeClass;
import org.objectweb.asm.Opcodes;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.DexType;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.Trap;
import com.googlecode.dex2jar.ir.expr.Exprs;
import com.googlecode.dex2jar.ir.expr.Local;
import com.googlecode.dex2jar.ir.expr.Value;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import com.googlecode.dex2jar.ir.stmt.StmtList;
import com.googlecode.dex2jar.ir.stmt.Stmts;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class Dex2IrAdapter extends DexCodeVisitor implements Opcodes, DexConstants {

    protected IrMethod irMethod;
    private Method method;
    private boolean isStatic;
    private StmtList list;
    private Local[] locals;
    Map<DexLabel, LabelStmt> labelStmtMap = new HashMap<>();
    /**
     * 函数调用的返回值保存的寄存器
     */
    private Local tmpLocal;

    /**
     * @param isStatic
     * @param method
     */
    public Dex2IrAdapter(boolean isStatic, Method method) {
        super();
        IrMethod irMethod = new IrMethod();
        irMethod.args = method.getParameterTypes();
        irMethod.ret = method.getReturnType();
        irMethod.owner = method.getOwner();
        irMethod.name = method.getName();
        irMethod.isStatic = isStatic;
        this.irMethod = irMethod;
        this.list = irMethod.stmts;
        this.irMethod = irMethod;
        this.method = method;
        this.isStatic = isStatic;
    }

    private LabelStmt toLabelStmt(DexLabel label) {
        LabelStmt ls = labelStmtMap.get(label);
        if (ls == null) {
            ls = new LabelStmt();
            labelStmtMap.put(label, ls);
        }
        return ls;
    }

    static int countParameterRegisters(Method m, boolean isStatic) {
        int a = isStatic ? 0 : 1;
        for (String t : m.getParameterTypes()) {
            switch (t.charAt(0)) {
            case 'J':
            case 'D':
                a += 2;
                break;
            default:
                a += 1;
                break;
            }
        }
        return a;
    }

    void x(Stmt stmt) {
        list.add(stmt);
    }

    @Override
    public void visitRegister(int total) {
        Local[] locals = new Local[total];
        this.locals = locals;
        this.tmpLocal = new Local(total);
        for (int i = 0; i < locals.length; i++) {
            locals[i] = new Local(i);
        }
        int nextReg = total - countParameterRegisters(method, isStatic);
        int nextReg0 = nextReg;
        if (!isStatic) {// is not static
            x(Stmts.nIdentity(locals[nextReg], Exprs.nThisRef(method.getOwner())));
            nextReg++;
        }
        String[] args = method.getParameterTypes();
        for (int i = 0; i < args.length; i++) {
            String t = args[i];
            x(Stmts.nIdentity(locals[nextReg], Exprs.nParameterRef(t, i)));
            nextReg++;
            if (t.equals("J") || t.equals("D")) {
                nextReg++;
            }
        }
        // simple fix for issue 219, init all tmp register to 0 at the start of insn.
        for (int i = 0; i < nextReg0; i++) {
            x(Stmts.nAssign(locals[i], nInt(0)));
        }
        x(Stmts.nAssign(tmpLocal, nInt(0)));
    }

    @Override
    public void visitStmt2R1N(Op op, int a, int b, int content) {
        Local va = locals[a];
        Local vb = locals[b];
        Value to;
        switch (op) {
        case ADD_INT_LIT16:
        case ADD_INT_LIT8:
            to = nAdd(vb, nInt(content), "I");
            break;
        case RSUB_INT_LIT8:
        case RSUB_INT://
            to = nSub(nInt(content), vb, "I");
            break;
        case MUL_INT_LIT8:
        case MUL_INT_LIT16:
            to = nMul(vb, nInt(content), "I");
            break;
        case DIV_INT_LIT16:
        case DIV_INT_LIT8:
            to = nDiv(vb, nInt(content), "I");
            break;
        case REM_INT_LIT16:
        case REM_INT_LIT8:
            to = nRem(vb, nInt(content), "I");
            break;
        case AND_INT_LIT16:
        case AND_INT_LIT8:
            to = nAnd(vb, nInt(content), content < 0 || content > 1 ? "I" : TypeClass.ZI.name);
            break;
        case OR_INT_LIT16:
        case OR_INT_LIT8:
            to = nOr(vb, nInt(content), content < 0 || content > 1 ? "I" : TypeClass.ZI.name);
            break;
        case XOR_INT_LIT16:
        case XOR_INT_LIT8:
            to = nXor(vb, nInt(content), content < 0 || content > 1 ? "I" : TypeClass.ZI.name);
            break;
        case SHL_INT_LIT8:
            to = nShl(vb, nInt(content), "I");
            break;
        case SHR_INT_LIT8:
            to = nShr(vb, nInt(content), "I");
            break;
        case USHR_INT_LIT8:
            to = nUshr(vb, nInt(content), "I");
            break;
        default:
            throw new RuntimeException();
        }
        x(nAssign(va, to));
    }

    @Override
    public void visitStmt3R(Op op, int a, int b, int c) {
        Value va = locals[a];
        Value vb = locals[b];
        Value vc = locals[c];
        switch (op) {
        case APUT:
            x(nAssign(nArray(vb, vc, TypeClass.IF.name), va));
            break;
        case APUT_BOOLEAN:
            x(nAssign(nArray(vb, vc, "Z"), va));
            break;
        case APUT_BYTE:
            x(nAssign(nArray(vb, vc, "B"), va));
            break;
        case APUT_CHAR:
            x(nAssign(nArray(vb, vc, "C"), va));
            break;
        case APUT_OBJECT:
            x(nAssign(nArray(vb, vc, "L"), va));
            break;
        case APUT_SHORT:
            x(nAssign(nArray(vb, vc, "S"), va));
            break;
        case APUT_WIDE:
            x(nAssign(nArray(vb, vc, TypeClass.JD.name), va));
            break;
        case AGET:
            x(nAssign(va, nArray(vb, vc, TypeClass.IF.name)));
            break;
        case AGET_BOOLEAN:
            x(nAssign(va, nArray(vb, vc, "Z")));
            break;
        case AGET_BYTE:
            x(nAssign(va, nArray(vb, vc, "B")));
            break;
        case AGET_CHAR:
            x(nAssign(va, nArray(vb, vc, "C")));
            break;
        case AGET_OBJECT:
            x(nAssign(va, nArray(vb, vc, "L")));
            break;
        case AGET_SHORT:
            x(nAssign(va, nArray(vb, vc, "S")));
            break;
        case AGET_WIDE:
            x(nAssign(va, nArray(vb, vc, TypeClass.JD.name)));
            break;
        case CMP_LONG:
            x(nAssign(va, nLCmp(vb, vc)));
            break;
        case CMPG_DOUBLE:
            x(nAssign(va, nDCmpg(vb, vc)));
            break;
        case CMPG_FLOAT:
            x(nAssign(va, nFCmpg(vb, vc)));
            break;
        case CMPL_DOUBLE:
            x(nAssign(va, nDCmpl(vb, vc)));
            break;
        case CMPL_FLOAT:
            x(nAssign(va, nFCmpl(vb, vc)));
            break;
        case ADD_DOUBLE:
            x(nAssign(va, nAdd(vb, vc, "D")));
            break;
        case ADD_FLOAT:
            x(nAssign(va, nAdd(vb, vc, "F")));
            break;
        case ADD_INT:
            x(nAssign(va, nAdd(vb, vc, "I")));
            break;
        case ADD_LONG:
            x(nAssign(va, nAdd(vb, vc, "J")));
            break;
        case SUB_DOUBLE:
            x(nAssign(va, nSub(vb, vc, "D")));
            break;
        case SUB_FLOAT:
            x(nAssign(va, nSub(vb, vc, "F")));
            break;
        // case RSUB_INT:
        // x(nAssign(va, nSub(vc, vb, "I")));
        // break;
        case SUB_INT:
            x(nAssign(va, nSub(vb, vc, "I")));
            break;
        case SUB_LONG:
            x(nAssign(va, nSub(vb, vc, "J")));
            break;
        case MUL_DOUBLE:
            x(nAssign(va, nMul(vb, vc, "D")));
            break;
        case MUL_FLOAT:
            x(nAssign(va, nMul(vb, vc, "F")));
            break;
        case MUL_INT:
            x(nAssign(va, nMul(vb, vc, "I")));
            break;
        case MUL_LONG:
            x(nAssign(va, nMul(vb, vc, "J")));
            break;
        case DIV_DOUBLE:
            x(nAssign(va, nDiv(vb, vc, "D")));
            break;
        case DIV_FLOAT:
            x(nAssign(va, nDiv(vb, vc, "F")));
            break;
        case DIV_INT:
            x(nAssign(va, nDiv(vb, vc, "I")));
            break;
        case DIV_LONG:
            x(nAssign(va, nDiv(vb, vc, "J")));
            break;
        case REM_DOUBLE:
            x(nAssign(va, nRem(vb, vc, "D")));
            break;
        case REM_FLOAT:
            x(nAssign(va, nRem(vb, vc, "F")));
            break;
        case REM_INT:
            x(nAssign(va, nRem(vb, vc, "I")));
            break;
        case REM_LONG:
            x(nAssign(va, nRem(vb, vc, "J")));
            break;
        case AND_INT:
            x(nAssign(va, nAnd(vb, vc, TypeClass.ZI.name)));
            break;
        case AND_LONG:
            x(nAssign(va, nAnd(vb, vc, "J")));
            break;
        case OR_INT:
            x(nAssign(va, nOr(vb, vc, TypeClass.ZI.name)));
            break;
        case OR_LONG:
            x(nAssign(va, nOr(vb, vc, "J")));
            break;
        case XOR_INT:
            x(nAssign(va, nXor(vb, vc, TypeClass.ZI.name)));
            break;
        case XOR_LONG:
            x(nAssign(va, nXor(vb, vc, "J")));
            break;
        case SHL_INT:
            x(nAssign(va, nShl(vb, vc, "I")));
            break;
        case SHL_LONG:
            x(nAssign(va, nShl(vb, vc, "J")));
            break;
        case SHR_INT:
            x(nAssign(va, nShr(vb, vc, "I")));
            break;
        case SHR_LONG:
            x(nAssign(va, nShr(vb, vc, "J")));
            break;
        case USHR_INT:
            x(nAssign(va, nUshr(vb, vc, "I")));
            break;
        case USHR_LONG:
            x(nAssign(va, nUshr(vb, vc, "J")));
            break;
        default:
            throw new RuntimeException();
        }
    }

    @Override
    public void visitTypeStmt(Op op, int a, int b, String type) {
        switch (op) {
        case INSTANCE_OF:
            list.add(nAssign(locals[a], nInstanceOf(locals[b], type)));
            break;
        case NEW_ARRAY:
            list.add(nAssign(locals[a], nNewArray(type.substring(1), locals[b])));
            break;
        case CHECK_CAST:
            list.add(nAssign(locals[a], nCheckCast(locals[a], type)));
            break;
        case NEW_INSTANCE:
            list.add(nAssign(locals[a], nNew(type)));
            break;
        default:
            throw new RuntimeException();
        }
    }

    @Override
    public void visitFillArrayDataStmt(Op op, int ra, Object array) {
        x(nFillArrayData(locals[ra], nArrayValue(array)));
    }

    @Override
    public void visitConstStmt(Op op, int toReg, Object value) {
        switch (op) {
        case CONST:
        case CONST_16:
        case CONST_4:
        case CONST_HIGH16:
            x(nAssign(locals[toReg], nInt((Integer) value)));
            break;
        case CONST_WIDE:
        case CONST_WIDE_16:
        case CONST_WIDE_32:
        case CONST_WIDE_HIGH16:
            x(nAssign(locals[toReg], nLong((Long) value)));
            break;
        case CONST_CLASS:
            x(nAssign(locals[toReg], nType((DexType) value)));
            break;
        case CONST_STRING:
        case CONST_STRING_JUMBO:
            x(nAssign(locals[toReg], nString((String) value)));
            break;
        default:
            throw new RuntimeException();
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.googlecode.dex2jar.visitors.DexCodeVisitor#visitEnd()
     */
    @Override
    public void visitEnd() {
        irMethod.locals.addAll(Arrays.asList(this.locals));
        irMethod.locals.add(tmpLocal);
        this.locals = null;
    }

    @Override
    public void visitFieldStmt(Op op, int a, int b, Field field) {
        switch (op) {
        case IGET:
        case IGET_BOOLEAN:
        case IGET_BYTE:
        case IGET_CHAR:
        case IGET_OBJECT:
        case IGET_SHORT:
        case IGET_WIDE:
            list.add(nAssign(locals[a], nField(locals[b], field.getOwner(), field.getName(), field.getType())));
            break;
        case IPUT:
        case IPUT_BOOLEAN:
        case IPUT_BYTE:
        case IPUT_CHAR:
        case IPUT_OBJECT:
        case IPUT_SHORT:
        case IPUT_WIDE:
            list.add(nAssign(nField(locals[b], field.getOwner(), field.getName(), field.getType()), locals[a]));
            break;
        case SGET:
        case SGET_BOOLEAN:
        case SGET_BYTE:
        case SGET_CHAR:
        case SGET_OBJECT:
        case SGET_SHORT:
        case SGET_WIDE:
            list.add(nAssign(locals[a], nStaticField(field.getOwner(), field.getName(), field.getType())));
            break;
        case SPUT:
        case SPUT_BOOLEAN:
        case SPUT_BYTE:
        case SPUT_CHAR:
        case SPUT_OBJECT:
        case SPUT_SHORT:
        case SPUT_WIDE:
            list.add(nAssign(nStaticField(field.getOwner(), field.getName(), field.getType()), locals[a]));
            break;
        default:
            throw new RuntimeException();
        }
    }

    @Override
    public void visitFilledNewArrayStmt(Op opc, int[] args, String type) {
        Local array = tmpLocal;
        String elem = type.substring(1);
        list.add(nAssign(array, nNewArray(elem, nInt(args.length))));
        for (int i = 0; i < args.length; i++) {
            list.add(nAssign(nArray(array, nInt(i), elem), locals[args[i]]));
        }
    }

    @Override
    public void visitJumpStmt(Op op, int a, int b, DexLabel label) {
        switch (op) {
        case GOTO:
        case GOTO_16:
        case GOTO_32:
            x(nGoto(toLabelStmt(label)));
            break;
        case IF_EQ:
            x(nIf(Exprs.nEq(locals[a], locals[b], TypeClass.ZIL.name), toLabelStmt(label)));
            break;
        case IF_GE:
            x(nIf(Exprs.nGe(locals[a], locals[b], "I"), toLabelStmt(label)));
            break;
        case IF_GT:
            x(nIf(Exprs.nGt(locals[a], locals[b], "I"), toLabelStmt(label)));
            break;
        case IF_LE:
            x(nIf(Exprs.nLe(locals[a], locals[b], "I"), toLabelStmt(label)));
            break;
        case IF_LT:
            x(nIf(Exprs.nLt(locals[a], locals[b], "I"), toLabelStmt(label)));
            break;
        case IF_NE:
            x(nIf(Exprs.nNe(locals[a], locals[b], TypeClass.ZIL.name), toLabelStmt(label)));
            break;
        case IF_EQZ:
            x(nIf(Exprs.nEq(locals[a], nInt(0), TypeClass.ZIL.name), toLabelStmt(label)));
            break;
        case IF_GEZ:
            x(nIf(Exprs.nGe(locals[a], nInt(0), "I"), toLabelStmt(label)));
            break;
        case IF_GTZ:
            x(nIf(Exprs.nGt(locals[a], nInt(0), "I"), toLabelStmt(label)));
            break;
        case IF_LEZ:
            x(nIf(Exprs.nLe(locals[a], nInt(0), "I"), toLabelStmt(label)));
            break;
        case IF_LTZ:
            x(nIf(Exprs.nLt(locals[a], nInt(0), "I"), toLabelStmt(label)));
            break;
        case IF_NEZ:
            x(nIf(Exprs.nNe(locals[a], nInt(0), TypeClass.ZIL.name), toLabelStmt(label)));
            break;
        default:
            throw new RuntimeException();
        }
    }

    @Override
    public void visitLabel(DexLabel label) {
        list.add(toLabelStmt(label));
    }

    @Override
    public void visitSparseSwitchStmt(Op op, int aA, int[] cases, DexLabel[] labels) {
        LabelStmt[] lss = new LabelStmt[cases.length];
        for (int i = 0; i < cases.length; i++) {
            lss[i] = toLabelStmt(labels[i]);
        }
        LabelStmt d = new LabelStmt();
        x(nLookupSwitch(locals[aA], cases, lss, d));
        x(d);
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, Method method) {
        Value[] vs;
        if (args.length > 0) {
            int i = 0;
            List<Local> ps = new ArrayList<Local>(args.length);
            if (op == Op.INVOKE_STATIC || op == Op.INVOKE_STATIC_RANGE) {
                ;
            } else {
                ps.add(locals[args[i]]);
                i++;
            }
            for (String t : method.getParameterTypes()) {
                ps.add(locals[args[i]]);
                if (t.equals("J") || t.equals("D")) {
                    i += 2;
                } else {
                    i++;
                }
            }
            vs = ps.toArray(new Value[ps.size()]);
        } else {
            vs = new Value[0];
        }

        Value invoke = null;
        switch (op) {
        case INVOKE_VIRTUAL_RANGE:
        case INVOKE_VIRTUAL:
            invoke = nInvokeVirtual(vs, method.getOwner(), method.getName(), method.getParameterTypes(),
                    method.getReturnType());
            break;
        case INVOKE_SUPER_RANGE:
        case INVOKE_DIRECT_RANGE:
        case INVOKE_SUPER:
        case INVOKE_DIRECT:
            invoke = nInvokeSpecial(vs, method.getOwner(), method.getName(), method.getParameterTypes(),
                    method.getReturnType());
            break;
        case INVOKE_STATIC_RANGE:
        case INVOKE_STATIC:
            invoke = nInvokeStatic(vs, method.getOwner(), method.getName(), method.getParameterTypes(),
                    method.getReturnType());
            break;
        case INVOKE_INTERFACE_RANGE:
        case INVOKE_INTERFACE:
            invoke = nInvokeInterface(vs, method.getOwner(), method.getName(), method.getParameterTypes(),
                    method.getReturnType());
            break;
        default:
            throw new RuntimeException();
        }
        if ("V".equals(method.getReturnType())) {
            x(nVoidInvoke(invoke));
        } else {
            x(nAssign(tmpLocal, invoke));
        }
    }

    @Override
    public void visitStmt1R(Op op, int reg) {
        Local va = locals[reg];
        switch (op) {
        case MONITOR_ENTER:
            x(nLock(va));
            break;
        case MONITOR_EXIT:
            x(nUnLock(va));
            break;
        case RETURN:
        case RETURN_WIDE:
        case RETURN_OBJECT:
            x(nReturn(va));
            break;
        case THROW:
            x(nThrow(va));
            break;
        case MOVE_RESULT:
        case MOVE_RESULT_WIDE:
        case MOVE_RESULT_OBJECT:
            if (lastIsInvokeOrFilledNewArray) { // right position
                x(nAssign(va, tmpLocal));
            } else { // wrong position, replace with throw new RuntimeExceptoin("...");
                System.err.println("WARN: find wrong position of " + op + " in method " + method);
                x(nThrow(nInvokeNew(new Value[] { nString("d2j: wrong position of " + op) },
                        new String[] { "Ljava/lang/String;" }, "Ljava/lang/RuntimeException;")));
            }

            break;
        case MOVE_EXCEPTION:
            x(nIdentity(va, nExceptionRef("Ljava/lang/Throwable;")));
            break;
        default:
            throw new RuntimeException();
        }
    }

    @Override
    public void visitStmt2R(Op op, int a, int b) {
        Local va = locals[a];
        Local vb = locals[b];
        Value to = null;
        switch (op) {
        case MOVE:
        case MOVE_16:
        case MOVE_FROM16:
        case MOVE_OBJECT:
        case MOVE_OBJECT_16:
        case MOVE_OBJECT_FROM16:
        case MOVE_WIDE:
        case MOVE_WIDE_FROM16:
        case MOVE_WIDE_16:
            to = vb;
            break;
        case ARRAY_LENGTH:
            to = nLength(vb);
            break;
        case ADD_DOUBLE_2ADDR:
            to = nAdd(va, vb, "D");
            break;
        case ADD_FLOAT_2ADDR:
            to = nAdd(va, vb, "F");
            break;
        case ADD_INT_2ADDR:
            to = nAdd(va, vb, "I");
            break;
        case ADD_LONG_2ADDR:
            to = nAdd(va, vb, "J");
            break;
        case SUB_DOUBLE_2ADDR:
            to = nSub(va, vb, "D");
            break;
        case SUB_FLOAT_2ADDR:
            to = nSub(va, vb, "F");
            break;
        case SUB_INT_2ADDR:
            to = nSub(va, vb, "I");
            break;
        case SUB_LONG_2ADDR:
            to = nSub(va, vb, "J");
            break;
        case MUL_DOUBLE_2ADDR:
            to = nMul(va, vb, "D");
            break;
        case MUL_FLOAT_2ADDR:
            to = nMul(va, vb, "F");
            break;
        case MUL_INT_2ADDR:
            to = nMul(va, vb, "I");
            break;
        case MUL_LONG_2ADDR:
            to = nMul(va, vb, "J");
            break;
        case DIV_DOUBLE_2ADDR:
            to = nDiv(va, vb, "D");
            break;
        case DIV_FLOAT_2ADDR:
            to = nDiv(va, vb, "F");
            break;
        case DIV_INT_2ADDR:
            to = nDiv(va, vb, "I");
            break;
        case DIV_LONG_2ADDR:
            to = nDiv(va, vb, "J");
            break;
        case REM_DOUBLE_2ADDR:
            to = nRem(va, vb, "D");
            break;
        case REM_FLOAT_2ADDR:
            to = nRem(va, vb, "F");
            break;
        case REM_INT_2ADDR:
            to = nRem(va, vb, "I");
            break;
        case REM_LONG_2ADDR:
            to = nRem(va, vb, "J");
            break;
        case AND_INT_2ADDR:
            to = nAnd(va, vb, TypeClass.ZI.name);
            break;
        case AND_LONG_2ADDR:
            to = nAnd(va, vb, "J");
            break;
        case OR_INT_2ADDR:
            to = nOr(va, vb, TypeClass.ZI.name);
            break;
        case OR_LONG_2ADDR:
            to = nOr(va, vb, "J");
            break;
        case XOR_INT_2ADDR:
            to = nXor(va, vb, TypeClass.ZI.name);
            break;
        case XOR_LONG_2ADDR:
            to = nXor(va, vb, "J");
            break;
        case SHL_INT_2ADDR:
            to = nShl(va, vb, "I");
            break;
        case SHL_LONG_2ADDR:
            to = nShl(va, vb, "J");
            break;
        case SHR_INT_2ADDR:
            to = nShr(va, vb, "I");
            break;
        case SHR_LONG_2ADDR:
            to = nShr(va, vb, "J");
            break;
        case USHR_INT_2ADDR:
            to = nUshr(va, vb, "I");
            break;
        case USHR_LONG_2ADDR:
            to = nUshr(va, vb, "J");
            break;
        case NOT_INT:
            to = nNot(vb, "I");
            break;
        case NOT_LONG:
            to = nNot(vb, "J");
            break;
        case NEG_DOUBLE:
            to = nNeg(vb, "D");
            break;
        case NEG_FLOAT:
            to = nNeg(vb, "F");
            break;
        case NEG_INT:
            to = nNeg(vb, "I");
            break;
        case NEG_LONG:
            to = nNeg(vb, "J");
            break;
        case INT_TO_BYTE:
            to = nCast(vb, "I", "B");
            break;
        case INT_TO_CHAR:
            to = nCast(vb, "I", "C");
            break;
        case INT_TO_DOUBLE:
            to = nCast(vb, "I", "D");
            break;
        case INT_TO_FLOAT:
            to = nCast(vb, "I", "F");
            break;
        case INT_TO_LONG:
            to = nCast(vb, "I", "J");
            break;
        case INT_TO_SHORT:
            to = nCast(vb, "I", "S");
            break;
        case FLOAT_TO_DOUBLE:
            to = nCast(vb, "F", "D");
            break;
        case FLOAT_TO_INT:
            to = nCast(vb, "F", "I");
            break;
        case FLOAT_TO_LONG:
            to = nCast(vb, "F", "J");
            break;
        case DOUBLE_TO_FLOAT:
            to = nCast(vb, "D", "F");
            break;
        case DOUBLE_TO_INT:
            to = nCast(vb, "D", "I");
            break;
        case DOUBLE_TO_LONG:
            to = nCast(vb, "D", "J");
            break;
        case LONG_TO_DOUBLE:
            to = nCast(vb, "J", "D");
            break;
        case LONG_TO_FLOAT:
            to = nCast(vb, "J", "F");
            break;
        case LONG_TO_INT:
            to = nCast(vb, "J", "I");
            break;
        default:
            throw new RuntimeException();
        }
        x(nAssign(va, to));
    }

    @Override
    public void visitStmt0R(Op op) {
        switch (op) {
        case RETURN_VOID:
            x(nReturnVoid());
            break;
        case NOP:
            // ignore
            break;
        case BAD_OP:
            x(nThrow(nInvokeNew(new Value[] { nString("bad dex opcode") }, new String[] { "Ljava/lang/String;" },
                    "Ljava/lang/VerifyError;")));
            break;
        default:
            throw new RuntimeException();
        }
    }

    @Override
    public void visitPackedSwitchStmt(Op op, int aA, int first_case, DexLabel[] labels) {
        LabelStmt[] lss = new LabelStmt[labels.length];
        for (int i = 0; i < labels.length; i++) {
            lss[i] = toLabelStmt(labels[i]);
        }
        LabelStmt d = new LabelStmt();
        x(nTableSwitch(locals[aA], first_case, lss, d));
        x(d);
    }

    @Override
    public void visitTryCatch(DexLabel start, DexLabel end, DexLabel[] handlers, String[] types) {
        LabelStmt xlabelStmts[] = new LabelStmt[types.length];
        for (int i = 0; i < types.length; i++) {
            xlabelStmts[i] = toLabelStmt(handlers[i]);
        }
        irMethod.traps.add(new Trap(toLabelStmt(start), toLabelStmt(end), xlabelStmts, types));
    }

    boolean lastIsInvokeOrFilledNewArray = false;

    public IrMethod convert(DexCodeNode codeNode) {
        if (codeNode.tryStmts != null) {
            for (TryCatchNode n : codeNode.tryStmts) {
                n.accept(this);
            }
        }
        if (codeNode.debugNode != null) {
            DexDebugVisitor ddv = this.visitDebug();
            if (ddv != null) {
                codeNode.debugNode.accept(ddv);
                ddv.visitEnd();
            }
        }
        lastIsInvokeOrFilledNewArray = false;
        if (codeNode.totalRegister >= 0) {
            this.visitRegister(codeNode.totalRegister);
        }
        for (DexStmtNode n : codeNode.stmts) {
            n.accept(this);
            if (n instanceof FilledNewArrayStmtNode) {
                lastIsInvokeOrFilledNewArray = true;
            } else if (n instanceof MethodStmtNode) {
                lastIsInvokeOrFilledNewArray = !((MethodStmtNode) n).method.getReturnType().equals("V");
            } else if (!(n instanceof DexLabelStmtNode)) {
                lastIsInvokeOrFilledNewArray = false;
            }
        }

        visitEnd();
        return irMethod;
    }
}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2jar.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.spi.FileSystemProvider;
import java.util.HashMap;
import java.util.Map;

import com.googlecode.d2j.node.DexMethodNode;
import com.googlecode.d2j.reader.BaseDexFileReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import com.googlecode.d2j.converter.IR2JConverter;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.zip.ZipUtil;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;

public class Dex2jar {
    public static Dex2jar from(byte[] in) throws IOException {
        return from(new DexFileReader(ZipUtil.readDex(in)));
    }

    public static Dex2jar from(ByteBuffer in) throws IOException {
        return from(new DexFileReader(in));
    }

    public static Dex2jar from(BaseDexFileReader reader) {
        return new Dex2jar(reader);
    }

    public static Dex2jar from(File in) throws IOException {
        return from(Files.readAllBytes(in.toPath()));
    }

    public static Dex2jar from(InputStream in) throws IOException {
        return from(new DexFileReader(in));
    }

    public static Dex2jar from(String in) throws IOException {
        return from(new File(in));
    }

    private DexExceptionHandler exceptionHandler;

    final private BaseDexFileReader reader;
    private int readerConfig;
    private int v3Config;

    private Dex2jar(BaseDexFileReader reader) {
        super();
        this.reader = reader;
        readerConfig |= DexFileReader.SKIP_DEBUG;
    }

    private void doTranslate(final Path dist) {

        DexFileNode fileNode = new DexFileNode();
        try {
            reader.accept(fileNode, readerConfig | DexFileReader.IGNORE_READ_EXCEPTION);
        } catch (Exception ex) {
            exceptionHandler.handleFileException(ex);
        }
        ClassVisitorFactory cvf = new ClassVisitorFactory() {
            @Override
            public ClassVisitor create(final String name) {
                final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
                final LambadaNameSafeClassAdapter rca = new LambadaNameSafeClassAdapter(cw);
                return new ClassVisitor(Opcodes.ASM9, rca) {
                    @Override
                    public void visitEnd() {
                        super.visitEnd();
                        String className = rca.getClassName();
                        byte[] data;
                        try {
                            // FIXME handle 'java.lang.RuntimeException: Method code too large!'
                            data = cw.toByteArray();
                        } catch (Exception ex) {
                            System.err.printf("ASM fail to generate .class file: %s%n", className);
                            exceptionHandler.handleFileException(ex);
                            return;
                        }
                        try {
                            Path dist1 = dist.resolve(className + ".class");
                            Path parent = dist1.getParent();
                            if (parent != null && !Files.exists(parent)) {
                                Files.createDirectories(parent);
                            }
                            Files.write(dist1, data);
                        } catch (IOException e) {
                            e.printStackTrace(System.err);
                        }
                    }
                };
            }
        };

        new ExDex2Asm(exceptionHandler) {
            public void convertCode(DexMethodNode methodNode, MethodVisitor mv, ClzCtx clzCtx) {
                if ((readerConfig & DexFileReader.SKIP_CODE) != 0 && methodNode.method.getName().equals("<clinit>")) {
                    // also skip clinit
                    return;
                }
                super.convertCode(methodNode, mv, clzCtx);
            }

            @Override
            public void optimize(IrMethod irMethod) {
                T_cleanLabel.transform(irMethod);
                if (0 != (v3Config & V3.TOPOLOGICAL_SORT)) {
                    // T_topologicalSort.transform(irMethod);
                }
                T_deadCode.transform(irMethod);
                T_removeLocal.transform(irMethod);
                T_removeConst.transform(irMethod);
                T_zero.transform(irMethod);
                if (T_npe.transformReportChanged(irMethod)) {
                    T_deadCode.transform(irMethod);
                    T_removeLocal.transform(irMethod);
                    T_removeConst.transform(irMethod);
                }
                T_new.transform(irMethod);
                T_fillArray.transform(irMethod);
                T_agg.transform(irMethod);
                T_multiArray.transform(irMethod);
                T_voidInvoke.transform(irMethod);
                if (0 != (v3Config & V3.PRINT_IR)) {
                    int i = 0;
                    for (Stmt p : irMethod.stmts) {
                        if (p.st == Stmt.ST.LABEL) {
                            LabelStmt labelStmt = (LabelStmt) p;
                            labelStmt.displayName = "L" + i++;
                        }
                    }
                    System.out.println(irMethod);
                }
                {
                    // https://github.com/pxb1988/dex2jar/issues/477
                    // dead code found in unssa, clean up
                    T_deadCode.transform(irMethod);
                    T_removeLocal.transform(irMethod);
                    T_removeConst.transform(irMethod);
                }
                T_type.transform(irMethod);
                T_unssa.transform(irMethod);
                T_ir2jRegAssign.transform(irMethod);
                T_trimEx.transform(irMethod);
            }

            @Override
            public void ir2j(IrMethod irMethod, MethodVisitor mv, ClzCtx clzCtx) {
                new IR2JConverter()
                        .optimizeSynchronized(0 != (V3.OPTIMIZE_SYNCHRONIZED & v3Config))
                        .clzCtx(clzCtx)
                        .ir(irMethod)
                        .asm(mv)
                        .convert();
            }
        }.convertDex(fileNode, cvf);

    }

    public DexExceptionHandler getExceptionHandler() {
        return exceptionHandler;
    }

    public BaseDexFileReader getReader() {
        return reader;
    }

    public Dex2jar reUseReg(boolean b) {
        if (b) {
            this.v3Config |= V3.REUSE_REGISTER;
        } else {
            this.v3Config &= ~V3.REUSE_REGISTER;
        }
        return this;
    }

    public Dex2jar topoLogicalSort(boolean b) {
        if (b) {
            this.v3Config |= V3.TOPOLOGICAL_SORT;
        } else {
            this.v3Config &= ~V3.TOPOLOGICAL_SORT;
        }
        return this;
    }

    public Dex2jar noCode(boolean b) {
        if (b) {
            this.readerConfig |= DexFileReader.SKIP_CODE | DexFileReader.KEEP_CLINIT;
        } else {
            this.readerConfig &= ~(DexFileReader.SKIP_CODE | DexFileReader.KEEP_CLINIT);
        }
        return this;
    }

    public Dex2jar optimizeSynchronized(boolean b) {
        if (b) {
            this.v3Config |= V3.OPTIMIZE_SYNCHRONIZED;
        } else {
            this.v3Config &= ~V3.OPTIMIZE_SYNCHRONIZED;
        }
        return this;
    }

    public Dex2jar printIR(boolean b) {
        if (b) {
            this.v3Config |= V3.PRINT_IR;
        } else {
            this.v3Config &= ~V3.PRINT_IR;
        }
        return this;
    }

    public Dex2jar reUseReg() {
        this.v3Config |= V3.REUSE_REGISTER;
        return this;
    }

    public Dex2jar optimizeSynchronized() {
        this.v3Config |= V3.OPTIMIZE_SYNCHRONIZED;
        return this;
    }

    public Dex2jar printIR() {
        this.v3Config |= V3.PRINT_IR;
        return this;
    }

    public Dex2jar topoLogicalSort() {
        this.v3Config |= V3.TOPOLOGICAL_SORT;
        return this;
    }

    public void setExceptionHandler(DexExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }

    public Dex2jar skipDebug(boolean b) {
        if (b) {
            this.readerConfig |= DexFileReader.SKIP_DEBUG;
        } else {
            this.readerConfig &= ~DexFileReader.SKIP_DEBUG;
        }
        return this;
    }

    public Dex2jar skipDebug() {
        this.readerConfig |= DexFileReader.SKIP_DEBUG;
        return this;
    }

    public void to(Path file) throws IOException {
        if (Files.exists(file) && Files.isDirectory(file)) {
            doTranslate(file);
        } else {
            try (FileSystem fs = createZip(file)) {
                doTranslate(fs.getPath("/"));
            }
        }
    }

    private static FileSystem createZip(Path output) throws IOException {
        Map<String, Object> env = new HashMap<>();
        env.put("create", "true");
        Files.deleteIfExists(output);
        Path parent = output.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        for (FileSystemProvider p : FileSystemProvider.installedProviders()) {
            String s = p.getScheme();
            if ("jar".equals(s) || "zip".equalsIgnoreCase(s)) {
                return p.newFileSystem(output, env);
            }
        }
        throw new IOException("cant find zipfs support");
    }

    public Dex2jar withExceptionHandler(DexExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
        return this;
    }

    public Dex2jar skipExceptions(boolean b) {
        if (b) {
            this.readerConfig |= DexFileReader.SKIP_EXCEPTION;
        } else {
            this.readerConfig &= ~DexFileReader.SKIP_EXCEPTION;
        }
        return this;
    }
}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/DexExceptionHandler.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.node.DexMethodNode;
import org.objectweb.asm.MethodVisitor;

public interface DexExceptionHandler {
    public void handleFileException(Exception e);

    public void handleMethodTranslateException(Method method, DexMethodNode methodNode, MethodVisitor mv, Exception e);
}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/DexFix.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex;

import java.util.HashMap;
import java.util.Map;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFieldNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.node.DexMethodNode;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;

/**
 * 1. Dex omit the value of static-final filed if it is the default value.
 *
 * 2. static-final field init by zero, but assigned in clinit
 *
 * this method is try to fix the problems.
 */
public class DexFix {
    private static final int ACC_STATIC_FINAL = DexConstants.ACC_STATIC | DexConstants.ACC_FINAL;

    public static void fixStaticFinalFieldValue(final DexFileNode dex) {
        if (dex.clzs != null) {
            for (DexClassNode classNode : dex.clzs) {
                fixStaticFinalFieldValue(classNode);
            }
        }
    }

    /**
     * init value to default if the field is static and final, and the field is not init in clinit method
     *
     * erase the default value if the field is init in clinit method
     * 
     * @param classNode
     */
    public static void fixStaticFinalFieldValue(final DexClassNode classNode) {
        if (classNode.fields == null) {
            return;
        }
        final Map<String, DexFieldNode> fs = new HashMap<>();
        final Map<String, DexFieldNode> shouldNotBeAssigned = new HashMap<>();
        for (DexFieldNode fn : classNode.fields) {
            if ((fn.access & ACC_STATIC_FINAL) == ACC_STATIC_FINAL) {
                if (fn.cst == null) {
                    char t = fn.field.getType().charAt(0);
                    if (t == 'L' || t == '[') {
                        // ignore Object
                        continue;
                    }
                    fs.put(fn.field.getName() + ":" + fn.field.getType(), fn);
                } else if (isPrimitiveZero(fn.field.getType(), fn.cst)) {
                    shouldNotBeAssigned.put(fn.field.getName() + ":" + fn.field.getType(), fn);
                }
            }
        }
        if (fs.isEmpty() && shouldNotBeAssigned.isEmpty()) {
            return;
        }
        DexMethodNode node = null;
        if (classNode.methods != null) {
            for (DexMethodNode mn : classNode.methods) {
                if (mn.method.getName().equals("<clinit>")) {
                    node = mn;
                    break;
                }
            }
        }
        if (node != null) {
            if (node.codeNode != null) {
                node.codeNode.accept(new DexCodeVisitor() {
                    @Override
                    public void visitFieldStmt(Op op, int a, int b, Field field) {
                        switch (op) {
                        case SPUT:
                        case SPUT_BOOLEAN:
                        case SPUT_BYTE:
                        case SPUT_CHAR:
                        case SPUT_OBJECT:
                        case SPUT_SHORT:
                        case SPUT_WIDE:
                            if (field.getOwner().equals(classNode.className)) {
                                String key = field.getName() + ":" + field.getType();
                                fs.remove(key);
                                DexFieldNode dn = shouldNotBeAssigned.get(key);
                                if (dn != null) {
                                    //System.out.println(field.getName() + ":" + field.getType());
                                    dn.cst = null;
                                }
                            }
                            break;
                        default:
                            // ignored
                            break;
                        }
                    }
                });
            } else {
                // has init but no code
                return;
            }
        }

        for (DexFieldNode fn : fs.values()) {
            fn.cst = getDefaultValueOfType(fn.field.getType().charAt(0));
        }

    }

    private static Object getDefaultValueOfType(char t) {
        switch (t) {
        case 'B':
            return Byte.valueOf((byte) 0);
        case 'Z':
            return Boolean.FALSE;
        case 'S':
            return Short.valueOf((short) 0);
        case 'C':
            return Character.valueOf((char) 0);
        case 'I':
            return 0;
        case 'F':
            return Float.valueOf((float) 0.0);
        case 'J':
            return Long.valueOf((long) 0);
        case 'D':
            return Double.valueOf(0.0);
        case '[':
        case 'L':
        default:
            return null;
            // impossible
        }
    }

    static boolean isPrimitiveZero(String desc, Object value) {
        if (value != null && desc != null && desc.length() > 0) {
            switch (desc.charAt(0)) {
            // case 'V':// VOID_TYPE
            case 'Z':// BOOLEAN_TYPE
                return ((Boolean) value).booleanValue() == false;
            case 'C':// CHAR_TYPE
                return ((Character) value).charValue() == (char) 0;
            case 'B':// BYTE_TYPE
                return ((Byte) value).byteValue() == 0;
            case 'S':// SHORT_TYPE
                return ((Short) value).shortValue() == 0;
            case 'I':// INT_TYPE
                return ((Integer) value).intValue() == 0;
            case 'F':// FLOAT_TYPE
                return ((Float) value).floatValue() == 0f;
            case 'J':// LONG_TYPE
                return ((Long) value).longValue() == 0L;
            case 'D':// DOUBLE_TYPE
                return ((Double) value).doubleValue() == 0.0;
            }
        }
        return false;
    }
}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/ExDex2Asm.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex;

import org.objectweb.asm.AsmBridge;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.MethodNode;

import com.googlecode.d2j.DexException;
import com.googlecode.d2j.node.DexMethodNode;

public class ExDex2Asm extends Dex2Asm {
    final protected DexExceptionHandler exceptionHandler;

    public ExDex2Asm(DexExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }

    @Override
    public void convertCode(DexMethodNode methodNode, MethodVisitor mv, ClzCtx clzCtx) {
        MethodVisitor mw = AsmBridge.searchMethodWriter(mv);
        MethodNode mn = new MethodNode(Opcodes.ASM9, methodNode.access, methodNode.method.getName(),
                methodNode.method.getDesc(), null, null);
        try {
            super.convertCode(methodNode, mn, clzCtx);
        } catch (Exception ex) {
            if (exceptionHandler == null) {
                throw new DexException(ex, "Failed to convert code for %s", methodNode.method);
            } else {
                mn.instructions.clear();
                mn.tryCatchBlocks.clear();
                exceptionHandler.handleMethodTranslateException(methodNode.method, methodNode, mn, ex);
            }
        }
        // code convert ok, copy to MethodWriter and check for Size
        try {
            mn.accept(mv);
        } catch (Exception e) {
            System.out.println("Cannot convert " + clzCtx.classDescriptor);
            if (exceptionHandler != null)
                exceptionHandler.handleMethodTranslateException(methodNode.method, methodNode, mn, e);
        }
        if (mw != null) {
            try {
                AsmBridge.sizeOfMethodWriter(mw);
            } catch (Exception ex) {
                mn.instructions.clear();
                mn.tryCatchBlocks.clear();
                exceptionHandler.handleMethodTranslateException(methodNode.method, methodNode, mn, ex);
                AsmBridge.replaceMethodWriter(mw, mn);
            }
        }
    }
}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/LambadaNameSafeClassAdapter.java`:

```java
package com.googlecode.d2j.dex;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.commons.ClassRemapper;
import org.objectweb.asm.commons.Remapper;

public class LambadaNameSafeClassAdapter extends ClassRemapper {
    public String getClassName() {
        return remapper.mapType(className);
    }

    public LambadaNameSafeClassAdapter(ClassVisitor cv) {
        super(cv, new Remapper() {
            @Override
            public String mapType(String type) {
                if (type == null) {
                    return null;
                }
                return type.replace('-', '_');
            }
        });
    }
}

```

`dex-translator/src/main/java/com/googlecode/d2j/dex/V3.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex;


/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * @version $Rev$
 */
public class V3  {

    public static final int REUSE_REGISTER = 1 << 0;
    public static final int TOPOLOGICAL_SORT = 1 << 1;
    public static final int PRINT_IR = 1 << 2;
    public static final int OPTIMIZE_SYNCHRONIZED = 1 << 3;

}

```

`dex-translator/src/main/java/com/googlecode/d2j/util/Types.java`:

```java
package com.googlecode.d2j.util;

import com.googlecode.d2j.DexException;

import java.util.ArrayList;
import java.util.List;

public class Types {
    /**
     * @param desc
     *            a asm method desc, ex: (II)V
     * @return a array of argument types, ex: [I,I]
     */
    public static String[] getParameterTypeDesc(String desc) {

        if (desc.charAt(0) != '(') {
            throw new DexException("not a validate Method Desc %s", desc);
        }
        int x = desc.lastIndexOf(')');
        if (x < 0) {
            throw new DexException("not a validate Method Desc %s", desc);
        }
        List<String> ps = listDesc(desc.substring(1, x - 1));
        return ps.toArray(new String[ps.size()]);
    }

    /**
     * 
     * @param desc
     *            a asm method desc, ex: (II)V
     * @return the desc of return type, ex: V
     */
    public static String getReturnTypeDesc(String desc) {
        int x = desc.lastIndexOf(')');
        if (x < 0) {
            throw new DexException("not a validate Method Desc %s", desc);
        }
        return desc.substring(x + 1);
    }

    public static List<String> listDesc(String desc) {
        List<String> list = new ArrayList<>(5);
        if (desc == null) {
            return list;
        }
        char[] chars = desc.toCharArray();
        int i = 0;
        while (i < chars.length) {
            switch (chars[i]) {
            case 'V':
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
            case 'F':
            case 'J':
            case 'D':
                list.add(Character.toString(chars[i]));
                i++;
                break;
            case '[': {
                int count = 1;
                while (chars[i + count] == '[') {
                    count++;
                }
                if (chars[i + count] == 'L') {
                    count++;
                    while (chars[i + count] != ';') {
                        count++;
                    }
                }
                count++;
                list.add(new String(chars, i, count));
                i += count;
                break;
            }
            case 'L': {
                int count = 1;
                while (chars[i + count] != ';') {
                    ++count;
                }
                count++;
                list.add(new String(chars, i, count));
                i += count;
                break;
            }
            default:
                throw new RuntimeException("can't parse type list: " + desc);
            }
        }
        return list;
    }

    public static Object[] buildDexStyleSignature(String signature) {
        int rawLength = signature.length();
        ArrayList<String> pieces = new ArrayList<String>(20);

        for (int at = 0; at < rawLength; /* at */) {
            char c = signature.charAt(at);
            int endAt = at + 1;
            if (c == 'L') {
                // Scan to ';' or '<'. Consume ';' but not '<'.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == ';') {
                        endAt++;
                        break;
                    } else if (c == '<') {
                        break;
                    }
                    endAt++;
                }
            } else {
                // Scan to 'L' without consuming it.
                while (endAt < rawLength) {
                    c = signature.charAt(endAt);
                    if (c == 'L') {
                        break;
                    }
                    endAt++;
                }
            }

            pieces.add(signature.substring(at, endAt));
            at = endAt;
        }
        return pieces.toArray(new Object[pieces.size()]);
    }

}

```

`dex-translator/src/main/java/org/objectweb/asm/AsmBridge.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2014 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.objectweb.asm;

import java.lang.reflect.Field;
import org.objectweb.asm.tree.MethodNode;

public final class AsmBridge {

    public static MethodVisitor searchMethodWriter(MethodVisitor methodVisitor) {
        while (methodVisitor != null && !(methodVisitor instanceof MethodWriter)) {
            methodVisitor = methodVisitor.mv;
        }
        return methodVisitor;
    }

    public static int sizeOfMethodWriter(MethodVisitor methodVisitor) {
        MethodWriter mw = (MethodWriter) methodVisitor;
        return mw.computeMethodInfoSize();
    }

    private static void removeMethodWriter(MethodWriter methodWriter) {
        MethodWriter firstMethodWriter;
        MethodWriter lastMethodWriter;

        try {
            ClassWriter classWriter = reflectForClassWriter(methodWriter);

            Field fmField = ClassWriter.class.getDeclaredField("firstMethod");
            fmField.setAccessible(true);
            firstMethodWriter = (MethodWriter) fmField.get(classWriter);

            Field lmField = ClassWriter.class.getDeclaredField("lastMethod");
            lmField.setAccessible(true);
            lastMethodWriter = (MethodWriter) lmField.get(classWriter);

            // mv must be the last element
            if (firstMethodWriter == methodWriter) {
                fmField.set(classWriter, null);
                if (lastMethodWriter == methodWriter) {
                    lmField.set(classWriter, null);
                }
            } else {
                while (firstMethodWriter != null) {
                    if (firstMethodWriter.mv == methodWriter) {
                        firstMethodWriter.mv = methodWriter.mv;
                        if (lastMethodWriter == methodWriter) {
                            lmField.set(classWriter, firstMethodWriter);
                        }
                        break;
                    } else {
                        firstMethodWriter = (MethodWriter) firstMethodWriter.mv;
                    }
                }
            }
        } catch (IllegalAccessException | NoSuchFieldException exc) {
            exc.printStackTrace();
        }
    }

    private static ClassWriter reflectForClassWriter(MethodWriter methodWriter) throws NoSuchFieldException, IllegalAccessException {
        // Get the SymbolTable for accessing ClassWriter
        Field stField = MethodWriter.class.getDeclaredField("symbolTable");
        stField.setAccessible(true);
        SymbolTable symbolTable = (SymbolTable) stField.get(methodWriter);
        // Get ClassWriter object from methodWriter's SymbolTable
        return symbolTable.classWriter;
    }

    public static void replaceMethodWriter(MethodVisitor methodVisitor, MethodNode methodNode) {
        MethodWriter methodWriter = (MethodWriter) methodVisitor;

        try {
            ClassWriter classWriter = reflectForClassWriter(methodWriter);

            methodNode.accept(classWriter);
            removeMethodWriter(methodWriter);
        } catch (IllegalAccessException | NoSuchFieldException exc) {
            exc.printStackTrace();
        }
    }

    private AsmBridge() {
        throw new UnsupportedOperationException();
    }

}

```

`dex-translator/src/main/java/res/Hex.java`:

```java
package res;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;

public class Hex {

    public static long[] decode_J(String src) {
        byte[] d = decode_B(src);
        ByteBuffer b = ByteBuffer.wrap(d);
        b.order(ByteOrder.LITTLE_ENDIAN);
        LongBuffer s = b.asLongBuffer();
        long[] data = new long[d.length / 8];
        s.get(data);
        return data;
    }

    public static int[] decode_I(String src) {
        byte[] d = decode_B(src);
        ByteBuffer b = ByteBuffer.wrap(d);
        b.order(ByteOrder.LITTLE_ENDIAN);
        IntBuffer s = b.asIntBuffer();
        int[] data = new int[d.length / 4];
        s.get(data);
        return data;
    }

    public static short[] decode_S(String src) {
        byte[] d = decode_B(src);
        ByteBuffer b = ByteBuffer.wrap(d);
        b.order(ByteOrder.LITTLE_ENDIAN);
        ShortBuffer s = b.asShortBuffer();
        short[] data = new short[d.length / 2];
        s.get(data);
        return data;
    }

    public static byte[] decode_B(String src) {
        char[] d = src.toCharArray();
        byte[] ret = new byte[src.length() / 2];
        for (int i = 0; i < ret.length; i++) {
            char h = d[2 * i];
            char l = d[2 * i + 1];
            int hh;
            if (h >= '0' && h <= '9') {
                hh = h - '0';
            } else if (h >= 'a' && h <= 'f') {
                hh = h - 'a' + 10;
            } else if (h >= 'A' && h <= 'F') {
                hh = h - 'A' + 10;
            } else {
                throw new RuntimeException();
            }
            int ll;
            if (l >= '0' && l <= '9') {
                ll = l - '0';
            } else if (l >= 'a' && l <= 'f') {
                ll = l - 'a' + 10;
            } else if (l >= 'A' && l <= 'F') {
                ll = l - 'A' + 10;
            } else {
                throw new RuntimeException();
            }
            ret[i] = (byte) ((hh << 4) | ll);
        }
        return ret;
    }

}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/ASMifierTest.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.test;

import java.io.File;
import java.nio.file.FileSystem;
import java.nio.file.Path;

import org.junit.Test;

import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.util.ASMifierFileV;
import com.googlecode.dex2jar.tools.BaseCmd;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class ASMifierTest {
    public static String getBaseName(String fn) {
        int x = fn.lastIndexOf('.');
        return x >= 0 ? fn.substring(0, x) : fn;
    }

    @Test
    public void test() throws Exception {
        try {
            for (Path f : TestUtils.listTestDexFiles()) {
                System.out.println("asmifier file " + f);
                File distDir = new File("target", getBaseName(f.getFileName().toString()) + "_asmifier.zip");
                try (FileSystem fs = BaseCmd.createZip(distDir.toPath())) {
                    ASMifierFileV.doFile(f, fs.getPath("/"));
                }
            }
        } catch (Exception e) {
            DexFileReader.niceExceptionMessage(e, 0);
            throw e;
        }
    }

}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/ArrayTypeTest.java`:

```java
package com.googlecode.dex2jar.test;

import static com.googlecode.d2j.DexConstants.ACC_PUBLIC;
import static com.googlecode.d2j.DexConstants.ACC_STATIC;
import static com.googlecode.d2j.reader.Op.AGET;
import static com.googlecode.d2j.reader.Op.APUT;
import static com.googlecode.d2j.reader.Op.ARRAY_LENGTH;
import static com.googlecode.d2j.reader.Op.CONST;
import static com.googlecode.d2j.reader.Op.GOTO;
import static com.googlecode.d2j.reader.Op.INVOKE_VIRTUAL;
import static com.googlecode.d2j.reader.Op.NEW_ARRAY;
import static com.googlecode.d2j.reader.Op.RETURN_VOID;

import org.junit.Test;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.junit.runner.RunWith;

@RunWith(DexTranslatorRunner.class)
public class ArrayTypeTest {

    @Test
    public static void a120(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La;", "b", new String[] {}, "V"));
        DexCodeVisitor code = mv.visitCode();
        code.visitRegister(3);
        code.visitConstStmt(CONST, 0, Integer.valueOf(0));
        code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 0 }, new Method("Ljava/lang/String;", "toString",
                new String[] {}, "Ljava/lang/String;"));
        code.visitConstStmt(CONST, 1, Integer.valueOf(0));
        code.visitStmt2R(ARRAY_LENGTH, 2, 1);
        code.visitStmt0R(RETURN_VOID);
        code.visitEnd();
        mv.visitEnd();
    }

    @Test
    public static void a122(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La;", "b", new String[] {}, "V"));
        DexCodeVisitor code = mv.visitCode();
        code.visitRegister(3);
        code.visitConstStmt(CONST, 0, Integer.valueOf(0));
        code.visitConstStmt(CONST, 2, Integer.valueOf(1));
        code.visitStmt3R(AGET, 1, 0, 2);
        code.visitStmt0R(RETURN_VOID);
        code.visitEnd();
        mv.visitEnd();
    }

    @Test
    public static void a123(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La;", "b", new String[] {}, "V"));
        DexCodeVisitor code = mv.visitCode();
        code.visitRegister(3);
        code.visitConstStmt(CONST, 0, 0);
        code.visitConstStmt(CONST, 1, 1);
        code.visitConstStmt(CONST, 2, 0x63);
        code.visitStmt3R(APUT, 2, 0, 1);
        code.visitStmt0R(RETURN_VOID);
        code.visitEnd();
        mv.visitEnd();
    }

    @Test
    public static void merge1(DexClassVisitor cv) {// obj = array
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La;", "b", new String[] {}, "V"));
        DexCodeVisitor code = mv.visitCode();
        DexLabel L0 = new DexLabel();
        DexLabel L1 = new DexLabel();
        code.visitRegister(3);
        code.visitConstStmt(CONST, 0, 0);
        code.visitJumpStmt(GOTO, -1, -1, L1);
        code.visitLabel(L0);
        code.visitStmt2R(ARRAY_LENGTH, 1, 0);
        code.visitConstStmt(CONST, 1, 0);
        code.visitStmt3R(AGET, 2, 0, 1);
        code.visitStmt0R(RETURN_VOID);
        code.visitLabel(L1);
        code.visitConstStmt(CONST, 1, 1);
        code.visitTypeStmt(NEW_ARRAY, 0, 1, "[Ljava/security/cert/X509Certificate;");
        code.visitJumpStmt(GOTO, -1, -1, L0);
        code.visitEnd();
        mv.visitEnd();
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/AutoCastTest.java`:

```java
package com.googlecode.dex2jar.test;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexFieldVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.junit.Assert;
import org.junit.Test;

import static com.googlecode.d2j.reader.Op.*;

public class AutoCastTest implements DexConstants {

    /**
     * generate code, it works fine on JVM, but fails on Dalvik VM
     * 
     * <pre>
     * class a {
     *     private static short theField;
     * 
     *     public a() {
     *         theField = 0xffFFffFF + theField;// the 0xffFFffFF is not casted
     *     }
     * }
     * </pre>
     * 
     * @param cv
     */
    public static void strict(DexClassVisitor cv) {
        Field f = new Field("La;", "theField", "S");
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC, new Method("La;", "<init>", new String[] {}, "V"));
        if (mv != null) {
            DexCodeVisitor code = mv.visitCode();
            if (code != null) {
                code.visitRegister(3);

                code.visitMethodStmt(INVOKE_SUPER, new int[] { 2 }, new Method("Ljava/lang/Object;", "<init>",
                        new String[] {}, "V"));
                code.visitFieldStmt(SGET_BOOLEAN, 0, -1, f);
                code.visitConstStmt(CONST, 1, 0xffFFffFF);
                code.visitStmt3R(ADD_INT, 0, 0, 1);
                code.visitFieldStmt(SPUT_SHORT, 0, -1, f);
                code.visitStmt0R(RETURN_VOID);
                code.visitEnd();
            }
            mv.visitEnd();
        }
        DexFieldVisitor fv = cv.visitField(ACC_PRIVATE | ACC_STATIC, f, 0);
        if (fv != null) {
            fv.visitEnd();
        }
    }

    @Test
    public void test() throws Exception {
        byte[] data = TestUtils.testDexASMifier(getClass(), "strict", "a");
        Class<?> clz = TestUtils.defineClass("a", data);
        Object c = clz.newInstance();
        Assert.assertNotNull(c);
        java.lang.reflect.Field f = clz.getDeclaredField("theField");
        f.setAccessible(true);
        Short r = (Short) f.get(null);
        Assert.assertEquals(-1, r.intValue());

        // it's already ok to run on JVM and able to convert to dex,
        // // check for I2S instruction
        // ClassReader cr = new ClassReader(data);
        // ClassNode cn = new ClassNode();
        // cr.accept(cn, 0);
        // boolean find = false;
        // for (Object m : cn.methods) {
        // MethodNode method = (MethodNode) m;
        // for (AbstractInsnNode p = method.instructions.getFirst(); p != null; p = p.getNext()) {
        // if (p.getOpcode() == Opcodes.I2S) {
        // find = true;
        // break;
        // }
        // }
        // }
        // Assert.assertTrue("we need an I2S instruction", find);

    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/D2jErrorZipsTest.java`:

```java
/*
 * Copyright (c) 2009-2021 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.test;

import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexMethodNode;
import com.googlecode.d2j.smali.Smali;
import org.junit.Assert;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.spi.FileSystemProvider;
import java.util.*;
import java.util.stream.Collectors;

/**
 * auto create test case from d2j-error-zips/*-error.zip,
 * the error.zip is generated by BaksmaliBaseDexExceptionHandler
 *
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 */
@RunWith(D2jErrorZipsTest.S.class)
public class D2jErrorZipsTest {
    private static String parseSmaliContentFromSummary(Path zipEntry) throws IOException {
        List<String> lines = Files.readAllLines(zipEntry, StandardCharsets.UTF_8);
        StringBuilder sb = new StringBuilder();
        boolean hasMethod = false;
        boolean inMethodContent = false;
        for (String ln : lines) {
            if (!inMethodContent) {
                if (ln.startsWith(".method")) {
                    // append here to keep the line number
                    sb.append(".class LTT;.super Ljava/lang/Object;");
                    sb.append(ln);
                    inMethodContent = true;
                    hasMethod = true;
                }
            } else {
                sb.append(ln);
                if (ln.startsWith(".end method")) {
                    inMethodContent = false;
                }
            }
            sb.append("\n");
        }
        if (!hasMethod) {
            return null;
        }
        return sb.toString();
    }

    private static String parseSmaliContent(Path m) throws IOException {
        List<String> lines = Files.readAllLines(m, StandardCharsets.UTF_8);
        StringBuilder sb = new StringBuilder();

        boolean found = false;
        for (String ln : lines) {
            if (!found) {
                if (ln.startsWith(".method")) {
                    // append here to keep the line number
                    sb.append(".class LTT;.super Ljava/lang/Object;");
                    sb.append(ln).append("\n");
                    found = true;
                } else {
                    sb.append("\n");
                }
            } else {
                sb.append(ln).append("\n");
            }
        }

        return sb.toString();
    }

    public static class S extends ParentRunner<Runner> {

        List<Runner> runners;

        public S(Class<?> klass) throws InitializationError {
            super(klass);
            init(klass);
        }

        public void init(final Class<?> testClass) throws InitializationError {
            URL url = testClass.getResource("/smalis/writeString.smali");
            System.out.println("url is " + url);
            Assert.assertNotNull(url);

            final String file = url.getFile();
            Assert.assertNotNull(file);

            final Path basePath = new File(file).toPath().getParent().getParent().resolve("d2j-error-zips");

            final Set<Path> files = new TreeSet<>();
            try {
                Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().endsWith(".zip")) {
                            files.add(file);
                        }
                        return super.visitFile(file, attrs);
                    }
                });
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            FileSystemProvider zipFSP = null;
            for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
                String scheme = provider.getScheme();
                if (scheme.equals("zip") || scheme.equals("jar")) {
                    zipFSP = provider;
                    break;
                }
            }
            Assert.assertNotNull(zipFSP);

            List<Runner> runners = new ArrayList<>();
            for (final Path p : files) {
                Map<String, ?> env = new HashMap<>();
                try (FileSystem fs = zipFSP.newFileSystem(p, env)) {
                    List<Path> methods = Files.walk(fs.getPath("/"))
                            .filter(Files::isReadable)
                            .filter(Files::isRegularFile)
                            .filter(px -> {
                                String fn = px.getFileName().toString();
                                return fn.startsWith("m-") && fn.endsWith(".txt") || fn.equals("summary.txt");
                            })
                            .collect(Collectors.toList());

                    for (Path m : methods) {
                        processEachEntry(testClass, runners, p.getFileName().toString(), m);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            this.runners = runners;
        }

        private void processEachEntry(Class<?> testClass, List<Runner> runners, String zipFileName, Path zipEntry)
                throws IOException, InitializationError {

            String smaliContent = null;
            if (zipEntry.getFileName().toString().equals("summary.txt")) {
                smaliContent = parseSmaliContentFromSummary(zipEntry);
            } else {
                smaliContent = parseSmaliContent(zipEntry);
            }
            if (smaliContent == null) {
                return;
            }


            String finalSmaliContent = smaliContent;
            runners.add(new ParentRunner<String>(testClass) {
                @Override
                protected List<String> getChildren() {
                    return Arrays.asList(finalSmaliContent);
                }

                @Override
                protected String getName() {
                    return "s2j [" + zipFileName + "]";
                }

                @Override
                protected Description describeChild(String child) {
                    return Description.createTestDescription(testClass, "[" + zipFileName + ":" + zipEntry + "]");
                }

                @Override
                protected void runChild(final String child, RunNotifier notifier) {
                    runLeaf(new Statement() {
                        @Override
                        public void evaluate() throws Throwable {
                            DexClassNode classNode = Smali.smaliFile2Node(zipEntry.toString(), child);
                            if (classNode.methods.size() > 1) { // split into methods
                                for (DexMethodNode m : classNode.methods) {
                                    DexClassNode sub = new DexClassNode(0, "Lx;", "Ly;", new String[0]);
                                    sub.methods.add(m);
                                    TestUtils.translateAndCheck(null, sub);
                                }
                            } else {
                                TestUtils.translateAndCheck(null, classNode);
                            }
                        }
                    }, describeChild(child), notifier);
                }
            });
        }


        @Override
        protected List<Runner> getChildren() {
            return runners;
        }

        @Override
        protected Description describeChild(Runner child) {
            return child.getDescription();
        }

        @Override
        protected void runChild(Runner child, RunNotifier notifier) {
            child.run(notifier);
        }
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/D2jTest.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;

import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.zip.ZipUtil;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
@RunWith(D2jTest.S.class)
public class D2jTest {

    public static class S extends ParentRunner<Runner> {

        public S(Class<?> klass) throws InitializationError {
            super(klass);
            init(klass);
        }

        List<Runner> runners;

        public void init(final Class<?> testClass) throws InitializationError {
            Collection<Path> files = TestUtils.listTestDexFiles();

            List<Runner> runners = new ArrayList<>(files.size());

            for (final Path f : files) {
                final DexFileNode fileNode = readDex(f);
                runners.add(new ParentRunner<DexClassNode>(testClass) {
                    @Override
                    protected List<DexClassNode> getChildren() {
                        return fileNode.clzs;
                    }

                    @Override
                    protected String getName() {
                        return "d2j [" + f.toString() + "]";
                    }

                    @Override
                    protected Description describeChild(DexClassNode child) {
                        return Description.createTestDescription(testClass, "c [" + child.className + "]");
                    }

                    @Override
                    protected void runChild(final DexClassNode child, RunNotifier notifier) {
                        runLeaf(new Statement() {
                            @Override
                            public void evaluate() throws Throwable {
                                TestUtils.translateAndCheck(fileNode, child);
                            }
                        }, describeChild(child), notifier);
                    }
                });
            }
            this.runners = runners;
        }

        private DexFileNode readDex(Path f) {
            DexFileNode fileNode = new DexFileNode();
            DexFileReader reader = null;
            try {
                reader = new DexFileReader(ZipUtil.readDex(f));
            } catch (IOException e) {
                throw new RuntimeException("Fail to read dex:" + f);
            }
            reader.accept(fileNode);
            return fileNode;
        }

        @Override
        protected List<Runner> getChildren() {
            return runners;
        }

        @Override
        protected Description describeChild(Runner child) {
            return child.getDescription();
        }

        @Override
        protected void runChild(Runner child, RunNotifier notifier) {
            child.run(notifier);
        }
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/DexTranslatorRunner.java`:

```java
package com.googlecode.dex2jar.test;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.node.DexClassNode;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;

import java.util.List;

public class DexTranslatorRunner extends BlockJUnit4ClassRunner {

    public DexTranslatorRunner(Class klass) throws InitializationError {
        super(klass);
    }

    @Override
    protected Statement methodInvoker(final FrameworkMethod method, final Object test) {
        if (method.getMethod().getParameterTypes().length > 0) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    // 1.invoke the method
                    DexClassNode clzNode = new DexClassNode(DexConstants.ACC_PUBLIC, "La;", "Ljava/lang/Object;", null);
                    if (method.isStatic()) {
                        method.invokeExplosively(null, clzNode);
                    } else {
                        method.invokeExplosively(test, clzNode);
                    }
                    // 2. convert and verify
                    TestUtils.translateAndCheck(clzNode);
                }
            };
        } else {
            return super.methodInvoker(method, test);
        }
    }

    @Override
    protected void validateTestMethods(List<Throwable> errors) {
        // All methods are validate
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/EmptyTrapTest.java`:

```java
package com.googlecode.dex2jar.test;

import static com.googlecode.d2j.reader.Op.*;

import com.googlecode.d2j.visitors.DexDebugVisitor;
import org.junit.Test;
import org.junit.runner.RunWith;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

@RunWith(DexTranslatorRunner.class)
public class EmptyTrapTest {

    @Test
    public static void m005_toJSONString(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(0, new Method("LJSResponseTest;", "toJSONString", new String[] {},
                "Ljava/lang/String;"));
        if (mv != null) {
            DexCodeVisitor code = mv.visitCode();
            if (code != null) {
                code.visitRegister(6);

                DexLabel L8 = new DexLabel();
                DexLabel L9 = new DexLabel();
                DexLabel L10 = new DexLabel();

                DexLabel L0 = new DexLabel();
                DexLabel L1 = new DexLabel();
                DexLabel L2 = new DexLabel();
                code.visitTryCatch(L0, L1, new DexLabel[] { L2 }, new String[] { "Lorg/json/JSONException;" });
                DexLabel L3 = new DexLabel();
                DexLabel L4 = new DexLabel();
                code.visitTryCatch(L3, L4, new DexLabel[] { L2 }, new String[] { "Lorg/json/JSONException;" });
                DexLabel L5 = new DexLabel();
                DexLabel L6 = new DexLabel();
                code.visitTryCatch(L5, L6, new DexLabel[] { L2 }, new String[] { "Lorg/json/JSONException;" });

                code.visitConstStmt(CONST_STRING, 2, "response");
                code.visitConstStmt(CONST_STRING, 4, "");
                code.visitLabel(L0);
                code.visitFieldStmt(IGET, 2, 5, new Field("LJSResponseTest;", "className", "Ljava/lang/String;"));
                code.visitJumpStmt(IF_EQZ, 2, -1, L8);
                code.visitFieldStmt(IGET, 2, 5, new Field("LJSResponseTest;", "methodName", "Ljava/lang/String;"));
                code.visitJumpStmt(IF_NEZ, 2, -1, L10);
                code.visitLabel(L8);
                code.visitConstStmt(CONST_STRING, 2, "");
                code.visitStmt2R(MOVE, 2, 4);
                code.visitLabel(L9);
                code.visitStmt1R(RETURN_OBJECT, 2);
                code.visitLabel(L10);
                code.visitTypeStmt(NEW_INSTANCE, 1, -1, "Lorg/json/JSONObject;");
                code.visitMethodStmt(INVOKE_DIRECT, new int[] { 1 }, new Method("Lorg/json/JSONObject;", "<init>",
                        new String[] {}, "V"));

                code.visitConstStmt(CONST_STRING, 2, "class");
                code.visitFieldStmt(IGET, 3, 5, new Field("LJSResponseTest;", "className", "Ljava/lang/String;"));
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1, 2, 3 }, new Method("Lorg/json/JSONObject;", "put",
                        new String[] { "Ljava/lang/String;", "Ljava/lang/Object;" }, "Lorg/json/JSONObject;"));

                code.visitConstStmt(CONST_STRING, 2, "call");
                code.visitFieldStmt(IGET, 3, 5, new Field("LJSResponseTest;", "methodName", "Ljava/lang/String;"));
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1, 2, 3 }, new Method("Lorg/json/JSONObject;", "put",
                        new String[] { "Ljava/lang/String;", "Ljava/lang/Object;" }, "Lorg/json/JSONObject;"));

                code.visitConstStmt(CONST_STRING, 2, "result");
                code.visitFieldStmt(IGET, 3, 5, new Field("LJSResponseTest;", "result", "I"));
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1, 2, 3 }, new Method("Lorg/json/JSONObject;", "put",
                        new String[] { "Ljava/lang/String;", "I" }, "Lorg/json/JSONObject;"));

                code.visitFieldStmt(IGET, 2, 5, new Field("LJSResponseTest;", "response", "Ljava/lang/Object;"));
                code.visitJumpStmt(IF_EQZ, 2, -1, L3);

                code.visitConstStmt(CONST_STRING, 2, "response");
                code.visitFieldStmt(IGET, 3, 5, new Field("LJSResponseTest;", "response", "Ljava/lang/Object;"));
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1, 2, 3 }, new Method("Lorg/json/JSONObject;", "put",
                        new String[] { "Ljava/lang/String;", "Ljava/lang/Object;" }, "Lorg/json/JSONObject;"));
                code.visitLabel(L1);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1 }, new Method("Lorg/json/JSONObject;", "toString",
                        new String[] {}, "Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 2);
                code.visitJumpStmt(GOTO, -1, -1, L9);
                code.visitLabel(L3);
                code.visitFieldStmt(IGET, 2, 5, new Field("LJSResponseTest;", "dataResponse", "[B"));
                code.visitJumpStmt(IF_EQZ, 2, -1, L5);

                code.visitConstStmt(CONST_STRING, 2, "response");
                code.visitFieldStmt(IGET, 3, 5, new Field("LJSResponseTest;", "dataResponse", "[B"));
                code.visitMethodStmt(INVOKE_STATIC, new int[] { 3 }, new Method("LBase64;", "encode",
                        new String[] { "[B" }, "Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT, 3);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1, 2, 3 }, new Method("Lorg/json/JSONObject;", "put",
                        new String[] { "Ljava/lang/String;", "Ljava/lang/Object;" }, "Lorg/json/JSONObject;"));
                code.visitLabel(L4);
                code.visitJumpStmt(GOTO, -1, -1, L1);
                code.visitLabel(L2);
                code.visitStmt1R(MOVE_EXCEPTION, 2);
                code.visitStmt2R(MOVE, 0, 2);

                code.visitConstStmt(CONST_STRING, 2, "MillennialMediaSDK");
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 0 }, new Method("Lorg/json/JSONException;",
                        "getMessage", new String[] {}, "Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT, 3);
                code.visitMethodStmt(INVOKE_STATIC, new int[] { 2, 3 }, new Method("Landroid/util/Log;", "e",
                        new String[] { "Ljava/lang/String;", "Ljava/lang/String;" }, "I"));

                code.visitConstStmt(CONST_STRING, 2, "");
                code.visitStmt2R(MOVE, 2, 4);
                code.visitJumpStmt(GOTO, -1, -1, L9);
                code.visitLabel(L5);
                code.visitConstStmt(CONST_STRING, 2, "");
                code.visitLabel(L6);
                code.visitStmt2R(MOVE, 2, 4);
                code.visitJumpStmt(GOTO, -1, -1, L9);

                code.visitEnd();
            }
            mv.visitEnd();
        }
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/I101Test.java`:

```java
package com.googlecode.dex2jar.test;

import static com.googlecode.d2j.DexConstants.ACC_PUBLIC;
import static com.googlecode.d2j.DexConstants.ACC_STATIC;
import static com.googlecode.d2j.reader.Op.CONST_STRING;
import static com.googlecode.d2j.reader.Op.INVOKE_VIRTUAL;
import static com.googlecode.d2j.reader.Op.MOVE_EXCEPTION;
import static com.googlecode.d2j.reader.Op.RETURN_VOID;

import org.junit.Test;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

public class I101Test {

    public static void a(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La;", "b", new String[] {}, "V"));
        DexCodeVisitor code = mv.visitCode();
        code.visitRegister(2);
        DexLabel L0 = new DexLabel();
        DexLabel L1 = new DexLabel();
        DexLabel L2 = new DexLabel();
        code.visitTryCatch(L0, L1, new DexLabel[] { L2 }, new String[] { "Lsome/Exception;" });

        code.visitLabel(L0);
        code.visitConstStmt(CONST_STRING, 0, "abc");
        code.visitLabel(L1);

        code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 0 }, new Method("Ljava/lang/String;", "toString",
                new String[] {}, "Ljava/lang/String;"));
        code.visitStmt0R(RETURN_VOID);
        code.visitLabel(L2);
        code.visitStmt1R(MOVE_EXCEPTION, 1);
        code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1 }, new Method("Ljava/lang/String;", "toString",
                new String[] {}, "Ljava/lang/String;"));
        code.visitStmt0R(RETURN_VOID);
        code.visitEnd();
        mv.visitEnd();
    }

    @Test
    public void test() throws Exception {
        byte[] data = TestUtils.testDexASMifier(getClass(), "a", "Lt");
        TestUtils.defineClass("Lt", data);
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/I121Test.java`:

```java
package com.googlecode.dex2jar.test;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.junit.Test;
import org.junit.runner.RunWith;

import static com.googlecode.d2j.DexConstants.*;
import static com.googlecode.d2j.reader.Op.*;

@RunWith(DexTranslatorRunner.class)
public class I121Test {

    @Test
    public static void i121(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La;", "a", new String[] {
                "Ljava/lang/String;", "Ljava/lang/String;" }, "Ljava/lang/String;"));
        DexCodeVisitor code = mv.visitCode();
        int p0 = 2;
        int p1 = 3;
        int v0 = 0;
        int v1 = 1;

        DexLabel cond_7 = new DexLabel();
        DexLabel try_start_2 = new DexLabel();
        DexLabel try_end_9 = new DexLabel();
        DexLabel catch_a = new DexLabel();
        DexLabel goto_2 = new DexLabel();

        code.visitTryCatch(try_start_2, try_end_9, new DexLabel[] { catch_a },
                new String[] { "Ljava/io/UnsupportedEncodingException;" });

        code.visitRegister(4);

        code.visitJumpStmt(IF_EQZ, p1, -1, cond_7);

        code.visitLabel(goto_2);
        code.visitLabel(try_start_2);

        code.visitMethodStmt(INVOKE_STATIC, new int[] { p0, p1 }, new Method("Ljava/net/URLEncoder;", "encode",
                new String[] { "Ljava/lang/String;", "Ljava/lang/String;" }, "Ljava/lang/String;"));
        code.visitStmt1R(MOVE_RESULT_OBJECT, v0);
        code.visitStmt1R(RETURN_OBJECT, v0);
        code.visitLabel(cond_7);
        code.visitConstStmt(CONST_STRING, p1, "ISO-8859-1");

        code.visitLabel(try_end_9);
        code.visitJumpStmt(GOTO, -1, -1, goto_2);
        code.visitLabel(catch_a);
        code.visitStmt1R(MOVE_EXCEPTION, v0);
        code.visitTypeStmt(NEW_INSTANCE, v1, -1, "Ljava/lang/IllegalArgumentException;");
        code.visitMethodStmt(INVOKE_DIRECT, new int[] { v1, v0 }, new Method("Ljava/lang/IllegalArgumentException;",
                "<init>", new String[] { "Ljava/lang/Throwable;" }, "V"));
        code.visitStmt1R(THROW, v1);
        code.visitEnd();
        mv.visitEnd();
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/I168Test.java`:

```java
package com.googlecode.dex2jar.test;

import static com.googlecode.d2j.DexConstants.ACC_PUBLIC;
import static com.googlecode.d2j.DexConstants.ACC_STATIC;

import org.junit.Test;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.junit.runner.RunWith;

/**
 * test for huge insn 20000 and locals 2000
 * 
 * @author bob
 * 
 */
@RunWith(DexTranslatorRunner.class)
public class I168Test {

    @Test
    public static void i168(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La;", "a", new String[] {}, "I"));
        DexCodeVisitor code = mv.visitCode();
        code.visitRegister(2000); // 2000 locals
        for (int i = 0; i < 2000; i++) {// 2000 insns
            code.visitConstStmt(Op.CONST, i, i);
        }
        for (int i = 0; i < 18000; i++) {// 18000 insns
            code.visitConstStmt(Op.CONST, 25, i);
        }
        code.visitStmt1R(Op.RETURN, 25);
        code.visitEnd();
        mv.visitEnd();
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/I63Test.java`:

```java
package com.googlecode.dex2jar.test;

import com.googlecode.d2j.DexConstants;
import org.junit.Test;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.junit.runner.RunWith;

/**
 * test case for issue 63
 */
@RunWith(DexTranslatorRunner.class)
public class I63Test implements DexConstants {

    @Test
    public static void i63(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_STATIC, new Method("La;", "b", new String[] {}, "V"));
        if (mv != null) {
            DexCodeVisitor code = mv.visitCode();
            if (code != null) {
                code.visitRegister(1);
                DexLabel L1 = new DexLabel();
                DexLabel L2 = new DexLabel();
                code.visitLabel(L1);
                code.visitFieldStmt(Op.SGET, 0, -1, new Field("La;", "f", "J"));
                code.visitLabel(L2);
                code.visitStmt0R(Op.RETURN_VOID);
                code.visitEnd();
                code.visitTryCatch(L1, L2, new DexLabel[] { L2 }, new String[] { "La;" });
            }
            mv.visitEnd();
        }
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/Issue71Test.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.test;

import org.junit.Test;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.junit.runner.RunWith;

import static com.googlecode.d2j.reader.Op.*;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
@RunWith(DexTranslatorRunner.class)
public class Issue71Test implements DexConstants {
    @Test
    public static void i71(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_STATIC, new Method("La;", "test", new String[] {}, "V"));
        if (mv != null) {
            DexCodeVisitor code = mv.visitCode();
            if (code != null) {
                code.visitRegister(2);
                code.visitConstStmt(CONST_WIDE, 0, 0L);
                code.visitConstStmt(CONST_WIDE, 1, 2L);
                code.visitStmt3R(ADD_LONG, 0, 0, 1);
                code.visitStmt0R(RETURN_VOID);
                code.visitEnd();
            }
            mv.visitEnd();
        }
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/OptSyncTest.java`:

```java
package com.googlecode.dex2jar.test;

import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.PrintStream;

import static com.googlecode.d2j.DexConstants.ACC_PUBLIC;
import static com.googlecode.d2j.DexConstants.ACC_STATIC;
import static com.googlecode.d2j.reader.Op.*;

@RunWith(DexTranslatorRunner.class)
public class OptSyncTest {

    public void a() {
        synchronized (System.out) {
            System.out.println();
        }
    }

    public void b() {
        PrintStream a = System.out;
        synchronized (a) {
            System.out.println();
        }
    }

    public void c() {
        Object a = null;
        synchronized (a) {
            System.out.println();
        }
    }

    /**
     * Generate the following code
     * 
     * <pre>
     * public static void a() {
     * a0 = System.out
     * L0: 
     * lock a0 <= a0 is inside a try-catch
     * a1="haha"
     * a0.println(a1)
     * L1: 
     * unlock a0 
     * return
     * L2: 
     * a1 := @Exception 
     * unlock a0 
     * throw a1
     * ============= 
     * .catch L0 - L1 > L2 // all 
     * }
     * </pre>
     * 
     * @param cv
     */
    @Test
    public void test(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_PUBLIC | ACC_STATIC, new Method("La;", "a", new String[] {}, "V"));
        DexCodeVisitor code = mv.visitCode();
        int v0 = 0;
        int v1 = 1;
        DexLabel try_start = new DexLabel();
        DexLabel try_end = new DexLabel();
        DexLabel catch_a = new DexLabel();

        code.visitTryCatch(try_start, try_end, new DexLabel[] { catch_a }, new String[] { null });
        code.visitRegister(2);
        code.visitFieldStmt(SGET_OBJECT, v0, -1, new Field("Ljava/lang/System;", "out", "Ljava/io/PrintStream;"));
        code.visitLabel(try_start);
        code.visitStmt1R(MONITOR_ENTER, v0);
        code.visitConstStmt(CONST_STRING, v1, "haha");
        code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { v0, v1 }, new Method("Ljava/io/PrintString;", "println",
                new String[] { "Ljava/lang/String;" }, "V"));
        code.visitLabel(try_end);
        code.visitStmt1R(MONITOR_EXIT, v0);
        code.visitStmt0R(RETURN_VOID);
        code.visitLabel(catch_a);
        code.visitStmt1R(MOVE_EXCEPTION, v1);
        code.visitStmt1R(MONITOR_EXIT, v0);
        code.visitStmt1R(THROW, v1);
        code.visitEnd();
        mv.visitEnd();
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/ResTest.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.test;

import java.io.File;
import java.net.URL;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Assert;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;

import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.reader.DexFileReader;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
@RunWith(ResTest.R.class)
public class ResTest {

    public static class FileSet {
        String name;
        List<Path> files = new ArrayList<>(3);
    }

    public static class R extends ParentRunner<FileSet> {
        public R(Class<?> testClass) throws InitializationError {
            super(testClass);
            init(testClass);
        }

        List<FileSet> fileSetList;
        File dir;

        void init(Class<?> testClass) {
            URL url = testClass.getResource("/" + testClass.getName().replace('.', '/') + ".class");
            Assert.assertNotNull(url);
            String file = url.getFile();
            Assert.assertNotNull(file);
            String dirx = file.substring(0, file.length() - testClass.getName().length() - ".class".length());

            dir = new File(dirx, "res");
            Map<String, FileSet> m = new HashMap<>();
            for (Path f : TestUtils.listPath(dir, ".class")) {
                String name = getBaseName(f.getFileName().toString());

                int i = name.indexOf('$');
                String z = i > 0 ? name.substring(0, i) : name;
                FileSet fs = m.get(z);
                if (fs == null) {
                    fs = new FileSet();
                    fs.name = z;
                    m.put(z, fs);
                }
                fs.files.add(f);
            }
            this.fileSetList = new ArrayList<>(m.values());
        }

        @Override
        protected List<FileSet> getChildren() {
            return fileSetList;
        }

        @Override
        protected Description describeChild(FileSet child) {
            return Description.createTestDescription(getTestClass().getJavaClass(), child.name);
        }

        @Override
        protected void runChild(final FileSet child, RunNotifier notifier) {
            runLeaf(new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    File dex = TestUtils.dexP(child.files, new File(dir, child.name + ".dex"));
                    File distFile = new File(dex.getParentFile(), getBaseName(dex.getName()) + "_d2j.jar");
                    DexFileNode fileNode = new DexFileNode();
                    DexFileReader r = new DexFileReader(dex);
                    r.accept(fileNode);
                    for (DexClassNode classNode : fileNode.clzs) {
                        TestUtils.translateAndCheck(fileNode, classNode);
                    }
                }
            }, describeChild(child), notifier);
        }
    }

    public static String getBaseName(String fn) {
        int x = fn.lastIndexOf('.');
        return x >= 0 ? fn.substring(0, x) : fn;
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/Smali2jTest.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.test;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.junit.Assert;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;

import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.smali.Smali;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
@RunWith(Smali2jTest.S.class)
public class Smali2jTest {

    public static class S extends ParentRunner<Runner> {

        public S(Class<?> klass) throws InitializationError {
            super(klass);
            init(klass);
        }

        List<Runner> runners;

        public void init(final Class<?> testClass) throws InitializationError {
            URL url = testClass.getResource("/smalis/writeString.smali");
            System.out.println("url is " + url);
            Assert.assertNotNull(url);

            final String file = url.getFile();
            Assert.assertNotNull(file);

            Path dirxpath = new File(file).toPath();

            final Path basePath = dirxpath.getParent();

            final Set<Path> files = new TreeSet<>();
            try {
                Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (file.getFileName().toString().endsWith(".smali")) {
                            files.add(file);
                        }
                        return super.visitFile(file, attrs);
                    }
                });
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

            List<Runner> runners = new ArrayList<>();
            for (final Path p : files) {

                Smali smali = new Smali();
                final DexFileNode fileNode = new DexFileNode();
                try {
                    smali.smaliFile(p, fileNode);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                runners.add(new ParentRunner<DexClassNode>(testClass) {
                    @Override
                    protected List<DexClassNode> getChildren() {
                        return fileNode.clzs;
                    }

                    @Override
                    protected String getName() {
                        return "s2j [" + basePath.relativize(p) + "]";
                    }

                    @Override
                    protected Description describeChild(DexClassNode child) {
                        return Description.createTestDescription(testClass, "[" + child.className + "]");
                    }

                    @Override
                    protected void runChild(final DexClassNode child, RunNotifier notifier) {
                        runLeaf(new Statement() {
                            @Override
                            public void evaluate() throws Throwable {
                                if(p.getFileName().toString().contains("mayfail")) {
                                    try {
                                        TestUtils.translateAndCheck(fileNode, child);
                                    } catch (Exception ex) {
                                        ex.printStackTrace();
                                    }
                                } else {
                                    TestUtils.translateAndCheck(fileNode, child);
                                }
                            }
                        }, describeChild(child), notifier);
                    }
                });
            }
            this.runners = runners;
        }

        @Override
        protected List<Runner> getChildren() {
            return runners;
        }

        @Override
        protected Description describeChild(Runner child) {
            return child.getDescription();
        }

        @Override
        protected void runChild(Runner child, RunNotifier notifier) {
            child.run(notifier);
        }
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/TestDexClassV.java`:

```java
package com.googlecode.dex2jar.test;

import com.googlecode.d2j.node.DexMethodNode;
import org.junit.Ignore;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

@Ignore
public class TestDexClassV extends DexClassVisitor {
    private int config;
    private ClassWriter cw;

    public TestDexClassV(String clz, int config) {
        super();
        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, clz, null, "java/lang/Object", null);
        this.config = config;
    }

    public byte[] toByteArray() {
        cw.visitEnd();
        return cw.toByteArray();
    }

    @Override
    public DexMethodVisitor visitMethod(int accessFlags, Method method) {
        return new DexMethodNode(accessFlags, method) {

            @Override
            public void visitEnd() {
                super.visitEnd();
                // FIXME impl
                //methodNode.accept(cw);
            }
        };
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/TestUtils.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.dex2jar.test;

import com.android.dx.cf.direct.DirectClassFile;
import com.android.dx.cf.direct.StdAttributeFactory;
import com.android.dx.cf.iface.ParseException;
import com.android.dx.command.dexer.DxContext;
import com.android.dx.dex.DexOptions;
import com.android.dx.dex.cf.CfOptions;
import com.android.dx.dex.cf.CfTranslator;
import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.DexException;
import com.googlecode.d2j.dex.ClassVisitorFactory;
import com.googlecode.d2j.dex.Dex2Asm;
import com.googlecode.d2j.dex.LambadaNameSafeClassAdapter;
import com.googlecode.d2j.node.DexClassNode;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.node.DexMethodNode;
import com.googlecode.d2j.reader.zip.ZipUtil;
import com.googlecode.d2j.smali.BaksmaliDumper;
import com.googlecode.d2j.visitors.DexClassVisitor;
import org.junit.Assert;
import org.junit.Ignore;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TryCatchBlockNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.BasicVerifier;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.Textifier;
import org.objectweb.asm.util.TraceMethodVisitor;

import java.io.*;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
@Ignore
public abstract class TestUtils {

    public static void breakPoint() {
    }

    public static void checkZipFile(File zip) throws ZipException, Exception {
        ZipFile zipFile = new ZipFile(zip);
        for (Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {
            ZipEntry entry = e.nextElement();
            if (entry.getName().endsWith(".class")) {
                StringWriter sw = new StringWriter();
                // PrintWriter pw = new PrintWriter(sw);

                try (InputStream is = zipFile.getInputStream(entry)) {
                    verify(new ClassReader(ZipUtil.toByteArray(is)));
                }
                Assert.assertTrue(sw.toString(), sw.toString().length() == 0);
            }
        }
    }

    public static File dex(File file, File distFile) throws Exception {
        return dex(new File[] { file }, distFile);
    }

    public static File dex(File[] files) throws Exception {
        return dex(files, null);
    }

    public static File dex(File[] files, File distFile) throws Exception {
        return dex(Arrays.asList(files), distFile);
    }

    public static File dexP(List<Path> files, File distFile) throws Exception {
        Class<?> c = com.android.dx.command.Main.class;
        Method m = c.getMethod("main", String[].class);

        if (distFile == null) {
            distFile = File.createTempFile("dex", ".dex");
        }
        List<String> args = new ArrayList<String>();
        args.addAll(Arrays.asList("--dex", "--no-strict", "--output=" + distFile.getCanonicalPath()));
        for (Path f : files) {
            args.add(f.toAbsolutePath().toString());
        }
        m.invoke(null, new Object[] { args.toArray(new String[0]) });
        return distFile;
    }

    public static File dex(List<File> files, File distFile) throws Exception {
        Class<?> c = com.android.dx.command.Main.class;
        Method m = c.getMethod("main", String[].class);

        if (distFile == null) {
            distFile = File.createTempFile("dex", ".dex");
        }
        List<String> args = new ArrayList<String>();
        args.addAll(Arrays.asList("--dex", "--no-strict", "--output=" + distFile.getCanonicalPath()));
        for (File f : files) {
            args.add(f.getCanonicalPath());
        }
        m.invoke(null, new Object[] { args.toArray(new String[0]) });
        return distFile;
    }

    private static String getShortName(final String name) {
        int n = name.lastIndexOf('/');
        return n == -1 ? name : "o";
    }

    public static List<Path> listTestDexFiles() {

        Class<?> testClass = TestUtils.class;
        URL url = testClass.getResource("/dexes/i_jetty.dex");
        Assert.assertNotNull(url);

        final String fileStr = url.getFile();
        Assert.assertNotNull(fileStr);

        return listPath(new File(fileStr).getParentFile(), ".apk", ".dex", ".zip");
    }

    public static List<Path> listPath(File file, final String... exts) {
        final List<Path> list = new ArrayList<>();

        try {
            Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    String name = file.getFileName().toString();
                    boolean add = false;
                    for (String ext : exts) {
                        if (name.endsWith(ext)) {
                            add = true;
                            break;
                        }
                    }
                    if (add) {
                        list.add(file);
                    }
                    return super.visitFile(file, attrs);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return list;
    }

    private static class StringBuilderTextifier extends Textifier {
        public StringBuilder getStringBuilder() {
            return super.stringBuilder;
        }
    }

    static void printAnalyzerResult(MethodNode method, Analyzer a, final PrintWriter pw)
            throws IllegalArgumentException, IllegalAccessException {
        Frame[] frames = a.getFrames();
        StringBuilderTextifier t = new StringBuilderTextifier();
        TraceMethodVisitor mv = new TraceMethodVisitor(t);
        String format = "%05d %-" + (method.maxStack + method.maxLocals + 6) + "s|%s";
        for (int j = 0; j < method.instructions.size(); ++j) {
            method.instructions.get(j).accept(mv);

            StringBuffer s = new StringBuffer();
            Frame f = frames[j];
            if (f == null) {
                s.append('?');
            } else {
                for (int k = 0; k < f.getLocals(); ++k) {
                    s.append(getShortName(f.getLocal(k).toString()));
                }
                s.append(" : ");
                for (int k = 0; k < f.getStackSize(); ++k) {
                    s.append(getShortName(f.getStack(k).toString()));
                }
            }
            pw.printf(format, j, s, t.getStringBuilder()); // mv.text.get(j));
        }
        for (int j = 0; j < method.tryCatchBlocks.size(); ++j) {
            ((TryCatchBlockNode) method.tryCatchBlocks.get(j)).accept(mv);
            pw.print(" " + t.getStringBuilder());
        }
        pw.println();
        pw.flush();
    }

    public static void verify(final ClassReader cr) throws AnalyzerException, IllegalArgumentException,
            IllegalAccessException {
        try {
            verify(cr, new PrintWriter(new OutputStreamWriter(System.out, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }

    @SuppressWarnings("rawtypes")
    public static void verify(final ClassReader cr, PrintWriter out) throws AnalyzerException,
            IllegalArgumentException, IllegalAccessException {
        ClassNode cn = new ClassNode();
        cr.accept(new CheckClassAdapter(cn, false), ClassReader.SKIP_DEBUG);

        List methods = cn.methods;

        for (int i = 0; i < methods.size(); ++i) {
            MethodNode method = (MethodNode) methods.get(i);

            List tryCatchBlocks = method.tryCatchBlocks;
            for (int j = 0; j < tryCatchBlocks.size(); j++) {
                TryCatchBlockNode tcn = (TryCatchBlockNode) tryCatchBlocks.get(j);
                if (tcn.start.equals(tcn.end)) {
                    throw new DexException("try/catch block %d in %s has same start(%s) and end(%s)", j, method.name,
                            tcn.start.getLabel(), tcn.end.getLabel());
                }
            }

            BasicVerifier verifier = new BasicVerifier();
            Analyzer a = new Analyzer(verifier);
            try {
                a.analyze(cn.name, method);
            } catch (Exception e) {
                out.println(cr.getClassName() + "." + method.name + method.desc);
                printAnalyzerResult(method, a, out);
                e.printStackTrace(out);
                out.flush();
                throw new DexException("method " + method.name + " " + method.desc, e);
            }
        }
    }

    public static byte[] testDexASMifier(Class<?> clz, String methodName) throws Exception {
        return testDexASMifier(clz, methodName, "xxxx/" + methodName);
    }

    public static byte[] testDexASMifier(Class<?> clz, String methodName, String generateClassName) throws Exception {
        DexClassNode clzNode = new DexClassNode(DexConstants.ACC_PUBLIC, "L" + generateClassName + ";",
                "Ljava/lang/Object;", null);
        Method m = clz.getMethod(methodName, DexClassVisitor.class);
        if (m == null) {
            throw new java.lang.NoSuchMethodException(methodName);
        }
        m.setAccessible(true);
        if (Modifier.isStatic(m.getModifiers())) {
            m.invoke(null, clzNode);
        } else {
            m.invoke(clz.newInstance(), clzNode);
        }
        return translateAndCheck(clzNode);
    }

    public static byte[] translateAndCheck(DexFileNode fileNode, DexClassNode clzNode) throws AnalyzerException,
            IllegalAccessException {
        // 1. convert to .class
        Dex2Asm dex2Asm = new Dex2Asm() {
            @Override
            public void convertCode(DexMethodNode methodNode, MethodVisitor mv, ClzCtx clzCtx) {
                try {
                    super.convertCode(methodNode, mv, clzCtx);
                } catch (Exception ex) {
                    BaksmaliDumper d = new BaksmaliDumper();
                    try {
                        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.err, "UTF-8"));
                        d.baksmaliMethod(methodNode, out);
                        out.flush();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    throw new DexException(ex, "Failed to convert code for %s", methodNode.method);
                }
            }
        };
        final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        final LambadaNameSafeClassAdapter rca = new LambadaNameSafeClassAdapter(cw);
        ClassVisitorFactory cvf = new ClassVisitorFactory() {
            @Override
            public ClassVisitor create(String classInternalName) {
                return rca;
            }
        };
        if (fileNode != null) {
            dex2Asm.convertClass(clzNode, cvf, fileNode);
        } else {
            dex2Asm.convertClass(clzNode, cvf);
        }
        byte[] data = cw.toByteArray();

        // 2. verify .class
        ClassReader cr = new ClassReader(data);
        TestUtils.verify(cr);

        // 3. convert back to dex
        CfOptions cfOptions = new CfOptions();
        cfOptions.strictNameCheck = false;
        DexOptions dexOptions = new DexOptions();
        if (fileNode != null) {
            dexOptions.minSdkVersion = DexConstants.toMiniAndroidApiLevel(fileNode.dexVersion);
        }

        DirectClassFile dcf = new DirectClassFile(data, rca.getClassName() + ".class", true);
        dcf.setAttributeFactory(new StdAttributeFactory());
        com.android.dx.dex.file.DexFile dxFile = new com.android.dx.dex.file.DexFile(dexOptions);
        try {
            CfTranslator.translate(new DxContext(), dcf, data, cfOptions, dexOptions, dxFile);
        } catch (ParseException e) {
            if ("MethodHandle not supported".equals(e.getMessage())) {
                e.printStackTrace();
            } else {
                throw e;
            }
        }
        return data;
    }

    public static byte[] translateAndCheck(DexClassNode clzNode) throws AnalyzerException, IllegalAccessException {
        return translateAndCheck(null, clzNode);
    }

    public static Class<?> defineClass(String type, byte[] data) {
        return new CL().xxxDefine(type, data);
    }

    static class CL extends ClassLoader {
        public Class<?> xxxDefine(String type, byte[] data) {
            return super.defineClass(type, data, 0, data.length);
        }
    }
}

```

`dex-translator/src/test/java/com/googlecode/dex2jar/test/ZeroTest.java`:

```java
package com.googlecode.dex2jar.test;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import org.junit.Test;
import org.junit.runner.RunWith;

import static com.googlecode.d2j.reader.Op.*;

@RunWith(DexTranslatorRunner.class)
public class ZeroTest implements DexConstants {
    @Test
    public static void testZero(DexClassVisitor cv) {
        DexMethodVisitor mv = cv
                .visitMethod(ACC_STATIC, new Method("La;", "b", new String[] {}, "[Ljava/lang/Object;"));
        if (mv != null) {
            DexCodeVisitor code = mv.visitCode();
            if (code != null) {
                int v0 = 0;
                code.visitRegister(1);
                DexLabel L1 = new DexLabel();
                DexLabel L2 = new DexLabel();
                DexLabel L3 = new DexLabel();
                code.visitConstStmt(CONST, v0, 0);
                code.visitJumpStmt(IF_EQ, v0, v0, L2);
                code.visitLabel(L1);
                code.visitStmt1R(RETURN_OBJECT, v0);
                code.visitLabel(L2);
                code.visitJumpStmt(IF_EQ, v0, v0, L3);
                code.visitMethodStmt(INVOKE_STATIC, new int[0], new Method("La;", "getBytes", new String[0], "[B"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, v0);
                code.visitLabel(L3);
                code.visitMethodStmt(INVOKE_STATIC, new int[] { v0 }, new Method("La;", "useBytes",
                        new String[] { "[B" }, "V"));
                code.visitMethodStmt(INVOKE_STATIC, new int[0], new Method("La;", "getObjects", new String[0],
                        "[Ljava/lang/Object;"));
                code.visitStmt1R(MOVE_RESULT, v0);
                code.visitJumpStmt(GOTO, -1, -1, L1);
                code.visitEnd();
            }
            mv.visitEnd();
        }
    }
}

```

`dex-translator/src/test/java/dex2jar/gen/FTPClient__parsePassiveModeReply.java`:

```java
package dex2jar.gen;

import com.googlecode.d2j.*;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;
import com.googlecode.dex2jar.test.DexTranslatorRunner;
import com.googlecode.dex2jar.test.TestUtils;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.objectweb.asm.Opcodes;

import static com.googlecode.d2j.reader.Op.*;
@RunWith(DexTranslatorRunner.class)
public class FTPClient__parsePassiveModeReply implements Opcodes {
    @Test
    public static void m003___parsePassiveModeReply(DexClassVisitor cv) {
        DexMethodVisitor mv = cv.visitMethod(ACC_PRIVATE, new Method("Lorg/apache/commons/net/ftp/FTPClient;",
                "__parsePassiveModeReply", new String[] { "Ljava/lang/String;" }, "V"));
        if (mv != null) {
            {
                DexAnnotationVisitor av00 = mv.visitAnnotation("Ldalvik/annotation/Throws;", Visibility.RUNTIME);
                if (av00 != null) {
                    {
                        DexAnnotationVisitor av01 = av00.visitArray("value");
                        if (av01 != null) {
                            av01.visit(null, new DexType("Lorg/apache/commons/net/MalformedServerReplyException;"));
                            av01.visitEnd();
                        }
                    }
                    av00.visitEnd();
                }
            }
            DexCodeVisitor code = mv.visitCode();
            if (code != null) {
                code.visitRegister(11);
                DexLabel L0 = new DexLabel();
                DexLabel L1 = new DexLabel();
                DexLabel L2 = new DexLabel();
                code.visitTryCatch(L0, L1, new DexLabel[] { L2 }, new String[] { "Ljava/lang/NumberFormatException;" });

                code.visitConstStmt(CONST, 7, Integer.valueOf(46)); // int: 0x0000002e float:0.000000
                code.visitConstStmt(CONST_STRING, 8, "Could not parse passive host information.\nServer Reply: ");

                code.visitFieldStmt(SGET_OBJECT, 5,-1, new Field("Lorg/apache/commons/net/ftp/FTPClient;", "__parms_pat",
                        "Ljava/util/regex/Pattern;"));
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 10 }, new Method("Ljava/util/regex/Pattern;",
                        "matcher", new String[] { "Ljava/lang/CharSequence;" }, "Ljava/util/regex/Matcher;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 1);

                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1 }, new Method("Ljava/util/regex/Matcher;",
                        "find", new String[] {}, "Z"));
                code.visitStmt1R(MOVE_RESULT, 5);
                DexLabel L13 = new DexLabel();
                code.visitJumpStmt(IF_NEZ, 5, -1,L13);

                code.visitTypeStmt(NEW_INSTANCE, 5,-1, "Lorg/apache/commons/net/MalformedServerReplyException;");
                code.visitTypeStmt(NEW_INSTANCE, 6,-1, "Ljava/lang/StringBuilder;");
                code.visitMethodStmt(INVOKE_DIRECT, new int[] { 6 }, new Method("Ljava/lang/StringBuilder;",
                        "<init>", new String[] {}, "V"));
                code.visitConstStmt(CONST_STRING, 7, "Could not parse passive host information.\nServer Reply: ");
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 6, 8 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "Ljava/lang/String;" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 6);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 6, 10 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "Ljava/lang/String;" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 6);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 6 }, new Method("Ljava/lang/StringBuilder;",
                        "toString", new String[] {}, "Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 6);
                code.visitMethodStmt(INVOKE_DIRECT, new int[] { 5, 6 }, new Method(
                        "Lorg/apache/commons/net/MalformedServerReplyException;", "<init>",
                        new String[] { "Ljava/lang/String;" }, "V"));
                code.visitStmt1R(THROW, 5);
                code.visitLabel(L13);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1 }, new Method("Ljava/util/regex/Matcher;",
                        "group", new String[] {}, "Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 10);

                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 1 }, new Method("Ljava/util/regex/Matcher;",
                        "group", new String[] {}, "Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 5);
                code.visitConstStmt(CONST_STRING, 6, ",");
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 6 }, new Method("Ljava/lang/String;", "split",
                        new String[] { "Ljava/lang/String;" }, "[Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 4);

                code.visitTypeStmt(NEW_INSTANCE, 5, -1,"Ljava/lang/StringBuilder;");
                code.visitMethodStmt(INVOKE_DIRECT, new int[] { 5 }, new Method("Ljava/lang/StringBuilder;",
                        "<init>", new String[] {}, "V"));
                code.visitConstStmt(CONST, 6, Integer.valueOf(0)); // int: 0x00000000 float:0.000000
                code.visitStmt3R(AGET_OBJECT, 6, 4, 6);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 6 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "Ljava/lang/String;" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 5);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 7 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "C" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 5);
                code.visitConstStmt(CONST, 6, Integer.valueOf(1)); // int: 0x00000001 float:0.000000
                code.visitStmt3R(AGET_OBJECT, 6, 4, 6);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 6 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "Ljava/lang/String;" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 5);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 7 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "C" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 5);
                code.visitConstStmt(CONST, 6, Integer.valueOf(2)); // int: 0x00000002 float:0.000000
                code.visitStmt3R(AGET_OBJECT, 6, 4, 6);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 6 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "Ljava/lang/String;" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT, 5);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 7 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "C" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 5);
                code.visitConstStmt(CONST, 6, Integer.valueOf(3)); // int: 0x00000003 float:0.000000
                code.visitStmt3R(AGET_OBJECT, 6, 4, 6);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5, 6 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "Ljava/lang/String;" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT, 5);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 5 }, new Method("Ljava/lang/StringBuilder;",
                        "toString", new String[] {}, "Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT, 5);
                code.visitFieldStmt(IPUT, 5, 9, new Field("Lorg/apache/commons/net/ftp/FTPClient;", "__passiveHost",
                        "Ljava/lang/String;"));
                code.visitConstStmt(CONST, 5, Integer.valueOf(4)); // int: 0x00000004 float:0.000000
                code.visitLabel(L0);
                code.visitStmt3R(AGET_OBJECT, 5, 4, 5);
                code.visitMethodStmt(INVOKE_STATIC, new int[] { 5 }, new Method("Ljava/lang/Integer;", "parseInt",
                        new String[] { "Ljava/lang/String;" }, "I"));
                code.visitStmt1R(MOVE_RESULT, 2);

                code.visitConstStmt(CONST, 5, Integer.valueOf(5)); // int: 0x00000005 float:0.000000
                code.visitStmt3R(AGET_OBJECT, 5, 4, 5);
                code.visitMethodStmt(INVOKE_STATIC, new int[] { 5 }, new Method("Ljava/lang/Integer;", "parseInt",
                        new String[] { "Ljava/lang/String;" }, "I"));
                code.visitStmt1R(MOVE_RESULT, 3);
                                     code.visitStmt2R1N(Op.SHL_INT_LIT8,5,2,8);

                code.visitStmt3R(OR_INT, 5, 5, 3);
                code.visitFieldStmt(IPUT, 5, 9, new Field("Lorg/apache/commons/net/ftp/FTPClient;", "__passivePort",
                        "I"));
                code.visitLabel(L1);
                code.visitStmt0R(RETURN_VOID);
                code.visitLabel(L2);
                code.visitStmt1R(MOVE_EXCEPTION, 5);
                code.visitStmt2R(MOVE, 0, 5);

                code.visitTypeStmt(NEW_INSTANCE, 5, -1,"Lorg/apache/commons/net/MalformedServerReplyException;");
                code.visitTypeStmt(NEW_INSTANCE, 6,-1, "Ljava/lang/StringBuilder;");
                code.visitMethodStmt(INVOKE_DIRECT, new int[] { 6 }, new Method("Ljava/lang/StringBuilder;",
                        "<init>", new String[] {}, "V"));
                code.visitConstStmt(CONST_STRING, 7, "Could not parse passive host information.\nServer Reply: ");
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 6, 8 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "Ljava/lang/String;" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 6);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 6, 10 }, new Method("Ljava/lang/StringBuilder;",
                        "append", new String[] { "Ljava/lang/String;" }, "Ljava/lang/StringBuilder;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 6);
                code.visitMethodStmt(INVOKE_VIRTUAL, new int[] { 6 }, new Method("Ljava/lang/StringBuilder;",
                        "toString", new String[] {}, "Ljava/lang/String;"));
                code.visitStmt1R(MOVE_RESULT_OBJECT, 6);
                code.visitMethodStmt(INVOKE_DIRECT, new int[] { 5, 6 }, new Method(
                        "Lorg/apache/commons/net/MalformedServerReplyException;", "<init>",
                        new String[] { "Ljava/lang/String;" }, "V"));
                code.visitStmt1R(THROW, 5);

                code.visitEnd();
            }
            mv.visitEnd();
        }
    }
}

```

`dex-translator/src/test/java/res/ArrayRes.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class ArrayRes {

    void array() {
        int a[] = new int[] { 1, 2, 2, 3, 4, 5, 5, 6, 2, 7, };
        System.out.println(a);
        bb(1, 2, 4, 5, 6, 66, 77, 9, 77, 1, 123);
        int b = a[2];
        int c = (int) System.currentTimeMillis();
        bb(b, c);

    }

    void adadfasd() {
        Object object = new Object();
        Object object1 = new Object();
        Object object2 = new Object();
        Object object3 = new Object();
        Object object4 = new Object();
        Object object5 = new Object();
        Object object6 = new Object();
        Object object7 = new Object();
        Object object8 = new Object();
        Object object9 = new Object();
        Object object10 = new Object();
        Object object11 = new Object[] { object, object1, object2, object3, object4, object5, object6, object7, object8, object9, object10 };

    }

    Object adssss() {
        return new Object[] { new Object(), new Object(), new Object(), new Object(), new Object(), new Object(), new Object(), new Object(), new Object(),
                new Object(), new Object(), new Object() };
    }

    void bb(int... aaaaa) {
    }

}

```

`dex-translator/src/test/java/res/ChineseRes.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class ChineseRes {
    public void 你() {
        System.out.println("你好");
    }
}

```

`dex-translator/src/test/java/res/ConstValues.java`:

```java
package res;

public interface ConstValues {

    byte b1 = 0;
    byte b2 = -1;
    byte b3 = 1;
    byte b4 = 0x7F;

    short s1 = 0;
    short s2 = -1;
    short s3 = 1;
    short s4 = 0x7FFF;

    char c1 = 0;
    char c2 = 1;
    char c3 = 0x7FFF;

    int i1 = -1;
    int i2 = 0;
    int i3 = 0xFF;
    int i4 = 0xFFFF;
    int i5 = 0xFFFFFF;
    int i6 = 0x7FFFFFFF;

    float f1 = 0;
    float f2 = -1;
    float f3 = 1;
    float f4 = Float.MAX_VALUE;
    float f5 = Float.MIN_VALUE;

    double d1 = 0;
    double d2 = -1;
    double d3 = 1;
    double d4 = Double.MAX_VALUE;
    double d5 = Double.MIN_VALUE;

    long l1 = 0;
    long l2 = -1;
    long l3 = 1;
    long l4 = 0x7FFFFFFFFFFFFFFFL;

    boolean bl1 = true;
    boolean bl2 = false;

    Abc abc1 = null;
    Abc abc2 = Abc.X;

    enum Abc {
        X, Y
    }
}

```

`dex-translator/src/test/java/res/ExceptionRes.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class ExceptionRes {
    public int a() {
        try {
            System.out.println("abc");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return 0;
    }
}

```

`dex-translator/src/test/java/res/Gh28Type.java`:

```java
package res;

import java.lang.reflect.Array;

/**
 * https://github.com/pxb1988/dex2jar/issues/28
 */
public class Gh28Type {

    protected void onCreate() {
        double t0[] = new double[2];
        t0[0] = 1.0;
        t0[1] = 2.0; // for https://github.com/pxb1988/dex2jar/issues/101
        double t1[] = (double[]) Array.newInstance(Double.TYPE, 1);
        t1[0] = 0;
        double t2[][] = new double[1][1];
        t2[0][0] = 0; // incorrectly translated to 0L (long) rather than 0.0 (double)
        double t3[][] = (double[][]) Array.newInstance(Double.TYPE, 1, 1);
        t3[0][0] = 0; // incorrectly translated to 0L (long) rather than 0.0 (double)
        a(t0);
        a(t1);
        a(t2[0]);
        a(t3[0]);
    }

    private void a(double[] t0) {
        // Just to avoid optimization of unused local variables in onCreate here above
    }

}

```

`dex-translator/src/test/java/res/I142_annotation_default.java`:

```java
package res;

public @interface I142_annotation_default {

    enum AA {
        A, B, C
    }

    AA aaa() default AA.A;

    AA bbb();

    String ccc() default "";

    String ddd() default "ddd";

    int eee() default 1;

    byte fff() default 1;

    short ggg() default 1;

    char hhh() default 1;

    boolean iii() default true;

    long jjj() default 1L;

    float kkk() default 1.0F;

    double lll() default 1.0D;

}

```

`dex-translator/src/test/java/res/I56_AccessFlag.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class I56_AccessFlag {
    static class AStaticInnerClass {
    }

    class AInnerClass {
        class AAA {
        }
    }

    interface AInterface {
    }

    public static class B1 {
    };

    public static class B11 {
        public static class XXX1 {
        };
    };

    private static class B2 {
    };

    protected static class B3 {
    };

    /* package */static class B0 {
    };

    final static class B4 {
    }

    /* package */class C0 {
    }

    public class C1 {
    }

    private class C2 {
    }

    protected class C3 {
    }

    final class C4 {
    }

    abstract class C5 {
    }

    synchronized void sync1() {
    }

    /**
     * seams that dx translate this method to
     * 
     * <pre>
     * void sync2() {
     *     synchronized (this) {
     *         new Object();
     *     }
     * }
     * </pre>
     */
    synchronized void sync2() {
        new Object();
    }

    void a() {
        new Object() {
            Object o = new Object() {
            };

            class AX {
            }
        };
    }

    Object o = new Object() {
    };

    static interface AStaticInterface {
    }
}

```

`dex-translator/src/test/java/res/I71.java`:

```java
package res;

public class I71 {

    /**
     * code similar to edu.emory.mathcs.backport.java.util.concurrent.ConcurrentSkipListMap.SubMap.size()
     * 
     * @return
     */
    public int size() {
        long count = 0;
        for (int i = 0; i < 5; i++) {
            ++count;
        }
        return count >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) count;
    }

}

```

`dex-translator/src/test/java/res/I73.java`:

```java
package res;

public class I73 {
    String a() {
        Object x = new Object();
        String[] y = (String[]) x;
        y[0] = null;
        int[] z = (int[]) x;
        z[0] = 0;
        return "" + y + z;
    }
}

```

`dex-translator/src/test/java/res/I88.java`:

```java
package res;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import res.I88.A;

@A
public class I88 {

    public static void main(String... args) {
        A a = I88.class.getAnnotation(A.class);
        System.out.println(a.a());
    }

    @A
    I88() {
    }

    @A
    int i;

    @A
    public void a(@A int i) {
        @A
        // TODO the annotation is gone.
        String b = "";
    }

    @A
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE,
            ElementType.METHOD, ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE })
    public @interface A {
        String a() default "234";
    }
}

```

`dex-translator/src/test/java/res/LongDoubleRes.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class LongDoubleRes {
    long a(double d, double d2, long l1, long l2) {
        long l3 = l1 + l2;
        double d3 = d + d2;
        return (long) (d3 + l3);
    }
}

```

`dex-translator/src/test/java/res/NoEndRes.java`:

```java
package res;

/**
 * test case for issue 87, http://code.google.com/p/dex2jar/issues/detail?id=87
 * 
 * @author Panxiaobo
 * 
 */
public class NoEndRes {
    public void b() {
    }

    public void a() {
        while (true) {
            b();
        }
    }
}

```

`dex-translator/src/test/java/res/NullZero.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class NullZero {
    void nullzero() {
        String _null = null;
        int zero = 0;
        if (_null == null) {
            _null = "asdf";
            if (zero == 1) {
                zero = 123;
            }
        }
        System.out.println(0);
        System.out.println((String) null);
        System.out.println(_null);
        System.out.println(zero);
    }
}

```

`dex-translator/src/test/java/res/OptimizeSynchronized.java`:

```java
package res;

import java.io.PrintStream;

public class OptimizeSynchronized {
    public void a() {
        synchronized (this) {
            System.out.println(this);
        }
    }

    Object b;

    public void b() {
        synchronized (OptimizeSynchronized.class) {
            System.out.println(this);
        }
    }

    public void c() {
        synchronized (this.b) {
            System.out.println(this);
        }
    }

    public void d() {
        PrintStream out = System.out;
        synchronized (out) {
            out.print("aa");
        }
    }
}

```

`dex-translator/src/test/java/res/PopRes.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class PopRes {

    long aaa() {
        return 0;
    }

    void bbb() {
        aaa();
    }
}

```

`dex-translator/src/test/java/res/ResChild.java`:

```java
package res;

public class ResChild extends ResParent {
    @Override
    public void someMethod(int a, String b) {
        super.someMethod(a, b);
        this.someMethod(a, b);
    }

    public void anotherMethod() {
        this.someMethod(0, null);
        super.someMethod(0, null);
        super.bbb(0, null);
    }
}

```

`dex-translator/src/test/java/res/ResParent.java`:

```java
package res;

public class ResParent {
    public void someMethod(int a, String b) {
    }

    public void bbb(int a, String b) {
    }
}

```

`dex-translator/src/test/java/res/SwitchRes.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class SwitchRes {

    void sw1() {
        int a = 1;
        switch (a) {
        case 1:
        case 2:
        case 3:
            System.out.println("123");
            break;
        case 100:
            System.out.println("100");
            break;
        default:
            System.out.println("def");
            break;
        }
    }

    void sw2() {
        int a = 1;
        int b = 2;
        switch (a) {
        case 1:
            if (b == 2) {
                System.out.println("b");
            } else {
                System.out.println("bbb");
            }
        case 2:
        case 3:
            System.out.println("123");
            break;
        case 100:
            System.out.println("100");
            break;
        default:
            System.out.println("def");
            break;
        }
    }

}

```

`dex-translator/src/test/java/res/U0000String.java`:

```java
package res;

public class U0000String {
    void a() {
        System.out.println("AAA\u0000ZZZ");
    }
}

```

`dex-translator/src/test/java/res/WideRes.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 * 
 */
public class WideRes {
    float aaa() {
        float a = 1.01f + 2;
        float b = 12 + a;
        a = a + b;
        a = a * b;
        a = a - b;
        a = a / b;
        return a + 2;
    }

    double bbb() {
        double b = 1.01 + 2;
        double a = 12312.123 + b;
        a = a + b;
        a = a * b;
        a = a - b;
        a = a / b;
        return b + 2;
    }

    int ccc() {
        int b = 1 + 2;
        int a = 12312 + b;
        a += 1231231231;
        a = a + b;
        a = a * b;
        a = a - b;
        a = a / b;
        return b + 2;
    }

    long ddd() {
        long b = 1l + 2;
        long a = 12312l + b;
        a += 1231232134234234524L;
        a = a + b;
        a = a * b;
        a = a - b;
        a = a / b;
        return b + 2;
    }

}

```

`dex-translator/src/test/java/res/i55/AAbstractClass.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res.i55;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 *
 */
public abstract class AAbstractClass {

}

```

`dex-translator/src/test/java/res/i55/AClass.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res.i55;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 *
 */
public class AClass {

}

```

`dex-translator/src/test/java/res/i55/AInterface.java`:

```java
/*
 * Copyright (c) 2009-2012 Panxiaobo
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package res.i55;

/**
 * @author <a href="mailto:pxb1988@gmail.com">Panxiaobo</a>
 *
 */
public interface AInterface {

}

```

`dex-translator/src/test/resources/smalis/0zs.smali`:

```smali
.class Li;
.super Ljava/lang/Object;

.method protected static getCallScreenClassName()Ljava/lang/String;
    .registers 1

    .prologue
    .line 888
    invoke-static {}, Landroid/telephony/MSimTelephonyManager;->getDefault()Landroid/telephony/MSimTelephonyManager;

    move-result-object v0

    invoke-virtual {v0}, Landroid/telephony/MSimTelephonyManager;->isMultiSimEnabled()Z

    move-result v0

    if-eqz v0, :cond_11

    .line 889
    const-class v0, Lcom/android/phone/MSimInCallScreen;

    invoke-virtual {v0}, Ljava/lang/Class;->getName()Ljava/lang/String;

    move-result-object v0

    .line 891
    :goto_10
    return-object v0

    :cond_11
    const-class v0, Lcom/android/phone/InCallScreen;

    invoke-virtual {v0}, Ljava/lang/Class;->getName()Ljava/lang/String;

    move-result-object v0

    goto :goto_10
.end method

```

`dex-translator/src/test/resources/smalis/ML.smali`:

```smali
.class LML;
.super Ljava/lang/Object;
.source "ML.java"


# direct methods
.method constructor <init>()V
    .registers 1

    .prologue
    .line 1
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method


# virtual methods
.method a()Ljava/lang/Object;
    .registers 4

    .prologue
    .line 3
    const/4 v0, 0x4

    const/4 v1, 0x5

    const/4 v2, 0x6

    filled-new-array {v0, v1, v2}, [I

    move-result-object v0

    const-class v1, Ljava/lang/String;

    invoke-static {v1, v0}, Ljava/lang/reflect/Array;->newInstance(Ljava/lang/Class;[I)Ljava/lang/Object;

    move-result-object v0

    check-cast v0, [[[Ljava/lang/String;

    return-object v0
.end method

```

`dex-translator/src/test/resources/smalis/bb-1-can-not-merge-z-and-i.smali`:

```smali
.class Landroid/preference/MultiSelectListPreference;
.super Ljava/lang/Object;

.method test(Ljava/util/Set;Ljava/lang/Object;)V
  .registers 3
    invoke-interface { p1, p2 }, Ljava/util/Set;->add(Ljava/lang/Object;)Z
    move-result p1
    invoke-static { p0, p1 },  // p1 is boolean but used as integer
        Landroid/preference/MultiSelectListPreference;->access$076(Landroid/preference/MultiSelectListPreference;I)Z
    return-void
.end method


```

`dex-translator/src/test/resources/smalis/bb-5-ArrayIndexOutOfBoundsOnType.smali`:

```smali
.class Li;
.super Ljava/lang/Object;


.method public final a(Ljava/lang/Object;IZ)Ljava/lang/Object;
  .registers 8
    const/4 v0, 0
    instance-of v1, p1, Ljava/lang/Byte;
    if-eqz v1, :L1
    invoke-virtual { p0, v0, p2, p3 }, Lct/be;->a(BIZ)B
    move-result v0
    invoke-static { v0 }, Ljava/lang/Byte;->valueOf(B)Ljava/lang/Byte;
    move-result-object v0
  :L0
    return-object v0
  :L1
    instance-of v1, p1, Ljava/lang/Boolean;
    if-eqz v1, :L3
    invoke-virtual { p0, v0, p2, p3 }, Lct/be;->a(BIZ)B
    move-result v1
    if-eqz v1, :L2
    const/4 v0, 1
  :L2
    invoke-static { v0 }, Ljava/lang/Boolean;->valueOf(Z)Ljava/lang/Boolean;
    move-result-object v0
    goto :L0
  :L3
    instance-of v1, p1, Ljava/lang/Short;
    if-eqz v1, :L4
    invoke-virtual { p0, v0, p2, p3 }, Lct/be;->a(SIZ)S
    move-result v0
    invoke-static { v0 }, Ljava/lang/Short;->valueOf(S)Ljava/lang/Short;
    move-result-object v0
    goto :L0
  :L4
    instance-of v1, p1, Ljava/lang/Integer;
    if-eqz v1, :L5
    invoke-virtual { p0, v0, p2, p3 }, Lct/be;->a(IIZ)I
    move-result v0
    invoke-static { v0 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v0
    goto :L0
  :L5
    instance-of v1, p1, Ljava/lang/Long;
    if-eqz v1, :L6
    const-wide/16 v0, 0
    invoke-virtual { p0, v0, v1, p2, p3 }, Lct/be;->a(JIZ)J
    move-result-wide v0
    invoke-static { v0, v1 }, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;
    move-result-object v0
    goto :L0
  :L6
    instance-of v1, p1, Ljava/lang/Float;
    if-eqz v1, :L7
    const/4 v0, 0
    invoke-direct { p0, v0, p2, p3 }, Lct/be;->a(FIZ)F
    move-result v0
    invoke-static { v0 }, Ljava/lang/Float;->valueOf(F)Ljava/lang/Float;
    move-result-object v0
    goto :L0
  :L7
    instance-of v1, p1, Ljava/lang/Double;
    if-eqz v1, :L8
    const-wide/16 v0, 0
    invoke-direct { p0, v0, v1, p2, p3 }, Lct/be;->a(DIZ)D
    move-result-wide v0
    invoke-static { v0, v1 }, Ljava/lang/Double;->valueOf(D)Ljava/lang/Double;
    move-result-object v0
    goto :L0
  :L8
    instance-of v1, p1, Ljava/lang/String;
    if-eqz v1, :L9
    invoke-virtual { p0, p2, p3 }, Lct/be;->a(IZ)Ljava/lang/String;
    move-result-object v0
    goto :L0
  :L9
    instance-of v1, p1, Ljava/util/Map;
    if-eqz v1, :L10
    check-cast p1, Ljava/util/Map;
    new-instance v0, Ljava/util/HashMap;
    invoke-direct { v0 }, Ljava/util/HashMap;-><init>()V
    invoke-virtual { p0, v0, p1, p2, p3 }, Lct/be;->a(Ljava/util/Map;Ljava/util/Map;IZ)Ljava/util/Map;
    move-result-object v0
    check-cast v0, Ljava/util/HashMap;
    goto :L0
  :L10
    instance-of v1, p1, Ljava/util/List;
    if-eqz v1, :L16
    check-cast p1, Ljava/util/List;
    if-eqz p1, :L11
    invoke-interface { p1 }, Ljava/util/List;->isEmpty()Z
    move-result v1
    if-eqz v1, :L12
  :L11
    new-instance v0, Ljava/util/ArrayList;
    invoke-direct { v0 }, Ljava/util/ArrayList;-><init>()V
    goto/16 :L0
  :L12
    invoke-interface { p1, v0 }, Ljava/util/List;->get(I)Ljava/lang/Object;
    move-result-object v1
    invoke-direct { p0, v1, p2, p3 }, Lct/be;->b(Ljava/lang/Object;IZ)[Ljava/lang/Object;
    move-result-object v2
    if-nez v2, :L13
    const/4 v0, 0
    goto/16 :L0
  :L13
    new-instance v1, Ljava/util/ArrayList;
    invoke-direct { v1 }, Ljava/util/ArrayList;-><init>()V
  :L14
    array-length v3, v2
    if-ge v0, v3, :L15
    aget-object v3, v2, v0
    invoke-virtual { v1, v3 }, Ljava/util/ArrayList;->add(Ljava/lang/Object;)Z
    add-int/lit8 v0, v0, 1
    goto :L14
  :L15
    move-object v0, v1
    goto/16 :L0
  :L16
    instance-of v1, p1, Lct/bg;
    if-eqz v1, :L17
    check-cast p1, Lct/bg;
    invoke-virtual { p0, p1, p2, p3 }, Lct/be;->a(Lct/bg;IZ)Lct/bg;
    move-result-object v0
    goto/16 :L0
  :L17
    invoke-virtual { p1 }, Ljava/lang/Object;->getClass()Ljava/lang/Class;
    move-result-object v1
    invoke-virtual { v1 }, Ljava/lang/Class;->isArray()Z
    move-result v1
    if-eqz v1, :L28
    instance-of v1, p1, [B
    if-nez v1, :L18
    instance-of v1, p1, [Ljava/lang/Byte;
    if-eqz v1, :L19
  :L18
    invoke-virtual { p0, p2, p3 }, Lct/be;->b(IZ)[B
    move-result-object v0
    goto/16 :L0
  :L19
    instance-of v1, p1, [Z
    if-eqz v1, :L20
    invoke-direct { p0, p2, p3 }, Lct/be;->c(IZ)[Z
    move-result-object v0
    goto/16 :L0
  :L20
    instance-of v1, p1, [S
    if-eqz v1, :L21
    invoke-direct { p0, p2, p3 }, Lct/be;->d(IZ)[S
    move-result-object v0
    goto/16 :L0
  :L21
    instance-of v1, p1, [I
    if-eqz v1, :L22
    invoke-direct { p0, p2, p3 }, Lct/be;->e(IZ)[I
    move-result-object v0
    goto/16 :L0
  :L22
    instance-of v1, p1, [J
    if-eqz v1, :L23
    invoke-direct { p0, p2, p3 }, Lct/be;->f(IZ)[J
    move-result-object v0
    goto/16 :L0
  :L23
    instance-of v1, p1, [F
    if-eqz v1, :L24
    invoke-direct { p0, p2, p3 }, Lct/be;->g(IZ)[F
    move-result-object v0
    goto/16 :L0
  :L24
    instance-of v1, p1, [D
    if-eqz v1, :L25
    invoke-direct { p0, p2, p3 }, Lct/be;->h(IZ)[D
    move-result-object v0
    goto/16 :L0
  :L25
    check-cast p1, [Ljava/lang/Object;
    if-eqz p1, :L26
    array-length v1, p1
    if-nez v1, :L27
  :L26
    new-instance v0, Ljava/lang/RuntimeException;
    const-string/jumbo v1, "unable to get type of key and value."
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
  :L27
    aget-object v0, p1, v0
    invoke-direct { p0, v0, p2, p3 }, Lct/be;->b(Ljava/lang/Object;IZ)[Ljava/lang/Object;
    move-result-object v0
    goto/16 :L0
  :L28
    new-instance v0, Ljava/lang/RuntimeException;
    const-string/jumbo v1, "read object error: unsupport type."
    invoke-direct { v0, v1 }, Ljava/lang/RuntimeException;-><init>(Ljava/lang/String;)V
    throw v0
.end method


```

`dex-translator/src/test/resources/smalis/empty-try-catch-with-goto-head.smali`:

```smali
.class Letcwgh;
.super Ljava/lang/Object;

.method private aaa(F)V
  .catch Ljava/lang/Exception; { :L1 .. :L2 } :L3
  .registers 8
  :L0
    iget-object v0, p0, Lz;->z:Lz;
    if-eqz v0, :L1
    iget-object v0, p0, Lz;->z:Lz;
    invoke-static { }, Ljava/util/Locale;->getDefault()Ljava/util/Locale;
    move-result-object v1
    const-string/jumbo v2, "%.1f"
    const/4 v3, 1
    new-array v3, v3, [Ljava/lang/Object;
    const/4 v4, 0
    invoke-static { p1 }, Ljava/lang/Float;->valueOf(F)Ljava/lang/Float;
    move-result-object v5
    aput-object v5, v3, v4
    invoke-static { v1, v2, v3 }, Ljava/lang/String;->format(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
    move-result-object v1
    invoke-virtual { v0, v1 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V
  :L1
    return-void
  :L2
  :L3
    goto :L0
.end method
```

`dex-translator/src/test/resources/smalis/gh-issue-186.smali`:

```smali
.class Lgh/i186;
.super Ljava/lang/Object;

.method public getEntryIndex(FFLcom/github/mikephil/charting/data/DataSet$Rounding;)I
  .registers 14
    iget-object v0, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    const/4 v1, -1
    if-eqz v0, :L16
    iget-object v0, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    invoke-interface { v0 }, Ljava/util/List;->isEmpty()Z
    move-result v0
    if-eqz v0, :L0
    goto/16 :L16
  :L0
    const/4 v0, 0
    iget-object v2, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    invoke-interface { v2 }, Ljava/util/List;->size()I
    move-result v2
    add-int/lit8 v2, v2, -1
  :L1
    if-ge v0, v2, :L7
    add-int v3, v0, v2
    div-int/lit8 v3, v3, 2
    iget-object v4, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    invoke-interface { v4, v3 }, Ljava/util/List;->get(I)Ljava/lang/Object;
    move-result-object v4
    check-cast v4, Lcom/github/mikephil/charting/data/Entry;
    invoke-virtual { v4 }, Lcom/github/mikephil/charting/data/Entry;->getX()F
    move-result v4
    sub-float/2addr v4, p1
    iget-object v5, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    add-int/lit8 v6, v3, 1
    invoke-interface { v5, v6 }, Ljava/util/List;->get(I)Ljava/lang/Object;
    move-result-object v5
    check-cast v5, Lcom/github/mikephil/charting/data/Entry;
    invoke-virtual { v5 }, Lcom/github/mikephil/charting/data/Entry;->getX()F
    move-result v5
    sub-float/2addr v5, p1
    invoke-static { v4 }, Ljava/lang/Math;->abs(F)F
    move-result v7
    invoke-static { v5 }, Ljava/lang/Math;->abs(F)F
    move-result v5
    cmpg-float v8, v5, v7
    if-gez v8, :L3
  :L2
    move v0, v6
    goto :L1
  :L3
    cmpg-float v5, v7, v5
    if-gez v5, :L4
    goto :L5
  :L4
    float-to-double v4, v4
    const-wide/16 v7, 0
    cmpl-double v9, v4, v7
    if-ltz v9, :L6
  :L5
    move v2, v3
    goto :L1
  :L6
    cmpg-double v3, v4, v7
    if-gez v3, :L1
    goto :L2
  :L7
    if-eq v2, v1, :L15
    iget-object v0, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    invoke-interface { v0, v2 }, Ljava/util/List;->get(I)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Lcom/github/mikephil/charting/data/Entry;
    invoke-virtual { v0 }, Lcom/github/mikephil/charting/data/Entry;->getX()F
    move-result v0
    sget-object v1, Lcom/github/mikephil/charting/data/DataSet$Rounding;->UP:Lcom/github/mikephil/charting/data/DataSet$Rounding;
    if-ne p3, v1, :L8
    cmpg-float p1, v0, p1
    if-gez p1, :L9
    iget-object p1, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    invoke-interface { p1 }, Ljava/util/List;->size()I
    move-result p1
    add-int/lit8 p1, p1, -1
    if-ge v2, p1, :L9
    add-int/lit8 v2, v2, 1
    goto :L9
  :L8
    sget-object v1, Lcom/github/mikephil/charting/data/DataSet$Rounding;->DOWN:Lcom/github/mikephil/charting/data/DataSet$Rounding;
    if-ne p3, v1, :L9
    cmpl-float p1, v0, p1
    if-lez p1, :L9
    if-lez v2, :L9
    add-int/lit8 v2, v2, -1
  :L9
    invoke-static { p2 }, Ljava/lang/Float;->isNaN(F)Z
    move-result p1
    if-nez p1, :L15
  :L10
    if-lez v2, :L11
    iget-object p1, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    add-int/lit8 p3, v2, -1
    invoke-interface { p1, p3 }, Ljava/util/List;->get(I)Ljava/lang/Object;
    move-result-object p1
    check-cast p1, Lcom/github/mikephil/charting/data/Entry;
    invoke-virtual { p1 }, Lcom/github/mikephil/charting/data/Entry;->getX()F
    move-result p1
    cmpl-float p1, p1, v0
    if-nez p1, :L11
    add-int/lit8 v2, v2, -1
    goto :L10
  :L11
    iget-object p1, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    invoke-interface { p1, v2 }, Ljava/util/List;->get(I)Ljava/lang/Object;
    move-result-object p1
    check-cast p1, Lcom/github/mikephil/charting/data/Entry;
    invoke-virtual { p1 }, Lcom/github/mikephil/charting/data/Entry;->getY()F
    move-result p1
    move p3, p1
  :L12
    move p1, v2
  :L13
    add-int/lit8 v2, v2, 1
    iget-object v1, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    invoke-interface { v1 }, Ljava/util/List;->size()I
    move-result v1
    if-ge v2, v1, :L14
    iget-object v1, p0, Lcom/github/mikephil/charting/data/DataSet;->mValues:Ljava/util/List;
    invoke-interface { v1, v2 }, Ljava/util/List;->get(I)Ljava/lang/Object;
    move-result-object v1
    check-cast v1, Lcom/github/mikephil/charting/data/Entry;
    invoke-virtual { v1 }, Lcom/github/mikephil/charting/data/Entry;->getX()F
    move-result v3
    cmpl-float v3, v3, v0
    if-nez v3, :L14
    invoke-virtual { v1 }, Lcom/github/mikephil/charting/data/Entry;->getY()F
    move-result v1
    sub-float/2addr v1, p2
    invoke-static { v1 }, Ljava/lang/Math;->abs(F)F
    move-result v1
    sub-float v3, p3, p2
    invoke-static { v3 }, Ljava/lang/Math;->abs(F)F
    move-result v3
    cmpg-float v1, v1, v3
    if-gez v1, :L13
    move p3, p2
    goto :L12
  :L14
    move v2, p1
  :L15
    return v2
  :L16
    return v1
.end method


```

`dex-translator/src/test/resources/smalis/gh-issue-4.smali`:

```smali
.class Lgh/i4;
.super Ljava/lang/Object;

.method static public a(LIndenter;)Ljava/lang/Object;
  .registers 2
  if-nez v1, :L0
    new-instance v0, LNopIndenter;
    move-object v1, v0  #### use before init
    invoke-direct { v0 }, LNopIndenter;-><init>()V
  :L0
    return-object v1
.end method

```

`dex-translator/src/test/resources/smalis/gh501-r4k.smali`:

```smali
.class public final Lr4k;
.super Ljava/lang/Object;

# interfaces
.implements Lxak;


# direct methods
.method public constructor <init>()V
    .registers 1

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method


# virtual methods
.method public a(Ljava/lang/Throwable;)Lg9k;
    .registers 7

    instance-of v0, p1, LbAu;

    const/4 v1, 0x0

    if-eqz v0, :cond_2e

    new-instance v0, Lg9k;

    move-object v2, p1

    check-cast v2, LbAu;

    invoke-virtual {v2}, LbAu;->b()I

    move-result v3

    invoke-static {v3}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;

    move-result-object v3

    invoke-virtual {v2}, LbAu;->a()I

    move-result v2

    invoke-static {v2}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;

    move-result-object v2

    instance-of v4, p1, LoBu;

    if-eqz v4, :cond_2f

    :goto_1e
    check-cast p1, LoBu;

    iget p1, p1, LoBu;->a:I

    invoke-static {p1}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;

    move-result-object p1

    invoke-virtual {p0, p1}, Lr4k;->e(Ljava/lang/Integer;)Ljava/lang/Integer;

    move-result-object v1

    :cond_2a
    invoke-direct {v0, v3, v2, v1}, Lg9k;-><init>(Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Integer;)V

    move-object v1, v0

    :cond_2e
    return-object v1

    :cond_2f
    instance-of v4, p1, Lq4k;

    if-eqz v4, :cond_2a

    check-cast p1, Lq4k;

    iget-object p1, p1, Lq4k;->b:LbAu;

    instance-of v4, p1, LoBu;

    if-eqz v4, :cond_2a

    goto :goto_1e
.end method

.method public b(Ljava/lang/Exception;)Z
    .registers 5

    instance-of v0, p1, LbAu;

    const/4 v1, 0x0

    const/4 v2, 0x1

    if-eqz v0, :cond_16

    check-cast p1, LbAu;

    invoke-virtual {p1}, LbAu;->b()I

    move-result p1

    invoke-static {p1}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;

    move-result-object p1

    if-nez p1, :cond_17

    :cond_12
    const/4 p1, 0x0

    :goto_13
    if-eqz p1, :cond_16

    const/4 v1, 0x1

    :cond_16
    return v1

    :cond_17
    invoke-virtual {p1}, Ljava/lang/Integer;->intValue()I

    move-result p1

    const/4 v0, 0x3

    if-ne p1, v0, :cond_12

    const/4 p1, 0x1

    goto :goto_13
.end method

.method public c(Ls9k;Ljava/lang/Integer;Ljava/lang/Integer;)Z
    .registers 7

    sget-object v0, Ls9k;->CRONET:Ls9k;

    const/4 v1, 0x0

    if-eq p1, v0, :cond_6

    return v1

    :cond_6
    const/4 p1, 0x1

    if-nez p2, :cond_2b1

    :cond_9
    const/4 v0, 0x2

    if-nez p2, :cond_2b8

    :cond_c
    const/4 v0, 0x0

    :goto_d
    if-eqz v0, :cond_2a3

    :goto_f
    const/4 v0, 0x1

    :goto_10
    if-eqz v0, :cond_295

    :goto_12
    const/4 v0, 0x1

    :goto_13
    if-eqz v0, :cond_287

    :goto_15
    const/4 v0, 0x1

    :goto_16
    if-eqz v0, :cond_279

    :goto_18
    const/4 v0, 0x1

    :goto_19
    if-eqz v0, :cond_26b

    :goto_1b
    const/4 v0, 0x1

    :goto_1c
    if-eqz v0, :cond_25c

    :goto_1e
    const/4 v0, 0x1

    :goto_1f
    if-eqz v0, :cond_24d

    :goto_21
    const/4 v0, 0x1

    :goto_22
    if-eqz v0, :cond_23e

    :goto_24
    const/4 p2, 0x1

    :goto_25
    if-nez p2, :cond_87

    if-nez p3, :cond_22c

    :cond_29
    const/16 p2, -0xd

    if-nez p3, :cond_235

    :cond_2d
    const/4 p2, 0x0

    :goto_2e
    if-eqz p2, :cond_21e

    :goto_30
    const/4 p2, 0x1

    :goto_31
    if-eqz p2, :cond_20f

    :goto_33
    const/4 p2, 0x1

    :goto_34
    if-eqz p2, :cond_200

    :goto_36
    const/4 p2, 0x1

    :goto_37
    if-eqz p2, :cond_1f1

    :goto_39
    const/4 p2, 0x1

    :goto_3a
    if-eqz p2, :cond_1e2

    :goto_3c
    const/4 p2, 0x1

    :goto_3d
    if-eqz p2, :cond_1d3

    :goto_3f
    const/4 p2, 0x1

    :goto_40
    if-eqz p2, :cond_1c4

    :goto_42
    const/4 p2, 0x1

    :goto_43
    if-eqz p2, :cond_1b5

    :goto_45
    const/4 p2, 0x1

    :goto_46
    if-eqz p2, :cond_1a6

    :goto_48
    const/4 p2, 0x1

    :goto_49
    if-eqz p2, :cond_197

    :goto_4b
    const/4 p2, 0x1

    :goto_4c
    if-eqz p2, :cond_188

    :goto_4e
    const/4 p2, 0x1

    :goto_4f
    if-eqz p2, :cond_179

    :goto_51
    const/4 p2, 0x1

    :goto_52
    if-eqz p2, :cond_16a

    :goto_54
    const/4 p2, 0x1

    :goto_55
    if-eqz p2, :cond_15b

    :goto_57
    const/4 p2, 0x1

    :goto_58
    if-eqz p2, :cond_14c

    :goto_5a
    const/4 p2, 0x1

    :goto_5b
    if-eqz p2, :cond_13d

    :goto_5d
    const/4 p2, 0x1

    :goto_5e
    if-eqz p2, :cond_12e

    :goto_60
    const/4 p2, 0x1

    :goto_61
    if-eqz p2, :cond_11f

    :goto_63
    const/4 p2, 0x1

    :goto_64
    if-eqz p2, :cond_110

    :goto_66
    const/4 p2, 0x1

    :goto_67
    if-eqz p2, :cond_101

    :goto_69
    const/4 p2, 0x1

    :goto_6a
    if-eqz p2, :cond_f2

    :goto_6c
    const/4 p2, 0x1

    :goto_6d
    if-eqz p2, :cond_e4

    :goto_6f
    const/4 p2, 0x1

    :goto_70
    if-eqz p2, :cond_d7

    :goto_72
    const/4 p2, 0x1

    :goto_73
    if-eqz p2, :cond_ca

    :goto_75
    const/4 p2, 0x1

    :goto_76
    if-eqz p2, :cond_bd

    :goto_78
    const/4 p2, 0x1

    :goto_79
    if-eqz p2, :cond_b0

    :goto_7b
    const/4 p2, 0x1

    :goto_7c
    if-eqz p2, :cond_a3

    :goto_7e
    const/4 p2, 0x1

    :goto_7f
    if-eqz p2, :cond_96

    :goto_81
    const/4 p2, 0x1

    :goto_82
    if-eqz p2, :cond_89

    :goto_84
    const/4 p2, 0x1

    :goto_85
    if-eqz p2, :cond_88

    :cond_87
    const/4 v1, 0x1

    :cond_88
    return v1

    :cond_89
    const/16 p2, -0x160

    if-nez p3, :cond_8f

    :cond_8d
    const/4 p2, 0x0

    goto :goto_85

    :cond_8f
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result p3

    if-ne p3, p2, :cond_8d

    goto :goto_84

    :cond_96
    const/16 p2, -0x144

    if-nez p3, :cond_9c

    :cond_9a
    const/4 p2, 0x0

    goto :goto_82

    :cond_9c
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_9a

    goto :goto_81

    :cond_a3
    const/16 p2, -0x96

    if-nez p3, :cond_a9

    :cond_a7
    const/4 p2, 0x0

    goto :goto_7f

    :cond_a9
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_a7

    goto :goto_7e

    :cond_b0
    const/16 p2, -0x164

    if-nez p3, :cond_b6

    :cond_b4
    const/4 p2, 0x0

    goto :goto_7c

    :cond_b6
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_b4

    goto :goto_7b

    :cond_bd
    const/16 p2, -0x89

    if-nez p3, :cond_c3

    :cond_c1
    const/4 p2, 0x0

    goto :goto_79

    :cond_c3
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_c1

    goto :goto_78

    :cond_ca
    const/16 p2, -0x6b

    if-nez p3, :cond_d0

    :cond_ce
    const/4 p2, 0x0

    goto :goto_76

    :cond_d0
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_ce

    goto :goto_75

    :cond_d7
    const/16 p2, -0xc9

    if-nez p3, :cond_dd

    :cond_db
    const/4 p2, 0x0

    goto :goto_73

    :cond_dd
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_db

    goto :goto_72

    :cond_e4
    const/16 p2, -0xca

    if-nez p3, :cond_ea

    :cond_e8
    const/4 p2, 0x0

    goto :goto_70

    :cond_ea
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_e8

    goto/16 :goto_6f

    :cond_f2
    const/16 p2, -0xc8

    if-nez p3, :cond_f9

    :cond_f6
    const/4 p2, 0x0

    goto/16 :goto_6d

    :cond_f9
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_f6

    goto/16 :goto_6c

    :cond_101
    const/16 p2, -0x323

    if-nez p3, :cond_108

    :cond_105
    const/4 p2, 0x0

    goto/16 :goto_6a

    :cond_108
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_105

    goto/16 :goto_69

    :cond_110
    const/16 p2, -0x8b

    if-nez p3, :cond_117

    :cond_114
    const/4 p2, 0x0

    goto/16 :goto_67

    :cond_117
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_114

    goto/16 :goto_66

    :cond_11f
    const/16 p2, -0x82

    if-nez p3, :cond_126

    :cond_123
    const/4 p2, 0x0

    goto/16 :goto_64

    :cond_126
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_123

    goto/16 :goto_63

    :cond_12e
    const/16 p2, -0x79

    if-nez p3, :cond_135

    :cond_132
    const/4 p2, 0x0

    goto/16 :goto_61

    :cond_135
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_132

    goto/16 :goto_60

    :cond_13d
    const/16 p2, -0x78

    if-nez p3, :cond_144

    :cond_141
    const/4 p2, 0x0

    goto/16 :goto_5e

    :cond_144
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_141

    goto/16 :goto_5d

    :cond_14c
    const/16 p2, -0x76

    if-nez p3, :cond_153

    :cond_150
    const/4 p2, 0x0

    goto/16 :goto_5b

    :cond_153
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_150

    goto/16 :goto_5a

    :cond_15b
    const/16 p2, -0x6f

    if-nez p3, :cond_162

    :cond_15f
    const/4 p2, 0x0

    goto/16 :goto_58

    :cond_162
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_15f

    goto/16 :goto_57

    :cond_16a
    const/16 p2, -0x6d

    if-nez p3, :cond_171

    :cond_16e
    const/4 p2, 0x0

    goto/16 :goto_55

    :cond_171
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_16e

    goto/16 :goto_54

    :cond_179
    const/16 p2, -0x6a

    if-nez p3, :cond_180

    :cond_17d
    const/4 p2, 0x0

    goto/16 :goto_52

    :cond_180
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_17d

    goto/16 :goto_51

    :cond_188
    const/16 p2, -0x69

    if-nez p3, :cond_18f

    :cond_18c
    const/4 p2, 0x0

    goto/16 :goto_4f

    :cond_18f
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_18c

    goto/16 :goto_4e

    :cond_197
    const/16 p2, -0x68

    if-nez p3, :cond_19e

    :cond_19b
    const/4 p2, 0x0

    goto/16 :goto_4c

    :cond_19e
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_19b

    goto/16 :goto_4b

    :cond_1a6
    const/16 p2, -0x67

    if-nez p3, :cond_1ad

    :cond_1aa
    const/4 p2, 0x0

    goto/16 :goto_49

    :cond_1ad
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_1aa

    goto/16 :goto_48

    :cond_1b5
    const/16 p2, -0x66

    if-nez p3, :cond_1bc

    :cond_1b9
    const/4 p2, 0x0

    goto/16 :goto_46

    :cond_1bc
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_1b9

    goto/16 :goto_45

    :cond_1c4
    const/16 p2, -0x65

    if-nez p3, :cond_1cb

    :cond_1c8
    const/4 p2, 0x0

    goto/16 :goto_43

    :cond_1cb
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_1c8

    goto/16 :goto_42

    :cond_1d3
    const/16 p2, -0x64

    if-nez p3, :cond_1da

    :cond_1d7
    const/4 p2, 0x0

    goto/16 :goto_40

    :cond_1da
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_1d7

    goto/16 :goto_3f

    :cond_1e2
    const/16 p2, -0x1b

    if-nez p3, :cond_1e9

    :cond_1e6
    const/4 p2, 0x0

    goto/16 :goto_3d

    :cond_1e9
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_1e6

    goto/16 :goto_3c

    :cond_1f1
    const/16 p2, -0x1a

    if-nez p3, :cond_1f8

    :cond_1f5
    const/4 p2, 0x0

    goto/16 :goto_3a

    :cond_1f8
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_1f5

    goto/16 :goto_39

    :cond_200
    const/16 p2, -0x17

    if-nez p3, :cond_207

    :cond_204
    const/4 p2, 0x0

    goto/16 :goto_37

    :cond_207
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_204

    goto/16 :goto_36

    :cond_20f
    const/16 p2, -0x15

    if-nez p3, :cond_216

    :cond_213
    const/4 p2, 0x0

    goto/16 :goto_34

    :cond_216
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_213

    goto/16 :goto_33

    :cond_21e
    const/4 p2, -0x3

    if-nez p3, :cond_224

    :cond_221
    const/4 p2, 0x0

    goto/16 :goto_31

    :cond_224
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_221

    goto/16 :goto_30

    :cond_22c
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result p2

    const/16 v0, -0xc

    if-ne p2, v0, :cond_29

    goto :goto_23b

    :cond_235
    invoke-virtual {p3}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p2, :cond_2d

    :goto_23b
    const/4 p2, 0x1

    goto/16 :goto_2e

    :cond_23e
    const/16 v0, 0xa

    if-nez p2, :cond_245

    :cond_242
    const/4 p2, 0x0

    goto/16 :goto_25

    :cond_245
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result p2

    if-ne p2, v0, :cond_242

    goto/16 :goto_24

    :cond_24d
    const/16 v0, 0x9

    if-nez p2, :cond_254

    :cond_251
    const/4 v0, 0x0

    goto/16 :goto_22

    :cond_254
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_251

    goto/16 :goto_21

    :cond_25c
    const/16 v0, 0x8

    if-nez p2, :cond_263

    :cond_260
    const/4 v0, 0x0

    goto/16 :goto_1f

    :cond_263
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_260

    goto/16 :goto_1e

    :cond_26b
    const/4 v0, 0x7

    if-nez p2, :cond_271

    :cond_26e
    const/4 v0, 0x0

    goto/16 :goto_1c

    :cond_271
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_26e

    goto/16 :goto_1b

    :cond_279
    const/4 v0, 0x6

    if-nez p2, :cond_27f

    :cond_27c
    const/4 v0, 0x0

    goto/16 :goto_19

    :cond_27f
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_27c

    goto/16 :goto_18

    :cond_287
    const/4 v0, 0x5

    if-nez p2, :cond_28d

    :cond_28a
    const/4 v0, 0x0

    goto/16 :goto_16

    :cond_28d
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_28a

    goto/16 :goto_15

    :cond_295
    const/4 v0, 0x4

    if-nez p2, :cond_29b

    :cond_298
    const/4 v0, 0x0

    goto/16 :goto_13

    :cond_29b
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_298

    goto/16 :goto_12

    :cond_2a3
    const/4 v0, 0x3

    if-nez p2, :cond_2a9

    :cond_2a6
    const/4 v0, 0x0

    goto/16 :goto_10

    :cond_2a9
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_2a6

    goto/16 :goto_f

    :cond_2b1
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v0

    if-ne v0, p1, :cond_9

    goto :goto_2be

    :cond_2b8
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_c

    :goto_2be
    const/4 v0, 0x1

    goto/16 :goto_d
.end method

.method public d(Ls9k;Ljava/lang/Integer;)LK9k;
    .registers 7

    sget-object v0, Ls9k;->CRONET:Ls9k;

    const/4 v1, 0x0

    if-eq p1, v0, :cond_6

    return-object v1

    :cond_6
    const/4 p1, 0x0

    const/4 v0, 0x1

    if-nez p2, :cond_40

    :cond_a
    const/4 v2, 0x0

    :goto_b
    if-eqz v2, :cond_10

    sget-object v1, LK9k;->DNS_ERROR:LK9k;

    :cond_f
    :goto_f
    return-object v1

    :cond_10
    if-nez p2, :cond_1b

    :goto_12
    const/4 v2, 0x6

    if-nez p2, :cond_23

    :cond_15
    const/4 v2, 0x0

    :goto_16
    if-eqz v2, :cond_2b

    sget-object v1, LK9k;->TIMEOUT:LK9k;

    goto :goto_f

    :cond_1b
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    const/4 v3, 0x4

    if-eq v2, v3, :cond_29

    goto :goto_12

    :cond_23
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v3

    if-ne v3, v2, :cond_15

    :cond_29
    const/4 v2, 0x1

    goto :goto_16

    :cond_2b
    if-nez p2, :cond_32

    :cond_2d
    :goto_2d
    if-eqz p1, :cond_3b

    sget-object v1, LK9k;->NETWORK_CHANGED:LK9k;

    goto :goto_f

    :cond_32
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    const/4 v3, 0x3

    if-ne v2, v3, :cond_2d

    const/4 p1, 0x1

    goto :goto_2d

    :cond_3b
    if-eqz p2, :cond_f

    sget-object v1, LK9k;->CONNECTION_ERROR:LK9k;

    goto :goto_f

    :cond_40
    invoke-virtual {p2}, Ljava/lang/Integer;->intValue()I

    move-result v2

    if-ne v2, v0, :cond_a

    const/4 v2, 0x1

    goto :goto_b
.end method

.method public final e(Ljava/lang/Integer;)Ljava/lang/Integer;
    .registers 3

    const/4 v0, 0x0

    if-nez p1, :cond_4

    :goto_3
    return-object v0

    :cond_4
    invoke-virtual {p1}, Ljava/lang/Number;->intValue()I

    move-result p1

    if-nez p1, :cond_b

    goto :goto_3

    :cond_b
    invoke-static {p1}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;

    move-result-object p1

    move-object v0, p1

    goto :goto_3
.end method

```

`dex-translator/src/test/resources/smalis/goto-first-label.smali`:

```smali
.class Lxgoto/first/label;
.super Ljava/lang/Object;

.method public static assertSlept()V
    .registers 3
    :L0
    sget-object v1, LA;->sleepSemaphore:Ljava/util/concurrent/Semaphore;
    invoke-virtual { v1 }, Ljava/util/concurrent/Semaphore;->availablePermits()I
    move-result v1
    if-nez v1, :L1
    return-void
    :L1
    const-wide/16 v1, 50
    invoke-static { v1, v2 }, Ljava/lang/Thread;->sleep(J)V
    goto :L0
.end method

.method public static g2(LObj;)V
    .registers 4
    :L0
    invoke-virtual { p0 }, LObj;->next()LObj;
    move-result-object v3
    if-nez v3, :L1
    return-void
    :L1
    invoke-virtual { p0 }, LObj;->next()LObj;
    move-result-object p0
    goto :L0
.end method

```

`dex-translator/src/test/resources/smalis/i230.smali`:

```smali
.class Li230;
.super Li230;

.method public i230(II)F
    .catchall { :L5 .. :L10 } :L9
    .registers 10
    move-object v0, p0
    monitor-enter v0
    :L5
    int-to-float v0, p1
    int-to-float v1, p2
    div-float/2addr v1, v0
    move-object v0, p0
    monitor-exit v0
    return v1

    :L9
    move-exception v1
    monitor-exit v0
    :L10
    const v1, 0
    return v1
.end method

```

`dex-translator/src/test/resources/smalis/int-or-boolean.smali`:

```smali
.class Li/or/Z;
.super Ljava/lang/Object;

.method static synthetic access$376(Lcom/google/android/finsky/widget/consumption/NowPlayingWidgetProvider$ViewTreeWrapper;I)Z
    .registers 3
    iget-boolean v0, v1, Lcom/google/android/finsky/widget/consumption/NowPlayingWidgetProvider$ViewTreeWrapper;->showBackground:Z
    or-int/2addr v0, v2
    int-to-byte v0, v0
    iput-boolean v0, v1, Lcom/google/android/finsky/widget/consumption/NowPlayingWidgetProvider$ViewTreeWrapper;->showBackground:Z
    return v0
.end method

```

`dex-translator/src/test/resources/smalis/issue-220-219-uninit-reg.smali`:

```smali
.class Li220/i219;
.super Ljava/lang/Object;
.method public static i219(Ljava/lang/String;)I
    .registers 2
    return v0
.end method

.method public i220()Ljava/lang/String;
    .registers 7
    if-eqz v1, :L0
    move v0, v6
    :L0
    return-object v2
.end method

.method public onClick(Landroid/content/DialogInterface;I)V
    .registers 5
    iget-object v0, v2, Lcom/adroidbscpc/a15mSurvival3rh/MainA$2;->this$0:Lcom/adroidbscpc/a15mSurvival3rh/MainA;
    move-result-object v0
    iget-object v1, v2, Lcom/adroidbscpc/a15mSurvival3rh/MainA$2;->this$0:Lcom/adroidbscpc/a15mSurvival3rh/MainA;
    return-void
.end method

```

`dex-translator/src/test/resources/smalis/loop-enclosing-class.smali`:

```smali
.class La;
.super Ljava/lang/Object;

# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = La;
.end annotation
.end class


.class Lb;
.super Ljava/lang/Object;

# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lc;
.end annotation
.end class


.class Lc;
.super Ljava/lang/Object;

# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = Lb;
.end annotation
.end class
```

`dex-translator/src/test/resources/smalis/method-code-too-large.smali`:

```smali

.class Lcode/Large;
.super Lcode/LargeS;

.method private static constructor <clinit>()V
  .catchall { :L2 .. :L3 } :L0
  .catchall { :L6 .. :L7 } :L4
  .catchall { :L10 .. :L11 } :L8
  .catchall { :L14 .. :L15 } :L12
  .catchall { :L18 .. :L19 } :L16
  .catchall { :L22 .. :L23 } :L20
  .catchall { :L27 .. :L28 } :L25
  .catchall { :L30 .. :L31 } :L29
  .catchall { :L34 .. :L35 } :L32
  .catchall { :L39 .. :L40 } :L37
  .catchall { :L43 .. :L44 } :L41
  .catchall { :L48 .. :L49 } :L46
  .catchall { :L53 .. :L54 } :L51
  .catchall { :L57 .. :L58 } :L55
  .catchall { :L61 .. :L62 } :L59
  .catchall { :L65 .. :L66 } :L63
  .catchall { :L70 .. :L71 } :L68
  .catch Ljava/lang/Exception; { :L72 .. :L74 } :L97
  .catchall { :L75 .. :L76 } :L73
  .catch Ljava/lang/Exception; { :L78 .. :L79 } :L97
  .catchall { :L80 .. :L81 } :L77
  .catch Ljava/lang/Exception; { :L82 .. :L84 } :L97
  .catchall { :L85 .. :L86 } :L83
  .catch Ljava/lang/Exception; { :L88 .. :L89 } :L97
  .catchall { :L90 .. :L91 } :L87
  .catch Ljava/lang/Exception; { :L92 .. :L94 } :L97
  .catchall { :L95 .. :L96 } :L93
  .catchall { :L100 .. :L101 } :L98
  .catchall { :L104 .. :L105 } :L102
  .catchall { :L107 .. :L108 } :L106
  .catchall { :L111 .. :L112 } :L109
  .catchall { :L115 .. :L116 } :L113
  .catchall { :L119 .. :L120 } :L117
  .catchall { :L123 .. :L124 } :L121
  .catchall { :L127 .. :L128 } :L125
  .catchall { :L131 .. :L132 } :L129
  .catchall { :L135 .. :L136 } :L133
  .catch Ljava/lang/Exception; { :L138 .. :L139 } :L150
  .catchall { :L140 .. :L141 } :L137
  .catch Ljava/lang/Exception; { :L144 .. :L145 } :L151
  .catchall { :L146 .. :L147 } :L143
  .registers 18
    const/16 v0, 648
    new-array v0, v0, [S
    fill-array-data v0, :L152
    sput-object v0, Lo/\ufee4$\u1508;->\u0399:[S
    const/16 v0, 217
    sput v0, Lo/\ufee4$\u1508;->\u0406:I
    const/16 v17, 0
    const/4 v10, 0
    const/4 v13, 0
    const/16 v0, 5336
    const/16 v1, 612
    const/4 v2, 7
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    goto :L1
  :L0
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L1
    const/4 v1, 1
  :L2
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v2, 0
    aput-object v0, v1, v2
    const/16 v0, 5277
    const/16 v2, 85
    const/16 v3, 29
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/4 v2, 1
    new-array v2, v2, [Ljava/lang/Class;
    const-class v3, Ljava/lang/String;
    const/4 v4, 0
    aput-object v3, v2, v4
    invoke-virtual { v0, v2 }, Ljava/lang/Class;->getDeclaredConstructor([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;
    move-result-object v0
    invoke-virtual { v0, v1 }, Ljava/lang/reflect/Constructor;->newInstance([Ljava/lang/Object;)Ljava/lang/Object;
  :L3
    move-result-object v14
    goto :L5
  :L4
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L5
    const/16 v0, 5277
    const/16 v1, 85
    const/16 v2, 29
  :L6
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v1, 5284
    const/16 v2, 438
    const/16 v3, 33
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v1, 0
    invoke-virtual { v0, v14, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Boolean;
    invoke-virtual { v0 }, Ljava/lang/Boolean;->booleanValue()Z
  :L7
    move-result v0
    if-nez v0, :L24
    const/16 v0, 5277
    const/16 v1, 451
    const/16 v2, 27
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    goto :L9
  :L8
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L9
    const/4 v1, 2
  :L10
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v2, 1
    aput-object v0, v1, v2
    const/4 v2, 0
    aput-object v0, v1, v2
    sget v0, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v0, v0, 63
    int-to-byte v0, v0
    const/16 v2, 5277
    const/16 v3, 493
    invoke-static { v2, v3, v0 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v2, 5280
    const/16 v3, 115
    const/16 v4, 30
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 2
    new-array v3, v3, [Ljava/lang/Class;
    const-class v4, Ljava/lang/String;
    const/4 v5, 0
    aput-object v4, v3, v5
    const-class v4, Ljava/lang/String;
    const/4 v5, 1
    aput-object v4, v3, v5
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v2, 0
    invoke-virtual { v0, v2, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L11
    move-result-object v0
    goto :L13
  :L12
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L13
    const/4 v1, 1
  :L14
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v2, 0
    aput-object v0, v1, v2
    const/16 v0, 5277
    const/16 v2, 85
    const/16 v3, 29
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/4 v2, 1
    new-array v2, v2, [Ljava/lang/Class;
    const-class v3, Ljava/lang/String;
    const/4 v4, 0
    aput-object v3, v2, v4
    invoke-virtual { v0, v2 }, Ljava/lang/Class;->getDeclaredConstructor([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;
    move-result-object v0
    invoke-virtual { v0, v1 }, Ljava/lang/reflect/Constructor;->newInstance([Ljava/lang/Object;)Ljava/lang/Object;
  :L15
    move-result-object v14
    goto :L17
  :L16
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L17
    const/16 v0, 5277
    const/16 v1, 85
    const/16 v2, 29
  :L18
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v1, 5284
    const/16 v2, 438
    const/16 v3, 33
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v1, 0
    invoke-virtual { v0, v14, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Boolean;
    invoke-virtual { v0 }, Ljava/lang/Boolean;->booleanValue()Z
  :L19
    move-result v0
    if-nez v0, :L24
    goto :L21
  :L20
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L21
    const/16 v0, 5286
    const/16 v1, 205
    const/16 v2, 19
  :L22
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    sget v1, Lo/\ufee4$\u1508;->\u0406:I
    or-int/lit8 v1, v1, 32
    int-to-short v1, v1
    const/16 v2, 5280
    const/16 v3, 14
    invoke-static { v2, v1, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v1, 0
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L23
    move-result-object v14
  :L24
    const/16 v0, 5300
    const/16 v1, 427
    const/16 v2, 33
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    goto :L26
  :L25
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L26
    const/4 v1, 1
  :L27
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v2, 0
    aput-object v0, v1, v2
    const/16 v0, 5277
    const/16 v2, 420
    const/16 v3, 15
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v2, 5280
    const/16 v3, 184
    const/16 v4, 30
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 1
    new-array v3, v3, [Ljava/lang/Class;
    const-class v4, Ljava/lang/String;
    const/4 v5, 0
    aput-object v4, v3, v5
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v2, 0
    invoke-virtual { v0, v2, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L28
    move-result-object v12
    goto :L30
  :L29
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L30
    sget v0, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v0, v0, 63
    int-to-byte v0, v0
    const/16 v1, 5277
    const/16 v2, 493
    invoke-static { v1, v2, v0 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    sget v1, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v1, v1, 62
    int-to-byte v1, v1
    const/16 v2, 5284
    const/16 v3, 368
    invoke-static { v2, v3, v1 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v1, 0
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Long;
    invoke-virtual { v0 }, Ljava/lang/Long;->longValue()J
  :L31
    move-result-wide v0
    const-wide/32 v2, 166624680
    xor-long/2addr v2, v0
    goto :L33
  :L32
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L33
    const/4 v0, 1
  :L34
    new-array v1, v0, [Ljava/lang/Object;
    invoke-static { v2, v3 }, Ljava/lang/Long;->valueOf(J)Ljava/lang/Long;
    move-result-object v0
    const/4 v2, 0
    aput-object v0, v1, v2
    const/16 v0, 5277
    const/16 v2, 420
    const/16 v3, 15
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v2, 5268
    const/16 v3, 121
    const/16 v4, 34
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 1
    new-array v3, v3, [Ljava/lang/Class;
    sget-object v4, Ljava/lang/Long;->TYPE:Ljava/lang/Class;
    const/4 v5, 0
    aput-object v4, v3, v5
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    invoke-virtual { v0, v12, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L35
    new-instance v0, Ljava/lang/String;
    const/4 v1, 4
    new-array v1, v1, [C
    const/4 v2, 0
    const/16 v3, 46
    goto/16 :L45
  :L36
    goto :L38
  :L37
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L38
    const/4 v3, 1
  :L39
    new-array v4, v3, [Ljava/lang/Object;
    const v3, 65279
    invoke-static { v3 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v3
    const/4 v5, 0
    aput-object v3, v4, v5
    const/16 v3, 5277
    const/16 v5, 420
    const/16 v6, 15
    invoke-static { v3, v5, v6 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v3
    invoke-static { v3 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v3
    const/16 v5, 5273
    const/4 v6, 0
    const/16 v7, 34
    invoke-static { v5, v6, v7 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v5
    const/4 v6, 1
    new-array v6, v6, [Ljava/lang/Class;
    sget-object v7, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v8, 0
    aput-object v7, v6, v8
    invoke-virtual { v3, v5, v6 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v3
    invoke-virtual { v3, v12, v4 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v3
    check-cast v3, Ljava/lang/Integer;
    invoke-virtual { v3 }, Ljava/lang/Integer;->intValue()I
  :L40
    move-result v3
    add-int/lit16 v3, v3, 256
    goto :L42
  :L41
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L42
    const/4 v4, 1
  :L43
    new-array v5, v4, [Ljava/lang/Object;
    invoke-static { v3 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v4
    const/4 v6, 0
    aput-object v4, v5, v6
    const/16 v4, 5277
    const/16 v6, 386
    const/16 v7, 22
    invoke-static { v4, v6, v7 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v4
    invoke-static { v4 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v4
    sget v6, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v6, v6, 55
    int-to-byte v6, v6
    const/16 v7, 5278
    const/16 v8, 144
    invoke-static { v7, v8, v6 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v6
    const/4 v7, 1
    new-array v7, v7, [Ljava/lang/Class;
    sget-object v8, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v9, 0
    aput-object v8, v7, v9
    invoke-virtual { v4, v6, v7 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v4
    const/4 v6, 0
    invoke-virtual { v4, v6, v5 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v4
    check-cast v4, Ljava/lang/Boolean;
    invoke-virtual { v4 }, Ljava/lang/Boolean;->booleanValue()Z
  :L44
    move-result v4
    if-nez v4, :L45
    goto/16 :L36
  :L45
    int-to-char v3, v3
    aput-char v3, v1, v2
    add-int/lit8 v2, v2, 1
    and-int/lit8 v3, v2, 3
    if-nez v3, :L36
    invoke-direct { v0, v1 }, Ljava/lang/String;-><init>([C)V
    goto :L47
  :L46
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L47
    const/4 v1, 2
  :L48
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v2, 1
    aput-object v0, v1, v2
    const/4 v0, 0
    aput-object v14, v1, v0
    const/16 v0, 5277
    const/16 v2, 85
    const/16 v3, 29
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/4 v2, 2
    new-array v2, v2, [Ljava/lang/Class;
    const/16 v3, 5277
    const/16 v4, 85
    const/16 v5, 29
    invoke-static { v3, v4, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v3
    invoke-static { v3 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v3
    const/4 v4, 0
    aput-object v3, v2, v4
    const-class v3, Ljava/lang/String;
    const/4 v4, 1
    aput-object v3, v2, v4
    invoke-virtual { v0, v2 }, Ljava/lang/Class;->getDeclaredConstructor([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;
    move-result-object v0
    invoke-virtual { v0, v1 }, Ljava/lang/reflect/Constructor;->newInstance([Ljava/lang/Object;)Ljava/lang/Object;
  :L49
    move-result-object v10
    if-nez v17, :L50
    move-object/from16 v17, v10
    goto/16 :L35
  :L50
    const/16 v0, 5272
    const/16 v1, 154
    const/16 v2, 36
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v16
    const/16 v11, 2150
    sget v0, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v0, v0, 62
    int-to-byte v0, v0
    const/16 v1, 5318
    const/16 v2, 628
    invoke-static { v1, v2, v0 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    const/16 v1, 5317
    const/16 v2, 428
    const/16 v3, 39
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    goto :L52
  :L51
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L52
    const/4 v1, 2
  :L53
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v3, 1
    aput-object v2, v1, v3
    const/4 v2, 0
    aput-object v0, v1, v2
    const/16 v0, 5277
    const/16 v2, 547
    const/16 v3, 22
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v2, 5280
    const/16 v3, 184
    const/16 v4, 30
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 2
    new-array v3, v3, [Ljava/lang/Class;
    const-class v4, Ljava/lang/String;
    const/4 v5, 0
    aput-object v4, v3, v5
    const-class v4, Ljava/lang/String;
    const/4 v5, 1
    aput-object v4, v3, v5
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v2, 0
    invoke-virtual { v0, v2, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L54
    move-result-object v0
    const/16 v1, 16
    new-array v1, v1, [B
    fill-array-data v1, :L153
    const/16 v2, 5318
    const/16 v3, 453
    const/16 v4, 38
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v3
    goto :L56
  :L55
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L56
    const/4 v2, 2
  :L57
    new-array v2, v2, [Ljava/lang/Object;
    const/4 v4, 1
    aput-object v3, v2, v4
    const/4 v3, 0
    aput-object v1, v2, v3
    const/16 v1, 5277
    const/16 v3, 30
    const/16 v4, 10
    invoke-static { v1, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    invoke-static { v1 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v1
    const/4 v3, 2
    new-array v3, v3, [Ljava/lang/Class;
    const-class v4, [B
    const/4 v5, 0
    aput-object v4, v3, v5
    const-class v4, Ljava/lang/String;
    const/4 v5, 1
    aput-object v4, v3, v5
    invoke-virtual { v1, v3 }, Ljava/lang/Class;->getDeclaredConstructor([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;
    move-result-object v1
    invoke-virtual { v1, v2 }, Ljava/lang/reflect/Constructor;->newInstance([Ljava/lang/Object;)Ljava/lang/Object;
  :L58
    move-result-object v1
    const/16 v2, 16
    new-array v2, v2, [B
    fill-array-data v2, :L154
    goto :L60
  :L59
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L60
    const/4 v3, 1
  :L61
    new-array v3, v3, [Ljava/lang/Object;
    const/4 v4, 0
    aput-object v2, v3, v4
    sget v2, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v2, v2, 46
    int-to-byte v2, v2
    const/16 v4, 5277
    const/16 v5, 579
    invoke-static { v4, v5, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    invoke-static { v2 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v2
    const/4 v4, 1
    new-array v4, v4, [Ljava/lang/Class;
    const-class v5, [B
    const/4 v6, 0
    aput-object v5, v4, v6
    invoke-virtual { v2, v4 }, Ljava/lang/Class;->getDeclaredConstructor([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;
    move-result-object v2
    invoke-virtual { v2, v3 }, Ljava/lang/reflect/Constructor;->newInstance([Ljava/lang/Object;)Ljava/lang/Object;
  :L62
    move-result-object v3
    goto :L64
  :L63
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L64
    const/4 v2, 3
  :L65
    new-array v2, v2, [Ljava/lang/Object;
    const/4 v4, 2
    aput-object v3, v2, v4
    const/4 v3, 1
    aput-object v1, v2, v3
    const/4 v1, 2
    invoke-static { v1 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v1
    const/4 v3, 0
    aput-object v1, v2, v3
    const/16 v1, 5277
    const/16 v3, 547
    const/16 v4, 22
    invoke-static { v1, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    invoke-static { v1 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v1
    sget v3, Lo/\ufee4$\u1508;->\u0406:I
    add-int/lit8 v3, v3, -1
    int-to-short v3, v3
    const/16 v4, 5278
    const/16 v5, 37
    invoke-static { v4, v3, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v3
    const/4 v4, 3
    new-array v4, v4, [Ljava/lang/Class;
    sget-object v5, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v6, 0
    aput-object v5, v4, v6
    sget v5, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v5, v5, 62
    int-to-byte v5, v5
    const/16 v6, 5277
    const/16 v7, 529
    invoke-static { v6, v7, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v5
    invoke-static { v5 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v5
    const/4 v6, 1
    aput-object v5, v4, v6
    const/16 v5, 5277
    const/16 v6, 342
    const/4 v7, 0
    invoke-static { v5, v6, v7 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v5
    invoke-static { v5 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v5
    const/4 v6, 2
    aput-object v5, v4, v6
    invoke-virtual { v1, v3, v4 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v1
    invoke-virtual { v1, v0, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L66
    const/16 v1, 17
    const/16 v2, 2172
    const/16 v3, 2189
    new-array v3, v3, [B
    fill-array-data v3, :L155
  :L67
    const/16 v4, 2188
    aget-byte v4, v3, v4
    add-int/lit8 v4, v4, 42
    int-to-byte v4, v4
    const/16 v5, 748
    aput-byte v4, v3, v5
    goto :L69
  :L68
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L69
    const/4 v4, 3
  :L70
    new-array v4, v4, [Ljava/lang/Object;
    invoke-static { v2 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v2
    const/4 v5, 2
    aput-object v2, v4, v5
    const/16 v1, 17
    invoke-static { v1 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v1
    const/4 v2, 1
    aput-object v1, v4, v2
    const/4 v1, 0
    aput-object v3, v4, v1
    const/16 v1, 5277
    const/16 v2, 547
    const/16 v3, 22
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    invoke-static { v1 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v1
    const/16 v2, 5283
    const/16 v3, 638
    const/16 v5, 34
    invoke-static { v2, v3, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 3
    new-array v3, v3, [Ljava/lang/Class;
    const-class v5, [B
    const/4 v6, 0
    aput-object v5, v3, v6
    sget-object v5, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v6, 1
    aput-object v5, v3, v6
    sget-object v5, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v6, 2
    aput-object v5, v3, v6
    invoke-virtual { v1, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v1
    invoke-virtual { v1, v0, v4 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, [B
  :L71
    move-object v15, v0
    const/16 v0, 5286
    const/16 v1, 302
    const/16 v2, 20
  :L72
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    const/4 v12, 0
    const-class v0, Lo/\ufee4$\u1508;
    invoke-virtual { v0 }, Ljava/lang/Class;->getClassLoader()Ljava/lang/ClassLoader;
    move-result-object v0
    goto :L74
  :L73
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L74
    const/4 v1, 1
  :L75
    new-array v2, v1, [Ljava/lang/Object;
    const/4 v1, 1
    invoke-static { v1 }, Ljava/lang/Boolean;->valueOf(Z)Ljava/lang/Boolean;
    move-result-object v1
    const/4 v3, 0
    aput-object v1, v2, v3
    const/16 v1, 5277
    const/16 v3, 474
    const/16 v4, 19
    invoke-static { v1, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    invoke-static { v1 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v1
    const/4 v3, 1
    new-array v3, v3, [Ljava/lang/Class;
    sget-object v4, Ljava/lang/Boolean;->TYPE:Ljava/lang/Class;
    const/4 v5, 0
    aput-object v4, v3, v5
    invoke-virtual { v1, v3 }, Ljava/lang/Class;->getDeclaredConstructor([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;
    move-result-object v1
    invoke-virtual { v1, v2 }, Ljava/lang/reflect/Constructor;->newInstance([Ljava/lang/Object;)Ljava/lang/Object;
  :L76
    move-result-object v3
    add-int/lit8 v1, v11, -63
    goto :L79
  :L77
    move-exception v0
  :L78
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L79
    const/4 v2, 3
  :L80
    new-array v2, v2, [Ljava/lang/Object;
    invoke-static { v1 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v1
    const/4 v4, 2
    aput-object v1, v2, v4
    const/16 v1, 63
    invoke-static { v1 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v1
    const/4 v4, 1
    aput-object v1, v2, v4
    const/4 v1, 0
    aput-object v15, v2, v1
    const/16 v1, 5277
    const/16 v4, 474
    const/16 v5, 19
    invoke-static { v1, v4, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    invoke-static { v1 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v1
    sget v4, Lo/\ufee4$\u1508;->\u0406:I
    or-int/lit8 v4, v4, 6
    int-to-short v4, v4
    const/16 v5, 5268
    const/16 v6, 33
    invoke-static { v5, v4, v6 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v4
    const/4 v5, 3
    new-array v5, v5, [Ljava/lang/Class;
    const-class v6, [B
    const/4 v7, 0
    aput-object v6, v5, v7
    sget-object v6, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v7, 1
    aput-object v6, v5, v7
    sget-object v6, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v7, 2
    aput-object v6, v5, v7
    invoke-virtual { v1, v4, v5 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v1
    invoke-virtual { v1, v3, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L81
    const/16 v1, 44
  :L82
    aget-byte v1, v15, v1
    and-int/lit16 v1, v1, 255
    const/16 v2, 45
    aget-byte v2, v15, v2
    shl-int/lit8 v2, v2, 8
    int-to-char v2, v2
    or-int/2addr v1, v2
    const/16 v2, 46
    aget-byte v2, v15, v2
    and-int/lit16 v2, v2, 255
    shl-int/lit8 v2, v2, 16
    or-int/2addr v1, v2
    const/16 v2, 47
    aget-byte v2, v15, v2
    shl-int/lit8 v2, v2, 24
    or-int/2addr v1, v2
    new-array v1, v1, [B
    goto :L84
  :L83
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L84
    const/4 v2, 1
  :L85
    new-array v4, v2, [Ljava/lang/Object;
    const/4 v2, 0
    aput-object v1, v4, v2
    const/16 v2, 5277
    const/16 v5, 474
    const/16 v6, 19
    invoke-static { v2, v5, v6 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    invoke-static { v2 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v2
    const/16 v5, 5278
    const/16 v6, 91
    const/16 v7, 34
    invoke-static { v5, v6, v7 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v5
    const/4 v6, 1
    new-array v6, v6, [Ljava/lang/Class;
    const-class v7, [B
    const/4 v8, 0
    aput-object v7, v6, v8
    invoke-virtual { v2, v5, v6 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v2
    invoke-virtual { v2, v3, v4 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v2
    check-cast v2, Ljava/lang/Integer;
    invoke-virtual { v2 }, Ljava/lang/Integer;->intValue()I
  :L86
    goto :L89
  :L87
    move-exception v0
  :L88
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L89
    const/4 v2, 1
  :L90
    new-array v2, v2, [Ljava/lang/Object;
    const/4 v3, 0
    aput-object v1, v2, v3
    const/16 v1, 5283
    const/16 v3, 513
    const/16 v4, 20
    invoke-static { v1, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    invoke-static { v1 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v1
    const/16 v3, 5272
    const/16 v4, 352
    const/16 v5, 30
    invoke-static { v3, v4, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v3
    const/4 v4, 1
    new-array v4, v4, [Ljava/lang/Class;
    const-class v5, [B
    const/4 v6, 0
    aput-object v5, v4, v6
    invoke-virtual { v1, v3, v4 }, Ljava/lang/Class;->getDeclaredMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v1
    const/4 v3, 1
    invoke-virtual { v1, v3 }, Ljava/lang/reflect/AccessibleObject;->setAccessible(Z)V
    const/4 v3, 0
    invoke-virtual { v1, v3, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v1
    check-cast v1, Ljava/lang/Integer;
    invoke-virtual { v1 }, Ljava/lang/Integer;->intValue()I
  :L91
    move-result v2
  :L92
    invoke-static { v2 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v14
    goto :L94
  :L93
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L94
    const/4 v1, 3
  :L95
    new-array v1, v1, [Ljava/lang/Object;
    invoke-static { v2 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v2
    const/4 v3, 2
    aput-object v2, v1, v3
    const/4 v2, 1
    aput-object v0, v1, v2
    const/4 v0, 0
    aput-object v16, v1, v0
    const/16 v0, 5283
    const/16 v2, 513
    const/16 v3, 20
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v2, 5283
    const/16 v3, 259
    const/16 v4, 30
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 3
    new-array v3, v3, [Ljava/lang/Class;
    const-class v4, Ljava/lang/String;
    const/4 v5, 0
    aput-object v4, v3, v5
    const-class v4, Ljava/lang/ClassLoader;
    const/4 v5, 1
    aput-object v4, v3, v5
    sget-object v4, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v5, 2
    aput-object v4, v3, v5
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getDeclaredMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v2, 1
    invoke-virtual { v0, v2 }, Ljava/lang/reflect/AccessibleObject;->setAccessible(Z)V
    const/4 v2, 0
    invoke-virtual { v0, v2, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Class;
  :L96
    move-object v12, v0
    goto/16 :L148
  :L97
    const/4 v12, 0
    goto :L99
  :L98
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L99
    const/4 v0, 1
  :L100
    new-array v1, v0, [Ljava/lang/Object;
    const/4 v0, 0
    aput-object v17, v1, v0
    sget v0, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v0, v0, 55
    int-to-byte v0, v0
    const/16 v2, 5277
    const/16 v3, 282
    invoke-static { v2, v3, v0 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/4 v2, 1
    new-array v2, v2, [Ljava/lang/Class;
    const/16 v3, 5277
    const/16 v4, 85
    const/16 v5, 29
    invoke-static { v3, v4, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v3
    invoke-static { v3 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v3
    const/4 v4, 0
    aput-object v3, v2, v4
    invoke-virtual { v0, v2 }, Ljava/lang/Class;->getDeclaredConstructor([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;
    move-result-object v0
    invoke-virtual { v0, v1 }, Ljava/lang/reflect/Constructor;->newInstance([Ljava/lang/Object;)Ljava/lang/Object;
  :L101
    move-result-object v1
    goto :L103
  :L102
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L103
    const/4 v0, 3
  :L104
    new-array v2, v0, [Ljava/lang/Object;
    invoke-static { v11 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v0
    const/4 v3, 2
    aput-object v0, v2, v3
    const/16 v0, 22
    invoke-static { v0 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v0
    const/4 v3, 1
    aput-object v0, v2, v3
    const/4 v0, 0
    aput-object v15, v2, v0
    const/16 v0, 5277
    const/16 v3, 49
    const/16 v4, 21
    invoke-static { v0, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v3, 5264
    const/16 v4, 390
    const/16 v5, 36
    invoke-static { v3, v4, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v3
    const/4 v4, 3
    new-array v4, v4, [Ljava/lang/Class;
    const-class v5, [B
    const/4 v6, 0
    aput-object v5, v4, v6
    sget-object v5, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v6, 1
    aput-object v5, v4, v6
    sget-object v5, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v6, 2
    aput-object v5, v4, v6
    invoke-virtual { v0, v3, v4 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L105
    goto :L107
  :L106
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L107
    sget v0, Lo/\ufee4$\u1508;->\u0406:I
    and-int/lit8 v0, v0, 55
    int-to-byte v0, v0
    const/16 v2, 5277
    const/16 v3, 282
    invoke-static { v2, v3, v0 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v2, 5280
    const/16 v3, 632
    const/16 v4, 36
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 0
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L108
    move-result-object v2
    goto :L110
  :L109
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L110
    const/16 v0, 5277
    const/16 v3, 70
    const/16 v4, 19
  :L111
    invoke-static { v0, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v3, 5268
    const/16 v4, 431
    const/16 v5, 37
    invoke-static { v3, v4, v5 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v3
    const/4 v4, 0
    invoke-virtual { v0, v3, v4 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v3, 0
    invoke-virtual { v0, v2, v3 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L112
    goto :L114
  :L113
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L114
    const/16 v0, 5277
    const/16 v2, 49
    const/16 v3, 21
  :L115
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v2, 5284
    const/16 v3, 478
    const/16 v4, 36
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 0
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L116
    goto :L118
  :L117
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L118
    const/16 v0, 5277
    const/16 v1, 85
    const/16 v2, 29
  :L119
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v1, 5280
    const/16 v2, 105
    const/16 v3, 26
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    move-object/from16 v1, v17
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L120
    move-result-object v0
    goto :L122
  :L121
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L122
    const/16 v1, 5277
    const/16 v2, 85
    const/16 v3, 29
  :L123
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    invoke-static { v1 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v1
    const/16 v2, 5280
    const/16 v3, 105
    const/16 v4, 26
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 0
    invoke-virtual { v1, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v1, v10, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L124
    move-result-object v2
    goto :L126
  :L125
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L126
    const/4 v1, 3
  :L127
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v3, 0
    invoke-static { v3 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;
    move-result-object v3
    const/4 v4, 2
    aput-object v3, v1, v4
    const/4 v3, 1
    aput-object v2, v1, v3
    const/4 v2, 0
    aput-object v0, v1, v2
    const/16 v0, 5283
    const/16 v2, 513
    const/16 v3, 20
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v2, 5275
    const/16 v3, 150
    const/16 v4, 34
    invoke-static { v2, v3, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 3
    new-array v3, v3, [Ljava/lang/Class;
    const-class v4, Ljava/lang/String;
    const/4 v5, 0
    aput-object v4, v3, v5
    const-class v4, Ljava/lang/String;
    const/4 v5, 1
    aput-object v4, v3, v5
    sget-object v4, Ljava/lang/Integer;->TYPE:Ljava/lang/Class;
    const/4 v5, 2
    aput-object v4, v3, v5
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v2, 0
    invoke-virtual { v0, v2, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L128
    move-result-object v14
    const-class v0, Lo/\ufee4$\u1508;
    invoke-virtual { v0 }, Ljava/lang/Class;->getClassLoader()Ljava/lang/ClassLoader;
    move-result-object v0
    goto :L130
  :L129
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L130
    const/4 v1, 2
  :L131
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v2, 1
    aput-object v0, v1, v2
    const/4 v0, 0
    aput-object v16, v1, v0
    const/16 v0, 5283
    const/16 v2, 513
    const/16 v3, 20
    invoke-static { v0, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    sget v2, Lo/\ufee4$\u1508;->\u0406:I
    add-int/lit8 v2, v2, -4
    int-to-short v2, v2
    const/16 v3, 5275
    const/16 v4, 32
    invoke-static { v3, v2, v4 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v2
    const/4 v3, 2
    new-array v3, v3, [Ljava/lang/Class;
    const-class v4, Ljava/lang/String;
    const/4 v5, 0
    aput-object v4, v3, v5
    const/16 v4, 5277
    const/16 v5, 174
    const/16 v6, 20
    invoke-static { v4, v5, v6 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v4
    invoke-static { v4 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v4
    const/4 v5, 1
    aput-object v4, v3, v5
    invoke-virtual { v0, v2, v3 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    invoke-virtual { v0, v14, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Class;
  :L132
    move-object v12, v0
    if-eqz v12, :L136
    goto :L134
  :L133
    move-exception v0
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L134
    const/16 v0, 5283
    const/16 v1, 513
    const/16 v2, 20
  :L135
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v1, 5284
    const/16 v2, 478
    const/16 v3, 36
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v1, 0
    invoke-virtual { v0, v14, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  :L136
    goto :L139
  :L137
    move-exception v0
  :L138
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L139
    const/16 v0, 5277
    const/16 v1, 85
    const/16 v2, 29
  :L140
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v1, 5283
    const/16 v2, 395
    const/16 v3, 35
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    move-object/from16 v1, v17
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Boolean;
    invoke-virtual { v0 }, Ljava/lang/Boolean;->booleanValue()Z
  :L141
    nop
  :L142
    goto :L145
  :L143
    move-exception v0
  :L144
    invoke-virtual { v0 }, Ljava/lang/Throwable;->getCause()Ljava/lang/Throwable;
    move-result-object v0
    throw v0
  :L145
    const/16 v0, 5277
    const/16 v1, 85
    const/16 v2, 29
  :L146
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    invoke-static { v0 }, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v0
    const/16 v1, 5283
    const/16 v2, 395
    const/16 v3, 35
    invoke-static { v1, v2, v3 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v1
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/Class;->getMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v1, 0
    invoke-virtual { v0, v10, v1 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Ljava/lang/Boolean;
    invoke-virtual { v0 }, Ljava/lang/Boolean;->booleanValue()Z
  :L147
    nop
  :L148
    if-nez v12, :L149
    const/4 v0, 1
    new-array v0, v0, [Ljava/lang/Class;
    const-class v1, Ljava/lang/Object;
    const/4 v2, 0
    aput-object v1, v0, v2
    invoke-virtual { v13, v0 }, Ljava/lang/Class;->getDeclaredConstructor([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;
    move-result-object v0
    const/4 v1, 1
    new-array v1, v1, [Ljava/lang/Object;
    const/4 v2, 0
    aput-object v14, v1, v2
    invoke-virtual { v0, v1 }, Ljava/lang/reflect/Constructor;->newInstance([Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    sput-object v0, Lo/\ufee4$\u1508;->\u14bd:Ljava/lang/Object;
    return-void
  :L149
    move-object v13, v12
    const/16 v0, 5272
    const/16 v1, 74
    const/16 v2, 36
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v16
    const v11, 45911
    const/4 v0, 0
    const/16 v1, 30
    const/16 v2, 40
    invoke-static { v0, v1, v2 }, Lo/\ufee4$\u1508;->\u0456(SIB)Ljava/lang/String;
    move-result-object v0
    const/4 v1, 0
    invoke-virtual { v12, v0, v1 }, Ljava/lang/Class;->getDeclaredMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v0
    const/4 v1, 0
    const/4 v2, 0
    invoke-virtual { v0, v1, v2 }, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v0
    const v2, 45933
    const v3, 45950
    new-array v3, v3, [B
    fill-array-data v3, :L156
    goto/16 :L67
  :L150
    goto :L142
  :L151
    goto :L148
  :L152
  .array-data 2
    9t 0t
    118t 0t
    127t 0t
    -94t -1t
    -40t 13t
    12t 14t
    -64t 13t
    -34t 13t
    -16t 13t
    -40t 13t
    -27t 13t
    -44t 13t
    17t 14t
    -27t 13t
    -33t 13t
    -43t 13t
    7t 14t
    -49t 13t
    -32t 13t
    -25t 13t
    -10t 13t
    -60t 13t
    -62t 13t
    2t 14t
    -46t 13t
    -32t 13t
    -29t 13t
    -34t 13t
    -34t 13t
    -22t 13t
    -82t 13t
    -26t 13t
    -48t 13t
    -10t 13t
    21t 14t
    -82t 13t
    -26t 13t
    -48t 13t
    -10t 13t
    21t 14t
    -81t 13t
    -41t 13t
    -27t 13t
    34t 14t
    -99t 13t
    -10t 13t
    -47t 13t
    -21t 13t
    -20t 13t
    -48t 13t
    -11t 13t
    -37t 13t
    -37t 13t
    40t 14t
    -99t 13t
    -10t 13t
    -47t 13t
    -21t 13t
    -20t 13t
    -48t 13t
    -11t 13t
    -37t 13t
    -37t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    -52t 13t
    45t 14t
    -82t 13t
    -44t 13t
    -36t 13t
    -20t 13t
    -33t 13t
    -24t 13t
    36t 14t
    -98t 13t
    -26t 13t
    -18t 13t
    -27t 13t
    24t 14t
    -56t 13t
    -74t 13t
    9t 14t
    -46t 13t
    -46t 13t
    -12t 13t
    -41t 13t
    -21t 13t
    -44t 13t
    -14t 13t
    -42t 13t
    2t 14t
    -58t 13t
    -18t 13t
    -27t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    -52t 13t
    45t 14t
    -82t 13t
    -44t 13t
    -36t 13t
    -20t 13t
    -33t 13t
    -24t 13t
    36t 14t
    -50t 13t
    -67t 13t
    -36t 13t
    -21t 13t
    -26t 13t
    -42t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -98t 13t
    -15t 13t
    -27t 13t
    -47t 13t
    -26t 13t
    -20t 13t
    -40t 13t
    -34t 13t
    46t 14t
    -58t 13t
    -55t 13t
    -49t 13t
    -26t 13t
    -40t 13t
    -39t 13t
    -16t 13t
    -31t 13t
    32t 14t
    -98t 13t
    -35t 13t
    -23t 13t
    -30t 13t
    -14t 13t
    -37t 13t
    34t 14t
    -51t 13t
    -62t 13t
    -48t 13t
    21t 14t
    -64t 13t
    -32t 13t
    -22t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -91t 13t
    -18t 13t
    -42t 13t
    -22t 13t
    28t 14t
    -66t 13t
    -67t 13t
    -23t 13t
    -30t 13t
    -14t 13t
    -37t 13t
    -38t 13t
    -32t 13t
    -33t 13t
    -15t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -100t 13t
    -28t 13t
    -18t 13t
    -32t 13t
    33t 14t
    -105t 13t
    -12t 13t
    -36t 13t
    37t 14t
    -56t 13t
    -66t 13t
    -21t 13t
    -35t 13t
    -18t 13t
    -48t 13t
    -14t 13t
    -42t 13t
    -33t 13t
    -43t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -88t 13t
    -35t 13t
    36t 14t
    -99t 13t
    -22t 13t
    -32t 13t
    -17t 13t
    -34t 13t
    -38t 13t
    -27t 13t
    -42t 13t
    -6t 13t
    -56t 13t
    -20t 13t
    -40t 13t
    -14t 13t
    -35t 13t
    -18t 13t
    -18t 13t
    -30t 13t
    -18t 13t
    -22t 13t
    -13t 13t
    -60t 13t
    -31t 13t
    -25t 13t
    -22t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -98t 13t
    -15t 13t
    -27t 13t
    -47t 13t
    -26t 13t
    -20t 13t
    -40t 13t
    -34t 13t
    46t 14t
    -66t 13t
    -47t 13t
    -27t 13t
    -47t 13t
    -26t 13t
    -16t 13t
    -10t 13t
    -44t 13t
    -42t 13t
    -19t 13t
    -40t 13t
    -27t 13t
    -30t 13t
    -36t 13t
    -22t 13t
    -44t 13t
    -14t 13t
    -24t 13t
    -20t 13t
    -40t 13t
    -14t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -91t 13t
    -18t 13t
    -42t 13t
    -22t 13t
    28t 14t
    -50t 13t
    -66t 13t
    -22t 13t
    -46t 13t
    -12t 13t
    -31t 13t
    -46t 13t
    -14t 13t
    -42t 13t
    -47t 13t
    -26t 13t
    -29t 13t
    -16t 13t
    -38t 13t
    -35t 13t
    3t 14t
    -50t 13t
    -33t 13t
    -21t 13t
    -5t 13t
    -57t 13t
    -32t 13t
    -29t 13t
    -26t 13t
    -39t 13t
    -30t 13t
    -18t 13t
    -38t 13t
    13t 14t
    -62t 13t
    -48t 13t
    21t 14t
    -64t 13t
    -32t 13t
    -22t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -98t 13t
    -15t 13t
    -27t 13t
    -47t 13t
    -26t 13t
    -20t 13t
    -40t 13t
    -34t 13t
    46t 14t
    -98t 13t
    -26t 13t
    -18t 13t
    -27t 13t
    24t 14t
    -48t 13t
    -72t 13t
    -24t 13t
    -37t 13t
    -32t 13t
    -20t 13t
    -40t 13t
    -17t 13t
    -34t 13t
    0t 14t
    -46t 13t
    -46t 13t
    -12t 13t
    -41t 13t
    -21t 13t
    -44t 13t
    -14t 13t
    -42t 13t
    2t 14t
    -58t 13t
    -18t 13t
    -27t 13t
    -42t 13t
    -19t 13t
    -43t 13t
    -26t 13t
    -23t 13t
    -24t 13t
    25t 14t
    -100t 13t
    -28t 13t
    -18t 13t
    -32t 13t
    33t 14t
    -63t 13t
    -63t 13t
    -26t 13t
    -30t 13t
    -18t 13t
    -42t 13t
    -31t 13t
    -34t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -88t 13t
    -35t 13t
    36t 14t
    -53t 13t
    -64t 13t
    -32t 13t
    -22t 13t
    -7t 13t
    -67t 13t
    -28t 13t
    -25t 13t
    -34t 13t
    -28t 13t
    4t 14t
    -62t 13t
    -27t 13t
    -16t 13t
    -25t 13t
    -41t 13t
    -30t 13t
    -30t 13t
    -32t 13t
    -34t 13t
    -20t 13t
    5t 14t
    -70t 13t
    -18t 13t
    -47t 13t
    -29t 13t
    -27t 13t
    -44t 13t
    18t 14t
    -80t 13t
    -25t 13t
    -14t 13t
    -42t 13t
    -25t 13t
    -16t 13t
    -40t 13t
    -4t 13t
    -62t 13t
    -24t 13t
    -32t 13t
    -12t 13t
    -35t 13t
    -27t 13t
    4t 14t
    -66t 13t
    -38t 13t
    -16t 13t
    -27t 13t
    -46t 13t
    -24t 13t
    -32t 13t
    -36t 13t
    -15t 13t
    -44t 13t
    14t 14t
    -66t 13t
    -31t 13t
    -34t 13t
    -28t 13t
    -34t 13t
    -24t 13t
    -40t 13t
    -32t 13t
    -15t 13t
    -32t 13t
    4t 14t
    -70t 13t
    -18t 13t
    -47t 13t
    -29t 13t
    -42t 13t
    -19t 13t
    -43t 13t
    -26t 13t
    -23t 13t
    -24t 13t
    25t 14t
    -94t 13t
    -33t 13t
    40t 14t
    -52t 13t
    -70t 13t
    -37t 13t
    -16t 13t
    -38t 13t
    -26t 13t
    -28t 13t
    -28t 13t
    -21t 13t
    -38t 13t
    -35t 13t
    -27t 13t
    -44t 13t
    14t 14t
    -66t 13t
    -34t 13t
    -30t 13t
    -10t 13t
    -42t 13t
    -18t 13t
    -31t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -91t 13t
    -18t 13t
    -42t 13t
    -22t 13t
    28t 14t
    -50t 13t
    -70t 13t
    -18t 13t
    -47t 13t
    -29t 13t
    10t 14t
    -64t 13t
    -15t 13t
    -32t 13t
    -30t 13t
    -42t 13t
    35t 14t
    46t 15t
    -93t 12t
    -47t -16t
    -32t 13t
    -15t 13t
    -32t 13t
    3t 14t
    -62t 13t
    -48t 13t
    -39t 13t
    1t 14t
    -54t 13t
    -24t 13t
    -23t 13t
    -41t 13t
    -18t 13t
    -30t 13t
    -1t 13t
    -56t 13t
    -30t 13t
    -38t 13t
    -35t 13t
    -18t 13t
    -26t 13t
    -32t 13t
    -25t 13t
    -42t 13t
    2t 14t
    -62t 13t
    -10t 13t
    -46t 13t
    -31t 13t
    -15t 13t
    -44t 13t
    4t 14t
    -47t 13t
    -29t 13t
    -28t 13t
    -27t 13t
    -44t 13t
    7t 14t
    -63t 13t
    -26t 13t
    -30t 13t
    -18t 13t
    -42t 13t
    -31t 13t
    -34t 13t
    -27t 13t
    -44t 13t
    22t 14t
    -62t 13t
    -46t 13t
    -25t 13t
    -26t 13t
    -38t 13t
    -28t 13t
    -14t 13t
    -8t 13t
    -46t 13t
    -48t 13t
    -17t 13t
    -34t 13t
    -21t 13t
    -35t 13t
    -18t 13t
    -48t 13t
    -14t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -88t 13t
    -35t 13t
    36t 14t
    -53t 13t
    -64t 13t
    -32t 13t
    -22t 13t
    35t 14t
    46t 15t
    -93t 12t
    25t -8t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -88t 13t
    -35t 13t
    36t 14t
    -53t 13t
    -64t 13t
    -32t 13t
    -22t 13t
    4t 14t
    -62t 13t
    -43t 13t
    -13t 13t
    -44t 13t
    -20t 13t
    -36t 13t
    -33t 13t
    -24t 13t
    -32t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    22t 14t
    -88t 13t
    -35t 13t
    36t 14t
    -62t 13t
    -67t 13t
    -28t 13t
    -25t 13t
    -34t 13t
    -28t 13t
    4t 14t
    -62t 13t
    -27t 13t
    -16t 13t
    -25t 13t
    -41t 13t
    -20t 13t
    -50t 13t
    -8t 13t
    -52t 13t
    45t 14t
    -82t 13t
    -44t 13t
    -36t 13t
    -20t 13t
    -33t 13t
    -24t 13t
    36t 14t
    -98t 13t
    -26t 13t
    -18t 13t
    -27t 13t
    24t 14t
    -66t 13t
    -47t 13t
    -27t 13t
    -44t 13t
    -16t 13t
    -44t 13t
    12t 14t
    -55t 13t
    -49t 13t
    9t 14t
    -58t 13t
    -18t 13t
    -27t 13t
    -20t 13t
    -48t 13t
    -25t 13t
    14t 14t
    -66t 13t
    -35t 13t
  .end array-data
  :L153
  .array-data 1
    79t
    84t
    114t
    -55t
    7t
    58t
    -20t
    47t
    98t
    11t
    55t
    -34t
    12t
    -108t
    -117t
    -53t
  .end array-data
  :L154
  .array-data 1
    49t
    74t
    -19t
    40t
    14t
    0t
    45t
    81t
    109t
    -80t
    85t
    -128t
    -115t
    -70t
    127t
    100t
  .end array-data
  :L155
  .array-data 1
    106t
    97t
    118t
    97t
    47t
    108t
    97t
    110t
    103t
    47t
    73t
    110t
    116t
    101t
    103t
    101t
    114t
    -26t
    -63t
    -112t
    26t
    105t
    114t
    -88t
    -90t
    -18t
    90t
    126t
    60t
    -112t
    -97t
    97t
    -64t
    90t
    78t
    -121t
    -116t
    81t
    17t
    112t
    0t
    4t
    -105t
    8t
    68t
    98t
    56t
    12t
    44t
    -83t
    -36t
    -106t
    -77t
    70t
    38t
    -107t
    -91t
    12t
    18t
    -121t
    -87t
    19t
    120t
    85t
    12t
    57t
    -32t
    -25t
    -53t
    -24t
    -69t
    92t
    4t
    88t
    52t
    16t
    -68t
    -65t
    -93t
    96t
    39t
    -99t
    28t
    26t
    32t
    -81t
    -38t
    -108t
    -48t
    -70t
    22t
    39t
    -125t
    -13t
    -18t
    -122t
    -19t
    -64t
    -38t
    127t
    -74t
    31t
    50t
    -14t
    -84t
    -116t
    -6t
    -36t
    -109t
    27t
    90t
    -33t
    40t
    -38t
    14t
    -18t
    104t
    -55t
    -29t
    127t
    -122t
    86t
    85t
    93t
    -124t
    96t
    42t
    -6t
    -30t
    -9t
    109t
    117t
    78t
    54t
    64t
    -100t
    80t
    -68t
    -23t
    52t
    -70t
    32t
    -51t
    39t
    -57t
    -121t
    -26t
    0t
    -65t
    -37t
    104t
    4t
    43t
    44t
    22t
    95t
    -75t
    80t
    97t
    -7t
    -14t
    -67t
    -25t
    -112t
    13t
    43t
    68t
    57t
    37t
    119t
    26t
    68t
    -46t
    -70t
    -75t
    -12t
    125t
    -88t
    36t
    -90t
    65t
    117t
    -124t
    -102t
    43t
    41t
    46t
    -23t
    -95t
    -77t
    92t
    -11t
    -69t
    -9t
    -46t
    6t
    -24t
    67t
    -48t
    -17t
    -41t
    -4t
    -123t
    -24t
    -117t
    75t
    37t
    75t
    36t
    34t
    -88t
    99t
    -102t
    93t
    -55t
    -8t
    -50t
    22t
    -25t
    -127t
    74t
    -103t
    -128t
    71t
    48t
    11t
    -32t
    -18t
    81t
    -31t
    61t
    -102t
    -89t
    -98t
    66t
    -35t
    127t
    -67t
    13t
    -92t
    81t
    11t
    21t
    -113t
    103t
    81t
    -39t
    13t
    -126t
    107t
    29t
    114t
    98t
    100t
    63t
    11t
    29t
    -48t
    -104t
    44t
    -52t
    88t
    112t
    63t
    -65t
    97t
    -83t
    52t
    97t
    -57t
    -126t
    72t
    -69t
    -70t
    33t
    67t
    100t
    100t
    19t
    -61t
    29t
    82t
    -86t
    80t
    106t
    -45t
    -67t
    -5t
    75t
    20t
    51t
    -113t
    -89t
    56t
    -69t
    -98t
    6t
    23t
    77t
    97t
    -17t
    -58t
    9t
    -57t
    -46t
    85t
    -26t
    31t
    84t
    61t
    -87t
    -91t
    -85t
    12t
    13t
    77t
    -16t
    -40t
    115t
    100t
    -91t
    56t
    -105t
    -77t
    -23t
    98t
    125t
    62t
    110t
    -93t
    -6t
    35t
    -118t
    11t
    101t
    -55t
    -45t
    11t
    -95t
    -102t
    99t
    -99t
    63t
    119t
    119t
    -30t
    37t
    -92t
    -92t
    -25t
    7t
    46t
    104t
    16t
    -32t
    116t
    76t
    -108t
    108t
    -83t
    -52t
    15t
    -10t
    88t
    68t
    111t
    110t
    39t
    59t
    -20t
    -98t
    -72t
    -96t
    -121t
    -113t
    123t
    24t
    108t
    86t
    0t
    -76t
    59t
    89t
    -74t
    -43t
    83t
    126t
    51t
    112t
    68t
    62t
    42t
    -12t
    -68t
    -124t
    118t
    103t
    78t
    -6t
    -54t
    -83t
    123t
    -89t
    113t
    9t
    -100t
    -119t
    -51t
    7t
    -107t
    -13t
    -62t
    -5t
    79t
    18t
    -79t
    -108t
    -124t
    -60t
    -65t
    -117t
    -123t
    -4t
    -49t
    -69t
    -61t
    124t
    69t
    -4t
    55t
    -115t
    97t
    -3t
    -109t
    36t
    65t
    -98t
    62t
    13t
    -85t
    116t
    -25t
    -3t
    57t
    111t
    16t
    9t
    -33t
    49t
    113t
    -67t
    36t
    -35t
    11t
    -42t
    37t
    -31t
    24t
    -39t
    33t
    -125t
    8t
    -81t
    114t
    20t
    116t
    107t
    -98t
    -97t
    -51t
    -81t
    27t
    14t
    123t
    -11t
    74t
    -66t
    -48t
    62t
    -125t
    -8t
    -57t
    -81t
    29t
    -41t
    57t
    92t
    40t
    122t
    92t
    66t
    -3t
    -108t
    -72t
    7t
    113t
    28t
    79t
    -32t
    -70t
    18t
    81t
    25t
    -59t
    103t
    -115t
    -75t
    -118t
    -128t
    -83t
    -60t
    89t
    48t
    75t
    -72t
    -68t
    5t
    67t
    -32t
    -1t
    -9t
    19t
    46t
    -66t
    104t
    50t
    87t
    -73t
    -56t
    -4t
    91t
    -21t
    68t
    -63t
    -89t
    -14t
    -33t
    114t
    -31t
    16t
    -86t
    98t
    -53t
    -23t
    -120t
    83t
    -49t
    -78t
    7t
    -90t
    107t
    89t
    47t
    -71t
    54t
    74t
    7t
    66t
    9t
    -39t
    5t
    -45t
    -100t
    62t
    21t
    32t
    -125t
    -17t
    -39t
    102t
    -118t
    -15t
    13t
    -85t
    24t
    116t
    93t
    87t
    -98t
    127t
    -103t
    103t
    31t
    33t
    -1t
    28t
    43t
    -73t
    56t
    15t
    -44t
    54t
    -41t
    -68t
    -16t
    102t
    -96t
    -78t
    6t
    71t
    -18t
    -107t
    90t
    37t
    58t
    -80t
    80t
    84t
    25t
    25t
    -42t
    55t
    54t
    11t
    -15t
    9t
    43t
    -43t
    9t
    125t
    95t
    24t
    -126t
    -92t
    -117t
    13t
    28t
    30t
    -66t
    -19t
    100t
    4t
    72t
    -61t
    70t
    -43t
    87t
    96t
    36t
    29t
    -5t
    40t
    -35t
    113t
    20t
    -19t
    46t
    45t
    6t
    -73t
    -106t
    -87t
    75t
    49t
    -45t
    35t
    108t
    82t
    -115t
    -62t
    105t
    -2t
    -60t
    7t
    -106t
    53t
    -40t
    -46t
    -40t
    -102t
    -57t
    25t
    -64t
    -92t
    62t
    -7t
    -127t
    -37t
    -62t
    -29t
    92t
    5t
    42t
    -115t
    -3t
    -51t
    50t
    -69t
    126t
    14t
    -93t
    -104t
    73t
    59t
    27t
    86t
    71t
    75t
    -9t
    27t
    70t
    -44t
    43t
    94t
    -86t
    54t
    110t
    69t
    18t
    23t
    0t
    -15t
    105t
    -82t
    16t
    66t
    -76t
    -109t
    28t
    42t
    42t
    -58t
    -42t
    0t
    -49t
    75t
    -98t
    36t
    -8t
    23t
    -58t
    -21t
    47t
    74t
    60t
    114t
    -36t
    -30t
    63t
    -29t
    71t
    60t
    -23t
    -35t
    -128t
    37t
    125t
    67t
    31t
    10t
    -118t
    102t
    8t
    101t
    -53t
    -58t
    -92t
    54t
    -7t
    105t
    -31t
    77t
    -126t
    -4t
    19t
    31t
    -125t
    94t
    16t
    -116t
    73t
    97t
    78t
    -4t
    -54t
    -35t
    -126t
    35t
    65t
    5t
    97t
    37t
    -45t
    16t
    80t
    3t
    -63t
    114t
    10t
    44t
    3t
    126t
    90t
    -104t
    88t
    -114t
    5t
    -60t
    127t
    4t
    -11t
    -34t
    107t
    47t
    -2t
    49t
    65t
    -119t
    127t
    5t
    86t
    73t
    -22t
    -12t
    -63t
    18t
    47t
    -42t
    1t
    -87t
    -46t
    -26t
    -113t
    121t
    119t
    -32t
    118t
    -17t
    67t
    60t
    -23t
    -97t
    65t
    37t
    -112t
    85t
    0t
    -35t
    3t
    112t
    10t
    -70t
    38t
    52t
    -111t
    -53t
    -106t
    88t
    -71t
    -124t
    -120t
    -92t
    -123t
    -76t
    -33t
    61t
    -96t
    39t
    57t
    -108t
    10t
    9t
    -58t
    30t
    -107t
    -114t
    -33t
    68t
    51t
    -100t
    95t
    -67t
    -111t
    96t
    111t
    18t
    44t
    -3t
    48t
    94t
    -102t
    -127t
    13t
    -32t
    2t
    -125t
    -62t
    80t
    3t
    -10t
    29t
    -79t
    8t
    -68t
    -105t
    100t
    -52t
    -99t
    -14t
    -15t
    -28t
    -36t
    -20t
    95t
    -114t
    -66t
    15t
    -15t
    44t
    97t
    -107t
    -10t
    77t
    -111t
    34t
    85t
    101t
    82t
    126t
    -95t
    -126t
    -41t
    62t
    -124t
    27t
    -83t
    76t
    93t
    3t
    76t
    87t
    35t
    -33t
    -73t
    109t
    109t
    8t
    -76t
    79t
    57t
    57t
    -92t
    4t
    117t
    -97t
    98t
    -79t
    62t
    39t
    119t
    101t
    97t
    -12t
    32t
    61t
    71t
    14t
    -9t
    35t
    76t
    39t
    -23t
    93t
    50t
    24t
    -42t
    2t
    -90t
    -20t
    -75t
    -102t
    -75t
    -45t
    -16t
    110t
    87t
    25t
    33t
    -24t
    9t
    -15t
    12t
    -33t
    99t
    14t
    -121t
    -69t
    19t
    69t
    -13t
    28t
    50t
    -30t
    -91t
    -92t
    127t
    -114t
    -29t
    -28t
    -111t
    -99t
    -32t
    -73t
    -90t
    31t
    -108t
    -18t
    127t
    89t
    -36t
    9t
    -107t
    70t
    94t
    -18t
    -100t
    96t
    -97t
    -5t
    -108t
    -34t
    -56t
    -20t
    -9t
    -92t
    -46t
    -109t
    13t
    -40t
    -68t
    -11t
    103t
    13t
    31t
    -46t
    4t
    -38t
    -66t
    57t
    -42t
    49t
    -123t
    59t
    -39t
    -56t
    -91t
    87t
    -37t
    -39t
    75t
    34t
    -73t
    109t
    -33t
    -48t
    -71t
    74t
    65t
    39t
    103t
    86t
    -1t
    -24t
    -99t
    114t
    12t
    106t
    39t
    -58t
    89t
    -13t
    77t
    -21t
    33t
    -118t
    66t
    -88t
    95t
    -119t
    111t
    81t
    -58t
    71t
    -76t
    -1t
    51t
    23t
    -82t
    31t
    84t
    -61t
    -10t
    127t
    107t
    16t
    -38t
    -59t
    27t
    -70t
    -77t
    -23t
    -52t
    -59t
    16t
    26t
    18t
    5t
    66t
    -37t
    112t
    -73t
    -120t
    -55t
    -3t
    36t
    24t
    -30t
    92t
    -94t
    -69t
    30t
    -57t
    -5t
    92t
    42t
    -108t
    33t
    -87t
    45t
    98t
    -27t
    19t
    20t
    71t
    -86t
    25t
    -66t
    -108t
    25t
    55t
    -56t
    90t
    -99t
    104t
    90t
    -64t
    -121t
    57t
    -75t
    89t
    -47t
    36t
    -62t
    122t
    -60t
    -118t
    -123t
    86t
    74t
    -90t
    85t
    1t
    112t
    -111t
    69t
    71t
    -37t
    -52t
    22t
    -105t
    5t
    -123t
    24t
    121t
    72t
    -66t
    3t
    76t
    52t
    -50t
    -16t
    102t
    49t
    -128t
    33t
    120t
    -60t
    -26t
    -40t
    93t
    -118t
    -72t
    15t
    111t
    104t
    -7t
    -115t
    -32t
    48t
    -82t
    -39t
    -66t
    -121t
    72t
    -17t
    75t
    -68t
    73t
    82t
    30t
    -52t
    -123t
    7t
    112t
    28t
    64t
    -91t
    -111t
    -59t
    -50t
    -33t
    78t
    82t
    52t
    78t
    98t
    -77t
    93t
    -103t
    -56t
    39t
    -94t
    -13t
    97t
    104t
    90t
    20t
    46t
    -11t
    -30t
    10t
    124t
    -60t
    -71t
    68t
    -77t
    -34t
    69t
    -93t
    103t
    41t
    28t
    98t
    78t
    -63t
    -24t
    -103t
    84t
    99t
    -116t
    -123t
    79t
    109t
    -125t
    104t
    8t
    39t
    17t
    -101t
    -90t
    2t
    58t
    92t
    -31t
    -68t
    50t
    -22t
    12t
    93t
    57t
    24t
    -123t
    95t
    -65t
    -128t
    -54t
    57t
    -43t
    -108t
    115t
    62t
    -110t
    -72t
    -12t
    -71t
    -29t
    -96t
    -26t
    -42t
    44t
    -78t
    -122t
    51t
    -74t
    -57t
    -102t
    106t
    60t
    11t
    31t
    71t
    60t
    44t
    -103t
    -57t
    -48t
    117t
    -34t
    78t
    115t
    77t
    -20t
    -91t
    90t
    -72t
    11t
    17t
    -36t
    -117t
    57t
    -96t
    -11t
    -128t
    -15t
    -110t
    -116t
    -9t
    -18t
    -72t
    87t
    67t
    29t
    15t
    -12t
    -31t
    -79t
    39t
    107t
    38t
    11t
    -122t
    -121t
    28t
    -10t
    86t
    -8t
    -51t
    42t
    -116t
    -40t
    -53t
    -23t
    85t
    124t
    -95t
    111t
    93t
    -99t
    -48t
    74t
    -123t
    97t
    93t
    77t
    74t
    -124t
    -58t
    43t
    -35t
    -9t
    34t
    64t
    -35t
    -12t
    14t
    59t
    3t
    97t
    -48t
    -45t
    -37t
    58t
    -61t
    -46t
    49t
    -97t
    49t
    -19t
    50t
    -114t
    101t
    -24t
    -61t
    -76t
    -40t
    60t
    -4t
    -107t
    101t
    -127t
    -32t
    -53t
    109t
    -76t
    4t
    98t
    115t
    16t
    -56t
    -67t
    45t
    113t
    -118t
    -86t
    45t
    108t
    2t
    -121t
    116t
    87t
    -14t
    99t
    -67t
    -73t
    1t
    -45t
    84t
    -88t
    -84t
    116t
    51t
    -76t
    -122t
    -68t
    -95t
    32t
    -25t
    9t
    82t
    -92t
    -91t
    -19t
    72t
    56t
    64t
    39t
    80t
    46t
    58t
    98t
    -43t
    102t
    -106t
    113t
    116t
    -46t
    -18t
    -11t
    24t
    85t
    -36t
    -39t
    -120t
    73t
    65t
    -116t
    74t
    -43t
    -53t
    90t
    -63t
    94t
    31t
    -6t
    -17t
    -49t
    14t
    -74t
    125t
    -15t
    13t
    76t
    -108t
    -103t
    2t
    82t
    -80t
    -101t
    32t
    -118t
    52t
    123t
    -84t
    19t
    -92t
    -24t
    35t
    79t
    64t
    -97t
    106t
    114t
    19t
    50t
    -27t
    96t
    -46t
    -127t
    -90t
    -21t
    7t
    -26t
    -78t
    91t
    88t
    -83t
    45t
    30t
    5t
    11t
    -109t
    -117t
    -55t
    -69t
    125t
    102t
    91t
    -108t
    69t
    62t
    -31t
    -113t
    -85t
    50t
    -39t
    -1t
    48t
    -60t
    66t
    -124t
    -89t
    1t
    -26t
    -60t
    103t
    26t
    14t
    27t
    -124t
    -80t
    22t
    110t
    -90t
    54t
    112t
    116t
    -65t
    -93t
    99t
    61t
    -83t
    52t
    -122t
    -36t
    -8t
    -116t
    -25t
    -47t
    80t
    -94t
    102t
    119t
    28t
    11t
    39t
    -21t
    47t
    -57t
    54t
    -89t
    -16t
    -85t
    -59t
    88t
    55t
    -61t
    71t
    -15t
    88t
    -58t
    44t
    -102t
    63t
    -103t
    -44t
    -93t
    63t
    23t
    120t
    38t
    44t
    -63t
    0t
    -73t
    -27t
    63t
    -40t
    91t
    -12t
    20t
    -39t
    97t
    -21t
    94t
    -25t
    -6t
    106t
    -97t
    49t
    -4t
    -108t
    103t
    -60t
    62t
    -70t
    -61t
    14t
    -77t
    96t
    -38t
    21t
    59t
    36t
    -50t
    90t
    -25t
    -92t
    114t
    89t
    103t
    -96t
    -5t
    100t
    41t
    -3t
    36t
    -11t
    103t
    -67t
    37t
    -46t
    127t
    -70t
    113t
    -15t
    -67t
    76t
    -78t
    37t
    -90t
    -23t
    2t
    54t
    -89t
    105t
    -21t
    -79t
    -5t
    29t
    -30t
    -49t
    116t
    3t
    58t
    66t
    65t
    -54t
    79t
    84t
    6t
    55t
    -6t
    -22t
    -40t
    -101t
    32t
    -124t
    78t
    55t
    100t
    101t
    -16t
    -102t
    -37t
    2t
    108t
    -123t
    -46t
    77t
    112t
    25t
    -31t
    16t
    -21t
    -90t
    125t
    -74t
    29t
    -113t
    -76t
    118t
    27t
    -80t
    -86t
    16t
    -7t
    64t
    6t
    12t
    -101t
    -128t
    110t
    -50t
    9t
    67t
    52t
    -96t
    -38t
    -21t
    67t
    94t
    -95t
    -69t
    -54t
    -109t
    -9t
    62t
    -32t
    -54t
    -67t
    -78t
    29t
    121t
    90t
    -114t
    -54t
    75t
    38t
    91t
    -1t
    83t
    -114t
    -124t
    107t
    64t
    -62t
    -85t
    -127t
    -119t
    -104t
    63t
    5t
    -70t
    18t
    66t
    95t
    -61t
    7t
    38t
    -116t
    55t
    -95t
    46t
    -18t
    55t
    100t
    42t
    89t
    -112t
    -126t
    6t
    -17t
    15t
    120t
    -121t
    99t
    -109t
    78t
    -102t
    8t
    -77t
    28t
    92t
    112t
    90t
    -18t
    -52t
    65t
    28t
    95t
    29t
    -121t
    -90t
    1t
    -64t
    38t
    8t
    49t
    0t
    97t
    -115t
    -24t
    94t
    94t
    -58t
    -35t
    110t
    61t
    -98t
    -107t
    -89t
    44t
    -32t
    -123t
    42t
    108t
    77t
    108t
    2t
    -54t
    98t
    -53t
    40t
    -121t
    62t
    33t
    42t
    57t
    122t
    -119t
    -39t
    105t
    -45t
    45t
    -106t
    -74t
    47t
    -36t
    -86t
    -64t
    86t
    -74t
    -23t
    49t
    122t
    55t
    -111t
    -92t
    34t
    -112t
    -33t
    125t
    -95t
    -34t
    -104t
    1t
    74t
    -43t
    -10t
    69t
    81t
    17t
    -125t
    -118t
    -44t
    -113t
    84t
    -17t
    26t
    -122t
    45t
    -30t
    30t
    -17t
    19t
    63t
    94t
    -26t
    -55t
    101t
    24t
    -44t
    -74t
    54t
    -46t
    107t
    90t
    32t
    -84t
    -81t
    15t
    -35t
    82t
    -22t
    103t
    -77t
    -65t
    65t
    47t
    1t
    -122t
    10t
    -20t
    -23t
    13t
    33t
    -1t
    84t
    14t
    82t
    68t
    112t
    -76t
    -25t
    61t
    -69t
    -2t
    112t
    -127t
    -115t
    121t
    110t
    -70t
    35t
    -9t
    15t
    19t
    96t
    76t
    106t
    63t
    90t
    118t
    -43t
    24t
    -64t
    2t
    -75t
    125t
    -100t
    -12t
    76t
    -69t
    -114t
    -111t
    29t
    0t
    24t
    25t
    26t
    71t
    123t
    10t
    44t
    -1t
    -64t
    -60t
    -49t
    33t
    -48t
    9t
    107t
    37t
    119t
    55t
    -85t
    43t
    -76t
    -95t
    4t
    83t
    49t
    35t
    20t
    21t
    -37t
    66t
    92t
    85t
    -93t
    -3t
    -44t
    73t
    -92t
    73t
    -69t
    111t
    -118t
    -63t
    118t
    49t
    28t
    -127t
    -20t
    38t
    42t
    78t
    -95t
    108t
    77t
    123t
    117t
    80t
    -87t
    -42t
    -21t
    -72t
    69t
    -56t
    -124t
    47t
    -49t
    -2t
    -95t
    -70t
    112t
    -78t
    -5t
    98t
    47t
    68t
    -27t
    -12t
    102t
    85t
    125t
    100t
    -36t
    105t
    85t
    -95t
    -96t
    36t
    9t
    120t
    -62t
    -51t
    -45t
    48t
    26t
    77t
    -56t
    -86t
    110t
    -52t
    101t
    -41t
    -115t
    36t
    -6t
    -32t
    -15t
    121t
    -3t
    21t
    79t
    48t
    -32t
    -86t
    -99t
    58t
    119t
    93t
    39t
    62t
    -57t
    76t
    -44t
    117t
    86t
    -14t
    -34t
    89t
    105t
    -33t
    -119t
    -88t
    -118t
    22t
    86t
    10t
    -62t
    -36t
    -119t
    -104t
    16t
    117t
    -80t
    79t
    -67t
    -37t
    -14t
    -75t
    12t
    58t
    10t
    11t
    97t
    19t
    -97t
    -21t
    -6t
    33t
    -109t
    108t
    36t
    49t
    -99t
    -66t
    -124t
    107t
    -24t
    76t
    -5t
    12t
    -65t
    18t
    98t
    92t
    73t
    -27t
    -105t
    117t
    -67t
    -126t
    -124t
    94t
    -82t
    -41t
    39t
    -85t
    119t
    -118t
    -98t
    -91t
    74t
    -125t
    -79t
    -85t
    -71t
    -49t
    -121t
    -81t
    -103t
    -128t
    -19t
    -38t
    124t
    -48t
    13t
    -97t
    -82t
    -110t
    -34t
    -65t
    53t
    103t
    16t
    101t
    -16t
    29t
    -104t
    -116t
    -9t
    -74t
    -22t
    103t
    -60t
    -54t
  .end array-data
  :L156
  .array-data 1
    106t
    97t
    118t
    97t
    47t
    108t
    97t
    110t
    103t
    47t
    73t
    110t
    116t
    101t
    103t
    101t
    114t
    113t
    -35t
    114t
    99t
    -38t
    -44t
    16t
    22t
    98t
    -74t
    -51t
    -83t
    57t
    -1t
    -108t
    22t
    98t
    -43t
    58t
    -102t
    25t
    -4t
    -58t
    -14t
    19t
    -78t
    -72t
    -34t
    -11t
    124t
    -126t
    33t
    68t
    48t
    62t
    -120t
    -28t
    -83t
    -86t
    77t
    -40t
    -87t
    -106t
    -77t
    119t
    99t
    -65t
    97t
    18t
    60t
    92t
    -76t
    126t
    -125t
    26t
    -47t
    -10t
    -103t
    -102t
    -41t
    19t
    99t
    15t
    -51t
    66t
    39t
    7t
    93t
    31t
    112t
    98t
    -127t
    50t
    -95t
    -11t
    46t
    -6t
    -72t
    -73t
    58t
    71t
    68t
    8t
    -30t
    -17t
    -45t
    -28t
    -9t
    -81t
    11t
    69t
    1t
    -95t
    7t
    -99t
    -53t
    113t
    10t
    124t
    -6t
    117t
    124t
    -91t
    -89t
    24t
    62t
    -52t
    104t
    -24t
    18t
    -113t
    79t
    60t
    -20t
    20t
    114t
    -46t
    -125t
    111t
    93t
    107t
    -27t
    44t
    15t
    -101t
    -32t
    52t
    24t
    52t
    61t
    55t
    -63t
    -37t
    -45t
    -39t
    93t
    -44t
    10t
    115t
    -34t
    -32t
    -12t
    74t
    89t
    54t
    -102t
    124t
    -52t
    27t
    -81t
    -112t
    12t
    92t
    20t
    101t
    45t
    43t
    -102t
    -47t
    -83t
    -100t
    5t
    85t
    -78t
    -30t
    -7t
    -20t
    -80t
    118t
    95t
    -71t
    108t
    27t
    118t
    35t
    96t
    42t
    -48t
    10t
    84t
    -50t
    0t
    5t
    39t
    -95t
    -111t
    -63t
    47t
    14t
    31t
    36t
    7t
    -38t
    41t
    -4t
    -8t
    -71t
    78t
    -6t
    -94t
    -68t
    9t
    47t
    -104t
    90t
    -56t
    -10t
    -60t
    41t
    -7t
    -106t
    -59t
    -88t
    2t
    20t
    69t
    105t
    2t
    112t
    111t
    -78t
    -67t
    -13t
    18t
    33t
    -30t
    101t
    125t
    72t
    103t
    -42t
    -13t
    -20t
    -52t
    62t
    119t
    -12t
    -9t
    -6t
    106t
    -78t
    -104t
    25t
    64t
    -6t
    -117t
    -40t
    -114t
    -122t
    -8t
    122t
    -13t
    -102t
    -123t
    55t
    -66t
    32t
    -56t
    118t
    -105t
    -107t
    -32t
    103t
    96t
    -52t
    13t
    19t
    -103t
    85t
    78t
    -30t
    -79t
    -18t
    -107t
    -68t
    61t
    -124t
    9t
    20t
    28t
    53t
    19t
    -74t
    56t
    -78t
    119t
    -111t
    -61t
    -83t
    -98t
    -21t
    -115t
    -68t
    -48t
    -86t
    27t
    -52t
    -53t
    115t
    74t
    39t
    90t
    -126t
    112t
    -88t
    29t
    -5t
    39t
    1t
    -73t
    74t
    38t
    -45t
    96t
    117t
    81t
    -28t
    107t
    52t
    -47t
    87t
    105t
    -127t
    3t
    -76t
    39t
    4t
    124t
    -79t
    57t
    117t
    16t
    6t
    -83t
    -61t
    25t
    32t
    -53t
    101t
    -102t
    89t
    -27t
    -6t
    -99t
    38t
    -26t
    83t
    20t
    -42t
    88t
    -86t
    91t
    -22t
    65t
    -22t
    120t
    41t
    -104t
    -55t
    -91t
    95t
    51t
    97t
    -115t
    40t
    79t
    10t
    10t
    82t
    120t
    -119t
    25t
    125t
    94t
    -18t
    88t
    -7t
    -30t
    22t
    -35t
    71t
    101t
    22t
    -3t
    -91t
    -123t
    -7t
    106t
    8t
    -54t
    -101t
    91t
    70t
    10t
    38t
    46t
    -45t
    54t
    -100t
    6t
    48t
    -110t
    65t
    85t
    -66t
    85t
    7t
    -38t
    92t
    -120t
    22t
    49t
    -47t
    -71t
    -102t
    -100t
    -118t
    51t
    2t
    36t
    -103t
    -42t
    27t
    -113t
    20t
    27t
    24t
    -6t
    -23t
    -36t
    -29t
    45t
    87t
    101t
    -54t
    109t
    12t
    37t
    106t
    67t
    114t
    22t
    -19t
    59t
    -64t
    6t
    30t
    91t
    -104t
    -36t
    -98t
    38t
    83t
    72t
    16t
    -50t
    -29t
    87t
    87t
    -84t
    65t
    -60t
    10t
    -5t
    -52t
    114t
    54t
    -111t
    -112t
    -106t
    -82t
    -16t
    12t
    -96t
    -30t
    -122t
    70t
    14t
    51t
    -59t
    109t
    -120t
    109t
    125t
    -66t
    -49t
    14t
    50t
    63t
    -14t
    -67t
    104t
    115t
    101t
    -109t
    74t
    76t
    -78t
    -111t
    49t
    -10t
    11t
    10t
    -67t
    -5t
    -94t
    76t
    -116t
    -20t
    -22t
    108t
    116t
    -114t
    -119t
    118t
    57t
    45t
    75t
    -46t
    -4t
    113t
    -30t
    -110t
    -69t
    -40t
    -16t
    6t
    30t
    124t
    -61t
    16t
    -51t
    -69t
    -63t
    -23t
    23t
    -26t
    100t
    54t
    -92t
    84t
    -48t
    20t
    39t
    41t
    -65t
    -21t
    117t
    53t
    40t
    43t
    -81t
    -50t
    -10t
    4t
    53t
    -14t
    -123t
    108t
    -47t
    56t
    107t
    -11t
    98t
    79t
    107t
    108t
    -90t
    78t
    -17t
    -7t
    120t
    87t
    8t
    -82t
    -89t
    -84t
    -106t
    -81t
    81t
    -82t
    72t
    102t
    -107t
    32t
    -6t
    -36t
    -1t
    -76t
    19t
    -101t
    -1t
    -89t
    59t
    61t
    59t
    -125t
    121t
    -8t
    -20t
    100t
    -12t
    92t
    -23t
    -50t
    20t
    -10t
    -26t
    -45t
    -99t
    99t
    -86t
    77t
    -111t
    -48t
    -121t
    -93t
    96t
    28t
    79t
    76t
    13t
    68t
    -97t
    -49t
    37t
    99t
    -3t
    -62t
    -67t
    -11t
    -46t
    -103t
    118t
    -24t
    -120t
    -34t
    88t
    -40t
    -66t
    -37t
    112t
    15t
    28t
    34t
    23t
    -73t
    97t
    65t
    56t
    -74t
    -15t
    -100t
    85t
    -71t
    97t
    14t
    60t
    -126t
    49t
    122t
    5t
    -40t
    -41t
    18t
    -85t
    -99t
    120t
    67t
    -123t
    70t
    20t
    -61t
    -46t
    35t
    116t
    -40t
    -108t
    85t
    -114t
    88t
    33t
    87t
    -25t
    39t
    107t
    60t
    -108t
    84t
    2t
    -80t
    -47t
    -30t
    117t
    -19t
    -75t
    78t
    -11t
    24t
    -125t
    68t
    -127t
    44t
    18t
    -85t
    -72t
    22t
    1t
    -25t
    -125t
    -53t
    -107t
    -15t
    -29t
    93t
    -127t
    21t
    -122t
    -77t
    26t
    84t
    -105t
    -21t
    -115t
    72t
    -110t
    79t
    104t
    28t
    -108t
    29t
    -1t
    102t
    4t
    85t
    -121t
    91t
    -113t
    122t
    115t
    -29t
    53t
    -108t
    -81t
    29t
    -86t
    96t
    17t
    -105t
    -97t
    98t
    11t
    -61t
    32t
    -105t
    39t
    8t
    -22t
    84t
    127t
    7t
    8t
    6t
    9t
    -66t
    8t
    -119t
    -62t
    -14t
    80t
    31t
    126t
    -90t
    -122t
    52t
    -118t
    55t
    31t
    -95t
    50t
    87t
    -73t
    -75t
    11t
    -76t
    76t
    -90t
    -72t
    -34t
    -77t
    94t
    -121t
    -107t
    -81t
    72t
    -109t
    22t
    100t
    114t
    -105t
    36t
    19t
    96t
    -94t
    27t
    -59t
    87t
    87t
    106t
    -105t
    -84t
    -104t
    20t
    -83t
    29t
    63t
    56t
    -75t
    123t
    -80t
    -30t
    121t
    -30t
    -125t
    104t
    -61t
    -80t
    88t
    -97t
    73t
    -125t
    112t
    -7t
    110t
    6t
    103t
    -30t
    13t
    89t
    -5t
    61t
    -24t
    -83t
    62t
    -10t
    -68t
    -85t
    25t
    -62t
    -85t
    -21t
    99t
    -40t
    123t
    12t
    70t
    -102t
    -125t
    -107t
    120t
    -5t
    -42t
    80t
    99t
    29t
    -106t
    126t
    5t
    102t
    -18t
    -38t
    -59t
    9t
    -17t
    -74t
    -47t
    -7t
    31t
    83t
    -80t
    -74t
    -79t
    -56t
    -8t
    -112t
    74t
    -13t
    -7t
    96t
    100t
    1t
    -56t
    -23t
    47t
    38t
    85t
    47t
    -52t
    5t
    35t
    -91t
    23t
    -66t
    -17t
    50t
    115t
    100t
    34t
    -26t
    102t
    19t
    -54t
    -5t
    -56t
    -127t
    -23t
    -30t
    -108t
    106t
    -17t
    54t
    -125t
    61t
    -35t
    88t
    39t
    -35t
    -12t
    97t
    -128t
    -14t
    69t
    118t
    98t
    116t
    -69t
    66t
    -101t
    -82t
    -14t
    -14t
    43t
    -47t
    -79t
    -82t
    -45t
    -99t
    99t
    -29t
    -20t
    -95t
    -16t
    -35t
    112t
    115t
    86t
    -119t
    -117t
    -6t
    70t
    -38t
    -36t
    44t
    90t
    -54t
    103t
    -22t
    -32t
    -112t
    -65t
    110t
    -47t
    -71t
    -25t
    -43t
    83t
    89t
    119t
    -91t
    -66t
    118t
    92t
    120t
    89t
    -79t
    -126t
    67t
    -94t
    -53t
    44t
    -127t
    34t
    -14t
    98t
    -110t
    7t
    15t
    25t
    16t
    -15t
    9t
    -105t
    -123t
    -53t
    91t
    -124t
    120t
    -115t
    119t
    86t
    20t
    -54t
    72t
    21t
    13t
    -26t
    104t
    64t
    119t
    123t
    72t
    -124t
    -33t
    -118t
    57t
    -71t
    12t
    -71t
    79t
    -60t
    91t
    -7t
    -122t
    -109t
    109t
    36t
    -69t
    -38t
    -10t
    -98t
    -38t
    102t
    -106t
    -33t
    123t
    -40t
    -15t
    16t
    17t
    14t
    -121t
    -122t
    5t
    -115t
    5t
    -16t
    -30t
    63t
    -18t
    34t
    -2t
    -8t
    82t
    38t
    18t
    117t
    -43t
    25t
    69t
    -121t
    76t
    -37t
    29t
    111t
    -106t
    -83t
    -34t
    -50t
    -105t
    127t
    69t
    -112t
    15t
    -37t
    -49t
    41t
    58t
    -53t
    -95t
    110t
    -103t
    109t
    115t
    12t
    48t
    -110t
    15t
    -105t
    -56t
    -56t
    87t
    71t
    -108t
    -11t
    -37t
    118t
    -112t
    74t
    -65t
    -89t
    -78t
    -87t
    -26t
    -107t
    -115t
    -52t
    92t
    -34t
    -61t
    -51t
    -115t
    -25t
    -117t
    67t
    73t
    -63t
    1t
    -113t
    17t
    -32t
    119t
    94t
    -55t
    92t
    -119t
    -1t
    -18t
    -109t
    -40t
    -90t
    -81t
    -5t
    25t
    113t
    -66t
    11t
    -97t
    -77t
    -33t
    126t
    5t
    30t
    93t
    52t
    -24t
    103t
    -114t
    114t
    -43t
    61t
    -103t
    -121t
    60t
    104t
    74t
    -22t
    25t
    122t
    -101t
    125t
    -5t
    61t
    47t
    10t
    113t
    -118t
    68t
    96t
    -40t
    13t
    111t
    90t
    63t
    71t
    -38t
    1t
    35t
    83t
    52t
    -38t
    74t
    -71t
    56t
    57t
    89t
    -33t
    -57t
    113t
    109t
    -50t
    78t
    15t
    -79t
    -90t
    -4t
    11t
    -128t
    -121t
    33t
    -4t
    -105t
    -115t
    -54t
    -102t
    -8t
    38t
    45t
    8t
    -45t
    101t
    11t
    -12t
    50t
    -59t
    42t
    39t
    -77t
    -57t
    45t
    -66t
    -69t
    -49t
    75t
    -69t
    122t
    -56t
    117t
    102t
    106t
    -24t
    3t
    26t
    -126t
    -102t
    67t
    -109t
    -19t
    -41t
    116t
    100t
    100t
    -92t
    -124t
    71t
    18t
    -8t
    115t
    111t
    14t
    9t
    120t
    4t
    33t
    86t
    31t
    -120t
    127t
    30t
    85t
    60t
    -7t
    68t
    -18t
    22t
    3t
    -73t
    -75t
    14t
    116t
    -97t
    -32t
    29t
    -7t
    52t
    -61t
    -47t
    -80t
    50t
    -111t
    92t
    4t
    104t
    87t
    -16t
    99t
    117t
    68t
    21t
    40t
    -45t
    -99t
    61t
    -20t
    20t
    19t
    117t
    64t
    9t
    16t
    -8t
    34t
    -64t
    -113t
    -89t
    122t
    -7t
    68t
    89t
    54t
    -15t
    -109t
    -65t
    -84t
    -29t
    89t
    5t
    27t
    95t
    39t
    -19t
    77t
    -4t
    -72t
    96t
    -47t
    -30t
    100t
    24t
    15t
    -69t
    -22t
    47t
    51t
    63t
    105t
    -102t
    -21t
    80t
    -125t
    73t
    34t
    -11t
    6t
    -65t
    -32t
    -87t
    96t
    -80t
    -31t
    47t
    6t
    -63t
    -34t
    -26t
    58t
    -54t
    -17t
    -64t
    -25t
    114t
    10t
    103t
    12t
    69t
    -128t
    -113t
    36t
    -111t
    -51t
    -26t
    57t
    -103t
    5t
    -40t
    87t
    123t
    123t
    -6t
    1t
    87t
    -28t
    64t
    11t
    74t
    -47t
    -79t
    -110t
    -70t
    31t
    90t
    57t
    46t
    34t
    -4t
    -104t
    35t
    -117t
    102t
    20t
    14t
    102t
    5t
    -124t
    -116t
    -8t
    52t
    -39t
    126t
    -118t
    123t
    90t
    -124t
    -113t
    -107t
    91t
    -48t
    1t
    13t
    -5t
    -27t
    67t
    79t
    -103t
    -93t
    0t
    -95t
    -37t
    -34t
    106t
    -17t
    9t
    79t
    -53t
    -18t
    14t
    111t
    -31t
    44t
    95t
    -1t
    -48t
    -54t
    -124t
    11t
    75t
    16t
    -123t
    97t
    100t
    -66t
    7t
    -4t
    -117t
    -121t
    -8t
    -124t
    -126t
    -56t
    91t
    93t
    72t
    83t
    93t
    124t
    53t
    -83t
    80t
    -16t
    -117t
    -1t
    -127t
    33t
    80t
    44t
    40t
    -1t
    -87t
    71t
    7t
    -14t
    -1t
    82t
    76t
    32t
    -113t
    -54t
    -72t
    11t
    -43t
    -6t
    112t
    -104t
    -34t
    -37t
    -3t
    63t
    125t
    0t
    -103t
    -22t
    91t
    -42t
    -21t
    49t
    70t
    -16t
    -85t
    31t
    78t
    28t
    4t
    67t
    37t
    24t
    -73t
    100t
    94t
    -111t
    -18t
    81t
    -30t
    -27t
    70t
    -13t
    119t
    -89t
    40t
    -114t
    82t
    -49t
    -102t
    37t
    -84t
    75t
    -55t
    -54t
    -66t
    124t
    117t
    121t
    -14t
    -114t
    98t
    62t
    -61t
    55t
    51t
    52t
    -66t
    81t
    -75t
    86t
    -76t
    100t
    33t
    65t
    -32t
    11t
    -65t
    92t
    -16t
    -7t
    124t
    -121t
    -126t
    27t
    79t
    -38t
    -7t
    19t
    30t
    -100t
    -29t
    44t
    30t
    -79t
    126t
    -47t
    85t
    -27t
    -64t
    -60t
    125t
    -91t
    -81t
    -119t
    -123t
    -14t
    16t
    -60t
    -74t
    83t
    94t
    -71t
    -25t
    3t
    -89t
    -115t
    118t
    -21t
    -83t
    -110t
    -70t
    -127t
    -39t
    -110t
    71t
    64t
    -38t
    -52t
    -75t
    -42t
    24t
    -90t
    -64t
    -36t
    38t
    87t
    -114t
    63t
    16t
    37t
    -106t
    -61t
    45t
    -39t
    75t
    31t
    22t
    90t
    -75t
    -72t
    33t
    -42t
    -50t
    13t
    107t
    4t
    -122t
    3t
    75t
    13t
    108t
    -47t
    -26t
    7t
    -11t
    53t
    91t
    -116t
    -118t
    40t
    -87t
    -84t
    21t
    117t
    -33t
    49t
    -28t
    108t
    78t
    12t
    64t
    -124t
    94t
    3t
    101t
    57t
    96t
    86t
    -37t
    86t
    29t
    -29t
    61t
    -108t
    84t
    -39t
    -107t
    17t
    107t
    -127t
    -59t
    -32t
    -33t
    -45t
    -17t
    21t
    -39t
    -94t
    -56t
    43t
    -107t
    -41t
    125t
    -59t
    -16t
    6t
    -95t
    4t
    -111t
    -72t
    -120t
    -23t
    -108t
    -120t
    81t
    -86t
    -118t
    -2t
    -33t
    81t
    -16t
    38t
    -87t
    -12t
    68t
    -10t
    22t
    114t
    80t
    13t
    122t
    -76t
    35t
    -68t
    -19t
    -58t
    -109t
    -103t
    115t
    -70t
    54t
    -67t
    -108t
    101t
    15t
    -66t
    -117t
    74t
    40t
    82t
    -59t
    23t
    -120t
    88t
    -115t
    116t
    -6t
    -51t
    84t
    26t
    -39t
    -59t
    -7t
    -123t
    93t
    -20t
    70t
    104t
    126t
    -5t
    -81t
    -30t
    -60t
    -116t
    -62t
    -31t
    -20t
    27t
    59t
    -56t
    28t
    74t
    69t
    46t
    -1t
    -96t
    -57t
    7t
    -47t
    -22t
    98t
    -91t
    23t
    -86t
    111t
    -87t
    -55t
    25t
    -127t
    127t
    118t
    -103t
    -9t
    -75t
    -86t
    71t
    -96t
    27t
    28t
    2t
    -69t
    -45t
    -112t
    -75t
    81t
    -80t
    98t
    110t
    95t
    39t
    104t
    -92t
    6t
    16t
    -113t
    -20t
    95t
    -39t
    27t
    -81t
    52t
    109t
    35t
    -57t
    -10t
    -34t
    3t
    -46t
    -16t
    -64t
    42t
    -63t
    -86t
    -2t
    84t
    71t
    49t
    -56t
    -80t
    16t
    -111t
    122t
    28t
    89t
    55t
    14t
    -72t
    -20t
    0t
    -49t
    50t
    82t
    113t
    -53t
    -119t
    49t
    77t
    80t
    66t
    127t
    -100t
    -114t
    116t
    -97t
    43t
    22t
    104t
    -110t
    -61t
    52t
    51t
    -104t
    -59t
    39t
    -93t
    9t
    -14t
    -18t
    73t
    71t
    -36t
    91t
    67t
    103t
    -4t
    -38t
    -87t
    -81t
    -79t
    93t
    -6t
    58t
    -118t
    -57t
    88t
    54t
    11t
    -86t
    -119t
    -42t
    104t
    -29t
    -96t
    -108t
    -78t
    50t
    -21t
    -74t
    -122t
    109t
    -52t
    -103t
    62t
    77t
    -98t
    -65t
    92t
    -12t
    70t
    16t
    124t
    -95t
    -55t
    -104t
    33t
    -96t
    -6t
    105t
    -16t
    6t
    41t
    92t
    -42t
    -100t
    48t
    -64t
    41t
    85t
    91t
    -67t
    18t
    -35t
    66t
    5t
    -120t
    83t
    -16t
    -37t
    1t
    101t
    -21t
    -104t
    -67t
    -120t
    42t
    -96t
    49t
    88t
    17t
    -102t
    41t
    -36t
    6t
    72t
    4t
    73t
    73t
    58t
    -79t
    29t
    -102t
    30t
    -117t
    -61t
    108t
    -76t
    -28t
    -47t
    47t
    -115t
    44t
    -16t
    -89t
    23t
    18t
    -40t
    -103t
    36t
    97t
    -12t
    113t
    -72t
    -90t
    -113t
    21t
    -106t
    -81t
    56t
    -70t
    62t
    7t
    -100t
    -100t
    113t
    -112t
    54t
    -55t
    -11t
    72t
    -49t
    -117t
    104t
    -46t
    -91t
    52t
    -126t
    -35t
    -3t
    39t
    51t
    -34t
    -33t
    20t
    68t
    26t
    39t
    -83t
    -52t
    -109t
    67t
    105t
    48t
    1t
    69t
    96t
    -107t
    105t
    87t
    14t
    -106t
    -37t
    -103t
    75t
    44t
    101t
    -45t
    19t
    -112t
    -62t
    -26t
    -118t
    -19t
    19t
    62t
    -91t
    -89t
    -90t
    -122t
    -128t
    -84t
    -126t
    -115t
    8t
    -73t
    -126t
    -26t
    5t
    112t
    -74t
    -74t
    -2t
    9t
    18t
    -112t
    -53t
    12t
    -6t
    -55t
    4t
    -60t
    43t
    1t
    93t
    40t
    56t
    104t
    -39t
    118t
    46t
    -98t
    -38t
    -47t
    -12t
    0t
    116t
    76t
    112t
    -63t
    42t
    -83t
    88t
    -125t
    -64t
    50t
    -64t
    -21t
    56t
    -118t
    6t
    113t
    -25t
    -83t
    -65t
    -7t
    105t
    75t
    -102t
    117t
    24t
    110t
    86t
    96t
    43t
    26t
    -4t
    29t
    -117t
    -23t
    11t
    118t
    -36t
    -66t
    65t
    -113t
    -119t
    -93t
    -34t
    -66t
    -67t
    -23t
    76t
    -89t
    7t
    -69t
    -49t
    -11t
    -2t
    -37t
    83t
    20t
    113t
    -7t
    29t
    74t
    -75t
    44t
    71t
    75t
    61t
    101t
    -22t
    21t
    -3t
    -86t
    57t
    -86t
    58t
    116t
    -128t
    -6t
    26t
    39t
    72t
    4t
    -28t
    12t
    -61t
    86t
    47t
    73t
    -68t
    65t
    -62t
    89t
    31t
    41t
    23t
    30t
    54t
    11t
    117t
    -91t
    122t
    50t
    -127t
    21t
    -27t
    -1t
    -27t
    50t
    52t
    -65t
    -88t
    -31t
    -29t
    -81t
    67t
    98t
    97t
    76t
    68t
    -53t
    -97t
    -33t
    3t
    -115t
    -1t
    83t
    70t
    -47t
    28t
    25t
    -112t
    -64t
    -53t
    60t
    -7t
    31t
    57t
    -2t
    -47t
    -95t
    -4t
    -121t
    -16t
    -43t
    0t
    -123t
    64t
    44t
    81t
    46t
    -23t
    -68t
    43t
    29t
    -29t
    -53t
    3t
    101t
    53t
    73t
    -79t
    -124t
    -121t
    -3t
    26t
    101t
    105t
    -46t
    127t
    -71t
    39t
    63t
    45t
    56t
    96t
    -32t
    49t
    111t
    94t
    25t
    64t
    -44t
    116t
    107t
    -107t
    -123t
    72t
    114t
    -116t
    33t
    -49t
    92t
    -105t
    14t
    -67t
    120t
    -27t
    -54t
    -66t
    -94t
    -84t
    -116t
    14t
    64t
    -97t
    -27t
    -26t
    -106t
    -83t
    96t
    -97t
    27t
    74t
    -30t
    33t
    -19t
    53t
    39t
    45t
    -53t
    38t
    77t
    -34t
    59t
    -68t
    -80t
    -23t
    126t
    112t
    63t
    52t
    110t
    -14t
    -98t
    16t
    88t
    -121t
    -59t
    -124t
    -62t
    -56t
    -34t
    60t
    87t
    36t
    -16t
    -9t
    53t
    5t
    69t
    -37t
    83t
    -28t
    -39t
    -83t
    -1t
    103t
    -103t
    -17t
    -120t
    -117t
    104t
    61t
    113t
    -73t
    108t
    110t
    -7t
    51t
    40t
    -42t
    113t
    -67t
    105t
    4t
    -118t
    34t
    58t
    48t
    62t
    -93t
    -41t
    -109t
    59t
    95t
    -13t
    1t
    22t
    53t
    104t
    -23t
    -89t
    -115t
    58t
    75t
    87t
    71t
    -73t
    65t
    -127t
    -11t
    -2t
    -39t
    106t
    117t
    122t
    -24t
    70t
    -8t
    73t
    92t
    49t
    -119t
    103t
    -96t
    45t
    -128t
    -126t
    121t
    35t
    -120t
    -21t
    -92t
    74t
    16t
    -49t
    74t
    -11t
    -123t
    -84t
    28t
    72t
    -91t
    9t
    117t
    -25t
    44t
    -120t
    -73t
    -71t
    -47t
    -7t
    127t
    25t
    100t
    53t
    -32t
    -20t
    57t
    -71t
    38t
    -62t
    15t
    -99t
    124t
    -15t
    -109t
    111t
    -99t
    -124t
    99t
    121t
    74t
    52t
    21t
    50t
    17t
    -71t
    54t
    -13t
    -97t
    6t
    116t
    95t
    92t
    -117t
    -60t
    -35t
    -80t
    -47t
    19t
    118t
    82t
    -111t
    -20t
    103t
    12t
    84t
    77t
    4t
    40t
    29t
    -40t
    98t
    105t
    62t
    -121t
    93t
    -112t
    28t
    84t
    14t
    21t
    -99t
    -67t
    -62t
    62t
    22t
    -88t
    48t
    -110t
    -44t
    -67t
    -106t
    20t
    -122t
    39t
    27t
    110t
    -3t
    -69t
    52t
    -128t
    -101t
    -57t
    66t
    74t
    -14t
    35t
    86t
    99t
    100t
    -10t
    -16t
    -4t
    -84t
    -62t
    13t
    -2t
    117t
    11t
    -55t
    14t
    16t
    -99t
    52t
    0t
    -96t
    71t
    -8t
    -72t
    83t
    -18t
    32t
    -125t
    77t
    -37t
    -44t
    73t
    122t
    83t
    99t
    -111t
    -8t
    -107t
    58t
    -113t
    -77t
    46t
    115t
    -28t
    61t
    -99t
    -104t
    97t
    22t
    -112t
    113t
    22t
    -108t
    110t
    96t
    58t
    -122t
    125t
    35t
    83t
    6t
    72t
    -33t
    54t
    91t
    -113t
    -23t
    -99t
    -43t
    -41t
    -67t
    -117t
    94t
    100t
    60t
    120t
    119t
    13t
    8t
    109t
    -33t
    107t
    7t
    26t
    118t
    46t
    -106t
    -122t
    -115t
    -30t
    -45t
    29t
    -52t
    58t
    104t
    17t
    -72t
    -46t
    102t
    69t
    50t
    37t
    -9t
    -59t
    -114t
    -47t
    -47t
    -6t
    -65t
    -100t
    -92t
    109t
    -108t
    24t
    -106t
    20t
    -103t
    -43t
    71t
    119t
    -23t
    77t
    123t
    12t
    -112t
    92t
    -36t
    -68t
    34t
    77t
    -27t
    -41t
    69t
    102t
    -116t
    -127t
    -48t
    42t
    -31t
    30t
    38t
    70t
    -53t
    74t
    125t
    35t
    81t
    26t
    123t
    -58t
    -84t
    27t
    110t
    -31t
    87t
    5t
    -88t
    -7t
    -113t
    -119t
    -59t
    -119t
    -73t
    -114t
    -64t
    88t
    63t
    30t
    -77t
    -91t
    -58t
    2t
    79t
    -29t
    -11t
    63t
    26t
    -12t
    -64t
    -68t
    -68t
    114t
    -18t
    -2t
    72t
    -33t
    -98t
    -23t
    -12t
    -13t
    -119t
    -82t
    -103t
    121t
    90t
    -46t
    -43t
    -83t
    76t
    2t
    -41t
    -12t
    110t
    -50t
    0t
    67t
    5t
    -113t
    89t
    78t
    19t
    108t
    1t
    73t
    30t
    1t
    -46t
    72t
    52t
    -34t
    -64t
    75t
    -88t
    58t
    -127t
    -120t
    52t
    -124t
    -103t
    -2t
    -9t
    -30t
    -52t
    -112t
    80t
    92t
    -47t
    116t
    21t
    13t
    -6t
    -79t
    -124t
    -80t
    54t
    -112t
    -52t
    125t
    -28t
    -61t
    -61t
    35t
    -29t
    -119t
    39t
    -43t
    -69t
    -48t
    51t
    49t
    31t
    29t
    96t
    122t
    38t
    64t
    -39t
    -23t
    95t
    100t
    39t
    -88t
    62t
    -76t
    -84t
    64t
    -69t
    -11t
    97t
    -18t
    59t
    -117t
    48t
    17t
    99t
    -55t
    -40t
    7t
    94t
    -12t
    8t
    87t
    -78t
    95t
    -92t
    122t
    96t
    7t
    -80t
    9t
    112t
    5t
    -29t
    -117t
    70t
    97t
    17t
    52t
    88t
    110t
    -3t
    69t
    -74t
    116t
    124t
    -89t
    95t
    -60t
    47t
    -17t
    -123t
    89t
    -85t
    -115t
    117t
    -40t
    50t
    40t
    -53t
    118t
    57t
    -54t
    -40t
    87t
    95t
    -33t
    126t
    -73t
    46t
    32t
    -121t
    8t
    -100t
    -60t
    17t
    -113t
    83t
    -89t
    32t
    99t
    -58t
    -11t
    -75t
    -13t
    37t
    105t
    90t
    117t
    -89t
    102t
    -104t
    91t
    -96t
    10t
    -121t
    19t
    -86t
    -76t
    -107t
    -104t
    53t
    -19t
    -9t
    -99t
    71t
    -71t
    -25t
    -29t
    -43t
    64t
    77t
    -32t
    25t
    -7t
    -49t
    -4t
    -115t
    -54t
    -117t
    125t
    -69t
    -23t
    120t
    47t
    -34t
    17t
    -43t
    -83t
    -3t
    58t
    45t
    15t
    18t
    54t
    -125t
    93t
    -100t
    -104t
    -26t
    -107t
    -39t
    116t
    91t
    68t
    65t
    35t
    71t
    63t
    -6t
    -101t
    31t
    -93t
    76t
    2t
    -75t
    -112t
    -105t
    51t
    109t
    62t
    -20t
    24t
    -25t
    22t
    115t
    82t
    -11t
    -47t
    103t
    -53t
    -20t
    113t
    101t
    -9t
    -108t
    20t
    65t
    63t
    -8t
    -61t
    43t
    -88t
    -125t
    -108t
    37t
    80t
    -63t
    118t
    -114t
    97t
    96t
    3t
    -35t
    30t
    119t
    8t
    -104t
    31t
    -63t
    47t
    -28t
    -91t
    -109t
    99t
    70t
    0t
    13t
    102t
    -67t
    95t
    -13t
    12t
    115t
    -72t
    116t
    -24t
    -28t
    -81t
    -26t
    29t
    -123t
    33t
    77t
    24t
    46t
    17t
    -42t
    -10t
    3t
    -120t
    -116t
    69t
    8t
    -36t
    41t
    -102t
    100t
    -125t
    78t
    26t
    -83t
    -102t
    -121t
    -70t
    70t
    76t
    -35t
    120t
    9t
    -44t
    74t
    -78t
    -118t
    26t
    123t
    -41t
    -60t
    -53t
    -1t
    76t
    -123t
    119t
    -68t
    107t
    -5t
    -115t
    -11t
    39t
    52t
    -52t
    41t
    33t
    116t
    33t
    -79t
    103t
    59t
    104t
    30t
    22t
    -113t
    92t
    -101t
    79t
    -101t
    40t
    28t
    60t
    -26t
    36t
    105t
    19t
    40t
    90t
    102t
    -128t
    -38t
    -24t
    108t
    36t
    -3t
    -76t
    -119t
    -123t
    87t
    87t
    -18t
    -15t
    -118t
    -9t
    86t
    56t
    74t
    -92t
    -115t
    98t
    7t
    98t
    72t
    37t
    74t
    -20t
    -14t
    -126t
    30t
    26t
    -54t
    -79t
    -72t
    53t
    14t
    -81t
    72t
    61t
    74t
    -27t
    -1t
    19t
    -23t
    100t
    96t
    16t
    123t
    -23t
    -109t
    -79t
    -85t
    119t
    27t
    26t
    100t
    11t
    39t
    56t
    6t
    -61t
    34t
    -63t
    67t
    -4t
    67t
    32t
    -61t
    82t
    -79t
    -56t
    -83t
    9t
    -9t
    -85t
    62t
    -38t
    -50t
    55t
    106t
    -30t
    20t
    -103t
    -20t
    69t
    33t
    -97t
    91t
    -72t
    -64t
    78t
    -106t
    25t
    76t
    13t
    93t
    -87t
    -4t
    3t
    4t
    -60t
    61t
    96t
    -116t
    126t
    104t
    59t
    17t
    -76t
    99t
    -86t
    -9t
    21t
    125t
    52t
    4t
    -35t
    118t
    -100t
    8t
    121t
    -11t
    -126t
    -75t
    -34t
    65t
    24t
    -52t
    71t
    31t
    78t
    -98t
    61t
    -46t
    -68t
    -105t
    121t
    124t
    37t
    0t
    61t
    -11t
    101t
    21t
    125t
    27t
    -18t
    -108t
    66t
    -42t
    -5t
    -5t
    12t
    109t
    6t
    -63t
    -118t
    60t
    -28t
    93t
    110t
    73t
    33t
    -90t
    23t
    -67t
    89t
    90t
    -76t
    -96t
    -95t
    -30t
    -49t
    116t
    -118t
    -125t
    -77t
    -80t
    3t
    83t
    -91t
    -6t
    126t
    25t
    -53t
    97t
    111t
    45t
    92t
    -43t
    56t
    -96t
    68t
    -104t
    83t
    46t
    116t
    66t
    123t
    -23t
    -105t
    43t
    76t
    103t
    -111t
    37t
    53t
    -25t
    66t
    -45t
    109t
    -25t
    22t
    20t
    -76t
    -58t
    68t
    -23t
    -95t
    -126t
    -84t
    24t
    24t
    -67t
    -99t
    -14t
    -11t
    -25t
    17t
    3t
    76t
    126t
    7t
    91t
    0t
    78t
    -63t
    -78t
    117t
    31t
    -37t
    79t
    88t
    -112t
    -97t
    -71t
    0t
    70t
    -21t
    91t
    70t
    11t
    60t
    -66t
    59t
    -97t
    -19t
    28t
    -64t
    65t
    8t
    22t
    77t
    62t
    -98t
    -21t
    61t
    110t
    36t
    -28t
    86t
    18t
    -127t
    -25t
    117t
    84t
    -72t
    -76t
    3t
    88t
    45t
    -97t
    37t
    -76t
    -93t
    72t
    52t
    -116t
    -11t
    -114t
    60t
    32t
    -54t
    9t
    -72t
    -115t
    53t
    92t
    -113t
    -82t
    -64t
    -33t
    87t
    102t
    -63t
    -88t
    108t
    -17t
    4t
    -14t
    45t
    -77t
    72t
    -82t
    32t
    -70t
    115t
    -43t
    40t
    120t
    -31t
    15t
    -57t
    -34t
    101t
    -77t
    42t
    -89t
    -11t
    -39t
    -112t
    -47t
    -22t
    16t
    -39t
    79t
    -108t
    -3t
    -88t
    118t
    53t
    41t
    37t
    54t
    71t
    -119t
    102t
    91t
    -32t
    13t
    -101t
    -109t
    71t
    34t
    -106t
    -100t
    -77t
    13t
    101t
    91t
    -54t
    -5t
    -63t
    -71t
    -121t
    48t
    -63t
    22t
    66t
    -125t
    -13t
    110t
    109t
    -43t
    61t
    81t
    99t
    82t
    -5t
    -96t
    -6t
    -107t
    -97t
    -81t
    0t
    68t
    -96t
    49t
    1t
    84t
    -59t
    56t
    -31t
    92t
    71t
    -58t
    11t
    82t
    -18t
    -114t
    -39t
    -127t
    40t
    -42t
    44t
    -75t
    104t
    16t
    88t
    -13t
    73t
    -101t
    -105t
    58t
    -15t
    -57t
    -39t
    114t
    -2t
    -66t
    -82t
    45t
    -14t
    117t
    -4t
    108t
    -115t
    -122t
    -46t
    52t
    1t
    72t
    120t
    -86t
    103t
    -109t
    -69t
    64t
    117t
    38t
    102t
    105t
    6t
    69t
    -24t
    -3t
    -106t
    29t
    -73t
    -72t
    -2t
    54t
    -114t
    120t
    0t
    57t
    -27t
    29t
    28t
    36t
    -57t
    126t
    23t
    114t
    10t
    -86t
    -3t
    -11t
    43t
    86t
    -122t
    -93t
    -29t
    -49t
    -72t
    43t
    103t
    -22t
    10t
    -112t
    111t
    -85t
    110t
    -37t
    46t
    -107t
    -121t
    8t
    51t
    -73t
    40t
    -109t
    80t
    -127t
    -125t
    127t
    63t
    -51t
    -12t
    -19t
    -37t
    73t
    -126t
    55t
    -81t
    36t
    -45t
    46t
    -57t
    125t
    -104t
    36t
    -121t
    57t
    59t
    -45t
    121t
    -12t
    75t
    -74t
    -36t
    36t
    -37t
    -73t
    12t
    57t
    -63t
    89t
    -93t
    -26t
    84t
    112t
    97t
    125t
    111t
    47t
    86t
    22t
    65t
    -118t
    -114t
    80t
    115t
    107t
    82t
    -91t
    47t
    -99t
    113t
    -9t
    -97t
    37t
    63t
    53t
    -55t
    127t
    -112t
    45t
    62t
    -80t
    -1t
    45t
    -106t
    57t
    57t
    -87t
    -6t
    90t
    64t
    38t
    -51t
    -75t
    46t
    -100t
    19t
    24t
    -13t
    31t
    -16t
    -10t
    -32t
    7t
    -99t
    -32t
    -77t
    -49t
    62t
    -69t
    103t
    -28t
    70t
    105t
    96t
    -11t
    -100t
    34t
    -49t
    50t
    -96t
    118t
    -47t
    12t
    58t
    -117t
    -96t
    8t
    127t
    87t
    33t
    25t
    -123t
    67t
    -37t
    -118t
    107t
    -117t
    93t
    30t
    -41t
    -95t
    -77t
    -57t
    -102t
    -44t
    62t
    -111t
    -55t
    28t
    -42t
    -33t
    -63t
    -19t
    -63t
    -44t
    -117t
    -15t
    -108t
    81t
    11t
    7t
    -70t
    106t
    57t
    -67t
    14t
    -67t
    -79t
    -64t
    -114t
    -97t
    -19t
    25t
    -1t
    106t
    -112t
    -105t
    79t
    -126t
    35t
    -98t
    0t
    -43t
    -89t
    91t
    -93t
    -21t
    68t
    -7t
    -29t
    109t
    -44t
    116t
    -69t
    103t
    -85t
    116t
    -122t
    53t
    -8t
    119t
    -85t
    104t
    -107t
    52t
    107t
    -62t
    109t
    77t
    -2t
    110t
    -96t
    -46t
    63t
    -84t
    -45t
    120t
    15t
    85t
    -1t
    -89t
    -83t
    -60t
    93t
    -92t
    108t
    52t
    -96t
    -113t
    2t
    111t
    47t
    49t
    22t
    116t
    -115t
    -10t
    -25t
    -45t
    -43t
    91t
    -59t
    -58t
    -86t
    99t
    -25t
    -86t
    -93t
    -115t
    -95t
    -93t
    114t
    122t
    -108t
    -96t
    15t
    64t
    -5t
    103t
    71t
    45t
    -99t
    -82t
    -15t
    -120t
    42t
    107t
    64t
    -95t
    -53t
    -60t
    -1t
    -118t
    -27t
    5t
    -17t
    106t
    -128t
    63t
    -63t
    71t
    -19t
    51t
    23t
    97t
    16t
    -101t
    88t
    -68t
    22t
    -99t
    -108t
    117t
    46t
    -32t
    99t
    7t
    -113t
    118t
    92t
    117t
    -98t
    -27t
    41t
    114t
    7t
    86t
    2t
    43t
    -67t
    -108t
    -45t
    24t
    -101t
    35t
    -98t
    -61t
    44t
    13t
    67t
    -46t
    -68t
    -19t
    -88t
    -114t
    -15t
    87t
    40t
    99t
    -119t
    -54t
    37t
    -110t
    -17t
    31t
    -39t
    -11t
    -61t
    39t
    -72t
    -18t
    68t
    59t
    -20t
    -72t
    -85t
    -84t
    117t
    -94t
    37t
    97t
    82t
    96t
    -92t
    -73t
    -87t
    -26t
    124t
    -14t
    -35t
    -7t
    52t
    80t
    19t
    66t
    -30t
    24t
    86t
    -17t
    91t
    -60t
    -81t
    66t
    -62t
    -16t
    -68t
    32t
    57t
    27t
    92t
    105t
    -53t
    50t
    86t
    105t
    -10t
    -91t
    127t
    47t
    -22t
    98t
    -114t
    -26t
    -4t
    -85t
    -103t
    -10t
    60t
    -10t
    -118t
    81t
    27t
    -92t
    -65t
    99t
    33t
    -4t
    74t
    -61t
    -19t
    127t
    -87t
    108t
    93t
    115t
    -90t
    0t
    -101t
    65t
    89t
    68t
    -32t
    40t
    -18t
    6t
    11t
    114t
    -116t
    67t
    119t
    60t
    6t
    -88t
    -84t
    -10t
    120t
    116t
    -119t
    39t
    72t
    -16t
    -52t
    60t
    85t
    -38t
    117t
    -6t
    125t
    -85t
    103t
    29t
    41t
    -115t
    -74t
    -64t
    117t
    -128t
    -4t
    77t
    -22t
    112t
    45t
    58t
    71t
    -69t
    -125t
    49t
    94t
    -57t
    -4t
    25t
    115t
    51t
    5t
    -13t
    -27t
    14t
    104t
    80t
    48t
    -14t
    108t
    89t
    -61t
    -85t
    -16t
    -25t
    63t
    -70t
    83t
    -89t
    -119t
    -107t
    127t
    -86t
    43t
    -41t
    75t
    -65t
    95t
    63t
    -79t
    -122t
    -25t
    -58t
    45t
    58t
    18t
    88t
    25t
    5t
    -69t
    -68t
    14t
    -12t
    -53t
    -127t
    -78t
    -122t
    87t
    70t
    -59t
    -69t
    -60t
    90t
    -19t
    -70t
    -60t
    -104t
    -81t
    102t
    -65t
    -60t
    18t
    -5t
    31t
    54t
    -28t
    92t
    38t
    27t
    -19t
    -76t
    -48t
    -87t
    16t
    -59t
    58t
    55t
    -35t
    43t
    -119t
    81t
    -93t
    117t
    94t
    -62t
    -106t
    41t
    23t
    76t
    75t
    -13t
    -23t
    -3t
    101t
    71t
    -31t
    38t
    -82t
    40t
    16t
    -93t
    -18t
    41t
    97t
    4t
    -30t
    97t
    105t
    -73t
    125t
    -5t
    -4t
    93t
    -17t
    127t
    -80t
    -51t
    127t
    52t
    -7t
    12t
    -73t
    29t
    118t
    -126t
    8t
    -57t
    80t
    -28t
    -63t
    12t
    -60t
    -123t
    -26t
    -74t
    2t
    64t
    -25t
    27t
    -18t
    -74t
    -74t
    -103t
    -103t
    -70t
    -11t
    -67t
    -54t
    48t
    -105t
    89t
    111t
    -27t
    -37t
    -92t
    68t
    -73t
    23t
    -87t
    -15t
    68t
    78t
    -69t
    45t
    106t
    -122t
    108t
    102t
    -84t
    74t
    -84t
    27t
    -99t
    -104t
    0t
    49t
    43t
    -2t
    -3t
    54t
    -82t
    115t
    -80t
    -84t
    -27t
    17t
    62t
    -59t
    -125t
    104t
    60t
    -110t
    119t
    123t
    88t
    -12t
    81t
    95t
    -40t
    -70t
    126t
    -60t
    58t
    -3t
    14t
    93t
    -33t
    107t
    -97t
    -43t
    -29t
    4t
    102t
    -123t
    14t
    89t
    -34t
    -70t
    32t
    117t
    -69t
    110t
    47t
    38t
    -4t
    121t
    -119t
    -51t
    56t
    -46t
    -93t
    -41t
    -80t
    79t
    46t
    -74t
    61t
    -103t
    110t
    52t
    126t
    76t
    122t
    -49t
    96t
    113t
    -24t
    54t
    65t
    -92t
    2t
    -125t
    -101t
    -101t
    97t
    110t
    -5t
    -76t
    87t
    -20t
    -2t
    -90t
    36t
    22t
    105t
    29t
    -80t
    -64t
    -109t
    14t
    82t
    -117t
    66t
    -127t
    -124t
    -58t
    -97t
    22t
    -44t
    89t
    75t
    115t
    -19t
    -98t
    -102t
    -25t
    -99t
    122t
    -29t
    72t
    -30t
    -40t
    -13t
    80t
    -79t
    -21t
    -102t
    41t
    -93t
    97t
    112t
    53t
    -50t
    -54t
    -41t
    -120t
    -116t
    -20t
    -99t
    11t
    65t
    -1t
    -42t
    14t
    -41t
    -118t
    109t
    -17t
    -110t
    15t
    104t
    67t
    96t
    100t
    -98t
    -38t
    -46t
    104t
    -46t
    48t
    51t
    -65t
    -16t
    -115t
    64t
    37t
    -89t
    117t
    8t
    -34t
    74t
    -37t
    -106t
    -90t
    52t
    78t
    57t
    -77t
    -89t
    113t
    -37t
    -118t
    72t
    -12t
    19t
    -62t
    -94t
    121t
    -30t
    49t
    124t
    59t
    -33t
    -87t
    120t
    75t
    -92t
    49t
    3t
    -91t
    -3t
    26t
    75t
    -68t
    -61t
    112t
    -75t
    21t
    -80t
    -30t
    -54t
    -69t
    9t
    18t
    -124t
    -113t
    -61t
    -90t
    -118t
    118t
    -46t
    91t
    31t
    -49t
    17t
    -98t
    -124t
    -39t
    100t
    -113t
    -27t
    6t
    0t
    63t
    -63t
    118t
    16t
    -122t
    98t
    -62t
    112t
    -93t
    -115t
    23t
    90t
    19t
    88t
    11t
    121t
    -117t
    95t
    43t
    74t
    -75t
    75t
    30t
    -92t
    91t
    116t
    52t
    47t
    125t
    -50t
    -28t
    -46t
    -73t
    84t
    -101t
    111t
    101t
    43t
    75t
    -110t
    87t
    -61t
    5t
    -84t
    58t
    -112t
    68t
    41t
    29t
    83t
    -49t
    -90t
    -106t
    -70t
    84t
    118t
    -127t
    16t
    -83t
    -106t
    -96t
    -7t
    -57t
    94t
    16t
    -71t
    -8t
    -88t
    112t
    17t
    -36t
    -50t
    58t
    -116t
    43t
    61t
    -64t
    -95t
    78t
    17t
    112t
    -36t
    -6t
    -121t
    -61t
    23t
    88t
    76t
    -97t
    -51t
    -119t
    109t
    119t
    -107t
    -21t
    -55t
    -55t
    101t
    -16t
    87t
    -29t
    119t
    -80t
    96t
    46t
    -65t
    -3t
    -90t
    105t
    98t
    -48t
    -126t
    -118t
    104t
    -67t
    68t
    45t
    -74t
    -59t
    52t
    16t
    -50t
    -128t
    -7t
    -91t
    -36t
    109t
    -19t
    51t
    126t
    51t
    -113t
    -86t
    -36t
    44t
    48t
    106t
    -2t
    53t
    -108t
    10t
    -25t
    87t
    53t
    75t
    105t
    -94t
    1t
    -65t
    44t
    66t
    -77t
    112t
    0t
    2t
    56t
    80t
    38t
    -83t
    74t
    30t
    81t
    0t
    -123t
    104t
    -22t
    44t
    -79t
    81t
    77t
    -32t
    49t
    -39t
    121t
    -81t
    107t
    106t
    -72t
    -98t
    -44t
    -81t
    -110t
    -98t
    -72t
    105t
    -1t
    -125t
    -20t
    -19t
    -84t
    65t
    -58t
    -54t
    -115t
    93t
    51t
    -78t
    30t
    -111t
    1t
    45t
    -10t
    103t
    47t
    -43t
    -71t
    -17t
    75t
    63t
    -112t
    27t
    -83t
    -105t
    -22t
    64t
    91t
    121t
    48t
    91t
    42t
    -47t
    -44t
    1t
    104t
    93t
    124t
    65t
    -4t
    -95t
    94t
    120t
    109t
    52t
    73t
    26t
    92t
    50t
    64t
    -76t
    -62t
    -9t
    87t
    -120t
    -116t
    110t
    -104t
    -109t
    -102t
    -23t
    -78t
    -38t
    -22t
    50t
    -96t
    -108t
    -113t
    -107t
    -76t
    18t
    -15t
    -46t
    -17t
    -33t
    -90t
    38t
    -82t
    -102t
    -127t
    -80t
    86t
    -44t
    75t
    -109t
    61t
    -102t
    55t
    75t
    -16t
    -86t
    -5t
    -63t
    -58t
    41t
    -92t
    -53t
    36t
    -96t
    109t
    108t
    -36t
    -100t
    83t
    10t
    -87t
    78t
    12t
    69t
    -94t
    -120t
    -3t
    42t
    12t
    -74t
    60t
    -18t
    117t
    101t
    -62t
    -93t
    24t
    -93t
    13t
    104t
    -72t
    -116t
    10t
    83t
    43t
    104t
    -52t
    -78t
    -63t
    -25t
    62t
    124t
    -57t
    107t
    -127t
    -89t
    122t
    -104t
    -51t
    99t
    40t
    -126t
    -84t
    -102t
    -33t
    -15t
    11t
    50t
    102t
    -118t
    100t
    33t
    -82t
    77t
    -47t
    0t
    62t
    -88t
    27t
    -35t
    -66t
    118t
    -97t
    -4t
    113t
    -15t
    -40t
    57t
    5t
    25t
    -65t
    75t
    79t
    104t
    80t
    95t
    12t
    119t
    -49t
    -74t
    -66t
    -72t
    57t
    -35t
    -3t
    52t
    15t
    6t
    65t
    -16t
    -8t
    -89t
    -64t
    35t
    -33t
    69t
    -106t
    106t
    29t
    94t
    88t
    9t
    115t
    -73t
    56t
    7t
    -87t
    -117t
    -13t
    -18t
    -42t
    112t
    98t
    -24t
    -66t
    -75t
    118t
    -8t
    -74t
    30t
    -92t
    -125t
    -115t
    93t
    17t
    71t
    -46t
    121t
    -82t
    86t
    119t
    64t
    -54t
    51t
    98t
    -69t
    -97t
    56t
    117t
    -39t
    -6t
    25t
    96t
    30t
    125t
    9t
    39t
    9t
    -110t
    -69t
    -109t
    -61t
    -10t
    -57t
    87t
    -22t
    -37t
    -67t
    64t
    2t
    -10t
    -83t
    -126t
    -116t
    74t
    34t
    47t
    -83t
    -117t
    -56t
    82t
    -4t
    -100t
    32t
    -30t
    34t
    -81t
    -64t
    31t
    -68t
    124t
    22t
    52t
    109t
    8t
    35t
    60t
    103t
    -110t
    70t
    6t
    36t
    -79t
    13t
    24t
    -22t
    75t
    -112t
    -62t
    58t
    -63t
    58t
    10t
    115t
    54t
    57t
    123t
    46t
    -22t
    -115t
    -68t
    44t
    98t
    -115t
    43t
    86t
    115t
    63t
    -109t
    -89t
    102t
    41t
    67t
    77t
    -27t
    97t
    93t
    -76t
    -63t
    45t
    -94t
    62t
    -82t
    -56t
    -26t
    106t
    -123t
    27t
    55t
    2t
    122t
    126t
    18t
    67t
    -1t
    111t
    -27t
    122t
    69t
    -10t
    54t
    -86t
    -103t
    -14t
    83t
    -58t
    -49t
    2t
    -57t
    -89t
    -115t
    -108t
    -125t
    -73t
    112t
    113t
    -78t
    25t
    -16t
    -121t
    18t
    92t
    -1t
    -103t
    101t
    74t
    112t
    -36t
    -114t
    122t
    -119t
    -1t
    -118t
    -54t
    -36t
    -111t
    -101t
    30t
    7t
    -50t
    -13t
    -103t
    23t
    -119t
    -83t
    -105t
    31t
    119t
    -123t
    85t
    58t
    13t
    -51t
    95t
    126t
    69t
    83t
    -30t
    34t
    10t
    -2t
    -52t
    -82t
    15t
    -60t
    67t
    45t
    99t
    23t
    7t
    16t
    -10t
    -36t
    24t
    44t
    2t
    -4t
    -56t
    64t
    82t
    -79t
    -97t
    -30t
    81t
    95t
    44t
    76t
    51t
    -21t
    -33t
    90t
    11t
    21t
    81t
    112t
    92t
    45t
    49t
    -116t
    0t
    99t
    -19t
    -18t
    82t
    41t
    -11t
    -51t
    -78t
    -41t
    -51t
    109t
    93t
    96t
    -31t
    108t
    25t
    59t
    43t
    -61t
    94t
    -113t
    120t
    111t
    107t
    -77t
    -23t
    89t
    -120t
    -25t
    62t
    -114t
    95t
    -50t
    -108t
    -49t
    -13t
    -48t
    -83t
    -103t
    -68t
    -106t
    -106t
    118t
    -59t
    127t
    -9t
    41t
    9t
    -47t
    -76t
    67t
    -43t
    17t
    -108t
    -126t
    -2t
    -100t
    66t
    116t
    -50t
    80t
    -73t
    87t
    39t
    -67t
    24t
    32t
    23t
    -37t
    -101t
    -64t
    40t
    -109t
    27t
    116t
    -20t
    2t
    -122t
    -47t
    63t
    -20t
    -46t
    -13t
    41t
    28t
    70t
    -122t
    -127t
    -15t
    -40t
    48t
    -13t
    70t
    66t
    13t
    58t
    0t
    94t
    72t
    44t
    -21t
    -65t
    72t
    -97t
    -13t
    101t
    78t
    4t
    -72t
    -12t
    -38t
    -112t
    55t
    115t
    6t
    -29t
    78t
    97t
    43t
    -105t
    -87t
    -34t
    102t
    53t
    -55t
    -56t
    73t
    101t
    21t
    47t
    -8t
    44t
    26t
    79t
    76t
    -101t
    -92t
    -99t
    -113t
    49t
    63t
    5t
    -81t
    -28t
    -82t
    13t
    -85t
    7t
    113t
    -60t
    -82t
    -61t
    -114t
    -31t
    75t
    13t
    -43t
    -21t
    44t
    -34t
    -23t
    41t
    103t
    54t
    51t
    39t
    -71t
    -7t
    -128t
    -121t
    -123t
    -16t
    32t
    -95t
    78t
    24t
    33t
    41t
    86t
    -41t
    -6t
    -21t
    -118t
    -116t
    36t
    47t
    -93t
    69t
    66t
    -90t
    95t
    119t
    94t
    44t
    116t
    20t
    33t
    -16t
    -70t
    -120t
    -15t
    126t
    -56t
    93t
    16t
    -3t
    96t
    57t
    56t
    -58t
    7t
    0t
    -54t
    -52t
    58t
    -18t
    -65t
    -71t
    -19t
    -65t
    -42t
    6t
    -59t
    22t
    -33t
    -119t
    25t
    -39t
    116t
    14t
    111t
    -95t
    -60t
    72t
    -6t
    -7t
    -17t
    12t
    -82t
    40t
    -103t
    -101t
    101t
    -58t
    117t
    55t
    103t
    -82t
    -124t
    15t
    111t
    20t
    87t
    -99t
    -125t
    -117t
    -96t
    18t
    45t
    117t
    81t
    18t
    -90t
    102t
    98t
    75t
    -123t
    39t
    -33t
    116t
    26t
    26t
    -77t
    -35t
    48t
    8t
    -123t
    -101t
    -96t
    61t
    -15t
    87t
    101t
    -61t
    -4t
    105t
    -100t
    112t
    -39t
    99t
    -10t
    -25t
    85t
    49t
    120t
    80t
    94t
    59t
    59t
    80t
    21t
    -126t
    21t
    98t
    83t
    105t
    -105t
    46t
    -56t
    -25t
    -63t
    -3t
    28t
    19t
    -34t
    -3t
    -65t
    24t
    -41t
    -96t
    -44t
    104t
    89t
    27t
    -128t
    -38t
    69t
    23t
    -76t
    -29t
    -31t
    95t
    -80t
    -101t
    104t
    -70t
    -8t
    -100t
    104t
    -88t
    2t
    -50t
    -30t
    -8t
    -32t
    -128t
    -32t
    -82t
    -71t
    -82t
    85t
    -115t
    -108t
    16t
    -85t
    109t
    -51t
    55t
    -45t
    -2t
    0t
    -28t
    -43t
    -97t
    -122t
    -45t
    76t
    -87t
    -25t
    -127t
    81t
    -103t
    75t
    -65t
    74t
    72t
    -39t
    41t
    -55t
    90t
    120t
    0t
    1t
    125t
    95t
    -62t
    105t
    -44t
    4t
    79t
    -74t
    92t
    14t
    55t
    97t
    -51t
    105t
    49t
    33t
    -56t
    -69t
    98t
    0t
    -81t
    -108t
    -62t
    45t
    -121t
    17t
    -38t
    -128t
    -79t
    105t
    -128t
    -57t
    -118t
    36t
    -40t
    -79t
    112t
    109t
    7t
    -105t
    -92t
    110t
    71t
    122t
    -97t
    43t
    -44t
    -59t
    49t
    26t
    65t
    -105t
    96t
    -3t
    -120t
    44t
    19t
    -93t
    7t
    25t
    -48t
    -16t
    41t
    -44t
    -60t
    -78t
    14t
    -22t
    -4t
    46t
    -88t
    13t
    -126t
    107t
    10t
    62t
    11t
    78t
    -111t
    -7t
    -60t
    87t
    11t
    48t
    53t
    -9t
    74t
    -5t
    79t
    91t
    39t
    -125t
    41t
    -86t
    115t
    -23t
    -74t
    79t
    121t
    -64t
    106t
    -30t
    40t
    -32t
    -20t
    -21t
    -32t
    6t
    105t
    57t
    -110t
    -95t
    81t
    88t
    -120t
    118t
    -80t
    -4t
    125t
    -105t
    76t
    117t
    -86t
    26t
    79t
    -8t
    -69t
    62t
    91t
    -20t
    118t
    -111t
    84t
    77t
    47t
    -78t
    -109t
    102t
    -19t
    39t
    38t
    88t
    94t
    -85t
    -88t
    -81t
    -122t
    -15t
    -1t
    89t
    -85t
    125t
    -121t
    -95t
    29t
    35t
    52t
    -64t
    14t
    116t
    -63t
    -4t
    -76t
    83t
    -122t
    -19t
    -109t
    107t
    35t
    -35t
    -39t
    -39t
    -60t
    -29t
    71t
    -29t
    113t
    -39t
    8t
    63t
    -114t
    -128t
    16t
    -122t
    48t
    -19t
    -89t
    101t
    59t
    -110t
    36t
    -89t
    -110t
    -35t
    -20t
    -73t
    72t
    -57t
    -56t
    -127t
    -87t
    21t
    60t
    -119t
    -75t
    115t
    120t
    -118t
    15t
    -3t
    33t
    -122t
    45t
    105t
    92t
    -29t
    104t
    88t
    7t
    -87t
    43t
    -87t
    -86t
    68t
    -2t
    -114t
    36t
    -85t
    51t
    -120t
    -61t
    -26t
    -2t
    121t
    96t
    20t
    15t
    -60t
    -55t
    97t
    -100t
    100t
    -15t
    -85t
    -4t
    -107t
    -91t
    59t
    -94t
    -48t
    71t
    39t
    -69t
    29t
    19t
    -90t
    39t
    -95t
    -17t
    33t
    47t
    -37t
    -121t
    -23t
    13t
    -31t
    -70t
    -80t
    -83t
    15t
    -88t
    9t
    -3t
    -101t
    -111t
    67t
    -8t
    115t
    -20t
    -70t
    17t
    -21t
    30t
    62t
    -97t
    66t
    90t
    4t
    34t
    -65t
    -83t
    -56t
    -17t
    97t
    12t
    16t
    -80t
    80t
    -117t
    54t
    79t
    -77t
    66t
    -108t
    6t
    -96t
    9t
    4t
    110t
    52t
    -89t
    119t
    -99t
    -13t
    -65t
    116t
    -28t
    82t
    -24t
    101t
    1t
    104t
    52t
    8t
    -15t
    122t
    10t
    22t
    -21t
    -60t
    -128t
    -64t
    -100t
    44t
    -11t
    -94t
    94t
    -116t
    -80t
    -83t
    -72t
    -84t
    -117t
    1t
    -115t
    -100t
    125t
    -39t
    -35t
    -16t
    110t
    39t
    -43t
    -113t
    64t
    -70t
    -24t
    -55t
    22t
    106t
    76t
    97t
    -95t
    38t
    69t
    -119t
    -104t
    2t
    -111t
    89t
    -84t
    97t
    -102t
    32t
    81t
    105t
    -47t
    19t
    102t
    -87t
    48t
    47t
    -17t
    81t
    116t
    70t
    124t
    -20t
    127t
    -99t
    -56t
    1t
    45t
    61t
    -30t
    -100t
    107t
    7t
    -117t
    -65t
    -86t
    107t
    112t
    -85t
    -127t
    98t
    -26t
    -109t
    -4t
    -48t
    -60t
    38t
    -9t
    63t
    81t
    14t
    65t
    -70t
    -59t
    -48t
    -101t
    54t
    61t
    112t
    -16t
    -70t
    -38t
    -88t
    100t
    -8t
    8t
    -54t
    -43t
    6t
    -41t
    -105t
    -31t
    121t
    79t
    -122t
    63t
    63t
    -64t
    -73t
    122t
    115t
    -3t
    118t
    -115t
    97t
    -21t
    24t
    29t
    34t
    -68t
    -30t
    24t
    111t
    36t
    93t
    70t
    26t
    -84t
    -127t
    -50t
    11t
    -62t
    50t
    78t
    75t
    -92t
    108t
    -54t
    86t
    31t
    -19t
    -34t
    61t
    -106t
    64t
    44t
    -110t
    -56t
    -117t
    -40t
    -87t
    121t
    -68t
    51t
    81t
    26t
    27t
    112t
    44t
    -121t
    73t
    31t
    126t
    -62t
    97t
    18t
    -24t
    -77t
    -120t
    21t
    22t
    7t
    -14t
    102t
    15t
    -13t
    -123t
    104t
    -93t
    -69t
    95t
    -79t
    -30t
    -100t
    -46t
    -118t
    -103t
    21t
    42t
    76t
    -56t
    -9t
    -33t
    26t
    -39t
    -95t
    38t
    -7t
    -56t
    -126t
    -45t
    -107t
    -91t
    34t
    -126t
    -43t
    -114t
    36t
    -76t
    78t
    22t
    80t
    66t
    100t
    -5t
    -12t
    121t
    119t
    -31t
    19t
    -17t
    89t
    -73t
    104t
    103t
    -38t
    -113t
    64t
    -108t
    -28t
    -115t
    91t
    -105t
    15t
    -45t
    47t
    114t
    66t
    -117t
    29t
    -87t
    -126t
    119t
    11t
    -82t
    57t
    -86t
    11t
    29t
    -104t
    75t
    90t
    -21t
    85t
    13t
    48t
    88t
    -75t
    -87t
    117t
    92t
    105t
    -60t
    -47t
    106t
    -58t
    19t
    -59t
    41t
    23t
    19t
    -118t
    22t
    -8t
    -61t
    118t
    -30t
    75t
    -97t
    58t
    61t
    -55t
    -90t
    -48t
    -75t
    -37t
    2t
    -84t
    -62t
    -66t
    -83t
    -16t
    31t
    42t
    125t
    31t
    32t
    -13t
    106t
    -100t
    26t
    102t
    13t
    -60t
    86t
    -91t
    -106t
    -71t
    -20t
    43t
    70t
    -85t
    -50t
    -114t
    -101t
    102t
    -94t
    -31t
    109t
    103t
    -88t
    35t
    28t
    103t
    -115t
    -66t
    63t
    103t
    89t
    -26t
    46t
    39t
    -80t
    0t
    -68t
    30t
    -19t
    -96t
    -84t
    -89t
    107t
    74t
    38t
    -91t
    -42t
    -65t
    84t
    47t
    4t
    -53t
    -6t
    -106t
    77t
    -48t
    -44t
    102t
    30t
    -101t
    75t
    -67t
    50t
    61t
    -62t
    -32t
    -7t
    -19t
    9t
    -39t
    -117t
    113t
    -12t
    115t
    -22t
    58t
    64t
    20t
    84t
    73t
    25t
    -32t
    117t
    -8t
    -28t
    73t
    49t
    -94t
    28t
    -80t
    -86t
    -34t
    111t
    26t
    -31t
    -52t
    109t
    -33t
    127t
    15t
    80t
    66t
    118t
    86t
    1t
    -93t
    -53t
    30t
    -70t
    -56t
    -1t
    85t
    -62t
    -40t
    116t
    -127t
    -11t
    -18t
    57t
    -84t
    -20t
    67t
    -94t
    118t
    107t
    24t
    -126t
    -76t
    -116t
    116t
    -30t
    -61t
    -111t
    -84t
    -35t
    -69t
    -82t
    75t
    -123t
    8t
    -123t
    -1t
    37t
    34t
    -27t
    6t
    -103t
    114t
    -78t
    -87t
    70t
    -88t
    -68t
    116t
    -1t
    110t
    70t
    105t
    -5t
    98t
    -47t
    -13t
    41t
    61t
    -84t
    74t
    99t
    28t
    -62t
    33t
    91t
    -58t
    37t
    -12t
    -101t
    -68t
    59t
    66t
    -4t
    27t
    36t
    119t
    -128t
    122t
    40t
    -64t
    -11t
    127t
    -121t
    -61t
    14t
    -6t
    -78t
    -111t
    34t
    -89t
    -117t
    -12t
    101t
    -98t
    65t
    -128t
    123t
    -46t
    -119t
    9t
    -64t
    -7t
    113t
    -47t
    106t
    39t
    -82t
    13t
    -2t
    -88t
    -79t
    72t
    -117t
    -9t
    74t
    -94t
    -110t
    -21t
    117t
    70t
    59t
    110t
    -8t
    69t
    90t
    -19t
    66t
    85t
    -114t
    92t
    34t
    79t
    41t
    60t
    39t
    33t
    -49t
    39t
    -85t
    -66t
    98t
    -69t
    88t
    118t
    -66t
    -109t
    -93t
    -32t
    51t
    -104t
    -111t
    -101t
    -40t
    -69t
    -45t
    78t
    -126t
    92t
    -23t
    -55t
    87t
    88t
    98t
    2t
    76t
    -10t
    -87t
    5t
    -91t
    67t
    78t
    -102t
    -126t
    8t
    96t
    -76t
    3t
    -111t
    -93t
    37t
    67t
    -6t
    28t
    -32t
    -11t
    -7t
    45t
    -21t
    -60t
    89t
    23t
    3t
    -104t
    21t
    -50t
    84t
    -112t
    43t
    -121t
    44t
    58t
    -88t
    -10t
    23t
    -95t
    -88t
    12t
    9t
    36t
    -7t
    17t
    -74t
    -53t
    -114t
    -92t
    126t
    -39t
    -77t
    -98t
    18t
    84t
    28t
    41t
    30t
    16t
    -95t
    59t
    -51t
    88t
    -60t
    -97t
    -116t
    37t
    -50t
    -97t
    123t
    -95t
    -118t
    6t
    -97t
    20t
    64t
    49t
    -37t
    29t
    48t
    64t
    4t
    67t
    -84t
    -95t
    88t
    16t
    99t
    -91t
    92t
    103t
    8t
    -89t
    120t
    28t
    -45t
    -9t
    -128t
    -50t
    2t
    43t
    21t
    -118t
    -108t
    78t
    -63t
    -126t
    -100t
    49t
    -52t
    37t
    114t
    50t
    87t
    61t
    29t
    98t
    118t
    32t
    99t
    76t
    -4t
    -116t
    25t
    -30t
    -64t
    105t
    3t
    47t
    9t
    -61t
    109t
    37t
    83t
    118t
    65t
    71t
    85t
    -87t
    21t
    -28t
    3t
    2t
    99t
    54t
    -79t
    -125t
    -62t
    61t
    124t
    114t
    -105t
    54t
    32t
    -6t
    -23t
    -63t
    86t
    22t
    -31t
    78t
    21t
    -70t
    -44t
    -82t
    -37t
    125t
    42t
    -15t
    111t
    -65t
    91t
    -68t
    23t
    -88t
    111t
    -126t
    -55t
    118t
    89t
    59t
    96t
    -95t
    -38t
    -81t
    8t
    31t
    39t
    -88t
    24t
    -29t
    51t
    16t
    -42t
    64t
    -73t
    -66t
    14t
    89t
    -28t
    17t
    -26t
    48t
    48t
    38t
    -33t
    35t
    46t
    -126t
    -68t
    -95t
    120t
    73t
    -16t
    -85t
    -120t
    113t
    109t
    -82t
    15t
    122t
    -89t
    109t
    17t
    -47t
    67t
    -126t
    48t
    -43t
    -98t
    21t
    -1t
    -11t
    -7t
    -77t
    -83t
    -88t
    73t
    44t
    94t
    99t
    -77t
    -110t
    59t
    96t
    56t
    30t
    2t
    117t
    -108t
    84t
    -116t
    -27t
    71t
    18t
    -8t
    -86t
    -105t
    -74t
    -113t
    -78t
    67t
    -96t
    -125t
    22t
    -124t
    -119t
    -26t
    43t
    90t
    -6t
    -118t
    61t
    52t
    84t
    -66t
    47t
    -107t
    108t
    -107t
    -9t
    -56t
    28t
    34t
    -70t
    -98t
    -21t
    66t
    89t
    104t
    125t
    -88t
    -54t
    67t
    81t
    6t
    -91t
    -126t
    105t
    109t
    -47t
    63t
    120t
    -91t
    1t
    -24t
    -88t
    101t
    -127t
    -25t
    -122t
    40t
    -12t
    95t
    20t
    90t
    77t
    -25t
    -92t
    18t
    -105t
    -68t
    82t
    -37t
    46t
    59t
    -58t
    -99t
    -91t
    79t
    -7t
    -6t
    -85t
    89t
    102t
    40t
    -20t
    -35t
    -37t
    -74t
    44t
    -104t
    73t
    -127t
    -51t
    107t
    87t
    16t
    -125t
    87t
    112t
    -37t
    89t
    111t
    71t
    -107t
    39t
    122t
    95t
    97t
    71t
    -60t
    69t
    -123t
    -98t
    4t
    60t
    -1t
    84t
    -79t
    -32t
    78t
    92t
    -37t
    -14t
    120t
    -111t
    54t
    40t
    76t
    123t
    -113t
    88t
    -59t
    64t
    98t
    8t
    -54t
    77t
    33t
    124t
    19t
    -2t
    -98t
    41t
    118t
    120t
    31t
    -36t
    -85t
    -70t
    -127t
    -120t
    -91t
    -71t
    -103t
    -63t
    70t
    75t
    61t
    -78t
    126t
    70t
    -51t
    -23t
    58t
    124t
    -20t
    -95t
    65t
    -8t
    11t
    -74t
    -77t
    -34t
    -46t
    -85t
    96t
    -46t
    60t
    -60t
    -122t
    125t
    -66t
    83t
    -82t
    -27t
    -95t
    115t
    46t
    74t
    -118t
    -73t
    52t
    87t
    -77t
    -38t
    -105t
    -31t
    -76t
    -91t
    69t
    -84t
    -47t
    37t
    -88t
    -60t
    -88t
    53t
    23t
    -93t
    14t
    9t
    -8t
    -127t
    121t
    -68t
    92t
    30t
    33t
    69t
    -27t
    88t
    5t
    100t
    30t
    -62t
    60t
    6t
    118t
    -32t
    38t
    59t
    -117t
    -26t
    -104t
    -25t
    114t
    54t
    -26t
    -84t
    -120t
    104t
    -78t
    62t
    107t
    126t
    54t
    -59t
    -75t
    63t
    -75t
    -16t
    -85t
    -44t
    31t
    110t
    -70t
    114t
    -118t
    74t
    -5t
    31t
    12t
    -80t
    78t
    12t
    88t
    97t
    93t
    52t
    -118t
    -72t
    -41t
    38t
    96t
    31t
    -116t
    15t
    -12t
    101t
    50t
    118t
    124t
    -100t
    74t
    67t
    -122t
    49t
    67t
    97t
    -114t
    59t
    -88t
    121t
    -32t
    122t
    -72t
    -95t
    39t
    -98t
    -34t
    -18t
    -68t
    -25t
    -92t
    -104t
    -36t
    36t
    82t
    -24t
    112t
    -100t
    71t
    30t
    -90t
    83t
    76t
    96t
    -39t
    54t
    104t
    27t
    -2t
    -62t
    70t
    -64t
    70t
    70t
    126t
    -11t
    -126t
    -59t
    -34t
    -92t
    38t
    -109t
    -93t
    -66t
    -108t
    102t
    -12t
    90t
    24t
    -54t
    -20t
    103t
    13t
    -67t
    67t
    -2t
    -27t
    -110t
    104t
    48t
    -66t
    93t
    110t
    -60t
    -50t
    -50t
    73t
    17t
    25t
    -8t
    -109t
    16t
    -87t
    32t
    50t
    26t
    -9t
    -92t
    -12t
    -93t
    -72t
    110t
    -12t
    -81t
    -117t
    -118t
    112t
    -57t
    98t
    15t
    121t
    -64t
    -102t
    102t
    116t
    114t
    81t
    56t
    42t
    111t
    -7t
    26t
    48t
    -80t
    -125t
    -36t
    23t
    -128t
    42t
    -69t
    -16t
    68t
    -62t
    -101t
    103t
    122t
    118t
    -111t
    98t
    -61t
    0t
    113t
    -53t
    -20t
    -31t
    -103t
    87t
    116t
    86t
    97t
    87t
    69t
    -110t
    -14t
    -80t
    -124t
    -28t
    -128t
    -68t
    -56t
    83t
    29t
    -34t
    -45t
    -40t
    110t
    126t
    21t
    -63t
    -85t
    55t
    -35t
    -39t
    -76t
    54t
    -102t
    -24t
    -114t
    -120t
    -3t
    15t
    -22t
    -98t
    107t
    28t
    12t
    -107t
    -89t
    -85t
    63t
    -67t
    25t
    124t
    -110t
    -107t
    27t
    -125t
    -74t
    -62t
    92t
    -54t
    -22t
    -118t
    35t
    61t
    -30t
    -6t
    115t
    94t
    18t
    -69t
    -9t
    -69t
    7t
    113t
    49t
    -16t
    94t
    28t
    61t
    -29t
    -65t
    101t
    -14t
    51t
    -95t
    68t
    -126t
    38t
    -85t
    -58t
    -69t
    117t
    78t
    -122t
    -64t
    102t
    -40t
    118t
    -115t
    116t
    16t
    97t
    -97t
    79t
    44t
    70t
    -42t
    107t
    -13t
    26t
    -85t
    -73t
    22t
    -116t
    -51t
    15t
    60t
    74t
    75t
    41t
    -93t
    -53t
    80t
    50t
    56t
    25t
    60t
    103t
    -86t
    91t
    75t
    89t
    -37t
    -63t
    -29t
    -1t
    -21t
    -62t
    109t
    103t
    88t
    83t
    -82t
    -115t
    -33t
    99t
    -86t
    6t
    61t
    4t
    -94t
    -7t
    42t
    73t
    97t
    -29t
    -68t
    19t
    -32t
    -107t
    63t
    -24t
    -123t
    -65t
    20t
    -33t
    11t
    47t
    18t
    -109t
    5t
    43t
    -8t
    84t
    122t
    -20t
    3t
    40t
    -31t
    -111t
    -9t
    124t
    -30t
    34t
    -85t
    -36t
    58t
    93t
    92t
    -28t
    -87t
    -8t
    86t
    -111t
    80t
    65t
    -123t
    30t
    67t
    70t
    31t
    -70t
    -82t
    47t
    -79t
    -12t
    104t
    112t
    -69t
    -108t
    -88t
    44t
    119t
    98t
    20t
    -97t
    77t
    -93t
    8t
    6t
    -58t
    -75t
    -112t
    -32t
    -73t
    104t
    -123t
    -29t
    5t
    109t
    6t
    -117t
    -116t
    -94t
    12t
    -53t
    7t
    -98t
    -79t
    -106t
    38t
    90t
    104t
    -116t
    -90t
    -79t
    61t
    2t
    92t
    53t
    -73t
    -119t
    -36t
    70t
    -115t
    -24t
    -55t
    81t
    91t
    42t
    -81t
    92t
    97t
    -88t
    47t
    1t
    104t
    -101t
    41t
    -110t
    -30t
    -46t
    9t
    25t
    53t
    65t
    20t
    111t
    32t
    13t
    110t
    93t
    63t
    126t
    18t
    96t
    -72t
    -76t
    -63t
    5t
    36t
    -115t
    71t
    16t
    -114t
    38t
    24t
    77t
    12t
    0t
    48t
    -16t
    21t
    -33t
    -17t
    38t
    119t
    -39t
    -60t
    -89t
    -119t
    39t
    29t
    -53t
    -3t
    27t
    66t
    67t
    -3t
    -55t
    98t
    -9t
    -112t
    -69t
    106t
    -116t
    42t
    121t
    -6t
    42t
    -13t
    -57t
    119t
    -92t
    51t
    115t
    21t
    95t
    20t
    -69t
    -19t
    -26t
    -92t
    22t
    -9t
    -38t
    -79t
    90t
    -71t
    99t
    59t
    -60t
    116t
    72t
    46t
    -56t
    -11t
    -58t
    21t
    -103t
    -9t
    -26t
    31t
    55t
    4t
    71t
    -100t
    -65t
    -32t
    86t
    79t
    -87t
    53t
    73t
    -25t
    2t
    84t
    -12t
    -31t
    115t
    24t
    -7t
    -42t
    -7t
    -72t
    -4t
    21t
    43t
    61t
    1t
    -38t
    -39t
    118t
    85t
    -9t
    -27t
    108t
    -127t
    110t
    -41t
    45t
    20t
    13t
    -120t
    52t
    -8t
    110t
    -16t
    -80t
    90t
    126t
    -42t
    -60t
    42t
    47t
    -117t
    118t
    -128t
    -38t
    84t
    85t
    -105t
    -8t
    97t
    92t
    -4t
    -91t
    -84t
    -70t
    24t
    21t
    -36t
    12t
    21t
    -104t
    91t
    -4t
    91t
    119t
    70t
    -117t
    -71t
    27t
    -83t
    -18t
    77t
    27t
    28t
    -102t
    -113t
    -88t
    50t
    119t
    19t
    -58t
    -25t
    -109t
    36t
    66t
    -52t
    93t
    30t
    -101t
    -47t
    -43t
    87t
    -18t
    -44t
    127t
    -78t
    35t
    82t
    28t
    54t
    -53t
    -30t
    111t
    -35t
    123t
    10t
    -94t
    118t
    46t
    -33t
    -12t
    -20t
    -19t
    -33t
    -100t
    -107t
    111t
    127t
    116t
    -82t
    -114t
    91t
    61t
    125t
    -87t
    90t
    117t
    -80t
    -93t
    -58t
    -123t
    81t
    32t
    -74t
    79t
    -79t
    117t
    -101t
    -66t
    -86t
    73t
    -15t
    49t
    -33t
    -14t
    86t
    34t
    20t
    -54t
    1t
    58t
    11t
    -36t
    -5t
    -64t
    -59t
    -21t
    -3t
    -67t
    116t
    2t
    76t
    -31t
    36t
    -14t
    64t
    -49t
    -38t
    -54t
    86t
    105t
    41t
    -28t
    -30t
    -4t
    -101t
    116t
    12t
    -86t
    44t
    80t
    16t
    -70t
    46t
    -92t
    82t
    -87t
    5t
    72t
    57t
    -46t
    -19t
    103t
    12t
    74t
    -107t
    115t
    -113t
    -29t
    103t
    -122t
    -91t
    55t
    95t
    -126t
    -110t
    61t
    -36t
    -14t
    -15t
    -18t
    -33t
    -46t
    63t
    -66t
    111t
    79t
    -78t
    79t
    100t
    122t
    95t
    7t
    58t
    -112t
    2t
    75t
    106t
    -42t
    -45t
    112t
    -106t
    33t
    21t
    -93t
    -26t
    94t
    -104t
    -28t
    -78t
    -15t
    -76t
    -111t
    41t
    -38t
    -35t
    38t
    -94t
    -33t
    45t
    -44t
    -40t
    40t
    -13t
    27t
    38t
    -9t
    74t
    55t
    -123t
    -53t
    78t
    -6t
    121t
    -28t
    43t
    -48t
    -61t
    -39t
    -99t
    -26t
    -113t
    27t
    -71t
    119t
    80t
    -117t
    101t
    83t
    21t
    -8t
    -42t
    15t
    -63t
    68t
    54t
    2t
    -6t
    75t
    -103t
    -71t
    121t
    -47t
    -58t
    -22t
    77t
    8t
    123t
    -119t
    108t
    92t
    126t
    -76t
    29t
    -42t
    12t
    -119t
    -40t
    0t
    33t
    46t
    44t
    121t
    -83t
    76t
    -4t
    41t
    -55t
    -82t
    -84t
    55t
    39t
    -2t
    118t
    5t
    20t
    21t
    51t
    -47t
    89t
    119t
    16t
    -126t
    -25t
    11t
    -13t
    -60t
    107t
    -66t
    -86t
    75t
    32t
    -113t
    -83t
    -55t
    -6t
    -82t
    -40t
    -108t
    -100t
    -50t
    -66t
    -119t
    -61t
    -110t
    -118t
    95t
    -95t
    -70t
    9t
    -110t
    43t
    -35t
    -76t
    61t
    105t
    -25t
    -66t
    33t
    25t
    94t
    -49t
    13t
    -71t
    119t
    8t
    89t
    44t
    21t
    -48t
    3t
    96t
    38t
    17t
    -54t
    -10t
    -13t
    -106t
    34t
    -72t
    85t
    46t
    -84t
    19t
    46t
    -14t
    -95t
    48t
    -96t
    111t
    -96t
    71t
    78t
    -25t
    18t
    115t
    7t
    10t
    -89t
    82t
    70t
    67t
    43t
    -33t
    -71t
    0t
    97t
    58t
    -95t
    71t
    0t
    68t
    -48t
    -92t
    -97t
    38t
    -77t
    60t
    -50t
    -43t
    -32t
    -64t
    -33t
    25t
    73t
    -27t
    56t
    -29t
    -127t
    96t
    86t
    -45t
    -16t
    -89t
    -94t
    -71t
    -52t
    -65t
    26t
    32t
    -69t
    -97t
    31t
    40t
    -7t
    15t
    -33t
    83t
    18t
    9t
    -60t
    70t
    -77t
    28t
    -56t
    75t
    22t
    19t
    39t
    55t
    104t
    46t
    25t
    -43t
    82t
    -14t
    118t
    -31t
    -95t
    109t
    -126t
    -29t
    103t
    19t
    -38t
    -103t
    108t
    -25t
    -102t
    49t
    43t
    -97t
    -35t
    -5t
    24t
    12t
    97t
    35t
    -34t
    -19t
    -32t
    73t
    -27t
    -37t
    -63t
    -71t
    55t
    -71t
    -128t
    -65t
    91t
    -101t
    76t
    -9t
    101t
    -66t
    -61t
    -64t
    75t
    65t
    -12t
    -55t
    -54t
    92t
    28t
    105t
    -122t
    -8t
    112t
    86t
    -88t
    -122t
    125t
    -76t
    -46t
    107t
    -10t
    -37t
    -95t
    110t
    18t
    -24t
    49t
    -83t
    -123t
    -3t
    -16t
    -111t
    97t
    -51t
    -42t
    39t
    5t
    -126t
    57t
    125t
    98t
    -86t
    -28t
    -104t
    91t
    33t
    67t
    40t
    103t
    -53t
    37t
    -48t
    127t
    -47t
    43t
    65t
    86t
    28t
    -20t
    52t
    105t
    -28t
    -118t
    -17t
    13t
    79t
    -68t
    2t
    110t
    83t
    121t
    34t
    -111t
    -10t
    -72t
    -66t
    -86t
    -55t
    -18t
    25t
    -118t
    -7t
    120t
    -53t
    1t
    -68t
    -43t
    73t
    -69t
    -33t
    9t
    16t
    -61t
    46t
    53t
    25t
    -33t
    2t
    68t
    -30t
    -38t
    -113t
    -65t
    112t
    -88t
    27t
    -78t
    -54t
    63t
    -4t
    -37t
    -40t
    -62t
    74t
    119t
    -90t
    77t
    93t
    96t
    40t
    77t
    108t
    -54t
    34t
    -120t
    62t
    -126t
    -65t
    64t
    81t
    -44t
    -109t
    -4t
    -19t
    4t
    76t
    115t
    -79t
    -98t
    -98t
    37t
    91t
    -27t
    26t
    -45t
    -119t
    -88t
    47t
    77t
    -4t
    -42t
    109t
    10t
    1t
    -103t
    -108t
    90t
    16t
    -112t
    -83t
    -74t
    110t
    -79t
    33t
    -92t
    73t
    -66t
    108t
    6t
    -35t
    61t
    94t
    110t
    8t
    -27t
    -31t
    86t
    -64t
    57t
    21t
    -77t
    -98t
    -100t
    111t
    100t
    98t
    102t
    1t
    -117t
    55t
    57t
    2t
    -46t
    -57t
    59t
    37t
    -18t
    49t
    -103t
    -52t
    -124t
    51t
    32t
    -47t
    -47t
    -25t
    76t
    65t
    48t
    -98t
    16t
    -65t
    -110t
    -117t
    117t
    -73t
    -21t
    11t
    38t
    72t
    107t
    -17t
    -116t
    115t
    86t
    -101t
    -64t
    -92t
    26t
    96t
    -43t
    122t
    70t
    84t
    64t
    -2t
    -14t
    -30t
    66t
    -11t
    55t
    23t
    123t
    -124t
    -107t
    -66t
    -108t
    4t
    -47t
    74t
    -1t
    74t
    12t
    10t
    15t
    98t
    -99t
    -16t
    -77t
    -46t
    59t
    -23t
    56t
    23t
    -56t
    2t
    -53t
    -26t
    -127t
    -35t
    -31t
    90t
    58t
    -43t
    67t
    -34t
    -4t
    49t
    52t
    99t
    -102t
    -76t
    -4t
    -30t
    102t
    18t
    101t
    -6t
    -118t
    -127t
    -100t
    -3t
    56t
    110t
    61t
    -44t
    -26t
    -73t
    -69t
    37t
    -52t
    -82t
    76t
    8t
    -77t
    -75t
    54t
    34t
    -58t
    -90t
    34t
    -84t
    96t
    -87t
    -22t
    -68t
    68t
    119t
    17t
    -45t
    -51t
    -50t
    27t
    -106t
    13t
    59t
    -104t
    72t
    84t
    -85t
    -56t
    -12t
    35t
    33t
    78t
    44t
    7t
    -94t
    -56t
    67t
    -36t
    105t
    45t
    63t
    23t
    -46t
    55t
    -24t
    -105t
    2t
    68t
    -60t
    -13t
    -96t
    81t
    -22t
    -44t
    12t
    106t
    18t
    73t
    -77t
    20t
    -22t
    -106t
    80t
    97t
    111t
    20t
    115t
    -46t
    50t
    -24t
    -60t
    -120t
    -101t
    -87t
    126t
    -97t
    -97t
    15t
    -115t
    65t
    -99t
    58t
    97t
    82t
    -104t
    -103t
    -67t
    49t
    87t
    104t
    -41t
    30t
    -29t
    -111t
    73t
    19t
    -116t
    -125t
    -6t
    39t
    71t
    102t
    -128t
    74t
    -116t
    -100t
    -101t
    -119t
    117t
    -120t
    -20t
    45t
    27t
    41t
    37t
    -33t
    98t
    -84t
    -28t
    -27t
    5t
    13t
    27t
    -96t
    -77t
    -48t
    -112t
    -87t
    -17t
    -49t
    -27t
    115t
    107t
    -101t
    102t
    84t
    -123t
    -97t
    41t
    93t
    68t
    8t
    79t
    -71t
    60t
    73t
    74t
    -71t
    -34t
    121t
    98t
    68t
    94t
    113t
    -60t
    -57t
    107t
    -46t
    -40t
    -34t
    90t
    -92t
    -31t
    -61t
    119t
    104t
    -87t
    13t
    -11t
    -91t
    123t
    4t
    -15t
    -45t
    -110t
    124t
    85t
    -115t
    93t
    -81t
    -90t
    -112t
    -123t
    72t
    -58t
    -104t
    -98t
    69t
    91t
    -15t
    -88t
    116t
    92t
    25t
    -27t
    15t
    -75t
    -78t
    68t
    125t
    96t
    -8t
    -9t
    78t
    55t
    31t
    16t
    -45t
    14t
    70t
    -91t
    -24t
    121t
    71t
    -92t
    27t
    114t
    -111t
    -65t
    -125t
    28t
    47t
    120t
    -52t
    111t
    -43t
    122t
    114t
    -72t
    50t
    15t
    5t
    117t
    -88t
    -8t
    -55t
    8t
    125t
    91t
    -89t
    -68t
    -95t
    -39t
    21t
    46t
    77t
    -85t
    91t
    -44t
    50t
    18t
    -87t
    -50t
    -12t
    9t
    115t
    -84t
    -126t
    -125t
    17t
    -58t
    115t
    -25t
    -74t
    -63t
    -16t
    21t
    31t
    96t
    54t
    66t
    -87t
    -37t
    -111t
    -101t
    99t
    111t
    61t
    -16t
    -61t
    -72t
    -1t
    -56t
    110t
    90t
    -90t
    -2t
    -17t
    -111t
    -30t
    -17t
    -31t
    -121t
    -62t
    -124t
    82t
    76t
    -18t
    82t
    33t
    -93t
    26t
    9t
    -37t
    87t
    -48t
    -118t
    72t
    2t
    -14t
    -101t
    71t
    107t
    -66t
    -113t
    30t
    -24t
    51t
    -8t
    39t
    30t
    45t
    -18t
    11t
    54t
    -19t
    -19t
    95t
    35t
    108t
    -40t
    64t
    -63t
    9t
    84t
    -100t
    61t
    24t
    79t
    -49t
    -70t
    -128t
    77t
    67t
    -56t
    -5t
    125t
    -118t
    113t
    61t
    126t
    -49t
    -109t
    86t
    -115t
    63t
    -36t
    -35t
    -106t
    85t
    90t
    65t
    -44t
    -89t
    94t
    78t
    81t
    89t
    76t
    82t
    -94t
    -103t
    -12t
    -75t
    -88t
    57t
    -42t
    -95t
    122t
    6t
    117t
    -60t
    78t
    -38t
    111t
    -37t
    -100t
    107t
    -94t
    44t
    -81t
    -119t
    122t
    86t
    -41t
    -95t
    3t
    84t
    -67t
    -123t
    120t
    -68t
    -8t
    -11t
    -59t
    -117t
    -63t
    94t
    60t
    26t
    -115t
    -78t
    -15t
    86t
    127t
    39t
    43t
    65t
    -69t
    74t
    -70t
    86t
    101t
    72t
    -80t
    77t
    93t
    -44t
    -69t
    30t
    72t
    -59t
    109t
    91t
    48t
    50t
    -44t
    -36t
    74t
    -37t
    -92t
    122t
    116t
    -8t
    80t
    84t
    104t
    111t
    48t
    124t
    72t
    69t
    -126t
    -10t
    -76t
    53t
    17t
    45t
    71t
    -38t
    -40t
    -124t
    -90t
    13t
    -111t
    124t
    -51t
    -41t
    -42t
    3t
    14t
    102t
    87t
    77t
    10t
    -58t
    -5t
    26t
    8t
    112t
    -4t
    19t
    -102t
    21t
    -111t
    46t
    -4t
    27t
    9t
    -17t
    -13t
    -6t
    1t
    9t
    -94t
    -45t
    -7t
    76t
    -127t
    -36t
    -25t
    -72t
    -40t
    -125t
    -16t
    -20t
    71t
    -66t
    118t
    81t
    90t
    -42t
    107t
    -108t
    57t
    84t
    126t
    96t
    -16t
    87t
    15t
    -118t
    -22t
    106t
    -21t
    -115t
    59t
    109t
    -125t
    -75t
    55t
    36t
    127t
    60t
    -25t
    45t
    115t
    122t
    -106t
    77t
    16t
    -65t
    64t
    -100t
    -5t
    87t
    89t
    -12t
    57t
    125t
    -25t
    16t
    79t
    115t
    22t
    -116t
    -29t
    -79t
    -61t
    117t
    53t
    -22t
    -117t
    47t
    45t
    25t
    -106t
    -80t
    -107t
    -86t
    80t
    -68t
    -103t
    97t
    -75t
    116t
    -8t
    26t
    36t
    6t
    -128t
    127t
    -103t
    37t
    78t
    67t
    -124t
    -92t
    -66t
    65t
    -40t
    -113t
    -98t
    56t
    -49t
    6t
    71t
    122t
    126t
    118t
    -56t
    -18t
    -116t
    65t
    111t
    -113t
    -101t
    72t
    -50t
    -93t
    -124t
    44t
    40t
    -50t
    55t
    -112t
    -79t
    -63t
    89t
    27t
    -75t
    85t
    -38t
    -10t
    47t
    -33t
    22t
    17t
    57t
    122t
    -55t
    -18t
    -103t
    -22t
    -36t
    62t
    121t
    30t
    -17t
    21t
    -56t
    -127t
    -117t
    -102t
    49t
    -44t
    72t
    53t
    84t
    -52t
    22t
    -33t
    -75t
    -60t
    44t
    103t
    -6t
    -91t
    -10t
    -90t
    2t
    10t
    -64t
    -114t
    -34t
    -112t
    -38t
    -40t
    103t
    7t
    74t
    -13t
    -22t
    15t
    -110t
    -60t
    -34t
    41t
    81t
    -78t
    112t
    -4t
    -126t
    52t
    100t
    -128t
    96t
    49t
    125t
    108t
    126t
    80t
    54t
    93t
    63t
    96t
    -13t
    85t
    111t
    -88t
    -114t
    82t
    -112t
    -96t
    -64t
    -90t
    -53t
    72t
    86t
    -80t
    43t
    -8t
    -124t
    -37t
    70t
    116t
    -62t
    82t
    -6t
    -101t
    -66t
    -78t
    84t
    -25t
    -56t
    35t
    -101t
    -108t
    64t
    -63t
    18t
    -101t
    91t
    -30t
    108t
    -71t
    -77t
    -22t
    -23t
    -88t
    -83t
    6t
    -85t
    -79t
    -116t
    -110t
    -64t
    -97t
    -24t
    35t
    58t
    -92t
    28t
    108t
    62t
    -27t
    -78t
    -63t
    -90t
    56t
    -33t
    0t
    90t
    -16t
    66t
    -105t
    79t
    -57t
    -127t
    101t
    -25t
    -107t
    -85t
    7t
    105t
    115t
    4t
    -103t
    94t
    12t
    -24t
    2t
    -122t
    -53t
    -35t
    34t
    -44t
    -41t
    102t
    -42t
    20t
    91t
    -120t
    -22t
    -90t
    -105t
    -51t
    -69t
    -49t
    25t
    -123t
    -36t
    121t
    -81t
    -44t
    -48t
    125t
    44t
    -42t
    -15t
    -126t
    72t
    49t
    -72t
    -11t
    43t
    18t
    19t
    -61t
    -55t
    -12t
    10t
    -88t
    34t
    52t
    -10t
    -27t
    -105t
    -11t
    43t
    76t
    91t
    48t
    121t
    48t
    -61t
    -78t
    -46t
    -50t
    111t
    -122t
    -2t
    60t
    8t
    125t
    38t
    100t
    38t
    -67t
    40t
    31t
    124t
    -36t
    43t
    77t
    8t
    -105t
    -107t
    -33t
    32t
    98t
    -62t
    87t
    6t
    -85t
    -78t
    105t
    2t
    121t
    -4t
    -89t
    -39t
    -116t
    1t
    88t
    45t
    -27t
    -39t
    -7t
    109t
    -18t
    24t
    101t
    -27t
    -19t
    50t
    -10t
    -33t
    -61t
    -125t
    122t
    -119t
    78t
    -85t
    0t
    -8t
    39t
    -78t
    1t
    15t
    84t
    -78t
    3t
    -9t
    -76t
    -58t
    -87t
    -27t
    -102t
    125t
    -111t
    76t
    -80t
    -119t
    -69t
    38t
    -31t
    116t
    68t
    -54t
    -55t
    98t
    -47t
    24t
    -68t
    6t
    73t
    -120t
    80t
    90t
    -127t
    -61t
    66t
    61t
    -59t
    -80t
    -27t
    116t
    -30t
    -47t
    61t
    -42t
    -66t
    41t
    102t
    -15t
    2t
    7t
    20t
    -4t
    125t
    55t
    97t
    93t
    44t
    -28t
    60t
    91t
    71t
    -68t
    123t
    -99t
    -15t
    3t
    85t
    -35t
    105t
    83t
    14t
    106t
    21t
    -28t
    -5t
    -123t
    24t
    37t
    28t
    -127t
    -73t
    -44t
    -36t
    -50t
    -91t
    -68t
    -33t
    -38t
    -102t
    55t
    -59t
    124t
    -9t
    75t
    94t
    87t
    45t
    -67t
    -53t
    16t
    124t
    84t
    -113t
    83t
    88t
    -62t
    -1t
    -77t
    -126t
    -20t
    -72t
    113t
    44t
    82t
    -101t
    28t
    113t
    -5t
    -60t
    -120t
    45t
    -101t
    103t
    28t
    -79t
    95t
    -41t
    -99t
    -111t
    -70t
    -17t
    -41t
    -52t
    6t
    22t
    -53t
    26t
    68t
    -50t
    -82t
    67t
    14t
    15t
    -61t
    119t
    -97t
    -123t
    -113t
    -123t
    -105t
    -80t
    -111t
    43t
    -37t
    10t
    -69t
    -83t
    45t
    22t
    83t
    124t
    -117t
    124t
    31t
    52t
    -9t
    -103t
    -45t
    53t
    -8t
    34t
    -23t
    -68t
    87t
    23t
    89t
    31t
    -124t
    21t
    -8t
    85t
    -104t
    7t
    96t
    -94t
    -16t
    -3t
    -55t
    -44t
    20t
    18t
    100t
    -91t
    9t
    -116t
    54t
    -30t
    111t
    -71t
    -52t
    28t
    -26t
    -77t
    -67t
    -63t
    31t
    30t
    -9t
    0t
    -100t
    -57t
    125t
    39t
    -106t
    -77t
    32t
    94t
    -91t
    81t
    40t
    120t
    68t
    -5t
    -112t
    -23t
    49t
    -22t
    66t
    -12t
    -45t
    27t
    -10t
    118t
    -67t
    -5t
    8t
    126t
    -109t
    -17t
    7t
    -17t
    48t
    -31t
    52t
    -20t
    -24t
    100t
    94t
    100t
    -25t
    24t
    26t
    4t
    -112t
    101t
    -6t
    42t
    -61t
    -32t
    -64t
    -125t
    -66t
    115t
    -80t
    23t
    -83t
    -40t
    27t
    63t
    -122t
    -110t
    -87t
    -18t
    -125t
    -37t
    14t
    2t
    17t
    -8t
    -33t
    105t
    -55t
    59t
    14t
    -4t
    -107t
    44t
    -43t
    -65t
    113t
    121t
    -24t
    18t
    76t
    -128t
    82t
    108t
    71t
    -95t
    42t
    -99t
    -113t
    -128t
    112t
    -47t
    83t
    -118t
    -8t
    -64t
    -9t
    -21t
    21t
    68t
    -23t
    111t
    95t
    -126t
    -34t
    124t
    -57t
    78t
    23t
    -15t
    -82t
    -47t
    20t
    -85t
    76t
    -124t
    -2t
    36t
    17t
    -108t
    121t
    60t
    50t
    103t
    112t
    21t
    81t
    -22t
    -117t
    21t
    88t
    123t
    -19t
    13t
    -116t
    40t
    23t
    -71t
    91t
    91t
    122t
    -103t
    16t
    -28t
    120t
    87t
    62t
    -102t
    -12t
    -67t
    -59t
    67t
    -55t
    3t
    19t
    67t
    53t
    -121t
    71t
    -57t
    -70t
    -83t
    108t
    -76t
    12t
    -122t
    52t
    100t
    39t
    -120t
    50t
    67t
    108t
    -114t
    -91t
    -89t
    -36t
    91t
    32t
    14t
    -58t
    -112t
    45t
    -83t
    -62t
    -98t
    101t
    15t
    68t
    -99t
    -94t
    9t
    82t
    83t
    18t
    -73t
    -18t
    -85t
    -120t
    -63t
    -14t
    -10t
    -99t
    104t
    59t
    -62t
    27t
    -88t
    -31t
    101t
    -99t
    -115t
    -35t
    -121t
    -82t
    -116t
    -64t
    10t
    -17t
    -125t
    -80t
    -85t
    -23t
    -41t
    -11t
    -28t
    94t
    -100t
    -17t
    95t
    91t
    -41t
    -26t
    97t
    -117t
    -69t
    -47t
    -28t
    41t
    -115t
    -54t
    36t
    75t
    -112t
    102t
    -123t
    -66t
    79t
    -29t
    -63t
    121t
    -13t
    33t
    59t
    -43t
    -52t
    17t
    -23t
    -115t
    -18t
    -78t
    50t
    125t
    16t
    4t
    44t
    -112t
    -88t
    80t
    -59t
    -24t
    71t
    116t
    -95t
    -97t
    62t
    65t
    5t
    26t
    -64t
    -52t
    42t
    90t
    73t
    50t
    -103t
    -128t
    96t
    -46t
    -35t
    56t
    -95t
    -11t
    109t
    88t
    -13t
    64t
    -24t
    -3t
    110t
    59t
    11t
    116t
    -7t
    8t
    -89t
    -108t
    16t
    98t
    41t
    -27t
    52t
    -95t
    -58t
    -94t
    60t
    -48t
    7t
    -98t
    8t
    -15t
    -41t
    49t
    -95t
    11t
    -18t
    -4t
    61t
    -80t
    -89t
    102t
    -44t
    -108t
    92t
    4t
    -122t
    -23t
    127t
    -103t
    -50t
    116t
    86t
    -10t
    114t
    -56t
    -38t
    -120t
    45t
    -47t
    62t
    110t
    -9t
    -18t
    -46t
    -8t
    -74t
    -106t
    92t
    -67t
    -50t
    32t
    -45t
    -52t
    -59t
    -56t
    -70t
    92t
    32t
    -19t
    27t
    -100t
    -51t
    80t
    30t
    29t
    9t
    -87t
    14t
    76t
    -60t
    36t
    -16t
    36t
    -13t
    -22t
    33t
    4t
    72t
    59t
    67t
    -62t
    -127t
    109t
    -11t
    27t
    -68t
    76t
    -65t
    48t
    4t
    104t
    -55t
    -19t
    122t
    -71t
    -57t
    -110t
    66t
    18t
    24t
    77t
    67t
    -77t
    61t
    -105t
    -38t
    -112t
    108t
    -40t
    48t
    78t
    -39t
    31t
    -81t
    103t
    -76t
    -15t
    14t
    -118t
    127t
    -25t
    -64t
    22t
    51t
    -18t
    -71t
    112t
    -114t
    76t
    82t
    -58t
    59t
    -99t
    12t
    0t
    -108t
    -90t
    -24t
    22t
    -10t
    112t
    39t
    -46t
    72t
    -48t
    -14t
    -12t
    116t
    11t
    5t
    57t
    91t
    -37t
    91t
    8t
    -122t
    -109t
    -32t
    -20t
    90t
    11t
    -125t
    -27t
    6t
    93t
    83t
    -54t
    -51t
    -27t
    78t
    -59t
    15t
    78t
    89t
    -23t
    -30t
    118t
    97t
    33t
    20t
    -41t
    -49t
    -37t
    64t
    -122t
    -107t
    -69t
    -31t
    -17t
    -35t
    40t
    -101t
    68t
    58t
    -114t
    -102t
    -55t
    -46t
    111t
    -53t
    -1t
    53t
    14t
    50t
    -34t
    16t
    117t
    116t
    108t
    93t
    -91t
    62t
    -31t
    46t
    -116t
    4t
    85t
    -59t
    92t
    -115t
    43t
    116t
    114t
    -23t
    -99t
    -4t
    28t
    115t
    83t
    -10t
    -120t
    -94t
    108t
    -79t
    121t
    -118t
    118t
    -43t
    108t
    126t
    58t
    56t
    108t
    -99t
    -60t
    -7t
    -110t
    127t
    93t
    -74t
    14t
    70t
    -14t
    -49t
    52t
    18t
    116t
    29t
    -75t
    84t
    62t
    64t
    -8t
    -53t
    -48t
    -108t
    -28t
    5t
    -117t
    110t
    60t
    59t
    -102t
    -13t
    49t
    112t
    -111t
    -54t
    87t
    -36t
    63t
    85t
    31t
    -8t
    -27t
    -95t
    -55t
    -21t
    115t
    78t
    -27t
    -105t
    -92t
    92t
    -89t
    -31t
    35t
    91t
    -8t
    71t
    75t
    -105t
    94t
    -69t
    41t
    -118t
    25t
    -105t
    -60t
    -4t
    -86t
    -19t
    -13t
    26t
    64t
    114t
    -119t
    119t
    -87t
    -23t
    -90t
    116t
    106t
    123t
    121t
    -63t
    69t
    16t
    84t
    -99t
    123t
    -79t
    62t
    -59t
    -112t
    111t
    -106t
    35t
    95t
    -18t
    -45t
    -70t
    -45t
    39t
    18t
    37t
    -96t
    -109t
    81t
    -65t
    -35t
    105t
    -76t
    126t
    -119t
    -2t
    -33t
    35t
    30t
    -13t
    44t
    -47t
    -83t
    53t
    -51t
    -104t
    -128t
    -41t
    31t
    -95t
    15t
    -15t
    -124t
    -108t
    -94t
    22t
    -122t
    -95t
    -85t
    5t
    -52t
    89t
    -76t
    -4t
    -22t
    -33t
    111t
    80t
    -51t
    -85t
    33t
    113t
    -68t
    90t
    124t
    0t
    -41t
    -22t
    15t
    9t
    26t
    121t
    -100t
    -62t
    -77t
    46t
    -108t
    -123t
    23t
    -122t
    25t
    -27t
    28t
    -97t
    -56t
    -66t
    -81t
    48t
    -63t
    -26t
    -66t
    21t
    -87t
    -86t
    85t
    -121t
    -107t
    85t
    -109t
    127t
    -29t
    88t
    -9t
    -53t
    -104t
    -49t
    29t
    -115t
    -124t
    94t
    20t
    -101t
    -104t
    -22t
    123t
    -54t
    -70t
    -91t
    121t
    -75t
    -66t
    72t
    108t
    -64t
    -40t
    97t
    -35t
    108t
    26t
    -90t
    35t
    -111t
    78t
    51t
    37t
    78t
    -26t
    -121t
    38t
    126t
    23t
    -76t
    46t
    97t
    32t
    -26t
    35t
    14t
    87t
    79t
    118t
    -27t
    -2t
    77t
    -38t
    74t
    -94t
    -28t
    90t
    -17t
    69t
    47t
    -79t
    91t
    -120t
    -9t
    38t
    -72t
    63t
    -35t
    73t
    65t
    36t
    30t
    -11t
    88t
    46t
    76t
    29t
    63t
    65t
    102t
    -15t
    106t
    24t
    69t
    104t
    -109t
    9t
    -120t
    -4t
    -71t
    43t
    65t
    -73t
    -40t
    1t
    99t
    72t
    -96t
    39t
    109t
    37t
    62t
    -88t
    -116t
    52t
    -69t
    119t
    29t
    -52t
    8t
    -58t
    64t
    -40t
    29t
    -120t
    -94t
    49t
    108t
    57t
    26t
    -54t
    68t
    -11t
    -125t
    43t
    11t
    -119t
    -42t
    77t
    -55t
    -84t
    -3t
    26t
    -24t
    -100t
    -66t
    118t
    33t
    -73t
    -86t
    41t
    35t
    84t
    40t
    15t
    -118t
    127t
    -36t
    -6t
    -65t
    99t
    -40t
    -13t
    102t
    126t
    -82t
    -21t
    109t
    -95t
    -114t
    -79t
    -48t
    81t
    121t
    -27t
    81t
    -118t
    32t
    -39t
    -77t
    100t
    -113t
    -5t
    -115t
    58t
    50t
    -69t
    -127t
    -39t
    -117t
    -36t
    20t
    -62t
    -96t
    96t
    -100t
    -109t
    98t
    -94t
    82t
    95t
    98t
    93t
    11t
    -121t
    -5t
    5t
    94t
    -114t
    38t
    -80t
    82t
    36t
    -46t
    85t
    118t
    -33t
    44t
    110t
    28t
    17t
    120t
    16t
    -40t
    -87t
    -4t
    -49t
    72t
    -82t
    113t
    -1t
    14t
    92t
    -65t
    80t
    -14t
    124t
    -120t
    25t
    121t
    29t
    63t
    8t
    -34t
    105t
    -101t
    -38t
    11t
    114t
    -30t
    67t
    -34t
    32t
    -41t
    -99t
    35t
    6t
    23t
    56t
    110t
    12t
    -12t
    -29t
    -62t
    107t
    125t
    -108t
    -38t
    62t
    -22t
    93t
    -28t
    -65t
    -87t
    -53t
    71t
    37t
    -30t
    -93t
    112t
    113t
    -4t
    107t
    33t
    -101t
    -65t
    104t
    -43t
    -119t
    -3t
    119t
    101t
    -17t
    -81t
    -119t
    -9t
    -62t
    24t
    -126t
    -124t
    -87t
    107t
    123t
    -100t
    -30t
    27t
    113t
    -15t
    -63t
    -67t
    -72t
    -2t
    84t
    -63t
    -86t
    -58t
    69t
    -106t
    -63t
    -45t
    23t
    -42t
    123t
    -23t
    -83t
    113t
    -107t
    39t
    -76t
    107t
    60t
    23t
    -26t
    63t
    -41t
    42t
    -20t
    -94t
    91t
    97t
    -127t
    -7t
    -85t
    -17t
    107t
    124t
    22t
    -39t
    53t
    -90t
    120t
    -104t
    -120t
    -59t
    112t
    96t
    19t
    92t
    65t
    -60t
    -119t
    -10t
    -94t
    -95t
    -88t
    -38t
    10t
    102t
    -37t
    124t
    4t
    81t
    -119t
    113t
    43t
    52t
    63t
    -7t
    -88t
    -48t
    -53t
    -123t
    103t
    -74t
    -92t
    -28t
    70t
    -86t
    8t
    -28t
    117t
    -107t
    -55t
    -23t
    23t
    7t
    44t
    127t
    66t
    -46t
    7t
    64t
    32t
    -113t
    -83t
    60t
    71t
    3t
    -5t
    -73t
    -14t
    -14t
    -42t
    -44t
    49t
    -17t
    74t
    -102t
    115t
    -50t
    66t
    87t
    -44t
    85t
    2t
    23t
    -97t
    52t
    4t
    -19t
    -52t
    -112t
    26t
    123t
    -47t
    45t
    -121t
    99t
    -9t
    -90t
    -39t
    68t
    86t
    -63t
    25t
    9t
    -98t
    -52t
    76t
    116t
    -118t
    95t
    -55t
    0t
    28t
    -66t
    -12t
    -87t
    2t
    17t
    18t
    -81t
    56t
    106t
    -5t
    57t
    -30t
    117t
    71t
    92t
    0t
    -48t
    13t
    -68t
    -61t
    -57t
    122t
    40t
    120t
    77t
    117t
    -116t
    -108t
    34t
    103t
    94t
    64t
    -53t
    44t
    123t
    -14t
    -68t
    -33t
    50t
    106t
    -60t
    54t
    -83t
    35t
    -62t
    -8t
    -15t
    13t
    111t
    -118t
    69t
    93t
    26t
    44t
    36t
    73t
    -14t
    -56t
    -118t
    59t
    70t
    117t
    -11t
    -74t
    -127t
    -127t
    -6t
    -93t
    -48t
    88t
    -74t
    41t
    21t
    -10t
    -49t
    114t
    63t
    -37t
    62t
    70t
    39t
    -26t
    73t
    58t
    125t
    -7t
    -81t
    -79t
    -13t
    102t
    -36t
    -1t
    -10t
    -46t
    48t
    -122t
    73t
    36t
    -5t
    42t
    80t
    -62t
    -52t
    31t
    88t
    100t
    -7t
    96t
    36t
    -119t
    -37t
    -119t
    48t
    -2t
    -73t
    95t
    83t
    -3t
    105t
    -22t
    -28t
    -52t
    26t
    22t
    -70t
    -126t
    54t
    17t
    99t
    -2t
    -123t
    -15t
    -23t
    -39t
    -20t
    -46t
    127t
    -99t
    8t
    64t
    75t
    -84t
    -115t
    23t
    -27t
    92t
    -77t
    -11t
    52t
    42t
    73t
    -99t
    11t
    1t
    -54t
    -128t
    67t
    15t
    -121t
    49t
    -18t
    57t
    -124t
    -85t
    -29t
    1t
    -53t
    1t
    101t
    95t
    60t
    115t
    -95t
    44t
    -5t
    119t
    -117t
    83t
    -114t
    -24t
    -38t
    -55t
    85t
    -72t
    -57t
    36t
    8t
    91t
    -101t
    -13t
    59t
    4t
    40t
    -102t
    -23t
    -8t
    -47t
    -27t
    -89t
    23t
    109t
    -30t
    -119t
    87t
    96t
    78t
    -96t
    -22t
    41t
    16t
    0t
    91t
    100t
    115t
    8t
    77t
    51t
    119t
    124t
    -52t
    -50t
    -99t
    -16t
    69t
    54t
    -127t
    113t
    -104t
    72t
    109t
    31t
    26t
    -71t
    -59t
    -87t
    50t
    -125t
    69t
    68t
    74t
    -105t
    0t
    -51t
    1t
    -2t
    -75t
    102t
    22t
    -89t
    -120t
    50t
    -60t
    -9t
    -76t
    -32t
    -14t
    122t
    102t
    -113t
    -23t
    116t
    -2t
    119t
    -56t
    12t
    -8t
    -32t
    82t
    116t
    -80t
    13t
    -65t
    96t
    -65t
    28t
    -41t
    72t
    73t
    -33t
    -119t
    124t
    -118t
    25t
    -6t
    -76t
    -55t
    -125t
    57t
    6t
    52t
    110t
    -38t
    -69t
    36t
    19t
    -117t
    39t
    117t
    85t
    12t
    112t
    79t
    -105t
    75t
    -25t
    -8t
    56t
    -9t
    -40t
    -96t
    13t
    -27t
    122t
    -119t
    -53t
    -88t
    -125t
    73t
    -20t
    110t
    43t
    101t
    19t
    123t
    43t
    -90t
    31t
    61t
    -13t
    84t
    -45t
    95t
    -61t
    -55t
    37t
    -13t
    -44t
    113t
    106t
    64t
    -66t
    -53t
    48t
    -78t
    108t
    -33t
    43t
    59t
    -100t
    -9t
    -108t
    122t
    -9t
    -7t
    127t
    -54t
    -77t
    53t
    111t
    -127t
    -85t
    66t
    78t
    -10t
    -103t
    106t
    -98t
    124t
    85t
    -23t
    -84t
    6t
    -88t
    96t
    35t
    -56t
    -23t
    110t
    -64t
    -114t
    -41t
    50t
    -33t
    59t
    76t
    -26t
    -35t
    103t
    -43t
    -77t
    -6t
    -41t
    46t
    127t
    81t
    25t
    82t
    60t
    -85t
    -83t
    56t
    121t
    -112t
    -59t
    -45t
    -36t
    -122t
    13t
    -128t
    -103t
    -24t
    62t
    21t
    29t
    -121t
    -97t
    54t
    25t
    -34t
    -23t
    21t
    -22t
    -52t
    43t
    33t
    -105t
    -111t
    -31t
    93t
    27t
    39t
    38t
    117t
    -9t
    -106t
    77t
    -75t
    -88t
    -52t
    -17t
    -49t
    -30t
    22t
    -24t
    85t
    32t
    -10t
    87t
    9t
    122t
    -53t
    -82t
    -128t
    121t
    63t
    31t
    -93t
    70t
    -87t
    49t
    110t
    -105t
    -21t
    -71t
    79t
    -40t
    -82t
    10t
    117t
    -121t
    59t
    19t
    -50t
    46t
    -119t
    -75t
    54t
    9t
    -45t
    32t
    -102t
    -28t
    111t
    -94t
    73t
    -15t
    114t
    -24t
    127t
    41t
    21t
    -39t
    -58t
    80t
    91t
    111t
    38t
    24t
    84t
    17t
    61t
    -17t
    -78t
    -108t
    -7t
    15t
    -24t
    2t
    -81t
    -127t
    97t
    -98t
    -121t
    -91t
    -17t
    61t
    -78t
    -84t
    -88t
    46t
    101t
    127t
    16t
    -19t
    49t
    -108t
    1t
    -14t
    -95t
    26t
    55t
    41t
    33t
    -74t
    76t
    -45t
    -108t
    35t
    -9t
    39t
    -87t
    -25t
    113t
    -65t
    98t
    -90t
    114t
    -120t
    44t
    -57t
    52t
    -36t
    49t
    -114t
    -119t
    61t
    82t
    58t
    -28t
    -109t
    15t
    -59t
    82t
    65t
    29t
    -107t
    43t
    48t
    86t
    24t
    -104t
    28t
    127t
    -54t
    -59t
    1t
    122t
    121t
    68t
    102t
    -118t
    95t
    -121t
    97t
    90t
    -49t
    -105t
    82t
    10t
    -95t
    25t
    -29t
    15t
    -128t
    -121t
    93t
    -115t
    -128t
    -126t
    26t
    106t
    111t
    90t
    -18t
    114t
    123t
    86t
    -62t
    37t
    96t
    81t
    -32t
    35t
    106t
    -36t
    -47t
    -117t
    91t
    1t
    32t
    0t
    -41t
    82t
    23t
    -19t
    -126t
    46t
    118t
    51t
    -85t
    53t
    124t
    42t
    -19t
    7t
    -61t
    -14t
    44t
    -23t
    -121t
    19t
    -108t
    73t
    -9t
    4t
    -13t
    114t
    35t
    -33t
    46t
    16t
    122t
    -89t
    119t
    51t
    -120t
    113t
    8t
    -35t
    29t
    5t
    63t
    -30t
    -52t
    39t
    -25t
    -65t
    29t
    -78t
    -48t
    -20t
    79t
    87t
    -45t
    4t
    125t
    -82t
    -53t
    88t
    122t
    -13t
    -79t
    122t
    68t
    93t
    13t
    114t
    -100t
    -88t
    -112t
    83t
    -107t
    8t
    -76t
    114t
    -58t
    -98t
    -9t
    114t
    -3t
    -31t
    76t
    -15t
    122t
    90t
    39t
    55t
    -16t
    -47t
    32t
    117t
    -105t
    -68t
    -117t
    25t
    -75t
    98t
    -92t
    74t
    -95t
    -45t
    10t
    -69t
    94t
    -59t
    -111t
    92t
    24t
    -42t
    88t
    4t
    -20t
    -25t
    -86t
    24t
    -62t
    75t
    102t
    -122t
    -53t
    95t
    20t
    -73t
    10t
    2t
    60t
    15t
    -40t
    -108t
    59t
    56t
    86t
    -8t
    39t
    -128t
    19t
    -107t
    81t
    16t
    -31t
    26t
    120t
    25t
    113t
    -98t
    127t
    -93t
    -50t
    82t
    67t
    26t
    16t
    16t
    -66t
    -22t
    -118t
    58t
    12t
    -88t
    -25t
    -112t
    101t
    32t
    52t
    90t
    124t
    81t
    -80t
    65t
    8t
    47t
    -29t
    -124t
    43t
    -92t
    -24t
    44t
    32t
    -91t
    -64t
    -21t
    117t
    41t
    115t
    76t
    -27t
    -11t
    -9t
    -123t
    42t
    110t
    89t
    5t
    120t
    -72t
    67t
    59t
    89t
    -118t
    50t
    -125t
    71t
    -62t
    48t
    19t
    96t
    -128t
    98t
    56t
    50t
    17t
    4t
    112t
    -68t
    75t
    53t
    86t
    -103t
    -21t
    -25t
    44t
    25t
    -125t
    -74t
    -63t
    121t
    2t
    3t
    -96t
    -12t
    121t
    -32t
    -122t
    58t
    56t
    69t
    -122t
    87t
    68t
    28t
    94t
    -37t
    -88t
    65t
    24t
    116t
    -83t
    -118t
    -28t
    -70t
    -109t
    -28t
    109t
    -76t
    -128t
    -101t
    64t
    58t
    87t
    14t
    119t
    -67t
    -87t
    -4t
    -75t
    127t
    -127t
    -13t
    115t
    -81t
    77t
    -121t
    75t
    37t
    -86t
    -1t
    -46t
    18t
    68t
    -113t
    -66t
    -45t
    -84t
    94t
    -87t
    27t
    -95t
    -54t
    11t
    31t
    49t
    -40t
    2t
    -101t
    -1t
    -82t
    -87t
    0t
    118t
    1t
    8t
    -54t
    -9t
    -63t
    55t
    -53t
    -73t
    94t
    52t
    -25t
    72t
    51t
    28t
    -18t
    89t
    96t
    23t
    97t
    5t
    66t
    48t
    8t
    43t
    8t
    -27t
    -109t
    -9t
    -9t
    -41t
    113t
    76t
    -57t
    22t
    95t
    -100t
    -51t
    -2t
    -52t
    -55t
    -88t
    110t
    -38t
    64t
    -51t
    105t
    122t
    22t
    107t
    -105t
    -74t
    -1t
    -106t
    106t
    -119t
    -103t
    -58t
    7t
    81t
    53t
    25t
    111t
    -67t
    -25t
    -122t
    -68t
    -7t
    63t
    78t
    -117t
    -32t
    -50t
    -116t
    -13t
    -3t
    -47t
    -83t
    -28t
    118t
    55t
    123t
    -117t
    89t
    -78t
    -70t
    -28t
    -30t
    99t
    -100t
    70t
    103t
    81t
    46t
    65t
    -81t
    100t
    -110t
    -19t
    -20t
    60t
    30t
    -2t
    -50t
    -62t
    8t
    61t
    -93t
    46t
    -81t
    5t
    42t
    -63t
    97t
    83t
    43t
    98t
    11t
    29t
    16t
    -97t
    -74t
    -69t
    -10t
    -86t
    26t
    -98t
    -110t
    -9t
    48t
    -35t
    103t
    -26t
    20t
    -109t
    -67t
    -78t
    -34t
    -38t
    -26t
    -94t
    -14t
    -85t
    -18t
    88t
    -120t
    -49t
    -52t
    -37t
    -45t
    81t
    -121t
    -69t
    -65t
    -85t
    86t
    -117t
    -71t
    48t
    101t
    -106t
    -13t
    51t
    81t
    14t
    -84t
    -6t
    77t
    -6t
    28t
    88t
    69t
    -81t
    104t
    122t
    -16t
    79t
    -87t
    112t
    -47t
    -74t
    -11t
    14t
    90t
    -126t
    -78t
    97t
    -102t
    -76t
    100t
    29t
    109t
    122t
    102t
    59t
    -29t
    117t
    -31t
    -106t
    61t
    4t
    -3t
    -10t
    -102t
    -56t
    91t
    15t
    -116t
    -83t
    -27t
    26t
    -110t
    -44t
    67t
    14t
    101t
    113t
    -88t
    69t
    -30t
    -93t
    -107t
    -125t
    -73t
    8t
    73t
    70t
    97t
    118t
    104t
    -20t
    -53t
    -80t
    71t
    93t
    2t
    90t
    -19t
    40t
    57t
    -3t
    105t
    -46t
    54t
    -81t
    -59t
    -64t
    29t
    42t
    44t
    -103t
    42t
    -67t
    -79t
    -82t
    100t
    93t
    62t
    -8t
    15t
    -84t
    47t
    89t
    0t
    99t
    -77t
    64t
    -74t
    -46t
    -26t
    102t
    64t
    41t
    -5t
    -14t
    -26t
    106t
    -37t
    17t
    -53t
    -25t
    -99t
    95t
    77t
    105t
    118t
    3t
    123t
    -103t
    -127t
    89t
    89t
    -109t
    -81t
    27t
    100t
    67t
    92t
    122t
    5t
    102t
    -34t
    65t
    118t
    121t
    -21t
    -44t
    34t
    52t
    78t
    81t
    -109t
    123t
    -11t
    -127t
    39t
    114t
    -123t
    0t
    54t
    -19t
    -22t
    90t
    50t
    113t
    92t
    -116t
    13t
    42t
    117t
    112t
    19t
    -27t
    -117t
    -64t
    -53t
    -69t
    -70t
    -128t
    -75t
    -10t
    0t
    89t
    78t
    42t
    28t
    50t
    -25t
    69t
    1t
    97t
    -51t
    -84t
    27t
    4t
    91t
    17t
    3t
    -108t
    94t
    -41t
    78t
    26t
    98t
    -5t
    116t
    -25t
    -73t
    5t
    -122t
    -112t
    -21t
    -65t
    -53t
    127t
    -77t
    59t
    -97t
    15t
    58t
    28t
    -121t
    -113t
    -80t
    115t
    -57t
    -76t
    -4t
    -71t
    106t
    103t
    -63t
    29t
    32t
    15t
    -108t
    118t
    9t
    -38t
    122t
    -54t
    47t
    85t
    10t
    59t
    14t
    63t
    -44t
    92t
    -63t
    76t
    60t
    -9t
    53t
    -86t
    -46t
    -58t
    -75t
    98t
    24t
    -67t
    107t
    -79t
    65t
    -58t
    24t
    102t
    -63t
    50t
    -36t
    31t
    66t
    -75t
    -110t
    113t
    -55t
    -15t
    -39t
    66t
    18t
    -101t
    -78t
    -109t
    -22t
    96t
    -51t
    68t
    111t
    41t
    14t
    30t
    123t
    49t
    89t
    -46t
    -105t
    31t
    102t
    19t
    -45t
    -88t
    -43t
    86t
    121t
    -64t
    50t
    -75t
    -71t
    31t
    -110t
    13t
    -101t
    59t
    14t
    101t
    41t
    111t
    -17t
    20t
    -46t
    70t
    116t
    -43t
    -90t
    -111t
    -85t
    53t
    52t
    17t
    -65t
    -111t
    68t
    -70t
    124t
    -66t
    -76t
    122t
    -1t
    68t
    112t
    -9t
    -27t
    -92t
    79t
    116t
    -53t
    88t
    28t
    -94t
    -103t
    -86t
    -66t
    -32t
    75t
    -124t
    -52t
    3t
    -69t
    83t
    -87t
    -25t
    -104t
    -61t
    -79t
    8t
    40t
    86t
    -122t
    -53t
    -77t
    -3t
    105t
    102t
    -19t
    -54t
    58t
    -20t
    -70t
    -73t
    -125t
    -106t
    101t
    62t
    -63t
    -100t
    82t
    42t
    22t
    70t
    76t
    37t
    -90t
    125t
    -21t
    119t
    62t
    99t
    40t
    -15t
    63t
    116t
    46t
    50t
    -115t
    -122t
    84t
    -50t
    -4t
    18t
    110t
    -81t
    3t
    66t
    22t
    78t
    75t
    11t
    107t
    117t
    95t
    26t
    -94t
    3t
    -5t
    89t
    5t
    88t
    -33t
    -122t
    -83t
    -31t
    -90t
    -78t
    104t
    -86t
    -46t
    116t
    28t
    -120t
    64t
    -66t
    89t
    -39t
    84t
    -6t
    -76t
    57t
    -11t
    -100t
    -2t
    73t
    27t
    -107t
    -52t
    -96t
    107t
    -48t
    -66t
    -9t
    103t
    98t
    50t
    -71t
    111t
    -35t
    -47t
    123t
    92t
    7t
    -66t
    -99t
    34t
    -32t
    124t
    -73t
    -78t
    116t
    -123t
    -39t
    -33t
    77t
    64t
    -39t
    7t
    15t
    -55t
    -105t
    36t
    -115t
    -93t
    71t
    7t
    14t
    13t
    45t
    32t
    -112t
    -96t
    -35t
    110t
    35t
    -118t
    -85t
    98t
    28t
    82t
    89t
    -47t
    34t
    -86t
    12t
    111t
    -18t
    -114t
    30t
    -99t
    62t
    -53t
    127t
    -1t
    -55t
    -126t
    -80t
    0t
    31t
    -37t
    110t
    -111t
    11t
    -119t
    104t
    105t
    -13t
    42t
    -71t
    32t
    -37t
    43t
    -96t
    -97t
    100t
    -84t
    -76t
    -83t
    82t
    57t
    -40t
    -33t
    86t
    -74t
    -48t
    51t
    -69t
    -89t
    26t
    -115t
    -104t
    121t
    84t
    -81t
    122t
    -95t
    126t
    -15t
    57t
    30t
    -29t
    -83t
    -89t
    -25t
    91t
    87t
    59t
    86t
    -126t
    -81t
    34t
    34t
    63t
    -83t
    116t
    -23t
    -60t
    -14t
    105t
    -17t
    -94t
    98t
    -15t
    41t
    -58t
    -94t
    25t
    100t
    -49t
    -67t
    60t
    58t
    7t
    55t
    20t
    30t
    -116t
    67t
    -125t
    -81t
    -43t
    -36t
    89t
    -30t
    114t
    119t
    79t
    -89t
    50t
    115t
    36t
    -35t
    -26t
    -40t
    25t
    -60t
    65t
    101t
    -73t
    112t
    -17t
    -73t
    11t
    -82t
    -58t
    -32t
    45t
    -26t
    -10t
    -50t
    -18t
    -49t
    -38t
    -24t
    18t
    76t
    75t
    117t
    110t
    125t
    53t
    -37t
    -125t
    -108t
    10t
    -41t
    -79t
    73t
    9t
    44t
    78t
    -27t
    -64t
    -124t
    112t
    -90t
    -19t
    -29t
    -74t
    -107t
    -17t
    14t
    -112t
    116t
    -93t
    -90t
    8t
    -13t
    -40t
    36t
    -119t
    -78t
    63t
    -91t
    24t
    114t
    116t
    22t
    28t
    30t
    -49t
    48t
    70t
    -41t
    -126t
    21t
    108t
    -98t
    45t
    -63t
    -98t
    -28t
    81t
    85t
    -74t
    78t
    -127t
    89t
    56t
    -103t
    -126t
    43t
    -128t
    -76t
    123t
    59t
    -67t
    65t
    -26t
    3t
    -113t
    34t
    24t
    -24t
    -9t
    68t
    1t
    -115t
    46t
    -48t
    -119t
    41t
    -40t
    -11t
    -67t
    103t
    -52t
    126t
    -4t
    88t
    -85t
    -69t
    -7t
    -76t
    71t
    19t
    122t
    98t
    121t
    -3t
    -4t
    -25t
    106t
    34t
    -125t
    62t
    113t
    -62t
    -116t
    71t
    -30t
    117t
    64t
    127t
    -124t
    -1t
    102t
    126t
    82t
    34t
    -94t
    79t
    -66t
    88t
    7t
    -123t
    120t
    -92t
    122t
    -103t
    22t
    98t
    -97t
    96t
    5t
    -87t
    -9t
    -128t
    113t
    -116t
    -61t
    7t
    -22t
    8t
    -59t
    20t
    27t
    -34t
    0t
    -71t
    -27t
    -62t
    85t
    -105t
    -126t
    57t
    16t
    55t
    -11t
    -22t
    -66t
    -30t
    1t
    -93t
    -121t
    -85t
    66t
    -81t
    27t
    103t
    92t
    16t
    102t
    -71t
    43t
    111t
    -46t
    -44t
    -125t
    105t
    -98t
    -110t
    -8t
    21t
    -36t
    -107t
    -85t
    118t
    -83t
    -67t
    70t
    7t
    -64t
    -113t
    117t
    114t
    -104t
    36t
    -76t
    41t
    -14t
    -52t
    98t
    65t
    -81t
    -107t
    63t
    -29t
    42t
    52t
    115t
    29t
    -113t
    -71t
    117t
    -105t
    101t
    76t
    33t
    97t
    80t
    -88t
    -126t
    116t
    -113t
    49t
    58t
    -46t
    -117t
    32t
    -89t
    114t
    -86t
    -95t
    -91t
    64t
    58t
    20t
    87t
    60t
    -10t
    41t
    -128t
    -125t
    20t
    -85t
    -51t
    91t
    53t
    -42t
    18t
    -106t
    -38t
    97t
    -58t
    -71t
    -57t
    22t
    -113t
    -49t
    -80t
    -63t
    93t
    60t
    61t
    -70t
    70t
    -24t
    34t
    49t
    -40t
    -21t
    -73t
    -117t
    12t
    -122t
    26t
    15t
    -8t
    102t
    -82t
    75t
    -9t
    -74t
    -71t
    25t
    103t
    -53t
    -23t
    89t
    106t
    -65t
    14t
    126t
    52t
    124t
    86t
    -92t
    -12t
    -9t
    119t
    -116t
    -71t
    -21t
    103t
    -59t
    41t
    53t
    -18t
    17t
    67t
    -114t
    106t
    -46t
    -2t
    35t
    -59t
    74t
    95t
    87t
    64t
    73t
    -52t
    -43t
    -35t
    -95t
    54t
    -3t
    56t
    -15t
    -49t
    20t
    10t
    22t
    -67t
    113t
    -112t
    111t
    98t
    -14t
    -28t
    109t
    119t
    -120t
    -90t
    -32t
    -89t
    46t
    -65t
    78t
    106t
    -75t
    -108t
    -97t
    103t
    -86t
    -128t
    -28t
    -42t
    -72t
    80t
    -52t
    39t
    -101t
    -127t
    -22t
    12t
    -74t
    89t
    45t
    70t
    -44t
    -70t
    43t
    -6t
    -91t
    -108t
    125t
    -58t
    68t
    117t
    40t
    83t
    -28t
    115t
    -102t
    -81t
    108t
    111t
    -118t
    -101t
    98t
    -56t
    102t
    -14t
    -18t
    9t
    -92t
    -126t
    108t
    -78t
    -93t
    -75t
    -49t
    95t
    13t
    56t
    78t
    26t
    67t
    -83t
    -71t
    64t
    -85t
    -109t
    -98t
    -78t
    -3t
    -127t
    -67t
    -96t
    121t
    -5t
    73t
    -102t
    121t
    -39t
    -4t
    30t
    -65t
    -99t
    84t
    -45t
    -84t
    43t
    100t
    -106t
    -8t
    59t
    -78t
    18t
    -86t
    30t
    -63t
    97t
    58t
    -125t
    -96t
    -97t
    84t
    6t
    -13t
    86t
    -2t
    -121t
    119t
    -90t
    -7t
    113t
    -24t
    56t
    55t
    87t
    102t
    84t
    66t
    52t
    110t
    -14t
    118t
    42t
    -104t
    38t
    -119t
    60t
    -103t
    -121t
    -10t
    -84t
    85t
    59t
    111t
    -102t
    -9t
    50t
    70t
    111t
    -116t
    23t
    23t
    54t
    20t
    -73t
    -64t
    30t
    -105t
    -107t
    -31t
    93t
    -23t
    -102t
    94t
    15t
    -26t
    11t
    -109t
    -22t
    90t
    -34t
    30t
    -123t
    117t
    -62t
    -20t
    12t
    -35t
    7t
    -70t
    -7t
    57t
    -31t
    -76t
    -76t
    -118t
    21t
    -90t
    -102t
    -89t
    81t
    -50t
    89t
    -22t
    -9t
    -53t
    17t
    -10t
    49t
    40t
    -113t
    -114t
    41t
    -62t
    91t
    23t
    -126t
    -76t
    67t
    -25t
    -85t
    -32t
    117t
    -79t
    -112t
    50t
    122t
    79t
    12t
    32t
    -12t
    -102t
    109t
    -18t
    -116t
    -58t
    -80t
    30t
    57t
    -84t
    -52t
    -117t
    114t
    67t
    -71t
    16t
    51t
    99t
    -77t
    -29t
    -40t
    -23t
    -55t
    -11t
    50t
    127t
    95t
    92t
    61t
    84t
    -107t
    -111t
    38t
    -20t
    46t
    -109t
    63t
    -108t
    18t
    24t
    -18t
    -59t
    -85t
    -77t
    -102t
    61t
    50t
    86t
    102t
    127t
    34t
    -122t
    29t
    -67t
    87t
    54t
    53t
    43t
    53t
    113t
    -1t
    30t
    18t
    -18t
    -117t
    117t
    -94t
    19t
    78t
    -75t
    -66t
    41t
    38t
    78t
    118t
    46t
    76t
    93t
    -72t
    -118t
    77t
    -18t
    -114t
    96t
    -89t
    -12t
    54t
    -77t
    -67t
    111t
    -75t
    91t
    77t
    15t
    -116t
    -102t
    -79t
    28t
    50t
    30t
    66t
    18t
    -90t
    -112t
    -14t
    22t
    91t
    64t
    98t
    -96t
    -106t
    -88t
    127t
    85t
    -8t
    26t
    13t
    84t
    -62t
    44t
    27t
    -3t
    46t
    100t
    70t
    -23t
    -7t
    18t
    70t
    106t
    6t
    15t
    13t
    -115t
    20t
    -28t
    114t
    -120t
    28t
    120t
    -34t
    -70t
    -25t
    -65t
    4t
    39t
    127t
    117t
    -84t
    12t
    64t
    -67t
    7t
    31t
    -4t
    -109t
    -127t
    108t
    -80t
    -93t
    79t
    102t
    -12t
    24t
    -21t
    25t
    104t
    -28t
    93t
    -101t
    -15t
    -96t
    -30t
    85t
    -96t
    -43t
    26t
    117t
    102t
    99t
    105t
    123t
    -46t
    81t
    -120t
    -64t
    -74t
    -3t
    -56t
    -114t
    23t
    45t
    18t
    -9t
    -76t
    -22t
    21t
    -24t
    -68t
    25t
    8t
    69t
    -103t
    17t
    123t
    4t
    49t
    60t
    38t
    -97t
    120t
    90t
    -115t
    85t
    -23t
    -115t
    -11t
    -90t
    -23t
    -35t
    59t
    37t
    -120t
    69t
    39t
    68t
    -76t
    -101t
    123t
    -83t
    95t
    20t
    -127t
    84t
    -35t
    116t
    42t
    -41t
    -75t
    11t
    -21t
    -89t
    -7t
    -82t
    -73t
    125t
    124t
    66t
    104t
    -66t
    38t
    -103t
    27t
    86t
    17t
    7t
    -12t
    21t
    -100t
    -44t
    25t
    100t
    -44t
    113t
    90t
    -29t
    28t
    36t
    109t
    -76t
    -6t
    55t
    -7t
    55t
    -49t
    -40t
    71t
    109t
    57t
    45t
    48t
    39t
    55t
    -65t
    -108t
    -78t
    -19t
    -82t
    55t
    7t
    5t
    102t
    89t
    -52t
    -123t
    -46t
    -71t
    75t
    -113t
    80t
    -103t
    -107t
    78t
    13t
    101t
    124t
    37t
    6t
    -117t
    -124t
    -82t
    -67t
    -38t
    -125t
    -82t
    -42t
    -105t
    116t
    -86t
    127t
    34t
    -88t
    26t
    -77t
    26t
    10t
    -39t
    -14t
    84t
    -23t
    -81t
    102t
    30t
    -106t
    65t
    -95t
    -93t
    17t
    61t
    81t
    -73t
    -82t
    -27t
    28t
    -63t
    55t
    105t
    -22t
    108t
    67t
    111t
    -5t
    10t
    32t
    -91t
    -61t
    43t
    -34t
    -23t
    38t
    -120t
    112t
    57t
    -1t
    39t
    58t
    -99t
    -79t
    24t
    113t
    -71t
    95t
    -51t
    -31t
    -63t
    -74t
    -28t
    -110t
    38t
    -7t
    45t
    -12t
    -27t
    63t
    28t
    -13t
    110t
    89t
    -44t
    -106t
    40t
    -13t
    87t
    -81t
    69t
    13t
    125t
    53t
    -70t
    -44t
    -101t
    102t
    26t
    117t
    123t
    71t
    -26t
    87t
    22t
    -93t
    78t
    -50t
    56t
    -20t
    111t
    -21t
    52t
    -56t
    -85t
    -42t
    120t
    3t
    -53t
    8t
    38t
    -15t
    -6t
    -96t
    30t
    109t
    -58t
    29t
    -120t
    -9t
    -84t
    -50t
    57t
    111t
    6t
    15t
    14t
    111t
    125t
    88t
    -93t
    37t
    45t
    -11t
    23t
    19t
    105t
    -27t
    -50t
    47t
    9t
    -34t
    -8t
    53t
    -13t
    105t
    54t
    126t
    9t
    -95t
    59t
    62t
    -122t
    -106t
    65t
    46t
    7t
    18t
    -13t
    -48t
    -126t
    -12t
    -64t
    -94t
    98t
    71t
    34t
    -45t
    46t
    53t
    -58t
    -83t
    17t
    111t
    113t
    -16t
    9t
    16t
    11t
    76t
    80t
    -23t
    -79t
    103t
    -89t
    120t
    60t
    109t
    -72t
    8t
    -84t
    50t
    72t
    -103t
    -15t
    -114t
    -35t
    105t
    15t
    -96t
    11t
    -88t
    67t
    -74t
    1t
    62t
    102t
    126t
    88t
    -19t
    122t
    -73t
    124t
    -121t
    9t
    -74t
    45t
    -14t
    124t
    66t
    -70t
    -78t
    -1t
    69t
    64t
    -33t
    95t
    -63t
    43t
    -117t
    122t
    97t
    6t
    85t
    -106t
    -76t
    -20t
    -127t
    -116t
    6t
    33t
    -23t
    71t
    36t
    33t
    -45t
    -30t
    63t
    24t
    -47t
    -29t
    -53t
    -3t
    -24t
    36t
    -36t
    80t
    100t
    82t
    4t
    113t
    48t
    -17t
    -49t
    -66t
    93t
    79t
    3t
    47t
    -30t
    49t
    -118t
    -64t
    2t
    106t
    116t
    -20t
    -72t
    72t
    39t
    50t
    -95t
    94t
    106t
    18t
    114t
    -42t
    -116t
    -123t
    -91t
    -76t
    105t
    -93t
    50t
    32t
    106t
    -52t
    93t
    -96t
    -40t
    46t
    99t
    77t
    -71t
    -127t
    29t
    -29t
    20t
    -103t
    -2t
    -44t
    103t
    2t
    0t
    21t
    79t
    -93t
    43t
    -8t
    1t
    -32t
    -72t
    -98t
    9t
    36t
    -81t
    7t
    114t
    38t
    3t
    90t
    -41t
    -16t
    -72t
    -104t
    8t
    9t
    26t
    36t
    39t
    112t
    -82t
    47t
    -16t
    86t
    -18t
    -57t
    109t
    105t
    62t
    -94t
    57t
    5t
    -86t
    99t
    117t
    110t
    37t
    -120t
    -41t
    118t
    -66t
    -108t
    60t
    -120t
    12t
    104t
    -70t
    56t
    -52t
    16t
    43t
    -96t
    60t
    41t
    124t
    57t
    -103t
    125t
    103t
    25t
    -117t
    83t
    59t
    95t
    112t
    -55t
    90t
    91t
    -69t
    0t
    -104t
    -105t
    91t
    -26t
    77t
    26t
    29t
    -109t
    -65t
    53t
    -1t
    -82t
    118t
    -80t
    17t
    -5t
    -17t
    -11t
    114t
    -43t
    -7t
    96t
    23t
    32t
    119t
    2t
    114t
    -90t
    -4t
    34t
    12t
    -85t
    112t
    -82t
    73t
    -105t
    -62t
    62t
    -79t
    -46t
    -41t
    97t
    -126t
    -43t
    22t
    -61t
    -62t
    -106t
    10t
    81t
    85t
    65t
    18t
    99t
    -39t
    -119t
    -23t
    -73t
    -96t
    114t
    55t
    -54t
    11t
    -66t
    19t
    82t
    51t
    25t
    -14t
    12t
    49t
    42t
    -60t
    126t
    -2t
    23t
    -19t
    -79t
    -31t
    0t
    -122t
    122t
    -111t
    -12t
    53t
    -39t
    22t
    96t
    -31t
    96t
    -58t
    -13t
    74t
    40t
    47t
    -79t
    118t
    -105t
    -108t
    -54t
    -95t
    21t
    -12t
    -87t
    104t
    -104t
    77t
    45t
    40t
    -42t
    -120t
    61t
    -126t
    -22t
    -98t
    -103t
    61t
    100t
    63t
    -104t
    -87t
    -5t
    93t
    23t
    -11t
    -27t
    -20t
    36t
    -105t
    -14t
    75t
    -4t
    -114t
    -3t
    23t
    86t
    -108t
    112t
    15t
    100t
    -33t
    25t
    -128t
    98t
    -1t
    84t
    96t
    -116t
    28t
    -94t
    0t
    121t
    -83t
    111t
    122t
    76t
    -80t
    116t
    8t
    12t
    123t
    72t
    -81t
    127t
    82t
    6t
    57t
    98t
    92t
    57t
    82t
    -120t
    -23t
    114t
    21t
    99t
    -128t
    -128t
    96t
    -113t
    -74t
    -21t
    61t
    62t
    3t
    -14t
    -2t
    95t
    -21t
    -53t
    102t
    111t
    -87t
    28t
    26t
    75t
    -6t
    65t
    -53t
    -72t
    -34t
    90t
    -77t
    113t
    -40t
    11t
    94t
    -1t
    -80t
    -54t
    29t
    43t
    108t
    38t
    -10t
    5t
    36t
    -91t
    21t
    40t
    -82t
    44t
    109t
    -54t
    105t
    6t
    66t
    77t
    11t
    110t
    64t
    20t
    82t
    46t
    91t
    8t
    82t
    79t
    -116t
    -22t
    20t
    -13t
    117t
    -14t
    -44t
    78t
    -33t
    102t
    57t
    -114t
    -54t
    -20t
    102t
    -35t
    36t
    -72t
    17t
    -106t
    -39t
    79t
    -120t
    109t
    -48t
    68t
    -36t
    72t
    -115t
    -6t
    43t
    -108t
    -77t
    -88t
    100t
    68t
    25t
    -98t
    -85t
    -73t
    -52t
    -3t
    29t
    -116t
    114t
    -9t
    15t
    48t
    -20t
    29t
    103t
    58t
    -54t
    -27t
    -71t
    98t
    -48t
    -22t
    -48t
    -64t
    28t
    -94t
    -39t
    -106t
    -99t
    123t
    23t
    117t
    -122t
    30t
    12t
    -4t
    -98t
    -97t
    -66t
    -20t
    -118t
    46t
    -37t
    123t
    18t
    -103t
    14t
    70t
    117t
    -28t
    81t
    24t
    -43t
    -82t
    39t
    84t
    -55t
    -43t
    6t
    83t
    24t
    -43t
    -38t
    107t
    82t
    115t
    56t
    116t
    -76t
    57t
    -53t
    -107t
    43t
    93t
    -10t
    -39t
    -126t
    -101t
    -105t
    64t
    57t
    52t
    84t
    10t
    113t
    66t
    0t
    -54t
    -48t
    123t
    -84t
    122t
    8t
    -66t
    60t
    17t
    98t
    69t
    -46t
    -72t
    -59t
    -102t
    60t
    -82t
    53t
    -102t
    85t
    72t
    4t
    -101t
    118t
    -104t
    -20t
    18t
    48t
    87t
    -54t
    -87t
    4t
    60t
    76t
    51t
    -40t
    -62t
    -59t
    -104t
    -31t
    -118t
    99t
    -123t
    25t
    -106t
    -24t
    -13t
    -67t
    0t
    19t
    -95t
    -38t
    118t
    -52t
    -98t
    -107t
    119t
    -55t
    -84t
    -46t
    -89t
    -9t
    -93t
    -119t
    -104t
    95t
    103t
    113t
    -68t
    -5t
    35t
    126t
    -112t
    -83t
    123t
    88t
    -27t
    92t
    -9t
    -30t
    37t
    5t
    -96t
    -38t
    -64t
    -104t
    -2t
    6t
    -66t
    -53t
    -75t
    -51t
    -2t
    -1t
    19t
    -46t
    -44t
    27t
    66t
    41t
    -73t
    -29t
    -9t
    -37t
    119t
    17t
    -105t
    19t
    -111t
    48t
    6t
    33t
    94t
    -16t
    1t
    -42t
    80t
    50t
    114t
    3t
    41t
    39t
    -120t
    -77t
    37t
    -108t
    -70t
    10t
    48t
    -75t
    -111t
    43t
    60t
    -117t
    -109t
    9t
    100t
    -16t
    48t
    101t
    -33t
    -91t
    -46t
    -2t
    7t
    -96t
    127t
    37t
    71t
    -114t
    -61t
    -100t
    44t
    25t
    82t
    -71t
    114t
    116t
    -61t
    -107t
    -78t
    -24t
    -109t
    -84t
    6t
    -16t
    -117t
    -70t
    24t
    -70t
    118t
    31t
    -119t
    -22t
    -74t
    -102t
    -125t
    97t
    17t
    -33t
    7t
    -68t
    127t
    -113t
    33t
    122t
    85t
    68t
    21t
    -39t
    82t
    83t
    97t
    81t
    5t
    26t
    116t
    -34t
    83t
    70t
    -112t
    41t
    83t
    -19t
    -124t
    -101t
    77t
    123t
    82t
    -73t
    -60t
    -97t
    33t
    124t
    5t
    9t
    22t
    -29t
    -122t
    53t
    -114t
    100t
    123t
    79t
    58t
    122t
    -53t
    -63t
    -65t
    -102t
    116t
    -116t
    14t
    -109t
    38t
    8t
    -112t
    82t
    -59t
    -85t
    35t
    -121t
    -97t
    -50t
    -31t
    -63t
    1t
    85t
    -114t
    -1t
    104t
    -51t
    71t
    68t
    -30t
    19t
    -43t
    -64t
    84t
    66t
    13t
    -96t
    -116t
    -91t
    109t
    23t
    77t
    115t
    73t
    5t
    63t
    -117t
    -72t
    94t
    -120t
    88t
    125t
    88t
    116t
    -81t
    -35t
    -29t
    -55t
    -50t
    -26t
    120t
    116t
    24t
    -93t
    124t
    -94t
    100t
    -90t
    -69t
    -90t
    -82t
    112t
    -103t
    -114t
    -112t
    104t
    46t
    -100t
    -62t
    -4t
    6t
    105t
    -22t
    113t
    42t
    -78t
    -96t
    -10t
    -96t
    -14t
    77t
    6t
    28t
    -69t
    -29t
    59t
    -126t
    13t
    118t
    83t
    123t
    -86t
    -15t
    117t
    67t
    4t
    -101t
    4t
    -88t
    -39t
    122t
    -67t
    8t
    64t
    -69t
    20t
    -30t
    80t
    88t
    -87t
    -108t
    -113t
    -78t
    -31t
    63t
    15t
    46t
    81t
    27t
    114t
    61t
    8t
    -26t
    -17t
    -23t
    -47t
    -71t
    57t
    -50t
    94t
    -9t
    -103t
    -93t
    10t
    110t
    -31t
    -37t
    -100t
    80t
    77t
    23t
    69t
    31t
    21t
    -39t
    97t
    -70t
    118t
    -6t
    -38t
    -16t
    31t
    -96t
    14t
    -55t
    41t
    -66t
    -5t
    -83t
    -64t
    96t
    -82t
    -27t
    -65t
    -68t
    -95t
    64t
    81t
    108t
    -99t
    64t
    -17t
    91t
    -59t
    91t
    -20t
    -44t
    85t
    76t
    121t
    35t
    127t
    -62t
    108t
    -113t
    -83t
    -98t
    20t
    -32t
    -4t
    95t
    -102t
    -59t
    47t
    -97t
    19t
    88t
    -128t
    60t
    -84t
    -110t
    -31t
    78t
    125t
    24t
    94t
    -62t
    78t
    98t
    -126t
    -48t
    84t
    -4t
    55t
    125t
    -115t
    -112t
    57t
    34t
    86t
    84t
    38t
    53t
    120t
    -110t
    -21t
    -14t
    -111t
    -86t
    79t
    -47t
    38t
    -15t
    -21t
    12t
    43t
    22t
    -62t
    59t
    109t
    -100t
    34t
    40t
    102t
    -46t
    -12t
    6t
    56t
    86t
    35t
    -12t
    0t
    92t
    -122t
    -82t
    -104t
    99t
    -88t
    -8t
    8t
    99t
    -88t
    -73t
    95t
    -105t
    74t
    34t
    -19t
    34t
    125t
    -26t
    -8t
    -127t
    20t
    -30t
    48t
    -83t
    19t
    -86t
    103t
    -80t
    66t
    -21t
    -104t
    116t
    -78t
    50t
    99t
    -120t
    -68t
    115t
    -59t
    -106t
    -97t
    -86t
    26t
    -62t
    -120t
    57t
    31t
    -78t
    104t
    20t
    51t
    72t
    88t
    1t
    -17t
    56t
    101t
    -116t
    -59t
    54t
    -58t
    72t
    -1t
    -118t
    -21t
    -34t
    -76t
    -122t
    -32t
    -36t
    -109t
    60t
    -75t
    32t
    2t
    -77t
    19t
    19t
    -121t
    -95t
    -68t
    -1t
    40t
    -93t
    42t
    -65t
    -107t
    7t
    58t
    75t
    31t
    3t
    -125t
    -101t
    47t
    -48t
    49t
    -72t
    47t
    -6t
    -102t
    108t
    121t
    40t
    30t
    9t
    74t
    -24t
    -11t
    -128t
    -51t
    47t
    13t
    -43t
    50t
    96t
    126t
    -65t
    111t
    102t
    -1t
    30t
    81t
    -109t
    -20t
    -21t
    -117t
    -111t
    -36t
    81t
    -1t
    -3t
    -82t
    70t
    -32t
    -80t
    -63t
    -110t
    86t
    -107t
    20t
    -120t
    42t
    119t
    19t
    -119t
    -90t
    -50t
    -75t
    116t
    111t
    -90t
    -12t
    -96t
    -103t
    107t
    106t
    -108t
    105t
    -102t
    61t
    68t
    -34t
    -72t
    -90t
    13t
    76t
    120t
    -98t
    67t
    78t
    -42t
    20t
    100t
    55t
    -125t
    -59t
    100t
    -98t
    -121t
    -84t
    81t
    -75t
    -54t
    97t
    117t
    -93t
    92t
    122t
    -125t
    -14t
    -18t
    36t
    -88t
    64t
    96t
    75t
    79t
    -67t
    6t
    -90t
    -33t
    -33t
    45t
    2t
    -18t
    -56t
    -81t
    77t
    85t
    55t
    43t
    68t
    123t
    -39t
    -106t
    -45t
    47t
    -78t
    -92t
    -127t
    -45t
    -122t
    -128t
    -73t
    -104t
    25t
    -8t
    26t
    97t
    126t
    -21t
    -68t
    91t
    35t
    9t
    84t
    -53t
    114t
    -128t
    -36t
    102t
    -37t
    37t
    67t
    -69t
    42t
    -73t
    109t
    -39t
    -49t
    -22t
    86t
    -41t
    23t
    76t
    -94t
    -76t
    -59t
    5t
    -82t
    -77t
    -46t
    -73t
    -68t
    84t
    80t
    -61t
    50t
    66t
    33t
    -39t
    24t
    71t
    27t
    104t
    -62t
    94t
    18t
    123t
    -101t
    46t
    -104t
    43t
    -48t
    -39t
    76t
    -11t
    72t
    -61t
    117t
    -105t
    -98t
    -13t
    127t
    -86t
    54t
    -1t
    -14t
    46t
    -11t
    -92t
    62t
    -115t
    -63t
    74t
    -4t
    57t
    107t
    -51t
    65t
    52t
    -8t
    7t
    -1t
    -25t
    -68t
    -113t
    96t
    -128t
    -100t
    38t
    36t
    -83t
    44t
    102t
    31t
    -35t
    -110t
    -52t
    99t
    -44t
    -89t
    -14t
    81t
    87t
    15t
    -106t
    -92t
    79t
    22t
    -23t
    -89t
    -115t
    112t
    -52t
    -122t
    115t
    -15t
    -27t
    -32t
    92t
    10t
    33t
    -74t
    92t
    -94t
    -128t
    77t
    -81t
    14t
    -69t
    -70t
    120t
    76t
    52t
    123t
    28t
    111t
    19t
    -123t
    84t
    114t
    -29t
    -128t
    64t
    -9t
    79t
    56t
    -94t
    111t
    -54t
    43t
    -64t
    29t
    -26t
    67t
    -60t
    -28t
    54t
    96t
    20t
    -44t
    -16t
    105t
    103t
    -118t
    -5t
    20t
    110t
    -69t
    20t
    120t
    -51t
    62t
    60t
    21t
    -119t
    -60t
    25t
    -43t
    -112t
    -121t
    85t
    7t
    -96t
    87t
    -123t
    104t
    -68t
    104t
    -10t
    -109t
    60t
    82t
    -42t
    1t
    -104t
    82t
    -16t
    -21t
    -56t
    67t
    -69t
    63t
    94t
    105t
    81t
    90t
    -5t
    88t
    41t
    -109t
    61t
    -118t
    39t
    55t
    10t
    -57t
    -107t
    126t
    45t
    59t
    -108t
    48t
    25t
    63t
    -119t
    108t
    115t
    68t
    24t
    25t
    112t
    72t
    -96t
    3t
    33t
    -126t
    111t
    49t
    112t
    -83t
    -62t
    -35t
    98t
    20t
    -22t
    -24t
    -38t
    -125t
    95t
    -70t
    -33t
    20t
    53t
    46t
    76t
    -83t
    59t
    38t
    98t
    119t
    37t
    -105t
    51t
    -76t
    18t
    -14t
    -46t
    43t
    12t
    86t
    -94t
    115t
    -52t
    50t
    66t
    -70t
    12t
    49t
    72t
    120t
    -125t
    83t
    67t
    69t
    93t
    10t
    126t
    116t
    -126t
    107t
    -9t
    -106t
    -84t
    -37t
    -79t
    -94t
    116t
    -35t
    -30t
    6t
    92t
    -108t
    13t
    -18t
    -90t
    100t
    -88t
    119t
    -3t
    -124t
    -46t
    -61t
    -17t
    84t
    35t
    7t
    -111t
    113t
    -125t
    95t
    -84t
    98t
    42t
    -19t
    30t
    11t
    119t
    -25t
    79t
    87t
    -103t
    -65t
    -57t
    95t
    -125t
    6t
    100t
    96t
    52t
    78t
    95t
    -108t
    -128t
    -109t
    -48t
    -84t
    22t
    -33t
    -75t
    -23t
    -21t
    -84t
    -80t
    102t
    39t
    -75t
    114t
    29t
    -36t
    3t
    -9t
    69t
    -119t
    7t
    -114t
    65t
    120t
    -31t
    28t
    8t
    18t
    -99t
    -104t
    55t
    57t
    48t
    106t
    122t
    94t
    -117t
    -108t
    31t
    -13t
    56t
    7t
    -72t
    17t
    25t
    30t
    71t
    -102t
    -54t
    71t
    -36t
    -57t
    -40t
    56t
    55t
    -39t
    -122t
    51t
    -109t
    -9t
    -31t
    -127t
    -85t
    -101t
    -4t
    -51t
    29t
    78t
    22t
    -128t
    -22t
    71t
    -76t
    105t
    -85t
    -71t
    85t
    52t
    117t
    43t
    8t
    31t
    -127t
    103t
    -50t
    45t
    -116t
    48t
    66t
    2t
    -100t
    -18t
    99t
    -80t
    -108t
    120t
    -121t
    40t
    -17t
    -61t
    -10t
    109t
    126t
    76t
    94t
    75t
    -1t
    19t
    28t
    87t
    -88t
    112t
    -110t
    -127t
    37t
    79t
    -107t
    -46t
    -115t
    55t
    -74t
    24t
    28t
    -48t
    -101t
    -100t
    68t
    -53t
    32t
    118t
    -33t
    -110t
    -13t
    -71t
    -104t
    111t
    96t
    76t
    -32t
    118t
    99t
    -15t
    -82t
    -100t
    -20t
    -27t
    -72t
    -3t
    -46t
    -91t
    121t
    -18t
    -115t
    11t
    -2t
    -101t
    -38t
    103t
    110t
    -9t
    18t
    35t
    20t
    27t
    -59t
    -69t
    117t
    53t
    -61t
    -113t
    -66t
    -76t
    -3t
    121t
    97t
    -96t
    66t
    -83t
    -111t
    -128t
    -26t
    0t
    114t
    -82t
    29t
    77t
    -8t
    1t
    -77t
    -44t
    -88t
    -112t
    32t
    110t
    -124t
    -67t
    -71t
    12t
    86t
    -38t
    4t
    -119t
    -9t
    -54t
    28t
    87t
    -121t
    -108t
    -15t
    38t
    -38t
    62t
    -72t
    -3t
    117t
    80t
    34t
    102t
    -4t
    -54t
    19t
    27t
    127t
    -2t
    -20t
    58t
    -80t
    115t
    -30t
    -112t
    100t
    -14t
    112t
    -67t
    118t
    -113t
    108t
    -101t
    -94t
    -19t
    22t
    69t
    -2t
    46t
    10t
    -81t
    82t
    56t
    -6t
    62t
    74t
    7t
    -20t
    -14t
    -105t
    -37t
    -86t
    88t
    55t
    -127t
    93t
    116t
    81t
    -39t
    5t
    104t
    105t
    14t
    -9t
    122t
    -56t
    13t
    -6t
    -36t
    -111t
    -97t
    -44t
    25t
    -104t
    15t
    -69t
    -108t
    -117t
    -111t
    41t
    -23t
    113t
    81t
    124t
    -101t
    -73t
    -102t
    -3t
    120t
    -56t
    38t
    -17t
    36t
    -75t
    -72t
    -24t
    -23t
    -100t
    -47t
    115t
    18t
    -89t
    103t
    20t
    112t
    -125t
    -23t
    -82t
    -5t
    85t
    62t
    53t
    -69t
    -91t
    -44t
    -32t
    25t
    71t
    -92t
    3t
    -83t
    3t
    73t
    96t
    31t
    69t
    24t
    -106t
    -64t
    -38t
    -40t
    80t
    -49t
    24t
    83t
    116t
    79t
    73t
    15t
    -42t
    104t
    14t
    44t
    120t
    32t
    83t
    124t
    41t
    61t
    21t
    -82t
    78t
    114t
    126t
    56t
    63t
    62t
    -58t
    -46t
    -65t
    -13t
    34t
    -48t
    96t
    118t
    -54t
    -6t
    92t
    -90t
    -46t
    74t
    -28t
    -98t
    3t
    26t
    59t
    -34t
    68t
    -23t
    -78t
    -74t
    -1t
    -32t
    -34t
    -86t
    49t
    43t
    -125t
    93t
    111t
    127t
    -120t
    120t
    75t
    85t
    90t
    109t
    -30t
    -39t
    44t
    34t
    110t
    48t
    71t
    101t
    87t
    8t
    41t
    74t
    65t
    51t
    -115t
    93t
    -110t
    20t
    106t
    -95t
    106t
    127t
    -38t
    124t
    -45t
    -63t
    -117t
    -54t
    -53t
    -38t
    -42t
    110t
    -18t
    127t
    -68t
    126t
    -113t
    113t
    99t
    51t
    -40t
    -106t
    29t
    38t
    -73t
    -81t
    -36t
    -48t
    -108t
    -25t
    -21t
    -80t
    20t
    -111t
    -25t
    -94t
    -56t
    -83t
    105t
    37t
    -6t
    97t
    -1t
    -75t
    -128t
    -43t
    22t
    -48t
    -3t
    -42t
    9t
    50t
    75t
    64t
    51t
    -19t
    -125t
    119t
    -128t
    -127t
    -61t
    70t
    20t
    -70t
    -1t
    -29t
    -92t
    65t
    125t
    -55t
    -110t
    9t
    98t
    -21t
    95t
    -72t
    -121t
    21t
    -28t
    -64t
    51t
    -111t
    -125t
    -2t
    -94t
    82t
    -62t
    -73t
    73t
    -44t
    86t
    17t
    -112t
    34t
    17t
    -41t
    -117t
    39t
    59t
    -62t
    126t
    73t
    125t
    58t
    -40t
    116t
    -19t
    -40t
    0t
    -109t
    -5t
    113t
    11t
    -88t
    34t
    -39t
    79t
    -77t
    -99t
    -118t
    -40t
    85t
    49t
    119t
    -46t
    90t
    -86t
    88t
    -71t
    -66t
    -65t
    36t
    40t
    32t
    -27t
    127t
    -22t
    -20t
    -69t
    -94t
    -62t
    -13t
    79t
    111t
    66t
    -26t
    106t
    -108t
    -39t
    -104t
    -67t
    -108t
    60t
    -95t
    -65t
    -30t
    -20t
    -9t
    83t
    -18t
    -102t
    -49t
    75t
    45t
    105t
    56t
    -66t
    120t
    -21t
    -14t
    -69t
    -23t
    54t
    36t
    117t
    -100t
    -86t
    -82t
    -96t
    -113t
    -26t
    108t
    47t
    -70t
    0t
    -112t
    -44t
    -57t
    -62t
    -76t
    -68t
    -96t
    -102t
    -32t
    74t
    78t
    31t
    113t
    127t
    -1t
    -65t
    86t
    -25t
    39t
    -74t
    -26t
    -48t
    -30t
    28t
    92t
    -39t
    73t
    -32t
    101t
    -8t
    -44t
    6t
    -61t
    -112t
    96t
    -45t
    120t
    96t
    -112t
    95t
    -91t
    78t
    23t
    76t
    -114t
    65t
    -100t
    79t
    30t
    -105t
    -24t
    104t
    94t
    70t
    -12t
    -102t
    -19t
    -29t
    -117t
    -117t
    -65t
    -99t
    -64t
    -77t
    40t
    -108t
    31t
    107t
    19t
    91t
    74t
    -112t
    -127t
    28t
    -2t
    73t
    -36t
    11t
    57t
    72t
    28t
    118t
    -69t
    92t
    -9t
    -41t
    -93t
    52t
    -125t
    43t
    17t
    80t
    80t
    -60t
    -17t
    -28t
    74t
    -15t
    95t
    2t
    -18t
    -21t
    -18t
    -6t
    121t
    101t
    102t
    -70t
    -76t
    87t
    48t
    -56t
    -109t
    50t
    126t
    -115t
    41t
    47t
    -103t
    0t
    -6t
    46t
    -28t
    -11t
    -58t
    27t
    82t
    97t
    120t
    52t
    23t
    91t
    121t
    59t
    -100t
    18t
    80t
    79t
    64t
    90t
    48t
    91t
    -97t
    -115t
    -8t
    -43t
    -23t
    -66t
    -78t
    22t
    4t
    -26t
    -85t
    -2t
    80t
    -5t
    -27t
    111t
    65t
    104t
    -17t
    64t
    -23t
    -127t
    99t
    61t
    -26t
    -112t
    52t
    -36t
    116t
    98t
    -61t
    48t
    -19t
    102t
    -47t
    -53t
    -52t
    90t
    64t
    -40t
    27t
    -27t
    -57t
    -36t
    21t
    -53t
    81t
    31t
    -7t
    99t
    -93t
    -45t
    108t
    60t
    32t
    49t
    -98t
    65t
    117t
    -76t
    68t
    -82t
    98t
    76t
    49t
    -68t
    111t
    -43t
    48t
    -126t
    -36t
    -86t
    8t
    -90t
    -55t
    -127t
    29t
    67t
    76t
    47t
    -126t
    -76t
    -96t
    52t
    6t
    -59t
    -1t
    -20t
    80t
    -40t
    -73t
    -120t
    -42t
    -6t
    -21t
    -42t
    -67t
    -78t
    26t
    58t
    64t
    -58t
    -117t
    100t
    -78t
    -32t
    67t
    -28t
    69t
    -59t
    20t
    -93t
    -2t
    15t
    -2t
    32t
    -45t
    -35t
    -73t
    14t
    -25t
    -63t
    -105t
    -96t
    -78t
    -35t
    -93t
    48t
    24t
    15t
    125t
    -85t
    21t
    52t
    -38t
    108t
    -21t
    -26t
    -102t
    -85t
    23t
    -40t
    -2t
    45t
    -128t
    -22t
    -103t
    -126t
    49t
    19t
    -68t
    -9t
    -65t
    -121t
    -120t
    -10t
    105t
    -6t
    104t
    59t
    -6t
    9t
    -108t
    100t
    -14t
    104t
    90t
    109t
    -83t
    -85t
    -17t
    -107t
    -73t
    101t
    -12t
    39t
    -24t
    58t
    57t
    -118t
    61t
    88t
    95t
    -118t
    -60t
    70t
    -88t
    50t
    -34t
    67t
    4t
    -101t
    -37t
    69t
    -96t
    82t
    -123t
    58t
    111t
    -78t
    11t
    -125t
    -43t
    -1t
    -97t
    124t
    -120t
    -83t
    -106t
    97t
    -47t
    -98t
    98t
    -99t
    59t
    -46t
    80t
    -59t
    -63t
    65t
    -17t
    66t
    6t
    71t
    112t
    100t
    -77t
    88t
    -72t
    -104t
    -66t
    -28t
    17t
    -77t
    111t
    -99t
    111t
    26t
    47t
    64t
    -33t
    10t
    -38t
    -19t
    118t
    123t
    -92t
    82t
    -103t
    -87t
    81t
    -56t
    57t
    -26t
    92t
    70t
    39t
    -112t
    -29t
    49t
    97t
    -77t
    13t
    108t
    115t
    57t
    -91t
    40t
    -89t
    -6t
    56t
    84t
    110t
    8t
    70t
    -17t
    -31t
    83t
    43t
    86t
    33t
    39t
    -43t
    1t
    44t
    72t
    -34t
    -87t
    35t
    95t
    -55t
    45t
    -91t
    -17t
    -27t
    86t
    117t
    -10t
    17t
    82t
    -58t
    81t
    -77t
    52t
    57t
    -78t
    64t
    -90t
    73t
    -5t
    -33t
    -97t
    -42t
    70t
    -9t
    -51t
    -109t
    11t
    13t
    -57t
    101t
    120t
    15t
    50t
    -64t
    -44t
    65t
    -35t
    26t
    17t
    79t
    122t
    56t
    52t
    112t
    47t
    -39t
    -94t
    -96t
    -54t
    90t
    123t
    23t
    91t
    86t
    -53t
    97t
    45t
    107t
    -43t
    97t
    -97t
    113t
    3t
    -110t
    -90t
    -27t
    -120t
    42t
    48t
    109t
    -83t
    -30t
    -128t
    7t
    -58t
    121t
    -33t
    125t
    43t
    50t
    53t
    46t
    6t
    10t
    7t
    -20t
    -83t
    -124t
    -39t
    -61t
    74t
    56t
    -117t
    -76t
    54t
    -15t
    39t
    -31t
    -1t
    66t
    -95t
    -53t
    24t
    109t
    39t
    13t
    -31t
    80t
    -16t
    120t
    57t
    83t
    27t
    -70t
    -31t
    23t
    108t
    -56t
    -112t
    111t
    63t
    -67t
    -51t
    61t
    41t
    7t
    76t
    -122t
    45t
    94t
    104t
    -39t
    -95t
    -56t
    -70t
    -115t
    -121t
    -98t
    -22t
    63t
    -28t
    -74t
    103t
    120t
    122t
    -105t
    -23t
    -68t
    68t
    46t
    -108t
    -116t
    71t
    98t
    -78t
    -10t
    76t
    122t
    -6t
    24t
    -16t
    -16t
    -43t
    39t
    63t
    36t
    106t
    -79t
    65t
    118t
    57t
    102t
    -112t
    -65t
    -46t
    -22t
    -6t
    -49t
    -108t
    34t
    22t
    29t
    -49t
    77t
    16t
    94t
    -9t
    -106t
    -36t
    94t
    -81t
    -127t
    -39t
    -17t
    47t
    -1t
    -20t
    3t
    -37t
    -104t
    50t
    76t
    -81t
    -46t
    49t
    110t
    91t
    -102t
    -84t
    -49t
    111t
    26t
    -63t
    40t
    62t
    -49t
    -21t
    -44t
    106t
    -31t
    -58t
    90t
    -100t
    11t
    127t
    -85t
    5t
    73t
    75t
    59t
    -95t
    -13t
    -103t
    -7t
    85t
    -69t
    -124t
    36t
    80t
    -82t
    10t
    -33t
    31t
    -41t
    -43t
    -68t
    -99t
    -45t
    -55t
    -128t
    -58t
    81t
    -68t
    -1t
    -42t
    -123t
    -97t
    -65t
    -56t
    111t
    -69t
    117t
    -87t
    78t
    -118t
    91t
    25t
    -19t
    -27t
    34t
    -39t
    30t
    -45t
    105t
    19t
    -71t
    -91t
    -50t
    -77t
    87t
    116t
    -99t
    94t
    -49t
    -98t
    -36t
    -115t
    -79t
    38t
    82t
    -14t
    -104t
    -74t
    31t
    -15t
    -59t
    -17t
    -94t
    35t
    91t
    -81t
    -3t
    122t
    120t
    -18t
    17t
    34t
    -56t
    -66t
    54t
    -56t
    96t
    -44t
    -95t
    42t
    -21t
    -13t
    60t
    -109t
    49t
    -19t
    -75t
    75t
    47t
    110t
    105t
    20t
    -98t
    -88t
    100t
    -103t
    -31t
    126t
    -48t
    123t
    -106t
    34t
    18t
    81t
    113t
    -67t
    18t
    111t
    -9t
    -127t
    -79t
    -92t
    4t
    25t
    -13t
    58t
    63t
    48t
    -81t
    -42t
    18t
    100t
    -84t
    -30t
    -96t
    -119t
    65t
    -126t
    49t
    -28t
    -14t
    -50t
    35t
    46t
    -100t
    -15t
    -10t
    -34t
    -55t
    -47t
    92t
    -41t
    -2t
    112t
    84t
    -8t
    -76t
    125t
    90t
    -78t
    -125t
    -114t
    20t
    -66t
    -82t
    -57t
    -106t
    0t
    54t
    115t
    -90t
    -82t
    84t
    34t
    -96t
    -101t
    -64t
    -90t
    80t
    -61t
    -107t
    57t
    -127t
    -79t
    108t
    -5t
    95t
    32t
    79t
    -110t
    48t
    58t
    14t
    34t
    -29t
    27t
    13t
    -102t
    -75t
    72t
    -64t
    -18t
    -21t
    95t
    -43t
    31t
    58t
    115t
    96t
    -36t
    -121t
    63t
    -98t
    20t
    50t
    -75t
    -125t
    111t
    -52t
    93t
    101t
    24t
    -71t
    -122t
    -36t
    111t
    66t
    109t
    7t
    13t
    -117t
    88t
    -7t
    110t
    63t
    -51t
    95t
    13t
    68t
    -76t
    1t
    14t
    -101t
    -38t
    66t
    112t
    -3t
    -126t
    -20t
    -71t
    122t
    44t
    -54t
    -105t
    40t
    -108t
    40t
    -28t
    -68t
    10t
    -58t
    44t
    124t
    55t
    122t
    64t
    -13t
    -109t
    -12t
    -9t
    -96t
    -104t
    -9t
    -25t
    6t
    -50t
    -54t
    104t
    -44t
    -116t
    85t
    4t
    92t
    49t
    7t
    37t
    39t
    -70t
    121t
    -26t
    -93t
    -80t
    -8t
    59t
    -93t
    -80t
    94t
    -75t
    -121t
    -6t
    -108t
    86t
    -35t
    69t
    125t
    -84t
    115t
    -99t
    -60t
    69t
    -84t
    19t
    109t
    61t
    107t
    39t
    111t
    -113t
    -82t
    -49t
    41t
    4t
    94t
    84t
    -58t
    60t
    -63t
    54t
    12t
    38t
    -68t
    -37t
    50t
    126t
    39t
    115t
    -44t
    19t
    -107t
    -13t
    -8t
    -12t
    -123t
    45t
    -13t
    5t
    -20t
    -96t
    -1t
    27t
    70t
    53t
    99t
    63t
    -16t
    -124t
    -126t
    -58t
    22t
    -8t
    -114t
    0t
    -64t
    114t
    14t
    33t
    -106t
    110t
    126t
    37t
    -120t
    20t
    -6t
    -119t
    23t
    41t
    112t
    -104t
    -100t
    -19t
    -52t
    5t
    97t
    1t
    -17t
    84t
    -10t
    29t
    62t
    30t
    104t
    -104t
    -101t
    26t
    124t
    125t
    -8t
    116t
    111t
    42t
    -55t
    -32t
    109t
    -7t
    92t
    -78t
    54t
    -13t
    115t
    100t
    -39t
    -38t
    67t
    38t
    115t
    -54t
    -70t
    63t
    104t
    -62t
    -76t
    67t
    -35t
    -91t
    28t
    73t
    5t
    2t
    46t
    -110t
    -92t
    -29t
    109t
    -38t
    122t
    -28t
    -112t
    -39t
    -31t
    -25t
    -62t
    -96t
    -73t
    -71t
    -93t
    64t
    6t
    -89t
    -70t
    24t
    52t
    -51t
    -79t
    71t
    7t
    -26t
    41t
    54t
    43t
    -82t
    -121t
    119t
    -12t
    108t
    -104t
    -47t
    -49t
    14t
    -112t
    89t
    -112t
    77t
    2t
    -83t
    -125t
    64t
    97t
    -65t
    -41t
    103t
    116t
    -120t
    67t
    109t
    -36t
    -20t
    -22t
    -106t
    61t
    69t
    49t
    47t
    88t
    95t
    -61t
    -14t
    -83t
    95t
    42t
    106t
    78t
    35t
    -90t
    -116t
    -80t
    94t
    -101t
    -43t
    -35t
    44t
    56t
    97t
    -8t
    -105t
    96t
    95t
    92t
    90t
    -125t
    -56t
    -63t
    123t
    10t
    -87t
    -14t
    32t
    79t
    97t
    -83t
    6t
    -28t
    -43t
    -29t
    116t
    126t
    -14t
    72t
    -50t
    41t
    -5t
    18t
    36t
    60t
    12t
    113t
    -3t
    -79t
    46t
    7t
    -83t
    11t
    -73t
    -47t
    -83t
    -74t
    -31t
    37t
    -52t
    9t
    -98t
    -39t
    -105t
    19t
    62t
    -72t
    24t
    -106t
    80t
    18t
    79t
    5t
    -109t
    -97t
    -83t
    -126t
    28t
    104t
    8t
    -66t
    -73t
    -66t
    -100t
    97t
    96t
    -34t
    -25t
    11t
    60t
    3t
    28t
    86t
    -125t
    -57t
    -35t
    -123t
    -67t
    75t
    -18t
    32t
    19t
    -94t
    125t
    76t
    -20t
    97t
    -27t
    74t
    -10t
    14t
    71t
    -88t
    -48t
    57t
    38t
    -15t
    -125t
    -109t
    105t
    44t
    110t
    13t
    52t
    -25t
    28t
    -7t
    23t
    103t
    84t
    33t
    64t
    -36t
    -43t
    -115t
    -74t
    34t
    2t
    12t
    -92t
    107t
    41t
    75t
    85t
    -20t
    -50t
    24t
    -22t
    78t
    10t
    8t
    -56t
    41t
    -123t
    -41t
    -53t
    24t
    23t
    118t
    54t
    81t
    76t
    56t
    -44t
    -113t
    105t
    59t
    -120t
    7t
    -93t
    22t
    28t
    -108t
    -14t
    18t
    75t
    2t
    3t
    -125t
    -85t
    11t
    -40t
    95t
    -122t
    104t
    46t
    58t
    25t
    -97t
    -31t
    67t
    -80t
    16t
    123t
    -118t
    46t
    -30t
    17t
    -122t
    5t
    69t
    -21t
    36t
    -111t
    69t
    38t
    -19t
    30t
    55t
    -101t
    127t
    -39t
    109t
    33t
    -93t
    -96t
    88t
    -49t
    22t
    82t
    35t
    99t
    89t
    11t
    -70t
    79t
    -81t
    -116t
    -15t
    68t
    89t
    126t
    14t
    -33t
    19t
    53t
    21t
    15t
    -1t
    97t
    99t
    -31t
    -10t
    101t
    65t
    102t
    -124t
    12t
    75t
    77t
    -77t
    6t
    -68t
    -85t
    -112t
    -99t
    -43t
    -111t
    116t
    78t
    -104t
    28t
    23t
    -14t
    9t
    -61t
    -10t
    -66t
    6t
    122t
    82t
    -51t
    -23t
    -77t
    122t
    -115t
    95t
    7t
    -40t
    -109t
    -119t
    20t
    8t
    61t
    72t
    -17t
    -105t
    37t
    -87t
    86t
    76t
    -85t
    72t
    -108t
    104t
    -86t
    99t
    -113t
    -127t
    27t
    39t
    -9t
    119t
    46t
    108t
    12t
    86t
    50t
    -12t
    -109t
    52t
    56t
    107t
    89t
    95t
    71t
    36t
    -77t
    72t
    94t
    99t
    33t
    -90t
    -74t
    26t
    -109t
    3t
    -19t
    44t
    69t
    -62t
    -107t
    95t
    -15t
    -89t
    16t
    41t
    -124t
    78t
    -76t
    -55t
    -26t
    -18t
    -41t
    28t
    90t
    -6t
    26t
    -106t
    -51t
    -86t
    123t
    -87t
    -55t
    70t
    -73t
    -41t
    -6t
    53t
    68t
    -4t
    36t
    -28t
    -101t
    -91t
    -110t
    -79t
    50t
    -27t
    78t
    62t
    -24t
    105t
    84t
    -96t
    -100t
    -100t
    -67t
    -120t
    30t
    -6t
    -66t
    -73t
    -62t
    121t
    -4t
    61t
    49t
    -126t
    44t
    -89t
    -58t
    65t
    40t
    -101t
    -74t
    5t
    111t
    -95t
    -74t
    -37t
    96t
    -52t
    -31t
    7t
    41t
    -73t
    14t
    -73t
    46t
    -56t
    -119t
    122t
    -101t
    121t
    81t
    -70t
    15t
    122t
    71t
    63t
    93t
    45t
    -37t
    -16t
    74t
    11t
    125t
    -7t
    -99t
    42t
    -44t
    -124t
    58t
    -70t
    13t
    -42t
    73t
    60t
    17t
    11t
    -86t
    -99t
    -16t
    23t
    -6t
    -115t
    -39t
    108t
    9t
    -43t
    7t
    25t
    119t
    -75t
    -2t
    -25t
    -102t
    21t
    75t
    111t
    40t
    73t
    69t
    105t
    -66t
    -2t
    -116t
    -59t
    -97t
    -90t
    -99t
    -53t
    -37t
    39t
    35t
    36t
    -87t
    -24t
    94t
    46t
    14t
    43t
    104t
    45t
    16t
    -127t
    111t
    -100t
    -57t
    120t
    -66t
    -60t
    64t
    -51t
    -46t
    33t
    -82t
    -106t
    39t
    75t
    -16t
    107t
    -36t
    68t
    93t
    -28t
    106t
    103t
    52t
    2t
    3t
    -5t
    20t
    -21t
    47t
    52t
    117t
    -80t
    -123t
    -36t
    -67t
    -27t
    110t
    124t
    87t
    50t
    -31t
    -29t
    -113t
    6t
    37t
    33t
    29t
    -127t
    -106t
    -68t
    110t
    -88t
    34t
    -111t
    75t
    -62t
    -106t
    -87t
    -48t
    -31t
    99t
    35t
    -50t
    -53t
    -57t
    -16t
    -105t
    -35t
    -68t
    -42t
    46t
    51t
    92t
    -123t
    -105t
    7t
    73t
    -35t
    54t
    99t
    -125t
    -29t
    -119t
    52t
    99t
    76t
    52t
    11t
    90t
    -85t
    -89t
    -43t
    23t
    111t
    -44t
    96t
    101t
    -101t
    -52t
    94t
    95t
    116t
    -110t
    40t
    60t
    -36t
    10t
    54t
    -10t
    84t
    104t
    23t
    -110t
    -101t
    -116t
    -127t
    -51t
    121t
    -84t
    0t
    19t
    118t
    48t
    33t
    -95t
    -14t
    -86t
    -83t
    -105t
    112t
    -28t
    56t
    -95t
    55t
    -94t
    -96t
    -6t
    60t
    -107t
    122t
    6t
    -97t
    48t
    -67t
    -120t
    11t
    -21t
    87t
    85t
    91t
    2t
    -98t
    47t
    -44t
    127t
    4t
    -26t
    -50t
    -70t
    -32t
    -128t
    45t
    -128t
    -120t
    88t
    -38t
    -112t
    31t
    79t
    -38t
    68t
    60t
    57t
    32t
    91t
    -13t
    -68t
    2t
    -120t
    -87t
    42t
    -76t
    52t
    -65t
    122t
    -13t
    -24t
    41t
    69t
    90t
    21t
    12t
    -27t
    -40t
    65t
    -106t
    103t
    -126t
    -15t
    57t
    61t
    127t
    118t
    124t
    102t
    -59t
    -50t
    -75t
    78t
    -24t
    -114t
    -106t
    -118t
    -56t
    62t
    -18t
    -39t
    -61t
    -82t
    21t
    33t
    -1t
    -124t
    -79t
    41t
    22t
    -108t
    -29t
    -93t
    -127t
    -98t
    109t
    73t
    -44t
    110t
    126t
    -1t
    94t
    -112t
    39t
    46t
    -94t
    44t
    110t
    -103t
    -51t
    111t
    4t
    -70t
    -78t
    68t
    -104t
    -99t
    44t
    99t
    -88t
    116t
    118t
    -103t
    -47t
    -57t
    -105t
    -62t
    92t
    -65t
    -18t
    56t
    122t
    -12t
    -9t
    22t
    -66t
    45t
    100t
    28t
    87t
    53t
    -9t
    109t
    -111t
    110t
    88t
    -92t
    -76t
    -66t
    75t
    19t
    -45t
    44t
    32t
    48t
    119t
    20t
    101t
    56t
    -117t
    89t
    89t
    98t
    107t
    13t
    67t
    -122t
    -72t
    -28t
    29t
    101t
    82t
    -48t
    93t
    -110t
    -71t
    -106t
    -54t
    -61t
    -18t
    -74t
    90t
    106t
    -72t
    -58t
    -91t
    69t
    -107t
    -63t
    106t
    -70t
    -128t
    -63t
    84t
    -47t
    56t
    121t
    14t
    0t
    -85t
    -1t
    -1t
    -10t
    -86t
    -120t
    -57t
    -81t
    16t
    115t
    -85t
    -28t
    -13t
    19t
    20t
    49t
    73t
    73t
    21t
    30t
    78t
    -7t
    105t
    -107t
    -105t
    -112t
    -32t
    -121t
    2t
    29t
    4t
    -11t
    117t
    -29t
    -3t
    -16t
    39t
    -1t
    -6t
    8t
    81t
    26t
    -106t
    -11t
    12t
    18t
    -66t
    90t
    72t
    63t
    122t
    -128t
    -106t
    -74t
    42t
    10t
    -39t
    -75t
    -24t
    80t
    22t
    77t
    -127t
    105t
    -120t
    126t
    -58t
    -107t
    -47t
    43t
    -11t
    -32t
    -34t
    67t
    -106t
    52t
    -18t
    -20t
    -11t
    -92t
    48t
    106t
    21t
    23t
    -65t
    73t
    -36t
    -27t
    67t
    -34t
    39t
    35t
    0t
    -48t
    -12t
    -68t
    -9t
    114t
    -36t
    18t
    94t
    -41t
    -74t
    86t
    -125t
    -118t
    -85t
    -34t
    21t
    88t
    -113t
    56t
    -48t
    -56t
    68t
    -72t
    -20t
    -37t
    -108t
    104t
    -90t
    -9t
    30t
    -69t
    8t
    98t
    -42t
    -71t
    36t
    -39t
    100t
    70t
    -89t
    118t
    25t
    -65t
    -69t
    -100t
    33t
    53t
    -110t
    62t
    87t
    -92t
    -3t
    -18t
    34t
    -112t
    117t
    -13t
    -91t
    -73t
    52t
    -83t
    -11t
    40t
    49t
    -1t
    87t
    -1t
    119t
    -110t
    31t
    81t
    84t
    9t
    87t
    84t
    -100t
    -51t
    -7t
    -30t
    100t
    -1t
    -1t
    124t
    110t
    -21t
    89t
    -46t
    -102t
    -80t
    -119t
    42t
    -42t
    -39t
    -10t
    -77t
    -64t
    -96t
    -1t
    83t
    -96t
    -12t
    68t
    -39t
    -45t
    113t
    -97t
    114t
    16t
    -33t
    15t
    75t
    -51t
    118t
    22t
    -39t
    -116t
    -115t
    119t
    51t
    0t
    26t
    -6t
    -115t
    -23t
    81t
    108t
    -96t
    -120t
    -12t
    -100t
    12t
    33t
    -121t
    14t
    35t
    -112t
    81t
    115t
    2t
    -69t
    -104t
    90t
    123t
    -93t
    -90t
    -107t
    -89t
    13t
    -28t
    0t
    34t
    126t
    -2t
    58t
    -52t
    122t
    111t
    48t
    85t
    73t
    10t
    0t
    -117t
    -11t
    -63t
    66t
    124t
    99t
    89t
    -73t
    -111t
    -35t
    -60t
    22t
    -1t
    -35t
    -58t
    -107t
    -23t
    15t
    88t
    -3t
    -103t
    -2t
    -112t
    36t
    97t
    -104t
    92t
    1t
    110t
    -19t
    16t
    -121t
    -69t
    39t
    -105t
    70t
    -18t
    73t
    -81t
    -30t
    106t
    -38t
    -43t
    60t
    26t
    77t
    25t
    15t
    -126t
    105t
    -62t
    -109t
    -86t
    53t
    -115t
    66t
    42t
    33t
    -97t
    78t
    59t
    -5t
    -108t
    55t
    4t
    -106t
    -48t
    -7t
    43t
    -90t
    -108t
    16t
    -49t
    -14t
    -68t
    5t
    18t
    80t
    -61t
    62t
    8t
    109t
    13t
    29t
    18t
    112t
    49t
    -101t
    87t
    -103t
    82t
    58t
    60t
    -36t
    69t
    83t
    -99t
    40t
    -90t
    -10t
    85t
    18t
    -115t
    73t
    -33t
    -7t
    -11t
    41t
    35t
    20t
    -51t
    4t
    87t
    59t
    55t
    -105t
    -118t
    -126t
    -5t
    21t
    122t
    -88t
    53t
    26t
    -127t
    104t
    80t
    31t
    120t
    57t
    121t
    58t
    -19t
    39t
    -1t
    -78t
    -56t
    8t
    -32t
    -19t
    -52t
    80t
    -73t
    -94t
    12t
    -63t
    50t
    78t
    -120t
    62t
    74t
    54t
    81t
    121t
    -15t
    95t
    -28t
    -122t
    87t
    11t
    -53t
    63t
    3t
    -127t
    -48t
    -39t
    -103t
    -40t
    17t
    -27t
    76t
    82t
    46t
    110t
    121t
    43t
    34t
    -112t
    -2t
    26t
    37t
    40t
    -42t
    6t
    12t
    66t
    -38t
    0t
    -52t
    -7t
    -86t
    0t
    75t
    -9t
    74t
    23t
    -103t
    123t
    -82t
    21t
    100t
    95t
    -87t
    -9t
    18t
    66t
    -61t
    -85t
    -80t
    7t
    73t
    -20t
    -3t
    -74t
    -72t
    -111t
    -59t
    25t
    109t
    121t
    69t
    53t
    64t
    113t
    -78t
    -88t
    -104t
    -30t
    42t
    -48t
    -22t
    74t
    104t
    -51t
    49t
    -55t
    102t
    -97t
    -105t
    91t
    -69t
    -57t
    -47t
    -100t
    -64t
    -49t
    -32t
    52t
    -62t
    49t
    42t
    -73t
    9t
    9t
    91t
    -12t
    -7t
    -81t
    80t
    114t
    94t
    -51t
    -86t
    -25t
    101t
    -78t
    127t
    -8t
    -95t
    78t
    85t
    7t
    47t
    60t
    54t
    112t
    7t
    -2t
    118t
    -125t
    -107t
    -49t
    111t
    -103t
    -67t
    -3t
    38t
    -15t
    -96t
    100t
    43t
    101t
    100t
    -45t
    96t
    -18t
    -14t
    42t
    71t
    -111t
    26t
    49t
    -20t
    -66t
    -33t
    -86t
    103t
    -28t
    -37t
    -91t
    -52t
    74t
    101t
    16t
    96t
    116t
    36t
    24t
    -5t
    -36t
    122t
    -79t
    -24t
    86t
    76t
    -89t
    91t
    -34t
    58t
    -109t
    -15t
    -122t
    -114t
    104t
    39t
    53t
    12t
    -50t
    -34t
    26t
    11t
    119t
    57t
    -79t
    -101t
    124t
    73t
    34t
    -20t
    83t
    -102t
    37t
    -7t
    43t
    45t
    56t
    83t
    65t
    110t
    -93t
    -9t
    85t
    38t
    -89t
    -43t
    124t
    59t
    93t
    -25t
    -9t
    -113t
    -82t
    113t
    28t
    10t
    -17t
    96t
    -79t
    119t
    -26t
    -87t
    -63t
    -1t
    -92t
    23t
    -68t
    56t
    42t
    26t
    -11t
    -1t
    92t
    -59t
    -111t
    -18t
    50t
    -55t
    -5t
    -2t
    -43t
    -7t
    72t
    114t
    -72t
    -122t
    18t
    47t
    102t
    62t
    -7t
    -27t
    41t
    66t
    -51t
    -75t
    81t
    111t
    97t
    -119t
    -8t
    71t
    18t
    49t
    -123t
    35t
    96t
    -20t
    33t
    -57t
    109t
    -87t
    -86t
    49t
    59t
    28t
    -7t
    -72t
    -2t
    -54t
    31t
    79t
    -56t
    -13t
    22t
    13t
    38t
    67t
    -18t
    9t
    -35t
    -128t
    54t
    -121t
    -104t
    -118t
    84t
    112t
    -124t
    -57t
    -30t
    -48t
    -88t
    -54t
    -81t
    111t
    55t
    97t
    -24t
    96t
    95t
    13t
    17t
    123t
    -27t
    -109t
    116t
    112t
    94t
    106t
    92t
    -116t
    -85t
    99t
    -72t
    89t
    71t
    18t
    -75t
    118t
    -38t
    -13t
    -69t
    -16t
    123t
    34t
    103t
    -46t
    104t
    -87t
    53t
    102t
    -9t
    116t
    -56t
    -114t
    28t
    -118t
    -97t
    105t
    -49t
    7t
    -76t
    -70t
    -81t
    52t
    -53t
    -62t
    21t
    41t
    -41t
    -26t
    124t
    -31t
    63t
    -110t
    86t
    -74t
    -2t
    9t
    -104t
    111t
    93t
    -70t
    -127t
    -9t
    16t
    -14t
    -79t
    68t
    -38t
    106t
    -118t
    12t
    -2t
    -17t
    -43t
    -55t
    -56t
    -56t
    1t
    -122t
    85t
    -85t
    -31t
    -125t
    -1t
    -25t
    -93t
    -25t
    120t
    -5t
    -128t
    79t
    -78t
    118t
    -32t
    -33t
    -41t
    112t
    -102t
    62t
    -21t
    -41t
    56t
    -112t
    -11t
    -26t
    115t
    -46t
    -31t
    -34t
    -105t
    -24t
    61t
    55t
    121t
    34t
    60t
    101t
    38t
    88t
    -1t
    -43t
    50t
    49t
    66t
    4t
    -50t
    -39t
    102t
    -128t
    29t
    -7t
    -104t
    -90t
    49t
    -30t
    -45t
    -45t
    99t
    76t
    -76t
    101t
    -37t
    8t
    -3t
    81t
    110t
    -37t
    -92t
    85t
    -88t
    -18t
    -82t
    -43t
    -14t
    -35t
    4t
    92t
    24t
    -31t
    -123t
    -31t
    -50t
    -72t
    -110t
    44t
    -75t
    94t
    24t
    60t
    27t
    -20t
    118t
    -123t
    -27t
    8t
    -106t
    15t
    -70t
    82t
    60t
    44t
    24t
    5t
    126t
    68t
    119t
    46t
    -67t
    -127t
    -6t
    109t
    52t
    -31t
    -30t
    -53t
    25t
    -10t
    121t
    97t
    123t
    84t
    -25t
    -109t
    85t
    -9t
    49t
    70t
    23t
    28t
    19t
    21t
    -39t
    -8t
    -56t
    105t
    -35t
    97t
    -111t
    53t
    4t
    -47t
    72t
    -37t
    -61t
    -10t
    -25t
    31t
    -115t
    -48t
    36t
    -72t
    33t
    65t
    81t
    71t
    -40t
    127t
    60t
    120t
    72t
    -111t
    -62t
    -20t
    -120t
    22t
    69t
    112t
    124t
    -32t
    -13t
    100t
    -92t
    -72t
    5t
    6t
    -97t
    -85t
    -88t
    -91t
    -120t
    47t
    110t
    33t
    67t
    36t
    -35t
    27t
    52t
    -71t
    -3t
    122t
    21t
    -1t
    57t
    79t
    66t
    51t
    68t
    -61t
    -46t
    15t
    65t
    106t
    -68t
    2t
    -36t
    57t
    65t
    91t
    -11t
    8t
    31t
    -2t
    -74t
    -48t
    -126t
    -61t
    49t
    46t
    43t
    -36t
    -61t
    -61t
    63t
    -126t
    -17t
    62t
    -105t
    49t
    35t
    108t
    -72t
    -24t
    108t
    3t
    -77t
    120t
    41t
    -65t
    115t
    16t
    77t
    53t
    1t
    -41t
    35t
    46t
    -107t
    45t
    -109t
    -117t
    -74t
    43t
    -105t
    -98t
    103t
    79t
    -80t
    113t
    -25t
    30t
    -2t
    120t
    51t
    109t
    64t
    38t
    -63t
    -127t
    39t
    -8t
    -6t
    105t
    -101t
    -45t
    -88t
    -50t
    -9t
    42t
    -121t
    -20t
    -93t
    126t
    -94t
    104t
    -125t
    -44t
    -57t
    -40t
    69t
    107t
    -30t
    -72t
    -2t
    68t
    87t
    -114t
    -102t
    -110t
    28t
    21t
    106t
    -112t
    -122t
    -73t
    18t
    89t
    89t
    -47t
    -6t
    -99t
    104t
    -94t
    -73t
    -50t
    -74t
    -71t
    -25t
    0t
    -76t
    -96t
    -55t
    57t
    9t
    -80t
    -4t
    -122t
    106t
    -2t
    95t
    46t
    82t
    -118t
    -117t
    -101t
    -123t
    -89t
    81t
    -17t
    90t
    52t
    44t
    102t
    -77t
    -70t
    -105t
    102t
    90t
    -66t
    2t
    -4t
    63t
    77t
    -8t
    18t
    56t
    -78t
    -25t
    -29t
    122t
    -110t
    -71t
    -1t
    80t
    112t
    -73t
    -31t
    -77t
    72t
    92t
    -110t
    -28t
    -29t
    83t
    77t
    12t
    124t
    -67t
    26t
    -26t
    36t
    -11t
    -15t
    -106t
    -83t
    -1t
    88t
    -54t
    -93t
    -7t
    69t
    40t
    50t
    -80t
    92t
    19t
    -107t
    54t
    16t
    79t
    12t
    94t
    -78t
    -18t
    23t
    -72t
    -16t
    92t
    62t
    71t
    114t
    -82t
    -115t
    109t
    -32t
    1t
    -37t
    -11t
    -91t
    71t
    -126t
    119t
    63t
    -67t
    23t
    -32t
    67t
    81t
    -45t
    24t
    -50t
    66t
    -26t
    -55t
    -32t
    -87t
    -24t
    113t
    6t
    72t
    -85t
    -115t
    43t
    12t
    56t
    -105t
    -18t
    -121t
    -45t
    -64t
    -107t
    72t
    60t
    -109t
    63t
    -18t
    123t
    -36t
    -102t
    124t
    61t
    -119t
    -47t
    -47t
    -119t
    28t
    32t
    30t
    -37t
    -122t
    83t
    -62t
    -22t
    64t
    -73t
    -94t
    -33t
    51t
    -45t
    -82t
    57t
    11t
    -85t
    106t
    36t
    119t
    -39t
    -85t
    100t
    -93t
    49t
    69t
    -51t
    24t
    93t
    119t
    -38t
    -10t
    82t
    -55t
    10t
    -67t
    71t
    -126t
    -42t
    -31t
    -46t
    125t
    -33t
    21t
    72t
    13t
    32t
    -50t
    47t
    -88t
    105t
    79t
    -29t
    -121t
    70t
    -90t
    114t
    97t
    34t
    18t
    -105t
    91t
    -49t
    -97t
    -56t
    -88t
    -59t
    120t
    106t
    59t
    -29t
    80t
    115t
    -33t
    -58t
    30t
    112t
    -92t
    -88t
    -5t
    10t
    -80t
    107t
    64t
    24t
    107t
    32t
    93t
    -68t
    -14t
    -123t
    -47t
    119t
    -11t
    84t
    21t
    13t
    -47t
    72t
    -82t
    65t
    -57t
    -60t
    115t
    34t
    10t
    127t
    -37t
    120t
    -69t
    18t
    -33t
    108t
    -127t
    74t
    106t
    -81t
    57t
    100t
    70t
    -61t
    2t
    88t
    96t
    -77t
    60t
    43t
    69t
    -37t
    -54t
    -28t
    39t
    38t
    -11t
    -92t
    -40t
    99t
    38t
    -66t
    -94t
    -80t
    -86t
    97t
    -122t
    -59t
    -3t
    -10t
    94t
    80t
    -29t
    -7t
    86t
    91t
    109t
    -36t
    38t
    -33t
    -99t
    -98t
    -26t
    68t
    -10t
    92t
    75t
    2t
    57t
    32t
    -103t
    -44t
    30t
    30t
    13t
    111t
    -73t
    56t
    121t
    -35t
    -119t
    -22t
    -58t
    -54t
    -125t
    74t
    -106t
    106t
    -51t
    -78t
    89t
    11t
    -27t
    -13t
    107t
    123t
    112t
    -13t
    -6t
    -38t
    80t
    59t
    61t
    -78t
    124t
    -22t
    57t
    -93t
    -24t
    40t
    39t
    -101t
    71t
    -27t
    -100t
    94t
    112t
    20t
    109t
    119t
    80t
    -23t
    -81t
    69t
    5t
    -61t
    -114t
    89t
    -121t
    73t
    102t
    58t
    -58t
    81t
    -120t
    -83t
    123t
    -88t
    18t
    -109t
    94t
    -1t
    -47t
    18t
    -44t
    126t
    -61t
    -78t
    -92t
    11t
    -123t
    -14t
    58t
    -91t
    -113t
    125t
    87t
    10t
    26t
    -46t
    28t
    33t
    71t
    125t
    -97t
    37t
    64t
    46t
    105t
    5t
    -38t
    101t
    -71t
    -89t
    -21t
    -54t
    61t
    77t
    -29t
    44t
    78t
    122t
    110t
    -97t
    10t
    115t
    73t
    -1t
    17t
    -90t
    54t
    -19t
    77t
    -6t
    86t
    96t
    -89t
    -57t
    -87t
    -99t
    49t
    -13t
    -3t
    104t
    -79t
    -3t
    -22t
    -39t
    -18t
    109t
    -79t
    16t
    125t
    -87t
    48t
    -44t
    -19t
    -30t
    58t
    78t
    -61t
    57t
    8t
    -17t
    -49t
    -93t
    -76t
    -84t
    77t
    54t
    -26t
    -125t
    120t
    21t
    101t
    48t
    104t
    -113t
    -72t
    106t
    -27t
    15t
    -124t
    -103t
    -41t
    84t
    19t
    -106t
    17t
    10t
    46t
    -103t
    15t
    68t
    -62t
    -39t
    -66t
    125t
    100t
    -8t
    99t
    -107t
    -80t
    -112t
    83t
    85t
    31t
    63t
    84t
    -43t
    -76t
    -65t
    -114t
    -119t
    -52t
    37t
    -110t
    -100t
    -75t
    -126t
    -20t
    50t
    -28t
    30t
    -38t
    13t
    -14t
    121t
    -95t
    -60t
    48t
    -70t
    -46t
    -43t
    32t
    -127t
    105t
    -108t
    -115t
    122t
    24t
    -77t
    104t
    63t
    -33t
    -110t
    -44t
    26t
    20t
    -74t
    -53t
    -2t
    -70t
    30t
    -24t
    -107t
    58t
    37t
    -70t
    56t
    -56t
    72t
    62t
    125t
    103t
    -98t
    -62t
    121t
    110t
    -78t
    114t
    24t
    -112t
    94t
    6t
    52t
    81t
    21t
    35t
    112t
    77t
    -117t
    72t
    -31t
    72t
    -126t
    92t
    51t
    -124t
    -2t
    -124t
    -13t
    -51t
    80t
    -2t
    -9t
    -114t
    55t
    -28t
    54t
    14t
    71t
    -29t
    -47t
    42t
    66t
    -85t
    118t
    -23t
    -74t
    -35t
    64t
    30t
    -18t
    17t
    -6t
    -32t
    -40t
    77t
    68t
    82t
    -76t
    41t
    -6t
    -31t
    52t
    31t
    39t
    108t
    -83t
    118t
    -80t
    119t
    58t
    91t
    -126t
    29t
    105t
    9t
    -7t
    62t
    6t
    120t
    -122t
    23t
    67t
    -49t
    43t
    -22t
    80t
    44t
    -49t
    98t
    -128t
    -82t
    -45t
    122t
    12t
    81t
    52t
    -41t
    89t
    46t
    -78t
    -123t
    10t
    -3t
    -56t
    -116t
    7t
    -73t
    -88t
    42t
    22t
    -128t
    16t
    46t
    80t
    8t
    -3t
    -6t
    -65t
    123t
    124t
    20t
    -36t
    -124t
    -54t
    -18t
    11t
    -77t
    40t
    -5t
    0t
    94t
    -15t
    27t
    41t
    -33t
    81t
    18t
    125t
    113t
    -35t
    1t
    106t
    11t
    -123t
    62t
    2t
    -18t
    55t
    -2t
    -46t
    114t
    -109t
    -32t
    -82t
    -28t
    22t
    86t
    -21t
    -26t
    55t
    107t
    38t
    -27t
    -38t
    -4t
    101t
    110t
    -127t
    -103t
    14t
    62t
    113t
    -30t
    -77t
    119t
    -67t
    66t
    107t
    95t
    -100t
    -92t
    36t
    41t
    61t
    -104t
    110t
    -117t
    -111t
    27t
    100t
    93t
    -43t
    26t
    4t
    35t
    -4t
    -46t
    108t
    100t
    -114t
    15t
    12t
    -91t
    92t
    -15t
    -34t
    -24t
    -10t
    -39t
    44t
    1t
    -123t
    19t
    -43t
    76t
    -37t
    25t
    -27t
    -12t
    118t
    -88t
    -99t
    56t
    -21t
    42t
    -39t
    69t
    -76t
    -54t
    -16t
    -123t
    -93t
    -19t
    32t
    -115t
    -28t
    -81t
    48t
    76t
    69t
    6t
    -45t
    -106t
    -52t
    -13t
    -50t
    37t
    -72t
    107t
    15t
    -44t
    90t
    24t
    -66t
    -63t
    93t
    41t
    -39t
    -97t
    -27t
    -3t
    -2t
    -96t
    -40t
    63t
    -80t
    44t
    84t
    -94t
    39t
    -49t
    -116t
    -76t
    -109t
    36t
    -108t
    -79t
    46t
    90t
    49t
    13t
    -78t
    -29t
    -75t
    -36t
    -58t
    -22t
    -110t
    70t
    -10t
    94t
    -123t
    -90t
    -77t
    -81t
    -92t
    -32t
    -62t
    -76t
    -90t
    -78t
    -32t
    -60t
    57t
    9t
    -6t
    -114t
    88t
    78t
    -63t
    -18t
    -72t
    -50t
    -70t
    112t
    103t
    -60t
    -21t
    -76t
    0t
    -33t
    12t
    -71t
    -63t
    58t
    13t
    73t
    -42t
    -31t
    71t
    36t
    29t
    104t
    31t
    6t
    56t
    -127t
    -13t
    -127t
    103t
    55t
    115t
    13t
    75t
    91t
    47t
    -91t
    -123t
    -22t
    44t
    -2t
    -128t
    -19t
    119t
    28t
    20t
    123t
    66t
    -126t
    70t
    43t
    15t
    123t
    26t
    86t
    -49t
    -78t
    79t
    -48t
    -66t
    -8t
    49t
    -90t
    6t
    25t
    -75t
    73t
    -16t
    -48t
    -123t
    -59t
    -57t
    -6t
    77t
    -60t
    -65t
    -32t
    -111t
    55t
    -25t
    -83t
    -98t
    124t
    81t
    104t
    -126t
    -127t
    37t
    70t
    106t
    72t
    -59t
    93t
    -45t
    90t
    -61t
    105t
    -30t
    -63t
    -88t
    -60t
    76t
    89t
    -99t
    31t
    -102t
    -17t
    -56t
    114t
    94t
    -60t
    -55t
    -4t
    -122t
    -74t
    60t
    124t
    103t
    -49t
    -9t
    -124t
    47t
    -111t
    -105t
    24t
    59t
    34t
    -18t
    -75t
    99t
    88t
    85t
    114t
    12t
    -100t
    71t
    78t
    55t
    -1t
    -33t
    -57t
    -99t
    50t
    102t
    41t
    -50t
    122t
    27t
    -37t
    94t
    71t
    -6t
    43t
    -110t
    90t
    -86t
    40t
    -37t
    -2t
    95t
    -72t
    69t
    -11t
    -15t
    55t
    -17t
    10t
    126t
    76t
    -27t
    -99t
    -95t
    113t
    -56t
    -29t
    121t
    -100t
    52t
    -5t
    18t
    -76t
    6t
    11t
    -86t
    -81t
    -73t
    -121t
    -126t
    -80t
    -91t
    81t
    -113t
    99t
    -111t
    -125t
    47t
    -9t
    62t
    125t
    -67t
    -78t
    121t
    -45t
    9t
    78t
    -74t
    -35t
    -108t
    -27t
    -124t
    -36t
    -114t
    -30t
    -108t
    115t
    -125t
    98t
    -106t
    56t
    50t
    -101t
    52t
    114t
    -115t
    86t
    77t
    -30t
    76t
    -69t
    -62t
    70t
    83t
    -61t
    -81t
    80t
    1t
    72t
    -72t
    -109t
    -93t
    98t
    -86t
    -64t
    -67t
    2t
    2t
    89t
    10t
    114t
    108t
    27t
    -65t
    5t
    -22t
    54t
    -62t
    118t
    -20t
    -112t
    -14t
    -22t
    -74t
    59t
    -16t
    66t
    -102t
    106t
    -24t
    -12t
    34t
    74t
    63t
    -62t
    -30t
    -5t
    1t
    52t
    -82t
    109t
    -22t
    -66t
    119t
    -5t
    -112t
    53t
    125t
    -54t
    15t
    -4t
    5t
    13t
    -12t
    -30t
    -9t
    110t
    -57t
    -23t
    -107t
    121t
    72t
    -71t
    36t
    70t
    13t
    -2t
    97t
    -120t
    107t
    -64t
    -111t
    40t
    47t
    76t
    43t
    -62t
    -42t
    -128t
    33t
    65t
    -84t
    73t
    -118t
    -17t
    11t
    1t
    37t
    -93t
    99t
    93t
    -116t
    -126t
    105t
    -93t
    -99t
    -114t
    90t
    -47t
    -11t
    -90t
    93t
    -80t
    -12t
    -35t
    -24t
    -7t
    39t
    37t
    36t
    -66t
    109t
    -88t
    -64t
    -101t
    -50t
    -75t
    -69t
    -124t
    40t
    -110t
    30t
    8t
    121t
    51t
    25t
    46t
    -117t
    98t
    -67t
    61t
    96t
    57t
    -11t
    78t
    65t
    -93t
    -127t
    -10t
    11t
    30t
    5t
    52t
    -67t
    15t
    -108t
    -68t
    -91t
    -28t
    -93t
    59t
    124t
    -17t
    103t
    17t
    -41t
    44t
    71t
    51t
    10t
    -1t
    76t
    57t
    -54t
    103t
    92t
    -38t
    78t
    11t
    104t
    80t
    90t
    80t
    45t
    -7t
    107t
    -35t
    69t
    -69t
    89t
    -15t
    -6t
    56t
    33t
    9t
    26t
    117t
    -121t
    87t
    -108t
    106t
    105t
    -4t
    -36t
    -37t
    22t
    57t
    -33t
    -122t
    -71t
    -114t
    -12t
    84t
    -98t
    105t
    119t
    11t
    12t
    36t
    88t
    -112t
    72t
    -40t
    -40t
    -50t
    33t
    19t
    -77t
    118t
    -79t
    27t
    109t
    32t
    -122t
    -103t
    28t
    -119t
    -80t
    27t
    -11t
    9t
    67t
    -53t
    85t
    -3t
    118t
    36t
    35t
    18t
    64t
    -85t
    99t
    -15t
    -11t
    -72t
    125t
    -89t
    -36t
    27t
    5t
    104t
    -41t
    45t
    78t
    67t
    -74t
    -66t
    76t
    -59t
    -110t
    -94t
    2t
    -98t
    88t
    -53t
    35t
    75t
    -125t
    0t
    92t
    83t
    -126t
    -4t
    -32t
    35t
    -18t
    53t
    22t
    -85t
    -62t
    86t
    -103t
    -42t
    17t
    127t
    105t
    -120t
    -41t
    -124t
    -86t
    39t
    -123t
    -14t
    -36t
    -66t
    37t
    -97t
    -37t
    125t
    6t
    -119t
    42t
    110t
    109t
    -74t
    -126t
    32t
    12t
    -79t
    -128t
    -52t
    -4t
    -87t
    -126t
    127t
    -105t
    -31t
    -101t
    100t
    54t
    -42t
    70t
    65t
    50t
    -19t
    -66t
    -93t
    116t
    -81t
    -14t
    -102t
    94t
    28t
    -12t
    111t
    79t
    124t
    44t
    -102t
    -46t
    -47t
    114t
    82t
    -116t
    103t
    69t
    42t
    95t
    -98t
    87t
    -71t
    -30t
    -66t
    -29t
    73t
    60t
    -90t
    21t
    -79t
    71t
    -72t
    -61t
    84t
    -33t
    -51t
    -97t
    -19t
    86t
    -18t
    -17t
    115t
    -38t
    43t
    -75t
    18t
    34t
    115t
    -43t
    70t
    21t
    122t
    -117t
    -71t
    -93t
    95t
    -28t
    70t
    35t
    -51t
    117t
    -87t
    76t
    88t
    -83t
    46t
    -25t
    39t
    91t
    127t
    -75t
    -84t
    9t
    47t
    95t
    83t
    -18t
    -13t
    1t
    123t
    -60t
    20t
    22t
    42t
    -78t
    77t
    -39t
    -80t
    -8t
    105t
    -26t
    69t
    70t
    -7t
    -47t
    101t
    -84t
    35t
    -104t
    -17t
    73t
    58t
    -23t
    2t
    -127t
    52t
    -80t
    -48t
    103t
    -58t
    9t
    83t
    -29t
    33t
    91t
    3t
    100t
    14t
    35t
    -48t
    -14t
    -32t
    -36t
    95t
    -77t
    21t
    -88t
    0t
    17t
    -19t
    -121t
    -63t
    -33t
    89t
    50t
    -95t
    105t
    -62t
    94t
    -127t
    -118t
    -59t
    1t
    -6t
    -71t
    112t
    68t
    100t
    127t
    27t
    78t
    60t
    66t
    13t
    41t
    -28t
    100t
    -123t
    18t
    4t
    124t
    -102t
    61t
    -119t
    -30t
    78t
    57t
    43t
    -70t
    -17t
    -45t
    88t
    -1t
    -65t
    127t
    -84t
    4t
    116t
    -17t
    119t
    -117t
    21t
    -123t
    -76t
    52t
    98t
    79t
    -57t
    108t
    -52t
    -28t
    104t
    75t
    88t
    15t
    74t
    -109t
    63t
    68t
    -79t
    -95t
    -30t
    -87t
    -122t
    -96t
    -37t
    0t
    -121t
    -47t
    17t
    111t
    32t
    -80t
    -18t
    69t
    37t
    -27t
    19t
    -5t
    79t
    -3t
    13t
    -50t
    -53t
    -49t
    45t
    -120t
    85t
    12t
    -84t
    119t
    -115t
    -72t
    3t
    81t
    122t
    74t
    42t
    82t
    -10t
    -89t
    -115t
    -8t
    32t
    70t
    49t
    63t
    -6t
    106t
    -22t
    -116t
    -70t
    97t
    46t
    -119t
    65t
    118t
    -98t
    78t
    103t
    44t
    116t
    -79t
    95t
    -90t
    -38t
    74t
    -106t
    -60t
    115t
    21t
    -48t
    22t
    67t
    -17t
    48t
    68t
    101t
    39t
    61t
    -45t
    8t
    4t
    66t
    125t
    -23t
    -119t
    79t
    52t
    -35t
    109t
    -3t
    -82t
    -70t
    39t
    40t
    -126t
    -126t
    109t
    -123t
    -115t
    -26t
    -95t
    -17t
    39t
    -110t
    -102t
    -37t
    -78t
    81t
    -96t
    87t
    -96t
    -4t
    -124t
    -46t
    -45t
    -125t
    -25t
    -17t
    67t
    -36t
    107t
    5t
    -116t
    -124t
    -98t
    12t
    -75t
    72t
    -55t
    13t
    -42t
    118t
    -107t
    -32t
    67t
    12t
    89t
    13t
    31t
    -75t
    -127t
    -111t
    15t
    21t
    -36t
    60t
    -63t
    85t
    39t
    17t
    99t
    4t
    88t
    104t
    -73t
    -109t
    -19t
    -82t
    -85t
    42t
    120t
    118t
    20t
    -1t
    58t
    -31t
    114t
    -61t
    -107t
    -30t
    -23t
    17t
    -69t
    -110t
    10t
    -54t
    16t
    12t
    65t
    15t
    100t
    -125t
    50t
    22t
    118t
    21t
    113t
    -106t
    2t
    17t
    -94t
    -67t
    -79t
    -77t
    25t
    87t
    -46t
    -108t
    -87t
    -55t
    62t
    52t
    123t
    88t
    56t
    68t
    79t
    -112t
    122t
    23t
    -8t
    -112t
    83t
    21t
    105t
    -113t
    37t
    -56t
    73t
    6t
    57t
    -60t
    30t
    -78t
    86t
    -1t
    -69t
    -96t
    -33t
    -73t
    -43t
    24t
    -114t
    -87t
    -57t
    23t
    36t
    112t
    -33t
    71t
    -29t
    120t
    78t
    -97t
    35t
    122t
    -106t
    46t
    89t
    23t
    -98t
    -35t
    62t
    -125t
    -38t
    44t
    28t
    113t
    -113t
    83t
    119t
    -26t
    -19t
    19t
    -126t
    8t
    -91t
    106t
    113t
    114t
    84t
    90t
    99t
    65t
    -41t
    65t
    44t
    -79t
    -120t
    -90t
    -16t
    -50t
    -64t
    64t
    65t
    3t
    72t
    13t
    30t
    8t
    -120t
    -122t
    -54t
    -56t
    -124t
    -115t
    -12t
    -45t
    -69t
    -60t
    7t
    66t
    122t
    102t
    86t
    -21t
    6t
    -113t
    -33t
    -25t
    -112t
    -87t
    -91t
    -53t
    73t
    117t
    -65t
    40t
    -91t
    -75t
    126t
    -22t
    5t
    102t
    -87t
    -10t
    7t
    -82t
    -43t
    -124t
    -102t
    -64t
    47t
    -49t
    -91t
    -68t
    -65t
    83t
    -55t
    90t
    -66t
    -73t
    78t
    46t
    -116t
    118t
    -38t
    107t
    97t
    -99t
    -91t
    -108t
    -48t
    107t
    73t
    -23t
    68t
    -128t
    41t
    115t
    -32t
    -23t
    -32t
    -10t
    -117t
    31t
    -77t
    6t
    -88t
    14t
    70t
    -102t
    73t
    17t
    102t
    -92t
    112t
    -126t
    58t
    82t
    -19t
    4t
    -5t
    -74t
    0t
    86t
    116t
    38t
    121t
    7t
    29t
    124t
    49t
    39t
    -120t
    45t
    -38t
    19t
    -94t
    81t
    0t
    12t
    100t
    -1t
    89t
    49t
    97t
    34t
    105t
    38t
    56t
    18t
    -8t
    112t
    -86t
    118t
    -37t
    88t
    30t
    -86t
    9t
    90t
    88t
    121t
    -107t
    -86t
    -58t
    -13t
    108t
    -4t
    -5t
    22t
    -106t
    -54t
    -54t
    107t
    -20t
    4t
    74t
    -17t
    100t
    18t
    -106t
    48t
    -25t
    91t
    96t
    -48t
    47t
    -33t
    36t
    61t
    117t
    67t
    -90t
    42t
    -56t
    -123t
    105t
    67t
    23t
    75t
    39t
    -13t
    126t
    99t
    15t
    97t
    29t
    -47t
    94t
    15t
    19t
    3t
    -66t
    -89t
    -11t
    -31t
    30t
    67t
    40t
    68t
    7t
    -22t
    -113t
    -82t
    94t
    127t
    24t
    -78t
    109t
    23t
    -10t
    -110t
    12t
    35t
    -18t
    21t
    121t
    97t
    -93t
    -8t
    -117t
    -124t
    9t
    -89t
    -94t
    -29t
    33t
    -96t
    49t
    -120t
    -98t
    89t
    -99t
    68t
    53t
    28t
    -75t
    -2t
    -79t
    -96t
    -106t
    46t
    -11t
    97t
    -23t
    -76t
    67t
    -9t
    36t
    101t
    -123t
    109t
    120t
    2t
    -51t
    27t
    -99t
    -71t
    73t
    -64t
    99t
    113t
    -63t
    -83t
    36t
    -89t
    -12t
    -61t
    -119t
    24t
    50t
    -60t
    25t
    -122t
    -101t
    -56t
    -32t
    78t
    117t
    -13t
    12t
    51t
    -12t
    56t
    104t
    -15t
    62t
    -109t
    -74t
    96t
    -122t
    -119t
    -22t
    26t
    -43t
    -105t
    -76t
    39t
    -27t
    60t
    68t
    31t
    -77t
    97t
    -9t
    48t
    -22t
    10t
    -50t
    14t
    -6t
    111t
    -61t
    8t
    8t
    79t
    103t
    44t
    115t
    84t
    66t
    -31t
    -106t
    12t
    -60t
    -93t
    -37t
    -38t
    30t
    -94t
    54t
    83t
    10t
    -20t
    78t
    -54t
    -110t
    63t
    -59t
    12t
    84t
    115t
    10t
    -2t
    120t
    -15t
    -122t
    53t
    57t
    56t
    90t
    -112t
    91t
    88t
    -6t
    -90t
    11t
    -120t
    -3t
    -76t
    -63t
    86t
    27t
    39t
    42t
    70t
    47t
    -72t
    -39t
    55t
    57t
    28t
    44t
    3t
    17t
    55t
    13t
    -6t
    -54t
    -67t
    -126t
    -112t
    46t
    -20t
    -67t
    43t
    -27t
    -11t
    -11t
    79t
    -26t
    -66t
    112t
    92t
    1t
    -86t
    -102t
    88t
    56t
    -89t
    -93t
    -120t
    -35t
    58t
    72t
    11t
    86t
    -37t
    35t
    -9t
    69t
    48t
    -53t
    -65t
    -26t
    119t
    5t
    103t
    80t
    -33t
    -93t
    -80t
    -22t
    -7t
    93t
    40t
    -101t
    49t
    52t
    118t
    -10t
    28t
    -44t
    -46t
    -125t
    -36t
    -3t
    -90t
    3t
    -92t
    31t
    99t
    -22t
    30t
    -24t
    -33t
    36t
    -30t
    94t
    -73t
    -45t
    -30t
    16t
    60t
    -65t
    -118t
    29t
    104t
    83t
    1t
    112t
    -71t
    0t
    75t
    -115t
    -91t
    78t
    46t
    -86t
    -4t
    -72t
    -23t
    51t
    -58t
    123t
    -87t
    -81t
    66t
    57t
    -94t
    -53t
    24t
    55t
    -127t
    120t
    -113t
    65t
    91t
    -21t
    113t
    12t
    2t
    -4t
    -34t
    -58t
    46t
    -75t
    -91t
    -76t
    -56t
    100t
    -30t
    -26t
    -103t
    50t
    80t
    92t
    -8t
    -28t
    10t
    -117t
    -48t
    76t
    56t
    -117t
    62t
    -79t
    38t
    118t
    36t
    31t
    -16t
    -81t
    0t
    38t
    -44t
    -26t
    -43t
    -73t
    40t
    74t
    -48t
    93t
    -104t
    17t
    -79t
    103t
    32t
    123t
    -63t
    86t
    27t
    -97t
    8t
    -112t
    -77t
    16t
    23t
    88t
    83t
    37t
    -55t
    -50t
    -90t
    -30t
    82t
    69t
    -67t
    -111t
    -29t
    -27t
    -109t
    -8t
    42t
    -111t
    18t
    -55t
    10t
    46t
    112t
    -91t
    48t
    102t
    -28t
    -5t
    -113t
    -19t
    -84t
    19t
    -58t
    79t
    3t
    93t
    -6t
    -128t
    -89t
    12t
    -47t
    8t
    -91t
    -103t
    -111t
    -32t
    -35t
    20t
    -32t
    113t
    -122t
    -61t
    93t
    -2t
    15t
    -55t
    -83t
    -41t
    35t
    -80t
    -39t
    -26t
    77t
    -90t
    -56t
    -73t
    36t
    29t
    52t
    -34t
    -70t
    61t
    -17t
    -55t
    114t
    -24t
    -45t
    85t
    -117t
    76t
    -70t
    121t
    -38t
    -72t
    55t
    -100t
    -99t
    86t
    21t
    87t
    -37t
    -115t
    30t
    -1t
    33t
    100t
    -55t
    123t
    -77t
    113t
    -128t
    3t
    -17t
    -18t
    -120t
    104t
    -26t
    93t
    14t
    -106t
    -117t
    106t
    -62t
    3t
    -20t
    54t
    8t
    60t
    2t
    -76t
    108t
    10t
    33t
    73t
    -13t
    -86t
    -93t
    -123t
    -42t
    67t
    124t
    -104t
    -38t
    73t
    107t
    106t
    -125t
    -68t
    -60t
    -66t
    14t
    -92t
    95t
    12t
    43t
    54t
    -30t
    -31t
    113t
    87t
    112t
    87t
    -90t
    74t
    51t
    73t
    51t
    84t
    127t
    -3t
    89t
    -62t
    0t
    -105t
    2t
    -78t
    18t
    51t
    16t
    106t
    76t
    105t
    74t
    -67t
    79t
    25t
    -78t
    -65t
    123t
    -41t
    55t
    -100t
    -79t
    29t
    -33t
    37t
    -15t
    -120t
    54t
    -107t
    82t
    -11t
    23t
    113t
    -104t
    -122t
    70t
    -102t
    74t
    113t
    80t
    17t
    -60t
    -86t
    -105t
    -28t
    94t
    124t
    95t
    116t
    -77t
    -39t
    1t
    -10t
    108t
    -13t
    -80t
    -51t
    45t
    94t
    101t
    17t
    -105t
    -90t
    -93t
    -16t
    11t
    58t
    21t
    -90t
    -44t
    -33t
    -24t
    -58t
    -39t
    -64t
    -49t
    -45t
    -12t
    32t
    -79t
    82t
    -12t
    -71t
    10t
    -58t
    103t
    -52t
    127t
    110t
    112t
    27t
    100t
    -64t
    -30t
    -50t
    117t
    -108t
    -50t
    74t
    82t
    108t
    -36t
    86t
    28t
    -103t
    -102t
    78t
    -24t
    61t
    -59t
    30t
    -4t
    -86t
    63t
    -16t
    92t
    89t
    -106t
    65t
    -28t
    -65t
    41t
    -81t
    -2t
    -87t
    72t
    -38t
    114t
    -36t
    -71t
    -117t
    105t
    20t
    -128t
    18t
    2t
    -101t
    11t
    -72t
    -103t
    -53t
    28t
    -55t
    -73t
    120t
    -68t
    -73t
    53t
    26t
    -37t
    -2t
    44t
    -44t
    -34t
    23t
    97t
    115t
    65t
    79t
    25t
    54t
    53t
    -108t
    -87t
    -37t
    -68t
    -113t
    -89t
    9t
    124t
    -102t
    -62t
    62t
    123t
    90t
    -89t
    91t
    32t
    -88t
    -15t
    88t
    -62t
    -96t
    94t
    -74t
    21t
    114t
    -30t
    -52t
    112t
    -34t
    -22t
    120t
    113t
    -77t
    -93t
    -2t
    -82t
    -80t
    -128t
    120t
    54t
    -120t
    112t
    19t
    53t
    83t
    -55t
    -18t
    48t
    120t
    95t
    -60t
    -123t
    23t
    94t
    -23t
    81t
    121t
    59t
    -72t
    122t
    108t
    8t
    46t
    26t
    -45t
    -51t
    -7t
    88t
    77t
    106t
    92t
    104t
    -52t
    -73t
    103t
    29t
    -24t
    10t
    -88t
    8t
    89t
    57t
    6t
    48t
    71t
    -59t
    -73t
    -54t
    -26t
    109t
    -62t
    66t
    -19t
    93t
    -79t
    79t
    -68t
    5t
    -13t
    -109t
    -40t
    32t
    78t
    41t
    63t
    -41t
    109t
    41t
    -123t
    -35t
    -29t
    19t
    -74t
    -75t
    92t
    38t
    -127t
    -101t
    99t
    83t
    96t
    108t
    68t
    66t
    116t
    -42t
    112t
    -106t
    -5t
    9t
    -81t
    80t
    -93t
    6t
    124t
    47t
    -20t
    62t
    -58t
    -55t
    103t
    9t
    3t
    -43t
    72t
    -10t
    82t
    39t
    -126t
    125t
    -22t
    38t
    -65t
    72t
    101t
    -24t
    36t
    86t
    6t
    42t
    87t
    64t
    107t
    -101t
    -119t
    -43t
    -3t
    -35t
    -102t
    -35t
    -108t
    -119t
    71t
    -55t
    86t
    -107t
    -101t
    90t
    70t
    34t
    83t
    -1t
    -119t
    15t
    -113t
    24t
    124t
    10t
    -115t
    105t
    93t
    -78t
    115t
    -24t
    80t
    12t
    47t
    -42t
    -119t
    -97t
    -28t
    11t
    -5t
    -26t
    -43t
    -5t
    16t
    47t
    111t
    -1t
    -58t
    108t
    -77t
    -8t
    35t
    57t
    26t
    23t
    120t
    20t
    -55t
    -95t
    119t
    94t
    -96t
    31t
    -42t
    -5t
    -103t
    -46t
    50t
    -69t
    -35t
    56t
    -7t
    -101t
    119t
    72t
    107t
    107t
    103t
    121t
    104t
    26t
    29t
    84t
    -1t
    40t
    -59t
    74t
    90t
    -39t
    -29t
    85t
    -82t
    4t
    -29t
    88t
    -59t
    40t
    -118t
    -40t
    -78t
    77t
    -38t
    -74t
    -68t
    -26t
    42t
    -65t
    -19t
    1t
    116t
    -77t
    62t
    -14t
    -62t
    -127t
    106t
    -99t
    -117t
    -9t
    -91t
    105t
    58t
    -75t
    70t
    -4t
    90t
    32t
    -90t
    41t
    -95t
    -39t
    -45t
    127t
    42t
    123t
    62t
    89t
    -64t
    69t
    -65t
    -94t
    12t
    -6t
    95t
    -85t
    -71t
    9t
    -74t
    -103t
    68t
    49t
    92t
    56t
    -89t
    97t
    77t
    90t
    65t
    123t
    -108t
    67t
    -5t
    124t
    -104t
    119t
    28t
    -39t
    109t
    50t
    79t
    21t
    39t
    -41t
    -78t
    -43t
    -2t
    -17t
    30t
    106t
    -117t
    -102t
    73t
    -118t
    -38t
    37t
    -108t
    -90t
    28t
    -22t
    -88t
    -21t
    31t
    -108t
    1t
    75t
    -94t
    100t
    91t
    -50t
    -63t
    84t
    -89t
    45t
    27t
    -30t
    59t
    54t
    43t
    -89t
    -76t
    -14t
    -13t
    -101t
    19t
    41t
    -93t
    71t
    -60t
    15t
    6t
    94t
    -85t
    46t
    120t
    -14t
    -56t
    -127t
    63t
    -128t
    2t
    21t
    88t
    2t
    -101t
    -14t
    -92t
    -42t
    39t
    -94t
    100t
    -93t
    -35t
    -90t
    -106t
    80t
    84t
    -73t
    32t
    -78t
    28t
    -101t
    55t
    52t
    -76t
    51t
    23t
    42t
    61t
    -40t
    46t
    -44t
    -60t
    -3t
    113t
    19t
    -71t
    -48t
    16t
    1t
    41t
    -69t
    3t
    25t
    -35t
    55t
    -94t
    -17t
    66t
    -91t
    57t
    -9t
    94t
    -30t
    117t
    28t
    62t
    97t
    -26t
    -101t
    72t
    23t
    -57t
    75t
    37t
    28t
    19t
    97t
    43t
    110t
    -36t
    -89t
    16t
    114t
    -100t
    18t
    55t
    -85t
    -63t
    -17t
    -101t
    49t
    -15t
    101t
    -59t
    50t
    -95t
    82t
    76t
    60t
    32t
    11t
    -19t
    -90t
    32t
    -36t
    -4t
    -74t
    123t
    115t
    60t
    112t
    85t
    -101t
    51t
    11t
    38t
    -110t
    -118t
    -3t
    -73t
    111t
    -79t
    63t
    71t
    24t
    59t
    86t
    -113t
    71t
    74t
    -33t
    -122t
    -68t
    92t
    93t
    -38t
    -106t
    -33t
    -3t
    -50t
    106t
    -120t
    30t
    91t
    39t
    -94t
    -111t
    -68t
    101t
    -31t
    100t
    -80t
    -112t
    72t
    -60t
    -46t
    -108t
    -14t
    -82t
    -4t
    -40t
    122t
    -73t
    -105t
    -103t
    -63t
    83t
    84t
    9t
    85t
    57t
    37t
    85t
    1t
    -112t
    -77t
    41t
    -2t
    -56t
    90t
    21t
    127t
    -128t
    31t
    106t
    -27t
    -52t
    -51t
    -88t
    64t
    127t
    -88t
    21t
    78t
    126t
    -115t
    39t
    37t
    99t
    32t
    48t
    -104t
    -122t
    46t
    -83t
    85t
    -95t
    -102t
    -33t
    -70t
    -44t
    -93t
    -71t
    57t
    86t
    -48t
    93t
    21t
    11t
    -23t
    61t
    34t
    71t
    102t
    126t
    54t
    70t
    56t
    31t
    79t
    125t
    41t
    84t
    -98t
    -111t
    -32t
    50t
    -47t
    54t
    -20t
    -14t
    26t
    -48t
    123t
    14t
    -92t
    78t
    5t
    -105t
    8t
    32t
    70t
    101t
    -39t
    -8t
    -74t
    -3t
    39t
    4t
    -74t
    -7t
    -60t
    53t
    -54t
    49t
    -40t
    -16t
    -82t
    -102t
    -6t
    34t
    -106t
    19t
    -58t
    54t
    22t
    12t
    11t
    17t
    76t
    -119t
    114t
    -97t
    17t
    122t
    -62t
    32t
    -64t
    -47t
    -76t
    -100t
    -49t
    -93t
    -116t
    -9t
    80t
    44t
    -102t
    105t
    -124t
    73t
    -123t
    86t
    -20t
    -28t
    -79t
    28t
    99t
    91t
    -18t
    59t
    -128t
    2t
    76t
    2t
    -66t
    65t
    -44t
    -91t
    -43t
    -13t
    70t
    -45t
    72t
    22t
    115t
    52t
    20t
    41t
    -109t
    -118t
    127t
    22t
    65t
    39t
    68t
    103t
    -71t
    -90t
    -79t
    -125t
    -122t
    -125t
    55t
    81t
    111t
    -7t
    99t
    -79t
    60t
    -26t
    9t
    37t
    38t
    4t
    29t
    96t
    -3t
    1t
    12t
    74t
    -10t
    35t
    -98t
    65t
    -103t
    -115t
    -79t
    -4t
    -98t
    89t
    -72t
    42t
    -39t
    59t
    -21t
    28t
    -60t
    32t
    -88t
    -36t
    98t
    -116t
    -69t
    62t
    44t
    94t
    71t
    75t
    14t
    120t
    122t
    -29t
    36t
    -63t
    107t
    19t
    0t
    -18t
    -9t
    -90t
    -70t
    78t
    42t
    -113t
    -59t
    113t
    81t
    87t
    -32t
    4t
    7t
    -95t
    -3t
    -95t
    -39t
    42t
    12t
    93t
    2t
    -17t
    -54t
    -92t
    -126t
    20t
    88t
    92t
    2t
    -105t
    60t
    94t
    -79t
    -68t
    -19t
    -121t
    -123t
    -110t
    61t
    -87t
    80t
    37t
    -70t
    -15t
    65t
    -103t
    0t
    92t
    107t
    50t
    33t
    -122t
    -107t
    31t
    -121t
    71t
    -19t
    70t
    30t
    28t
    108t
    92t
    115t
    -8t
    121t
    -104t
    -26t
    76t
    -114t
    -45t
    -60t
    122t
    -84t
    69t
    20t
    -37t
    -78t
    115t
    -20t
    -10t
    -57t
    -4t
    -45t
    27t
    56t
    33t
    103t
    -86t
    31t
    17t
    -115t
    -67t
    -14t
    -77t
    -73t
    -11t
    39t
    91t
    9t
    -105t
    -74t
    -45t
    52t
    84t
    -26t
    -1t
    -115t
    70t
    -121t
    -118t
    -8t
    -89t
    26t
    101t
    104t
    94t
    -82t
    40t
    -37t
    -31t
    103t
    4t
    115t
    14t
    -11t
    27t
    68t
    81t
    -106t
    42t
    -120t
    -24t
    14t
    2t
    35t
    -94t
    87t
    78t
    -112t
    -18t
    33t
    -97t
    1t
    -101t
    -33t
    114t
    36t
    -104t
    -21t
    -8t
    -40t
    -62t
    108t
    49t
    27t
    9t
    -110t
    -50t
    -16t
    3t
    -86t
    -62t
    -3t
    -112t
    83t
    56t
    -47t
    116t
    78t
    85t
    -38t
    -32t
    65t
    113t
    99t
    -32t
    -91t
    45t
    79t
    71t
    86t
    19t
    -113t
    -61t
    -96t
    -34t
    57t
    -40t
    101t
    -40t
    -47t
    -27t
    2t
    -55t
    44t
    -23t
    94t
    123t
    -93t
    117t
    -116t
    -6t
    -43t
    7t
    -86t
    -102t
    37t
    81t
    90t
    -125t
    -30t
    -6t
    -30t
    68t
    8t
    -36t
    71t
    17t
    24t
    54t
    -33t
    34t
    -94t
    46t
    2t
    50t
    97t
    -79t
    72t
    -108t
    -43t
    10t
    -41t
    -21t
    -119t
    17t
    -115t
    -112t
    35t
    -3t
    -127t
    -7t
    -120t
    -18t
    -128t
    101t
    21t
    -63t
    16t
    65t
    32t
    31t
    27t
    126t
    -41t
    123t
    -90t
    26t
    -19t
    66t
    91t
    -101t
    -72t
    -94t
    53t
    -27t
    -68t
    28t
    -21t
    -15t
    -49t
    -40t
    -61t
    124t
    114t
    -32t
    -77t
    64t
    -29t
    38t
    -68t
    19t
    -58t
    -94t
    -103t
    -53t
    64t
    -69t
    5t
    125t
    53t
    77t
    -18t
    -39t
    -75t
    98t
    64t
    -102t
    -57t
    -54t
    -124t
    -104t
    -51t
    125t
    47t
    -79t
    -52t
    20t
    -81t
    90t
    123t
    119t
    38t
    114t
    4t
    -1t
    -48t
    -25t
    -86t
    68t
    81t
    5t
    -99t
    32t
    -65t
    22t
    69t
    -71t
    12t
    -27t
    92t
    27t
    114t
    57t
    53t
    -32t
    -11t
    -49t
    -23t
    -64t
    -27t
    -68t
    83t
    -33t
    55t
    -119t
    65t
    62t
    68t
    113t
    29t
    86t
    84t
    -122t
    -96t
    -118t
    -43t
    -88t
    20t
    2t
    -96t
    -101t
    -24t
    -45t
    6t
    -37t
    -110t
    -58t
    -54t
    -72t
    -57t
    -2t
    117t
    -19t
    -6t
    67t
    106t
    17t
    54t
    88t
    50t
    107t
    94t
    -121t
    98t
    -34t
    29t
    20t
    -20t
    -42t
    60t
    100t
    94t
    83t
    -64t
    -106t
    -7t
    -114t
    -91t
    94t
    -69t
    -116t
    83t
    -127t
    -108t
    -31t
    -123t
    81t
    54t
    78t
    -15t
    57t
    36t
    -120t
    44t
    -6t
    -44t
    116t
    -49t
    -31t
    67t
    -105t
    66t
    -98t
    -78t
    0t
    84t
    43t
    -115t
    116t
    -3t
    -115t
    -17t
    63t
    -35t
    -31t
    -25t
    -46t
    -114t
    -13t
    99t
    -68t
    -106t
    72t
    -43t
    34t
    -54t
    119t
    92t
    36t
    -111t
    27t
    66t
    -9t
    -67t
    106t
    -116t
    108t
    -117t
    87t
    -125t
    20t
    35t
    -100t
    66t
    -29t
    -30t
    109t
    -12t
    54t
    -41t
    117t
    107t
    28t
    93t
    -43t
    -69t
    117t
    -37t
    16t
    37t
    48t
    88t
    -42t
    127t
    17t
    -85t
    22t
    -93t
    -109t
    -5t
    42t
    57t
    49t
    -77t
    66t
    -119t
    115t
    15t
    -3t
    109t
    -18t
    -97t
    125t
    -37t
    9t
    79t
    -86t
    27t
    -107t
    22t
    78t
    -94t
    54t
    6t
    -64t
    124t
    67t
    105t
    -106t
    86t
    -96t
    -50t
    99t
    79t
    84t
    -10t
    44t
    -80t
    -57t
    -106t
    8t
    -98t
    30t
    -5t
    95t
    -11t
    -112t
    -120t
    -80t
    54t
    -16t
    23t
    -76t
    88t
    95t
    -2t
    -60t
    76t
    -70t
    35t
    116t
    -104t
    -96t
    -73t
    -31t
    93t
    -91t
    26t
    95t
    23t
    10t
    -54t
    75t
    -38t
    107t
    -126t
    -78t
    11t
    81t
    65t
    49t
    93t
    106t
    27t
    2t
    1t
    15t
    -42t
    -63t
    -9t
    108t
    -126t
    4t
    -69t
    53t
    113t
    60t
    72t
    35t
    51t
    -110t
    111t
    -93t
    -116t
    2t
    124t
    -81t
    104t
    42t
    3t
    86t
    113t
    120t
    3t
    -23t
    85t
    -27t
    56t
    5t
    -84t
    -65t
    -92t
    41t
    75t
    -20t
    87t
    -21t
    36t
    26t
    -44t
    -78t
    66t
    -90t
    48t
    125t
    124t
    -10t
    -33t
    9t
    120t
    68t
    7t
    -22t
    -79t
    -120t
    117t
    125t
    -30t
    -8t
    -7t
    98t
    114t
    -56t
    73t
    -111t
    -119t
    68t
    56t
    15t
    -64t
    92t
    -104t
    -94t
    3t
    65t
    88t
    -25t
    -76t
    59t
    -125t
    -88t
    41t
    -95t
    53t
    -31t
    -38t
    5t
    31t
    -92t
    -73t
    68t
    60t
    100t
    54t
    -121t
    39t
    -10t
    -94t
    40t
    104t
    -19t
    -77t
    -101t
    -120t
    69t
    -91t
    -80t
    23t
    78t
    -32t
    -90t
    -76t
    65t
    -21t
    107t
    93t
    -27t
    38t
    -84t
    20t
    43t
    -123t
    119t
    49t
    7t
    66t
    -128t
    -75t
    -59t
    -25t
    123t
    8t
    71t
    123t
    106t
    54t
    -54t
    120t
    54t
    -125t
    -70t
    65t
    94t
    120t
    54t
    -124t
    -22t
    73t
    -99t
    -59t
    124t
    98t
    105t
    103t
    115t
    92t
    0t
    4t
    -91t
    17t
    -23t
    102t
    -89t
    59t
    114t
    -86t
    21t
    23t
    -88t
    87t
    -88t
    0t
    -44t
    -28t
    -91t
    -113t
    62t
    27t
    102t
    -1t
    -123t
    79t
    104t
    68t
    -45t
    -110t
    101t
    62t
    120t
    13t
    26t
    -25t
    -47t
    79t
    94t
    110t
    -23t
    -119t
    -85t
    48t
    112t
    -15t
    6t
    -58t
    -115t
    -99t
    61t
    -56t
    3t
    40t
    -89t
    -110t
    -124t
    -10t
    98t
    99t
    117t
    88t
    45t
    27t
    -128t
    -71t
    62t
    62t
    -3t
    -124t
    118t
    51t
    17t
    90t
    -120t
    -28t
    -91t
    88t
    123t
    104t
    49t
    -121t
    102t
    -43t
    66t
    51t
    -2t
    102t
    113t
    71t
    1t
    -53t
    -88t
    -81t
    49t
    59t
    -60t
    -53t
    100t
    46t
    -36t
    20t
    53t
    -98t
    86t
    119t
    -46t
    -24t
    46t
    84t
    91t
    -101t
    -96t
    -36t
    -127t
    17t
    -93t
    58t
    -98t
    -9t
    -94t
    90t
    -91t
    12t
    91t
    122t
    -29t
    -42t
    -6t
    5t
    -108t
    -127t
    -30t
    86t
    54t
    8t
    -4t
    121t
    1t
    -11t
    44t
    -65t
    54t
    112t
    -40t
    -122t
    23t
    58t
    -21t
    -103t
    123t
    64t
    -73t
    -74t
    37t
    100t
    67t
    -109t
    89t
    15t
    1t
    114t
    -105t
    102t
    16t
    26t
    34t
    -95t
    96t
    -7t
    80t
    60t
    98t
    107t
    64t
    36t
    -55t
    78t
    -81t
    26t
    87t
    -83t
    -88t
    -23t
    -35t
    -43t
    1t
    124t
    127t
    -97t
    -52t
    76t
    82t
    99t
    52t
    -57t
    37t
    124t
    -86t
    96t
    48t
    64t
    6t
    113t
    -120t
    78t
    23t
    99t
    102t
    -63t
    -66t
    -118t
    66t
    94t
    -2t
    -68t
    12t
    101t
    -1t
    -124t
    111t
    123t
    122t
    108t
    -78t
    17t
    -19t
    -26t
    4t
    -57t
    -51t
    -55t
    -53t
    -49t
    -118t
    -84t
    19t
    96t
    21t
    21t
    113t
    19t
    30t
    -79t
    -23t
    -86t
    -89t
    -76t
    113t
    110t
    14t
    98t
    -94t
    106t
    -16t
    47t
    23t
    83t
    69t
    78t
    108t
    -109t
    -29t
    -26t
    8t
    -128t
    -100t
    25t
    -42t
    -45t
    -23t
    -24t
    -35t
    -27t
    -75t
    42t
    -5t
    18t
    60t
    108t
    95t
    -71t
    45t
    80t
    116t
    -82t
    37t
    70t
    109t
    57t
    -82t
    -92t
    -94t
    -81t
    112t
    110t
    -45t
    -87t
    -55t
    104t
    117t
    -40t
    108t
    -97t
    -90t
    -88t
    -98t
    9t
    68t
    -26t
    -103t
    -112t
    -75t
    72t
    -100t
    -84t
    118t
    112t
    -16t
    -56t
    -110t
    34t
    103t
    -79t
    30t
    73t
    -112t
    112t
    -36t
    -121t
    78t
    -14t
    -47t
    30t
    94t
    83t
    -84t
    117t
    -83t
    -31t
    -14t
    -46t
    -14t
    -25t
    -94t
    28t
    -60t
    53t
    10t
    -70t
    14t
    122t
    51t
    21t
    -13t
    -67t
    -39t
    -49t
    20t
    83t
    36t
    23t
    17t
    107t
    -69t
    -67t
    -50t
    -122t
    91t
    79t
    -74t
    -57t
    -26t
    -105t
    -40t
    86t
    -18t
    -49t
    73t
    -116t
    16t
    17t
    32t
    -97t
    90t
    -91t
    41t
    -37t
    51t
    -127t
    87t
    -106t
    -69t
    -10t
    69t
    -42t
    100t
    77t
    31t
    -36t
    -66t
    98t
    110t
    5t
    45t
    -55t
    -89t
    -66t
    -9t
    126t
    6t
    -124t
    -111t
    0t
    122t
    -62t
    -54t
    -109t
    -91t
    3t
    -9t
    7t
    -108t
    23t
    75t
    -103t
    -105t
    10t
    55t
    113t
    -64t
    -31t
    -6t
    -30t
    -120t
    29t
    49t
    66t
    126t
    -96t
    -19t
    -46t
    -118t
    7t
    91t
    56t
    46t
    -103t
    81t
    47t
    69t
    -83t
    78t
    51t
    -126t
    35t
    57t
    -111t
    -57t
    42t
    -52t
    78t
    -21t
    -25t
    -39t
    -61t
    122t
    -120t
    18t
    71t
    4t
    115t
    13t
    -89t
    121t
    13t
    109t
    -49t
    -104t
    -7t
    112t
    53t
    44t
    -42t
    -126t
    39t
    -4t
    104t
    119t
    99t
    32t
    123t
    97t
    43t
    -71t
    -110t
    -38t
    84t
    -97t
    -111t
    69t
    12t
    22t
    -80t
    -51t
    -2t
    -39t
    69t
    71t
    55t
    62t
    -48t
    -78t
    -107t
    90t
    21t
    -108t
    12t
    96t
    74t
    -116t
    -99t
    -42t
    -92t
    115t
    -118t
    27t
    -8t
    -84t
    126t
    -82t
    -33t
    -68t
    -66t
    -96t
    -115t
    -52t
    74t
    23t
    15t
    -85t
    -40t
    21t
    -99t
    -108t
    50t
    -67t
    33t
    57t
    83t
    -66t
    -75t
    -71t
    -82t
    34t
    91t
    107t
    -90t
    35t
    -75t
    57t
    -103t
    59t
    -6t
    -36t
    115t
    48t
    -124t
    -81t
    97t
    61t
    104t
    -35t
    -24t
    -74t
    -45t
    -31t
    -41t
    79t
    72t
    35t
    -12t
    41t
    116t
    33t
    -15t
    -26t
    58t
    -111t
    -62t
    -75t
    40t
    -1t
    16t
    -113t
    110t
    111t
    63t
    13t
    -10t
    -73t
    65t
    -31t
    -64t
    -33t
    37t
    14t
    72t
    72t
    36t
    105t
    70t
    100t
    77t
    -119t
    -25t
    -64t
    8t
    -3t
    86t
    -89t
    -108t
    -127t
    55t
    -86t
    37t
    -24t
    -53t
    120t
    124t
    -92t
    9t
    56t
    54t
    63t
    -100t
    -82t
    40t
    14t
    -44t
    36t
    101t
    37t
    -109t
    110t
    -123t
    2t
    -48t
    28t
    118t
    -83t
    -85t
    92t
    21t
    -126t
    72t
    -90t
    -86t
    49t
    -125t
    111t
    -111t
    -108t
    119t
    -96t
    -25t
    41t
    45t
    -11t
    91t
    -122t
    -54t
    96t
    26t
    115t
    37t
    -119t
    64t
    -84t
    94t
    110t
    -20t
    -86t
    -61t
    72t
    57t
    -97t
    71t
    6t
    -12t
    -47t
    -93t
    -44t
    124t
    -69t
    -50t
    -3t
    -38t
    -91t
    -90t
    123t
    -127t
    -7t
    16t
    85t
    79t
    106t
    -69t
    -92t
    -99t
    -64t
    47t
    118t
    -110t
    -128t
    -73t
    68t
    21t
    14t
    -98t
    -109t
    99t
    12t
    -114t
    30t
    63t
    78t
    33t
    -9t
    -100t
    -14t
    -99t
    -108t
    -42t
    -79t
    -64t
    92t
    -90t
    -42t
    -32t
    9t
    117t
    -35t
    31t
    -34t
    -96t
    23t
    36t
    4t
    88t
    -116t
    -120t
    112t
    67t
    -122t
    49t
    11t
    -116t
    99t
    99t
    27t
    15t
    -44t
    -86t
    -81t
    48t
    -39t
    -10t
    -56t
    117t
    -48t
    23t
    -89t
    47t
    40t
    -28t
    58t
    40t
    56t
    65t
    82t
    -67t
    0t
    -63t
    -83t
    108t
    23t
    75t
    -28t
    -41t
    86t
    -95t
    23t
    26t
    -38t
    -79t
    -5t
    -122t
    -35t
    -61t
    16t
    -102t
    54t
    22t
    3t
    73t
    -113t
    107t
    -37t
    106t
    -89t
    20t
    29t
    120t
    53t
    -99t
    118t
    58t
    -121t
    -93t
    67t
    13t
    119t
    -43t
    -24t
    -105t
    84t
    -63t
    98t
    -37t
    -22t
    -124t
    90t
    80t
    115t
    -83t
    -118t
    64t
    -64t
    -122t
    -40t
    -91t
    -91t
    -15t
    8t
    -104t
    126t
    -62t
    -55t
    -57t
    -89t
    70t
    -76t
    -69t
    123t
    98t
    101t
    -114t
    -46t
    10t
    -35t
    45t
    13t
    -92t
    103t
    70t
    -122t
    -17t
    114t
    -75t
    -42t
    105t
    29t
    42t
    120t
    -64t
    78t
    -92t
    -32t
    64t
    -64t
    87t
    -15t
    -68t
    120t
    -114t
    115t
    -49t
    -19t
    102t
    50t
    74t
    59t
    75t
    70t
    86t
    -59t
    -122t
    -122t
    76t
    -107t
    64t
    -11t
    -54t
    99t
    -111t
    104t
    -44t
    -25t
    -101t
    -24t
    90t
    -102t
    -21t
    -2t
    23t
    -59t
    69t
    27t
    60t
    74t
    -115t
    110t
    106t
    44t
    90t
    -88t
    -33t
    39t
    54t
    122t
    23t
    119t
    -80t
    -110t
    -96t
    13t
    -43t
    3t
    -31t
    -128t
    -19t
    65t
    39t
    77t
    44t
    60t
    106t
    57t
    -36t
    78t
    -22t
    22t
    -94t
    115t
    -84t
    36t
    80t
    -22t
    51t
    38t
    25t
    76t
    -70t
    60t
    -22t
    32t
    -39t
    -15t
    -40t
    -42t
    -126t
    -28t
    115t
    57t
    126t
    -41t
    -115t
    44t
    -105t
    -47t
    -74t
    123t
    -96t
    -42t
    87t
    13t
    -85t
    107t
    121t
    108t
    -126t
    -86t
    -98t
    -26t
    105t
    -123t
    -5t
    79t
    -56t
    124t
    66t
    3t
    80t
    68t
    -86t
    51t
    -38t
    96t
    100t
    87t
    75t
    66t
    82t
    108t
    50t
    -33t
    124t
    2t
    -106t
    126t
    -32t
    -26t
    -62t
    -66t
    -117t
    116t
    -92t
    51t
    71t
    -91t
    22t
    107t
    3t
    81t
    -55t
    -43t
    -98t
    15t
    16t
    6t
    -78t
    7t
    56t
    68t
    119t
    50t
    -97t
    3t
    -95t
    114t
    -122t
    101t
    -99t
    -22t
    55t
    -24t
    -53t
    102t
    66t
    77t
    79t
    -34t
    -11t
    -115t
    -19t
    -56t
    23t
    16t
    105t
    87t
    13t
    -124t
    -107t
    34t
    -68t
    85t
    104t
    -42t
    92t
    18t
    95t
    -99t
    75t
    -86t
    -121t
    -109t
    88t
    19t
    -87t
    18t
    86t
    -94t
    96t
    79t
    -27t
    -46t
    -17t
    50t
    -105t
    62t
    -106t
    3t
    -45t
    -46t
    35t
    -20t
    -78t
    12t
    47t
    -72t
    109t
    -81t
    -40t
    3t
    -85t
    69t
    12t
    74t
    -53t
    123t
    -101t
    -13t
    -120t
    -8t
    27t
    56t
    41t
    -94t
    -5t
    -87t
    -121t
    115t
    -28t
    121t
    105t
    94t
    -83t
    7t
    -58t
    -36t
    -73t
    124t
    -51t
    117t
    -85t
    -50t
    -68t
    -21t
    1t
    99t
    90t
    -71t
    -5t
    -123t
    7t
    36t
    36t
    82t
    -9t
    -20t
    -9t
    1t
    -11t
    29t
    -27t
    -71t
    54t
    -6t
    -86t
    -14t
    -78t
    10t
    119t
    33t
    -93t
    78t
    24t
    71t
    -47t
    -83t
    57t
    30t
    -48t
    124t
    -57t
    -113t
    -90t
    -107t
    -42t
    -61t
    70t
    40t
    65t
    -32t
    70t
    -92t
    108t
    55t
    105t
    93t
    48t
    -7t
    -97t
    -108t
    -29t
    -29t
    -7t
    -99t
    34t
    125t
    124t
    -61t
    96t
    66t
    45t
    -35t
    -98t
    -13t
    43t
    111t
    81t
    120t
    -11t
    119t
    59t
    -109t
    -108t
    -51t
    35t
    -25t
    81t
    33t
    -76t
    67t
    -83t
    36t
    -91t
    96t
    -75t
    -63t
    -80t
    -29t
    -44t
    36t
    107t
    75t
    53t
    -78t
    -4t
    113t
    96t
    -125t
    0t
    110t
    91t
    -77t
    -19t
    -13t
    28t
    -8t
    33t
    33t
    101t
    -107t
    -87t
    -45t
    -82t
    114t
    125t
    -120t
    -59t
    -1t
    -2t
    29t
    12t
    -5t
    -17t
    91t
    -117t
    -45t
    65t
    -57t
    -126t
    -123t
    127t
    76t
    -41t
    46t
    123t
    15t
    -22t
    45t
    -114t
    -34t
    48t
    122t
    46t
    127t
    -3t
    34t
    -120t
    68t
    -109t
    67t
    -60t
    56t
    106t
    -61t
    -101t
    119t
    3t
    25t
    5t
    -46t
    25t
    50t
    81t
    -60t
    -25t
    -113t
    24t
    -123t
    92t
    -98t
    -91t
    -64t
    27t
    -57t
    -65t
    90t
    39t
    -61t
    -110t
    103t
    -22t
    -97t
    -117t
    13t
    78t
    31t
    48t
    -79t
    -106t
    -127t
    22t
    52t
    60t
    -116t
    110t
    -29t
    66t
    -58t
    -13t
    -104t
    -63t
    -125t
    -43t
    112t
    -82t
    111t
    -100t
    -47t
    98t
    -105t
    19t
    0t
    -111t
    115t
    71t
    -127t
    -113t
    -10t
    38t
    -113t
    120t
    -26t
    -42t
    43t
    41t
    -84t
    -24t
    108t
    123t
    -20t
    -99t
    -68t
    -109t
    98t
    105t
    -62t
    -33t
    70t
    -90t
    -123t
    -68t
    -39t
    124t
    -69t
    82t
    114t
    -28t
    127t
    20t
    -57t
    11t
    79t
    85t
    -58t
    -26t
    7t
    85t
    60t
    124t
    -12t
    -31t
    -88t
    -82t
    -66t
    -29t
    65t
    -32t
    80t
    -100t
    14t
    -38t
    73t
    26t
    -16t
    -125t
    95t
    -81t
    -116t
    -95t
    -9t
    124t
    42t
    106t
    40t
    60t
    -3t
    -100t
    -112t
    124t
    -54t
    99t
    -122t
    -110t
    -2t
    95t
    95t
    38t
    78t
    36t
    -41t
    16t
    25t
    41t
    -49t
    -96t
    -21t
    -115t
    68t
    121t
    -6t
    -81t
    63t
    -23t
    -41t
    34t
    -64t
    122t
    -124t
    82t
    44t
    31t
    82t
    121t
    93t
    86t
    4t
    107t
    86t
    36t
    88t
    -55t
    -30t
    -25t
    87t
    -79t
    38t
    -42t
    -16t
    -67t
    0t
    -29t
    -13t
    -104t
    -123t
    -57t
    -102t
    34t
    -59t
    -41t
    46t
    -18t
    -35t
    44t
    123t
    84t
    -93t
    -53t
    -126t
    -101t
    -84t
    -77t
    118t
    -55t
    93t
    -108t
    -58t
    -23t
    -89t
    -103t
    -77t
    33t
    77t
    62t
    112t
    93t
    14t
    -119t
    -27t
    -114t
    -102t
    -111t
    -27t
    78t
    7t
    -77t
    103t
    109t
    -101t
    55t
    99t
    50t
    -109t
    58t
    -111t
    18t
    -59t
    -104t
    94t
    -4t
    87t
    86t
    19t
    24t
    -109t
    -41t
    -61t
    -97t
    100t
    -36t
    31t
    81t
    -78t
    23t
    -118t
    -68t
    -49t
    -105t
    33t
    105t
    -55t
    13t
    98t
    -110t
    -101t
    24t
    35t
    -119t
    26t
    60t
    -83t
    121t
    -88t
    123t
    42t
    87t
    -11t
    -119t
    87t
    -99t
    54t
    3t
    -3t
    -25t
    36t
    60t
    -51t
    77t
    53t
    -77t
    40t
    -127t
    -18t
    116t
    -3t
    -52t
    17t
    67t
    -27t
    77t
    111t
    96t
    68t
    59t
    -109t
    113t
    -82t
    -11t
    -71t
    -119t
    34t
    -115t
    6t
    80t
    -103t
    -63t
    -77t
    -90t
    86t
    -100t
    10t
    64t
    30t
    121t
    64t
    -33t
    74t
    41t
    46t
    105t
    -3t
    -128t
    -92t
    -73t
    127t
    -27t
    -9t
    43t
    102t
    32t
    15t
    120t
    -125t
    -21t
    34t
    42t
    68t
    -58t
    -117t
    11t
    27t
    99t
    104t
    -61t
    -114t
    -46t
    9t
    -7t
    -115t
    -12t
    -58t
    121t
    -47t
    59t
    -42t
    -99t
    -15t
    -87t
    100t
    64t
    -34t
    -118t
    -102t
    89t
    58t
    66t
    -52t
    -40t
    -95t
    -111t
    -29t
    51t
    1t
    105t
    -87t
    19t
    -35t
    -65t
    -21t
    54t
    -53t
    95t
    -65t
    120t
    -9t
    -84t
    -35t
    62t
    65t
    -31t
    -39t
    9t
    -91t
    7t
    -40t
    -42t
    63t
    -108t
    113t
    13t
    -49t
    83t
    -7t
    90t
    -17t
    12t
    -1t
    109t
    -122t
    -80t
    41t
    -109t
    -3t
    -103t
    -36t
    -77t
    27t
    -24t
    26t
    -1t
    11t
    11t
    69t
    -68t
    92t
    -106t
    111t
    111t
    -90t
    -49t
    14t
    -51t
    69t
    97t
    -93t
    77t
    116t
    -11t
    -74t
    -27t
    -126t
    -40t
    117t
    49t
    67t
    89t
    -53t
    102t
    81t
    74t
    62t
    -112t
    -106t
    -55t
    13t
    14t
    19t
    113t
    -94t
    35t
    -107t
    45t
    -29t
    94t
    77t
    86t
    95t
    81t
    -107t
    71t
    0t
    -104t
    -18t
    91t
    82t
    -35t
    126t
    13t
    -38t
    111t
    113t
    89t
    -86t
    22t
    -121t
    -103t
    12t
    -115t
    113t
    115t
    -15t
    119t
    125t
    105t
    62t
    15t
    3t
    14t
    -96t
    44t
    118t
    -43t
    7t
    -86t
    -25t
    -20t
    -26t
    -87t
    -50t
    -56t
    -50t
    -83t
    -92t
    75t
    39t
    -89t
    -50t
    93t
    -40t
    57t
    -52t
    -122t
    102t
    79t
    -124t
    92t
    62t
    53t
    90t
    -86t
    42t
    -105t
    -26t
    112t
    -128t
    23t
    123t
    -110t
    -102t
    57t
    -93t
    -122t
    63t
    -101t
    -123t
    -110t
    103t
    -41t
    90t
    90t
    -9t
    50t
    83t
    20t
    -82t
    1t
    -11t
    1t
    10t
    -98t
    50t
    -107t
    -51t
    -34t
    127t
    -8t
    120t
    -65t
    33t
    -71t
    -111t
    -13t
    33t
    -77t
    57t
    118t
    34t
    62t
    -109t
    19t
    -95t
    -112t
    -36t
    -109t
    -49t
    90t
    18t
    69t
    118t
    -18t
    -104t
    106t
    126t
    -105t
    -19t
    -10t
    -71t
    -36t
    57t
    -59t
    31t
    77t
    -52t
    33t
    -41t
    89t
    112t
    28t
    -66t
    -85t
    47t
    73t
    56t
    -90t
    -39t
    48t
    4t
    -53t
    20t
    35t
    -40t
    38t
    65t
    36t
    113t
    -111t
    -28t
    123t
    105t
    -12t
    -16t
    -106t
    -102t
    121t
    -93t
    -29t
    -12t
    -102t
    -27t
    68t
    -115t
    -41t
    23t
    -26t
    -83t
    6t
    111t
    -23t
    49t
    58t
    111t
    -27t
    -126t
    77t
    25t
    -63t
    106t
    19t
    23t
    70t
    98t
    -33t
    -68t
    -10t
    123t
    4t
    97t
    10t
    41t
    78t
    -114t
    -105t
    33t
    52t
    -55t
    116t
    24t
    -93t
    -99t
    39t
    57t
    -86t
    91t
    41t
    -89t
    66t
    -47t
    -18t
    -86t
    24t
    87t
    -4t
    87t
    -109t
    77t
    72t
    -18t
    -95t
    -57t
    -27t
    -71t
    -88t
    40t
    -4t
    -47t
    27t
    119t
    -34t
    124t
    -42t
    108t
    107t
    31t
    84t
    -62t
    92t
    124t
    118t
    10t
    -43t
    103t
    -15t
    -10t
    23t
    -63t
    11t
    -66t
    98t
    106t
    68t
    -26t
    114t
    24t
    52t
    -119t
    74t
    -79t
    -89t
    49t
    35t
    40t
    42t
    37t
    -23t
    -100t
    -19t
    6t
    115t
    -113t
    118t
    122t
    58t
    -4t
    -26t
    99t
    51t
    62t
    -64t
    -96t
    5t
    113t
    -105t
    2t
    80t
    -28t
    26t
    41t
    5t
    119t
    123t
    26t
    -114t
    -82t
    -20t
    -3t
    -54t
    100t
    -64t
    -115t
    63t
    44t
    -101t
    72t
    83t
    84t
    76t
    123t
    27t
    -91t
    -22t
    -77t
    23t
    43t
    -125t
    21t
    75t
    25t
    -99t
    -108t
    94t
    -112t
    48t
    -59t
    113t
    -40t
    82t
    -107t
    46t
    58t
    -110t
    82t
    51t
    -75t
    -37t
    -103t
    80t
    26t
    37t
    50t
    64t
    117t
    -50t
    15t
    64t
    -24t
    -108t
    4t
    -49t
    -28t
    3t
    32t
    89t
    65t
    -120t
    84t
    -109t
    45t
    19t
    -25t
    -16t
    103t
    -57t
    -60t
    -91t
    17t
    127t
    77t
    -28t
    101t
    58t
    48t
    50t
    119t
    64t
    -89t
    87t
    1t
    44t
    -65t
    98t
    86t
    -84t
    69t
    -105t
    -16t
    -20t
    97t
    -83t
    91t
    -53t
    57t
    -29t
    -13t
    -27t
    112t
    1t
    57t
    -125t
    -38t
    -15t
    -103t
    54t
    34t
    -71t
    120t
    18t
    -32t
    -96t
    -37t
    85t
    -2t
    -95t
    -23t
    8t
    48t
    49t
    36t
    92t
    43t
    19t
    38t
    98t
    -51t
    116t
    57t
    0t
    -91t
    -25t
    -80t
    -2t
    122t
    63t
    -8t
    -83t
    -69t
    -87t
    120t
    -18t
    -109t
    36t
    68t
    126t
    125t
    75t
    -11t
    111t
    118t
    38t
    -50t
    39t
    110t
    54t
    -96t
    71t
    81t
    -120t
    -93t
    -51t
    -21t
    -73t
    127t
    -102t
    -65t
    -54t
    86t
    -65t
    -11t
    -16t
    -122t
    62t
    -82t
    -95t
    54t
    34t
    -59t
    59t
    -49t
    3t
    -9t
    -3t
    90t
    73t
    -21t
    -44t
    41t
    -5t
    -12t
    -88t
    99t
    -1t
    15t
    -71t
    92t
    -48t
    -120t
    -110t
    -36t
    112t
    -73t
    61t
    -78t
    -44t
    -73t
    -76t
    -89t
    -42t
    -117t
    86t
    108t
    60t
    103t
    -16t
    -94t
    -101t
    -5t
    -105t
    -49t
    30t
    125t
    84t
    -53t
    -21t
    -12t
    -121t
    8t
    121t
    62t
    62t
    -12t
    28t
    -95t
    127t
    125t
    79t
    124t
    -86t
    82t
    79t
    1t
    15t
    -19t
    -68t
    -34t
    -91t
    15t
    125t
    -91t
    -83t
    111t
    61t
    109t
    -6t
    -128t
    81t
    -118t
    10t
    43t
    -10t
    84t
    123t
    75t
    -105t
    -17t
    -46t
    70t
    103t
    -72t
    -93t
    19t
    -93t
    -90t
    79t
    66t
    -71t
    17t
    -119t
    89t
    -112t
    1t
    30t
    -95t
    -15t
    -106t
    73t
    82t
    -84t
    16t
    -53t
    -70t
    119t
    8t
    92t
    -26t
    114t
    -7t
    -47t
    46t
    105t
    -39t
    -48t
    102t
    -55t
    -94t
    107t
    45t
    -66t
    -19t
    -35t
    -28t
    28t
    -80t
    -72t
    22t
    60t
    -79t
    126t
    -65t
    95t
    -99t
    84t
    -35t
    -111t
    31t
    0t
    -81t
    -122t
    -44t
    80t
    43t
    -24t
    73t
    -85t
    71t
    -45t
    -114t
    -55t
    88t
    -115t
    51t
    -98t
    14t
    -69t
    -110t
    86t
    120t
    -57t
    90t
    56t
    -124t
    -51t
    -32t
    86t
    -81t
    -1t
    54t
    27t
    106t
    -45t
    -94t
    -45t
    63t
    -118t
    89t
    79t
    82t
    -68t
    85t
    72t
    -37t
    -88t
    98t
    65t
    -27t
    9t
    57t
    15t
    -64t
    -33t
    -30t
    -123t
    75t
    -24t
    127t
    119t
    54t
    107t
    -96t
    -70t
    -21t
    93t
    -47t
    -43t
    -13t
    -120t
    -41t
    -70t
    -55t
    55t
    41t
    -117t
    126t
    26t
    43t
    -12t
    -115t
    14t
    94t
    -93t
    -58t
    -1t
    6t
    -98t
    21t
    -93t
    -17t
    -44t
    98t
    -30t
    99t
    -10t
    90t
    125t
    -15t
    49t
    101t
    -73t
    -54t
    90t
    2t
    -80t
    -112t
    -95t
    107t
    92t
    -112t
    -8t
    -92t
    61t
    -81t
    97t
    -103t
    30t
    -54t
    32t
    94t
    -53t
    75t
    56t
    116t
    36t
    5t
    49t
    125t
    37t
    6t
    -49t
    -46t
    117t
    -113t
    -84t
    -84t
    -48t
    112t
    -39t
    -10t
    98t
    54t
    -62t
    -73t
    99t
    75t
    18t
    108t
    -40t
    -9t
    112t
    -51t
    -123t
    -59t
    1t
    51t
    113t
    -125t
    19t
    -48t
    -119t
    -10t
    -105t
    86t
    -16t
    41t
    38t
    -64t
    -38t
    -36t
    -88t
    -114t
    111t
    110t
    -23t
    -59t
    13t
    123t
    33t
    -53t
    3t
    -78t
    33t
    50t
    87t
    -120t
    76t
    6t
    -122t
    -91t
    95t
    -58t
    52t
    -103t
    28t
    87t
    86t
    -84t
    -71t
    94t
    55t
    -125t
    48t
    67t
    -118t
    -57t
    106t
    62t
    26t
    20t
    20t
    -116t
    14t
    38t
    -56t
    99t
    -77t
    -16t
    -45t
    -89t
    121t
    113t
    -120t
    2t
    -12t
    126t
    -18t
    -88t
    89t
    -22t
    122t
    85t
    94t
    49t
    -108t
    75t
    -96t
    106t
    13t
    -16t
    -111t
    -28t
    -49t
    60t
    -57t
    -90t
    -35t
    -85t
    82t
    106t
    51t
    -55t
    17t
    69t
    -20t
    -76t
    -29t
    52t
    25t
    -128t
    -2t
    70t
    -126t
    -117t
    -49t
    47t
    -38t
    -14t
    -39t
    -13t
    105t
    -47t
    91t
    34t
    26t
    -47t
    108t
    -14t
    123t
    -84t
    -107t
    -29t
    -85t
    5t
    32t
    85t
    112t
    -58t
    69t
    25t
    115t
    -86t
    -116t
    15t
    -47t
    -118t
    6t
    -7t
    33t
    43t
    24t
    49t
    115t
    -127t
    74t
    -55t
    -122t
    -49t
    22t
    73t
    -59t
    111t
    -89t
    23t
    52t
    -22t
    26t
    -55t
    51t
    -54t
    60t
    35t
    42t
    83t
    43t
    77t
    -30t
    105t
    14t
    -82t
    -77t
    -62t
    122t
    68t
    29t
    104t
    -76t
    90t
    117t
    -53t
    -113t
    -118t
    -96t
    -110t
    -82t
    -68t
    11t
    7t
    67t
    36t
    -40t
    81t
    -92t
    58t
    -116t
    -84t
    -99t
    55t
    103t
    86t
    49t
    114t
    70t
    -65t
    123t
    -120t
    -21t
    1t
    -96t
    41t
    -39t
    -75t
    -48t
    54t
    -109t
    -12t
    115t
    -81t
    -25t
    -112t
    101t
    84t
    21t
    91t
    -88t
    -94t
    -116t
    53t
    -109t
    -23t
    8t
    86t
    111t
    44t
    -56t
    76t
    -91t
    -90t
    53t
    -103t
    43t
    98t
    -51t
    -17t
    8t
    83t
    66t
    -60t
    -112t
    -46t
    18t
    -104t
    75t
    -19t
    -108t
    124t
    -11t
    84t
    -53t
    -23t
    4t
    -115t
    73t
    -100t
    106t
    -111t
    0t
    -40t
    2t
    -41t
    -75t
    -55t
    -4t
    10t
    108t
    -67t
    103t
    -117t
    -83t
    7t
    -49t
    -121t
    22t
    -39t
    18t
    -108t
    81t
    -30t
    87t
    -122t
    111t
    115t
    -20t
    3t
    42t
    50t
    -66t
    96t
    50t
    -72t
    123t
    0t
    -108t
    89t
    70t
    -38t
    54t
    71t
    39t
    -31t
    -34t
    120t
    78t
    -91t
    -85t
    22t
    -50t
    -101t
    -87t
    54t
    116t
    -31t
    55t
    64t
    -89t
    64t
    -67t
    -12t
    14t
    -108t
    -83t
    109t
    126t
    40t
    121t
    -24t
    -10t
    -71t
    -51t
    97t
    70t
    -29t
    -110t
    -68t
    -103t
    -109t
    33t
    -77t
    -111t
    -87t
    96t
    89t
    -50t
    1t
    102t
    111t
    -92t
    -45t
    -6t
    66t
    -125t
    -75t
    90t
    -97t
    22t
    87t
    48t
    27t
    2t
    -2t
    -102t
    -102t
    5t
    5t
    -117t
    -12t
    118t
    80t
    28t
    -64t
    -70t
    -101t
    69t
    -52t
    91t
    -44t
    -30t
    -111t
    29t
    -24t
    45t
    -107t
    93t
    -50t
    -36t
    120t
    -58t
    -29t
    -102t
    -17t
    -62t
    95t
    -104t
    -57t
    -27t
    -74t
    73t
    -103t
    80t
    23t
    38t
    77t
    17t
    42t
    52t
    -63t
    95t
    -94t
    95t
    26t
    -62t
    -43t
    77t
    73t
    -97t
    5t
    41t
    60t
    29t
    69t
    105t
    20t
    -12t
    10t
    -15t
    -79t
    69t
    -105t
    -9t
    84t
    45t
    13t
    -39t
    107t
    -66t
    -55t
    -121t
    -95t
    -46t
    -40t
    2t
    -75t
    -111t
    78t
    -9t
    -16t
    123t
    32t
    -95t
    98t
    54t
    102t
    -111t
    -104t
    30t
    102t
    -80t
    115t
    -27t
    16t
    94t
    -7t
    -85t
    55t
    110t
    -6t
    -127t
    5t
    23t
    11t
    27t
    -65t
    96t
    -116t
    -28t
    -96t
    64t
    -73t
    22t
    -67t
    78t
    104t
    -119t
    4t
    95t
    55t
    18t
    -122t
    38t
    86t
    3t
    -107t
    43t
    41t
    92t
    11t
    36t
    -88t
    105t
    -83t
    15t
    -29t
    9t
    -127t
    74t
    -51t
    -121t
    -21t
    99t
    -62t
    38t
    -26t
    48t
    56t
    -47t
    66t
    -56t
    108t
    37t
    -76t
    -22t
    56t
    -80t
    101t
    54t
    111t
    38t
    -18t
    -90t
    125t
    86t
    -99t
    -31t
    105t
    30t
    -11t
    33t
    25t
    -96t
    -40t
    -87t
    -120t
    74t
    -28t
    -5t
    92t
    85t
    -39t
    109t
    101t
    112t
    -125t
    -13t
    28t
    104t
    -101t
    -105t
    75t
    1t
    28t
    -107t
    48t
    0t
    -105t
    42t
    -2t
    20t
    -115t
    -72t
    93t
    -122t
    -116t
    33t
    -32t
    82t
    33t
    31t
    4t
    -72t
    -91t
    -30t
    -22t
    -116t
    -24t
    -108t
    70t
    23t
    -52t
    -52t
    120t
    -101t
    -109t
    77t
    -84t
    -32t
    -35t
    -102t
    15t
    120t
    -74t
    -91t
    8t
    -91t
    -37t
    -70t
    41t
    -96t
    -45t
    55t
    29t
    21t
    -113t
    38t
    24t
    105t
    70t
    40t
    20t
    -67t
    -64t
    -78t
    -95t
    4t
    -39t
    59t
    -108t
    -111t
    -62t
    88t
    8t
    48t
    73t
    44t
    75t
    74t
    -13t
    62t
    87t
    -37t
    -32t
    16t
    0t
    73t
    -58t
    -9t
    -26t
    25t
    103t
    35t
    -62t
    -10t
    -28t
    101t
    -27t
    -43t
    65t
    -107t
    23t
    90t
    -52t
    19t
    -12t
    94t
    -7t
    -81t
    121t
    123t
    -25t
    -36t
    118t
    67t
    16t
    78t
    -21t
    20t
    -72t
    90t
    96t
    64t
    -7t
    8t
    19t
    -115t
    29t
    13t
    90t
    30t
    30t
    60t
    -51t
    -33t
    4t
    72t
    -53t
    -104t
    102t
    0t
    -65t
    103t
    56t
    -99t
    35t
    -24t
    29t
    45t
    76t
    87t
    -116t
    -95t
    -31t
    108t
    -105t
    20t
    -88t
    -36t
    -113t
    10t
    -24t
    -58t
    28t
    96t
    -14t
    -21t
    -13t
    71t
    71t
    18t
    70t
    -111t
    -78t
    -35t
    -94t
    51t
    -20t
    -25t
    -59t
    -63t
    -102t
    -68t
    60t
    -93t
    71t
    70t
    -6t
    -2t
    78t
    -67t
    19t
    44t
    -125t
    111t
    -120t
    -95t
    -16t
    53t
    56t
    27t
    64t
    115t
    -114t
    -46t
    -76t
    -72t
    92t
    26t
    109t
    126t
    -118t
    -93t
    26t
    69t
    -66t
    -76t
    119t
    109t
    116t
    108t
    -111t
    -63t
    -45t
    -50t
    -81t
    -34t
    -57t
    -96t
    -35t
    -32t
    -101t
    -75t
    -55t
    66t
    34t
    16t
    -83t
    43t
    -21t
    -87t
    67t
    125t
    98t
    -45t
    119t
    65t
    -71t
    -82t
    59t
    6t
    -42t
    116t
    64t
    66t
    -85t
    -100t
    63t
    72t
    126t
    -61t
    123t
    23t
    104t
    45t
    -6t
    90t
    93t
    -126t
    115t
    -110t
    -23t
    49t
    -102t
    -58t
    -18t
    84t
    106t
    100t
    -43t
    54t
    3t
    -39t
    25t
    -70t
    -34t
    86t
    100t
    -7t
    -46t
    -90t
    -20t
    -116t
    -12t
    -100t
    -2t
    -19t
    107t
    -125t
    -13t
    3t
    -95t
    -52t
    53t
    -90t
    41t
    -56t
    -67t
    -124t
    -10t
    56t
    88t
    -28t
    -84t
    114t
    -72t
    124t
    101t
    105t
    56t
    -9t
    -1t
    -11t
    -69t
    53t
    123t
    32t
    -73t
    -107t
    -22t
    110t
    69t
    52t
    -95t
    -37t
    113t
    -10t
    92t
    3t
    78t
    -90t
    49t
    -84t
    -87t
    91t
    101t
    -45t
    -54t
    -122t
    73t
    92t
    24t
    -76t
    0t
    -121t
    -94t
    -6t
    -100t
    34t
    75t
    14t
    109t
    -43t
    7t
    -34t
    -100t
    -116t
    10t
    83t
    -22t
    -92t
    127t
    -6t
    -41t
    -46t
    57t
    91t
    18t
    46t
    15t
    44t
    -14t
    55t
    -92t
    95t
    1t
    -32t
    -34t
    40t
    85t
    -108t
    86t
    104t
    -64t
    118t
    4t
    71t
    -105t
    61t
    -60t
    -114t
    -101t
    -72t
    1t
    62t
    79t
    -106t
    104t
    -22t
    27t
    70t
    23t
    -50t
    -12t
    -101t
    -98t
    -70t
    -2t
    50t
    -77t
    41t
    -2t
    -35t
    -29t
    7t
    -128t
    92t
    32t
    -101t
    -20t
    -24t
    76t
    120t
    83t
    -78t
    95t
    -124t
    108t
    -87t
    -52t
    64t
    97t
    93t
    -95t
    -74t
    70t
    42t
    105t
    101t
    -5t
    65t
    -38t
    99t
    -19t
    127t
    70t
    -8t
    -68t
    -84t
    -115t
    50t
    121t
    29t
    109t
    -79t
    -78t
    -72t
    87t
    -36t
    3t
    -84t
    46t
    75t
    79t
    95t
    57t
    -47t
    -60t
    51t
    -3t
    -75t
    -58t
    87t
    51t
    111t
    -21t
    -7t
    -98t
    -36t
    111t
    5t
    -62t
    82t
    84t
    0t
    -120t
    106t
    90t
    -125t
    85t
    -11t
    27t
    -65t
    69t
    -58t
    105t
    -31t
    47t
    -124t
    -17t
    99t
    -12t
    50t
    -122t
    -99t
    10t
    79t
    -109t
    -65t
    106t
    -64t
    -36t
    65t
    -28t
    -119t
    112t
    46t
    55t
    25t
    51t
    111t
    33t
    -19t
    -73t
    -49t
    34t
    -17t
    4t
    99t
    110t
    -78t
    -116t
    -100t
    -54t
    -82t
    -109t
    -90t
    -85t
    -30t
    -73t
    -83t
    85t
    -101t
    -2t
    33t
    127t
    -39t
    -95t
    84t
    46t
    61t
    -109t
    78t
    17t
    18t
    -26t
    117t
    -45t
    -6t
    -44t
    -63t
    60t
    -21t
    69t
    46t
    -37t
    40t
    -110t
    57t
    -65t
    -35t
    5t
    -108t
    -70t
    -34t
    -110t
    -52t
    117t
    12t
    -12t
    95t
    -1t
    102t
    -21t
    21t
    -99t
    -109t
    59t
    -69t
    35t
    -88t
    -56t
    105t
    -101t
    -108t
    -28t
    79t
    -79t
    106t
    -100t
    -44t
    102t
    7t
    -18t
    70t
    -118t
    -90t
    -47t
    86t
    91t
    -45t
    113t
    113t
    -116t
    53t
    8t
    99t
    108t
    24t
    6t
    -13t
    104t
    30t
    40t
    -35t
    -18t
    -39t
    25t
    -53t
    63t
    -82t
    70t
    -50t
    -32t
    -65t
    34t
    -8t
    -71t
    116t
    -58t
    -21t
    83t
    45t
    15t
    -16t
    80t
    -83t
    110t
    -16t
    47t
    97t
    99t
    82t
    -77t
    89t
    -128t
    -71t
    27t
    -82t
    -27t
    -101t
    -106t
    -99t
    92t
    71t
    13t
    24t
    -13t
    51t
    102t
    -120t
    -26t
    -106t
    15t
    -7t
    -28t
    -83t
    -100t
    -127t
    36t
    -51t
    -56t
    120t
    -95t
    -6t
    -106t
    81t
    124t
    122t
    51t
    19t
    48t
    73t
    -124t
    65t
    49t
    -88t
    -28t
    -45t
    -17t
    43t
    -8t
    93t
    -79t
    41t
    -12t
    -59t
    -117t
    0t
    82t
    67t
    -55t
    -27t
    -29t
    -118t
    83t
    -115t
    -101t
    -112t
    -124t
    66t
    -7t
    41t
    -104t
    -83t
    19t
    -35t
    40t
    -31t
    1t
    -16t
    4t
    -95t
    44t
    48t
    -55t
    -28t
    -42t
    14t
    88t
    113t
    24t
    31t
    -12t
    -1t
    123t
    69t
    -39t
    -71t
    -2t
    109t
    -73t
    56t
    105t
    77t
    44t
    83t
    -110t
    -108t
    9t
    28t
    17t
    77t
    -19t
    -34t
    96t
    12t
    0t
    61t
    -101t
    57t
    31t
    -46t
    -58t
    -25t
    48t
    -62t
    93t
    -20t
    -76t
    27t
    -4t
    101t
    17t
    -127t
    9t
    85t
    15t
    93t
    -95t
    -79t
    -3t
    -38t
    62t
    -39t
    102t
    -117t
    -24t
    33t
    -66t
    71t
    53t
    59t
    27t
    -52t
    11t
    -45t
    85t
    42t
    107t
    59t
    88t
    54t
    124t
    -67t
    22t
    25t
    -36t
    -19t
    -35t
    83t
    43t
    -99t
    35t
    -83t
    36t
    33t
    99t
    76t
    -20t
    85t
    -21t
    -90t
    119t
    77t
    -38t
    -73t
    -1t
    73t
    0t
    -40t
    29t
    -16t
    76t
    -114t
    41t
    -75t
    -117t
    57t
    8t
    -49t
    -120t
    -121t
    -45t
    105t
    87t
    16t
    -57t
    108t
    -74t
    -32t
    28t
    110t
    -111t
    -43t
    107t
    -115t
    61t
    51t
    -112t
    -104t
    -128t
    59t
    -60t
    69t
    123t
    78t
    92t
    -103t
    -33t
    50t
    -89t
    114t
    -11t
    -57t
    60t
    73t
    30t
    21t
    104t
    -64t
    -128t
    -18t
    107t
    -88t
    110t
    28t
    38t
    -48t
    12t
    -50t
    -34t
    55t
    24t
    37t
    -128t
    -35t
    42t
    -122t
    -119t
    127t
    -40t
    19t
    124t
    -117t
    -75t
    -20t
    115t
    -91t
    111t
    95t
    30t
    -74t
    -126t
    -59t
    49t
    -91t
    -13t
    -3t
    119t
    28t
    -113t
    -19t
    59t
    75t
    95t
    15t
    -34t
    -62t
    -15t
    -118t
    -102t
    66t
    -117t
    -71t
    87t
    -123t
    -119t
    97t
    -11t
    -65t
    -76t
    -48t
    60t
    109t
    -13t
    27t
    -72t
    10t
    -83t
    -26t
    87t
    -115t
    49t
    -93t
    -99t
    98t
    69t
    -120t
    -107t
    -28t
    13t
    20t
    -92t
    22t
    -42t
    -54t
    59t
    14t
    29t
    -29t
    80t
    -36t
    49t
    -26t
    -40t
    95t
    51t
    84t
    34t
    -23t
    -21t
    -78t
    -64t
    41t
    72t
    27t
    -60t
    44t
    2t
    -15t
    -30t
    -107t
    -51t
    111t
    40t
    51t
    36t
    112t
    -49t
    83t
    124t
    -37t
    -9t
    -21t
    41t
    -71t
    -20t
    8t
    -118t
    30t
    118t
    47t
    -26t
    -21t
    33t
    -103t
    26t
    78t
    -93t
    -111t
    -62t
    -65t
    -11t
    -29t
    41t
    -128t
    124t
    -46t
    64t
    -86t
    -19t
    13t
    93t
    -71t
    106t
    -7t
    15t
    109t
    -83t
    123t
    51t
    24t
    -18t
    102t
    -25t
    20t
    108t
    -79t
    -2t
    -98t
    -59t
    55t
    -39t
    -51t
    116t
    31t
    -62t
    -81t
    -71t
    -87t
    -20t
    -78t
    123t
    -47t
    127t
    -82t
    -33t
    -77t
    90t
    -34t
    -52t
    -38t
    -52t
    -84t
    -63t
    109t
    -16t
    89t
    70t
    -17t
    87t
    86t
    -6t
    -5t
    -51t
    -53t
    52t
    80t
    -95t
    35t
    -88t
    -28t
    51t
    -80t
    32t
    115t
    27t
    38t
    83t
    2t
    97t
    34t
    -22t
    -63t
    -125t
    -49t
    -118t
    120t
    44t
    98t
    7t
    -53t
    -43t
    27t
    65t
    -25t
    -37t
    6t
    70t
    111t
    37t
    114t
    -58t
    5t
    12t
    126t
    63t
    -17t
    77t
    -44t
    -57t
    21t
    -92t
    68t
    106t
    -101t
    45t
    108t
    125t
    -119t
    74t
    -84t
    -83t
    36t
    -41t
    -123t
    -42t
    -95t
    89t
    -124t
    -92t
    -28t
    -5t
    36t
    -64t
    -97t
    118t
    -57t
    89t
    10t
    -117t
    -59t
    5t
    -65t
    70t
    66t
    -46t
    119t
    40t
    79t
    4t
    -75t
    12t
    29t
    78t
    18t
    -101t
    105t
    105t
    -63t
    -8t
    -127t
    -88t
    -13t
    -103t
    -30t
    71t
    32t
    122t
    66t
    -69t
    -53t
    25t
    96t
    -39t
    -90t
    -20t
    11t
    6t
    -115t
    -102t
    103t
    -58t
    58t
    68t
    45t
    45t
    -35t
    -36t
    26t
    -10t
    48t
    10t
    -91t
    -69t
    31t
    -44t
    -113t
    53t
    -35t
    -45t
    0t
    -88t
    -9t
    40t
    101t
    -38t
    50t
    120t
    62t
    22t
    -33t
    -28t
    119t
    -53t
    -95t
    127t
    -54t
    10t
    72t
    -77t
    12t
    -79t
    26t
    56t
    -98t
    27t
    -95t
    31t
    -59t
    -103t
    -111t
    65t
    -47t
    -122t
    -101t
    -118t
    92t
    -10t
    -110t
    -97t
    -12t
    -125t
    75t
    -38t
    64t
    -17t
    -86t
    60t
    -115t
    -77t
    -28t
    -126t
    -8t
    -54t
    71t
    10t
    -100t
    34t
    -98t
    -120t
    35t
    20t
    70t
    4t
    -122t
    68t
    18t
    -56t
    94t
    127t
    -76t
    34t
    -98t
    -120t
    54t
    -85t
    49t
    74t
    -18t
    -93t
    -81t
    -126t
    -115t
    111t
    16t
    -53t
    -54t
    -8t
    -120t
    -23t
    36t
    25t
    112t
    -85t
    -83t
    -73t
    -103t
    96t
    -22t
    56t
    119t
    -22t
    5t
    79t
    107t
    126t
    -123t
    57t
    40t
    -36t
    81t
    32t
    -88t
    116t
    -77t
    -93t
    -68t
    -111t
    101t
    -21t
    106t
    -27t
    67t
    44t
    86t
    -4t
    69t
    -104t
    -60t
    -118t
    -118t
    119t
    119t
    -71t
    16t
    116t
    -77t
    93t
    54t
    -98t
    -1t
    10t
    -121t
    -65t
    -68t
    10t
    -56t
    61t
    103t
    37t
    -83t
    -122t
    31t
    64t
    59t
    -118t
    -59t
    -58t
    -50t
    -51t
    73t
    111t
    102t
    27t
    -54t
    75t
    -97t
    58t
    64t
    -34t
    -47t
    -28t
    -121t
    63t
    -108t
    -91t
    4t
    111t
    39t
    79t
    -121t
    -26t
    -96t
    91t
    80t
    -108t
    -54t
    7t
    33t
    39t
    -2t
    80t
    1t
    15t
    127t
    -73t
    -31t
    -88t
    7t
    -71t
    26t
    10t
    4t
    0t
    -37t
    75t
    -105t
    13t
    46t
    25t
    62t
    -98t
    -29t
    -25t
    48t
    -29t
    -10t
    -42t
    104t
    -62t
    29t
    88t
    20t
    77t
    110t
    -36t
    -8t
    26t
    -26t
    17t
    -80t
    11t
    13t
    -121t
    -65t
    58t
    -77t
    -50t
    29t
    -47t
    -12t
    -126t
    -99t
    72t
    -56t
    -89t
    -74t
    122t
    5t
    25t
    94t
    18t
    105t
    -89t
    34t
    5t
    7t
    72t
    -100t
    -120t
    59t
    93t
    -81t
    -56t
    28t
    31t
    -128t
    -111t
    127t
    47t
    -58t
    39t
    -67t
    2t
    -101t
    -48t
    54t
    39t
    -51t
    -44t
    93t
    -118t
    -23t
    57t
    116t
    13t
    -79t
    45t
    32t
    127t
    -74t
    95t
    -97t
    -5t
    100t
    98t
    35t
    2t
    -98t
    -17t
    87t
    31t
    -85t
    35t
    -40t
    -25t
    -83t
    -83t
    124t
    32t
    -44t
    14t
    -44t
    21t
    -57t
    -122t
    106t
    18t
    106t
    -102t
    63t
    -108t
    62t
    45t
    -67t
    -79t
    -78t
    -48t
    101t
    -79t
    -105t
    -98t
    10t
    123t
    -21t
    -10t
    109t
    -107t
    -50t
    85t
    47t
    75t
    66t
    38t
    -53t
    34t
    56t
    -94t
    108t
    -105t
    -34t
    -107t
    -43t
    -108t
    -80t
    -115t
    -27t
    -36t
    41t
    -66t
    -114t
    -50t
    57t
    -26t
    69t
    91t
    -85t
    56t
    -89t
    76t
    81t
    -118t
    -21t
    118t
    39t
    34t
    114t
    -5t
    -11t
    -27t
    63t
    15t
    32t
    -22t
    2t
    -12t
    -122t
    0t
    54t
    -43t
    -68t
    18t
    -121t
    79t
    47t
    -8t
    115t
    -27t
    -17t
    -2t
    -41t
    61t
    -82t
    68t
    -60t
    124t
    75t
    24t
    -75t
    -59t
    -3t
    93t
    90t
    -74t
    92t
    84t
    -14t
    61t
    64t
    40t
    -120t
    95t
    -35t
    65t
    13t
    58t
    -69t
    23t
    -15t
    71t
    -125t
    -90t
    15t
    38t
    -33t
    17t
    -2t
    54t
    -23t
    23t
    81t
    80t
    -53t
    -113t
    -19t
    -61t
    -103t
    -62t
    56t
    -114t
    70t
    -23t
    69t
    53t
    -91t
    72t
    -35t
    80t
    69t
    17t
    35t
    74t
    -79t
    -119t
    -22t
    7t
    28t
    6t
    -107t
    59t
    27t
    -15t
    76t
    -27t
    -72t
    -65t
    -111t
    23t
    -84t
    -9t
    18t
    61t
    83t
    33t
    -40t
    43t
    47t
    -19t
    -72t
    -5t
    -79t
    -46t
    127t
    72t
    113t
    61t
    -22t
    -96t
    45t
    1t
    -101t
    41t
    -94t
    68t
    37t
    33t
    -103t
    -98t
    -71t
    -52t
    94t
    46t
    -32t
    -2t
    -86t
    36t
    114t
    -83t
    20t
    -49t
    78t
    51t
    -45t
    50t
    -128t
    -39t
    39t
    -113t
    -106t
    86t
    100t
    -118t
    -30t
    79t
    107t
    28t
    -73t
    -84t
    81t
    -57t
    -27t
    -85t
    104t
    -18t
    95t
    112t
    -40t
    95t
    -108t
    -82t
    95t
    -29t
    86t
    -61t
    21t
    -111t
    83t
    -88t
    -62t
    71t
    37t
    64t
    -1t
    31t
    7t
    44t
    63t
    53t
    -83t
    -120t
    -52t
    -11t
    33t
    57t
    -59t
    71t
    21t
    -71t
    -3t
    -23t
    88t
    -35t
    -127t
    -107t
    -8t
    63t
    39t
    15t
    34t
    1t
    -105t
    -82t
    -54t
    75t
    32t
    -95t
    21t
    -73t
    119t
    -47t
    -86t
    -64t
    -69t
    94t
    8t
    90t
    18t
    25t
    104t
    101t
    20t
    51t
    -71t
    -105t
    -7t
    14t
    -99t
    -125t
    -37t
    63t
    -23t
    -109t
    77t
    122t
    -127t
    99t
    103t
    50t
    -106t
    6t
    93t
    -107t
    -96t
    89t
    -60t
    86t
    -61t
    -66t
    -46t
    -29t
    37t
    -69t
    -86t
    -128t
    51t
    -43t
    66t
    43t
    8t
    -91t
    88t
    28t
    -83t
    55t
    63t
    39t
    -99t
    70t
    39t
    58t
    -64t
    -88t
    -93t
    12t
    -115t
    -78t
    60t
    93t
    115t
    15t
    47t
    -90t
    -73t
    93t
    -61t
    120t
    -107t
    -98t
    122t
    100t
    -52t
    91t
    20t
    -40t
    37t
    18t
    -36t
    -31t
    18t
    75t
    -27t
    -64t
    105t
    -78t
    -89t
    44t
    -19t
    -9t
    -64t
    8t
    -123t
    37t
    8t
    -9t
    -2t
    -17t
    -104t
    43t
    -123t
    54t
    60t
    67t
    23t
    60t
    102t
    8t
    81t
    47t
    -41t
    126t
    49t
    84t
    -37t
    -114t
    -114t
    -53t
    -35t
    4t
    115t
    -109t
    -100t
    -88t
    68t
    -13t
    -92t
    -10t
    -24t
    29t
    78t
    -65t
    -97t
    107t
    105t
    -68t
    -97t
    -99t
    -33t
    80t
    73t
    58t
    -114t
    -91t
    71t
    92t
    -21t
    66t
    77t
    -7t
    -3t
    55t
    76t
    112t
    -104t
    69t
    -120t
    -126t
    34t
    6t
    -45t
    -14t
    -76t
    -27t
    78t
    -7t
    -73t
    9t
    10t
    4t
    -118t
    -106t
    58t
    57t
    -64t
    58t
    -63t
    9t
    -121t
    27t
    -8t
    -75t
    76t
    10t
    79t
    -78t
    97t
    -105t
    -111t
    -69t
    -28t
    61t
    126t
    -51t
    122t
    -111t
    86t
    -115t
    -37t
    41t
    -57t
    -32t
    67t
    112t
    -114t
    -4t
    91t
    -112t
    127t
    13t
    10t
    -117t
    93t
    -106t
    -6t
    65t
    -126t
    -24t
    -111t
    41t
    87t
    87t
    -90t
    53t
    -17t
    104t
    4t
    -68t
    -102t
    41t
    89t
    -38t
    74t
    76t
    -51t
    -116t
    -9t
    -33t
    49t
    -36t
    115t
    56t
    123t
    9t
    104t
    -126t
    -42t
    93t
    56t
    113t
    113t
    -100t
    -112t
    -103t
    99t
    54t
    29t
    -75t
    102t
    38t
    28t
    93t
    96t
    -64t
    -28t
    69t
    81t
    50t
    67t
    86t
    67t
    111t
    13t
    119t
    62t
    -108t
    -109t
    69t
    -50t
    109t
    124t
    41t
    83t
    124t
    116t
    59t
    103t
    90t
    -112t
    93t
    42t
    41t
    -95t
    -15t
    57t
    72t
    -60t
    -125t
    -30t
    -19t
    43t
    -108t
    108t
    -85t
    -64t
    73t
    -24t
    -115t
    73t
    -12t
    103t
    -124t
    -94t
    -92t
    41t
    69t
    99t
    -74t
    -117t
    -114t
    41t
    79t
    107t
    -69t
    -32t
    -46t
    60t
    -45t
    -88t
    14t
    8t
    -39t
    42t
    44t
    -33t
    -94t
    -36t
    10t
    -30t
    38t
    -45t
    96t
    -61t
    -48t
    -70t
    -7t
    50t
    23t
    -121t
    3t
    -127t
    -28t
    62t
    -125t
    -82t
    -77t
    22t
    112t
    -57t
    -47t
    -41t
    -38t
    81t
    100t
    -122t
    16t
    104t
    -96t
    -11t
    -1t
    113t
    -35t
    -1t
    113t
    3t
    125t
    -46t
    -102t
    44t
    40t
    -44t
    67t
    -35t
    -48t
    98t
    -35t
    -112t
    -58t
    94t
    -41t
    48t
    112t
    98t
    -27t
    -91t
    31t
    -44t
    86t
    82t
    -81t
    -100t
    -80t
    81t
    41t
    -103t
    -27t
    -30t
    -11t
    -20t
    83t
    111t
    -17t
    19t
    50t
    43t
    90t
    -64t
    -2t
    41t
    15t
    11t
    47t
    77t
    -49t
    80t
    -3t
    -4t
    87t
    25t
    112t
    44t
    -43t
    -102t
    -96t
    6t
    54t
    54t
    -93t
    -110t
    60t
    121t
    66t
    -9t
    -56t
    59t
    -57t
    -4t
    39t
    77t
    118t
    -8t
    69t
    101t
    11t
    18t
    36t
    102t
    -5t
    115t
    -6t
    121t
    -67t
    40t
    -15t
    94t
    -46t
    -85t
    109t
    -5t
    -38t
    -16t
    124t
    -118t
    21t
    -45t
    -42t
    -99t
    41t
    -53t
    124t
    -128t
    -17t
    88t
    1t
    6t
    -55t
    -20t
    -24t
    -117t
    -52t
    -26t
    -62t
    127t
    -38t
    -21t
    -117t
    40t
    -77t
    -101t
    117t
    76t
    -58t
    -42t
    95t
    70t
    -42t
    69t
    81t
    108t
    107t
    41t
    -64t
    -46t
    51t
    53t
    91t
    59t
    -104t
    -116t
    118t
    112t
    62t
    11t
    3t
    -94t
    -101t
    -111t
    77t
    -109t
    -38t
    27t
    -79t
    -95t
    48t
    -67t
    102t
    45t
    -115t
    -42t
    -110t
    18t
    -44t
    -83t
    19t
    39t
    -33t
    79t
    11t
    -16t
    23t
    79t
    48t
    119t
    -14t
    125t
    -13t
    -65t
    -5t
    -58t
    -33t
    -13t
    36t
    -80t
    61t
    46t
    -6t
    107t
    -57t
    -30t
    -117t
    -58t
    -128t
    -73t
    18t
    -23t
    -9t
    50t
    78t
    21t
    27t
    -13t
    -25t
    -73t
    -120t
    -32t
    103t
    53t
    47t
    28t
    -124t
    -5t
    -46t
    74t
    56t
    61t
    -44t
    -26t
    96t
    -110t
    -51t
    -113t
    84t
    95t
    -64t
    81t
    109t
    -7t
    -29t
    -126t
    -42t
    -128t
    -96t
    -83t
    -13t
    54t
    107t
    -92t
    43t
    46t
    -54t
    -122t
    50t
    -23t
    -4t
    -97t
    8t
    38t
    -29t
    -87t
    -114t
    108t
    50t
    -123t
    -14t
    -15t
    -30t
    3t
    -87t
    -113t
    -4t
    -36t
    82t
    -97t
    -114t
    9t
    33t
    95t
    -36t
    -76t
    15t
    -10t
    -48t
    59t
    104t
    -32t
    32t
    83t
    -41t
    117t
    -99t
    -64t
    -109t
    -15t
    -42t
    62t
    -95t
    -71t
    -75t
    -48t
    -37t
    -54t
    36t
    54t
    -96t
    103t
    -4t
    116t
    -97t
    -15t
    -54t
    28t
    73t
    80t
    85t
    -126t
    56t
    32t
    -117t
    -26t
    108t
    23t
    -28t
    -32t
    -5t
    21t
    80t
    123t
    -34t
    94t
    8t
    -105t
    -88t
    -30t
    6t
    -83t
    81t
    -95t
    -8t
    33t
    49t
    -41t
    68t
    54t
    -96t
    117t
    -58t
    -77t
    89t
    -73t
    -103t
    -110t
    -27t
    90t
    37t
    -103t
    25t
    -61t
    -19t
    -36t
    81t
    -114t
    -7t
    -73t
    -28t
    101t
    73t
    -5t
    -92t
    -59t
    -119t
    -73t
    -108t
    -44t
    -97t
    6t
    -9t
    31t
    71t
    15t
    -56t
    39t
    60t
    -23t
    104t
    -33t
    79t
    82t
    -15t
    -103t
    2t
    8t
    39t
    -50t
    -35t
    -59t
    86t
    -89t
    12t
    -26t
    -76t
    -94t
    52t
    -76t
    125t
    16t
    -70t
    72t
    115t
    79t
    71t
    -109t
    94t
    -121t
    -43t
    -82t
    29t
    11t
    -62t
    122t
    91t
    107t
    41t
    -56t
    -16t
    127t
    -4t
    -58t
    -61t
    29t
    -5t
    -19t
    -25t
    36t
    -92t
    -124t
    -120t
    -83t
    59t
    51t
    -12t
    11t
    -17t
    93t
    16t
    107t
    -61t
    -6t
    -17t
    -110t
    124t
    60t
    90t
    -116t
    100t
    19t
    89t
    -31t
    -77t
    62t
    126t
    78t
    21t
    -81t
    -102t
    76t
    28t
    -108t
    -42t
    -21t
    43t
    -29t
    -88t
    97t
    -49t
    84t
    124t
    117t
    -30t
    -93t
    10t
    -111t
    -113t
    -123t
    -63t
    85t
    -74t
    -77t
    -92t
    49t
    97t
    63t
    -106t
    30t
    -17t
    107t
    36t
    -79t
    34t
    102t
    99t
    -70t
    -17t
    -63t
    70t
    -74t
    68t
    1t
    -109t
    67t
    -110t
    29t
    67t
    37t
    11t
    -82t
    127t
    -37t
    -9t
    104t
    10t
    -106t
    53t
    -17t
    3t
    46t
    26t
    -115t
    -9t
    -11t
    13t
    -55t
    67t
    49t
    82t
    -65t
    -115t
    48t
    -14t
    -57t
    88t
    0t
    -110t
    -73t
    -119t
    -36t
    -73t
    53t
    102t
    -30t
    126t
    -102t
    54t
    61t
    -107t
    -14t
    100t
    58t
    -73t
    107t
    -19t
    -89t
    -26t
    -77t
    -60t
    9t
    70t
    106t
    98t
    75t
    -2t
    6t
    -32t
    42t
    -76t
    112t
    83t
    -9t
    -30t
    21t
    -122t
    -104t
    66t
    -128t
    -93t
    112t
    -85t
    96t
    66t
    -105t
    26t
    -95t
    -18t
    53t
    -125t
    -47t
    92t
    -74t
    98t
    -1t
    -9t
    113t
    -31t
    67t
    12t
    121t
    -73t
    -116t
    -61t
    33t
    62t
    -106t
    22t
    -105t
    26t
    -79t
    52t
    -49t
    -56t
    20t
    83t
    73t
    -99t
    1t
    76t
    -123t
    18t
    30t
    -39t
    11t
    49t
    30t
    69t
    22t
    -50t
    -110t
    -64t
    7t
    60t
    -125t
    -90t
    34t
    -85t
    95t
    58t
    -31t
    -19t
    -128t
    3t
    36t
    10t
    -31t
    18t
    3t
    -90t
    60t
    -15t
    -34t
    10t
    119t
    -94t
    -49t
    -98t
    -42t
    51t
    126t
    85t
    44t
    24t
    107t
    13t
    -40t
    74t
    -113t
    84t
    78t
    -27t
    -97t
    120t
    22t
    -67t
    -34t
    73t
    3t
    -104t
    -72t
    -19t
    -105t
    55t
    -92t
    57t
    1t
    105t
    118t
    42t
    -54t
    -116t
    61t
    116t
    -76t
    -55t
    -118t
    13t
    -78t
    -121t
    -98t
    -39t
    -48t
    -122t
    -32t
    -7t
    -16t
    -107t
    1t
    38t
    -73t
    23t
    52t
    -95t
    67t
    25t
    -104t
    33t
    -46t
    -50t
    -128t
    80t
    -77t
    -14t
    2t
    -46t
    -88t
    -72t
    20t
    -75t
    19t
    -109t
    -78t
    45t
    109t
    127t
    102t
    -82t
    -1t
    -36t
    -81t
    -121t
    104t
    78t
    -126t
    -99t
    115t
    -64t
    29t
    9t
    -104t
    98t
    -66t
    -2t
    -25t
    52t
    -106t
    -27t
    -121t
    -108t
    -85t
    -127t
    34t
    -73t
    123t
    6t
    -9t
    -2t
    10t
    14t
    81t
    -4t
    43t
    37t
    88t
    -25t
    65t
    -88t
    85t
    34t
    116t
    79t
    121t
    -17t
    69t
    59t
    -68t
    2t
    15t
    122t
    -57t
    12t
    -12t
    84t
    -91t
    -66t
    -92t
    -30t
    -70t
    36t
    -70t
    -20t
    -72t
    -109t
    -98t
    -54t
    -93t
    -69t
    89t
    127t
    51t
    13t
    3t
    6t
    -82t
    -9t
    25t
    -26t
    74t
    85t
    45t
    -110t
    35t
    71t
    -53t
    -34t
    88t
    64t
    -79t
    -126t
    -16t
    72t
    25t
    -16t
    -111t
    73t
    116t
    -31t
    -40t
    55t
    82t
    -81t
    13t
    -125t
    41t
    -97t
    99t
    -57t
    20t
    -90t
    0t
    124t
    31t
    18t
    -36t
    20t
    -114t
    50t
    -86t
    -37t
    127t
    -2t
    -18t
    -106t
    121t
    115t
    -68t
    -25t
    90t
    127t
    -31t
    -126t
    30t
    107t
    -50t
    0t
    66t
    60t
    102t
    -114t
    52t
    56t
    65t
    -124t
    123t
    -17t
    -4t
    -1t
    83t
    95t
    45t
    -75t
    -119t
    -66t
    122t
    -118t
    -124t
    -122t
    73t
    16t
    75t
    -105t
    -96t
    -94t
    22t
    16t
    -125t
    -84t
    52t
    -7t
    118t
    63t
    -25t
    -96t
    76t
    34t
    72t
    -9t
    120t
    -22t
    -81t
    -110t
    33t
    13t
    3t
    -124t
    -63t
    -33t
    10t
    107t
    118t
    4t
    111t
    118t
    -118t
    -61t
    59t
    -120t
    70t
    59t
    -69t
    98t
    51t
    74t
    -59t
    -93t
    -24t
    -70t
    -81t
    98t
    65t
    -14t
    108t
    93t
    97t
    111t
    45t
    -43t
    101t
    -52t
    -119t
    -114t
    -111t
    45t
    25t
    -115t
    -68t
    14t
    -96t
    -103t
    113t
    3t
    110t
    102t
    -79t
    -80t
    59t
    -59t
    -7t
    11t
    -6t
    127t
    98t
    -55t
    87t
    80t
    -56t
    -104t
    -12t
    16t
    60t
    -6t
    -49t
    -113t
    21t
    12t
    -55t
    103t
    19t
    98t
    -52t
    -73t
    -45t
    68t
    -38t
    -94t
    98t
    -90t
    -14t
    -22t
    -121t
    91t
    -51t
    -8t
    103t
    64t
    -106t
    9t
    -74t
    9t
    74t
    13t
    -13t
    -128t
    95t
    -25t
    -25t
    -25t
    49t
    125t
    -83t
    38t
    65t
    24t
    118t
    0t
    -82t
    -61t
    -36t
    -108t
    70t
    -33t
    101t
    -71t
    -36t
    98t
    2t
    35t
    -113t
    88t
    -104t
    -65t
    -37t
    -113t
    -17t
    -2t
    -73t
    61t
    8t
    -123t
    88t
    107t
    -24t
    56t
    42t
    -88t
    45t
    -14t
    80t
    88t
    -76t
    28t
    33t
    38t
    29t
    -87t
    89t
    -11t
    15t
    -37t
    1t
    -102t
    -105t
    118t
    -75t
    12t
    53t
    -35t
    32t
    -77t
    -38t
    -73t
    -41t
    117t
    95t
    60t
    13t
    -2t
    -73t
    16t
    39t
    -125t
    126t
    70t
    65t
    45t
    112t
    -93t
    -57t
    -5t
    21t
    -62t
    66t
    119t
    -94t
    -40t
    -21t
    52t
    25t
    8t
    -4t
    -30t
    95t
    77t
    7t
    -102t
    -7t
    31t
    -36t
    -83t
    2t
    104t
    -66t
    44t
    111t
    -103t
    43t
    94t
    95t
    -127t
    35t
    91t
    -76t
    37t
    38t
    5t
    20t
    -31t
    42t
    86t
    113t
    -33t
    52t
    -16t
    -42t
    -67t
    23t
    -14t
    49t
    -55t
    -46t
    -38t
    52t
    -77t
    114t
    -51t
    125t
    96t
    -25t
    0t
    -90t
    50t
    62t
    97t
    55t
    -97t
    105t
    70t
    62t
    43t
    -64t
    99t
    -120t
    31t
    77t
    28t
    76t
    -83t
    -52t
    -114t
    -23t
    73t
    -123t
    72t
    -34t
    -15t
    59t
    -113t
    115t
    36t
    -125t
    -55t
    -42t
    -77t
    -31t
    -93t
    -92t
    -82t
    -113t
    99t
    28t
    -58t
    -89t
    -98t
    76t
    -103t
    -61t
    113t
    86t
    -69t
    10t
    -29t
    87t
    78t
    -15t
    -68t
    9t
    -64t
    -96t
    64t
    72t
    94t
    -31t
    0t
    87t
    -41t
    119t
    110t
    -74t
    5t
    28t
    -11t
    14t
    -73t
    -49t
    -103t
    22t
    -53t
    32t
    53t
    -17t
    54t
    -2t
    29t
    -107t
    69t
    45t
    -44t
    86t
    -121t
    110t
    114t
    76t
    1t
    -70t
    25t
    -98t
    47t
    -128t
    -74t
    -31t
    97t
    -100t
    9t
    -61t
    32t
    43t
    -84t
    -48t
    -57t
    -68t
    61t
    123t
    56t
    -108t
    -6t
    -22t
    17t
    -65t
    -107t
    -112t
    -93t
    -86t
    -28t
    59t
    47t
    -51t
    29t
    115t
    49t
    -120t
    -31t
    78t
    -14t
    88t
    125t
    -63t
    104t
    28t
    89t
    -114t
    -94t
    100t
    -18t
    65t
    -101t
    7t
    -76t
    99t
    -96t
    -118t
    -57t
    23t
    16t
    27t
    5t
    -81t
    -120t
    80t
    58t
    -83t
    86t
    13t
    127t
    -28t
    126t
    -103t
    86t
    127t
    94t
    -75t
    -11t
    -102t
    96t
    -93t
    4t
    15t
    -23t
    109t
    -52t
    -3t
    42t
    65t
    -73t
    73t
    -67t
    15t
    -12t
    -90t
    105t
    117t
    51t
    -34t
    102t
    17t
    -34t
    92t
    34t
    34t
    -4t
    -2t
    78t
    82t
    -44t
    78t
    8t
    -11t
    89t
    -20t
    -125t
    12t
    -95t
    70t
    -98t
    -108t
    -33t
    64t
    57t
    44t
    122t
    -95t
    56t
    112t
    127t
    -108t
    28t
    108t
    117t
    77t
    90t
    -12t
    -43t
    60t
    -92t
    58t
    -72t
    -26t
    -49t
    -118t
    -31t
    71t
    28t
    -128t
    120t
    -40t
    -101t
    123t
    -42t
    -35t
    127t
    -49t
    -46t
    -110t
    -120t
    -44t
    -21t
    113t
    -12t
    -74t
    -91t
    107t
    -17t
    -90t
    -95t
    -115t
    -37t
    -38t
    -41t
    123t
    -125t
    -11t
    123t
    -81t
    3t
    -118t
    -88t
    -20t
    -47t
    -103t
    105t
    21t
    -101t
    -41t
    -64t
    96t
    -115t
    88t
    9t
    -110t
    -11t
    66t
    -63t
    -55t
    -82t
    16t
    -56t
    -86t
    75t
    -38t
    -54t
    103t
    -100t
    40t
    110t
    8t
    -11t
    13t
    10t
    -15t
    113t
    -69t
    104t
    64t
    85t
    53t
    65t
    16t
    95t
    125t
    127t
    -18t
    81t
    37t
    -117t
    77t
    41t
    -97t
    112t
    67t
    62t
    -13t
    119t
    85t
    64t
    51t
    -66t
    -40t
    77t
    -101t
    -107t
    -69t
    -122t
    -10t
    106t
    -125t
    29t
    -28t
    -5t
    58t
    54t
    -51t
    94t
    70t
    71t
    -117t
    -4t
    -8t
    -7t
    -67t
    28t
    124t
    -102t
    -80t
    -26t
    -71t
    78t
    51t
    -60t
    -53t
    120t
    -31t
    -22t
    -40t
    -30t
    -38t
    -45t
    5t
    -2t
    37t
    -21t
    -46t
    42t
    -42t
    -27t
    -21t
    55t
    -24t
    109t
    105t
    80t
    -100t
    -117t
    -37t
    46t
    -113t
    -11t
    51t
    -3t
    -127t
    -27t
    -45t
    18t
    1t
    -49t
    -73t
    4t
    98t
    23t
    -50t
    -22t
    -119t
    -40t
    -127t
    -85t
    -36t
    50t
    46t
    58t
    49t
    88t
    -106t
    93t
    -74t
    -14t
    -71t
    -64t
    -100t
    119t
    18t
    40t
    -47t
    11t
    115t
    89t
    -120t
    37t
    -22t
    10t
    4t
    69t
    -66t
    20t
    -23t
    30t
    77t
    -36t
    -122t
    3t
    -39t
    -106t
    -120t
    -3t
    -125t
    42t
    25t
    -34t
    35t
    -127t
    37t
    -24t
    -64t
    -98t
    -121t
    56t
    74t
    78t
    124t
    -118t
    -71t
    -38t
    116t
    -20t
    69t
    1t
    -57t
    -105t
    -29t
    -35t
    2t
    -48t
    84t
    -66t
    -77t
    69t
    9t
    85t
    112t
    111t
    -39t
    -68t
    -39t
    36t
    76t
    115t
    10t
    -59t
    25t
    -65t
    72t
    -107t
    -16t
    -58t
    -77t
    -5t
    39t
    -102t
    38t
    49t
    -116t
    -48t
    -41t
    -95t
    35t
    43t
    -54t
    -22t
    -123t
    40t
    112t
    10t
    -17t
    106t
    100t
    50t
    -56t
    71t
    70t
    98t
    122t
    -26t
    -21t
    -123t
    -89t
    -9t
    -79t
    14t
    39t
    67t
    -81t
    -89t
    82t
    93t
    117t
    98t
    -80t
    -64t
    -97t
    -65t
    -2t
    -95t
    -109t
    78t
    -9t
    102t
    -109t
    106t
    -69t
    -2t
    90t
    81t
    -78t
    -16t
    -93t
    -8t
    0t
    -115t
    -81t
    -33t
    98t
    92t
    -6t
    62t
    -56t
    -94t
    21t
    123t
    -31t
    -87t
    -43t
    -70t
    -80t
    82t
    99t
    14t
    47t
    13t
    -18t
    34t
    -13t
    -58t
    -117t
    82t
    17t
    -112t
    -40t
    -36t
    -17t
    -25t
    -109t
    -88t
    -80t
    71t
    92t
    59t
    -18t
    21t
    -43t
    -54t
    69t
    40t
    104t
    40t
    79t
    84t
    12t
    -9t
    77t
    13t
    -124t
    -20t
    96t
    -85t
    -67t
    80t
    59t
    -53t
    79t
    -123t
    70t
    49t
    -64t
    -125t
    7t
    109t
    -42t
    43t
    42t
    21t
    -90t
    -93t
    72t
    -4t
    53t
    31t
    -4t
    -18t
    -18t
    87t
    -98t
    81t
    -69t
    61t
    -23t
    107t
    40t
    81t
    48t
    16t
    -78t
    70t
    123t
    16t
    6t
    16t
    -124t
    -65t
    95t
    -114t
    109t
    -37t
    -94t
    -42t
    -124t
    113t
    -115t
    114t
    125t
    57t
    98t
    12t
    -47t
    -117t
    -17t
    127t
    50t
    -11t
    -45t
    -2t
    -114t
    127t
    81t
    -120t
    -23t
    -2t
    -117t
    12t
    25t
    52t
    -3t
    98t
    55t
    23t
    4t
    -55t
    26t
    -31t
    19t
    85t
    126t
    -3t
    45t
    -56t
    73t
    -16t
    -27t
    93t
    -77t
    83t
    51t
    116t
    -124t
    -112t
    -39t
    -45t
    7t
    -92t
    -104t
    33t
    52t
    3t
    -109t
    -15t
    0t
    -25t
    -88t
    -124t
    -41t
    -95t
    -127t
    88t
    30t
    10t
    70t
    -47t
    105t
    15t
    -48t
    -107t
    58t
    -19t
    104t
    -63t
    19t
    -110t
    13t
    -41t
    120t
    6t
    122t
    103t
    4t
    74t
    -78t
    102t
    -31t
    -23t
    37t
    -105t
    -79t
    -47t
    -73t
    -77t
    -99t
    -112t
    3t
    -121t
    -119t
    114t
    -17t
    -13t
    -50t
    -103t
    -72t
    -60t
    -44t
    38t
    2t
    53t
    39t
    127t
    98t
    -23t
    -80t
    -45t
    71t
    87t
    47t
    -43t
    45t
    84t
    -125t
    37t
    -14t
    61t
    -6t
    42t
    101t
    55t
    -2t
    -70t
    -87t
    -107t
    -34t
    -41t
    87t
    -101t
    -91t
    -28t
    -113t
    79t
    29t
    62t
    109t
    -80t
    83t
    0t
    -20t
    -14t
    -14t
    7t
    -8t
    -47t
    -78t
    -101t
    -80t
    12t
    60t
    91t
    -25t
    35t
    -108t
    29t
    -65t
    -74t
    68t
    -110t
    42t
    -91t
    90t
    -38t
    96t
    100t
    -3t
    -86t
    95t
    -128t
    31t
    105t
    -38t
    110t
    25t
    77t
    -121t
    80t
    29t
    65t
    79t
    -126t
    35t
    86t
    119t
    29t
    -115t
    -87t
    -127t
    -48t
    54t
    -5t
    -29t
    1t
    13t
    45t
    -116t
    -127t
    78t
    -49t
    37t
    -111t
    -94t
    -104t
    -119t
    -16t
    -58t
    118t
    82t
    -68t
    -18t
    -2t
    -83t
    36t
    -103t
    78t
    127t
    92t
    11t
    104t
    -19t
    -103t
    -74t
    51t
    -80t
    16t
    59t
    115t
    79t
    -14t
    -85t
    -61t
    -85t
    -99t
    15t
    -45t
    -32t
    -117t
    -40t
    -58t
    74t
    -122t
    -61t
    -63t
    -23t
    121t
    -23t
    110t
    3t
    126t
    94t
    77t
    -84t
    -67t
    -119t
    66t
    58t
    45t
    31t
    -60t
    -63t
    -42t
    -38t
    123t
    1t
    79t
    -123t
    -16t
    -16t
    26t
    86t
    14t
    -109t
    109t
    76t
    -15t
    -122t
    -109t
    65t
    -48t
    17t
    -118t
    88t
    15t
    73t
    -92t
    -93t
    67t
    44t
    61t
    -67t
    120t
    -43t
    50t
    104t
    33t
    -102t
    75t
    87t
    36t
    35t
    -83t
    5t
    95t
    81t
    -64t
    111t
    -35t
    30t
    126t
    40t
    -50t
    7t
    -18t
    37t
    24t
    -110t
    61t
    -6t
    -78t
    81t
    114t
    31t
    60t
    -49t
    -8t
    -121t
    125t
    59t
    -124t
    -118t
    123t
    96t
    6t
    -107t
    24t
    4t
    21t
    110t
    -107t
    63t
    124t
    54t
    121t
    34t
    97t
    88t
    -30t
    34t
    -39t
    14t
    84t
    88t
    -106t
    106t
    109t
    -22t
    124t
    -126t
    6t
    21t
    65t
    -80t
    -22t
    73t
    78t
    -111t
    105t
    -14t
    102t
    22t
    75t
    79t
    69t
    94t
    57t
    -115t
    70t
    30t
    13t
    -115t
    -94t
    86t
    -9t
    -35t
    80t
    97t
    -22t
    -50t
    -71t
    -16t
    -41t
    -82t
    2t
    38t
    34t
    16t
    -74t
    -103t
    -24t
    41t
    -49t
    -126t
    -58t
    30t
    -126t
    -47t
    -59t
    -96t
    98t
    -57t
    49t
    -52t
    -84t
    17t
    -105t
    53t
    36t
    -89t
    -84t
    -43t
    -78t
    23t
    11t
    26t
    -2t
    -47t
    94t
    89t
    89t
    71t
    -87t
    -28t
    -62t
    67t
    -54t
    40t
    14t
    85t
    71t
    35t
    22t
    -32t
    0t
    -29t
    -122t
    -30t
    126t
    -81t
    -87t
    -78t
    16t
    -33t
    -11t
    84t
    -124t
    9t
    107t
    -103t
    48t
    -97t
    -25t
    6t
    40t
    -91t
    61t
    -22t
    77t
    -43t
    -65t
    -90t
    -17t
    -27t
    -45t
    14t
    -38t
    24t
    101t
    74t
    123t
    116t
    101t
    -47t
    77t
    -89t
    107t
    51t
    85t
    41t
    38t
    29t
    11t
    -118t
    -123t
    -67t
    74t
    -106t
    -18t
    -63t
    114t
    25t
    -20t
    -106t
    -38t
    49t
    -84t
    -92t
    43t
    6t
    95t
    120t
    -54t
    43t
    124t
    3t
    52t
    93t
    50t
    -25t
    54t
    -92t
    31t
    -117t
    -109t
    -107t
    -81t
    73t
    -80t
    11t
    -48t
    110t
    100t
    126t
    55t
    -2t
    -63t
    -61t
    50t
    -26t
    54t
    -24t
    -26t
    83t
    5t
    108t
    45t
    90t
    -118t
    -90t
    -5t
    37t
    48t
    -70t
    86t
    -95t
    123t
    38t
    -9t
    -65t
    68t
    -108t
    -90t
    -80t
    98t
    -58t
    -89t
    32t
    2t
    103t
    21t
    103t
    30t
    -120t
    -122t
    -26t
    92t
    46t
    47t
    -80t
    -22t
    -60t
    -10t
    8t
    -94t
    76t
    -119t
    -72t
    116t
    -75t
    100t
    83t
    -61t
    -49t
    -58t
    48t
    -85t
    55t
    56t
    -31t
    -2t
    115t
    107t
    -28t
    37t
    92t
    25t
    35t
    -83t
    -78t
    37t
    -66t
    64t
    -66t
    -80t
    1t
    44t
    56t
    -5t
    -12t
    29t
    -38t
    24t
    12t
    91t
    -12t
    108t
    -9t
    104t
    100t
    23t
    -7t
    -82t
    30t
    17t
    2t
    44t
    -40t
    37t
    -5t
    -102t
    36t
    -123t
    -102t
    69t
    53t
    73t
    -57t
    112t
    -96t
    109t
    -91t
    -95t
    -81t
    110t
    -116t
    95t
    -36t
    -54t
    100t
    -64t
    38t
    -126t
    88t
    8t
    16t
    -59t
    -62t
    29t
    -122t
    -56t
    100t
    -42t
    -39t
    -8t
    16t
    117t
    82t
    18t
    85t
    -105t
    59t
    -23t
    -52t
    101t
    -48t
    -21t
    -97t
    78t
    -68t
    85t
    -121t
    -69t
    43t
    57t
    -56t
    67t
    -24t
    -39t
    125t
    -100t
    -35t
    74t
    105t
    10t
    104t
    -8t
    34t
    52t
    -67t
    64t
    -67t
    -28t
    -59t
    69t
    -68t
    24t
    76t
    115t
    21t
    12t
    96t
    -71t
    69t
    84t
    84t
    -115t
    -75t
    -111t
    121t
    -72t
    68t
    -94t
    12t
    -88t
    -91t
    -100t
    1t
    -6t
    10t
    90t
    40t
    -128t
    13t
    -91t
    97t
    -89t
    33t
    -44t
    -82t
    59t
    39t
    -94t
    29t
    69t
    116t
    -43t
    -100t
    91t
    -20t
    -127t
    -114t
    -122t
    31t
    85t
    -10t
    -91t
    -117t
    -87t
    -120t
    8t
    -109t
    28t
    115t
    -48t
    104t
    -22t
    35t
    72t
    -14t
    36t
    51t
    97t
    104t
    -109t
    -122t
    -127t
    -64t
    39t
    -20t
    -88t
    -66t
    -20t
    -32t
    -50t
    87t
    81t
    99t
    -81t
    -20t
    -39t
    -79t
    -90t
    0t
    54t
    -109t
    46t
    124t
    -64t
    105t
    -94t
    13t
    -10t
    46t
    -106t
    -77t
    -3t
    -99t
    58t
    -13t
    -99t
    -98t
    -10t
    24t
    113t
    -43t
    60t
    62t
    -23t
    -20t
    -114t
    67t
    110t
    125t
    101t
    -110t
    -53t
    103t
    -119t
    -12t
    -55t
    -63t
    78t
    69t
    120t
    -80t
    62t
    4t
    -75t
    -27t
    -78t
    13t
    21t
    -36t
    -24t
    -97t
    111t
    -80t
    67t
    -79t
    32t
    -52t
    -71t
    -60t
    78t
    62t
    -117t
    -29t
    -107t
    70t
    48t
    -62t
    112t
    6t
    59t
    90t
    115t
    50t
    -38t
    -46t
    -125t
    95t
    -94t
    -125t
    -34t
    76t
    60t
    123t
    -60t
    -42t
    96t
    54t
    102t
    65t
    -51t
    100t
    -42t
    -111t
    -119t
    62t
    40t
    -12t
    49t
    -69t
    -97t
    81t
    -110t
    32t
    -54t
    125t
    115t
    -93t
    111t
    98t
    -92t
    63t
    -98t
    85t
    39t
    -2t
    -127t
    31t
    90t
    -30t
    98t
    56t
    -122t
    -10t
    6t
    -116t
    2t
    104t
    41t
    16t
    -82t
    -70t
    22t
    -72t
    68t
    114t
    -58t
    -75t
    43t
    -70t
    -23t
    -29t
    -41t
    -38t
    79t
    2t
    42t
    85t
    96t
    -60t
    -74t
    -87t
    3t
    -77t
    47t
    4t
    -34t
    -11t
    38t
    -70t
    -39t
    -59t
    -64t
    -64t
    28t
    -60t
    48t
    -77t
    57t
    -99t
    87t
    55t
    47t
    104t
    55t
    -110t
    -85t
    122t
    -57t
    17t
    -121t
    -76t
    57t
    104t
    -23t
    88t
    19t
    -31t
    -36t
    71t
    49t
    105t
    -31t
    65t
    -62t
    44t
    -45t
    -19t
    72t
    -26t
    -23t
    26t
    61t
    -51t
    102t
    61t
    -4t
    -41t
    -20t
    40t
    19t
    66t
    -58t
    -50t
    7t
    -89t
    105t
    -114t
    -23t
    -70t
    45t
    126t
    93t
    -117t
    76t
    -126t
    -81t
    16t
    31t
    43t
    93t
    -71t
    -62t
    -91t
    -117t
    -27t
    -8t
    111t
    29t
    65t
    -55t
    45t
    54t
    55t
    -16t
    -124t
    10t
    46t
    27t
    -55t
    -29t
    -38t
    106t
    111t
    -48t
    -104t
    40t
    124t
    4t
    2t
    8t
    72t
    108t
    1t
    -104t
    18t
    -57t
    54t
    44t
    15t
    -47t
    110t
    -77t
    80t
    18t
    -89t
    38t
    25t
    -5t
    5t
    -125t
    -66t
    91t
    -59t
    -2t
    42t
    45t
    -32t
    16t
    -69t
    100t
    -69t
    -56t
    -5t
    -32t
    44t
    -56t
    -36t
    -94t
    -74t
    -97t
    62t
    111t
    19t
    -126t
    -32t
    -126t
    102t
    -128t
    16t
    99t
    -93t
    34t
    -85t
    -42t
    -29t
    30t
    -7t
    -27t
    122t
    35t
    -31t
    -53t
    -53t
    -21t
    -12t
    90t
    -97t
    46t
    -65t
    -79t
    -109t
    44t
    110t
    99t
    -83t
    -30t
    88t
    77t
    -86t
    -13t
    -68t
    12t
    -51t
    -76t
    76t
    -85t
    124t
    -54t
    -7t
    39t
    -4t
    114t
    125t
    49t
    -66t
    -10t
    -114t
    -68t
    -52t
    -121t
    -34t
    -107t
    78t
    -35t
    40t
    -124t
    28t
    -121t
    81t
    -57t
    72t
    97t
    -88t
    8t
    50t
    -86t
    95t
    -110t
    -93t
    -39t
    -121t
    111t
    -47t
    -72t
    -10t
    72t
    -19t
    91t
    -74t
    79t
    -95t
    -51t
    -62t
    -55t
    62t
    -48t
    -51t
    -36t
    -112t
    -110t
    127t
    82t
    60t
    53t
    125t
    -111t
    -76t
    -90t
    -55t
    -113t
    -36t
    113t
    28t
    -74t
    56t
    69t
    40t
    69t
    -37t
    -106t
    -43t
    16t
    2t
    -96t
    -88t
    -88t
    -98t
    -106t
    -38t
    -118t
    -127t
    -102t
    -102t
    -38t
    88t
    96t
    -44t
    -122t
    -44t
    38t
    -34t
    -103t
    19t
    -24t
    102t
    5t
    -37t
    -52t
    -28t
    -31t
    -7t
    85t
    1t
    87t
    -110t
    65t
    -3t
    63t
    26t
    24t
    -20t
    54t
    -65t
    -49t
    -123t
    -121t
    -26t
    106t
    -51t
    -111t
    -100t
    11t
    -37t
    58t
    38t
    -73t
    124t
    17t
    -44t
    111t
    122t
    -12t
    73t
    87t
    -109t
    0t
    119t
    58t
    69t
    118t
    5t
    57t
    -73t
    -14t
    -24t
    -13t
    -83t
    51t
    69t
    127t
    -94t
    -96t
    -97t
    55t
    -16t
    104t
    122t
    -18t
    48t
    1t
    -97t
    96t
    50t
    55t
    86t
    60t
    -79t
    126t
    117t
    100t
    -38t
    -19t
    103t
    -109t
    -25t
    -33t
    -36t
    -28t
    58t
    -43t
    -59t
    41t
    -107t
    -68t
    92t
    68t
    120t
    -107t
    -63t
    -5t
    -36t
    -27t
    -123t
    53t
    -104t
    -1t
    -23t
    -66t
    116t
    -53t
    -74t
    -100t
    -54t
    31t
    -119t
    -68t
    -68t
    -101t
    -6t
    54t
    -34t
    -15t
    -53t
    -23t
    -28t
    -105t
    49t
    34t
    31t
    26t
    -52t
    -78t
    -69t
    48t
    37t
    99t
    -14t
    -122t
    104t
    9t
    40t
    -23t
    -124t
    -98t
    -33t
    34t
    4t
    59t
    112t
    79t
    -43t
    -24t
    33t
    -115t
    -68t
    79t
    -102t
    -105t
    85t
    -18t
    96t
    19t
    81t
    44t
    -55t
    112t
    124t
    80t
    -36t
    48t
    -103t
    4t
    -36t
    -60t
    83t
    126t
    0t
    120t
    121t
    26t
    2t
    -12t
    103t
    -119t
    -51t
    -110t
    28t
    -110t
    -26t
    53t
    46t
    13t
    -26t
    38t
    -87t
    -59t
    -23t
    -28t
    -84t
    101t
    17t
    60t
    -74t
    -104t
    -24t
    33t
    96t
    65t
    -123t
    35t
    45t
    -80t
    118t
    76t
    -80t
    59t
    -87t
    -74t
    27t
    -103t
    -62t
    121t
    -35t
    6t
    64t
    -107t
    17t
    29t
    -107t
    97t
    44t
    -35t
    -112t
    39t
    61t
    -42t
    41t
    69t
    98t
    98t
    44t
    39t
    62t
    88t
    -26t
    -92t
    -87t
    -78t
    -109t
    10t
    -106t
    -26t
    -118t
    -38t
    -71t
    91t
    58t
    27t
    -39t
    109t
    85t
    47t
    122t
    -74t
    -35t
    -5t
    -121t
    -43t
    -20t
    -40t
    -83t
    -53t
    19t
    -109t
    121t
    -81t
    -124t
    8t
    84t
    45t
    60t
    -5t
    -85t
    -23t
    -9t
    15t
    -25t
    73t
    39t
    44t
    127t
    7t
    71t
    92t
    116t
    10t
    4t
    -40t
    -112t
    52t
    97t
    28t
    -92t
    72t
    113t
    58t
    -5t
    40t
    110t
    -50t
    15t
    -27t
    -110t
    -104t
    -30t
    -90t
    61t
    -1t
    -70t
    -88t
    -22t
    -41t
    23t
    86t
    93t
    32t
    96t
    30t
    -14t
    75t
    -10t
    -2t
    54t
    90t
    104t
    90t
    77t
    -122t
    -35t
    -6t
    -119t
    59t
    -46t
    39t
    65t
    -21t
    -27t
    -121t
    3t
    60t
    102t
    -2t
    -40t
    99t
    7t
    -24t
    -102t
    101t
    17t
    -92t
    -121t
    18t
    84t
    -111t
    113t
    49t
    -62t
    -121t
    7t
    -18t
    -117t
    36t
    -121t
    42t
    43t
    -72t
    -55t
    -12t
    99t
    -63t
    88t
    69t
    -41t
    -39t
    -9t
    -4t
    46t
    -26t
    58t
    -106t
    -2t
    -17t
    -70t
    -114t
    -70t
    40t
    -86t
    -108t
    65t
    80t
    -57t
    -104t
    -83t
    38t
    46t
    -78t
    -100t
    37t
    116t
    52t
    50t
    4t
    19t
    15t
    61t
    -111t
    76t
    -78t
    -64t
    -120t
    -119t
    -71t
    -3t
    84t
    32t
    102t
    -17t
    -94t
    38t
    -126t
    96t
    63t
    94t
    -110t
    98t
    -100t
    -63t
    26t
    -99t
    122t
    -50t
    13t
    -23t
    17t
    -52t
    -10t
    45t
    39t
    94t
    113t
    122t
    121t
    23t
    62t
    -39t
    100t
    -95t
    76t
    123t
    35t
    75t
    111t
    50t
    -91t
    -50t
    23t
    101t
    -120t
    52t
    -79t
    82t
    3t
    11t
    -119t
    -126t
    -126t
    -106t
    -67t
    -111t
    117t
    -30t
    6t
    -16t
    -9t
    -74t
    125t
    -42t
    77t
    -32t
    7t
    0t
    81t
    88t
    117t
    -93t
    38t
    43t
    111t
    21t
    3t
    78t
    23t
    -76t
    -109t
    48t
    11t
    14t
    -104t
    20t
    29t
    14t
    82t
    -35t
    -113t
    -83t
    -115t
    -39t
    -91t
    -118t
    -95t
    -25t
    14t
    24t
    51t
    -89t
    60t
    -102t
    -85t
    64t
    -88t
    9t
    30t
    85t
    21t
    -30t
    83t
    65t
    40t
    -54t
    -33t
    20t
    -113t
    68t
    -126t
    -16t
    110t
    38t
    41t
    8t
    -45t
    -11t
    31t
    71t
    -99t
    16t
    110t
    -118t
    -95t
    -96t
    -20t
    91t
    65t
    -37t
    96t
    11t
    -38t
    86t
    38t
    122t
    85t
    41t
    -8t
    -89t
    121t
    93t
    -86t
    79t
    -61t
    -73t
    -70t
    -31t
    73t
    127t
    -67t
    -47t
    40t
    122t
    83t
    68t
    39t
    74t
    -44t
    81t
    -75t
    -89t
    -22t
    -23t
    10t
    60t
    1t
    -25t
    80t
    51t
    72t
    9t
    2t
    -22t
    28t
    6t
    106t
    -101t
    12t
    -108t
    71t
    -52t
    -35t
    98t
    97t
    73t
    -108t
    -49t
    122t
    -116t
    -98t
    -41t
    96t
    22t
    -57t
    120t
    49t
    76t
    75t
    -41t
    -64t
    -112t
    -102t
    63t
    38t
    49t
    15t
    29t
    -39t
    54t
    42t
    27t
    -36t
    85t
    96t
    88t
    -53t
    11t
    -71t
    65t
    120t
    -58t
    54t
    91t
    -115t
    -70t
    -52t
    -70t
    61t
    -24t
    78t
    51t
    122t
    69t
    -102t
    -18t
    13t
    -126t
    -22t
    60t
    -41t
    32t
    86t
    -53t
    87t
    35t
    44t
    -38t
    -42t
    -43t
    -83t
    107t
    -64t
    -98t
    -49t
    -63t
    3t
    10t
    45t
    -53t
    -87t
    -55t
    -121t
    -118t
    -12t
    -53t
    -55t
    0t
    80t
    2t
    -109t
    -23t
    -17t
    -40t
    69t
    -33t
    4t
    -78t
    114t
    100t
    -125t
    1t
    109t
    -28t
    -117t
    -34t
    -72t
    49t
    -73t
    13t
    -3t
    63t
    -43t
    111t
    41t
    123t
    -70t
    -28t
    91t
    112t
    116t
    51t
    -73t
    -58t
    -24t
    -47t
    11t
    -50t
    62t
    -85t
    33t
    11t
    122t
    1t
    111t
    -98t
    -21t
    59t
    52t
    -44t
    -85t
    115t
    -93t
    -80t
    125t
    -96t
    91t
    45t
    -80t
    -29t
    79t
    127t
    121t
    93t
    56t
    -94t
    -28t
    24t
    -93t
    -95t
    -31t
    -15t
    -86t
    -49t
    -83t
    -104t
    100t
    106t
    -114t
    17t
    -18t
    12t
    65t
    -121t
    -13t
    22t
    -43t
    -121t
    -83t
    57t
    118t
    20t
    -69t
    67t
    41t
    -21t
    17t
    -104t
    -50t
    -37t
    -108t
    3t
    -3t
    -82t
    -106t
    -18t
    88t
    87t
    36t
    -56t
    -6t
    27t
    -62t
    51t
    22t
    -105t
    -41t
    113t
    85t
    -84t
    -49t
    39t
    -68t
    107t
    62t
    49t
    124t
    -88t
    -24t
    -89t
    122t
    67t
    -31t
    -8t
    -41t
    74t
    -26t
    -102t
    -68t
    55t
    35t
    -90t
    -51t
    30t
    -69t
    78t
    -112t
    -68t
    -108t
    -22t
    71t
    -19t
    51t
    44t
    -96t
    -32t
    -117t
    33t
    -45t
    -66t
    1t
    -18t
    77t
    50t
    9t
    -61t
    124t
    118t
    105t
    33t
    8t
    66t
    -54t
    -127t
    97t
    115t
    38t
    -95t
    48t
    100t
    53t
    63t
    -15t
    -108t
    20t
    102t
    60t
    -6t
    114t
    33t
    65t
    -109t
    -39t
    -7t
    -34t
    87t
    -62t
    -127t
    -12t
    -37t
    -115t
    60t
    52t
    97t
    -46t
    2t
    9t
    -112t
    -101t
    125t
    21t
    -44t
    6t
    87t
    109t
    107t
    -70t
    -102t
    -126t
    -36t
    53t
    68t
    103t
    -128t
    14t
    -70t
    -43t
    -80t
    43t
    -85t
    -11t
    -44t
    34t
    30t
    -51t
    16t
    35t
    96t
    107t
    71t
    -63t
    -57t
    -36t
    92t
    -92t
    -110t
    -47t
    89t
    57t
    -30t
    115t
    82t
    74t
    42t
    -50t
    70t
    37t
    -46t
    -62t
    125t
    86t
    59t
    69t
    -123t
    -48t
    -55t
    104t
    -85t
    38t
    -42t
    103t
    127t
    -86t
    109t
    -61t
    121t
    -103t
    34t
    -67t
    17t
    -35t
    114t
    109t
    38t
    -68t
    -37t
    83t
    29t
    110t
    126t
    -46t
    110t
    -14t
    -61t
    -66t
    79t
    -24t
    -102t
    124t
    -64t
    99t
    -116t
    -100t
    113t
    77t
    -21t
    22t
    87t
    24t
    -8t
    -50t
    -16t
    31t
    100t
    -99t
    -13t
    -4t
    -69t
    77t
    102t
    -15t
    -25t
    -35t
    -22t
    -34t
    25t
    59t
    85t
    -123t
    -44t
    -115t
    -119t
    106t
    39t
    51t
    -25t
    -107t
    -25t
    126t
    5t
    104t
    -92t
    41t
    -25t
    -122t
    -91t
    19t
    -7t
    -16t
    -56t
    -119t
    120t
    74t
    -21t
    59t
    -112t
    75t
    -126t
    -126t
    -102t
    6t
    -9t
    113t
    -35t
    -48t
    -79t
    0t
    114t
    126t
    -82t
    17t
    -41t
    -53t
    114t
    84t
    -124t
    -10t
    96t
    35t
    -91t
    -88t
    -77t
    99t
    -123t
    80t
    -73t
    -88t
    -25t
    47t
    11t
    -1t
    -20t
    65t
    -42t
    -8t
    123t
    -54t
    -127t
    -82t
    -5t
    1t
    -35t
    -8t
    52t
    -92t
    51t
    -26t
    121t
    4t
    -94t
    -1t
    29t
    60t
    0t
    -14t
    67t
    25t
    82t
    -83t
    51t
    65t
    -59t
    34t
    115t
    -100t
    102t
    3t
    41t
    23t
    85t
    -28t
    -107t
    -31t
    14t
    -75t
    99t
    123t
    123t
    113t
    -23t
    -125t
    6t
    124t
    -82t
    83t
    74t
    -26t
    -79t
    -6t
    -91t
    -62t
    -82t
    10t
    82t
    11t
    -33t
    110t
    125t
    123t
    -6t
    98t
    50t
    82t
    41t
    -55t
    -82t
    -115t
    93t
    111t
    -76t
    -32t
    -40t
    125t
    -87t
    -10t
    94t
    18t
    82t
    -54t
    50t
    -35t
    99t
    -1t
    92t
    -2t
    118t
    -101t
    13t
    -63t
    -115t
    -81t
    -78t
    41t
    -111t
    -2t
    48t
    55t
    -4t
    94t
    56t
    67t
    31t
    -94t
    46t
    -2t
    117t
    -21t
    112t
    -109t
    -94t
    -82t
    -65t
    41t
    -95t
    107t
    -20t
    -15t
    93t
    -43t
    127t
    -24t
    19t
    -22t
    43t
    -4t
    64t
    108t
    88t
    103t
    79t
    -52t
    -52t
    -80t
    -63t
    -70t
    2t
    -22t
    -92t
    -21t
    30t
    -105t
    -22t
    -13t
    -18t
    107t
    36t
    -63t
    3t
    115t
    45t
    -107t
    -95t
    -24t
    112t
    15t
    -70t
    29t
    68t
    47t
    -79t
    -96t
    105t
    -60t
    101t
    91t
    -110t
    -104t
    -121t
    37t
    103t
    58t
    82t
    -88t
    73t
    -13t
    -112t
    -101t
    -108t
    -69t
    38t
    -113t
    18t
    -85t
    -72t
    44t
    99t
    118t
    -58t
    -101t
    55t
    121t
    0t
    -73t
    -58t
    112t
    19t
    47t
    66t
    -58t
    -101t
    -105t
    -3t
    58t
    35t
    -92t
    -33t
    -25t
    -45t
    52t
    -44t
    98t
    -86t
    -100t
    92t
    -90t
    31t
    125t
    42t
    -58t
    -39t
    70t
    -113t
    121t
    -99t
    -60t
    40t
    -53t
    -83t
    44t
    17t
    -8t
    -66t
    -101t
    -77t
    22t
    -21t
    23t
    117t
    83t
    105t
    -81t
    4t
    6t
    31t
    -97t
    61t
    -82t
    29t
    60t
    -64t
    21t
    -5t
    47t
    -82t
    68t
    64t
    -16t
    -120t
    -69t
    -121t
    -9t
    -11t
    -14t
    -65t
    -64t
    18t
    -112t
    -51t
    -32t
    120t
    -82t
    41t
    51t
    69t
    3t
    -73t
    9t
    -71t
    103t
    -84t
    46t
    -121t
    -97t
    -16t
    33t
    -85t
    -3t
    -79t
    -106t
    -116t
    5t
    97t
    -62t
    85t
    49t
    18t
    -22t
    -22t
    -82t
    76t
    104t
    83t
    6t
    118t
    117t
    -3t
    -111t
    -54t
    -47t
    -24t
    -28t
    105t
    118t
    -127t
    -48t
    11t
    39t
    44t
    -122t
    -26t
    39t
    28t
    23t
    -54t
    -62t
    16t
    -85t
    -109t
    48t
    38t
    -42t
    100t
    -64t
    -66t
    -84t
    -102t
    -104t
    -36t
    -46t
    29t
    -38t
    -37t
    27t
    84t
    74t
    77t
    -1t
    -74t
    -116t
    48t
    -6t
    -58t
    80t
    -107t
    -22t
    84t
    112t
    104t
    -43t
    54t
    -2t
    32t
    -117t
    -77t
    -98t
    63t
    74t
    -10t
    116t
    64t
    103t
    40t
    -69t
    3t
    34t
    80t
    93t
    -86t
    28t
    98t
    86t
    -38t
    86t
    40t
    41t
    -126t
    75t
    -14t
    -89t
    83t
    -102t
    29t
    23t
    107t
    25t
    -49t
    -76t
    6t
    -94t
    42t
    -82t
    92t
    49t
    19t
    -62t
    18t
    -106t
    80t
    -68t
    70t
    -92t
    -13t
    8t
    125t
    115t
    62t
    -63t
    -16t
    -17t
    1t
    -49t
    -69t
    119t
    104t
    -113t
    -35t
    -57t
    17t
    3t
    -94t
    -118t
    20t
    -7t
    36t
    -6t
    -55t
    76t
    38t
    85t
    89t
    66t
    -59t
    -38t
    70t
    -82t
    -10t
    -4t
    -12t
    20t
    -24t
    -57t
    -86t
    119t
    -87t
    -3t
    31t
    94t
    49t
    39t
    -104t
    -70t
    62t
    -63t
    127t
    111t
    97t
    -15t
    105t
    -38t
    120t
    -102t
    101t
    -35t
    -24t
    -102t
    46t
    56t
    96t
    79t
    -78t
    -115t
    -68t
    -52t
    84t
    35t
    107t
    124t
    8t
    -114t
    -14t
    -33t
    -102t
    -91t
    63t
    117t
    56t
    80t
    -110t
    -115t
    25t
    12t
    91t
    85t
    -68t
    -86t
    -97t
    1t
    13t
    -38t
    44t
    -12t
    102t
    109t
    -24t
    38t
    74t
    -102t
    -127t
    85t
    26t
    51t
    17t
    111t
    109t
    -46t
    113t
    -99t
    106t
    44t
    39t
    -1t
    86t
    -32t
    96t
    -37t
    49t
    -36t
    -104t
    -106t
    95t
    118t
    23t
    111t
    -126t
    91t
    -62t
    19t
    -36t
    66t
    -22t
    -36t
    76t
    79t
    -34t
    -101t
    -38t
    -59t
    -107t
    -87t
    21t
    -61t
    27t
    17t
    -51t
    101t
    54t
    0t
    5t
    -31t
    -2t
    43t
    -83t
    -4t
    52t
    34t
    58t
    19t
    121t
    31t
    -42t
    114t
    19t
    106t
    89t
    -106t
    -9t
    5t
    -65t
    93t
    14t
    -29t
    -12t
    119t
    9t
    -76t
    126t
    15t
    15t
    1t
    70t
    -113t
    55t
    -57t
    66t
    -43t
    -34t
    -80t
    -4t
    -87t
    80t
    6t
    46t
    -20t
    33t
    49t
    -57t
    21t
    105t
    -45t
    71t
    1t
    57t
    112t
    107t
    85t
    121t
    100t
    44t
    -99t
    108t
    123t
    59t
    -23t
    -95t
    -126t
    -101t
    -51t
    -115t
    115t
    11t
    -5t
    24t
    88t
    -38t
    -120t
    -87t
    24t
    61t
    46t
    28t
    -57t
    42t
    -15t
    -11t
    104t
    -60t
    -42t
    85t
    122t
    0t
    120t
    26t
    -74t
    -105t
    57t
    28t
    -55t
    50t
    -107t
    54t
    60t
    -83t
    -67t
    30t
    0t
    -128t
    52t
    37t
    65t
    6t
    15t
    31t
    -106t
    106t
    39t
    -11t
    69t
    -30t
    124t
    -19t
    56t
    -29t
    71t
    -34t
    83t
    -76t
    -23t
    -71t
    102t
    -32t
    -25t
    64t
    -122t
    -47t
    -112t
    100t
    102t
    -126t
    -82t
    116t
    96t
    -25t
    -55t
    96t
    -100t
    -103t
    -108t
    -30t
    -100t
    -107t
    -89t
    -117t
    -20t
    -124t
    -26t
    -98t
    127t
    118t
    -95t
    48t
    -26t
    93t
    72t
    107t
    10t
    14t
    8t
    -34t
    -124t
    -52t
    -9t
    -109t
    6t
    23t
    24t
    -42t
    73t
    18t
    -97t
    -107t
    70t
    -50t
    -113t
    -52t
    97t
    9t
    46t
    -21t
    89t
    -119t
    66t
    -28t
    1t
    -58t
    31t
    -50t
    97t
    -49t
    -5t
    -108t
    -62t
    73t
    23t
    75t
    28t
    11t
    -83t
    29t
    96t
    -5t
    121t
    -125t
    -34t
    2t
    -24t
    -100t
    -68t
    -4t
    117t
    30t
    126t
    -54t
    -121t
    34t
    19t
    -107t
    -81t
    -66t
    27t
    27t
    -103t
    -109t
    28t
    -103t
    70t
    -60t
    -87t
    53t
    -30t
    121t
    -96t
    16t
    29t
    70t
    1t
    -122t
    106t
    -41t
    -62t
    62t
    -86t
    -38t
    -111t
    63t
    -17t
    103t
    35t
    39t
    88t
    122t
    115t
    -61t
    -95t
    61t
    118t
    -65t
    86t
    -116t
    -122t
    -17t
    46t
    121t
    -5t
    -39t
    -100t
    49t
    -103t
    10t
    95t
    28t
    82t
    -56t
    37t
    -8t
    -102t
    -97t
    -41t
    86t
    65t
    111t
    63t
    85t
    47t
    -118t
    -64t
    77t
    44t
    118t
    -81t
    -38t
    110t
    1t
    11t
    117t
    106t
    -72t
    69t
    51t
    29t
    117t
    -69t
    55t
    -55t
    -42t
    38t
    -1t
    -33t
    116t
    111t
    -67t
    64t
    -117t
    -80t
    -108t
    3t
    -119t
    8t
    -6t
    123t
    -60t
    122t
    -50t
    95t
    12t
    -27t
    58t
    8t
    70t
    47t
    52t
    8t
    -4t
    45t
    43t
    -35t
    -24t
    -48t
    -48t
    -76t
    -106t
    -80t
    44t
    94t
    105t
    -75t
    78t
    76t
    -101t
    97t
    36t
    -93t
    70t
    -44t
    41t
    11t
    3t
    76t
    90t
    86t
    -24t
    -30t
    112t
    54t
    -58t
    55t
    52t
    74t
    -33t
    48t
    -88t
    61t
    -22t
    112t
    -59t
    25t
    -36t
    -43t
    83t
    68t
    66t
    90t
    -128t
    14t
    21t
    30t
    -57t
    -81t
    -126t
    -97t
    -70t
    -57t
    27t
    -108t
    -77t
    -14t
    121t
    37t
    -17t
    -89t
    -91t
    5t
    -87t
    -8t
    -104t
    41t
    55t
    -29t
    -87t
    -105t
    52t
    -90t
    92t
    8t
    -61t
    86t
    22t
    -115t
    19t
    87t
    -53t
    106t
    -37t
    -12t
    -78t
    -24t
    -66t
    -95t
    -58t
    108t
    8t
    37t
    -73t
    83t
    11t
    -82t
    9t
    -61t
    -53t
    -3t
    101t
    -80t
    125t
    -103t
    27t
    -99t
    88t
    65t
    -125t
    -40t
    83t
    108t
    115t
    100t
    23t
    -98t
    -125t
    -18t
    -8t
    -119t
    -92t
    -127t
    103t
    33t
    -75t
    90t
    21t
    66t
    -37t
    -80t
    60t
    -59t
    -63t
    -15t
    -29t
    -6t
    104t
    -30t
    -57t
    -13t
    -126t
    -13t
    -80t
    95t
    73t
    -57t
    49t
    -84t
    8t
    74t
    -9t
    -76t
    -7t
    -35t
    39t
    57t
    97t
    -32t
    100t
    87t
    125t
    -110t
    66t
    -97t
    88t
    16t
    104t
    81t
    6t
    -82t
    -111t
    82t
    -16t
    91t
    -60t
    29t
    -57t
    25t
    -11t
    77t
    58t
    -78t
    122t
    -15t
    106t
    84t
    86t
    -17t
    -93t
    -60t
    -36t
    -66t
    -33t
    -107t
    38t
    72t
    24t
    1t
    3t
    -44t
    -75t
    38t
    -44t
    75t
    10t
    -58t
    -46t
    94t
    123t
    61t
    -17t
    10t
    118t
    -15t
    125t
    97t
    -83t
    38t
    107t
    66t
    6t
    111t
    -17t
    79t
    -63t
    28t
    28t
    -120t
    -109t
    20t
    32t
    -18t
    15t
    16t
    -94t
    16t
    51t
    82t
    -54t
    -86t
    12t
    104t
    -59t
    -96t
    -25t
    -35t
    -69t
    78t
    114t
    79t
    -92t
    -58t
    -5t
    92t
    -79t
    43t
    -115t
    25t
    -66t
    65t
    -93t
    -113t
    -27t
    67t
    99t
    -43t
    -66t
    35t
    88t
    11t
    -5t
    126t
    -61t
    -105t
    11t
    30t
    -73t
    78t
    126t
    77t
    -29t
    60t
    12t
    65t
    -84t
    105t
    -46t
    -64t
    -124t
    51t
    5t
    65t
    -84t
    -89t
    -93t
    86t
    72t
    3t
    -15t
    -36t
    93t
    -3t
    32t
    -57t
    81t
    -3t
    101t
    -91t
    -110t
    -65t
    -39t
    -92t
    90t
    -31t
    76t
    -101t
    -119t
    65t
    102t
    -122t
    -62t
    89t
    18t
    -36t
    -68t
    78t
    41t
    123t
    -93t
    119t
    -75t
    94t
    -72t
    -105t
    -79t
    -33t
    120t
    -71t
    -45t
    -126t
    -118t
    -16t
    62t
    -119t
    36t
    -80t
    123t
    37t
    91t
    -68t
    -14t
    43t
    99t
    -66t
    89t
    -16t
    -56t
    -31t
    21t
    -1t
    -77t
    -80t
    -77t
    -40t
    74t
    117t
    111t
    -65t
    -32t
    -14t
    -71t
    -67t
    -32t
    117t
    27t
    51t
    -40t
    -110t
    -116t
    -3t
    -61t
    -104t
    63t
    -43t
    -103t
    -58t
    -80t
    2t
    39t
    35t
    94t
    12t
    -17t
    103t
    108t
    31t
    114t
    81t
    1t
    -94t
    120t
    112t
    110t
    -6t
    -76t
    -117t
    84t
    5t
    -7t
    63t
    -72t
    2t
    -79t
    44t
    110t
    -44t
    93t
    23t
    92t
    -124t
    -11t
    -63t
    -70t
    -29t
    74t
    -34t
    23t
    -14t
    112t
    79t
    -123t
    -66t
    39t
    40t
    38t
    112t
    -70t
    85t
    -3t
    -45t
    -78t
    84t
    -115t
    -107t
    47t
    -97t
    -122t
    -112t
    105t
    -13t
    38t
    70t
    -3t
    83t
    -117t
    6t
    51t
    53t
    26t
    -113t
    5t
    -79t
    -30t
    -81t
    96t
    -34t
    106t
    -110t
    12t
    66t
    -94t
    41t
    -101t
    -43t
    35t
    -65t
    98t
    32t
    -12t
    127t
    4t
    -81t
    -37t
    -26t
    -92t
    -93t
    123t
    81t
    -17t
    -52t
    -116t
    -73t
    38t
    115t
    40t
    126t
    -61t
    33t
    -29t
    116t
    -112t
    -106t
    88t
    -15t
    -68t
    -71t
    -32t
    -103t
    -37t
    38t
    74t
    -114t
    21t
    3t
    -48t
    16t
    -1t
    -115t
    -24t
    -84t
    -121t
    -45t
    25t
    11t
    64t
    74t
    101t
    13t
    22t
    36t
    45t
    -47t
    88t
    -28t
    105t
    -32t
    110t
    20t
    -112t
    35t
    -93t
    -26t
    -67t
    -121t
    -71t
    49t
    57t
    -119t
    -69t
    -84t
    19t
    27t
    96t
    122t
    -48t
    -40t
    -34t
    -122t
    52t
    15t
    32t
    7t
    44t
    66t
    21t
    118t
    -112t
    -28t
    89t
    -73t
    -88t
    83t
    -1t
    -13t
    -48t
    -62t
    30t
    -69t
    -113t
    -26t
    -61t
    -94t
    48t
    -70t
    93t
    -31t
    18t
    -75t
    114t
    -128t
    -9t
    -112t
    -70t
    -57t
    -2t
    7t
    55t
    97t
    -40t
    96t
    46t
    -124t
    -66t
    95t
    21t
    105t
    115t
    -25t
    18t
    51t
    37t
    -54t
    82t
    46t
    63t
    -125t
    -64t
    100t
    -119t
    34t
    57t
    -14t
    -113t
    49t
    23t
    59t
    -67t
    -81t
    105t
    109t
    125t
    -77t
    97t
    30t
    -60t
    68t
    96t
    101t
    -106t
    13t
    -122t
    28t
    87t
    -50t
    123t
    35t
    -81t
    90t
    49t
    -38t
    118t
    10t
    126t
    -2t
    -94t
    -114t
    24t
    120t
    -53t
    83t
    71t
    -91t
    26t
    -44t
    -33t
    125t
    8t
    25t
    -70t
    -21t
    -67t
    -110t
    -20t
    21t
    -102t
    118t
    40t
    9t
    -67t
    92t
    -41t
    -73t
    -126t
    -80t
    81t
    20t
    29t
    94t
    76t
    -79t
    -75t
    102t
    -42t
    -5t
    83t
    59t
    -56t
    -104t
    68t
    -44t
    57t
    27t
    -115t
    29t
    -93t
    125t
    111t
    -77t
    47t
    -39t
    127t
    -33t
    -77t
    40t
    122t
    -10t
    -32t
    70t
    -117t
    -115t
    -96t
    121t
    -64t
    -32t
    -13t
    121t
    41t
    37t
    86t
    -66t
    7t
    92t
    -124t
    110t
    -90t
    125t
    -98t
    -90t
    115t
    40t
    -113t
    -101t
    13t
    -104t
    -31t
    -53t
    -29t
    -121t
    118t
    70t
    -52t
    42t
    -42t
    126t
    29t
    71t
    -17t
    -106t
    82t
    67t
    111t
    -49t
    -123t
    -43t
    -74t
    89t
    -97t
    -92t
    -47t
    -62t
    6t
    -117t
    4t
    63t
    -7t
    -73t
    -66t
    52t
    -46t
    -8t
    -107t
    -60t
    57t
    -87t
    92t
    -92t
    -53t
    -94t
    39t
    47t
    8t
    -48t
    29t
    10t
    -2t
    126t
    43t
    20t
    -103t
    14t
    -42t
    -40t
    67t
    77t
    6t
    89t
    33t
    58t
    -126t
    17t
    -84t
    -103t
    -76t
    49t
    80t
    91t
    43t
    -66t
    -37t
    -67t
    85t
    43t
    -62t
    3t
    -9t
    115t
    -53t
    60t
    -39t
    117t
    -101t
    -65t
    -61t
    111t
    -7t
    -78t
    -120t
    -21t
    111t
    71t
    7t
    72t
    94t
    116t
    -70t
    -77t
    -78t
    62t
    -116t
    119t
    63t
    100t
    74t
    56t
    127t
    6t
    73t
    -57t
    32t
    -20t
    -83t
    -71t
    -90t
    -92t
    -24t
    -98t
    118t
    -13t
    45t
    112t
    97t
    -103t
    -102t
    1t
    -69t
    -74t
    80t
    87t
    120t
    -87t
    66t
    104t
    43t
    -65t
    123t
    -24t
    -31t
    19t
    92t
    69t
    -79t
    101t
    32t
    -32t
    41t
    120t
    77t
    -36t
    18t
    -115t
    -75t
    -116t
    -52t
    -24t
    9t
    -55t
    -40t
    67t
    81t
    -108t
    9t
    38t
    71t
    123t
    1t
    76t
    -126t
    84t
    14t
    -17t
    -53t
    100t
    -94t
    22t
    -124t
    -2t
    -75t
    51t
    50t
    51t
    125t
    -54t
    -22t
    -26t
    22t
    125t
    74t
    56t
    -13t
    115t
    -124t
    -32t
    14t
    -46t
    -116t
    -76t
    -109t
    74t
    50t
    -38t
    -6t
    -116t
    21t
    -4t
    -95t
    70t
    -113t
    -100t
    -127t
    -72t
    -115t
    62t
    26t
    -89t
    126t
    -42t
    86t
    -41t
    3t
    -108t
    -75t
    32t
    -32t
    -42t
    -72t
    -102t
    81t
    -12t
    92t
    21t
    76t
    -69t
    48t
    113t
    -113t
    -60t
    99t
    -30t
    25t
    -77t
    -117t
    -49t
    -12t
    104t
    47t
    3t
    9t
    -111t
    -103t
    -36t
    103t
    10t
    -19t
    8t
    -46t
    57t
    -113t
    117t
    125t
    -124t
    -126t
    -71t
    -29t
    120t
    -99t
    -58t
    -78t
    123t
    26t
    -49t
    30t
    -25t
    -105t
    5t
    -115t
    118t
    44t
    -27t
    47t
    -37t
    67t
    11t
    -52t
    -114t
    -41t
    94t
    14t
    54t
    -112t
    49t
    -30t
    98t
    -111t
    -61t
    89t
    106t
    -61t
    121t
    46t
    71t
    -52t
    119t
    -53t
    101t
    -100t
    72t
    -35t
    109t
    50t
    68t
    -39t
    9t
    70t
    -77t
    -56t
    -48t
    -49t
    -58t
    74t
    -127t
    -94t
    47t
    -6t
    -127t
    70t
    117t
    -41t
    123t
    111t
    18t
    120t
    -13t
    14t
    80t
    91t
    -45t
    115t
    -51t
    7t
    120t
    -6t
    111t
    38t
    -42t
    12t
    123t
    -28t
    99t
    1t
    115t
    -11t
    5t
    126t
    61t
    105t
    -22t
    -117t
    -1t
    87t
    -42t
    -20t
    -5t
    -87t
    -16t
    48t
    -15t
    18t
    2t
    -116t
    101t
    120t
    -64t
    81t
    66t
    94t
    -18t
    115t
    89t
    -76t
    116t
    54t
    -50t
    -67t
    55t
    9t
    108t
    105t
    24t
    24t
    -21t
    72t
    86t
    -11t
    21t
    -45t
    -121t
    -39t
    33t
    29t
    26t
    114t
    123t
    -107t
    -87t
    49t
    -125t
    -103t
    83t
    -51t
    -39t
    -78t
    67t
    99t
    -55t
    -127t
    20t
    53t
    -76t
    113t
    -97t
    61t
    -124t
    91t
    4t
    71t
    -121t
    -125t
    66t
    -97t
    109t
    77t
    20t
    75t
    113t
    -55t
    -46t
    100t
    19t
    42t
    -103t
    -98t
    121t
    -87t
    117t
    -4t
    -119t
    -44t
    25t
    -42t
    15t
    -113t
    26t
    -59t
    88t
    -64t
    -101t
    -6t
    11t
    -75t
    -59t
    39t
    76t
    -128t
    -118t
    -4t
    123t
    -118t
    92t
    103t
    30t
    36t
    -106t
    -50t
    -98t
    54t
    37t
    43t
    78t
    -70t
    12t
    -122t
    -101t
    -46t
    -82t
    123t
    79t
    -113t
    19t
    -81t
    35t
    56t
    -18t
    0t
    -118t
    106t
    90t
    126t
    76t
    -32t
    -20t
    -128t
    -38t
    -118t
    110t
    -106t
    18t
    74t
    126t
    -90t
    -125t
    87t
    25t
    48t
    -62t
    -109t
    -80t
    31t
    47t
    81t
    73t
    -71t
    -36t
    -85t
    -86t
    -44t
    -83t
    -80t
    -7t
    -73t
    86t
    71t
    -45t
    -82t
    -70t
    87t
    -7t
    90t
    -89t
    -86t
    74t
    51t
    -41t
    115t
    -6t
    -4t
    -60t
    84t
    -81t
    79t
    124t
    -111t
    15t
    -40t
    -116t
    -29t
    47t
    60t
    38t
    16t
    -83t
    19t
    -92t
    41t
    114t
    -62t
    -104t
    -108t
    20t
    100t
    -51t
    23t
    72t
    108t
    -62t
    62t
    13t
    -47t
    -78t
    -34t
    -91t
    -92t
    20t
    -71t
    -18t
    37t
    55t
    49t
    15t
    77t
    -20t
    0t
    14t
    17t
    -63t
    -52t
    120t
    124t
    65t
    -127t
    -58t
    -3t
    72t
    -82t
    -95t
    24t
    109t
    -84t
    92t
    -19t
    101t
    21t
    4t
    -55t
    14t
    -46t
    -58t
    115t
    56t
    -116t
    68t
    24t
    48t
    -5t
    55t
    23t
    62t
    -49t
    -72t
    20t
    -86t
    33t
    -72t
    6t
    89t
    7t
    -6t
    -119t
    -72t
    -84t
    -15t
    -24t
    88t
    -78t
    -16t
    112t
    -38t
    -84t
    64t
    -15t
    115t
    -23t
    31t
    13t
    -101t
    23t
    -104t
    -84t
    126t
    15t
    -69t
    82t
    -110t
    -97t
    -13t
    -63t
    67t
    -52t
    -99t
    -126t
    86t
    -87t
    42t
    -42t
    -51t
    20t
    2t
    -27t
    -34t
    -81t
    87t
    -5t
    71t
    -66t
    -9t
    -41t
    86t
    82t
    -44t
    106t
    -1t
    73t
    101t
    -105t
    -97t
    -31t
    72t
    -84t
    -103t
    19t
    10t
    -56t
    6t
    95t
    -53t
    -66t
    -121t
    49t
    1t
    -41t
    40t
    24t
    101t
    -83t
    64t
    105t
    63t
    -51t
    -39t
    71t
    35t
    -13t
    -61t
    43t
    -51t
    -94t
    81t
    60t
    34t
    87t
    82t
    -87t
    123t
    87t
    -82t
    -33t
    47t
    -30t
    -53t
    -13t
    -5t
    22t
    -36t
    71t
    45t
    7t
    109t
    66t
    74t
    -125t
    44t
    -63t
    13t
    -127t
    85t
    7t
    -127t
    23t
    -10t
    18t
    53t
    18t
    102t
    -8t
    -39t
    83t
    58t
    79t
    -33t
    -47t
    -95t
    -78t
    60t
    -72t
    -11t
    -1t
    105t
    -128t
    -49t
    86t
    -58t
    -110t
    102t
    -19t
    13t
    -67t
    95t
    51t
    -63t
    11t
    -84t
    83t
    -24t
    -10t
    -17t
    114t
    -55t
    -39t
    51t
    -67t
    58t
    -39t
    84t
    -5t
    -114t
    -9t
    35t
    -82t
    -42t
    74t
    100t
    -70t
    125t
    -49t
    24t
    -82t
    -114t
    104t
    52t
    -126t
    25t
    -58t
    85t
    -55t
    30t
    107t
    -52t
    -126t
    58t
    68t
    124t
    -102t
    -14t
    13t
    101t
    27t
    102t
    -64t
    114t
    -68t
    -117t
    124t
    117t
    -91t
    18t
    110t
    -90t
    -103t
    -112t
    34t
    -72t
    9t
    86t
    -101t
    -61t
    50t
    -74t
    61t
    36t
    -79t
    126t
    -15t
    -6t
    102t
    -23t
    -54t
    -30t
    67t
    5t
    -104t
    64t
    49t
    61t
    -38t
    31t
    -2t
    -24t
    14t
    5t
    90t
    51t
    -69t
    -107t
    43t
    -4t
    -68t
    103t
    59t
    -103t
    126t
    -6t
    71t
    -105t
    49t
    47t
    24t
    75t
    95t
    -29t
    -93t
    -3t
    -28t
    14t
    87t
    -71t
    81t
    93t
    -109t
    78t
    -20t
    59t
    -114t
    24t
    -99t
    -7t
    115t
    13t
    124t
    30t
    -34t
    52t
    -33t
    -31t
    -11t
    25t
    -80t
    -20t
    -105t
    -90t
    13t
    -54t
    84t
    118t
    -15t
    -72t
    -36t
    -109t
    -93t
    -62t
    -100t
    66t
    -112t
    -6t
    -62t
    -77t
    82t
    51t
    23t
    -59t
    110t
    126t
    -89t
    -97t
    6t
    -66t
    -61t
    -92t
    -58t
    37t
    -80t
    -91t
    -68t
    -61t
    90t
    -108t
    20t
    75t
    -82t
    -40t
    -11t
    -2t
    88t
    27t
    -2t
    -118t
    -116t
    -112t
    18t
    -64t
    -15t
    79t
    89t
    46t
    -124t
    63t
    97t
    -116t
    -114t
    -103t
    4t
    -114t
    16t
    -115t
    -65t
    96t
    51t
    -30t
    -75t
    -64t
    56t
    -43t
    48t
    -63t
    70t
    -4t
    33t
    114t
    114t
    40t
    -112t
    -17t
    -41t
    11t
    120t
    -108t
    94t
    -96t
    -115t
    67t
    3t
    -118t
    -111t
    101t
    81t
    -36t
    -6t
    87t
    54t
    26t
    47t
    37t
    116t
    49t
    15t
    96t
    26t
    -87t
    103t
    -49t
    -80t
    -58t
    65t
    9t
    37t
    86t
    -118t
    -54t
    121t
    32t
    7t
    -103t
    4t
    -60t
    96t
    -84t
    71t
    -35t
    -18t
    79t
    -89t
    7t
    -8t
    -99t
    -67t
    94t
    54t
    -56t
    96t
    -3t
    103t
    -24t
    9t
    -10t
    -82t
    86t
    86t
    -6t
    -23t
    109t
    -15t
    111t
    105t
    63t
    43t
    -10t
    -50t
    112t
    71t
    -93t
    21t
    30t
    20t
    20t
    72t
    92t
    -83t
    100t
    -119t
    45t
    126t
    -119t
    -93t
    96t
    -13t
    -103t
    -25t
    -10t
    -59t
    -47t
    8t
    -13t
    65t
    62t
    -98t
    -85t
    109t
    -123t
    71t
    -25t
    -106t
    -94t
    92t
    -53t
    -30t
    -85t
    -120t
    68t
    -1t
    90t
    -9t
    33t
    85t
    -112t
    -55t
    -68t
    113t
    19t
    119t
    -12t
    -107t
    -52t
    31t
    79t
    -69t
    -118t
    -54t
    125t
    -62t
    -52t
    95t
    3t
    120t
    70t
    -54t
    -30t
    -13t
    16t
    -109t
    -117t
    44t
    -54t
    91t
    42t
    -120t
    56t
    53t
    -124t
    4t
    43t
    67t
    -17t
    -67t
    -65t
    8t
    16t
    19t
    39t
    15t
    56t
    -53t
    102t
    34t
    -42t
    42t
    45t
    123t
    96t
    64t
    -10t
    -78t
    -116t
    -9t
    -96t
    110t
    -63t
    34t
    -119t
    -8t
    -50t
    53t
    54t
    -26t
    -63t
    -105t
    -11t
    102t
    26t
    118t
    -90t
    122t
    -50t
    -72t
    -44t
    -109t
    -11t
    126t
    -59t
    -67t
    105t
    92t
    53t
    118t
    48t
    -23t
    -124t
    73t
    -123t
    33t
    -116t
    -53t
    4t
    106t
    -87t
    -122t
    78t
    48t
    -15t
    -94t
    -77t
    69t
    -73t
    -104t
    -8t
    -66t
    75t
    -117t
    108t
    99t
    51t
    -68t
    89t
    46t
    -94t
    -78t
    -90t
    40t
    -58t
    -95t
    38t
    -10t
    -111t
    4t
    -19t
    -5t
    79t
    -24t
    -3t
    -119t
    127t
    74t
    -32t
    103t
    16t
    44t
    87t
    -83t
    85t
    64t
    -89t
    16t
    -113t
    103t
    -80t
    -19t
    -108t
    115t
    -80t
    84t
    -128t
    67t
    62t
    -88t
    -120t
    -99t
    11t
    -113t
    126t
    -69t
    -73t
    -54t
    -57t
    -68t
    37t
    -103t
    58t
    -38t
    16t
    -71t
    -68t
    107t
    -102t
    63t
    82t
    -5t
    52t
    109t
    91t
    117t
    105t
    -41t
    34t
    35t
    86t
    -93t
    64t
    -28t
    -42t
    -76t
    -69t
    -4t
    50t
    10t
    -60t
    -14t
    12t
    -2t
    -96t
    -78t
    -99t
    67t
    -23t
    -74t
    -88t
    -6t
    84t
    -41t
    56t
    -34t
    -112t
    26t
    127t
    78t
    -26t
    -25t
    -115t
    -114t
    19t
    -21t
    44t
    47t
    109t
    -107t
    39t
    76t
    -94t
    -106t
    -90t
    -80t
    40t
    109t
    24t
    66t
    103t
    -36t
    19t
    9t
    7t
    -86t
    -63t
    108t
    89t
    -125t
    93t
    38t
    121t
    -82t
    58t
    43t
    -105t
    0t
    11t
    118t
    123t
    -83t
    38t
    -62t
    42t
    106t
    -113t
    -53t
    -43t
    93t
    -70t
    57t
    63t
    -1t
    -28t
    2t
    50t
    -98t
    58t
    -49t
    55t
    -29t
    48t
    -84t
    72t
    -75t
    38t
    -91t
    -90t
    126t
    -7t
    36t
    -96t
    40t
    27t
    27t
    16t
    -115t
    71t
    -78t
    124t
    -52t
    106t
    20t
    -39t
    125t
    116t
    -88t
    -65t
    114t
    88t
    -43t
    5t
    -3t
    -96t
    113t
    -72t
    110t
    59t
    62t
    80t
    26t
    79t
    -13t
    109t
    -111t
    52t
    117t
    -16t
    -103t
    -81t
    -112t
    65t
    33t
    101t
    70t
    -13t
    90t
    101t
    39t
    29t
    -8t
    -111t
    39t
    25t
    96t
    -84t
    84t
    -117t
    52t
    -96t
    10t
    95t
    -66t
    70t
    65t
    4t
    -77t
    100t
    109t
    -120t
    -17t
    21t
    -87t
    -72t
    69t
    -117t
    51t
    14t
    -102t
    118t
    -42t
    -109t
    -4t
    -26t
    11t
    -68t
    -88t
    8t
    -86t
    89t
    44t
    5t
    119t
    -106t
    46t
    95t
    -50t
    55t
    94t
    33t
    92t
    121t
    86t
    -80t
    82t
    85t
    -30t
    -33t
    74t
    101t
    4t
    -31t
    -116t
    80t
    -37t
    50t
    -79t
    -15t
    -91t
    -29t
    -63t
    112t
    -1t
    -54t
    127t
    -98t
    -109t
    -47t
    -119t
    -39t
    94t
    -52t
    29t
    -61t
    -49t
    84t
    -16t
    22t
    -119t
    -10t
    80t
    31t
    -7t
    -115t
    51t
    -23t
    93t
    -105t
    119t
    43t
    -47t
    92t
    58t
    -94t
    83t
    -53t
    -81t
    -26t
    94t
    30t
    89t
    -106t
    -116t
    82t
    5t
    -22t
    2t
    -51t
    84t
    -81t
    -118t
    -81t
    -51t
    -10t
    -115t
    90t
    -88t
    -14t
    -117t
    -28t
    -39t
    -126t
    30t
    47t
    51t
    76t
    -17t
    -110t
    -4t
    -83t
    77t
    -31t
    -12t
    -62t
    -27t
    117t
    7t
    13t
    28t
    -35t
    8t
    30t
    -101t
    98t
    -70t
    91t
    -35t
    40t
    -28t
    -128t
    -104t
    87t
    77t
    62t
    69t
    89t
    -66t
    -15t
    -111t
    -81t
    -41t
    79t
    11t
    -93t
    69t
    125t
    113t
    -33t
    -114t
    -124t
    -41t
    73t
    38t
    105t
    120t
    -75t
    -61t
    -110t
    -3t
    77t
    -51t
    -28t
    89t
    -37t
    -78t
    25t
    -37t
    26t
    -49t
    13t
    74t
    -15t
    -6t
    -83t
    -18t
    82t
    6t
    -104t
    118t
    -73t
    -18t
    -55t
    17t
    -75t
    -74t
    -39t
    -49t
    17t
    55t
    8t
    31t
    -71t
    105t
    111t
    -98t
    -109t
    -24t
    -12t
    21t
    -13t
    -121t
    -124t
    124t
    -31t
    -13t
    49t
    123t
    -55t
    -116t
    -23t
    96t
    13t
    107t
    100t
    -116t
    72t
    3t
    24t
    23t
    94t
    25t
    -47t
    -101t
    -53t
    -59t
    25t
    121t
    27t
    -75t
    79t
    126t
    -37t
    -8t
    -127t
    63t
    20t
    10t
    -125t
    -31t
    -75t
    -9t
    -97t
    62t
    97t
    -97t
    -58t
    -67t
    95t
    -79t
    109t
    16t
    -24t
    -6t
    91t
    -126t
    -101t
    121t
    -21t
    22t
    -2t
    -51t
    91t
    69t
    61t
    57t
    100t
    16t
    58t
    -56t
    111t
    70t
    12t
    48t
    49t
    -105t
    -26t
    -82t
    -79t
    -96t
    31t
    44t
    74t
    58t
    34t
    -15t
    16t
    -93t
    -81t
    -126t
    84t
    -50t
    80t
    -33t
    -71t
    -51t
    27t
    75t
    -127t
    9t
    62t
    89t
    49t
    121t
    124t
    -121t
    20t
    -32t
    73t
    -92t
    52t
    -92t
    -128t
    -55t
    59t
    8t
    125t
    84t
    -71t
    28t
    57t
    -90t
    -47t
    -120t
    93t
    20t
    100t
    -22t
    16t
    78t
    124t
    -45t
    28t
    5t
    -44t
    -5t
    -25t
    -42t
    -65t
    61t
    -128t
    -117t
    -7t
    86t
    77t
    123t
    14t
    -32t
    89t
    -101t
    -85t
    121t
    1t
    56t
    -49t
    -35t
    -94t
    90t
    -113t
    91t
    116t
    -105t
    -95t
    11t
    31t
    -76t
    -72t
    78t
    -1t
    -49t
    -48t
    -124t
    -53t
    125t
    -119t
    123t
    -54t
    92t
    -13t
    -75t
    108t
    82t
    -102t
    115t
    -46t
    -7t
    45t
    -121t
    -85t
    -3t
    -124t
    -115t
    44t
    46t
    -94t
    -113t
    56t
    -70t
    116t
    77t
    -67t
    14t
    69t
    -90t
    25t
    108t
    -76t
    -124t
    -113t
    17t
    62t
    92t
    2t
    -48t
    -32t
    -100t
    -98t
    -15t
    -97t
    63t
    20t
    110t
    100t
    -1t
    56t
    -42t
    -93t
    12t
    15t
    31t
    -113t
    87t
    112t
    109t
    -10t
    24t
    126t
    -54t
    -29t
    -35t
    -101t
    -19t
    0t
    32t
    -1t
    10t
    -105t
    115t
    41t
    20t
    4t
    -95t
    84t
    90t
    -13t
    -70t
    -75t
    -115t
    43t
    -111t
    79t
    -114t
    80t
    -65t
    19t
    73t
    -110t
    -67t
    7t
    31t
    59t
    43t
    -22t
    -37t
    33t
    61t
    28t
    -2t
    54t
    -65t
    15t
    -95t
    -32t
    125t
    -26t
    117t
    33t
    9t
    13t
    83t
    -14t
    -17t
    -68t
    30t
    -82t
    76t
    -35t
    54t
    -89t
    -85t
    -50t
    24t
    2t
    22t
    -86t
    24t
    78t
    70t
    42t
    50t
    -107t
    19t
    98t
    58t
    120t
    51t
    -49t
    45t
    -54t
    98t
    17t
    -86t
    104t
    61t
    82t
    -77t
    -40t
    64t
    96t
    -107t
    -102t
    105t
    -31t
    -13t
    56t
    58t
    24t
    -5t
    -125t
    -124t
    50t
    -82t
    -83t
    -61t
    61t
    101t
    36t
    119t
    -10t
    94t
    106t
    -115t
    102t
    -57t
    44t
    -59t
    -80t
    -107t
    105t
    0t
    109t
    -91t
    44t
    61t
    67t
    -30t
    29t
    -122t
    -110t
    107t
    -114t
    -66t
    112t
    -34t
    -128t
    -11t
    -52t
    -62t
    -93t
    -127t
    -117t
    -1t
    8t
    -111t
    -106t
    -2t
    -112t
    -67t
    -74t
    79t
    120t
    -126t
    -17t
    71t
    46t
    -47t
    -72t
    -28t
    116t
    -75t
    64t
    -10t
    70t
    -85t
    81t
    46t
    78t
    116t
    -102t
    -76t
    -82t
    -11t
    41t
    33t
    -127t
    127t
    68t
    1t
    -86t
    50t
    93t
    -66t
    38t
    39t
    118t
    12t
    -85t
    -10t
    43t
    28t
    76t
    -53t
    -100t
    103t
    124t
    -116t
    -21t
    -71t
    114t
    24t
    -92t
    -55t
    111t
    54t
    113t
    123t
    -104t
    -28t
    120t
    68t
    104t
    -82t
    -103t
    99t
    -120t
    -89t
    50t
    -82t
    96t
    -77t
    62t
    41t
    122t
    -14t
    4t
    -3t
    -112t
    56t
    -46t
    83t
    93t
    16t
    33t
    32t
    -99t
    -50t
    59t
    57t
    -90t
    -101t
    17t
    24t
    -57t
    49t
    -30t
    47t
    39t
    72t
    98t
    -124t
    95t
    108t
    75t
    52t
    73t
    82t
    95t
    -72t
    6t
    40t
    -99t
    33t
    -81t
    9t
    -11t
    52t
    -44t
    -25t
    107t
    -31t
    -75t
    94t
    -18t
    44t
    -101t
    0t
    -25t
    55t
    9t
    -107t
    -69t
    -103t
    29t
    -4t
    -124t
    -43t
    52t
    21t
    -86t
    -48t
    39t
    -109t
    -117t
    -66t
    -51t
    4t
    -62t
    45t
    -93t
    20t
    -126t
    -17t
    44t
    -89t
    -97t
    -77t
    16t
    -119t
    127t
    -59t
    9t
    -71t
    97t
    -68t
    33t
    24t
    -21t
    119t
    16t
    46t
    -72t
    48t
    -66t
    -67t
    116t
    73t
    -42t
    42t
    -17t
    -72t
    -69t
    49t
    44t
    67t
    114t
    -100t
    87t
    36t
    66t
    -103t
    -32t
    -62t
    -34t
    -99t
    40t
    6t
    51t
    4t
    9t
    -49t
    -56t
    -96t
    -120t
    -108t
    -81t
    -122t
    104t
    -104t
    -26t
    -119t
    -35t
    -88t
    117t
    73t
    -91t
    37t
    74t
    -13t
    -81t
    -11t
    123t
    29t
    15t
    -20t
    -49t
    -79t
    51t
    -76t
    -64t
    -127t
    -74t
    -107t
    56t
    -119t
    0t
    -9t
    -92t
    -27t
    -127t
    14t
    -64t
    -88t
    -33t
    35t
    -63t
    71t
    83t
    83t
    28t
    -66t
    -18t
    -117t
    5t
    -22t
    93t
    -122t
    -59t
    -49t
    -42t
    -54t
    -48t
    41t
    108t
    92t
    -43t
    107t
    112t
    -111t
    34t
    -39t
    110t
    -120t
    -36t
    31t
    -46t
    69t
    72t
    -6t
    -40t
    54t
    -99t
    59t
    -25t
    -54t
    123t
    77t
    44t
    84t
    53t
    4t
    37t
    -8t
    73t
    45t
    96t
    123t
    94t
    90t
    11t
    85t
    -89t
    -94t
    127t
    54t
    96t
    120t
    78t
    -25t
    -100t
    -119t
    48t
    44t
    -31t
    51t
    -128t
    78t
    -82t
    58t
    110t
    -122t
    87t
    0t
    -68t
    39t
    -95t
    76t
    63t
    -111t
    -49t
    -116t
    85t
    -95t
    121t
    69t
    103t
    -123t
    56t
    57t
    -69t
    76t
    -32t
    -22t
    -34t
    -115t
    -8t
    -44t
    -13t
    8t
    64t
    18t
    -43t
    66t
    -7t
    -75t
    93t
    65t
    10t
    -78t
    123t
    85t
    32t
    81t
    -5t
    -22t
    -17t
    89t
    -30t
    85t
    47t
    71t
    69t
    77t
    50t
    -26t
    34t
    -28t
    -47t
    0t
    -111t
    -8t
    25t
    99t
    -94t
    -55t
    40t
    -24t
    -2t
    87t
    -29t
    -127t
    67t
    91t
    -7t
    122t
    68t
    -70t
    122t
    61t
    40t
    48t
    -30t
    106t
    84t
    -90t
    60t
    -89t
    34t
    -123t
    49t
    109t
    -22t
    -94t
    76t
    73t
    -49t
    -117t
    -58t
    -56t
    123t
    45t
    36t
    -85t
    127t
    -100t
    -34t
    40t
    45t
    -21t
    -10t
    -80t
    -121t
    -63t
    0t
    80t
    28t
    -106t
    102t
    -111t
    30t
    75t
    -119t
    14t
    -38t
    -3t
    -96t
    118t
    68t
    -83t
    5t
    -22t
    37t
    -86t
    -29t
    1t
    -91t
    -24t
    64t
    75t
    -116t
    -120t
    -62t
    23t
    -34t
    92t
    -120t
    -78t
    -25t
    17t
    98t
    -97t
    -48t
    42t
    -113t
    -36t
    -38t
    -78t
    13t
    56t
    -50t
    -2t
    -81t
    71t
    -68t
    127t
    -125t
    43t
    36t
    -88t
    -28t
    -127t
    -1t
    -72t
    -109t
    104t
    55t
    -97t
    -92t
    -79t
    -41t
    -56t
    96t
    87t
    -87t
    110t
    74t
    -36t
    -37t
    125t
    28t
    56t
    -113t
    -105t
    18t
    -3t
    -57t
    84t
    87t
    -4t
    -57t
    -89t
    117t
    6t
    -119t
    108t
    80t
    12t
    -122t
    122t
    -26t
    14t
    -38t
    71t
    -30t
    -52t
    -11t
    0t
    -85t
    0t
    -89t
    124t
    -50t
    46t
    -22t
    28t
    114t
    -109t
    -57t
    -117t
    -5t
    -32t
    -27t
    122t
    0t
    -79t
    38t
    -58t
    -6t
    116t
    -55t
    -46t
    -44t
    -66t
    42t
    -69t
    -108t
    -13t
    -74t
    121t
    -44t
    22t
    66t
    29t
    -55t
    98t
    -92t
    59t
    -116t
    -39t
    -115t
    -58t
    89t
    -78t
    -102t
    34t
    -85t
    -87t
    -116t
    -85t
    -56t
    89t
    51t
    -84t
    91t
    -122t
    -13t
    -58t
    -95t
    83t
    75t
    -125t
    -106t
    48t
    -39t
    -6t
    4t
    4t
    -103t
    -32t
    -33t
    -51t
    -48t
    -76t
    121t
    -41t
    100t
    -26t
    97t
    -125t
    28t
    68t
    92t
    116t
    -34t
    4t
    75t
    91t
    -85t
    -76t
    -118t
    88t
    -14t
    -54t
    -12t
    77t
    -10t
    92t
    122t
    -100t
    89t
    70t
    102t
    -46t
    -62t
    -25t
    118t
    45t
    32t
    -11t
    78t
    16t
    -28t
    66t
    -64t
    44t
    -52t
    15t
    -4t
    -47t
    33t
    -91t
    114t
    114t
    -120t
    -66t
    -1t
    -88t
    -28t
    -15t
    96t
    -118t
    45t
    -86t
    -98t
    -107t
    8t
    -56t
    -88t
    -67t
    38t
    -115t
    -101t
    -109t
    -45t
    -120t
    -113t
    110t
    -109t
    1t
    -51t
    49t
    80t
    90t
    69t
    -118t
    113t
    -101t
    -30t
    -89t
    14t
    -87t
    -30t
    18t
    14t
    -37t
    -109t
    -121t
    35t
    -81t
    25t
    -113t
    -52t
    -95t
    -38t
    -106t
    -110t
    -14t
    -58t
    -38t
    -117t
    72t
    81t
    5t
    74t
    -81t
    -57t
    43t
    24t
    -121t
    112t
    -55t
    119t
    38t
    -26t
    92t
    5t
    -116t
    43t
    59t
    76t
    66t
    -92t
    19t
    87t
    -16t
    -116t
    -113t
    114t
    79t
    -56t
    -2t
    -86t
    -121t
    -77t
    -57t
    -12t
    36t
    -63t
    113t
    -78t
    -126t
    4t
    38t
    109t
    -89t
    99t
    -25t
    65t
    91t
    -21t
    25t
    24t
    -11t
    44t
    44t
    67t
    -109t
    -51t
    121t
    -27t
    100t
    -74t
    108t
    -120t
    -32t
    -20t
    -39t
    83t
    -106t
    96t
    100t
    91t
    -100t
    0t
    -85t
    -7t
    -64t
    -110t
    -16t
    -50t
    -43t
    61t
    84t
    16t
    26t
    64t
    -94t
    110t
    86t
    -119t
    78t
    98t
    -108t
    73t
    125t
    -88t
    -103t
    48t
    -42t
    89t
    53t
    -47t
    -32t
    70t
    -93t
    26t
    -53t
    -48t
    44t
    -99t
    -10t
    96t
    15t
    -23t
    64t
    -105t
    -108t
    76t
    -71t
    -27t
    68t
    32t
    2t
    9t
    115t
    98t
    -60t
    -102t
    122t
    -97t
    115t
    90t
    52t
    -37t
    -73t
    -4t
    71t
    113t
    2t
    64t
    -66t
    101t
    22t
    -41t
    108t
    20t
    98t
    89t
    -63t
    106t
    -69t
    -116t
    -44t
    -118t
    10t
    -52t
    -59t
    94t
    -13t
    13t
    -100t
    101t
    90t
    53t
    -80t
    -68t
    -94t
    -107t
    -67t
    -8t
    92t
    -51t
    32t
    68t
    118t
    -100t
    124t
    -43t
    -40t
    87t
    119t
    -65t
    25t
    -72t
    -97t
    -18t
    -53t
    12t
    -41t
    60t
    36t
    -68t
    -94t
    44t
    16t
    122t
    58t
    -114t
    70t
    97t
    -109t
    -79t
    -109t
    -8t
    2t
    80t
    -17t
    -16t
    -114t
    -84t
    94t
    34t
    21t
    106t
    -18t
    110t
    -78t
    -70t
    -123t
    -64t
    -51t
    -44t
    56t
    -2t
    113t
    9t
    -16t
    15t
    76t
    -66t
    43t
    117t
    47t
    -38t
    33t
    -84t
    -4t
    6t
    -30t
    -78t
    -89t
    -30t
    33t
    -36t
    25t
    112t
    -52t
    106t
    -51t
    54t
    -58t
    -126t
    -75t
    1t
    -5t
    -23t
    -29t
    98t
    -121t
    -111t
    113t
    -106t
    -105t
    9t
    70t
    34t
    -115t
    31t
    105t
    -106t
    -109t
    70t
    -25t
    20t
    118t
    -125t
    112t
    23t
    124t
    27t
    -83t
    44t
    121t
    42t
    32t
    -45t
    12t
    -3t
    1t
    -19t
    53t
    5t
    -84t
    31t
    89t
    -58t
    33t
    56t
    31t
    20t
    35t
    85t
    -46t
    -91t
    12t
    64t
    124t
    88t
    -71t
    -98t
    96t
    -82t
    54t
    -123t
    -24t
    -107t
    66t
    29t
    -77t
    -111t
    42t
    65t
    -67t
    22t
    110t
    -41t
    3t
    -70t
    -101t
    99t
    24t
    -126t
    -26t
    46t
    31t
    70t
    -86t
    76t
    -60t
    -96t
    37t
    -44t
    68t
    27t
    -1t
    30t
    100t
    30t
    -30t
    -62t
    -127t
    12t
    58t
    -112t
    39t
    -50t
    42t
    115t
    -28t
    13t
    -47t
    -56t
    87t
    -112t
    -69t
    -122t
    -100t
    -88t
    86t
    55t
    30t
    -22t
    44t
    37t
    87t
    -38t
    -99t
    118t
    -55t
    97t
    118t
    116t
    -51t
    -11t
    -15t
    -108t
    -30t
    43t
    39t
    68t
    -99t
    87t
    -103t
    22t
    37t
    25t
    -70t
    91t
    -100t
    -18t
    -93t
    -25t
    103t
    -123t
    91t
    -67t
    102t
    -86t
    -3t
    110t
    32t
    -55t
    -40t
    61t
    3t
    -79t
    113t
    69t
    -63t
    -92t
    125t
    -56t
    -128t
    74t
    95t
    -22t
    -108t
    124t
    -49t
    -49t
    -92t
    -33t
    66t
    -7t
    12t
    -46t
    87t
    -62t
    -83t
    6t
    51t
    45t
    -2t
    -91t
    -43t
    -100t
    -67t
    0t
    -14t
    -74t
    -98t
    -118t
    -60t
    2t
    71t
    5t
    -76t
    -67t
    -55t
    114t
    -40t
    113t
    -46t
    -60t
    69t
    -46t
    -120t
    -9t
    95t
    82t
    -99t
    106t
    44t
    30t
    101t
    115t
    90t
    -15t
    22t
    -53t
    -81t
    -126t
    -127t
    112t
    114t
    43t
    110t
    53t
    78t
    -54t
    -39t
    -1t
    68t
    -83t
    76t
    -30t
    11t
    24t
    -35t
    10t
    105t
    -1t
    -111t
    101t
    41t
    -1t
    -87t
    -4t
    -33t
    25t
    -12t
    -52t
    100t
    21t
    -17t
    -53t
    -57t
    41t
    93t
    -64t
    1t
    110t
    8t
    118t
    48t
    -125t
    -20t
    112t
    44t
    105t
    -23t
    -30t
    97t
    -103t
    -105t
    110t
    12t
    -86t
    -61t
    -23t
    -115t
    50t
    -126t
    -42t
    -18t
    -21t
    127t
    91t
    -46t
    50t
    48t
    45t
    -66t
    105t
    37t
    26t
    82t
    -26t
    27t
    -87t
    -120t
    -69t
    -28t
    -63t
    -85t
    -107t
    -53t
    120t
    -39t
    -6t
    95t
    24t
    -42t
    -17t
    -1t
    48t
    -100t
    6t
    77t
    121t
    -121t
    -117t
    71t
    -34t
    -11t
    -95t
    -128t
    -48t
    30t
    13t
    -15t
    -100t
    68t
    13t
    -53t
    -15t
    97t
    -21t
    -83t
    72t
    6t
    -10t
    -39t
    120t
    26t
    -121t
    62t
    6t
    95t
    -117t
    120t
    -101t
    -4t
    -59t
    74t
    -111t
    127t
    -71t
    -44t
    4t
    118t
    -86t
    -82t
    17t
    64t
    13t
    60t
    -73t
    111t
    45t
    61t
    21t
    -117t
    -102t
    -88t
    101t
    -52t
    116t
    23t
    -39t
    39t
    33t
    70t
    46t
    101t
    34t
    -12t
    33t
    -51t
    93t
    119t
    94t
    85t
    -38t
    71t
    -54t
    25t
    -111t
    117t
    -56t
    -9t
    -15t
    77t
    108t
    77t
    39t
    -102t
    113t
    43t
    71t
    -75t
    -34t
    61t
    -109t
    -20t
    -90t
    -122t
    76t
    6t
    5t
    98t
    36t
    25t
    -113t
    117t
    115t
    -62t
    -68t
    30t
    27t
    -79t
    -88t
    100t
    94t
    66t
    -54t
    -22t
    -105t
    -121t
    -27t
    -62t
    -67t
    -19t
    -63t
    28t
    -47t
    75t
    -56t
    34t
    -101t
    -63t
    61t
    -76t
    -100t
    -117t
    46t
    -119t
    -16t
    -35t
    67t
    -104t
    -91t
    32t
    -45t
    117t
    39t
    -46t
    -81t
    8t
    -121t
    114t
    4t
    -4t
    60t
    -84t
    -100t
    -89t
    97t
    89t
    -31t
    53t
    48t
    38t
    -7t
    111t
    -110t
    28t
    -13t
    -104t
    -124t
    2t
    9t
    122t
    6t
    -49t
    13t
    19t
    -72t
    16t
    -30t
    -115t
    -31t
    -111t
    -127t
    6t
    55t
    -87t
    -98t
    84t
    26t
    6t
    -96t
    -91t
    -128t
    -72t
    35t
    10t
    12t
    -16t
    -91t
    47t
    -8t
    -70t
    123t
    6t
    -62t
    96t
    -84t
    -80t
    45t
    13t
    9t
    -95t
    -40t
    46t
    62t
    -7t
    -65t
    99t
    -89t
    -78t
    45t
    -109t
    101t
    57t
    -80t
    80t
    67t
    -75t
    11t
    -69t
    72t
    -72t
    -14t
    111t
    -55t
    -22t
    -117t
    -82t
    63t
    -124t
    -14t
    116t
    53t
    92t
    -74t
    41t
    35t
    -4t
    79t
    120t
    -43t
    -81t
    -64t
    76t
    23t
    92t
    62t
    -28t
    -47t
    49t
    63t
    -78t
    106t
    26t
    -49t
    127t
    -83t
    69t
    -105t
    -112t
    40t
    -75t
    71t
    -100t
    -119t
    6t
    -70t
    -61t
    -115t
    -35t
    19t
    -75t
    33t
    71t
    -19t
    75t
    -20t
    100t
    57t
    -11t
    87t
    -127t
    -8t
    -117t
    97t
    12t
    27t
    79t
    -104t
    -107t
    -118t
    -106t
    -92t
    22t
    85t
    105t
    -86t
    -48t
    103t
    -23t
    -120t
    108t
    -74t
    -83t
    47t
    -75t
    100t
    -117t
    72t
    -68t
    20t
    93t
    -28t
    96t
    18t
    -37t
    60t
    -95t
    9t
    93t
    102t
    -103t
    26t
    -51t
    -43t
    -91t
    120t
    107t
    -113t
    -126t
    -52t
    79t
    -117t
    28t
    -81t
    96t
    -52t
    42t
    -39t
    42t
    68t
    -47t
    101t
    77t
    33t
    30t
    66t
    53t
    115t
    14t
    13t
    -98t
    9t
    -80t
    -70t
    -26t
    69t
    -12t
    72t
    87t
    58t
    43t
    33t
    -32t
    23t
    -107t
    -75t
    -115t
    114t
    -102t
    -120t
    20t
    -16t
    -77t
    -122t
    51t
    83t
    -43t
    -33t
    -17t
    91t
    30t
    -95t
    -57t
    -50t
    -114t
    94t
    101t
    -81t
    36t
    80t
    -76t
    -7t
    -116t
    106t
    12t
    15t
    97t
    -109t
    -56t
    -59t
    59t
    -23t
    40t
    31t
    31t
    -78t
    -45t
    38t
    -125t
    -116t
    58t
    118t
    -58t
    3t
    90t
    28t
    -43t
    35t
    -104t
    122t
    54t
    47t
    -74t
    -41t
    -11t
    -40t
    116t
    -113t
    100t
    63t
    41t
    -1t
    -113t
    57t
    -5t
    -69t
    60t
    -59t
    -125t
    26t
    29t
    -2t
    40t
    30t
    53t
    -10t
    37t
    82t
    -124t
    76t
    -71t
    -54t
    20t
    70t
    97t
    -119t
    96t
    -70t
    87t
    35t
    -25t
    23t
    45t
    22t
    -66t
    -119t
    80t
    104t
    110t
    -74t
    -103t
    -101t
    6t
    91t
    101t
    -57t
    -5t
    51t
    -107t
    7t
    -43t
    69t
    -56t
    -70t
    103t
    114t
    81t
    8t
    78t
    56t
    -123t
    -106t
    -76t
    -47t
    119t
    119t
    76t
    32t
    17t
    26t
    126t
    121t
    88t
    -3t
    111t
    87t
    -2t
    79t
    18t
    -80t
    94t
    36t
    68t
    92t
    -90t
    6t
    -15t
    4t
    121t
    -56t
    -128t
    -120t
    1t
    -92t
    -55t
    -57t
    -68t
    88t
    123t
    6t
    123t
    63t
    50t
    115t
    72t
    -33t
    106t
    -75t
    -119t
    76t
    -111t
    114t
    68t
    27t
    17t
    -87t
    -80t
    115t
    -36t
    115t
    -4t
    9t
    105t
    28t
    -119t
    -45t
    -66t
    36t
    1t
    -78t
    -83t
    -108t
    -11t
    -99t
    -32t
    -41t
    12t
    -89t
    -89t
    -128t
    -104t
    47t
    19t
    -111t
    -98t
    -39t
    -114t
    -55t
    58t
    106t
    -58t
    43t
    48t
    -34t
    34t
    -34t
    48t
    -83t
    -125t
    77t
    5t
    -1t
    -93t
    50t
    47t
    22t
    14t
    -41t
    -66t
    27t
    -107t
    -65t
    -43t
    -100t
    127t
    -99t
    43t
    -124t
    15t
    -25t
    -104t
    101t
    85t
    -44t
    117t
    -37t
    -117t
    -32t
    118t
    54t
    96t
    30t
    -84t
    -12t
    -84t
    -26t
    121t
    67t
    -27t
    110t
    -125t
    -83t
    -70t
    -83t
    3t
    -110t
    -104t
    -115t
    110t
    -16t
    -10t
    -18t
    -126t
    -124t
    104t
    -102t
    18t
    -13t
    32t
    78t
    91t
    -109t
    -12t
    9t
    -116t
    123t
    -60t
    104t
    -51t
    -13t
    -113t
    -1t
    26t
    -20t
    -11t
    -69t
    88t
    20t
    42t
    63t
    12t
    -23t
    -102t
    110t
    54t
    99t
    -60t
    -107t
    -92t
    59t
    77t
    3t
    -83t
    110t
    -46t
    53t
    56t
    -73t
    83t
    -6t
    -66t
    -2t
    80t
    -72t
    77t
    -38t
    -85t
    -109t
    -87t
    81t
    -42t
    -88t
    39t
    -58t
    124t
    -14t
    -63t
    30t
    44t
    68t
    32t
    -114t
    -25t
    -110t
    30t
    -28t
    121t
    43t
    33t
    68t
    80t
    -35t
    -35t
    -112t
    -115t
    -123t
    121t
    53t
    2t
    -52t
    62t
    111t
    -106t
    25t
    -93t
    1t
    -72t
    92t
    -103t
    -7t
    53t
    10t
    -62t
    50t
    119t
    -100t
    -94t
    -41t
    -46t
    79t
    -21t
    -53t
    39t
    67t
    -61t
    98t
    -19t
    -23t
    98t
    45t
    -4t
    5t
    -54t
    -62t
    -124t
    -34t
    -95t
    116t
    -65t
    51t
    4t
    20t
    100t
    -73t
    2t
    -49t
    127t
    -62t
    106t
    -26t
    -108t
    97t
    54t
    -4t
    122t
    -12t
    -59t
    -89t
    93t
    61t
    -46t
    -127t
    18t
    32t
    -79t
    27t
    -57t
    -34t
    -57t
    43t
    0t
    61t
    -77t
    1t
    3t
    -93t
    -54t
    -104t
    29t
    -113t
    104t
    -17t
    49t
    22t
    22t
    -7t
    -127t
    64t
    63t
    36t
    34t
    -71t
    -117t
    118t
    97t
    -77t
    -23t
    -66t
    -13t
    -82t
    101t
    18t
    25t
    -76t
    -122t
    -74t
    -52t
    -17t
    52t
    81t
    -69t
    -3t
    125t
    15t
    24t
    -99t
    -65t
    91t
    69t
    84t
    94t
    -64t
    -31t
    -31t
    -57t
    59t
    -9t
    66t
    106t
    117t
    64t
    -54t
    -90t
    -5t
    64t
    46t
    -50t
    -109t
    111t
    -97t
    14t
    -52t
    47t
    -1t
    -7t
    88t
    -25t
    21t
    -54t
    22t
    75t
    -107t
    64t
    -6t
    -76t
    -45t
    50t
    47t
    77t
    12t
    100t
    31t
    110t
    -121t
    -24t
    -79t
    29t
    87t
    -77t
    98t
    -3t
    55t
    -99t
    -108t
    118t
    -27t
    -1t
    125t
    112t
    -22t
    -36t
    72t
    91t
    100t
    57t
    97t
    -68t
    112t
    62t
    -86t
    -8t
    -26t
    33t
    40t
    -107t
    22t
    22t
    118t
    1t
    -6t
    -58t
    54t
    -3t
    -14t
    -83t
    112t
    85t
    46t
    69t
    67t
    -65t
    65t
    -119t
    111t
    -34t
    -16t
    -128t
    59t
    -44t
    -28t
    -99t
    126t
    -17t
    -88t
    67t
    -103t
    -109t
    -114t
    17t
    -62t
    36t
    -34t
    41t
    49t
    103t
    82t
    73t
    -76t
    -47t
    61t
    0t
    78t
    -45t
    -110t
    27t
    -120t
    88t
    -119t
    9t
    -44t
    68t
    110t
    1t
    -88t
    95t
    56t
    86t
    -19t
    114t
    -112t
    -44t
    -65t
    -2t
    42t
    -3t
    -41t
    -72t
    -57t
    80t
    -9t
    -19t
    11t
    -67t
    23t
    -10t
    20t
    72t
    -56t
    -57t
    -72t
    -114t
    57t
    88t
    98t
    -52t
    43t
    -59t
    5t
    -75t
    -101t
    -116t
    1t
    -45t
    -1t
    -56t
    11t
    -67t
    1t
    24t
    93t
    -98t
    -3t
    55t
    119t
    105t
    82t
    99t
    45t
    23t
    43t
    1t
    24t
    -50t
    103t
    -22t
    33t
    76t
    44t
    98t
    62t
    71t
    66t
    -72t
    -80t
    -7t
    53t
    51t
    -1t
    -39t
    -123t
    -23t
    -100t
    -29t
    -30t
    -88t
    86t
    96t
    -17t
    -9t
    -126t
    64t
    -44t
    79t
    63t
    -89t
    115t
    81t
    120t
    109t
    71t
    -43t
    16t
    8t
    10t
    -87t
    61t
    -124t
    -102t
    114t
    -59t
    49t
    -25t
    11t
    -112t
    -106t
    -11t
    107t
    26t
    111t
    77t
    -72t
    -47t
    127t
    -98t
    -49t
    -123t
    76t
    120t
    -17t
    118t
    -124t
    -98t
    -117t
    -32t
    45t
    35t
    78t
    46t
    27t
    -50t
    -42t
    -68t
    -43t
    8t
    -66t
    56t
    42t
    -20t
    60t
    52t
    76t
    35t
    85t
    75t
    -96t
    47t
    18t
    55t
    101t
    9t
    89t
    -126t
    66t
    11t
    98t
    28t
    -61t
    -107t
    120t
    -74t
    80t
    126t
    87t
    -4t
    -60t
    -97t
    -84t
    -13t
    -119t
    -52t
    119t
    85t
    96t
    47t
    -50t
    51t
    86t
    -35t
    96t
    8t
    6t
    91t
    1t
    -13t
    45t
    -94t
    -59t
    -98t
    69t
    -123t
    52t
    47t
    70t
    100t
    -87t
    -46t
    114t
    -107t
    42t
    118t
    22t
    65t
    102t
    28t
    0t
    99t
    -1t
    36t
    -95t
    -28t
    -76t
    127t
    -123t
    -67t
    69t
    -92t
    4t
    10t
    63t
    84t
    116t
    101t
    61t
    86t
    -37t
    106t
    45t
    110t
    63t
    -32t
    -12t
    -41t
    14t
    111t
    57t
    -116t
    -64t
    91t
    104t
    105t
    -71t
    -77t
    -105t
    85t
    -65t
    93t
    -113t
    80t
    -78t
    -113t
    16t
    109t
    14t
    44t
    59t
    -65t
    -41t
    125t
    -82t
    -51t
    -47t
    35t
    81t
    73t
    120t
    -44t
    78t
    -62t
    88t
    -93t
    25t
    -72t
    79t
    34t
    -79t
    -117t
    96t
    80t
    -108t
    1t
    8t
    77t
    -115t
    -61t
    -26t
    3t
    64t
    -30t
    93t
    -5t
    94t
    -88t
    124t
    47t
    25t
    -55t
    112t
    -112t
    -8t
    28t
    -83t
    -50t
    -109t
    27t
    -44t
    -128t
    -28t
    -120t
    78t
    -6t
    -111t
    9t
    29t
    -8t
    74t
    65t
    -78t
    32t
    58t
    -108t
    43t
    90t
    -107t
    -72t
    124t
    -117t
    -55t
    121t
    81t
    115t
    -95t
    -121t
    2t
    50t
    -11t
    -68t
    -17t
    79t
    -53t
    66t
    104t
    16t
    127t
    -90t
    77t
    69t
    -52t
    55t
    36t
    40t
    -25t
    85t
    32t
    86t
    -39t
    101t
    84t
    -72t
    92t
    24t
    -71t
    -59t
    11t
    103t
    -72t
    -123t
    100t
    33t
    -123t
    -20t
    48t
    -44t
    -113t
    -77t
    -104t
    -18t
    101t
    -93t
    -45t
    15t
    58t
    -19t
    -91t
    47t
    27t
    43t
    -4t
    27t
    -31t
    85t
    -65t
    -85t
    50t
    37t
    -24t
    -100t
    74t
    23t
    1t
    -28t
    9t
    -61t
    -20t
    22t
    99t
    34t
    93t
    124t
    -124t
    93t
    60t
    35t
    -95t
    -94t
    2t
    -56t
    -22t
    -71t
    14t
    -94t
    63t
    -42t
    66t
    30t
    -16t
    -32t
    -125t
    -73t
    79t
    39t
    68t
    55t
    16t
    4t
    110t
    -5t
    124t
    -1t
    20t
    -107t
    -98t
    -28t
    97t
    -127t
    -96t
    85t
    -106t
    -96t
    -108t
    -45t
    110t
    113t
    28t
    67t
    -26t
    -117t
    49t
    -38t
    1t
    2t
    -102t
    -95t
    108t
    28t
    -21t
    115t
    -37t
    -49t
    -36t
    -93t
    102t
    -68t
    58t
    -74t
    115t
    -46t
    -117t
    0t
    9t
    -46t
    33t
    -28t
    -103t
    -25t
    115t
    -80t
    93t
    -37t
    -6t
    57t
    63t
    82t
    85t
    2t
    16t
    85t
    -26t
    -30t
    -67t
    -28t
    15t
    -49t
    -111t
    57t
    122t
    -63t
    55t
    84t
    -68t
    43t
    -14t
    -29t
    -44t
    59t
    -80t
    100t
    -15t
    -114t
    29t
    -100t
    -62t
    104t
    -97t
    81t
    119t
    -49t
    56t
    -31t
    -121t
    90t
    3t
    -128t
    -27t
    70t
    -102t
    -21t
    -102t
    78t
    -53t
    14t
    -117t
    -7t
    65t
    74t
    -66t
    21t
    -91t
    71t
    60t
    13t
    -66t
    -74t
    73t
    -64t
    18t
    -8t
    -124t
    -69t
    109t
    -118t
    -49t
    32t
    70t
    -11t
    -75t
    84t
    -10t
    -119t
    -97t
    114t
    28t
    45t
    -14t
    61t
    2t
    -127t
    -32t
    39t
    27t
    110t
    72t
    49t
    -65t
    81t
    -46t
    -107t
    55t
    -119t
    43t
    124t
    2t
    8t
    56t
    121t
    47t
    103t
    -10t
    90t
    -109t
    -55t
    113t
    12t
    3t
    56t
    36t
    112t
    -93t
    83t
    79t
    -16t
    -112t
    -46t
    83t
    52t
    126t
    106t
    109t
    -45t
    103t
    -95t
    21t
    -13t
    -125t
    52t
    -44t
    -100t
    -97t
    82t
    26t
    79t
    45t
    124t
    84t
    -78t
    -104t
    43t
    61t
    77t
    47t
    57t
    -53t
    -99t
    -70t
    67t
    51t
    34t
    96t
    89t
    -74t
    8t
    27t
    -124t
    3t
    98t
    86t
    -56t
    -83t
    24t
    -18t
    -68t
    14t
    14t
    -79t
    -74t
    -114t
    72t
    109t
    83t
    -128t
    44t
    -91t
    31t
    -113t
    -3t
    113t
    -10t
    91t
    -127t
    74t
    98t
    125t
    96t
    10t
    -58t
    -7t
    -25t
    -92t
    -58t
    88t
    70t
    96t
    44t
    87t
    63t
    67t
    -26t
    117t
    -57t
    125t
    110t
    15t
    -121t
    -64t
    25t
    -49t
    85t
    -59t
    53t
    -84t
    116t
    17t
    83t
    -88t
    -41t
    21t
    -22t
    97t
    8t
    -7t
    82t
    -45t
    -112t
    -104t
    5t
    -41t
    39t
    -53t
    -54t
    29t
    -51t
    -79t
    -78t
    1t
    61t
    -18t
    39t
    92t
    116t
    30t
    -116t
    -103t
    -19t
    108t
    1t
    -59t
    101t
    48t
    65t
    -37t
    31t
    47t
    115t
    -17t
    89t
    -48t
    117t
    -18t
    -4t
    86t
    -7t
    -111t
    117t
    79t
    -44t
    -128t
    42t
    -27t
    -40t
    100t
    10t
    14t
    -92t
    66t
    -67t
    51t
    -88t
    -43t
    -80t
    64t
    -19t
    -81t
    -78t
    -46t
    67t
    -64t
    -82t
    90t
    -3t
    74t
    -15t
    -5t
    -54t
    -128t
    -95t
    -8t
    127t
    58t
    -6t
    -128t
    7t
    -102t
    10t
    -124t
    57t
    -81t
    -116t
    50t
    -116t
    -52t
    -7t
    -106t
    72t
    106t
    -97t
    -23t
    -54t
    -88t
    0t
    -104t
    -60t
    -43t
    82t
    -21t
    -10t
    -74t
    -76t
    -52t
    74t
    95t
    52t
    46t
    4t
    -108t
    -73t
    -127t
    -127t
    -57t
    -52t
    -90t
    63t
    115t
    59t
    86t
    30t
    -120t
    -101t
    -124t
    71t
    -44t
    -118t
    -69t
    -4t
    59t
    5t
    73t
    -109t
    -90t
    -127t
    -45t
    -88t
    -47t
    -75t
    -41t
    48t
    -80t
    35t
    -88t
    71t
    74t
    32t
    81t
    -30t
    30t
    -103t
    -44t
    50t
    3t
    -25t
    90t
    107t
    68t
    -111t
    -98t
    76t
    45t
    -40t
    65t
    81t
    29t
    -75t
    -3t
    18t
    39t
    86t
    -88t
    111t
    42t
    77t
    4t
    -30t
    -117t
    19t
    -41t
    -10t
    -40t
    -65t
    -15t
    -40t
    -2t
    -7t
    -104t
    -92t
    -36t
    -104t
    114t
    115t
    14t
    -116t
    -49t
    -44t
    88t
    20t
    114t
    17t
    48t
    72t
    -74t
    3t
    -37t
    101t
    -49t
    -108t
    7t
    90t
    119t
    72t
    -68t
    34t
    31t
    -55t
    -14t
    -9t
    -21t
    121t
    -101t
    117t
    -50t
    4t
    106t
    -117t
    -112t
    -93t
    -41t
    88t
    30t
    89t
    9t
    -77t
    -36t
    -36t
    -92t
    -40t
    -58t
    125t
    66t
    23t
    -61t
    -114t
    -69t
    -105t
    17t
    111t
    -58t
    111t
    73t
    -86t
    -13t
    107t
    -58t
    -79t
    -91t
    125t
    -120t
    -124t
    -54t
    112t
    -99t
    38t
    -109t
    30t
    -34t
    -126t
    -121t
    -85t
    105t
    -37t
    -115t
    17t
    -99t
    -58t
    -47t
    -49t
    -48t
    121t
    56t
    92t
    -79t
    90t
    110t
    -20t
    74t
    -119t
    71t
    -59t
    -81t
    103t
    119t
    -18t
    66t
    117t
    90t
    -92t
    -5t
    -4t
    110t
    -54t
    -104t
    -111t
    -85t
    -1t
    54t
    -102t
    42t
    -107t
    61t
    60t
    48t
    101t
    -28t
    39t
    -76t
    51t
    53t
    111t
    112t
    -7t
    -89t
    -81t
    7t
    -35t
    122t
    -24t
    10t
    -124t
    66t
    -38t
    117t
    76t
    -45t
    -126t
    3t
    -68t
    121t
    -70t
    91t
    41t
    -25t
    61t
    -62t
    -82t
    -47t
    -5t
    -95t
    47t
    -52t
    -80t
    -15t
    56t
    -112t
    -76t
    -82t
    72t
    -13t
    80t
    -49t
    -99t
    -69t
    -98t
    -36t
    -4t
    94t
    78t
    -60t
    74t
    -58t
    54t
    -92t
    -101t
    34t
    114t
    -66t
    77t
    43t
    62t
    18t
    28t
    57t
    -81t
    -57t
    59t
    12t
    -26t
    -20t
    -30t
    5t
    10t
    122t
    87t
    107t
    21t
    -102t
    92t
    -105t
    89t
    12t
    19t
    -28t
    -51t
    -127t
    -71t
    37t
    -110t
    -18t
    112t
    -90t
    50t
    -32t
    16t
    103t
    -3t
    -19t
    -46t
    31t
    2t
    73t
    -86t
    0t
    -32t
    11t
    -62t
    116t
    121t
    -13t
    -126t
    54t
    96t
    -74t
    57t
    -36t
    96t
    50t
    -103t
    -33t
    -23t
    44t
    115t
    -71t
    60t
    -84t
    5t
    -28t
    33t
    -46t
    4t
    -70t
    41t
    102t
    112t
    -115t
    -66t
    107t
    116t
    76t
    91t
    -92t
    92t
    15t
    -62t
    -55t
    -125t
    -75t
    -119t
    63t
    115t
    -60t
    -124t
    8t
    -6t
    -100t
    58t
    17t
    9t
    -118t
    -87t
    -104t
    102t
    32t
    91t
    118t
    117t
    110t
    98t
    52t
    44t
    -44t
    -111t
    121t
    -81t
    56t
    -57t
    26t
    53t
    -20t
    -10t
    125t
    -58t
    -85t
    -46t
    -113t
    73t
    -108t
    127t
    17t
    6t
    -6t
    -54t
    28t
    86t
    90t
    46t
    -18t
    6t
    -123t
    25t
    -80t
    -89t
    18t
    79t
    -94t
    55t
    -20t
    -98t
    32t
    -81t
    -59t
    -69t
    117t
    -54t
    -124t
    32t
    -62t
    -30t
    24t
    -68t
    109t
    -8t
    -72t
    65t
    -103t
    78t
    -64t
    127t
    -2t
    -91t
    -118t
    66t
    7t
    -83t
    16t
    66t
    83t
    -90t
    22t
    -44t
    -15t
    0t
    11t
    -25t
    -58t
    -106t
    -50t
    54t
    -120t
    40t
    -85t
    -76t
    -51t
    102t
    -17t
    -3t
    10t
    -34t
    62t
    -28t
    4t
    -46t
    -79t
    -36t
    -88t
    -63t
    108t
    -53t
    102t
    -63t
    -46t
    6t
    -79t
    8t
    -121t
    121t
    -91t
    77t
    -87t
    31t
    -71t
    55t
    -106t
    -125t
    -103t
    -61t
    -116t
    56t
    -74t
    51t
    106t
    52t
    8t
    82t
    68t
    67t
    -100t
    -106t
    -97t
    -76t
    -63t
    -43t
    -121t
    80t
    3t
    -119t
    55t
    -123t
    -38t
    76t
    41t
    -11t
    -93t
    -27t
    -36t
    -105t
    -110t
    51t
    71t
    -54t
    -40t
    -125t
    -35t
    117t
    12t
    -80t
    -34t
    -45t
    51t
    -31t
    -103t
    57t
    -115t
    5t
    -90t
    54t
    12t
    68t
    22t
    -45t
    -25t
    92t
    77t
    -101t
    43t
    -62t
    28t
    0t
    5t
    -111t
    -123t
    42t
    -55t
    91t
    108t
    -99t
    8t
    111t
    110t
    -89t
    67t
    60t
    -51t
    -3t
    -90t
    116t
    28t
    33t
    71t
    -82t
    16t
    -67t
    -118t
    -121t
    124t
    64t
    103t
    52t
    -115t
    57t
    4t
    14t
    -51t
    57t
    -19t
    -49t
    -42t
    68t
    -95t
    124t
    79t
    -15t
    -87t
    55t
    97t
    -122t
    -49t
    -31t
    86t
    94t
    -55t
    -27t
    -90t
    89t
    -39t
    15t
    -73t
    11t
    -54t
    -127t
    42t
    68t
    57t
    -74t
    54t
    71t
    -53t
    -89t
    -107t
    -2t
    -126t
    -65t
    19t
    122t
    105t
    109t
    -84t
    -107t
    2t
    123t
    -39t
    85t
    34t
    -12t
    -8t
    -19t
    -42t
    75t
    55t
    98t
    -15t
    46t
    -31t
    -87t
    97t
    82t
    7t
    -125t
    69t
    95t
    31t
    101t
    17t
    -14t
    114t
    94t
    39t
    7t
    49t
    -73t
    -32t
    71t
    82t
    -2t
    -5t
    55t
    104t
    -35t
    12t
    49t
    2t
    -88t
    -96t
    -55t
    -80t
    -78t
    34t
    90t
    -62t
    116t
    70t
    -71t
    9t
    37t
    27t
    50t
    60t
    17t
    -73t
    -10t
    -111t
    -20t
    59t
    -72t
    111t
    -15t
    108t
    -124t
    -118t
    9t
    -17t
    69t
    -11t
    -21t
    49t
    47t
    -26t
    6t
    -75t
    118t
    10t
    40t
    23t
    3t
    -128t
    -105t
    97t
    -17t
    67t
    -6t
    -81t
    22t
    29t
    -52t
    -100t
    -99t
    -93t
    48t
    -66t
    88t
    -43t
    -100t
    79t
    36t
    -121t
    -42t
    4t
    8t
    44t
    107t
    82t
    -20t
    46t
    -77t
    -40t
    19t
    98t
    -109t
    55t
    -13t
    12t
    117t
    -27t
    -75t
    15t
    -72t
    -98t
    -48t
    -107t
    -108t
    -121t
    20t
    -96t
    107t
    -14t
    -3t
    -42t
    -37t
    -44t
    -85t
    126t
    12t
    -62t
    117t
    -100t
    -19t
    80t
    0t
    49t
    -55t
    -63t
    -43t
    -19t
    39t
    106t
    -1t
    112t
    -111t
    -37t
    -37t
    -83t
    -22t
    -99t
    -104t
    74t
    119t
    -94t
    25t
    117t
    52t
    -70t
    4t
    -106t
    -68t
    99t
    96t
    29t
    -124t
    119t
    -13t
    -117t
    -113t
    87t
    -29t
    -28t
    -118t
    98t
    -31t
    73t
    -14t
    -79t
    48t
    -115t
    -51t
    95t
    -3t
    53t
    -25t
    -54t
    32t
    -1t
    63t
    8t
    -119t
    17t
    2t
    -116t
    -83t
    -107t
    -18t
    75t
    -54t
    123t
    6t
    -123t
    90t
    -38t
    -35t
    -12t
    -2t
    -128t
    8t
    -91t
    -128t
    116t
    55t
    111t
    -17t
    37t
    89t
    4t
    3t
    -116t
    -21t
    -124t
    -69t
    -42t
    120t
    22t
    122t
    30t
    -45t
    17t
    -107t
    109t
    20t
    35t
    -39t
    17t
    -67t
    -59t
    123t
    -103t
    -52t
    -43t
    -36t
    -33t
    68t
    -126t
    123t
    -115t
    -124t
    39t
    0t
    13t
    109t
    -126t
    -24t
    110t
    -39t
    -41t
    124t
    124t
    103t
    -36t
    83t
    111t
    -14t
    -20t
    6t
    -120t
    -22t
    6t
    90t
    6t
    114t
    20t
    33t
    116t
    -75t
    19t
    35t
    63t
    127t
    61t
    -104t
    -49t
    -128t
    58t
    9t
    -28t
    103t
    87t
    121t
    105t
    -33t
    -3t
    -103t
    85t
    50t
    -90t
    -120t
    -16t
    122t
    -69t
    2t
    -114t
    -32t
    -47t
    76t
    14t
    105t
    75t
    -43t
    82t
    97t
    96t
    113t
    -86t
    -1t
    -121t
    -81t
    34t
    24t
    121t
    -115t
    31t
    -12t
    93t
    111t
    18t
    77t
    -29t
    35t
    35t
    127t
    41t
    -8t
    -93t
    -50t
    46t
    -63t
    28t
    -119t
    -124t
    -24t
    11t
    -38t
    5t
    115t
    -1t
    38t
    72t
    -99t
    30t
    38t
    -2t
    -65t
    29t
    -68t
    10t
    -68t
    67t
    24t
    -112t
    124t
    -102t
    36t
    18t
    61t
    89t
    9t
    115t
    34t
    -19t
    30t
    -69t
    14t
    103t
    50t
    -11t
    37t
    47t
    -107t
    75t
    -29t
    -54t
    107t
    -112t
    10t
    122t
    105t
    -118t
    102t
    86t
    97t
    101t
    -52t
    112t
    115t
    127t
    -48t
    62t
    70t
    -12t
    -117t
    10t
    -91t
    -109t
    -124t
    17t
    -112t
    32t
    97t
    -87t
    61t
    110t
    31t
    53t
    -9t
    45t
    -48t
    -72t
    -26t
    -86t
    -120t
    -10t
    -124t
    6t
    -122t
    -81t
    -40t
    41t
    94t
    71t
    -42t
    -124t
    -58t
    124t
    115t
    16t
    70t
    68t
    60t
    -39t
    106t
    -46t
    -98t
    43t
    12t
    80t
    77t
    61t
    35t
    -122t
    52t
    -48t
    -32t
    64t
    -54t
    54t
    48t
    -84t
    -53t
    50t
    34t
    -2t
    -32t
    107t
    -112t
    97t
    95t
    -34t
    79t
    20t
    -61t
    -120t
    -117t
    93t
    -14t
    109t
    -90t
    -71t
    -66t
    90t
    -107t
    55t
    -76t
    118t
    -114t
    -55t
    39t
    39t
    -88t
    37t
    95t
    29t
    92t
    -68t
    -10t
    -123t
    -21t
    49t
    87t
    -61t
    -18t
    23t
    -66t
    -34t
    101t
    -3t
    -102t
    35t
    -34t
    -8t
    39t
    -88t
    69t
    -121t
    -118t
    72t
    -81t
    -94t
    111t
    -120t
    -47t
    81t
    -62t
    55t
    -19t
    -9t
    126t
    -36t
    -29t
    -85t
    74t
    -35t
    -98t
    120t
    -23t
    26t
    -35t
    -95t
    -9t
    -74t
    -116t
    -45t
    68t
    -54t
    111t
    98t
    -116t
    -79t
    8t
    80t
    -100t
    -72t
    -109t
    80t
    109t
    50t
    -71t
    -96t
    -68t
    15t
    114t
    5t
    124t
    -77t
    72t
    -125t
    -103t
    118t
    -91t
    70t
    -21t
    7t
    -44t
    -74t
    -67t
    -8t
    71t
    63t
    67t
    113t
    -72t
    -2t
    -78t
    -93t
    -15t
    123t
    -3t
    68t
    -27t
    -41t
    82t
    -124t
    98t
    -22t
    97t
    20t
    -27t
    -22t
    89t
    59t
    50t
    -6t
    -37t
    9t
    -2t
    -1t
    19t
    -113t
    -126t
    -30t
    -31t
    -104t
    -33t
    20t
    -85t
    -32t
    -20t
    18t
    3t
    0t
    -4t
    50t
    -52t
    -95t
    42t
    -128t
    13t
    46t
    -93t
    113t
    -118t
    -27t
    125t
    -94t
    -95t
    106t
    -37t
    121t
    19t
    93t
    116t
    118t
    -104t
    109t
    -92t
    -93t
    -102t
    -113t
    106t
    15t
    -102t
    44t
    -46t
    -31t
    123t
    10t
    23t
    124t
    67t
    -80t
    31t
    60t
    -35t
    -29t
    21t
    -105t
    28t
    -62t
    58t
    72t
    30t
    -91t
    58t
    78t
    78t
    -22t
    123t
    -47t
    94t
    15t
    -70t
    -75t
    92t
    72t
    -62t
    -108t
    -76t
    0t
    -93t
    -15t
    -103t
    11t
    -37t
    32t
    -76t
    53t
    -89t
    3t
    -6t
    111t
    1t
    -62t
    41t
    88t
    29t
    1t
    -66t
    -28t
    127t
    -103t
    91t
    113t
    -8t
    -88t
    56t
    85t
    -105t
    -31t
    -4t
    -50t
    43t
    117t
    86t
    -96t
    123t
    -42t
    115t
    64t
    -53t
    -98t
    -16t
    -79t
    126t
    42t
    114t
    -98t
    -104t
    -124t
    -20t
    97t
    8t
    -56t
    29t
    97t
    -78t
    20t
    -92t
    73t
    -100t
    118t
    -109t
    -57t
    60t
    -54t
    -84t
    -68t
    -10t
    -69t
    -128t
    -6t
    -10t
    41t
    -78t
    -37t
    60t
    -107t
    -101t
    -36t
    13t
    82t
    -97t
    39t
    -59t
    125t
    106t
    59t
    -50t
    -80t
    88t
    -43t
    29t
    67t
    34t
    21t
    64t
    12t
    41t
    -105t
    11t
    116t
    -23t
    35t
    0t
    -40t
    -74t
    71t
    15t
    38t
    72t
    -10t
    -14t
    57t
    49t
    47t
    119t
    104t
    -84t
    -121t
    -24t
    77t
    -6t
    47t
    101t
    -125t
    64t
    46t
    82t
    84t
    -37t
    -85t
    96t
    -100t
    -32t
    90t
    -73t
    -33t
    -10t
    90t
    -21t
    -84t
    98t
    -82t
    -24t
    -102t
    72t
    92t
    29t
    58t
    -89t
    1t
    -20t
    -38t
    122t
    29t
    95t
    60t
    -74t
    37t
    -126t
    68t
    89t
    -58t
    -110t
    45t
    -73t
    74t
    98t
    110t
    -99t
    31t
    -58t
    49t
    42t
    -36t
    44t
    78t
    -82t
    -112t
    20t
    72t
    -67t
    -57t
    -120t
    41t
    -38t
    107t
    62t
    16t
    -27t
    -80t
    -86t
    -23t
    -14t
    -99t
    20t
    86t
    -95t
    68t
    98t
    111t
    65t
    -67t
    -21t
    -48t
    -96t
    -18t
    -106t
    127t
    125t
    -6t
    -36t
    -114t
    -60t
    97t
    50t
    -112t
    88t
    -73t
    103t
    -58t
    -62t
    -100t
    86t
    -67t
    -87t
    46t
    -62t
    101t
    48t
    -58t
    -113t
    54t
    -92t
    -122t
    80t
    115t
    96t
    111t
    0t
    -85t
    -7t
    12t
    99t
    -2t
    61t
    47t
    -16t
    49t
    -63t
    -35t
    -68t
    -11t
    -55t
    107t
    -17t
    -32t
    0t
    -20t
    -117t
    -73t
    -103t
    18t
    -73t
    40t
    1t
    111t
    -117t
    -77t
    33t
    84t
    53t
    62t
    67t
    80t
    21t
    96t
    -125t
    78t
    -112t
    -20t
    101t
    28t
    6t
    59t
    121t
    40t
    -83t
    95t
    -80t
    -77t
    74t
    9t
    107t
    56t
    -103t
    127t
    104t
    53t
    104t
    28t
    17t
    79t
    -115t
    92t
    40t
    -84t
    -114t
    -104t
    -21t
    -10t
    -1t
    -75t
    80t
    115t
    65t
    23t
    100t
    126t
    79t
    -38t
    85t
    -44t
    81t
    -88t
    22t
    -90t
    36t
    84t
    8t
    33t
    48t
    -25t
    -16t
    -28t
    64t
    80t
    -94t
    -47t
    25t
    113t
    4t
    -28t
    72t
    16t
    -47t
    -75t
    -23t
    -44t
    0t
    89t
    -55t
    -36t
    37t
    53t
    -79t
    -19t
    53t
    118t
    -9t
    111t
    -68t
    -53t
    79t
    -118t
    14t
    -47t
    -9t
    80t
    -98t
    115t
    -107t
    6t
    105t
    -93t
    125t
    15t
    -74t
    84t
    74t
    115t
    -115t
    102t
    50t
    -123t
    9t
    -24t
    -17t
    -2t
    114t
    64t
    92t
    -67t
    -12t
    -50t
    -52t
    101t
    90t
    82t
    -98t
    76t
    38t
    -59t
    -115t
    23t
    51t
    -82t
    -53t
    8t
    -112t
    -107t
    -83t
    -14t
    -31t
    25t
    -65t
    -29t
    -78t
    -110t
    69t
    -35t
    -7t
    4t
    -92t
    -64t
    65t
    -39t
    -64t
    -78t
    75t
    69t
    -8t
    -66t
    -41t
    -67t
    -19t
    86t
    -91t
    3t
    -40t
    -1t
    -55t
    -77t
    49t
    -112t
    25t
    -102t
    93t
    -110t
    -62t
    -88t
    4t
    27t
    36t
    -102t
    -84t
    36t
    59t
    58t
    103t
    76t
    2t
    122t
    65t
    78t
    -86t
    104t
    -101t
    58t
    99t
    88t
    -79t
    80t
    -66t
    -115t
    -116t
    -48t
    51t
    -126t
    -35t
    -67t
    55t
    -59t
    114t
    112t
    -74t
    -66t
    -29t
    -74t
    38t
    -99t
    59t
    35t
    -61t
    13t
    40t
    39t
    -40t
    -106t
    -121t
    -106t
    28t
    -25t
    -28t
    -72t
    26t
    -85t
    23t
    15t
    102t
    90t
    -54t
    87t
    -75t
    109t
    -19t
    75t
    -127t
    51t
    126t
    63t
    -43t
    -10t
    48t
    -18t
    25t
    -71t
    -14t
    -80t
    21t
    94t
    -69t
    -31t
    116t
    55t
    -127t
    -33t
    -58t
    94t
    41t
    -68t
    -80t
    125t
    -125t
    -48t
    119t
    44t
    -100t
    -122t
    -105t
    -70t
    28t
    -50t
    -56t
    28t
    -119t
    58t
    -77t
    -87t
    -59t
    96t
    103t
    -64t
    96t
    24t
    0t
    -58t
    -12t
    122t
    108t
    -127t
    -6t
    -17t
    41t
    -32t
    -20t
    67t
    76t
    -46t
    -48t
    125t
    3t
    93t
    -76t
    -39t
    108t
    88t
    41t
    -5t
    34t
    -86t
    -39t
    -16t
    59t
    -45t
    27t
    -14t
    -91t
    54t
    -120t
    -56t
    72t
    -86t
    -76t
    -90t
    75t
    36t
    16t
    -89t
    36t
    -65t
    -44t
    3t
    67t
    -10t
    118t
    -44t
    17t
    30t
    -106t
    50t
    -35t
    -80t
    95t
    2t
    78t
    8t
    -44t
    82t
    -28t
    -82t
    46t
    -88t
    0t
    -22t
    -89t
    -7t
    73t
    101t
    98t
    -52t
    103t
    75t
    51t
    -106t
    126t
    52t
    104t
    -118t
    -56t
    -95t
    -24t
    -123t
    55t
    -127t
    -41t
    -51t
    -60t
    1t
    -10t
    23t
    -49t
    -126t
    -64t
    45t
    37t
    79t
    58t
    10t
    -39t
    83t
    -75t
    -62t
    -49t
    101t
    38t
    102t
    66t
    -109t
    100t
    110t
    49t
    58t
    -2t
    -38t
    106t
    25t
    -91t
    37t
    -56t
    -84t
    -104t
    -103t
    -37t
    25t
    46t
    124t
    6t
    -78t
    -55t
    67t
    -68t
    -15t
    -2t
    -61t
    20t
    -98t
    -102t
    89t
    -95t
    67t
    2t
    51t
    -90t
    -3t
    -11t
    59t
    81t
    13t
    -1t
    -83t
    -71t
    -121t
    -6t
    89t
    -82t
    12t
    -94t
    -27t
    -21t
    16t
    62t
    -118t
    -38t
    -68t
    -55t
    97t
    -37t
    53t
    -36t
    60t
    -104t
    -49t
    9t
    54t
    -49t
    65t
    -6t
    -12t
    -30t
    -65t
    -3t
    -27t
    16t
    121t
    -67t
    4t
    -122t
    58t
    76t
    -32t
    -68t
    85t
    65t
    -23t
    -73t
    -122t
    -19t
    -44t
    48t
    124t
    78t
    43t
    -43t
    4t
    20t
    -26t
    -118t
    -52t
    -25t
    117t
    24t
    37t
    99t
    101t
    49t
    100t
    -37t
    -98t
    58t
    108t
    -62t
    109t
    -111t
    100t
    12t
    -125t
    111t
    -65t
    -31t
    94t
    -19t
    -7t
    -102t
    44t
    119t
    47t
    33t
    -60t
    -6t
    -9t
    112t
    -27t
    -120t
    46t
    94t
    46t
    58t
    -17t
    -38t
    -105t
    -41t
    -6t
    24t
    -110t
    44t
    29t
    121t
    -30t
    37t
    -56t
    -107t
    -67t
    77t
    -3t
    75t
    -54t
    31t
    -124t
    -34t
    81t
    -60t
    108t
    56t
    32t
    17t
    -127t
    66t
    -72t
    -30t
    -56t
    -78t
    54t
    -13t
    46t
    -64t
    126t
    84t
    12t
    64t
    -37t
    28t
    -57t
    28t
    39t
    89t
    -72t
    -115t
    80t
    -4t
    20t
    -79t
    67t
    115t
    7t
    50t
    58t
    -113t
    -124t
    95t
    60t
    10t
    -1t
    -64t
    116t
    102t
    -69t
    -125t
    48t
    -25t
    -60t
    107t
    -106t
    -105t
    -81t
    -17t
    -117t
    114t
    31t
    47t
    -42t
    83t
    -26t
    90t
    14t
    64t
    -53t
    -115t
    83t
    -111t
    -1t
    84t
    98t
    -116t
    110t
    -85t
    47t
    -57t
    85t
    33t
    -69t
    -39t
    26t
    108t
    -32t
    -50t
    -127t
    67t
    -74t
    50t
    -93t
    -29t
    75t
    -108t
    80t
    -111t
    -77t
    -124t
    -1t
    30t
    93t
    -20t
    -89t
    31t
    -122t
    40t
    -69t
    -107t
    23t
    81t
    -103t
    35t
    -13t
    -26t
    44t
    12t
    74t
    52t
    -68t
    16t
    -77t
    4t
    89t
    -52t
    -85t
    40t
    120t
    69t
    38t
    -18t
    -80t
    -112t
    -24t
    -89t
    60t
    -14t
    33t
    118t
    70t
    -100t
    123t
    -116t
    113t
    -10t
    67t
    81t
    27t
    85t
    80t
    -124t
    -27t
    50t
    113t
    83t
    -113t
    -92t
    104t
    45t
    70t
    -4t
    -85t
    108t
    42t
    -46t
    -68t
    28t
    27t
    114t
    77t
    -18t
    35t
    -57t
    10t
    -111t
    84t
    97t
    23t
    67t
    53t
    -95t
    106t
    101t
    -106t
    65t
    -51t
    55t
    -44t
    101t
    -100t
    -62t
    114t
    121t
    -23t
    91t
    38t
    27t
    -22t
    118t
    -4t
    -12t
    -109t
    118t
    125t
    13t
    6t
    12t
    65t
    -43t
    38t
    -34t
    17t
    -23t
    -27t
    0t
    14t
    -43t
    117t
    76t
    65t
    78t
    -126t
    82t
    38t
    -119t
    -59t
    -35t
    32t
    86t
    -48t
    92t
    35t
    37t
    -20t
    -87t
    25t
    -42t
    -47t
    -15t
    89t
    19t
    68t
    69t
    58t
    8t
    125t
    -23t
    -10t
    -45t
    -118t
    -22t
    -38t
    85t
    -12t
    26t
    34t
    -42t
    93t
    97t
    -55t
    114t
    -2t
    -84t
    -42t
    -16t
    115t
    51t
    -81t
    -113t
    25t
    71t
    127t
    126t
    -96t
    -25t
    -71t
    -66t
    37t
    120t
    -57t
    33t
    -99t
    96t
    -108t
    -104t
    -114t
    30t
    98t
    -12t
    91t
    -89t
    -39t
    28t
    -103t
    89t
    -102t
    44t
    4t
    114t
    -98t
    57t
    52t
    110t
    -111t
    91t
    96t
    64t
    99t
    122t
    -117t
    -121t
    116t
    -80t
    55t
    103t
    63t
    85t
    55t
    -49t
    4t
    83t
    -86t
    35t
    -128t
    53t
    -88t
    6t
    -87t
    -22t
    110t
    -30t
    -12t
    -15t
    -6t
    109t
    -6t
    -79t
    104t
    -3t
    115t
    -107t
    -23t
    43t
    -70t
    89t
    94t
    8t
    -64t
    -59t
    61t
    58t
    -44t
    63t
    71t
    33t
    12t
    12t
    67t
    -2t
    11t
    -68t
    87t
    -68t
    96t
    -32t
    -48t
    -27t
    95t
    -34t
    95t
    -34t
    -44t
    -71t
    -94t
    -83t
    119t
    119t
    92t
    3t
    -72t
    -121t
    36t
    116t
    18t
    30t
    104t
    46t
    -37t
    14t
    -110t
    74t
    10t
    -29t
    -76t
    125t
    -25t
    -70t
    -114t
    31t
    -76t
    -121t
    -52t
    122t
    4t
    19t
    57t
    -120t
    -96t
    -99t
    127t
    -28t
    -104t
    13t
    60t
    -64t
    -18t
    101t
    -87t
    -48t
    61t
    29t
    79t
    56t
    46t
    53t
    -45t
    93t
    49t
    103t
    -113t
    16t
    57t
    113t
    -16t
    -125t
    69t
    -3t
    44t
    -110t
    64t
    -58t
    79t
    48t
    -88t
    -97t
    113t
    8t
    45t
    -37t
    -50t
    -70t
    46t
    -34t
    93t
    112t
    81t
    69t
    -47t
    -58t
    -93t
    -23t
    -102t
    86t
    7t
    9t
    106t
    -57t
    -100t
    -21t
    106t
    94t
    -121t
    94t
    73t
    109t
    39t
    -107t
    -116t
    69t
    -31t
    109t
    84t
    -86t
    -1t
    20t
    -29t
    19t
    119t
    -58t
    63t
    55t
    95t
    -121t
    12t
    103t
    -76t
    -106t
    111t
    94t
    44t
    100t
    -1t
    -69t
    96t
    -97t
    -94t
    11t
    -37t
    52t
    -118t
    -122t
    33t
    101t
    82t
    -33t
    -49t
    -99t
    105t
    -101t
    92t
    39t
    -58t
    94t
    93t
    -74t
    -108t
    -1t
    -112t
    -44t
    -28t
    -6t
    -127t
    65t
    98t
    -89t
    90t
    78t
    -26t
    119t
    19t
    -17t
    63t
    70t
    -122t
    -84t
    49t
    44t
    -115t
    -1t
    111t
    -8t
    92t
    -4t
    0t
    -61t
    -57t
    -66t
    49t
    94t
    -23t
    7t
    -77t
    -57t
    0t
    60t
    -74t
    95t
    34t
    4t
    105t
    -116t
    -108t
    -83t
    25t
    67t
    89t
    -102t
    -61t
    -56t
    -17t
    -23t
    -40t
    -11t
    8t
    14t
    -51t
    58t
    -59t
    79t
    58t
    118t
    117t
    -7t
    -44t
    103t
    18t
    40t
    -4t
    79t
    51t
    51t
    -63t
    110t
    127t
    -51t
    2t
    -76t
    75t
    88t
    -30t
    76t
    -94t
    53t
    -43t
    52t
    -68t
    -33t
    127t
    -48t
    64t
    -26t
    -127t
    -85t
    31t
    -115t
    -58t
    78t
    94t
    0t
    87t
    95t
    -117t
    99t
    -58t
    -32t
    38t
    -79t
    39t
    -14t
    101t
    88t
    -11t
    -43t
    113t
    -73t
    -56t
    -120t
    -4t
    -85t
    109t
    -3t
    110t
    8t
    -5t
    102t
    -94t
    -88t
    119t
    71t
    116t
    54t
    73t
    -11t
    20t
    -1t
    34t
    121t
    103t
    -68t
    -101t
    -109t
    -93t
    86t
    43t
    26t
    120t
    -22t
    -38t
    -8t
    -6t
    -94t
    -3t
    73t
    -56t
    -30t
    33t
    -45t
    108t
    39t
    -61t
    -72t
    -91t
    -117t
    119t
    119t
    115t
    46t
    25t
    86t
    16t
    91t
    112t
    38t
    125t
    60t
    94t
    -87t
    16t
    -25t
    40t
    87t
    -69t
    21t
    -54t
    103t
    -2t
    -92t
    119t
    -113t
    125t
    -108t
    20t
    123t
    -74t
    -75t
    -35t
    79t
    -119t
    89t
    -1t
    -61t
    82t
    -91t
    72t
    -116t
    -38t
    17t
    -102t
    69t
    102t
    -127t
    -3t
    -14t
    -109t
    82t
    -106t
    80t
    -13t
    -35t
    -1t
    41t
    66t
    18t
    -112t
    124t
    66t
    38t
    -44t
    -110t
    -38t
    -73t
    -54t
    -22t
    73t
    91t
    -56t
    -28t
    77t
    98t
    -9t
    -16t
    -7t
    -34t
    -35t
    83t
    67t
    54t
    9t
    90t
    37t
    -66t
    93t
    -112t
    -93t
    27t
    -4t
    -36t
    -29t
    80t
    28t
    10t
    -59t
    -61t
    -46t
    12t
    0t
    -70t
    -62t
    48t
    102t
    25t
    85t
    -28t
    127t
    14t
    44t
    93t
    51t
    -14t
    -16t
    55t
    50t
    -59t
    -50t
    -53t
    -99t
    -22t
    -37t
    124t
    58t
    2t
    124t
    -27t
    -2t
    23t
    7t
    98t
    115t
    -58t
    -50t
    -43t
    -47t
    -105t
    112t
    -15t
    -42t
    -10t
    -6t
    19t
    46t
    17t
    22t
    61t
    -64t
    17t
    -31t
    102t
    95t
    115t
    113t
    52t
    66t
    25t
    -54t
    26t
    28t
    111t
    -48t
    -85t
    47t
    -14t
    6t
    -117t
    60t
    115t
    63t
    -39t
    -88t
    -92t
    8t
    125t
    -96t
    93t
    -77t
    -69t
    63t
    13t
    79t
    71t
    6t
    -34t
    84t
    -74t
    -72t
    9t
    -24t
    101t
    4t
    -121t
    -32t
    47t
    -62t
    125t
    -19t
    59t
    52t
    -26t
    120t
    -8t
    0t
    96t
    -49t
    120t
    -19t
    -46t
    -99t
    -75t
    75t
    -96t
    -104t
    -60t
    -43t
    85t
    58t
    -3t
    -107t
    111t
    -53t
    17t
    113t
    26t
    23t
    -32t
    -25t
    6t
    -59t
    87t
    -14t
    -80t
    93t
    120t
    -35t
    -76t
    -72t
    16t
    -33t
    105t
    57t
    -11t
    -109t
    -82t
    113t
    -113t
    36t
    29t
    -107t
    -94t
    -2t
    88t
    -104t
    100t
    -75t
    28t
    70t
    -39t
    -84t
    -49t
    68t
    84t
    -123t
    -17t
    -102t
    -27t
    -21t
    -118t
    91t
    -9t
    117t
    54t
    11t
    29t
    -99t
    108t
    81t
    106t
    76t
    66t
    -58t
    -110t
    -114t
    44t
    -88t
    -21t
    -121t
    76t
    100t
    13t
    16t
    127t
    -121t
    -124t
    92t
    56t
    78t
    55t
    43t
    -81t
    -47t
    -29t
    53t
    -119t
    -29t
    94t
    -13t
    -94t
    -9t
    -82t
    106t
    -109t
    -74t
    -24t
    102t
    -4t
    -6t
    126t
    -101t
    -44t
    37t
    -4t
    45t
    -51t
    -103t
    3t
    -86t
    -125t
    -104t
    -29t
    -87t
    -95t
    68t
    51t
    121t
    17t
    27t
    -52t
    24t
    122t
    127t
    -39t
    -106t
    66t
    91t
    -55t
    99t
    34t
    -113t
    4t
    -125t
    59t
    22t
    59t
    -105t
    18t
    13t
    60t
    33t
    -72t
    7t
    -34t
    -72t
    -126t
    -47t
    40t
    119t
    93t
    -27t
    -74t
    102t
    59t
    -124t
    85t
    62t
    -66t
    -93t
    1t
    -60t
    39t
    -45t
    115t
    127t
    -121t
    80t
    108t
    -61t
    -90t
    -55t
    -41t
    100t
    -7t
    106t
    -3t
    -45t
    -96t
    82t
    -67t
    -105t
    -35t
    62t
    -91t
    -96t
    4t
    -10t
    -35t
    9t
    -124t
    90t
    -95t
    85t
    60t
    87t
    -76t
    -88t
    -117t
    56t
    -38t
    -25t
    -108t
    106t
    -94t
    -10t
    57t
    -73t
    -46t
    -116t
    -58t
    -100t
    -13t
    45t
    -32t
    98t
    79t
    -26t
    -70t
    8t
    -64t
    -86t
    -111t
    -118t
    -35t
    101t
    -88t
    63t
    -6t
    83t
    -88t
    67t
    127t
    112t
    -58t
    72t
    -18t
    100t
    40t
    -31t
    103t
    -35t
    -25t
    -92t
    -68t
    70t
    92t
    127t
    -92t
    -64t
    -83t
    -54t
    12t
    61t
    -17t
    -115t
    71t
    -27t
    -51t
    10t
    54t
    54t
    33t
    55t
    6t
    -6t
    -50t
    59t
    -22t
    76t
    -15t
    89t
    -1t
    -110t
    22t
    -73t
    -20t
    -86t
    -72t
    78t
    -99t
    -90t
    28t
    58t
    -96t
    -34t
    -16t
    59t
    -14t
    31t
    120t
    111t
    40t
    -27t
    20t
    106t
    -62t
    83t
    -75t
    27t
    23t
    126t
    -32t
    -47t
    -48t
    -24t
    -115t
    -49t
    -7t
    44t
    -20t
    -68t
    115t
    -101t
    -10t
    -84t
    -93t
    -10t
    -27t
    117t
    124t
    -77t
    -96t
    -128t
    77t
    7t
    53t
    -38t
    -117t
    -28t
    81t
    -111t
    22t
    114t
    71t
    105t
    -43t
    57t
    90t
    -1t
    -65t
    28t
    -51t
    -91t
    -116t
    53t
    -13t
    28t
    40t
    43t
    45t
    -17t
    45t
    -82t
    -128t
    44t
    89t
    -8t
    66t
    14t
    -2t
    -92t
    106t
    56t
    33t
    -116t
    81t
    -89t
    15t
    95t
    35t
    -124t
    40t
    49t
    56t
    -44t
    -94t
    106t
    -22t
    24t
    121t
    -84t
    12t
    85t
    4t
    -67t
    104t
    57t
    29t
    -56t
    59t
    -68t
    32t
    52t
    -107t
    -44t
    -15t
    77t
    -103t
    24t
    -50t
    -72t
    -71t
    -42t
    -4t
    6t
    81t
    20t
    -109t
    91t
    -48t
    -74t
    96t
    -30t
    104t
    11t
    60t
    11t
    95t
    -123t
    -60t
    -48t
    68t
    78t
    -20t
    -20t
    19t
    63t
    26t
    101t
    47t
    3t
    -81t
    -54t
    -90t
    67t
    59t
    -15t
    71t
    -69t
    76t
    -8t
    33t
    -31t
    28t
    -86t
    110t
    -35t
    -17t
    57t
    59t
    -31t
    79t
    85t
    -73t
    40t
    -16t
    31t
    -47t
    -75t
    60t
    8t
    -102t
    -37t
    -82t
    -82t
    -60t
    1t
    -111t
    41t
    92t
    93t
    -70t
    95t
    51t
    -10t
    -22t
    -28t
    -74t
    -5t
    -44t
    -42t
    89t
    85t
    -94t
    95t
    -25t
    -113t
    -12t
    -51t
    38t
    -114t
    -115t
    -45t
    -109t
    23t
    66t
    -126t
    -67t
    -56t
    -22t
    -75t
    -74t
    -5t
    77t
    8t
    56t
    -10t
    86t
    -122t
    -85t
    38t
    -15t
    -69t
    -18t
    -69t
    27t
    109t
    -43t
    110t
    101t
    -117t
    -67t
    55t
    -92t
    75t
    -61t
    -50t
    20t
    -82t
    -72t
    92t
    80t
    93t
    18t
    -96t
    33t
    65t
    120t
    105t
    -54t
    -62t
    126t
    -121t
    51t
    127t
    127t
    -16t
    79t
    -29t
    25t
    -31t
    -62t
    16t
    -113t
    -105t
    -84t
    -43t
    12t
    71t
    65t
    -93t
    -53t
    -76t
    27t
    -93t
    70t
    -27t
    40t
    -61t
    -95t
    -7t
    -68t
    25t
    -46t
    -52t
    -105t
    -31t
    -88t
    -7t
    114t
    -48t
    -60t
    -116t
    -19t
    -37t
    -92t
    20t
    19t
    -71t
    25t
    108t
    35t
    -8t
    -4t
    101t
    -47t
    25t
    -111t
    72t
    29t
    -6t
    -71t
    9t
    107t
    -57t
    103t
    30t
    -83t
    40t
    113t
    -19t
    -117t
    55t
    -15t
    -48t
    73t
    59t
    -48t
    -104t
    98t
    77t
    40t
    -24t
    -49t
    124t
    -50t
    64t
    -51t
    -105t
    58t
    -71t
    -3t
    -40t
    26t
    -4t
    74t
    -63t
    73t
    82t
    72t
    9t
    -78t
    -95t
    37t
    -21t
    94t
    -62t
    -40t
    89t
    -40t
    -85t
    44t
    97t
    -73t
    112t
    33t
    1t
    87t
    -80t
    -70t
    13t
    100t
    86t
    37t
    92t
    -127t
    66t
    -2t
    -123t
    -67t
    -19t
    58t
    -6t
    53t
    22t
    -121t
    -94t
    -41t
    3t
    102t
    -93t
    85t
    39t
    -120t
    95t
    -91t
    -18t
    96t
    -41t
    94t
    -10t
    18t
    83t
    73t
    126t
    72t
    11t
    119t
    -55t
    75t
    -87t
    -36t
    -73t
    121t
    -53t
    -118t
    25t
    14t
    -67t
    102t
    113t
    -20t
    -69t
    41t
    -2t
    -49t
    -48t
    88t
    3t
    116t
    126t
    -65t
    -97t
    47t
    -15t
    27t
    109t
    63t
    87t
    -37t
    -54t
    -58t
    -16t
    61t
    4t
    50t
    -12t
    95t
    111t
    -45t
    27t
    -41t
    -22t
    -40t
    113t
    120t
    -37t
    -112t
    -103t
    -35t
    95t
    30t
    44t
    -77t
    28t
    80t
    82t
    -93t
    -90t
    -4t
    -119t
    123t
    -19t
    -41t
    -94t
    -71t
    -85t
    125t
    -92t
    72t
    -48t
    51t
    -69t
    76t
    -22t
    -60t
    83t
    -9t
    35t
    12t
    -2t
    -28t
    25t
    111t
    -126t
    120t
    107t
    67t
    -23t
    64t
    -79t
    -68t
    -116t
    -106t
    26t
    -37t
    -59t
    -23t
    63t
    8t
    2t
    104t
    6t
    88t
    42t
    34t
    -32t
    96t
    67t
    -77t
    49t
    64t
    54t
    -117t
    36t
    -16t
    126t
    -119t
    123t
    58t
    72t
    99t
    -75t
    -83t
    -25t
    -60t
    51t
    -41t
    -63t
    -34t
    -41t
    66t
    102t
    -17t
    84t
    98t
    101t
    112t
    -43t
    -58t
    -95t
    -8t
    -54t
    87t
    -38t
    99t
    126t
    74t
    -78t
    21t
    88t
    -95t
    -62t
    125t
    -47t
    -99t
    -43t
    -81t
    92t
    48t
    -16t
    75t
    -59t
    29t
    64t
    -38t
    -92t
    98t
    8t
    66t
    72t
    65t
    89t
    103t
    123t
    -124t
    48t
    28t
    64t
    117t
    -68t
    77t
    5t
    -85t
    41t
    13t
    86t
    -77t
    1t
    -70t
    6t
    67t
    -102t
    -11t
    -78t
    -58t
    -9t
    108t
    79t
    -74t
    -120t
    84t
    73t
    91t
    104t
    48t
    -4t
    -6t
    -15t
    -99t
    -19t
    -95t
    59t
    0t
    32t
    -28t
    81t
    80t
    94t
    -52t
    25t
    34t
    -89t
    -78t
    -115t
    -106t
    54t
    -54t
    102t
    -6t
    -121t
    35t
    13t
    -99t
    -32t
    64t
    -81t
    99t
    -105t
    -95t
    -116t
    -85t
    20t
    -111t
    122t
    46t
    59t
    -55t
    113t
    -113t
    77t
    -52t
    83t
    -127t
    -77t
    14t
    89t
    58t
    57t
    -2t
    125t
    21t
    -60t
    -5t
    105t
    -100t
    49t
    -54t
    81t
    -5t
    96t
    -55t
    8t
    -116t
    -26t
    -29t
    -108t
    -40t
    77t
    -50t
    -127t
    -89t
    -72t
    65t
    77t
    -37t
    -106t
    122t
    27t
    -110t
    -128t
    120t
    29t
    50t
    33t
    -87t
    73t
    -5t
    -42t
    -115t
    -44t
    -126t
    -87t
    56t
    29t
    108t
    13t
    53t
    83t
    -42t
    -100t
    -72t
    -84t
    -50t
    13t
    -39t
    -110t
    98t
    87t
    115t
    110t
    -118t
    22t
    -69t
    30t
    -27t
    -33t
    -2t
    86t
    84t
    -84t
    79t
    -55t
    -80t
    -41t
    -27t
    54t
    -64t
    -95t
    -37t
    -90t
    61t
    -46t
    -52t
    3t
    -31t
    -116t
    37t
    -29t
    -58t
    -38t
    122t
    59t
    40t
    -23t
    83t
    106t
    -62t
    -39t
    -48t
    -102t
    46t
    -65t
    -127t
    -55t
    29t
    -84t
    -62t
    90t
    -103t
    122t
    -60t
    13t
    60t
    108t
    -87t
    115t
    -65t
    -63t
    -79t
    85t
    -36t
    113t
    92t
    54t
    -128t
    -74t
    -100t
    29t
    30t
    5t
    27t
    115t
    102t
    123t
    -100t
    23t
    0t
    33t
    -43t
    -35t
    18t
    -5t
    -52t
    10t
    -57t
    117t
    -18t
    -9t
    54t
    116t
    41t
    -20t
    -51t
    121t
    -101t
    -60t
    -26t
    9t
    10t
    54t
    -99t
    -94t
    -51t
    122t
    -110t
    -1t
    102t
    89t
    39t
    -114t
    -17t
    83t
    -57t
    -110t
    -68t
    -103t
    -57t
    66t
    -118t
    34t
    -30t
    107t
    -100t
    -10t
    -43t
    -105t
    -86t
    60t
    91t
    -3t
    -62t
    -126t
    -70t
    -118t
    77t
    51t
    -19t
    117t
    110t
    -117t
    89t
    -85t
    84t
    106t
    99t
    45t
    -78t
    -35t
    -115t
    -128t
    85t
    1t
    -43t
    -60t
    -97t
    -97t
    102t
    52t
    107t
    -18t
    34t
    -83t
    -86t
    21t
    39t
    47t
    54t
    119t
    105t
    32t
    52t
    -99t
    17t
    -37t
    10t
    72t
    -12t
    -54t
    12t
    126t
    -76t
    -89t
    16t
    106t
    -75t
    44t
    -9t
    -78t
    -88t
    50t
    19t
    -40t
    111t
    -83t
    -34t
    -36t
    -93t
    -26t
    -79t
    0t
    -23t
    94t
    79t
    -53t
    -47t
    106t
    -38t
    -29t
    93t
    59t
    -119t
    -92t
    -30t
    -48t
    -73t
    86t
    -20t
    35t
    20t
    -92t
    38t
    2t
    57t
    61t
    -42t
    -110t
    120t
    -102t
    -61t
    -75t
    -91t
    -47t
    -82t
    74t
    -102t
    125t
    14t
    30t
    40t
    114t
    69t
    -57t
    127t
    -18t
    75t
    -110t
    123t
    99t
    21t
    -44t
    -12t
    -108t
    127t
    -123t
    88t
    113t
    5t
    119t
    59t
    -38t
    50t
    22t
    115t
    -95t
    63t
    121t
    -74t
    46t
    -107t
    -48t
    126t
    -82t
    19t
    -112t
    -71t
    -38t
    -69t
    7t
    58t
    -86t
    -97t
    100t
    -120t
    -59t
    -14t
    -60t
    72t
    -2t
    -26t
    -9t
    -110t
    -81t
    4t
    -78t
    79t
    11t
    16t
    10t
    -18t
    115t
    29t
    -43t
    77t
    -34t
    2t
    -10t
    117t
    4t
    -24t
    25t
    13t
    12t
    120t
    -28t
    114t
    62t
    47t
    -119t
    73t
    9t
    95t
    110t
    78t
    -86t
    9t
    75t
    -81t
    64t
    24t
    79t
    -117t
    111t
    -9t
    -81t
    37t
    -46t
    -80t
    101t
    21t
    36t
    -124t
    -112t
    -104t
    84t
    53t
    115t
    -17t
    122t
    4t
    -120t
    42t
    -83t
    32t
    -38t
    75t
    -125t
    -10t
    51t
    50t
    -95t
    -103t
    -33t
    24t
    -22t
    56t
    -107t
    122t
    -30t
    -7t
    30t
    40t
    84t
    -5t
    -47t
    -88t
    53t
    69t
    125t
    88t
    -16t
    -17t
    -12t
    43t
    28t
    91t
    0t
    -104t
    -87t
    41t
    51t
    95t
    33t
    113t
    -9t
    34t
    -10t
    42t
    -68t
    -98t
    -119t
    49t
    -15t
    -12t
    69t
    -127t
    -48t
    108t
    11t
    -29t
    -68t
    -80t
    -37t
    67t
    7t
    -113t
    -6t
    -50t
    -19t
    112t
    54t
    96t
    -50t
    -7t
    -78t
    -98t
    35t
    -44t
    -91t
    -14t
    -113t
    84t
    97t
    -110t
    112t
    -94t
    119t
    37t
    -82t
    -32t
    -51t
    83t
    -124t
    -93t
    72t
    -54t
    123t
    -30t
    95t
    -13t
    26t
    -108t
    -28t
    43t
    82t
    116t
    -78t
    79t
    -77t
    87t
    77t
    -47t
    -10t
    -74t
    -119t
    94t
    50t
    -94t
    12t
    5t
    -34t
    -77t
    71t
    66t
    -118t
    -15t
    -52t
    39t
    -94t
    -106t
    -89t
    60t
    48t
    -87t
    -75t
    113t
    40t
    -23t
    15t
    -39t
    -27t
    107t
    55t
    68t
    -86t
    26t
    119t
    80t
    48t
    101t
    1t
    22t
    24t
    68t
    11t
    4t
    81t
    -25t
    -15t
    95t
    11t
    -121t
    -71t
    118t
    -20t
    85t
    -80t
    71t
    122t
    112t
    77t
    91t
    -109t
    52t
    -28t
    -21t
    -29t
    -29t
    115t
    118t
    89t
    68t
    77t
    95t
    55t
    45t
    112t
    40t
    64t
    -127t
    -80t
    118t
    -101t
    -77t
    -126t
    -19t
    -118t
    109t
    -98t
    98t
    16t
    -122t
    83t
    17t
    -34t
    -115t
    40t
    -6t
    96t
    114t
    62t
    8t
    -67t
    114t
    114t
    99t
    99t
    -87t
    81t
    -83t
    91t
    109t
    63t
    -58t
    -10t
    -34t
    101t
    -57t
    -22t
    -10t
    -19t
    -78t
    -101t
    55t
    17t
    -101t
    -7t
    25t
    4t
    -2t
    -26t
    74t
    -51t
    13t
    38t
    15t
    18t
    47t
    0t
    -89t
    -49t
    -113t
    -107t
    102t
    -21t
    -126t
    -116t
    -110t
    5t
    122t
    44t
    -44t
    36t
    -67t
    75t
    -88t
    -26t
    -104t
    -82t
    77t
    17t
    -81t
    37t
    13t
    -79t
    81t
    -18t
    52t
    -12t
    -32t
    -24t
    104t
    111t
    -50t
    49t
    58t
    101t
    -128t
    -126t
    -39t
    -27t
    3t
    124t
    -97t
    7t
    70t
    18t
    112t
    36t
    104t
    -69t
    -25t
    -36t
    -64t
    4t
    -24t
    -64t
    -1t
    -8t
    -102t
    3t
    -11t
    -8t
    1t
    74t
    -71t
    -116t
    93t
    9t
    113t
    -64t
    13t
    -14t
    15t
    66t
    113t
    -119t
    -88t
    85t
    26t
    52t
    58t
    112t
    94t
    -85t
    43t
    116t
    12t
    37t
    102t
    -61t
    -106t
    21t
    24t
    105t
    -29t
    64t
    -87t
    71t
    -121t
    -1t
    0t
    109t
    -57t
    -117t
    -54t
    -73t
    54t
    -104t
    -94t
    115t
    -55t
    61t
    -5t
    -65t
    -58t
    13t
    89t
    -128t
    96t
    85t
    -9t
    -2t
    -94t
    66t
    -66t
    23t
    -51t
    -118t
    -81t
    -99t
    81t
    -27t
    -90t
    59t
    -73t
    82t
    -120t
    17t
    -64t
    -60t
    -28t
    109t
    105t
    50t
    -54t
    -6t
    -79t
    -36t
    43t
    113t
    126t
    -112t
    20t
    -33t
    -77t
    24t
    105t
    50t
    17t
    -118t
    -67t
    -59t
    -30t
    23t
    41t
    -20t
    103t
    -46t
    -3t
    -18t
    -27t
    -58t
    127t
    -65t
    -10t
    15t
    18t
    -58t
    -93t
    64t
    75t
    26t
    90t
    -111t
    -19t
    50t
    -57t
    98t
    71t
    109t
    113t
    -109t
    -83t
    -127t
    127t
    103t
    97t
    -46t
    54t
    -108t
    103t
    -60t
    56t
    -64t
    -126t
    37t
    16t
    -111t
    31t
    4t
    -93t
    80t
    102t
    10t
    -70t
    -36t
    -24t
    -44t
    89t
    107t
    33t
    -34t
    -14t
    -52t
    -120t
    19t
    92t
    -73t
    73t
    -116t
    122t
    -85t
    127t
    -64t
    -34t
    -47t
    23t
    114t
    119t
    30t
    16t
    -45t
    -26t
    69t
    30t
    11t
    -28t
    -109t
    -33t
    40t
    111t
    -29t
    65t
    -34t
    96t
    39t
    -82t
    -103t
    -20t
    -125t
    31t
    59t
    123t
    118t
    -13t
    -50t
    -120t
    118t
    -69t
    -6t
    -68t
    10t
    -92t
    -82t
    -74t
    -1t
    16t
    -74t
    84t
    -121t
    126t
    -35t
    123t
    37t
    -6t
    -57t
    -112t
    92t
    -31t
    -117t
    111t
    -28t
    -7t
    -69t
    -59t
    -124t
    8t
    -115t
    -51t
    120t
    5t
    -11t
    -41t
    36t
    -110t
    -13t
    -94t
    -53t
    -38t
    -106t
    46t
    67t
    -102t
    -45t
    43t
    112t
    -62t
    109t
    96t
    -39t
    -20t
    -110t
    -55t
    58t
    -103t
    100t
    -74t
    -125t
    120t
    50t
    11t
    -20t
    -51t
    100t
    60t
    22t
    41t
    53t
    -46t
    45t
    20t
    -27t
    65t
    -93t
    -7t
    -119t
    82t
    -122t
    -75t
    104t
    61t
    81t
    -62t
    92t
    15t
    54t
    -52t
    39t
    5t
    -22t
    -116t
    85t
    -45t
    12t
    -59t
    -19t
    -55t
    37t
    -60t
    -7t
    33t
    118t
    56t
    9t
    39t
    72t
    47t
    34t
    -60t
    -26t
    60t
    34t
    39t
    -23t
    40t
    116t
    70t
    101t
    -13t
    113t
    68t
    -74t
    -17t
    64t
    54t
    98t
    112t
    -51t
    -5t
    93t
    32t
    -7t
    -72t
    -43t
    -38t
    56t
    -15t
    91t
    86t
    39t
    -115t
    59t
    107t
    -74t
    -121t
    -4t
    -50t
    -40t
    31t
    106t
    -1t
    113t
    -65t
    47t
    -78t
    14t
    -29t
    -100t
    -109t
    100t
    87t
    -62t
    -97t
    92t
    10t
    98t
    -20t
    -40t
    120t
    -10t
    88t
    75t
    -81t
    -25t
    53t
    -122t
    -101t
    -4t
    -90t
    0t
    -72t
    99t
    -2t
    49t
    4t
    -55t
    93t
    59t
    100t
    24t
    -63t
    32t
    35t
    -18t
    109t
    -54t
    -87t
    87t
    82t
    37t
    76t
    -102t
    65t
    7t
    -128t
    92t
    -93t
    -7t
    -38t
    19t
    122t
    -97t
    -76t
    124t
    -101t
    -92t
    -30t
    67t
    96t
    -103t
    -106t
    -56t
    -25t
    -114t
    -89t
    -14t
    -65t
    113t
    101t
    -119t
    79t
    -91t
    -72t
    -15t
    112t
    -30t
    -36t
    -89t
    62t
    108t
    -45t
    56t
    -122t
    126t
    24t
    98t
    -66t
    -109t
    -81t
    -59t
    -40t
    4t
    -12t
    112t
    14t
    -119t
    -86t
    -69t
    94t
    110t
    118t
    77t
    -87t
    97t
    15t
    -10t
    103t
    14t
    -98t
    -69t
    -62t
    -33t
    -98t
    -56t
    95t
    -33t
    -14t
    70t
    54t
    -84t
    81t
    -116t
    13t
    36t
    -12t
    -29t
    20t
    82t
    6t
    117t
    -36t
    120t
    -11t
    -113t
    -49t
    -8t
    24t
    -23t
    42t
    120t
    48t
    17t
    -66t
    -24t
    113t
    -80t
    -55t
    -27t
    -76t
    121t
    5t
    64t
    55t
    -39t
    23t
    0t
    -76t
    29t
    93t
    85t
    -98t
    -114t
    -14t
    -24t
    124t
    56t
    -7t
    19t
    72t
    -74t
    115t
    -18t
    83t
    25t
    -97t
    19t
    -47t
    25t
    41t
    -3t
    67t
    62t
    74t
    -46t
    -67t
    -107t
    65t
    106t
    -29t
    115t
    -98t
    -6t
    -95t
    50t
    126t
    46t
    43t
    35t
    -49t
    46t
    -74t
    -87t
    -83t
    122t
    81t
    62t
    -75t
    120t
    -44t
    -20t
    -28t
    -54t
    29t
    52t
    72t
    101t
    -112t
    114t
    23t
    -85t
    -55t
    -33t
    -45t
    -75t
    -49t
    -51t
    -115t
    -103t
    15t
    104t
    43t
    52t
    -112t
    -25t
    -67t
    40t
    119t
    124t
    -47t
    -51t
    -57t
    -47t
    110t
    -124t
    82t
    -117t
    -8t
    -86t
    -108t
    121t
    -124t
    105t
    92t
    -122t
    -52t
    80t
    -13t
    -64t
    -34t
    45t
    104t
    11t
    102t
    -61t
    3t
    14t
    -109t
    118t
    -58t
    33t
    -96t
    -2t
    24t
    -84t
    -125t
    -36t
    15t
    5t
    43t
    -47t
    94t
    47t
    97t
    -29t
    -28t
    -30t
    -110t
    -62t
    -53t
    57t
    104t
    100t
    -64t
    -94t
    -58t
    65t
    -113t
    53t
    78t
    61t
    -65t
    -82t
    50t
    75t
    74t
    80t
    -126t
    -11t
    -6t
    -6t
    52t
    63t
    -128t
    -94t
    -54t
    113t
    -82t
    125t
    -96t
    -23t
    115t
    107t
    -114t
    2t
    -12t
    -124t
    20t
    -30t
    -41t
    10t
    -8t
    -2t
    -97t
    -7t
    -62t
    70t
    50t
    -15t
    -61t
    -32t
    75t
    113t
    121t
    -21t
    -11t
    17t
    1t
    72t
    -91t
    -124t
    -110t
    -24t
    44t
    -97t
    -17t
    38t
    -29t
    96t
    -105t
    25t
    -70t
    -38t
    26t
    43t
    124t
    -106t
    126t
    39t
    42t
    -89t
    -113t
    -1t
    1t
    -106t
    -120t
    107t
    -71t
    108t
    114t
    127t
    -106t
    -64t
    46t
    8t
    12t
    -82t
    88t
    46t
    -116t
    93t
    -111t
    36t
    -53t
    -3t
    90t
    -118t
    115t
    -8t
    43t
    -92t
    50t
    -79t
    127t
    -50t
    -115t
    -28t
    125t
    -44t
    -56t
    -9t
    51t
    73t
    -50t
    -79t
    34t
    -46t
    85t
    121t
    -27t
    94t
    40t
    72t
    71t
    -24t
    74t
    25t
    19t
    125t
    -102t
    -31t
    107t
    38t
    32t
    -3t
    19t
    -72t
    -68t
    119t
    21t
    -91t
    -11t
    21t
    18t
    104t
    -88t
    -93t
    -78t
    68t
    29t
    81t
    -78t
    -37t
    -63t
    50t
    90t
    -94t
    23t
    116t
    30t
    -76t
    107t
    -124t
    -32t
    -122t
    -126t
    102t
    122t
    -83t
    -34t
    17t
    116t
    6t
    -38t
    95t
    -8t
    -88t
    -104t
    -42t
    -31t
    2t
    95t
    82t
    -31t
    -121t
    -96t
    -69t
    6t
    14t
    -56t
    -81t
    74t
    -35t
    2t
    41t
    -24t
    24t
    22t
    20t
    63t
    67t
    62t
    -106t
    -76t
    -118t
    35t
    -91t
    -104t
    -94t
    20t
    45t
    24t
    0t
    6t
    -121t
    98t
    71t
    -101t
    -109t
    -77t
    113t
    -97t
    -67t
    -94t
    -32t
    56t
    9t
    100t
    44t
    36t
    124t
    -31t
    25t
    103t
    -87t
    -17t
    77t
    -81t
    -18t
    -98t
    81t
    -108t
    50t
    -97t
    -42t
    95t
    -60t
    -36t
    74t
    -127t
    -16t
    -40t
    0t
    -29t
    34t
    57t
    108t
    92t
    23t
    -28t
    -107t
    -71t
    95t
    -66t
    -25t
    -32t
    114t
    12t
    -46t
    89t
    -71t
    6t
    29t
    -101t
    99t
    62t
    101t
    38t
    6t
    -68t
    -14t
    89t
    -73t
    -89t
    -89t
    -61t
    -16t
    5t
    66t
    -23t
    63t
    93t
    64t
    126t
    45t
    81t
    91t
    -81t
    -51t
    -9t
    -9t
    -79t
    -24t
    124t
    127t
    104t
    101t
    -65t
    -85t
    -116t
    -119t
    1t
    -61t
    -39t
    12t
    104t
    17t
    68t
    -53t
    123t
    -34t
    26t
    -2t
    -100t
    69t
    -78t
    68t
    -78t
    -31t
    -88t
    113t
    -90t
    -31t
    -14t
    -64t
    -127t
    -25t
    72t
    -90t
    -128t
    -113t
    14t
    91t
    18t
    9t
    -54t
    -95t
    -12t
    54t
    -85t
    -67t
    49t
    -56t
    -77t
    51t
    116t
    -53t
    -91t
    79t
    -38t
    71t
    -80t
    -7t
    -99t
    7t
    82t
    99t
    81t
    33t
    14t
    -2t
    -119t
    -118t
    -24t
    -16t
    70t
    49t
    19t
    119t
    -29t
    5t
    106t
    -84t
    74t
    107t
    -37t
    43t
    21t
    53t
    -99t
    9t
    103t
    43t
    40t
    -84t
    113t
    -10t
    -121t
    28t
    -117t
    103t
    41t
    -110t
    120t
    39t
    -50t
    -59t
    54t
    -123t
    114t
    -77t
    -98t
    30t
    -32t
    19t
    42t
    -76t
    7t
    11t
    -64t
    -126t
    -2t
    90t
    -58t
    -85t
    121t
    -34t
    76t
    -82t
    77t
    -62t
    -90t
    -29t
    79t
    -120t
    -76t
    -101t
    19t
    74t
    -100t
    -25t
    109t
    -84t
    2t
    28t
    122t
    -115t
    -20t
    -4t
    56t
    32t
    -31t
    -89t
    -32t
    102t
    100t
    59t
    -43t
    8t
    -99t
    -90t
    66t
    -119t
    -97t
    62t
    85t
    65t
    14t
    29t
    -13t
    66t
    -89t
    31t
    -116t
    -27t
    -68t
    96t
    22t
    41t
    -85t
    0t
    21t
    -28t
    54t
    -128t
    -65t
    -32t
    26t
    91t
    -84t
    21t
    -112t
    -8t
    -106t
    98t
    -25t
    29t
    87t
    27t
    -96t
    25t
    10t
    -36t
    -48t
    -51t
    89t
    -49t
    -16t
    56t
    80t
    25t
    33t
    -109t
    -110t
    -90t
    -37t
    -80t
    33t
    25t
    73t
    123t
    97t
    14t
    -56t
    90t
    -91t
    9t
    -93t
    -32t
    -70t
    0t
    20t
    -40t
    12t
    -34t
    -124t
    74t
    114t
    -99t
    -83t
    -96t
    -104t
    -46t
    26t
    36t
    -14t
    -98t
    -95t
    80t
    80t
    -56t
    109t
    59t
    66t
    -7t
    64t
    -107t
    -74t
    15t
    -87t
    98t
    -27t
    -27t
    -38t
    7t
    -7t
    -2t
    -128t
    38t
    -91t
    -38t
    96t
    73t
    -99t
    -15t
    103t
    43t
    13t
    -96t
    -36t
    118t
    -110t
    101t
    -34t
    51t
    -13t
    -76t
    -40t
    109t
    -102t
    -35t
    34t
    3t
    -79t
    -118t
    -79t
    23t
    -110t
    92t
    111t
    94t
    -60t
    -30t
    28t
    -102t
    78t
    -45t
    46t
    18t
    37t
    -111t
    -63t
    30t
    49t
    -30t
    -5t
    -86t
    -5t
    3t
    111t
    -46t
    -20t
    -1t
    97t
    -58t
    68t
    -110t
    78t
    63t
    -79t
    75t
    110t
    -119t
    81t
    -87t
    15t
    -96t
    60t
    74t
    6t
    -14t
    90t
    -72t
    -70t
    -54t
    48t
    -56t
    -126t
    122t
    -126t
    -22t
    -119t
    56t
    -81t
    -89t
    98t
    -88t
    17t
    19t
    -99t
    26t
    -51t
    -120t
    -59t
    36t
    -111t
    -110t
    55t
    7t
    -27t
    96t
    -59t
    -55t
    90t
    -100t
    68t
    -59t
    -120t
    -70t
    -119t
    -3t
    31t
    -80t
    -55t
    5t
    34t
    -44t
    89t
    -14t
    41t
    93t
    -83t
    48t
    105t
    90t
    107t
    75t
    -88t
    123t
    -39t
    -23t
    -45t
    -23t
    -35t
    122t
    -61t
    -71t
    -71t
    -56t
    -45t
    -125t
    -95t
    65t
    51t
    79t
    -58t
    -114t
    -73t
    87t
    44t
    119t
    104t
    51t
    -73t
    103t
    -114t
    -74t
    -25t
    -126t
    -26t
    -53t
    56t
    0t
    -114t
    -47t
    -112t
    12t
    44t
    83t
    75t
    -96t
    -62t
    41t
    54t
    -112t
    119t
    -88t
    -25t
    122t
    65t
    -42t
    -49t
    16t
    -12t
    22t
    -83t
    -50t
    -77t
    -113t
    -29t
    -127t
    -82t
    -50t
    -89t
    -99t
    -58t
    -106t
    81t
    101t
    -12t
    -117t
    -123t
    45t
    -64t
    -46t
    -122t
    14t
    -99t
    -96t
    -28t
    -44t
    -24t
    -81t
    -22t
    -59t
    -106t
    120t
    116t
    24t
    -123t
    -72t
    127t
    -5t
    32t
    22t
    60t
    33t
    -72t
    119t
    5t
    -90t
    25t
    -91t
    -91t
    -10t
    -12t
    54t
    71t
    0t
    71t
    50t
    -69t
    92t
    -87t
    -23t
    -62t
    19t
    -125t
    2t
    -73t
    53t
    -112t
    27t
    -102t
    -83t
    -96t
    27t
    37t
    -2t
    48t
    -108t
    -27t
    61t
    30t
    27t
    -126t
    -118t
    -104t
    -6t
    72t
    100t
    66t
    15t
    10t
    -51t
    101t
    95t
    -73t
    -126t
    27t
    27t
    35t
    117t
    -87t
    -11t
    -38t
    -2t
    -126t
    -127t
    66t
    118t
    -17t
    -120t
    116t
    78t
    61t
    99t
    -65t
    13t
    -51t
    100t
    -125t
    103t
    -96t
    -83t
    18t
    -95t
    60t
    104t
    -122t
    -54t
    -11t
    105t
    -16t
    -119t
    98t
    -40t
    -115t
    113t
    13t
    118t
    67t
    3t
    37t
    46t
    3t
    123t
    -126t
    -6t
    -34t
    1t
    40t
    124t
    52t
    -68t
    -122t
    75t
    -20t
    -6t
    -41t
    -27t
    -100t
    -16t
    -23t
    -103t
    -53t
    -87t
    23t
    112t
    -72t
    -66t
    31t
    -108t
    68t
    25t
    -12t
    38t
    54t
    -51t
    17t
    53t
    110t
    39t
    11t
    44t
    -48t
    -84t
    -63t
    -91t
    -18t
    -23t
    -42t
    -94t
    -88t
    88t
    -40t
    -42t
    30t
    77t
    88t
    -34t
    30t
    83t
    91t
    -6t
    -113t
    -27t
    16t
    11t
    -41t
    72t
    -86t
    -90t
    111t
    48t
    -63t
    1t
    -48t
    -51t
    97t
    -80t
    22t
    -118t
    -14t
    115t
    -6t
    -110t
    -112t
    89t
    82t
    83t
    -44t
    83t
    -62t
    75t
    67t
    10t
    27t
    -102t
    -46t
    -23t
    39t
    46t
    -101t
    0t
    48t
    -119t
    -69t
    73t
    9t
    -17t
    -27t
    79t
    -10t
    31t
    -99t
    63t
    -121t
    -24t
    115t
    -117t
    -83t
    65t
    88t
    109t
    -17t
    -30t
    29t
    -104t
    -36t
    -95t
    36t
    -18t
    101t
    -74t
    -8t
    21t
    90t
    -67t
  .end array-data
.end method

```

`dex-translator/src/test/resources/smalis/negative-array-size.smali`:

```smali
.class Li;
.super Ljava/lang/Object;

.method public getFileLength()I
  .catch Ljava/lang/Exception; { :L0 .. :L1 } :L2
  .catch Ljava/lang/Exception; { :L3 .. :L4 } :L5
  .registers 3
    const/4 v0, -1
  :L0
    new-array v1, v0, [I
  :L1
    goto :L0
  :L2
    move-exception v0
    const/4 v0, 0
    sput v0, Lz;->b:I
  :L3
    iget v0, p0, Lz;->b:I
  :L4
    return v0
  :L5
    move-exception v0
    throw v0
.end method

```

`dex-translator/src/test/resources/smalis/npe-cause-trap-fail.smali`:

```smali
.class Lnpe/cause/trap/fail;
.super Lb;

.method public final run()V
    .catch Ljava/lang/Exception; { :L0 .. :L1 } :L8
    .catch Ljava/lang/Exception; { :L4 .. :L5 } :L8
    .catch Ljava/lang/Exception; { :L5 .. :L6 } :L6
    .catch Ljava/lang/Exception; { :L7 .. :L8 } :L8
    .catch Ljava/lang/Exception; { :L9 .. :L10 } :L6
    .catch Ljava/lang/Exception; { :L11 .. :L12 } :L22
    .catch Ljava/lang/Exception; { :L13 .. :L14 } :L6
    .catch Ljava/lang/Exception; { :L15 .. :L16 } :L22
    .catch Ljava/lang/Exception; { :L18 .. :L21 } :L6
    .registers 8
    const/4 v6, 0
    iput-object v7, v7, Lcom/jcraft/jsch/e;->a:Ljava/lang/Runnable;
    :L0
    iget-object v0, v7, Lcom/jcraft/jsch/e;->a:Ljava/lang/Runnable;
    :L1
    if-nez v0, :L3
    :L2
    iput-object v6, v7, Lcom/jcraft/jsch/e;->a:Ljava/lang/Runnable;
    return-void
    :L3
    const/4 v0, 0
    :L4
    invoke-virtual { v0 }, Ljava/net/ServerSocket;->accept()Ljava/net/Socket;
    move-result-object v0
    const/4 v1, 1
    invoke-virtual { v0, v1 }, Ljava/net/Socket;->setTcpNoDelay(Z)V
    invoke-virtual { v0 }, Ljava/net/Socket;->getInputStream()Ljava/io/InputStream;
    move-result-object v1
    invoke-virtual { v0 }, Ljava/net/Socket;->getOutputStream()Ljava/io/OutputStream;
    move-result-object v2
    new-instance v3, Lcom/jcraft/jsch/v;
    invoke-direct { v3 }, Lcom/jcraft/jsch/v;-><init>()V
    invoke-virtual { v3 }, Lcom/jcraft/jsch/v;->a()V
    iget-object v4, v3, Lcom/jcraft/jsch/v;->a:Lcom/jcraft/jsch/ad;
    iput-object v1, v4, Lcom/jcraft/jsch/ad;->a:Ljava/io/InputStream;
    iget-object v1, v3, Lcom/jcraft/jsch/v;->a:Lcom/jcraft/jsch/ad;
    iput-object v2, v1, Lcom/jcraft/jsch/ad;->a:Ljava/io/OutputStream;
    const/4 v1, 0
    invoke-virtual { v1, v3 }, Lcom/jcraft/jsch/f;->a(Lcom/jcraft/jsch/ab;)V
    const/4 v1, 0
    iput-object v1, v3, Lcom/jcraft/jsch/v;->a:Ljava/lang/String;
    const/4 v1, 0
    iput v1, v3, Lcom/jcraft/jsch/v;->a:I
    invoke-virtual { v0 }, Ljava/net/Socket;->getInetAddress()Ljava/net/InetAddress;
    move-result-object v1
    invoke-virtual { v1 }, Ljava/net/InetAddress;->getHostAddress()Ljava/lang/String;
    move-result-object v1
    iput-object v1, v3, Lcom/jcraft/jsch/v;->b:Ljava/lang/String;
    invoke-virtual { v0 }, Ljava/net/Socket;->getPort()I
    move-result v0
    iput v0, v3, Lcom/jcraft/jsch/v;->b:I
    :L5
    invoke-virtual { v3 }, Lcom/jcraft/jsch/v;->a()Lcom/jcraft/jsch/f;
    move-result-object v1
    invoke-virtual { v1 }, Lcom/jcraft/jsch/f;->a()Z
    move-result v0
    if-nez v0, :L9
    new-instance v0, Lcom/jcraft/jsch/JSchException;
    const-string v1, "session is down"
    invoke-direct { v0, v1 }, Lcom/jcraft/jsch/JSchException;-><init>(Ljava/lang/String;)V
    throw v0
    :L6
    move-exception v0
    :L7
    iget-object v1, v3, Lcom/jcraft/jsch/v;->a:Lcom/jcraft/jsch/ad;
    invoke-virtual { v1 }, Lcom/jcraft/jsch/ad;->b()V
    const/4 v1, 0
    iput-object v1, v3, Lcom/jcraft/jsch/v;->a:Lcom/jcraft/jsch/ad;
    invoke-static { v3 }, Lcom/jcraft/jsch/ab;->a(Lcom/jcraft/jsch/ab;)V
    instance-of v1, v0, Lcom/jcraft/jsch/JSchException;
    if-eqz v1, :L0
    check-cast v0, Lcom/jcraft/jsch/JSchException;
    throw v0
    :L8
    move-exception v0
    goto :L2
    :L9
    new-instance v0, Lcom/jcraft/jsch/k;
    const/16 v2, 150
    invoke-direct { v0, v2 }, Lcom/jcraft/jsch/k;-><init>(I)V
    new-instance v2, Lcom/jcraft/jsch/i;
    invoke-direct { v2, v0 }, Lcom/jcraft/jsch/i;-><init>(Lcom/jcraft/jsch/k;)V
    invoke-virtual { v2 }, Lcom/jcraft/jsch/i;->a()V
    const/16 v4, 90
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->a(B)V
    const-string v4, "direct-tcpip"
    invoke-static { v4 }, Lcom/jcraft/jsch/q;->a(Ljava/lang/String;)[B
    move-result-object v4
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->b([B)V
    iget v4, v3, Lcom/jcraft/jsch/v;->c:I
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->a(I)V
    iget v4, v3, Lcom/jcraft/jsch/v;->f:I
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->a(I)V
    iget v4, v3, Lcom/jcraft/jsch/v;->g:I
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->a(I)V
    const/4 v4, 0
    invoke-static { v4 }, Lcom/jcraft/jsch/q;->a(Ljava/lang/String;)[B
    move-result-object v4
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->b([B)V
    const/4 v4, 0
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->a(I)V
    iget-object v4, v3, Lcom/jcraft/jsch/v;->b:Ljava/lang/String;
    invoke-static { v4 }, Lcom/jcraft/jsch/q;->a(Ljava/lang/String;)[B
    move-result-object v4
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->b([B)V
    iget v4, v3, Lcom/jcraft/jsch/v;->b:I
    invoke-virtual { v0, v4 }, Lcom/jcraft/jsch/k;->a(I)V
    invoke-virtual { v1, v2 }, Lcom/jcraft/jsch/f;->a(Lcom/jcraft/jsch/i;)V
    :L10
    const/16 v0, 1000
    :L11
    invoke-virtual { v3 }, Lcom/jcraft/jsch/v;->a()I
    move-result v2
    const/4 v4, -1
    if-ne v2, v4, :L13
    invoke-virtual { v1 }, Lcom/jcraft/jsch/f;->a()Z
    move-result v2
    if-eqz v2, :L13
    if-lez v0, :L13
    iget-boolean v2, v3, Lcom/jcraft/jsch/v;->a:Z
    :L12
    if-eqz v2, :L14
    :L13
    invoke-virtual { v1 }, Lcom/jcraft/jsch/f;->a()Z
    move-result v2
    if-nez v2, :L17
    new-instance v0, Lcom/jcraft/jsch/JSchException;
    const-string v1, "session is down"
    invoke-direct { v0, v1 }, Lcom/jcraft/jsch/JSchException;-><init>(Ljava/lang/String;)V
    throw v0
    :L14
    const-wide/16 v4, 50
    :L15
    invoke-static { v4, v5 }, Ljava/lang/Thread;->sleep(J)V
    :L16
    add-int/lit8 v0, v0, -1
    goto :L11
    :L17
    if-eqz v0, :L19
    :L18
    iget-boolean v0, v3, Lcom/jcraft/jsch/v;->a:Z
    if-eqz v0, :L20
    :L19
    new-instance v0, Lcom/jcraft/jsch/JSchException;
    const-string v1, "channel is not opened."
    invoke-direct { v0, v1 }, Lcom/jcraft/jsch/JSchException;-><init>(Ljava/lang/String;)V
    throw v0
    :L20
    const/4 v0, 1
    iput-boolean v0, v3, Lcom/jcraft/jsch/v;->c:Z
    iget-object v0, v3, Lcom/jcraft/jsch/v;->a:Lcom/jcraft/jsch/ad;
    iget-object v0, v0, Lcom/jcraft/jsch/ad;->a:Ljava/io/InputStream;
    if-eqz v0, :L0
    new-instance v0, Ljava/lang/Thread;
    invoke-direct { v0, v3 }, Ljava/lang/Thread;-><init>(Ljava/lang/Runnable;)V
    iput-object v0, v3, Lcom/jcraft/jsch/v;->a:Ljava/lang/Thread;
    iget-object v0, v3, Lcom/jcraft/jsch/v;->a:Ljava/lang/Thread;
    new-instance v2, Ljava/lang/StringBuilder;
    const-string v4, "DirectTCPIP thread "
    invoke-direct { v2, v4 }, Ljava/lang/StringBuilder;-><init>(Ljava/lang/String;)V
    invoke-virtual { v1 }, Lcom/jcraft/jsch/f;->a()Ljava/lang/String;
    move-result-object v1
    invoke-virtual { v2, v1 }, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v1
    invoke-virtual { v1 }, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v1
    invoke-virtual { v0, v1 }, Ljava/lang/Thread;->setName(Ljava/lang/String;)V
    iget-object v0, v3, Lcom/jcraft/jsch/v;->a:Ljava/lang/Thread;
    invoke-virtual { v0 }, Ljava/lang/Thread;->start()V
    :L21
    goto/16 :L0
    :L22
    move-exception v2
    goto :L13
.end method

```

`dex-translator/src/test/resources/smalis/opt-lock.smali`:

```smali
.class Lopt/lock;
.super Ljava/lang/Object;
.method public static a()V
    .catchall { :L0 .. :L1 } :L2
    .registers 2
    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
    :L0
    monitor-enter v0
    const-string v1, "haha"
    invoke-virtual { v0, v1 }, Ljava/io/PrintString;->println(Ljava/lang/String;)V
    :L1
    monitor-exit v0
    return-void
    :L2
    move-exception v1
    monitor-exit v0
    throw v1
.end method

```

`dex-translator/src/test/resources/smalis/useless-new.smali`:

```smali
.class Luseless/new;
.super Ljava/lang/Object;
.method public onCreate1(Landroid/os/Bundle;)V
    .registers 7
    const/4 v4, -2
    const/4 v3, 1
    const/4 v2, 0
    invoke-super { v5, v6 }, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V
    const v0, 2130903050
    invoke-virtual { v5, v0 }, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->setContentView(I)V
    new-instance v0, Landroid/widget/LinearLayout;
    invoke-direct { v0, v5 }, Landroid/widget/LinearLayout;-><init>(Landroid/content/Context;)V
    iput-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->container:Landroid/widget/LinearLayout;
    move-result-object v0
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->PREFS_NAME:Ljava/lang/String;
    invoke-virtual { v5, v0, v2 }, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->getSharedPreferences(Ljava/lang/String;I)Landroid/content/SharedPreferences;
    move-result-object v0
    iput-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->settings:Landroid/content/SharedPreferences;
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->settings:Landroid/content/SharedPreferences;
    const-string v1, "times"
    invoke-interface { v0, v1, v2 }, Landroid/content/SharedPreferences;->getBoolean(Ljava/lang/String;Z)Z
    move-result v0
    iput-boolean v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->times:Z
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->settings:Landroid/content/SharedPreferences;
    const-string v1, "jump"
    invoke-interface { v0, v1, v2 }, Landroid/content/SharedPreferences;->getBoolean(Ljava/lang/String;Z)Z
    move-result v0
    iput-boolean v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->removeadv:Z
    invoke-static { v5 }, Lcom/mobclick/android/MobclickAgent;->updateOnlineConfig(Landroid/content/Context;)V
    invoke-static { v2 }, Lcom/mobclick/android/MobclickAgent;->setUpdateOnlyWifi(Z)V
    invoke-direct { v5 }, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->se()V
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->a:Ljava/lang/String;
    const-string v1, "f90c2179e4ea7fb0531a1182b2ab90aa"
    invoke-virtual { v0, v1 }, Ljava/lang/String;->equals(Ljava/lang/Object;)Z
    move-result v0
    if-nez v0, :L0
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->pointsTextView:Landroid/widget/TextView;
    const/16 v1, 111
    invoke-virtual { v0, v1 }, Landroid/widget/TextView;->setText(I)V
    :L0
    iget-boolean v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->removeadv:Z
    if-nez v0, :L2
    invoke-virtual { v5 }, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->getApplicationContext()Landroid/content/Context;
    move-result-object v0
    const-string v1, "window"
    invoke-virtual { v0, v1 }, Landroid/content/Context;->getSystemService(Ljava/lang/String;)Ljava/lang/Object;
    move-result-object v0
    check-cast v0, Landroid/view/WindowManager;
    iput-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wm:Landroid/view/WindowManager;
    new-instance v0, Landroid/view/WindowManager$LayoutParams;
    invoke-direct { v0 }, Landroid/view/WindowManager$LayoutParams;-><init>()V
    iput-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    const/16 v1, 2003
    iput v1, v0, Landroid/view/WindowManager$LayoutParams;->type:I
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    iput v3, v0, Landroid/view/WindowManager$LayoutParams;->format:I
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    const/16 v1, 40
    iput v1, v0, Landroid/view/WindowManager$LayoutParams;->flags:I
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    iput v4, v0, Landroid/view/WindowManager$LayoutParams;->width:I
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    iput v2, v0, Landroid/view/WindowManager$LayoutParams;->x:I
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    iput v2, v0, Landroid/view/WindowManager$LayoutParams;->y:I
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    iput v4, v0, Landroid/view/WindowManager$LayoutParams;->height:I
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    const/16 v1, 49
    iput v1, v0, Landroid/view/WindowManager$LayoutParams;->gravity:I
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wm:Landroid/view/WindowManager;
    iget-object v1, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->container:Landroid/widget/LinearLayout;
    iget-object v2, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->wmParams:Landroid/view/WindowManager$LayoutParams;
    invoke-interface { v0, v1, v2 }, Landroid/view/WindowManager;->addView(Landroid/view/View;Landroid/view/ViewGroup$LayoutParams;)V
    new-instance v0, Ljava/lang/Object;
    iget-object v1, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->container:Landroid/widget/LinearLayout;
    const/16 v1, 30
    iput-boolean v3, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->Badview:Z
    :L1
    new-instance v0, Lcom/adroidbscpc/a15mSurvival3rh/MainA$ContThread;
    invoke-direct { v0, v5 }, Lcom/adroidbscpc/a15mSurvival3rh/MainA$ContThread;-><init>(Lcom/adroidbscpc/a15mSurvival3rh/MainA;)V
    iput-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->conthred:Ljava/lang/Thread;
    iget-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->conthred:Ljava/lang/Thread;
    invoke-virtual { v0 }, Ljava/lang/Thread;->start()V
    new-instance v0, Lcom/adroidbscpc/a15mSurvival3rh/MainA$1;
    invoke-direct { v0, v5 }, Lcom/adroidbscpc/a15mSurvival3rh/MainA$1;-><init>(Lcom/adroidbscpc/a15mSurvival3rh/MainA;)V
    iput-object v0, v5, Lcom/adroidbscpc/a15mSurvival3rh/MainA;->mainHandler:Landroid/os/Handler;
    return-void
    :L2
    invoke-static { v5 }, Lcom/cooguo/advideo/VideoAdsManager;->getInstance(Landroid/content/Context;)Lcom/cooguo/advideo/VideoAdsManager;
    move-result-object v0
    invoke-virtual { v0, v3 }, Lcom/cooguo/advideo/VideoAdsManager;->receiveVideoAd(I)V
    move-result-object v0
    invoke-static { }, Lcom/kuguo/ad/KuguoAdsManager;->getInstance()Lcom/kuguo/ad/KuguoAdsManager;
    move-result-object v0
    invoke-virtual { v0, v5, v3 }, Lcom/kuguo/ad/KuguoAdsManager;->receivePushMessage(Landroid/content/Context;Z)V
    goto :L1
.end method

.method private static setAdmobAdView(Landroid/content/Context;Landroid/view/ViewGroup;Landroid/view/ViewGroup$LayoutParams;)V
    .registers 5
    new-instance v0, Ljava/lang/Object;
    const/4 v1, 0
    const v1, 16777215
    const/4 v1, -1
    const v1, -3355444
    const-string v1, "android game arcade action casual application"
    const/16 v1, 15
    new-instance v1, Lorg/collcode/xrlophone/AdManager$1;
    invoke-virtual { v3, v0, v4 }, Landroid/view/ViewGroup;->addView(Landroid/view/View;Landroid/view/ViewGroup$LayoutParams;)V
    return-void
.end method

```

`dex-translator/src/test/resources/smalis/writeString.smali`:

```smali
.class LDD;
.super Lee;
.method writeString(Ljava/lang/String;[BIZ)I
    .catch Ljava/io/UnsupportedEncodingException; { :L0 .. :L1 } :L14
    .catch Ljava/io/UnsupportedEncodingException; { :L2 .. :L3 } :L16
    .catch Ljava/io/UnsupportedEncodingException; { :L4 .. :L5 } :L14
    .catch Ljava/io/UnsupportedEncodingException; { :L6 .. :L7 } :L16
    .catch Ljava/io/UnsupportedEncodingException; { :L8 .. :L11 } :L14
    .catch Ljava/io/UnsupportedEncodingException; { :L12 .. :L13 } :L16
    .registers 12
    move v2, v10
    if-eqz v11, :L10
    :L0
    iget v4, v7, Ljcifs/smb/ServerMessageBlock;->headerStart:I
    sub-int v4, v10, v4
    rem-int/lit8 v4, v4, 2
    :L1
    if-eqz v4, :L4
    add-int/lit8 v1, v10, 1
    const/4 v4, 0
    :L2
    aput-byte v4, v9, v10
    :L3
    move v10, v1
    :L4
    const-string v4, "UTF-16LE"
    invoke-virtual { v8, v4 }, Ljava/lang/String;->getBytes(Ljava/lang/String;)[B
    move-result-object v4
    const/4 v5, 0
    invoke-virtual { v8 }, Ljava/lang/String;->length()I
    move-result v6
    mul-int/lit8 v6, v6, 2
    invoke-static { v4, v5, v9, v10, v6 }, Ljava/lang/System;->arraycopy(Ljava/lang/Object;ILjava/lang/Object;II)V
    invoke-virtual { v8 }, Ljava/lang/String;->length()I
    :L5
    move-result v4
    mul-int/lit8 v4, v4, 2
    add-int/2addr v10, v4
    add-int/lit8 v1, v10, 1
    const/4 v4, 0
    :L6
    aput-byte v4, v9, v10
    :L7
    add-int/lit8 v10, v1, 1
    const/4 v4, 0
    :L8
    aput-byte v4, v9, v1
    :L9
    sub-int v4, v10, v2
    return v4
    :L10
    sget-object v4, Ljcifs/smb/SmbConstants;->OEM_ENCODING:Ljava/lang/String;
    invoke-virtual { v8, v4 }, Ljava/lang/String;->getBytes(Ljava/lang/String;)[B
    move-result-object v0
    const/4 v4, 0
    array-length v5, v0
    invoke-static { v0, v4, v9, v10, v5 }, Ljava/lang/System;->arraycopy(Ljava/lang/Object;ILjava/lang/Object;II)V
    array-length v4, v0
    :L11
    add-int/2addr v10, v4
    add-int/lit8 v1, v10, 1
    const/4 v4, 0
    :L12
    aput-byte v4, v9, v10
    :L13
    move v10, v1
    goto :L9
    :L14
    move-exception v4
    move-object v3, v4
    :L15
    sget-object v4, Ljcifs/smb/ServerMessageBlock;->log:Ljcifs/util/LogStream;
    sget v4, Ljcifs/util/LogStream;->level:I
    const/4 v5, 1
    if-le v4, v5, :L9
    sget-object v4, Ljcifs/smb/ServerMessageBlock;->log:Ljcifs/util/LogStream;
    invoke-virtual { v3, v4 }, Ljava/io/UnsupportedEncodingException;->printStackTrace(Ljava/io/PrintStream;)V
    goto :L9
    :L16
    move-exception v4
    move-object v3, v4
    move v10, v1
    goto :L15
.end method

```

`dex-writer/build.gradle`:

```gradle
description = 'Dex Writer'

dependencies {
    compile project(':dex-reader-api')
    testCompile group: 'junit', name: 'junit', version:'4.10'
    testCompile project(':dex-reader')
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/AnnotationWriter.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer;

import com.googlecode.d2j.DexType;
import com.googlecode.d2j.dex.writer.ev.EncodedAnnotation;
import com.googlecode.d2j.dex.writer.ev.EncodedAnnotation.AnnotationElement;
import com.googlecode.d2j.dex.writer.ev.EncodedArray;
import com.googlecode.d2j.dex.writer.ev.EncodedValue;
import com.googlecode.d2j.dex.writer.item.ConstPool;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;

import java.util.List;

/*package*/class AnnotationWriter extends DexAnnotationVisitor {
    ConstPool cp;
    List<AnnotationElement> elements;

    public AnnotationWriter(List<AnnotationElement> elements, ConstPool cp) {
        this.elements = elements;
        this.cp = cp;
    }

    AnnotationElement newAnnotationElement(String name) {
        AnnotationElement ae = new AnnotationElement();
        ae.name = cp.uniqString(name);
        elements.add(ae);
        return ae;
    }

    // int,int long
    public void visit(String name, Object value) {
        if (value instanceof Object[]) {
            DexAnnotationVisitor s = visitArray(name);
            if (s != null) {
                for (Object v : (Object[]) value) {
                    s.visit(null, v);
                }
                s.visitEnd();
            }
        } else {
            AnnotationElement ae = newAnnotationElement(name);
            ae.value = EncodedValue.wrap(cp.wrapEncodedItem(value));
        }
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name, String desc) {
        EncodedValue encodedValue;
        EncodedAnnotation encodedAnnotation = new EncodedAnnotation();
        encodedAnnotation.type = cp.uniqType(desc);
        encodedValue = new EncodedValue(EncodedValue.VALUE_ANNOTATION,
                encodedAnnotation);
        AnnotationElement ae = newAnnotationElement(name);
        ae.value = encodedValue;
        return new AnnotationWriter(encodedAnnotation.elements, cp);
    }

    @Override
    public DexAnnotationVisitor visitArray(String name) {
        AnnotationElement ae = newAnnotationElement(name);
        final EncodedArray encodedArray = new EncodedArray();
        ae.value = new EncodedValue(EncodedValue.VALUE_ARRAY, encodedArray);
        return new EncodedArrayAnnWriter(encodedArray);
    }

    @Override
    public void visitEnum(String name, String fower, String fname) {
        AnnotationElement ae = newAnnotationElement(name);
        ae.value = new EncodedValue(EncodedValue.VALUE_ENUM, cp.uniqField(
                fower, fname, fower));
    }

    class EncodedArrayAnnWriter extends DexAnnotationVisitor {
        final EncodedArray encodedArray;

        public EncodedArrayAnnWriter(EncodedArray encodedArray) {
            super();
            this.encodedArray = encodedArray;
        }

        @Override
        public void visit(String name, Object value) {
            EncodedValue encodedValue;
            if (value instanceof String) {
                encodedValue = new EncodedValue(EncodedValue.VALUE_STRING,
                        cp.uniqString((String) value));
            } else if (value instanceof DexType) {
                encodedValue = new EncodedValue(EncodedValue.VALUE_TYPE,
                        cp.uniqType(((DexType) value).desc));
            } else {
                encodedValue = EncodedValue.wrap(value);
            }
            encodedArray.values.add(encodedValue);
        }

        @Override
        public DexAnnotationVisitor visitAnnotation(String name, String desc) {
            EncodedValue encodedValue;
            EncodedAnnotation encodedAnnotation = new EncodedAnnotation();
            encodedAnnotation.type = cp.uniqType(desc);
            encodedValue = new EncodedValue(EncodedValue.VALUE_ANNOTATION,
                    encodedAnnotation);
            encodedArray.values.add(encodedValue);
            return new AnnotationWriter(encodedAnnotation.elements, cp);
        }

        @Override
        public DexAnnotationVisitor visitArray(String name) {
            EncodedValue encodedValue;
            encodedValue = new EncodedValue(EncodedValue.VALUE_ARRAY,
                    encodedArray);
            encodedArray.values.add(encodedValue);
            return new EncodedArrayAnnWriter(encodedArray);
        }

        @Override
        public void visitEnum(String name, String fower, String fname) {
            EncodedValue encodedValue;
            encodedValue = new EncodedValue(EncodedValue.VALUE_ENUM,
                    cp.uniqField(fower, fname, fower));
            encodedArray.values.add(encodedValue);
        }

    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/CantNotFixContentException.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer;

import com.googlecode.d2j.reader.Op;

public class CantNotFixContentException extends RuntimeException {

    private static final long serialVersionUID = -3939621228619424486L;

    public CantNotFixContentException(Op op, String contentName, int v) {
        super(String.format("content is not fit for op: %s, %s, value:0x%x",
                op.displayName, contentName, v));
    }

    public CantNotFixContentException(Op op, String contentName, long v) {
        super(String.format("content is not fit for op: %s, %s, value:0x%x",
                op.displayName, contentName, v));
    }
}
```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/ClassWriter.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.dex.writer.ev.EncodedValue;
import com.googlecode.d2j.dex.writer.item.*;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexFieldVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

/*package*/class ClassWriter extends DexClassVisitor implements DexConstants {

    final public ConstPool cp;
    public ClassDefItem defItem;
    ClassDataItem dataItem = new ClassDataItem();

    public ClassWriter(ClassDefItem defItem, ConstPool cp) {
        super();
        this.defItem = defItem;
        this.cp = cp;
    }

    @Override
    public AnnotationWriter visitAnnotation(String type, Visibility visibility) {
        final AnnotationItem annItem = new AnnotationItem(cp.uniqType(type),
                visibility);
        AnnotationSetItem asi = defItem.classAnnotations;
        if (asi == null) {
            asi = new AnnotationSetItem();
            defItem.classAnnotations = asi;
        }
        asi.annotations.add(annItem);
        return new AnnotationWriter(annItem.annotation.elements, cp);
    }

    public void visitEnd() {
        if (dataItem != null && dataItem.getMemberSize() > 0) {
            cp.addClassDataItem(dataItem);
            defItem.classData = dataItem;
        }
        defItem.prepare(cp);

    }

    @Override
    public DexFieldVisitor visitField(int accessFlags, Field field, Object value) {
        final ClassDataItem.EncodedField encodedField = new ClassDataItem.EncodedField();
        encodedField.accessFlags = accessFlags;
        encodedField.field = cp.uniqField(field);
        if (value != null) {
            encodedField.staticValue = EncodedValue.wrap(cp.wrapEncodedItem(value));
        }
        if (0 != (ACC_STATIC & accessFlags)) { // is static
            dataItem.staticFields.add(encodedField);
        } else {
            dataItem.instanceFields.add(encodedField);
        }

        return new FieldWriter(encodedField, cp);
    }

    @Override
    public DexMethodVisitor visitMethod(int accessFlags, Method method) {
        final ClassDataItem.EncodedMethod encodedMethod = new ClassDataItem.EncodedMethod();
        encodedMethod.accessFlags = accessFlags;
        encodedMethod.method = cp.uniqMethod(method);
        if (0 != (accessFlags & (ACC_STATIC | ACC_PRIVATE | ACC_CONSTRUCTOR))) {
            dataItem.directMethods.add(encodedMethod);
        } else {
            dataItem.virtualMethods.add(encodedMethod);
        }

        return new MethodWriter(encodedMethod, method,
                0 != (accessFlags & ACC_STATIC), cp);
    }

    @Override
    public void visitSource(String file) {
        defItem.sourceFile = cp.uniqString(file);
    }

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/CodeWriter.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer;

import com.googlecode.d2j.CallSite;
import com.googlecode.d2j.DexLabel;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.dex.writer.insn.*;
import com.googlecode.d2j.dex.writer.item.*;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexDebugVisitor;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.*;

import static com.googlecode.d2j.reader.InstructionFormat.*;
import static com.googlecode.d2j.reader.Op.*;

@SuppressWarnings("incomplete-switch")
public class CodeWriter extends DexCodeVisitor {
    final CodeItem codeItem;
    final ConstPool cp;
    ByteBuffer b = ByteBuffer.allocate(10).order(ByteOrder.LITTLE_ENDIAN);
    int in_reg_size = 0;
    int max_out_reg_size = 0;
    List<Insn> ops = new ArrayList<>();
    List<Insn> tailOps = new ArrayList<>();
    int total_reg;
    List<CodeItem.TryItem> tryItems = new ArrayList<>();
    Method owner;
    Map<DexLabel, Label> labelMap = new HashMap<>();
    ClassDataItem.EncodedMethod encodedMethod;

    public CodeWriter(ClassDataItem.EncodedMethod encodedMethod, CodeItem codeItem, Method owner, boolean isStatic, ConstPool cp) {
        this.encodedMethod = encodedMethod;
        this.codeItem = codeItem;
        this.owner = owner;
        int in_reg_size = 0;
        if (!isStatic) {
            in_reg_size++;
        }
        for (String s : owner.getParameterTypes()) {
            switch (s.charAt(0)) {
            case 'J':
            case 'D':
                in_reg_size += 2;
                break;
            default:
                in_reg_size++;
                break;
            }
        }
        this.in_reg_size = in_reg_size;
        this.cp = cp;
    }

    public static void checkContentByte(Op op, String cc, int v) {
        if (v > Byte.MAX_VALUE || v < Byte.MIN_VALUE) {
            throw new CantNotFixContentException(op, cc, v);
        }
    }

    public static void checkContentS4bit(Op op, String name, int v) {
        if (v > 7 || v < -8) { // TODO check
            throw new CantNotFixContentException(op, name, v);
        }
    }

    public static void checkContentShort(Op op, String cccc, int v) {
        if (v > Short.MAX_VALUE || v < Short.MIN_VALUE) {
            throw new CantNotFixContentException(op, cccc, v);
        }
    }

    public static void checkContentU4bit(Op op, String name, int v) {
        if (v > 15 || v < 0) {
            throw new CantNotFixContentException(op, name, v);
        }
    }

    public static void checkContentUByte(Op op, String cc, int v) {
        if (v > 0xFF || v < 0) {
            throw new CantNotFixContentException(op, cc, v);
        }
    }

    public static void checkContentUShort(Op op, String cccc, int v) {
        if (v > 0xFFFF || v < 0) {
            throw new CantNotFixContentException(op, cccc, v);
        }
    }

    public static void checkRegA(Op op, String s, int reg) {
        if (reg > 0xF || reg < 0) {
            throw new CantNotFixContentException(op, s, reg);
        }
    }

    public static void checkRegAA(Op op, String s, int reg) {
        if (reg > 0xFF || reg < 0) {
            throw new CantNotFixContentException(op, s, reg);
        }
    }

    static void checkRegAAAA(Op op, String s, int reg) {
        if (reg > 0xFFFF || reg < 0) {
            throw new CantNotFixContentException(op, s, reg);
        }
    }

    static byte[] copy(ByteBuffer b) {
        int size = b.position();
        byte[] data = new byte[size];
        System.arraycopy(b.array(), 0, data, 0, size);
        return data;
    }

    public void add(Insn insn) {
        ops.add(insn);
    }

    private byte[] build10x(Op op) {
        b.position(0);
        b.put((byte) op.opcode).put((byte) 0);

        return copy(b);
    }

    // B|A|op
    private byte[] build11n(Op op, int vA, int B) {
        checkRegA(op, "vA", vA);
        checkContentS4bit(op, "#+B", B);
        b.position(0);
        b.put((byte) op.opcode).put((byte) ((vA & 0xF) | (B << 4)));
        return copy(b);
    }

    // AA|op
    private byte[] build11x(Op op, int vAA) {
        checkRegAA(op, "vAA", vAA);
        b.position(0);
        b.put((byte) op.opcode).put((byte) vAA);

        return copy(b);
    }

    // B|A|op
    private byte[] build12x(Op op, int vA, int vB) {
        checkRegA(op, "vA", vA);
        checkRegA(op, "vB", vB);
        b.position(0);
        b.put((byte) op.opcode).put((byte) ((vA & 0xF) | (vB << 4)));

        return copy(b);
    }

    // AA|op BBBB
    private byte[] build21h(Op op, int vAA, Number value) {
        checkRegAA(op, "vAA", vAA);
        int realV;
        if (op == CONST_HIGH16) { // op vAA, #+BBBB0000
            int v = ((Number) value).intValue();
            if ((v & 0xFFFF) != 0) {
                throw new CantNotFixContentException(op, "#+BBBB0000", v);
            }
            realV = v >> 16;

        } else { // CONST_WIDE_HIGH16 //op vAA, #+BBBB000000000000
            long v = ((Number) value).longValue();
            if ((v & 0x0000FFFFffffFFFFL) != 0) {
                throw new CantNotFixContentException(op, "#+BBBB000000000000", v);
            }
            realV = (int) (v >> 48);
        }
        b.position(0);
        b.put((byte) op.opcode).put((byte) vAA).putShort((short) realV);
        return copy(b);
    }

    // AA|op BBBB
    private byte[] build21s(Op op, int vAA, Number value) {
        checkRegAA(op, "vAA", vAA);
        int realV;
        if (op == CONST_16) {
            realV = value.intValue();
            checkContentShort(op, "#+BBBB", realV);
        } else {// CONST_WIDE_16
            long v = value.longValue();
            if (v > Short.MAX_VALUE || v < Short.MIN_VALUE) {
                throw new CantNotFixContentException(op, "#+BBBB", v);
            }
            realV = (int) v;
        }
        b.position(0);
        b.put((byte) op.opcode).put((byte) vAA).putShort((short) realV);
        return copy(b);
    }

    // AA|op CC|BB
    private byte[] build22b(Op op, int vAA, int vBB, int cc) {
        checkRegAA(op, "vAA", vAA);
        checkRegAA(op, "vBB", vBB);
        checkContentByte(op, "#+CC", cc);

        b.position(0);
        b.put((byte) op.opcode).put((byte) vAA).put((byte) vBB).put((byte) cc);
        return copy(b);
    }

    // B|A|op CCCC
    private byte[] build22s(Op op, int A, int B, int CCCC) {
        checkRegA(op, "vA", A);
        checkRegA(op, "vB", B);
        checkContentShort(op, "+CCCC", CCCC);

        b.position(0);
        b.put((byte) op.opcode).put((byte) ((A & 0xF) | (B << 4))).putShort((short) CCCC);
        return copy(b);
    }

    // AA|op BBBB
    private byte[] build22x(Op op, int vAA, int vBBBB) {
        checkRegAA(op, "vAA", vAA);
        checkRegAAAA(op, "vBBBB", vBBBB);
        b.position(0);
        b.put((byte) op.opcode).put((byte) vAA).putShort((short) vBBBB);
        return copy(b);
    }

    // AA|op CC|BB
    private byte[] build23x(Op op, int vAA, int vBB, int vCC) {
        checkRegAA(op, "vAA", vAA);
        checkRegAA(op, "vBB", vBB);
        checkRegAA(op, "vCC", vCC);
        b.position(0);
        b.put((byte) op.opcode).put((byte) vAA).put((byte) vBB).put((byte) vCC);
        return copy(b);
    }

    // AA|op BBBBlo BBBBhi
    private byte[] build31i(Op op, int vAA, Number value) {
        checkRegAA(op, "vAA", vAA);
        int realV;
        if (op == CONST) {
            realV = value.intValue();
        } else if (op == CONST_WIDE_32) {
            long v = value.longValue();
            if (v > Integer.MAX_VALUE || v < Integer.MIN_VALUE) {
                throw new CantNotFixContentException(op, "#+BBBBBBBB", v);
            }
            realV = (int) v;
        } else {
            throw new RuntimeException();
        }
        b.position(0);
        b.put((byte) op.opcode).put((byte) vAA).putInt(realV);
        return copy(b);
    }

    // ØØ|op AAAA BBBB
    private byte[] build32x(Op op, int vAAAA, int vBBBB) {
        checkRegAAAA(op, "vAAAA", vAAAA);
        checkRegAAAA(op, "vBBBB", vBBBB);
        b.position(0);
        b.put((byte) op.opcode).put((byte) 0).putShort((short) vAAAA).putShort((short) vBBBB);
        return copy(b);
    }

    // AA|op BBBBlo BBBB BBBB BBBBhi
    private byte[] build51l(Op op, int vAA, Number value) {
        checkRegAA(op, "vAA", vAA);

        b.position(0);
        b.put((byte) op.opcode).put((byte) vAA).putLong(value.longValue());
        return copy(b);

    }

    Label getLabel(DexLabel label) {
        Label mapped = labelMap.get(label);
        if (mapped == null) {
            mapped = new Label();
            labelMap.put(label, mapped);
        }
        return mapped;
    }

    @Override
    public void visitFillArrayDataStmt(Op op, int ra, Object value) {

        ByteBuffer b;

        if (value instanceof byte[]) {
            byte[] data = (byte[]) value;
            int size = data.length;
            int element_width = 1;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            b.put(data);
        } else if (value instanceof short[]) {
            short[] data = (short[]) value;
            int size = data.length;
            int element_width = 2;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (short s : data) {
                b.putShort(s);
            }
        } else if (value instanceof int[]) {
            int[] data = (int[]) value;
            int size = data.length;
            int element_width = 4;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (int s : data) {
                b.putInt(s);
            }
        } else if (value instanceof float[]) {
            float[] data = (float[]) value;
            int size = data.length;
            int element_width = 4;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (float s : data) {
                b.putInt(Float.floatToIntBits(s));
            }
        } else if (value instanceof long[]) {
            long[] data = (long[]) value;
            int size = data.length;
            int element_width = 8;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (long s : data) {
                b.putLong(s);
            }
        } else if (value instanceof double[]) {
            double[] data = (double[]) value;
            int size = data.length;
            int element_width = 8;
            b = ByteBuffer.allocate(((size * element_width + 1) / 2 + 4) * 2).order(ByteOrder.LITTLE_ENDIAN);
            b.putShort((short) 0x0300);
            b.putShort((short) element_width);
            b.putInt(size);
            for (double s : data) {
                b.putLong(Double.doubleToLongBits(s));
            }
        } else {
            throw new RuntimeException();
        }
        Label d = new Label();
        ops.add(new JumpOp(op, ra, 0, d));

        tailOps.add(d);
        tailOps.add(new PreBuildInsn(b.array()));

    }

    /**
     * kFmt21c,kFmt31c,kFmt11n,kFmt21h,kFmt21s,kFmt31i,kFmt51l
     * 
     * @param op
     * @param ra
     * @param value
     */
    @Override
    public void visitConstStmt(Op op, int ra, Object value) {
        if (op == CONST_METHOD_HANDLE || op == CONST_METHOD_TYPE) {
            cp.dex039();
        }
        switch (op.format) {
        case kFmt21c:// value is field,type,string,method_handle,proto
        case kFmt31c:// value is string,
            value = cp.wrapEncodedItem(value);
            ops.add(new CodeWriter.IndexedInsn(op, ra, 0, (BaseItem) value));
            break;
        case kFmt11n:
            ops.add(new PreBuildInsn(build11n(op, ra, ((Number) value).intValue())));
            break;
        case kFmt21h:
            ops.add(new PreBuildInsn(build21h(op, ra, ((Number) value))));
            break;
        case kFmt21s:
            ops.add(new PreBuildInsn(build21s(op, ra, ((Number) value))));
            break;
        case kFmt31i:
            ops.add(new PreBuildInsn(build31i(op, ra, ((Number) value))));
            break;
        case kFmt51l:
            ops.add(new PreBuildInsn(build51l(op, ra, ((Number) value))));
            break;

        }
    }

    @Override
    public void visitEnd() {
        if (ops.size() == 0 && tailOps.size() == 0) {
            encodedMethod.code = null;
            return;
        }
        cp.addCodeItem(codeItem);

        codeItem.registersSize = this.total_reg;
        codeItem.outsSize = max_out_reg_size;
        codeItem.insSize = in_reg_size;

        codeItem.init(ops, tailOps, tryItems);

        if (codeItem.debugInfo != null) {
            cp.addDebugInfoItem(codeItem.debugInfo);
            List<DebugInfoItem.DNode> debugNodes = codeItem.debugInfo.debugNodes;
            Collections.sort(debugNodes, new Comparator<DebugInfoItem.DNode>() {
                @Override
                public int compare(DebugInfoItem.DNode o1, DebugInfoItem.DNode o2) {
                    int x = o1.label.offset - o2.label.offset;
                    // if (x == 0) {
                    // if (o1.op == o2.op) {
                    // x = o1.reg - o2.reg;
                    // if (x == 0) {
                    // x = o1.line - o2.line;
                    // }
                    // } else {
                    // //
                    // }
                    // }
                    return x;
                }
            });
        }

        ops = null;
        tailOps = null;
        tryItems = null;

    }

    @Override
    public void visitFieldStmt(Op op, int a, int b, Field field) {
        ops.add(new CodeWriter.IndexedInsn(op, a, b, cp.uniqField(field)));
    }

    @Override
    public void visitFilledNewArrayStmt(Op op, int[] args, String type) {
        if (op.format == kFmt35c) {
            ops.add(new CodeWriter.OP35c(op, args, cp.uniqType(type)));
        } else {
            ops.add(new CodeWriter.OP3rc(op, args, cp.uniqType(type)));
        }
    }

    @Override
    public void visitJumpStmt(Op op, int a, int b, DexLabel label) {

        ops.add(new JumpOp(op, a, b, getLabel(label)));
    }

    @Override
    public void visitLabel(DexLabel label) {
        ops.add(getLabel(label));
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, Method method) {
        if (op.format == kFmt3rc) {
            ops.add(new CodeWriter.OP3rc(op, args, cp.uniqMethod(method)));
        } else if (op.format == kFmt35c) {
            ops.add(new CodeWriter.OP35c(op, args, cp.uniqMethod(method)));
        }
        if (args.length > max_out_reg_size) {
            max_out_reg_size = args.length;
        }
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, CallSite callSite) {
        cp.dex038();
        if (op.format == kFmt3rc) {
            ops.add(new CodeWriter.OP3rc(op, args, cp.uniqCallSite(callSite)));
        } else if (op.format == kFmt35c) {
            ops.add(new CodeWriter.OP35c(op, args, cp.uniqCallSite(callSite)));
        }
        if (args.length > max_out_reg_size) {
            max_out_reg_size = args.length;
        }
    }

    @Override
    public void visitMethodStmt(Op op, int[] args, Method bsm, Proto proto) {
        cp.dex038();
        if (op.format == kFmt4rcc) {
            ops.add(new CodeWriter.OP4rcc(op, args, cp.uniqMethod(bsm), cp.uniqProto(proto)));
        } else if (op.format == kFmt45cc) {
            ops.add(new CodeWriter.OP45cc(op, args, cp.uniqMethod(bsm), cp.uniqProto(proto)));
        }

        if (args.length > max_out_reg_size) {
            max_out_reg_size = args.length;
        }
    }

    @Override
    public void visitPackedSwitchStmt(Op op, int aA, final int first_case, final DexLabel[] labels) {
        Label switch_data_location = new Label();
        final JumpOp jumpOp = new JumpOp(op, aA, 0, switch_data_location);
        ops.add(jumpOp);

        tailOps.add(switch_data_location);
        tailOps.add(new Insn() {

            @Override
            public int getCodeUnitSize() {
                return (labels.length * 2) + 4;
            }

            @Override
            public void write(ByteBuffer out) {
                out.putShort((short) 0x0100).putShort((short) labels.length).putInt(first_case);

                for (int i = 0; i < labels.length; i++) {
                    out.putInt(getLabel(labels[i]).offset - jumpOp.offset);
                }
            }
        });
    }

    @Override
    public void visitRegister(int total) {
        this.total_reg = total;
    }

    @Override
    public void visitSparseSwitchStmt(Op op, int ra, final int[] cases, final DexLabel[] labels) {
        Label switch_data_location = new Label();
        final JumpOp jumpOp = new JumpOp(op, ra, 0, switch_data_location);
        ops.add(jumpOp);

        tailOps.add(switch_data_location);
        tailOps.add(new Insn() {

            @Override
            public int getCodeUnitSize() {
                return (cases.length * 4) + 2;
            }

            @Override
            public void write(ByteBuffer out) {
                out.putShort((short) 0x0200).putShort((short) cases.length);
                for (int i = 0; i < cases.length; i++) {
                    out.putInt(cases[i]);
                }
                for (int i = 0; i < cases.length; i++) {
                    out.putInt(getLabel(labels[i]).offset - jumpOp.offset);
                }
            }
        });

    }

    @Override
    public void visitStmt0R(Op op) {
        if (op == BAD_OP) {
            // TODO check
        } else {
            if (op.format == kFmt10x) {
                ops.add(new PreBuildInsn(build10x(op)));
            } else {
                // FIXME error
            }
        }
    }

    /**
     * kFmt11x
     * 
     * @param op
     * @param reg
     */
    @Override
    public void visitStmt1R(Op op, int reg) {
        if (op.format == kFmt11x) {
            ops.add(new PreBuildInsn(build11x(op, reg)));
        } else {
        }
    }

    /**
     * kFmt12x,kFmt22x,kFmt32x
     * 
     * @param op
     * @param a
     * @param b
     */
    @Override
    public void visitStmt2R(Op op, int a, int b) {
        switch (op.format) {
        case kFmt12x:
            ops.add(new PreBuildInsn(build12x(op, a, b)));
            break;
        case kFmt22x:
            ops.add(new PreBuildInsn(build22x(op, a, b)));
            break;
        case kFmt32x:
            ops.add(new PreBuildInsn(build32x(op, a, b)));
            break;
        }
    }

    /**
     * Only kFmt22s, kFmt22b
     * 
     * @param op
     * @param distReg
     * @param srcReg
     * @param content
     */
    @Override
    public void visitStmt2R1N(Op op, int distReg, int srcReg, int content) {
        if (op.format == kFmt22s) {
            ops.add(new PreBuildInsn(build22s(op, distReg, srcReg, content)));
        } else if (op.format == kFmt22b) {
            ops.add(new PreBuildInsn(build22b(op, distReg, srcReg, content)));
        } else {
        }
    }

    /**
     * kFmt23x
     * 
     * @param op
     * @param a
     * @param b
     * @param c
     */
    @Override
    public void visitStmt3R(Op op, int a, int b, int c) {
        if (op.format == kFmt23x) {
            ops.add(new PreBuildInsn(build23x(op, a, b, c)));
        } else {
        }
    }

    @Override
    public void visitTryCatch(DexLabel start, DexLabel end, DexLabel[] handlers, String[] types) {
        CodeItem.TryItem tryItem = new CodeItem.TryItem();
        tryItem.start = getLabel(start);
        tryItem.end = getLabel(end);
        CodeItem.EncodedCatchHandler ech = new CodeItem.EncodedCatchHandler();
        tryItem.handler = ech;
        tryItems.add(tryItem);
        ech.addPairs = new ArrayList<>(types.length);
        for (int i = 0; i < types.length; i++) {
            String type = types[i];
            Label label = getLabel(handlers[i]);
            if (type == null) {
                ech.catchAll = label;
            } else {
                ech.addPairs.add(new CodeItem.EncodedCatchHandler.AddrPair(cp.uniqType(type), label));
            }
        }
    }

    @Override
    public void visitTypeStmt(Op op, int a, int b, String type) {
        ops.add(new CodeWriter.IndexedInsn(op, a, b, cp.uniqType(type)));
    }

    public static class IndexedInsn extends OpInsn {
        final int a, b;
        final BaseItem idxItem;

        public IndexedInsn(Op op, int a, int b, BaseItem idxItem) {
            super(op);
            switch (op.format) {
            case kFmt21c:
            case kFmt31c:
                checkRegAA(op, "vAA", a);
                break;
            case kFmt22c:
                checkContentU4bit(op, "A", a);
                checkContentU4bit(op, "B", b);
                break;
            }

            this.a = a;
            this.b = b;
            this.idxItem = idxItem;
        }

        // 21c AA|op BBBB
        // 31c AA|op BBBBlo BBBBhi
        // 22c B|A|op CCCC
        @Override
        public void write(ByteBuffer out) {
            out.put((byte) op.opcode);
            switch (op.format) {
            case kFmt21c:
                checkContentUShort(op, "?@BBBB", idxItem.index);
                out.put((byte) a).putShort((short) idxItem.index);
                break;
            case kFmt31c:
                out.put((byte) a).putInt(idxItem.index);
                break;
            case kFmt22c: // B|A|op CCCC
                checkContentUShort(op, "?@CCCC", idxItem.index);
                out.put((byte) ((a & 0xF) | (b << 4))).putShort((short) idxItem.index);
                break;
            }
        }

        public void fit() {
            if (op == CONST_STRING && (idxItem.index > 0xFFFF || idxItem.index < 0)) {
                op = CONST_STRING_JUMBO;
            }
        }
    }

    public static class OP35c extends OpInsn {
        final BaseItem item;
        int A, C, D, E, F, G;

        public OP35c(Op op, int[] args, BaseItem item) {
            super(op);
            int A = args.length;
            if (A > 5) {
                throw new CantNotFixContentException(op, "A", A);
            }
            this.A = A;
            switch (A) { // [A=5] op {vC, vD, vE, vF, vG},
            case 5:
                G = args[4];
                checkContentU4bit(op, "vG", G);
            case 4:
                F = args[3];
                checkContentU4bit(op, "vF", F);
            case 3:
                E = args[2];
                checkContentU4bit(op, "vE", E);
            case 2:
                D = args[1];
                checkContentU4bit(op, "vD", D);
            case 1:
                C = args[0];
                checkContentU4bit(op, "vC", C);
                break;
            }
            this.item = item;
        }

        @Override
        public void write(ByteBuffer out) { // A|G|op BBBB F|E|D|C
            checkContentUShort(op, "@BBBB", item.index);
            out.put((byte) op.opcode).put((byte) ((A << 4) | (G & 0xF))).putShort((short) item.index)
                    .put((byte) ((D << 4) | (C & 0xF))).put((byte) ((F << 4) | (E & 0xF)));
        }
    }

    //A|G|op BBBB F|E|D|C HHHH
    public static class OP45cc extends OpInsn {
        final BaseItem mtd;
        final BaseItem proto;
        int A, C, D, E, F, G;

        public OP45cc(Op op, int[] args, BaseItem mtd, BaseItem proto) {
            super(op);
            int A = args.length;
            if (A > 5) {
                throw new CantNotFixContentException(op, "A", A);
            }
            this.A = A;
            switch (A) { // [A=5] op {vC, vD, vE, vF, vG},
                case 5:
                    G = args[4];
                    checkContentU4bit(op, "vG", G);
                case 4:
                    F = args[3];
                    checkContentU4bit(op, "vF", F);
                case 3:
                    E = args[2];
                    checkContentU4bit(op, "vE", E);
                case 2:
                    D = args[1];
                    checkContentU4bit(op, "vD", D);
                case 1:
                    C = args[0];
                    checkContentU4bit(op, "vC", C);
                    break;
            }
            this.mtd = mtd;
            this.proto = proto;
        }

        @Override
        public void write(ByteBuffer out) { // A|G|op BBBB F|E|D|C HHHH
            checkContentUShort(op, "@BBBB", mtd.index);
            checkContentUShort(op, "@HHHH", proto.index);
            out
                    .put((byte) op.opcode).put((byte) ((A << 4) | (G & 0xF))) //
                    .putShort((short) mtd.index) //
                    .put((byte) ((D << 4) | (C & 0xF))).put((byte) ((F << 4) | (E & 0xF))) //
                    .putShort((short) proto.index) //

            ;
        }
    }
    // AA|op BBBB CCCC HHHH
    public static class OP4rcc extends OpInsn {
        final BaseItem mtd;
        final BaseItem proto;
        final int length;
        final int start;

        public OP4rcc(Op op, int[] args, BaseItem mtd, BaseItem proto) {
            super(op);
            this.mtd = mtd;
            this.proto = proto;
            length = args.length;
            checkContentUByte(op, "AA", length);
            if (length > 0) {
                start = args[0];
                checkContentUShort(op, "CCCC", start);
                for (int i = 1; i < args.length; i++) {
                    if (start + i != args[i]) {
                        throw new CantNotFixContentException(op, "a", args[i]);
                    }
                }
            } else {
                start = 0;
            }

        }

        @Override
        public void write(ByteBuffer out) {
            checkContentUShort(op, "@BBBB", mtd.index);
            checkContentUShort(op, "@HHHH", proto.index);
            out
                    .put((byte) op.opcode).put((byte) length) //
                    .putShort((short) mtd.index) //
                    .putShort((short) start) //
                    .putShort((short) proto.index) //
            ;

        }
    }

    // AA|op BBBB CCCC
    public static class OP3rc extends OpInsn {
        final BaseItem item;
        final int length;
        final int start;

        public OP3rc(Op op, int[] args, BaseItem item) {
            super(op);
            this.item = item;
            length = args.length;
            checkContentUByte(op, "AA", length);
            if (length > 0) {
                start = args[0];
                checkContentUShort(op, "CCCC", start);
                for (int i = 1; i < args.length; i++) {
                    if (start + i != args[i]) {
                        throw new CantNotFixContentException(op, "a", args[i]);
                    }
                }
            } else {
                start = 0;
            }

        }

        @Override
        public void write(ByteBuffer out) {
            checkContentUShort(op, "@BBBB", item.index);
            out.put((byte) op.opcode).put((byte) length).putShort((short) item.index).putShort((short) start);
        }
    }

    @Override
    public DexDebugVisitor visitDebug() {

        if (codeItem.debugInfo == null) {
            codeItem.debugInfo = new DebugInfoItem();
            codeItem.debugInfo.parameterNames=new StringIdItem[owner.getParameterTypes().length];
        }
        final DebugInfoItem debugInfoItem = codeItem.debugInfo;
        return new DexDebugVisitor() {

            @Override
            public void visitParameterName(int parameterIndex, String name) {
                if (name == null) {
                    return;
                }
                if (parameterIndex >= debugInfoItem.parameterNames.length) {
                    return;
                }
                debugInfoItem.parameterNames[parameterIndex] = cp.uniqString(name);
            }

            @Override
            public void visitStartLocal(int reg, DexLabel label, String name, String type, String signature) {
                if (signature == null) {
                    debugInfoItem.debugNodes.add(DebugInfoItem.DNode.startLocal(reg, getLabel(label),
                            cp.uniqString(name), cp.uniqType(type)));
                } else {
                    debugInfoItem.debugNodes.add(DebugInfoItem.DNode.startLocalEx(reg, getLabel(label),
                            cp.uniqString(name), cp.uniqType(type), cp.uniqString(signature)));
                }
            }

            int miniLine = 0;

            @Override
            public void visitLineNumber(int line, DexLabel label) {
                if ((0x00000000FFFFffffL & line) < miniLine) {
                    miniLine = line;
                }
                debugInfoItem.debugNodes.add(DebugInfoItem.DNode.line(line, getLabel(label)));
            }

            @Override
            public void visitPrologue(DexLabel dexLabel) {
                debugInfoItem.debugNodes.add(DebugInfoItem.DNode.prologue( getLabel(dexLabel)));
            }

            @Override
            public void visitEpiogue(DexLabel dexLabel) {
                debugInfoItem.debugNodes.add(DebugInfoItem.DNode.epiogue( getLabel(dexLabel)));
            }

            @Override
            public void visitEndLocal(int reg, DexLabel label) {
                debugInfoItem.debugNodes.add(DebugInfoItem.DNode.endLocal(reg, getLabel(label)));
            }

            @Override
            public void visitSetFile(String file) {
                debugInfoItem.fileName = cp.uniqString(file);
            }

            @Override
            public void visitRestartLocal(int reg, DexLabel label) {
                debugInfoItem.debugNodes.add(DebugInfoItem.DNode.restartLocal(reg, getLabel(label)));
            }

            @Override
            public void visitEnd() {
                debugInfoItem.firstLine = miniLine;
            }
        };
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/DexFileWriter.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer;

import com.googlecode.d2j.dex.writer.ev.EncodedArray;
import com.googlecode.d2j.dex.writer.io.ByteBufferOut;
import com.googlecode.d2j.dex.writer.io.DataOut;
import com.googlecode.d2j.dex.writer.item.*;
import com.googlecode.d2j.dex.writer.item.SectionItem.SectionType;
import com.googlecode.d2j.visitors.DexClassVisitor;
import com.googlecode.d2j.visitors.DexFileVisitor;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.Adler32;

public class DexFileWriter extends DexFileVisitor {
    private static final boolean DEBUG = false;
    MapListItem mapItem;
    HeadItem headItem;
    public ConstPool cp = new ConstPool();

    static private DataOut wrapDumpOut(final DataOut out0) {
        return (DataOut) Proxy.newProxyInstance(
                DexFileWriter.class.getClassLoader(),
                new Class[]{DataOut.class}, new InvocationHandler() {
            int indent = 0;

            @Override
            public Object invoke(Object proxy, Method method,
                                 Object[] args) throws Throwable {

                if (method.getParameterTypes().length > 0
                        && method.getParameterTypes()[0]
                        .equals(String.class)) {
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < indent; i++) {
                        sb.append("  ");
                    }
                    sb.append(String.format("%05d ", out0.offset()));
                    sb.append(method.getName() + " [");
                    for (Object arg : args) {
                        if (arg instanceof byte[]) {
                            byte[] data = (byte[]) arg;
                            sb.append("0x[");
                            int start = 0;
                            int size = data.length;
                            if (args.length > 2) {
                                start = (Integer) args[2];
                                size = (Integer) args[3];
                            }
                            for (int i = 0; i < size; i++) {
                                sb.append(String.format("%02x",
                                        data[start + i] & 0xff));
                                if (i != size - 1) {
                                    sb.append(", ");
                                }
                            }

                            sb.append("], ");
                        } else {
                            sb.append(arg).append(", ");
                        }

                    }
                    sb.append("]");
                    System.out.println(sb);
                }
                if (method.getName().equals("begin")) {
                    indent++;
                }
                if (method.getName().equals("end")) {
                    indent--;
                }
                return method.invoke(out0, args);
            }
        });

    }

    void buildMapListItem() {

        // begin ===========
        // satisfy 'bool DexFileVerifier::CheckMap()' on art/runtime/dex_file_verifier.cc
        // make sure the items are not empty
        if (cp.classDefs.isEmpty()) {
            System.err.println("WARN: no classdef on the dex");
        }
        if (cp.methods.isEmpty()) {
            cp.uniqMethod("Ljava/lang/Object;", "<init>", new String[0], "V");
        }
        if (cp.fields.isEmpty()) {
            cp.uniqField("Ljava/lang/System;", "out", "Ljava/io/PrintStream;");
        }
        if (cp.protos.isEmpty()) {
            cp.uniqProto(new String[0], "V");
        }
        if (cp.types.isEmpty()) {
            cp.uniqType("V");
        }
        if (cp.strings.isEmpty()) {
            cp.uniqString("V");
        }
        // end ===========

        mapItem = new MapListItem();
        headItem = new HeadItem();
        headItem.version = cp.dexVersion;
        SectionItem<HeadItem> headSection = new SectionItem<>(SectionType.TYPE_HEADER_ITEM);
        headSection.items.add(headItem);
        SectionItem<MapListItem> mapSection = new SectionItem<MapListItem>(SectionType.TYPE_MAP_LIST);
        mapSection.items.add(mapItem);
        SectionItem<StringIdItem> stringIdSection = new SectionItem<>(
                SectionType.TYPE_STRING_ID_ITEM, cp.strings.values());
        SectionItem<TypeIdItem> typeIdSection = new SectionItem<>(
                SectionType.TYPE_TYPE_ID_ITEM, cp.types.values());
        SectionItem<ProtoIdItem> protoIdSection = new SectionItem<>(
                SectionType.TYPE_PROTO_ID_ITEM, cp.protos.values());
        SectionItem<FieldIdItem> fieldIdSection = new SectionItem<>(
                SectionType.TYPE_FIELD_ID_ITEM, cp.fields.values());
        SectionItem<MethodIdItem> methodIdSection = new SectionItem<>(
                SectionType.TYPE_METHOD_ID_ITEM, cp.methods.values());
        SectionItem<MethodHandleItem> methodHandlerSection = new SectionItem<>(
                SectionType.TYPE_METHOD_HANDLE_ITEM, cp.methodHandlers.values());
        SectionItem<ClassDefItem> classDefSection = new SectionItem<>(
                SectionType.TYPE_CLASS_DEF_ITEM, cp.buildSortedClassDefItems());
        SectionItem<TypeListItem> typeListSection = new SectionItem<>(
                SectionType.TYPE_TYPE_LIST, cp.typeLists.values());
        SectionItem<AnnotationSetRefListItem> annotationSetRefListItemSection = new SectionItem<>(
                SectionType.TYPE_ANNOTATION_SET_REF_LIST,
                cp.annotationSetRefListItems.values());
        SectionItem<AnnotationSetItem> annotationSetSection = new SectionItem<>(
                SectionType.TYPE_ANNOTATION_SET_ITEM,
                cp.annotationSetItems.values());
        SectionItem<ClassDataItem> classDataItemSection = new SectionItem<>(
                SectionType.TYPE_CLASS_DATA_ITEM, cp.classDataItems);
        SectionItem<CodeItem> codeItemSection = new SectionItem<>(
                SectionType.TYPE_CODE_ITEM, cp.codeItems);
        SectionItem<StringDataItem> stringDataItemSection = new SectionItem<>(
                SectionType.TYPE_STRING_DATA_ITEM, cp.stringDatas);
        SectionItem<DebugInfoItem> debugInfoSection = new SectionItem<>(
                SectionType.TYPE_DEBUG_INFO_ITEM, cp.debugInfoItems);
        SectionItem<AnnotationItem> annotationItemSection = new SectionItem<>(
                SectionType.TYPE_ANNOTATION_ITEM, cp.annotationItems.values());
        SectionItem<EncodedArray> encodedArrayItemSection = new SectionItem<>(
                SectionType.TYPE_ENCODED_ARRAY_ITEM, cp.encodedArrayItems.values());
        SectionItem<CallSiteIdItem> callSiteIdItemSectionItem = new SectionItem<>(
                SectionType.TYPE_CALL_SITE_ID_ITEM, cp.callSiteIdItems.values());
        SectionItem<AnnotationsDirectoryItem> annotationsDirectoryItemSection = new SectionItem<>(
                SectionType.TYPE_ANNOTATIONS_DIRECTORY_ITEM,
                cp.annotationsDirectoryItems);

        {
            headItem.mapSection = mapSection;
            headItem.stringIdSection = stringIdSection;
            headItem.typeIdSection = typeIdSection;
            headItem.protoIdSection = protoIdSection;
            headItem.fieldIdSection = fieldIdSection;
            headItem.methodIdSection = methodIdSection;
            headItem.classDefSection = classDefSection;
        }

        List<SectionItem<?>> dataSectionItems = new ArrayList<>();
        {
            dataSectionItems.add(mapSection); // data section
            dataSectionItems.add(typeListSection);// data section
            dataSectionItems.add(annotationSetRefListItemSection);// data
            // section
            dataSectionItems.add(annotationSetSection);// data section
            // make codeItem Before classDataItem
            dataSectionItems.add(codeItemSection);// data section
            dataSectionItems.add(classDataItemSection);// data section
            dataSectionItems.add(stringDataItemSection);// data section
            dataSectionItems.add(debugInfoSection);// data section
            dataSectionItems.add(annotationItemSection);// data section
            dataSectionItems.add(encodedArrayItemSection);// data section
            dataSectionItems.add(annotationsDirectoryItemSection);// data
            // section
        }

        List<SectionItem<?>> items = mapItem.items;
        {
            items.add(headSection);
            items.add(stringIdSection);
            items.add(typeIdSection);
            items.add(protoIdSection);
            items.add(fieldIdSection);
            items.add(methodIdSection);
            items.add(classDefSection);
            if (callSiteIdItemSectionItem.items.size() > 0) {
                items.add(callSiteIdItemSectionItem);
            }
            if (methodHandlerSection.items.size() > 0) {
                items.add(methodHandlerSection);
            }

            items.addAll(dataSectionItems);
        }
        // cp is useless now since all value are copied now
        cp.clean();
        cp = null;
    }

    public byte[] toByteArray() {

        // init structure for writing
        buildMapListItem();

        // place all item into file, we can know the size now
        final int size = place();

        ByteBuffer buffer = ByteBuffer.allocate(size);
        DataOut out = new ByteBufferOut(buffer);

        if (DEBUG) {
            out = wrapDumpOut(out);
        }
        // write it
        write(out);

        if (size != buffer.position()) {
            throw new RuntimeException("generated different file size, planned " + size + ", but is " + buffer.position());
        }

        // update the CRC/ sha1 checksum in dex header
        updateChecksum(buffer, size);

        return buffer.array();
    }

    public static void updateChecksum(ByteBuffer buffer, int size) {
        byte[] data = buffer.array();
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            throw new AssertionError();
        }

        digest.update(data, 32, size - 32);
        byte[] sha1 = digest.digest();
        System.arraycopy(sha1, 0, data, 12, sha1.length);

        Adler32 adler32 = new Adler32();
        adler32.update(data, 12, size - 12);
        int v = (int) adler32.getValue();
        buffer.position(8);
        buffer.putInt(v);
    }

    private void write(DataOut out) {
        List<SectionItem<?>> list = new ArrayList<>(mapItem.items);
        // mapItem is useless now
        this.mapItem = null;
        for (int i = 0; i < list.size(); i++) {
            SectionItem<?> section = list.get(i);
            list.set(i, null);
            BaseItem.addPadding(out, out.offset(),
                    section.sectionType.alignment);
            if (out.offset() != section.offset) {
                throw new RuntimeException(section.sectionType
                        + " start with different position, planned:"
                        + section.offset + ", but is:" + out.offset());
            }
            section.write(out);
        }
    }

    private int place() {
        // 2. order
        mapItem.cleanZeroSizeEntry();

        // 3. place
        int offset = 0;
        // int index = 0;
        for (SectionItem<?> section : mapItem.items) {

            offset = BaseItem.padding(offset, section.sectionType.alignment);
            section.offset = offset;
            // section.index = index;
            // index++;
            offset = section.place(offset);
        }
        int size = offset;
        { // fix size
            headItem.fileSize = size;
            // headItem is useless now
            this.headItem = null;
        }
        return size;
    }

    @Override
    public DexClassVisitor visit(int accessFlag, String name,
                                 String superClass, String[] itfClass) {
        ClassDefItem defItem = cp.putClassDefItem(accessFlag, name, superClass,
                itfClass);
        return new ClassWriter(defItem, cp);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/DexWriteException.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer;

public class DexWriteException extends RuntimeException {

    private static final long serialVersionUID = 8501861997187282533L;

    public DexWriteException() {
        super();

    }

    public DexWriteException(String message) {
        super(message);

    }

    public DexWriteException(String message, Throwable cause) {
        super(message, cause);

    }

    public DexWriteException(String message, Throwable cause,
                             boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);

    }

    public DexWriteException(Throwable cause) {
        super(cause);

    }

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/FieldWriter.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer;

import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.dex.writer.item.AnnotationItem;
import com.googlecode.d2j.dex.writer.item.AnnotationSetItem;
import com.googlecode.d2j.dex.writer.item.ClassDataItem;
import com.googlecode.d2j.dex.writer.item.ConstPool;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;
import com.googlecode.d2j.visitors.DexFieldVisitor;

/*package*/class FieldWriter extends DexFieldVisitor {
    final public ConstPool cp;
    private final ClassDataItem.EncodedField encodedField;

    public FieldWriter(ClassDataItem.EncodedField encodedField, ConstPool cp) {
        this.encodedField = encodedField;
        this.cp = cp;
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name,
                                                Visibility visibility) {
        final AnnotationItem annItem = new AnnotationItem(cp.uniqType(name),
                visibility);
        AnnotationSetItem asi = encodedField.annotationSetItem;
        if (asi == null) {
            asi = new AnnotationSetItem();
            encodedField.annotationSetItem = asi;
        }
        asi.annotations.add(annItem);
        return new AnnotationWriter(annItem.annotation.elements, cp);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/MethodWriter.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer;

import com.googlecode.d2j.Method;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.dex.writer.item.*;
import com.googlecode.d2j.visitors.DexAnnotationAble;
import com.googlecode.d2j.visitors.DexAnnotationVisitor;
import com.googlecode.d2j.visitors.DexCodeVisitor;
import com.googlecode.d2j.visitors.DexMethodVisitor;

/*package*/class MethodWriter extends DexMethodVisitor {
    final public ConstPool cp;
    private final ClassDataItem.EncodedMethod encodedMethod;
    final boolean isStatic;
    final Method method;
    private final int parameterSize;

    public MethodWriter(ClassDataItem.EncodedMethod encodedMethod, Method m,
                        boolean isStatic, ConstPool cp) {
        this.encodedMethod = encodedMethod;
        this.parameterSize = m.getParameterTypes().length;
        this.cp = cp;
        this.method = m;
        this.isStatic = isStatic;
    }

    @Override
    public DexAnnotationVisitor visitAnnotation(String name,
                                                Visibility visibility) {
        final AnnotationItem annItem = new AnnotationItem(cp.uniqType(name),
                visibility);
        AnnotationSetItem asi = encodedMethod.annotationSetItem;
        if (asi == null) {
            asi = new AnnotationSetItem();
            encodedMethod.annotationSetItem = asi;
        }
        asi.annotations.add(annItem);
        return new AnnotationWriter(annItem.annotation.elements, cp);
    }

    @Override
    public DexCodeVisitor visitCode() {
        encodedMethod.code = new CodeItem();
        return new CodeWriter(encodedMethod, encodedMethod.code, method, isStatic, cp);
    }

    @Override
    public DexAnnotationAble visitParameterAnnotation(final int index) {
        return new DexAnnotationAble() {
            @Override
            public DexAnnotationVisitor visitAnnotation(String name,
                                                        Visibility visibility) {
                AnnotationSetRefListItem asrl = encodedMethod.parameterAnnotation;
                if (asrl == null) {
                    asrl = new AnnotationSetRefListItem(parameterSize);
                    encodedMethod.parameterAnnotation = asrl;
                }
                AnnotationSetItem asi = asrl.annotationSets[index];
                if (asi == null) {
                    asi = new AnnotationSetItem();
                    asrl.annotationSets[index] = asi;
                }
                final AnnotationItem annItem = new AnnotationItem(
                        cp.uniqType(name), visibility);
                asi.annotations.add(annItem);
                return new AnnotationWriter(annItem.annotation.elements, cp);
            }
        };
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/ann/Alignment.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.ann;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface Alignment {
    int value();
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/ann/Idx.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.ann;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.SOURCE)
public @interface Idx {

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/ann/Off.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.ann;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.SOURCE)
public @interface Off {

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/ev/EncodedAnnotation.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.ev;

import com.googlecode.d2j.dex.writer.ann.Idx;
import com.googlecode.d2j.dex.writer.io.DataOut;
import com.googlecode.d2j.dex.writer.item.BaseItem;
import com.googlecode.d2j.dex.writer.item.StringIdItem;
import com.googlecode.d2j.dex.writer.item.TypeIdItem;

import java.util.ArrayList;
import java.util.List;

public class EncodedAnnotation implements Comparable<EncodedAnnotation> {
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EncodedAnnotation that = (EncodedAnnotation) o;

        if (!elements.equals(that.elements)) return false;
        if (!type.equals(that.type)) return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = type.hashCode();
        result = 31 * result + elements.hashCode();
        return result;
    }

    @Override
    public int compareTo(EncodedAnnotation o) {
        if (o == null) {
            return 1;
        }

        int x = type.compareTo(o.type);
        if (x != 0) {
            return x;
        }
        x = Integer.compare(elements.size(), o.elements.size());
        if (x != 0) {
            return x;
        }
        for (int i = 0; i < elements.size(); i++) {
            AnnotationElement a = elements.get(i);
            AnnotationElement b = o.elements.get(i);

            x = a.compareTo(b);
            if (x != 0) {
                return x;
            }
        }
        return 0;
    }

    public static class AnnotationElement implements Comparable<AnnotationElement> {
        public StringIdItem name;
        public EncodedValue value;

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            AnnotationElement that = (AnnotationElement) o;

            if (!name.equals(that.name)) return false;
            if (!value.equals(that.value)) return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = name.hashCode();
            result = 31 * result + value.hashCode();
            return result;
        }

        @Override
        public int compareTo(AnnotationElement o) {
            if (o == null) {
                return 1;
            }
            int x = name.compareTo(o.name);
            if (x != 0) {
                return x;
            }
            return value.compareTo(o.value);
        }
    }

    @Idx
    public TypeIdItem type;
    final public List<AnnotationElement> elements = new ArrayList<>(5);

    public int place(int offset) {
        offset += BaseItem.lengthOfUleb128(type.index);
        offset += BaseItem.lengthOfUleb128(elements.size());
        for (AnnotationElement ae : elements) {
            offset += BaseItem.lengthOfUleb128(ae.name.index);
            offset = ae.value.place(offset);
        }
        return offset;
    }

    public void write(DataOut out) {
        out.uleb128("type_idx", type.index);
        out.uleb128("size", elements.size());
        for (AnnotationElement ae : elements) {
            out.uleb128("name_idx", ae.name.index);
            ae.value.write(out);
        }
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/ev/EncodedArray.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.ev;

import com.googlecode.d2j.dex.writer.io.DataOut;
import com.googlecode.d2j.dex.writer.item.BaseItem;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class EncodedArray extends BaseItem implements Comparable<EncodedArray> {

    public List<EncodedValue> values = new ArrayList<>(5);

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EncodedArray that = (EncodedArray) o;

        if (!values.equals(that.values)) return false;

        return true;
    }

    @Override
    public int hashCode() {
        return values.hashCode();
    }

    public int place(int offset) {
        offset += BaseItem.lengthOfUleb128(values.size());
        for (EncodedValue ev : values) {
            offset = ev.place(offset);
        }
        return offset;
    }

    public void write(DataOut out) {
        out.uleb128("size", values.size());
        for (EncodedValue ev : values) {
            ev.write(out);
        }
    }

    @Override
    public int compareTo(EncodedArray o) {
        if (o == null) {
            return 1;
        }
        int x = Integer.compare(values.size(), o.values.size());
        if (x != 0) {
            return x;
        }
        for (int i = 0; i < values.size(); i++) {
            EncodedValue a = values.get(i);
            EncodedValue b = o.values.get(i);
            x = a.compareTo(b);
            if (x != 0) {
                return x;
            }
        }
        return 0;
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/ev/EncodedValue.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.ev;

import com.googlecode.d2j.dex.writer.io.DataOut;
import com.googlecode.d2j.dex.writer.item.BaseItem;
import com.googlecode.d2j.dex.writer.item.FieldIdItem;
import com.googlecode.d2j.dex.writer.item.MethodHandleItem;
import com.googlecode.d2j.dex.writer.item.MethodIdItem;
import com.googlecode.d2j.dex.writer.item.ProtoIdItem;
import com.googlecode.d2j.dex.writer.item.StringIdItem;
import com.googlecode.d2j.dex.writer.item.TypeIdItem;

public class EncodedValue implements Comparable<EncodedValue> {

    public final static int VALUE_ANNOTATION = 0x1d;
    public final static int VALUE_ARRAY = 0x1c;
    public final static int VALUE_BOOLEAN = 0x1f;
    public final static int VALUE_BYTE = 0x00;
    public final static int VALUE_CHAR = 0x03;
    public final static int VALUE_DOUBLE = 0x11;
    public final static int VALUE_ENUM = 0x1b;
    public final static int VALUE_FIELD = 0x19;
    public final static int VALUE_FLOAT = 0x10;
    public final static int VALUE_INT = 0x04;
    public final static int VALUE_LONG = 0x06;
    public final static int VALUE_METHOD_TYPE = 0x15;
    public final static int VALUE_METHOD_HANDLE = 0x16;
    public final static int VALUE_METHOD = 0x1a;
    public final static int VALUE_NULL = 0x1e;
    public final static int VALUE_SHORT = 0x02;
    public final static int VALUE_STRING = 0x17;
    public final static int VALUE_TYPE = 0x18;
    public final int valueType;
    public Object value;

    public EncodedValue(int valueType, Object value) {
        this.valueType = valueType;
        this.value = value;
    }

    public static int lengthOfDouble(double value) {
        int requiredBits = 64 - Long.numberOfTrailingZeros(Double.doubleToRawLongBits(value));
        if (requiredBits == 0) {
            requiredBits = 1;
        }
        return (requiredBits + 0x07) >> 3;
    }

    public static int lengthOfFloat(float value) {
        int requiredBits = 64 - Long.numberOfTrailingZeros(((long) (Float.floatToRawIntBits(value))) << 32);
        if (requiredBits == 0) {
            requiredBits = 1;
        }
        return (requiredBits + 0x07) >> 3;
    }

    public static int lengthOfSint(int value) {
        int nbBits = 33 - Integer.numberOfLeadingZeros(value ^ (value >> 31));
        return (nbBits + 0x07) >> 3;
    }

    public static int lengthOfSint(long value) {
        int nbBits = 65 - Long.numberOfLeadingZeros(value ^ (value >> 63));
        return (nbBits + 0x07) >> 3;
    }

    public final static int lengthOfUint(int val) {
        int size = 1;
        if (val != 0) {
            val = val >>> 8;
            if (val != 0) {
                size++;
                val = val >>> 8;
                if (val != 0) {
                    size++;
                    val = val >>> 8;
                    if (val != 0) {
                        size++;
                    }
                }
            }
        }
        return size;
    }

    public static EncodedValue wrap(Object v) {
        if (v == null) {
            return new EncodedValue(VALUE_NULL, null);
        }
        if (v instanceof Integer) {
            return new EncodedValue(VALUE_INT, v);
        } else if (v instanceof Short) {
            return new EncodedValue(VALUE_SHORT, v);
        } else if (v instanceof Character) {
            return new EncodedValue(VALUE_CHAR, v);
        } else if (v instanceof Long) {
            return new EncodedValue(VALUE_LONG, v);
        } else if (v instanceof Float) {
            return new EncodedValue(VALUE_FLOAT, v);
        } else if (v instanceof Double) {
            return new EncodedValue(VALUE_DOUBLE, v);
        } else if (v instanceof Boolean) {
            return new EncodedValue(VALUE_BOOLEAN, v);
        } else if (v instanceof Byte) {
            return new EncodedValue(VALUE_BYTE, v);
        } else if (v instanceof TypeIdItem) {
            return new EncodedValue(VALUE_TYPE, v);
        } else if (v instanceof StringIdItem) {
            return new EncodedValue(VALUE_STRING, v);
        } else if (v instanceof FieldIdItem) {
            return new EncodedValue(VALUE_FIELD, v);
        } else if (v instanceof MethodIdItem) {
            return new EncodedValue(VALUE_METHOD, v);
        } else if (v instanceof MethodHandleItem) {
            return new EncodedValue(VALUE_METHOD_HANDLE, v);
        } else if (v instanceof ProtoIdItem) {
            return new EncodedValue(VALUE_METHOD_TYPE, v);
        }


        throw new RuntimeException("not support");
    }

    public static EncodedValue defaultValueForType(String typeString) {
        switch (typeString.charAt(0)) {
            case '[':
            case 'L':
                return new EncodedValue(VALUE_NULL, null);
            case 'B':
                return new EncodedValue(VALUE_BYTE, (byte) 0);
            case 'Z':
                return new EncodedValue(VALUE_BOOLEAN, false);
            case 'S':
                return new EncodedValue(VALUE_SHORT, (short) 0);
            case 'C':
                return new EncodedValue(VALUE_CHAR, (char) 0);
            case 'I':
                return new EncodedValue(VALUE_INT, (int) 0);
            case 'F':
                return new EncodedValue(VALUE_FLOAT, (float) 0);
            case 'D':
                return new EncodedValue(VALUE_DOUBLE, (double) 0);
            case 'J':
                return new EncodedValue(VALUE_LONG, (long) 0);
            default:
                throw new RuntimeException();
        }
    }

    static byte[] encodeLong(int length, long value) {
        byte[] data = new byte[length];
        switch (length) {
            case 8:
                data[7] = (byte) (value >> 56);
            case 7:
                data[6] = (byte) (value >> 48);
            case 6:
                data[5] = (byte) (value >> 40);
            case 5:
                data[4] = (byte) (value >> 32);
            case 4:
                data[3] = (byte) (value >> 24);
            case 3:
                data[2] = (byte) (value >> 16);
            case 2:
                data[1] = (byte) (value >> 8);
            case 1:
                data[0] = (byte) (value >> 0);
                break;
            default:
                throw new RuntimeException();

        }
        return data;
    }

    static byte[] encodeSint(int length, int value) {
        byte[] data = new byte[length];
        switch (length) {
            case 4:
                data[3] = (byte) (value >> 24);
            case 3:
                data[2] = (byte) (value >> 16);
            case 2:
                data[1] = (byte) (value >> 8);
            case 1:
                data[0] = (byte) (value >> 0);
                break;
            default:
                throw new RuntimeException();
        }
        return data;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EncodedValue that = (EncodedValue) o;

        if (valueType != that.valueType) return false;
        if (value != null ? !value.equals(that.value) : that.value != null) return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = valueType;
        result = 31 * result + (value != null ? value.hashCode() : 0);
        return result;
    }

    public boolean isDefaultValueForType() {
        if (valueType == VALUE_NULL) {
            return true;
        }
        switch (valueType) {
            case VALUE_CHAR:
                Character c = (Character) this.value;
                return c.charValue() == 0;
            case VALUE_BYTE:
            case VALUE_INT:
            case VALUE_SHORT:
                return ((Number) this.value).intValue() == 0;
            case VALUE_LONG:
                return ((Number) this.value).longValue() == 0;
            case VALUE_FLOAT:
                return ((Number) this.value).floatValue() == 0.0f;
            case VALUE_DOUBLE:
                return ((Number) this.value).doubleValue() == 0.0;
            case VALUE_BOOLEAN:
                Boolean z = (Boolean) this.value;
                return Boolean.FALSE.equals(z);
        }
        return false;
    }

    protected int doPlace(int offset) {
        switch (valueType) {
            case VALUE_NULL:
            case VALUE_BOOLEAN:
                return offset;
            case VALUE_ARRAY: {
                EncodedArray ea = (EncodedArray) value;
                return ea.place(offset);
            }
            case VALUE_ANNOTATION: {
                EncodedAnnotation ea = (EncodedAnnotation) value;
                return ea.place(offset);
            }
            case VALUE_STRING:
            case VALUE_TYPE:
            case VALUE_FIELD:
            case VALUE_METHOD:
            case VALUE_ENUM:
            case VALUE_METHOD_HANDLE:
            case VALUE_METHOD_TYPE:
            default:
                return offset + getValueArg() + 1;
        }
    }

    protected int getValueArg() {
        switch (valueType) {
            case VALUE_NULL:
            case VALUE_ANNOTATION:
            case VALUE_ARRAY:
                return 0;
            case VALUE_BOOLEAN:
                return Boolean.TRUE.equals(value) ? 1 : 0;
            case VALUE_BYTE:
                return 0;
            case VALUE_SHORT:
            case VALUE_INT:
                return lengthOfSint(((Number) value).intValue()) - 1;
            case VALUE_CHAR:
                return lengthOfUint(((Character) value).charValue()) - 1;
            case VALUE_LONG:
                return lengthOfSint(((Number) value).longValue()) - 1;
            case VALUE_DOUBLE:
                return lengthOfDouble(((Number) value).doubleValue()) - 1;
            case VALUE_FLOAT:
                return lengthOfFloat(((Number) value).floatValue()) - 1;
            case VALUE_STRING:
            case VALUE_TYPE:
            case VALUE_FIELD:
            case VALUE_METHOD:
            case VALUE_ENUM:
            case VALUE_METHOD_HANDLE:
            case VALUE_METHOD_TYPE:
                BaseItem bi = (BaseItem) value;
                return lengthOfUint(bi.index) - 1;
        }
        return 0;
    }

    final public int place(int offset) {
        offset += 1;
        return doPlace(offset);
    }

    public void write(DataOut out) {
        int valueArg = getValueArg();
        out.ubyte("(value_arg << 5 | value_type", valueArg << 5 | valueType);
        switch (valueType) {
            case VALUE_NULL:
            case VALUE_BOOLEAN:
                // nop
                break;
            case VALUE_SHORT:
                out.bytes("value_short", encodeSint(valueArg + 1, (Short) value));
                break;
            case VALUE_CHAR:
                out.bytes("value_char", encodeSint(valueArg + 1, (Character) value));
                break;
            case VALUE_INT:
                out.bytes("value_int", encodeSint(valueArg + 1, (Integer) value));
                break;
            case VALUE_LONG:
                out.bytes("value_long", encodeLong(valueArg + 1, (Long) value));
                break;
            case VALUE_DOUBLE:
                out.bytes("value_double", writeRightZeroExtendedValue(valueArg+1,Double.doubleToLongBits( ((Number) value).doubleValue())));
                break;
            case VALUE_FLOAT:
                out.bytes("value_float", writeRightZeroExtendedValue(valueArg+1,((long)Float.floatToIntBits((((Number) value).floatValue())))<<32));
                break;
            case VALUE_STRING:
            case VALUE_TYPE:
            case VALUE_FIELD:
            case VALUE_METHOD:
            case VALUE_ENUM:
            case VALUE_METHOD_HANDLE:
            case VALUE_METHOD_TYPE:
                out.bytes("value_xidx", encodeLong(valueArg + 1, ((BaseItem) value).index));
                break;
            case VALUE_ARRAY: {
                EncodedArray ea = (EncodedArray) value;
                ea.write(out);
            }
            break;
            case VALUE_ANNOTATION: {
                EncodedAnnotation ea = (EncodedAnnotation) value;
                ea.write(out);
            }
            break;
            case VALUE_BYTE: {
                out.ubyte("value_byte", (Byte) value);
                break;
            }
            default:
                throw new RuntimeException();

        }
    }

    private byte[] writeRightZeroExtendedValue(int requiredBytes, long value) {
        value >>= 64 - (requiredBytes * 8);
        byte[] s = new byte[requiredBytes];
        for (int i = 0; i < requiredBytes; i++) {
            s[i] = ((byte) value);
            value >>= 8;
        }
        return s;
    }

    @Override
    public int compareTo(EncodedValue o) {
        if (o == null) {
            return 1;
        }
        int x = Integer.compare(valueType, o.valueType);
        if (x != 0) {
            return x;
        }
        switch (valueType) {
            case VALUE_NULL:
                return 0;
            case VALUE_BOOLEAN:
                return Boolean.compare((Boolean) value, (Boolean) o.value);
            case VALUE_SHORT:
                return ((Short) value).compareTo((Short) o.value);
            case VALUE_CHAR:
                return ((Character) value).compareTo((Character) o.value);
            case VALUE_INT:
                return ((Integer) value).compareTo((Integer) o.value);
            case VALUE_LONG:
                return ((Long) value).compareTo((Long) o.value);
            case VALUE_DOUBLE:
                return Long.compare(Double.doubleToLongBits((Double) value), Double.doubleToLongBits((Double) o.value));
            case VALUE_FLOAT:
                return Integer.compare(Float.floatToIntBits((Float) value), Float.floatToIntBits((Float) o.value));
            case VALUE_STRING:
            case VALUE_TYPE:
            case VALUE_FIELD:
            case VALUE_METHOD:
            case VALUE_ENUM:
            case VALUE_METHOD_HANDLE:
            case VALUE_METHOD_TYPE:
                if (value instanceof Comparable) {
                    return ((Comparable) value).compareTo(o.value);
                } else {
                    throw new RuntimeException();
                }
            case VALUE_ARRAY: {
                return ((EncodedArray) value).compareTo((EncodedArray) o.value);
            }
            case VALUE_ANNOTATION: {
                return ((EncodedAnnotation) value).compareTo((EncodedAnnotation) o.value);
            }
            case VALUE_BYTE: {
                return Byte.compare((Byte) value, (Byte) o.value);
            }
            default:
                throw new RuntimeException();
        }
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/insn/Insn.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.insn;

import java.nio.ByteBuffer;

public abstract class Insn {
    protected static final boolean DEBUG = false;
    /**
     * offset in codeUnit
     */
    public int offset;

    /**
     * size in codeUnit
     *
     * @return
     */
    abstract public int getCodeUnitSize();

    public void write(ByteBuffer out) {
        // TODO Auto-generated method stub

    }

    boolean isLabel() {
        return false;
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/insn/JumpOp.java`:

```java
package com.googlecode.d2j.dex.writer.insn;

import java.nio.ByteBuffer;

import com.googlecode.d2j.dex.writer.CodeWriter;
import com.googlecode.d2j.reader.Op;

public class JumpOp extends OpInsn {
    final int a;
    final int b;
    final Label label;

    public JumpOp(Op op, int a, int b, Label label) {
        super(op);
        switch (op.format) {
            case kFmt31t:
            case kFmt21t:
                CodeWriter.checkRegAA(op, "vAA", a);
                break;
            case kFmt22t:
                CodeWriter.checkRegA(op, "vA", a);
                CodeWriter.checkRegA(op, "vB", b);
                break;
            default:
        }
        this.label = label;
        this.a = a;
        this.b = b;
    }

    @Override
    public void write(ByteBuffer out) {
        out.put((byte) op.opcode);
        int offset = label.offset - this.offset;
        switch (op.format) {
            case kFmt10t: // AA|op
                CodeWriter.checkContentByte(op, "+AA", offset);
                out.put((byte) offset);
                break;
            case kFmt20t: // ØØ|op AAAA
                CodeWriter.checkContentShort(op, "+AAAA", offset);
                out.put((byte) 0).putShort((short) offset);
                break;
            case kFmt30t: // ØØ|op AAAAlo AAAAhi
                out.put((byte) 0).putInt(offset);
                break;
            case kFmt31t: // AA|op BBBBlo BBBBhi
                out.put((byte) a).putInt(offset);
                break;
            case kFmt22t: // B|A|op CCCC
                CodeWriter.checkContentShort(op, "+CCCC", offset);
                out.put((byte) ((a & 0xF) | (b << 4))).putShort((short) offset);
                break;
            case kFmt21t: // AA|op BBBB
                CodeWriter.checkContentShort(op, "+BBBB", offset);
                out.put((byte) a).putShort((short) offset);
                break;
            default:
                throw new RuntimeException("not support");
        }
    }

    public boolean fit() {
        int offset = label.offset - this.offset;
        if ((op == Op.GOTO && (offset > Byte.MAX_VALUE || offset < Byte.MIN_VALUE)) ||
                (op == Op.GOTO_16 && (offset > Short.MAX_VALUE || offset < Short.MIN_VALUE))
                ) {
            if ((offset > Short.MAX_VALUE || offset < Short.MIN_VALUE)) {
                op = Op.GOTO_32;
            } else {
                op = Op.GOTO_16;
            }
            return false;
        }
        return true;
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/insn/Label.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.insn;


public class Label extends Insn {

    @Override
    public int getCodeUnitSize() {
        return 0;
    }

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/insn/OpInsn.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.insn;

import com.googlecode.d2j.reader.Op;

public abstract class OpInsn extends Insn {
    public Op op;


    public OpInsn(Op op) {
        this.op = op;
    }

    final public boolean isLabel() {
        return true;
    }

    @Override
    public int getCodeUnitSize() {
        return op.format.size;
    }
}
```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/insn/PreBuildInsn.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.insn;

import java.nio.ByteBuffer;

public class PreBuildInsn extends Insn {

    final public byte[] data;

    public PreBuildInsn(byte[] data) {

        this.data = data;
    }


    @Override
    public int getCodeUnitSize() {
        return data.length / 2;
    }

    @Override
    public void write(ByteBuffer out) {
        out.put(data);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/io/ByteBufferOut.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.io;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class ByteBufferOut implements DataOut {
    public final ByteBuffer buffer;

    public ByteBufferOut(ByteBuffer buffer) {
        this.buffer = buffer;
        buffer.order(ByteOrder.LITTLE_ENDIAN);
    }

    @Override
    public void begin(String s) {
    }

    @Override
    public void bytes(String s, byte[] bs) {
        buffer.put(bs);
    }

    @Override
    public void bytes(String string, byte[] buf, int offset, int size) {
        buffer.put(buf, offset, size);
    }

    public void doUleb128(int value) {
        int remaining = value >>> 7;

        while (remaining != 0) {
            buffer.put((byte) ((value & 0x7f) | 0x80));
            value = remaining;
            remaining >>>= 7;
        }

        buffer.put((byte) (value & 0x7f));
    }

    @Override
    public void end() {
    }

    @Override
    public int offset() {
        return buffer.position();
    }

    @Override
    public void sbyte(String s, int b) {
        buffer.put((byte) b);
    }

    @Override
    public void sint(String s, int i) {
        buffer.putInt(i);
    }

    @Override
    public void skip(String s, int n) {
        buffer.position(buffer.position() + n);
    }

    @Override
    public void skip4(String s) {
        buffer.putInt(0);
    }

    @Override
    public void sleb128(String s, int value) {
        int remaining = value >> 7;
        boolean hasMore = true;
        int end = ((value & Integer.MIN_VALUE) == 0) ? 0 : -1;

        while (hasMore) {
            hasMore = (remaining != end)
                    || ((remaining & 1) != ((value >> 6) & 1));

            buffer.put((byte) ((value & 0x7f) | (hasMore ? 0x80 : 0)));
            value = remaining;
            remaining >>= 7;
        }

    }

    @Override
    public void sshort(String s, int i) {
        buffer.putShort((short) i);
    }

    @Override
    public void ubyte(String s, int b) {
        buffer.put((byte) b);
    }

    @Override
    public void uint(String s, int i) {
        buffer.putInt(i);
    }

    @Override
    public void uleb128(String s, int value) {
        doUleb128(value);
    }

    @Override
    public void uleb128p1(String s, int i) {
        doUleb128(i + 1);
    }

    @Override
    public void ushort(String s, int i) {
        buffer.putShort((short) i);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/io/DataOut.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.io;

public interface DataOut {

    void begin(String s);

    void bytes(String s, byte[] bs);

    void bytes(String string, byte[] buf, int offset, int size);

    void end();

    int offset();

    void sbyte(String s, int b);

    void sint(String s, int i);

    void skip(String s, int n);

    void skip4(String s);

    void sleb128(String s, int i);

    void sshort(String s, int i);

    void ubyte(String s, int b);

    void uint(String s, int i);

    void uleb128(String s, int i);

    void uleb128p1(String s, int i);

    void ushort(String s, int i);
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/AnnotationItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.dex.writer.ev.EncodedAnnotation;
import com.googlecode.d2j.dex.writer.io.DataOut;

public class AnnotationItem extends BaseItem {
    final public Visibility visibility;
    final public EncodedAnnotation annotation = new EncodedAnnotation();

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        AnnotationItem that = (AnnotationItem) o;

        if (!annotation.equals(that.annotation)) return false;
        if (visibility != that.visibility) return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = visibility.hashCode();
        result = 31 * result + annotation.hashCode();
        return result;
    }

    public AnnotationItem(TypeIdItem type, Visibility visibility) {
        this.visibility = visibility;
        annotation.type = type;
    }

    @Override
    public int place(int offset) {
        offset += 1;
        return annotation.place(offset);
    }

    @Override
    public void write(DataOut out) {
        out.ubyte("visibility", visibility.value);
        annotation.write(out);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/AnnotationSetItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.io.DataOut;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class AnnotationSetItem extends BaseItem {
    public List<AnnotationItem> annotations = new ArrayList<>(3);
    private static final Comparator<AnnotationItem> cmp = new Comparator<AnnotationItem>() {
        @Override
        public int compare(AnnotationItem o1, AnnotationItem o2) {
            return o1.annotation.type.compareTo(o2.annotation.type);
        }
    };
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        AnnotationSetItem that = (AnnotationSetItem) o;

        if (!annotations.equals(that.annotations)) return false;
        return true;
    }

    @Override
    public int hashCode() {
        return annotations.hashCode();
    }

    @Override
    public int place(int offset) {
        return offset + 4 + annotations.size() * 4;
    }

    @Override
    public void write(DataOut out) {
        Collections.sort(annotations, cmp);
        out.uint("size", annotations.size());
        for (AnnotationItem item : annotations) {
            out.uint("annotation_off", item.offset);
        }
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/AnnotationSetRefListItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Off;
import com.googlecode.d2j.dex.writer.io.DataOut;

public class AnnotationSetRefListItem extends BaseItem {
    @Off
    final public AnnotationSetItem[] annotationSets;

    public AnnotationSetRefListItem(int size) {
        this.annotationSets = new AnnotationSetItem[size];
    }

    @Override
    public int place(int offset) {
        return offset + 4 + annotationSets.length * 4;
    }

    @Override
    public void write(DataOut out) {
        out.uint("size", annotationSets.length);
        for (AnnotationSetItem item : annotationSets) {
            out.uint("annotations_off", item == null ? 0 : item.offset);
        }
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/AnnotationsDirectoryItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Off;
import com.googlecode.d2j.dex.writer.io.DataOut;

import java.util.Map;
import java.util.Map.Entry;

public class AnnotationsDirectoryItem extends BaseItem {
    @Off
    public AnnotationSetItem classAnnotations;
    public Map<FieldIdItem, AnnotationSetItem> fieldAnnotations;
    public Map<MethodIdItem, AnnotationSetItem> methodAnnotations;
    public Map<MethodIdItem, AnnotationSetRefListItem> parameterAnnotations;

    @Override
    public int place(int offset) {
        offset += 16;
        if (fieldAnnotations != null) {
            offset += fieldAnnotations.size() * 8;
        }
        if (methodAnnotations != null) {
            offset += methodAnnotations.size() * 8;
        }
        if (parameterAnnotations != null) {
            offset += parameterAnnotations.size() * 8;
        }
        return offset;
    }

    @Override
    public void write(DataOut out) {
        out.uint("class_annotations_off", classAnnotations == null ? 0 : classAnnotations.offset);
        out.uint("fields_size", fieldAnnotations == null ? 0 : fieldAnnotations.size());
        out.uint("annotated_methods_size", methodAnnotations == null ? 0 : methodAnnotations.size());
        out.uint("annotated_parameter_size", parameterAnnotations == null ? 0 : parameterAnnotations.size());
        if (fieldAnnotations != null) {
            for (Entry<FieldIdItem, AnnotationSetItem> fe : fieldAnnotations.entrySet()) {
                out.uint("field_idx", fe.getKey().index);
                out.uint("annotations_off", fe.getValue().offset);
            }
        }
        if (methodAnnotations != null) {
            for (Entry<MethodIdItem, AnnotationSetItem> fe : methodAnnotations.entrySet()) {
                out.uint("method_idx", fe.getKey().index);
                out.uint("annotations_off", fe.getValue().offset);
            }
        }
        if (parameterAnnotations != null) {
            for (Entry<MethodIdItem, AnnotationSetRefListItem> fe : parameterAnnotations.entrySet()) {
                out.uint("method_idx", fe.getKey().index);
                out.uint("annotations_off", fe.getValue().offset);
            }
        }
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/BaseItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.io.DataOut;

public abstract class BaseItem {
    public static final int NO_INDEX = -1;
    public int index;
    public int offset;

    static protected void addPadding(DataOut out, int alignment) {
        int x = out.offset() % alignment;
        if (x != 0) {
            out.skip("padding", alignment - x);// Padding
        }
    }

    static public void addPadding(DataOut out, int offset, int alignment) {
        int x = offset % alignment;
        if (x != 0) {
            out.skip("padding", alignment - x);// Padding
        }
    }

    public static int padding(int offset, int alignment) {
        int x = offset % alignment;
        if (x != 0) {
            offset += alignment - x;// Padding
        }
        return offset;
    }

    public static int lengthOfSleb128(int value) {
        int remaining = value >> 7;
        boolean hasMore = true;
        int end = ((value & Integer.MIN_VALUE) == 0) ? 0 : -1;
        int count = 0;
        while (hasMore) {
            hasMore = (remaining != end)
                    || ((remaining & 1) != ((value >> 6) & 1));
            count++;
            value = remaining;
            remaining >>= 7;
        }
        return count;
    }

    public static int lengthOfUleb128(int value) {
        int remaining = value >>> 7;
        int length = 1;
        while (remaining != 0) {
            length++;
            remaining >>>= 7;
        }
        return length;
    }

    public abstract void write(DataOut out);

    public abstract int place(int offset);
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/CallSiteIdItem.java`:

```java
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ev.EncodedArray;
import com.googlecode.d2j.dex.writer.io.DataOut;

public class CallSiteIdItem extends BaseItem implements Comparable<CallSiteIdItem> {
    String name;
    EncodedArray encodedArrayItem;

    public CallSiteIdItem(String name, EncodedArray encodedArrayItem) {
        this.name = name;
        this.encodedArrayItem = encodedArrayItem;
    }

    @Override
    public void write(DataOut out) {
        out.uint("call_site_off", encodedArrayItem.offset);
    }

    @Override
    public int place(int offset) {
        return offset + 4;
    }

    @Override
    public int compareTo(CallSiteIdItem o) {
        if (o == null) {
            return 1;
        }
        if (name != null) {
            if (o.name == null) {
                return 1;
            } else {
                int x = name.compareTo(o.name);
                if (x != 0) {
                    return x;
                }
            }
        } else {
            if (o.name != null) {
                return -1;
            }
        }
        return encodedArrayItem.compareTo(o.encodedArrayItem);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/ClassDataItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Idx;
import com.googlecode.d2j.dex.writer.ann.Off;
import com.googlecode.d2j.dex.writer.ev.EncodedValue;
import com.googlecode.d2j.dex.writer.io.DataOut;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ClassDataItem extends BaseItem {
    public final List<EncodedField> staticFields = new ArrayList<>(5);
    public final List<EncodedField> instanceFields = new ArrayList<>(5);
    public final List<EncodedMethod> directMethods = new ArrayList<>(5);
    public final List<EncodedMethod> virtualMethods = new ArrayList<>(5);

    @Override
    public int place(int offset) {
        offset += lengthOfUleb128(staticFields.size());
        offset += lengthOfUleb128(instanceFields.size());
        offset += lengthOfUleb128(directMethods.size());
        offset += lengthOfUleb128(virtualMethods.size());
        offset = placeField(offset, staticFields);
        offset = placeField(offset, instanceFields);
        offset = placeMethod(offset, directMethods);
        offset = placeMethod(offset, virtualMethods);
        return offset;
    }

    private int placeMethod(int offset, List<EncodedMethod> methods) {
        if (methods.size() == 0) {
            return offset;
        }
        int lastIdx = 0;
        for (EncodedMethod f : methods) {
            offset += lengthOfUleb128(f.method.index - lastIdx);
            offset += lengthOfUleb128(f.accessFlags);
            offset += lengthOfUleb128(f.code == null ? 0 : f.code.offset);
            lastIdx = f.method.index;
        }
        return offset;
    }

    private int placeField(int offset, List<EncodedField> fields) {
        if (fields.size() == 0) {
            return offset;
        }
        int lastIdx = 0;
        for (EncodedField f : fields) {
            offset += lengthOfUleb128(f.field.index - lastIdx);
            offset += lengthOfUleb128(f.accessFlags);

            lastIdx = f.field.index;
        }
        return offset;
    }

    @Override
    public void write(DataOut out) {
        out.uleb128("static_fields_size", staticFields.size());
        out.uleb128("instance_fields_size", instanceFields.size());
        out.uleb128("ditect_methods_size", directMethods.size());
        out.uleb128("virtual_methods_size", virtualMethods.size());
        writeField(out, staticFields);
        writeField(out, instanceFields);
        writeMethod(out, directMethods);
        writeMethod(out, virtualMethods);
    }

    private void writeMethod(DataOut out, List<EncodedMethod> methods) {
        if (methods == null || methods.size() == 0) {
            return;
        }
        int lastIdx = 0;
        for (EncodedMethod f : methods) {
            out.uleb128("method_idx_diff", f.method.index - lastIdx);
            out.uleb128("access_flags", f.accessFlags);
            out.uleb128("code_off", f.code == null ? 0 : f.code.offset);
            lastIdx = f.method.index;
        }
    }

    private void writeField(DataOut out, List<EncodedField> fields) {
        if (fields == null || fields.size() == 0) {
            return;
        }
        int lastIdx = 0;
        for (EncodedField f : fields) {
            out.uleb128("field_idx_diff", f.field.index - lastIdx);
            out.uleb128("access_flags", f.accessFlags);
            lastIdx = f.field.index;
        }
    }

    public int getMemberSize() {
        return instanceFields.size() + staticFields.size() + directMethods.size() + virtualMethods.size();
    }

    public void prepare(ConstPool cp) {
        Comparator<EncodedField> fc = new Comparator<EncodedField>() {

            @Override
            public int compare(EncodedField arg0, EncodedField arg1) {
                return arg0.field.compareTo(arg1.field);
            }
        };
        Comparator<EncodedMethod> mc = new

                Comparator<EncodedMethod>() {

                    @Override
                    public int compare(EncodedMethod arg0, EncodedMethod arg1) {
                        return arg0.method.compareTo(arg1.method);
                    }
                };
        Collections.sort(instanceFields, fc);
        Collections.sort(staticFields, fc);
        Collections.sort(directMethods, mc);
        Collections.sort(virtualMethods, mc);

    }

    public static class EncodedField {
        public int accessFlags;
        @Idx
        public FieldIdItem field;
        public EncodedValue staticValue;
        public AnnotationSetItem annotationSetItem;
    }

    public static class EncodedMethod {
        public int accessFlags;
        @Idx
        public MethodIdItem method;
        @Off
        public CodeItem code;
        //
        public AnnotationSetItem annotationSetItem;
        public AnnotationSetRefListItem parameterAnnotation;
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/ClassDefItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Idx;
import com.googlecode.d2j.dex.writer.ann.Off;
import com.googlecode.d2j.dex.writer.ev.EncodedArray;
import com.googlecode.d2j.dex.writer.ev.EncodedValue;
import com.googlecode.d2j.dex.writer.io.DataOut;
import com.googlecode.d2j.dex.writer.item.ClassDataItem.EncodedField;
import com.googlecode.d2j.dex.writer.item.ClassDataItem.EncodedMethod;

import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class ClassDefItem extends BaseItem {
    @Idx
    public TypeIdItem clazz;
    public int accessFlags;
    @Idx
    public TypeIdItem superclazz;
    @Off
    public TypeListItem interfaces;
    @Idx
    public StringIdItem sourceFile;
    @Off
    public ClassDataItem classData;
    //
    public AnnotationSetItem classAnnotations;
    @Off
    private AnnotationsDirectoryItem annotations;// Build later
    @Off
    private EncodedArray staticValues; // Build later

    @Override
    public int place(int offset) {
        return offset + 0x20;
    }

    public void prepare(ConstPool cp) {
        if (classData != null) {
            classData.prepare(cp);
        }
        preparteAnnotationsDirectoryItem(cp);
        prepareEncodedArrayItem(cp);
    }

    private void prepareEncodedArrayItem(ConstPool cp) {
        if (classData == null) {
            return;
        }
        List<EncodedField> fs = classData.staticFields;
        int count = -1;
        for (int i = 0; i < fs.size(); i++) {
            EncodedField f = fs.get(i);
            EncodedValue ev = f.staticValue;
            if (ev != null) {
                if (!ev.isDefaultValueForType()) {
                    count = i;
                }
            }
        }

        if (count >= 0) {
            EncodedArray array = new EncodedArray();
            for (int i = 0; i <= count; i++) {
                EncodedField f = fs.get(i);
                EncodedValue ev = f.staticValue;
                if (ev == null) {
                    array.values.add(EncodedValue.defaultValueForType(f.field.getTypeString()));
                } else {
                    array.values.add(ev);
                }
            }
            staticValues = cp.uniqEncodedArrayItem(array);
        }
    }

    private void preparteAnnotationsDirectoryItem(ConstPool cp) {
        Map<FieldIdItem, AnnotationSetItem> fieldAnnotations = new TreeMap<>();
        Map<MethodIdItem, AnnotationSetItem> methodAnnotations = new TreeMap<>();
        Map<MethodIdItem, AnnotationSetRefListItem> parameterAnnotations = new TreeMap<>();
        if (classData != null) {
            collectField(fieldAnnotations, classData.staticFields, cp);
            collectField(fieldAnnotations, classData.instanceFields, cp);
            collectMethod(methodAnnotations, parameterAnnotations, classData.directMethods, cp);
            collectMethod(methodAnnotations, parameterAnnotations, classData.virtualMethods, cp);
        }
        if (this.classAnnotations != null || fieldAnnotations.size() > 0 || methodAnnotations.size() > 0
                || parameterAnnotations.size() > 0) {
            AnnotationsDirectoryItem annotationsDirectoryItem = cp.putAnnotationDirectoryItem();
            this.annotations = annotationsDirectoryItem;
            if (classAnnotations != null) {
                annotationsDirectoryItem.classAnnotations = cp.uniqAnnotationSetItem(classAnnotations);
            }
            if (fieldAnnotations.size() > 0) {
                annotationsDirectoryItem.fieldAnnotations = fieldAnnotations;
            }
            if (methodAnnotations.size() > 0) {
                annotationsDirectoryItem.methodAnnotations = methodAnnotations;
            }
            if (parameterAnnotations.size() > 0) {
                annotationsDirectoryItem.parameterAnnotations = parameterAnnotations;
            }
        }
    }

    private void collectMethod(Map<MethodIdItem, AnnotationSetItem> methodAnnotations,
                               Map<MethodIdItem, AnnotationSetRefListItem> parameterAnnotations, List<EncodedMethod> ms, ConstPool cp) {
        for (EncodedMethod m : ms) {
            if (m.annotationSetItem != null) {
                methodAnnotations.put(m.method, cp.uniqAnnotationSetItem(m.annotationSetItem));
            }
            if (m.parameterAnnotation != null) {
                parameterAnnotations.put(m.method, cp.uniqAnnotationSetRefListItem(m.parameterAnnotation));
            }
        }
    }

    private void collectField(Map<FieldIdItem, AnnotationSetItem> fieldAnnotations, List<EncodedField> fs, ConstPool cp) {
        for (EncodedField f : fs) {
            if (f.annotationSetItem != null) {
                fieldAnnotations.put(f.field, cp.uniqAnnotationSetItem(f.annotationSetItem));
            }
        }
    }

    @Override
    public void write(DataOut out) {
        out.uint("class_idx", clazz.index);
        out.uint("access_flags", this.accessFlags);
        out.uint("superclass_idx", superclazz == null ? NO_INDEX : superclazz.index);
        out.uint("interfaces_off", (interfaces == null || interfaces.items.size() == 0) ? 0 : interfaces.offset);
        out.uint("source_file_idx", sourceFile == null ? NO_INDEX : sourceFile.index);
        out.uint("annotations_off", annotations == null ? 0 : annotations.offset);
        out.uint("class_data_off", classData == null ? 0 : classData.offset);
        out.uint("static_values_off", staticValues == null ? 0 : staticValues.offset);
    }

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/CodeItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.CodeWriter;
import com.googlecode.d2j.dex.writer.ann.Off;
import com.googlecode.d2j.dex.writer.insn.Insn;
import com.googlecode.d2j.dex.writer.insn.JumpOp;
import com.googlecode.d2j.dex.writer.insn.Label;
import com.googlecode.d2j.dex.writer.insn.PreBuildInsn;
import com.googlecode.d2j.dex.writer.io.DataOut;
import com.googlecode.d2j.dex.writer.item.CodeItem.EncodedCatchHandler.AddrPair;
import com.googlecode.d2j.reader.Op;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.*;

public class CodeItem extends BaseItem {

    public int registersSize;
    public int insSize;
    public int outsSize;
    public int insn_size;
    public List<TryItem> tries;
    @Off
    public DebugInfoItem debugInfo;
    public List<Insn> insns;
    public List<EncodedCatchHandler> handlers;

    List<TryItem> _tryItems;
    List<Insn> _ops;
    List<Insn> _tailOps;
    @Override
    public int place(int offset) {
        prepareInsns();
        prepareTries();

        offset += 16 + insn_size * 2;
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                offset += 2;
            }
            offset += 8 * tries.size();
            if (handlers.size() > 0) {
                int base = offset;
                offset += lengthOfUleb128(handlers.size());

                for (EncodedCatchHandler h : handlers) {
                    h.handler_off = offset - base;
                    int size = h.addPairs.size();
                    offset += lengthOfSleb128(h.catchAll != null ? -size : size);
                    for (AddrPair ap : h.addPairs) {
                        offset += lengthOfUleb128(ap.type.index) + lengthOfUleb128(ap.addr.offset);
                    }
                    if (h.catchAll != null) {
                        offset += lengthOfUleb128(h.catchAll.offset);
                    }
                }
            }

        }
        return offset;
    }

    @Override
    public void write(DataOut out) {
        out.ushort("registers_size", registersSize);
        out.ushort("ins_size", insSize);
        out.ushort("outs_size", outsSize);
        out.ushort("tries_size", tries == null ? 0 : tries.size());
        out.uint("debug_info_off", debugInfo == null ? 0 : debugInfo.offset);
        out.uint("insn_size", insn_size);
        ByteBuffer b = ByteBuffer.allocate(insn_size * 2).order(ByteOrder.LITTLE_ENDIAN);
        for (Insn insn : insns) {
            insn.write(b);
        }
        out.bytes("insn", b.array());
        if (tries != null && tries.size() > 0) {
            if ((insn_size & 0x01) != 0) {// padding
                out.skip("padding", 2);
            }
            int lastEnd = 0;
            for (TryItem ti : tries) {
                if (ti.start.offset < lastEnd) {
                    System.err.println("'Out-of-order try' may throwed by libdex");
                }
                out.uint("start_addr", ti.start.offset);
                out.ushort("insn_count", ti.end.offset - ti.start.offset);
                lastEnd = ti.end.offset;
                out.ushort("handler_off", ti.handler.handler_off);
            }
            if (handlers.size() > 0) {
                out.uleb128("size", handlers.size());
                for (EncodedCatchHandler h : handlers) {

                    int size = h.addPairs.size();
                    out.sleb128("size", (h.catchAll != null ? -size : size));
                    for (AddrPair ap : h.addPairs) {
                        out.uleb128("type_idx", (ap.type.index));
                        out.uleb128("addr", (ap.addr.offset));
                    }
                    if (h.catchAll != null) {
                        out.uleb128("catch_all_addr", (h.catchAll.offset));
                    }
                }
            }
        }
    }

    public void init(List<Insn> ops, List<Insn> tailOps, List<TryItem> tryItems) {
        this._ops = ops;
        this._tailOps = tailOps;
        this._tryItems = tryItems;
    }
    private void prepareTries() {
        if (_tryItems.size() > 0) {
            List<CodeItem.TryItem> uniqTrys = new ArrayList<>();
            { // merge dup trys
                Set<TryItem> set = new HashSet<>();
                for (CodeItem.TryItem tryItem : _tryItems) {
                    if (!set.contains(tryItem)) {
                        uniqTrys.add(tryItem);
                        set.add(tryItem);
                    } else {
                        for (TryItem t : uniqTrys) {
                            if (t.equals(tryItem)) {
                                mergeExceptionHandler(t.handler, tryItem.handler);
                            }
                        }
                    }
                }
                set.clear();
                this.tries = uniqTrys;
                if (uniqTrys.size() > 0) {
                    Collections.sort(uniqTrys, new Comparator<TryItem>() {
                        @Override
                        public int compare(TryItem o1, TryItem o2) {
                            int x = o1.start.offset - o2.start.offset;
                            if (x == 0) {
                                x = o1.end.offset - o2.end.offset;
                            }
                            return x;
                        }
                    });
                }
            }
            { // merge dup handlers
                List<CodeItem.EncodedCatchHandler> uniqHanders = new ArrayList<>();
                Map<EncodedCatchHandler, EncodedCatchHandler> map = new HashMap<>();
                for (CodeItem.TryItem tryItem : uniqTrys) {
                    CodeItem.EncodedCatchHandler d = tryItem.handler;
                    CodeItem.EncodedCatchHandler uH = map.get(d);
                    if (uH != null) {
                        tryItem.handler = uH;
                    } else {
                        uniqHanders.add(d);
                        map.put(d, d);
                    }
                }
                this.handlers = uniqHanders;
                map.clear();
            }

        }
    }

    private void mergeExceptionHandler(EncodedCatchHandler to, EncodedCatchHandler from) {
        for (AddrPair pair : from.addPairs) {
            if (!to.addPairs.contains(pair)) {
                to.addPairs.add(pair);
            }
        }
        if (to.catchAll == null) {
            to.catchAll = from.catchAll;
        }
    }

    private void prepareInsns() {
        List<JumpOp> jumpOps=new ArrayList<>();
        for (Insn insn : _ops) {
            if (insn instanceof CodeWriter.IndexedInsn) {
                ((CodeWriter.IndexedInsn) insn).fit();
            } else  if(insn instanceof JumpOp){
                jumpOps.add((JumpOp)insn);
            }
        }

        int codeSize = 0;
        while (true) {
            for (Insn insn : _ops) {
                insn.offset = codeSize;
                codeSize += insn.getCodeUnitSize();
            }
            boolean allfit = true;
            for (JumpOp jop : jumpOps) {
                if (!jop.fit()) {
                    allfit = false;
                }
            }
            if (allfit) {
                break;
            }
            codeSize = 0;
        }
        for (Insn insn : _tailOps) {
            if ((codeSize & 1) != 0) { // not 32bit alignment
                Insn nop = new PreBuildInsn(new byte[] { (byte) Op.NOP.opcode, 0 }); // f10x
                insn.offset = codeSize;
                codeSize += nop.getCodeUnitSize();
                _ops.add(nop);
            }
            insn.offset = codeSize;
            codeSize += insn.getCodeUnitSize();
            _ops.add(insn);
        }
        _tailOps.clear();
        this.insns = _ops;
        this.insn_size = codeSize;
    }

    public static class EncodedCatchHandler {
        public int handler_off;
        public List<AddrPair> addPairs;
        public Label catchAll;

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;

            EncodedCatchHandler that = (EncodedCatchHandler) o;

            if (!addPairs.equals(that.addPairs))
                return false;
            if (catchAll != null ? !catchAll.equals(that.catchAll) : that.catchAll != null)
                return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = addPairs.hashCode();
            result = 31 * result + (catchAll != null ? catchAll.offset : 0);
            return result;
        }

        public static class AddrPair {
            final public TypeIdItem type;
            final public Label addr;

            public AddrPair(TypeIdItem type, Label addr) {
                this.type = type;
                this.addr = addr;
            }

            @Override
            public boolean equals(Object o) {
                if (this == o)
                    return true;
                if (o == null || getClass() != o.getClass())
                    return false;

                AddrPair addrPair = (AddrPair) o;

                if (addr.offset != addrPair.addr.offset)
                    return false;
                if (!type.equals(addrPair.type))
                    return false;

                return true;
            }

            @Override
            public int hashCode() {
                int result = type.hashCode();
                result = 31 * result + addr.offset;
                return result;
            }
        }
    }

    public static class TryItem {
        public Label start;
        public Label end;
        public EncodedCatchHandler handler;

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;

            TryItem tryItem = (TryItem) o;

            if (end.offset != tryItem.end.offset)
                return false;
            if (start.offset != tryItem.start.offset)
                return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = start.offset;
            result = 31 * result + end.offset;
            return result;
        }
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/ConstPool.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.CallSite;
import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.DexType;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.MethodHandle;
import com.googlecode.d2j.Proto;
import com.googlecode.d2j.dex.writer.DexWriteException;
import com.googlecode.d2j.dex.writer.ev.EncodedArray;
import com.googlecode.d2j.dex.writer.ev.EncodedValue;

import java.util.*;

public class ConstPool {
    public int dexVersion = DexConstants.DEX_035;

    public Map<CallSiteIdItem, CallSiteIdItem> callSiteIdItems = new TreeMap<>();
    public Map<EncodedArray, EncodedArray> encodedArrayItems = new TreeMap<>();
    public Map<AnnotationSetRefListItem, AnnotationSetRefListItem> annotationSetRefListItems = new HashMap<>();
    public List<CodeItem> codeItems = new ArrayList<>();
    public List<ClassDataItem> classDataItems = new ArrayList<>();
    public List<DebugInfoItem> debugInfoItems = new ArrayList<>();
    public Map<AnnotationItem, AnnotationItem> annotationItems = new HashMap<>();
    public List<AnnotationsDirectoryItem> annotationsDirectoryItems = new ArrayList<>();
    public Map<AnnotationSetItem, AnnotationSetItem> annotationSetItems = new HashMap<>();
    public Map<FieldIdItem, FieldIdItem> fields = new TreeMap<>();
    public Map<MethodIdItem, MethodIdItem> methods = new TreeMap<>();
    public Map<ProtoIdItem, ProtoIdItem> protos = new TreeMap<>();
    public List<StringDataItem> stringDatas = new ArrayList<>(100);
    public Map<String, StringIdItem> strings = new TreeMap<>();
    public Map<TypeListItem, TypeListItem> typeLists = new TreeMap<>();
    public Map<String, TypeIdItem> types = new TreeMap<>();
    public Map<TypeIdItem, ClassDefItem> classDefs = new HashMap<>();
    public Map<MethodHandleItem, MethodHandleItem> methodHandlers = new TreeMap<>();

    public Object wrapEncodedItem(Object value) {
        if (value instanceof DexType) {
            return uniqType(((DexType) value).desc);
        } else if (value instanceof Field) {
            return uniqField((Field) value);
        } else if (value instanceof String) {
            return uniqString((String) value);
        } else if (value instanceof Method) {
            return uniqMethod((Method) value);
        } else if (value instanceof MethodHandle) {
            return uniqMethodHandle((MethodHandle) value);
        } else if (value instanceof Proto) {
            return uniqProto((Proto) value);
        }
        return value;
    }

    private MethodHandleItem uniqMethodHandle(MethodHandle value) {
        MethodHandleItem mh = new MethodHandleItem();
        mh.type = value.getType();
        Field field = value.getField();
        Method method = value.getMethod();
        if (field != null) {
            mh.field = uniqField(field);
        } else if (method != null) {
            mh.method = uniqMethod(method);
        }

        MethodHandleItem result = methodHandlers.get(mh);
        if (result == null) {
            methodHandlers.put(mh, mh);
            result = mh;
        }

        return result;
    }

    public void clean() {
        encodedArrayItems.clear();
        annotationSetRefListItems.clear();
        codeItems.clear();
        classDataItems.clear();
        debugInfoItems.clear();
        annotationItems.clear();
        annotationsDirectoryItems.clear();
        annotationSetItems.clear();
        fields.clear();
        methods.clear();
        protos.clear();
        stringDatas.clear();
        typeLists.clear();
        types.clear();
        classDefs.clear();
    }

    private String buildShorty(String ret, String[] types2) {
        StringBuilder sb = new StringBuilder();
        if (ret.length() == 1) {
            sb.append(ret);
        } else {
            sb.append("L");
        }
        for (String s : types2) {
            if (s.length() == 1) {
                sb.append(s);
            } else {
                sb.append("L");
            }
        }
        return sb.toString();
    }

    PE iterateParent(ClassDefItem p) {
        List<TypeIdItem> list = new ArrayList<>(6);
        list.add(p.superclazz);
        if (p.interfaces != null) {
            list.addAll(p.interfaces.items);
        }
        return new PE(p, list.iterator());
    }

    public void addDebugInfoItem(DebugInfoItem debugInfoItem) {
        debugInfoItems.add(debugInfoItem);
    }

    public void dex039() {
        if (dexVersion < DexConstants.DEX_039) {
            dexVersion = DexConstants.DEX_039;
        }
    }

    public void dex038() {
        if (dexVersion < DexConstants.DEX_038) {
            dexVersion = DexConstants.DEX_038;
        }
    }

    static class PE {
        final ClassDefItem owner;
        final Iterator<TypeIdItem> it;

        PE(ClassDefItem owner, Iterator<TypeIdItem> it) {
            this.owner = owner;
            this.it = it;
        }
    }

    public List<ClassDefItem> buildSortedClassDefItems() {
        List<ClassDefItem> added = new ArrayList<>();
        Stack<PE> stack1 = new Stack<>();
        Set<ClassDefItem> children = new HashSet<>();

        for (ClassDefItem c : classDefs.values()) {
            if (added.contains(c)) {
                continue;
            }
            children.add(c);
            stack1.push(iterateParent(c));

            while (!stack1.empty()) {
                PE e = stack1.peek();
                boolean canPop = true;
                while (e.it.hasNext()) {
                    TypeIdItem tid = e.it.next();
                    if (tid == null) {
                        continue;
                    }
                    ClassDefItem superDef = classDefs.get(tid);
                    if (superDef != null && !added.contains(superDef)) {
                        if (children.contains(superDef)) {
                            System.err.println("WARN: dep-loop " + e.owner.clazz.descriptor.stringData.string + " -> "
                                    + superDef.clazz.descriptor.stringData.string);
                        } else {
                            canPop = false;
                            children.add(superDef);
                            stack1.push(iterateParent(superDef));
                            break;
                        }
                    }
                }
                if (canPop) {
                    stack1.pop();
                    added.add(e.owner);
                    children.remove(e.owner);
                }
            }
            children.clear();
        }
        return added;
    }

    public AnnotationsDirectoryItem putAnnotationDirectoryItem() {
        AnnotationsDirectoryItem aDirectoryItem = new AnnotationsDirectoryItem();
        annotationsDirectoryItems.add(aDirectoryItem);
        return aDirectoryItem;
    }

    public AnnotationItem uniqAnnotationItem(AnnotationItem key) {
        AnnotationItem v = annotationItems.get(key);
        if (v == null) {
            annotationItems.put(key, key);
            return key;
        }
        return v;
    }

    public ClassDefItem putClassDefItem(int accessFlag, String name, String superClass, String[] itfClass) {
        TypeIdItem type = uniqType(name);
        if (classDefs.containsKey(type)) {
            throw new DexWriteException("dup clz: " + name);
        }
        ClassDefItem classDefItem = new ClassDefItem();
        classDefItem.accessFlags = accessFlag;
        classDefItem.clazz = type;
        if (superClass != null) {
            classDefItem.superclazz = uniqType(superClass);
        }
        if (itfClass != null && itfClass.length > 0) {
            classDefItem.interfaces = putTypeList(Arrays.asList(itfClass));
        }
        classDefs.put(type, classDefItem);
        return classDefItem;
    }

    public FieldIdItem uniqField(Field field) {
        return uniqField(field.getOwner(), field.getName(), field.getType());
    }

    public FieldIdItem uniqField(String owner, String name, String type) {
        FieldIdItem key = new FieldIdItem(uniqType(owner), uniqString(name), uniqType(type));
        FieldIdItem item = fields.get(key);
        if (item != null) {
            return item;
        }
        fields.put(key, key);
        return key;
    }

    public MethodIdItem uniqMethod(Method method) {
        MethodIdItem key = new MethodIdItem(uniqType(method.getOwner()), uniqString(method.getName()), uniqProto(method));
        return uniqMethod(key);
    }

    public MethodIdItem uniqMethod(String owner, String name, String parms[], String ret) {
        MethodIdItem key = new MethodIdItem(uniqType(owner), uniqString(name), uniqProto(parms, ret));
        return uniqMethod(key);
    }

    public MethodIdItem uniqMethod(MethodIdItem key) {
        MethodIdItem item = methods.get(key);
        if (item != null) {
            return item;
        }
        methods.put(key, key);
        return key;
    }

    public ProtoIdItem uniqProto(Proto method) {
        return uniqProto(method.getParameterTypes(), method.getReturnType());
    }
    private ProtoIdItem uniqProto(Method method) {
        return uniqProto(method.getProto());
    }

    public ProtoIdItem uniqProto(String[] types, String retDesc) {
        TypeIdItem ret = uniqType(retDesc);
        StringIdItem shorty = uniqString(buildShorty(retDesc, types));
        TypeListItem params = putTypeList(types);
        ProtoIdItem key = new ProtoIdItem(params, ret, shorty);
        ProtoIdItem item = protos.get(key);
        if (item != null) {
            return item;
        } else {
            protos.put(key, key);
            return key;
        }
    }

    public StringIdItem uniqString(String data) {
        StringIdItem item = strings.get(data);
        if (item != null) {
            return item;
        }
        StringDataItem sd = new StringDataItem(data);
        stringDatas.add(sd);
        item = new StringIdItem(sd);
        strings.put(data, item);
        return item;
    }

    public TypeIdItem uniqType(String type) {
        TypeIdItem item = types.get(type);
        if (item != null) {
            return item;
        }
        item = new TypeIdItem(uniqString(type));
        types.put(type, item);
        return item;
    }

    private TypeListItem putTypeList(String... subList) {
        if (subList.length == 0) {
            return ZERO_SIZE_TYPE_LIST;
        }
        List<TypeIdItem> idItems = new ArrayList<>(subList.length);
        for (String s : subList) {
            idItems.add(uniqType(s));
        }
        TypeListItem key = new TypeListItem(idItems);
        TypeListItem item = typeLists.get(key);
        if (item != null) {
            return item;
        }
        typeLists.put(key, key);
        return key;
    }

    private static final TypeListItem ZERO_SIZE_TYPE_LIST = new TypeListItem(Collections.EMPTY_LIST);
    static {
        // make sure the offset is 0
        ZERO_SIZE_TYPE_LIST.offset = 0;
    }

    private TypeListItem putTypeList(List<String> subList) {
        if (subList.size() == 0) {
            return ZERO_SIZE_TYPE_LIST;
        }
        List<TypeIdItem> idItems = new ArrayList<>(subList.size());
        for (String s : subList) {
            idItems.add(uniqType(s));
        }
        TypeListItem key = new TypeListItem(idItems);
        TypeListItem item = typeLists.get(key);
        if (item != null) {
            return item;
        }
        typeLists.put(key, key);
        return key;
    }

    public ClassDataItem addClassDataItem(ClassDataItem dataItem) {
        classDataItems.add(dataItem);
        return dataItem;
    }

    public CallSiteIdItem uniqCallSite(CallSite callSite) {
        EncodedArray e = new EncodedArray();
        e.values.add(new EncodedValue(EncodedValue.VALUE_METHOD_HANDLE, uniqMethodHandle(callSite.getBootstrapMethodHandler())));
        e.values.add(new EncodedValue(EncodedValue.VALUE_STRING, uniqString(callSite.getMethodName())));
        e.values.add(new EncodedValue(EncodedValue.VALUE_METHOD_TYPE, uniqProto(callSite.getMethodProto())));
        for (Object arg : callSite.getExtraArguments()) {
            e.values.add(EncodedValue.wrap(wrapEncodedItem(arg)));
        }
        CallSiteIdItem k = new CallSiteIdItem(callSite.getName(), uniqEncodedArrayItem(e));

        CallSiteIdItem v = callSiteIdItems.get(k);
        if (v == null) {
            v = k;
            callSiteIdItems.put(v, v);
        }
        return v;
    }

    public EncodedArray uniqEncodedArrayItem(EncodedArray k) {
        EncodedArray v = encodedArrayItems.get(k);
        if (v == null) {
            v = k;
            encodedArrayItems.put(v, v);
        }
        return v;
    }

    public AnnotationSetItem uniqAnnotationSetItem(AnnotationSetItem key) {
        List<AnnotationItem> copy = new ArrayList<AnnotationItem>(key.annotations);
        key.annotations.clear();
        for (AnnotationItem annotationItem : copy) {
            key.annotations.add(uniqAnnotationItem(annotationItem));
        }
        AnnotationSetItem v = annotationSetItems.get(key);
        if (v != null) {
            return v;
        }
        annotationSetItems.put(key, key);
        return key;
    }

    public AnnotationSetRefListItem uniqAnnotationSetRefListItem(AnnotationSetRefListItem key) {
        for (int i = 0; i < key.annotationSets.length; i++) {
            AnnotationSetItem anno = key.annotationSets[i];
            if (anno != null) {
                key.annotationSets[i] = uniqAnnotationSetItem(anno);
            }
        }
        AnnotationSetRefListItem v = annotationSetRefListItems.get(key);
        if (v == null) {
            annotationSetRefListItems.put(key, key);
            return key;
        }
        return v;
    }

    public void addCodeItem(CodeItem code) {
        codeItems.add(code);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/DebugInfoItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.insn.Label;
import com.googlecode.d2j.dex.writer.io.DataOut;

import java.util.ArrayList;
import java.util.List;

public class DebugInfoItem extends BaseItem {
    public List<DNode> debugNodes = new ArrayList<>();
    public StringIdItem parameterNames[];
    public int firstLine;
    public StringIdItem fileName;

    public static class DNode {
        public int op;
        public int reg;
        public int line;
        public Label label;
        StringIdItem name;
        TypeIdItem type;
        StringIdItem sig;

        public static DNode startLocal(int reg, Label label, StringIdItem name, TypeIdItem type) {
            DNode node = new DNode();
            node.reg = reg;
            node.label = label;
            node.name = name;
            node.type = type;
            node.op = DBG_START_LOCAL;
            return node;
        }

        public static DNode line(int line, Label label) {
            DNode node = new DNode();
            node.line = line;
            node.label = label;
            node.op = 99999;
            return node;
        }

        public static DNode startLocalEx(int reg, Label label, StringIdItem name, TypeIdItem type, StringIdItem sig) {
            DNode node = new DNode();
            node.reg = reg;
            node.label = label;
            node.name = name;
            node.type = type;
            node.sig = sig;
            node.op = DBG_START_LOCAL_EXTENDED;
            return node;
        }

        public static DNode endLocal(int reg, Label label) {
            DNode node = new DNode();
            node.reg = reg;
            node.label = label;
            node.op = DBG_END_LOCAL;
            return node;
        }

        public static DNode restartLocal(int reg, Label label) {
            DNode node = new DNode();
            node.reg = reg;
            node.label = label;
            node.op = DBG_RESTART_LOCAL;
            return node;
        }

        public static DNode epiogue(Label label) {
            DNode node = new DNode();
            node.label = label;
            node.op = DBG_SET_EPILOGUE_BEGIN;
            return node;
        }

        public static DNode prologue(Label label) {
            DNode node = new DNode();
            node.label = label;
            node.op = DBG_SET_PROLOGUE_END;
            return node;
        }
    }

    static final int DBG_END_SEQUENCE = 0x00;
    static final int DBG_ADVANCE_PC = 0x01;
    static final int DBG_ADVANCE_LINE = 0x02;
    static final int DBG_START_LOCAL = 0x03;
    static final int DBG_START_LOCAL_EXTENDED = 0x04;
    static final int DBG_END_LOCAL = 0x05;
    static final int DBG_RESTART_LOCAL = 0x06;
    static final int DBG_SET_PROLOGUE_END = 0x07;
    static final int DBG_SET_EPILOGUE_BEGIN = 0x08;
    static final int DBG_SET_FILE = 0x09;
    static final int DBG_FIRST_SPECIAL = 0x0a;
    static final int DBG_LINE_BASE = -4;
    static final int DBG_LINE_RANGE = 15;

    @Override
    public int place(int offset) {
        offset += lengthOfUleb128(firstLine);
        if (parameterNames == null) {
            offset += lengthOfUleb128(0);
        } else {
            offset += lengthOfUleb128(parameterNames.length);
            for (StringIdItem s : parameterNames) {
                offset += lengthOfUleb128(1 + (s == null ? -1 : s.index));
            }

        }
        int line = firstLine;
        int addr = 0;

        if (fileName != null) {
            offset += 1;
            offset += lengthOfUleb128(fileName.index + 1);
        }
        for (DNode opNode : debugNodes) {
            switch (opNode.op) {
            case DBG_START_LOCAL_EXTENDED:
                offset += lengthOfUleb128(opNode.sig.index + 1);
                // through;
            case DBG_START_LOCAL: {
                int pcData = opNode.label.offset - addr;
                if (pcData < 0) {
                    throw new RuntimeException();
                } else if (pcData > 0) {
                    // add an addvance_PC
                    offset += 1;
                    offset += lengthOfUleb128(pcData);
                }
                addr = opNode.label.offset;
            }
                offset += 1;// op;
                offset += lengthOfUleb128(opNode.reg);
                offset += lengthOfUleb128(opNode.name.index + 1);
                offset += lengthOfUleb128(opNode.type.index + 1);
                break;
            case DBG_RESTART_LOCAL:
            case DBG_END_LOCAL: {
                int pcData = opNode.label.offset - addr;
                if (pcData < 0) {
                    throw new RuntimeException();
                } else if (pcData > 0) {
                    // add an addvance_PC
                    offset += 1;
                    offset += lengthOfUleb128(pcData);
                }
                addr = opNode.label.offset;
            }
                offset += 1;// op;
                offset += lengthOfUleb128(opNode.reg);
                break;
            case DBG_SET_EPILOGUE_BEGIN:
            case DBG_SET_PROLOGUE_END:
                offset += 1;
                break;
            case DBG_SET_FILE:
                throw new RuntimeException();
            default:
                int lineDelta = opNode.line - line;
                int addrDelta = opNode.label.offset - addr;
                if (addrDelta < 0) {
                    throw new RuntimeException();
                }
                if (opNode.label.offset == 0 && lineDelta == 0 && addrDelta == 0) { // first line;
                    break;
                }
                if ((lineDelta >= -4 && lineDelta <= 10) && addrDelta <= 15) {
                    // do nothing
                } else {
                    if (addrDelta > 15) { // pc not ok, add addvance_PC
                        offset += 1;
                        offset += lengthOfUleb128(addrDelta);
                        addrDelta = 0;
                    }
                    if (lineDelta < -4 || lineDelta > 10) { // line not ok, add DBG_ADVANCE_LINE
                        offset += 1;
                        offset += lengthOfSleb128(lineDelta);
                        lineDelta = 0;
                    }
                }
                // int op = lineDelta + 4 + addrDelta * DBG_LINE_RANGE + DBG_FIRST_SPECIAL;
                offset += 1;
                line = opNode.line;
                addr = opNode.label.offset;
                break;
            }

        }
        offset += 1;// end sequence;

        return offset;
    }

    @Override
    public void write(DataOut out) {
        out.uleb128("startline", firstLine);
        if (parameterNames == null) {
            out.uleb128("szParams", 0);
        } else {
            out.uleb128("szParams", parameterNames.length);
            for (StringIdItem s : parameterNames) {
                out.uleb128p1("param_name_index", s == null ? -1 : s.index);
            }
        }
        int line = firstLine;
        int addr = 0;

        if (fileName != null) {
            out.sbyte("DBG_SET_FILE", DBG_SET_FILE);
            out.uleb128p1("filename", fileName.index);
        }
        for (DNode opNode : debugNodes) {
            switch (opNode.op) {
            case DBG_START_LOCAL_EXTENDED: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }
                out.sbyte("DBG_START_LOCAL_EXTENDED", DBG_START_LOCAL_EXTENDED);
                out.uleb128("reg", opNode.reg);
                out.uleb128p1("name", opNode.name.index);
                out.uleb128p1("type", opNode.type.index);
                out.uleb128p1("sig", opNode.sig.index);
                break;
            case DBG_START_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }
                out.sbyte("DBG_START_LOCAL", DBG_START_LOCAL);
                out.uleb128("reg", opNode.reg);
                out.uleb128p1("name", opNode.name.index);
                out.uleb128p1("type", opNode.type.index);

                break;
            case DBG_RESTART_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }

                out.sbyte("DBG_RESTART_LOCAL", DBG_RESTART_LOCAL);
                out.uleb128("reg", opNode.reg);
                break;
            case DBG_END_LOCAL: {
                int pcDelta = opNode.label.offset - addr;
                if (pcDelta < 0) {
                    throw new RuntimeException();
                } else if (pcDelta > 0) {
                    addAdvancePC(out, pcDelta);
                }
                addr = opNode.label.offset;
            }

                out.sbyte("DBG_END_LOCAL", DBG_END_LOCAL);
                out.uleb128("reg", opNode.reg);
                break;
            case DBG_SET_EPILOGUE_BEGIN:
                out.sbyte("DBG_SET_EPILOGUE_BEGIN", DBG_SET_EPILOGUE_BEGIN);
                break;
            case DBG_SET_PROLOGUE_END:
                out.sbyte("DBG_SET_PROLOGUE_END", DBG_SET_PROLOGUE_END);
                break;
            case DBG_SET_FILE:
                throw new RuntimeException();
            default:
                int lineDelta = opNode.line - line;
                int addrDelta = opNode.label.offset - addr;
                if (addrDelta < 0) {
                    throw new RuntimeException();
                }
                if (opNode.label.offset == 0 && lineDelta == 0 && addrDelta == 0) { // first line;
                    break;
                }
                if ((lineDelta >= -4 && lineDelta <= 10) && addrDelta <= 15) {
                    // do nothing
                } else {
                    if (addrDelta > 15) { // pc not ok, add addvance_PC
                        addAdvancePC(out, addrDelta);
                        addrDelta = 0;
                    }
                    if (lineDelta < -4 || lineDelta > 10) { // line not ok, add DBG_ADVANCE_LINE
                        addAdvanceLine(out, lineDelta);
                        lineDelta = 0;
                    }
                }
                int op = lineDelta + 4 + addrDelta * DBG_LINE_RANGE + DBG_FIRST_SPECIAL;
                out.sbyte("DEBUG_OP_X", op);
                line = opNode.line;
                addr = opNode.label.offset;
                break;
            }
        }
        out.sbyte("DBG_END_SEQUENCE", DBG_END_SEQUENCE);
    }

    private void addAdvanceLine(DataOut out, int lineDelta) {
        out.sbyte("DBG_ADVANCE_LINE", DBG_ADVANCE_LINE);
        out.sleb128("offset", lineDelta);
    }

    private void addAdvancePC(DataOut out, int delta) {
        out.sbyte("DBG_ADVANCE_PC", DBG_ADVANCE_PC);
        out.uleb128("offset", delta);
    }

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/FieldIdItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Alignment;
import com.googlecode.d2j.dex.writer.ann.Idx;
import com.googlecode.d2j.dex.writer.io.DataOut;

@Alignment(4)

public class FieldIdItem extends BaseItem implements Comparable<FieldIdItem> {
    @Idx
    public final TypeIdItem clazz;
    @Idx
    public final TypeIdItem type;
    @Idx
    public final StringIdItem name;

    public String getTypeString() {
        return type.descriptor.stringData.string;
    }

    public FieldIdItem(TypeIdItem clazz, StringIdItem name, TypeIdItem type) {
        super();
        this.clazz = clazz;
        this.name = name;
        this.type = type;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((clazz == null) ? 0 : clazz.hashCode());
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((type == null) ? 0 : type.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        FieldIdItem other = (FieldIdItem) obj;
        if (clazz == null) {
            if (other.clazz != null)
                return false;
        } else if (!clazz.equals(other.clazz))
            return false;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        if (type == null) {
            if (other.type != null)
                return false;
        } else if (!type.equals(other.type))
            return false;
        return true;
    }

    @Override
    public int place(int offset) {
        return offset + 8;
    }

    @Override
    public int compareTo(FieldIdItem o) {
        if (o == null) {
            return 1;
        }
        int x = clazz.compareTo(o.clazz);
        if (x != 0) {
            return x;
        }
        x = name.compareTo(o.name);
        if (x != 0) {
            return x;
        }
        return type.compareTo(o.type);
    }

    @Override
    public void write(DataOut out) {
        out.ushort("class_idx", clazz.index);
        out.ushort("proto_idx", type.index);
        out.uint("name_idx", name.index);
    }

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/HeadItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.dex.writer.io.DataOut;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class HeadItem extends BaseItem {
    public int version = DexConstants.DEX_035;
    public SectionItem<MapListItem> mapSection;
    public SectionItem<StringIdItem> stringIdSection;
    public SectionItem<TypeIdItem> typeIdSection;
    public SectionItem<ProtoIdItem> protoIdSection;
    public SectionItem<FieldIdItem> fieldIdSection;
    public SectionItem<MethodIdItem> methodIdSection;
    public SectionItem<ClassDefItem> classDefSection;
    public int fileSize = -1;

    public void write(DataOut out) {
        out.uint("magic", 0x0A786564);

        // version in DexConstants is big endian
        out.bytes("version", writeBigEndian(version << 8));
        out.skip4("checksum");
        out.skip("signature", 20);
        out.uint("file_size", fileSize);
        out.uint("head_size", 0x70);
        out.uint("endian_tag", 0x12345678);
        out.skip("link_size,link_off", 8);
        out.uint("map_off", mapSection.items.size() == 0 ? 0 : mapSection.offset);
        out.uint("string_ids_size", stringIdSection.items.size());
        out.uint("string_ids_off", stringIdSection.items.size() == 0 ? 0 : stringIdSection.offset);

        out.uint("type_ids_size", typeIdSection.items.size());
        out.uint("type_ids_off", typeIdSection.items.size() == 0 ? 0 : typeIdSection.offset);

        out.uint("proto_ids_size", protoIdSection.items.size());
        out.uint("proto_ids_off", protoIdSection.items.size() == 0 ? 0 : protoIdSection.offset);

        out.uint("field_ids_size", fieldIdSection.items.size());
        out.uint("field_ids_off", fieldIdSection.items.size() == 0 ? 0 : fieldIdSection.offset);

        out.uint("method_ids_size", methodIdSection.items.size());
        out.uint("method_ids_off", methodIdSection.items.size() == 0 ? 0 : methodIdSection.offset);
        out.uint("class_defs_size", classDefSection.items.size());
        out.uint("class_defs_off", classDefSection.items.size() == 0 ? 0 : classDefSection.offset);

        out.uint("data_size", fileSize - mapSection.offset);   // every thing after map is data section
        out.uint("data_off", mapSection.offset);// map is the first in data section

    }

    private static byte[] writeBigEndian(int value) {
        return ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN)
                .putInt(value).array();
    }

    @Override
    public int place(int offset) {
        return offset + 0x70;
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/MapListItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.io.DataOut;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class MapListItem extends BaseItem {
    final public List<SectionItem<?>> items = new ArrayList<>();

    public int getSize() {
        return 4 + items.size() * 12;
    }

    public void writeMapItem(DataOut out, int type, int size, int offset) {
        out.begin("map_item");
        out.ushort("type", type);
        out.ushort("unused", 0);
        out.uint("size", size);
        out.uint("offset", offset);
        out.end();
    }

    public void cleanZeroSizeEntry() {
        for (Iterator<SectionItem<?>> it = items.iterator(); it.hasNext(); ) {
            SectionItem<?> i = it.next();
            if (i == null || i.items.size() < 1) {
                it.remove();
            }
        }
    }

    public void write(DataOut out) {
        out.begin("map_list");
        out.uint("size", items.size());
        for (SectionItem<?> t : items) {
            writeMapItem(out, t.sectionType.code, t.items.size(), t.offset);
        }
        out.end();
        items.clear();
    }

    @Override
    public int place(int offset) {
        return offset + 4 + items.size() * 12;
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/MethodHandleItem.java`:

```java
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.io.DataOut;

import java.util.Objects;

public class MethodHandleItem extends BaseItem implements Comparable<MethodHandleItem> {
    public int type;
    public FieldIdItem field;
    public MethodIdItem method;

    @Override
    public void write(DataOut out) {
        out.ushort("method_handle_type", type);
        out.ushort("unused", 0);
        out.ushort("field_or_method_id", field != null ? field.index : method.index);
        out.ushort("unused", 0);
    }

    @Override
    public int place(int offset) {
        return offset + 8;
    }

    @Override
    public int compareTo(MethodHandleItem o) {
        if (o == null) {
            return 1;
        }
        int x = Integer.compare(type, o.type);
        if (x != 0) {
            return x;
        }
        if (field != null) {
            return field.compareTo(o.field);
        } else if (method != null) {
            return method.compareTo(o.method);
        } else {
            return -1;
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MethodHandleItem that = (MethodHandleItem) o;
        return type == that.type && Objects.equals(field, that.field) && Objects.equals(method, that.method);
    }

    @Override
    public int hashCode() {
        return Objects.hash(type, field, method);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/MethodIdItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Alignment;
import com.googlecode.d2j.dex.writer.ann.Idx;
import com.googlecode.d2j.dex.writer.io.DataOut;

@Alignment(4)
public class MethodIdItem extends BaseItem implements Comparable<MethodIdItem> {

    public MethodIdItem(TypeIdItem typeItem, StringIdItem nameItem, ProtoIdItem protoIdItem) {
        super();
        this.clazz = typeItem;
        this.name = nameItem;
        this.proto = protoIdItem;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((proto == null) ? 0 : proto.hashCode());
        result = prime * result + ((clazz == null) ? 0 : clazz.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        MethodIdItem other = (MethodIdItem) obj;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        if (proto == null) {
            if (other.proto != null)
                return false;
        } else if (!proto.equals(other.proto))
            return false;
        if (clazz == null) {
            if (other.clazz != null)
                return false;
        } else if (!clazz.equals(other.clazz))
            return false;
        return true;
    }

    @Idx
    public final StringIdItem name;
    @Idx
    public final TypeIdItem clazz;
    @Idx
    public final ProtoIdItem proto;

    @Override
    public int place(int offset) {
        return offset + 0x08;
    }

    @Override
    public int compareTo(MethodIdItem o) {
        if (o == null) {
            return 1;
        }
        int x = clazz.compareTo(o.clazz);
        if (x != 0) {
            return x;
        }
        x = name.compareTo(o.name);
        if (x != 0) {
            return x;
        }
        return proto.compareTo(o.proto);
    }

    @Override
    public void write(DataOut out) {
        out.ushort("class_idx", clazz.index);
        out.ushort("proto_idx", proto.index);
        out.uint("name_idx", name.index);
    }

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/ProtoIdItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Idx;
import com.googlecode.d2j.dex.writer.ann.Off;
import com.googlecode.d2j.dex.writer.io.DataOut;

public class ProtoIdItem extends BaseItem implements Comparable<ProtoIdItem> {
    @Idx
    public final StringIdItem shorty;
    @Idx
    public final TypeIdItem ret;
    @Off
    public final TypeListItem parameters;

    public ProtoIdItem(TypeListItem parameters, TypeIdItem ret, StringIdItem shorty) {
        super();
        this.parameters = parameters;
        this.ret = ret;
        this.shorty = shorty;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((parameters == null) ? 0 : parameters.hashCode());
        result = prime * result + ((ret == null) ? 0 : ret.hashCode());
        result = prime * result + ((shorty == null) ? 0 : shorty.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        ProtoIdItem other = (ProtoIdItem) obj;
        if (parameters == null) {
            if (other.parameters != null)
                return false;
        } else if (!parameters.equals(other.parameters))
            return false;
        if (ret == null) {
            if (other.ret != null)
                return false;
        } else if (!ret.equals(other.ret))
            return false;
        if (shorty == null) {
            if (other.shorty != null)
                return false;
        } else if (!shorty.equals(other.shorty))
            return false;
        return true;
    }

    @Override
    public int place(int offset) {
        return offset + 0x0c;
    }

    @Override
    public int compareTo(ProtoIdItem o) {
        int x = ret.compareTo(o.ret);
        if (x != 0) {
            return x;
        }
        return parameters.compareTo(o.parameters);
    }

    @Override
    public void write(DataOut out) {
        out.uint("shorty_idx", shorty.index);
        out.uint("return_type_idx", ret.index);
        // can't use zero-size type_list_item in libart
        out.uint("parameters_off", (parameters == null || parameters.items.size() == 0) ? 0 : parameters.offset);
    }

}
```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/SectionItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.io.DataOut;
import com.googlecode.d2j.dex.writer.item.StringDataItem.Buffer;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class SectionItem<T extends BaseItem> extends BaseItem {
    final public SectionType sectionType;
    public final List<T> items = new ArrayList<>();

    public SectionItem(SectionType typeCode) {
        super();
        this.sectionType = typeCode;

    }

    public SectionItem(SectionType typeCode, Collection<T> itms) {
        super();
        this.sectionType = typeCode;
        this.items.addAll(itms);
    }

    public static void main(String... strings) throws IllegalArgumentException, IllegalAccessException {
        for (Field f : SectionItem.class.getFields()) {
            if (f.getType().equals(int.class)) {
                if (0 != (f.getModifiers() & Modifier.STATIC)) {
                    System.out.printf("%s(0x%04x,0,0),//\n", f.getName(), f.get(null));
                }
            }
        }
    }

    public int place(int offset) {
        final int startOffset = offset;
        int index = 0;
        for (T t : items) {
            offset = padding(offset, sectionType.alignment);
            t.offset = offset;
            t.index = index;
            index++;
            offset = t.place(offset);
        }
        return offset;
    }

    public void write(DataOut out) {
        out.begin("Section:" + sectionType);
        List<T> items = this.items;
        if (sectionType == SectionType.TYPE_STRING_DATA_ITEM) {
            Buffer buff = new Buffer();

            for (int i = 0; i < items.size(); i++) {
                T t = items.get(i);
                items.set(i, null);
                addPadding(out, sectionType.alignment);
                if (out.offset() != t.offset) {
                    throw new RuntimeException();
                }
                StringDataItem stringDataItem = (StringDataItem) t;
                stringDataItem.write(out, buff);
                buff.reset();
            }
        } else {
            for (int i = 0; i < items.size(); i++) {
                T t = items.get(i);
                items.set(i, null);
                addPadding(out, sectionType.alignment);
                if (out.offset() != t.offset) {
                    System.err.println("Error for type:" + this.sectionType + ", " + t.index);
                    throw new RuntimeException();
                }
                t.write(out);
            }
        }
        out.end();
    }

    public enum SectionType {
        TYPE_HEADER_ITEM(0x0000, 1, 0), //
        TYPE_STRING_ID_ITEM(0x0001, 4, 0), //
        TYPE_TYPE_ID_ITEM(0x0002, 4, 0), //
        TYPE_PROTO_ID_ITEM(0x0003, 4, 0), //
        TYPE_FIELD_ID_ITEM(0x0004, 4, 0), //
        TYPE_METHOD_ID_ITEM(0x0005, 1, 0), //
        TYPE_CLASS_DEF_ITEM(0x0006, 4, 0), //
        TYPE_CALL_SITE_ID_ITEM(0x0007, 4, 0), //
        TYPE_METHOD_HANDLE_ITEM(0x0008, 4, 0), //
        TYPE_MAP_LIST(0x1000, 4, 0), //
        TYPE_TYPE_LIST(0x1001, 4, 0), //
        TYPE_ANNOTATION_SET_REF_LIST(0x1002, 4, 0), //
        TYPE_ANNOTATION_SET_ITEM(0x1003, 4, 0), //
        TYPE_CLASS_DATA_ITEM(0x2000, 1, 0), //
        TYPE_CODE_ITEM(0x2001, 4, 0), //
        TYPE_STRING_DATA_ITEM(0x2002, 1, 0), //
        TYPE_DEBUG_INFO_ITEM(0x2003, 1, 0), //
        TYPE_ANNOTATION_ITEM(0x2004, 1, 0), //
        TYPE_ENCODED_ARRAY_ITEM(0x2005, 1, 0), //
        TYPE_ANNOTATIONS_DIRECTORY_ITEM(0x2006, 4, 0), //
        ;
        public int code;
        public int alignment;

        SectionType(int typeCode, int alignment, int size) {
            this.code = typeCode;
            this.alignment = alignment;
        }
    }

}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/StringDataItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Alignment;
import com.googlecode.d2j.dex.writer.io.DataOut;

import java.io.ByteArrayOutputStream;

@Alignment(1)
public class StringDataItem extends BaseItem implements Comparable<StringDataItem> {
    static public class Buffer extends ByteArrayOutputStream {
        public byte[] getBuf() {
            return buf;
        }
    }

    public static void encode(ByteArrayOutputStream out, String s) {
        final int length = s.length();
        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                out.write(ch);
            } else if (ch <= 2047) {
                out.write((0xc0 | (0x1f & (ch >> 6))));
                out.write((0x80 | (0x3f & ch)));
            } else {
                out.write((0xe0 | (0x0f & (ch >> 12))));
                out.write((0x80 | (0x3f & (ch >> 6))));
                out.write((0x80 | (0x3f & ch)));
            }
        }
    }

    public static int lengthOfMutf8(String s) {
        int result = 0;
        final int length = s.length();
        for (int i = 0; i < length; ++i) {
            char ch = s.charAt(i);
            if (ch != 0 && ch <= 127) { // U+0000 uses two bytes.
                ++result;
            } else if (ch <= 2047) {
                result += 2;
            } else {
                result += 3;
            }
        }
        return result;
    }

    public final String string;

    public StringDataItem(String data) {
        this.string = data;
    }

    @Override
    public int compareTo(StringDataItem o) {
        return string.compareTo(o.string);
    }

    @Override
    public int place(int offset) {
        int length = lengthOfMutf8(string);
        return offset + lengthOfUleb128(string.length()) + length + 1; // 1 for tailing 0
    }

    @Override
    public String toString() {
        return "StringDataItem [string=" + string + "]";
    }

    @Override
    public void write(DataOut out) {
        write(out, new Buffer());
    }

    public void write(DataOut out, Buffer buff) {
        out.uleb128("string_data_length", string.length());
        encode(buff, string);
        buff.write(0);
        out.bytes("mutf8-string", buff.getBuf(), 0, buff.size());
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/StringIdItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Alignment;
import com.googlecode.d2j.dex.writer.ann.Off;
import com.googlecode.d2j.dex.writer.io.DataOut;

@Alignment(4)
public class StringIdItem extends BaseItem implements Comparable<StringIdItem> {
    public StringIdItem(StringDataItem stringDataItem) {
        this.stringData = stringDataItem;
    }

    @Override
    public String toString() {
        return "StringIdItem [stringData=" + stringData + "]";
    }

    @Off
    public final StringDataItem stringData;

    @Override
    public int place(int offset) {
        return offset + 4;
    }

    @Override
    public int compareTo(StringIdItem o) {
        return stringData.compareTo(o.stringData);
    }

    @Override
    public void write(DataOut out) {
        out.uint("string_data_off", stringData.offset);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/TypeIdItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Alignment;
import com.googlecode.d2j.dex.writer.ann.Idx;
import com.googlecode.d2j.dex.writer.io.DataOut;

@Alignment(4)
public class TypeIdItem extends BaseItem implements Comparable<TypeIdItem> {
    public TypeIdItem(StringIdItem stringIdItem) {
        super();
        this.descriptor = stringIdItem;
    }

    @Idx
    public final StringIdItem descriptor;

    @Override
    public int place(int offset) {
        return offset + 0x04;
    }

    @Override
    public String toString() {
        return "TypeIdItem [descriptor=" + descriptor + "]";
    }

    @Override
    public void write(DataOut out) {
        out.uint("descriptor_idx", this.descriptor.index);
    }

    @Override
    public int compareTo(TypeIdItem o) {
        return descriptor.compareTo(o.descriptor);
    }
}

```

`dex-writer/src/main/java/com/googlecode/d2j/dex/writer/item/TypeListItem.java`:

```java
/*
 * dex2jar - Tools to work with android .dex and java .class files
 * Copyright (c) 2009-2013 Panxiaobo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.d2j.dex.writer.item;

import com.googlecode.d2j.dex.writer.ann.Alignment;
import com.googlecode.d2j.dex.writer.ann.Off;
import com.googlecode.d2j.dex.writer.io.DataOut;

import java.util.List;

@Alignment(4)
public class TypeListItem extends BaseItem implements Comparable<TypeListItem> {
    public TypeListItem(List<TypeIdItem> items) {
        super();
        this.items = items;
    }

    @Off
    public final List<TypeIdItem> items;

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((items == null) ? 0 : items.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        TypeListItem other = (TypeListItem) obj;
        if (items == null) {
            if (other.items != null)
                return false;
        } else if (!items.equals(other.items))
            return false;
        return true;
    }

    @Override
    public int place(int offset) {
        return offset + 4 + items.size() * 2;
    }

    @Override
    public void write(DataOut out) {
        out.uint("size", items.size());
        for (TypeIdItem idItem : items) {
            out.ushort("type_idx", idItem.index);
        }
    }

    @Override
    public int compareTo(TypeListItem o) {
        int min = Math.min(items.size(), o.items.size());
        for (int i = 0; i < min; i++) {
            int x = items.get(i).compareTo(o.items.get(i));
            if (x != 0) {
                return x;
            }
        }
        return (items.size() == o.items.size() ? 0 : (items.size() < o.items.size() ? -1 : 1));
    }
}

```

`dex-writer/src/test/java/a/AppWriterTest.java`:

```java
package a;

import com.googlecode.d2j.DexConstants;
import com.googlecode.d2j.Field;
import com.googlecode.d2j.Method;
import com.googlecode.d2j.Visibility;
import com.googlecode.d2j.dex.writer.DexFileWriter;
import com.googlecode.d2j.dex.writer.DexWriteException;
import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.Op;
import com.googlecode.d2j.visitors.*;

import org.junit.Test;

import java.io.File;
import java.io.IOException;

public class AppWriterTest implements DexConstants {
    @Test(expected = DexWriteException.class)
    public void testDupClz() {
        DexFileWriter w = new DexFileWriter();
        DexClassVisitor cv = w.visit(0, "La/b;", null, null);
        cv.visitEnd();
        cv = w.visit(0, "La/b;", null, null);
        cv.visitEnd();
        w.visitEnd();
    }

    @Test
    public void test3() {
        DexFileWriter w = new DexFileWriter();
        DexClassVisitor cv = w.visit(0x1, "La/c;", null, new String[]{"Ljava/lang/Comparable;"});
        cv.visitSource("c.java");
        cv.visitAnnotation("LAnn;", Visibility.SYSTEM).visitEnd();
        DexFieldVisitor fv = cv.visitField(ACC_PUBLIC | ACC_STATIC, new Field("La/c;", "a", "I"), 55);
        fv.visitAnnotation("LE;", Visibility.RUNTIME).visitEnd();
        fv.visitEnd();

        DexMethodVisitor mv = cv.visitMethod(ACC_STATIC, new Method("La/c;", "bb", new String[]{"I"}, "V"));
        mv.visitAnnotation("Laaa;", Visibility.RUNTIME).visitEnd();
        DexAnnotationVisitor dav = mv.visitParameterAnnotation(0).visitAnnotation("Laaa;", Visibility.RUNTIME);
        dav.visit("abc", true);
        DexAnnotationVisitor dav2 = dav.visitArray("efg");
        dav2.visit("", "123");
        dav2.visit("", "456");
        dav2.visitEnd();
        dav.visitEnd();

        DexCodeVisitor code = mv.visitCode();
        code.visitRegister(2);

        code.visitStmt0R(Op.RETURN_VOID);
        code.visitEnd();
        mv.visitEnd();

        cv.visitEnd();


        w.visitEnd();
        w.toByteArray();
    }

    @Test
    public void test4() throws IOException {
        DexFileWriter w = new DexFileWriter();
        DexFileReader dexFileReader = new DexFileReader(new File("../dex-translator/src/test/resources/dexes/i_jetty.dex"));
        dexFileReader.accept(w);
        w.toByteArray();
    }
}

```

`dex-writer/src/test/java/a/CpStringTest.java`:

```java
package a;

import org.junit.Assert;
import org.junit.Test;

import com.googlecode.d2j.dex.writer.item.ConstPool;

public class CpStringTest {
    @Test
    public void test() {
        ConstPool cp = new ConstPool();
        Assert.assertTrue(cp.uniqString("b").compareTo(cp.uniqString("a")) > 0);
        Assert.assertTrue(cp.uniqType("Lb;").compareTo(cp.uniqType("La;")) > 0);
    }

}

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-6.9.1-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
rootProject.name = 'dex2jar'
include ':dex-reader-api', ':dex-reader', ':dex-writer', ':dex-translator', ':dex-ir', ':dex-tools', ':d2j-smali', ':d2j-base-cmd', ':d2j-jasmin'

```