Project Path: arc_Qemu-Gang_Escape-from-TuxKov_i4196ff_

Source Tree:

```txt
arc_Qemu-Gang_Escape-from-TuxKov_i4196ff_
├── CMakeLists.txt
├── README.md
├── extract.sh
├── gdb.sh
├── inject.sh
├── modules
│   ├── m0dular
│   ├── peeper
│   └── vmread
├── reload.sh
└── src
    ├── Main.cpp
    ├── Signatures.h
    ├── globals.h
    ├── hacks
    │   ├── aimbot.cpp
    │   ├── aimbot.h
    │   ├── esp.cpp
    │   ├── esp.h
    │   ├── esp_loot.h
    │   ├── norecoil.cpp
    │   └── norecoil.h
    ├── sdk
    │   ├── Vector.h
    │   ├── mono.h
    │   ├── tarkov.h
    │   ├── unity.cpp
    │   └── unity.h
    └── utils
        ├── Handles.cpp
        ├── InputSystem.cpp
        ├── InputSystem.h
        ├── Logger.cpp
        ├── Logger.h
        ├── Math.h
        ├── Memutils.cpp
        ├── Memutils.h
        └── minitrace.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.8)
project(Escape-from-TuxKov)
set(CMAKE_CXX_STANDARD 17)
include(CheckCXXCompilerFlag)

foreach(COMP_ARG "-Weverything -Wall -Wno-zero-as-null-pointer-constant -Wno-sign-conversion" "-Wno-covered-switch-default" "-Wno-c++98-compat" "-Wno-padded" "-Wno-c++98-compat-pedantic" "-Wno-weak-vtables" "-Wno-documentation-unknown-command" "-Wno-old-style-cast" "-Wno-float-equal" "-Wno-unused-command-line-argument -Wno-reserved-id-macro -Wno-cast-align -Wno-exit-time-destructors -Wno-global-constructors")
  CHECK_CXX_COMPILER_FLAG("${COMP_ARG}" ARG_SUPPORTED)
  if(ARG_SUPPORTED)
    set(WARNING_ARGS "${WARNING_ARGS} ${COMP_ARG}")
  endif()
endforeach(COMP_ARG)

message("Supported warning args: ${WARNING_ARGS}")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${WARNING_ARGS} -pedantic -ldl -fpic -isystem${CMAKE_SOURCE_DIR}/modules -DMVERBOSE=0 -DNUM_THREADS=4 -DMEMUTILS_CUSTOM_RW -DPATTERN_SCAN_PAGE_SCAN")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -O3 -g")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3 -s -fvisibility=hidden -fvisibility-inlines-hidden")

set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS}")

if(NOT CMAKE_BUILD_TYPE)
	message(STATUS "No build type selected, default to Release")
	set(CMAKE_BUILD_TYPE RELEASE)
endif(NOT CMAKE_BUILD_TYPE)

if(USE_EAC_LAUNCHER)
  message("Using EAC Launcher")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DUSE_EAC_LAUNCHER=1")
endif()

if(MTR_ENABLED)
  message("Enabling minitrace")
  set(CMAKE_C_FLAGS "${CMAKE_CXX_FLAGS} -DMTR_ENABLED=1")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DMTR_ENABLED=1")
endif()

if(BUILD_WITH_SANITIZERS)
	message("Enabling ASan")
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize=address")
endif(BUILD_WITH_SANITIZERS)

foreach(SFILE "threading.cpp" "semaphores.cpp" "atomic_lock.cpp" "mutex.cpp" "pattern_scan.cpp")
  list(APPEND SOURCE_FILES_CXX "${CMAKE_SOURCE_DIR}/modules/m0dular/utils/${SFILE}")
endforeach(SFILE)

foreach(SFILE "src/*.cpp" "src/utils/*.cpp" "src/sdk/*.cpp" "src/features/*.cpp" "modules/vmread/hlapi/*.cpp" "modules/peeper/client/peeper.cpp" "src/hacks/*.cpp")
  file(GLOB GLOB_FILES "${CMAKE_SOURCE_DIR}/${SFILE}")
  list(APPEND SOURCE_FILES_CXX ${GLOB_FILES})
endforeach(SFILE)

file(GLOB_RECURSE SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/*.c")

list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/peeper/ext/imgui/examples/libs/gl3w/GL/gl3w.c")
list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/vmread/example.c")
list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/vmread/vmmem.c")
list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/vmread/intmem.c")
list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/vmread/kmem.c")
list(REMOVE_ITEM SOURCE_FILES_CXX "${CMAKE_SOURCE_DIR}/modules/vmread/example.cpp")

message("Source files: ${SOURCE_FILES_CXX}")
message("Source files(C): ${SOURCE_FILES_C}")

find_package(Threads)

include_directories(${INCLUDE_DIRS})

add_library(TuxKov SHARED ${SOURCE_FILES_CXX} ${SOURCE_FILES_C} "${CMAKE_SOURCE_DIR}/modules/vmread/intmem.c" src/hacks/aimbot.cpp src/hacks/aimbot.h)
target_link_libraries(TuxKov dl rt ${CMAKE_THREAD_LIBS_INIT})
target_compile_definitions(TuxKov PUBLIC LMODE=MODE_QEMU_INJECT)

add_executable(TuxKovExternal ${SOURCE_FILES_CXX} ${SOURCE_FILES_C} "${CMAKE_SOURCE_DIR}/modules/vmread/vmmem.c")
target_link_libraries(TuxKovExternal dl rt ${CMAKE_THREAD_LIBS_INIT})
target_compile_definitions(TuxKovExternal PUBLIC LMODE=MODE_EXTERNAL)

```

`README.md`:

```md
# Escape-from-TuxKov
# Build
```
git clone --recursive https://github.com/Qemu-Gang/Escape-from-TuxKov
cd Escap*
mkdir build
cd build
cmake ..
make
```

# Run
- Make sure peeper is running

- `sudo ./TuxKovExternal`

# Notes
- janky between games, restart if it glitches out or stops working.

# Screenshot
![woods](https://i.imgur.com/jiT7atn.png)

# Credits
- https://github.com/frankie-11/eft-external
- various members of the UC reversing thread( respecter, ichbinkrass, more.. )

```

`extract.sh`:

```sh
#!/usr/bin/env bash

qemu_pid=$(pidof qemu-system-x86_64)
filename="$(pwd)/build/libTuxKov.so"

if grep -q "$filename" /proc/"$qemu_pid"/maps; then
    sudo gdb -n -q -batch \
  	-ex "set logging on" \
  	-ex "set logging file /dev/null" \
  	-ex "set logging redirect on" \
    -ex "attach $qemu_pid" \
    -ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
    -ex "set \$dlclose = (int(*)(void*)) dlclose" \
    -ex "set \$library = \$dlopen(\"$filename\", 6)" \
    -ex "call \$dlclose(\$library)" \
	-ex "call \$dlclose(\$library)" \
    -ex "quit"
else
	echo "Library is not injected!"
fi


```

`gdb.sh`:

```sh
#!/bin/bash
# Starts a GDB session on Qemu,
# Sets a couple of things up and then you can use GDB normally

qemu_pid=$(pidof qemu-system-x86_64)
if [ -z "$qemu_pid" ]; then
    /bin/echo -e "\e[31mQemu needs to be open...\e[0m"
    exit 1
fi

#https://www.kernel.org/doc/Documentation/security/Yama.txt
sudo echo "2" | sudo tee /proc/sys/kernel/yama/ptrace_scope # Only allows root to inject code. This is temp until reboot.

echo "Qemu PID: " $qemu_pid

(sudo echo -e "set \$dlopen = (void*(*)(char*, int)) dlopen\n" \
"set \$dlmopen = (void* (*)(long int, char*, int)) dlmopen\n" \
"set \$dlinfo = (int (*)(void*, int, void*)) dlinfo\n" \
"set \$malloc = (void* (*)(long long)) malloc\n" \
"set \$dlerror = (char* (*)(void)) dlerror\n" \
""; cat) | sudo gdb -p $qemu_pid
```

`inject.sh`:

```sh
#!/usr/bin/env bash

qemu_pid=$(pidof qemu-system-x86_64)
filename="$(pwd)/build/libTuxKov.so"

if grep -q "$filename" /proc/"$qemu_pid"/maps; then
    /bin/echo -e "\\e[33mLibrary is already injected... Aborting...\\e[0m"
    exit
fi

sudo gdb -n -q -batch \
  	-ex "set logging on" \
  	-ex "set logging file /dev/null" \
  	-ex "set logging redirect on" \
    -ex "attach $qemu_pid" \
    -ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
    -ex "set \$library = \$dlopen(\"$filename\", 1)" \
    -ex "quit"

```

`reload.sh`:

```sh
#!/usr/bin/env bash

cd build/
make -j$(nproc)
cd ..
sudo bash extract.sh
sudo bash inject.sh

```

`src/Main.cpp`:

```cpp
#include "vmread/hlapi/hlapi.h"
#include "utils/Logger.h"
#include "utils/Memutils.h"
#include "globals.h"
#include "utils/minitrace.h"
#include "utils/InputSystem.h"

#include "m0dular/utils/threading.h"
#include "m0dular/utils/pattern_scan.h"

#include <unistd.h> //getpid
#include <thread>
#include <atomic>
#include <csignal>
#include <numeric>
#include <thread>
#include <chrono>
#include <iostream>

#include "sdk/unity.h"
#include "sdk/mono.h"
#include "peeper/client/peeper.h"
#include "hacks/esp.h"
#include "hacks/norecoil.h"
#include "hacks/aimbot.h"

#define PROCNAME "EscapeFromTarkov.exe"
#define MODNAME "UnityPlayer.dll"
#define MODNAME_MONO "mono-2.0-bdwgc.dll"

#include "Signatures.h"

static thread_t mainThread;
static thread_t inputSystemThread;

#if (LMODE() == MODE_EXTERNAL())

int main() {
    while (running) {
        char c = (char) getchar();

        if (c == 'Q' || c =='q')
            break;
    }

    return 0;
}
#endif

typedef std::chrono::high_resolution_clock Clock;

static bool sigscanFailed = false;

static void *ThreadSignature(const Signature *sig) {
    MTR_SCOPED_TRACE("Initialization", "ThreadedSignature");

    *sig->result = PatternScan::FindPattern(sig->pattern, sig->module);

    if (!*sig->result) {
        Logger::Log("Failed to find pattern {%s}\n", sig->pattern);
        sigscanFailed = true;
    }

    return nullptr;
}

static void UpdateData()
{
    if( localPlayerAddr )
    {
        Player localPlayer = process->Read<Player>( localPlayerAddr );
        ProceduralWeaponAnimation localWeaponAnim = process->Read<ProceduralWeaponAnimation>( (uintptr_t)localPlayer.m_pProceduralWeaponAnimation );
        BreathEffector breathEffector = process->Read<BreathEffector>( (uintptr_t)localWeaponAnim.m_pBreath );
        localPlayerIsAiming = breathEffector.IsAiming;

        //OpticSight sight = process->Read<OpticSight>( (uintptr_t) localWeaponAnim.m_pOpticSightArray );
        //localPlayerIsOpticCamera = (bool)sight.m_pCamera;
    }
    if( cameraAddr )
    {
        cameraEntity = process->Read<CameraEntity>( cameraAddr );
    }
}
static void *MainThread(void *) {
    Logger::Log("Main Loaded.\n");
    pid_t pid;

#if (LMODE() == MODE_EXTERNAL())
    FILE *pipe = popen("pidof qemu-system-x86_64", "r");
    fscanf(pipe, "%d", &pid);
    pclose(pipe);
#else
    pid = getpid();
#endif

#ifdef MTR_ENABLED
    Logger::Log("Initialize performance tracing...\n");
    mtr_init("/tmp/tuxkov.json");
    MTR_META_PROCESS_NAME("TuxKov");
#endif

    Threading::InitThreads();
    auto t1 = Clock::now();

    try {
        MTR_BEGIN("Initialization", "InitCTX");
        WinContext ctx(pid);
        MTR_END("Initialization", "InitCTX");

        MTR_BEGIN("Initialization", "FindProcesses");
        ctx.processList.Refresh();
        for (auto &i : ctx.processList) {
            //Logger::Log("\nFound Process %s(PID:%ld)", i.proc.name, i.proc.pid);
            if (!strcasecmp(PROCNAME, i.proc.name)) {
                Logger::Log("\nFound Process %s(PID:%ld)", i.proc.name, i.proc.pid);
                PEB peb = i.GetPeb();
                short magic = i.Read<short>(peb.ImageBaseAddress);
                uintptr_t translatedBase = VTranslate(&i.ctx->process, i.proc.dirBase, peb.ImageBaseAddress);
                Logger::Log("\tWinBase:\t%p\tBase:\t%p\tQemuBase:\t%p\tMagic:\t%hx (valid: %hhx)\n", (void *) peb.ImageBaseAddress, (void *) i.proc.process,
                            (void *) translatedBase,
                            magic, (char) (magic == IMAGE_DOS_SIGNATURE));
                for (auto &o : i.modules) {
                    if( strstr( o.info.name, MODNAME ) ){
                        Logger::Log("Found Module: (%s) - baseAddr(%p)\n", o.info.name, o.info.baseAddress);
                        process = &i;
                        unityplayerBase = o.info.baseAddress;
                    }
                    else if ( strstr( o.info.name, MODNAME_MONO ) ){
                        Logger::Log("Found Module: (%s) - baseAddr(%p)\n", o.info.name, o.info.baseAddress);
                        monoBase = o.info.baseAddress;
                        //Logger::Log("\t%.8lx\t%.8lx\t%lx\t%s\n", o.info.baseAddress, o.info.entryPoint, o.info.sizeOfModule, o.info.name);
                        for (auto& u : o.exports)
                        {
                            //Logger::Log("\t\t%lx\t%s\n", u.address, u.name);
                            if (!strcmp(u.name, "mono_get_root_domain"))
                            {
                                // 48 8B 05 21 CD 46 00    mov rax, cs:qword_12321213
                                // C3                      retn
                                monoRootDomain = GetAbsoluteAddressVm(*process, u.address, 3, 7);
                                Logger::Log("Mono Root domain(%p)\n", monoRootDomain);
                            }
                        }
                    }
                }
            }
        }
        MTR_END("Initialization", "FindProcesses");

        if (!process) {
            Logger::Log("Could not Find Process/Base. Exiting...\n");
            goto quit;
        }

        MTR_BEGIN("Initialization", "FindSignatures");
        for (const Signature &sig : signatures)
            Threading::QueueJobRef(ThreadSignature, &sig);

        Threading::FinishQueue(true);

        if (sigscanFailed) {
            Logger::Log("One of the sigs failed. Stopping. (Make sure you are in-game)\n");
            goto quit;
        }
        MTR_END("Initialization", "FindSignatures");

        MTR_BEGIN("Initialization", "Setup");
        Logger::Log("gom(%p)\n", gomAddr);
        gom = process->Read<GlobalObjectManager>( gomAddr );

        cameraAddr = Unity::GetObjectPtrByName( "FPS Camera", true );
        Logger::Log("Camera(%p)\n", cameraAddr );

        gameWorldAddr = Unity::GetWorldPtr();
        Logger::Log("Gameworld(%p)\n", gameWorldAddr);


        //Logger::Log("-----Tagged Objects-----\n");
        //Unity::PrintGOMObjects( true );
        //Logger::Log("------------------------\n");
        //Logger::Log("-----Active Objects-----\n");
        //Unity::PrintGOMObjects( false );
        //Logger::Log("------------------------\n");

        Unity::PrintItemStats();
        Unity::PrintPlayerList();

        MTR_END("Initialization", "Setup");

        //mono::init_functions( );
//
        //static auto eft_hard_settings = mono::find_class( "Assembly-CSharp", "EFTHardSettings" )->get_vtable( mono::get_root_domain( ) )->get_static_field_data( );
        //printf( "[EFTHardSettings] -> %p\n", eft_hard_settings );

        auto t2 = Clock::now();
        Logger::Log("Initialization time: %lld ms\n", (long long) std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count());

        Logger::Log("Starting Main Loop.(q to quit)\n");

        mainLoopDone = false;
        while (running) {
            static uint64_t callCount = 0;
            static std::time_t t = 0;
            std::time_t currentTime = std::time(0);
            callCount++;
            if( (currentTime - t) >= 1 ){
                Logger::Log("Hz in last second: %lld\n", callCount);
                callCount = 0;
                t = currentTime;
            }

            UpdateData();
            ESP::DrawPlayers();
            ESP::DrawItems();
            NoRecoil::ApplyNoRecoil();
            //Aimbot::Aim();

            //sleep:
            //std::this_thread::sleep_for(std::chrono::microseconds(1000));
        }
        mainLoopDone = true;
        Logger::Log("Main Loop Ended.\n");
    } catch (VMException &e) {
        Logger::Log("Initialization error: %d\n", e.value);
    }

    quit:
    running = false;

    Threading::FinishQueue(true);
    Threading::EndThreads();

#ifdef MTR_ENABLED
    mtr_flush();
    mtr_shutdown();
#endif

    Logger::Log("Main Ended.\n");

    return nullptr;
}

static void __attribute__((constructor)) Startup() {
    int peeperCode = Peeper::Open();
    if( peeperCode ){
        Logger::Log("Couldn't start peeper! Code: %d \n", peeperCode);
        return;
    }
    inputSystemThread = Threading::StartThread(InputSystem::InputSystem, nullptr, false);
    mainThread = Threading::StartThread(MainThread, nullptr, false);
}

static void __attribute__((destructor)) Shutdown() {
    Logger::Log("Unloading...");

    running = false;

    while( !mainLoopDone ){
        std::this_thread::sleep_for(std::chrono::microseconds(2000));
    }

    Peeper::ClearDraws();
    Peeper::Close();

    if( inputSystemThread )
        Threading::JoinThread(inputSystemThread, nullptr);
    if( mainThread )
        Threading::JoinThread(mainThread, nullptr);

    Logger::Log("Done\n");
}

```

`src/Signatures.h`:

```h
#pragma once

#include <vector>

#include "globals.h"

struct Signature
{
    uintptr_t* result;
    const char* module;
    const char* pattern;

    template<typename T>
    Signature(T& ref, const char* p, const char* m)
    : result((uintptr_t*)&ref), module(m), pattern(p) {}
};

inline std::vector<Signature> signatures = {
    // Example - Signature(entList, "[48 8D 15 *?? ?? ?? ??] 48 C1 E1 05 C1", MODNAME),
    Signature(gomAddr, "[48 8B 05 **?? ?? ?? ??] 66 83 F9 05", MODNAME),
};
```

`src/globals.h`:

```h
#pragma once

#include "sdk/unity.h"
#include "vmread/hlapi/hlapi.h"
#include <vector>
#include <cstdint>
#include <deque>
#include <map>
#include <atomic>
#include <linux/input-event-codes.h>

inline WinProcess *process;
inline uintptr_t unityplayerBase;
inline uintptr_t monoBase;
inline uintptr_t monoRootDomain;
inline uintptr_t gomAddr;
inline GlobalObjectManager gom;
inline uintptr_t gameWorldAddr;
inline uintptr_t cameraAddr;
inline uintptr_t localPlayerAddr;
inline Vector3D localPlayerHead;
inline bool localPlayerIsAiming;
inline bool localPlayerIsOpticCamera;
inline CameraEntity cameraEntity;

inline bool pressedKeys[500]; // keyboard is 0-256 and mouse is > 256, so let's make the array unreasonably big to avoid overwriting other data
inline std::atomic<bool> running = true;
inline bool mainLoopDone = true;
```

`src/hacks/aimbot.cpp`:

```cpp
#include "aimbot.h"

#include "../globals.h"
#include "../sdk/Vector.h"
#include "../utils/Math.h"

#include <csignal>

Vector3D CalculateAngle(const Vector3D &local, const Vector3D &enemy) {
    Vector3D delta = local - enemy;
    //delta.y -= 180.0f;
    //delta.NormalizeAngles();

    float len = delta.Length();

    Vector3D ret;
    ret.y = asinf(delta.y / len ) * RAD2DEG;
    ret.x = -atan2f(delta.x, -delta.z) * RAD2DEG;

    return ret;
}

static MovementContext movement;
void Aimbot::Aim() {
    if( !pressedKeys[KEY_1] )
        return;

    LOCALGAMEWORLD gameworld = process->Read<LOCALGAMEWORLD>( gameWorldAddr );

    Array playerList = process->Read<Array>( (uintptr_t)gameworld.m_pPlayerList );

    for( int i = 0; i < playerList.Count; i++ ){
        uintptr_t playerAddr = process->Read<uintptr_t>((uintptr_t) playerList.m_pList + (0x20 + (i * 8)));
        Player player = process->Read<Player>( playerAddr );
        if( player.m_pLocalPlayerChecker ){
            localPlayerAddr = playerAddr;
        }
    }

    Player localPlayer;
    localPlayer = process->Read<Player>( localPlayerAddr );
    movement = process->Read<MovementContext>( (uintptr_t)localPlayer.m_pMovementContext );
    //std::raise(SIGINT);
    // Garbage data.
    if( playerList.Count > 100 || playerList.Count < 0 )
        return;

    MovementContext localMovement = process->Read<MovementContext>((uintptr_t)localPlayer.m_pMovementContext);

    QAngle localView;
    localView.x = localMovement.ViewAngles.x;
    localView.y = localMovement.ViewAngles.y;

    volatile float fov;
    float bestFov = 999.0f;
    uintptr_t chosenPlayer = 0;
    QAngle chosenPlayerAngle;

    // Get closest player in fov
    for( int i = 0; i < playerList.Count; i++ ) {
        uintptr_t playerAddr = process->Read<uintptr_t>((uintptr_t) playerList.m_pList + (0x20 + (i * 8)));

        if (!playerAddr)
            continue;

        Vector3D headPos = Unity::GetBonePosition( playerAddr, Bones::HumanHead );
        QAngle aimAngle = CalculateAngle( localPlayerHead, headPos );

        fov = Math::AngleFOV( localView, aimAngle );
        Logger::Log("Fov(%f)\n", fov);
        if( fov < bestFov ){
            Logger::Log("FOUND NEW BEST FOV! REEEE!\n");
            bestFov = fov;
            chosenPlayer = playerAddr;
            chosenPlayerAngle = aimAngle;
        }
    }

    if( !chosenPlayer || bestFov > 180.0f ){
        Logger::Log("No suitable aimbot target.\n");
        Logger::Log("best fov(%f)\n", bestFov);
        return;
    }

    Logger::Log("Writing angle..(%f/%f)\n", chosenPlayerAngle.x, chosenPlayerAngle.y);
    localMovement.ViewAngles.x = chosenPlayerAngle.x;
    localMovement.ViewAngles.y = chosenPlayerAngle.y;
    process->Write<MovementContext>( (uintptr_t)localPlayer.m_pMovementContext, localMovement );
}
```

`src/hacks/aimbot.h`:

```h
#pragma once

namespace Aimbot
{
    void Aim();
}
```

`src/hacks/esp.cpp`:

```cpp
#include "esp.h"
#include "esp_loot.h"

#include "../globals.h"
#include "../sdk/unity.h"
#include "peeper/client/peeper.h"
#include "../utils/Logger.h"

#include <csignal>
#include <ios>
#include <iostream>

const int arm_right[] = { Bones::HumanRUpperarm, Bones::HumanRForearm1, Bones::HumanRPalm };
const int arm_left[] = { Bones::HumanLUpperarm, Bones::HumanLForearm1, Bones::HumanLPalm };

const int leg_right[] = { Bones::HumanRThigh1, Bones::HumanRCalf, Bones::HumanRFoot };
const int leg_left[] = { Bones::HumanLThigh1, Bones::HumanLCalf, Bones::HumanLFoot };

void ESP::DrawPlayers( ) {
    LOCALGAMEWORLD gameworld = process->Read<LOCALGAMEWORLD>( gameWorldAddr );

    Array playerList = process->Read<Array>( (uintptr_t)gameworld.m_pPlayerList );

    for( int i = 0; i < playerList.Count; i++ ){
        Vector2D head2D, neck2D, pelvis2D;
        float distance;
        char buffer[8];
        std::string text;
        Color color;
        Player player;
        PlayerProfile profile;
        PlayerInfo info;
        UnityEngineString name;
        HealthController healthController;
        HealthBody healthBody;
        BodyController bodyController;
        float hp = 0;

        uintptr_t playerAddr = process->Read<uintptr_t>((uintptr_t)playerList.m_pList + (0x20 + (i * 8)) );

        if( !playerAddr )
            continue;

        player = process->Read<Player>( playerAddr );

        // Check for localplayer while we're itering over these. Not ideal but whatever
        if( player.m_pLocalPlayerChecker ){
            localPlayerAddr = playerAddr;
            localPlayerHead = Unity::GetBonePosition( localPlayerAddr, Bones::HumanHead );
            continue;
        }

        Vector3D headPos = Unity::GetBonePosition( playerAddr, Bones::HumanHead );
        if( !Unity::World2Screen( headPos, &head2D ) )
            continue;
        Vector3D neckPos = Unity::GetBonePosition( playerAddr, Bones::HumanNeck );
        if( !Unity::World2Screen( neckPos, &neck2D ) )
            continue;
        Vector3D pelvisPos = Unity::GetBonePosition( playerAddr, Bones::HumanPelvis );
        if( !Unity::World2Screen( pelvisPos, &pelvis2D ) )
            continue;

        // Needed bones for anything
        if( !Unity::World2Screen( headPos, &head2D )
        || !Unity::World2Screen( neckPos, &neck2D )
        || !Unity::World2Screen( pelvisPos, &pelvis2D ) ){
            continue;
        }

        // Scav color check
        profile = process->Read<PlayerProfile>( (uintptr_t)player.m_pPlayerProfile );
        info = process->Read<PlayerInfo>( (uintptr_t)profile.m_PlayerInfo );
        name = process->Read<UnityEngineString>( (uintptr_t)info.m_pPlayerName );
        healthController = process->Read<HealthController>( (uintptr_t)player.m_pHealthController );
        healthBody = process->Read<HealthBody>( (uintptr_t)healthController.m_pHealthBody );
        bodyController = process->Read<BodyController>( (uintptr_t)healthBody.m_pBodyController );

        // Calculate HP
        for( int limb = 0; limb < NUM_BODY_PARTS; limb++ )
        {
            HealthContainer bodypart = process->Read<HealthContainer>( (uintptr_t)bodyController.m_bodyParts[limb].m_pBodyPart );
            Health bodypartHealth = process->Read<Health>( (uintptr_t)bodypart.m_pHealth );
            hp += bodypartHealth.Health;
        }

        // humans have creationdate
        if( info.CreationDate > 0 ){
            // player scav
            if( info.Side == 4 )
            {
                color = Color( 28, 67, 193, 255 );
            }
            else
            {
                color = Color( 225, 0, 0, 255 );
            }
        } else {
            color = Color( 255, 179, 71, 255 );
        }

        // Draw Spine
        Peeper::AddLine( head2D.x, head2D.y, neck2D.x, neck2D.y, color, 1.0f );
        Peeper::AddLine( neck2D.x, neck2D.y, pelvis2D.x, pelvis2D.y, color, 1.0f );

        // Draw distance
        if( localPlayerAddr ){
            distance = localPlayerHead.Distance( headPos );
            sprintf(buffer, "%0.1fm", distance );
            text += '(';
            text += buffer;
            text += ')';
            // Draw Name if not scav
            if( info.Side != 4 )
            {
                char playername[64] = { 0 };
                int j = 0;
                // the legendary unicode byte skipper
                for(int byte = 0; (byte < (name.size * 2) + 2); byte++)
                {
                    if((byte % 2) != 0)
                        continue;

                    char ascii = ((char*)(&name.name[0]))[byte];
                    // set this manually like a man
                    if (ascii <= 0 || ascii > 127)
                        continue;

                    playername[j] = ascii;
                    j++;
                }

                playername[std::min(63, (name.size * 2) + 2)] = '\0';
                playername[63] = '\0';
                text += '-';
                text += playername;
            }

            sprintf(buffer, "%0.0f", hp );
            text += " [";
            text += buffer;
            text += ']';

            Peeper::AddText( head2D.x, head2D.y, color, text.c_str() );

            // if they are very far, end here and dont draw more limbs
            if( distance > 200.0f ){
                continue;
            }
        }



        // Draw right arm
        Vector2D previous = neck2D;
        for( const int bone : arm_right ){
            Vector2D bone2D;
            Vector3D bone3D = Unity::GetBonePosition( playerAddr, bone );

            if( !Unity::World2Screen( bone3D, &bone2D ) )
                continue;

            Peeper::AddLine( previous.x, previous.y, bone2D.x, bone2D.y, color, 1.0f );
            previous = bone2D;
        }

        // Draw left arm
        previous = neck2D;
        for( const int bone : arm_left ){
            Vector2D bone2D;
            Vector3D bone3D = Unity::GetBonePosition( playerAddr, bone );

            if( !Unity::World2Screen( bone3D, &bone2D ) )
                continue;

            Peeper::AddLine( previous.x, previous.y, bone2D.x, bone2D.y, color, 1.0f );
            previous = bone2D;
        }

        // Draw right leg
        previous = pelvis2D;
        for( const int bone : leg_right ){
            Vector2D bone2D;
            Vector3D bone3D = Unity::GetBonePosition( playerAddr, bone );

            if( !Unity::World2Screen( bone3D, &bone2D ) )
                continue;

            Peeper::AddLine( previous.x, previous.y, bone2D.x, bone2D.y, color, 1.0f );
            previous = bone2D;
        }

        // Draw left leg
        previous = pelvis2D;
        for( const int bone : leg_left ){
            Vector2D bone2D;
            Vector3D bone3D = Unity::GetBonePosition( playerAddr, bone );

            if( !Unity::World2Screen( bone3D, &bone2D ) )
                continue;

            if( !Peeper::AddLine( previous.x, previous.y, bone2D.x, bone2D.y, color, 1.0f ) ){
                Logger::Log("Warning! Too many draw requests!\n");
            }
            previous = bone2D;
        }
    }

    Peeper::SubmitDraws();
}

void ESP::DrawItems() {
    char nameBuffer[128];
    float distance;
    Vector2D item2D;
    bool queueFull = false;

    static const Color defaultItemColor = Color( 169, 169, 169, 175 );
    static const Color goodItemColor = Color( 255, 0, 255, 200 );
    static const Color corpseColor = Color( 255, 182, 193, 200 );

    LOCALGAMEWORLD gameworld = process->Read<LOCALGAMEWORLD>( gameWorldAddr );

    LootArray itemList = process->Read<LootArray>((uintptr_t)gameworld.m_pItemList );

    for( int i = 0; i < itemList.Count; i++ ){
        uintptr_t itemAddr = process->Read<uintptr_t>((uintptr_t)itemList.m_pItemList + (0x20 + (i * 8)) );

        if( !itemAddr )
            continue;

        const Color *itemColoring = &defaultItemColor;

        // Get Item Location and name
        Item item = process->Read<Item>( itemAddr );
        ItemProfile itemProfile = process->Read<ItemProfile>( (uintptr_t)item.m_pItemProfile );
        ItemBasicInformation itemBasicInformation = process->Read<ItemBasicInformation>( (uintptr_t)itemProfile.m_pItemInformation );
        ItemLocalization itemLocalization = process->Read<ItemLocalization>( (uintptr_t)itemBasicInformation.m_pItemLocalization );
        ItemCoordinates itemCoordinates = process->Read<ItemCoordinates>( (uintptr_t)itemLocalization.m_pItemCoordinates );
        ItemLocationContainer itemLocationContainer = process->Read<ItemLocationContainer>( (uintptr_t)itemCoordinates.m_pItemLocationContainer );

        if( !Unity::World2Screen( itemLocationContainer.ItemPosition, &item2D ) )
            continue;

        process->Read( (uintptr_t)itemBasicInformation.ItemPatName, nameBuffer, 128 );

        if( IsPlayerCorpse( nameBuffer ) ){
            itemColoring = &corpseColor;
            strcpy(nameBuffer, "body");
        } else if( IsGoodLoot( nameBuffer ) ){
            itemColoring = &goodItemColor;
            //strcpy(nameBuffer, "goodie");
        } else {
            distance = localPlayerHead.Distance( itemLocationContainer.ItemPosition );
            if( distance > 50.0f )
                continue;
            nameBuffer[127] = '\0';
        }

        queueFull |= !Peeper::AddCircle( item2D.x, item2D.y, *itemColoring, std::min(distance / 6, 8.0f), 16, 1.0f );
        queueFull |= !Peeper::AddText( item2D.x, item2D.y, *itemColoring, nameBuffer );

        //Logger::Log("Item Name: (%s)\n", nameBuffer );
    }

    if( queueFull )
        Logger::Log("Warning! Draw queue full!\n");
}
```

`src/hacks/esp.h`:

```h
#pragma once

#include <cstdint>

namespace ESP
{
    void DrawPlayers();
    void DrawItems();
}
```

`src/hacks/esp_loot.h`:

```h
#pragma once

#include <cstring>

static inline bool IsPlayerCorpse( const char *string )
{
    // This picks up scav corpses too for some reason
    return !strncmp( string, "Observed_Player", 15 );
}

static inline bool IsGoodLoot( const char *string )
{
    bool isGood = false;
    isGood |= (bool)strstr( string, "_transilluminator" );
    //isGood |= (bool)strstr( string, "key_" );
    isGood |= (bool)strstr( string, "gl40" );
    isGood |= (bool)strstr( string, "lab" );
    isGood |= (bool)strstr( string, "info_intelligence" );
    isGood |= (bool)strstr( string, "video_card" );
    isGood |= (bool)strstr( string, "barter_electr_tetriz" );

    return isGood;
}
```

`src/hacks/norecoil.cpp`:

```cpp
#include "norecoil.h"

#include "../globals.h"
#include "../utils/Logger.h"


void NoRecoil::ApplyNoRecoil( ) {
    if( !localPlayerAddr )
        return;

    Player localplayer = process->Read<Player>( localPlayerAddr );
    ProceduralWeaponAnimation weaponAnimation = process->Read<ProceduralWeaponAnimation>( (uintptr_t)localplayer.m_pProceduralWeaponAnimation );

    //HandsController handsController = process->Read<HandsController>( (uintptr_t)localplayer.m_pHandsController );
    //WeaponItem weaponItem = process->Read<WeaponItem>( (uintptr_t)handsController.m_pWeaponItem );
    //ItemTemplate itemTemplate = process->Read<ItemTemplate>( (uintptr_t) weaponItem.m_BackingField);
    //itemTemplate.m_allowFeed = false;
    //itemTemplate.m_allowJam = false;
    //itemTemplate.m_allowMisfire = false;
    //itemTemplate.m_allowSlide = false;
    //process->Write<ItemTemplate>( (uintptr_t) weaponItem.m_BackingField, itemTemplate );

    //Logger::Log("proceduralWeaponAnim (%p)\n", localplayer.m_pProceduralWeaponAnimation);
    ShotEffector shotEffector = process->Read<ShotEffector>( (uintptr_t)weaponAnimation.m_pShooting );
    shotEffector.recoilHori = 0.0f;
    shotEffector.recoilVert = 0.0f;
    process->Write<ShotEffector>( (uintptr_t)weaponAnimation.m_pShooting, shotEffector );

    BreathEffector breathEffector = process->Read<BreathEffector>( (uintptr_t)weaponAnimation.m_pBreath );
    breathEffector.Intensity = 0.0f;
    process->Write<BreathEffector>( (uintptr_t)weaponAnimation.m_pBreath, breathEffector );

    weaponAnimation.mask = 1;
    process->Write<ProceduralWeaponAnimation>( (uintptr_t)localplayer.m_pProceduralWeaponAnimation, weaponAnimation );

    FirearmController fire = process->Read<FirearmController>( (uintptr_t)weaponAnimation.m_pFiring );

    WeaponItem weaponItem = process->Read<WeaponItem>( (uintptr_t)fire.m_pItem );
    WeaponTemplate weaponTemplate = process->Read<WeaponTemplate>( (uintptr_t)weaponItem.m_BackingField );
    if (weaponTemplate.m_allowFeed)
    {
        weaponTemplate.m_allowSlide = false;
        weaponTemplate.m_allowMisfire = false;
        weaponTemplate.m_allowJam = false;
        weaponTemplate.m_allowFeed = false;
        process->Write<WeaponTemplate>( (uintptr_t)weaponItem.m_BackingField, weaponTemplate );
    }

    fire.m_hipInaccuracy = 0.0f;
    //fire.m_weaponLn = 0.1f; // buggy
    process->Write<FirearmController>( (uintptr_t)weaponAnimation.m_pFiring, fire );
    //process->Write<int32_t>( (uintptr_t)localplayer.m_pProceduralWeaponAnimation + offsetof(ProceduralWeaponAnimation, Mask), 1 );


    //process->Write<float>( (uintptr_t)weaponAnimation.m_pFiring + offsetof(Firing, floater1), 1.0f );
    //process->Write<float>( (uintptr_t)weaponAnimation.m_pFiring + offsetof(Firing, floater2), 0.0f ); // spread
    //process->Write<float>( (uintptr_t)weaponAnimation.m_pFiring + offsetof(Firing, floater3), 1.0f );
    //fire.bulletSpeedMultiplier = 5.0f;
    //process->Write<float>( (uintptr_t)weaponAnimation.m_pFiring + offsetof(Firing, bulletSpeedMultiplier), 4.9f );
}
```

`src/hacks/norecoil.h`:

```h
#pragma once

namespace NoRecoil
{
    void ApplyNoRecoil();
}
```

`src/sdk/Vector.h`:

```h
#pragma once

#include <cmath>

struct Vector2D
{
    float x, y;
};

struct Vector3D
{
    float x, y, z;

    Vector3D operator-( const Vector3D& input ) const
    {
        return Vector3D{ x - input.x, y - input.y, z - input.z };
    }

    float DotProduct( Vector3D input ) const
    {
        return ( x * input.x ) + ( y * input.y ) + ( z * input.z );
    }

    float Length() const
    {
        return sqrt( ( x * x ) + ( y * y ) + ( z * z ) );
    }

    float Length2D() const
    {
        return sqrt( ( x * x ) + ( y * y ) );
    }

    float Distance( Vector3D input ) const
    {
        return ( *this - input ).Length();
    }

    float Distance2D( Vector3D input ) const
    {
        return ( *this - input ).Length2D();
    }

    void NormalizeAngles()
    {
        while (y > 89.0f)
            y -= 180.0f;

        while (y < -89.0f)
            y += 180.0f;

        while (x > 360.0f)
            x -= 720.0f;

        while (x < 0.0f)
            x += 720.0f;
    }
};

typedef Vector3D QAngle;

struct Matrix4x4
{
    inline Matrix4x4(){}
    inline Matrix4x4(
            float m00, float m01, float m02, float m03,
            float m10, float m11, float m12, float m13,
            float m20, float m21, float m22, float m23,
            float m30, float m31, float m32, float m33 )
    {
        Init(
                m00, m01, m02, m03,
                m10, m11, m12, m13,
                m20, m21, m22, m23,
                m30, m31, m32, m33
        );
    }

    inline void Init(
            float m00, float m01, float m02, float m03,
            float m10, float m11, float m12, float m13,
            float m20, float m21, float m22, float m23,
            float m30, float m31, float m32, float m33
    )
    {
        m[ 0 ][ 0 ] = m00;
        m[ 0 ][ 1 ] = m01;
        m[ 0 ][ 2 ] = m02;
        m[ 0 ][ 3 ] = m03;

        m[ 1 ][ 0 ] = m10;
        m[ 1 ][ 1 ] = m11;
        m[ 1 ][ 2 ] = m12;
        m[ 1 ][ 3 ] = m13;

        m[ 2 ][ 0 ] = m20;
        m[ 2 ][ 1 ] = m21;
        m[ 2 ][ 2 ] = m22;
        m[ 2 ][ 3 ] = m23;

        m[ 3 ][ 0 ] = m30;
        m[ 3 ][ 1 ] = m31;
        m[ 3 ][ 2 ] = m32;
        m[ 3 ][ 3 ] = m33;
    }
    Matrix4x4 Transpose( ) const
    {
        return Matrix4x4(
                m[ 0 ][ 0 ], m[ 1 ][ 0 ], m[ 2 ][ 0 ], m[ 3 ][ 0 ],
                m[ 0 ][ 1 ], m[ 1 ][ 1 ], m[ 2 ][ 1 ], m[ 3 ][ 1 ],
                m[ 0 ][ 2 ], m[ 1 ][ 2 ], m[ 2 ][ 2 ], m[ 3 ][ 2 ],
                m[ 0 ][ 3 ], m[ 1 ][ 3 ], m[ 2 ][ 3 ], m[ 3 ][ 3 ] );
    }
    float m[ 4 ][ 4 ];
};
```

`src/sdk/mono.h`:

```h
// many thanks big sir for doing the needful paste!!
// https://github.com/reahly/mono-external-lib/blob/main/mono.hh

#pragma once
#include <unordered_map>
#include <codecvt>
#include <string>
#include <locale>
#include <cstdarg>
#include "../globals.h"

inline int sprintf_s(char* buffer, size_t sizeOfBuffer, const char* format, ...)
{
    va_list ap;
    va_start(ap, format);
    int result = vsnprintf(buffer, sizeOfBuffer, format, ap);
    va_end(ap);
    return result;
}

//#define OFFSET(func, type, offset) type func { return read<type>( reinterpret_cast<uintptr_t>( this ) + offset ); }
#define OFFSET(func, type, offset) type func { return process->Read<type>( reinterpret_cast<uintptr_t>( this ) + offset ); }

inline std::unordered_map<uintptr_t, uintptr_t> functions;

inline unsigned short utf8_to_utf16( const char* val ) {
    std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> convert;
    std::u16string dest = convert.from_bytes( val );
    return *reinterpret_cast<unsigned short*>( &dest[0] );
}

inline std::string read_widechar( const std::uintptr_t address, const std::size_t size ) {
    const auto buffer = std::make_unique<char[]>( size );
    //raw_read( address, buffer.get( ), size );
    process->Read( address, buffer.get(), size);
    return std::string( buffer.get( ) );
}

struct glist_t {
    OFFSET( data( ), uintptr_t, 0x0 )
    OFFSET( next( ), uintptr_t, 0x8 )
};

struct mono_root_domain_t {
    OFFSET( domain_assemblies( ), glist_t*, 0xC8 )
    OFFSET( domain_id( ), int, 0xBC )
    OFFSET( jitted_function_table( ), uintptr_t, 0x148 )
};

struct mono_table_info_t {
    int get_rows( ) {
        //return read<int>( reinterpret_cast<uintptr_t>( this ) + 0x8 ) & 0xFFFFFF;
        return process->Read<int>( reinterpret_cast<uintptr_t>( this ) + 0x8 ) & 0xFFFFFF;
    }
};

struct mono_method_t {
    std::string name( ) {
        //auto name = read_widechar( read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x18 ), 128 );
        auto name = read_widechar( process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x18 ), 128 );
        if ( static_cast<std::uint8_t>( name[0] ) == 0xEE ) { // https://github.com/cheat-engine/cheat-engine/blob/8bdb7f28a9d40ccaa6f4116b13c570907ce9ee2e/Cheat%20Engine/MonoDataCollector/MonoDataCollector/PipeServer.cpp#L896
            char name_buff[ 32 ];
            sprintf_s( name_buff, 32, "\\u%04X", utf8_to_utf16( const_cast<char*>( name.c_str( ) ) ) );
            name = name_buff;
        }

        return name;
    }
};

struct mono_class_field_t {
    OFFSET( offset( ), int, 0x18 )

    std::string name( ) {
        //auto name = read_widechar( read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x8 ), 128 );
        auto name = read_widechar( process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x8 ), 128 );
        if ( static_cast<std::uint8_t>( name[0] ) == 0xEE ) {
            char name_buff[ 32 ];
            sprintf_s( name_buff, 32, "\\u%04X", utf8_to_utf16( const_cast<char*>( name.c_str( ) ) ) );
            name = name_buff;
        }

        return name;
    }
};

struct mono_class_runtime_info_t {
    OFFSET( max_domain( ), int, 0x0 )
};

struct mono_vtable_t {
    OFFSET( flags( ), uint8_t, 0x30 )

    uintptr_t get_static_field_data( ) {
        if ( ( this->flags( ) & 4 ) != 0 )
        {
            //return read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x40 + 8 * read<int>( read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x0 ) + 0x5c ) );
            return process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x40 + 8 * process->Read<int>( process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x0 ) + 0x5c ) );
        }

        return 0;
    }
};

struct mono_class_t {
    OFFSET( num_fields( ), int, 0x100 )
    OFFSET( runtime_info( ), mono_class_runtime_info_t*, 0xd0 )

    std::string name( ) {
        //auto name = read_widechar( read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x48 ), 128 );
        auto name = read_widechar( process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x48 ), 128 );
        if ( static_cast<std::uint8_t>( name[0] ) == 0xEE ) {
            char name_buff[ 32 ];
            sprintf_s( name_buff, 32, "\\u%04X", utf8_to_utf16( const_cast<char*>( name.c_str( ) ) ) );
            name = name_buff;
        }

        return name;
    }

    std::string namespace_name( ) {
        //auto name = read_widechar( read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x50 ), 128 );
        auto name = read_widechar( process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x50 ), 128 );
        if ( static_cast<std::uint8_t>( name[0] ) == 0xEE ) {
            char name_buff[32];
            sprintf_s( name_buff, 32, ( "\\u%04X" ), utf8_to_utf16( const_cast<char*>( name.c_str( ) ) ) );
            name = name_buff;
        }

        return name;
    }

    int get_num_methods( ) {
        //const auto v2 = ( read<int>( reinterpret_cast<uintptr_t>( this ) + 0x2a ) & 7 ) - 1;
        const auto v2 = ( process->Read<int>( reinterpret_cast<uintptr_t>( this ) + 0x2a ) & 7 ) - 1;
        switch ( v2 ) {
            case 0:
            case 1:
            {
                //return read<int>( reinterpret_cast<uintptr_t>( this ) + 0xFC );
                return process->Read<int>( reinterpret_cast<uintptr_t>( this ) + 0xFC );
            }
            case 3:
            case 5:
                return 0;

            case 4u:
            {
                //return read<int>( reinterpret_cast<uintptr_t>( this ) + 0xF0 );
                return process->Read<int>( reinterpret_cast<uintptr_t>( this ) + 0xF0 );
            }

            default: break;
        }

        return 0;
    }

    mono_method_t* get_method( const int i ) {
        //return reinterpret_cast<mono_method_t*>( read<uintptr_t>( read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0xA0 ) + 0x8 * i ) );
        return reinterpret_cast<mono_method_t*>( process->Read<uintptr_t>( process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0xA0 ) + 0x8 * i ) );
    }

    mono_class_field_t* get_field( const int i ) {
        //return reinterpret_cast<mono_class_field_t*>( read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x98 ) + 0x20 * i );
        return reinterpret_cast<mono_class_field_t*>( process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( this ) + 0x98 ) + 0x20 * i );
    }

    mono_vtable_t* get_vtable( mono_root_domain_t* domain ) {
        const auto runtime_info = this->runtime_info( );
        if ( !runtime_info )
            return nullptr;

        const auto domain_id = domain->domain_id( );
        if ( runtime_info->max_domain( ) < domain_id )
            return nullptr;

        //return reinterpret_cast<mono_vtable_t*>( read<uintptr_t>( reinterpret_cast<uintptr_t>( runtime_info ) + 8 * domain_id + 8 ) );
        return reinterpret_cast<mono_vtable_t*>( process->Read<uintptr_t>( reinterpret_cast<uintptr_t>( runtime_info ) + 8 * domain_id + 8 ) );
    }

    mono_method_t* find_method( const char* method_name ) {
        auto mono_ptr = uintptr_t( );
        for ( auto i = 0; i < this->get_num_methods( ); i++ ) {
            const auto method = this->get_method( i );
            if ( !method )
                continue;

            if ( !strcmp( method->name( ).c_str( ), method_name ) )
                mono_ptr = reinterpret_cast<uintptr_t>( method );
        }

        return reinterpret_cast<mono_method_t*>( functions[mono_ptr] );
    }

    mono_class_field_t* find_field( const char* field_name ) {
        for ( auto i = 0; i < this->num_fields( ); i++ ) {
            const auto field = this->get_field( i );
            if ( !field )
                continue;

            if ( !strcmp( field->name( ).c_str( ), field_name ) )
                return field;
        }

        return nullptr;
    }
};

struct mono_hash_table_t {
    OFFSET( size( ), int, 0x18 )
    OFFSET( data( ), uintptr_t, 0x20 )
    OFFSET( next_value( ), void*, 0x108 )
    OFFSET( key_extract( ), unsigned int, 0x58 )

    template<typename T>
    T* lookup( void* key ) {
        //auto v4 = static_cast<mono_hash_table_t*>( read<void*>( data( ) + 0x8 * ( reinterpret_cast<unsigned int>( key ) % this->size( ) ) ) );
        unsigned int hack = *(unsigned int*)&key;
        auto v4 = static_cast<mono_hash_table_t*>( process->Read<void*>( data( ) + 0x8 * ( hack % this->size( ) ) ) );
        if ( !v4 )
            return nullptr;

        while ( reinterpret_cast<void*>( v4->key_extract( ) ) != key ) {
            v4 = static_cast<mono_hash_table_t*>( v4->next_value( ) );
            if ( !v4 )
                return nullptr;
        }

        return reinterpret_cast<T*>( v4 );
    }
};

struct mono_image_t {
    OFFSET( flags( ), int, 0x1C )

    mono_table_info_t* get_table_info( const int table_id ) {
        if ( table_id > 55 )
            return nullptr;

        return reinterpret_cast<mono_table_info_t*>( reinterpret_cast<uintptr_t>( this ) + 0x10 * ( static_cast<int>( table_id ) + 0xE ) );
    }

    mono_class_t* get( const int type_id ) {
        if ( ( this->flags( ) & 0x20 ) != 0 )
            return nullptr;

        if ( ( type_id & 0xFF000000 ) != 0x2000000 )
            return nullptr;

        return reinterpret_cast<mono_hash_table_t*>( this + 0x4C0 )->lookup<mono_class_t>( reinterpret_cast<void*>( type_id ) );
    }
};

struct mono_assembly_t {
    OFFSET( mono_image( ), mono_image_t*, 0x60 )
};

namespace mono {
    inline mono_root_domain_t* get_root_domain( ) {
        //return reinterpret_cast<mono_root_domain_t*>( read<uintptr_t>( mono_module /* module handle of mono-2.0-bdwgc.dll */ + 0x499c78 ) );
        //return reinterpret_cast<mono_root_domain_t*>( process->Read<uintptr_t>( monoBase /* module handle of mono-2.0-bdwgc.dll */ + 0x499c78 ) );
        return reinterpret_cast<mono_root_domain_t*>( process->Read<uintptr_t>( monoRootDomain ) );
    }

    inline void init_functions( ) { // credits: niceone1 (https://www.unknowncheats.me/forum/3434741-post11.html)
        const auto jitted_table = get_root_domain( )->jitted_function_table( );
        //for ( auto i = 0; i < read<int>( jitted_table + 0x8 ); i++  ) {
        for ( auto i = 0; i < process->Read<int>( jitted_table + 0x8 ); i++  ) {
            //const auto entry = read<uintptr_t>( jitted_table + 0x10 + i * 0x8 );
            const auto entry = process->Read<uintptr_t>( jitted_table + 0x10 + i * 0x8 );
            if ( !entry )
                continue;

            //for ( auto j = 0; j < read<int>( entry + 0x4 ); j++ ) {
            for ( auto j = 0; j < process->Read<int>( entry + 0x4 ); j++ ) {
                //const auto function = read<uintptr_t>( entry + 0x18 + j * 0x8 );
                const auto function = process->Read<uintptr_t>( entry + 0x18 + j * 0x8 );
                if ( !function )
                    continue;

                //const auto mono_ptr = read<uintptr_t>( function + 0x0 );
                const auto mono_ptr = process->Read<uintptr_t>( function + 0x0 );
                //const auto jitted_ptr = read<uintptr_t>( function + 0x10 );
                const auto jitted_ptr = process->Read<uintptr_t>( function + 0x10 );
                functions[mono_ptr] = jitted_ptr;
            }
        }
    }

    inline mono_assembly_t* domain_assembly_open( mono_root_domain_t* domain, const char* name ) {
        auto domain_assemblies = domain->domain_assemblies( );
        if ( !domain_assemblies )
            return nullptr;

        auto data = uintptr_t( );
        while ( true ) {
            data = domain_assemblies->data( );
            if ( !data )
                continue;

            //const auto data_name = read_widechar( read<uintptr_t>( data + 0x10 ), 128 );
            const auto data_name = read_widechar( process->Read<uintptr_t>( data + 0x10 ), 128 );
            if ( !strcmp( data_name.c_str( ), name ) )
                break;

            domain_assemblies = reinterpret_cast<glist_t*>( domain_assemblies->next( ) );
            if ( !domain_assemblies )
                break;
        }

        return reinterpret_cast<mono_assembly_t*>( data );
    }

    inline mono_class_t* find_class( const char* assembly_name, const char* class_name ) {
        Logger::Log("Finding class %s in %s...\n", class_name, assembly_name);
        const auto root_domain = get_root_domain( );
        if ( !root_domain )
            return nullptr;
        Logger::Log("Found root domain\n");
        const auto domain_assembly = domain_assembly_open( root_domain, assembly_name );
        if ( !domain_assembly )
            return nullptr;
        Logger::Log("Found domain asm\n");
        const auto mono_image = domain_assembly->mono_image( );
        if ( !mono_image )
            return nullptr;
        Logger::Log("Found mono image\n");
        const auto table_info = mono_image->get_table_info( 2 );
        if ( !table_info )
            return nullptr;
        int maxRows = table_info->get_rows( );
        Logger::Log("Found table info (%d) rows\n", maxRows);
        for ( int i = 0; i < maxRows; i++ ) {
            const auto ptr = static_cast<mono_hash_table_t*>( reinterpret_cast<void*>( mono_image + 0x4C0 ) )->lookup<mono_class_t>( reinterpret_cast<void*>( 0x02000000 | i + 1 ) );
            if ( !ptr )
                continue;

            auto name = ptr->name( );
            if ( !ptr->namespace_name( ).empty( ) )
                name = ptr->namespace_name( ).append( "." ).append( ptr->name( ) );

            if ( !strcmp( name.c_str( ), class_name ) )
                return ptr;
        }

        return nullptr;
    }
}
```

`src/sdk/tarkov.h`:

```h
#pragma once

#include "Vector.h"

#include <cstdint>

class LOCALGAMEWORLD // Aka LocalGameWorld
{
public:
    /*
    char pad_0000[24]; //0x0000
    class ExitController* m_pExitController; //0x0018
    char pad_0020[24]; //0x0020
    class UnityEngineString* m_LocalPlayerID; //0x0038
    char pad_0038[24]; //0x0040
     */
    char pad58[0x68];
    class LootArray* m_pItemList; //0x0068
    char pad_18[0x18]; //0x0070
    class Array* m_pPlayerList; //0x0088
}; //Size: 0x0078

class Array
{
public:
    char pad_0000[0x10]; //0x0000
    class List* m_pList; //0x0010
    int32_t Count; //0x0018
    int32_t MaxCount; //0x001C
}; //Size: 0x0020

class List
{
public:
    char pad_0000[0x20]; //0x0000
    class Player* m_pFirstEntity; //0x0020
    class Player* m_pSecondPlayer; //0x0028
}; //Size: 0x0030

class WeaponTemplate
{
public:
    char _pad[0x24C];
    bool m_allowJam;
    bool m_allowFeed;
    bool m_allowMisfire;
    bool m_allowSlide;
};
class WeaponItem
{
public:
    char _pad[0x10];
    class UnityEngineString* m_Id;      // 0x10
    class ItemAddress* m_itemAddress;   // 0x18
    class Components* m_components;     // 0x20
    class StringCache* m_stringCache;   // 0x28
    class ItemAddress* m_currentAddress;// 0x30
    class asdfasdf* m_ChildrenChanged;  // 0x38
    class WeaponTemplate* m_BackingField; // 0x40 //EFT.InventoryLogic.WeaponTemplate
    class List*         m_Attributes;   // 0x48
    class Nullable*     m_BackingField2;// 0x50
    uint32_t m_bUnlimitedCount;         // 0x58
    int32_t m_BuyRestrictionMax;        // 0x5C
    int32_t m_BuyRestrictionCurrent;    // 0x60
    int32_t m_StackObjectsCount;        // 0x64
    int32_t m_Version;                  // 0x68
    int32_t m_SpawnedInSession;         // 0x6C
    class Grid* m_Grids;                // 0x70
    class Slot* m_Slots;                // 0x78
    class RepairableComponent* m_Repairable; // 0x80
    class FoldableComponent* m_Foldable;// 0x88
    class FireModeComponent* m_FireMode;// 0x90
    class Slot* m_Chambers;             // 0x98 [pointer to Array]
    class Vector3D* m_OpticCalibrationPts;// 0xA0
    class Vector3D* m_OpticTrajInfos;   // 0xA8
    class asdfff* m_MalfState;          // 0xB0
    class Slot* m_magSlotCache;         // 0xB8
    // aimindex
    //onmalfunctionvalidate
    //shellsinchambers
    //compatibleammo
    //armed
    //cylinderhammerclosed
};
class HandsController
{
public:
    char pad_60[0x60];
    class WeaponItem* m_pWeaponItem; // 0x60       EFT.InventoryLogic.Item
};
class Player
{
public:
    char pad_0000[24]; //0x0000
    class LocalPlayerChecker *m_pLocalPlayerChecker; //0x0018
    char pad_0020[32]; //0x0020
    class MovementContext *m_pMovementContext; //0x0040
    char pad_60[96];
    class PlayerBody *m_pPlayerBody; //0x00A8
    char pad_c0[232];
    class ProceduralWeaponAnimation *m_pProceduralWeaponAnimation; //0x0198
    char pad_270[672];
    char pad_a0[0xB0];
    class PlayerProfile *m_pPlayerProfile; //0x04F0
    char pad_028[0x30];
    class HealthController *m_pHealthController; //0x0528
    char _paderino[0x18];
    class HandsController *m_pHandsController; // 0x0540
};

class MovementContext
{
public:
    char pad_0000[0x22C]; //0x0000
    Vector2D ViewAngles;
    Vector2D ViewAngles2;
    Vector3D LocalPosition;
}; //Size: 0x01FC

class CAMERA // Aka FPS Camera
{
public:
    char pad_0000[48]; //0x0000
    class FPSCamera* m_pFpsCamera; //0x0030
}; //Size: 0x0038

class FPSCamera
{
public:
    char pad_0000[48]; //0x0000
    class CameraObject* m_pCameraObject; //0x0030
    char pad_0038[40]; //0x0038
    char* ObjectName; //0x0060
    char pad_0068[8]; //0x0068
    class OpticCameraManager* m_pOpticCameraManager; // 0x0070
}; //Size: 0x0068

class CameraObject
{
public:
    char pad_0000[8]; //0x0000
    class CameraContainer* m_pCameraContainer; //0x0008
    char pad_0010[8]; //0x0010
    class CameraEntity* m_pCameraEntity; //0x0018
}; //Size: 0x0020

class OpticCameraManager
{
public:
    char pad_0000[16]; //0x0000
    class TemplateCamera* m_pTemplateCamera; // 0x0010 aka ScopeCamera
    char pad_0001[16]; //0x0018
    class OpticSight* m_pOpticSight; // 0x0028
};

class TemplateCamera
{
public:
    char pad_0000[48]; //0x0000
    class CameraObject* m_pCameraObject; //0x0030
};

class CameraEntity
{
public:
    char pad_0000[0xDC];
    Matrix4x4 ViewMatrix; //0x00D8
    char pad_00E0[64]; //0x00E0
    float FOVY; // 0x0098
    char pad_009C[20]; //0x009C
    float FOVX; // 0x00AC
}; //Size: 0x0118

class PlayerBody
{
public:
    char pad_0000[40]; //0x0000
    class m_pSkeletonRootJoin* m_pSkeletonRootJoin; //0x0028
}; //Size: 0x0030

class m_pSkeletonRootJoin
{
public:
    char pad_0000[40]; //0x0000
    class BoneEnumerator* m_pBoneEnumerator; //0x0028
}; //Size: 0x0030

class BoneEnumerator
{
public:
    char pad_0000[16]; //0x0000
    class TransformArray* m_pTransformArray; //0x0010
}; //Size: 0x0018

class TransformArray
{
public:
    char pad_0000[8]; //0x0000
}; //Size: 0x0008

class PlayerProfile
{
public:
    char pad_0000[16]; //0x0000
    class UnityEngineString* m_pPlayerId; //0x0010
    char pad_0018[16]; //0x0018
    class PlayerInfo* m_PlayerInfo; //0x0028
    char pad_0030[16]; //0x0030
    class PlayerHealth* m_pHealth; //0x0040
    class Inventory* m_pInventory; //0x0048
    void* pad;                     //0x0050
    void* pad2;                    //0x0058
    void* skills;                  //0x0060
}; //Size: 0x0050

class PlayerInfoSettings
{
    char pad[0x10];
    int role;          // 0x10
    int botDifficulty; // 0x14
};
class PlayerInfo
{
public:
    char pad_0000[0x10]; //0x0000
    class UnityEngineString* m_pPlayerName; // 0x10
    class UnityEngineString* m_pNickname;   // 0x18
    class UnityEngineString* m_pGroupId;    // 0x20
    class UnityEngineString* m_pEntryPoint; // 0x28
    class UnityEngineString* m_pVoice;      // 0x30
    void *list;
    void *pad;
    class PlayerInfoSettings* settings;     // 0x48
    void *action1;                          // 0x50
    void *action2;                          // 0x58
    void *action3;                          // 0x60
    int32_t Side;                           // 0x68
    int32_t CreationDate;                   // 0x6c
    double savageLockTime;
    int64_t nicknameChangeDate;
    int isStreamerModeAvailable;
    int memberCategory;
}; //Size: 0x0058

class UnityEngineString
{
public:
    char pad_0000[16]; //0x0000
    int32_t size; //0x0010
    //wchar_t name[24]; //0x0014
    char16_t name[16]; //0x0014
}; //Size: 0x0028

class HealthController // _healthController
{
public:
    char pad_0000[0x50]; //0x0000
    class HealthBody* m_pHealthBody;
}; //Size: 0x0020

class HealthBody
{
public:
    char pad_0000[0x18]; //0x0000
    class BodyController* m_pBodyController; //0x0018
}; //Size: 0x0020


enum BodyParts_t
{
    HEAD = 0,
    THORAX,
    STOMACH,
    LEFTARM,
    RIGHTARM,
    LEFTLEG,
    RIGHTLEG,
    NUM_BODY_PARTS
};

class BodyPartContainer
{
public:
    char _pad[0x10];
    class HealthContainer* m_pBodyPart;
};
class BodyController
{
public:
    char pad_0000[0x20]; //0x0000

    BodyPartContainer m_bodyParts[NUM_BODY_PARTS];
}; //Size: 0x00C8

class HealthContainer
{
public:
    char pad_0000[0x10]; //0x0000
    class Health* m_pHealth; //0x0010
}; //Size: 0x0018

class Health
{
public:
    char pad_0000[0x10]; //0x0000
    float Health; //0x0010
    float HealthMax; //0x0014
}; //Size: 0x0018

class PlayerHealth
{
public:
    char pad_0000[24]; //0x0000
    class HealthInfo* m_playerHealthInfo; //0x0018
}; //Size: 0x0020

class HealthInfo
{
public:
    char pad_0000[16]; //0x0000
    float CurentHealth; //0x0010
    float MaxHealth; //0x0014
}; //Size: 0x0018

class CameraContainer
{
public:
    char pad_0000[56]; //0x0000
    class CameraPosition* m_pCameraPosition; //0x0038
}; //Size: 0x0040

class CameraPosition
{
public:
    char pad_0000[176]; //0x0000
    Vector3D cameraPosition; //0x00B0
    char pad_00BC[4]; //0x00BC
    Vector3D cameraRotation; //0x00C0
}; //Size: 0x00D0

class LootArray
{
public:
    char pad_0000[0x10]; //0x0000
    class ItemList* m_pItemList; //0x0010
    int32_t Count; //0x0018
    int32_t MaxCount; //0x001C
}; //Size: 0x0020

class ItemList
{
public:
    char pad_0000[0x20]; //0x0000
    class Item* m_pFirstItem; //0x0020
    class Item* m_pSecondItem; //0x0028
}; //Size: 0x0030

class Item
{
public:
    char pad_0000[0x10]; //0x0000
    class ItemProfile* m_pItemProfile; //0x0010
}; //Size: 0x0018

class ItemProfile
{
public:
    char pad_0000[0x28]; //0x0000
    class ItemStats* m_pItemStats; //0x0028
    class ItemBasicInformation* m_pItemInformation; //0x0030
}; //Size: 0x0038S

class ItemBasicInformation
{
public:
    char pad_0000[48]; //0x0000
    class ItemLocalization* m_pItemLocalization; //0x0030
    char pad_0038[40]; //0x0038
    char* ItemPatName; //0x0060
}; //Size: 0x0068

class ItemLocalization
{
public:
    char pad_0000[8]; //0x0000
    class ItemCoordinates* m_pItemCoordinates; //0x0008
}; //Size: 0x0010

class ItemCoordinates
{
public:
    char pad_0000[0x38]; //0x0000
    class ItemLocationContainer* m_pItemLocationContainer; //0x0038
}; //Size: 0x0040

class ItemLocationContainer
{
public:
    char pad_0000[0x90]; //0x0000
    Vector3D ItemPosition;
}; //Size: 0x00BC

class Inventory
{
public:
    char pad_0000[48]; //0x0000
    class FastAccess* m_pFastAccess; //0x0030
}; //Size: 0x0038

class FastAccess
{
public:
    char pad_0000[16]; //0x0000
    class BoundCells* m_pBoundCells; //0x0010
}; //Size: 0x0018

class BoundCells
{
public:
    char pad_0000[24]; //0x0000
    class CollectionEntry* Entries; //0x0018
    char pad_0020[32]; //0x0020
    int32_t Count; //0x0040
    int32_t Max; //0x0044
}; //Size: 0x0048

class m_pDictionaryItems
{
public:
    char pad_0000[32]; //0x0000
    class Weapon* Knife; //0x0020
    class Weapon* Pistol; //0x0028
    class Weapon* FirstWeapon; //0x0030
    class Weapon* SecondWeapon; //0x0038
    char pad_0040[64]; //0x0040
}; //Size: 0x0080

class Weapon
{
public:
    char pad_0000[32]; //0x0000
    class WeaponDetails* m_pWeaponDetails; //0x0020
}; //Size: 0x0028

class WeaponDetails
{
public:
    char pad_0000[32]; //0x0000
    class WeaponNameInfo* m_pWeaponNameInfo; //0x0020
}; //Size: 0x0028

class WeaponNameInfo
{
public:
    char pad_0000[16]; //0x0000
    class UnityEngineString* Name; //0x0010
    char pad_0018[16]; //0x0018
    class UnityEngineString* NameType; //0x0028
}; //Size: 0x0030

class FirearmController
{
public:
    char _padd[0x60];
    class WeaponItem *m_pItem;
    char _pad[0xD8];
    float m_hipInaccuracy; // 0x140
    float m_weaponLn; // weapon length
};

class ProceduralWeaponAnimation
{
public:
    char pad_0000[0x28]; //0x0000
    class BreathEffector *m_pBreath;         //0x0028
    class WalkEffector *m_pWalk;             // 0x30
    class MotionEffector *m_pMotionReact;    // 0x38
    class ForceEffector *m_pForceReact;      // 0x40
    class ShotEffector *m_pShooting;         // 0x48
    class TurnAwayEffector *m_pTurnaway;     // 0x50
    char pad_0050[0x28];                     //0x0058
    class FirearmController *m_pFiring;      //0x0080
    char pad_0088[0x78];                     //0x0088
    uint32_t mask; //0x0100
    float sway1;
    float sway2;
    float sway3;
}; //Size: 0x01D8

class ItemStats
{
public:
    char pad_0000[0xB0]; //0x0000
    class GameItem* m_pGameItem;
}; //Size: 0x0058

class StatsNames
{
public:
    char pad_0000[0x40]; //0x0000
    class ItemNames* m_pItemNames; //0x0040
}; //Size: 0x0028

class ItemNames
{
public:
    char pad_0000[80]; //0x0000
    class UnityEngineString* m_pItemHashIdentifier; //0x0050
    char pad_0058[8]; //0x0058
    class UnityEngineString* m_pParentHashIdentifier; //0x0060
}; //Size: 0x0068

class OpticSight
{
public:
    char pad_0000[40]; //0x0000
    class UnityCamera* m_pCamera; //0x0020
}; //Size: 0x0028

class UnityCamera
{
public:
    char pad_0000[40]; //0x0000
    class CameraRaw* m_pCameraRaw; //0x0028
}; //Size: 0x0030

class BreathEffector
{
public:
    char pad_0000[0xA0]; //0x0000
    bool IsAiming; //0x00A0
    char pad_0091[3];
    float Intensity; //0x00A4
}; //Size: 0x0098

class ShotEffector
{
public:
    char pad_0000[0x6C]; //0x0000
    float padyolo;
    float recoilHori;
    float recoilVert;
    float Intensity4;
    float Intensity5;
    float Intensity6;
    float Intensity7;
}; //Size: 0x006C

class CameraRaw
{
public:
    char pad_0000[48]; //0x0000
    class CameraEntity* m_pCameraEntity; //0x0030
}; //Size: 0x0038

class PlayerId
{
public:
    char pad_0000[16]; //0x0000
    int32_t N000007E4; //0x0010
    wchar_t N000007F5[24]; //0x0014
    char pad_0044[112]; //0x0044
}; //Size: 0x00B4

class LocalPlayerChecker
{
public:
    char pad_0000[8]; //0x0000
}; //Size: 0x0008

class ExitController
{
public:
    char pad_0000[32]; //0x0000
    class ExitPoint* m_pExitPoint; //0x0020
}; //Size: 0x0028

class ExitPoint
{
public:
    char pad_0000[24]; //0x0000
    int32_t ExitCount; //0x0018
    char pad_001C[4]; //0x001C
    class Extraction* m_pFirstEntry; //0x0020
    class Extraction* m_pSecondEntry; //0x0028
}; //Size: 0x0030

class Extraction
{
public:
    char pad_0000[16]; //0x0000
    class PositionStuff* m_pPositionStuff; //0x0010
    char pad_0018[64]; //0x0018
    class ExtractionName* m_pExtractName; //0x0058
}; //Size: 0x0060

class ExtractionName
{
public:
    char pad_0000[16]; //0x0000
    class UnityEngineString* Name; //0x0010
}; //Size: 0x0018

class PositionStuff
{
public:
    char pad_0000[48]; //0x0000
    class PositionStuff2* m_pPositionStuff2; //0x0030
}; //Size: 0x0038

class PositionStuff2
{
public:
    char pad_0000[48]; //0x0000
    class PositionStuff3* m_pPositionStuff3; //0x0030
}; //Size: 0x0038

class PositionStuff3
{
public:
    char pad_0000[8]; //0x0000
    class ExtractionTransforms* m_pExtractionTransform; //0x0008
}; //Size: 0x0010

class ExtractionTransforms
{
public:
    char pad_0000[40]; //0x0000
    class ExtranctionTransformPointer* m_pExtractionTransform; //0x0028
}; //Size: 0x0030

class ExtranctionTransformPointer
{
public:
    char pad_0000[16]; //0x0000
    class Transform* m_pTransform; //0x0010
}; //Size: 0x0018

class Transform
{
public:
    char pad_0000[40]; //0x0000
    Matrix4x4 ExitMatrix; //0x0028
}; //Size: 0x0068

class CollectionEntry
{
public:
    char pad_0000[48]; //0x0000
    class InventoryLogicSlot* m_pKnife; //0x0030
    char pad_0038[16]; //0x0038
    class InventoryLogicSlot* m_pPistol; //0x0048
    char pad_0050[16]; //0x0050
    class InventoryLogicSlot* m_pFirstWeapon; //0x0060
    char pad_0068[16]; //0x0068
    class InventoryLogicSlot* m_pSecondWeapon; //0x0078
}; //Size: 0x0080

class InventoryLogicSlot
{
public:
    char pad_0000[24]; //0x0000
    class DizBindingBindableState* m_pReactiveContainedItem; //0x0018
}; //Size: 0x0020

class DizBindingBindableState
{
public:
    char pad_0000[16]; //0x0000
    class GameItem* m_pGameItem; //0x0010
}; //Size: 0x0018

class GameItem
{
public:
    char pad_0000[32]; //0x0000
    class ItemTemplate* m_pItemTemplate; //0x0020
}; //Size: 0x0028
```

`src/sdk/unity.cpp`:

```cpp
#include "unity.h"

#include "../globals.h"
#include "../utils/Logger.h"

#include <csignal>
#include <immintrin.h>
#include <ios>
#include <iostream>
#include <wchar.h>
#include <uchar.h>
#include <stdio.h>
#include <stdlib.h>

void Unity::PrintGOMObjects( bool tagged ) {
    uintptr_t firstObjectPtr;
    uintptr_t lastObjectPtr;

    if( tagged ){
        firstObjectPtr = (uintptr_t)gom.taggedFirst;
        lastObjectPtr = (uintptr_t)gom.taggedLast;
    } else {
        firstObjectPtr = (uintptr_t)gom.activeFirst;
        lastObjectPtr = (uintptr_t)gom.activeLast;
    }

    uintptr_t itr = firstObjectPtr;

    while( itr ){
        mono_object_wrapper wrapper = process->Read<mono_object_wrapper>( itr );
        mono_object object = process->Read<mono_object>( (uintptr_t)wrapper.object );
        char name[256] = {0};
        process->Read( (uint64_t)object.objectname, name, 256 );

        Logger::Log("[%d][%s]\n", object.Tag, name);

        if( itr == lastObjectPtr )
            break;

        itr = (uintptr_t)wrapper.next;
    }
}

void Unity::PrintPlayerList() {
    LOCALGAMEWORLD gameworld = process->Read<LOCALGAMEWORLD>( gameWorldAddr );

    Array playerList = process->Read<Array>( (uintptr_t)gameworld.m_pPlayerList );

    Logger::Log("Printing %d players..\n", playerList.Count);
    for( int i = 0; i < playerList.Count; i++ ){
        uintptr_t playerAddr = process->Read<uintptr_t>((uintptr_t)playerList.m_pList + (0x20 + (i * 8)));

        if( !playerAddr )
            continue;

        Player player = process->Read<Player>( playerAddr );
        PlayerProfile profile = process->Read<PlayerProfile>( (uintptr_t)player.m_pPlayerProfile );
        PlayerInfo info = process->Read<PlayerInfo>( (uintptr_t)profile.m_PlayerInfo );
        UnityEngineString name = process->Read<UnityEngineString>( (uintptr_t)info.m_pPlayerName );

        Logger::Log("Player Addr(%p) - healthcontroller(%p) Side(%d)\n", playerAddr, player.m_pHealthController, info.Side);

        char playername[64] = { 0 };
        if( info.Side == 4 )
        {
            if( info.CreationDate > 0 )
            {
                strcpy(playername, "player-scav");
            }
            else
            {
                continue;
            }
        }
        else
        {
            int j = 0;
            // the legendary unicode byte skipper
            for(int byte = 0; (byte < (name.size * 2) + 2); byte++)
            {
                if((byte % 2) != 0)
                    continue;

                char ascii = ((char*)(&name.name[0]))[byte];
                // set this manually like a man
                if (ascii <= 0 || ascii > 127)
                    continue;

                playername[j] = ascii;
                j++;
            }

            playername[std::min(63, (name.size * 2) + 2)] = '\0';
            playername[63] = '\0';
        }

        float hp = 0;
        auto healthController = process->Read<HealthController>( (uintptr_t)player.m_pHealthController );
        auto healthBody = process->Read<HealthBody>( (uintptr_t)healthController.m_pHealthBody );
        auto bodyController = process->Read<BodyController>( (uintptr_t)healthBody.m_pBodyController );

        // Calculate HP
        for( int limb = 0; limb < NUM_BODY_PARTS; limb++ )
        {
            HealthContainer bodypart = process->Read<HealthContainer>( (uintptr_t)bodyController.m_bodyParts[limb].m_pBodyPart );
            Health bodypartHealth = process->Read<Health>( (uintptr_t)bodypart.m_pHealth );
            hp += bodypartHealth.Health;
        }

        Vector3D headPos = Unity::GetBonePosition( playerAddr, Bones::HumanHead );
        if( player.m_pLocalPlayerChecker ){
            Logger::Log("[LOCALPLAYER-Team(%d)][%d](%s)Player(%f,%f,%f) - HP(%f)\n", info.Side, name.size, playername, headPos.x, headPos.y, headPos.z, hp);
        } else {
            Logger::Log("[Team(%d)](%s)Player(%f,%f,%f) - HP(%f)\n", info.Side, playername, headPos.x, headPos.y, headPos.z, hp);
        }
    }
    Logger::Log("Done printing players.\n");
}

void Unity::PrintItemStats() {
    LOCALGAMEWORLD gameworld = process->Read<LOCALGAMEWORLD>( gameWorldAddr );

    LootArray itemList = process->Read<LootArray>((uintptr_t)gameworld.m_pItemList );

    Logger::Log("This map has %d Items\n", itemList.Count);
}

uint64_t matrix_list_base;
uint64_t dependency_index_table_base = 0;

static Vector3D GetPosition(uint64_t transform)
{
    auto transform_internal = process->Read<uint64_t>(transform + 0x10);

    auto matrices = process->Read<uint64_t>(transform_internal + 0x38);
    auto index = process->Read<int>(transform_internal + 0x40);

    process->Read((uintptr_t)(matrices + 0x18), &matrix_list_base, sizeof(matrix_list_base));
    process->Read((uintptr_t)(matrices + 0x20), &dependency_index_table_base, sizeof(dependency_index_table_base));

    static auto get_dependency_index = [](uint64_t base, int32_t index)
    {
        process->Read((uintptr_t)(base + index * 4), &index, sizeof(index));
        return index;
    };

    static auto get_matrix_blob = [](uint64_t base, uint64_t offs, float* blob, uint32_t size) {
        process->Read((uintptr_t)(base + offs), blob, size);
    };

    int32_t index_relation = get_dependency_index(dependency_index_table_base, index);

    Vector3D ret_value;
    {
        float* base_matrix3x4 = (float*)malloc(64),
                * matrix3x4_buffer0 = (float*)((uint64_t)base_matrix3x4 + 16),
                * matrix3x4_buffer1 = (float*)((uint64_t)base_matrix3x4 + 32),
                * matrix3x4_buffer2 = (float*)((uint64_t)base_matrix3x4 + 48);

        get_matrix_blob(matrix_list_base, index * 48, base_matrix3x4, 16);

        __m128 xmmword_1410D1340 = { -2.f, 2.f, -2.f, 0.f };
        __m128 xmmword_1410D1350 = { 2.f, -2.f, -2.f, 0.f };
        __m128 xmmword_1410D1360 = { -2.f, -2.f, 2.f, 0.f };

        while (index_relation >= 0)
        {
            uint32_t matrix_relation_index = 6 * index_relation;

            // paziuret kur tik 3 nureadina, ten translationas, kur 4 = quatas ir yra rotationas.
            get_matrix_blob(matrix_list_base, 8 * matrix_relation_index, matrix3x4_buffer2, 16);
            __m128 v_0 = *(__m128*)matrix3x4_buffer2;

            get_matrix_blob(matrix_list_base, 8 * matrix_relation_index + 32, matrix3x4_buffer0, 16);
            __m128 v_1 = *(__m128*)matrix3x4_buffer0;

            get_matrix_blob(matrix_list_base, 8 * matrix_relation_index + 16, matrix3x4_buffer1, 16);
            __m128i v9 = *(__m128i*)matrix3x4_buffer1;

            __m128* v3 = (__m128*)base_matrix3x4; // r10@1
            __m128 v10; // xmm9@2
            __m128 v11; // xmm3@2
            __m128 v12; // xmm8@2
            __m128 v13; // xmm4@2
            __m128 v14; // xmm2@2
            __m128 v15; // xmm5@2
            __m128 v16; // xmm6@2
            __m128 v17; // xmm7@2

            v10 = _mm_mul_ps(v_1, *v3);
            v11 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 0));
            v12 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 85));
            v13 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -114));
            v14 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -37));
            v15 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -86));
            v16 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 113));

            v17 = _mm_add_ps(
                    _mm_add_ps(
                            _mm_add_ps(
                                    _mm_mul_ps(
                                            _mm_sub_ps(
                                                    _mm_mul_ps(_mm_mul_ps(v11, (__m128)xmmword_1410D1350), v13),
                                                    _mm_mul_ps(_mm_mul_ps(v12, (__m128)xmmword_1410D1360), v14)),
                                            _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), -86))),
                                    _mm_mul_ps(
                                            _mm_sub_ps(
                                                    _mm_mul_ps(_mm_mul_ps(v15, (__m128)xmmword_1410D1360), v14),
                                                    _mm_mul_ps(_mm_mul_ps(v11, (__m128)xmmword_1410D1340), v16)),
                                            _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 85)))),
                            _mm_add_ps(
                                    _mm_mul_ps(
                                            _mm_sub_ps(
                                                    _mm_mul_ps(_mm_mul_ps(v12, (__m128)xmmword_1410D1340), v16),
                                                    _mm_mul_ps(_mm_mul_ps(v15, (__m128)xmmword_1410D1350), v13)),
                                            _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 0))),
                                    v10)),
                    v_0);

            *v3 = v17;

            index_relation = get_dependency_index(dependency_index_table_base, index_relation);
        }

        ret_value = *(Vector3D*)base_matrix3x4;
        delete[] base_matrix3x4;
    }

    return ret_value;
}

Vector3D Unity::GetBonePosition( uintptr_t playerAddr, int boneID ) {
    // The power of external!
    Player player = process->Read<Player>( playerAddr );
    PlayerBody playerBody = process->Read<PlayerBody>( (uintptr_t)player.m_pPlayerBody );
    m_pSkeletonRootJoin skeletonRootJoin = process->Read<m_pSkeletonRootJoin>( (uintptr_t)playerBody.m_pSkeletonRootJoin );
    BoneEnumerator bones = process->Read<BoneEnumerator>( (uintptr_t)skeletonRootJoin.m_pBoneEnumerator );

    uintptr_t transform = process->Read<uintptr_t>( uintptr_t(bones.m_pTransformArray) + (0x20 + (boneID * 8) ) );
    return GetPosition( transform );
}

uintptr_t Unity::GetObjectPtrByName(const char *objname, bool tagged) {
    uintptr_t firstObjectPtr;
    uintptr_t lastObjectPtr;

    if( tagged ){
        firstObjectPtr = (uintptr_t)gom.taggedFirst;
        lastObjectPtr = (uintptr_t)gom.taggedLast;
    } else {
        firstObjectPtr = (uintptr_t)gom.activeFirst;
        lastObjectPtr = (uintptr_t)gom.activeLast;
    }

    uintptr_t itr = firstObjectPtr;

    while( itr ){
        mono_object_wrapper wrapper = process->Read<mono_object_wrapper>( itr );
        mono_object object = process->Read<mono_object>( (uintptr_t)wrapper.object );
        char name[256] = {0};
        process->Read( (uint64_t)object.objectname, name, 256 );

        if( !strcmp( objname, name ) ){
            game_object_wrapper gameobjWrapper = process->Read<game_object_wrapper>( (uintptr_t)object.pObjectClass );
            return (uintptr_t)gameobjWrapper.gameObject;
        }
        if( itr == lastObjectPtr )
            break;

        itr = (uintptr_t)wrapper.next;
    }

    return 0;
}

uintptr_t Unity::GetWorldPtr() {
    uintptr_t firstObjectPtr;
    uintptr_t lastObjectPtr;

    firstObjectPtr = (uintptr_t)gom.activeFirst;
    lastObjectPtr = (uintptr_t)gom.activeLast;

    uintptr_t itr = firstObjectPtr;

    while( itr ){
        mono_object_wrapper wrapper = process->Read<mono_object_wrapper>( itr );
        mono_object object = process->Read<mono_object>( (uintptr_t)wrapper.object );
        char name[256] = {0};
        process->Read( (uint64_t)object.objectname, name, 256 );

        if( !strcmp( "GameWorld", name ) ){
            game_object_wrapper gameobjWrapper = process->Read<game_object_wrapper>( (uintptr_t)object.pObjectClass );
            GameWorldWrapper gameWorldWrapper = process->Read<GameWorldWrapper>( (uintptr_t)gameobjWrapper.gameObject );
            LOCALGAMEWORLD world = process->Read<LOCALGAMEWORLD>( (uintptr_t)gameWorldWrapper.localgameworld );
            Array playerList = process->Read<Array>( (uintptr_t)world.m_pPlayerList );
            if( playerList.Count == 0 )
                goto next;

            return (uintptr_t)gameWorldWrapper.localgameworld;
        }
        if( itr == lastObjectPtr )
            break;

        next:
        itr = (uintptr_t)wrapper.next;
    }

    return 0;
}

bool Unity::World2Screen(const Vector3D &world, Vector2D *screen) {
    Matrix4x4 matrix = cameraEntity.ViewMatrix.Transpose();

    const Vector3D translation = { matrix.m[3][0], matrix.m[3][1], matrix.m[3][2] };
    const Vector3D up = { matrix.m[1][0], matrix.m[1][1], matrix.m[1][2] };
    const Vector3D right = { matrix.m[0][0], matrix.m[0][1], matrix.m[0][2] };

    const float w = translation.DotProduct( world ) + matrix.m[3][3];

    // Not on screen
    if( w < 0.1f )
        return false;

    float x = right.DotProduct( world ) + matrix.m[0][3];
    float y = up.DotProduct( world ) + matrix.m[1][3];

    if (localPlayerIsAiming && localPlayerIsOpticCamera)
    {
        //TODO: scope scale
    }

    screen->x = (2560 / 2) * (1.f + x / w);
    screen->y = (1440 / 2) * (1.f - y / w);

    return true;
}
```

`src/sdk/unity.h`:

```h
#pragma once

#include "tarkov.h"

#include <cstdint>

struct GameWorldWrapper
{
    char pad_0[0x28];
    LOCALGAMEWORLD* localgameworld;
};

struct unity_transform
{
    char pad_0[0x10];
    void* transform;
};

struct game_object_wrapper
{
    char pad_0[0x18];
    void* gameObject;
};

struct mono_object
{
    char pad_0000[0x30];
    game_object_wrapper *pObjectClass;
    char pad_0038[0x10];
    int16_t Unk;
    char pad_004A[6];
    int32_t Layer;
    int16_t Tag;
    char pad_0056[10];
    char *objectname;
};

struct mono_object_wrapper
{
    char pad_0[0x8];
    mono_object_wrapper* next;
    mono_object* object;
};

struct GlobalObjectManager
{
    void* shitlistLast;
    void* shitlistFirst; // 0x8
    mono_object_wrapper *taggedLast; // 0x10
    mono_object_wrapper *taggedFirst; // 0x18
    mono_object_wrapper *activeLast;  // 0x20
    mono_object_wrapper *activeFirst; // 0x28
};


namespace Unity
{
    void PrintGOMObjects( bool tagged );
    void PrintPlayerList();
    void PrintItemStats();
    Vector3D GetBonePosition( uintptr_t playerAddr, int boneID );
    uintptr_t GetObjectPtrByName( const char *objname, bool tagged );
    uintptr_t GetWorldPtr();
    bool World2Screen( const Vector3D &world, Vector2D *screen );
}


enum Bones : int
{
    HumanBase = 0,
    HumanPelvis = 14,
    HumanLThigh1 = 15,
    HumanLThigh2 = 16,
    HumanLCalf = 17,
    HumanLFoot = 18,
    HumanLToe = 19,
    HumanRThigh1 = 20,
    HumanRThigh2 = 21,
    HumanRCalf = 22,
    HumanRFoot = 23,
    HumanRToe = 24,
    HumanSpine1 = 29,
    HumanSpine2 = 36,
    HumanSpine3 = 37,
    HumanLCollarbone = 89,
    HumanLUpperarm = 90,
    HumanLForearm1 = 91,
    HumanLForearm2 = 92,
    HumanLForearm3 = 93,
    HumanLPalm = 94,
    HumanRCollarbone = 110,
    HumanRUpperarm = 111,
    HumanRForearm1 = 112,
    HumanRForearm2 = 113,
    HumanRForearm3 = 114,
    HumanRPalm = 115,
    HumanNeck = 132,
    HumanHead = 133
};
```

`src/utils/Handles.cpp`:

```cpp
#include "m0dular/utils/handles.h"
#include "../globals.h"

ModuleInfo Handles::GetModuleInfo(const char *module)
{
    WinDll *moduleInfo = process->GetModuleInfo(module);

    if (!moduleInfo)
        return { nullptr, 0, 0 };

    return { (void *)moduleInfo, moduleInfo->info.baseAddress, moduleInfo->info.sizeOfModule };
}

```

`src/utils/InputSystem.cpp`:

```cpp
#include "InputSystem.h"
#include "Logger.h"

// https://github.com/LWSS/evdev-mirror

// This struct is the same at <linux/input.h>
struct input_value {
    uint16_t type;
    uint16_t code;
    int32_t value;
};

void *InputSystem::InputSystem(void *) {
    int fd;
    struct input_value input;

    fd = open("/dev/input/evdev-mirror", O_RDONLY | O_NONBLOCK);
    if (fd < 0) {
        Logger::Log("Error opening evdev-mirror! (%d), %d\nInput will be disabled.\n", fd, errno);
        return nullptr;
    }
    Logger::Log("Started input loop\n");
    while (running) {
        // if zero bytes, keep goin...
        if (!read(fd, &input, sizeof(struct input_value))) {
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            continue;
        }
        if( input.type != EV_KEY ){
            continue;
        }
        pressedKeys[input.code] = input.value > 0;
        //Logger::Log("Key: %d - state: %d\n", input.code, input.value);
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
    return nullptr;
}
```

`src/utils/InputSystem.h`:

```h
#pragma once

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <chrono>
#include <thread>
#include <errno.h>

#include "../globals.h"

namespace InputSystem {
    extern void *InputSystem(void *);
}
```

`src/utils/Logger.cpp`:

```cpp
#include "Logger.h"

#include <cstdio> // setbuf, fopen, fclose..
#include <cstdarg> // va_list, va_start, va_arg, va_end
#include <string.h>
#include <fstream>
//LMODE
#include "vmread/definitions.h"

#if (LMODE() != MODE_EXTERNAL())
#define LOGFILE_NAME "/tmp/tuxkov.log"
#endif

void Logger::Log( const char *format, ... ) {
    char buffer[4096];
    FILE *logFile;
#if (LMODE() == MODE_EXTERNAL())
    logFile = stdout;
#else
    static bool bFirst = true;

    if ( bFirst ) {
        logFile = fopen(LOGFILE_NAME, "w"); // create new log
        bFirst = false;
        if (logFile)
            fprintf(logFile, "--Start of log--\n");
    } else {
        logFile = fopen(LOGFILE_NAME, "a"); // append to log
    }

    if (!logFile)
        return;
#endif

    va_list args;
    va_start(args, format);
    vsnprintf(buffer, 4096, format, args);
    fprintf(logFile, buffer);
    va_end(args);
    fflush(logFile);
#if (LMODE() != MODE_EXTERNAL())
    fclose(logFile);
#endif
}

```

`src/utils/Logger.h`:

```h
#pragma once

namespace Logger {
    void Log( const char *format, ... );
}

```

`src/utils/Math.h`:

```h
#include "../sdk/Vector.h"
#include "../utils/Logger.h"

#define RAD2DEG 57.295779513f

namespace Math {

    inline float AngleFOV(const QAngle &viewAngle, const QAngle &aimAngle) {
        QAngle delta = viewAngle - aimAngle;
        return fabsf(delta.Length());
    }

    inline float DistanceFOV(const QAngle &viewAngle, const QAngle &aimAngle, const float distance) {
        float angleFOV = AngleFOV(viewAngle, aimAngle);

        angleFOV /= 90.0f;

        float distanceFOV = angleFOV * distance;

        return distanceFOV;
    }
}

```

`src/utils/Memutils.cpp`:

```cpp
#include "m0dular/utils/memutils.h"
#include "../globals.h"

//TODO: Add thread-local process selection
void ReadMem(void* destination, void* source, size_t size)
{
    process->Read((uint64_t)source, destination, size);
}

void WriteMem(void* destination, void* source, size_t size)
{
    process->Write((uint64_t)destination, source, size);
}

```

`src/utils/Memutils.h`:

```h
#pragma once
#include "vmread/hlapi/hlapi.h"
#include "Logger.h"

inline uintptr_t GetAbsoluteAddressVm( WinProcess &proc, uintptr_t instructionPtr, int offset, int size ) {
    if( !instructionPtr ){
        return 0;
    }
    return instructionPtr + proc.Read<int>( instructionPtr + offset ) + size;
}

```

`src/utils/minitrace.h`:

```h
#pragma once

#define MTR_SCOPED
#include "m0dular/submodules/minitrace/minitrace.h"
#ifdef MTR_ENABLED
#define MTR_SCOPED_TRACE(cat, name) auto scopedTrace = MTRScopedTrace(cat, name);
#else
#define MTR_SCOPED_TRACE(cat, name)
#endif

```