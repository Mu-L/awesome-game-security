Project Path: arc_0vercl0k_kdmp-parser_3j_xoeju

Source Tree:

```txt
arc_0vercl0k_kdmp-parser_3j_xoeju
├── CMakeLists.txt
├── LICENSE
├── README.md
├── pics
│   └── parser.jpg
└── src
    ├── lib
    │   ├── CMakeLists.txt
    │   ├── filemap.h
    │   ├── kdmp-parser-structs.h
    │   ├── kdmp-parser-version.h.in
    │   ├── kdmp-parser.h
    │   └── platform.h
    ├── parser
    │   ├── CMakeLists.txt
    │   └── parser.cc
    ├── python
    │   ├── CMakeLists.txt
    │   ├── README.md
    │   ├── kdmp_parser
    │   │   ├── __init__.py
    │   │   └── page.py
    │   ├── pyproject.toml
    │   ├── requirements.txt
    │   ├── src
    │   │   └── kdmp_parser.cc
    │   └── tests
    │       ├── pytest.ini
    │       ├── requirements.txt
    │       ├── test_page.py
    │       ├── test_parser.py
    │       └── test_version.py
    └── tests
        ├── CMakeLists.txt
        ├── tests_parser.cc
        └── tests_version.cc

```

`CMakeLists.txt`:

```txt
# Axel '0vercl0k' Souchet - April 18 2020
# CMakeList.txt : CMake project for kdmp-parser, include source and define
# project specific logic here.
#
cmake_minimum_required(VERSION 3.21)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_POSITION_INDEPENDENT_CODE True)

project(
    kdmp-parser
    DESCRIPTION "A Cross-Platform C++ parser library for Windows kernel minidumps."
    HOMEPAGE_URL https://github.com/0vercl0k/kdmp-parser
    VERSION 0.7.4
)

set(PROJECT_AUTHOR 0vercl0k)
set(PROJECT_LICENSE MIT)

option(BUILD_PARSER "Build the parser executable for kdmp-parser" ON)
option(BUILD_TESTS "Build the test suite for kdmp-parser" OFF)
option(BUILD_PYTHON_BINDING "Build the Python bindings for kdmp-parser" OFF)

add_subdirectory(src/lib)

if(BUILD_PARSER)
    add_subdirectory(src/parser)
endif(BUILD_PARSER)

if(BUILD_PYTHON_BINDING)
    add_subdirectory(src/python)
endif(BUILD_PYTHON_BINDING)

if(BUILD_TESTS)
    add_subdirectory(src/tests)
endif(BUILD_TESTS)

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Axel Souchet

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# kdmp-parser

![Build status](https://github.com/0vercl0k/kdmp-parser/workflows/Builds/badge.svg)
[![Downloads](https://static.pepy.tech/badge/kdmp-parser/month)](https://pepy.tech/project/kdmp-parser)

This C++ library parses Windows kernel [full](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/complete-memory-dump) dumps (`.dump /f` in WinDbg), [BMP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/active-memory-dump) dumps (`.dump /ka` in WinDbg) as well as more recent dump types that were introduced in ~2022.

![parser](pics/parser.jpg)

The library supports loading 64-bit dumps and provides read access to things like:

- The context record,
- The exception record,
- The bugcheck parameters,
- The physical memory.

Compiled binaries are available in the [releases](https://github.com/0vercl0k/kdmp-parser/releases) section.

Special thanks to:
- [hugsy](https://github.com/hugsy) for numerous contributions: the new Python bindings, CI improvements, new dump types, etc.,
- [masthoon](https://github.com/masthoon) for the initial version of the Python bindings,
- [yrp604](https://github.com/yrp604) for being knowledgeable about the format,
- the [rekall](https://github.com/google/rekall) project and their [Python implementation](https://github.com/google/rekall/blob/master/rekall-core/rekall/plugins/overlays/windows/crashdump.py) (most of the structures in [kdmp-parser-structs.h](https://github.com/0vercl0k/kdmp-parser/blob/master/src/kdmp-parser/kdmp-parser-structs.h) have been adapted from it).

## Parser

The `parser.exe` application is able to dump various information about the dump file: exception record, context record, etc.

```text
>parser.exe -c -e -p 0x1000 full.dmp
--------------------------------------------------------------------------------
Context Record:
  rax=0000000000000003 rbx=fffff8050f4e9f70 rcx=0000000000000001
  rdx=fffff805135684d0 rsi=0000000000000100 rdi=fffff8050f4e9f80
  rip=fffff805108776a0 rsp=fffff805135684f8 rbp=fffff80513568600
   r8=0000000000000003  r9=fffff805135684b8 r10=0000000000000000
  r11=ffffa8848825e000 r12=fffff8050f4e9f80 r13=fffff80510c3c958
  r14=0000000000000000 r15=0000000000000052
  cs=0010 ss=0018 ds=002b es=002b fs=0053 gs=002b                 efl=00040202
  fpcw=0000    fpsw=0000    fptw=0001
    st0=fffff80510bbf000fffff80510c3c9c0       st1=0005e5a800ab2000fffff805106b3000
    st2=4000000000200000fffff80510beaea8       st3=000000000a0d656c69666f7250206465
    st4=0000000a0d656c69666f725000000010       st5=0000000000000000fffff80510b16900
    st6=0000000000000000fffff805133e9000       st7=fffff47c02899f480000000000000000
   xmm0=000000000a0d656c69666f7250206465      xmm1=0000000a0d656c69666f725000000010
   xmm2=0000000000000000fffff80510b16900      xmm3=0000000000000000fffff805133e9000
   xmm4=fffff47c02899f480000000000000000      xmm5=00000000000000000000000000000000
   xmm6=00000000000000000000000000000000      xmm7=00000000000000000000000000000000
   xmm8=00000000000000000000000000000000      xmm9=00000000000000000000000000000000
  xmm10=00000000000000000000000000000000     xmm11=00000000000000000000000000000000
  xmm12=00000000000000000000000000000000     xmm13=00000000000000000000000000000000
  xmm14=00000000000000000000000000000000     xmm15=00000000000000000000000000000000
--------------------------------------------------------------------------------
Exception Record:
  KDMP_PARSER_EXCEPTION_RECORD64
    +0x0000: ExceptionCode            : 0x80000003.
    +0x0004: ExceptionFlags           : 0x00000000.
    +0x0008: ExceptionRecord          : 0x0000000000000000.
    +0x0010: ExceptionAddress         : 0xfffff805108776a0.
    +0x0018: NumberParameters         : 0x00000001.
    +0x0020: ExceptionInformation[0]  : 0x0000000000000000.
    +0x0028: ExceptionInformation[1]  : 0x0000000000000000.
    +0x0030: ExceptionInformation[2]  : 0xffffa8848825e000.
    +0x0038: ExceptionInformation[3]  : 0x00000000000002c0.
    +0x0040: ExceptionInformation[4]  : 0xfffff80511022203.
    +0x0048: ExceptionInformation[5]  : 0x0000000000004280.
    +0x0050: ExceptionInformation[6]  : 0xfffff80510880524.
    +0x0058: ExceptionInformation[7]  : 0xffffa88488282360.
    +0x0060: ExceptionInformation[8]  : 0x0000000000000280.
    +0x0068: ExceptionInformation[9]  : 0xfffff805135683d8.
    +0x0070: ExceptionInformation[10] : 0xffffa8848d9d6fb0.
    +0x0078: ExceptionInformation[11] : 0x0000000000004280.
    +0x0080: ExceptionInformation[12] : 0x00001f8001004280.
    +0x0088: ExceptionInformation[13] : 0x0000000000000003.
    +0x0090: ExceptionInformation[14] : 0xfffff80513568578.
--------------------------------------------------------------------------------
Physical memory:
00001000: 00 00 00 00 00 00 00 00 00 00 f9 ff 00 00 00 00  |................|
00001010: 00 06 01 01 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00001020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00001030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00001040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00001050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00001060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00001070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00001080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
00001090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |................|
000010a0: 00 00 00 00 00 00 00 00 00 a0 87 00 00 00 00 00  |................|
000010b0: ff ff ff ff ff ff ff ff 00 00 60 11 05 f8 ff ff  |..........`.....|
000010c0: 00 90 2f 00 00 00 00 00 ff ff ff ff 03 80 ff ff  |../.............|
000010d0: f8 00 00 c0 c1 f7 ff ff 00 00 00 00 03 00 00 00  |................|
000010e0: f8 00 00 c0 c1 f7 ff ff 00 00 00 00 03 00 00 00  |................|
000010f0: 00 00 00 00 00 00 00 00 70 37 01 c0 c1 f7 ff ff  |........p7......|
...
```

## Building

You can build it yourself using CMake and it builds on Linux, Windows, OSX with the Microsoft, the LLVM Clang and GNU compilers.

Here is an example on Windows:
```
> mkdir build
> cd build
> cmake ..
-- Building for: Visual Studio 17 2022
...

> cmake --build . --config RelWithDebInfo
MSBuild version 17.8.3+195e7f5a3 for .NET Framework
...

> src\parser\RelWithDebInfo\parser.exe
You didn't provide the path to the dump file.

parser.exe [-p [<physical address>]] [-c] [-e] [-h] <kdump path>

Examples:
  Show every structures of the dump:
    parser.exe -a full.dmp

  Show the context record:
    parser.exe -c full.dmp

  Show the exception record:
    parser.exe -e full.dmp

  Show all the physical memory (first 16 bytes of every pages):
    parser.exe -p full.dmp

  Show the context record as well as the page at physical address 0x1000:
    parser.exe -c -p 0x1000 full.dmp
```

Here is another example on Linux (with the Python bindings):
```
$ mkdir build
$ cd build
$ cmake .. -DBUILD_PYTHON_BINDING=ON
...

$ cmake --build . --config RelWithDebInfo
...

$ ./src/parser/parser
You didn't provide the path to the dump file.

parser.exe [-p [<physical address>]] [-c] [-e] [-h] <kdump path>

Examples:
  Show every structures of the dump:
    parser.exe -a full.dmp

  Show the context record:
    parser.exe -c full.dmp

  Show the exception record:
    parser.exe -e full.dmp

  Show all the physical memory (first 16 bytes of every pages):
    parser.exe -p full.dmp

  Show the context record as well as the page at physical address 0x1000:
    parser.exe -c -p 0x1000 full.dmp
```

## Python bindings

### From PyPI

The easiest way is simply to:
```
pip install kdmp_parser
```

### Using PIP

Run the following after installing [CMake](https://cmake.org/) and [Python](https://python.org/) 3.8+ / `pip`:
```
cd src/python
pip install requirements.txt
pip install .
```

To create a wheel pacakge:
```
cd src/python
pip wheel .
```

### Usage

#### Get context, print the program counter

```python
import kdmp_parser
dmp = kdmp_parser.KernelDumpParser("full.dmp")
assert dmp.type == kdmp_parser.DumpType.FullDump
print(f"Dump RIP={dmp.context.Rip:#x}")
```

#### Read a virtual memory page at address pointed by RIP

```python
import kdmp_parser
dmp = kdmp_parser.KernelDumpParser("full.dmp")
dmp.read_virtual_page(dmp.context.Rip)
```

#### Explore the physical memory

```python
import kdmp_parser
dmp = kdmp_parser.KernelDumpParser("full.dmp")
pml4 = dmp.directory_table_base
print(f"{pml4=:#x}")
dmp.read_physical_page(pml4)
```

#### Translate a virtual address into a physical address

```python
import kdmp_parser
dmp = kdmp_parser.KernelDumpParser("full.dmp")
VA = dmp.context.Rip
PA = dmp.translate_virtual(VA)
print(f"{VA=:#x} -> {PA=:#x}")
```

# Authors

* Axel '[@0vercl0k](https://twitter.com/0vercl0k)' Souchet

# Contributors

[ ![contributors-img](https://contrib.rocks/image?repo=0vercl0k/kdmp-parser) ](https://github.com/0vercl0k/kdmp-parser/graphs/contributors)

```

`src/lib/CMakeLists.txt`:

```txt
# Axel '0vercl0k' Souchet - April 18 2020
add_library(kdmp-parser INTERFACE)
configure_file(${CMAKE_CURRENT_SOURCE_DIR}/kdmp-parser-version.h.in ${CMAKE_CURRENT_SOURCE_DIR}/kdmp-parser-version.h)
target_include_directories(kdmp-parser INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})

```

`src/lib/filemap.h`:

```h
// Axel '0vercl0k' Souchet - April 28 2020
#include "platform.h"
#include <cstdint>
#include <cstdio>

#if defined(LINUX)
#include <errno.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#endif

namespace kdmpparser {
namespace Page {

//
// Page size.
//

constexpr uint64_t Size = 0x1000;

//
// Page align an address.
//

constexpr uint64_t Align(const uint64_t Address) { return Address & ~0xfff; }

//
// Extract the page offset off an address.
//

constexpr uint64_t Offset(const uint64_t Address) { return Address & 0xfff; }
} // namespace Page

#if defined(WINDOWS)
class FileMap_t {
  //
  // Handle to the input file.
  //

  HANDLE File_ = nullptr;

  //
  // Handle to the file mapping.
  //

  HANDLE FileMap_ = nullptr;

  //
  // Base address of the file view.
  //

  PVOID ViewBase_ = nullptr;

  //
  // File size
  //

  uint64_t FileSize_ = 0;

public:
  ~FileMap_t() {
    //
    // Unmap the view of the mapping..
    //

    if (ViewBase_ != nullptr) {
      UnmapViewOfFile(ViewBase_);
      ViewBase_ = nullptr;
    }

    //
    // Close the handle to the file mapping..
    //

    if (FileMap_ != nullptr) {
      CloseHandle(FileMap_);
      FileMap_ = nullptr;
    }

    //
    // And finally the file itself.
    //

    if (File_ != nullptr) {
      CloseHandle(File_);
      File_ = nullptr;
    }
  }

  FileMap_t() = default;
  FileMap_t(const FileMap_t &) = delete;
  FileMap_t &operator=(const FileMap_t &) = delete;

  constexpr void *ViewBase() const { return ViewBase_; }

  bool MapFile(const char *PathFile) {
    bool Success = true;
    HANDLE File = nullptr;
    HANDLE FileMap = nullptr;
    PVOID ViewBase = nullptr;
    LARGE_INTEGER FileSize = {0};

    //
    // Open the dump file in read-only.
    //

    File = CreateFileA(PathFile, GENERIC_READ, FILE_SHARE_READ, nullptr,
                       OPEN_EXISTING, 0, nullptr);

    if (File == nullptr) {

      //
      // If we fail to open the file, let the user know.
      //

      const DWORD GLE = GetLastError();
      printf("CreateFile failed with GLE=%lu.\n", GLE);

      if (GLE == ERROR_FILE_NOT_FOUND) {
        printf("  The file %s was not found.\n", PathFile);
      }

      Success = false;
      goto clean;
    }

    //
    // Create the ro file mapping.
    //

    FileMap = CreateFileMappingA(File, nullptr, PAGE_READONLY, 0, 0, nullptr);

    if (FileMap == nullptr) {

      //
      // If we fail to create a file mapping, let
      // the user know.
      //

      const DWORD GLE = GetLastError();
      printf("CreateFileMapping failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    //
    // Map a view of the file in memory.
    //

    ViewBase = MapViewOfFile(FileMap, FILE_MAP_READ, 0, 0, 0);

    if (ViewBase == nullptr) {

      //
      // If we fail to map the view, let the user know.
      //

      const DWORD GLE = GetLastError();
      printf("MapViewOfFile failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    //
    // Get the file size.
    //

    if (!GetFileSizeEx(File, &FileSize)) {
      const DWORD GLE = GetLastError();
      printf("GetFileSizeEx failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    FileSize_ = Page::Align(FileSize.QuadPart) + Page::Size;

    //
    // Everything went well, so grab a copy of the handles for
    // our class and null-out the temporary variables.
    //

    File_ = File;
    File = nullptr;

    FileMap_ = FileMap;
    FileMap = nullptr;

    ViewBase_ = ViewBase;
    ViewBase = nullptr;

  clean:

    //
    // Close the handle to the file mapping..
    //

    if (FileMap != nullptr) {
      CloseHandle(FileMap);
      FileMap = nullptr;
    }

    //
    // And finally the file itself.
    //

    if (File != nullptr) {
      CloseHandle(File);
      File = nullptr;
    }

    return Success;
  }

  bool InBounds(const void *Ptr, const size_t Size) const {
    const uint8_t *ViewEnd = (uint8_t *)ViewBase_ + FileSize_;
    const uint8_t *PtrEnd = (uint8_t *)Ptr + Size;
    return PtrEnd > Ptr && ViewEnd > ViewBase_ && Ptr >= ViewBase_ &&
           PtrEnd < ViewEnd;
  }
};

#elif defined(LINUX)

class FileMap_t {
  void *ViewBase_ = nullptr;
  off_t ViewSize_ = 0;
  int Fd_ = -1;

public:
  ~FileMap_t() {
    if (ViewBase_) {
      munmap(ViewBase_, ViewSize_);
      ViewBase_ = nullptr;
      ViewSize_ = 0;
    }

    if (Fd_ != -1) {
      close(Fd_);
      Fd_ = -1;
    }
  }

  FileMap_t() = default;
  FileMap_t(const FileMap_t &) = delete;
  FileMap_t &operator=(const FileMap_t &) = delete;

  constexpr void *ViewBase() const { return ViewBase_; }

  bool MapFile(const char *PathFile) {
    Fd_ = open(PathFile, O_RDONLY);
    if (Fd_ < 0) {
      perror("Could not open dump file");
      return false;
    }

    struct stat Stat;
    if (fstat(Fd_, &Stat) < 0) {
      perror("Could not stat dump file");
      return false;
    }

    ViewSize_ = Page::Align(Stat.st_size) + Page::Size;
    ViewBase_ = mmap(nullptr, ViewSize_, PROT_READ, MAP_SHARED, Fd_, 0);
    if (ViewBase_ == MAP_FAILED) {
      perror("Could not mmap");
      return false;
    }

    return true;
  }

  bool InBounds(const void *Ptr, const size_t Size) const {
    const uint8_t *ViewEnd = (uint8_t *)ViewBase_ + ViewSize_;
    const uint8_t *PtrEnd = (uint8_t *)Ptr + Size;
    return PtrEnd > Ptr && ViewEnd > ViewBase_ && Ptr >= ViewBase_ &&
           PtrEnd < ViewEnd;
  }
};
#endif
} // namespace kdmpparser

```

`src/lib/kdmp-parser-structs.h`:

```h
// Axel '0vercl0k' Souchet - February 15 2019
#pragma once

#include "platform.h"
#include <array>
#include <cinttypes>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <string_view>
#include <type_traits>
#include <variant>

namespace kdmpparser {

//
// We need a way to represent 128-bits integers so here goes.
//

struct uint128_t {
  uint64_t Low;
  uint64_t High;
};

static_assert(sizeof(uint128_t) == 16, "uint128_t's size looks wrong.");

enum class DumpType_t : uint32_t {
  // Old dump types from dbgeng.dll
  FullDump = 0x1,
  KernelDump = 0x2,
  BMPDump = 0x5,

  // New stuff
  MiniDump = 0x4,             // Produced by `.dump /m`
  LiveKernelBitmapDump = 0x6, // (22h2+) Produced by TaskMgr > System > Create
                              // Live Kernel Memory Dump
  KernelMemoryDump = 0x8,     // Produced by `.dump /k`
  KernelAndUserMemoryDump = 0x9, // Produced by `.dump /ka`
  CompleteMemoryDump = 0xa,      // Produced by `.dump /f`
};

//
// Save off the alignement setting and disable
// alignement.
//

#pragma pack(push)
#pragma pack(1)

//
// Field is a pointer inside the this object and this function
// returns the offset of Field in the object via pointer arithmetic.
//

constexpr uint64_t OffsetFromThis(const uintptr_t This, const uintptr_t Field) {
  return uint64_t(Field) - uint64_t(This);
}

static void DisplayHeader(const uint32_t Prefix, const char *FieldName,
                          const void *This, const void *Field) {
  printf("%*s+0x%04" PRIx64 ": %-25s", Prefix, "",
         OffsetFromThis(uintptr_t(This), uintptr_t(Field)), FieldName);
}

//
// This is the macro we use to get the field name via the preprocessor.
//

#define DISPLAY_FIELD(FieldName)                                               \
  DisplayField(Prefix + 2, #FieldName, this, &FieldName)

#define DISPLAY_FIELD_OFFSET(FieldName)                                        \
  DisplayHeader(Prefix + 2, #FieldName, this, &FieldName);                     \
  printf("\n")

//
// This takes care of displaying basic types.
//

constexpr std::string_view DumpTypeToString(const DumpType_t Type) {
  switch (Type) {
  // Old dump types from dbgeng.dll
  case DumpType_t::FullDump:
    return "FullDump";
  case DumpType_t::KernelDump:
    return "KernelDump";
  case DumpType_t::BMPDump:
    return "BMPDump";

  // New stuff
  case DumpType_t::MiniDump:
    return "MiniDump";
  case DumpType_t::LiveKernelBitmapDump:
    return "LiveKernelBitmapDump";
  case DumpType_t::KernelMemoryDump:
    return "KernelMemoryDump";
  case DumpType_t::KernelAndUserMemoryDump:
    return "KernelAndUserMemoryDump";
  case DumpType_t::CompleteMemoryDump:
    return "CompleteMemoryDump";
  }

  return "Unknown";
}

template <typename Field_t>
static void DisplayField(const uint32_t Prefix, const char *FieldName,
                         const void *This, const Field_t *Field) {
  DisplayHeader(Prefix, FieldName, This, Field);
  if constexpr (std::is_same<Field_t, uint8_t>::value) {
    printf(": 0x%02x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint16_t>::value) {
    printf(": 0x%04x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint32_t>::value) {
    printf(": 0x%08x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint64_t>::value) {
    printf(": 0x%016" PRIx64 ".\n", *Field);
  } else if constexpr (std::is_same<Field_t, int64_t>::value) {
    printf(": 0x%016" PRIx64 ".\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint128_t>::value) {
    printf(": 0x%016" PRIx64 "%016" PRIx64 ".\n", Field->High, Field->Low);
  } else if constexpr (std::is_same<Field_t, DumpType_t>::value) {
    printf(": %s.\n", DumpTypeToString(*Field).data());
  } else {

    //
    // We use std::is_same<> here because otherwise the static_assert fires
    // immediately on g++/clang++ without even instantiating FieldType_t.
    // So we kind of trick the compiler into doing what we want.
    //

    static_assert(std::is_same<Field_t, uint8_t>::value,
                  "DisplayField: Unknown type trying to be displayed.");
  }
}

//
// Display the header of a dump section.
//

#define DISPLAY_HEADER(Name) printf("%*s" Name "\n", Prefix, "")

//
// All credit goes to the rekall project for the RE of the file format.
// https://github.com/google/rekall/blob/master/rekall-core/rekall/plugins/overlays/windows/crashdump.py
//

struct PHYSMEM_RUN {
  uint64_t BasePage;
  uint64_t PageCount;

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("PHYSMEM_RUN");
    DISPLAY_FIELD(BasePage);
    DISPLAY_FIELD(PageCount);
  }
};

static_assert(sizeof(PHYSMEM_RUN) == 0x10, "PHYSMEM_RUN's size looks wrong.");

struct PHYSMEM_DESC {
  uint32_t NumberOfRuns;
  uint32_t Padding0;
  uint64_t NumberOfPages;
  PHYSMEM_RUN Run[1];

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("PHYSMEM_DESC");
    DISPLAY_FIELD(NumberOfRuns);
    DISPLAY_FIELD(NumberOfPages);
    DISPLAY_FIELD_OFFSET(Run);
    if (!LooksGood()) {
      return;
    }

    for (uint32_t RunIdx = 0; RunIdx < NumberOfRuns; RunIdx++) {
      Run[RunIdx].Show(Prefix + 2);
    }
  }

  constexpr bool LooksGood() const {
    if (NumberOfRuns == 0x45474150 || NumberOfPages == 0x4547415045474150ULL) {
      return false;
    }

    return true;
  }
};

static_assert(sizeof(PHYSMEM_DESC) == 0x20,
              "PHYSICAL_MEMORY_DESCRIPTOR's size looks wrong.");

struct BMP_HEADER64 {
  static constexpr uint32_t ExpectedSignature = 0x50'4D'44'53;  // 'PMDS'
  static constexpr uint32_t ExpectedSignature2 = 0x50'4D'44'46; // 'PMDF'
  static constexpr uint32_t ExpectedValidDump = 0x50'4D'55'44;  // 'PMUD'

  //
  // Should be FDMP.
  //

  uint32_t Signature;

  //
  // Should be DUMP.
  //

  uint32_t ValidDump;

  //
  // According to rekall there's a gap there:
  // 'ValidDump': [0x4, ['String', dict(
  //    length=4,
  //    term=None,
  //    )]],
  // # The offset of the first page in the file.
  // 'FirstPage': [0x20, ['unsigned long long']],
  //

  std::array<uint8_t, 0x20 - (0x4 + sizeof(ValidDump))> Padding0;

  //
  // The offset of the first page in the file.
  //

  uint64_t FirstPage;

  //
  // Total number of pages present in the bitmap.
  //
  uint64_t TotalPresentPages;

  //
  // Total number of pages in image.This dictates the total size of the
  // bitmap.This is not the same as the TotalPresentPages which is only
  // the sum of the bits set to 1.
  //

  uint64_t Pages;

  std::array<uint8_t, 1> Bitmap;

  bool LooksGood() const {

    //
    // Integrity check the headers.
    //

    if (Signature != ExpectedSignature && Signature != ExpectedSignature2) {
      printf("BMP_HEADER64::Signature looks wrong.\n");
      return false;
    }

    if (ValidDump != ExpectedValidDump) {
      printf("BMP_HEADER64::ValidDump looks wrong.\n");
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("BMP_HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(FirstPage);
    DISPLAY_FIELD(TotalPresentPages);
    DISPLAY_FIELD(Pages);
    DISPLAY_FIELD_OFFSET(Bitmap);
  }
};

static_assert(offsetof(BMP_HEADER64, FirstPage) == 0x20,
              "First page offset looks wrong.");

struct RDMP_HEADER64 {
  static constexpr uint32_t ExpectedMarker = 0x40;
  static constexpr uint32_t ExpectedSignature = 0x50'4D'44'52; // 'PMDR'
  static constexpr uint32_t ExpectedValidDump = 0x50'4D'55'44; // 'PMUD'

  uint32_t Marker;
  uint32_t Signature;
  uint32_t ValidDump;
  uint32_t __Unused;
  uint64_t MetadataSize;
  uint64_t FirstPageOffset;

  bool LooksGood() const {
    if (Marker != ExpectedMarker) {
      return false;
    }

    if (Signature != RDMP_HEADER64::ExpectedSignature) {
      return false;
    }

    if (ValidDump != RDMP_HEADER64::ExpectedValidDump) {
      return false;
    }

    if (MetadataSize - 0x20 !=
        FirstPageOffset -
            0x20'40) { // sizeof(HEADER64) + sizeof(RDMP_HEADERS64)
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("RDMP_HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(FirstPageOffset);
    DISPLAY_FIELD(MetadataSize);
  }
};

static_assert(sizeof(RDMP_HEADER64) == 0x20, "Invalid size for RDMP_HEADER64");

struct KERNEL_RDMP_HEADER64 {
  RDMP_HEADER64 Hdr;
  uint64_t __Unknown1;
  uint64_t __Unknown2;
  std::array<uint8_t, 1> Bitmap;
};

static_assert(sizeof(KERNEL_RDMP_HEADER64) == 0x30 + 1,
              "Invalid size for KERNEL_RDMP_HEADER64");

static_assert(offsetof(KERNEL_RDMP_HEADER64, Bitmap) == 0x30,
              "Invalid offset for KERNEL_RDMP_HEADER64");

struct FULL_RDMP_HEADER64 {
  RDMP_HEADER64 Hdr;
  uint32_t NumberOfRanges;
  uint16_t __Unknown1;
  uint16_t __Unknown2;
  uint64_t TotalNumberOfPages;
  std::array<uint8_t, 1> Bitmap;
};

static_assert(sizeof(FULL_RDMP_HEADER64) == 0x30 + 1,
              "Invalid size for FULL_RDMP_HEADER64");

static_assert(offsetof(FULL_RDMP_HEADER64, Bitmap) == 0x30,
              "Invalid offset for FULL_RDMP_HEADER64");

struct CONTEXT {

  //
  // Note that the below definition has been stolen directly from the windows
  // headers. Why you might ask? Well the structure comes with DECLSPEC_ALIGN
  // that was preventing me from layoung the Context structure at the offset I
  // wanted. Maybe there's a cleaner way to do this, if so let me know :)
  //

  //
  // Register parameter home addresses.
  //
  // N.B. These fields are for convience - they could be used to extend the
  //      context record in the future.
  //

  uint64_t P1Home;
  uint64_t P2Home;
  uint64_t P3Home;
  uint64_t P4Home;
  uint64_t P5Home;
  uint64_t P6Home;

  //
  // Control flags.
  //

  uint32_t ContextFlags;
  uint32_t MxCsr;

  //
  // Segment Registers and processor flags.
  //

  uint16_t SegCs;
  uint16_t SegDs;
  uint16_t SegEs;
  uint16_t SegFs;
  uint16_t SegGs;
  uint16_t SegSs;
  uint32_t EFlags;

  //
  // Debug registers
  //

  uint64_t Dr0;
  uint64_t Dr1;
  uint64_t Dr2;
  uint64_t Dr3;
  uint64_t Dr6;
  uint64_t Dr7;

  //
  // Integer registers.
  //

  uint64_t Rax;
  uint64_t Rcx;
  uint64_t Rdx;
  uint64_t Rbx;
  uint64_t Rsp;
  uint64_t Rbp;
  uint64_t Rsi;
  uint64_t Rdi;
  uint64_t R8;
  uint64_t R9;
  uint64_t R10;
  uint64_t R11;
  uint64_t R12;
  uint64_t R13;
  uint64_t R14;
  uint64_t R15;

  //
  // Program counter.
  //

  uint64_t Rip;

  //
  // Floating point state.
  //

  uint16_t ControlWord;
  uint16_t StatusWord;
  uint8_t TagWord;
  uint8_t Reserved1;
  uint16_t ErrorOpcode;
  uint32_t ErrorOffset;
  uint16_t ErrorSelector;
  uint16_t Reserved2;
  uint32_t DataOffset;
  uint16_t DataSelector;
  uint16_t Reserved3;
  uint32_t MxCsr2;
  uint32_t MxCsr_Mask;
  std::array<uint128_t, 8> FloatRegisters;
  uint128_t Xmm0;
  uint128_t Xmm1;
  uint128_t Xmm2;
  uint128_t Xmm3;
  uint128_t Xmm4;
  uint128_t Xmm5;
  uint128_t Xmm6;
  uint128_t Xmm7;
  uint128_t Xmm8;
  uint128_t Xmm9;
  uint128_t Xmm10;
  uint128_t Xmm11;
  uint128_t Xmm12;
  uint128_t Xmm13;
  uint128_t Xmm14;
  uint128_t Xmm15;

  //
  // Vector registers.
  //

  std::array<uint128_t, 26> VectorRegister;
  uint64_t VectorControl;

  //
  // Special debug control registers.
  //

  uint64_t DebugControl;
  uint64_t LastBranchToRip;
  uint64_t LastBranchFromRip;
  uint64_t LastExceptionToRip;
  uint64_t LastExceptionFromRip;

  bool LooksGood() const {

    //
    // Integrity check the CONTEXT record.
    //

    if (MxCsr != MxCsr2) {
      printf("CONTEXT::MxCsr doesn't match MxCsr2.\n");
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("CONTEXT");
    DISPLAY_FIELD(P1Home);
    DISPLAY_FIELD(P2Home);
    DISPLAY_FIELD(P3Home);
    DISPLAY_FIELD(P4Home);
    DISPLAY_FIELD(P5Home);
    DISPLAY_FIELD(P6Home);

    //
    // Control flags.
    //

    DISPLAY_FIELD(ContextFlags);
    DISPLAY_FIELD(MxCsr);

    //
    // Segment Registers and processor flags.
    //

    DISPLAY_FIELD(SegCs);
    DISPLAY_FIELD(SegDs);
    DISPLAY_FIELD(SegEs);
    DISPLAY_FIELD(SegFs);
    DISPLAY_FIELD(SegGs);
    DISPLAY_FIELD(SegSs);
    DISPLAY_FIELD(EFlags);

    //
    // Debug registers.
    // XXX: Figure out what they don't look right.
    //

    DISPLAY_FIELD(Dr0);
    DISPLAY_FIELD(Dr1);
    DISPLAY_FIELD(Dr2);
    DISPLAY_FIELD(Dr3);
    DISPLAY_FIELD(Dr6);
    DISPLAY_FIELD(Dr7);

    //
    // Integer registers.
    //

    DISPLAY_FIELD(Rax);
    DISPLAY_FIELD(Rcx);
    DISPLAY_FIELD(Rdx);
    DISPLAY_FIELD(Rbx);
    DISPLAY_FIELD(Rsp);
    DISPLAY_FIELD(Rbp);
    DISPLAY_FIELD(Rsi);
    DISPLAY_FIELD(Rdi);
    DISPLAY_FIELD(R8);
    DISPLAY_FIELD(R9);
    DISPLAY_FIELD(R10);
    DISPLAY_FIELD(R11);
    DISPLAY_FIELD(R12);
    DISPLAY_FIELD(R13);
    DISPLAY_FIELD(R14);
    DISPLAY_FIELD(R15);

    //
    // Program counter.
    //

    DISPLAY_FIELD(Rip);

    //
    // Floating point state.
    //

    DISPLAY_FIELD(ControlWord);
    DISPLAY_FIELD(StatusWord);
    DISPLAY_FIELD(TagWord);
    DISPLAY_FIELD(ErrorOpcode);
    DISPLAY_FIELD(ErrorOffset);
    DISPLAY_FIELD(ErrorSelector);
    DISPLAY_FIELD(DataOffset);
    DISPLAY_FIELD(DataSelector);
    DISPLAY_FIELD(MxCsr2);
    DISPLAY_FIELD(MxCsr_Mask);
    DISPLAY_FIELD(FloatRegisters[0]);
    DISPLAY_FIELD(FloatRegisters[1]);
    DISPLAY_FIELD(FloatRegisters[2]);
    DISPLAY_FIELD(FloatRegisters[3]);
    DISPLAY_FIELD(FloatRegisters[4]);
    DISPLAY_FIELD(FloatRegisters[5]);
    DISPLAY_FIELD(FloatRegisters[6]);
    DISPLAY_FIELD(FloatRegisters[7]);
    DISPLAY_FIELD(Xmm0);
    DISPLAY_FIELD(Xmm1);
    DISPLAY_FIELD(Xmm2);
    DISPLAY_FIELD(Xmm3);
    DISPLAY_FIELD(Xmm4);
    DISPLAY_FIELD(Xmm5);
    DISPLAY_FIELD(Xmm6);
    DISPLAY_FIELD(Xmm7);
    DISPLAY_FIELD(Xmm8);
    DISPLAY_FIELD(Xmm9);
    DISPLAY_FIELD(Xmm10);
    DISPLAY_FIELD(Xmm11);
    DISPLAY_FIELD(Xmm12);
    DISPLAY_FIELD(Xmm13);
    DISPLAY_FIELD(Xmm14);
    DISPLAY_FIELD(Xmm15);

    //
    // Vector registers.
    //

    // M128A VectorRegister[26];
    DISPLAY_FIELD(VectorControl);

    //
    // Special debug control registers.
    //

    DISPLAY_FIELD(DebugControl);
    DISPLAY_FIELD(LastBranchToRip);
    DISPLAY_FIELD(LastBranchFromRip);
    DISPLAY_FIELD(LastExceptionToRip);
    DISPLAY_FIELD(LastExceptionFromRip);
  }
};

static_assert(offsetof(CONTEXT, Xmm0) == 0x1a0,
              "The offset of Xmm0 looks wrong.");

struct EXCEPTION_RECORD64 {
  uint32_t ExceptionCode;
  uint32_t ExceptionFlags;
  uint64_t ExceptionRecord;
  uint64_t ExceptionAddress;
  uint32_t NumberParameters;
  uint32_t __unusedAlignment;
  std::array<uint64_t, 15> ExceptionInformation;

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("KDMP_PARSER_EXCEPTION_RECORD64");
    DISPLAY_FIELD(ExceptionCode);
    DISPLAY_FIELD(ExceptionFlags);
    DISPLAY_FIELD(ExceptionRecord);
    DISPLAY_FIELD(ExceptionAddress);
    DISPLAY_FIELD(NumberParameters);
    DISPLAY_FIELD(ExceptionInformation[0]);
    DISPLAY_FIELD(ExceptionInformation[1]);
    DISPLAY_FIELD(ExceptionInformation[2]);
    DISPLAY_FIELD(ExceptionInformation[3]);
    DISPLAY_FIELD(ExceptionInformation[4]);
    DISPLAY_FIELD(ExceptionInformation[5]);
    DISPLAY_FIELD(ExceptionInformation[6]);
    DISPLAY_FIELD(ExceptionInformation[7]);
    DISPLAY_FIELD(ExceptionInformation[8]);
    DISPLAY_FIELD(ExceptionInformation[9]);
    DISPLAY_FIELD(ExceptionInformation[10]);
    DISPLAY_FIELD(ExceptionInformation[11]);
    DISPLAY_FIELD(ExceptionInformation[12]);
    DISPLAY_FIELD(ExceptionInformation[13]);
    DISPLAY_FIELD(ExceptionInformation[14]);
  }
};

static_assert(sizeof(EXCEPTION_RECORD64) == 0x98,
              "KDMP_PARSER_EXCEPTION_RECORD64's size looks wrong.");

union DUMP_FILE_ATTRIBUTES {
  struct DUMP_FILE_ATTRIBUTES_0 {
    uint32_t _bitfield;
  } Anonymous;
  uint32_t Attributes;
};

//
// Adjusted C struct for `DUMP_HEADERS64` from MS Rust docs. Padding
// adjustment added from reversing `nt!IoFillDumpHeader`.
//
// @link
// https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/Diagnostics/Debug/struct.DUMP_HEADER64.html#structfield.DumpType
//

struct HEADER64 {
  static constexpr uint32_t ExpectedSignature = 0x45474150; // 'EGAP'
  static constexpr uint32_t ExpectedValidDump = 0x34365544; // '46UD'

  /* 0x0000 */ uint32_t Signature;
  /* 0x0004 */ uint32_t ValidDump;
  /* 0x0008 */ uint32_t MajorVersion;
  /* 0x000c */ uint32_t MinorVersion;
  /* 0x0010 */ uint64_t DirectoryTableBase;
  /* 0x0018 */ uint64_t PfnDatabase;
  /* 0x0020 */ uint64_t PsLoadedModuleList;
  /* 0x0028 */ uint64_t PsActiveProcessHead;
  /* 0x0030 */ uint32_t MachineImageType;
  /* 0x0034 */ uint32_t NumberProcessors;
  /* 0x0038 */ uint32_t BugCheckCode;
  /* 0x003c */ uint32_t __Padding0;
  /* 0x0040 */ std::array<uint64_t, 4> BugCheckCodeParameters;
  /* 0x0060 */ std::array<uint8_t, 32> VersionUser;
  /* 0x0080 */ uint64_t KdDebuggerDataBlock;
  /* 0x0088 */ union DUMP_HEADER64_0 {
    PHYSMEM_DESC PhysicalMemoryBlock;
    std::array<uint8_t, 700> PhysicalMemoryBlockBuffer;
  } u1;
  /* 0x0344 */ uint32_t __Padding1;
  /* 0x0348 */ union CONTEXT_RECORD64_0 {
    CONTEXT ContextRecord;
    std::array<uint8_t, 3000> ContextRecordBuffer;
  } u2;
  /* 0x0f00 */ EXCEPTION_RECORD64 Exception;
  /* 0x0f98 */ DumpType_t DumpType;
  /* 0x0f9c */ uint32_t __Padding2;
  /* 0x0fa0 */ int64_t RequiredDumpSpace;
  /* 0x0fa8 */ int64_t SystemTime;
  /* 0x0fb0 */ std::array<uint8_t, 128> Comment;
  /* 0x1030 */ int64_t SystemUpTime;
  /* 0x1038 */ uint32_t MiniDumpFields;
  /* 0x103c */ uint32_t SecondaryDataState;
  /* 0x1040 */ uint32_t ProductType;
  /* 0x1044 */ uint32_t SuiteMask;
  /* 0x1048 */ uint32_t WriterStatus;
  /* 0x104c */ uint8_t Unused1;
  /* 0x104d */ uint8_t KdSecondaryVersion;
  /* 0x104e */ std::array<uint8_t, 2> Unused;
  /* 0x1050 */ DUMP_FILE_ATTRIBUTES Attributes;
  /* 0x1054 */ uint32_t BootId;
  /* 0x1058 */ std::array<uint8_t, 4008> _reserved0;

  union {
    // When dealing with a `DumpType_t::FullDump`, the content of the physical
    // memory directly follows, there's no extra header like with the BMP/RDMP
    // dumps (see `KernelDumpParser::BuildPhysmemFullDump`).
    BMP_HEADER64 BmpHeader;
    KERNEL_RDMP_HEADER64 RdmpHeader;
    FULL_RDMP_HEADER64 FullRdmpHeader;
  } u3;

  bool LooksGood() const {

    //
    // Integrity check the headers.
    //

    if (Signature != ExpectedSignature) {
      printf("HEADER64::Signature looks wrong.\n");
      return false;
    }

    if (ValidDump != ExpectedValidDump) {
      printf("HEADER64::ValidDump looks wrong.\n");
      return false;
    }

    //
    // Make sure it's a dump type we know how to handle.
    //

    switch (DumpType) {
    case DumpType_t::FullDump: {
      if (!u1.PhysicalMemoryBlock.LooksGood()) {
        printf("The PhysicalMemoryBlockBuffer looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::LiveKernelBitmapDump:
    case DumpType_t::BMPDump: {
      if (!u3.BmpHeader.LooksGood()) {
        printf("The BmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::KernelAndUserMemoryDump:
    case DumpType_t::KernelMemoryDump: {
      if (!u3.RdmpHeader.Hdr.LooksGood()) {
        printf("The RdmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::CompleteMemoryDump: {
      if (!u3.FullRdmpHeader.Hdr.LooksGood()) {
        printf("The RdmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::MiniDump: {
      printf("Unsupported type %s (%#x).\n", DumpTypeToString(DumpType).data(),
             uint32_t(DumpType));
      return false;
    }

    default: {
      printf("Unknown Type %#x.\n", uint32_t(DumpType));
      return false;
    }
    }

    //
    // Integrity check the CONTEXT record.
    //

    if (!u2.ContextRecord.LooksGood()) {
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(MajorVersion);
    DISPLAY_FIELD(MinorVersion);
    DISPLAY_FIELD(DirectoryTableBase);
    DISPLAY_FIELD(PfnDatabase);
    DISPLAY_FIELD(PsLoadedModuleList);
    DISPLAY_FIELD(PsActiveProcessHead);
    DISPLAY_FIELD(MachineImageType);
    DISPLAY_FIELD(NumberProcessors);
    DISPLAY_FIELD(BugCheckCode);
    DISPLAY_FIELD_OFFSET(BugCheckCodeParameters);
    DISPLAY_FIELD(KdDebuggerDataBlock);
    DISPLAY_FIELD_OFFSET(u1.PhysicalMemoryBlockBuffer);
    u1.PhysicalMemoryBlock.Show(Prefix + 2);
    DISPLAY_FIELD_OFFSET(u2.ContextRecordBuffer);
    u2.ContextRecord.Show(Prefix + 2);
    DISPLAY_FIELD_OFFSET(Exception);
    Exception.Show(Prefix + 2);
    DISPLAY_FIELD(DumpType);
    DISPLAY_FIELD(RequiredDumpSpace);
    DISPLAY_FIELD(SystemTime);
    DISPLAY_FIELD_OFFSET(Comment);
    DISPLAY_FIELD(SystemUpTime);
    DISPLAY_FIELD(MiniDumpFields);
    DISPLAY_FIELD(SecondaryDataState);
    DISPLAY_FIELD(ProductType);
    DISPLAY_FIELD(SuiteMask);
    DISPLAY_FIELD(WriterStatus);
    DISPLAY_FIELD(KdSecondaryVersion);
    if (DumpType == DumpType_t::BMPDump) {
      DISPLAY_FIELD_OFFSET(u3.BmpHeader);
      u3.BmpHeader.Show();
    }
  }
};

//
// Restore the default alignement setting.
//

#pragma pack(pop)

//
// Prevent the user to play around with those.
//

#undef DISPLAY_HEADER
#undef DISPLAY_FIELD

//
// Those asserts are the results of a lot of frustration getting the right
// layout, so hopefully they prevent any regressions regarding the layout.
//

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif //__GNUC__
static_assert(offsetof(HEADER64, Signature) == 0x00,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, BugCheckCodeParameters) == 0x40,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, KdDebuggerDataBlock) == 0x80,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, u2.ContextRecord) == 0x348,
              "The offset of ContextRecord looks wrong.");

static_assert(offsetof(HEADER64, Exception) == 0xf00,
              "The offset of Exception looks wrong.");

static_assert(offsetof(HEADER64, Comment) == 0xfb0,
              "The offset of Comment looks wrong.");

static_assert(offsetof(HEADER64, u3.BmpHeader) == 0x2000,
              "The offset of BmpHeaders looks wrong.");
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif //__GNUC__

//
// Structure for parsing a PTE.
//

union MMPTE_HARDWARE {
  struct {
    uint64_t Present : 1;
    uint64_t Write : 1;
    uint64_t UserAccessible : 1;
    uint64_t WriteThrough : 1;
    uint64_t CacheDisable : 1;
    uint64_t Accessed : 1;
    uint64_t Dirty : 1;
    uint64_t LargePage : 1;
    uint64_t Available : 4;
    uint64_t PageFrameNumber : 36;
    uint64_t ReservedForHardware : 4;
    uint64_t ReservedForSoftware : 11;
    uint64_t NoExecute : 1;
  } u;
  uint64_t AsUINT64;
  constexpr MMPTE_HARDWARE(const uint64_t Value) : AsUINT64(Value) {}
};

//
// Structure to parse a virtual address.
//

union VIRTUAL_ADDRESS {
  struct {
    uint64_t Offset : 12;
    uint64_t PtIndex : 9;
    uint64_t PdIndex : 9;
    uint64_t PdPtIndex : 9;
    uint64_t Pml4Index : 9;
    uint64_t Reserved : 16;
  } u;
  uint64_t AsUINT64;
  constexpr VIRTUAL_ADDRESS(const uint64_t Value) : AsUINT64(Value) {}
};

static_assert(sizeof(MMPTE_HARDWARE) == 8);
static_assert(sizeof(VIRTUAL_ADDRESS) == 8);
} // namespace kdmpparser
```

`src/lib/kdmp-parser-version.h.in`:

```in
#pragma once

// clang-format off
#define KDMPPARSER_PROJECT_NAME "@PROJECT_NAME@"
#define KDMPPARSER_PROJECT_AUTHOR "@PROJECT_AUTHOR@"
#define KDMPPARSER_PROJECT_LICENSE "@PROJECT_LICENSE@"
#define KDMPPARSER_VERSION_MAJOR @PROJECT_VERSION_MAJOR@
#define KDMPPARSER_VERSION_MINOR @PROJECT_VERSION_MINOR@
#define KDMPPARSER_VERSION_PATCH @PROJECT_VERSION_PATCH@
#define KDMPPARSER_VERSION_RELEASE "@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@"
// clang-format on

```

`src/lib/kdmp-parser.h`:

```h
// Axel '0vercl0k' Souchet - February 15 2019
#pragma once

#include "filemap.h"
#include "kdmp-parser-structs.h"
#include "kdmp-parser-version.h"

#include <array>
#include <cstdint>
#include <cstdio>
#include <filesystem>
#include <optional>
#include <string>
#include <unordered_map>

namespace kdmpparser {

using Page_t = std::array<uint8_t, kdmpparser::Page::Size>;
using Physmem_t = std::unordered_map<uint64_t, const uint8_t *>;

struct BugCheckParameters_t {
  uint32_t BugCheckCode;
  std::array<uint64_t, 4> BugCheckCodeParameter;
};

class KernelDumpParser {

  //
  // The mapped file.
  //

  FileMap_t FileMap_;

  //
  // Header of the crash-dump.
  //

  HEADER64 *DmpHdr_ = nullptr;

  //
  // File path to the crash-dump.
  //

  std::filesystem::path PathFile_;

  //
  // Mapping between physical addresses / page data.
  //

  Physmem_t Physmem_;

public:
  //
  // Actually do the parsing of the file.
  //

  bool Parse(const char *PathFile) {

    //
    // Copy the path file.
    //

    PathFile_ = std::filesystem::path(PathFile);
    if (!std::filesystem::exists(PathFile_)) {
      printf("Invalid file: %s.\n", (char *)PathFile_.string().c_str());
      return false;
    }

    //
    // Map a view of the file.
    //

    if (!MapFile()) {
      printf("MapFile failed.\n");
      return false;
    }

    //
    // Parse the DMP_HEADER.
    //

    if (!ParseDmpHeader()) {
      printf("ParseDmpHeader failed.\n");
      return false;
    }

    //
    // Retrieve the physical memory according to the type of dump we have.
    //

    switch (DmpHdr_->DumpType) {
    case DumpType_t::FullDump: {
      if (!BuildPhysmemFullDump()) {
        printf("BuildPhysmemFullDump failed.\n");
        return false;
      }
      break;
    }
    case DumpType_t::LiveKernelBitmapDump:
    case DumpType_t::BMPDump: {
      if (!BuildPhysmemBMPDump()) {
        printf("BuildPhysmemBMPDump failed.\n");
        return false;
      }
      break;
    }

    case DumpType_t::CompleteMemoryDump:
    case DumpType_t::KernelAndUserMemoryDump:
    case DumpType_t::KernelMemoryDump: {
      if (!BuildPhysicalMemoryFromDump(DmpHdr_->DumpType)) {
        printf("BuildPhysicalMemoryFromDump failed.\n");
        return false;
      }
      break;
    }

    default: {
      printf("Invalid type\n");
      return false;
    }
    }

    return true;
  }

  //
  // Give the Context record to the user.
  //

  constexpr const CONTEXT &GetContext() const {

    //
    // Give the user a view of the context record.
    //

    return DmpHdr_->u2.ContextRecord;
  }

  //
  // Give the bugcheck parameters to the user.
  //

  constexpr BugCheckParameters_t GetBugCheckParameters() const {

    //
    // Give the user a view of the bugcheck parameters.
    //

    return {DmpHdr_->BugCheckCode,
            {DmpHdr_->BugCheckCodeParameters[0],
             DmpHdr_->BugCheckCodeParameters[1],
             DmpHdr_->BugCheckCodeParameters[2],
             DmpHdr_->BugCheckCodeParameters[3]}};
  }

  //
  // Get the path of dump.
  //

  const std::filesystem::path &GetDumpPath() const { return PathFile_; }

  //
  // Get the type of dump.
  //

  constexpr DumpType_t GetDumpType() const { return DmpHdr_->DumpType; }

  //
  // Get the physmem.
  //

  constexpr const Physmem_t &GetPhysmem() const { return Physmem_; }

  //
  // Show the exception record.
  //

  void ShowExceptionRecord(const uint32_t Prefix) const {
    DmpHdr_->Exception.Show(Prefix);
  }

  //
  // Show the context record.
  //

  void ShowContextRecord(const uint32_t Prefix) const {
    const CONTEXT &Context = GetContext();
    printf("%*srax=%016" PRIx64 " rbx=%016" PRIx64 " rcx=%016" PRIx64 "\n",
           Prefix, "", Context.Rax, Context.Rbx, Context.Rcx);
    printf("%*srdx=%016" PRIx64 " rsi=%016" PRIx64 " rdi=%016" PRIx64 "\n",
           Prefix, "", Context.Rdx, Context.Rsi, Context.Rdi);
    printf("%*srip=%016" PRIx64 " rsp=%016" PRIx64 " rbp=%016" PRIx64 "\n",
           Prefix, "", Context.Rip, Context.Rsp, Context.Rbp);
    printf("%*s r8=%016" PRIx64 "  r9=%016" PRIx64 " r10=%016" PRIx64 "\n",
           Prefix, "", Context.R8, Context.R9, Context.R10);
    printf("%*sr11=%016" PRIx64 " r12=%016" PRIx64 " r13=%016" PRIx64 "\n",
           Prefix, "", Context.R11, Context.R12, Context.R13);
    printf("%*sr14=%016" PRIx64 " r15=%016" PRIx64 "\n", Prefix, "",
           Context.R14, Context.R15);
    printf("%*scs=%04x ss=%04x ds=%04x es=%04x fs=%04x gs=%04x    "
           "             efl=%08x\n",
           Prefix, "", Context.SegCs, Context.SegSs, Context.SegDs,
           Context.SegEs, Context.SegFs, Context.SegGs, Context.EFlags);
    printf("%*sfpcw=%04x    fpsw=%04x    fptw=%04x\n", Prefix, "",
           Context.ControlWord, Context.StatusWord, 1);
    printf("%*s  st0=%016" PRIx64 "%016" PRIx64 "       st1=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[0].High,
           Context.FloatRegisters[0].Low, Context.FloatRegisters[1].High,
           Context.FloatRegisters[1].Low);
    printf("%*s  st2=%016" PRIx64 "%016" PRIx64 "       st3=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[2].High,
           Context.FloatRegisters[2].Low, Context.FloatRegisters[3].High,
           Context.FloatRegisters[3].Low);
    printf("%*s  st4=%016" PRIx64 "%016" PRIx64 "       st5=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[4].High,
           Context.FloatRegisters[4].Low, Context.FloatRegisters[5].High,
           Context.FloatRegisters[5].Low);
    printf("%*s  st6=%016" PRIx64 "%016" PRIx64 "       st7=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[6].High,
           Context.FloatRegisters[6].Low, Context.FloatRegisters[7].High,
           Context.FloatRegisters[7].Low);
    printf("%*s xmm0=%016" PRIx64 "%016" PRIx64 "      xmm1=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm0.High, Context.Xmm0.Low, Context.Xmm1.High,
           Context.Xmm1.Low);
    printf("%*s xmm2=%016" PRIx64 "%016" PRIx64 "      xmm3=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm2.High, Context.Xmm2.Low, Context.Xmm3.High,
           Context.Xmm3.Low);
    printf("%*s xmm4=%016" PRIx64 "%016" PRIx64 "      xmm5=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm4.High, Context.Xmm4.Low, Context.Xmm5.High,
           Context.Xmm5.Low);
    printf("%*s xmm6=%016" PRIx64 "%016" PRIx64 "      xmm7=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm6.High, Context.Xmm6.Low, Context.Xmm7.High,
           Context.Xmm7.Low);
    printf("%*s xmm8=%016" PRIx64 "%016" PRIx64 "      xmm9=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm8.High, Context.Xmm8.Low, Context.Xmm9.High,
           Context.Xmm9.Low);
    printf("%*sxmm10=%016" PRIx64 "%016" PRIx64 "     xmm11=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm10.High, Context.Xmm10.Low,
           Context.Xmm11.High, Context.Xmm11.Low);
    printf("%*sxmm12=%016" PRIx64 "%016" PRIx64 "     xmm13=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm12.High, Context.Xmm12.Low,
           Context.Xmm13.High, Context.Xmm13.Low);
    printf("%*sxmm14=%016" PRIx64 "%016" PRIx64 "     xmm15=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm14.High, Context.Xmm14.Low,
           Context.Xmm15.High, Context.Xmm15.Low);
  }

  //
  // Show all the structures of the dump.
  //

  void ShowAllStructures(const uint32_t Prefix) const { DmpHdr_->Show(Prefix); }

  //
  // Get the content of a physical address.
  //

  const uint8_t *GetPhysicalPage(const uint64_t PhysicalAddress) const {

    //
    // Attempt to find the physical address.
    //

    const auto &Pair = Physmem_.find(PhysicalAddress);

    //
    // If it doesn't exist then return nullptr.
    //

    if (Pair == Physmem_.end()) {
      return nullptr;
    }

    //
    // Otherwise we return a pointer to the content of the page.
    //

    return Pair->second;
  }

  //
  // Get the directory table base.
  //

  constexpr uint64_t GetDirectoryTableBase() const {
    return DmpHdr_->DirectoryTableBase;
  }

  //
  // Translate a virtual address to physical address using a directory table
  // base.
  //

  std::optional<uint64_t>
  VirtTranslate(const uint64_t VirtualAddress,
                const uint64_t DirectoryTableBase = 0) const {

    //
    // If DirectoryTableBase is null ; use the one from the dump header and
    // clear PCID bits (bits 11:0).
    //

    uint64_t LocalDTB = Page::Align(GetDirectoryTableBase());

    if (DirectoryTableBase) {
      LocalDTB = Page::Align(DirectoryTableBase);
    }

    //
    // Stole code from @yrp604 and @0vercl0k.
    //

    const VIRTUAL_ADDRESS GuestAddress(VirtualAddress);
    const MMPTE_HARDWARE Pml4(LocalDTB);
    const uint64_t Pml4Base = Pml4.u.PageFrameNumber * Page::Size;
    const uint64_t Pml4eGpa = Pml4Base + GuestAddress.u.Pml4Index * 8;
    const MMPTE_HARDWARE Pml4e(PhyRead8(Pml4eGpa));
    if (!Pml4e.u.Present) {
      printf("Invalid page map level 4, address translation failed!\n");
      return {};
    }

    const uint64_t PdptBase = Pml4e.u.PageFrameNumber * Page::Size;
    const uint64_t PdpteGpa = PdptBase + GuestAddress.u.PdPtIndex * 8;
    const MMPTE_HARDWARE Pdpte(PhyRead8(PdpteGpa));
    if (!Pdpte.u.Present) {
      printf("Invalid page directory pointer table, address translation "
             "failed!\n");
      return {};
    }

    //
    // huge pages:
    // 7 (PS) - Page size; must be 1 (otherwise, this entry references a page
    // directory; see Table 4-1
    //

    const uint64_t PdBase = Pdpte.u.PageFrameNumber * Page::Size;
    if (Pdpte.u.LargePage) {
      return PdBase + (VirtualAddress & 0x3fff'ffff);
    }

    const uint64_t PdeGpa = PdBase + GuestAddress.u.PdIndex * 8;
    const MMPTE_HARDWARE Pde(PhyRead8(PdeGpa));
    if (!Pde.u.Present) {
      printf("Invalid page directory entry, address translation failed!\n");
      return {};
    }

    //
    // large pages:
    // 7 (PS) - Page size; must be 1 (otherwise, this entry references a page
    // table; see Table 4-18
    //

    const uint64_t PtBase = Pde.u.PageFrameNumber * Page::Size;
    if (Pde.u.LargePage) {
      return PtBase + (VirtualAddress & 0x1f'ffff);
    }

    const uint64_t PteGpa = PtBase + GuestAddress.u.PtIndex * 8;
    const MMPTE_HARDWARE Pte(PhyRead8(PteGpa));
    if (!Pte.u.Present) {
      printf("Invalid page table entry, address translation failed!\n");
      return {};
    }

    const uint64_t PageBase = Pte.u.PageFrameNumber * Page::Size;
    return PageBase + GuestAddress.u.Offset;
  }

  //
  // Get the content of a virtual address.
  //

  const uint8_t *GetVirtualPage(const uint64_t VirtualAddress,
                                const uint64_t DirectoryTableBase = 0) const {

    //
    // First remove offset and translate the virtual address.
    //

    const auto &PhysicalAddress =
        VirtTranslate(Page::Align(VirtualAddress), DirectoryTableBase);

    if (!PhysicalAddress) {
      return nullptr;
    }

    //
    // Then get the physical page.
    //

    return GetPhysicalPage(*PhysicalAddress);
  }

  const HEADER64 &GetDumpHeader() const {
    if (!DmpHdr_) {
      std::abort();
    }

    return *DmpHdr_;
  }

private:
  //
  // Utility function to read an uint64_t from a physical address.
  //

  uint64_t PhyRead8(const uint64_t PhysicalAddress) const {

    //
    // Get the physical page and read from the offset.
    //

    const uint8_t *PhysicalPage = GetPhysicalPage(Page::Align(PhysicalAddress));

    if (!PhysicalPage) {
      printf("Internal page table parsing failed!\n");
      return 0;
    }

    const uint64_t *Ptr =
        (uint64_t *)(PhysicalPage + Page::Offset(PhysicalAddress));
    return *Ptr;
  }

  //
  // Build a map of physical addresses / page data pointers for full dump.
  //

  bool BuildPhysmemFullDump() {

    //
    // Walk through the runs.
    //

    uint8_t *RunBase = (uint8_t *)&DmpHdr_->u3.BmpHeader;
    const uint32_t NumberOfRuns = DmpHdr_->u1.PhysicalMemoryBlock.NumberOfRuns;

    //
    // Back at it, this time building the index!
    //

    for (uint32_t RunIdx = 0; RunIdx < NumberOfRuns; RunIdx++) {

      //
      // Grab the current run as well as its base page and page count.
      //

      const PHYSMEM_RUN *Run = DmpHdr_->u1.PhysicalMemoryBlock.Run + RunIdx;

      const uint64_t BasePage = Run->BasePage;
      const uint64_t PageCount = Run->PageCount;

      //
      // Walk the pages from the run.
      //

      for (uint64_t PageIdx = 0; PageIdx < PageCount; PageIdx++) {

        //
        // Compute the current PFN as well as the actual physical address of
        // the page.
        //

        const uint64_t Pfn = BasePage + PageIdx;
        const uint64_t Pa = Pfn * Page::Size;

        //
        // Now one thing to understand is that the Runs structure allows to
        // skip for holes in memory. Instead of, padding them with empty
        // spaces to conserve a 1:1 mapping between physical address and file
        // offset, the Run gives you the base Pfn. This means that we don't
        // have a 1:1 mapping between file offset and physical addresses so we
        // need to keep track of where the Run starts in memory and then we
        // can simply access our pages one after the other.
        //
        // If this is not clear enough, here is a small example:
        //  Run[0]
        //    BasePage = 1337, PageCount = 2
        //  Run[1]
        //    BasePage = 1400, PageCount = 1
        //
        // In the above we clearly see that there is a hole between the two
        // runs; the dump file has 2+1 memory pages. Their Pfns are: 1337+0,
        // 1337+1, 1400+0.
        //
        // Now if we want to get the file offset of those pages we start at
        // Run0:
        //   Run0 starts at file offset 0x2000 so Page0 is at file offset
        //   0x2000, Page1 is at file offset 0x3000. Run1 starts at file
        //   offset 0x2000+(2*0x1000) so Page3 is at file offset
        //   0x2000+(2*0x1000)+0x1000.
        //
        // That is the reason why the computation below is RunBase + (PageIdx
        // * 0x1000) instead of RunBase + (Pfn * 0x1000).

        const uint8_t *PageBase = RunBase + (PageIdx * Page::Size);

        //
        // Map the Pfn to a page.
        //

        Physmem_.try_emplace(Pa, PageBase);
      }

      //
      // Move the run base past all the pages in the current run.
      //

      RunBase += PageCount * Page::Size;
    }

    return true;
  }

  //
  // Build a map of physical addresses / page data pointers for BMP dump.
  //

  bool BuildPhysmemBMPDump() {
    const uint8_t *Page = (uint8_t *)DmpHdr_ + DmpHdr_->u3.BmpHeader.FirstPage;
    const uint64_t BitmapSize = DmpHdr_->u3.BmpHeader.Pages / 8;
    const uint8_t *Bitmap = DmpHdr_->u3.BmpHeader.Bitmap.data();

    //
    // Walk the bitmap byte per byte.
    //

    for (uint64_t BitmapIdx = 0; BitmapIdx < BitmapSize; BitmapIdx++) {

      //
      // Now walk the bits of the current byte.
      //

      const uint8_t Byte = Bitmap[BitmapIdx];
      for (uint8_t BitIdx = 0; BitIdx < 8; BitIdx++) {

        //
        // If the bit is not set we just skip to the next.
        //

        const bool BitSet = ((Byte >> BitIdx) & 1) == 1;
        if (!BitSet) {
          continue;
        }

        //
        // If the bit is one we add the page to the physmem.
        //

        const uint64_t Pfn = (BitmapIdx * 8) + BitIdx;
        const uint64_t Pa = Pfn * Page::Size;
        Physmem_.try_emplace(Pa, Page);
        Page += Page::Size;
      }
    }

    return true;
  }

  //
  // Populate the physical memory map for the 'new' dump types.
  // `Type` must be either `KernelMemoryDump`, `KernelAndUserMemoryDump`,
  // or `CompleteMemoryDump`.
  //
  // Returns true on success, false otherwise.
  //

  bool BuildPhysicalMemoryFromDump(const DumpType_t Type) {
    uint64_t FirstPageOffset = 0;
    uint8_t *Page = nullptr;
    uint64_t MetadataSize = 0;
    uint8_t *Bitmap = nullptr;
    uint64_t TotalNumberOfPages = 0;
    uint64_t CurrentPageCount = 0;

    switch (Type) {
    case DumpType_t::KernelMemoryDump:
    case DumpType_t::KernelAndUserMemoryDump: {
      FirstPageOffset = DmpHdr_->u3.RdmpHeader.Hdr.FirstPageOffset;
      Page = (uint8_t *)DmpHdr_ + FirstPageOffset;
      MetadataSize = DmpHdr_->u3.RdmpHeader.Hdr.MetadataSize;
      Bitmap = DmpHdr_->u3.RdmpHeader.Bitmap.data();
      break;
    }

    case DumpType_t::CompleteMemoryDump: {
      FirstPageOffset = DmpHdr_->u3.FullRdmpHeader.Hdr.FirstPageOffset;
      Page = (uint8_t *)DmpHdr_ + FirstPageOffset;
      MetadataSize = DmpHdr_->u3.FullRdmpHeader.Hdr.MetadataSize;
      Bitmap = DmpHdr_->u3.FullRdmpHeader.Bitmap.data();
      TotalNumberOfPages = DmpHdr_->u3.FullRdmpHeader.TotalNumberOfPages;
      break;
    }

    default: {
      return false;
    }
    }

    if (!FirstPageOffset || !Page || !MetadataSize || !Bitmap) {
      return false;
    }

    auto IsPageInBounds = [&](const uint8_t *Ptr) {
      return FileMap_.InBounds(Ptr, Page::Size);
    };

    if (!IsPageInBounds(Page)) {
      return false;
    }

    struct PfnRange {
      uint64_t PageFileNumber;
      uint64_t NumberOfPages;
    };

    // Sanity check
    if (MetadataSize % sizeof(PfnRange)) {
      return false;
    }

    for (uint64_t Offset = 0; Offset < MetadataSize;
         Offset += sizeof(PfnRange)) {

      if (Type == DumpType_t::CompleteMemoryDump) {
        // `CompleteMemoryDump` type seems to be bound by the
        // `TotalNumberOfPages` field, *not* by `MetadataSize`.
        if (CurrentPageCount == TotalNumberOfPages) {
          break;
        }

        if (CurrentPageCount > TotalNumberOfPages) {
          return false;
        }
      }

      const PfnRange &Entry = (PfnRange &)Bitmap[Offset];
      if (!FileMap_.InBounds(&Entry, sizeof(Entry))) {
        return false;
      }

      CurrentPageCount += Entry.NumberOfPages;

      const uint64_t Pfn = Entry.PageFileNumber;
      if (!Pfn) {
        break;
      }

      for (uint64_t PageIdx = 0; PageIdx < Entry.NumberOfPages; PageIdx++) {
        if (!IsPageInBounds(Page)) {
          return false;
        }

        const uint64_t Pa = (Pfn * Page::Size) + (PageIdx * Page::Size);
        Physmem_.try_emplace(Pa, Page);
        Page += Page::Size;
      }
    }

    return true;
  }

  //
  // Parse the DMP_HEADER.
  //

  bool ParseDmpHeader() {

    //
    // The base of the view points on the HEADER64.
    //

    DmpHdr_ = (HEADER64 *)FileMap_.ViewBase();

    //
    // Now let's make sure the structures look right.
    //

    if (!DmpHdr_->LooksGood()) {
      printf("The header looks wrong.\n");
      return false;
    }

    return true;
  }

  //
  // Map a view of the file in memory.
  //

  bool MapFile() { return FileMap_.MapFile(PathFile_.string().c_str()); }
};

struct Version_t {
  static inline const uint16_t Major = KDMPPARSER_VERSION_MAJOR;
  static inline const uint16_t Minor = KDMPPARSER_VERSION_MINOR;
  static inline const uint16_t Patch = KDMPPARSER_VERSION_PATCH;
  static inline const std::string Release = KDMPPARSER_VERSION_RELEASE;
};

} // namespace kdmpparser

```

`src/lib/platform.h`:

```h
// Axel '0vercl0k' Souchet - April 18 2020
#pragma once

#if defined(__i386__) || defined(_M_IX86)
#define ARCH_X86
#elif defined(__amd64__) || defined(_M_X64)
#define ARCH_X64
#elif defined(__aarch64__) || defined(_M_ARM64)
#define ARCH_ARM64
#else
#error Architecture not supported.
#endif

#if defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64)
#define WINDOWS
#define SYSTEM_PLATFORM "Windows"

#include <windows.h>
#if defined(ARCH_X86)
#define WINDOWS_X86
#elif defined(ARCH_X64)
#define WINDOWS_X64
#elif defined(ARCH_ARM64)
#define WINDOWS_ARM64
#endif

#elif defined(linux) || defined(__linux) || defined(__FreeBSD__) ||            \
    defined(__FreeBSD_kernel__) || defined(__MACH__)
#define LINUX

#if defined(linux) || defined(__linux)
#define SYSTEM_PLATFORM "Linux"

#if defined(ARCH_X86)
#define LINUX_X86
#elif defined(ARCH_X64)
#define LINUX_X64
#elif defined(ARCH_ARM64)
#define LINUX_ARM64
#endif

#elif defined(__APPLE__)

#define SYSTEM_PLATFORM "OSX"
#if defined(ARCH_X86)
#define OSX_X86
#elif defined(ARCH_X64)
#define OSX_X64
#elif defined(ARCH_ARM64)
#define OSX_ARM64
#endif
#else
#error An error occured
#endif

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

#else
#error Platform not supported.
#endif

```

`src/parser/CMakeLists.txt`:

```txt
# Axel '0vercl0k' Souchet - April 18 2020
link_libraries(kdmp-parser)
add_executable(parser parser.cc)
target_compile_options(
    parser
    PUBLIC
    $<$<CXX_COMPILER_ID:MSVC>:/W4$<SEMICOLON>/WX>
    $<$<CXX_COMPILER_ID:GNU>:-Wall$<SEMICOLON>-Wextra$<SEMICOLON>-pedantic$<SEMICOLON>-Werror>
    $<$<CXX_COMPILER_ID:Clang>:-Wall$<SEMICOLON>-Wextra$<SEMICOLON>-pedantic$<SEMICOLON>-Werror>
)
install(TARGETS parser DESTINATION .)

if(MSVC)
    install(FILES $<TARGET_PDB_FILE:parser> DESTINATION . OPTIONAL)
endif(MSVC)

```

`src/parser/parser.cc`:

```cc
// Axel '0vercl0k' Souchet - February 15 2019
#include "kdmp-parser.h"

#include <algorithm>
#include <cctype>
#include <cstring>
#include <string_view>
#include <vector>

//
// Delimiter.
//

#define DELIMITER                                                              \
  "----------------------------------------------------------------------"     \
  "----------"

//
// The options available for the parser.
//

struct Options_t {

  //
  // This is enabled if -h is used.
  //

  bool ShowHelp = false;

  //
  // This is enabled if -c is used.
  //

  bool ShowContextRecord = false;

  //
  // This is enabled if -a is used.
  //

  bool ShowAllStructures = false;

  //
  // This is enabled if -e is used.
  //

  bool ShowExceptionRecord = false;

  //
  // This is enable if -p is used.
  //

  bool ShowPhysicalMem = false;

  //
  // This is on if the user specified a physical address.
  //

  bool HasPhysicalAddress = false;

  //
  // If an optional physical address has been passed to -p then this is the
  // physical address.

  uint64_t PhysicalAddress = 0;

  //
  // The path to the dump file.
  //

  std::string_view DumpPath;
};

//
// Display usage
//

void Help() {
  printf("parser.exe [-p [<physical address>]] [-c] [-e] [-h] <kdump path>\n");
  printf("\n");
  printf("Examples:\n");
  printf("  Show every structures of the dump:\n");
  printf("    parser.exe -a full.dmp\n");
  printf("\n");
  printf("  Show the context record:\n");
  printf("    parser.exe -c full.dmp\n");
  printf("\n");
  printf("  Show the exception record:\n");
  printf("    parser.exe -e full.dmp\n");
  printf("\n");
  printf("  Show all the physical memory (first 16 bytes of every "
         "pages):\n");
  printf("    parser.exe -p full.dmp\n");
  printf("\n");
  printf("  Show the context record as well as the page at physical "
         "address 0x1000:\n");
  printf("    parser.exe -c -p 0x1000 full.dmp\n");
}

//
// Copied from https://github.com/pvachon/tsl/blob/master/tsl/hexdump.c.
// Phil is the man.
//

void Hexdump(const uint64_t Address, const void *Buffer, size_t Len) {
  const uint8_t *ptr = (uint8_t *)Buffer;

  for (size_t i = 0; i < Len; i += 16) {
    printf("%08" PRIx64 ": ", Address + i);
    for (int j = 0; j < 16; j++) {
      if (i + j < Len) {
        printf("%02x ", ptr[i + j]);
      } else {
        printf("   ");
      }
    }
    printf(" |");
    for (int j = 0; j < 16; j++) {
      if (i + j < Len) {
        printf("%c", isprint(ptr[i + j]) ? (char)ptr[i + j] : '.');
      } else {
        printf(" ");
      }
    }
    printf("|\n");
  }
}

//
// Let's do some work!
//

int main(int argc, const char *argv[]) {

  //
  // This holds the options passed to the program.
  //

  Options_t Opts;

  //
  // Parse the arguments passed to the program.
  //

  for (int ArgIdx = 1; ArgIdx < argc; ArgIdx++) {
    const std::string_view Arg(argv[ArgIdx]);
    const int IsLastArg = (ArgIdx + 1) >= argc;

    if (Arg == "-c") {

      //
      // Show the context record.
      //

      Opts.ShowContextRecord = 1;
    } else if (Arg == "-p") {

      //
      // Show the physical memory.
      //

      Opts.ShowPhysicalMem = 1;

      //
      // If the next argument is not the last one, we assume that it is followed
      // by a physical address.
      //

      const int NextArgIdx = ArgIdx + 1;
      const bool IsNextArgLast = (NextArgIdx + 1) >= argc;

      if (!IsNextArgLast) {

        //
        // In which case we convert it to an actual integer.
        //

        Opts.HasPhysicalAddress = true;
        Opts.PhysicalAddress = strtoull(argv[NextArgIdx], nullptr, 0);

        //
        // Skip the next argument.
        //

        ArgIdx++;
      }
    } else if (Arg == "-e") {

      //
      // Show the exception record.
      //

      Opts.ShowExceptionRecord = 1;
    } else if (Arg == "-a") {

      //
      // Show all the structures.
      //

      Opts.ShowAllStructures = true;
    } else if (Arg == "-h") {

      //
      // Show the help.
      //

      Opts.ShowHelp = true;
    } else if (IsLastArg) {

      //
      // If this is the last argument then this must be the dump path.
      //

      Opts.DumpPath = Arg;
    } else {

      //
      // Otherwise it seems that the user passed something wrong?
      //

      printf("The argument %s is not recognized.\n\n", Arg.data());
      Help();
      return EXIT_FAILURE;
    }
  }

  //
  // Show the help.
  //

  if (Opts.ShowHelp) {
    Help();
    return EXIT_SUCCESS;
  }

  //
  // The only thing we actually need is a file path. So let's make sure we
  // have one.
  //

  if (Opts.DumpPath.empty()) {
    printf("You didn't provide the path to the dump file.\n\n");
    Help();
    return EXIT_FAILURE;
  }

  //
  // If we only have a path, at least force to dump the context
  // structure.
  //

  if (!Opts.ShowContextRecord && !Opts.ShowPhysicalMem &&
      !Opts.ShowAllStructures && !Opts.ShowExceptionRecord) {
    printf("Forcing to show the context record as no option as been "
           "passed.\n\n");
    Opts.ShowContextRecord = 1;
  }

  //
  // Create the parser instance.
  //

  kdmpparser::KernelDumpParser Dmp;

  //
  // Parse the dump file.
  //

  if (!Dmp.Parse(Opts.DumpPath.data())) {
    printf("Parsing of the dump failed, exiting.\n");
    return EXIT_FAILURE;
  }

  //
  // If the user wants all the structures, then show them.
  //

  if (Opts.ShowAllStructures) {
    printf(DELIMITER "\nDump structures:\n");
    Dmp.ShowAllStructures(2);
  }

  //
  // If the user wants the context, then show it.
  //

  if (Opts.ShowContextRecord) {
    printf(DELIMITER "\nContext Record:\n");
    Dmp.ShowContextRecord(2);
  }

  //
  // If the user wants the exception record, then show it.
  //

  if (Opts.ShowExceptionRecord) {
    printf(DELIMITER "\nException Record:\n");
    Dmp.ShowExceptionRecord(2);
  }

  //
  // If the user wants some physical memory, then show it.
  //

  if (Opts.ShowPhysicalMem) {
    printf(DELIMITER "\nPhysical memory:\n");

    //
    // If the user specified a physical address this is the one we
    // will dump.
    //

    if (Opts.PhysicalAddress) {

      //
      // Retrieve the page for the specified PhysicalAddress.
      // If it doesn't exist then display a message, else dump it on stdout.
      //

      const uint8_t *Page = Dmp.GetPhysicalPage(Opts.PhysicalAddress);
      if (Page == nullptr) {
        printf("0x%" PRIx64 " is not a valid physical address.\n",
               Opts.PhysicalAddress);
      } else {
        Hexdump(Opts.PhysicalAddress, Page, 0x1000);
      }
    } else {

      //
      // If the user didn't specify a physical address then dump the first
      // 16 bytes of every physical pages.
      //
      // Note that as the physmem is unordered, so we order the addresses here
      // so that it is nicer for the user as they probably don't expect unorder.
      //

      const auto &Physmem = Dmp.GetPhysmem();
      std::vector<kdmpparser::Physmem_t::key_type> OrderedPhysicalAddresses;
      OrderedPhysicalAddresses.reserve(Physmem.size());

      //
      // Stuff the physical addresses in a vector.
      //

      for (const auto &[PhysicalAddress, _] : Dmp.GetPhysmem()) {
        OrderedPhysicalAddresses.emplace_back(PhysicalAddress);
      }

      //
      // Sort them.
      //

      std::sort(OrderedPhysicalAddresses.begin(),
                OrderedPhysicalAddresses.end());

      //
      // And now we can iterate through them and get the page content.
      //

      for (const auto PhysicalAddress : OrderedPhysicalAddresses) {
        const uint8_t *Page = Dmp.GetPhysicalPage(PhysicalAddress);
        Hexdump(PhysicalAddress, Page, 16);
      }
    }
  }

  return EXIT_SUCCESS;
}
```

`src/python/CMakeLists.txt`:

```txt
#
# This file is part of kdmp-parser project
#
# Released under MIT License, by 0vercl0k - 2023
#
# With contributions from:
# * masthoon - (github.com/masthoon)
# * hugsy - (github.com/hugsy)
#
cmake_minimum_required(VERSION 3.20)

project(
    kdmp-parser-python
    DESCRIPTION "A Cross-Platform C++ parser library for Windows kernel minidumps."
    HOMEPAGE_URL https://github.com/0vercl0k/kdmp-parser
    VERSION 0.7.4
)
set(PROJECT_AUTHOR 0vercl0k)
set(PROJECT_LICENSE MIT)
set(CMAKE_CXX_STANDARD 20)

find_package(Python 3
    REQUIRED COMPONENTS Interpreter Development.Module
    OPTIONAL_COMPONENTS Development.SABIModule
)

if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the type of build." FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
endif()

set(KDMPPARSER_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/../..")
set(KDMPPARSER_INCLUDE_DIR "${KDMPPARSER_ROOT}/src/lib")
configure_file(${KDMPPARSER_INCLUDE_DIR}/kdmp-parser-version.h.in ${KDMPPARSER_INCLUDE_DIR}/kdmp-parser-version.h)

execute_process(
    COMMAND "${Python_EXECUTABLE}" -m nanobind --cmake_dir
    OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE NB_DIR)
list(APPEND CMAKE_PREFIX_PATH "${NB_DIR}")

find_package(nanobind CONFIG REQUIRED)

nanobind_add_module(_kdmp_parser STABLE_ABI src/kdmp_parser.cc)

if(BUILD_PYTHON_PACKAGE)
    #
    # Those directives are only used when creating a standalone `kdmp_parser` python package
    # Usual case is when build with `pip install src/python`
    #
    target_include_directories(_kdmp_parser PRIVATE ${KDMPPARSER_INCLUDE_DIR})
    install(DIRECTORY kdmp_parser DESTINATION .)
    install(TARGETS _kdmp_parser LIBRARY DESTINATION kdmp_parser)
else()
    #
    # This is the general case, when built from the root cmakefile
    #
    target_include_directories(_kdmp_parser PRIVATE $<TARGET_PROPERTY:kdmp-parser,INTERFACE_INCLUDE_DIRECTORIES>)
    install(TARGETS _kdmp_parser DESTINATION bindings/python)

    if(MSVC)
        install(FILES $<TARGET_PDB_FILE:_kdmp_parser> DESTINATION . OPTIONAL)
    endif(MSVC)
endif()

```

`src/python/README.md`:

```md
# Python building for `kdmp-parser`

![Build status](https://github.com/0vercl0k/kdmp-parser/workflows/Builds/badge.svg)

This C++ library parses Windows kernel [full](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/complete-memory-dump) dumps (`.dump /f` in WinDbg), [BMP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/active-memory-dump) dumps (`.dump /ka` in WinDbg) as well as more recent dump types that were introduced in ~2022.

![parser](https://github.com/0vercl0k/kdmp-parser/raw/master/pics/parser.jpg)

The library supports loading 64-bit dumps and provides read access to things like:

- The context record,
- The exception record,
- The bugcheck parameters,
- The physical memory.

The Python bindings were authored by [hugsy](https://github.com/hugsy) & [masthoon](https://github.com/masthoon). Refer to the [project page on Github](https://github.com/0vercl0k/kdmp-parser) for documentation, issues and pull requests.

## Installing from PyPI

The easiest way is simply to:

```bash
pip install kdmp_parser
```

## Installing using PIP

Run the following after installing [CMake](https://cmake.org/) and [Python](https://python.org/) 3.8+ / `pip`:
```
cd src/python
pip install requirements.txt
pip install .
```

To create a wheel pacakge:
```
cd src/python
pip wheel .
```

## Usage

### Get context, print the program counter

```python
import kdmp_parser
dmp = kdmp_parser.KernelDumpParser("full.dmp")
assert dmp.type == kdmp_parser.DumpType.FullDump
print(f"Dump RIP={dmp.context.Rip:#x}")
```

### Read a virtual memory page at address pointed by RIP

```python
import kdmp_parser
dmp = kdmp_parser.KernelDumpParser("full.dmp")
dmp.read_virtual_page(dmp.context.Rip)
```

### Explore the physical memory

```python
import kdmp_parser
dmp = kdmp_parser.KernelDumpParser("full.dmp")
pml4 = dmp.directory_table_base
print(f"{pml4=:#x}")
dmp.read_physical_page(pml4)
```

### Translate a virtual address into a physical address

```python
import kdmp_parser
dmp = kdmp_parser.KernelDumpParser("full.dmp")
VA = dmp.context.Rip
PA = dmp.translate_virtual(VA)
print(f"{VA=:#x} -> {PA=:#x}")
```

# Authors

* Axel '[@0vercl0k](https://twitter.com/0vercl0k)' Souchet

# Contributors

[ ![contributors-img](https://contrib.rocks/image?repo=0vercl0k/kdmp-parser) ](https://github.com/0vercl0k/kdmp-parser/graphs/contributors)

```

`src/python/kdmp_parser/__init__.py`:

```py
"""
Root module of `kdmp_parser` Python package.
"""

import enum
import pathlib
from typing import Optional, Union

#
# `_kdmp_parser` is the C++ module. It contains the port of all C++ classes/enums/etc. in their
# original form. The Python package part provides more Pythonic APIs.
#
from ._kdmp_parser import (  # type: ignore
    version,
    DumpType_t as _DumpType_t,
    KernelDumpParser as _KernelDumpParser,
    CONTEXT as __CONTEXT,
    HEADER64 as __HEADER64,
)

from .page import (
    PageIterator as _PageIterator,
)


class DumpType(enum.IntEnum):
    FullDump = _DumpType_t.FullDump.value
    KernelDump = _DumpType_t.KernelDump.value
    BMPDump = _DumpType_t.BMPDump.value
    LiveKernelBitmapDump = _DumpType_t.LiveKernelBitmapDump.value
    MiniDump = _DumpType_t.MiniDump.value
    KernelMemoryDump = _DumpType_t.KernelMemoryDump.value
    KernelAndUserMemoryDump = _DumpType_t.KernelAndUserMemoryDump.value
    CompleteMemoryDump = _DumpType_t.CompleteMemoryDump.value


class KernelDumpParser:
    def __init__(self, path: Union[str, pathlib.Path]):
        """Parse a kernel dump file

        Args:
            path (pathlib.Path|str): Path to the kernel dump file
        """
        if isinstance(path, str):
            path = pathlib.Path(path)

        if not isinstance(path, pathlib.Path):
            raise TypeError

        if not path.exists():
            raise ValueError

        self.__dump = _KernelDumpParser()
        if not self.__dump.Parse(str(path.absolute())):
            raise RuntimeError(f"Invalid kernel dump file: {path}")

        self.filepath = path
        self.context: __CONTEXT = self.__dump.GetContext()
        self.directory_table_base: int = self.__dump.GetDirectoryTableBase() & ~0xFFF
        self.type = DumpType(self.__dump.GetDumpType().value)
        self.header: __HEADER64 = self.__dump.GetDumpHeader()
        self.pages = _PageIterator(self.__dump)
        return

    def __repr__(self) -> str:
        return f"KernelDumpParser({self.filepath}, {self.type})"

    def read_physical_page(self, physical_address: int) -> Optional[bytearray]:
        """Read a physical page from the memory dump

        Args:
            physical_address (int): The physical address to read. Note that no alignment
            of this parameter is assumed.

        Returns:
            Optional[bytearray]: The bytes in the page if found, None otherwise
        """
        raw_page = self.__dump.GetPhysicalPage(physical_address)
        if not raw_page:
            return None

        return bytearray(raw_page)

    def read_virtual_page(
        self, virtual_address: int, directory_table_base: Optional[int] = 0
    ) -> Optional[bytearray]:
        """Read a virtual page from the memory dump

        Args:
            virtual_address (int): _description_
            directory_table_base (Optional[int]): if given, corresponds to the DirectoryTableBase value

        Returns:
            Optional[bytearray]: The bytes in the page if found, None otherwise
        """
        raw_page = self.__dump.GetVirtualPage(virtual_address, directory_table_base)
        if not raw_page:
            return None

        return bytearray(raw_page)

    def translate_virtual(
        self, virtual_address: int, directory_table_base: Optional[int] = 0
    ) -> Optional[int]:
        """Translate a virtual address to physical. A directory table base can be optionally
        provided

        Args:
            virtual_address (int): _description_
            directory_table_base (Optional[int]): if given, corresponds to the DirectoryTableBase
            value

        Returns:
            Optional[int]: If found, return the physical address to the virtual address. None
            otherwise
        """
        return self.__dump.VirtTranslate(virtual_address, directory_table_base)

```

`src/python/kdmp_parser/page.py`:

```py
from typing import Generator
from ._kdmp_parser import (  # type: ignore
    PageSize as size,
    PageAlign as align,
    PageOffset as offset,
    KernelDumpParser as _KernelDumpParser,
)

VALID_PAGE_SIZES = (0x1000, 0x20_0000, 0x4000_0000)


class PageIterator:
    """Access a dump pages"""

    def __init__(self, dump: _KernelDumpParser) -> None:
        self.__dump = dump

    def __getitem__(self, physical_address: int) -> bytearray:
        raw_page = self.__dump.GetPhysicalPage(physical_address)
        if not raw_page:
            raise IndexError
        return bytearray(raw_page)

    def __iter__(self) -> Generator[int, None, None]:
        return self.keys()

    def __contains__(self, addr: int) -> bool:
        return addr in self.keys()

    def __len__(self) -> int:
        return len(list(self.keys()))

    def keys(self) -> Generator[int, None, None]:
        for page_addr in self.__dump.GetPhysmem():
            yield page_addr

    def values(self) -> Generator[bytearray, None, None]:
        for page_addr in self.__dump.GetPhysmem():
            yield self[page_addr]

    def items(self) -> Generator["tuple[int, bytearray]", None, None]:
        for page_addr in self.__dump.GetPhysmem():
            yield page_addr, self[page_addr]

```

`src/python/pyproject.toml`:

```toml
[build-system]
requires = ["scikit-build-core >=0.4.3", "nanobind >=1.3.2"]
build-backend = "scikit_build_core.build"

[project]
name = "kdmp-parser"
version = "0.7.4"
description = "A Cross-Platform C++ parser library for Windows kernel minidumps."
readme = "README.md"
requires-python = ">=3.8"
authors = [{ name = "0vercl0k", email = "0vercl0k@not-your-biz.net" }]
classifiers = [
    "Development Status :: 4 - Beta",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Software Development :: Assemblers",
    "Natural Language :: English",
]
dependencies = []

[project.urls]
Homepage = "https://github.com/0vercl0k/kdmp-parser"

[tool.isort]
profile = "black"

[tool.scikit-build]
wheel.py-api = "cp312"
minimum-version = "0.4"
build-dir = "build/{wheel_tag}"
cmake.minimum-version = "3.20"
cmake.args = ["-DBUILD_PYTHON_PACKAGE:BOOL=ON"]

[tool.cibuildwheel]
build-verbosity = 1
test-command = "pytest -vvv {project}/src/python/tests"

[tool.cibuildwheel.macos.environment]
MACOSX_DEPLOYMENT_TARGET = "10.15"

```

`src/python/requirements.txt`:

```txt
setuptools
wheel
nanobind
black

```

`src/python/src/kdmp_parser.cc`:

```cc
//
// This file is part of kdmp-parser project
//
// Released under MIT License, by 0vercl0k - 2023
//
// With contributions from:
//  * hugsy - (github.com/hugsy)
//

#include "kdmp-parser.h"

#include <cstring>
#include <nanobind/nanobind.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/bind_map.h>
#include <nanobind/stl/filesystem.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/pair.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/unordered_map.h>
#include <nanobind/stl/variant.h>
#include <vector>

namespace nb = nanobind;
using namespace nb::literals;

NB_MODULE(_kdmp_parser, m) {

  m.doc() = "KDMP parser module";

  nb::class_<kdmpparser::Version_t>(m, "version")
      .def_ro_static("major", &kdmpparser::Version_t::Major)
      .def_ro_static("minor", &kdmpparser::Version_t::Minor)
      .def_ro_static("patch", &kdmpparser::Version_t::Patch)
      .def_ro_static("release", &kdmpparser::Version_t::Release);

  nb::class_<kdmpparser::uint128_t>(m, "uint128_t")
      .def(nb::init<>())
      .def_rw("Low", &kdmpparser::uint128_t::Low)
      .def_rw("High", &kdmpparser::uint128_t::High);

  nb::enum_<kdmpparser::DumpType_t>(m, "DumpType_t")
      .value("FullDump", kdmpparser::DumpType_t::FullDump)
      .value("KernelDump", kdmpparser::DumpType_t::KernelDump)
      .value("BMPDump", kdmpparser::DumpType_t::BMPDump)
      .value("LiveKernelBitmapDump",
             kdmpparser::DumpType_t::LiveKernelBitmapDump)
      .value("MiniDump", kdmpparser::DumpType_t::MiniDump)
      .value("KernelMemoryDump", kdmpparser::DumpType_t::KernelMemoryDump)
      .value("KernelAndUserMemoryDump",
             kdmpparser::DumpType_t::KernelAndUserMemoryDump)
      .value("CompleteMemoryDump", kdmpparser::DumpType_t::CompleteMemoryDump)
      .export_values();

  nb::class_<kdmpparser::PHYSMEM_RUN>(m, "PHYSMEM_RUN")
      .def(nb::init<>())
      .def_rw("BasePage", &kdmpparser::PHYSMEM_RUN::BasePage)
      .def_rw("PageCount", &kdmpparser::PHYSMEM_RUN::PageCount)
      .def("Show", &kdmpparser::PHYSMEM_RUN::Show, "Prefix"_a);

  nb::class_<kdmpparser::PHYSMEM_DESC>(m, "PHYSMEM_DESC")
      .def(nb::init<>())
      .def_ro("NumberOfRuns", &kdmpparser::PHYSMEM_DESC::NumberOfRuns)
      .def_ro("Padding0", &kdmpparser::PHYSMEM_DESC::Padding0)
      .def_ro("NumberOfPages", &kdmpparser::PHYSMEM_DESC::NumberOfPages)
      .def_ro("Run", &kdmpparser::PHYSMEM_DESC::Run)
      .def("Show", &kdmpparser::PHYSMEM_DESC::Show, "Prefix"_a)
      .def("LooksGood", &kdmpparser::PHYSMEM_DESC::LooksGood);

  nb::class_<kdmpparser::BMP_HEADER64>(m, "BMP_HEADER64")
      .def(nb::init<>())
      .def_ro_static("ExpectedSignature",
                     &kdmpparser::BMP_HEADER64::ExpectedSignature)
      .def_ro_static("ExpectedSignature2",
                     &kdmpparser::BMP_HEADER64::ExpectedSignature2)
      .def_ro_static("ExpectedValidDump",
                     &kdmpparser::BMP_HEADER64::ExpectedValidDump)
      .def_ro("Signature", &kdmpparser::BMP_HEADER64::Signature)
      .def_ro("ValidDump", &kdmpparser::BMP_HEADER64::ValidDump)
      .def_ro("Padding0", &kdmpparser::BMP_HEADER64::Padding0)
      .def_ro("FirstPage", &kdmpparser::BMP_HEADER64::FirstPage)
      .def_ro("TotalPresentPages", &kdmpparser::BMP_HEADER64::TotalPresentPages)
      .def_ro("Pages", &kdmpparser::BMP_HEADER64::Pages)
      .def_ro("Bitmap", &kdmpparser::BMP_HEADER64::Bitmap)
      .def("Show", &kdmpparser::BMP_HEADER64::Show, "Prefix"_a)
      .def("LooksGood", &kdmpparser::BMP_HEADER64::LooksGood);

  nb::class_<kdmpparser::RDMP_HEADER64>(m, "RDMP_HEADER64")
      .def(nb::init<>())
      .def_ro_static("ExpectedMarker",
                     &kdmpparser::RDMP_HEADER64::ExpectedMarker)
      .def_ro_static("ExpectedSignature",
                     &kdmpparser::RDMP_HEADER64::ExpectedSignature)
      .def_ro_static("ExpectedValidDump",
                     &kdmpparser::RDMP_HEADER64::ExpectedValidDump)
      .def_ro("Marker", &kdmpparser::RDMP_HEADER64::Marker)
      .def_ro("Signature", &kdmpparser::RDMP_HEADER64::Signature)
      .def_ro("ValidDump", &kdmpparser::RDMP_HEADER64::ValidDump)
      .def_ro("MetadataSize", &kdmpparser::RDMP_HEADER64::MetadataSize)
      .def_ro("FirstPageOffset", &kdmpparser::RDMP_HEADER64::FirstPageOffset)
      .def("LooksGood", &kdmpparser::RDMP_HEADER64::LooksGood)
      .def("Show", &kdmpparser::RDMP_HEADER64::Show);

  nb::class_<kdmpparser::KERNEL_RDMP_HEADER64>(m, "KERNEL_RDMP_HEADER64")
      .def(nb::init<>());

  nb::class_<kdmpparser::FULL_RDMP_HEADER64>(m, "FULL_RDMP_HEADER64")
      .def(nb::init<>());

  using CONTEXT = kdmpparser::CONTEXT;
  nb::class_<CONTEXT>(m, "CONTEXT")
      .def(nb::init<>())
      .def_ro("P1Home", &CONTEXT::P1Home)
      .def_ro("P2Home", &CONTEXT::P2Home)
      .def_ro("P3Home", &CONTEXT::P3Home)
      .def_ro("P4Home", &CONTEXT::P4Home)
      .def_ro("P5Home", &CONTEXT::P5Home)
      .def_ro("P6Home", &CONTEXT::P6Home)
      .def_ro("ContextFlags", &CONTEXT::ContextFlags)
      .def_ro("MxCsr", &CONTEXT::MxCsr)
      .def_ro("SegCs", &CONTEXT::SegCs)
      .def_ro("SegDs", &CONTEXT::SegDs)
      .def_ro("SegEs", &CONTEXT::SegEs)
      .def_ro("SegFs", &CONTEXT::SegFs)
      .def_ro("SegGs", &CONTEXT::SegGs)
      .def_ro("SegSs", &CONTEXT::SegSs)
      .def_ro("EFlags", &CONTEXT::EFlags)
      .def_ro("Dr0", &CONTEXT::Dr0)
      .def_ro("Dr1", &CONTEXT::Dr1)
      .def_ro("Dr2", &CONTEXT::Dr2)
      .def_ro("Dr3", &CONTEXT::Dr3)
      .def_ro("Dr6", &CONTEXT::Dr6)
      .def_ro("Dr7", &CONTEXT::Dr7)
      .def_ro("Rax", &CONTEXT::Rax)
      .def_ro("Rcx", &CONTEXT::Rcx)
      .def_ro("Rdx", &CONTEXT::Rdx)
      .def_ro("Rbx", &CONTEXT::Rbx)
      .def_ro("Rsp", &CONTEXT::Rsp)
      .def_ro("Rbp", &CONTEXT::Rbp)
      .def_ro("Rsi", &CONTEXT::Rsi)
      .def_ro("Rdi", &CONTEXT::Rdi)
      .def_ro("R8", &CONTEXT::R8)
      .def_ro("R9", &CONTEXT::R9)
      .def_ro("R10", &CONTEXT::R10)
      .def_ro("R11", &CONTEXT::R11)
      .def_ro("R12", &CONTEXT::R12)
      .def_ro("R13", &CONTEXT::R13)
      .def_ro("R14", &CONTEXT::R14)
      .def_ro("R15", &CONTEXT::R15)
      .def_ro("Rip", &CONTEXT::Rip)
      .def_ro("ControlWord", &CONTEXT::ControlWord)
      .def_ro("StatusWord", &CONTEXT::StatusWord)
      .def_ro("TagWord", &CONTEXT::TagWord)
      .def_ro("Reserved1", &CONTEXT::Reserved1)
      .def_ro("ErrorOpcode", &CONTEXT::ErrorOpcode)
      .def_ro("ErrorOffset", &CONTEXT::ErrorOffset)
      .def_ro("ErrorSelector", &CONTEXT::ErrorSelector)
      .def_ro("Reserved2", &CONTEXT::Reserved2)
      .def_ro("DataOffset", &CONTEXT::DataOffset)
      .def_ro("DataSelector", &CONTEXT::DataSelector)
      .def_ro("Reserved3", &CONTEXT::Reserved3)
      .def_ro("MxCsr2", &CONTEXT::MxCsr2)
      .def_ro("MxCsr_Mask", &CONTEXT::MxCsr_Mask)
      .def_ro("FloatRegisters", &CONTEXT::FloatRegisters)
      .def_ro("Xmm0", &CONTEXT::Xmm0)
      .def_ro("Xmm1", &CONTEXT::Xmm1)
      .def_ro("Xmm2", &CONTEXT::Xmm2)
      .def_ro("Xmm3", &CONTEXT::Xmm3)
      .def_ro("Xmm4", &CONTEXT::Xmm4)
      .def_ro("Xmm5", &CONTEXT::Xmm5)
      .def_ro("Xmm6", &CONTEXT::Xmm6)
      .def_ro("Xmm7", &CONTEXT::Xmm7)
      .def_ro("Xmm8", &CONTEXT::Xmm8)
      .def_ro("Xmm9", &CONTEXT::Xmm9)
      .def_ro("Xmm10", &CONTEXT::Xmm10)
      .def_ro("Xmm11", &CONTEXT::Xmm11)
      .def_ro("Xmm12", &CONTEXT::Xmm12)
      .def_ro("Xmm13", &CONTEXT::Xmm13)
      .def_ro("Xmm14", &CONTEXT::Xmm14)
      .def_ro("Xmm15", &CONTEXT::Xmm15)
      .def_ro("VectorRegister", &CONTEXT::VectorRegister)
      .def_ro("VectorControl", &CONTEXT::VectorControl)
      .def_ro("DebugControl", &CONTEXT::DebugControl)
      .def_ro("LastBranchToRip", &CONTEXT::LastBranchToRip)
      .def_ro("LastBranchFromRip", &CONTEXT::LastBranchFromRip)
      .def_ro("LastExceptionToRip", &CONTEXT::LastExceptionToRip)
      .def_ro("LastExceptionFromRip", &CONTEXT::LastExceptionFromRip)
      .def("Show", &CONTEXT::Show, "Prefix"_a)
      .def("LooksGood", &CONTEXT::LooksGood);

  using EXCEPTION_RECORD64 = kdmpparser::EXCEPTION_RECORD64;
  nb::class_<EXCEPTION_RECORD64>(m, "EXCEPTION_RECORD64")
      .def(nb::init<>())
      .def_ro("ExceptionCode", &EXCEPTION_RECORD64::ExceptionCode)
      .def_ro("ExceptionFlags", &EXCEPTION_RECORD64::ExceptionFlags)
      .def_ro("ExceptionRecord", &EXCEPTION_RECORD64::ExceptionRecord)
      .def_ro("ExceptionAddress", &EXCEPTION_RECORD64::ExceptionAddress)
      .def_ro("NumberParameters", &EXCEPTION_RECORD64::NumberParameters)
      .def_ro("__unusedAlignment", &EXCEPTION_RECORD64::__unusedAlignment)
      .def_ro("ExceptionInformation", &EXCEPTION_RECORD64::ExceptionInformation)
      .def("Show", &EXCEPTION_RECORD64::Show, "Prefix"_a);

  using HEADER64 = kdmpparser::HEADER64;
  nb::class_<HEADER64>(m, "HEADER64")
      .def(nb::init<>())
      .def_ro_static("ExpectedSignature", &HEADER64::ExpectedSignature)
      .def_ro_static("ExpectedValidDump", &HEADER64::ExpectedValidDump)
      .def_ro("Signature", &HEADER64::Signature)
      .def_ro("ValidDump", &HEADER64::ValidDump)
      .def_ro("MajorVersion", &HEADER64::MajorVersion)
      .def_ro("MinorVersion", &HEADER64::MinorVersion)
      .def_ro("DirectoryTableBase", &HEADER64::DirectoryTableBase)
      .def_ro("PfnDatabase", &HEADER64::PfnDatabase)
      .def_ro("PsLoadedModuleList", &HEADER64::PsLoadedModuleList)
      .def_ro("PsActiveProcessHead", &HEADER64::PsActiveProcessHead)
      .def_ro("MachineImageType", &HEADER64::MachineImageType)
      .def_ro("NumberProcessors", &HEADER64::NumberProcessors)
      .def_ro("BugCheckCode", &HEADER64::BugCheckCode)
      .def_ro("BugCheckCodeParameter", &HEADER64::BugCheckCodeParameters)
      .def_ro("KdDebuggerDataBlock", &HEADER64::KdDebuggerDataBlock)
      .def_prop_ro("PhysicalMemoryBlock",
                   [](const HEADER64 &Hdr) -> kdmpparser::PHYSMEM_DESC {
                     return Hdr.u1.PhysicalMemoryBlock;
                   })
      .def_prop_ro("ContextRecord",
                   [](const HEADER64 &Hdr) { return Hdr.u2.ContextRecord; })
      .def_ro("Exception", &HEADER64::Exception)
      .def_ro("DumpType", &HEADER64::DumpType)
      .def_ro("RequiredDumpSpace", &HEADER64::RequiredDumpSpace)
      .def_ro("SystemTime", &HEADER64::SystemTime)
      .def_ro("Comment", &HEADER64::Comment)
      .def_ro("SystemUpTime", &HEADER64::SystemUpTime)
      .def_ro("MiniDumpFields", &HEADER64::MiniDumpFields)
      .def_ro("SecondaryDataState", &HEADER64::SecondaryDataState)
      .def_ro("ProductType", &HEADER64::ProductType)
      .def_ro("SuiteMask", &HEADER64::SuiteMask)
      .def_ro("WriterStatus", &HEADER64::WriterStatus)
      .def_ro("KdSecondaryVersion", &HEADER64::KdSecondaryVersion)
      .def_ro("Attributes", &HEADER64::Attributes)
      .def_ro("BootId", &HEADER64::BootId)
      .def_prop_ro(
          "BmpHeader",
          [](const HEADER64 &Hdr) -> std::optional<kdmpparser::BMP_HEADER64> {
            if (Hdr.DumpType != kdmpparser::DumpType_t::BMPDump) {
              return {};
            }

            return Hdr.u3.BmpHeader;
          })
      .def_prop_ro("RdmpHeader",
                   [](const HEADER64 &Hdr)
                       -> std::optional<kdmpparser::KERNEL_RDMP_HEADER64> {
                     if (Hdr.DumpType !=
                             kdmpparser::DumpType_t::KernelAndUserMemoryDump &&
                         Hdr.DumpType !=
                             kdmpparser::DumpType_t::KernelMemoryDump) {
                       return {};
                     }

                     return Hdr.u3.RdmpHeader;
                   })
      .def_prop_ro("FullRdmpHeader",
                   [](const HEADER64 &Hdr)
                       -> std::optional<kdmpparser::FULL_RDMP_HEADER64> {
                     if (Hdr.DumpType !=
                         kdmpparser::DumpType_t::CompleteMemoryDump) {
                       return {};
                     }

                     return Hdr.u3.FullRdmpHeader;
                   })
      .def("Show", &HEADER64::Show, "Prefix"_a)
      .def("LooksGood", &HEADER64::LooksGood);

  m.attr("PageSize") = kdmpparser::Page::Size;
  m.def("PageAlign", &kdmpparser::Page::Align, "Address"_a,
        "Get the aligned value on the page for the given address.");
  m.def("PageOffset", &kdmpparser::Page::Offset, "Address"_a,
        "Get the offset to the page for the given address.");

  using BugCheckParameters_t = kdmpparser::BugCheckParameters_t;
  nb::class_<BugCheckParameters_t>(m, "BugCheckParameters_t")
      .def(nb::init<>())
      .def_ro("BugCheckCode", &BugCheckParameters_t::BugCheckCode)
      .def_ro("BugCheckCodeParameter",
              &BugCheckParameters_t::BugCheckCodeParameter);

  using KernelDumpParser = kdmpparser::KernelDumpParser;
  nb::class_<KernelDumpParser>(m, "KernelDumpParser")
      .def(nb::init<>())
      .def("Parse", &KernelDumpParser::Parse, "PathFile"_a)
      .def("GetContext", &KernelDumpParser::GetContext)
      .def("GetDumpHeader", &KernelDumpParser::GetDumpHeader,
           nb::rv_policy::reference)
      .def("GetBugCheckParameters", &KernelDumpParser::GetBugCheckParameters)
      .def("GetDumpType", &KernelDumpParser::GetDumpType)
      .def("GetPhysmem",
           [](const KernelDumpParser &Parser) {
             const auto &PhysMem = Parser.GetPhysmem();
             return nb::make_key_iterator(nb::type<std::vector<uint64_t>>(),
                                          "it", PhysMem.cbegin(),
                                          PhysMem.cend());
           })
      .def("ShowExceptionRecord", &KernelDumpParser::ShowExceptionRecord,
           "Prefix"_a = 0)
      .def("ShowContextRecord", &KernelDumpParser::ShowContextRecord,
           "Prefix"_a = 0)
      .def("ShowAllStructures", &KernelDumpParser::ShowAllStructures,
           "Prefix"_a = 0)
      .def(
          "GetPhysicalPage",
          [](const KernelDumpParser &Parser, const uint64_t PhysicalAddress)
              -> std::optional<kdmpparser::Page_t> {
            const auto *Page = Parser.GetPhysicalPage(PhysicalAddress);
            if (!Page) {
              return std::nullopt;
            }

            kdmpparser::Page_t Out;
            memcpy(Out.data(), Page, kdmpparser::Page::Size);
            return Out;
          },
          "PhysicalAddress"_a)
      .def("GetDirectoryTableBase", &KernelDumpParser::GetDirectoryTableBase)
      .def("VirtTranslate", &KernelDumpParser::VirtTranslate,
           "VirtualAddress"_a, "DirectoryTableBase"_a)
      .def(
          "GetVirtualPage",
          [](const KernelDumpParser &Parser, const uint64_t VirtualAddress,
             const uint64_t DirectoryTableBase =
                 0) -> std::optional<kdmpparser::Page_t> {
            const auto *Page =
                Parser.GetVirtualPage(VirtualAddress, DirectoryTableBase);
            if (!Page) {
              return std::nullopt;
            }

            kdmpparser::Page_t Out;
            memcpy(Out.data(), Page, kdmpparser::Page::Size);
            return Out;
          },
          "VirtualAddress"_a, "DirectoryTableBase"_a = 0);
}

```

`src/python/tests/pytest.ini`:

```ini
[pytest]
log_level = INFO
minversion = 6.0
required_plugins =
    pytest-xdist
    pytest-cov
python_functions =
    test_*
    time_*
python_files = *.py
testpaths =
    .
markers =
    slow: flag test as slow (deselect with '-m "not slow"')
    online: flag test as requiring internet to work (deselect with '-m "not online"')

```

`src/python/tests/requirements.txt`:

```txt
pytest
pytest-cov
pytest-xdist
pytest-forked

```

`src/python/tests/test_page.py`:

```py
#
# This file is part of kdmp-parser project
#
# Released under MIT License, by 0vercl0k - 2023
#
# With contributions from:
# * masthoon - (github.com/masthoon)
# * hugsy - (github.com/hugsy)
#
import kdmp_parser.page


def test_page():
    assert callable(kdmp_parser.page.align)
    assert callable(kdmp_parser.page.offset)
    assert isinstance(kdmp_parser.page.size, int)
    assert kdmp_parser.page.size in kdmp_parser.page.VALID_PAGE_SIZES

```

`src/python/tests/test_parser.py`:

```py
#
# This file is part of kdmp-parser project
#
# Released under MIT License, by 0vercl0k - 2023
#
# With contributions from:
# * masthoon - (github.com/masthoon)
# * hugsy - (github.com/hugsy)
#

import pathlib
import unittest
import kdmp_parser

REPO_ROOT = pathlib.Path(__file__).absolute().parent.parent.parent.parent

class TestParserBasic(unittest.TestCase):
    def setUp(self):
        self.minidump_files: list[pathlib.Path] = [
            REPO_ROOT / "bmp.dmp",
            REPO_ROOT / "full.dmp",
        ]

        return super().setUp()

    def tearDown(self) -> None:
        return super().tearDown()

    def test_parser_context(self):
        expected_values = {
            "bmp.dmp": {
                "rip": 0xFFFFF805108776A0,
                "rbp": 0xFFFFF80513568600,
                "rsp": 0xFFFFF805135684F8,
                "rax": 0x3,
                "rbx": 0xFFFFF8050F4E9F70,
                "rcx": 0x1,
                "rdx": 0xFFFFF805135684D0,
                "r8": 0x3,
                "r9": 0xFFFFF805135684B8,
                "r10": 0x0,
                "r11": 0xFFFFA8848825E000,
                "r12": 0xFFFFF8050F4E9F80,
                "r13": 0xFFFFF80510C3C958,
                "r14": 0x0,
                "r15": 0x52,
                "dtd": 0x6D4000,
            },
            "full.dmp": {
                "rip": 0xFFFFF805108776A0,
                "rbp": 0xFFFFF80513568600,
                "rsp": 0xFFFFF805135684F8,
                "rax": 0x3,
                "rbx": 0xFFFFF8050F4E9F70,
                "rcx": 0x1,
                "rdx": 0xFFFFF805135684D0,
                "r8": 0x3,
                "r9": 0xFFFFF805135684B8,
                "r10": 0x0,
                "r11": 0xFFFFA8848825E000,
                "r12": 0xFFFFF8050F4E9F80,
                "r13": 0xFFFFF80510C3C958,
                "r14": 0x0,
                "r15": 0x52,
                "dtd": 0x6D4000,
            },
        }

        for md in self.minidump_files:
            parser = kdmp_parser.KernelDumpParser(md)
            assert parser.filepath == md

            values = expected_values[md.name]
            assert parser.context is not None
            assert parser.context.Rip == values["rip"]
            assert parser.context.Rbp == values["rbp"]
            assert parser.context.Rsp == values["rsp"]
            assert parser.context.Rax == values["rax"]
            assert parser.context.Rbx == values["rbx"]
            assert parser.context.Rcx == values["rcx"]
            assert parser.context.Rdx == values["rdx"]
            assert parser.context.R8 == values["r8"]
            assert parser.context.R9 == values["r9"]
            assert parser.context.R10 == values["r10"]
            assert parser.context.R11 == values["r11"]
            assert parser.context.R12 == values["r12"]
            assert parser.context.R13 == values["r13"]
            assert parser.context.R14 == values["r14"]
            assert parser.context.R15 == values["r15"]

            assert parser.directory_table_base == values["dtd"]

    def test_parser_memory(self):
        parser = kdmp_parser.KernelDumpParser(self.minidump_files[0])
        assert parser.directory_table_base == 0x6D4000

        page = parser.read_physical_page(0x5000)
        assert page is not None
        assert page[0x34:0x38] == b"MSFT"

        assert parser.translate_virtual(0xFFFFF78000000000) == 0x0000000000C2F000
        assert parser.translate_virtual(0xFFFFF80513370000) == 0x000000003D555000

        assert parser.read_virtual_page(
            0xFFFFF78000000000
        ) == parser.read_physical_page(0x0000000000C2F000)
        assert parser.read_virtual_page(
            0xFFFFF80513370000
        ) == parser.read_physical_page(0x000000003D555000)

    def test_parser_page_iterator(self):
        parser = kdmp_parser.KernelDumpParser(self.minidump_files[0])

        page_addresses = list(parser.pages.keys())
        page_values = list(parser.pages.values())

        assert len(parser.pages) > 0
        assert len(page_addresses) == len(parser.pages)
        assert len(page_addresses) == len(page_values)

        addr = page_addresses[0]
        page = parser.pages[addr]
        assert parser.read_physical_page(addr) == page

        for addr, page in parser.pages.items():
            assert addr in page_addresses
            assert page in page_values
            assert len(page) == kdmp_parser.page.size
            assert parser.read_physical_page(addr) == page

```

`src/python/tests/test_version.py`:

```py
#
# This file is part of kdmp-parser project
#
# Released under MIT License, by 0vercl0k - 2023
#
# With contributions from:
# * masthoon - (github.com/masthoon)
# * hugsy - (github.com/hugsy)
#
import kdmp_parser


def test_version():
    assert isinstance(kdmp_parser.version.major, int)
    assert isinstance(kdmp_parser.version.minor, int)
    assert isinstance(kdmp_parser.version.patch, int)
    assert isinstance(kdmp_parser.version.release, str)

```

`src/tests/CMakeLists.txt`:

```txt
# Axel '0vercl0k' Souchet - April 18 2020
enable_testing()

#
# Build and link Catch2 library dependency automatically if not already found
#
include(FetchContent)
FetchContent_Declare(
    Catch2
    URL https://github.com/catchorg/Catch2/archive/refs/tags/v3.4.0.zip
    URL_HASH MD5=c426e77d4ee0055410bc930182959ae5
)
FetchContent_MakeAvailable(Catch2)

#
# Build all test files
#
list(APPEND TEST_SOURCE_FILES
    tests_version.cc
    tests_parser.cc
)

foreach(SOURCE_FILE ${TEST_SOURCE_FILES})
    cmake_path(GET SOURCE_FILE STEM TEST_EXECUTABLE_NAME)
    add_executable(${TEST_EXECUTABLE_NAME} ${SOURCE_FILE})
    target_link_libraries(${TEST_EXECUTABLE_NAME} PUBLIC kdmp-parser Catch2::Catch2WithMain)
    add_test(NAME ${TEST_EXECUTABLE_NAME} COMMAND $<TARGET_FILE:${TEST_EXECUTABLE_NAME}>)
    install(FILES $<TARGET_FILE:${TEST_EXECUTABLE_NAME}> DESTINATION tests)
endforeach()

```

`src/tests/tests_parser.cc`:

```cc
// Axel '0vercl0k' Souchet - 2023
#define CATCH_CONFIG_MAIN

#include "kdmp-parser.h"
#include <array>
#include <catch2/catch_test_macros.hpp>
#include <cstdint>
#include <cstring>
#include <filesystem>
#include <unordered_map>

struct TestCaseValues {
  std::string_view File;
  kdmpparser::DumpType_t Type;
  uint64_t Size = 0;
  uint64_t ReadAddress = 0;
  std::array<uint8_t, 16> Bytes;
  uint64_t Rax = 0;
  uint64_t Rbx = 0;
  uint64_t Rcx = 0;
  uint64_t Rdx = 0;
  uint64_t Rsi = 0;
  uint64_t Rdi = 0;
  uint64_t Rip = 0;
  uint64_t Rsp = 0;
  uint64_t Rbp = 0;
  uint64_t R8 = 0;
  uint64_t R9 = 0;
  uint64_t R10 = 0;
  uint64_t R11 = 0;
  uint64_t R12 = 0;
  uint64_t R13 = 0;
  uint64_t R14 = 0;
  uint64_t R15 = 0;
};

constexpr TestCaseValues TestCaseBmp{
    //
    // kd> r
    // rax=0000000000000003 rbx=fffff8050f4e9f70 rcx=0000000000000001
    // rdx=fffff805135684d0 rsi=0000000000000100 rdi=fffff8050f4e9f80
    // rip=fffff805108776a0 rsp=fffff805135684f8 rbp=fffff80513568600
    // r8=0000000000000003  r9=fffff805135684b8 r10=0000000000000000
    // r11=ffffa8848825e000 r12=fffff8050f4e9f80 r13=fffff80510c3c958
    // r14=0000000000000000 r15=0000000000000052
    // iopl=0         nv up ei pl nz na pe nc
    // cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b efl=00040202
    //
    "bmp.dmp",
    kdmpparser::DumpType_t::BMPDump,
    0x54'4b,
    0x6d'4d'22,
    {0x6d, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x63, 0x88, 0x75, 0x00, 0x00, 0x00,
     0x00, 0x0a, 0x63, 0x98},
    0x00000000'00000003ULL,
    0xfffff805'0f4e9f70ULL,
    0x00000000'00000001ULL,
    0xfffff805'135684d0ULL,
    0x00000000'00000100ULL,
    0xfffff805'0f4e9f80ULL,
    0xfffff805'108776a0ULL,
    0xfffff805'135684f8ULL,
    0xfffff805'13568600ULL,
    0x00000000'00000003ULL,
    0xfffff805'135684b8ULL,
    0x00000000'00000000ULL,
    0xffffa884'8825e000ULL,
    0xfffff805'0f4e9f80ULL,
    0xfffff805'10c3c958ULL,
    0x00000000'00000000ULL,
    0x00000000'00000052ULL,
};

constexpr TestCaseValues TestCaseFull{
    "full.dmp",
    kdmpparser::DumpType_t::FullDump,
    0x03'fb'e6,
    0x6d'4d'22,
    {0x6d, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x63, 0x88, 0x75, 0x00, 0x00, 0x00,
     0x00, 0x0a, 0x63, 0x98},
    0x00000000'00000003ULL,
    0xfffff805'0f4e9f70ULL,
    0x00000000'00000001ULL,
    0xfffff805'135684d0ULL,
    0x00000000'00000100ULL,
    0xfffff805'0f4e9f80ULL,
    0xfffff805'108776a0ULL,
    0xfffff805'135684f8ULL,
    0xfffff805'13568600ULL,
    0x00000000'00000003ULL,
    0xfffff805'135684b8ULL,
    0x00000000'00000000ULL,
    0xffffa884'8825e000ULL,
    0xfffff805'0f4e9f80ULL,
    0xfffff805'10c3c958ULL,
    0x00000000'00000000ULL,
    0x00000000'00000052ULL,
};

constexpr TestCaseValues TestCaseKernelDump{
    "kerneldump.dmp",
    kdmpparser::DumpType_t::KernelMemoryDump,
    0xa0'2e,
    0x02'58'92'f0,
    {0x10, 0x8c, 0x24, 0x50, 0x0c, 0xc0, 0xff, 0xff, 0xa0, 0x19, 0x38, 0x51,
     0x0c, 0xc0, 0xff, 0xff},
    0x00000000'00007a01ULL,
    0xffffc00c'5191e010ULL,
    0x00000000'00000001ULL,
    0x00000012'00000000ULL,
    0xffffc00c'51907bb0ULL,
    0x00000000'00000002ULL,
    0xfffff803'f2c35470ULL,
    0xfffff803'f515ec28ULL,
    0x00000000'0c1c9800ULL,
    0x00000000'000000b0ULL,
    0xffffc00c'502ff000ULL,
    0x00000000'00000057ULL,
    0xfffff803'f3a04500ULL,
    0xfffff803'f515ee60ULL,
    0x00000000'00000003ULL,
    0xfffff803'f1e9a180ULL,
    0x00000000'0000001fULL,
};

constexpr TestCaseValues TestCaseKernelUserDump{
    "kerneluserdump.dmp",
    kdmpparser::DumpType_t::KernelAndUserMemoryDump,
    0x01'f7'c7,
    0x02'58'92'f0,
    {0x10, 0x8c, 0x24, 0x50, 0x0c, 0xc0, 0xff, 0xff, 0xa0, 0x19, 0x38, 0x51,
     0x0c, 0xc0, 0xff, 0xff},
    0x00000000'00007a01ULL,
    0xffffc00c'5191e010ULL,
    0x00000000'00000001ULL,
    0x00000012'00000000ULL,
    0xffffc00c'51907bb0ULL,
    0x00000000'00000002ULL,
    0xfffff803'f2c35470ULL,
    0xfffff803'f515ec28ULL,
    0x00000000'0c1c9800ULL,
    0x00000000'000000b0ULL,
    0xffffc00c'502ff000ULL,
    0x00000000'00000057ULL,
    0xfffff803'f3a04500ULL,
    0xfffff803'f515ee60ULL,
    0x00000000'00000003ULL,
    0xfffff803'f1e9a180ULL,
    0x00000000'0000001fULL,
};

constexpr TestCaseValues TestCaseCompleteDump{
    "completedump.dmp",
    kdmpparser::DumpType_t::CompleteMemoryDump,
    0x01'fb'f9,
    0x02'58'92'f0,
    {0x10, 0x8c, 0x24, 0x50, 0x0c, 0xc0, 0xff, 0xff, 0xa0, 0x19, 0x38, 0x51,
     0x0c, 0xc0, 0xff, 0xff},
    0x00000000'00007a01ULL,
    0xffffc00c'5191e010ULL,
    0x00000000'00000001ULL,
    0x00000012'00000000ULL,
    0xffffc00c'51907bb0ULL,
    0x00000000'00000002ULL,
    0xfffff803'f2c35470ULL,
    0xfffff803'f515ec28ULL,
    0x00000000'0c1c9800ULL,
    0x00000000'000000b0ULL,
    0xffffc00c'502ff000ULL,
    0x00000000'00000057ULL,
    0xfffff803'f3a04500ULL,
    0xfffff803'f515ee60ULL,
    0x00000000'00000003ULL,
    0xfffff803'f1e9a180ULL,
    0x00000000'0000001fULL,
};

constexpr TestCaseValues TestLiveKernelBitmapDump{
    "fulllivekernelmemory.dmp",
    kdmpparser::DumpType_t::LiveKernelBitmapDump,
    0x154f5,
    0x0000000d96a9000, // cr3
    {0x67, 0xd8, 0xb6, 0xdd, 0x00, 0x00, 0x00, 0x0a, 0x67, 0xa8, 0x1d, 0xd6,
     0x00, 0x00, 0x00, 0x0a},
    0x4ULL,
    0xffffd20fd8553000ULL,
    0xffffa1000ed84a00ULL,
    0x0ULL,
    0xffffd20fd3beeae0ULL,
    0xfffff8074fb4b180ULL,
    0xfffff80750a98b6dULL,
    0xfffffd8d6bcaed10ULL,
    0x0ULL,
    0xb80ULL,
    0xffffd20fd8553348ULL,
    0x0ULL,
    0xffffd20fd8553000ULL,
    0x2ULL,
    0x0ULL,
    0xffffd20fd48d5080ULL,
    0x1ULL,
};

constexpr std::array Testcases{
    TestCaseBmp,          TestCaseFull,
    TestCaseKernelDump,   TestCaseKernelUserDump,
    TestCaseCompleteDump, TestLiveKernelBitmapDump,
};

TEST_CASE("kdmp-parser", "parser") {
  SECTION("Test minidump exists") {
    for (const auto &Testcase : Testcases) {
      REQUIRE(std::filesystem::exists(Testcase.File));
    }
  }

  SECTION("Basic parsing") {
    for (const auto &Testcase : Testcases) {
      kdmpparser::KernelDumpParser Dmp;
      REQUIRE(Dmp.Parse(Testcase.File.data()));
      CHECK(Dmp.GetDumpType() == Testcase.Type);
      const auto &Physmem = Dmp.GetPhysmem();
      CHECK(Physmem.size() == Testcase.Size);
    }
  }

  SECTION("Context values") {
    for (const auto &Testcase : Testcases) {
      kdmpparser::KernelDumpParser Dmp;
      REQUIRE(Dmp.Parse(Testcase.File.data()));
      const auto &Context = Dmp.GetContext();
      CHECK(Context.Rax == Testcase.Rax);
      CHECK(Context.Rbx == Testcase.Rbx);
      CHECK(Context.Rcx == Testcase.Rcx);
      CHECK(Context.Rdx == Testcase.Rdx);
      CHECK(Context.Rsi == Testcase.Rsi);
      CHECK(Context.Rdi == Testcase.Rdi);
      CHECK(Context.Rip == Testcase.Rip);
      CHECK(Context.Rsp == Testcase.Rsp);
      CHECK(Context.Rbp == Testcase.Rbp);
      CHECK(Context.R8 == Testcase.R8);
      CHECK(Context.R9 == Testcase.R9);
      CHECK(Context.R10 == Testcase.R10);
      CHECK(Context.R11 == Testcase.R11);
      CHECK(Context.R12 == Testcase.R12);
      CHECK(Context.R13 == Testcase.R13);
      CHECK(Context.R14 == Testcase.R14);
      CHECK(Context.R15 == Testcase.R15);
    }
  }

  SECTION("Memory access") {
    for (const auto &Testcase : Testcases) {
      kdmpparser::KernelDumpParser Dmp;
      REQUIRE(Dmp.Parse(Testcase.File.data()));
      const uint64_t Address = Testcase.ReadAddress;
      const uint64_t AddressAligned = kdmpparser::Page::Align(Address);
      const uint64_t AddressOffset = kdmpparser::Page::Offset(Address);
      const auto &ExpectedContent = Testcase.Bytes;
      const uint8_t *Page = Dmp.GetPhysicalPage(AddressAligned);
      REQUIRE(Page != nullptr);
      CHECK(memcmp(Page + AddressOffset, ExpectedContent.data(),
                   sizeof(ExpectedContent)) == 0);
    }
  }
}

```

`src/tests/tests_version.cc`:

```cc
// Axel '0vercl0k' Souchet - 2023
#define CATCH_CONFIG_MAIN

#include <catch2/catch_test_macros.hpp>

#include "kdmp-parser.h"

TEST_CASE("kdmp-parser", "version") {
  CHECK(kdmpparser::Version_t::Major == KDMPPARSER_VERSION_MAJOR);
  CHECK(kdmpparser::Version_t::Minor == KDMPPARSER_VERSION_MINOR);
  CHECK(kdmpparser::Version_t::Patch == KDMPPARSER_VERSION_PATCH);
  CHECK(kdmpparser::Version_t::Release == KDMPPARSER_VERSION_RELEASE);
}

```