Project Path: arc_0vercl0k_udmp-parser_q_qj4gn8

Source Tree:

```txt
arc_0vercl0k_udmp-parser_q_qj4gn8
├── LICENSE
├── README.md
├── pics
│   ├── parser-usage.gif
│   └── parser.gif
└── src
    ├── CMakeLists.txt
    ├── build
    │   ├── build-release-msvc-wo-python.bat
    │   ├── build-release-msvc.bat
    │   ├── build-release-osx-wo-python.sh
    │   ├── build-release-osx.sh
    │   ├── build-release-wo-python.bat
    │   ├── build-release-wo-python.sh
    │   ├── build-release.bat
    │   └── build-release.sh
    ├── lib
    │   ├── CMakeLists.txt
    │   └── udmp-parser.h
    ├── parser
    │   ├── CMakeLists.txt
    │   └── parser.cc
    └── python
        ├── CMakeLists.txt
        ├── README.md
        ├── pyproject.toml
        ├── requirements.txt
        ├── src
        │   ├── udmp_parser.cc
        │   └── udmp_parser_utils.cc
        ├── tests
        │   ├── __init__.py
        │   ├── pytest.ini
        │   ├── requirements.txt
        │   ├── test_parser.py
        │   └── utils.py
        └── udmp_parser-stubs
            ├── __init__.pyi
            └── utils.pyi

```

`LICENSE`:

```
MIT License

Copyright (c) 2022-2023 Axel Souchet

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# udmp-parser: A Cross-Platform C++ parser library for Windows user minidumps

![Build status](https://github.com/0vercl0k/udmp-parser/workflows/Builds/badge.svg)
[![Downloads](https://static.pepy.tech/badge/udmp-parser/month)](https://pepy.tech/project/udmp-parser)

This is a cross-platform (Windows / Linux / OSX / x86 / x64) C++ library that parses Windows user [minidump](https://docs.microsoft.com/en-us/windows/win32/debug/minidump-files) dumps (`.dump /m` and **not** `.dump /f` in WinDbg usermode).

![parser](pics/parser.gif)

The library supports Intel 32-bit / 64-bit dumps and provides read access to things like:

- The thread list and their context records,
- The virtual memory,
- The loaded modules.

Compiled binaries are available in the [releases](https://github.com/0vercl0k/udmp-parser/releases) section.

## Parser

The `parser` application is a small utility to show-case how to use the library and demonstrate its features. You can use it to dump memory, list the loaded modules, dump thread contexts, dump a memory map various, etc.

![parser-usage](pics/parser-usage.gif)

Here are the options supported:
```
parser.exe [-a] [-mods] [-mem] [-t [<TID>|main] [-h] [-dump <addr>] <dump path>

Examples:
  Show all:
    parser.exe -a user.dmp
  Show loaded modules:
    parser.exe -mods user.dmp
  Show memory map:
    parser.exe -mem user.dmp
  Show all threads:
    parser.exe -t user.dmp
  Show thread w/ specific TID:
    parser.exe -t 1337 user.dmp
  Show foreground thread:
    parser.exe -t main user.dmp
  Show a memory page at a specific address:
    parser.exe -dump 0x7ff00 user.dmp
```

## Building

You can build it yourself using the appropriate build script for your platform in the [build](build/) directory. It builds on Linux, Windows, OSX with the [Microsoft](https://visualstudio.microsoft.com/vs/features/cplusplus/), the [LLVM Clang](https://clang.llvm.org/) and [GNU](https://gcc.gnu.org/) compilers.

Here is an example on Windows:

```
udmp-parser>cd src\build
udmp-parser\src\build>build-release.bat
udmp-parser\src\build>cmake .. -GNinja
-- The C compiler identification is MSVC 19.29.30139.0
-- The CXX compiler identification is MSVC 19.29.30139.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30133/bin/Hostx64/x64/cl.exe - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30133/bin/Hostx64/x64/cl.exe - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: C:/work/codes/udmp-parser/src/build
udmp-parser\src\build>cmake --build . --config RelWithDebInfo
[1/2] Building CXX object parser\CMakeFiles\parser.dir\parser.cc.obj
cl : Command line warning D9025 : overriding '/W3' with '/W4'
[2/2] Linking CXX executable parser\parser.exe
```

And here is another example on Linux:

```
~/udmp-parser$ cd src/build
~/udmp-parser/src/build$ chmod u+x build-release.sh
~/udmp-parser/src/build$ ./build-release.sh
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: ~/udmp-parser/src/build
[2/2] Linking CXX executable parser/parser
```

## Python bindings

### From PyPI

The easiest way is simply to:

```
pip install udmp_parser
```

### Using PIP

To install the package
```
cd src/python
pip install .
```

To create a wheel pacakge
```
cd src/python
pip wheel .
```


### Usage

The Python API was built around the C++ code so the names were preserved. Everything lives within the module `udmp_parser`.
Note: For convenience, a simple [pure Python script](src/python/tests/utils.py) was added to generate minidumps ready to use:

```python
$ python -i src/python/tests/utils.py
>>> pid, dmppath = generate_minidump_from_process_name("winver.exe")
Minidump generated successfully: PID=3232 -> minidump-winver.exe-1687024880.dmp
>>> pid
3232
>>> dmppath
WindowsPath('minidump-winver.exe-1687024880.dmp'))
```

Parsing a minidump object is as simple as:

```python
>>> import udmp_parser
>>> udmp_parser.version.major, udmp_parser.version.minor, udmp_parser.version.release
(0, 4, '')
>>> dmp = udmp_parser.UserDumpParser()
>>> dmp.Parse(pathlib.Path("C:/temp/rundll32.dmp"))
True
```

Feature-wise, here are some examples of usage:

#### Threads

Get a hashmap of threads (as `{TID: ThreadObject}`), access their information:

```python
>>> threads = dmp.Threads()
>>> len(threads)
14
>>> threads
{5292: Thread(Id=0x14ac, SuspendCount=0x1, Teb=0x2e8000),
 5300: Thread(Id=0x14b4, SuspendCount=0x1, Teb=0x2e5000),
 5316: Thread(Id=0x14c4, SuspendCount=0x1, Teb=0x2df000),
 3136: Thread(Id=0xc40, SuspendCount=0x1, Teb=0x2ee000),
 4204: Thread(Id=0x106c, SuspendCount=0x1, Teb=0x309000),
 5328: Thread(Id=0x14d0, SuspendCount=0x1, Teb=0x2e2000),
 1952: Thread(Id=0x7a0, SuspendCount=0x1, Teb=0x2f7000),
 3888: Thread(Id=0xf30, SuspendCount=0x1, Teb=0x2eb000),
 1760: Thread(Id=0x6e0, SuspendCount=0x1, Teb=0x2f4000),
 792: Thread(Id=0x318, SuspendCount=0x1, Teb=0x300000),
 1972: Thread(Id=0x7b4, SuspendCount=0x1, Teb=0x2fa000),
 1228: Thread(Id=0x4cc, SuspendCount=0x1, Teb=0x2fd000),
 516: Thread(Id=0x204, SuspendCount=0x1, Teb=0x303000),
 2416: Thread(Id=0x970, SuspendCount=0x1, Teb=0x306000)}
```

And access invidual thread, including their register context:

```python
>>> thread = threads[5292]
>>> print(f"RIP={thread.Context.Rip:#x} RBP={thread.Context.Rbp:#x} RSP={thread.Context.Rsp:#x}")
RIP=0x7ffc264b0ad4 RBP=0x404fecc RSP=0x7de628
```


#### Modules

Get a hashmap of modules (as `{address: ModuleObject}`), access their information:

```python
>>> modules = dmp.Modules()
>>> modules
{1572864: Module_t(BaseOfImage=0x180000, SizeOfImage=0x3000, ModuleName=C:\Windows\SysWOW64\sfc.dll),
 10813440: Module_t(BaseOfImage=0xa50000, SizeOfImage=0x14000, ModuleName=C:\Windows\SysWOW64\rundll32.exe),
 1929052160: Module_t(BaseOfImage=0x72fb0000, SizeOfImage=0x11000, ModuleName=C:\Windows\SysWOW64\wkscli.dll),
 1929183232: Module_t(BaseOfImage=0x72fd0000, SizeOfImage=0x52000, ModuleName=C:\Windows\SysWOW64\mswsock.dll),
 1929576448: Module_t(BaseOfImage=0x73030000, SizeOfImage=0xf000, ModuleName=C:\Windows\SysWOW64\browcli.dll),
 1929641984: Module_t(BaseOfImage=0x73040000, SizeOfImage=0xa000, ModuleName=C:\Windows\SysWOW64\davhlpr.dll),
 1929707520: Module_t(BaseOfImage=0x73050000, SizeOfImage=0x19000, ModuleName=C:\Windows\SysWOW64\davclnt.dll),
 1929838592: Module_t(BaseOfImage=0x73070000, SizeOfImage=0x18000, ModuleName=C:\Windows\SysWOW64\ntlanman.dll),
 [...]
 140720922427392: Module_t(BaseOfImage=0x7ffc24980000, SizeOfImage=0x83000, ModuleName=C:\Windows\System32\wow64win.dll),
 140720923017216: Module_t(BaseOfImage=0x7ffc24a10000, SizeOfImage=0x59000, ModuleName=C:\Windows\System32\wow64.dll),
 140720950280192: Module_t(BaseOfImage=0x7ffc26410000, SizeOfImage=0x1f8000, ModuleName=C:\Windows\System32\ntdll.dll)}
```

Access directly module info:

```python
>>> ntdll_modules = [mod for addr, mod in dmp.Modules().items() if mod.ModuleName.lower().endswith("ntdll.dll")]
>>> len(ntdll_modules)
2
>>> for ntdll in ntdll_modules:
  print(f"{ntdll.ModuleName=} {ntdll.BaseOfImage=:#x} {ntdll.SizeOfImage=:#x}")

ntdll.ModuleName='C:\\Windows\\SysWOW64\\ntdll.dll' ntdll.BaseOfImage=0x77430000 ntdll.SizeOfImage=0x1a4000
ntdll.ModuleName='C:\\Windows\\System32\\ntdll.dll' ntdll.BaseOfImage=0x7ffc26410000 ntdll.SizeOfImage=0x1f8000
```

A convenience function under `udmp_parser.UserDumpParser.ReadMemory()` can be used to directly read memory from the dump. The signature of the function is as follow: `def ReadMemory(Address: int, Size: int) -> list[int]`. So to dump for instance the `wow64` module, it would go as follow:

```python
>>> wow64 = [mod for addr, mod in dmp.Modules().items() if mod.ModuleName.lower() == r"c:\windows\system32\wow64.dll"][0]
>>> print(str(wow64))
Module_t(BaseOfImage=0x7ffc24a10000, SizeOfImage=0x59000, ModuleName=C:\Windows\System32\wow64.dll)
>>> wow64_module = bytearray(dmp.ReadMemory(wow64.BaseOfImage, wow64.SizeOfImage))
>>> assert wow64_module[:2] == b'MZ'
>>> import hexdump
>>> hexdump.hexdump(wow64_module[:128])
00000000: 4D 5A 90 00 03 00 00 00  04 00 00 00 FF FF 00 00  MZ..............
00000010: B8 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  ........@.......
00000020: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000030: 00 00 00 00 00 00 00 00  00 00 00 00 E8 00 00 00  ................
00000040: 0E 1F BA 0E 00 B4 09 CD  21 B8 01 4C CD 21 54 68  ........!..L.!Th
00000050: 69 73 20 70 72 6F 67 72  61 6D 20 63 61 6E 6E 6F  is program canno
00000060: 74 20 62 65 20 72 75 6E  20 69 6E 20 44 4F 53 20  t be run in DOS
00000070: 6D 6F 64 65 2E 0D 0D 0A  24 00 00 00 00 00 00 00  mode....$.......
```


#### Memory

The memory blocks can also be enumerated in a hashmap `{address: MemoryBlock}`.

```python
>>> memory = dmp.Memory()
>>> len(memory)
0x260
>>> memory
[...]
 0x7ffc26410000: [MemBlock_t(BaseAddress=0x7ffc26410000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x1000)],
 0x7ffc26411000: [MemBlock_t(BaseAddress=0x7ffc26411000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x11c000)],
 0x7ffc2652d000: [MemBlock_t(BaseAddress=0x7ffc2652d000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x49000)],
 0x7ffc26576000: [MemBlock_t(BaseAddress=0x7ffc26576000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x1000)],
 0x7ffc26577000: [MemBlock_t(BaseAddress=0x7ffc26577000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x2000)],
 0x7ffc26579000: [MemBlock_t(BaseAddress=0x7ffc26579000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x9000)],
 0x7ffc26582000: [MemBlock_t(BaseAddress=0x7ffc26582000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x86000)],
 0x7ffc26608000: [MemBlock_t(BaseAddress=0x7ffc26608000, AllocationBase=0x0, AllocationProtect=0x0, RegionSize=0x3d99e8000)]}
```

To facilitate the parsing in a human-friendly manner, some helper functions are provided:
 * `udmp_parser.utils.TypeToString`: convert the region type to its meaning (from MSDN)
 * `udmp_parser.utils.StateToString`: convert the region state to its meaning (from MSDN)
 * `udmp_parser.utils.ProtectionToString`: convert the region protection to its meaning (from MSDN)

This allows to search and filter in a more comprehensible way:


```python
# Collect only executable memory regions
>>> exec_regions = [region for _, region in dmp.Memory().items() if "PAGE_EXECUTE_READ" in udmp_parser.utils.ProtectionToString(region.Protect)]

# Pick any, disassemble code using capstone
>>> exec_region = exec_regions[-1]
>>> mem = dmp.ReadMemory(exec_region.BaseAddress, 0x100)
>>> for insn in cs.disasm(bytearray(mem), exec_region.BaseAddress):
  print(f"{insn=}")

insn=<CsInsn 0x7ffc26582000 [cc]: int3 >
insn=<CsInsn 0x7ffc26582001 [cc]: int3 >
insn=<CsInsn 0x7ffc26582002 [cc]: int3 >
insn=<CsInsn 0x7ffc26582003 [cc]: int3 >
insn=<CsInsn 0x7ffc26582004 [cc]: int3 >
insn=<CsInsn 0x7ffc26582005 [cc]: int3 >
insn=<CsInsn 0x7ffc26582006 [cc]: int3 >
insn=<CsInsn 0x7ffc26582007 [cc]: int3 >
insn=<CsInsn 0x7ffc26582008 [cc]: int3 >
insn=<CsInsn 0x7ffc26582009 [cc]: int3 >
insn=<CsInsn 0x7ffc2658200a [cc]: int3 >
insn=<CsInsn 0x7ffc2658200b [cc]: int3 >
insn=<CsInsn 0x7ffc2658200c [cc]: int3 >
insn=<CsInsn 0x7ffc2658200d [cc]: int3 >
insn=<CsInsn 0x7ffc2658200e [cc]: int3 >
insn=<CsInsn 0x7ffc2658200f [cc]: int3 >
insn=<CsInsn 0x7ffc26582010 [48895c2410]: mov qword ptr [rsp + 0x10], rbx>
insn=<CsInsn 0x7ffc26582015 [4889742418]: mov qword ptr [rsp + 0x18], rsi>
insn=<CsInsn 0x7ffc2658201a [57]: push rdi>
insn=<CsInsn 0x7ffc2658201b [4156]: push r14>
insn=<CsInsn 0x7ffc2658201d [4157]: push r15>
[...]
```

# Authors

* Axel '[@0vercl0k](https://twitter.com/0vercl0k)' Souchet

# Contributors

[ ![contributors-img](https://contrib.rocks/image?repo=0vercl0k/udmp-parser) ](https://github.com/0vercl0k/udmp-parser/graphs/contributors)

```

`src/CMakeLists.txt`:

```txt
# Axel '0vercl0k' Souchet - January 22 2022
# Note: the cmake version must be the same as in python/pyproject.toml::tool.scikit-build:cmake.minimum-version
cmake_minimum_required(VERSION 3.21)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_POSITION_INDEPENDENT_CODE True)

project(
    udmp-parser
    DESCRIPTION "A Cross-Platform C++ parser library for Windows user minidumps."
    HOMEPAGE_URL https://github.com/0vercl0k/udmp-parser
    VERSION 0.6.0
)

set(PROJECT_AUTHOR 0vercl0k)
set(PROJECT_LICENSE MIT)

option(BUILD_PARSER "Build the parser executable for UdmpParser" ${PROJECT_IS_TOP_LEVEL})
option(UDMP_PARSER_INSTALL "Install targets" ${PROJECT_IS_TOP_LEVEL})

add_subdirectory(lib)

if(BUILD_PARSER)
    add_subdirectory(parser)
endif(BUILD_PARSER)

```

`src/build/build-release-msvc-wo-python.bat`:

```bat
set ARCH=x64
if "%1"=="win32" set ARCH=Win32
cmake .. -A %ARCH% -DBUILD_PYTHON_BINDING=OFF
cmake --build . --config RelWithDebInfo

```

`src/build/build-release-msvc.bat`:

```bat
set ARCH=x64
if "%1"=="win32" set ARCH=Win32
cmake .. -A %ARCH%
cmake --build . --config RelWithDebInfo

```

`src/build/build-release-osx-wo-python.sh`:

```sh
cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_PYTHON_BINDING=OFF && cmake --build .

```

`src/build/build-release-osx.sh`:

```sh
cmake .. -DCMAKE_BUILD_TYPE=Release && cmake --build .

```

`src/build/build-release-wo-python.bat`:

```bat
cmake .. -GNinja -DBUILD_PYTHON_BINDING=OFF
cmake --build . --config RelWithDebInfo

```

`src/build/build-release-wo-python.sh`:

```sh
cmake .. -DCMAKE_BUILD_TYPE=Release -GNinja -DBUILD_PYTHON_BINDING=OFF && cmake --build .

```

`src/build/build-release.bat`:

```bat
cmake .. -GNinja
cmake --build . --config RelWithDebInfo

```

`src/build/build-release.sh`:

```sh
cmake .. -DCMAKE_BUILD_TYPE=Release -GNinja && cmake --build .

```

`src/lib/CMakeLists.txt`:

```txt
# Axel '0vercl0k' Souchet - January 22 2022
add_library(udmp-parser INTERFACE)
target_include_directories(udmp-parser INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})

if(WIN32)
    target_compile_definitions(udmp-parser INTERFACE NOMINMAX)
endif()

if(UDMP_PARSER_INSTALL)
    install(FILES $<TARGET_PROPERTY:udmp-parser,INTERFACE_INCLUDE_DIRECTORIES>/udmp-parser.h DESTINATION inc)
endif(UDMP_PARSER_INSTALL)

```

`src/lib/udmp-parser.h`:

```h
// Axel '0vercl0k' Souchet - January 22 2022
#pragma once
#include <algorithm>
#include <array>
#include <cinttypes>
#include <cstdarg>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <filesystem>
#include <map>
#include <memory>
#include <optional>
#include <span>
#include <sstream>
#include <string>
#include <unordered_map>
#include <variant>
#include <vector>

namespace fs = std::filesystem;

#if defined(__i386__) || defined(_M_IX86)
#define ARCH_X86
#elif defined(__amd64__) || defined(_M_X64)
#define ARCH_X64
#elif defined(__arm__) || defined(_M_ARM)
#define ARCH_ARM
#elif defined(__aarch64__) || defined(_M_ARM64)
#define ARCH_AARCH64
#else
#error Platform not supported.
#endif

#if defined(_WIN32)

#define WINDOWS
#include <Windows.h>

#if defined(ARCH_X86)
#define WINDOWS_X86
#elif defined(ARCH_X64)
#define WINDOWS_X64
#elif defined(ARCH_ARM)
#define WINDOWS_ARM
#elif defined(ARCH_AARCH64)
#define WINDOWS_AARCH64
#endif // ARCH_XXX

#elif defined(linux) || defined(__linux) || defined(__FreeBSD__) ||            \
    defined(__FreeBSD_kernel__) || defined(__MACH__)

#define LINUX
#include <errno.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#if defined(ARCH_X86)
#define LINUX_X86
#elif defined(ARCH_X64)
#define LINUX_X64
#elif defined(ARCH_ARM)
#define LINUX_ARM
#elif defined(ARCH_AARCH64)
#define LINUX_AARCH64
#endif // ARCH_XXX

#else

#error Platform not supported.

#endif // _WIN32

namespace udmpparser {

#ifdef NDEBUG
static void DbgPrintf(const char *Format, ...) { (void)Format; }
#else
static void DbgPrintf(const char *Format, ...) {
  va_list ArgList;
  va_start(ArgList, Format);
  vfprintf(stderr, Format, ArgList);
  va_end(ArgList);
}
#endif

#pragma pack(push)
#pragma pack(1)

struct Version {
  static inline const uint16_t Major = 0;
  static inline const uint16_t Minor = 7;
  static inline const std::string Release = "";
};

enum class ProcessorArch_t : uint16_t {
  X86 = 0,
  ARM = 5,
  IA64 = 6,
  AMD64 = 9,
  Unknown = 0xffff
};

constexpr uint32_t kWOW64_SIZE_OF_80387_REGISTERS = 80;

struct FloatingSaveArea32_t {
  uint32_t ControlWord;
  uint32_t StatusWord;
  uint32_t TagWord;
  uint32_t ErrorOffset;
  uint32_t ErrorSelector;
  uint32_t DataOffset;
  uint32_t DataSelector;
  std::array<uint8_t, kWOW64_SIZE_OF_80387_REGISTERS> RegisterArea;
  uint32_t Cr0NpxState;
};

static_assert(sizeof(FloatingSaveArea32_t) == 0x70);

constexpr uint32_t kWOW64_MAXIMUM_SUPPORTED_EXTENSION = 512;

struct Context32_t {
  uint32_t ContextFlags;
  uint32_t Dr0;
  uint32_t Dr1;
  uint32_t Dr2;
  uint32_t Dr3;
  uint32_t Dr6;
  uint32_t Dr7;
  FloatingSaveArea32_t FloatSave;
  uint32_t SegGs;
  uint32_t SegFs;
  uint32_t SegEs;
  uint32_t SegDs;
  uint32_t Edi;
  uint32_t Esi;
  uint32_t Ebx;
  uint32_t Edx;
  uint32_t Ecx;
  uint32_t Eax;
  uint32_t Ebp;
  uint32_t Eip;
  uint32_t SegCs;
  uint32_t EFlags;
  uint32_t Esp;
  uint32_t SegSs;
  std::array<uint8_t, kWOW64_MAXIMUM_SUPPORTED_EXTENSION> ExtendedRegisters;
};

static_assert(sizeof(Context32_t) == 0x2cc);

struct uint128_t {
  uint64_t Low;
  uint64_t High;
};

static_assert(sizeof(uint128_t) == 0x10);

struct Context64_t {
  uint64_t P1Home;
  uint64_t P2Home;
  uint64_t P3Home;
  uint64_t P4Home;
  uint64_t P5Home;
  uint64_t P6Home;
  uint32_t ContextFlags;
  uint32_t MxCsr;
  uint16_t SegCs;
  uint16_t SegDs;
  uint16_t SegEs;
  uint16_t SegFs;
  uint16_t SegGs;
  uint16_t SegSs;
  uint32_t EFlags;
  uint64_t Dr0;
  uint64_t Dr1;
  uint64_t Dr2;
  uint64_t Dr3;
  uint64_t Dr6;
  uint64_t Dr7;
  uint64_t Rax;
  uint64_t Rcx;
  uint64_t Rdx;
  uint64_t Rbx;
  uint64_t Rsp;
  uint64_t Rbp;
  uint64_t Rsi;
  uint64_t Rdi;
  uint64_t R8;
  uint64_t R9;
  uint64_t R10;
  uint64_t R11;
  uint64_t R12;
  uint64_t R13;
  uint64_t R14;
  uint64_t R15;
  uint64_t Rip;
  uint16_t ControlWord;
  uint16_t StatusWord;
  uint8_t TagWord;
  uint8_t Reserved1;
  uint16_t ErrorOpcode;
  uint32_t ErrorOffset;
  uint16_t ErrorSelector;
  uint16_t Reserved2;
  uint32_t DataOffset;
  uint16_t DataSelector;
  uint16_t Reserved3;
  uint32_t MxCsr2;
  uint32_t MxCsr_Mask;
  std::array<uint128_t, 8> FloatRegisters;
  uint128_t Xmm0;
  uint128_t Xmm1;
  uint128_t Xmm2;
  uint128_t Xmm3;
  uint128_t Xmm4;
  uint128_t Xmm5;
  uint128_t Xmm6;
  uint128_t Xmm7;
  uint128_t Xmm8;
  uint128_t Xmm9;
  uint128_t Xmm10;
  uint128_t Xmm11;
  uint128_t Xmm12;
  uint128_t Xmm13;
  uint128_t Xmm14;
  uint128_t Xmm15;
  std::array<uint8_t, 0x60> Padding;
  std::array<uint128_t, 26> VectorRegister;
  uint64_t VectorControl;
  uint64_t DebugControl;
  uint64_t LastBranchToRip;
  uint64_t LastBranchFromRip;
  uint64_t LastExceptionToRip;
  uint64_t LastExceptionFromRip;
};

static_assert(offsetof(Context64_t, Xmm0) == 0x1a0);
static_assert(offsetof(Context64_t, VectorRegister) == 0x300);
static_assert(sizeof(Context64_t) == 0x4d0);

namespace dmp {

struct Header_t {
  static inline const uint32_t ExpectedSignature = 0x50'4d'44'4d; // 'PMDM';
  static inline const uint32_t ValidFlagsMask = 0x00'1f'ff'ff;
  uint32_t Signature;
  uint16_t Version;
  uint16_t ImplementationVersion;
  uint32_t NumberOfStreams;
  uint32_t StreamDirectoryRva;
  uint32_t CheckSum;
  uint32_t Reserved;
  uint32_t TimeDateStamp;
  uint32_t Flags;

  bool LooksGood() const {
    if (Signature != ExpectedSignature) {
      DbgPrintf("The signature (%" PRIx32
                ") does not match the expected signature.\n",
                Signature);
      return false;
    }

    if ((Flags & ValidFlagsMask) != Flags) {
      DbgPrintf("The flags have unknown bits set.\n");
      return false;
    }

    if (NumberOfStreams == 0) {
      DbgPrintf("There is no streams.\n");
      return false;
    }

    return true;
  }
};

static_assert(sizeof(Header_t) == 0x20);

struct LocationDescriptor32_t {
  uint32_t DataSize = 0;
  uint32_t Rva = 0;
};

static_assert(sizeof(LocationDescriptor32_t) == 0x8);

struct LocationDescriptor64_t {
  uint64_t DataSize = 0;
  uint64_t Rva = 0;
};

static_assert(sizeof(LocationDescriptor64_t) == 0x10);

enum class StreamType_t : uint32_t {
  Unused = 0,
  ThreadList = 3,
  ModuleList = 4,
  Exception = 6,
  SystemInfo = 7,
  Memory64List = 9,
  MemoryInfoList = 16,
};

struct Directory_t {
  StreamType_t StreamType = StreamType_t::Unused;
  LocationDescriptor32_t Location;
};

static_assert(sizeof(Directory_t) == 0x0c);

struct Memory64ListStreamHdr_t {
  uint64_t NumberOfMemoryRanges = 0;
  uint64_t BaseRva = 0;
};

static_assert(sizeof(Memory64ListStreamHdr_t) == 0x10);

struct MemoryDescriptor64_t {
  uint64_t StartOfMemoryRange = 0;
  uint64_t DataSize = 0;
};

static_assert(sizeof(MemoryDescriptor64_t) == 0x10);

struct FixedFileInfo_t {
  uint32_t Signature = 0;
  uint32_t StrucVersion = 0;
  uint32_t FileVersionMS = 0;
  uint32_t FileVersionLS = 0;
  uint32_t ProductVersionMS = 0;
  uint32_t ProductVersionLS = 0;
  uint32_t FileFlagsMask = 0;
  uint32_t FileFlags = 0;
  uint32_t FileOS = 0;
  uint32_t FileType = 0;
  uint32_t FileSubtype = 0;
  uint32_t FileDateMS = 0;
  uint32_t FileDateLS = 0;
};

static_assert(sizeof(FixedFileInfo_t) == 0x34);

struct ModuleEntry_t {
  uint64_t BaseOfImage = 0;
  uint32_t SizeOfImage = 0;
  uint32_t CheckSum = 0;
  uint32_t TimeDateStamp = 0;
  uint32_t ModuleNameRva = 0;
  FixedFileInfo_t VersionInfo;
  LocationDescriptor32_t CvRecord;
  LocationDescriptor32_t MiscRecord;
  uint64_t Reserved0 = 0;
  uint64_t Reserved1 = 0;
};

static_assert(sizeof(ModuleEntry_t) == 0x6c);

struct MemoryInfoListStream_t {
  uint32_t SizeOfHeader = 0;
  uint32_t SizeOfEntry = 0;
  uint64_t NumberOfEntries = 0;
};

static_assert(sizeof(MemoryInfoListStream_t) == 0x10);

struct MemoryInfo_t {
  uint64_t BaseAddress = 0;
  uint64_t AllocationBase = 0;
  uint32_t AllocationProtect = 0;
  uint32_t __alignment1 = 0;
  uint64_t RegionSize = 0;
  uint32_t State = 0;
  uint32_t Protect = 0;
  uint32_t Type = 0;
  uint32_t __alignment2 = 0;
};

static_assert(sizeof(MemoryInfo_t) == 0x30);

struct MemoryDescriptor_t {
  uint64_t StartOfMemoryRange = 0;
  LocationDescriptor32_t Memory;
};

static_assert(sizeof(MemoryDescriptor_t) == 0x10);

struct ThreadEntry_t {
  uint32_t ThreadId = 0;
  uint32_t SuspendCount = 0;
  uint32_t PriorityClass = 0;
  uint32_t Priority = 0;
  uint64_t Teb = 0;
  MemoryDescriptor_t Stack;
  LocationDescriptor32_t ThreadContext;
};

static_assert(sizeof(ThreadEntry_t) == 0x30);

struct SystemInfoStream_t {
  ProcessorArch_t ProcessorArchitecture = ProcessorArch_t::Unknown;
  uint16_t ProcessorLevel = 0;
  uint16_t ProcessorRevision = 0;
  uint8_t NumberOfProcessors = 0;
  uint8_t ProductType = 0;
  uint32_t MajorVersion = 0;
  uint32_t MinorVersion = 0;
  uint32_t BuildNumber = 0;
  uint32_t PlatformId = 0;
  uint32_t CSDVersionRva = 0;
  uint16_t SuiteMask = 0;
  uint16_t Reserved2 = 0;
};

static_assert(sizeof(SystemInfoStream_t) == 0x20);

constexpr uint32_t kEXCEPTION_MAXIMUM_PARAMETERS = 15;

struct ExceptionRecord_t {
  uint32_t ExceptionCode;
  uint32_t ExceptionFlags;
  uint64_t ExceptionRecord;
  uint64_t ExceptionAddress;
  uint32_t NumberParameters;
  uint32_t __unusedAlignment;
  std::array<uint64_t, kEXCEPTION_MAXIMUM_PARAMETERS> ExceptionInformation;
};

static_assert(sizeof(ExceptionRecord_t) == 0x98);

struct ExceptionStream_t {
  uint32_t ThreadId = 0;
  uint32_t __alignment = 0;
  ExceptionRecord_t ExceptionRecord;
  LocationDescriptor32_t ThreadContext;
};

static_assert(sizeof(ExceptionStream_t) == 0xa8);

} // namespace dmp
#pragma pack(pop)

class MemoryReader_t {
protected:
  std::span<const uint8_t> View_;

public:
  MemoryReader_t() = default;
  virtual ~MemoryReader_t() = default;
  MemoryReader_t(const std::span<const uint8_t> View) : View_(View) {}
  MemoryReader_t(MemoryReader_t &&) = default;
  MemoryReader_t(const MemoryReader_t &) = delete;
  MemoryReader_t &operator=(MemoryReader_t &&) = default;
  MemoryReader_t &operator=(const MemoryReader_t &) = delete;

  size_t ViewSize() const { return View_.size_bytes(); }

  bool Read(const size_t Offset, std::span<uint8_t> Dest) {
    const size_t EndOffset = Offset + Dest.size_bytes();
    if (EndOffset <= Offset) {
      DbgPrintf("Overflow detected for EndOffset.\n");
      return false;
    }

    if (EndOffset > View_.size_bytes()) {
      DbgPrintf("Read request would read OOB.\n");
      return false;
    }

    auto Subspan = View_.subspan(Offset, Dest.size());
    std::copy(Subspan.begin(), Subspan.end(), Dest.begin());
    return true;
  }

  template <typename Pod_t> bool ReadT(const size_t Offset, Pod_t &Dest) {
    std::span<uint8_t> Span((uint8_t *)&Dest, sizeof(Dest));
    return Read(Offset, Span);
  }

  bool ReadFromLocation32(const dmp::LocationDescriptor32_t &Location,
                          const size_t Offset, std::span<uint8_t> Dest) {

    //
    // Exit early if the location is empty (to not trigger the `=` in the below
    // check).
    //

    if (Dest.size_bytes() == 0) {
      return true;
    }

    //
    // Check if there's any overflows, if what we are reading is indeed
    // contained in the block of memory described by `Location`. Worth noting
    // that those are useful to detect functional issues but not for memory
    // safety. The ones in `Read` are really the one that'll prevent callers
    // from reading out of bounds.
    //

    const size_t EndOffset = Offset + Dest.size_bytes();
    if (EndOffset <= Offset) {
      DbgPrintf("EndOffset overflow.\n");
      return false;
    }

    if (EndOffset > size_t(std::numeric_limits<uint32_t>::max())) {
      DbgPrintf("EndOffset is too large to be truncated to u32.\n");
      return false;
    }

    if (uint32_t(EndOffset) > Location.DataSize) {
      DbgPrintf("Reading more than what the directory contains.\n");
      return false;
    }

    const auto AbsoluteOffset = size_t(Location.Rva) + Offset;
    if (AbsoluteOffset <= Offset) {
      DbgPrintf("AbsoluteOffset overflow.\n");
      return false;
    }

    return Read(AbsoluteOffset, Dest);
  }

  template <typename Pod_t>
  bool ReadTFromDirectory(const dmp::Directory_t &Directory,
                          const size_t Offset, Pod_t &Dest) {
    std::span<uint8_t> Span((uint8_t *)&Dest, sizeof(Dest));
    return ReadFromLocation32(Directory.Location, Offset, Span);
  }
};

#if defined(WINDOWS)
class FileMapReader_t : public MemoryReader_t {

  //
  // Handle to the file mapping.
  //

  HANDLE FileMap_ = nullptr;

public:
  ~FileMapReader_t() override {
    //
    // Unmap the view of the mapping..
    //

    if (!View_.empty()) {
      UnmapViewOfFile(View_.data());
    }

    //
    // Close the handle to the file mapping.
    //

    if (FileMap_ != nullptr) {
      CloseHandle(FileMap_);
    }
  }

  bool MapFile(const char *PathFile) {

    //
    // Open the dump file in read-only.
    //

    HANDLE File = CreateFileA(PathFile, GENERIC_READ, FILE_SHARE_READ, nullptr,
                              OPEN_EXISTING, 0, nullptr);

    if (File == nullptr) {

      //
      // If we fail to open the file, let the user know.
      //

      const DWORD GLE = GetLastError();
      DbgPrintf("CreateFile failed with GLE=%lu.\n", GLE);

      if (GLE == ERROR_FILE_NOT_FOUND) {
        DbgPrintf("The file %s was not found.\n", PathFile);
      }

      return false;
    }

    DWORD High = 0;
    const DWORD Low = GetFileSize(File, &High);
    const DWORD64 FileSize = (DWORD64(High) << 32) | DWORD64(Low);
    if (FileSize > std::numeric_limits<size_t>::max()) {
      DbgPrintf("FileSize is larger than size_t's capacity.");
      return false;
    }

    //
    // Create the ro file mapping.
    //

    HANDLE FileMap =
        CreateFileMappingA(File, nullptr, PAGE_READONLY, 0, 0, nullptr);
    CloseHandle(File);

    if (FileMap == nullptr) {

      //
      // If we fail to create a file mapping, let
      // the user know.
      //

      const DWORD GLE = GetLastError();
      DbgPrintf("CreateFileMapping failed with GLE=%lu.\n", GLE);
      return false;
    }

    //
    // Map a view of the file in memory.
    //

    PVOID ViewBase = MapViewOfFile(FileMap, FILE_MAP_READ, 0, 0, 0);

    if (ViewBase == nullptr) {

      CloseHandle(FileMap);

      //
      // If we fail to map the view, let the user know.
      //

      const DWORD GLE = GetLastError();
      DbgPrintf("MapViewOfFile failed with GLE=%lu.\n", GLE);
      return false;
    }

    View_ = std::span((uint8_t *)ViewBase, size_t(FileSize));
    return true;
  }
};

#elif defined(LINUX)

class FileMapReader_t : public MemoryReader_t {
  int Fd_ = -1;

public:
  ~FileMapReader_t() override {
    if (!View_.empty()) {
      munmap((void *)View_.data(), ViewSize());
    }

    if (Fd_ != -1) {
      close(Fd_);
    }
  }

  bool MapFile(const char *PathFile) {
    Fd_ = open(PathFile, O_RDONLY);
    if (Fd_ < 0) {
      perror("Could not open dump file");
      return false;
    }

    struct stat Stat;
    if (fstat(Fd_, &Stat) < 0) {
      perror("Could not stat dump file");
      return false;
    }

    uint8_t *ViewBase =
        (uint8_t *)mmap(nullptr, Stat.st_size, PROT_READ, MAP_SHARED, Fd_, 0);
    if (ViewBase == MAP_FAILED) {
      perror("Could not mmap");
      return false;
    }

    View_ = std::span(ViewBase, Stat.st_size);
    return true;
  }
};

#endif

enum class Arch_t { X86, X64 };

struct MemBlock_t {
  uint64_t BaseAddress = 0;
  uint64_t AllocationBase = 0;
  uint32_t AllocationProtect = 0;
  uint64_t RegionSize = 0;
  uint32_t State = 0;
  uint32_t Protect = 0;
  uint32_t Type = 0;
  uint64_t DataOffset = 0;
  uint64_t DataSize = 0;

  MemBlock_t(const dmp::MemoryInfo_t &Info_)
      : BaseAddress(Info_.BaseAddress), AllocationBase(Info_.AllocationBase),
        AllocationProtect(Info_.AllocationProtect),
        RegionSize(Info_.RegionSize), State(Info_.State),
        Protect(Info_.Protect), Type(Info_.Type) {};

  std::string to_string() const {
    std::stringstream ss;
    ss << "[MemBlock_t(";
    ss << "BaseAddress=0x" << std::hex << BaseAddress;
    ss << ", AllocationBase=0x" << AllocationBase;
    ss << ", AllocationProtect=0x" << AllocationProtect;
    ss << ", RegionSize=0x" << RegionSize;
    ss << ")]";
    return ss.str();
  }
};

struct Module_t {
  uint64_t BaseOfImage = 0;
  uint32_t SizeOfImage = 0;
  uint32_t CheckSum = 0;
  uint32_t TimeDateStamp = 0;
  std::string ModuleName;
  dmp::FixedFileInfo_t VersionInfo;
  std::vector<uint8_t> CvRecord;
  std::vector<uint8_t> MiscRecord;

  Module_t(const dmp::ModuleEntry_t &M, const std::string &Name,
           std::vector<uint8_t> CvRecord_, std::vector<uint8_t> MiscRecord_)
      : BaseOfImage(M.BaseOfImage), SizeOfImage(M.SizeOfImage),
        CheckSum(M.CheckSum), TimeDateStamp(M.TimeDateStamp), ModuleName(Name),
        VersionInfo(M.VersionInfo), CvRecord(std::move(CvRecord_)),
        MiscRecord(std::move(MiscRecord_)) {}

  std::string to_string() const {
    std::stringstream ss;
    ss << "Module_t(";
    ss << "BaseOfImage=0x" << std::hex << BaseOfImage;
    ss << ", SizeOfImage=0x" << SizeOfImage;
    ss << ", ModuleName=" << ModuleName;
    ss << ")";
    return ss.str();
  }
};

class UnknownContext_t {};

struct Thread_t {
  uint32_t ThreadId = 0;
  uint32_t SuspendCount = 0;
  uint32_t PriorityClass = 0;
  uint32_t Priority = 0;
  uint64_t Teb = 0;
  std::variant<UnknownContext_t, Context32_t, Context64_t> Context;
  Thread_t(const dmp::ThreadEntry_t &T, UnknownContext_t &UnknownContext)
      : Thread_t(T) {
    Context = UnknownContext;
  }

  Thread_t(const dmp::ThreadEntry_t &T, Context32_t &Context32) : Thread_t(T) {
    Context = Context32;
  }

  Thread_t(const dmp::ThreadEntry_t &T, Context64_t &Context64) : Thread_t(T) {
    Context = Context64;
  }

  std::string to_string() const {
    std::stringstream ss;
    ss << "Thread(";
    ss << "Id=0x" << std::hex << ThreadId << ", ";
    ss << "SuspendCount=0x" << std::hex << SuspendCount << ", ";
    ss << "Teb=0x" << std::hex << Teb;
    ss << ")";
    return ss.str();
  }

private:
  Thread_t(const dmp::ThreadEntry_t &T)
      : ThreadId(T.ThreadId), SuspendCount(T.SuspendCount),
        PriorityClass(T.PriorityClass), Priority(T.Priority), Teb(T.Teb) {}
};

class UserDumpParser {
private:
  //
  // The memory map; base address -> mem.
  //

  std::map<uint64_t, MemBlock_t> Mem_;

  //
  // The architecture of the dumped process.
  //

  std::optional<ProcessorArch_t> Arch_;

  //
  // The list of loaded modules; base address -> module.
  //

  std::map<uint64_t, Module_t> Modules_;

  //
  // The thread id of the foreground thread.
  //

  std::optional<uint32_t> ForegroundThreadId_;

  //
  // The list of threads; thread id -> thread.
  //

  std::unordered_map<uint32_t, Thread_t> Threads_;

  //
  // Reader.
  //

  std::shared_ptr<MemoryReader_t> Reader_;

public:
  //
  // Parse the file.
  //

  bool Parse(const char *PathFile) {

    //
    // Map a view of the file.
    //

    if (!fs::exists(PathFile)) {
      DbgPrintf("The dump file specified does not exist.\n");
      return false;
    }

    auto FileMapReader = std::make_shared<FileMapReader_t>();
    if (!FileMapReader->MapFile(PathFile)) {
      DbgPrintf("MapFile failed.\n");
      return false;
    }

    Reader_ = std::move(FileMapReader);
    return Parse();
  }

  bool Parse(const fs::path &PathFile) {
    return Parse(PathFile.string().c_str());
  }

  //
  // Parse from memory view.
  //

  bool Parse(std::shared_ptr<MemoryReader_t> Reader) {
    if (!Reader) {
      DbgPrintf("The memory view passed is null.\n");
      return false;
    }

    Reader_ = std::move(Reader);
    return Parse();
  }

  const std::map<uint64_t, MemBlock_t> &GetMem() const { return Mem_; }

  const MemBlock_t *GetMemBlock(const void *Address) const {
    return GetMemBlock(uint64_t(Address));
  }

  const MemBlock_t *GetMemBlock(const uint64_t Address) const {
    auto It = Mem_.upper_bound(Address);
    if (It == Mem_.begin()) {
      return nullptr;
    }

    It--;
    const auto &[MemBlockAddress, MemBlock] = *It;
    if (Address >= MemBlockAddress &&
        Address < (MemBlockAddress + MemBlock.RegionSize)) {
      return &MemBlock;
    }

    return nullptr;
  }

  const Module_t *GetModule(const void *Address) const {
    return GetModule(uint64_t(Address));
  }

  const Module_t *GetModule(const uint64_t Address) const {

    //
    // Look for a module that includes this address.
    //

    const auto &Res =
        std::find_if(Modules_.begin(), Modules_.end(), [&](const auto &It) {
          return Address >= It.first &&
                 Address < (It.first + It.second.SizeOfImage);
        });

    //
    // If we have a match, return it!
    //

    if (Res != Modules_.end()) {
      return &Res->second;
    }

    return nullptr;
  }

  const std::map<uint64_t, Module_t> &GetModules() const { return Modules_; }

  const std::unordered_map<uint32_t, Thread_t> &GetThreads() const {
    return Threads_;
  }

  std::optional<uint32_t> GetForegroundThreadId() const {
    return ForegroundThreadId_;
  }

  std::string to_string() const {
    std::stringstream ss;
    ss << "UserDumpParser(";
    ss << "ModuleNb=" << Modules_.size();
    ss << ", ThreadNb=" << Threads_.size();
    ss << ")";
    return ss.str();
  }

  std::optional<std::vector<uint8_t>> ReadMemory(const uint64_t Address,
                                                 const size_t Size) const {
    const auto &Block = GetMemBlock(Address);
    if (!Block) {
      return std::nullopt;
    }

    std::vector<uint8_t> Out;
    if (Block->DataSize == 0) {
      return Out;
    }

    const uint64_t OffsetFromStart = Address - Block->BaseAddress;
    const uint64_t RemainingSize = Block->DataSize - OffsetFromStart;
    if (RemainingSize > uint64_t(std::numeric_limits<size_t>::max())) {
      DbgPrintf("RemainingSize truncation to usize would be lossy.\n");
      return std::nullopt;
    }

    const size_t DumpSize = std::min(size_t(RemainingSize), Size);
    Out.resize(DumpSize);
    if (!Reader_->Read(size_t(Block->DataOffset + OffsetFromStart), Out)) {
      DbgPrintf("Failed to ReadMemory.\n");
      return std::nullopt;
    }

    return Out;
  }

private:
  bool Parse() {

    //
    // Read the header..
    //

    dmp::Header_t Hdr;
    if (!Reader_->ReadT(0, Hdr)) {
      DbgPrintf("The header are not in bounds.\n");
      return false;
    }

    //
    // ..verify that it looks sane..
    //

    if (!Hdr.LooksGood()) {
      DbgPrintf("The header looks wrong.\n");
      return false;
    }

    //
    // .. walk through its directories.
    //

    std::unordered_map<dmp::StreamType_t, dmp::Directory_t> Directories;
    for (uint32_t StreamIdx = 0; StreamIdx < Hdr.NumberOfStreams; StreamIdx++) {
      //
      // Read the current directory..
      //

      const auto CurrentStreamDirectoryOffset =
          Hdr.StreamDirectoryRva + (StreamIdx * sizeof(dmp::Directory_t));
      dmp::Directory_t CurrentStreamDirectory;
      if (!Reader_->ReadT(CurrentStreamDirectoryOffset,
                          CurrentStreamDirectory)) {
        DbgPrintf("The stream directory %" PRIu32 " is out of the bounds.\n",
                  StreamIdx);
        return false;
      }

      //
      // ..skip unused ones..
      //

      if (CurrentStreamDirectory.StreamType == dmp::StreamType_t::Unused) {
        continue;
      }

      //
      // ..and keep track of the various stream encountered. If we see a stream
      // twice, bail as it isn't expected.
      //

      const auto &[_, Inserted] = Directories.try_emplace(
          CurrentStreamDirectory.StreamType, CurrentStreamDirectory);

      if (!Inserted) {
        DbgPrintf("There are more than one stream of type %" PRIu32 "\n",
                  uint32_t(CurrentStreamDirectory.StreamType));
        return false;
      }
    }

    //
    // Now, let's parse the stream in a specific order. Technically not
    // required, but it makes some logic easier to write.
    //

    const dmp::StreamType_t Order[] = {
        dmp::StreamType_t::SystemInfo,     dmp::StreamType_t::Exception,
        dmp::StreamType_t::MemoryInfoList, dmp::StreamType_t::Memory64List,
        dmp::StreamType_t::ThreadList,     dmp::StreamType_t::ModuleList};

    for (const auto &Type : Order) {

      //
      // If we have seen this stream, skip to the next.
      //

      const auto &Directory = Directories.find(Type);
      if (Directory == Directories.end()) {
        continue;
      }

      //
      // Parse the stream & bail the stream isn't recognized..
      //

      const auto &Result = ParseStream(Directory->second);
      if (!Result.has_value()) {
        DbgPrintf("Seems like there is a missing case for %" PRIu32
                  " in ParseStream?\n",
                  uint32_t(Type));
        return false;
      }

      //
      // ..or if the parsing of the stream has failed.
      //

      if (!Result.value()) {
        DbgPrintf("Failed to parse stream %" PRIu32 ".\n", uint32_t(Type));
        return false;
      }
    }

    //
    // If no foreground thread has been identified, then we're done.
    //

    if (!ForegroundThreadId_) {
      return true;
    }

    //
    // If we have one, ensure it exists in the list of threads, otherwise bail.
    //

    const bool ForegroundThreadExists =
        Threads_.find(*ForegroundThreadId_) != Threads_.end();
    if (!ForegroundThreadExists) {
      DbgPrintf("The Exception stream referenced a thread id that does not "
                "exist in the thread list.\n");
      return false;
    }

    return true;
  }

  std::optional<bool> ParseStream(const dmp::Directory_t &StreamDirectory) {

    //
    // Parse a stream if we know how to.
    //

    switch (StreamDirectory.StreamType) {
    case dmp::StreamType_t::Unused: {
      return true;
    }

    case dmp::StreamType_t::SystemInfo: {
      return ParseSystemInfoStream(StreamDirectory);
    }

    case dmp::StreamType_t::MemoryInfoList: {
      return ParseMemoryInfoListStream(StreamDirectory);
    }

    case dmp::StreamType_t::Memory64List: {
      return ParseMemory64ListStream(StreamDirectory);
    }

    case dmp::StreamType_t::ModuleList: {
      return ParseModuleListStream(StreamDirectory);
    }

    case dmp::StreamType_t::ThreadList: {
      return ParseThreadListStream(StreamDirectory);
    }

    case dmp::StreamType_t::Exception: {
      return ParseExceptionStream(StreamDirectory);
    }
    }

    return std::nullopt;
  }

  bool ParseExceptionStream(const dmp::Directory_t &StreamDirectory) {

    //
    // Read the exception stream..
    //

    dmp::ExceptionStream_t Exception;
    if (!Reader_->ReadTFromDirectory(StreamDirectory, 0, Exception)) {
      DbgPrintf("Failed to read ExceptionStream_t.\n");
      return false;
    }

    //
    // ..and grab the foreground TID (we ignore the rest).
    //

    ForegroundThreadId_ = Exception.ThreadId;
    return true;
  }

  bool ParseSystemInfoStream(const dmp::Directory_t &StreamDirectory) {

    //
    // Read the system infos stream..
    //

    dmp::SystemInfoStream_t SystemInfos;
    if (!Reader_->ReadTFromDirectory(StreamDirectory, 0, SystemInfos)) {
      DbgPrintf("The SystemInfo stream seems malformed.\n");
      return false;
    }

    //
    // ..and grab the processor architecture (we ignore the rest).
    //

    Arch_ = SystemInfos.ProcessorArchitecture;
    return true;
  }

  template <typename C_t>
  bool EmplaceThreadContext(const dmp::LocationDescriptor32_t &ThreadContext,
                            const dmp::ThreadEntry_t &Thread) {
    //
    // Make sure the that the thread context location is at least back enough to
    // read a `C_t`; otherwise bail.
    //

    C_t Context;
    if (!std::is_same<C_t, UnknownContext_t>()) {
      if (ThreadContext.DataSize < sizeof(Context)) {
        DbgPrintf("The size of the Context doesn't match up with the thread "
                  "context's length.\n");
        return false;
      }

      //
      // Read it..
      //

      if (!Reader_->ReadT(ThreadContext.Rva, Context)) {
        DbgPrintf("Failed to read Context for Thread %" PRIu32 ".\n",
                  Thread.ThreadId);
        return false;
      }
    }

    //
    // ..and create a `Thread_t`.
    //

    Threads_.try_emplace(Thread.ThreadId, Thread, Context);
    return true;
  }

  bool ParseThreadListStream(const dmp::Directory_t &StreamDirectory) {

    //
    // Read the number of thread..
    //

    uint32_t NumberOfThreads = 0;
    if (!Reader_->ReadTFromDirectory(StreamDirectory, 0, NumberOfThreads)) {
      DbgPrintf("The size of the ThreadList stream is not right.\n");
      return false;
    }

    //
    // ..and walk through every one of them.
    //

    for (uint32_t ThreadIdx = 0; ThreadIdx < NumberOfThreads; ThreadIdx++) {

      //
      // Read the thread entry which follows the `uint32_t` that contains the
      // number of threads..
      //

      dmp::ThreadEntry_t CurrentThread;
      const auto ThreadEntryOffset =
          sizeof(NumberOfThreads) + (ThreadIdx * sizeof(CurrentThread));
      if (!Reader_->ReadTFromDirectory(StreamDirectory, ThreadEntryOffset,
                                       CurrentThread)) {
        DbgPrintf("Failed to read Thread[%" PRIu32 ".\n");
        return false;
      }

      //
      // ..and figure out what kind of context do we expect depending on the
      // architecture if we have found any.
      //

      const auto &ThreadContext = CurrentThread.ThreadContext;
      bool Success = false;
      if (Arch_.has_value()) {
        switch (Arch_.value()) {
        case ProcessorArch_t::X86: {
          Success =
              EmplaceThreadContext<Context32_t>(ThreadContext, CurrentThread);
          break;
        }

        case ProcessorArch_t::AMD64: {
          Success =
              EmplaceThreadContext<Context64_t>(ThreadContext, CurrentThread);
          break;
        }

        default: {
          Success = EmplaceThreadContext<UnknownContext_t>(ThreadContext,
                                                           CurrentThread);
          break;
        }
        }
      } else {
        Success = EmplaceThreadContext<UnknownContext_t>(ThreadContext,
                                                         CurrentThread);
      }

      if (!Success) {
        return false;
      }
    }

    return true;
  }

  bool ParseMemoryInfoListStream(const dmp::Directory_t &StreamDirectory) {

    //
    // Read the memory info list stream..
    //

    dmp::MemoryInfoListStream_t MemoryInfoList;
    if (!Reader_->ReadTFromDirectory(StreamDirectory, 0, MemoryInfoList)) {
      DbgPrintf("Failed to read MemoryInfoListStream_t.\n");
      return false;
    }

    //
    // ..check that the header looks right..
    //

    if (MemoryInfoList.SizeOfHeader < sizeof(MemoryInfoList)) {
      DbgPrintf("The size of the MemoryInfoList header is not right.\n");
      return false;
    }

    //
    // ..check that the size of the entries looks right..
    //

    if (MemoryInfoList.SizeOfEntry < sizeof(dmp::MemoryInfo_t)) {
      DbgPrintf("The size of the MemoryInfo entries are not right.\n");
      return false;
    }

    //
    // ..and finally check that the size of the stream is what we think it
    // should be.
    //

    const uint64_t MaxEntries = std::numeric_limits<uint64_t>::max() /
                                uint64_t(MemoryInfoList.SizeOfEntry);
    if (MemoryInfoList.NumberOfEntries > MaxEntries) {
      DbgPrintf("Too many entries.\n");
      return false;
    }

    const uint64_t EntryOffset =
        uint64_t(MemoryInfoList.SizeOfEntry) * MemoryInfoList.NumberOfEntries;
    const uint64_t CalculatedStreamSize =
        uint64_t(MemoryInfoList.SizeOfHeader) + EntryOffset;
    if (CalculatedStreamSize <= EntryOffset) {
      DbgPrintf("Overflow with size of header.\n");
      return false;
    }

    if (CalculatedStreamSize != uint64_t(StreamDirectory.Location.DataSize)) {
      DbgPrintf("The MemoryInfoList stream size is not right.\n");
      return false;
    }

    //
    // Walk through the entries..
    //

    for (uint64_t MemoryInfoIdx = 0;
         MemoryInfoIdx < MemoryInfoList.NumberOfEntries; MemoryInfoIdx++) {
      //
      // ..read the entry..
      //

      const uint64_t CurrentMemoryInfoOffset =
          uint64_t(MemoryInfoList.SizeOfHeader) +
          (uint64_t(MemoryInfoList.SizeOfEntry) * MemoryInfoIdx);
      dmp::MemoryInfo_t CurrentMemoryInfo;
      if (!Reader_->ReadTFromDirectory(StreamDirectory,
                                       size_t(CurrentMemoryInfoOffset),
                                       CurrentMemoryInfo)) {
        return false;
      }

      //
      // ..and insert it in the map. If we've already seen this entry, bail.
      //

      const uint64_t BaseAddress = CurrentMemoryInfo.BaseAddress;
      const auto &[_, Inserted] =
          Mem_.try_emplace(BaseAddress, CurrentMemoryInfo);

      if (!Inserted) {
        DbgPrintf("The region %" PRIx64 " is already in the memory map.\n",
                  BaseAddress);
        return false;
      }
    }

    return true;
  }

  bool ParseModuleListStream(const dmp::Directory_t &StreamDirectory) {

    //
    // Read the number of modules..
    //

    uint32_t NumberOfModules;
    if (!Reader_->ReadTFromDirectory(StreamDirectory, 0, NumberOfModules)) {
      DbgPrintf("Failed to read NumberOfModules.\n");
      return false;
    }

    //
    // ..and walk through the entries.
    //

    for (uint32_t ModuleIdx = 0; ModuleIdx < NumberOfModules; ModuleIdx++) {
      //
      // Read the entry..
      //

      dmp::ModuleEntry_t CurrentModule;
      const size_t CurrentModuleOffset =
          sizeof(NumberOfModules) + (sizeof(CurrentModule) * size_t(ModuleIdx));
      if (!Reader_->ReadTFromDirectory(StreamDirectory, CurrentModuleOffset,
                                       CurrentModule)) {
        DbgPrintf("Failed to read module entry.\n");
        return false;
      }

      //
      // ..read the length of the module name..
      //

      const uint32_t ModuleNameLengthOffset = CurrentModule.ModuleNameRva;
      uint32_t ModuleNameLength;
      if (!Reader_->ReadT(ModuleNameLengthOffset, ModuleNameLength)) {
        DbgPrintf("Failed to read NameLengthOffset.\n");
        return false;
      }

      //
      // ..verify that it is well formed..
      //

      const bool WellFormed = (ModuleNameLength % 2) == 0;
      if (!WellFormed) {
        DbgPrintf("The MINIDUMP_STRING for the module index %" PRIu32
                  " is not well formed.\n",
                  ModuleIdx);
        return false;
      }

      //
      // ..and finally read the module name.
      //

      const size_t ModuleNameOffset =
          size_t(ModuleNameLengthOffset) + sizeof(ModuleNameLength);
      std::string ModuleName(ModuleNameLength, 0);
      std::span<uint8_t> ModuleNameSpan((uint8_t *)&ModuleName.front(),
                                        (uint8_t *)&ModuleName.back());
      if (!Reader_->Read(ModuleNameOffset, ModuleNameSpan)) {
        DbgPrintf("Failed to read the module name.\n");
        return false;
      }

      //
      // The module name is UTF16, so assume it is ASCII encoded so skip every
      // second bytes.
      //

      for (size_t CharIdx = 0; CharIdx < ModuleNameLength; CharIdx += 2) {
        if (!isprint(ModuleName[CharIdx])) {
          DbgPrintf("The MINIDUMP_STRING for the module index %" PRIu32
                    " has a non printable ascii character.\n",
                    ModuleIdx);
          return false;
        }

        ModuleName[CharIdx / 2] = ModuleName[CharIdx];
      }

      //
      // Resize the module name buffer when we read all its ASCII characters.
      //

      ModuleName.resize(ModuleNameLength / 2);
      ModuleName.shrink_to_fit();

      //
      // Read the Cv record..
      //

      std::vector<uint8_t> CvRecord(CurrentModule.CvRecord.DataSize);
      if (!Reader_->ReadFromLocation32(CurrentModule.CvRecord, 0, CvRecord)) {
        DbgPrintf("Failed to read CvRecord.\n");
        return false;
      }

      //
      // ..read the Misc record..
      //

      std::vector<uint8_t> MiscRecord(CurrentModule.MiscRecord.DataSize);
      if (!Reader_->ReadFromLocation32(CurrentModule.MiscRecord, 0,
                                       MiscRecord)) {
        DbgPrintf("Failed to read MiscRecord.\n");
        return false;
      }

      //
      // ..and finally create a `Module_t`.
      //

      Modules_.try_emplace(CurrentModule.BaseOfImage, CurrentModule, ModuleName,
                           std::move(CvRecord), std::move(MiscRecord));
    }

    return true;
  }

  bool ParseMemory64ListStream(const dmp::Directory_t &StreamDirectory) {

    //
    // Read the memory 64 list header..
    //

    dmp::Memory64ListStreamHdr_t Memory64List;
    if (!Reader_->ReadTFromDirectory(StreamDirectory, 0, Memory64List)) {
      DbgPrintf("Failed to read Memory64ListStreamHdr_t.\n");
      return false;
    }

    //
    // Grab the offset of where the actual memory content is stored at.
    //

    const uint64_t NumberOfMemoryRanges = Memory64List.NumberOfMemoryRanges;
    uint64_t CurrentDataOffset = Memory64List.BaseRva;

    //
    // Walk through the entries..
    //

    for (uint32_t RangeIdx = 0; RangeIdx < NumberOfMemoryRanges; RangeIdx++) {

      //
      // ..read a descriptor..
      //

      dmp::MemoryDescriptor64_t CurrentDescriptor;
      const size_t CurrentDescriptorOffset =
          sizeof(Memory64List) + (sizeof(CurrentDescriptor) * size_t(RangeIdx));

      if (!Reader_->ReadTFromDirectory(StreamDirectory, CurrentDescriptorOffset,
                                       CurrentDescriptor)) {
        DbgPrintf("Failed to read MemoryDescriptor64_t.\n");
        return false;
      }

      //
      // ..and if no existing entry is found, something funky is going on.
      //

      const uint64_t StartOfMemoryRange = CurrentDescriptor.StartOfMemoryRange;
      const auto &It = Mem_.find(StartOfMemoryRange);
      if (It == Mem_.end()) {
        DbgPrintf("The memory region starting at %" PRIx64
                  " does not exist in the map.\n",
                  StartOfMemoryRange);
        return false;
      }

      //
      // Update the entry.
      //

      const size_t DataSize = size_t(CurrentDescriptor.DataSize);
      It->second.DataOffset = CurrentDataOffset;
      It->second.DataSize = DataSize;
      CurrentDataOffset += DataSize;
    }

    return true;
  }
};
} // namespace udmpparser

```

`src/parser/CMakeLists.txt`:

```txt
# Axel '0vercl0k' Souchet - January 22 2022
add_executable(parser parser.cc)

if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    message(STATUS "Using GCC")
    target_compile_options(parser PRIVATE -Wall -Wextra -Werror -pedantic)

elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    message(STATUS "Using Clang")
    target_compile_options(parser PRIVATE -Wall -Wextra -Werror -pedantic)

elseif(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    message(STATUS "Using MSVC")
    target_compile_options(parser PRIVATE /W4 /WX)
    target_compile_definitions(parser PRIVATE NOMINMAX)
else()
    message(STATUS "Using ${CMAKE_CXX_COMPILER_ID}")
endif()

target_link_libraries(parser PRIVATE udmp-parser)

if(UDMP_PARSER_INSTALL)
    install(FILES $<TARGET_FILE:parser> DESTINATION bin)

    if(MSVC)
        install(FILES $<TARGET_PDB_FILE:parser> DESTINATION bin OPTIONAL)
    endif(MSVC)
endif()
```

`src/parser/parser.cc`:

```cc
// Axel '0vercl0k' Souchet - January 22 2022
#include "udmp-parser.h"
#include <algorithm>
#include <cinttypes>
#include <cstdint>
#include <cstdio>
#include <optional>

//
// Bunch of utils.
//

namespace utils {

//
// Get a string representation of the memory state.
//

const char *StateToString(const uint32_t State) {
  switch (State) {
  case 0x10'00: {
    return "MEM_COMMIT";
  }

  case 0x20'00: {
    return "MEM_RESERVE";
  }

  case 0x1'00'00: {
    return "MEM_FREE";
  }

  default: {
    return "UNKNOWN";
  }
  }
}

const char *TypeToString(const uint32_t Type) {
  switch (Type) {
  case 0x2'00'00: {
    return "MEM_PRIVATE";
  }
  case 0x4'00'00: {
    return "MEM_MAPPED";
  }
  case 0x1'00'00'00: {
    return "MEM_IMAGE";
  }
  default: {
    return "UNKNOWN";
  }
  }
}

//
// Print an Intel X86 context like windbg.
//

void PrintX86Context(const udmpparser::Context32_t &C, const int Prefix = 0) {
  printf("%*ceax=%08" PRIx32 " ebx=%08" PRIx32 " ecx=%08" PRIx32
         " edx=%08" PRIx32 " esi=%08" PRIx32 " edi=%08" PRIx32 "\n",
         Prefix, ' ', C.Eax, C.Ebx, C.Ecx, C.Edx, C.Esi, C.Edi);
  printf("%*ceip=%08" PRIx32 " esp=%08" PRIx32 " ebp=%08" PRIx32 "\n", Prefix,
         ' ', C.Eip, C.Esp, C.Ebp);
  printf("%*ccs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x gs=%04x              "
         "efl=%08x\n",
         Prefix, ' ', C.SegCs, C.SegSs, C.SegDs, C.SegEs, C.SegFs, C.SegGs,
         C.EFlags);
}

//
// Print an Intel X64 context like windbg.
//

void PrintX64Context(const udmpparser::Context64_t &C, const int Prefix = 0) {
  printf("%*crax=%016" PRIx64 " rbx=%016" PRIx64 " rcx=%016" PRIx64 "\n",
         Prefix, ' ', C.Rax, C.Rbx, C.Rcx);
  printf("%*crdx=%016" PRIx64 " rsi=%016" PRIx64 " rdi=%016" PRIx64 "\n",
         Prefix, ' ', C.Rdx, C.Rsi, C.Rdi);
  printf("%*crip=%016" PRIx64 " rsp=%016" PRIx64 " rbp=%016" PRIx64 "\n",
         Prefix, ' ', C.Rip, C.Rsp, C.Rbp);
  printf("%*c r8=%016" PRIx64 "  r9=%016" PRIx64 " r10=%016" PRIx64 "\n",
         Prefix, ' ', C.R8, C.R9, C.R10);
  printf("%*cr11=%016" PRIx64 " r12=%016" PRIx64 " r13=%016" PRIx64 "\n",
         Prefix, ' ', C.R11, C.R12, C.R13);
  printf("%*cr14=%016" PRIx64 " r15=%016" PRIx64 "\n", Prefix, ' ', C.R14,
         C.R15);
  printf("%*ccs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x gs=%04x              "
         "efl=%08x\n",
         Prefix, ' ', C.SegCs, C.SegSs, C.SegDs, C.SegEs, C.SegFs, C.SegGs,
         C.EFlags);
  printf("%*cfpcw=%04x    fpsw=%04x    fptw=%04x\n", Prefix, ' ', C.ControlWord,
         C.StatusWord, C.TagWord);
  printf("%*c  st0=%016" PRIx64 "%016" PRIx64 "       st1=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.FloatRegisters[0].High, C.FloatRegisters[0].Low,
         C.FloatRegisters[1].High, C.FloatRegisters[1].Low);
  printf("%*c  st2=%016" PRIx64 "%016" PRIx64 "       st3=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.FloatRegisters[2].High, C.FloatRegisters[2].Low,
         C.FloatRegisters[3].High, C.FloatRegisters[3].Low);
  printf("%*c  st4=%016" PRIx64 "%016" PRIx64 "       st5=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.FloatRegisters[4].High, C.FloatRegisters[4].Low,
         C.FloatRegisters[5].High, C.FloatRegisters[5].Low);
  printf("%*c  st6=%016" PRIx64 "%016" PRIx64 "       st7=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.FloatRegisters[6].High, C.FloatRegisters[6].Low,
         C.FloatRegisters[7].High, C.FloatRegisters[7].Low);
  printf("%*c xmm0=%016" PRIx64 "%016" PRIx64 "      xmm1=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.Xmm0.High, C.Xmm0.Low, C.Xmm1.High, C.Xmm1.Low);
  printf("%*c xmm2=%016" PRIx64 "%016" PRIx64 "      xmm3=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.Xmm2.High, C.Xmm2.Low, C.Xmm3.High, C.Xmm3.Low);
  printf("%*c xmm4=%016" PRIx64 "%016" PRIx64 "      xmm5=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.Xmm4.High, C.Xmm4.Low, C.Xmm5.High, C.Xmm5.Low);
  printf("%*c xmm6=%016" PRIx64 "%016" PRIx64 "      xmm7=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.Xmm6.High, C.Xmm6.Low, C.Xmm7.High, C.Xmm7.Low);
  printf("%*c xmm8=%016" PRIx64 "%016" PRIx64 "      xmm9=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.Xmm8.High, C.Xmm8.Low, C.Xmm9.High, C.Xmm9.Low);
  printf("%*cxmm10=%016" PRIx64 "%016" PRIx64 "     xmm11=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.Xmm10.High, C.Xmm10.Low, C.Xmm11.High, C.Xmm11.Low);
  printf("%*cxmm12=%016" PRIx64 "%016" PRIx64 "     xmm13=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.Xmm12.High, C.Xmm12.Low, C.Xmm13.High, C.Xmm13.Low);
  printf("%*cxmm14=%016" PRIx64 "%016" PRIx64 "     xmm15=%016" PRIx64
         "%016" PRIx64 "\n",
         Prefix, ' ', C.Xmm14.High, C.Xmm14.Low, C.Xmm15.High, C.Xmm15.Low);
}

//
// Print a CPU context like windbg does.
//

void PrintContext(const udmpparser::Thread_t &T, const int Prefix = 0) {
  printf("%*cTID %" PRIx32 ", TEB %" PRIx64 "\n", Prefix, ' ', T.ThreadId,
         T.Teb);
  printf("%*cContext:\n", Prefix, ' ');
  const auto &C = T.Context;
  if (std::holds_alternative<udmpparser::Context32_t>(C)) {
    const auto &C32 = std::get<udmpparser::Context32_t>(C);
    return PrintX86Context(C32, Prefix + 2);
  }

  if (std::holds_alternative<udmpparser::Context64_t>(C)) {
    const auto &C64 = std::get<udmpparser::Context64_t>(C);
    return PrintX64Context(C64, Prefix + 2);
  }

  printf("%*cUnknown type of context!\n", Prefix, ' ');
}

void Hexdump(const uint64_t Address, const std::span<uint8_t> Buffer,
             const int Prefix = 0) {
  const auto Len = Buffer.size_bytes();
  for (size_t i = 0; i < Len; i += 16) {
    printf("%*c%" PRIx64 ": ", Prefix, ' ', Address + i);
    for (size_t j = 0; j < 16; j++) {
      if (i + j < Len) {
        printf("%02" PRIx8, Buffer[i + j]);
      } else {
        printf("   ");
      }
    }
    printf(" |");
    for (size_t j = 0; j < 16; j++) {
      if (i + j < Len) {
        printf("%c", isprint(Buffer[i + j]) ? char(Buffer[i + j]) : '.');
      } else {
        printf(" ");
      }
    }
    printf("|\n");
  }
}

} // namespace utils

//
// Delimiter.
//

#define DELIMITER                                                              \
  "----------------------------------------------------------------------"     \
  "----------"

//
// The options available for the parser.
//

struct Options_t {

  //
  // This is enabled if -h is used.
  //

  bool ShowHelp = false;

  //
  // This is enabled if -a is used.
  //

  bool ShowAll = false;

  //
  // This is enabled if -mods is used.
  //

  bool ShowLoadedModules = false;

  //
  // This is enabled if -mem is used.
  //

  bool ShowMemoryMap = false;

  //
  // This is enabled if -t is used.
  //

  bool ShowThreads = false;

  //
  // This holds a TID if -t is followed by an integer.
  //

  std::optional<uint32_t> Tid;

  //
  // This is enabled if -t main is used.
  //

  bool ShowForegroundThread = false;

  //
  // This is set if -dump <addr> is used.
  //

  std::optional<uint64_t> DumpAddress;

  //
  // The path to the dump file.
  //

  std::string_view DumpPath;
};

//
// Help menu.
//

void Help() {
  printf("parser.exe [-a] [-mods] [-mem] [-t [<TID|main>] [-h] [-dump <addr>] "
         "<dump path>\n");
  printf("\n");
  printf("Examples:\n");
  printf("  Show all:\n");
  printf("    parser.exe -a user.dmp\n");
  printf("  Show loaded modules:\n");
  printf("    parser.exe -mods user.dmp\n");
  printf("  Show memory map:\n");
  printf("    parser.exe -mem user.dmp\n");
  printf("  Show all threads:\n");
  printf("    parser.exe -t user.dmp\n");
  printf("  Show thread w/ specific TID:\n");
  printf("    parser.exe -t 1337 user.dmp\n");
  printf("  Show foreground thread:\n");
  printf("    parser.exe -t main user.dmp\n");
  printf("  Dump a memory page at a specific address:\n");
  printf("    parser.exe -dump 0x7ff00 user.dmp\n");
  printf("\n");
}

int main(int argc, char *argv[]) {

  //
  // Parse the options.
  //

  Options_t Opts;
  for (int ArgIdx = 1; ArgIdx < argc; ArgIdx++) {
    const std::string_view Arg(argv[ArgIdx]);
    const bool IsLastArg = (ArgIdx + 1) >= argc;
    if (Arg == "-a") {
      Opts.ShowAll = true;
    } else if (Arg == "-h") {
      Opts.ShowHelp = true;
    } else if (Arg == "-mods") {
      Opts.ShowLoadedModules = true;
    } else if (Arg == "-mem") {
      Opts.ShowMemoryMap = true;
    } else if (Arg == "-t") {
      Opts.ShowThreads = true;

      //
      // Verify that there's enough argument for an integer and the last
      // argument which is the dump.
      //
      const std::string_view NextArg(IsLastArg ? "" : argv[ArgIdx + 1]);
      if (NextArg == "main") {
        Opts.ShowForegroundThread = true;
      } else {
        char *End = nullptr;
        const uint32_t Tid = std::strtoul(NextArg.data(), &End, 0);
        const bool Valid = errno == 0 && End != NextArg.data();
        if (Valid) {
          Opts.Tid = Tid;
        }
      }

      //
      // If we grabbed a TID or set the foreground thread, skip an argument.
      //

      if (Opts.Tid.has_value() || Opts.ShowForegroundThread) {
        ArgIdx++;
      }
    } else if (Arg == "-dump") {
      const std::string_view NextArg(IsLastArg ? "" : argv[ArgIdx + 1]);
      char *End = nullptr;
      const uint64_t Address = std::strtoull(NextArg.data(), &End, 0);
      const bool Valid = errno == 0 && End != NextArg.data();
      if (Valid) {
        Opts.DumpAddress = Address;
        ArgIdx++;
      }
    } else if (IsLastArg) {

      //
      // If this is the last argument, then this is the dump path.
      //

      Opts.DumpPath = Arg;
    } else {

      //
      // Otherwise it seems that the user passed something wrong?
      //

      printf("The argument %s is not recognized.\n\n", Arg.data());
      Help();
      return EXIT_FAILURE;
    }
  }

  //
  // Display help if wanted or no argument were specified.
  //

  if (argc == 1 || Opts.ShowHelp) {
    Help();
    return argc == 1 ? EXIT_FAILURE : EXIT_SUCCESS;
  }

  //
  // Initialize the parser.
  //

  udmpparser::UserDumpParser UserDump;
  if (!UserDump.Parse(Opts.DumpPath.data())) {
    printf("Loading '%s' failed.\n", Opts.DumpPath.data());
    return EXIT_FAILURE;
  }

  //
  // Show the loaded modules.
  //

  if (Opts.ShowLoadedModules || Opts.ShowAll) {
    printf(DELIMITER "\nLoaded modules:\n");
    const auto &Modules = UserDump.GetModules();
    for (const auto &[Base, ModuleInfo] : Modules) {
      printf("  %016" PRIx64 ": %s\n", Base, ModuleInfo.ModuleName.c_str());
    }
  }

  //
  // Show the memory map.
  //

  if (Opts.ShowMemoryMap || Opts.ShowAll) {
    printf(DELIMITER "\nMemory map:\n");
    for (const auto &[_, Descriptor] : UserDump.GetMem()) {

      //
      // Get a string representation for the state of the region.
      //

      const char *State = utils::StateToString(Descriptor.State);

      //
      // Get a string representation for the memory type of the region.
      //

      const char *Type = "";
      if (strcmp(State, "MEM_FREE")) {
        Type = utils::TypeToString(Descriptor.Type);
      }

      //
      // Display start / end / size / state / type of the region.
      //

      const auto BaseAddress = Descriptor.BaseAddress;
      const auto RegionSize = Descriptor.RegionSize;
      const auto EndAddress = BaseAddress + RegionSize;
      printf("  %16" PRIx64 " %16" PRIx64 " %16" PRIx64 " %11s %11s",
             BaseAddress, EndAddress, RegionSize, State, Type);

      //
      // Is the region actually part of a module?
      //

      const auto &Module = UserDump.GetModule(BaseAddress);

      //
      // If we found a module that overlaps with this region, let's dump it as
      // well.
      //

      if (Module != nullptr) {

        //
        // Find the last '\' to get the module name off its path.
        //

        const auto &ModulePathName = Module->ModuleName;
        auto ModuleNameOffset = ModulePathName.find_last_of('\\');
        if (ModuleNameOffset == ModulePathName.npos) {
          ModuleNameOffset = 0;
        } else {
          ModuleNameOffset++;
        }

        //
        // Show the module path & module name.
        //

        printf("   [%s; \"%s\"]", &ModulePathName[ModuleNameOffset],
               ModulePathName.c_str());
      }

      //
      // Dump the first 4 bytes of the region if its available in the dump.
      //

      if (Descriptor.DataSize >= 4) {
        auto Data = UserDump.ReadMemory(Descriptor.BaseAddress, 4);
        printf("   %02" PRIx8 " %02" PRIx8 " %02" PRIx8 " %02" PRIx8 "...",
               (*Data)[0], (*Data)[1], (*Data)[2], (*Data)[3]);
      }

      //
      // Phew! We are done for this region :)
      //

      printf("\n");
    }
  }

  //
  // Show the threads.
  //

  if (Opts.ShowThreads || Opts.ShowAll) {
    printf(DELIMITER "\nThreads:\n");
    const auto &ForegroundTid = UserDump.GetForegroundThreadId();
    for (const auto &[Tid, Thread] : UserDump.GetThreads()) {

      //
      // If we are looking for a specific TID, skip unless we have a match.
      //

      if (Opts.Tid && Tid != *Opts.Tid) {
        continue;
      }

      //
      // If we are looking for the foreground thread, skip unless we have a
      // match.
      //

      if (Opts.ShowForegroundThread && Tid != *ForegroundTid) {
        continue;
      }

      //
      // If we have a match or no filters, dump the context.
      //

      utils::PrintContext(Thread, 2);
    }
  }

  //
  // Dump virtual memory.
  //

  if (Opts.DumpAddress.has_value()) {
    printf(DELIMITER "\nMemory:\n");

    //
    // Find a block of virtual memory that overlaps with the address we want to
    // dump.
    //

    const auto DumpAddress = *Opts.DumpAddress;
    const auto &Block = UserDump.GetMemBlock(DumpAddress);

    //
    // If we found a match, let's go.
    //

    if (Block != nullptr) {

      //
      // Display basic information about the matching memory region.
      //

      const auto BlockStart = Block->BaseAddress;
      const auto BlockDataSize = Block->DataSize;
      const auto BlockRegionSize = Block->RegionSize;
      const auto BlockEnd = BlockStart + BlockRegionSize;
      printf("%016" PRIx64 " -> %016" PRIx64 "\n", BlockStart, BlockEnd);
      if (BlockDataSize > 0) {

        //
        // Calculate where from we need to start dumping, and the appropriate
        // amount of bytes to dump.
        //

        const auto OffsetFromStart = DumpAddress - BlockStart;
        const auto Remaining = size_t(BlockDataSize - OffsetFromStart);
        const size_t MaxSize = 0x100;
        const size_t DumpSize = std::min(MaxSize, Remaining);
        auto Data = UserDump.ReadMemory(BlockStart + OffsetFromStart, DumpSize);
        utils::Hexdump(BlockStart + OffsetFromStart, *Data, 2);
      } else {
        printf("The dump does not have the content of the memory at %" PRIx64
               "\n",
               DumpAddress);
      }
    } else {
      printf("No memory block were found for %" PRIx64 ".\n", DumpAddress);
    }
  }

  return EXIT_SUCCESS;
}
```

`src/python/CMakeLists.txt`:

```txt
#
# This file is part of udmp-parser project
#
# Released under MIT License, by 0vercl0k - 2023
#
# With contribution from:
# * hugsy - (github.com/hugsy)
#
cmake_minimum_required(VERSION 3.21)

project(
    udmp-parser-python
    DESCRIPTION "A Cross-Platform C++ parser library for Windows user minidumps."
    HOMEPAGE_URL https://github.com/0vercl0k/udmp-parser
    VERSION 0.6.0
)

if(NOT PROJECT_IS_TOP_LEVEL)
    message(FATAL_ERROR "This project is not intended to be used as a sub-project")
endif()

find_package(Python 3
    REQUIRED COMPONENTS Interpreter Development.Module
    OPTIONAL_COMPONENTS Development.SABIModule
)

if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the type of build." FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
endif()

execute_process(
    COMMAND "${Python_EXECUTABLE}" -m nanobind --cmake_dir
    OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE NB_DIR)
list(APPEND CMAKE_PREFIX_PATH "${NB_DIR}")

find_package(nanobind CONFIG REQUIRED)

set(CMAKE_CXX_STANDARD 20)

nanobind_add_module(udmp_parser STABLE_ABI src/udmp_parser_utils.cc src/udmp_parser.cc)

if(MSVC)
    target_link_libraries(udmp_parser PRIVATE DbgHelp.lib)
endif(MSVC)

#
# Those directives are only used when creating a standalone `udmp_parser` python package
#
target_include_directories(udmp_parser PRIVATE ../lib)
install(TARGETS udmp_parser LIBRARY DESTINATION .)
install(DIRECTORY udmp_parser-stubs DESTINATION .)

if(WIN32)
    target_compile_definitions(udmp_parser PRIVATE NOMINMAX)
endif()

```

`src/python/README.md`:

```md
# Python Bindings for `udmp-parser`

[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black) [![Licence MIT](https://img.shields.io/packagist/l/doctrine/orm.svg?maxAge=2592000?style=plastic)](https://github.com/0vercl0k/udmp-parser/blob/master/LICENSE)

`udmp-parser` is a cross-platform C++ parser library for Windows [user minidumps](https://docs.microsoft.com/en-us/windows/win32/debug/minidump-files) written by [0vercl0k](https://github.com/0vercl0k). The Python bindings were added by [hugsy](https://github.com/hugsy). Refer to the [project page on Github](https://github.com/0vercl0k/udmp-parser) for documentation, issues and pull requests.

![parser](https://github.com/0vercl0k/udmp-parser/raw/main/pics/parser.gif)

The library supports Intel 32-bit / 64-bit dumps and provides read access to things like:

- The thread list and their context records,
- The virtual memory,
- The loaded modules.

## Installing from PyPI

The easiest way is simply to:

```
pip install udmp_parser
```

## Usage

The Python API was built around the C++ code so the names were preserved. Everything lives within the module `udmp_parser`.
Note: For convenience, a simple [pure Python script](src/python/tests/utils.py) was added to generate minidumps ready to use:

```python
$ python -i src/python/tests/utils.py
>>> pid, dmppath = generate_minidump_from_process_name("winver.exe")
Minidump generated successfully: PID=3232 -> minidump-winver.exe-1687024880.dmp
>>> pid
3232
>>> dmppath
WindowsPath('minidump-winver.exe-1687024880.dmp'))
```

Parsing a minidump object is as simple as:

```python
>>> import udmp_parser
>>> udmp_parser.version.major, udmp_parser.version.minor, udmp_parser.version.release
(0, 4, '')
>>> dmp = udmp_parser.UserDumpParser()
>>> dmp.Parse(pathlib.Path("C:/temp/rundll32.dmp"))
True
```

Feature-wise, here are some examples of usage:

### Threads

Get a hashmap of threads (as `{TID: ThreadObject}`), access their information:

```python
>>> threads = dmp.Threads()
>>> len(threads)
14
>>> threads
{5292: Thread(Id=0x14ac, SuspendCount=0x1, Teb=0x2e8000),
 5300: Thread(Id=0x14b4, SuspendCount=0x1, Teb=0x2e5000),
 5316: Thread(Id=0x14c4, SuspendCount=0x1, Teb=0x2df000),
 3136: Thread(Id=0xc40, SuspendCount=0x1, Teb=0x2ee000),
 4204: Thread(Id=0x106c, SuspendCount=0x1, Teb=0x309000),
 5328: Thread(Id=0x14d0, SuspendCount=0x1, Teb=0x2e2000),
 1952: Thread(Id=0x7a0, SuspendCount=0x1, Teb=0x2f7000),
 3888: Thread(Id=0xf30, SuspendCount=0x1, Teb=0x2eb000),
 1760: Thread(Id=0x6e0, SuspendCount=0x1, Teb=0x2f4000),
 792: Thread(Id=0x318, SuspendCount=0x1, Teb=0x300000),
 1972: Thread(Id=0x7b4, SuspendCount=0x1, Teb=0x2fa000),
 1228: Thread(Id=0x4cc, SuspendCount=0x1, Teb=0x2fd000),
 516: Thread(Id=0x204, SuspendCount=0x1, Teb=0x303000),
 2416: Thread(Id=0x970, SuspendCount=0x1, Teb=0x306000)}
```

And access invidual thread, including their register context:

```python
>>> thread = threads[5292]
>>> print(f"RIP={thread.Context.Rip:#x} RBP={thread.Context.Rbp:#x} RSP={thread.Context.Rsp:#x}")
RIP=0x7ffc264b0ad4 RBP=0x404fecc RSP=0x7de628
```


### Modules

Get a hashmap of modules (as `{address: ModuleObject}`), access their information:

```python
>>> modules = dmp.Modules()
>>> modules
{1572864: Module_t(BaseOfImage=0x180000, SizeOfImage=0x3000, ModuleName=C:\Windows\SysWOW64\sfc.dll),
 10813440: Module_t(BaseOfImage=0xa50000, SizeOfImage=0x14000, ModuleName=C:\Windows\SysWOW64\rundll32.exe),
 1929052160: Module_t(BaseOfImage=0x72fb0000, SizeOfImage=0x11000, ModuleName=C:\Windows\SysWOW64\wkscli.dll),
 1929183232: Module_t(BaseOfImage=0x72fd0000, SizeOfImage=0x52000, ModuleName=C:\Windows\SysWOW64\mswsock.dll),
 1929576448: Module_t(BaseOfImage=0x73030000, SizeOfImage=0xf000, ModuleName=C:\Windows\SysWOW64\browcli.dll),
 1929641984: Module_t(BaseOfImage=0x73040000, SizeOfImage=0xa000, ModuleName=C:\Windows\SysWOW64\davhlpr.dll),
 1929707520: Module_t(BaseOfImage=0x73050000, SizeOfImage=0x19000, ModuleName=C:\Windows\SysWOW64\davclnt.dll),
 1929838592: Module_t(BaseOfImage=0x73070000, SizeOfImage=0x18000, ModuleName=C:\Windows\SysWOW64\ntlanman.dll),
 [...]
 140720922427392: Module_t(BaseOfImage=0x7ffc24980000, SizeOfImage=0x83000, ModuleName=C:\Windows\System32\wow64win.dll),
 140720923017216: Module_t(BaseOfImage=0x7ffc24a10000, SizeOfImage=0x59000, ModuleName=C:\Windows\System32\wow64.dll),
 140720950280192: Module_t(BaseOfImage=0x7ffc26410000, SizeOfImage=0x1f8000, ModuleName=C:\Windows\System32\ntdll.dll)}
```

Access directly module info:

```python
>>> ntdll_modules = [mod for addr, mod in dmp.Modules().items() if mod.ModuleName.lower().endswith("ntdll.dll")]
>>> len(ntdll_modules)
2
>>> for ntdll in ntdll_modules:
  print(f"{ntdll.ModuleName=} {ntdll.BaseOfImage=:#x} {ntdll.SizeOfImage=:#x}")

ntdll.ModuleName='C:\\Windows\\SysWOW64\\ntdll.dll' ntdll.BaseOfImage=0x77430000 ntdll.SizeOfImage=0x1a4000
ntdll.ModuleName='C:\\Windows\\System32\\ntdll.dll' ntdll.BaseOfImage=0x7ffc26410000 ntdll.SizeOfImage=0x1f8000
```

A convenience function under `udmp_parser.UserDumpParser.ReadMemory()` can be used to directly read memory from the dump. The signature of the function is as follow: `def ReadMemory(Address: int, Size: int) -> list[int]`. So to dump for instance the `wow64` module, it would go as follow:

```python
>>> wow64 = [mod for addr, mod in dmp.Modules().items() if mod.ModuleName.lower() == r"c:\windows\system32\wow64.dll"][0]
>>> print(str(wow64))
Module_t(BaseOfImage=0x7ffc24a10000, SizeOfImage=0x59000, ModuleName=C:\Windows\System32\wow64.dll)
>>> wow64_module = bytearray(dmp.ReadMemory(wow64.BaseOfImage, wow64.SizeOfImage))
>>> assert wow64_module[:2] == b'MZ'
>>> import hexdump
>>> hexdump.hexdump(wow64_module[:128])
00000000: 4D 5A 90 00 03 00 00 00  04 00 00 00 FF FF 00 00  MZ..............
00000010: B8 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  ........@.......
00000020: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000030: 00 00 00 00 00 00 00 00  00 00 00 00 E8 00 00 00  ................
00000040: 0E 1F BA 0E 00 B4 09 CD  21 B8 01 4C CD 21 54 68  ........!..L.!Th
00000050: 69 73 20 70 72 6F 67 72  61 6D 20 63 61 6E 6E 6F  is program canno
00000060: 74 20 62 65 20 72 75 6E  20 69 6E 20 44 4F 53 20  t be run in DOS
00000070: 6D 6F 64 65 2E 0D 0D 0A  24 00 00 00 00 00 00 00  mode....$.......
```


### Memory

The memory blocks can also be enumerated in a hashmap `{address: MemoryBlock}`.

```python
>>> memory = dmp.Memory()
>>> len(memory)
0x260
>>> memory
[...]
 0x7ffc26410000: [MemBlock_t(BaseAddress=0x7ffc26410000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x1000)],
 0x7ffc26411000: [MemBlock_t(BaseAddress=0x7ffc26411000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x11c000)],
 0x7ffc2652d000: [MemBlock_t(BaseAddress=0x7ffc2652d000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x49000)],
 0x7ffc26576000: [MemBlock_t(BaseAddress=0x7ffc26576000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x1000)],
 0x7ffc26577000: [MemBlock_t(BaseAddress=0x7ffc26577000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x2000)],
 0x7ffc26579000: [MemBlock_t(BaseAddress=0x7ffc26579000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x9000)],
 0x7ffc26582000: [MemBlock_t(BaseAddress=0x7ffc26582000, AllocationBase=0x7ffc26410000, AllocationProtect=0x80, RegionSize=0x86000)],
 0x7ffc26608000: [MemBlock_t(BaseAddress=0x7ffc26608000, AllocationBase=0x0, AllocationProtect=0x0, RegionSize=0x3d99e8000)]}
```

To facilitate the parsing in a human-friendly manner, some helper functions are provided:
 * `udmp_parser.utils.TypeToString`: convert the region type to its meaning (from MSDN)
 * `udmp_parser.utils.StateToString`: convert the region state to its meaning (from MSDN)
 * `udmp_parser.utils.ProtectionToString`: convert the region protection to its meaning (from MSDN)

This allows to search and filter in a more comprehensible way:


```python
# Collect only executable memory regions
>>> exec_regions = [region for _, region in dmp.Memory().items() if "PAGE_EXECUTE_READ" in udmp_parser.utils.ProtectionToString(region.Protect)]

# Pick any, disassemble code using capstone
>>> exec_region = exec_regions[-1]
>>> mem = dmp.ReadMemory(exec_region.BaseAddress, 0x100)
>>> for insn in cs.disasm(bytearray(mem), exec_region.BaseAddress):
  print(f"{insn=}")

insn=<CsInsn 0x7ffc26582000 [cc]: int3 >
insn=<CsInsn 0x7ffc26582001 [cc]: int3 >
insn=<CsInsn 0x7ffc26582002 [cc]: int3 >
insn=<CsInsn 0x7ffc26582003 [cc]: int3 >
insn=<CsInsn 0x7ffc26582004 [cc]: int3 >
insn=<CsInsn 0x7ffc26582005 [cc]: int3 >
insn=<CsInsn 0x7ffc26582006 [cc]: int3 >
insn=<CsInsn 0x7ffc26582007 [cc]: int3 >
insn=<CsInsn 0x7ffc26582008 [cc]: int3 >
insn=<CsInsn 0x7ffc26582009 [cc]: int3 >
insn=<CsInsn 0x7ffc2658200a [cc]: int3 >
insn=<CsInsn 0x7ffc2658200b [cc]: int3 >
insn=<CsInsn 0x7ffc2658200c [cc]: int3 >
insn=<CsInsn 0x7ffc2658200d [cc]: int3 >
insn=<CsInsn 0x7ffc2658200e [cc]: int3 >
insn=<CsInsn 0x7ffc2658200f [cc]: int3 >
insn=<CsInsn 0x7ffc26582010 [48895c2410]: mov qword ptr [rsp + 0x10], rbx>
insn=<CsInsn 0x7ffc26582015 [4889742418]: mov qword ptr [rsp + 0x18], rsi>
insn=<CsInsn 0x7ffc2658201a [57]: push rdi>
insn=<CsInsn 0x7ffc2658201b [4156]: push r14>
insn=<CsInsn 0x7ffc2658201d [4157]: push r15>
[...]
```

# Authors

* Axel '[@0vercl0k](https://twitter.com/0vercl0k)' Souchet

# Contributors

[ ![contributors-img](https://contrib.rocks/image?repo=0vercl0k/udmp-parser) ](https://github.com/0vercl0k/udmp-parser/graphs/contributors)

```

`src/python/pyproject.toml`:

```toml
[build-system]
requires = ["scikit-build-core >=0.4.3", "nanobind >=1.3.2"]
build-backend = "scikit_build_core.build"

[project]
name = "udmp-parser"
version = "0.7.0"
description = "A Cross-Platform C++ parser library for Windows user minidumps."
readme = "README.md"
requires-python = ">=3.8"
authors = [{ name = "0vercl0k", email = "0vercl0k@not-your-biz.net" }]
classifiers = [
    "Development Status :: 4 - Beta",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Software Development :: Assemblers",
    "Natural Language :: English",
]
dependencies = []

[project.urls]
Homepage = "https://github.com/0vercl0k/udmp-parser"

[project.scripts]
generate_minidump = "udmp_parser.utils:generate_minidump_from_command_line"

[tool.isort]
profile = "black"

[tool.scikit-build]
wheel.py-api = "cp313"
minimum-version = "0.4"
build-dir = "build/{wheel_tag}"
cmake.minimum-version = "3.21"

[tool.cibuildwheel]
build-verbosity = 1
# udmp_parser builds fine for this target, but not `lief`.
skip = "cp314t-*"
before-test = "pip install -U -r {project}/src/python/tests/requirements.txt"
test-command = "pytest -vvv {project}/src/python/tests"

[tool.cibuildwheel.macos.environment]
MACOSX_DEPLOYMENT_TARGET = "10.15"

```

`src/python/requirements.txt`:

```txt
setuptools
wheel
nanobind
black

```

`src/python/src/udmp_parser.cc`:

```cc
//
// This file is part of udmp-parser project
//
// Released under MIT License, by 0vercl0k - 2023
//
// With contribution from:
//  * hugsy - (github.com/hugsy)
//

#include "udmp-parser.h"

#include <nanobind/nanobind.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/filesystem.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/pair.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/unordered_map.h>
#include <nanobind/stl/unordered_set.h>
#include <nanobind/stl/variant.h>
#include <nanobind/stl/vector.h>

namespace nb = nanobind;

void udmp_parser_utils_module(nb::module_ &m);

NB_MODULE(udmp_parser, m) {

  udmp_parser_utils_module(m);

  nb::enum_<udmpparser::ProcessorArch_t>(m, "ProcessorArch")
      .value("X86", udmpparser::ProcessorArch_t::X86)
      .value("ARM", udmpparser::ProcessorArch_t::ARM)
      .value("IA64", udmpparser::ProcessorArch_t::IA64)
      .value("AMD64", udmpparser::ProcessorArch_t::AMD64)
      .value("Unknown", udmpparser::ProcessorArch_t::Unknown)
      .export_values();

  nb::class_<udmpparser::FloatingSaveArea32_t>(m, "FloatingSaveArea32")
      .def_ro("ControlWord", &udmpparser::FloatingSaveArea32_t::ControlWord)
      .def_ro("StatusWord", &udmpparser::FloatingSaveArea32_t::StatusWord)
      .def_ro("TagWord", &udmpparser::FloatingSaveArea32_t::TagWord)
      .def_ro("ErrorOffset", &udmpparser::FloatingSaveArea32_t::ErrorOffset)
      .def_ro("ErrorSelector", &udmpparser::FloatingSaveArea32_t::ErrorSelector)
      .def_ro("DataOffset", &udmpparser::FloatingSaveArea32_t::DataOffset)
      .def_ro("DataSelector", &udmpparser::FloatingSaveArea32_t::DataSelector)
      .def_ro("RegisterArea", &udmpparser::FloatingSaveArea32_t::RegisterArea)
      .def_ro("Cr0NpxState", &udmpparser::FloatingSaveArea32_t::Cr0NpxState);

  nb::class_<udmpparser::Context32_t>(m, "Context32")
      .def_ro("ContextFlags", &udmpparser::Context32_t::ContextFlags)
      .def_ro("Dr0", &udmpparser::Context32_t::Dr0)
      .def_ro("Dr1", &udmpparser::Context32_t::Dr1)
      .def_ro("Dr2", &udmpparser::Context32_t::Dr2)
      .def_ro("Dr3", &udmpparser::Context32_t::Dr3)
      .def_ro("Dr6", &udmpparser::Context32_t::Dr6)
      .def_ro("Dr7", &udmpparser::Context32_t::Dr7)
      .def_ro("FloatSave", &udmpparser::Context32_t::FloatSave)
      .def_ro("SegGs", &udmpparser::Context32_t::SegGs)
      .def_ro("SegFs", &udmpparser::Context32_t::SegFs)
      .def_ro("SegEs", &udmpparser::Context32_t::SegEs)
      .def_ro("SegDs", &udmpparser::Context32_t::SegDs)
      .def_ro("Edi", &udmpparser::Context32_t::Edi)
      .def_ro("Esi", &udmpparser::Context32_t::Esi)
      .def_ro("Ebx", &udmpparser::Context32_t::Ebx)
      .def_ro("Edx", &udmpparser::Context32_t::Edx)
      .def_ro("Ecx", &udmpparser::Context32_t::Ecx)
      .def_ro("Eax", &udmpparser::Context32_t::Eax)
      .def_ro("Ebp", &udmpparser::Context32_t::Ebp)
      .def_ro("Eip", &udmpparser::Context32_t::Eip)
      .def_ro("SegCs", &udmpparser::Context32_t::SegCs)
      .def_ro("EFlags", &udmpparser::Context32_t::EFlags)
      .def_ro("Esp", &udmpparser::Context32_t::Esp)
      .def_ro("SegSs", &udmpparser::Context32_t::SegSs)
      .def_ro("ExtendedRegisters", &udmpparser::Context32_t::ExtendedRegisters);

  nb::class_<udmpparser::uint128_t>(m, "uint128")
      .def_ro("Low", &udmpparser::uint128_t::Low)
      .def_ro("High", &udmpparser::uint128_t::High);

  nb::class_<udmpparser::Context64_t>(m, "Context64")
      .def_ro("P1Home", &udmpparser::Context64_t::P1Home)
      .def_ro("P2Home", &udmpparser::Context64_t::P2Home)
      .def_ro("P3Home", &udmpparser::Context64_t::P3Home)
      .def_ro("P4Home", &udmpparser::Context64_t::P4Home)
      .def_ro("P5Home", &udmpparser::Context64_t::P5Home)
      .def_ro("P6Home", &udmpparser::Context64_t::P6Home)
      .def_ro("ContextFlags", &udmpparser::Context64_t::ContextFlags)
      .def_ro("MxCsr", &udmpparser::Context64_t::MxCsr)
      .def_ro("SegCs", &udmpparser::Context64_t::SegCs)
      .def_ro("SegDs", &udmpparser::Context64_t::SegDs)
      .def_ro("SegEs", &udmpparser::Context64_t::SegEs)
      .def_ro("SegFs", &udmpparser::Context64_t::SegFs)
      .def_ro("SegGs", &udmpparser::Context64_t::SegGs)
      .def_ro("SegSs", &udmpparser::Context64_t::SegSs)
      .def_ro("EFlags", &udmpparser::Context64_t::EFlags)
      .def_ro("Dr0", &udmpparser::Context64_t::Dr0)
      .def_ro("Dr1", &udmpparser::Context64_t::Dr1)
      .def_ro("Dr2", &udmpparser::Context64_t::Dr2)
      .def_ro("Dr3", &udmpparser::Context64_t::Dr3)
      .def_ro("Dr6", &udmpparser::Context64_t::Dr6)
      .def_ro("Dr7", &udmpparser::Context64_t::Dr7)
      .def_ro("Rax", &udmpparser::Context64_t::Rax)
      .def_ro("Rcx", &udmpparser::Context64_t::Rcx)
      .def_ro("Rdx", &udmpparser::Context64_t::Rdx)
      .def_ro("Rbx", &udmpparser::Context64_t::Rbx)
      .def_ro("Rsp", &udmpparser::Context64_t::Rsp)
      .def_ro("Rbp", &udmpparser::Context64_t::Rbp)
      .def_ro("Rsi", &udmpparser::Context64_t::Rsi)
      .def_ro("Rdi", &udmpparser::Context64_t::Rdi)
      .def_ro("R8", &udmpparser::Context64_t::R8)
      .def_ro("R9", &udmpparser::Context64_t::R9)
      .def_ro("R10", &udmpparser::Context64_t::R10)
      .def_ro("R11", &udmpparser::Context64_t::R11)
      .def_ro("R12", &udmpparser::Context64_t::R12)
      .def_ro("R13", &udmpparser::Context64_t::R13)
      .def_ro("R14", &udmpparser::Context64_t::R14)
      .def_ro("R15", &udmpparser::Context64_t::R15)
      .def_ro("Rip", &udmpparser::Context64_t::Rip)
      .def_ro("ControlWord", &udmpparser::Context64_t::ControlWord)
      .def_ro("StatusWord", &udmpparser::Context64_t::StatusWord)
      .def_ro("TagWord", &udmpparser::Context64_t::TagWord)
      .def_ro("Reserved1", &udmpparser::Context64_t::Reserved1)
      .def_ro("ErrorOpcode", &udmpparser::Context64_t::ErrorOpcode)
      .def_ro("ErrorOffset", &udmpparser::Context64_t::ErrorOffset)
      .def_ro("ErrorSelector", &udmpparser::Context64_t::ErrorSelector)
      .def_ro("Reserved2", &udmpparser::Context64_t::Reserved2)
      .def_ro("DataOffset", &udmpparser::Context64_t::DataOffset)
      .def_ro("DataSelector", &udmpparser::Context64_t::DataSelector)
      .def_ro("Reserved3", &udmpparser::Context64_t::Reserved3)
      .def_ro("MxCsr2", &udmpparser::Context64_t::MxCsr2)
      .def_ro("MxCsr_Mask", &udmpparser::Context64_t::MxCsr_Mask)
      .def_ro("FloatRegisters", &udmpparser::Context64_t::FloatRegisters)
      .def_ro("Xmm0", &udmpparser::Context64_t::Xmm0)
      .def_ro("Xmm1", &udmpparser::Context64_t::Xmm1)
      .def_ro("Xmm2", &udmpparser::Context64_t::Xmm2)
      .def_ro("Xmm3", &udmpparser::Context64_t::Xmm3)
      .def_ro("Xmm4", &udmpparser::Context64_t::Xmm4)
      .def_ro("Xmm5", &udmpparser::Context64_t::Xmm5)
      .def_ro("Xmm6", &udmpparser::Context64_t::Xmm6)
      .def_ro("Xmm7", &udmpparser::Context64_t::Xmm7)
      .def_ro("Xmm8", &udmpparser::Context64_t::Xmm8)
      .def_ro("Xmm9", &udmpparser::Context64_t::Xmm9)
      .def_ro("Xmm10", &udmpparser::Context64_t::Xmm10)
      .def_ro("Xmm11", &udmpparser::Context64_t::Xmm11)
      .def_ro("Xmm12", &udmpparser::Context64_t::Xmm12)
      .def_ro("Xmm13", &udmpparser::Context64_t::Xmm13)
      .def_ro("Xmm14", &udmpparser::Context64_t::Xmm14)
      .def_ro("Xmm15", &udmpparser::Context64_t::Xmm15)
      .def_ro("VectorRegister", &udmpparser::Context64_t::VectorRegister)
      .def_ro("VectorControl", &udmpparser::Context64_t::VectorControl)
      .def_ro("DebugControl", &udmpparser::Context64_t::DebugControl)
      .def_ro("LastBranchToRip", &udmpparser::Context64_t::LastBranchToRip)
      .def_ro("LastBranchFromRip", &udmpparser::Context64_t::LastBranchFromRip)
      .def_ro("LastExceptionToRip",
              &udmpparser::Context64_t::LastExceptionToRip)
      .def_ro("LastExceptionFromRip",
              &udmpparser::Context64_t::LastExceptionFromRip);

  nb::class_<udmpparser::dmp::Header_t>(m, "Header")
      .def_ro_static("ExpectedSignature",
                     &udmpparser::dmp::Header_t::ExpectedSignature)
      .def_ro_static("ValidFlagsMask",
                     &udmpparser::dmp::Header_t::ValidFlagsMask)
      .def_ro("Signature", &udmpparser::dmp::Header_t::Signature)
      .def_ro("Version", &udmpparser::dmp::Header_t::Version)
      .def_ro("ImplementationVersion",
              &udmpparser::dmp::Header_t::ImplementationVersion)
      .def_ro("NumberOfStreams", &udmpparser::dmp::Header_t::NumberOfStreams)
      .def_ro("StreamDirectoryRva",
              &udmpparser::dmp::Header_t::StreamDirectoryRva)
      .def_ro("CheckSum", &udmpparser::dmp::Header_t::CheckSum)
      .def_ro("Reserved", &udmpparser::dmp::Header_t::Reserved)
      .def_ro("TimeDateStamp", &udmpparser::dmp::Header_t::TimeDateStamp)
      .def_ro("Flags", &udmpparser::dmp::Header_t::Flags)
      .def("LooksGood", &udmpparser::dmp::Header_t::LooksGood);

  nb::class_<udmpparser::dmp::LocationDescriptor32_t>(m, "LocationDescriptor32")
      .def_ro("DataSize", &udmpparser::dmp::LocationDescriptor32_t::DataSize)
      .def_ro("Rva", &udmpparser::dmp::LocationDescriptor32_t::Rva);

  nb::class_<udmpparser::dmp::LocationDescriptor64_t>(m, "LocationDescriptor64")
      .def_ro("DataSize", &udmpparser::dmp::LocationDescriptor64_t::DataSize)
      .def_ro("Rva", &udmpparser::dmp::LocationDescriptor64_t::Rva);

  nb::enum_<udmpparser::dmp::StreamType_t>(m, "StreamType")
      .value("Unused", udmpparser::dmp::StreamType_t::Unused)
      .value("ThreadList", udmpparser::dmp::StreamType_t::ThreadList)
      .value("ModuleList", udmpparser::dmp::StreamType_t::ModuleList)
      .value("Exception", udmpparser::dmp::StreamType_t::Exception)
      .value("SystemInfo", udmpparser::dmp::StreamType_t::SystemInfo)
      .value("Memory64List", udmpparser::dmp::StreamType_t::Memory64List)
      .value("MemoryInfoList", udmpparser::dmp::StreamType_t::MemoryInfoList)
      .export_values();

  nb::class_<udmpparser::dmp::Directory_t>(m, "Directory")
      .def_ro("StreamType", &udmpparser::dmp::Directory_t::StreamType)
      .def_ro("Location", &udmpparser::dmp::Directory_t::Location);

  nb::class_<udmpparser::dmp::MemoryInfoListStream_t>(m, "MemoryInfoListStream")
      .def_ro("SizeOfHeader",
              &udmpparser::dmp::MemoryInfoListStream_t::SizeOfHeader)
      .def_ro("SizeOfEntry",
              &udmpparser::dmp::MemoryInfoListStream_t::SizeOfEntry)
      .def_ro("NumberOfEntries",
              &udmpparser::dmp::MemoryInfoListStream_t::NumberOfEntries);

  nb::class_<udmpparser::dmp::Memory64ListStreamHdr_t>(m,
                                                       "Memory64ListStreamHdr")
      .def_ro("NumberOfMemoryRanges",
              &udmpparser::dmp::Memory64ListStreamHdr_t::NumberOfMemoryRanges)
      .def_ro("BaseRva", &udmpparser::dmp::Memory64ListStreamHdr_t::BaseRva);

  nb::class_<udmpparser::dmp::MemoryDescriptor64_t>(m, "MemoryDescriptor64")
      .def_ro("StartOfMemoryRange",
              &udmpparser::dmp::MemoryDescriptor64_t::StartOfMemoryRange)
      .def_ro("DataSize", &udmpparser::dmp::MemoryDescriptor64_t::DataSize);

  nb::class_<udmpparser::dmp::FixedFileInfo_t>(m, "FixedFileInfo")
      .def_ro("Signature", &udmpparser::dmp::FixedFileInfo_t::Signature)
      .def_ro("StrucVersion", &udmpparser::dmp::FixedFileInfo_t::StrucVersion)
      .def_ro("FileVersionMS", &udmpparser::dmp::FixedFileInfo_t::FileVersionMS)
      .def_ro("FileVersionLS", &udmpparser::dmp::FixedFileInfo_t::FileVersionLS)
      .def_ro("ProductVersionMS",
              &udmpparser::dmp::FixedFileInfo_t::ProductVersionMS)
      .def_ro("ProductVersionLS",
              &udmpparser::dmp::FixedFileInfo_t::ProductVersionLS)
      .def_ro("FileFlagsMask", &udmpparser::dmp::FixedFileInfo_t::FileFlagsMask)
      .def_ro("FileFlags", &udmpparser::dmp::FixedFileInfo_t::FileFlags)
      .def_ro("FileOS", &udmpparser::dmp::FixedFileInfo_t::FileOS)
      .def_ro("FileType", &udmpparser::dmp::FixedFileInfo_t::FileType)
      .def_ro("FileSubtype", &udmpparser::dmp::FixedFileInfo_t::FileSubtype)
      .def_ro("FileDateMS", &udmpparser::dmp::FixedFileInfo_t::FileDateMS)
      .def_ro("FileDateLS", &udmpparser::dmp::FixedFileInfo_t::FileDateLS);

  nb::class_<udmpparser::dmp::MemoryInfo_t>(m, "MemoryInfo")
      .def_ro("BaseAddress", &udmpparser::dmp::MemoryInfo_t::BaseAddress)
      .def_ro("AllocationBase", &udmpparser::dmp::MemoryInfo_t::AllocationBase)
      .def_ro("AllocationProtect",
              &udmpparser::dmp::MemoryInfo_t::AllocationProtect)
      .def_ro("RegionSize", &udmpparser::dmp::MemoryInfo_t::RegionSize)
      .def_ro("State", &udmpparser::dmp::MemoryInfo_t::State)
      .def_ro("Protect", &udmpparser::dmp::MemoryInfo_t::Protect)
      .def_ro("Type", &udmpparser::dmp::MemoryInfo_t::Type);

  nb::class_<udmpparser::dmp::MemoryDescriptor_t>(m, "MemoryDescriptor")
      .def_ro("StartOfMemoryRange",
              &udmpparser::dmp::MemoryDescriptor_t::StartOfMemoryRange)
      .def_ro("Memory", &udmpparser::dmp::MemoryDescriptor_t::Memory);

  nb::class_<udmpparser::dmp::ThreadEntry_t>(m, "ThreadEntry")
      .def_ro("ThreadId", &udmpparser::dmp::ThreadEntry_t::ThreadId)
      .def_ro("SuspendCount", &udmpparser::dmp::ThreadEntry_t::SuspendCount)
      .def_ro("PriorityClass", &udmpparser::dmp::ThreadEntry_t::PriorityClass)
      .def_ro("Priority", &udmpparser::dmp::ThreadEntry_t::Priority)
      .def_ro("Teb", &udmpparser::dmp::ThreadEntry_t::Teb)
      .def_ro("Stack", &udmpparser::dmp::ThreadEntry_t::Stack)
      .def_ro("ThreadContext", &udmpparser::dmp::ThreadEntry_t::ThreadContext);

  nb::class_<udmpparser::dmp::SystemInfoStream_t>(m, "SystemInfoStream")
      .def_ro("ProcessorArchitecture",
              &udmpparser::dmp::SystemInfoStream_t::ProcessorArchitecture)
      .def_ro("ProcessorLevel ",
              &udmpparser::dmp::SystemInfoStream_t::ProcessorLevel)
      .def_ro("ProcessorRevision ",
              &udmpparser::dmp::SystemInfoStream_t::ProcessorRevision)
      .def_ro("NumberOfProcessors ",
              &udmpparser::dmp::SystemInfoStream_t::NumberOfProcessors)
      .def_ro("ProductType ", &udmpparser::dmp::SystemInfoStream_t::ProductType)
      .def_ro("MajorVersion ",
              &udmpparser::dmp::SystemInfoStream_t::MajorVersion)
      .def_ro("MinorVersion ",
              &udmpparser::dmp::SystemInfoStream_t::MinorVersion)
      .def_ro("BuildNumber ", &udmpparser::dmp::SystemInfoStream_t::BuildNumber)
      .def_ro("PlatformId ", &udmpparser::dmp::SystemInfoStream_t::PlatformId)
      .def_ro("CSDVersionRva ",
              &udmpparser::dmp::SystemInfoStream_t::CSDVersionRva)
      .def_ro("SuiteMask ", &udmpparser::dmp::SystemInfoStream_t::SuiteMask)
      .def_ro("Reserved2 ", &udmpparser::dmp::SystemInfoStream_t::Reserved2);

  nb::class_<udmpparser::dmp::ExceptionRecord_t>(m, "ExceptionRecord")
      .def_ro("ExceptionCode",
              &udmpparser::dmp::ExceptionRecord_t::ExceptionCode)
      .def_ro("ExceptionFlags",
              &udmpparser::dmp::ExceptionRecord_t::ExceptionFlags)
      .def_ro("ExceptionRecord",
              &udmpparser::dmp::ExceptionRecord_t::ExceptionRecord)
      .def_ro("ExceptionAddress",
              &udmpparser::dmp::ExceptionRecord_t::ExceptionAddress)
      .def_ro("NumberParameters",
              &udmpparser::dmp::ExceptionRecord_t::NumberParameters)
      .def_ro("ExceptionInformation",
              &udmpparser::dmp::ExceptionRecord_t::ExceptionInformation);

  nb::class_<udmpparser::dmp::ExceptionStream_t>(m, "ExceptionStream")
      .def(nb::init<>())
      .def_ro("ThreadId", &udmpparser::dmp::ExceptionStream_t::ThreadId)
      .def_ro("ExceptionRecord",
              &udmpparser::dmp::ExceptionStream_t::ExceptionRecord)
      .def_ro("ThreadContext",
              &udmpparser::dmp::ExceptionStream_t::ThreadContext);

  nb::class_<udmpparser::FileMapReader_t>(m, "FileMapReader")
      .def(nb::init<>())
      .def("ViewSize", &udmpparser::FileMapReader_t::ViewSize)
      .def("MapFile", &udmpparser::FileMapReader_t::MapFile);

  nb::enum_<udmpparser::Arch_t>(m, "Arch")
      .value("X86", udmpparser::Arch_t::X86)
      .value("X64", udmpparser::Arch_t::X64)
      .export_values();

  nb::class_<udmpparser::MemBlock_t>(m, "MemBlock")
      .def(nb::init<const udmpparser::dmp::MemoryInfo_t &>())
      .def_ro("BaseAddress", &udmpparser::MemBlock_t::BaseAddress)
      .def_ro("AllocationBase", &udmpparser::MemBlock_t::AllocationBase)
      .def_ro("AllocationProtect", &udmpparser::MemBlock_t::AllocationProtect)
      .def_ro("RegionSize", &udmpparser::MemBlock_t::RegionSize)
      .def_ro("State", &udmpparser::MemBlock_t::State)
      .def_ro("Protect", &udmpparser::MemBlock_t::Protect)
      .def_ro("Type", &udmpparser::MemBlock_t::Type)
      .def_ro("DataOffset", &udmpparser::MemBlock_t::DataOffset)
      .def_ro("DataSize", &udmpparser::MemBlock_t::DataSize)
      .def("__repr__", &udmpparser::MemBlock_t::to_string);

  nb::class_<udmpparser::Module_t>(m, "Module")
      .def(nb::init<const udmpparser::dmp::ModuleEntry_t &, const std::string &,
                    std::vector<uint8_t>, std::vector<uint8_t>>(),
           nb::rv_policy::take_ownership)
      .def_ro("BaseOfImage", &udmpparser::Module_t::BaseOfImage)
      .def_ro("SizeOfImage", &udmpparser::Module_t::SizeOfImage)
      .def_ro("CheckSum", &udmpparser::Module_t::CheckSum)
      .def_ro("TimeDateStamp", &udmpparser::Module_t::TimeDateStamp)
      .def_ro("ModuleName", &udmpparser::Module_t::ModuleName)
      .def_ro("VersionInfo", &udmpparser::Module_t::VersionInfo)
      .def_ro("CvRecord", &udmpparser::Module_t::CvRecord)
      .def_ro("MiscRecord", &udmpparser::Module_t::MiscRecord)
      .def("__repr__", &udmpparser::Module_t::to_string);

  nb::class_<udmpparser::UnknownContext_t>(m, "UnknownContext");

  nb::class_<udmpparser::Thread_t>(m, "Thread")
      .def(nb::init<const udmpparser::dmp::ThreadEntry_t &,
                    udmpparser::UnknownContext_t &>())
      .def(nb::init<const udmpparser::dmp::ThreadEntry_t &,
                    udmpparser::Context32_t &>())
      .def(nb::init<const udmpparser::dmp::ThreadEntry_t &,
                    udmpparser::Context64_t &>())
      .def_ro("ThreadId", &udmpparser::Thread_t::ThreadId)
      .def_ro("SuspendCount", &udmpparser::Thread_t::SuspendCount)
      .def_ro("PriorityClass", &udmpparser::Thread_t::PriorityClass)
      .def_ro("Priority", &udmpparser::Thread_t::Priority)
      .def_ro("Teb", &udmpparser::Thread_t::Teb)
      .def_ro("Context", &udmpparser::Thread_t::Context)
      .def("__repr__", &udmpparser::Thread_t::to_string);

  nb::class_<udmpparser::UserDumpParser>(m, "UserDumpParser")
      .def(nb::init<>())
      .def("Parse",
           nb::overload_cast<const fs::path &>(
               &udmpparser::UserDumpParser::Parse),
           "Parse the minidump given in argument.")
      .def("Modules", &udmpparser::UserDumpParser::GetModules,
           nb::rv_policy::reference, "Get the minidump modules")
      .def("Memory", &udmpparser::UserDumpParser::GetMem,
           nb::rv_policy::reference)
      .def("Threads", &udmpparser::UserDumpParser::GetThreads,
           "Get the minidump threads")
      .def("ForegroundThreadId",
           &udmpparser::UserDumpParser::GetForegroundThreadId)
      .def("GetMemoryBlock",
           nb::overload_cast<const uint64_t>(
               &udmpparser::UserDumpParser::GetMemBlock, nb::const_),
           "Access a specific MemoryBlock")
      .def("ReadMemory", &udmpparser::UserDumpParser::ReadMemory,
           "Read bytes from memory")
      .def("__repr__", &udmpparser::UserDumpParser::to_string);

  nb::class_<udmpparser::Version>(m, "version")
      .def_ro_static("major", &udmpparser::Version::Major)
      .def_ro_static("minor", &udmpparser::Version::Minor)
      .def_ro_static("release", &udmpparser::Version::Release);
}

```

`src/python/src/udmp_parser_utils.cc`:

```cc
//
// This file is part of udmp-parser project
//
// Released under MIT License, by 0vercl0k - 2023
//
// With contribution from:
//  * hugsy - (github.com/hugsy)
//

#include "udmp-parser.h"

#include <filesystem>
#include <memory>
#include <nanobind/nanobind.h>
#include <nanobind/stl/filesystem.h>
#include <nanobind/stl/string.h>

namespace nb = nanobind;

#ifdef _WIN32
#include <dbghelp.h>
#include <windows.h>

bool GenerateMinidumpFromProcessId(
    const uint32_t TargetPid, const std::filesystem::path &MiniDumpFilePath) {
  const HANDLE File =
      CreateFileA(MiniDumpFilePath.string().c_str(), GENERIC_WRITE, 0, nullptr,
                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
  if (File == INVALID_HANDLE_VALUE) {
    return false;
  }

  const HANDLE Process = OpenProcess(PROCESS_ALL_ACCESS, false, TargetPid);
  if (Process == INVALID_HANDLE_VALUE) {
    CloseHandle(File);
    return false;
  }

  MINIDUMP_EXCEPTION_INFORMATION ExceptionInfo = {};
  const auto Flags = MINIDUMP_TYPE::MiniDumpWithFullMemory |
                     MINIDUMP_TYPE::MiniDumpWithDataSegs |
                     MINIDUMP_TYPE::MiniDumpScanMemory |
                     MINIDUMP_TYPE::MiniDumpWithHandleData |
                     MINIDUMP_TYPE::MiniDumpWithFullMemoryInfo;

  const auto Success =
      MiniDumpWriteDump(Process, TargetPid, File, MINIDUMP_TYPE(Flags),
                        &ExceptionInfo, nullptr, nullptr);

  CloseHandle(Process);
  CloseHandle(File);
  return Success;
}
#endif

void udmp_parser_utils_module(nb::module_ &m) {
  auto utils = m.def_submodule("utils", "Helper functions");

  utils.def(
      "TypeToString",
      [](const uint32_t Type) -> std::string {
        switch (Type) {
        case 0x2'00'00: {
          return "MEM_PRIVATE";
        }
        case 0x4'00'00: {
          return "MEM_MAPPED";
        }
        case 0x1'00'00'00: {
          return "MEM_IMAGE";
        }
        }
        return "";
      },
      "Get a string representation of the memory type");

  utils.def(
      "StateToString",
      [](const uint32_t State) {
        switch (State) {
        case 0x10'00: {
          return "MEM_COMMIT";
        }

        case 0x20'00: {
          return "MEM_RESERVE";
        }

        case 0x1'00'00: {
          return "MEM_FREE";
        }
        }
        return "";
      },
      "Get a string representation of the memory state");

  utils.def(
      "ProtectionToString",
      [](const uint32_t Protection) {
        struct {
          const char *Name = nullptr;
          uint32_t Mask = 0;
        } Flags[] = {
            {"PAGE_NOACCESS", 0x01},
            {"PAGE_READONLY", 0x02},
            {"PAGE_READWRITE", 0x04},
            {"PAGE_WRITECOPY", 0x08},
            {"PAGE_EXECUTE", 0x10},
            {"PAGE_EXECUTE_READ", 0x20},
            {"PAGE_EXECUTE_READWRITE", 0x40},
            {"PAGE_EXECUTE_WRITECOPY", 0x80},
            {"PAGE_GUARD", 0x100},
            {"PAGE_NOCACHE", 0x200},
            {"PAGE_WRITECOMBINE", 0x400},
            {"PAGE_TARGETS_INVALID", 0x4000'0000},
        };
        std::stringstream ss;
        uint32_t KnownFlags = 0;

        for (const auto &Flag : Flags) {
          if ((Protection & Flag.Mask) == 0) {
            continue;
          }

          ss << Flag.Name << ",";
          KnownFlags |= Flag.Mask;
        }

        const uint32_t MissingFlags = (~KnownFlags) & Protection;
        if (MissingFlags) {
          ss << std::hex << "0x" << MissingFlags;
        }

        std::string ProtectionString = ss.str();
        if (ProtectionString.size() > 1 &&
            ProtectionString[ProtectionString.size() - 1] == ',') {
          ProtectionString =
              ProtectionString.substr(0, ProtectionString.size() - 1);
        }

        return ProtectionString;
      },
      "Get a string representation of the memory protection");

#if defined(_WIN32)
  utils.def("generate_minidump", GenerateMinidumpFromProcessId, "TargetPid",
            "MiniDumpFilePath",
            "Generate a minidump for TargetPid and save it to the given path. "
            "Returns true on success.");

  utils.def(
      "generate_minidump_from_command_line",
      []() -> bool {
        nb::module_ sys = nb::module_::import_("sys");
        nb::list argv = sys.attr("argv");
        if (!argv.is_valid()) {
          return false;
        }

        if (argv.size() != 3) {
          return false;
        }

        auto a1 = nb::str(nb::handle(argv[1]));
        const auto TargetPid = uint32_t(std::atol(a1.c_str()));
        auto a2 = nb::str(nb::handle(argv[2]));
        return GenerateMinidumpFromProcessId(TargetPid, a2.c_str());
      },
      "Generate a minidump for the target TargetPid, write it to the given "
      "path. Returns true on success.");
#endif // _WIN32
}

```

`src/python/tests/pytest.ini`:

```ini
[pytest]
log_level = INFO
minversion = 6.0
required_plugins =
    pytest-xdist
    pytest-cov
python_functions =
    test_*
    time_*
python_files = *.py
testpaths =
    .
markers =
    slow: flag test as slow (deselect with '-m "not slow"')
    online: flag test as requiring internet to work (deselect with '-m "not online"')

```

`src/python/tests/requirements.txt`:

```txt
pytest
pytest-cov
pytest-xdist
pytest-forked
coverage
lief

```

`src/python/tests/test_parser.py`:

```py
#
# This file is part of udmp-parser project
#
# Released under MIT License, by 0vercl0k - 2023
#
# With contribution from:
# * hugsy - (github.com/hugsy)
#

import lief
import pathlib
import platform
import pytest
import subprocess
import tempfile
import time
import unittest

# format: on
import udmp_parser  # type: ignore
from .utils import generate_minidump_from_process_name  # type: ignore

# format: off

TARGET_PROCESS_NAME: str = "winver.exe"
TARGET_PROCESS_PATH: pathlib.Path = pathlib.Path(
    f"C:/Windows/System32/{TARGET_PROCESS_NAME}"
)


@pytest.mark.skipif(
    platform.system().lower() != "windows", reason="Tests only for Windows"
)
class TestParserBasic(unittest.TestCase):
    def setUp(self):
        # TODO switch to LFS to store minidump test cases (x86, x64, wow64, etc.)
        self.process = subprocess.Popen(
            [
                TARGET_PROCESS_PATH,
            ]
        )
        time.sleep(1)
        self.tempdir = tempfile.TemporaryDirectory(prefix="minidump_")
        self.tempdir_path = pathlib.Path(self.tempdir.name)
        res = generate_minidump_from_process_name(
            TARGET_PROCESS_NAME, self.tempdir_path
        )
        assert res
        _, self.minidump_file = res
        assert self.minidump_file.exists()

    def tearDown(self) -> None:
        self.process.kill()
        return super().tearDown()

    def test_version(self):
        assert udmp_parser.version.major == 0
        assert udmp_parser.version.minor == 7
        assert udmp_parser.version.release == ""

    def test_parser_basic(self):
        parser = udmp_parser.UserDumpParser()
        assert parser.ForegroundThreadId() is None
        assert len(parser.Threads()) == 0
        assert len(parser.Memory()) == 0
        assert parser.Parse(self.minidump_file)
        assert len(parser.Threads())
        assert len(parser.Memory())
        assert len(parser.Modules())

    def test_threads(self):
        parser = udmp_parser.UserDumpParser()
        assert parser.Parse(self.minidump_file)
        threads = parser.Threads()
        assert len(threads)

        for _, thread in threads.items():
            assert thread.ThreadId, "invalid ThreadId field"
            assert thread.Teb, "invalid Teb field"
            assert not isinstance(
                thread.Context, udmp_parser.UnknownContext
            ), "invalid Context field"
            if isinstance(thread.Context, udmp_parser.Context32):
                assert thread.Context.Esp
                assert thread.Context.Eip
            elif isinstance(thread.Context, udmp_parser.Context64):
                assert thread.Context.Rsp
                assert thread.Context.Rip
            else:
                assert False, "invalid Context field"

    def test_modules(self):
        parser = udmp_parser.UserDumpParser()
        assert parser.Parse(self.minidump_file)
        modules = parser.Modules()
        assert len(modules)

        ntdll_modules = [
            mod
            for _, mod in modules.items()
            if mod.ModuleName.lower().endswith("ntdll.dll")
        ]
        kernel32_modules = [
            mod
            for _, mod in modules.items()
            if mod.ModuleName.lower().endswith("kernel32.dll")
        ]

        assert len(ntdll_modules) >= 1
        assert len(kernel32_modules) >= 1

        for mod in ntdll_modules + kernel32_modules:
            assert mod.BaseOfImage > 0, f"Invalid BaseOfImage for '{mod}'"
            assert mod.SizeOfImage > 0, f"Invalid SizeOfImage for '{mod}'"
            module_raw = parser.ReadMemory(mod.BaseOfImage, mod.SizeOfImage)
            img = lief.PE.parse(module_raw)
            assert img
            assert img.header.numberof_sections
            assert img.optional_header.sizeof_code
            assert img.optional_header.imagebase

    def test_memory(self):
        parser = udmp_parser.UserDumpParser()
        assert parser.Parse(self.minidump_file)
        memory_regions = parser.Memory()
        assert len(memory_regions)

    def test_memory_inexistent(self):
        """This ensures that `ReadMemory` returns `None` when trying to
        read a segment of memory that isn't described in the dump file."""
        parser = udmp_parser.UserDumpParser()
        assert parser.Parse(self.minidump_file)
        assert parser.ReadMemory(0xDEADBEEF_BAADC0DE, 0x10) is None

    def test_memory_empty(self):
        """This ensures that `ReadMemory` returns an empty array (and not `None`)
        when trying to read into a memory region that has no data associated."""
        parser = udmp_parser.UserDumpParser()
        assert parser.Parse(self.minidump_file)
        mem = parser.Memory()
        empty_regions = list(filter(lambda m: m.DataSize == 0, mem.values()))
        assert len(empty_regions) > 0
        empty_region = empty_regions[0]
        assert len(parser.ReadMemory(empty_region.BaseAddress, 0x10)) == 0

    def test_utils(self):
        assert udmp_parser.utils.TypeToString(0x2_0000) == "MEM_PRIVATE"
        assert udmp_parser.utils.TypeToString(0x4_0000) == "MEM_MAPPED"
        assert udmp_parser.utils.TypeToString(0x100_0000) == "MEM_IMAGE"
        assert udmp_parser.utils.TypeToString(0x41414141) == ""

        assert udmp_parser.utils.StateToString(0x1000) == "MEM_COMMIT"
        assert udmp_parser.utils.StateToString(0x2000) == "MEM_RESERVE"
        assert udmp_parser.utils.StateToString(0x10000) == "MEM_FREE"
        assert udmp_parser.utils.StateToString(0x41414141) == ""

        assert udmp_parser.utils.ProtectionToString(0x01) == "PAGE_NOACCESS"
        assert udmp_parser.utils.ProtectionToString(0x02) == "PAGE_READONLY"
        assert udmp_parser.utils.ProtectionToString(0x04) == "PAGE_READWRITE"
        assert udmp_parser.utils.ProtectionToString(0x08) == "PAGE_WRITECOPY"
        assert udmp_parser.utils.ProtectionToString(0x10) == "PAGE_EXECUTE"
        assert udmp_parser.utils.ProtectionToString(
            0x20) == "PAGE_EXECUTE_READ"
        assert udmp_parser.utils.ProtectionToString(
            0x40) == "PAGE_EXECUTE_READWRITE"
        assert udmp_parser.utils.ProtectionToString(
            0x80) == "PAGE_EXECUTE_WRITECOPY"
        assert (
            udmp_parser.utils.ProtectionToString(
                0x18) == "PAGE_WRITECOPY,PAGE_EXECUTE"
        )
        assert (
            udmp_parser.utils.ProtectionToString(0x19)
            == "PAGE_NOACCESS,PAGE_WRITECOPY,PAGE_EXECUTE"
        )
        assert (
            udmp_parser.utils.ProtectionToString(0x44_0000 | 0x19)
            == "PAGE_NOACCESS,PAGE_WRITECOPY,PAGE_EXECUTE,0x440000"
        )

```

`src/python/tests/utils.py`:

```py
#
# This file is part of udmp-parser project
#
# Released under MIT License, by 0vercl0k - 2023
#
# With contribution from:
# * hugsy - (github.com/hugsy)
#

import pathlib
import ctypes
from ctypes import wintypes
import time
from typing import Optional, Tuple

import udmp_parser


def get_process_id(process_name: str):
    kernel32 = ctypes.WinDLL("kernel32")
    CreateToolhelp32Snapshot = kernel32.CreateToolhelp32Snapshot
    Process32First = kernel32.Process32First
    Process32Next = kernel32.Process32Next
    CloseHandle = kernel32.CloseHandle

    TH32CS_SNAPPROCESS = 0x00000002
    MAX_PATH = 260

    class PROCESSENTRY32(ctypes.Structure):
        _fields_ = [
            ("dwSize", wintypes.DWORD),
            ("cntUsage", wintypes.DWORD),
            ("th32ProcessID", wintypes.DWORD),
            ("th32DefaultHeapID", wintypes.LPVOID),
            ("th32ModuleID", wintypes.DWORD),
            ("cntThreads", wintypes.DWORD),
            ("th32ParentProcessID", wintypes.DWORD),
            ("pcPriClassBase", wintypes.LONG),
            ("dwFlags", wintypes.DWORD),
            ("szExeFile", wintypes.CHAR * MAX_PATH),
        ]

    snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
    if snapshot == -1:
        return None

    pe32 = PROCESSENTRY32()
    pe32.dwSize = ctypes.sizeof(PROCESSENTRY32)

    if Process32First(snapshot, ctypes.byref(pe32)) == 0:
        CloseHandle(snapshot)
        return None

    res = None
    while True:
        process_name_str = pe32.szExeFile.decode("utf-8").lower()
        if process_name.lower() == process_name_str:
            res = pe32.th32ProcessID
            break

        if Process32Next(snapshot, ctypes.byref(pe32)) == 0:
            break

    CloseHandle(snapshot)
    return res


def generate_minidump_from_process_name(
    process_name: str = "explorer.exe", output_dir: pathlib.Path = pathlib.Path(".")
) -> Optional[Tuple[int, pathlib.Path]]:
    process_id = get_process_id(process_name)
    if not process_id or not isinstance(process_id, int):
        return None

    dump_file_path = output_dir / f"minidump-{process_name}-{int(time.time())}.dmp"

    if not udmp_parser.utils.generate_minidump(process_id, dump_file_path):
        return None

    print(f"Minidump generated successfully: PID={process_id} -> {dump_file_path}")
    return (process_id, dump_file_path)

```

`src/python/udmp_parser-stubs/__init__.pyi`:

```pyi
import os
from typing import Union, Optional, overload
from enum import Enum, IntEnum
import udmp_parser


class ProcessorArch(IntEnum):
    X86 = 0
    ARM = 5
    IA64 = 6
    AMD64 = 9
    Unknown = 0xFFFF


class Arch(IntEnum):
    X86 = 0
    X64 = 1


kWOW64_SIZE_OF_80387_REGISTERS: int = 80


class FloatingSaveArea32:
    ControlWord: int
    StatusWord: int
    TagWord: int
    ErrorOffset: int
    ErrorSelector: int
    DataOffset: int
    DataSelector: int
    RegisterArea: bytearray  # size =kWOW64_SIZE_OF_80387_REGISTERS
    Cr0NpxState: int


class Context32:
    ContextFlags: int
    Dr0: int
    Dr1: int
    Dr2: int
    Dr3: int
    Dr6: int
    Dr7: int
    FloatSave: FloatingSaveArea32
    SegGs: int
    SegFs: int
    SegEs: int
    SegDs: int
    Edi: int
    Esi: int
    Ebx: int
    Edx: int
    Ecx: int
    Eax: int
    Ebp: int
    Eip: int
    SegCs: int
    EFlags: int
    Esp: int
    SegSs: int
    ExtendedRegisters: bytearray  # size =kWOW64_MAXIMUM_SUPPORTED_EXTENSION


class uint128_t:
    Low: int
    High: int


class Context64:
    P1Home: int
    P2Home: int
    P3Home: int
    P4Home: int
    P5Home: int
    P6Home: int
    ContextFlags: int
    MxCsr: int
    SegCs: int
    SegDs: int
    SegEs: int
    SegFs: int
    SegGs: int
    SegSs: int
    EFlags: int
    Dr0: int
    Dr1: int
    Dr2: int
    Dr3: int
    Dr6: int
    Dr7: int
    Rax: int
    Rcx: int
    Rdx: int
    Rbx: int
    Rsp: int
    Rbp: int
    Rsi: int
    Rdi: int
    R8: int
    R9: int
    R10: int
    R11: int
    R12: int
    R13: int
    R14: int
    R15: int
    Rip: int
    ControlWord: int
    StatusWord: int
    TagWord: int
    Reserved1: int
    ErrorOpcode: int
    ErrorOffset: int
    ErrorSelector: int
    Reserved2: int
    DataOffset: int
    DataSelector: int
    Reserved3: int
    MxCsr2: int
    MxCsr_Mask: int
    FloatRegisters: list[uint128_t]  # size =8
    Xmm0: uint128_t
    Xmm1: uint128_t
    Xmm2: uint128_t
    Xmm3: uint128_t
    Xmm4: uint128_t
    Xmm5: uint128_t
    Xmm6: uint128_t
    Xmm7: uint128_t
    Xmm8: uint128_t
    Xmm9: uint128_t
    Xmm10: uint128_t
    Xmm11: uint128_t
    Xmm12: uint128_t
    Xmm13: uint128_t
    Xmm14: uint128_t
    Xmm15: uint128_t
    Padding: bytearray  # size =0x60
    VectorRegister: list[uint128_t]  # size =26
    VectorControl: int
    DebugControl: int
    LastBranchToRip: int
    LastBranchFromRip: int
    LastExceptionToRip: int
    LastExceptionFromRip: int


class Directory:
    StreamType: StreamType = StreamType.Unused
    LocationDescriptor32_t: int


class FileMapReader:
    def MapFile(self, arg: str, /) -> bool: ...
    def ViewSize(self) -> int: ...
    def __init__(self) -> None: ...


class FixedFileInfo:
    Signature: int = 0
    StrucVersion: int = 0
    FileVersionMS: int = 0
    FileVersionLS: int = 0
    ProductVersionMS: int = 0
    ProductVersionLS: int = 0
    FileFlagsMask: int = 0
    FileFlags: int = 0
    FileOS: int = 0
    FileType: int = 0
    FileSubtype: int = 0
    FileDateMS: int = 0
    FileDateLS: int = 0


class Header:
    Signature: int
    Version: int
    ImplementationVersion: int
    NumberOfStreams: int
    StreamDirectoryRva: int
    CheckSum: int
    Reserved: int
    TimeDateStamp: int
    Flags: int
    ExpectedSignature: int
    ValidFlagsMask: int

    def LooksGood(self) -> bool: ...

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


class LocationDescriptor32:
    DataSize: int
    Rva: int

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


class LocationDescriptor64:
    DataSize: int
    Rva: int

    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


class MemBlock:
    BaseAddress: int
    AllocationBase: int
    AllocationProtect: int
    RegionSize: int
    State: int
    Protect: int
    Type: int
    DataOffset: int
    DataSize: int

    def __init__(self, arg: udmp_parser.MemoryInfo, /) -> None: ...
    def __str__(self) -> str: ...


class Memory64ListStreamHdr:
    StartOfMemoryRange: int
    DataSize: int


class MemoryDescriptor:
    ThreadId: int
    SuspendCount: int
    PriorityClass: int
    Priority: int
    Teb: int
    Stack: MemoryDescriptor
    ThreadContext: LocationDescriptor32


class ThreadEntry:
    ThreadId: int
    SuspendCount: int
    PriorityClass: int
    Priority: int
    Teb: int
    Stack: MemoryDescriptor
    ThreadContext: LocationDescriptor32


class Thread_t:
    ThreadId: int
    SuspendCount: int
    PriorityClass: int
    Priority: int
    Teb: int
    Context: Union[UnknownContext, Context32, Context64]


class MemoryDescriptor64:
    StartOfMemoryRange: int
    DataSize: int


class MemoryInfoListStream:
    SizeOfHeader: int
    SizeOfEntry: int
    NumberOfEntries: int


class MemoryInfo:
    BaseAddress: int
    AllocationBase: int
    AllocationProtect: int
    __alignment1: int
    RegionSize: int
    State: int
    Protect: int
    Type: int
    __alignment2: int


class Module:
    BaseAddress: int
    AllocationBase: int
    AllocationProtect: int
    RegionSize: int
    State: int
    Protect: int
    Type: int
    DataSize: int

    @property
    def Data(self) -> int: ...
    def __str__(self) -> str: ...


class StreamType(IntEnum):
    Unused = 0
    ThreadList = 3
    ModuleList = 4
    Exception = 6
    SystemInfo = 7
    Memory64List = 9
    MemoryInfoList = 16


class SystemInfoStream:
    ProcessorArchitecture: ProcessorArch
    ProcessorLevel: int
    ProcessorRevision: int
    NumberOfProcessors: int
    ProductType: int
    MajorVersion: int
    MinorVersion: int
    BuildNumber: int
    PlatformId: int
    CSDVersionRva: int
    SuiteMask: int
    Reserved2: int


class ExceptionRecord:
    ExceptionCode: int
    ExceptionFlags: int
    ExceptionRecord: int
    ExceptionAddress: int
    NumberParameters: int
    __unusedAlignment: int
    ExceptionInformation: list[int]  # size=kEXCEPTION_MAXIMUM_PARAMETERS


class ExceptionStream:
    ThreadId: int
    __alignment: int
    ExceptionRecord: ExceptionRecord
    ThreadContext: LocationDescriptor32


class UnknownContext:
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


class UserDumpParser:
    def ForegroundThreadId(self) -> Optional[int]: ...

    def GetMemoryBlock(self, arg: int, /) -> udmp_parser.MemBlock:
        """
        Access a specific MemoryBlock
        """
        ...

    def Memory(self) -> dict[int, udmp_parser.MemBlock]: ...

    def Modules(self) -> dict[int, udmp_parser.Modules]:
        """
        Get the minidump modules
        """
        ...

    def Parse(self, arg: os.PathLike, /) -> bool:
        """
        Parse the minidump given in argument.
        """
        ...

    def ReadMemory(self, arg0: int, arg1: int, /) -> Optional[list[int]]:
        """
        Read bytes from memory
        """
        ...

    def Threads(self) -> dict[int, udmp_parser.Thread]:
        """
        Get the minidump threads
        """
        ...

    def __init__(self) -> None: ...


class version:
    def __init__(*args, **kwargs):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    major: int

    minor: int

    release: str

```

`src/python/udmp_parser-stubs/utils.pyi`:

```pyi
import os


def ProtectionToString(arg: int, /) -> str:
    """
    Get a string representation of the memory protection
    """
    ...


def StateToString(arg: int, /) -> str:
    """
    Get a string representation of the memory state
    """
    ...


def TypeToString(arg: int, /) -> str:
    """
    Get a string representation of the memory type
    """
    ...


def generate_minidump(TargetPid: int, MiniDumpFilePath: os.PathLike) -> bool:
    """
    Generate a minidump for TargetPid and save it to the given path. Returns true on success.
    """
    ...


def generate_minidump_from_command_line() -> bool:
    """
    Generate a minidump for the target TargetPid, write it to the given path. Returns true on success.
    """
    ...

```