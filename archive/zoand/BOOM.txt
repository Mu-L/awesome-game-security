Project Path: arc_zoand_BOOM_uvrphi5q

Source Tree:

```txt
arc_zoand_BOOM_uvrphi5q
├── BOOM.cpp
├── BOOM.inf
├── BOOM.sln
├── BOOM.v12.suo
├── BOOM.vcxproj
├── BOOM.vcxproj.filters
├── BOOM.vcxproj.user
├── BOOM_Console
│   ├── BOOM_Console.vcxproj
│   ├── BOOM_Console.vcxproj.filters
│   ├── BOOM_Console.vcxproj.user
│   ├── BoomDef.h
│   ├── BoomSDK.cpp
│   ├── BoomSDK.h
│   ├── CDrvController.cpp
│   ├── CDrvController.h
│   ├── CDrvLoader.cpp
│   ├── CDrvLoader.h
│   └── Console.cpp
├── README.md
├── cmpcallback.c
├── cmpcallback.h
├── driver.c
├── global.h
├── inc
│   └── inc.h
├── obcallback.c
├── obcallback.h
├── regStruct.h
├── snapshot1.png
├── snapshot2.png
├── utils.cpp
└── utils.h

```

`BOOM.cpp`:

```cpp

#include "ntifs.h"
#include "utils.h"
#include "intrin.h"

#include "regStruct.h"
#include "./BOOM_Console/BoomDef.h"


//
//全局数据 内存标记
//
#define TAG_SYSTEMROUTINE	'rsys'
#define TAG_SHELLCODE		'dcls'
#define TAG_SHELLCODE_POBJ	'jbop'

//
//内存操作flasg
//
#define PROCESS_TERMINATE                  (0x0001)  
#define PROCESS_CREATE_THREAD              (0x0002)  
#define PROCESS_SET_SESSIONID              (0x0004)  
#define PROCESS_VM_OPERATION               (0x0008)  
#define PROCESS_VM_READ                    (0x0010)  
#define PROCESS_VM_WRITE                   (0x0020)  
#define PROCESS_DUP_HANDLE                 (0x0040)  
#define PROCESS_CREATE_PROCESS             (0x0080)  
#define PROCESS_SET_QUOTA                  (0x0100)  
#define PROCESS_SET_INFORMATION            (0x0200)  
#define PROCESS_QUERY_INFORMATION          (0x0400)  
#define PROCESS_SUSPEND_RESUME             (0x0800)  
#define PROCESS_QUERY_LIMITED_INFORMATION  (0x1000)  
#define PROCESS_SET_LIMITED_INFORMATION    (0x2000)  

//
//系统模块链表
//
typedef struct _LDR_DATA_TABLE_ENTRY64 {
	LIST_ENTRY64 InLoadOrderLinks;
	LIST_ENTRY64 InMemoryOrderLinks;
	LIST_ENTRY64 InInitializationOrderLinks;
	ULONG64 DllBase;
	ULONG64 EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG   Flags;
	USHORT  LoadCount;
	USHORT TlsIndex;
	union {
		LIST_ENTRY64 HashLinks;
		struct _Unkown1{
			ULONG64 SectionPointer;
			ULONG   CheckSum;
		};
	};
	union {
		ULONG   TimeDateStamp;
		ULONG64 LoadedImports;

	};

	//
	// NOTE : Do not grow this structure at the dump files used a packed
	// array of these structures.
	//

} LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64;

//
//自定义PEB结构
//
typedef struct _MYPEB
{
	union
	{
		struct dummy00
		{
			UCHAR InheritedAddressSpace;
			UCHAR ReadImageFileExecOptions;
			UCHAR BeingDebugged;
			UCHAR BitField;
		};
		PVOID dummy01;
	};

	PVOID Mutant;
	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} MYPEB, *PMYPEB;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	ULONG Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID	EntryInProgress;
	ULONG	ShutdownInProgress;
	PVOID	ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	union
	{
		ULONG SizeOfImage;
		PVOID dummy01;
	};
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;

} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

#ifdef __cplusplus    
extern "C"
{
#endif    
	NTKERNELAPI
		NTSTATUS
		ObReferenceObjectByName(
		IN PUNICODE_STRING ObjectName,
		IN ULONG Attributes,
		IN PACCESS_STATE PassedAccessState OPTIONAL,
		IN ACCESS_MASK DesiredAccess OPTIONAL,
		IN POBJECT_TYPE ObjectType,
		IN KPROCESSOR_MODE AccessMode,
		IN OUT PVOID ParseContext OPTIONAL,
		OUT PVOID *Object
		);
	extern POBJECT_TYPE *IoDriverObjectType;
#ifdef __cplusplus    
}
#endif    

//
//自己定义NTAPI，用于shellcode动态调用
//
typedef HANDLE(NTAPI *fn_PsGetCurrentProcessId)(
VOID
);

typedef NTSTATUS(NTAPI *fn_PsLookupProcessByProcessId)(
_In_ HANDLE ProcessId,
_Outptr_ PEPROCESS *Process
);

typedef BOOLEAN(NTAPI *fn_MmIsAddressValid)(
_In_ PVOID VirtualAddress
);

typedef PMDL(NTAPI *fn_IoAllocateMdl)(
_In_opt_ __drv_aliasesMem PVOID VirtualAddress,
_In_ ULONG Length,
_In_ BOOLEAN SecondaryBuffer,
_In_ BOOLEAN ChargeQuota,
_Inout_opt_ PIRP Irp
);

typedef VOID(NTAPI *fn_MmBuildMdlForNonPagedPool)(
_Inout_ PMDL MemoryDescriptorList
);

typedef PVOID(NTAPI *fn_MmMapLockedPages)(
_Inout_ PMDL MemoryDescriptorList,
_In_ __drv_strictType(KPROCESSOR_MODE / enum _MODE, __drv_typeConst)
KPROCESSOR_MODE AccessMode
);

typedef VOID(NTAPI *fn_IoFreeMdl)(
PMDL Mdl
);

typedef PEPROCESS(NTAPI *fn_PsGetCurrentProcess)(
VOID
);

typedef VOID(NTAPI *fn_KeStackAttachProcess)(
_Inout_ PRKPROCESS PROCESS,
_Out_ PRKAPC_STATE ApcState
);

typedef KIRQL(NTAPI *fn_KeRaiseIrqlToDpcLevel)(
	VOID
	);

typedef VOID(NTAPI *fn_RtlCopyMemory)(
	void *Dst,
	const void *Src,
	size_t Size);

typedef VOID(NTAPI *fn_KeLowerIrql)(
_In_ _Notliteral_ _IRQL_restores_ KIRQL NewIrql
);

typedef VOID(NTAPI *fn_KeUnstackDetachProcess)(
_In_ PRKAPC_STATE ApcState
);

typedef VOID(NTAPI *fn_MmUnmapLockedPages)(
_In_ PVOID BaseAddress,
_Inout_ PMDL MemoryDescriptorList
);

typedef LONG_PTR(NTAPI *fn_ObDereferenceObject)(
_In_ PVOID Object
);

typedef PVOID(NTAPI *fn_PsGetProcessWow64Process)(
	IN PEPROCESS Process);

typedef PMYPEB(NTAPI *fn_PsGetProcessPeb)(
	IN PEPROCESS Process);

typedef HANDLE(NTAPI* fn_PsGetProcessId)(
	_In_ PEPROCESS Process
	);

typedef VOID(NTAPI *fn_MmUnlockPages)(
_Inout_ PMDL MemoryDescriptorList
);

typedef VOID(NTAPI* fn_MmProbeAndLockPages)(
_Inout_ PMDL MemoryDescriptorList,
_In_ KPROCESSOR_MODE AccessMode,
_In_ LOCK_OPERATION Operation
);

typedef KIRQL(NTAPI *fn_KeGetCurrentIrql)(
	VOID);

typedef NTSTATUS(NTAPI* fn_MmCopyVirtualMemory)(
IN PEPROCESS FromProcess,
IN CONST VOID *FromAddress,
IN PEPROCESS ToProcess,
OUT PVOID ToAddress,
IN SIZE_T BufferSize,
IN KPROCESSOR_MODE PreviousMode,
OUT PSIZE_T NumberOfBytesCopied
);

typedef VOID(NTAPI* fn_RtlInitUnicodeString)(
PUNICODE_STRING DestinationString,
PCWSTR SourceString
);

typedef LONG(NTAPI* fn_RtlCompareUnicodeString)(
_In_ PCUNICODE_STRING String1,
_In_ PCUNICODE_STRING String2,
_In_ BOOLEAN CaseInSensitive
);

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation, // MEMORY_BASIC_INFORMATION
	MemoryWorkingSetInformation, // MEMORY_WORKING_SET_INFORMATION
	MemoryMappedFilenameInformation, // UNICODE_STRING
	MemoryRegionInformation, // MEMORY_REGION_INFORMATION
	MemoryWorkingSetExInformation, // MEMORY_WORKING_SET_EX_INFORMATION
	MemorySharedCommitInformation, // MEMORY_SHARED_COMMIT_INFORMATION
	MemoryImageInformation, // MEMORY_IMAGE_INFORMATION
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation
} MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_BASIC_INFORMATION {
	PVOID BaseAddress;
	PVOID AllocationBase;
	DWORD AllocationProtect;
	SIZE_T RegionSize;
	DWORD State;
	DWORD Protect;
	DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

typedef
NTSTATUS
(NTAPI*fn_NtQueryVirtualMemory)(
_In_ HANDLE ProcessHandle,
_In_ PVOID BaseAddress,
_In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
_Out_ PVOID MemoryInformation,
_In_ SIZE_T MemoryInformationLength,
_Out_opt_ PSIZE_T ReturnLength
);

//
//自定义全局数据，包含NTAPI 地址和一些数据
//
typedef struct _SYSTEM_ROUTINE_ADDRESS{
	HANDLE			ProtectPid;
	ULONG64			tag;
	ULONG64			flags;
	fn_PsGetCurrentProcessId pfn_PsGetCurrentProcessId;
	fn_PsLookupProcessByProcessId pfn_PsLookupProcessByProcessId;
	fn_MmIsAddressValid pfn_MmIsAddressValid;
	fn_IoAllocateMdl pfn_IoAllocateMdl;
	fn_MmBuildMdlForNonPagedPool pfn_MmBuildMdlForNonPagedPool;
	fn_MmMapLockedPages pfn_MmMapLockedPages;
	fn_IoFreeMdl pfn_IoFreeMdl;
	fn_PsGetCurrentProcess pfn_PsGetCurrentProcess;
	fn_KeStackAttachProcess pfn_KeStackAttachProcess;
	fn_KeRaiseIrqlToDpcLevel pfn_KeRaiseIrqlToDpcLevel;
	fn_RtlCopyMemory pfn_RtlCopyMemory;
	fn_KeLowerIrql pfn_KeLowerIrql;
	fn_KeUnstackDetachProcess pfn_KeUnstackDetachProcess;
	fn_MmUnmapLockedPages pfn_MmUnmapLockedPages;
	fn_ObDereferenceObject pfn_ObDereferenceObject;
	fn_PsGetProcessWow64Process pfn_PsGetProcessWow64Process;
	fn_PsGetProcessPeb pfn_PsGetProcessPeb;
	fn_PsGetProcessId pfn_PsGetProcessId;
	fn_MmUnlockPages pfn_MmUnlockPages;
	fn_MmProbeAndLockPages pfn_MmProbeAndLockPages;
	fn_KeGetCurrentIrql pfn_KeGetCurrentIrql;
	fn_NtQueryVirtualMemory pfn_NtQueryVirtualMemory;
	fn_MmCopyVirtualMemory pfn_MmCopyVirtualMemory;
	fn_RtlInitUnicodeString pfn_RtlInitUnicodeString;
	fn_RtlCompareUnicodeString pfn_RtlCompareUnicodeString;

}SYSTEM_ROUTINE_ADDRESS, *PSYSTEM_ROUTINE_ADDRESS;

//
//全局变量
//
static
LARGE_INTEGER				g_Regcookie = {0};

static
PSYSTEM_ROUTINE_ADDRESS		g_pSysRotineAddr = NULL;

static
PVOID						g_shellcode = NULL;

static
PVOID						g_shellcode_pobj = NULL;

static
PVOID						g_obHandle = NULL;

//
//驱动卸载例程
//
void DriverUnload(
	_In_ PDRIVER_OBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);

	CmUnRegisterCallback(g_Regcookie);

	ObUnRegisterCallbacks(g_obHandle);

	if (g_pSysRotineAddr)
		ExFreePoolWithTag(g_pSysRotineAddr, TAG_SYSTEMROUTINE);
	
	if (g_shellcode)
		ExFreePoolWithTag(g_shellcode, TAG_SHELLCODE);

	if (g_shellcode_pobj)
		ExFreePoolWithTag(g_shellcode_pobj, TAG_SHELLCODE_POBJ);
	
}

//
//驱动默认响应操作
//
NTSTATUS DriverDefaultHandler(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}

//
//注册表相关拦截callback，用于读写内存
//
NTSTATUS RegisterCallback(
	_In_ PVOID CallbackContext,
	_In_opt_ PVOID Argument1,
	_In_opt_ PVOID Argument2
	)
{
	UNREFERENCED_PARAMETER(CallbackContext);


	NTSTATUS Status = STATUS_SUCCESS;
	REG_NOTIFY_CLASS NotifyClass;
	PREG_SET_VALUE_KEY_INFORMATION PreSetValueInfo;

	NotifyClass = (REG_NOTIFY_CLASS)(ULONG_PTR)Argument1;

	if (Argument2 == NULL) 
	{
		return STATUS_SUCCESS;
	}

#if DBG
	PSYSTEM_ROUTINE_ADDRESS		g_pSRA = (PSYSTEM_ROUTINE_ADDRESS)g_pSysRotineAddr;
#else
	PSYSTEM_ROUTINE_ADDRESS		g_pSRA = (PSYSTEM_ROUTINE_ADDRESS)0x9090909090909090;
#endif


	PEPROCESS				process = NULL;
	PBOOM_PROCESS_OPERA		pInputData = NULL;
	PMYPEB					peb = NULL;
	KAPC_STATE				apc;
	KIRQL					kirql = NULL;
	PVOID					targetAddress = NULL;
	ULONG					targetSize = 0;
	ULONG64					cr0 = 0;
	UCHAR					probeBuf[1];
	SIZE_T					returnLenght =0;
	bool					attach = false;

	switch (NotifyClass)
	{
	case RegNtPreSetValueKey:
	{
		PreSetValueInfo = (PREG_SET_VALUE_KEY_INFORMATION)Argument2;

		if (PreSetValueInfo->Type == REG_BINARY &&
			PreSetValueInfo->DataSize == sizeof(BOOM_PROCESS_OPERA))
		{

			pInputData = (PBOOM_PROCESS_OPERA)PreSetValueInfo->Data;

			//
			//debugBreak
			//

			KdBreakPoint();

			if (g_pSRA->pfn_KeGetCurrentIrql() != PASSIVE_LEVEL)
			{
				return STATUS_SUCCESS;
			}

			switch (pInputData->tag)
			{
			case TAG_READ:
			{
				//
				//校验参数是否正确
				//

				Status = g_pSRA->pfn_PsLookupProcessByProcessId((HANDLE)pInputData->pid, &process);
				if (NT_SUCCESS(Status) && process != NULL && g_pSRA->pfn_MmIsAddressValid(pInputData->buf))
				{

					//
					//创建MDL来读取内存
					//

					PMDL g_pmdl = g_pSRA->pfn_IoAllocateMdl(pInputData->buf, pInputData->size, 0, 0, NULL);
					if (!g_pmdl)
						break;
					g_pSRA->pfn_MmBuildMdlForNonPagedPool(g_pmdl);
					unsigned char* Mapped = (unsigned char*)g_pSRA->pfn_MmMapLockedPages(g_pmdl, KernelMode);
					if (!Mapped)
					{
						g_pSRA->pfn_IoFreeMdl(g_pmdl);
						break;
					}

					//
					//attach上去的时候保存 读取目标地址和大小
					//

					targetAddress = (PVOID)pInputData->address;
					targetSize = pInputData->size;

					if (g_pSRA->pfn_PsGetCurrentProcess() != process)
					{
						g_pSRA->pfn_KeStackAttachProcess(process, &apc);
						attach = true;
					}

					//
					//读内存
					//
						
					if (g_pSRA->pfn_MmIsAddressValid(targetAddress))
					{

						kirql = g_pSRA->pfn_KeRaiseIrqlToDpcLevel();
						g_pSRA->pfn_RtlCopyMemory(Mapped, targetAddress, targetSize);
						g_pSRA->pfn_KeLowerIrql(kirql);
					}

					if (attach)
					{
						g_pSRA->pfn_KeUnstackDetachProcess(&apc);
					}

					g_pSRA->pfn_MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
					g_pSRA->pfn_IoFreeMdl(g_pmdl);

				}

				break;
			}
			case TAG_WRITE:
			{

				//
				//校验参数是否正确
				//

				Status = g_pSRA->pfn_PsLookupProcessByProcessId((HANDLE)pInputData->pid, &process);
				if (NT_SUCCESS(Status) && process != NULL && g_pSRA->pfn_MmIsAddressValid(pInputData->buf))
				{

					//
					//创建MDL来读取内存
					//

					PMDL g_pmdl = g_pSRA->pfn_IoAllocateMdl(pInputData->buf, pInputData->size, 0, 0, NULL);
					if (!g_pmdl)
						break;
					g_pSRA->pfn_MmBuildMdlForNonPagedPool(g_pmdl);
					

					unsigned char* Mapped = (unsigned char*)g_pSRA->pfn_MmMapLockedPages(g_pmdl, KernelMode);
					if (!Mapped)
					{
						g_pSRA->pfn_IoFreeMdl(g_pmdl);
						break;
					}

					//
					//attach上去的时候保存 读取目标地址和大小
					//

					targetAddress = (PVOID)pInputData->address;
					targetSize = pInputData->size;

					if (g_pSRA->pfn_PsGetCurrentProcess() != process)
					{
						g_pSRA->pfn_KeStackAttachProcess(process, &apc);
						attach = true;
					}


					if (g_pSRA->pfn_MmIsAddressValid(targetAddress))
					{

						kirql = g_pSRA->pfn_KeRaiseIrqlToDpcLevel();
						cr0 = __readcr0();
						cr0 &= 0xfffffffffffeffff;
						__writecr0(cr0);
						_disable();

						g_pSRA->pfn_RtlCopyMemory(targetAddress, Mapped, targetSize);
						g_pSRA->pfn_KeLowerIrql(kirql);

						cr0 = __readcr0();
						cr0 |= 0x10000;
						_enable();
						__writecr0(cr0);
						g_pSRA->pfn_KeLowerIrql(kirql);

					}

					if (attach)
					{
						g_pSRA->pfn_KeUnstackDetachProcess(&apc);
					}
					
					g_pSRA->pfn_MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
					g_pSRA->pfn_IoFreeMdl(g_pmdl);
					
					
				}
				break;
			}
			case TAG_GETMODULE:
			{
				//
				//校验参数是否正确
				//

				Status = g_pSRA->pfn_PsLookupProcessByProcessId((HANDLE)pInputData->pid, &process);
				if (NT_SUCCESS(Status) && process != NULL && g_pSRA->pfn_MmIsAddressValid(pInputData->buf))
				{

					//
					//创建MDL来写内存
					//

					PMDL g_pmdl = g_pSRA->pfn_IoAllocateMdl(pInputData->buf, pInputData->size, 0, 0, NULL);
					if (!g_pmdl)
						break;
					g_pSRA->pfn_MmBuildMdlForNonPagedPool(g_pmdl);
					unsigned char* Mapped = (unsigned char*)g_pSRA->pfn_MmMapLockedPages(g_pmdl, KernelMode);
					if (!Mapped)
					{
						g_pSRA->pfn_IoFreeMdl(g_pmdl);
						break;
					}

					//
					//attach上去
					//

					if (g_pSRA->pfn_PsGetCurrentProcess() != process)
					{
						g_pSRA->pfn_KeStackAttachProcess(process, &apc);
						attach = true;
					}

					//
					//判断是否64位进程
					//
					if (g_pSRA->pfn_PsGetProcessWow64Process(process) == NULL)
					{
						peb = g_pSRA->pfn_PsGetProcessPeb(process);
						if (peb != NULL)
						{
							if (Mapped[0] == '\0') //传空则获取 exe->ImageBaseAddress 基址
							{
								kirql = g_pSRA->pfn_KeRaiseIrqlToDpcLevel();
								g_pSRA->pfn_RtlCopyMemory(Mapped, &peb->ImageBaseAddress, sizeof(PVOID));
								g_pSRA->pfn_KeLowerIrql(kirql);
							}
							else
							{
								PPEB_LDR_DATA	pPebLdrData = (PPEB_LDR_DATA)peb->Ldr;
								PLIST_ENTRY		pListEntryStart = NULL;
								PLIST_ENTRY		pListEntryEnd = NULL;

								PLDR_DATA_TABLE_ENTRY pLdrDataEntry = NULL;

								UNICODE_STRING	queryModuleName;
								g_pSRA->pfn_RtlInitUnicodeString(&queryModuleName, (PCWSTR)Mapped);

								pListEntryStart = pListEntryEnd = pPebLdrData->InMemoryOrderModuleList.Blink;

								do
								{

									pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)CONTAINING_RECORD(pListEntryStart, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

									if (g_pSRA->pfn_RtlCompareUnicodeString(&pLdrDataEntry->BaseDllName, &queryModuleName, TRUE) == 0)
									{
										kirql = g_pSRA->pfn_KeRaiseIrqlToDpcLevel();
										g_pSRA->pfn_RtlCopyMemory(Mapped, &pLdrDataEntry->DllBase, sizeof(PVOID));
				
										g_pSRA->pfn_KeLowerIrql(kirql);
										break;
									}

									pListEntryStart = pListEntryStart->Blink;

								} while (pListEntryStart != pListEntryEnd);


							}
						}
					}
					
					if (attach)
					{
						g_pSRA->pfn_KeUnstackDetachProcess(&apc);
					}

					g_pSRA->pfn_MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
					g_pSRA->pfn_IoFreeMdl(g_pmdl);

				}

				break;
			}
			case TAG_PROTECT:
			{
				g_pSRA->ProtectPid = (HANDLE)pInputData->pid;
				break;
			}
			case TAG_PROBEREAD:
			{
				Status = g_pSRA->pfn_PsLookupProcessByProcessId((HANDLE)pInputData->pid, &process);
				if (NT_SUCCESS(Status) && process != NULL)
				{
					g_pSRA->pfn_MmCopyVirtualMemory(process,
													(PVOID)pInputData->address,
													g_pSRA->pfn_PsGetCurrentProcess(),
													probeBuf,
													sizeof(probeBuf),
													KernelMode,
													&returnLenght);
				
				}
			break;
			}
			default:
				break;
			}

			if (process != NULL)
			{
				g_pSRA->pfn_ObDereferenceObject(process);
			}
			Status = STATUS_UNSUCCESSFUL;

		}
		break;
	}
	default:
		break;
	}

	return Status;

}

//
//进程保护callback
//
OB_PREOP_CALLBACK_STATUS preCall(
	_In_ PVOID RegistrationContext,
	_In_ POB_PRE_OPERATION_INFORMATION pOperationInformation)
{
	UNREFERENCED_PARAMETER(RegistrationContext);

	if (pOperationInformation == NULL || pOperationInformation->Object == NULL)
	{
		return OB_PREOP_SUCCESS;
	}

#if DBG
	PSYSTEM_ROUTINE_ADDRESS		g_pSRA = (PSYSTEM_ROUTINE_ADDRESS)g_pSysRotineAddr;
#else
	PSYSTEM_ROUTINE_ADDRESS		g_pSRA = (PSYSTEM_ROUTINE_ADDRESS)0x9090909090909090;
#endif

	HANDLE pid = g_pSRA->pfn_PsGetProcessId((PEPROCESS)pOperationInformation->Object);

	if (g_pSRA->ProtectPid == pid)
	{
		if (pOperationInformation->Operation == OB_OPERATION_HANDLE_CREATE)
		{
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_TERMINATE)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_TERMINATE);
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_VM_OPERATION)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_VM_OPERATION);
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_VM_READ)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_VM_READ);
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_VM_WRITE)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_VM_WRITE);
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_SUSPEND_RESUME)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_SUSPEND_RESUME);
			 
		}
		if (pOperationInformation->Operation == OB_OPERATION_HANDLE_DUPLICATE)
		{
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_TERMINATE)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_TERMINATE);
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_VM_OPERATION)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_VM_OPERATION);
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_VM_READ)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_VM_READ);
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_VM_WRITE)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_VM_WRITE);
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_SUSPEND_RESUME)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_SUSPEND_RESUME);
		}
	}
	
	return OB_PREOP_SUCCESS;
}

//
//bypass objecthook签名
//
void BypassCheckSign(
	_In_ PDRIVER_OBJECT pDriverObj)
{
	//STRUCT FOR WIN64
	typedef struct _LDR_DATA                         			// 24 elements, 0xE0 bytes (sizeof)
	{
		LIST_ENTRY64 InLoadOrderLinks;
		LIST_ENTRY64 InMemoryOrderLinks;
		LIST_ENTRY64 InInitializationOrderLinks;
		ULONG64 DllBase;
		ULONG64 EntryPoint;
		ULONG SizeOfImage;
		UNICODE_STRING FullDllName;
		UNICODE_STRING BaseDllName;
		ULONG   Flags;
	}LDR_DATA, *PLDR_DATA;
	PLDR_DATA ldr;
	ldr = (PLDR_DATA)(pDriverObj->DriverSection);
	ldr->Flags |= 0x20;
}

//
//枚举 跳板驱动
//
PVOID EnumJumpDrv(
	_In_ PDRIVER_OBJECT		pDriverObject,
	_In_ PUNICODE_STRING	JumpSysName,
	_In_ PVOID address,
	_In_ ULONG count)
{
	PUCHAR				pJumpDrvBase = NULL;
	PIMAGE_DOS_HEADER	pDosHead;
	PIMAGE_NT_HEADERS	pNtHead;
	PIMAGE_SECTION_HEADER pSecHead;
	ULONG				AlignPageSize;
	ULONG				cResult1, cResult2;
	bool				bFinded = false;

	if (pDriverObject == NULL || address == NULL || count == 0)
	{
		return NULL;
	}


	//
	//寻找目标驱动
	//
	PLDR_DATA_TABLE_ENTRY64		entry = (PLDR_DATA_TABLE_ENTRY64)pDriverObject->DriverSection;
	PLDR_DATA_TABLE_ENTRY64		first;

	first = entry;

	__try{
		do
		{
			if (entry->BaseDllName.Buffer != NULL)
			{
				if (RtlCompareUnicodeString(&entry->BaseDllName, JumpSysName, TRUE) == 0)
				{
					pJumpDrvBase = (PUCHAR)entry->DllBase;
					break;
				}
				entry = (PLDR_DATA_TABLE_ENTRY64)entry->InLoadOrderLinks.Blink;
			}


		} while (entry->InLoadOrderLinks.Blink != (ULONGLONG)first);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return NULL;
	}

	if (!pJumpDrvBase)
	{
		return NULL;
	}

	//
	//hook shellcode
	//

	UCHAR	hookCode[] = {
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	pDosHead = (PIMAGE_DOS_HEADER)pJumpDrvBase;
	if (pDosHead->e_magic != IMAGE_DOS_SIGNATURE)
	{
		return NULL;
	}
	pNtHead = (PIMAGE_NT_HEADERS)\
		((LONG_PTR)pDosHead + pDosHead->e_lfanew);
	if (pNtHead->Signature != IMAGE_NT_SIGNATURE)
	{
		return NULL;
	}
	pSecHead = IMAGE_FIRST_SECTION(pNtHead);
	for (int i = 0; i < pNtHead->FileHeader.NumberOfSections; i++)
	{
		if (strcmp((const char*)(pSecHead->Name), ".text") == 0)
		{
			bFinded = true;
			break;
		}
		pSecHead++;
	}

	//
	//没有找到PAGE 页面
	//

	if (!bFinded)
	{
		KdPrint(("[BOOM] not find to name PAGE in the section.\n"));
		return NULL;
	}

	//
	//妈的 这么6？
	//

	if (pSecHead->Misc.VirtualSize % PAGE_SIZE == 0)
	{
		KdPrint(("[BOOM] PAGE virtual size not align space.\n"));
		return NULL;
	}

	AlignPageSize = ((pSecHead->Misc.VirtualSize / PAGE_SIZE) + 1) * PAGE_SIZE;

	cResult1 = AlignPageSize - pSecHead->Misc.VirtualSize;
	cResult2 = count * 16;
	if (cResult1 < cResult2)
	{
		KdPrint(("[BOOM] PAGE virtual size algin space not enough.\n"));
		return NULL;
	}

	//
	//已经被hook了
	//
	pJumpDrvBase += pSecHead->VirtualAddress;
	pJumpDrvBase += AlignPageSize;
	pJumpDrvBase -= cResult2;

	if (*pJumpDrvBase == hookCode[0])
	{
		return NULL;
	}

	memcpy(&hookCode[6], &address, sizeof(PVOID));

	RtlSuperCopyMemory(pJumpDrvBase, hookCode, sizeof(hookCode));

	return pJumpDrvBase;

}


//
//初始化全局NTAPI 地址
//
NTSTATUS InitSystemRoutineAddress(
	)
{
	NTSTATUS			status = STATUS_UNSUCCESSFUL;
	UNICODE_STRING		routineName;

	g_pSysRotineAddr = \
		(PSYSTEM_ROUTINE_ADDRESS)ExAllocatePoolWithTag(NonPagedPool, sizeof(SYSTEM_ROUTINE_ADDRESS), TAG_SYSTEMROUTINE);
	if (g_pSysRotineAddr == NULL)
	{
		return status;
	}
	g_pSysRotineAddr->ProtectPid = (HANDLE)-1;

	RtlInitUnicodeString(&routineName,L"PsGetCurrentProcessId");
	g_pSysRotineAddr->pfn_PsGetCurrentProcessId = \
		(fn_PsGetCurrentProcessId)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetCurrentProcessId == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsLookupProcessByProcessId");
	g_pSysRotineAddr->pfn_PsLookupProcessByProcessId = \
		(fn_PsLookupProcessByProcessId)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsLookupProcessByProcessId == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmIsAddressValid");
	g_pSysRotineAddr->pfn_MmIsAddressValid = \
		(fn_MmIsAddressValid)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmIsAddressValid == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"IoAllocateMdl");
	g_pSysRotineAddr->pfn_IoAllocateMdl = \
		(fn_IoAllocateMdl)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_IoAllocateMdl == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmBuildMdlForNonPagedPool");
	g_pSysRotineAddr->pfn_MmBuildMdlForNonPagedPool = \
		(fn_MmBuildMdlForNonPagedPool)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmBuildMdlForNonPagedPool == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmMapLockedPages");
	g_pSysRotineAddr->pfn_MmMapLockedPages = \
		(fn_MmMapLockedPages)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmMapLockedPages == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"IoFreeMdl");
	g_pSysRotineAddr->pfn_IoFreeMdl = \
		(fn_IoFreeMdl)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_IoFreeMdl == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsGetCurrentProcess");
	g_pSysRotineAddr->pfn_PsGetCurrentProcess = \
		(fn_PsGetCurrentProcess)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetCurrentProcess == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeStackAttachProcess");
	g_pSysRotineAddr->pfn_KeStackAttachProcess = \
		(fn_KeStackAttachProcess)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeStackAttachProcess == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeRaiseIrqlToDpcLevel");
	g_pSysRotineAddr->pfn_KeRaiseIrqlToDpcLevel = \
		(fn_KeRaiseIrqlToDpcLevel)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeRaiseIrqlToDpcLevel == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"RtlCopyMemory");
	g_pSysRotineAddr->pfn_RtlCopyMemory = \
		(fn_RtlCopyMemory)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_RtlCopyMemory == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeLowerIrql");
	g_pSysRotineAddr->pfn_KeLowerIrql = \
		(fn_KeLowerIrql)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeLowerIrql == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeUnstackDetachProcess");
	g_pSysRotineAddr->pfn_KeUnstackDetachProcess = \
		(fn_KeUnstackDetachProcess)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeUnstackDetachProcess == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmUnmapLockedPages");
	g_pSysRotineAddr->pfn_MmUnmapLockedPages = \
		(fn_MmUnmapLockedPages)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmUnmapLockedPages == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"ObDereferenceObject");	
	g_pSysRotineAddr->pfn_ObDereferenceObject = \
		(fn_ObDereferenceObject)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_ObDereferenceObject == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsGetProcessWow64Process");
	g_pSysRotineAddr->pfn_PsGetProcessWow64Process = \
		(fn_PsGetProcessWow64Process)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetProcessWow64Process == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsGetProcessPeb");
	g_pSysRotineAddr->pfn_PsGetProcessPeb = \
		(fn_PsGetProcessPeb)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetProcessPeb == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsGetProcessId");
	g_pSysRotineAddr->pfn_PsGetProcessId = \
		(fn_PsGetProcessId)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetProcessId == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmUnlockPages");
	g_pSysRotineAddr->pfn_MmUnlockPages = \
		(fn_MmUnlockPages)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmUnlockPages == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmProbeAndLockPages");
	g_pSysRotineAddr->pfn_MmProbeAndLockPages = \
		(fn_MmProbeAndLockPages)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmProbeAndLockPages == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeGetCurrentIrql");
	g_pSysRotineAddr->pfn_KeGetCurrentIrql = \
		(fn_KeGetCurrentIrql)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeGetCurrentIrql == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmCopyVirtualMemory");
	g_pSysRotineAddr->pfn_MmCopyVirtualMemory = \
		(fn_MmCopyVirtualMemory)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmCopyVirtualMemory == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"RtlInitUnicodeString");
	g_pSysRotineAddr->pfn_RtlInitUnicodeString = \
		(fn_RtlInitUnicodeString)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_RtlInitUnicodeString == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"RtlCompareUnicodeString");
	g_pSysRotineAddr->pfn_RtlCompareUnicodeString = \
		(fn_RtlCompareUnicodeString)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_RtlCompareUnicodeString == NULL)
	{
		return status;
	}


	return STATUS_SUCCESS;
}

//
//保护进程
//
NTSTATUS ProtectProcess(
	_In_ PVOID ObjectCllbackAddr)
{
	NTSTATUS	status;
	OB_CALLBACK_REGISTRATION obReg;
	OB_OPERATION_REGISTRATION opReg;

	memset(&obReg, 0, sizeof(obReg));
	obReg.Version = ObGetFilterVersion();
	obReg.OperationRegistrationCount = 1;
	obReg.RegistrationContext = NULL;
	RtlInitUnicodeString(&obReg.Altitude, L"326611");
	obReg.OperationRegistration = &opReg;
	memset(&opReg, 0, sizeof(opReg));
	opReg.ObjectType = PsProcessType;
	opReg.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
	opReg.PreOperation = (POB_PRE_OPERATION_CALLBACK)ObjectCllbackAddr;
	status = ObRegisterCallbacks(&obReg, &g_obHandle);

	return status;
}

//
//驱动入口
//
extern "C"
NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING  RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);
	NTSTATUS	status;
	PVOID		FakeCallback, FakeCallback2;
	PUCHAR		pRepRoutinePoint;
	UNICODE_STRING	altitude;
	UNICODE_STRING	fakeDrv;
	UNICODE_STRING	DeviceName;

	//set callback functions
	DriverObject->DriverUnload = DriverUnload;
	for (unsigned int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
		DriverObject->MajorFunction[i] = DriverDefaultHandler;


	//
	//先初始化地址
	//

	if (!NT_SUCCESS(InitSystemRoutineAddress()))
	{
		status = STATUS_APP_INIT_FAILURE;
		goto __exit;
	}

	//
	//初始化shellcode
	//

	g_shellcode = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, TAG_SHELLCODE);
	if (!g_shellcode)
	{
		status = STATUS_MEMORY_NOT_ALLOCATED;
		goto __exit;
	}
	RtlSuperCopyMemory(g_shellcode, RegisterCallback, PAGE_SIZE);

	pRepRoutinePoint = (PUCHAR)g_shellcode;
	for (int i = 0; i < PAGE_SIZE - sizeof(ULONG64); i++)
	{
		if (pRepRoutinePoint[i] == 0x90 && 
			*(ULONG64*)(&pRepRoutinePoint[i]) == 0x9090909090909090)
		{
			PVOID	fined = &pRepRoutinePoint[i];
			RtlSuperCopyMemory(fined, &g_pSysRotineAddr, sizeof(g_pSysRotineAddr));
			
		}
	}
	//object hook
	g_shellcode_pobj = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, TAG_SHELLCODE_POBJ);
	if (!g_shellcode_pobj)
	{
		status = STATUS_MEMORY_NOT_ALLOCATED;
		goto __exit;
	}
	RtlSuperCopyMemory(g_shellcode_pobj, preCall, PAGE_SIZE);

	pRepRoutinePoint = (PUCHAR)g_shellcode_pobj;
	for (int i = 0; i < PAGE_SIZE - sizeof(ULONG64); i++)
	{
		if (pRepRoutinePoint[i] == 0x90 &&
			*(ULONG64*)(&pRepRoutinePoint[i]) == 0x9090909090909090)
		{
			PVOID	fined = &pRepRoutinePoint[i];
			RtlSuperCopyMemory(fined, &g_pSysRotineAddr, sizeof(g_pSysRotineAddr));

		}
	}

	//
	//枚举其他驱动做跳板代码
	//
	RtlInitUnicodeString(&fakeDrv, L"Beep.SYS");
	FakeCallback = EnumJumpDrv(DriverObject, &fakeDrv,g_shellcode, 1);
	
	FakeCallback2 = EnumJumpDrv(DriverObject, &fakeDrv, g_shellcode_pobj, 2);

#ifndef DBG
	if (FakeCallback == NULL || FakeCallback2 == NULL)
	{
		status = STATUS_ALIAS_EXISTS;
		goto __exit;
	}
#endif

	//
	//先激活object hook
	//
	RtlInitUnicodeString(&DeviceName, L"\\Driver\\Beep");
	PDRIVER_OBJECT pDriver = NULL;
	status = ObReferenceObjectByName(&DeviceName,
									 OBJ_CASE_INSENSITIVE,
									 NULL, FILE_ALL_ACCESS,
									 *IoDriverObjectType,
									 KernelMode, NULL,
									 (PVOID*)&pDriver);

	if (NT_SUCCESS(status))
	{
		BypassCheckSign(DriverObject);
		BypassCheckSign(pDriver);
		ObDereferenceObject(pDriver);
	}
#if DBG
	ProtectProcess(preCall);
#else
	ProtectProcess(FakeCallback2);
#endif

	//
	//注册注册表回调
	//

	RtlInitUnicodeString(&altitude, L"466010");
#if DBG
	status = CmRegisterCallbackEx(
		(PEX_CALLBACK_FUNCTION)RegisterCallback,
		&altitude,
		DriverObject,
		NULL,
		&g_Regcookie,
		NULL);
#else
	status = CmRegisterCallbackEx(
		(PEX_CALLBACK_FUNCTION)FakeCallback,
		&altitude,
		DriverObject,
		NULL,
		&g_Regcookie,
		NULL);
#endif

	if (!NT_SUCCESS(status))
	{
		goto __exit;
	}
	else
	{
		//
		//这里是全部操作成功，但我们得返回 0xC0000088 来标记以上工作全部成功
		//
#if DBG
		return STATUS_SUCCESS;
#else
		return 0xC0000088;
#endif
	}

__exit:
	if (g_pSysRotineAddr)
		ExFreePoolWithTag(g_pSysRotineAddr, TAG_SYSTEMROUTINE);
	if (g_shellcode)
		ExFreePoolWithTag(g_shellcode, TAG_SHELLCODE);
	if (g_shellcode_pobj)
		ExFreePoolWithTag(g_shellcode_pobj, TAG_SHELLCODE_POBJ);

	return status;

}

```

`BOOM.inf`:

```inf
;
; BOOM.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=
ClassGuid=
Provider=
DriverVer=
CatalogFile=

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName=""
ClassName=""
DiskName="BOOM Source Disk"

```

`BOOM.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.168
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BOOM", "BOOM.vcxproj", "{7371B83F-AC43-48CB-AB8B-CACE67F2ECCE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BOOM_Console", "BOOM_Console\BOOM_Console.vcxproj", "{44FFF226-7F8C-403C-B8A2-A9AC1E2265BA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Win7 Debug|x64 = Win7 Debug|x64
		Win7 Release|x64 = Win7 Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7371B83F-AC43-48CB-AB8B-CACE67F2ECCE}.Win7 Debug|x64.ActiveCfg = Win7 Debug|x64
		{7371B83F-AC43-48CB-AB8B-CACE67F2ECCE}.Win7 Debug|x64.Build.0 = Win7 Debug|x64
		{7371B83F-AC43-48CB-AB8B-CACE67F2ECCE}.Win7 Debug|x64.Deploy.0 = Win7 Debug|x64
		{7371B83F-AC43-48CB-AB8B-CACE67F2ECCE}.Win7 Release|x64.ActiveCfg = Win7 Release|x64
		{7371B83F-AC43-48CB-AB8B-CACE67F2ECCE}.Win7 Release|x64.Build.0 = Win7 Release|x64
		{7371B83F-AC43-48CB-AB8B-CACE67F2ECCE}.Win7 Release|x64.Deploy.0 = Win7 Release|x64
		{44FFF226-7F8C-403C-B8A2-A9AC1E2265BA}.Win7 Debug|x64.ActiveCfg = Debug|x64
		{44FFF226-7F8C-403C-B8A2-A9AC1E2265BA}.Win7 Debug|x64.Build.0 = Debug|x64
		{44FFF226-7F8C-403C-B8A2-A9AC1E2265BA}.Win7 Debug|x64.Deploy.0 = Debug|x64
		{44FFF226-7F8C-403C-B8A2-A9AC1E2265BA}.Win7 Release|x64.ActiveCfg = Release|x64
		{44FFF226-7F8C-403C-B8A2-A9AC1E2265BA}.Win7 Release|x64.Build.0 = Release|x64
		{44FFF226-7F8C-403C-B8A2-A9AC1E2265BA}.Win7 Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B7D6D0CC-82C7-44F1-B7EF-C950428DC123}
	EndGlobalSection
EndGlobal

```

`BOOM.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Win7 Debug|x64">
      <Configuration>Win7 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|x64">
      <Configuration>Win7 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7371B83F-AC43-48CB-AB8B-CACE67F2ECCE}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>
    <Configuration>Win8.1 Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>BOOM</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)\bin\</OutDir>
    <IntDir>$(SolutionDir)\Temp\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName)_d</TargetName>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <OutDir>$(SolutionDir)\bin\</OutDir>
    <IntDir>$(SolutionDir)\Temp\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
    <FilesToPackage Include="@(Inf->'%(CopyOutput)')" Condition="'@(Inf)'!=''" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.c" />
    <ClCompile Include="cmpcallback.c" />
    <ClCompile Include="obcallback.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cmpcallback.h" />
    <ClInclude Include="obcallback.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BOOM.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="cmpcallback.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="obcallback.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cmpcallback.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="obcallback.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`BOOM.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`BOOM_Console/BOOM_Console.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{44FFF226-7F8C-403C-B8A2-A9AC1E2265BA}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>BOOM_Console</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\bin\</OutDir>
    <IntDir>$(SolutionDir)\Temp\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName)_d</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IntDir>$(SolutionDir)\Temp\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)\bin\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CDrvController.cpp" />
    <ClCompile Include="CDrvLoader.cpp" />
    <ClCompile Include="Console.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\inc\inc.h" />
    <ClInclude Include="CDrvController.h" />
    <ClInclude Include="CDrvLoader.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BOOM_Console/BOOM_Console.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Console.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="CDrvLoader.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="CDrvController.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CDrvLoader.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="CDrvController.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\inc.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`BOOM_Console/BOOM_Console.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BOOM_Console/BoomDef.h`:

```h
#ifndef _BOOM_DEFINE_STRUCT_H
#define _BOOM_DEFINE_STRUCT_H

#define	TAG_READ		0xAEFCBD88DEADC0DE
#define	TAG_WRITE		0xAEFCBD88E0CDC0DE
#define TAG_GETMODULE	0xAEFCBD88C0EDC0DE
#define TAG_PROTECT		0xAEFCBD88ECADC0DE
#define TAG_PROBEREAD	0xAEFCBD880DADC0DE


typedef struct _BOOM_PROCESS_OPERA{
	ULONG64		tag;		//标记
	ULONG		flags;		//标记
	ULONG64		pid;		//target process
	ULONG64		address;	//读取地址
	UCHAR		*buf;		//缓冲区指针
	ULONG		size;		//需要读取大小
}BOOM_PROCESS_OPERA,*PBOOM_PROCESS_OPERA;


#endif
```

`BOOM_Console/BoomSDK.cpp`:

```cpp

#include <windows.h>
#include "BoomDef.h"
#include "BoomSDK.h"



void
BO_ZwLoadDriver();

__int64
BO_GetProcessImageBase(ULONG64 pid)
{
	__int64 imageBase = 0;
	BOOM_PROCESS_OPERA	input = { 0 };

	input.tag = TAG_GETMODULE;
	input.pid = pid;
	input.address = NULL;
	input.buf = (UCHAR*)&imageBase;
	input.size = sizeof(imageBase);

	RegSetValueExA(HKEY_LOCAL_MACHINE,
				  "",
				  NULL,
				  REG_BINARY,
				  (byte*)&input,
				  48);

	return imageBase;
}

void
BO_ProtectProcess(ULONG64 pid)
{
	BOOM_PROCESS_OPERA	input = { 0 };

	input.tag = TAG_PROTECT;
	input.pid = pid;
	input.address = NULL;
	input.buf = NULL;
	input.size = NULL;

	RegSetValueExA(HKEY_LOCAL_MACHINE,
		"",
		NULL,
		REG_BINARY,
		(byte*)&input,
		48);
}

int
BO_ReadInt32(ULONG64 pid, ULONG64 address);

__int64
BO_ReadInt64(ULONG64 pid, ULONG64 address);

void
BO_ReadBytes(ULONG64 pid, ULONG64 address, PBYTE byteBuf, ULONG size);

float
BO_ReadFloat(ULONG64 pid, ULONG64 address);

double
BO_ReadDouble(ULONG64 pid, ULONG64 address);

void
BO_WriteInt32(ULONG64 pid, ULONG64 address, int data);

void
BO_WriteInt64(ULONG64 pid, ULONG64 address, __int64 data);

void
BO_WriteBytes(ULONG64 pid, ULONG64 address, PBYTE data, ULONG size);

void
BO_WriteFloat(ULONG64 pid, ULONG64 address, float data);

void
BO_WriteDouble(ULONG64 pid, ULONG64 address, double data);




```

`BOOM_Console/BoomSDK.h`:

```h
#ifndef _BOOM_SDK_H
#define _BOOM_SDK_H

void 
BO_ZwLoadDriver();

__int64 
BO_GetProcessImageBase(ULONG64 pid);

void
BO_ProtectProcess(ULONG64 pid);

int
BO_ReadInt32(ULONG64 pid, ULONG64 address);

__int64
BO_ReadInt64(ULONG64 pid, ULONG64 address);

void
BO_ReadBytes(ULONG64 pid, ULONG64 address, PBYTE byteBuf, ULONG size);

float
BO_ReadFloat(ULONG64 pid, ULONG64 address);

double
BO_ReadDouble(ULONG64 pid, ULONG64 address);

void
BO_WriteInt32(ULONG64 pid, ULONG64 address, int data);

void
BO_WriteInt64(ULONG64 pid, ULONG64 address, __int64 data);

void
BO_WriteBytes(ULONG64 pid, ULONG64 address, PBYTE data, ULONG size);

void
BO_WriteFloat(ULONG64 pid, ULONG64 address, float data);

void
BO_WriteDouble(ULONG64 pid, ULONG64 address, double data);





#endif
```

`BOOM_Console/CDrvController.cpp`:

```cpp

#include "CDrvController.h"

 
CDrvController::CDrvController()
{
}


CDrvController::~CDrvController()
{
}

BOOL CDrvController::DC_IsLoadBoomDrv()
{
	DWORD data1 = 666;
	DWORD data2 = 0;

	if (ReadMemory((ULONG64)GetCurrentProcessId(),(ULONG64)&data1,(PBYTE)&data2,sizeof(DWORD)))
	{
		if (data1 == data2)
		{
			return TRUE;
		}
	}

	return FALSE;
}

ULONG64 CDrvController::DC_GetModuleAddr(ULONG pid, LPCWSTR lpModuleName)
{
	BOOM_PROCESS_OPERA control = { 0 };

	WCHAR buf[MAX_PATH] = { 0 };

	control.tag = TAG_GETMODULE;
	control.pid = (ULONG64)pid;
	control.buf = (ULONG64)buf;

	if (lpModuleName != NULL)
	{
		wcscpy(buf, lpModuleName);
	}

	RegSetValueEx(HKEY_LOCAL_MACHINE, _T(""), NULL, REG_BINARY, (byte*)&control, sizeof(control));

	return *(ULONG64*)&buf;
}

BOOL CDrvController::DC_ProbeRead(ULONG pid, ULONG64 addr)
{
	BOOM_PROCESS_OPERA control = { 0 };

	control.tag = TAG_PROBEREAD;
	control.pid = (ULONG64)pid;
	control.address = (ULONG64)addr;

	RegSetValueEx(HKEY_LOCAL_MACHINE, _T(""), NULL, REG_BINARY, (byte*)&control, sizeof(control));

	return TRUE;
}

BYTE CDrvController::DC_ReadByte(ULONG pid, ULONG64 addr)
{
	BYTE buf = '\0';
	ReadMemory(pid, addr, (PBYTE)&buf, sizeof(BYTE));
	return buf;
}

SHORT CDrvController::DC_ReadShort(ULONG pid, ULONG64 addr)
{
	SHORT buf = 0;
	ReadMemory(pid, addr, (PBYTE)&buf, sizeof(SHORT));
	return buf;
}

INT CDrvController::DC_ReadInt(ULONG pid, ULONG64 addr)
{
	INT buf = 0;
	ReadMemory(pid, addr, (PBYTE)&buf, sizeof(INT));
	return buf;
}

INT64 CDrvController::DC_ReadInt64(ULONG pid, ULONG64 addr)
{
	INT64 buf = 0;
	ReadMemory(pid, addr, (PBYTE)&buf, sizeof(INT64));
	return buf;
}

FLOAT CDrvController::DC_ReadFloat(ULONG pid, ULONG64 addr)
{
	FLOAT buf = 0.0f;
	ReadMemory(pid, addr, (PBYTE)&buf, sizeof(FLOAT));
	return buf;
}

BOOL CDrvController::DC_ReadBytes(ULONG pid, ULONG64 addr, PBYTE pDataBuffer, ULONG size)
{
	return ReadMemory(pid, addr, pDataBuffer, size);
}

BOOL CDrvController::DC_WriteByte(ULONG pid, ULONG64 addr, BYTE pDataBuffer)
{
 	return WriteMemory(pid, addr, (PBYTE)&pDataBuffer, sizeof(BYTE));
}

BOOL CDrvController::DC_WriteShort(ULONG pid, ULONG64 addr, SHORT pDataBuffer)
{
	return WriteMemory(pid, addr, (PBYTE)&pDataBuffer, sizeof(SHORT));
}

BOOL CDrvController::DC_WriteInt(ULONG pid, ULONG64 addr, INT pDataBuffer)
{
	return WriteMemory(pid, addr, (PBYTE)&pDataBuffer, sizeof(INT));
}

BOOL CDrvController::DC_WriteInt64(ULONG pid, ULONG64 addr, INT64 pDataBuffer)
{
	return WriteMemory(pid, addr, (PBYTE)&pDataBuffer, sizeof(INT64));
}

BOOL CDrvController::DC_WriteFloat(ULONG pid, ULONG64 addr, FLOAT pDataBuffer)
{
	return WriteMemory(pid, addr, (PBYTE)&pDataBuffer, sizeof(FLOAT));
}

BOOL CDrvController::DC_WriteBytes(ULONG pid, ULONG64 addr, PBYTE pDataBuffer, ULONG size)
{
	return WriteMemory(pid, addr, pDataBuffer, size);
}

BOOL CDrvController::ReadMemory(ULONG64 pid, ULONG64 addr, PBYTE pDataBuffer, ULONG size)
{
	BOOM_PROCESS_OPERA control = { 0 };

	control.tag = TAG_READ;
	control.pid = (ULONG64)pid;
	control.address = (ULONG64)addr;
	control.buf = (ULONG64)pDataBuffer;
	control.size = size;

	RegSetValueEx(HKEY_LOCAL_MACHINE, _T(""), NULL, REG_BINARY, (byte*)&control, sizeof(control));

	return TRUE;
}

BOOL CDrvController::WriteMemory(ULONG64 pid, ULONG64 addr, PBYTE pDataBuffer, ULONG size)
{
	BOOM_PROCESS_OPERA control = { 0 };

	control.tag = TAG_WRITE;
	control.pid = (ULONG64)pid;
	control.address = (ULONG64)addr;
	control.buf = (ULONG64)pDataBuffer;
	control.size = size;

	RegSetValueEx(HKEY_LOCAL_MACHINE, _T(""), NULL, REG_BINARY, (byte*)&control, sizeof(control));

	return TRUE;
}

```

`BOOM_Console/CDrvController.h`:

```h
#pragma once

#include <tchar.h>
#include <windows.h>

#include "../inc/inc.h"

class CDrvController
{
public:
	CDrvController();
	~CDrvController();

	//
	//是否已加载驱动
	//
	BOOL DC_IsLoadBoomDrv();

	//
	//获取模块基址
	//
	ULONG64 DC_GetModuleAddr(ULONG pid, LPCWSTR lpModuleName);

	//
	//提交物理页,用于刚使用VirtualAlloc申请内存后，需要立刻写入
	//
	BOOL DC_ProbeRead(ULONG pid, ULONG64 addr);

	//-------------------------------READ--------------------------------------------------

	//
	//读内存 字节型(BYTE)
	//
	BYTE DC_ReadByte(ULONG pid, ULONG64 addr);

	//
	//读内存 短整数型(SHORT)
	//
	SHORT DC_ReadShort(ULONG pid, ULONG64 addr);

	//
	//读内存 整数型(INT)
	//
	INT DC_ReadInt(ULONG pid, ULONG64 addr);

	//
	//读内存 长整数型(INT64)
	//
	INT64 DC_ReadInt64(ULONG pid, ULONG64 addr);

	//
	//读内存 浮点型(FLOAT)
	//
	FLOAT DC_ReadFloat(ULONG pid, ULONG64 addr);

	//
	//读内存 字节集(Bytes)
	//
	BOOL DC_ReadBytes(ULONG pid, ULONG64 addr, _Out_ PBYTE pDataBuffer, ULONG size);

	//-------------------------------WRITE--------------------------------------------------

	//
	//写内存 字节型(BYTE)
	//
	BOOL DC_WriteByte(ULONG pid, ULONG64 addr, _In_ BYTE pDataBuffer);

	//
	//写内存 短整数型(SHORT)
	//
	BOOL DC_WriteShort(ULONG pid, ULONG64 addr, _In_ SHORT pDataBuffer);

	//
	//写内存 整数型(INT)
	//
	BOOL DC_WriteInt(ULONG pid, ULONG64 addr, _In_ INT pDataBuffer);

	//
	//写内存 长整数型(INT64)
	//
	BOOL DC_WriteInt64(ULONG pid, ULONG64 addr, _In_ INT64 pDataBuffer);

	//
	//写内存 浮点型(FLOAT)
	//
	BOOL DC_WriteFloat(ULONG pid, ULONG64 addr, _In_ FLOAT pDataBuffer);

	//
	//写内存 字节集(Bytes)
	//
	BOOL DC_WriteBytes(ULONG pid, ULONG64 addr, _In_ PBYTE pDataBuffer, ULONG size);

private:

	BOOL ReadMemory(ULONG64 pid, ULONG64 addr, _Out_ PBYTE pDataBuffer, ULONG size);

	BOOL WriteMemory(ULONG64 pid, ULONG64 addr, _In_ PBYTE pDataBuffer, ULONG size);

 };


```

`BOOM_Console/CDrvLoader.cpp`:

```cpp

//#include "stdafx.h"
#include "CDrvLoader.h"


CDrvLoader::CDrvLoader()
{
}


CDrvLoader::~CDrvLoader()
{
}

BOOL CDrvLoader::DL_EnableDrvLoadPrivilege()
{
	HANDLE hToken;
	LUID sedebugnameValue;
	TOKEN_PRIVILEGES tkp;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
	{
		return  FALSE;
	}
	if (!LookupPrivilegeValue(NULL, SE_LOAD_DRIVER_NAME, &sedebugnameValue))
	{
		CloseHandle(hToken);
		return FALSE;
	}
	tkp.PrivilegeCount = 1;
	tkp.Privileges[0].Luid = sedebugnameValue;
	tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, sizeof(tkp), NULL, NULL))
	{
		CloseHandle(hToken);
		return FALSE;
	}
	return TRUE;
}

BOOL CDrvLoader::DL_InstallDriver(LPCTSTR ServiceName, LPCTSTR DriverPath)
{
	SC_HANDLE sc_manage = NULL;
	SC_HANDLE sc_service = NULL;
	BOOL bRet = FALSE;

	do
	{
		sc_manage = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
		if (NULL == sc_manage)
		{
			m_errorCode = GetLastError();
			break;
		}

		sc_service = CreateService(
			sc_manage,
			ServiceName,
			ServiceName,
			SERVICE_ALL_ACCESS,
			SERVICE_KERNEL_DRIVER,
			SERVICE_DEMAND_START,
			SERVICE_ERROR_IGNORE,
			DriverPath,
			NULL, NULL, NULL, NULL, NULL);

		if (NULL == sc_service)
		{
			m_errorCode = GetLastError();
			break;
		}

		bRet = TRUE;
	} while (0);

	if (sc_service != NULL)
	{
		CloseServiceHandle(sc_service);
		sc_service = NULL;
	}

	if (sc_manage != NULL)
	{
		CloseServiceHandle(sc_manage);
		sc_manage = NULL;
	}

	return bRet;
}

BOOL CDrvLoader::DL_StartDriver(LPCTSTR ServiceName)
{
	SC_HANDLE sc_manage = NULL;
	SC_HANDLE sc_service = NULL;
	BOOL bRet = FALSE;

	do
	{
		sc_manage = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
		if (NULL == sc_manage)
		{
			m_errorCode = GetLastError();
			break;
		}

		sc_service = OpenService(sc_manage, ServiceName, SERVICE_ALL_ACCESS);
		if (NULL == sc_service)
		{
			m_errorCode = GetLastError();
			break;
		}

		if (StartService(sc_service, NULL, NULL) == FALSE)
		{
			m_errorCode = GetLastError();
			break;
		}

		bRet = TRUE;
	} while (0);

	if (sc_service != NULL)
	{
		CloseServiceHandle(sc_service);
		sc_service = NULL;
	}

	if (sc_manage != NULL)
	{
		CloseServiceHandle(sc_manage);
		sc_manage = NULL;
	}

	return bRet;
}

BOOL CDrvLoader::DL_StopDriver(LPCTSTR ServiceName)
{
	SC_HANDLE sc_manage = NULL;
	SC_HANDLE sc_service = NULL;
	SERVICE_STATUS ss = { 0 };
	BOOL bRet = FALSE;

	do
	{
		sc_manage = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
		if (NULL == sc_manage)
		{
			m_errorCode = GetLastError();
			break;
		}

		sc_service = OpenService(sc_manage, ServiceName, SERVICE_ALL_ACCESS);
		if (NULL == sc_service)
		{
			m_errorCode = GetLastError();
			break;
		}

		if (ControlService(sc_service, SERVICE_CONTROL_STOP, &ss) == FALSE)
		{
			m_errorCode = GetLastError();
			break;
		}

		bRet = TRUE;
	} while (0);

	if (sc_service != NULL)
	{
		CloseServiceHandle(sc_service);
		sc_service = NULL;
	}

	if (sc_manage != NULL)
	{
		CloseServiceHandle(sc_manage);
		sc_manage = NULL;
	}

	return bRet;
}

BOOL CDrvLoader::DL_UnInstallDriver(LPCTSTR ServiceName)
{
	SC_HANDLE sc_manage = NULL;
	SC_HANDLE sc_service = NULL;
	BOOL bRet = FALSE;

	do
	{
		sc_manage = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
		if (sc_manage == NULL)
		{
			m_errorCode = GetLastError();
			break;
		}

		sc_service = OpenService(sc_manage, ServiceName, SERVICE_ALL_ACCESS);
		if (sc_service == NULL)
		{
			m_errorCode = GetLastError();
			break;
		}

		if (DeleteService(sc_service) == FALSE)
		{
			m_errorCode = GetLastError();
			break;
		}

		bRet = TRUE;
	} while (0);

	if (sc_service != NULL)
	{
		CloseServiceHandle(sc_service);
		sc_service = NULL;
	}

	if (sc_manage != NULL)
	{
		CloseServiceHandle(sc_manage);
		sc_manage = NULL;
	}

	return bRet;
}


```

`BOOM_Console/CDrvLoader.h`:

```h
#pragma once


#include <tchar.h>
#include <windows.h>

//
//usr atl template
//
#include <atlbase.h>
#include <atlstr.h>

class CDrvLoader
{
public:
	CDrvLoader();
	~CDrvLoader();

	//
	//得到加载驱动权限的令牌
	//
	BOOL DL_EnableDrvLoadPrivilege();

	//
	//加载驱动
	//
	BOOL DL_InstallDriver(LPCTSTR ServiceName, LPCTSTR DriverPath);

	//
	//启动驱动
	//
	BOOL DL_StartDriver(LPCTSTR ServiceName);

	//
	//停止驱动
	//
	BOOL DL_StopDriver(LPCTSTR ServiceName);

	//
	//卸载驱动
	//
	BOOL DL_UnInstallDriver(LPCTSTR ServiceName);

private:

	DWORD m_errorCode;
};


```

`BOOM_Console/Console.cpp`:

```cpp

#include <stdio.h>
#include <windows.h>
#include <Shlwapi.h>

#include "CDrvLoader.h"
#include "CDrvController.h"

#pragma comment(lib,"Shlwapi.lib")

#define SERVICE_NAME	_T("BOOM")

int main()
{
	TCHAR drvPath[MAX_PATH];
	CDrvLoader drvLoad;
	CDrvController drvControl;


	//
	//try load boom driver
	//
	if (!drvControl.DC_IsLoadBoomDrv())
	{
		printf("not load boom driver1 \n");
		
		GetModuleFileName(NULL, drvPath, MAX_PATH);
		PathRemoveFileSpec(drvPath);
		_tcscat(drvPath, _T("\\BOOM.sys"));
		
		drvLoad.DL_InstallDriver(SERVICE_NAME, drvPath);
		drvLoad.DL_StartDriver(SERVICE_NAME);

		//
		//Because the method used is to hide the driver, we clean up the vestige.
		//
		drvLoad.DL_StopDriver(SERVICE_NAME);
		drvLoad.DL_UnInstallDriver(SERVICE_NAME);
		DeleteFile(drvPath);

		if (!drvControl.DC_IsLoadBoomDrv())
		{
			printf("not load boom driver2 \n");
			return 0;
		}
	}

	//
	//test 
	//

	HWND hwnd = FindWindow(_T("Progman"), _T("Program Manager"));
	DWORD expPID;

	GetWindowThreadProcessId(hwnd, &expPID);

	printf("explorer.exe pid = %d\n", expPID);

	// get module base address
	ULONG64 baseAddr;
	baseAddr = drvControl.DC_GetModuleAddr(expPID, L"ntdll.dll");
	printf("explorer.exe ntdll.dll baseAddr = %llx\n", baseAddr);
	baseAddr = drvControl.DC_GetModuleAddr(expPID, NULL);
	printf("explorer.exe baseAddr = %llx\n", baseAddr);


	//read memory
	baseAddr += 0x1000;
	unsigned char readBuf[0x10] = { 0 };
	drvControl.DC_ReadBytes(expPID, baseAddr, (PBYTE)readBuf, sizeof(readBuf));
	printf("readMemory-> %llx: ", baseAddr);
	for (int Index = 0; Index < sizeof(readBuf) ; Index++)
	{
		printf("%02X ", readBuf[Index]);
	}
	printf("\n");

	//write memory
	RtlFillMemory(readBuf, sizeof(readBuf), 0xFC);
	drvControl.DC_WriteBytes(expPID, baseAddr, (PBYTE)readBuf, sizeof(readBuf));
	printf("writeMemory-> %llx: ", baseAddr);
	for (int Index = 0; Index < sizeof(readBuf); Index++)
	{
		printf("%02X ", readBuf[Index]);
	}
	printf("\n");

	//second read memory
	drvControl.DC_ReadBytes(expPID, baseAddr, (PBYTE)readBuf, sizeof(readBuf));
	printf("readMemory-> %llx: ", baseAddr);
	for (int Index = 0; Index < sizeof(readBuf); Index++)
	{
		printf("%02X ", readBuf[Index]);
	}
	printf("\n");

	getchar();
	return 0;
}
```

`README.md`:

```md
# BOOM

## Introduction

This is a program that uses drivers to read and write to memory. 
It hides itself and changes the way of communication. Not found by ARK tools and game protector

## How Use

see CDrvController.h and Console.cpp

## Build 

IDE:VS2008 - VS2017

WDK: WDK7-WDK10

## snapshot

![avatar](snapshot1.png)

![avatar](snapshot2.png)

## support

win7x64 - win10x64
```

`cmpcallback.c`:

```c

#include "global.h"
#include "cmpcallback.h"

LARGE_INTEGER				g_Regcookie = { 0 };

extern
PSYSTEM_ROUTINE_ADDRESS		g_pSysRotineAddr;

//
//注册表相关拦截callback，用于读写内存
//
NTSTATUS RegisterCallback(
	_In_ PVOID CallbackContext,
	_In_opt_ PVOID Argument1,
	_In_opt_ PVOID Argument2
)
{
	UNREFERENCED_PARAMETER(CallbackContext);

	if (Argument1 == NULL)
	{
		return STATUS_SUCCESS;
	}

	if (Argument2 == NULL)
	{
		return STATUS_SUCCESS;
	}

	NTSTATUS Status = STATUS_SUCCESS;
	REG_NOTIFY_CLASS NotifyClass;
	PREG_SET_VALUE_KEY_INFORMATION PreSetValueInfo;

	NotifyClass = (REG_NOTIFY_CLASS)(ULONG_PTR)Argument1;



#if DBG
	volatile PSYSTEM_ROUTINE_ADDRESS		g_pSRA = (PSYSTEM_ROUTINE_ADDRESS)g_pSysRotineAddr;
#else
	volatile PSYSTEM_ROUTINE_ADDRESS		g_pSRA = (PSYSTEM_ROUTINE_ADDRESS)0x9090909090909090;
#endif


	PEPROCESS				process = NULL;
	PBOOM_PROCESS_OPERA		pInputData = NULL;
	PMYPEB					peb = NULL;
	KAPC_STATE				apc;
	KIRQL					kirql;
	PVOID					targetAddress = NULL;
	ULONG					targetSize = 0;
	ULONG64					cr0 = 0;
	UCHAR					probeBuf[1];
	SIZE_T					returnLenght = 0;
	BOOLEAN					attach = FALSE;

	switch (NotifyClass)
	{
	case RegNtPreSetValueKey:
	{
		PreSetValueInfo = (PREG_SET_VALUE_KEY_INFORMATION)Argument2;

		if (PreSetValueInfo->Type == REG_BINARY &&
			PreSetValueInfo->DataSize == sizeof(BOOM_PROCESS_OPERA))
		{

			pInputData = (PBOOM_PROCESS_OPERA)PreSetValueInfo->Data;

			//
			//debugBreak
			//

			//KdBreakPoint();

			if (g_pSRA->pfn_KeGetCurrentIrql() != PASSIVE_LEVEL)
			{
				return STATUS_SUCCESS;
			}

			switch (pInputData->tag)
			{
			case TAG_READ:
			{
				//
				//校验参数是否正确
				//

				Status = g_pSRA->pfn_PsLookupProcessByProcessId((HANDLE)pInputData->pid, &process);
				if (NT_SUCCESS(Status) && process != NULL && g_pSRA->pfn_MmIsAddressValid((PVOID)pInputData->buf))
				{

					//
					//创建MDL来读取内存
					//

					PMDL g_pmdl = g_pSRA->pfn_IoAllocateMdl((PVOID)pInputData->buf, pInputData->size, 0, 0, NULL);
					if (!g_pmdl)
						break;
					g_pSRA->pfn_MmBuildMdlForNonPagedPool(g_pmdl);
					unsigned char* Mapped = (unsigned char*)g_pSRA->pfn_MmMapLockedPages(g_pmdl, KernelMode);
					if (!Mapped)
					{
						g_pSRA->pfn_IoFreeMdl(g_pmdl);
						break;
					}

					//
					//attach上去的时候保存 读取目标地址和大小
					//

					targetAddress = (PVOID)pInputData->address;
					targetSize = pInputData->size;

					if (g_pSRA->pfn_PsGetCurrentProcess() != process)
					{
						g_pSRA->pfn_KeStackAttachProcess(process, &apc);
						attach = TRUE;
					}

					//
					//读内存
					//

					if (g_pSRA->pfn_MmIsAddressValid(targetAddress))
					{

						kirql = g_pSRA->pfn_KeRaiseIrqlToDpcLevel();
						g_pSRA->pfn_RtlCopyMemory(Mapped, targetAddress, targetSize);
						g_pSRA->pfn_KeLowerIrql(kirql);
					}

					if (attach)
					{
						g_pSRA->pfn_KeUnstackDetachProcess(&apc);
					}

					g_pSRA->pfn_MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
					g_pSRA->pfn_IoFreeMdl(g_pmdl);

				}

				break;
			}
			case TAG_WRITE:
			{

				//
				//校验参数是否正确
				//

				Status = g_pSRA->pfn_PsLookupProcessByProcessId((HANDLE)pInputData->pid, &process);
				if (NT_SUCCESS(Status) && process != NULL && g_pSRA->pfn_MmIsAddressValid((PVOID)pInputData->buf))
				{

					//
					//创建MDL来读取内存
					//

					PMDL g_pmdl = g_pSRA->pfn_IoAllocateMdl((PVOID)pInputData->buf, pInputData->size, 0, 0, NULL);
					if (!g_pmdl)
						break;
					g_pSRA->pfn_MmBuildMdlForNonPagedPool(g_pmdl);


					unsigned char* Mapped = (unsigned char*)g_pSRA->pfn_MmMapLockedPages(g_pmdl, KernelMode);
					if (!Mapped)
					{
						g_pSRA->pfn_IoFreeMdl(g_pmdl);
						break;
					}

					//
					//attach上去的时候保存 读取目标地址和大小
					//

					targetAddress = (PVOID)pInputData->address;
					targetSize = pInputData->size;

					if (g_pSRA->pfn_PsGetCurrentProcess() != process)
					{
						g_pSRA->pfn_KeStackAttachProcess(process, &apc);
						attach = TRUE;
					}


					if (g_pSRA->pfn_MmIsAddressValid(targetAddress))
					{

						cr0 = __readcr0();
						cr0 &= 0xfffffffffffeffff;
						__writecr0(cr0);
						_disable();

						kirql = g_pSRA->pfn_KeRaiseIrqlToDpcLevel();
						g_pSRA->pfn_RtlCopyMemory(targetAddress, Mapped, targetSize);
						g_pSRA->pfn_KeLowerIrql(kirql);

						cr0 = __readcr0();
						cr0 |= 0x10000;
						_enable();
						__writecr0(cr0);

					}

					if (attach)
					{
						g_pSRA->pfn_KeUnstackDetachProcess(&apc);
					}

					g_pSRA->pfn_MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
					g_pSRA->pfn_IoFreeMdl(g_pmdl);


				}
				break;
			}
			case TAG_GETMODULE:
			{
				//
				//校验参数是否正确
				//

				Status = g_pSRA->pfn_PsLookupProcessByProcessId((HANDLE)pInputData->pid, &process);
				if (NT_SUCCESS(Status) && process != NULL && g_pSRA->pfn_MmIsAddressValid((PVOID)pInputData->buf))
				{

					//
					//创建MDL来写内存
					//

					PMDL g_pmdl = g_pSRA->pfn_IoAllocateMdl((PVOID)pInputData->buf, pInputData->size, 0, 0, NULL);
					if (!g_pmdl)
						break;
					g_pSRA->pfn_MmBuildMdlForNonPagedPool(g_pmdl);
					unsigned char* Mapped = (unsigned char*)g_pSRA->pfn_MmMapLockedPages(g_pmdl, KernelMode);
					if (!Mapped)
					{
						g_pSRA->pfn_IoFreeMdl(g_pmdl);
						break;
					}

					//
					//attach上去
					//

					if (g_pSRA->pfn_PsGetCurrentProcess() != process)
					{
						g_pSRA->pfn_KeStackAttachProcess(process, &apc);
						attach = TRUE;
					}

					//
					//判断是否64位进程
					//
					if (g_pSRA->pfn_PsGetProcessWow64Process(process) == NULL)
					{
						peb = g_pSRA->pfn_PsGetProcessPeb(process);
						if (peb != NULL)
						{
							if (Mapped[0] == '\0') //传空则获取 exe->ImageBaseAddress 基址
							{
								kirql = g_pSRA->pfn_KeRaiseIrqlToDpcLevel();
								g_pSRA->pfn_RtlCopyMemory(Mapped, &peb->ImageBaseAddress, sizeof(PVOID));
								g_pSRA->pfn_KeLowerIrql(kirql);
							}
							else
							{
								PPEB_LDR_DATA	pPebLdrData = (PPEB_LDR_DATA)peb->Ldr;
								PLIST_ENTRY		pListEntryStart = NULL;
								PLIST_ENTRY		pListEntryEnd = NULL;

								PLDR_DATA_TABLE_ENTRY pLdrDataEntry = NULL;

								UNICODE_STRING	queryModuleName;
								g_pSRA->pfn_RtlInitUnicodeString(&queryModuleName, (PCWSTR)Mapped);

								pListEntryStart = pListEntryEnd = pPebLdrData->InMemoryOrderModuleList.Blink;

								do
								{

									pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)CONTAINING_RECORD(pListEntryStart, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

									if (g_pSRA->pfn_RtlCompareUnicodeString(&pLdrDataEntry->BaseDllName, &queryModuleName, TRUE) == 0)
									{
										kirql = g_pSRA->pfn_KeRaiseIrqlToDpcLevel();
										g_pSRA->pfn_RtlCopyMemory(Mapped, &pLdrDataEntry->DllBase, sizeof(PVOID));

										g_pSRA->pfn_KeLowerIrql(kirql);
										break;
									}

									pListEntryStart = pListEntryStart->Blink;

								} while (pListEntryStart != pListEntryEnd);


							}
						}
					}

					if (attach)
					{
						g_pSRA->pfn_KeUnstackDetachProcess(&apc);
					}

					g_pSRA->pfn_MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
					g_pSRA->pfn_IoFreeMdl(g_pmdl);

				}

				break;
			}
			case TAG_PROTECT:
			{
				g_pSRA->ProtectPid = (HANDLE)pInputData->pid;
				break;
			}
			case TAG_PROBEREAD:
			{
				Status = g_pSRA->pfn_PsLookupProcessByProcessId((HANDLE)pInputData->pid, &process);
				if (NT_SUCCESS(Status) && process != NULL)
				{
					g_pSRA->pfn_MmCopyVirtualMemory(process,
						(PVOID)pInputData->address,
						g_pSRA->pfn_PsGetCurrentProcess(),
						probeBuf,
						sizeof(probeBuf),
						KernelMode,
						&returnLenght);

				}
				break;
			}
			default:
				break;
			}

			if (process != NULL)
			{
				g_pSRA->pfn_ObDereferenceObject(process);
			}
			Status = STATUS_UNSUCCESSFUL;

		}
		break;
	}
	default:
		break;
	}

	return Status;

}
```

`cmpcallback.h`:

```h
#pragma once

//
//注册表相关拦截callback，用于读写内存
//
NTSTATUS RegisterCallback(
	_In_ PVOID CallbackContext,
	_In_opt_ PVOID Argument1,
	_In_opt_ PVOID Argument2
);
```

`driver.c`:

```c

#include "global.h"
#include "obcallback.h"
#include "cmpcallback.h"


//
//全局变量
//
PSYSTEM_ROUTINE_ADDRESS		g_pSysRotineAddr = NULL;

PVOID						g_shellcode = NULL;

PVOID						g_shellcode_pobj = NULL;

//
//引入其他变量
//
extern
LARGE_INTEGER				g_Regcookie;

extern
PVOID						g_obHandle;


//
//驱动卸载例程
//
void DriverUnload(
	_In_ PDRIVER_OBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);

	CmUnRegisterCallback(g_Regcookie);

	ObUnRegisterCallbacks(g_obHandle);

	if (g_pSysRotineAddr)
		ExFreePool(g_pSysRotineAddr);

	if (g_shellcode)
		ExFreePool(g_shellcode);

	if (g_shellcode_pobj)
		ExFreePool(g_shellcode_pobj);

}

//
//驱动默认响应操作
//
NTSTATUS DriverDefaultHandler(
	_In_ PDEVICE_OBJECT DeviceObject,
	_In_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Irp->IoStatus.Status;
}

//
//安全拷贝内存
//
NTSTATUS RtlSuperCopyMemory(IN VOID UNALIGNED* Destination, IN CONST VOID UNALIGNED* Source, IN ULONG Length)
{
	//Change memory properties.
	PMDL g_pmdl = IoAllocateMdl(Destination, Length, 0, 0, NULL);
	if (!g_pmdl)
		return STATUS_UNSUCCESSFUL;
	MmBuildMdlForNonPagedPool(g_pmdl);
	unsigned int* Mapped = (unsigned int*)MmMapLockedPages(g_pmdl, KernelMode);
	if (!Mapped)
	{
		IoFreeMdl(g_pmdl);
		return STATUS_UNSUCCESSFUL;
	}
	KIRQL kirql = KeRaiseIrqlToDpcLevel();
	RtlCopyMemory(Mapped, Source, Length);
	KeLowerIrql(kirql);
	//Restore memory properties.
	MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
	IoFreeMdl(g_pmdl);
	return STATUS_SUCCESS;
}


//
//锁定文件，防止被扫描到被修改的内存
//
void LockFile(wchar_t *filePath)
{
	UNICODE_STRING FileName;
	OBJECT_ATTRIBUTES ObjectAttributes;
	RtlInitUnicodeString(&FileName, filePath);
	InitializeObjectAttributes(&ObjectAttributes, &FileName,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		NULL, NULL);

	HANDLE FileHandle;
	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS NtStatus = ZwCreateFile(&FileHandle,
		GENERIC_READ,
		&ObjectAttributes,
		&IoStatusBlock,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		0,
		FILE_OPEN,
		FILE_SYNCHRONOUS_IO_NONALERT,
		NULL, 0);
	if (NT_SUCCESS(NtStatus))
	{
		DbgPrint("LockFile ok!\n");
	}

}

//
//枚举 跳板驱动
//
PVOID EnumJumpDrv(
	_In_ PDRIVER_OBJECT		pDriverObject,
	_In_ PUNICODE_STRING	JumpSysName,
	_In_ PVOID address,
	_In_ ULONG count)
{
	PUCHAR				pJumpDrvBase = NULL;
	PIMAGE_DOS_HEADER	pDosHead;
	PIMAGE_NT_HEADERS	pNtHead;
	PIMAGE_SECTION_HEADER pSecHead;
	ULONG				AlignPageSize;
	ULONG				cResult1, cResult2;
	BOOLEAN				bFinded = FALSE;

	if (pDriverObject == NULL || address == NULL || count == 0)
	{
		return NULL;
	}


	//
	//寻找目标驱动
	//
	PLDR_DATA_TABLE_ENTRY64		entry = (PLDR_DATA_TABLE_ENTRY64)pDriverObject->DriverSection;
	PLDR_DATA_TABLE_ENTRY64		first;

	first = entry;

	__try {
		do
		{
			if (entry->BaseDllName.Buffer != NULL)
			{
				if (RtlCompareUnicodeString(&entry->BaseDllName, JumpSysName, TRUE) == 0)
				{
					pJumpDrvBase = (PUCHAR)entry->DllBase;
					break;
				}
				entry = (PLDR_DATA_TABLE_ENTRY64)entry->InLoadOrderLinks.Blink;
			}


		} while (entry->InLoadOrderLinks.Blink != (ULONGLONG)first);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return NULL;
	}

	if (!pJumpDrvBase)
	{
		return NULL;
	}

	//
	//hook shellcode
	//

	UCHAR	hookCode[] = {
		0x53,
		0x48, 0xB8, 0xC7, 0x11, 0x62, 0xB3, 0x02, 0x01, 0x00, 0x00,
		0x48, 0xBB, 0x8E, 0xE3, 0x9D, 0x24, 0x1C, 0xCA, 0x00, 0x00,
		0x48, 0x33, 0xC3,
		0x5B,
		0x50,
		0xC3
	};



	pDosHead = (PIMAGE_DOS_HEADER)pJumpDrvBase;
	if (pDosHead->e_magic != IMAGE_DOS_SIGNATURE)
	{
		return NULL;
	}
	pNtHead = (PIMAGE_NT_HEADERS)\
		((LONG_PTR)pDosHead + pDosHead->e_lfanew);
	if (pNtHead->Signature != IMAGE_NT_SIGNATURE)
	{
		return NULL;
	}
	pSecHead = IMAGE_FIRST_SECTION(pNtHead);
	for (int i = 0; i < pNtHead->FileHeader.NumberOfSections; i++)
	{
		if (strcmp((const char*)(pSecHead->Name), ".text") == 0)
		{
			bFinded = TRUE;
			break;
		}
		pSecHead++;
	}

	//
	//没有找到PAGE 页面
	//

	if (!bFinded)
	{
		DbgPrint("[BOOM] not find to name PAGE in the section.\n");
		return NULL;
	}

	//
	//妈的 这么6？
	//

	if (pSecHead->Misc.VirtualSize % PAGE_SIZE == 0)
	{
		DbgPrint("[BOOM] PAGE virtual size not align space.\n");
		return NULL;
	}

	AlignPageSize = ((pSecHead->Misc.VirtualSize / PAGE_SIZE) + 1) * PAGE_SIZE;

	cResult1 = AlignPageSize - pSecHead->Misc.VirtualSize;
	cResult2 = count * 0x20;
	if (cResult1 < cResult2)
	{
		DbgPrint("[BOOM] PAGE virtual size algin space not enough.\n");
		return NULL;
	}

	//
	//已经被hook了
	//
	pJumpDrvBase += pSecHead->VirtualAddress;
	pJumpDrvBase += AlignPageSize;
	pJumpDrvBase -= cResult2;

	if (*pJumpDrvBase == hookCode[0])
	{
		return NULL;
	}
	ULONG64 addr = (ULONG64)address;
	ULONG64 time, tick;
	ULONG64 xor_number;
	KeQuerySystemTime(&time);
	KeQueryTickCount(&tick);
	tick ^= time;
	xor_number = tick ^ addr;

	memcpy(&hookCode[3], &xor_number, sizeof(ULONG64));
	memcpy(&hookCode[13], &tick, sizeof(ULONG64));

	RtlSuperCopyMemory(pJumpDrvBase, hookCode, sizeof(hookCode));

	return pJumpDrvBase;

}


//
//初始化全局NTAPI 地址
//
NTSTATUS InitSystemRoutineAddress(
)
{
	NTSTATUS			status = STATUS_UNSUCCESSFUL;
	UNICODE_STRING		routineName;

	g_pSysRotineAddr = \
		(PSYSTEM_ROUTINE_ADDRESS)ExAllocatePool(NonPagedPool, sizeof(SYSTEM_ROUTINE_ADDRESS));
	if (g_pSysRotineAddr == NULL)
	{
		return status;
	}
	g_pSysRotineAddr->ProtectPid = (HANDLE)-1;

	RtlInitUnicodeString(&routineName, L"PsGetCurrentProcessId");
	g_pSysRotineAddr->pfn_PsGetCurrentProcessId = \
		(fn_PsGetCurrentProcessId)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetCurrentProcessId == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsLookupProcessByProcessId");
	g_pSysRotineAddr->pfn_PsLookupProcessByProcessId = \
		(fn_PsLookupProcessByProcessId)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsLookupProcessByProcessId == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmIsAddressValid");
	g_pSysRotineAddr->pfn_MmIsAddressValid = \
		(fn_MmIsAddressValid)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmIsAddressValid == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"IoAllocateMdl");
	g_pSysRotineAddr->pfn_IoAllocateMdl = \
		(fn_IoAllocateMdl)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_IoAllocateMdl == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmBuildMdlForNonPagedPool");
	g_pSysRotineAddr->pfn_MmBuildMdlForNonPagedPool = \
		(fn_MmBuildMdlForNonPagedPool)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmBuildMdlForNonPagedPool == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmMapLockedPages");
	g_pSysRotineAddr->pfn_MmMapLockedPages = \
		(fn_MmMapLockedPages)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmMapLockedPages == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"IoFreeMdl");
	g_pSysRotineAddr->pfn_IoFreeMdl = \
		(fn_IoFreeMdl)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_IoFreeMdl == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsGetCurrentProcess");
	g_pSysRotineAddr->pfn_PsGetCurrentProcess = \
		(fn_PsGetCurrentProcess)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetCurrentProcess == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeStackAttachProcess");
	g_pSysRotineAddr->pfn_KeStackAttachProcess = \
		(fn_KeStackAttachProcess)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeStackAttachProcess == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeRaiseIrqlToDpcLevel");
	g_pSysRotineAddr->pfn_KeRaiseIrqlToDpcLevel = \
		(fn_KeRaiseIrqlToDpcLevel)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeRaiseIrqlToDpcLevel == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"RtlCopyMemory");
	g_pSysRotineAddr->pfn_RtlCopyMemory = \
		(fn_RtlCopyMemory)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_RtlCopyMemory == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeLowerIrql");
	g_pSysRotineAddr->pfn_KeLowerIrql = \
		(fn_KeLowerIrql)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeLowerIrql == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeUnstackDetachProcess");
	g_pSysRotineAddr->pfn_KeUnstackDetachProcess = \
		(fn_KeUnstackDetachProcess)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeUnstackDetachProcess == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmUnmapLockedPages");
	g_pSysRotineAddr->pfn_MmUnmapLockedPages = \
		(fn_MmUnmapLockedPages)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmUnmapLockedPages == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"ObDereferenceObject");
	g_pSysRotineAddr->pfn_ObDereferenceObject = \
		(fn_ObDereferenceObject)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_ObDereferenceObject == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsGetProcessWow64Process");
	g_pSysRotineAddr->pfn_PsGetProcessWow64Process = \
		(fn_PsGetProcessWow64Process)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetProcessWow64Process == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsGetProcessPeb");
	g_pSysRotineAddr->pfn_PsGetProcessPeb = \
		(fn_PsGetProcessPeb)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetProcessPeb == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"PsGetProcessId");
	g_pSysRotineAddr->pfn_PsGetProcessId = \
		(fn_PsGetProcessId)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_PsGetProcessId == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmUnlockPages");
	g_pSysRotineAddr->pfn_MmUnlockPages = \
		(fn_MmUnlockPages)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmUnlockPages == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmProbeAndLockPages");
	g_pSysRotineAddr->pfn_MmProbeAndLockPages = \
		(fn_MmProbeAndLockPages)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmProbeAndLockPages == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"KeGetCurrentIrql");
	g_pSysRotineAddr->pfn_KeGetCurrentIrql = \
		(fn_KeGetCurrentIrql)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_KeGetCurrentIrql == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"MmCopyVirtualMemory");
	g_pSysRotineAddr->pfn_MmCopyVirtualMemory = \
		(fn_MmCopyVirtualMemory)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_MmCopyVirtualMemory == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"RtlInitUnicodeString");
	g_pSysRotineAddr->pfn_RtlInitUnicodeString = \
		(fn_RtlInitUnicodeString)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_RtlInitUnicodeString == NULL)
	{
		return status;
	}

	RtlInitUnicodeString(&routineName, L"RtlCompareUnicodeString");
	g_pSysRotineAddr->pfn_RtlCompareUnicodeString = \
		(fn_RtlCompareUnicodeString)MmGetSystemRoutineAddress(&routineName);
	if (g_pSysRotineAddr->pfn_RtlCompareUnicodeString == NULL)
	{
		return status;
	}


	return STATUS_SUCCESS;
}



//
//驱动入口
//
NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING  RegistryPath)
{

	//DbgBreakPoint();

	UNREFERENCED_PARAMETER(RegistryPath);
	NTSTATUS			status;
	PUCHAR				pRepRoutinePoint;
	UNICODE_STRING		altitude;
	UNICODE_STRING		DeviceName;

	//set callback functions
	DriverObject->DriverUnload = DriverUnload;
	for (unsigned int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
		DriverObject->MajorFunction[i] = DriverDefaultHandler;


	//
	//先初始化地址
	//

	if (!NT_SUCCESS(InitSystemRoutineAddress()))
	{
		status = STATUS_APP_INIT_FAILURE;
		goto __exit;
	}

	//
	//初始化shellcode
	//

	g_shellcode = ExAllocatePool(NonPagedPool, PAGE_SIZE);
	if (!g_shellcode)
	{
		status = STATUS_MEMORY_NOT_ALLOCATED;
		goto __exit;
	}
	RtlSuperCopyMemory(g_shellcode, (PVOID)RegisterCallback, PAGE_SIZE);

	pRepRoutinePoint = (PUCHAR)g_shellcode;
	for (int i = 0; i < PAGE_SIZE - sizeof(ULONG64); i++)
	{
		if (pRepRoutinePoint[i] == 0x90 &&
			*(ULONG64*)(&pRepRoutinePoint[i]) == 0x9090909090909090)
		{
			PVOID	fined = &pRepRoutinePoint[i];
			RtlSuperCopyMemory(fined, &g_pSysRotineAddr, sizeof(g_pSysRotineAddr));
			break;
		}
	}
	//object hook
	g_shellcode_pobj = ExAllocatePool(NonPagedPool, PAGE_SIZE);
	if (!g_shellcode_pobj)
	{
		status = STATUS_MEMORY_NOT_ALLOCATED;
		goto __exit;
	}
	RtlSuperCopyMemory(g_shellcode_pobj, (PVOID)ObPreopCallback, PAGE_SIZE);

	pRepRoutinePoint = (PUCHAR)g_shellcode_pobj;
	for (int i = 0; i < PAGE_SIZE - sizeof(ULONG64); i++)
	{
		if (pRepRoutinePoint[i] == 0x90 &&
			*(ULONG64*)(&pRepRoutinePoint[i]) == 0x9090909090909090)
		{
			PVOID	fined = &pRepRoutinePoint[i];
			RtlSuperCopyMemory(fined, &g_pSysRotineAddr, sizeof(g_pSysRotineAddr));
			break;
		}
	}

	//
	//枚举其他驱动做跳板代码
	//

#ifndef DBG
	PVOID			FakeCallback, FakeCallback2;
	UNICODE_STRING	fakeDrv;

	RtlInitUnicodeString(&fakeDrv, L"Beep.sys");
	FakeCallback = EnumJumpDrv(DriverObject, &fakeDrv, g_shellcode, 1);
	FakeCallback2 = EnumJumpDrv(DriverObject, &fakeDrv, g_shellcode_pobj, 2);

	if (FakeCallback == NULL)
	{
		status = STATUS_ALIAS_EXISTS;
		goto __exit;
	}
#endif

	//
	//先激活object hook
	//
	RtlInitUnicodeString(&DeviceName, L"\\Driver\\Beep");

	PDRIVER_OBJECT pDriver = NULL;
	status = ObReferenceObjectByName(&DeviceName,
		OBJ_CASE_INSENSITIVE,
		NULL, FILE_ALL_ACCESS,
		*IoDriverObjectType,
		KernelMode, NULL,
		(PVOID*)&pDriver);

	if (NT_SUCCESS(status))
	{
		BypassCheckSign(DriverObject);
		BypassCheckSign(pDriver);
		ObDereferenceObject(pDriver);
	}
#if DBG
	ObRegiserCllabck((PVOID)ObPreopCallback);
#else
	ObRegiserCllabck(FakeCallback2);
#endif

	//
	//注册注册表回调
	//

	RtlInitUnicodeString(&altitude, L"396456");
#if DBG
	status = CmRegisterCallbackEx(
		(PEX_CALLBACK_FUNCTION)RegisterCallback,
		&altitude,
		DriverObject,
		NULL,
		&g_Regcookie,
		NULL);
#else
	status = CmRegisterCallbackEx(
		(PEX_CALLBACK_FUNCTION)FakeCallback,
		&altitude,
		DriverObject,
		NULL,
		&g_Regcookie,
		NULL);
#endif

	if (!NT_SUCCESS(status))
	{
		goto __exit;
	}
	else
	{
		//
		//这里是全部操作成功，但我们得返回 0xC0000088 来标记以上工作全部成功
		//
#if DBG
		return STATUS_SUCCESS;
#else
		return STATUS_UNSUCCESSFUL;
#endif
	}

__exit:
	if (g_pSysRotineAddr)
		ExFreePool(g_pSysRotineAddr);
	if (g_shellcode)
		ExFreePool(g_shellcode);
	if (g_shellcode_pobj)
		ExFreePool(g_shellcode_pobj);

	return status;

	}

```

`global.h`:

```h

#pragma once

#include <ntifs.h>
#include <intrin.h>
#include <ntimage.h>

#include "inc/inc.h"

#pragma warning(disable:4201)

//
//内存操作flasg
//
#define PROCESS_TERMINATE                  (0x0001)  
#define PROCESS_CREATE_THREAD              (0x0002)  
#define PROCESS_SET_SESSIONID              (0x0004)  
#define PROCESS_VM_OPERATION               (0x0008)  
#define PROCESS_VM_READ                    (0x0010)  
#define PROCESS_VM_WRITE                   (0x0020)  
#define PROCESS_DUP_HANDLE                 (0x0040)  
#define PROCESS_CREATE_PROCESS             (0x0080)  
#define PROCESS_SET_QUOTA                  (0x0100)  
#define PROCESS_SET_INFORMATION            (0x0200)  
#define PROCESS_QUERY_INFORMATION          (0x0400)  
#define PROCESS_SUSPEND_RESUME             (0x0800)  
#define PROCESS_QUERY_LIMITED_INFORMATION  (0x1000)  
#define PROCESS_SET_LIMITED_INFORMATION    (0x2000)  

//
//系统模块链表
//
typedef struct _LDR_DATA_TABLE_ENTRY64 {
	LIST_ENTRY64 InLoadOrderLinks;
	LIST_ENTRY64 InMemoryOrderLinks;
	LIST_ENTRY64 InInitializationOrderLinks;
	ULONG64 DllBase;
	ULONG64 EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG   Flags;
	USHORT  LoadCount;
	USHORT TlsIndex;
	union {
		LIST_ENTRY64 HashLinks;
		struct _Unkown1 {
			ULONG64 SectionPointer;
			ULONG   CheckSum;
		};
	};
	union {
		ULONG   TimeDateStamp;
		ULONG64 LoadedImports;

	};

	//
	// NOTE : Do not grow this structure at the dump files used a packed
	// array of these structures.
	//

} LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64;

//
//自定义PEB结构
//
typedef struct _MYPEB
{
	union
	{
		struct dummy00
		{
			UCHAR InheritedAddressSpace;
			UCHAR ReadImageFileExecOptions;
			UCHAR BeingDebugged;
			UCHAR BitField;
		};
		PVOID dummy01;
	};

	PVOID Mutant;
	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} MYPEB, *PMYPEB;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	ULONG Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID	EntryInProgress;
	ULONG	ShutdownInProgress;
	PVOID	ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	union
	{
		ULONG SizeOfImage;
		PVOID dummy01;
	};
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;

} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

#ifdef __cplusplus    
extern "C"
{
#endif    
	NTKERNELAPI
		NTSTATUS
		ObReferenceObjectByName(
			IN PUNICODE_STRING ObjectName,
			IN ULONG Attributes,
			IN PACCESS_STATE PassedAccessState OPTIONAL,
			IN ACCESS_MASK DesiredAccess OPTIONAL,
			IN POBJECT_TYPE ObjectType,
			IN KPROCESSOR_MODE AccessMode,
			IN OUT PVOID ParseContext OPTIONAL,
			OUT PVOID *Object
		);
	extern POBJECT_TYPE *IoDriverObjectType;
#ifdef __cplusplus    
}
#endif    

//
//自己定义NTAPI，用于shellcode动态调用
//
typedef HANDLE(NTAPI *fn_PsGetCurrentProcessId)(
	VOID
	);

typedef NTSTATUS(NTAPI *fn_PsLookupProcessByProcessId)(
	_In_ HANDLE ProcessId,
	_Outptr_ PEPROCESS *Process
	);

typedef BOOLEAN(NTAPI *fn_MmIsAddressValid)(
	_In_ PVOID VirtualAddress
	);

typedef PMDL(NTAPI *fn_IoAllocateMdl)(
	_In_opt_ __drv_aliasesMem PVOID VirtualAddress,
	_In_ ULONG Length,
	_In_ BOOLEAN SecondaryBuffer,
	_In_ BOOLEAN ChargeQuota,
	_Inout_opt_ PIRP Irp
	);

typedef VOID(NTAPI *fn_MmBuildMdlForNonPagedPool)(
	_Inout_ PMDL MemoryDescriptorList
	);

typedef PVOID(NTAPI *fn_MmMapLockedPages)(
	_Inout_ PMDL MemoryDescriptorList,
	_In_ __drv_strictType(KPROCESSOR_MODE / enum _MODE, __drv_typeConst)
	KPROCESSOR_MODE AccessMode
	);

typedef VOID(NTAPI *fn_IoFreeMdl)(
	PMDL Mdl
	);

typedef PEPROCESS(NTAPI *fn_PsGetCurrentProcess)(
	VOID
	);

typedef VOID(NTAPI *fn_KeStackAttachProcess)(
	_Inout_ PRKPROCESS PROCESS,
	_Out_ PRKAPC_STATE ApcState
	);

typedef KIRQL(NTAPI *fn_KeRaiseIrqlToDpcLevel)(
	VOID
	);

typedef VOID(NTAPI *fn_RtlCopyMemory)(
	void *Dst,
	const void *Src,
	size_t Size);

typedef VOID(NTAPI *fn_KeLowerIrql)(
	_In_ _Notliteral_ _IRQL_restores_ KIRQL NewIrql
	);

typedef VOID(NTAPI *fn_KeUnstackDetachProcess)(
	_In_ PRKAPC_STATE ApcState
	);

typedef VOID(NTAPI *fn_MmUnmapLockedPages)(
	_In_ PVOID BaseAddress,
	_Inout_ PMDL MemoryDescriptorList
	);

typedef LONG_PTR(NTAPI *fn_ObDereferenceObject)(
	_In_ PVOID Object
	);

typedef PVOID(NTAPI *fn_PsGetProcessWow64Process)(
	IN PEPROCESS Process);

typedef PMYPEB(NTAPI *fn_PsGetProcessPeb)(
	IN PEPROCESS Process);

typedef HANDLE(NTAPI* fn_PsGetProcessId)(
	_In_ PEPROCESS Process
	);

typedef VOID(NTAPI *fn_MmUnlockPages)(
	_Inout_ PMDL MemoryDescriptorList
	);

typedef VOID(NTAPI* fn_MmProbeAndLockPages)(
	_Inout_ PMDL MemoryDescriptorList,
	_In_ KPROCESSOR_MODE AccessMode,
	_In_ LOCK_OPERATION Operation
	);

typedef KIRQL(NTAPI *fn_KeGetCurrentIrql)(
	VOID);

typedef NTSTATUS(NTAPI* fn_MmCopyVirtualMemory)(
	IN PEPROCESS FromProcess,
	IN CONST VOID *FromAddress,
	IN PEPROCESS ToProcess,
	OUT PVOID ToAddress,
	IN SIZE_T BufferSize,
	IN KPROCESSOR_MODE PreviousMode,
	OUT PSIZE_T NumberOfBytesCopied
	);

typedef VOID(NTAPI* fn_RtlInitUnicodeString)(
	PUNICODE_STRING DestinationString,
	PCWSTR SourceString
	);

typedef LONG(NTAPI* fn_RtlCompareUnicodeString)(
	_In_ PCUNICODE_STRING String1,
	_In_ PCUNICODE_STRING String2,
	_In_ BOOLEAN CaseInSensitive
	);

//
//自定义全局数据，包含NTAPI 地址和一些数据
//
typedef struct _SYSTEM_ROUTINE_ADDRESS {
	HANDLE			ProtectPid;
	ULONG64			tag;
	ULONG64			flags;
	fn_PsGetCurrentProcessId pfn_PsGetCurrentProcessId;
	fn_PsLookupProcessByProcessId pfn_PsLookupProcessByProcessId;
	fn_MmIsAddressValid pfn_MmIsAddressValid;
	fn_IoAllocateMdl pfn_IoAllocateMdl;
	fn_MmBuildMdlForNonPagedPool pfn_MmBuildMdlForNonPagedPool;
	fn_MmMapLockedPages pfn_MmMapLockedPages;
	fn_IoFreeMdl pfn_IoFreeMdl;
	fn_PsGetCurrentProcess pfn_PsGetCurrentProcess;
	fn_KeStackAttachProcess pfn_KeStackAttachProcess;
	fn_KeRaiseIrqlToDpcLevel pfn_KeRaiseIrqlToDpcLevel;
	fn_RtlCopyMemory pfn_RtlCopyMemory;
	fn_KeLowerIrql pfn_KeLowerIrql;
	fn_KeUnstackDetachProcess pfn_KeUnstackDetachProcess;
	fn_MmUnmapLockedPages pfn_MmUnmapLockedPages;
	fn_ObDereferenceObject pfn_ObDereferenceObject;
	fn_PsGetProcessWow64Process pfn_PsGetProcessWow64Process;
	fn_PsGetProcessPeb pfn_PsGetProcessPeb;
	fn_PsGetProcessId pfn_PsGetProcessId;
	fn_MmUnlockPages pfn_MmUnlockPages;
	fn_MmProbeAndLockPages pfn_MmProbeAndLockPages;
	fn_KeGetCurrentIrql pfn_KeGetCurrentIrql;
	fn_MmCopyVirtualMemory pfn_MmCopyVirtualMemory;
	fn_RtlInitUnicodeString pfn_RtlInitUnicodeString;
	fn_RtlCompareUnicodeString pfn_RtlCompareUnicodeString;

}SYSTEM_ROUTINE_ADDRESS, *PSYSTEM_ROUTINE_ADDRESS;
```

`inc/inc.h`:

```h

#pragma once

#define	TAG_READ		0x85648485
#define	TAG_WRITE		0x89756453
#define TAG_GETMODULE	0x56165511
#define TAG_PROTECT		0x98844446
#define TAG_PROBEREAD	0x68468846

#pragma pack(push,1)
typedef struct _BOOM_PROCESS_OPERA {
	ULONG		tag;		//标记
	ULONG		flags;		//标记
	ULONG64		pid;		//target process
	ULONG64		address;	//读取地址
	ULONG64		buf;		//缓冲区指针
	ULONG		size;		//需要读取大小
}BOOM_PROCESS_OPERA, *PBOOM_PROCESS_OPERA;
#pragma pack(pop)
```

`obcallback.c`:

```c

#include "global.h"
#include "obcallback.h"

PVOID						g_obHandle = NULL;

extern
PSYSTEM_ROUTINE_ADDRESS		g_pSysRotineAddr;

//
//bypass objecthook푯츰
//
void BypassCheckSign(
	_In_ PDRIVER_OBJECT pDriverObj)
{
	//STRUCT FOR WIN64
	typedef struct _LDR_DATA                         			// 24 elements, 0xE0 bytes (sizeof)
	{
		LIST_ENTRY64 InLoadOrderLinks;
		LIST_ENTRY64 InMemoryOrderLinks;
		LIST_ENTRY64 InInitializationOrderLinks;
		ULONG64 DllBase;
		ULONG64 EntryPoint;
		ULONG SizeOfImage;
		UNICODE_STRING FullDllName;
		UNICODE_STRING BaseDllName;
		ULONG   Flags;
	}LDR_DATA, *PLDR_DATA;
	PLDR_DATA ldr;
	ldr = (PLDR_DATA)(pDriverObj->DriverSection);
	ldr->Flags |= 0x20;
}

//
//괏빱쏵넋
//
NTSTATUS ObRegiserCllabck(
	_In_ PVOID ObjectCllbackAddr)
{
	NTSTATUS	status;
	OB_CALLBACK_REGISTRATION obReg;
	OB_OPERATION_REGISTRATION opReg;

	memset(&obReg, 0, sizeof(obReg));
	obReg.Version = ObGetFilterVersion();
	obReg.OperationRegistrationCount = 1;
	obReg.RegistrationContext = NULL;
	RtlInitUnicodeString(&obReg.Altitude, L"354156");
	obReg.OperationRegistration = &opReg;
	memset(&opReg, 0, sizeof(opReg));
	opReg.ObjectType = PsProcessType;
	opReg.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
	opReg.PreOperation = (POB_PRE_OPERATION_CALLBACK)ObjectCllbackAddr;
	status = ObRegisterCallbacks(&obReg, &g_obHandle);

	return status;
}


//
//쏵넋괏빱callback
//
OB_PREOP_CALLBACK_STATUS ObPreopCallback(
	_In_ PVOID RegistrationContext,
	_In_ POB_PRE_OPERATION_INFORMATION pOperationInformation)
{
	UNREFERENCED_PARAMETER(RegistrationContext);

	if (pOperationInformation == NULL || pOperationInformation->Object == NULL)
	{
		return OB_PREOP_SUCCESS;
	}

#if DBG
	volatile PSYSTEM_ROUTINE_ADDRESS		g_pSRA = (PSYSTEM_ROUTINE_ADDRESS)g_pSysRotineAddr;
#else
	volatile PSYSTEM_ROUTINE_ADDRESS		g_pSRA = (PSYSTEM_ROUTINE_ADDRESS)0x9090909090909090;
#endif

	HANDLE pid = g_pSRA->pfn_PsGetProcessId((PEPROCESS)pOperationInformation->Object);

	if (g_pSRA->ProtectPid == pid)
	{
		if (pOperationInformation->Operation == OB_OPERATION_HANDLE_CREATE)
		{
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_TERMINATE)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_TERMINATE);
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_VM_OPERATION)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_VM_OPERATION);
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_VM_READ)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_VM_READ);
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_VM_WRITE)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_VM_WRITE);
			if (pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_SUSPEND_RESUME)
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= (~PROCESS_SUSPEND_RESUME);

		}
		if (pOperationInformation->Operation == OB_OPERATION_HANDLE_DUPLICATE)
		{
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_TERMINATE)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_TERMINATE);
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_VM_OPERATION)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_VM_OPERATION);
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_VM_READ)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_VM_READ);
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_VM_WRITE)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_VM_WRITE);
			if (pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_SUSPEND_RESUME)
				pOperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess &= (~PROCESS_SUSPEND_RESUME);
		}
	}

	return OB_PREOP_SUCCESS;
}
```

`obcallback.h`:

```h
#pragma once


//
//bypass objecthook签名
//
void BypassCheckSign(
	_In_ PDRIVER_OBJECT pDriverObj);
//
//注册callback
//
NTSTATUS ObRegiserCllabck(
	_In_ PVOID ObjectCllbackAddr);


//
//进程保护callback
//
OB_PREOP_CALLBACK_STATUS ObPreopCallback(
	_In_ PVOID RegistrationContext,
	_In_ POB_PRE_OPERATION_INFORMATION pOperationInformation);
```

`regStruct.h`:

```h
#ifndef _REG_STRUCT_H
#define _REG_STRUCT_H

#define MAX_ALTITUDE_BUFFER_LENGTH 10


typedef struct _RMCALLBACK_CONTEXT {

	//
	// A bit mask of all transaction notifications types that the RM Callback is 
	// notified of.
	//
	ULONG Notification;

	//
	// The handle to an enlistment
	//
	HANDLE Enlistment;

} RMCALLBACK_CONTEXT, *PRMCALLBACK_CONTEXT;

//
// List of callback modes
//
typedef enum _CALLBACK_MODE {
	CALLBACK_MODE_PRE_NOTIFICATION_BLOCK,
	CALLBACK_MODE_PRE_NOTIFICATION_BYPASS,
	CALLBACK_MODE_POST_NOTIFICATION_OVERRIDE_ERROR,
	CALLBACK_MODE_POST_NOTIFICATION_OVERRIDE_SUCCESS,
	CALLBACK_MODE_TRANSACTION_REPLAY,
	CALLBACK_MODE_TRANSACTION_ENLIST,
	CALLBACK_MODE_MULTIPLE_ALTITUDE_BLOCK_DURING_PRE,
	CALLBACK_MODE_MULTIPLE_ALTITUDE_INTERNAL_INVOCATION,
	CALLBACK_MODE_MULTIPLE_ALTITUDE_MONITOR,
	CALLBACK_MODE_SET_CALL_CONTEXT,
	CALLBACK_MODE_SET_OBJECT_CONTEXT,
	CALLBACK_MODE_CAPTURE,
	CALLBACK_MODE_VERSION_BUGCHECK,
	CALLBACK_MODE_VERSION_CREATE_OPEN_V1,
} CALLBACK_MODE;


typedef struct _CALLBACK_CONTEXT {

	//
	// List of callback contexts currently active
	//
	LIST_ENTRY CallbackCtxList;

	//
	// Specifies which callback helper method to use
	//
	CALLBACK_MODE CallbackMode;

	//
	// Records the current ProcessId to filter out registry operation from
	// other processes.
	//
	HANDLE ProcessId;

	//
	// Records the altitude that the callback was registered at
	//
	UNICODE_STRING Altitude;
	WCHAR AltitudeBuffer[MAX_ALTITUDE_BUFFER_LENGTH];

	//
	// Records the cookie returned by the registry when the callback was 
	// registered
	//
	LARGE_INTEGER Cookie;

	//
	// A pointer to the context for the transaction callback. 
	// Used to enlist on a transaction. Only used in the transaction samples.
	//
	PRMCALLBACK_CONTEXT RMCallbackCtx;

	//
	// These fields record information for verifying the behavior of the
	// certain samples. They are not used in all samples
	//

	//
	// Number of times the RegNtCallbackObjectContextCleanup 
	// notification was received
	//
	LONG ContextCleanupCount;

	//
	// Number of times the callback saw a notification with the call or
	// object context set correctly.
	//
	LONG NotificationWithContextCount;

	//
	// Number of times callback saw a notirication without call or without
	// object context set correctly
	//
	LONG NotificationWithNoContextCount;

	//
	// Number of pre-notifications received
	//
	LONG PreNotificationCount;

	//
	// Number of post-notifications received
	//
	LONG PostNotificationCount;

} CALLBACK_CONTEXT, *PCALLBACK_CONTEXT;


#endif

```

`utils.cpp`:

```cpp
#include "utils.h"

void* RtlAllocateMemory(bool InZeroMemory, SIZE_T InSize)
{
    void* Result = ExAllocatePoolWithTag(NonPagedPool, InSize, 'HIDE');
    if(InZeroMemory && (Result != NULL))
        RtlZeroMemory(Result, InSize);
    return Result;
}

void RtlFreeMemory(void* InPointer)
{
    ExFreePool(InPointer);
}

//Based on: http://leguanyuan.blogspot.nl/2013/09/x64-inline-hook-zwcreatesection.html
NTSTATUS RtlSuperCopyMemory(IN VOID UNALIGNED* Destination, IN CONST VOID UNALIGNED* Source, IN ULONG Length)
{
    //Change memory properties.
    PMDL g_pmdl = IoAllocateMdl(Destination, Length, 0, 0, NULL);
    if(!g_pmdl)
        return STATUS_UNSUCCESSFUL;
    MmBuildMdlForNonPagedPool(g_pmdl);
    unsigned int* Mapped = (unsigned int*)MmMapLockedPages(g_pmdl, KernelMode);
    if(!Mapped)
    {
        IoFreeMdl(g_pmdl);
        return STATUS_UNSUCCESSFUL;
    }
    KIRQL kirql = KeRaiseIrqlToDpcLevel();
    RtlCopyMemory(Mapped, Source, Length);
    KeLowerIrql(kirql);
    //Restore memory properties.
    MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
    IoFreeMdl(g_pmdl);
    return STATUS_SUCCESS;
}
```

`utils.h`:

```h
#ifndef _GLOBAL_H
#define _GLOBAL_H

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501
#endif

#ifdef __cplusplus
extern "C"
{
#endif

#include <ntifs.h>
#include <ntddstor.h>
#include <mountdev.h>
#include <ntddvol.h>
#include <ntstrsafe.h>
#include <ntimage.h>

#ifdef __cplusplus
}
#endif

void* RtlAllocateMemory(bool InZeroMemory, SIZE_T InSize);
void RtlFreeMemory(void* InPointer);
NTSTATUS RtlSuperCopyMemory(IN VOID UNALIGNED* Destination, IN CONST VOID UNALIGNED* Source, IN ULONG Length);

#endif
```