Project Path: arc_dnakov_radare2-mcp_jyfehzlc

Source Tree:

```txt
arc_dnakov_radare2-mcp_jyfehzlc
‚îú‚îÄ‚îÄ AGENTS.md
‚îú‚îÄ‚îÄ INSTALL.md
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ TODO.md
‚îú‚îÄ‚îÄ autogen.sh
‚îú‚îÄ‚îÄ config.h.w64
‚îú‚îÄ‚îÄ configure
‚îú‚îÄ‚îÄ configure.acr
‚îú‚îÄ‚îÄ dist
‚îÇ   ‚îú‚îÄ‚îÄ debian
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CONFIG
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DESCR
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Makefile
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ build.sh
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deb.mk
‚îÇ   ‚îú‚îÄ‚îÄ docker
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dockcross
‚îÇ   ‚îî‚îÄ‚îÄ scripts
‚îÇ       ‚îú‚îÄ‚îÄ indent.pl
‚îÇ       ‚îî‚îÄ‚îÄ indent.py
‚îú‚îÄ‚îÄ meson.build
‚îú‚îÄ‚îÄ meson_options.txt
‚îú‚îÄ‚îÄ prompts
‚îÇ   ‚îú‚îÄ‚îÄ crackme_solver.r2ai.md
‚îÇ   ‚îú‚îÄ‚îÄ document_function.r2ai.md
‚îÇ   ‚îú‚îÄ‚îÄ find_control_flow_path.r2ai.md
‚îÇ   ‚îî‚îÄ‚îÄ find_crypto_material.r2ai.md
‚îú‚îÄ‚îÄ r2mcp.png
‚îú‚îÄ‚îÄ r2mcp.svg
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ config.h.acr
‚îÇ   ‚îú‚îÄ‚îÄ curl.inc.c
‚îÇ   ‚îú‚îÄ‚îÄ dsltest.c
‚îÇ   ‚îú‚îÄ‚îÄ jsonrpc.c
‚îÇ   ‚îú‚îÄ‚îÄ jsonrpc.h
‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îú‚îÄ‚îÄ plugin.c
‚îÇ   ‚îú‚îÄ‚îÄ prompts.c
‚îÇ   ‚îú‚îÄ‚îÄ prompts.h
‚îÇ   ‚îú‚îÄ‚îÄ r2api.inc.c
‚îÇ   ‚îú‚îÄ‚îÄ r2mcp.c
‚îÇ   ‚îú‚îÄ‚îÄ r2mcp.h
‚îÇ   ‚îú‚îÄ‚îÄ readbuffer.c
‚îÇ   ‚îú‚îÄ‚îÄ readbuffer.h
‚îÇ   ‚îú‚îÄ‚îÄ tools.c
‚îÇ   ‚îú‚îÄ‚îÄ tools.h
‚îÇ   ‚îú‚îÄ‚îÄ utils.inc.c
‚îÇ   ‚îú‚îÄ‚îÄ validation.c
‚îÇ   ‚îî‚îÄ‚îÄ validation.h
‚îú‚îÄ‚îÄ svc
‚îÇ   ‚îú‚îÄ‚îÄ Makefile
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îî‚îÄ‚îÄ r2mcp-svc.c
‚îî‚îÄ‚îÄ test.sh

```

`AGENTS.md`:

```md
# Agentic Coding Guidelines for the r2mcp (radare2 MCP) server

This document contains repository- and project-specific guidance for editing and building the r2mcp server. It augments the general AGENTS rules and encodes conventions observed in `src/`.

**Scope**
- The primary source lives in `src/`. Small helper headers and include-fragments (files named `*.inc.c`) are included into TUs and must be treated accordingly.

**Repository layout (important files)**
- `src/main.c` - program entry, CLI parsing, signal setup and high-level program lifecycle.
- `src/r2mcp.c` - main server machinery: JSON-RPC handling, event loop, dispatch to `tools` and `prompts` registries.
- `src/tools.c`, `src/prompts.c` - registries and implementations for tools and prompts.
- `src/readbuffer.c` - framed message reader used by the MCP direct mode loop.
- `src/r2api.inc.c`, `src/utils.inc.c` - implementation fragments included into `r2mcp.c`. These are not separate compilation units.
- `src/r2mcp.h`, `src/tools.h`, `src/readbuffer.h`, `src/prompts.h` - public headers for the modules above.

Coding style and rules (project-specific)
- Indentation: use **TABS** for indentation (project convention).
- Function calls: include a space before the parenthesis, e.g. `foo ()`.
- Always use braces `{}` for conditionals and loops, even if a single statement.
- `case` labels in `switch` statements must be aligned at the same column as other cases.
- Define loop variables before the `for` statement (older C style used in this codebase).
- Prefer `!strcmp ()` instead of `strcmp () == 0`.
- Use `R_RETURN_*` macros in public APIs (functions exported as `R_API`) to declare preconditions and avoid returning invalid values.

Memory and ownership
- `R_NEW`/`R_NEW0` macros in this project are assumed never to return NULL; code can rely on that.
- Do not check for NULL before calling `free` or other `*_free` helpers (the codebase follows this convention).
- `r_json_parse` does not take ownership of the input string: after calling `r_json_parse (buf)` and later `r_json_free (parser)`, the caller is still responsible for freeing the original buffer if it was dynamically allocated. When parsing string data that will be reused or freed, prefer calling `strdup` or ensure the buffer lifetime outlives the parser.
- When using `r_strbuf_free`, `r_core_free`, `r_list_free` or similar, pass only previously-initialized objects; do not NULL-check before freeing.

Build and test
- To quickly compile only the code in `src/`, run: `make -C src -j` (run this from the repo root or from `src/`). This avoids rebuilding unrelated targets.
- The primary output binary is `src/r2mcp`. Run `src/r2mcp -t` to list available tools and `src/r2mcp -h` for CLI help.
- Use `make -C src -j > /dev/null` when you want quieter output during iterative development.

Guidelines for editing the code
- Keep changes minimal and narrowly scoped; prefer fixing the root cause.
- When adding new tools or commands, implement a `?` subcommand to print help for that tool.
- Prefer using `r_str_newf` for formatted strings instead of manual `malloc` + `snprintf`.
- Avoid `r_str_append` for large concatenations; favour `RStrBuf *sb = r_strbuf_new (NULL);` and `r_strbuf_appendf` / `r_strbuf_append` loops, then `r_strbuf_drain` / `r_strbuf_free`.
- Use `r_str_pad2` to construct repeated-character strings when needed.
- When introducing new public APIs, follow the `R_API` and `R_RETURN_*` conventions already present in the repo.

Working with `*.inc.c` files
- Files such as `r2api.inc.c` and `utils.inc.c` are included into `r2mcp.c` (see `#include "utils.inc.c"`). They are not standalone translation units. Keep these files self-contained (no duplicate symbol definitions across other TUs) and avoid adding non-static global symbols there. If you need new public functions, prefer adding a `.c` + `.h` pair.

Logging and diagnostics
- This codebase uses `r2mcp_log`, `r2mcp_log_pub`, `r2mcp_log_reset` and `r2mcp_log_drain` for structured log capture surrounding r2 core operations. Use these helpers where appropriate so logs can be captured and emitted in responses.

JSON and protocol handling
- The server implements a JSON-RPC 2.0-like protocol. Use the existing helpers to build responses (`pj_new`/`pj_*` helpers in this repo) and follow existing patterns in `r2mcp.c` for success and error responses.
- For request parsing: `r_json_parse` returns a parser which must be freed with `r_json_free`. The code should then free the original message buffer if it was dynamically allocated.
- Distinguish between notifications (no `id` field) and requests (have `id`). Notifications must not produce a response.

Signals and event loop
- `setup_signals` is defined in `src/main.c`. Use `write` in signal handlers (no non-reentrant calls). Changing signal handling should be done with care.
- The main MCP direct mode loop is in `r2mcp_eventloop` in `r2mcp.c` and uses `readbuffer.c` to accumulate framed messages. When modifying framing or message parsing, update `readbuffer.c` accordingly and test the loop with piped input.

Incidental tips
- When making changes that affect only `src/` files, run `make -C src -j` from the repo root to recompile only `src/`.
- Avoid adding new dependencies. This project expects to build against existing radare2 headers (`r_core.h`, `r_util/*`).
- When adding tests or additional tooling, prefer placing small test drivers under `b/` (repo already uses `b/` for auxiliary build/test files).

Checklist before submitting a patch
- Run `make -C src -j` and exercise the binary: `src/r2mcp -t`, `src/r2mcp -h`, and a simple direct-mode message roundtrip using `printf` or `jq`.
- Ensure all new public APIs use `R_RETURN_*` where appropriate.
- Follow TAB indentation and other style rules above.

If something in the codebase looks inconsistent with these rules, point it out in the PR rather than applying large style-only changes across many files.

```

`INSTALL.md`:

```md
Add the following JSON in your claude's config:

- macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
- Windows: `%APPDATA%\Claude\claude_desktop_config.json`
- Linux: `~/.config/Claude/claude_desktop_config.json`

```json
{
  "mcpServers": {
    "radare2": {
      "command": "r2pm",
      "args": ["-r", "r2mcp"]
    }
  }
}
```

To use r2mcp with OpenWebUI and local models run the mcp-server proxy like this:

```bash
pip install mcpo
mcpo -- r2pm -r r2mcp
```

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 dnakov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
SRC_TARGETS=all clean install user-install uninstall user-uninstall asan

$(SRC_TARGETS): src/Makefile
	$(MAKE) -C src $@
	$(MAKE) -C svc $@

format fmt indent:
	clang-format-radare2 src/*.c svc/*.c
	#clang-format -i src/*.c svc/*.c

src/Makefile:
	./configure

doc:
	cat INSTALL.md

.PHONY: $(SRC_TARGETS) help doc

```

`README.md`:

```md
# Radare2 MCP Server

[![ci](https://github.com/radareorg/radare2-mcp/actions/workflows/ci.yml/badge.svg)](https://github.com/radareorg/radare2-mcp/actions/workflows/ci.yml)
[![radare2](https://img.shields.io/badge/radare2-6.0.4-green)](https://github.com/radareorg/radare2)

<img width="400" alt="r2mcp logo" src="./r2mcp.png" />

An MCP server to use **radare2** with AI agents such as OpenCode, Mai, VSCode, Claude, CLION, ...

## Features

This implementation provides:

- üíª Fully written in C using the native r2 APIs
- üß© Works from the CLI, as an r2 plugin and as an MCP server
- üîç Seamless binary analysis with radare2
- üîó Connect to any local or remote r2/iaito session via r2pipe
- üîí Supports readonly mode, sandbox lock and restrict tools
- üî© Fine grained tools configuration
- üîÅ Direct stdin/stdout communication model
- üõ†Ô∏è Optional raw access to run r2 commands or r2js scripts

## Installation

<img width="400" alt="Screenshot_2025-03-22_at_5 34 47_PM" src="https://github.com/user-attachments/assets/5322c3fc-fc07-4770-96a3-5a6d82d439c2" />
<img width="400" alt="Screenshot_2025-03-22_at_5 36 17_PM" src="https://github.com/user-attachments/assets/132a1de0-6978-4202-8dce-aa3d60551b9a" />

### Using r2pm

The simplest way to install the package is by using `r2pm`:

```bash
$ r2pm -Uci r2mcp
```

The `r2mcp` executable will be copied into r2pm's bindir in your home directory. However, this binary is not supposed to be executed directly from the shell; it will only work when launched by the MCP service handler of your language model of choice.

```bash
$ r2pm -r r2mcp
```

That's the common mcpServer JSON configuration file:

```json
{
  "mcpServers": {
    "radare2": {
      "command": "r2pm",
      "args": ["-r", "r2mcp"]
    }
  }
}
```

### Using Docker

Alternatively, you can build the Docker image:

```bash
docker build -t r2mcp .
```

Update your MCP client configuration file (see below) to use the Docker image to use:

- `"command": "docker"`
- `"args": ["run", "--rm", "-i", "-v", "/tmp/data:/data", "r2mcp"]`.

## Configuration

### Claude Desktop Integration

In the Claude Desktop app, press `CMD + ,` to open the Developer settings. Edit the configuration file and restart the client after editing the JSON file as explained below:

1. Locate your Claude Desktop configuration file:

   - macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
   - Windows: `%APPDATA%\Claude\claude_desktop_config.json`

2. Add the following to your configuration file:

```json
{
  "mcpServers": {
    "radare2": {
      "command": "r2pm",
      "args": ["-r", "r2mcp"]
    }
  }
}
```

## VS Code Integration

To use r2mcp with GitHub Copilot Chat in Visual Studio Code by [adding it to your user configuration](https://code.visualstudio.com/docs/copilot/chat/mcp-servers#_add-an-mcp-server-to-your-user-configuration) (see other options [here](https://code.visualstudio.com/docs/copilot/chat/mcp-servers#_add-an-mcp-server)):

1. Open the Command Palette with `CMD + Shift + P` (macOS) or `Ctrl + Shift + P` (Windows/Linux).
2. Search for and select `Copilot: Open User Configuration` (typically found in `~/Library/Application Support/Code/User/mcp.json` in macOS).
3. Add the following to your configuration file:

```json
{
  "servers": {
    "radare2": {
      "type": "stdio",
      "command": "r2pm",
      "args": ["-r", "r2mcp"]
    }
  },
  "inputs": []
}
```

## Zed Integration

You can use r2mcp with Zed as well by [adding it to your configuration](https://zed.dev/docs/ai/mcp):

1. Open the command palette: `CMD + Shift + P` (macOS) or `Ctrl + Shift + P` (Windows/Linux). 
2. Search of `agent: open configuration` or search of `settings`.
3. Add your server as such:

```json
  "context_servers": {
    "r2-mcp-server": {
      "source": "custom",
      "command": "r2pm",
      "args": ["-r", "r2mcp"],
      "env": {}
    }
  }
```
Note: you will need another LLM agent, such as Claude, Gemini or else to be able to use it.

## For Developers

### Build from Source

#### Linux/macOS

To test the server locally, you can build and install it with make:

```bash
make install
```

This will compile the server and place the `r2mcp` binary in `/usr/local/bin` on macOS.

#### Windows

For Windows, just use meson and ninja like it's done in the CI:

```cmd
meson b
ninja -C b
```

```

`TODO.md`:

```md
# TODO

Ideas and future plans for r2mcp

* Support multiple sessions
  * The r2copilot-mcp supports having multiple clients using the same mcp at the same time
  * This requires a hard change in the logic because we need to pass session identifiers and handle multiple instancs of core. so better dont do it until core is fully refactored to be thread safe
* Extensions/Plugins
  * Let the user load an .r2.js script or yaml file to define new tools or prompts
  * Support loading custom plugins written in C or other languages
* Resources and Templates
  * Strings, symbols, relocs, imports, libraries, ..
  * Reversing context with user comments and project memory
* Advanced Analysis Tools
  * Find path between two points in the program
  * Progressive analysis and avoid analyzing twice (Optimized analysis for large binaries)
  * Support loading and unloading multiple files
* Projects Support
  * Function signature matching and library identification
  * Caching of analysis results
  * Export analysis results to various formats (JSON, XML, GraphML)
  * Import external analysis data
* Debugging Integration (Requires providing permissions to do it)
  * Support for emulation and native debugging
  * Spawn or Attach to running processes
  * Step-through debugging with breakpoints
  * Memory inspection and modification
  * Register state analysis
* User Interface and Testing Q&A
  * Documentation and tutorials
  * User-contributed scripts and templates
  * Comprehensive test suite for all tools

```

`autogen.sh`:

```sh
#!/bin/sh
[ -z "${EDITOR}" ] && EDITOR=vim
acr -p
V=`./configure -qV | cut -d - -f -1`
meson rewrite kwargs set project / version "$V"
${EDITOR} src/r2mcp.h
${EDITOR} src/r2mcp.c

```

`config.h.w64`:

```w64
#ifndef CONFIG_H
#define CONFIG_H

/* Windows-specific configuration for r2mcp */

/* Version information */
#define R2MCP_VERSION "1.2.0"
#define R2MCP_VERSION_MAJOR 1
#define R2MCP_VERSION_MINOR 2
#define R2MCP_VERSION_PATCH 0

/* Platform detection */
#define WINDOWS 1
#define WIN32 1
#define _WIN32 1
#define _WIN64 1

/* Compiler-specific definitions */
#ifdef _MSC_VER
#define HAVE_MSC_VER 1
#endif

/* Standard C library features */
#define HAVE_STDLIB_H 1
#define HAVE_STDIO_H 1
#define HAVE_STRING_H 1
#define HAVE_STRINGS_H 1
#define HAVE_UNISTD_H 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_FCNTL_H 1
#define HAVE_ERRNO_H 1
#define HAVE_SIGNAL_H 1

/* Windows-specific headers */
#define HAVE_WINDOWS_H 1
#define HAVE_WINSOCK2_H 1
#define HAVE_WS2TCPIP_H 1

/* Function availability */
#define HAVE_MEMCPY 1
#define HAVE_MEMSET 1
#define HAVE_STRCPY 1
#define HAVE_STRNCPY 1
#define HAVE_STRCAT 1
#define HAVE_STRNCAT 1
#define HAVE_STRCMP 1
#define HAVE_STRNCMP 1
#define HAVE_STRLEN 1
#define HAVE_STRDUP 1
#define HAVE_STRCHR 1
#define HAVE_STRRCHR 1
#define HAVE_STRSTR 1
#define HAVE_STRTOK 1
#define HAVE_SPRINTF 1
#define HAVE_SNPRINTF 1
#define HAVE_VSNPRINTF 1
#define HAVE_ATOI 1
#define HAVE_ATOL 1
#define HAVE_STRTOL 1
#define HAVE_STRTOUL 1
#define HAVE_MALLOC 1
#define HAVE_CALLOC 1
#define HAVE_REALLOC 1
#define HAVE_FREE 1

/* File I/O */
#define HAVE_OPEN 1
#define HAVE_CLOSE 1
#define HAVE_READ 1
#define HAVE_WRITE 1
#define HAVE_LSEEK 1
#define HAVE_UNLINK 1
#define HAVE_RENAME 1
#define HAVE_MKDIR 1
#define HAVE_RMDIR 1
#define HAVE_ACCESS 1
#define HAVE_STAT 1

/* Process control */
#undef HAVE_FORK
#define HAVE_FORK 0
#define HAVE_EXEC 0
#define HAVE_WAITPID 0
#define HAVE_KILL 0
#define HAVE_GETPID 1
#define HAVE_GETPPID 0

/* Network */
#define HAVE_SOCKET 1
#define HAVE_CONNECT 1
#define HAVE_BIND 1
#define HAVE_LISTEN 1
#define HAVE_ACCEPT 1
#define HAVE_SEND 1
#define HAVE_RECV 1
#define HAVE_SELECT 1
#define HAVE_POLL 1

/* Threading */
#define HAVE_PTHREAD_H 0
#define HAVE_THREAD_H 1

/* Math */
#define HAVE_MATH_H 1
#define HAVE_FLOOR 1
#define HAVE_CEIL 1
#define HAVE_ROUND 1
#define HAVE_SQRT 1
#define HAVE_POW 1
#define HAVE_LOG 1
#define HAVE_LOG10 1
#define HAVE_SIN 1
#define HAVE_COS 1
#define HAVE_TAN 1
#define HAVE_ASIN 1
#define HAVE_ACOS 1
#define HAVE_ATAN 1
#define HAVE_ATAN2 1

/* Time */
#define HAVE_TIME_H 1
#define HAVE_SYS_TIME_H 0
#define HAVE_TIME 1
#define HAVE_GETTIMEOFDAY 0
#define HAVE_CLOCK_GETTIME 0

/* Random */
#define HAVE_RAND 1
#define HAVE_SRAND 1
#define HAVE_RANDOM 0
#define HAVE_SRANDOM 0

/* Environment */
#define HAVE_GETENV 1
#define HAVE_SETENV 0
#define HAVE_UNSETENV 0
#define HAVE_PUTENV 1

/* Signal handling */
#define HAVE_SIGNAL 1
#define HAVE_SIGACTION 0
#define HAVE_SIGPROCMASK 0

/* Directory operations */
#define HAVE_OPENDIR 0
#define HAVE_READDIR 0
#define HAVE_CLOSEDIR 0
#define HAVE_REWINDDIR 0

/* Windows-specific features */
#define HAVE_GETPROCESSID 1
#define HAVE_GETCURRENTTHREADID 1
#define HAVE_GETCURRENTPROCESSID 1

/* Large file support */
#define HAVE_LARGEFILE_SUPPORT 1
#define _FILE_OFFSET_BITS 64

/* Endianness */
#define WORDS_BIGENDIAN 0
#define WORDS_LITTLEENDIAN 1

/* Architecture */
#define ARCH_X86 1
#define ARCH_X86_64 1
#define ARCH_AMD64 1

/* Build configuration */
#define DEBUG 0
#define NDEBUG 1
#define RELEASE 1

/* Feature flags */
#define HAVE_DYNAMIC_LOADING 1
#define HAVE_SHARED_LIBRARIES 1
#define HAVE_PLUGINS 1

/* Windows API version */
#define WINVER 0x0601
#define _WIN32_WINNT 0x0601
#define _WIN32_IE 0x0800

/* Unicode support */
#define UNICODE 1
#define _UNICODE 1

/* Security */
#define HAVE_SECURE_CRT 1

/* Compiler warnings */
#ifdef _MSC_VER
#pragma warning(disable: 4996) /* deprecated functions */
#pragma warning(disable: 4101) /* unreferenced local variable */
#pragma warning(disable: 4244) /* conversion from 'type1' to 'type2' */
#pragma warning(disable: 4267) /* conversion from 'size_t' to 'type' */
#endif

#endif /* CONFIG_H */

```

`configure`:

```
#!/bin/sh
# This script was automatically generated by ACR v2.2.4
# @author: pancake <nopcode.org>
# @url:    http://www.nopcode.org
# @repo:   git clone https://github.com/radare/acr

[ -z "${AWK}" ] && AWK=awk
do_remove() {
if [ "${ACR_RMFILES}" ]; then
  printf "cleaning temporally files... "
  rm -f ${ACR_RMFILES}
  echo "done"
fi
}
control_c() {
  printf "\n\n^C control-c : script execution interrupted.\n"
  do_remove
  exit 1
}
trap control_c 2
split_host() {
S="$"
while : ; do
ENVWORDS="${ENVWORDS} $1_CPU $1_OS"
STR=`eval "echo ${S}$1"`
SPLIT_CPU="`echo "$STR" | cut -d - -f 1`"
SPLIT_OS="`echo "$STR" | $AWK -F - '{
	if ($2=="unknown"){
		if (NF<3) { print $2; } else { print $3; }
	} else {
		if ($2=="linux") { print $2; } else
		if (NF<3) { print $2; } else { print $3; }
	}
}'`"
eval "$1_CPU=\"$SPLIT_CPU\""
eval "$1_OS=\"$SPLIT_OS\""
shift
[ -z "$1" ] && break
done
}

QUIET=0
be_quiet() {
	QUIET=1
}

VPATH=`dirname ${0}`
if [ "${VPATH}" = "." ]; then
	WODIS=current
else
	if [ "${VPATH}" = "${PWD}" ]; then
		VPATH=.
		WODIS=current
	else
		WODIS=crosspath
		CURDIR=$PWD
		cd $VPATH
		VPATH="${PWD}/"
		cd $CURDIR
	fi
fi

guess_os() {
if [ -e "${VPATH}/config.guess" ]; then
	sh ${VPATH}/config.guess
	return
fi
CPU="`uname -m | tr 'A-Z' 'a-z' | sed -e 's, ,,g' | cut -d - -f 1`"
OS="`uname -s|tr A-Z a-z`"
uname -r | grep -qE "(Microsoft|WSL)" 2>/dev/null && OS="wsl"
GNU="`uname --help 2>&1 | grep gnu`"
[ "${GNU}" ] && OS="${OS}-gnu"
# normalize CPU
case "${CPU}" in
	ppc*|powermac*|powermacintosh*|powerpc*)
		if echo "${CPU}" | grep -q '64'; then
			CPU=powerpc64
		else
			CPU=powerpc
		fi
		;;
	*) ;;
esac
VENDOR="unknown"
if [ "${OS}" = "darwin" ]; then
	VENDOR=apple
fi
echo "${CPU}-${VENDOR}-${OS}"
}

SEARCHPATH="/usr /usr/local /usr/pkg /sw"

: ${PREFIX:=/usr/local}
CROSSBUILD=0
BUILD=`guess_os`
HOST="${BUILD}"
TARGET="${HOST}"
ETCDIR="/etc"
SYSCONFDIR=""
DESCRIPTION=""

create_environ() {
: ${EPREFIX:="${PREFIX}"}
: ${SPREFIX:="${PREFIX}"}
: ${BINDIR:="${SPREFIX}/bin"}
: ${SBINDIR:="${PREFIX}/sbin"}
: ${ETCDIR:="${SPREFIX}/etc"}
: ${LIBDIR:="${SPREFIX}/lib"}
: ${PKGCFG_LIBDIR:='${exec_prefix}/lib'}
: ${PKGCFG_INCDIR:='${prefix}/include'}
: ${LIBEXECDIR:="${SPREFIX}/libexec"}
: ${INCLUDEDIR:="${SPREFIX}/include"}
: ${DATADIR:="${SPREFIX}/share"}
: ${INFODIR:="${DATADIR}/info"}
: ${MANDIR:="${DATADIR}/man"}
: ${DOCDIR:="${DATADIR}/doc/r2mcp"}
: ${LOCALSTATEDIR:="${SPREFIX}/var"}
for A in `echo ${PATH} | sed -e 's,:, ,g'` ; do
  [ -e "$A"/ginstall ] && : ${INSTALL:="$A"/ginstall} && break
  [ -e "$A"/install ] && : ${INSTALL:="$A"/install} && break
done
: ${INSTALL_DIR:=${INSTALL} -d}
: ${INSTALL_DATA:=${INSTALL} -m 644}
: ${INSTALL_SCRIPT:=${INSTALL} -m 755}
: ${INSTALL_PROGRAM:=${INSTALL} -m 755}
: ${INSTALL_PROGRAM_STRIP:=${INSTALL} -m 755 -s}
: ${INSTALL_MAN:=${INSTALL} -m 444}
: ${INSTALL_LIB:=${INSTALL} -m 755 -c}
 PKGNAME='r2mcp' ; VERSION='1.5.6' ; VERSION_MAJOR=1; VERSION_MINOR=5; VERSION_PATCH=6; VERSION_NUMBER=10506; CONTACT_MAIL="pancake@nopcode.org" ; CONTACT_NAME="pancake" ; CONTACT="pancake <pancake@nopcode.org>" ;
}

show_usage() {
cat <<EOF2
'configure' configures r2mcp-1.5.6 to adapt to many kinds of systems.

Usage: ./configure [OPTION]... [VAR=VALUE]...

To assign environment variables (e.g., CC, CFLAGS...), specify them as
VAR=VALUE.  See below for descriptions of some of the useful variables.

Defaults for the options are specified in brackets.

Configuration:
  -h, --help              display this help and exit
  -r, --report            show what libs/programs require to work
  -q, --quiet             be quiet, less verbose (see ./configure -qV)
  -V, --version           display version information and exit

Installation directories:
  --exec-prefix=EPREFIX  install arch-dependent files in EPREFIX [PREFIX]
  --prefix=PREFIX        install arch-independent files in PREFIX [/usr/local]
  --sandbox=SPREFIX      sandbox prefix directory: SPREFIX [PREFIX]

Fine tuning of the installation directories:
  --bindir=DIR           user executables [EPREFIX/bin]
  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
  --docdir=DIR           documentation directory [DATADIR/doc/r2mcp]
  --includedir=DIR       C header files [PREFIX/include]
  --infodir=DIR          info documentation [DATADIR/info]
  --libexecdir=DIR       program executables [EPREFIX/libexec]
  --libdir=DIR           object code libraries [EPREFIX/lib]
  --libpath=DIR          set rpath/libname-path to linker
  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
  --mandir=DIR           man documentation [DATADIR/man]
  --sbindir=DIR          system admin executables [EPREFIX/sbin]
  --etcdir=DIR           same as --sysconfdir (/etc)
  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]

System types:
  --build=BUILD          configure for building on BUILD [guessed]
  --host=HOST            cross-compile to build programs to run on HOST [BUILD]
  --target=TARGET        configure for building compilers for TARGET [HOST]
EOF2

printf "
Some influential environment variables:
  CC          C compiler command
  CFLAGS      C compiler flags
  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
              nonstandard directory <lib dir>
  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
              headers in a nonstandard directory <include dir>
  CPP         C preprocessor
"
printf "
Report bugs to: pancake <pancake@nopcode.org>"
echo ""
exit 0
}

take_environ() {
: ${SH:=/bin/sh}
: ${CPP:=cpp}
: ${CC:=gcc}
: ${PREFIX:=/usr/local/}
}

ochof() {
	[ "$QUIET" = 1 ] && return
	printf "$*"
}

ocho() {
	[ "$QUIET" = 1 ] && return
	echo "$*"
}

show_version() {
if [ "$QUIET" = 1 ]; then
	echo "1.5.6"
	exit 0
fi
echo "r2mcp-1.5.6 configuration script done with acr v2.2.4.
The 'Free Software Foundation' message is only for autodetection.
Originally written by pancake <nopcode.org>."
exit 0
}

parse_options() {
flag=`echo $1| cut -d = -f 1`
value=`echo $1| $AWK 'BEGIN{FS="=";}{print $2}'`
flag2=`echo $flag|cut -f2- -d -| sed -e 's,-,_,g' -e 's,^_,,g'|tr '[a-z]' '[A-Z]'`

if [ "${TARGET_OS}" = "darwin" ]; then
	LIBPATH=-Wl,-install_name,
else
	LIBPATH=-Wl,-R
fi

case $flag in
-h|--help|--hel|--h|--he|-help)
	show_usage ; ;;
-qV|-quiet-version|--quiet-version)
	be_quiet
	show_version ; ;;
-q|-quiet|--quiet)
	be_quiet ; ;;
-V|-version|--version)
	show_version ; ;;
-r|--r|--report)
echo "PKGNAME:     r2mcp"
echo "VERSION:     1.5.6"
echo "AUTHOR:      pancake"
echo "EMAIL:       pancake@nopcode.org"
echo "LANGS:       c"
echo "PKGCONFIG:   r_core"
	exit 0
	;;
--cache-file)
	# ignored: acr have no cache
	;;
--build)
	BUILD="$value"; split_host BUILD ; ;;
--host)
	CROSSBUILD=1 # XXX
	HOST="$value"; split_host HOST ; ;;
--target)
	TARGET="$value"; split_host TARGET ; ;;
--prefix)
	PREFIX="$value"; ;;
--exec-prefix)
	EPREFIX="$value"; ;;
--sandbox|--sprefix)
	SPREFIX="$value"; ;;
--bindir)
	BINDIR="$value"; ;;
--sbindir)
	SBINDIR="$value"; ;;
--libexecdir)
	LIBEXECDIR="$value"; ;;
--docdir)
	DOCDIR="$value"; ;;
--datadir)
	DATADIR="$value"; ;;
--sysconfdir)
	SYSCONFDIR="$value"
	ETCDIR="$value"; ;;
--etcdir)
	SYSCONFDIR="$value"
	ETCDIR="$value"; ;;
--sharedstatedir)
	SHAREDSTATEDIR="$value"; ;;
--localstatedir)
	LOCALSTATEDIR="$value"; ;;
--libdir)
	LIBDIR="$value"
	PKGCFG_LIBDIR="$value"; ;;
--libpath)
	LDFLAGS="${LDFLAGS} ${LIBPATH}$value"; ;;
--includedir)
	PKGCFG_INCDIR="$value"
	INCLUDEDIR="$value"; CFLAGS="${CFLAGS} -I$value"; ;;
--infodir)
	INFODIR="$value"; ;;
--mandir)
	MANDIR="$value"; ;;

*) if [ "$value" ]; then eval "`echo $flag2=$value`" ;
else echo ; echo "WARNING: Unknown flag '$flag'." >&2 ; echo ; fi ;;
esac
}

# MAIN #
take_environ
split_host BUILD HOST TARGET
[ -z "$ACRHOOK" ] && ACRHOOK=./configure.hook
[ -e "$ACRHOOK" ] && . ${ACRHOOK}

while : ; do
[ -z "$1" ] && break
parse_options "$1"
shift
done

ENVWORDS="MANDIR DESCRIPTION INFODIR LIBDIR INCLUDEDIR LOCALSTATEDIR ETCDIR SYSCONFDIR DATADIR DOCDIR LIBEXECDIR SBINDIR BINDIR EPREFIX PREFIX SPREFIX TARGET HOST BUILD INSTALL INSTALL_LIB INSTALL_MAN INSTALL_PROGRAM INSTALL_PROGRAM_STRIP INSTALL_DIR INSTALL_SCRIPT INSTALL_DATA HOST_OS HOST_CPU BUILD_OS BUILD_CPU TARGET_OS TARGET_CPU VERSION VERSION_MAJOR VERSION_MINOR VERSION_PATCH VERSION_NUMBER PKGCFG_LIBDIR PKGCFG_INCDIR PKGNAME VPATH CONTACT CONTACT_NAME CONTACT_MAIL CC CFLAGS CPPFLAGS LDFLAGS HAVE_LANG_C PKGCONFIG R2_CFLAGS R2_LDFLAGS HAVE_PKGCFG_R_CORE HAVE_R2 R2 R2_PREFIX R2_USER_PLUGINS R2_LIBR_PLUGINS R2MCP_VERSION"

create_environ

ocho "checking build system type... ${BUILD}"
ocho "checking host system type... ${HOST}"
ocho "checking target system type... ${TARGET}"
[ "${CROSSBUILD}" = 1 ] && echo "using crosscompilation mode."

#split_host BUILD HOST TARGET
[ -n "${prefix}" ] && PREFIX="${prefix}"
ocho "checking for working directories... ${WODIS}"
ocho "using prefix '${PREFIX}'"
ACR_RMFILES=" test.c a.out a.exe"

COMPILER=CC
ochof "checking for c compiler... "
HAVE_LANG_C=1
if [ "${CROSSBUILD}" = 1 ]; then
 (command -v ${HOST}-${CC} >/dev/null 2>&1)
 if [ $? = 0 ]; then CC="${HOST}-${CC}"; fi
fi
echo "int main(int argc, char **argv){return 0;}" > test.c
 (exec ${CC} -o a.out ${CFLAGS} ${CPPFLAGS} ${LDFLAGS} test.c >/dev/null 2>&1)
if [ $? = 0 ]; then echo ${CC}; else
 echo no ; HAVE_LANG_C=0
do_remove
echo "ERROR: ${CC} cannot create executables" >&2 ;
exit 1 ; fi
ochof "checking for pkg-config... "
ENVWORDS="${ENVWORDS} HAVE_PKGCONFIG"
if [ -n "$PKGCONFIG" ]; then
	if [ -x "$PKGCONFIG" ]; then
		_HAVE_PKGCONFIG="${PKGCONFIG}"
	else
		ocho "PKGCONFIG env is not executable"
		PKGCONFIG=""
	fi
else
	IFS=:
	for A in ${PATH} ; do
		if [ -x "${A}/pkg-config" ]; then
			PKGCONFIG="${A}/pkg-config"
		elif [ -x "${A}/pkgconf" ]; then
			PKGCONFIG="${A}/pkgconf"
		else
			continue
		fi
		break
	done
	unset IFS
fi
if [ -n "${PKGCONFIG}" ]; then
	ocho ${PKGCONFIG}
	HAVE_PKGCONFIG=1
else
	HAVE_PKGCONFIG=0
	echo "Cannot find pkg-config or pkgconf in PATH" >&2
	exit 1
ocho no; fi
if [ -z "${PKGCONFIG}" ]; then pkg-config --version >/dev/null 2>&1 ; if [ 0 = 0 ]; then PKGCONFIG=pkg-config ; else PKGCONFIG=pkgconf ; fi; fi
type ${PKGCONFIG} > /dev/null 2>&1 || echo "ERROR: Cannot find valid PKGCONFIG, pkg-config or pkgconf in PATH"
echo 'Using PKGCONFIG: '${PKGCONFIG}
printf 'checking pkg-config flags for r_core... '
tmp=`${PKGCONFIG} --cflags r_core 2>/dev/null`
if [ $? != 0 ]; then echo no ; HAVE_PKGCFG_R_CORE=0;
R2_CFLAGS='';R2_LDFLAGS='';
echo 'This package is required'
exit 1
else
R2_CFLAGS=$tmp;
tmp=`${PKGCONFIG} --libs r_core 2>/dev/null`
if [ $? = 0 ]; then
echo yes; HAVE_PKGCFG_R_CORE=1;
R2_LDFLAGS=$tmp; fi; fi
ochof "checking for r2... "
if [ -x "${R2}" ]; then
	FIND=${R2}
else
	FIND=""
	IFS=:
	for A in ${PATH} ; do
		if [ -x "${A}/r2" ]; then
			FIND="${A}/r2"
			break;
		fi
	done
	unset IFS
fi
if [ -n "${FIND}" ]; then
	ocho ${FIND};
HAVE_R2=1
	R2=${FIND}
else
	HAVE_R2=0
	R2=r2
if [ "" = 1 ]; then
echo "Cannot find r2" >&2
else
echo no
fi
	echo "error: This program is required." >&2
	exit 1 ; fi
printf "checking exec r2 -H R2_PREFIX... "
R2_PREFIX="`r2 -H R2_PREFIX 2>/dev/null`"
if [ $? = 0 ]; then
	echo "ok"
else
	R2_PREFIX=""
	echo "not found"
echo 'required'; exit 1
fi
printf "checking exec r2 -H R2_USER_PLUGINS... "
R2_USER_PLUGINS="`r2 -H R2_USER_PLUGINS 2>/dev/null`"
if [ $? = 0 ]; then
	echo "ok"
else
	R2_USER_PLUGINS=""
	echo "not found"
echo 'required'; exit 1
fi
printf "checking exec r2 -H R2_LIBR_PLUGINS... "
R2_LIBR_PLUGINS="`r2 -H R2_LIBR_PLUGINS 2>/dev/null`"
if [ $? = 0 ]; then
	echo "ok"
else
	R2_LIBR_PLUGINS=""
	echo "not found"
echo 'required'; exit 1
fi
R2MCP_VERSION="$VERSION"
SEDFLAGS=" -e '"
COUNT=0
for A in ${ENVWORDS} ; do
	[ "${A}" = VPATH ] && continue
	[ "${A}" = srcdir ] && continue
	eval "VAR=\$${A}"
	case "" in
	mingw*|cygwin*|msys*)
		VAR="`echo ${VAR} | sed -e 's/\\/\\\\/g' -e 's/\,/\\\,/g'`"
		;;
	*)
		VAR="`echo ${VAR} | sed -e 's/\,/\\\,/g'`"
		;;
	esac
	[ $COUNT = 10 ] && COUNT=0 && SEDFLAGS="${SEDFLAGS}' -e '"
	COUNT=$(($COUNT+1))
	SEDFLAGS="${SEDFLAGS}s,@${A}@,${VAR},g;"
done
SEDFLAGS="${SEDFLAGS}'"
for A in src/config.h  ; do # SUBDIRS
if [ -f "${VPATH}/${A}.acr" ]; then
  SD_TARGET=${A}
 else
  if [ -d "${VPATH}/${A}" ]; then
   SD_TARGET=${A}/Makefile
   mkdir -p ${A}
  else
   echo "ERROR: Cannot find ${VPATH}/${A}.acr" >&2
   exit 1
  fi
 fi
 ocho "creating ${SD_TARGET}"
[ "${VPATH}" != '.' ] &&  mkdir -p $(echo ${A} | sed -e "s,/`basename ${A}`$,,g")
 cat ${VPATH}/${SD_TARGET}.acr | \
eval sed -e "s,@VPATH@,${VPATH}/${A},g" ${SEDFLAGS} > ${SD_TARGET}.tmp

for A in ${ENVWORDS}; do
VALUE=`eval echo "$"${A}`
if [ "$VALUE" = 0 ]; then ## FALSE
 MARK="##${A}##"
if [ -n "`grep \"${MARK}\" ${SD_TARGET}.tmp`" ]; then
 mv ${SD_TARGET}.tmp ${SD_TARGET}.tmp2
 cat ${SD_TARGET}.tmp2 | MARK=$MARK $AWK 'BEGIN{a=0;}{if($1==ENVIRON["MARK"]){if(a)a=0;else a=1}else{if(!a)print;}}' > ${SD_TARGET}.tmp
 fi
fi
done
 mv ${SD_TARGET}.tmp ${SD_TARGET} && rm -f ${SD_TARGET}.tmp2
 if [ ! $? = 0 ]; then echo Cannot write target file ; control_c ; fi
done

do_remove
if [ "$QUIET" = 0 ]; then
echo
echo "Final report:"
for A in  VERSION R2_PREFIX PREFIX PKGCONFIG ; do
eval VAL="\$${A}"
[ -z "${VAL}" ] && VAL="\"\""
echo " - ${A} = ${VAL}"
done
fi

```

`configure.acr`:

```acr
PKGNAME r2mcp
VERSION 1.5.6
CONTACT pancake ; pancake@nopcode.org

LANG_C!
USE_PKGCONFIG!

PKGCFG! R2_CFLAGS R2_LDFLAGS r_core
CHKPRG! R2 r2

EXEC! R2_PREFIX r2 -H R2_PREFIX ;
EXEC! R2_USER_PLUGINS r2 -H R2_USER_PLUGINS ;
EXEC! R2_LIBR_PLUGINS r2 -H R2_LIBR_PLUGINS ;

R2MCP_VERSION = $VERSION ;

SUBDIRS src/config.h ;

REPORT VERSION R2_PREFIX PREFIX PKGCONFIG ;

```

`dist/debian/CONFIG`:

```
PACKAGE=r2mcp
VERSION=$(shell ../../configure -qV)
DEPENDS=radare2
SECTION=user/shell
PRIORITY=optional
MAINTAINER=pancake <pancake@nopcode.org>
# arch
UNAMEM=$(shell uname -m)
ifeq ($(UNAMEM),x86_64)
ARCH=amd64
else
ARCH=arm64
endif

```

`dist/debian/DESCR`:

```
Model Context Protocol server for radare2
AI Agents with MCP support can start the r2mcp to open binaries with radare2, analyze, solve crackmes, generate security reports, find vulnerabilities and anything you can express with human language without the need to know how to use radare2

```

`dist/debian/Makefile`:

```
include ./CONFIG

DEPENDS=
CROSSARCH=x64
PWD=$(shell pwd)
PACKAGE_DIR?=${PWD}

DOCKCROSS=$(PWD)/../docker/dockcross
R2PLUGDIR=$(shell r2 -H R2_LIBR_PLUGINS)

all: root
	$(MAKE) build

local: data
	$(MAKE) -C ../.. install DESTDIR=$(PWD)/root
	$(MAKE) build

data $(shell pwd)/data:
	sudo rm -rf control data
	${MAKE} clean
	rm -f data
	mkdir -p data
	cp -rf root/* data

build: data
	${MAKE} control
	${MAKE} deb

root:
	cd ../.. && $(DOCKCROSS) --image dockcross/linux-$(CROSSARCH) \
	bash -c 'DESTDIR=/work/dist/debian/root sh dist/debian/build.sh'

purge: clean
	rm -rf root
	docker rmi dockcross/linux-x64

summary:
	echo $(VERSION)

include deb.mk

```

`dist/debian/build.sh`:

```sh
#!/bin/sh

type fakeroot > /dev/null 2>&1
if [ $? = 0 ]; then
FAKEROOT=fakeroot
else
FAKEROOT=sudo
fi

r2 -qv
if [ $? != 0 ]; then
	echo "Cannot find radare2, building with sys/debian.sh from git.."
	# git clone --depth=1 git@github.com:radareorg/radare2 r2 || exit 1
	wget -c https://github.com/radareorg/radare2/archive/master.zip
	sudo apt-get update
	sudo apt-get -y install git g++ make pkg-config flex bison unzip patch || exit 1
	unzip -l master.zip
	unzip master.zip || exit 1
	mv radare2-master r2
	( cd r2 && sys/debian.sh ) # make -C r2/dist/debian
	sudo dpkg -i r2/dist/debian/*/*.deb || exit 1
fi
[ -z "${DESTDIR}" ] && DESTDIR="/work/dist/debian/root"

RV=`r2 -qv`
[ -z "${RV}" ] && RV=`r2/configure -qV`

R2_LIBR_PLUGINS="`r2 -H R2_LIBR_PLUGINS`"
[ -z "${R2_LIBR_PLUGINS}" ] && R2_LIBR_PLUGINS=/usr/lib/radare2

export CFLAGS=-O2
make R2_PLUGDIR=${R2_LIBR_PLUGINS} DESTDIR=${DESTDIR}

./configure --prefix=/usr || exit 1
make -j4 || exit 1
strip --strip-unneeded r2mcp
${FAKEROOT} make install DESTDIR="${DESTDIR}"

```

`dist/debian/deb.mk`:

```mk
# Create .deb without using dpkg tools.
#
# Author: Tim Wegener <twegener@madabar.com>
#
# Use 'include deb_hand.mak' after defining the user variables in a local
# makefile.
#
# The 'data' rule must be customised in the local make file.
# This rule should make a 'data' directory containing the full file
# layout of the installed package.
#
# This makefile will create a debian-binary file a control directory and a
# a build directory in the current directory.
# Do 'make clobber' to remove these generated files.
#
# Destination:
# PACKAGE_DIR - directory where package (and support files) will be built
#               defaults to the current directory
#
# Sources:
# SOURCE_DIR - directory containing files to be packaged
# ICON_SOURCE - 26x26 icon file for maemo
# DESCR - description with summary on first line
# preinst, postinst, prerm, postrm - optional control shell scripts

# These fields are used to build the control file:
# PACKAGE = 
# VERSION = 
# ARCH = 
# SECTION = 
# PRIORITY = 
# MAINTAINER = 
# DEPENDS = 
#
# SOURCE_DIR =
# ICON_SOURCE = 
# (ICON_SOURCE is optional)

# *** NO USER CHANGES REQUIRED BEYOND THIS POINT ***
ifeq ($(shell uname),Darwin)
MD5SUM=md5
else
MD5SUM=md5sum
endif

GAWK=awk
PACKAGE_DIR=$(shell pwd)
CONTROL_EXTRAS ?= ${wildcard preinst postinst prerm postrm}

${PACKAGE_DIR}/control: ${PACKAGE_DIR}/data ${CONTROL_EXTRAS} DESCR \
			${ICON_SOURCE}
	#rm -rf $@
	mkdir -p $@
ifneq (${CONTROL_EXTRAS},)
	cp ${CONTROL_EXTRAS} $@
endif
#       Make control file.
	echo "Package: ${PACKAGE}" > $@/control
	echo "Version: ${VERSION}" >> $@/control
	echo "Section: ${SECTION}" >> $@/control
	echo "Priority: ${PRIORITY}" >> $@/control
	echo "Architecture: ${ARCH}" >> $@/control
ifneq (${REPLACES},)
	echo "Replaces: ${REPLACES}" >> $@/control
endif
ifneq (${DEPENDS},)
	echo "Depends: ${DEPENDS}" >> $@/control
endif
	echo "Installed-Size: ${shell du -s ${PACKAGE_DIR}/data|cut -f1}" \
		>> $@/control
	echo "Maintainer: ${MAINTAINER}" >> $@/control
	printf "Description:" >> $@/control
	cat DESCR | ${GAWK} '{print " "$$0;}' >> $@/control
#ifneq (${ICON_SOURCE},)
#	echo "Maemo-Icon-26:" >> $@/control
#	base64 ${ICON_SOURCE} | ${GAWK} '{print " "$$0;}' >> $@/control
#endif
#       Make md5sums.
	cd ${PACKAGE_DIR}/data && find . -type f -exec ${MD5SUM} {} \; \
		| sed -e 's| \./||' \
		> $@/md5sums

${PACKAGE_DIR}/debian-binary:
	echo "2.0" > $@

${PACKAGE_DIR}/clean:
	rm -rf ${PACKAGE_DIR}/data ${PACKAGE_DIR}/control ${PACKAGE_DIR}/build *.deb

${PACKAGE_DIR}/build: ${PACKAGE_DIR}/debian-binary ${PACKAGE_DIR}/control \
			${PACKAGE_DIR}/data
	rm -rf $@
	mkdir $@
	cp ${PACKAGE_DIR}/debian-binary $@/
	cd ${PACKAGE_DIR}/control && tar cJvf $@/control.tar.xz *
	cd ${PACKAGE_DIR}/data && \
		COPY_EXTENDED_ATTRIBUTES_DISABLE=true \
		COPYFILE_DISABLE=true \
		tar cpJvf $@/data.tar.xz *

# Convert GNU ar to BSD ar that debian requires.
# Note: Order of files within ar archive is important!
${PACKAGE_DIR}/${PACKAGE}_${VERSION}_${ARCH}.deb: ${PACKAGE_DIR}/build
	ar -rc $@ $</debian-binary $</control.tar.xz $</data.tar.xz
	#sed -e 's|^\([^/]\+\)/ \(.*\)|\1  \2|g' $@tmp > $@fail
	#rm -f $@tmp
	#mv $@fail $@

.PHONY: data
data: ${PACKAGE_DIR}/data

.PHONY: control
control: ${PACKAGE_DIR}/control

.PHONY: build
build: ${PACKAGE_DIR}/build

.PHONY: clean
clean: ${PACKAGE_DIR}/clean $(EXTRA_CLEAN)
	rm -f debian-binary

.PHONY: deb
deb: ${PACKAGE_DIR}/${PACKAGE}_${VERSION}_${ARCH}.deb


clobber::
	rm -rf ${PACKAGE_DIR}/debian_binary ${PACKAGE_DIR}/control \
		${PACKAGE_DIR}/data ${PACKAGE_DIR}/build

push:
	scp *.deb radare.org:/srv/http/radareorg/cydia/debs

mrproper: clean
	rm -rf root

```

`dist/docker/Dockerfile`:

```
FROM alpine:latest AS builder

# Install build dependencies
RUN apk add --no-cache \
    build-base \
    git \
    pkgconfig \
    python3 \
    libc-dev \
    file-dev \
    libzip-dev \
    openssl-dev \
    linux-headers \
    meson \
    ninja

WORKDIR /build
# Install radare2 (for build only)
RUN git clone --depth 1 https://github.com/radareorg/radare2.git && \
    cd radare2 && \
    ./sys/install.sh && \
    cd .. 

RUN git clone --depth 1 https://github.com/radareorg/radare2-mcp.git && \
    cd radare2-mcp && \
    ./configure && \
    make && \
    cp -f src/r2mcp /usr/local/bin/

# Create /data volume for binary analysis
WORKDIR /data
VOLUME ["/data"]

# Environment setup for r2mcp
ENV R2MCP_DEBUG=0

# Simply set the entrypoint
ENTRYPOINT ["/usr/local/bin/r2mcp"]

# Instructions for users:
# IMPORTANT: Always run with `-i` flag to keep stdin open:
#   docker run -i --rm r2mcp

```

`dist/docker/dockcross`:

```
#!/bin/sh

DEFAULT_DOCKCROSS_IMAGE=dockcross/linux-armv5

#------------------------------------------------------------------------------
# Helpers
#
err() {
    echo >&2 ERROR: $@\\n
}

die() {
    err $@
    exit 1
}

has() {
    # eg. has command update
    local kind=$1
    local name=$2

    type -t $kind:$name | grep -q function
}

#------------------------------------------------------------------------------
# Command handlers
#
command_update_image() {
    docker pull $FINAL_IMAGE
}

help_update_image() {
    echo "Pull the latest $FINAL_IMAGE ."
}

command_update_script() {
    if [ docker run $FINAL_IMAGE | cmp -s $0 ]; then
        echo "$0 is up to date"
    else
        printf "Updating $0 '... '"
        docker run $FINAL_IMAGE > $0 && echo ok
    fi
}

command_update() {
	command_update_image
	command_update_script
}

help_update() {
    echo "Pull the latest $FINAL_IMAGE, and then update $0 from that."
}

command_help() {
    if [ $# != 0 ]; then
        if ! has command $1; then
            err \"$1\" is not an dockcross command
            command:help
        elif ! has help $1; then
            err No help found for \"$1\"
        else
            help:$1
    fi
    else
        cat >&2 <<ENDHELP
Usage: dockcross [options] [--] command [args]

By default, run the given *command* in an dockcross Docker container.

The *options* can be one of:

    --args|-a           Extra args to the *docker run* command
    --image|-i          Docker cross-compiler image to use
    --config|-c         Bash script to source before running this script


Additionally, there are special update commands:

    update-image
    update-script
    update

For update command help use: $0 help <command>
ENDHELP
        exit 1
    fi
}

#------------------------------------------------------------------------------
# Option processing
#
special_update_command=''
while [ $# != 0 ]; do
    case $1 in

        --)
            break
            ;;

        --args|-a)
            ARG_ARGS="$2"
            shift 2
            ;;

        --config|-c)
            ARG_CONFIG="$2"
            shift 2
            ;;

        --image|-i)
            ARG_IMAGE="$2"
            shift 2
            ;;
        update|update-image|update-script)
            special_update_command=$1
            break
            ;;
        -*)
            err Unknown option \"$1\"
            command:help
            exit
            ;;

        *)
            break
            ;;

    esac
done

# The precedence for options is:
# 1. command-line arguments
# 2. environment variables
# 3. defaults

# Source the config file if it exists
DEFAULT_DOCKCROSS_CONFIG=~/.dockcross
FINAL_CONFIG=${ARG_CONFIG-${DOCKCROSS_CONFIG-$DEFAULT_DOCKCROSS_CONFIG}}

[ -f "$FINAL_CONFIG" ] && source "$FINAL_CONFIG"

# Set the docker image
FINAL_IMAGE=${ARG_IMAGE-${DOCKCROSS_IMAGE-$DEFAULT_DOCKCROSS_IMAGE}}

# Handle special update command
if [ "$special_update_command" != "" ]; then
    case $special_update_command in

        update)
            command:update
            exit $?
            ;;

        update-image)
            command:update-image
            exit $?
            ;;

        update-script)
            command:update-script
            exit $?
            ;;

    esac
fi

# Set the docker run extra args (if any)
FINAL_ARGS=${ARG_ARGS-${DOCKCROSS_ARGS}}

# Bash on Ubuntu on Windows
UBUNTU_ON_WINDOWS=$([ -e /proc/version ] && grep -l Microsoft /proc/version || echo "")
# MSYS, Git Bash, etc.
MSYS=$([ -e /proc/version ] && grep -l MINGW /proc/version || echo "")

if [ -z "$UBUNTU_ON_WINDOWS" -a -z "$MSYS" ]; then
    USER_IDS="-e BUILDER_UID=$( id -u ) -e BUILDER_GID=$( id -g ) -e BUILDER_USER=$( id -un ) -e BUILDER_GROUP=$( id -gn )"
fi

# Change the PWD when working in Docker on Windows
if [ -n "$UBUNTU_ON_WINDOWS" ]; then
    HOST_PWD=$PWD
    HOST_PWD=${HOST_PWD/\/mnt\//}
    HOST_PWD=${HOST_PWD/\//:\/}
elif [ -n "$MSYS" ]; then
    HOST_PWD=$PWD
    HOST_PWD=${HOST_PWD/\//}
    HOST_PWD=${HOST_PWD/\//:\/}
else
    HOST_PWD=$PWD
fi

#------------------------------------------------------------------------------
# Now, finally, run the command in a container
#
tty -s && TTY_ARGS=-ti || TTY_ARGS=
CONTAINER_NAME=dockcross_$RANDOM
docker run $TTY_ARGS --name $CONTAINER_NAME \
    -v "$HOST_PWD":/work \
    $USER_IDS \
    $FINAL_ARGS \
    $FINAL_IMAGE "$@"
run_exit_code=$?

# Attempt to delete container
rm_output=$(docker rm -f $CONTAINER_NAME 2>&1)
rm_exit_code=$?
if [ $rm_exit_code != 0 ]; then
  if [ "$CIRCLECI" == "true" ] && [ $rm_output == *"Driver btrfs failed to remove"* ]; then
    : # Ignore error because of https://circleci.com/docs/docker-btrfs-error/
  else
    echo "$rm_output"
    exit $rm_exit_code
  fi
fi

exit $run_exit_code

################################################################################
#
# This image is not intended to be run manually.
#
# To create a dockcross helper script for the
# dockcross/linux-armv7 image, run:
#
# docker run --rm dockcross/linux-armv7 > dockcross-linux-armv7
# chmod +x dockcross-linux-armv7
#
# You may then wish to move the dockcross script to your PATH.
#
################################################################################

```

`dist/scripts/indent.pl`:

```pl
#!/usr/bin/perl
use strict;
use warnings;

while (<>) {
	s/^ +/\t/g;
	if (/^[A-Za-z0-9]/) {
		s/\s*\(/(/g;
	} else {
		s/\s*\(/ (/g;
	}
	print;
}

```

`dist/scripts/indent.py`:

```py
import re
import subprocess

# Step 1: Format the file in-place using clang-format
subprocess.run(["clang-format", "-i", "r2mcp.c"], check=True)

def is_function(s):
    return s and not s[0].isspace()

def is_control_structure(s):
    return s in {"if", "for", "while", "switch", "catch", "return"}

def fix_line(line):
    # Skip lines that are empty or only whitespace
    if not line.strip():
        return line

    # Match function calls like: foo(bar) => foo (bar)
    # Avoid if/for/while/catch/return and function *definitions*
    pattern = r'\b([a-zA-Z_]\w*)\('

    def replacer(match):
        name = match.group(1)
        if is_control_structure(name) or is_function(line):
            return match.group(0)  # No change
        return f'{name} ('

    return re.sub(pattern, replacer, line)

# Step 2: Read the file, transform it, and write it back
with open("r2mcp.c", "r", encoding="utf-8") as f:
    lines = f.readlines()

with open("r2mcp.c", "w", encoding="utf-8") as f:
    for line in lines:
        f.write(fix_line(line))

```

`meson.build`:

```build
project(
  'r2mcp',
  'c',
version : '1.5.6',
  default_options : ['warning_level=2', 'c_std=c11']
)

cc = meson.get_compiler('c')

r_core_dep = dependency('r_core', method: 'pkg-config', required: false)

r2_libdirs = []
r2_incdirs = []

if not r_core_dep.found()
  is_windows_like = host_machine.system() == 'windows' or cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl'

  if is_windows_like
    r2libdirs = []
    if get_option('r2_prefix') != ''
      p = get_option('r2_prefix')
      r2libdirs += [join_paths(p, 'lib'), join_paths(p, 'radare2', 'lib')]
    endif
    r2libdirs += [meson.current_source_dir() + '/radare2/lib', 'C:/radare2/lib']

    rcore_lib = cc.find_library('r_core', dirs: r2libdirs, required: false)
    if not rcore_lib.found()
      rcore_lib = cc.find_library('libr_core', dirs: r2libdirs, required: false)
    endif

    if rcore_lib.found()
      incdirs = []
      if get_option('r2_prefix') != ''
        p = get_option('r2_prefix')
        incdirs += [join_paths(p, 'include', 'libr'), join_paths(p, 'include')]
      endif
      rcore_inc = include_directories(incdirs)
      r_core_dep = declare_dependency(dependencies: [rcore_lib], include_directories: rcore_inc)
      r2_libdirs = r2libdirs
      r2_incdirs = incdirs
    else
      error('Windows dependency lookup for r_core failed: ensure radare2 is installed and pass -Dr2_prefix=<prefix> (e.g. C:/radare2)')
    endif
  else
    r2_prefixes = []
    if get_option('r2_prefix') != ''
      r2_prefixes += [get_option('r2_prefix')]
    endif

    found = false
    foreach p : r2_prefixes
      libdirs = [
        join_paths(p, 'lib'),
        join_paths(p, 'lib64'),
        join_paths(p, 'radare2', 'lib'),
        join_paths(p, 'radare2', 'lib64'),
        join_paths(p, 'mingw64', 'lib'),
      ]
      incdirs = [
        join_paths(p, 'include'),
        join_paths(p, 'radare2', 'include'),
        join_paths(p, 'include', 'radare2'),
      ]
      extra_libdirs = libdirs + [join_paths(p, 'bin')]
      candidate_names = ['r_core', 'r_core-6', 'r_core6', 'r_core64', 'libr_core']
      foreach name : candidate_names
        rcore_lib = cc.find_library(name, dirs: extra_libdirs, required: false)
        if rcore_lib.found()
          rcore_inc = include_directories(incdirs + [join_paths(p, 'include', 'libr')])
          r_core_dep = declare_dependency(dependencies: [rcore_lib], include_directories: rcore_inc)
          r2_libdirs = extra_libdirs
          r2_incdirs = incdirs + [join_paths(p, 'include', 'libr')]
          found = true
          break
        endif
      endforeach
      if found
        break
      endif
    endforeach

    if not found
      error('Dependency lookup for r_core failed: install radare2 development files or provide pkg-config paths or set the meson option -Dr2_prefix=<prefix>')
    endif
  endif
endif

r_deps = {
  'r_util': ['r_util', 'libr_util'],
  'r_cons': ['r_cons', 'libr_cons'],
  'r_config': ['r_config', 'libr_config'],
  'r_socket': ['r_socket', 'libr_socket']
}

foreach dep_name, lib_names : r_deps
  dep_var = dependency(dep_name, method: 'pkg-config', required: false)
  if not dep_var.found() and r2_libdirs.length() > 0
    foreach name : lib_names
      lib = cc.find_library(name, dirs: r2_libdirs, required: false)
      if lib.found()
        inc = include_directories(r2_incdirs)
        dep_var = declare_dependency(dependencies: [lib], include_directories: inc)
        break
      endif
    endforeach
  endif
  if not dep_var.found()
    warning('@0@ dependency not found via pkg-config or same paths as r_core'.format(dep_name))
  endif
  set_variable(dep_name + '_dep', dep_var)
endforeach

# duplicated files between srcs and plugins, also "srcs" is not clear who will use that
srcs = [
  'src/main.c',
  'src/r2mcp.c',
  'src/readbuffer.c',
  'src/validation.c',
  'src/tools.c',
  'src/dsltest.c',
  'src/prompts.c',
  'src/jsonrpc.c',
]

plugin_srcs = [
  'src/plugin.c',
  'src/r2mcp.c',
  'src/readbuffer.c',
  'src/validation.c',
  'src/tools.c',
  'src/dsltest.c',
  'src/prompts.c',
  'src/jsonrpc.c',
]

if host_machine.system() == 'windows'
  configure_file(
    input: 'config.h.w64',
    output: 'config.h',
    copy: true
  )

  link_args = []
  c_args = []
  if cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl'
    link_args += ['/SUBSYSTEM:CONSOLE', '/DEFAULTLIB:setupapi.lib']
  endif
else
  conf_data = configuration_data()
  conf_data.set('R2MCP_VERSION', meson.project_version())
  configure_file(
    input: 'src/config.h.acr',
    output: 'config.h',
    configuration: conf_data
  )
  link_args = []
  c_args = ['-D_GNU_SOURCE', '-D_POSIX_C_SOURCE=200809L']
endif

executable(
  'r2mcp',
  srcs,
  dependencies: [r_core_dep, r_util_dep, r_cons_dep, r_config_dep],
  c_args: c_args,
  link_args: link_args,
  install: true,
)

plugin_lib = shared_library(
  'core_r2mcp',
  plugin_srcs,
  dependencies: [r_core_dep, r_util_dep, r_cons_dep, r_config_dep],
  c_args: c_args,
  link_args: link_args,
  install: false,
)

executable(
  'r2mcp-svc',
  'svc/r2mcp-svc.c',
  dependencies: [r_socket_dep, r_util_dep, r_cons_dep],
  c_args: c_args,
  link_args: link_args,
  install: true,
)

```

`meson_options.txt`:

```txt
option('r2_prefix',
  type : 'string',
  value : '',
  description : 'Path prefix where radare2 is installed (include/ and lib/)',
)


```

`prompts/crackme_solver.r2ai.md`:

```md
---
description: 'Plan and solve a crackme using radare2 with minimal, targeted steps'
version: 0.1
author: r2mcp
args:
  - name: file_path
    description: 'Absolute path to target binary'
    required: false
  - name: goal
    description: 'What success looks like (e.g., recover password)'
    required: false
user_template: |
  Task: {goal}.
  {if file_path}Open file: {file_path} (use tools/call open_file).{/if}
  {else}Ask for or confirm file path if unknown.{/else}
  Plan your steps, then call: analyze (level=2), list_entrypoints, list_functions, list_imports, list_strings (filter optional).
  Use decompile_function or disassemble_function on candidate functions only.
---
You are an expert reverse engineer using radare2 via r2mcp.
Goal: plan first, then execute minimal tool calls.
General steps:
1) Open the target binary and run lightweight analysis (analyze level 2).
2) Identify main/entrypoints and functions referring to strcmp, strncmp, memcmp, crypto, or suspicious branches.
3) Read/Decompile only the most relevant functions (avoid dumping huge outputs).
4) Derive the key/logic and propose inputs or patches.
5) Summarize findings and next actions.
Prefer afl listing with addresses, selective pdc/pdf on key functions, and xrefs_to for checks.
```

`prompts/document_function.r2ai.md`:

```md
---
description: 'Explain a function's purpose, behavior, and pseudocode'
version: 0.1
author: r2mcp
args:
  - name: address
    description: 'Function start address to document'
    required: true
  - name: detail
    description: 'Level of detail: concise|full'
    required: false
user_template: |
  Target function address: {address}.
  Detail level: {detail}.
  Use: get_current_address (to verify), disassemble_function (address), decompile_function (address), get_function_prototype (address).
---
Produce a clear, structured explanation of a function's behavior.
Guidelines:
- Summarize purpose, inputs/outputs, side effects.
- Highlight algorithms, notable constants, error paths.
- Provide a brief high-level pseudocode if helpful.
```

`prompts/find_control_flow_path.r2ai.md`:

```md
---
description: 'Find a control-flow path between two addresses for reachability or exploit planning'
version: 0.1
author: r2mcp
args:
  - name: source_address
    description: 'Source address or block'
    required: true
  - name: target_address
    description: 'Target address or block'
    required: true
user_template: |
  Compute a path with minimal output.
  Source: {source_address}. Target: {target_address}. Use: get_current_address, disassemble_function, disassemble, xrefs_to.
---
Find and explain a feasible control-flow path between two addresses.
Approach:
- Identify function boundaries for source/target.
- Use xrefs_to and selective disassembly to traverse edges.
- Summarize the path as a sequence of blocks with conditions.
```

`prompts/find_crypto_material.r2ai.md`:

```md
---
description: 'Locate keys, IVs, S-boxes, and crypto constants'
version: 0.1
author: r2mcp
args:
  - name: hint
    description: 'Extra context (e.g., suspected algorithm)'
    required: false
user_template: |
  Focus: {hint}.
  Use: list_imports, list_strings (filter to crypto keywords), list_functions (scan for suspicious names), and xrefs_to (address).
  If needed, disassemble/decompile only tight regions where material is assigned.
---
You are tasked with locating cryptographic material in a binary.
Strategy:
- List imports and strings to find crypto APIs/signatures.
- Search for constants (AES S-box, SHA tables), base64 sets, or long random-looking blobs.
- Inspect xrefs to functions handling buffers just before encryption/decryption.
- Use selective decompilation and avoid dumping entire files.
```

`r2mcp.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (https://www.inkscape.org/) -->

<svg
   id="svg3004"
   version="1.1"
   inkscape0:version="0.48.2 r9819"
   width="500"
   height="300"
   xml:space="preserve"
   sodipodi0:docname="r2.svg"
   sodipodi:docname="r2mcp.svg"
   inkscape:version="1.4.2 (ebf0e940, 2025-05-08)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns:inkscape0="https://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi0="https://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:ns="https://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:ns0="https://creativecommons.org/ns#"
   xmlns:ns1="https://purl.org/dc/elements/1.1/"><sodipodi:namedview
     id="namedview1"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="false"
     inkscape:zoom="1.9968695"
     inkscape:cx="249.64074"
     inkscape:cy="147.23045"
     inkscape:window-width="1512"
     inkscape:window-height="1001"
     inkscape:window-x="265"
     inkscape:window-y="68"
     inkscape:window-maximized="0"
     inkscape:current-layer="svg3004" /><metadata
     id="metadata3010"><RDF><ns0:Work
         ns:about=""><ns1:format>image/svg+xml</ns1:format><ns1:type
           ns:resource="https://purl.org/dc/dcmitype/StillImage" /><ns1:title /></ns0:Work></RDF></metadata><defs
     id="defs3008"><clipPath
       clipPathUnits="userSpaceOnUse"
       id="clipPath3018"><path
         d="m 0,841.89 1190.55,0 L 1190.55,0 0,0 0,841.89 z"
         id="path3020"
         inkscape0:connector-curvature="0" /></clipPath></defs><sodipodi0:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape0:pageopacity="0"
     inkscape0:pageshadow="2"
     inkscape0:window-width="791"
     inkscape0:window-height="818"
     id="namedview3006"
     showgrid="false"
     inkscape0:zoom="0.39912236"
     inkscape0:cx="715.69007"
     inkscape0:cy="676.77258"
     inkscape0:window-x="2687"
     inkscape0:window-y="256"
     inkscape0:window-maximized="0"
     inkscape0:current-layer="g3012" /><image
     width="212.47162"
     height="225.99278"
     preserveAspectRatio="none"
     xlink:href="data:image/png;base64,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&#10;"
     id="image1"
     x="175.39853"
     y="52.265926" /><path
     style="fill:#000000"
     id="path2" /><path
     style="fill:#000000"
     id="path1" /><g
     id="g1048580"
     transform="translate(69.608954,-5.0078384)"><path
       d="M 178.75603,89.275988 V 208.33974 h 14.85125 v 6.72375 H 89.947278 v -6.72375 h 19.890002 v -64.43375 c 0,-11.485 0.84125,-21.5725 -3.07875,-32.4975 -0.84125,-2.80125 -9.242502,-18.768753 -13.447502,-11.766253 1.1225,4.203753 1.6825,8.965003 1.6825,13.170003 0,18.76625 -12.88875,30.8125 -31.3775,30.8125 -19.33,0 -32.77625,-13.44625 -32.77625,-32.77625 0,-20.170003 17.65,-31.093753 36.13875,-31.093753 19.88625,0 35.853752,10.6425 45.106252,27.732503 h 0.555 V 79.190987 c 26.89125,0.84125 54.0675,3.362501 80.9675,3.362501 v 6.7225 z"
       style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1.25"
       id="path3492-8"
       inkscape0:connector-curvature="0" /><g
       id="g1048579"
       transform="matrix(1.1681838,0,0,1.1681838,-51.445372,-28.914799)"><image
         width="142.58737"
         height="142.58737"
         preserveAspectRatio="none"
         xlink:href="data:image/png;base64,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&#10;"
         id="image1-9"
         x="174.87346"
         y="79.955605" /><path
         style="fill:#000000"
         d="m 257.57413,221.9363 c -5.78357,-1.7486 -16.6101,-16.58262 -15.70719,-21.52129 0.75265,-4.11681 -0.511,-2.73676 29.11557,-31.7976 15.50417,-15.20812 27.43862,-27.13519 27.95112,-27.93386 8.11358,-12.64392 -6.03476,-28.05958 -19.6689,-21.43074 -2.47477,1.20322 -1.59175,0.37205 -30.05415,28.28921 -11.0065,10.79565 -17.98979,17.43706 -18.6581,17.74465 -4.07309,1.87465 -8.36824,-2.04384 -6.88961,-6.28544 0.20799,-0.59665 7.06795,-7.5038 20.88905,-21.03272 25.55575,-25.01552 25.0621,-24.5072 26.26787,-27.04881 4.95176,-10.43769 -2.83895,-21.920354 -14.37372,-21.185302 -5.87263,0.374232 -6.27396,0.678921 -24.31356,18.458982 -46.16787,45.50363 -43.6317,43.13739 -46.23515,43.13739 -3.80561,0 -6.19323,-3.68625 -4.58406,-7.07732 0.47784,-1.00697 58.28534,-57.811909 60.64193,-59.59021 16.72876,-12.623629 41.46105,-0.013 40.6747,20.73943 l -0.0869,2.2933 2.70111,-0.0499 c 20.65527,-0.38138 33.40516,22.17252 22.01557,38.94442 -1.0758,1.58419 -11.24019,11.70508 -43.18348,42.99868 -11.15259,10.92575 -12.20559,12.02557 -12.20559,12.7483 0,0.15426 2.68791,2.91179 5.97313,6.12786 6.46707,6.33094 6.73539,6.71603 6.51673,9.35278 -0.2627,3.16775 -3.47747,5.11857 -6.78637,4.11816 z m -30.82468,-37.37489 c -19.25015,-1.66912 -29.36755,-24.31416 -17.68631,-39.58596 2.00165,-2.61692 44.84524,-44.50514 46.16682,-45.137355 4.16632,-1.993069 8.7258,2.547775 6.73987,6.712315 -0.25548,0.53575 -9.98939,10.28854 -22.37032,22.41372 -22.29357,21.83305 -23.4276,23.04551 -24.48181,26.1749 -4.50325,13.36769 10.88702,24.91641 22.62471,16.97738 0.85177,-0.57611 11.3671,-10.66545 23.3674,-22.42076 23.81039,-23.32429 22.55957,-22.22759 25.16235,-22.06186 3.77294,0.24024 6.01939,4.1568 4.14006,7.21795 -0.72021,1.17312 -44.32171,43.81694 -46.09871,45.08618 -5.03078,3.59328 -11.08015,5.18569 -17.56406,4.62349 z"
         id="path1048579" /></g></g></svg>

```

`src/config.h.acr`:

```acr
#ifndef R2MCP_CONFIG_H
#define R2MCP_CONFIG_H 1

#undef R2MCP_VERSION
#define R2MCP_VERSION "@R2MCP_VERSION@"

#endif

```

`src/curl.inc.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake, dnakov */

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#if defined(R2__WINDOWS__)
#include <windows.h>
#include <io.h>
#include <fcntl.h>
#elif defined(R2__UNIX__)
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#else
#error please define R2__WINDOWS__ or R2__UNIX__ for platform detection
#endif

/**
 * Execute: curl -sS -d "<msg>" <url>
 * Capture stdout (HTTP response body) and return it as a malloc'd NUL-terminated string.
 *
 * @param url  Target URL (non-NULL)
 * @param msg  Message for -d (non-NULL), e.g. "key=value" or JSON string
 * @param exit_code_out Optional: receives curl's exit code (0 on success). Pass NULL if not needed.
 *
 * @return malloc'd buffer with the response (caller must free), or NULL on error.
 *         On error, *exit_code_out (if provided) is set to a negative number when possible.
 */
char *curl_post_capture(const char *url, const char *msg, int *exit_code_out) {
	if (exit_code_out) {
		*exit_code_out = -1;
	}
	if (!url || !msg) {
		errno = EINVAL;
		return NULL;
	}
	char *buf = NULL;
	size_t len = 0;
	int exit_code = -1;
#if R2__WINDOWS__
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof (SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;

	HANDLE read_h = NULL, write_h = NULL;
	if (!CreatePipe (&read_h, &write_h, &sa, 0)) {
		return NULL;
	}
	// Ensure the read handle is not inherited
	SetHandleInformation (read_h, HANDLE_FLAG_INHERIT, 0);

	char *escaped_msg = r_str_escape_sh (msg);
	char *escaped_url = r_str_escape_sh (url);
	char *cmd = r_str_newf ("curl -sS -d \"%s\" \"%s\"", escaped_msg, escaped_url);
	free (escaped_msg);
	free (escaped_url);

	STARTUPINFOA si;
	PROCESS_INFORMATION pi;
	ZeroMemory (&si, sizeof (si));
	si.cb = sizeof (si);
	si.hStdOutput = write_h;
	si.hStdError = GetStdHandle (STD_ERROR_HANDLE);
	si.dwFlags |= STARTF_USESTDHANDLES;

	ZeroMemory (&pi, sizeof (pi));

	// Create process
	BOOL ok = CreateProcessA (NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
	free (cmd);
	// Close the write handle in parent after creating the child
	CloseHandle (write_h);

	if (!ok) {
		CloseHandle (read_h);
		return NULL;
	}

	// Read child's stdout
	size_t cap = 8192;
	buf = malloc (cap);
	if (!buf) {
		CloseHandle (read_h);
		CloseHandle (pi.hProcess);
		CloseHandle (pi.hThread);
		WaitForSingleObject (pi.hProcess, INFINITE);
		return NULL;
	}

	for (;;) {
		if (len + 4096 + 1 > cap) {
			size_t ncap = cap * 2;
			char *tmp = realloc (buf, ncap);
			if (!tmp) {
				R_FREE (buf);
				break;
			}
			buf = tmp;
			cap = ncap;
		}
		DWORD nread = 0;
		BOOL r = ReadFile (read_h, buf + len, 4096, &nread, NULL);
		if (r && nread > 0) {
			len += (size_t)nread;
			continue;
		}
		if (!r) {
			DWORD err = GetLastError ();
			if (err == ERROR_BROKEN_PIPE) {
				break; // EOF
			}
			R_FREE (buf);
			break;
		}
		// r == TRUE but nread == 0 -> EOF
		break;
	}

	CloseHandle (read_h);

	// Wait for process and get exit code
	WaitForSingleObject (pi.hProcess, INFINITE);
	DWORD exitcode = 0;
	if (!GetExitCodeProcess (pi.hProcess, &exitcode)) {
		exitcode = (DWORD)-1;
	}
	exit_code = (int)exitcode;
	CloseHandle (pi.hProcess);
	CloseHandle (pi.hThread);
#elif R2__UNIX__
	int pipefd[2];
	if (pipe (pipefd) == -1) {
		return NULL;
	}

	pid_t pid = fork ();
	if (pid == -1) {
		int e = errno;
		close (pipefd[0]);
		close (pipefd[1]);
		errno = e;
		return NULL;
	}

	if (pid == 0) {
		// Child: stdout -> pipe write end
		// stderr unchanged (so errors still show on parent stderr because of -sS)
		if (dup2 (pipefd[1], STDOUT_FILENO) == -1) {
			_exit (127);
		}

		close (pipefd[0]);
		close (pipefd[1]);

		// Build argv; no shell is involved (safe for spaces/quotes in msg/url).
		// Note: if msg starts with '@', curl treats it as a file. If that's unwanted,
		// use "--data-raw" instead of "-d".
		char *const argv[] = {
			"curl",
			"-sS",
			"-d",
			(char *)msg,
			(char *)url,
			NULL
		};

		execvp ("curl", argv);
		// If exec fails:
		_exit (127);
	}

	// Parent
	close (pipefd[1]); // we read from pipefd[0]

	// Read child's stdout fully into a dynamic buffer
	size_t cap = 8192;
	buf = malloc (cap);
	if (!buf) {
		close (pipefd[0]);
		// Reap child to avoid a zombie
		int st;
		waitpid (pid, &st, 0);
		return NULL;
	}

	for (;;) {
		if (len + 4096 + 1 > cap) {
			size_t ncap = cap * 2;
			char *tmp = realloc (buf, ncap);
			if (!tmp) {
				R_FREE (buf);
				break;
			}
			buf = tmp;
			cap = ncap;
		}
		ssize_t n = read (pipefd[0], buf + len, 4096);
		if (n > 0) {
			len += (size_t)n;
		} else if (n == 0) {
			break; // EOF
		} else if (errno != EINTR) {
			free (buf);
			buf = NULL; // read error
			break;
		}
	}
	close (pipefd[0]);
	// Reap curl
	int status = 0;
	if (waitpid (pid, &status, 0) != -1) {
		if (WIFEXITED (status)) {
			exit_code = WEXITSTATUS (status);
		} else if (WIFSIGNALED (status)) {
			exit_code = 128 + WTERMSIG (status);
		}
	}
#else
#error unsupported platform for curl_post_capture
#endif
	if (exit_code_out) {
		*exit_code_out = exit_code;
	}
	if (!buf) {
		return NULL;
	}
	// NUL-terminate (even if empty)
	buf[len] = '\0';
	return buf;
}

```

`src/dsltest.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake, dnakov */

#include "r2mcp.h"
// Simple DSL runner for invoking tools from the CLI for testing.
// DSL grammar (very small):
//   program := stmt (';' stmt)*
//   stmt := TOOLNAME (WS key=val)*
// Values may be quoted with double-quotes. Keys/values do not support
// nested structures. Example:
//   open_file file_path="/bin/ls"; list_functions only_named=true; close_file
char *tools_call(ServerState *ss, const char *tool_name, RJson *tool_args);
// Parse a single statement of the form: toolName [key=val ...]
// Returns 0 on success.
static int run_statement(ServerState *ss, char *stmt, RCore *core) {
	r_str_trim (stmt);
	if (R_STR_ISEMPTY (stmt)) {
		return 0;
	}
	// extract tool name (first token up to whitespace)
	char *p = stmt;
	while (*p && !isspace ((unsigned char)*p)) {
		p++;
	}
	char saved = *p;
	if (saved) {
		*p++ = '\0';
	}
	const char *tool = stmt;
	RStrBuf *sb = r_strbuf_new ("{");
	bool first = true;
	// parse key=val tokens
	while (*p) {
		p = (char *)r_str_trim_head_ro (p);
		if (!*p) {
			break;
		}
		// key
		char *key = p;
		// advance to '=' or whitespace
		while (*p && *p != '=' && !isspace ((ut8)*p)) {
			p++;
		}
		if (!*p || *p != '=') {
			// no key=value, treat rest as error or ignore
			break;
		}
		*p++ = '\0';
		// value
		char *val = p;
		if (*p == '"') {
			p++;
			val = p;
			while (*p && *p != '"') {
				if (*p == '\\' && p[1]) {
					p += 2;
				} else {
					p++;
				}
			}
			if (*p == '"') {
				*p++ = '\0';
			}
		} else {
			p = (char *)r_str_trim_head_ro (p);
			if (*p) {
				*p++ = '\0';
			}
		}
		// append to JSON
		if (!first) {
			r_strbuf_append (sb, ",");
		}
		first = false;
		// determine if val is a bare true/false or number
		bool bare = false;
		if (!strcmp (val, "true") || !strcmp (val, "false")) {
			bare = true;
		} else {
			// check if integer
			char *q = (char *)val;
			bool digits = true;
			if (*q == '-' || *q == '+') {
				q++;
			}
			while (*q) {
				if (!isdigit ((ut8)*q)) {
					digits = false;
					break;
				}
				q++;
			}
			if (digits && *val) {
				bare = true;
			}
		}
		if (bare) {
			r_strbuf_appendf (sb, "\"%s\":%s", key, val);
		} else {
			char *esc = strdup (val); // r_str_escape_json (val, -1);
			r_strbuf_appendf (sb, "\"%s\":\"%s\"", key, esc);
			free (esc);
		}
	}
	// no need to restore the separator char
	r_strbuf_append (sb, "}");
	char *jsonbuf = r_strbuf_drain (sb);
	// debug: built args JSON (left commented intentionally)
	// printf ("[DSL] args json: %s\n", jsonbuf);
	RJson *args = NULL;
	if (strlen (jsonbuf) > 2) {
		// parse it (parser does not take ownership; keep jsonbuf alive until free)
		args = r_json_parse (jsonbuf);
		if (!args) {
			printf ("[DSL] Failed to parse arguments for tool %s\n", tool);
			free (jsonbuf);
			return -1;
		}
	}
	// call the tool
	char *res = tools_call (ss, tool, args);
	if (args) {
		r_json_free (args);
	}
	if (res) {
		if (core) {
			// Extract text from JSON response
			const char *text_start = strstr (res, "\"text\":\"");
			if (text_start) {
				text_start += 8; // skip "text":"
				const char *text_end = strstr (text_start, "\"");
				if (text_end) {
					char *text = r_str_ndup (text_start, text_end - text_start);
					r_str_replace_in (text, -1, "\\n", "\n", true);
					r_cons_printf (core->cons, "%s\n", text);
					free (text);
				} else {
					r_cons_printf (core->cons, "(malformed text in response)\n");
				}
			} else {
				r_cons_printf (core->cons, "(no text in response)\n");
			}
		} else {
			printf ("[DSL] %s -> %s\n", tool, res);
		}
		free (res);
	} else {
		if (core) {
			r_cons_printf (core->cons, "(no result)\n");
		} else {
			printf ("[DSL] %s -> (no result)\n", tool);
		}
	}
	free (jsonbuf);
	return 0;
}

int r2mcp_run_dsl_tests(ServerState *ss, const char *dsl, RCore *core) {
	R_RETURN_VAL_IF_FAIL (dsl, 1);
	char *copy = strdup (dsl);
	char *cur = copy;
	char *semi;
	int rc = 0;
	while ((semi = strchr (cur, ';')) != NULL) {
		*semi = '\0';
		if (run_statement (ss, cur, core) != 0) {
			rc = 1;
		}
		cur = semi + 1;
	}
	if (*cur) {
		if (run_statement (ss, cur, core) != 0) {
			rc = 1;
		}
	}
	free (copy);
	return rc;
}

```

`src/jsonrpc.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake, dnakov */

#include "jsonrpc.h"

// Helper function to create a simple text tool result
char *jsonrpc_tooltext_response(const char *text) {
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_k (pj, "content");
	pj_a (pj);
	pj_o (pj);
	pj_ks (pj, "type", "text");
	pj_ks (pj, "text", text);
	pj_end (pj);
	pj_end (pj);
	pj_end (pj);
	return pj_drain (pj);
}

// Helper function to create a paginated text tool result
char *jsonrpc_tooltext_response_paginated(const char *text, bool has_more, const char *next_cursor) {
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_k (pj, "content");
	pj_a (pj);
	pj_o (pj);
	pj_ks (pj, "type", "text");
	pj_ks (pj, "text", text);
	pj_end (pj);
	pj_end (pj);
	if (has_more || next_cursor) {
		pj_k (pj, "pagination");
		pj_o (pj);
		if (has_more) {
			pj_kb (pj, "hasMore", true);
		}
		if (next_cursor) {
			pj_ks (pj, "nextCursor", next_cursor);
		}
		pj_end (pj);
	}
	pj_end (pj);
	return pj_drain (pj);
}

// Render tool output as a JSON array of lines for frontend filtering compatibility
char *jsonrpc_tooltext_response_lines(const char *text) {
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_k (pj, "content");
	pj_a (pj);
	if (text) {
		RList *lines = r_str_split_list ((char *)text, "\n", 0);
		if (lines) {
			RListIter *it;
			char *line;
			r_list_foreach (lines, it, line) {
				pj_s (pj, line);
			}
			r_list_free (lines);
		}
	}
	pj_end (pj);
	pj_end (pj);
	return pj_drain (pj);
}

// JSON-RPC error response builder. Returns heap-allocated JSON string (caller frees).
char *jsonrpc_error_response(int code, const char *message, const char *id, const char *uri) {
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_ks (pj, "jsonrpc", "2.0");
	if (id) {
		pj_ks (pj, "id", id);
	}
	pj_k (pj, "error");
	pj_o (pj);
	pj_ki (pj, "code", code);
	pj_ks (pj, "message", message);
	if (uri) {
		pj_k (pj, "data");
		pj_o (pj);
		pj_ks (pj, "uri", uri);
		pj_end (pj);
	}
	pj_end (pj);
	pj_end (pj);
	return pj_drain (pj);
}

// Create a proper success response
char *jsonrpc_success_response(ServerState *ss, const char *result, const char *id) {
	(void)ss; // unused now, kept for API consistency
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_ks (pj, "jsonrpc", "2.0");

	if (id) {
		// If id is a number string, treat it as a number
		char *endptr;
		long num_id = strtol (id, &endptr, 10);
		if (*id != '\0' && *endptr == '\0') {
			// It's a valid number
			pj_kn (pj, "id", num_id);
		} else {
			// It's a string
			pj_ks (pj, "id", id);
		}
	}

	pj_k (pj, "result");
	if (result) {
		pj_raw (pj, result);
	} else {
		pj_null (pj);
	}

	pj_end (pj);
	return pj_drain (pj);
}

// Standardized error response helpers for consistent error handling
char *jsonrpc_error_missing_param(const char *param_name) {
	char *msg = r_str_newf ("Missing required parameter: %s", param_name);
	char *err = jsonrpc_error_response (-32602, msg, NULL, NULL);
	free (msg);
	return err;
}

char *jsonrpc_error_tool_not_allowed(const char *tool_name) {
	char *msg = r_str_newf ("Tool '%s' not available in current mode (use -p for permissive)", tool_name);
	char *err = jsonrpc_error_response (-32611, msg, NULL, NULL);
	free (msg);
	return err;
}

char *jsonrpc_error_file_required(void) {
	return jsonrpc_error_response (-32611, "Use the open_file method before calling any other method", NULL, NULL);
}

```

`src/jsonrpc.h`:

```h
#ifndef JSONRPC_H
#define JSONRPC_H

#include <r_core.h>
#include "r2mcp.h"

char *jsonrpc_tooltext_response(const char *text);
char *jsonrpc_tooltext_response_paginated(const char *text, bool has_more, const char *next_cursor);
char *jsonrpc_tooltext_response_lines(const char *text);
char *jsonrpc_error_response(int code, const char *message, const char *id, const char *uri);
char *jsonrpc_success_response(ServerState *ss, const char *result, const char *id);
char *jsonrpc_error_missing_param(const char *param_name);
char *jsonrpc_error_tool_not_allowed(const char *tool_name);
char *jsonrpc_error_file_required(void);

#endif
```

`src/main.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake, dnakov */

#include <string.h>

#include "tools.h"
#include "prompts.h"

#if R2__UNIX__
#include <signal.h>
/* Signal handling moved from r2mcp.c */
static void signal_handler(int signum) {
	const char msg[] = "\nInterrupt received, shutting down...\n";
	(void)write (STDERR_FILENO, msg, sizeof (msg) - 1);
	r2mcp_running_set (0);
	signal (signum, SIG_DFL);
}
void setup_signals(void) {
	struct sigaction sa = { 0 };
	sa.sa_flags = 0;
	sa.sa_handler = signal_handler;
	sigemptyset (&sa.sa_mask);
	sigaction (SIGINT, &sa, NULL);
	sigaction (SIGTERM, &sa, NULL);
	sigaction (SIGHUP, &sa, NULL);
	signal (SIGPIPE, SIG_IGN);
}

#endif
/* Help and version moved from r2mcp.c */
void r2mcp_help(void) {
	const char help_text[] =
		"Usage: r2mcp [-flags]\n"
		" -c [cmd]   run those commands before entering the mcp loop\n"
		" -d [pdc]   select a different decompiler (pdc by default)\n"
		" -u [url]   use remote r2 webserver base URL (HTTP r2pipe client mode)\n"
		" -l [file]  append debug logs to this file\n"
		" -s [dir]   enable sandbox mode; only allow files under [dir]\n"
		" -e [tool]  enable only the specified tool (repeatable)\n"
		" -D [tool]  disable the specified tool (repeatable)\n"
		" -h         show this help\n"
		" -r         enable the dangerous runCommand tool\n"
		" -R         enable read-only mode (expose only non-mutating tools)\n"
		" -m         expose minimum amount of tools\n"
		" -t         list available tools and exit\n"
		" -T [tests] run DSL tests and exit\n"
		" -p         permissive tools: allow calling non-listed tools\n"
		" -n         do not load any plugin or radare2rc\n"
		" -i         ignore analysis level specified in analyze calls\n"
		" -S [url]   enable supervisor control; connect to svc at [url]\n"
		" -P [dir]   specify custom prompts directory (supports colon-separated paths like r2ai)\n"
		" -N         do not load any prompts\n"
		" -L         enable session management tools (list/open/close sessions)\n"
		" -v         show version\n";
	printf ("%s", help_text);
}

void r2mcp_version(void) {
	printf ("%s\n", R2MCP_VERSION);
}

/* Program entry point wrapper */
int main(int argc, const char **argv) {
	return r2mcp_main (argc, argv);
}
/* Moved from r2mcp.c to isolate main concerns here */
int r2mcp_main(int argc, const char **argv) {
	bool minimode = false;
	bool enable_run_command_tool = false;
	bool readonly_mode = false;
	bool list_tools = false;
	RList *cmds = r_list_newf (free);
	/* Whitelist of enabled tool names (populated via repeated -e flags) */
	RList *enabled_tools = NULL;
	bool loadplugins = true;
	const char *deco = NULL;
	bool http_mode = false;
	bool permissive = false;
	char *baseurl = NULL;
	char *svc_baseurl = NULL;
	char *sandbox = NULL;
	char *logfile = NULL;
	char *prompts_dir = NULL;
	bool load_prompts = true;
	bool ignore_analysis_level = false;
	bool use_sessions = false;
	const char *dsl_tests = NULL;
	RList *disabled_tools = NULL;
	RGetopt opt;
	r_getopt_init (&opt, argc, argv, "hmvpd:nc:u:l:s:rite:D:RT:S:P:NL");
	int c;
	while ((c = r_getopt_next (&opt)) != -1) {
		switch (c) {
		case 'h':
			r2mcp_help ();
			return 0;
		case 'c':
			r_list_append (cmds, strdup (opt.arg));
			break;
		case 'v':
			r2mcp_version ();
			return 0;
		case 'd':
			deco = opt.arg;
			break;
		case 'u':
			http_mode = true;
			baseurl = strdup (opt.arg);
			R_LOG_INFO ("[R2MCP] HTTP r2pipe client mode enabled, baseurl=%s", baseurl);
			break;
		case 'l':
			logfile = strdup (opt.arg);
			break;
		case 's':
			sandbox = strdup (opt.arg);
			break;
		case 'n':
			loadplugins = false;
			break;
		case 'm':
			minimode = true;
			break;
		case 'p':
			permissive = true;
			break;
		case 'r':
			enable_run_command_tool = true;
			break;
		case 'R':
			readonly_mode = true;
			break;
		case 'i':
			ignore_analysis_level = true;
			break;
		case 't':
			list_tools = true;
			break;
		case 'T':
			dsl_tests = opt.arg;
			break;
		case 'S':
			if (opt.arg) {
				if (strspn (opt.arg, "0123456789") == strlen (opt.arg)) {
					svc_baseurl = r_str_newf ("http://localhost:%s", opt.arg);
				} else {
					svc_baseurl = strdup (opt.arg);
				}
			}
			break;
		case 'e':
			if (opt.arg) {
				if (!enabled_tools) {
					enabled_tools = r_list_newf (free);
				}
				r_list_append (enabled_tools, strdup (opt.arg));
			}
			break;
		case 'D':
			if (opt.arg) {
				if (!disabled_tools) {
					disabled_tools = r_list_newf (free);
				}
				r_list_append (disabled_tools, strdup (opt.arg));
			}
			break;
		case 'P':
			prompts_dir = strdup (opt.arg);
			break;
		case 'N':
			load_prompts = false;
			break;
		case 'L':
			use_sessions = true;
			break;
		default:
			R_LOG_ERROR ("Invalid flag -%c", c);
			return 1;
		}
	}

	/* Handle environment variable for prompts directory */
	if (!prompts_dir) {
		char *env_prompts_dir = getenv ("R2MCP_PROMPTS_DIR");
		if (env_prompts_dir) {
			prompts_dir = strdup (env_prompts_dir);
		}
	}

	ServerState ss = {
		.info = {
			.name = "Radare2 MCP Connector",
			.version = R2MCP_VERSION },
		.capabilities = { .tools = true, .prompts = load_prompts, .resources = true },
		.instructions = "Use this server to analyze binaries with radare2",
		.initialized = false,
		.minimode = minimode,
		.readonly_mode = readonly_mode,
		.permissive_tools = permissive,
		.enable_run_command_tool = enable_run_command_tool,
		.use_sessions = use_sessions,
		.http_mode = http_mode,
		.baseurl = baseurl,
		.svc_baseurl = svc_baseurl,
		.sandbox = sandbox,
		.logfile = logfile,
		.prompts_dir = prompts_dir,
		.load_prompts = load_prompts,
		.ignore_analysis_level = ignore_analysis_level,
		.client_capabilities = NULL,
		.client_info = NULL,
		.enabled_tools = enabled_tools,
		.disabled_tools = disabled_tools,
		.frida_mode = false
	};
	/* Enable logging */
	r2mcp_log_pub (&ss, "r2mcp starting");
#if R2__UNIX__
	setup_signals ();
#endif
	/* Initialize registries */
	if (list_tools) {
		/* Print tools and exit early */
		tools_print_table (&ss);
		return 0;
	}
	if (ss.load_prompts) {
		prompts_registry_init (&ss);
	}
	/* Initialize r2 (unless running in HTTP client mode) */
	if (!ss.http_mode) {
		if (!r2mcp_state_init (&ss)) {
			R_LOG_ERROR ("Failed to initialize radare2");
			r2mcp_log_pub (&ss, "Failed to initialize radare2");
			return 1;
		}
		if (loadplugins) {
			r_core_loadlibs (ss.rstate.core, R_CORE_LOADLIBS_ALL, NULL);
			r_core_parse_radare2rc (ss.rstate.core);
		}
		if (deco) {
			if (!strcmp (deco, "decai")) {
				deco = "decai -d";
			}
			char *pdc = r_str_newf ("e cmd.pdc=%s", deco);
			R_LOG_INFO ("[R2MCP] Using Decompiler: %s", pdc);
			r2mcp_cmd (&ss, pdc);
			free (pdc);
		}
	} else {
		r2mcp_log_pub (&ss, "HTTP r2pipe client mode active - skipping local r2 initialization");
		char *cmd_result = r2mcp_cmd (&ss, "i~file");
		if (cmd_result && strstr (cmd_result, "frida://")) {
			r2mcp_log_pub (&ss, "Frida mode detected");
			ss.frida_mode = true;
		}
		free (cmd_result);
	}
	/* If -T was provided, run DSL tests and exit */
	if (dsl_tests) {
		int r = r2mcp_run_dsl_tests (&ss, dsl_tests, NULL);
		/* Cleanup and return */
		if (ss.load_prompts) {
			prompts_registry_fini (&ss);
		}
		r2mcp_state_fini (&ss);
		free (ss.baseurl);
		free (ss.svc_baseurl);
		free (ss.sandbox);
		free (ss.logfile);
		free (ss.prompts_dir);
		if (ss.enabled_tools) {
			r_list_free (ss.enabled_tools);
		}
		if (ss.disabled_tools) {
			r_list_free (ss.disabled_tools);
		}
		return r == 0? 0: 2;
	}
	RListIter *iter;
	const char *cmd;
	r_list_foreach (cmds, iter, cmd) {
		r2mcp_cmd (&ss, cmd);
	}
	r_list_free (cmds);
	r2mcp_running_set (1);
	r2mcp_eventloop (&ss);
	if (ss.load_prompts) {
		prompts_registry_fini (&ss);
	}
	r2mcp_state_fini (&ss);
	/* Cleanup */
	free (ss.baseurl);
	free (ss.sandbox);
	free (ss.logfile);
	free (ss.prompts_dir);
	if (ss.enabled_tools) {
		r_list_free (ss.enabled_tools);
	}
	if (ss.disabled_tools) {
		r_list_free (ss.disabled_tools);
	}
	(void)0;
	return 0;
}

```

`src/plugin.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake */

#define R_LOG_ORIGIN "core.r2mcp"

#include <r_core.h>
#include "r2mcp.h"
#include "tools.h"

int r2mcp_run_dsl_tests(ServerState *ss, const char *dsl, RCore *core);

typedef struct r2mcp_data_t {
	ServerState *ss;
} R2mcpData;

static bool r2mcp_call(RCorePluginSession *cps, const char *input) {
	RCore *core = cps->core;
	R2mcpData *data = cps->data;

	if (!r_str_startswith (input, "r2mcp")) {
		return false;
	}

	// Skip "r2mcp" command name
	const char *args = r_str_trim_head_ro (input + strlen ("r2mcp"));

	// Initialize server state if not already done
	if (!data->ss) {
		data->ss = R_NEW0 (ServerState);
		// Initialize the tools registry
		// Set up the core reference
		data->ss->rstate.core = core;
		data->ss->rstate.file_opened = true; // We're already in r2 with a file
	}

	if (R_STR_ISEMPTY (args)) {
		tools_print_table (data->ss);
	} else {
		if (r2mcp_run_dsl_tests (data->ss, args, core) != 0) {
			R_LOG_ERROR ("Error executing r2mcp command");
		}
	}

	return true;
}

static bool r2mcp_init(RCorePluginSession *cps) {
	R2mcpData *data = R_NEW0 (R2mcpData);
	cps->data = data;
	return true;
}

static bool r2mcp_fini(RCorePluginSession *cps) {
	R2mcpData *data = cps->data;
	if (data) {
		if (data->ss) {
			free (data->ss);
		}
		free (data);
	}
	return true;
}

// PLUGIN Definition Info
RCorePlugin r_core_plugin_r2mcp = {
	.meta = {
		.name = "core-r2mcp",
		.desc = "r2mcp command integration for radare2",
		.author = "pancake",
		.license = "MIT",
	},
	.call = r2mcp_call,
	.init = r2mcp_init,
	.fini = r2mcp_fini,
};

#ifndef R2_PLUGIN_INCORE
R_API RLibStruct radare_plugin = {
	.type = R_LIB_TYPE_CORE,
	.data = &r_core_plugin_r2mcp,
	.version = R2_VERSION,
	.abiversion = R2_ABIVERSION
};
#endif

```

`src/prompts.c`:

```c
/* r2mcp - MIT - Copyright 2025-2026 - pancake, dnakov */

#include "r2mcp.h"
#include "prompts.h"

typedef struct {
	char *name;
	char *desc;
	char *req;
} ParsedArg;

typedef struct {
	char *name;
	char *desc;
	char *content;
	char *user_template;
	RList *args;
} ParsedPrompt;

static char *json_text_msg(const char *role, const char *text) {
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_ks (pj, "role", role);
	pj_k (pj, "content");
	pj_a (pj);
	pj_o (pj);
	pj_ks (pj, "type", "text");
	pj_ks (pj, "text", text);
	pj_end (pj);
	pj_end (pj);
	pj_end (pj);
	return pj_drain (pj);
}

static char *expand_template(const char *template, RJson *arguments) {
	RStrBuf *sb = r_strbuf_new ("");
	const char *p = template;
	while (*p) {
		if (*p == '{') {
			if (r_str_startswith (p, "{if ")) {
				p += 4;
				const char *arg_start = p;
				char *end = strchr (p, '}');
				if (end) {
					char *arg = r_str_ndup (arg_start, end - arg_start);
					const char *val = r_json_get_str (arguments, arg);
					p = end + 1;
					const char *if_content = p;
					const char *else_pos = strstr (p, "{else}");
					const char *endif_pos = strstr (p, "{/if}");
					if (R_STR_ISNOTEMPTY (val)) {
						const char *end_content = else_pos? else_pos: endif_pos;
						if (end_content) {
							r_strbuf_append_n (sb, if_content, end_content - if_content);
							p = end_content + (else_pos? 6: 5);
						}
					} else {
						if (else_pos) {
							const char *else_content = else_pos + 6;
							const char *end_content = endif_pos;
							if (end_content) {
								r_strbuf_append_n (sb, else_content, end_content - else_content);
								p = end_content + 5;
							}
						} else {
							if (endif_pos) {
								p = endif_pos + 5;
							}
						}
					}
					free (arg);
				}
			} else {
				char *end = strchr (p, '}');
				if (end) {
					char *arg = r_str_ndup (p + 1, end - p - 1);
					const char *val = r_json_get_str (arguments, arg);
					if (val) {
						r_strbuf_append (sb, val);
					}
					p = end + 1;
					free (arg);
				} else {
					r_strbuf_appendf (sb, "%c", *p);
					p++;
				}
			}
		} else {
			r_strbuf_appendf (sb, "%c", *p);
			p++;
		}
	}
	return r_strbuf_drain (sb);
}

static char *render_loaded(const PromptSpec *spec, RJson *args) {
	ParsedPrompt *pp = (ParsedPrompt *)spec->render_data;
	char *user = NULL;
	if (pp->user_template) {
		user = expand_template (pp->user_template, args);
	}
	char *m1 = json_text_msg ("system", pp->content);
	char *m2 = user? json_text_msg ("user", user): NULL;
	RStrBuf *sb = r_strbuf_new ("{");
	r_strbuf_append (sb, "\"messages\":[");
	if (m1) {
		r_strbuf_append (sb, m1);
	}
	if (m2) {
		const char *comma = m1? ",": "";
		r_strbuf_appendf (sb, "%s%s", comma, m2);
	}
	r_strbuf_append (sb, "]}");
	free (m1);
	free (m2);
	free (user);
	return r_strbuf_drain (sb);
}

static PromptSpec *spec_from_prompt(ParsedPrompt *pp) {
	PromptSpec *spec = R_NEW (PromptSpec);
	spec->name = pp->name;
	spec->description = pp->desc;
	spec->nargs = pp->args? r_list_length (pp->args): 0;
	spec->args = calloc (spec->nargs + 1, sizeof (PromptArg));
	int i = 0;
	RListIter *it;
	ParsedArg *pa;
	r_list_foreach (pp->args, it, pa) {
		spec->args[i].name = pa->name;
		spec->args[i].description = pa->desc;
		spec->args[i].required = pa->req && !strcmp (pa->req, "true");
		i++;
	}
	spec->render = render_loaded;
	spec->render_data = pp;
	return spec;
}

static char *parse_args_block(char *line_ptr, ParsedPrompt *pp) {
	RList *args = r_list_newf (free);
	while (*line_ptr) {
		char *nl = strchr (line_ptr, '\n');
		if (!nl) {
			break;
		}
		*nl = '\0';
		r_str_trim (line_ptr);
		if (line_ptr[0] != '-') {
			pp->args = args;
			return line_ptr;
		}
		char *colon = strchr (line_ptr + 1, ':');
		if (colon) {
			*colon = 0;
			ParsedArg *arg = R_NEW0 (ParsedArg);
			char *key = r_str_trim_dup (line_ptr + 1);
			char *val = r_str_trim_dup (colon + 1);
			if (!strcmp (key, "name")) {
				arg->name = val;
			} else if (!strcmp (key, "description")) {
				arg->desc = val;
			} else if (!strcmp (key, "required")) {
				arg->req = val;
			} else {
				free (val);
			}
			free (key);
			if (arg->name) {
				r_list_append (args, arg);
			} else {
				free (arg);
			}
		}
		line_ptr = nl + 1;
	}
	pp->args = args;
	return line_ptr;
}

static char *parse_frontmatter_field(char *nl, char *line, ParsedPrompt *pp) {
	char *colon = strchr (line, ':');
	if (colon) {
		size_t keylen = colon - line;
		char *val = colon + 1;
		if (keylen == strlen ("description") && r_str_startswith (line, "description")) {
			pp->desc = strdup (val);
		} else if (keylen == strlen ("user_template") && r_str_startswith (line, "user_template")) {
			RStrBuf *sb = r_strbuf_new ("");
			char *p = nl + 1;
			while (*p) {
				char *next_nl = strchr (p, '\n');
				if (next_nl) {
					r_strbuf_append_n (sb, p, next_nl - p);
					r_strbuf_append (sb, "\n");
					p = next_nl + 1;
				} else {
					r_strbuf_append (sb, p);
					p += strlen (p);
				}
			}
			pp->user_template = r_strbuf_drain (sb);
			nl = p - 1;
		}
	}
	return nl + 1;
}

static ParsedPrompt *parse_r2ai_md(const char *path) {
	size_t sz;
	char *data = r_file_slurp (path, &sz);
	if (!data || sz < 4 || !r_str_startswith (data, "---\n")) {
		free (data);
		return NULL;
	}
	char *end = strstr (data + 4, "\n---\n");
	if (!end) {
		free (data);
		return NULL;
	}
	ParsedPrompt *pp = R_NEW0 (ParsedPrompt);
	pp->name = strdup (r_file_basename (path));
	char *dot = strstr (pp->name, ".r2ai.md");
	if (dot) {
		*dot = 0;
	}
	*end = 0;
	pp->content = r_str_trim_dup (end + 5);
	char *p = data + 4;
	while (*p) {
		char *nl = strchr (p, '\n');
		if (!nl) {
			break;
		}
		*nl = '\0';
		r_str_trim (p);
		if (!strcmp (p, "args:")) {
			p = parse_args_block (nl + 1, pp);
		} else {
			p = parse_frontmatter_field (nl, p, pp);
		}
	}
	free (data);
	return pp;
}

typedef struct {
	RList /*<PromptSpec*>*/ *lst;
} PromptRegistry;

void prompts_registry_init(ServerState *ss) {
	if (ss->prompts) {
		return;
	}
	PromptRegistry *reg = R_NEW0 (PromptRegistry);
	reg->lst = r_list_new ();
	if (!reg->lst) {
		free (reg);
		return;
	}
	RList *paths = r_list_newf (free);
	if (ss->prompts_dir) {
		RList *entries = r_str_split_duplist (ss->prompts_dir, ":", true);
		if (entries) {
			RListIter *it;
			char *e;
			r_list_foreach (entries, it, e) {
				char *exp = r_file_home (e);
				if (exp) {
					r_list_append (paths, exp);
				} else {
					r_list_append (paths, strdup (e));
				}
			}
			r_list_free (entries);
		}
	} else {
		r_list_append (paths, strdup ("prompts"));
		r_list_append (paths, r_file_home ("~/.config/r2ai/prompts"));
		r_list_append (paths, r_file_home ("~/.config/r2mcp/prompts"));
	}

	// Iterate through all directories and load prompt files
	char *path;
	RListIter *it;
	r_list_foreach (paths, it, path) {
		RList *files = r_sys_dir (path);
		if (files) {
			RListIter *fit;
			char *file;
			r_list_foreach (files, fit, file) {
				if (*file == '.' || !r_str_endswith (file, ".r2ai.md")) {
					continue;
				}
				char *full_path = r_str_newf ("%s/%s", path, file);
				ParsedPrompt *pp = parse_r2ai_md (full_path);
				if (pp) {
					PromptSpec *spec = spec_from_prompt (pp);
					r_list_append (reg->lst, spec);
				}
				free (full_path);
			}
			r_list_free (files);
		}
	}
	r_list_free (paths);
	ss->prompts = reg;
}

void prompts_registry_fini(ServerState *ss) {
	if (!ss || !ss->prompts) {
		return;
	}
	PromptRegistry *reg = (PromptRegistry *)ss->prompts;
	r_list_free (reg->lst);
	free (reg);
	ss->prompts = NULL;
}

static PromptSpec *prompts_find(const ServerState *ss, const char *nm) {
	if (!ss || !ss->prompts || !nm) {
		return NULL;
	}
	PromptRegistry *reg = (PromptRegistry *)ss->prompts;
	RListIter *it;
	PromptSpec *p;
	r_list_foreach (reg->lst, it, p) {
		if (!strcmp (p->name, nm)) {
			return p;
		}
	}
	return NULL;
}

char *prompts_build_list_json(const ServerState *ss, const char *cursor, int pagesz) {
	PromptRegistry *reg = (ss && ss->prompts)? (PromptRegistry *)ss->prompts: NULL;
	int total = 0;
	int eidx = 0;
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_k (pj, "prompts");
	pj_a (pj);
	if (reg) {
		int idx = 0;
		int total = r_list_length (reg->lst);
		int sidx = 0;
		if (cursor) {
			sidx = atoi (cursor);
			if (sidx < 0) {
				sidx = 0;
			}
		}
		eidx = sidx + pagesz;
		if (eidx > total) {
			eidx = total;
		}
		RListIter *it;
		PromptSpec *p;
		r_list_foreach (reg->lst, it, p) {
			if (idx >= sidx && idx < eidx) {
				pj_o (pj);
				pj_ks (pj, "name", p->name);
				pj_ks (pj, "description", p->description? p->description: "");
				pj_k (pj, "arguments");
				pj_a (pj);
				int i;
				for (i = 0; i < p->nargs; i++) {
					pj_o (pj);
					pj_ks (pj, "name", p->args[i].name);
					pj_ks (pj, "description", p->args[i].description? p->args[i].description: "");
					pj_kb (pj, "required", p->args[i].required);
					pj_end (pj);
				}
				pj_end (pj);
				pj_end (pj);
			}
			idx++;
		}
	}

	pj_end (pj); // end prompts array
	if (eidx < total) {
		char buf[32];
		snprintf (buf, sizeof (buf), "%d", eidx);
		pj_ks (pj, "nextCursor", buf);
	}
	pj_end (pj); // end root object
	return pj_drain (pj);
}

char *prompts_get_json(const ServerState *ss, const char *nm, RJson *args) {
	PromptSpec *spec = prompts_find (ss, nm);
	return spec? spec->render (spec, args): NULL;
}

```

`src/prompts.h`:

```h
#pragma once

#include <stdbool.h>
#include "r2mcp.h"

typedef struct {
	const char *name;
	const char *description;
	bool required;
} PromptArg;

typedef struct PromptSpec {
	const char *name;
	const char *description;
	PromptArg *args;
	int nargs;
	// Render returns a JSON object string with { messages: [...] }
	char *(*render)(const struct PromptSpec *spec, RJson *arguments);
	void *render_data;
} PromptSpec;

// Initialize and shutdown the prompts registry stored in ServerState
void prompts_registry_init(ServerState *ss);
void prompts_registry_fini(ServerState *ss);

// Build list JSON for prompts with optional pagination
char *prompts_build_list_json(const ServerState *ss, const char *cursor, int page_size);

// Resolve a prompt by name and arguments, returning a JSON object string
char *prompts_get_json(const ServerState *ss, const char *name, RJson *arguments);


```

`src/r2api.inc.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake, dnakov */

static void r2state_settings(RCore *core) {
	r_config_set_i (core->config, "scr.color", 0);
	r_config_set_b (core->config, "scr.utf8", false);
	r_config_set_b (core->config, "scr.interactive", false);
	r_config_set_b (core->config, "emu.str", true);
	r_config_set_b (core->config, "asm.bytes", false);
	r_config_set_b (core->config, "anal.strings", true);
	r_config_set_b (core->config, "asm.lines", false);
	r_config_set_b (core->config, "anal.hasnext", true); // TODO: optional
	r_config_set_b (core->config, "asm.lines.fcn", false);
	r_config_set_b (core->config, "asm.cmt.right", false);
	r_config_set_b (core->config, "scr.html", false);
	r_config_set_b (core->config, "scr.prompt", false);
	r_config_set_b (core->config, "scr.echo", false);
	r_config_set_b (core->config, "scr.flush", true);
	r_config_set_b (core->config, "scr.null", false);
	r_config_set_b (core->config, "scr.pipecolor", false);
	r_config_set_b (core->config, "scr.utf8", false);
	r_config_set_i (core->config, "scr.limit", 16768);
}

static bool logcb(void *user, int type, const char *origin, const char *msg) {
	if (type > R_LOG_LEVEL_WARN) {
		return false;
	}
	if (!msg || R_STR_ISEMPTY (origin)) {
		return true;
	}
	ServerState *ss = (ServerState *)user;
	if (ss->sb) {
		const char *typestr = r_log_level_tostring (type);
		// R_LOG_INFO ("[%s] from=%s message=%s\n", typestr, origin, msg);
		fprintf (stderr, "[%s] %s\n", typestr, msg);
		r_strbuf_appendf (ss->sb, "[%s] %s\n", typestr, msg);
		// r_strbuf_appendf (ss->sb, "[%s] from=%s message=%s\n", typestr, origin, msg);
	}
	return true;
}

static void r2mcp_log_reset(ServerState *ss) {
	r_strbuf_free (ss->sb);
	ss->sb = r_strbuf_new ("");
}

static char *r2mcp_log_drain(ServerState *ss) {
	char *s = r_strbuf_drain (ss->sb);
	if (R_STR_ISNOTEMPTY (s)) {
		ss->sb = NULL;
		return s;
	}
	free (s);
	ss->sb = NULL;
	return NULL;
}

static inline void r2mcp_log(ServerState *ss, const char *x) {
	R_LOG_INFO ("[R2MCP] %s", x);
#if R2MCP_DEBUG
	if (ss && ss->logfile && *ss->logfile) {
		r_file_dump (ss->logfile, (const ut8 *) (x), -1, true);
		r_file_dump (ss->logfile, (const ut8 *)"\n", -1, true);
	}
#endif
}

static char *r2_cmd_filter(const char *cmd, bool *changed) {
	char *res = r_str_trim_dup (cmd);
	char fchars[] = "|>`";
	*changed = false;
	if (*res == '!') {
		*changed = true;
		*res = 0;
	} else {
		char *ch = strstr (res, "$ (");
		if (ch) {
			*changed = true;
			*ch = 0;
		}
		for (ch = fchars; *ch; ch++) {
			char *p = strchr (res, *ch);
			if (p) {
				*changed = true;
				*p = 0;
			}
		}
	}
	return res;
}

#include "curl.inc.c"

static char *r2cmd_over_http(ServerState *ss, const char *cmd) {
	int rc = 0;
	char *res = curl_post_capture (ss->baseurl, cmd, &rc);
	if (rc != 0) {
		R_LOG_ERROR ("curl %d", rc);
		free (res);
		return NULL;
	}
	return res;
}

/* printf-like wrapper for r2mcp_cmd to avoid boilerplate */
char *r2mcp_cmdf(ServerState *ss, const char *fmt, ...) {
	if (!fmt) {
		return r2mcp_cmd (ss, "");
	}
	va_list ap;
	va_start (ap, fmt);
	va_list ap2;
	va_copy (ap2, ap);
	int n = vsnprintf (NULL, 0, fmt, ap2);
	va_end (ap2);
	if (n < 0) {
		va_end (ap);
		return NULL;
	}
	char *cmd = (char *)malloc ((size_t)n + 1);
	if (!cmd) {
		va_end (ap);
		return NULL;
	}
	vsnprintf (cmd, (size_t)n + 1, fmt, ap);
	va_end (ap);
	char *res = r2mcp_cmd (ss, cmd);
	free (cmd);
	return res;
}

static bool path_is_absolute(const char *p) {
	return p && p[0] == '/';
}

static bool path_contains_parent_ref(const char *p) {
	return p && strstr (p, "/../") != NULL;
}

static bool path_is_within_sandbox(const char *p, const char *sb) {
	if (!sb || !*sb) {
		return true;
	}
	size_t plen = strlen (p);
	size_t slen = strlen (sb);
	if (slen == 0 || slen > plen) {
		return false;
	}
	if (strncmp (p, sb, slen) != 0) {
		return false;
	}
	if (plen == slen) {
		return true; // exact match
	}
	// ensure boundary: next char must be '/'
	return p[slen] == '/';
}

R_IPI bool r2_open_file(ServerState *ss, const char *filepath) {
	R_LOG_INFO ("Attempting to open file: %s\n", filepath);

	// Security checks common to both local and HTTP modes
	if (R_STR_ISEMPTY (filepath)) {
		R_LOG_ERROR ("Empty file path is not allowed");
		return false;
	}
	bool is_uri = strstr (filepath, "://") != NULL;
	// Filesystem security checks only apply to local paths, not URI schemes
	if (!is_uri) {
		if (!path_is_absolute (filepath)) {
			R_LOG_ERROR ("Relative paths are not allowed. Use an absolute path");
			return false;
		}
		if (path_contains_parent_ref (filepath)) {
			R_LOG_ERROR ("Path traversal is not allowed (contains '/../')");
			return false;
		}
		if (ss->sandbox && *ss->sandbox) {
			if (!path_is_within_sandbox (filepath, ss->sandbox)) {
				R_LOG_ERROR ("Access denied: path is outside of the sandbox");
				return false;
			}
		}
	}

	/* In HTTP mode we do not touch the local r2 core. Just set the state
	 * so subsequent calls to r2mcp_cmd will be allowed (they will be handled
	 * by the HTTP helper).
	 */
	if (ss->http_mode) {
		free (ss->rstate.current_file);
		ss->rstate.current_file = strdup (filepath);
		ss->rstate.file_opened = true;
		return true;
	}

	RCore *core = ss->rstate.core;
	if (!core && !r2mcp_state_init (ss)) {
		R_LOG_ERROR ("Failed to initialize r2 core\n");
		return false;
	}

	if (ss->rstate.file_opened) {
		R_LOG_INFO ("Closing previously opened file: %s", ss->rstate.current_file);
		r_core_cmd0 (core, "o-*");
		ss->rstate.file_opened = false;
		free (ss->rstate.current_file);
		ss->rstate.current_file = NULL;
	}

	bool is_frida = strstr (filepath, "frida://") != NULL;
	if (is_frida) {
		ss->frida_mode = true;
	} else {
		r_core_cmd0 (core, "e bin.relocs.apply=true");
		r_core_cmd0 (core, "e bin.cache=true");
		R_LOG_INFO ("Loading binary information");
		r_core_cmd0 (core, "ob");
	}

	char *cmd = r_str_newf ("'o %s", filepath);
	R_LOG_INFO ("Running r2 command: %s", cmd);
	char *result = r_core_cmd_str (core, cmd);
	free (cmd);
	bool success = (result && strlen (result) > 0);
	free (result);

	if (!success) {
		R_LOG_INFO ("Trying alternative method to open file");
		RIODesc *fd = r_core_file_open (core, filepath, R_PERM_R, 0);
		if (fd) {
			r_core_bin_load (core, filepath, 0);
			R_LOG_INFO ("File opened using r_core_file_open");
			success = true;
		} else {
			R_LOG_ERROR ("Failed to open file: %s", filepath);
			return false;
		}
	}
	free (ss->rstate.current_file);
	ss->rstate.current_file = strdup (filepath);
	ss->rstate.file_opened = true;
	R_LOG_INFO ("File opened successfully: %s", filepath);

	return true;
}

R_IPI char *r2_analyze(ServerState *ss, int level) {
	if (ss && ss->http_mode) {
		/* In HTTP mode we won't run local analysis; return empty string. */
		return strdup ("");
	}
	RCore *core = ss->rstate.core;
	if (!core || !ss->rstate.file_opened) {
		return NULL;
	}
	const char *cmd = "aa";
	if (!ss->ignore_analysis_level) {
		switch (level) {
		case 1: cmd = "aac"; break;
		case 2: cmd = "aaa"; break;
		case 3: cmd = "aaaa"; break;
		case 4: cmd = "aaaaa"; break;
		}
	}
	r2mcp_log_reset (ss);
	r_core_cmd0 (core, cmd);
	return r2mcp_log_drain (ss);
}

```

`src/r2mcp.c`:

```c
/* r2mcp - MIT - Copyright 2025-2026 - pancake, dnakov */

#include <r_core.h>
#include <r_util/r_json.h>
#include <r_util/pj.h>
#include <r_util.h>
#include <r_util/r_print.h>

#include "config.h"
#include "jsonrpc.h"

#if defined(R2__UNIX__)
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#elif defined(R2__WINDOWS__)
#include <windows.h>
#include <io.h>
#include <fcntl.h>
#include <signal.h>
#else
#error please define R2__WINDOWS__ or R2__UNIX__ for platform detection
#endif
#include "r2mcp.h"
#include "tools.h"
#include "prompts.h"

#define R2MCP_DEBUG 1

#ifndef R2MCP_VERSION
#warning R2MCP_VERSION is not defined
#define R2MCP_VERSION "1.5.6"
#endif

#define LATEST_PROTOCOL_VERSION "2025-06-18"
// #define LATEST_PROTOCOL_VERSION "2024-11-05"

#include "utils.inc.c"
#include "r2api.inc.c"

static volatile sig_atomic_t running = 1;
void r2mcp_running_set(int value) {
	running = value? 1: 0;
}

static bool is_valid_json_response(const char *str) {
	if (!str || *str != '{') {
		return false;
	}
	char *copy = strdup (str);
	RJson *json = r_json_parse (copy);
	if (json) {
		free (copy);
		r_json_free (json);
		return true;
	}
	free (copy);
	return false;
}

// Local I/O mode helper (moved from utils.inc.c to avoid unused warnings in other TUs)
static void set_nonblocking_io(bool nonblocking) {
#if defined(R2__UNIX__)
	int flags = fcntl (STDIN_FILENO, F_GETFL, 0);
	if (nonblocking) {
		flags |= O_NONBLOCK;
	} else {
		flags &= ~O_NONBLOCK;
	}
	fcntl (STDIN_FILENO, F_SETFL, flags);
	setvbuf (stdout, NULL, _IOLBF, 0);
#elif defined(R2__WINDOWS__)
	// Windows doesn't support POSIX fcntl/O_NONBLOCK on stdin reliably.
	// We set stdin mode to binary/text depending on requested mode and
	// keep line-buffered stdout. This is a best-effort no-op for nonblocking.
	if (nonblocking) {
		_setmode (_fileno (stdin), _O_BINARY);
	} else {
		_setmode (_fileno (stdin), _O_TEXT);
	}
	setvbuf (stdout, NULL, _IOLBF, 0);
#else
	(void)nonblocking;
#endif
}

/* Public wrappers to expose internal static helpers from r2api.inc.c */
bool r2mcp_state_init(ServerState *ss) {
	RCore *core = r_core_new ();
	if (!core) {
		R_LOG_ERROR ("Failed to initialize radare2 core");
		return false;
	}
	r2state_settings (core);
	ss->rstate.core = core;
	R_LOG_INFO ("Radare2 core initialized");
	r_log_add_callback (logcb, ss);
	return true;
}

void r2mcp_state_fini(ServerState *ss) {
	RCore *core = ss->rstate.core;
	if (core) {
		r_core_free (core);
		r_strbuf_free (ss->sb);
		ss->sb = NULL;
		ss->rstate.core = NULL;
		ss->rstate.file_opened = false;
		ss->rstate.current_file = NULL;
	}
}

char *r2mcp_cmd(ServerState *ss, const char *cmd) {
	if (ss && ss->http_mode) {
		char *res = r2cmd_over_http (ss, cmd);
		if (!res) {
			return strdup ("HTTP request failed");
		}
		return res;
	}
	RCore *core = ss->rstate.core;
	if (!core || !ss->rstate.file_opened) {
		return strdup ("Cannot run commands without calling the `open_file` tool first");
	}
	bool changed = false;
	char *filteredCommand = r2_cmd_filter (cmd, &changed);
	if (changed) {
		r2mcp_log (ss, "command injection prevented");
	}
	r2mcp_log_reset (ss);
	char *res = r_core_cmd_str (core, filteredCommand);
	char *err = r2mcp_log_drain (ss);
	free (filteredCommand);
	// r2state_settings (core);
	if (err) {
		char *newres = r_str_newf ("%s<log>\n%s\n</log>\n", res, err);
		free (res);
		res = newres;
	}
	return res;
}

void r2mcp_log_pub(ServerState *ss, const char *msg) {
	r2mcp_log (ss, msg);
}

typedef bool(*CapCheckFn)(ServerState *, const char *);

typedef struct {
	const char *prefix;
	const char *cap;
	const char *errmsg;
} CapMap;

static const CapMap server_caps[] = {
	{ "sampling/createMessage", "sampling", "Server does not support sampling" },
	{ "prompts/", "prompts", "Server does not support prompts" },
	{ "tools/", "tools", "Server does not support tools" },
	{ "resources/", "resources", "Server does not support resources" },
	{ NULL, NULL, NULL }
};

static const CapMap client_caps[] = {
	{ "sampling/createMessage", "sampling", "Client does not support sampling" },
	{ "roots/list", "roots", "Client does not support listing roots" },
	{ NULL, NULL, NULL }
};

static bool has_client_cap(ServerState *ss, const char *cap) {
	if (ss->client_capabilities) {
		return r_json_get (ss->client_capabilities, cap) != NULL;
	}
	return false;
}

static bool has_server_cap(ServerState *ss, const char *cap) {
	if (!strcmp (cap, "tools")) {
		return ss->capabilities.tools;
	}
	if (!strcmp (cap, "prompts")) {
		return ss->capabilities.prompts;
	}
	if (!strcmp (cap, "resources")) {
		return ss->capabilities.resources;
	}
	return false;
}

static bool check_cap(ServerState *ss, const CapMap *map, CapCheckFn fn, const char *method, char **error) {
	int i;
	for (i = 0; map[i].prefix; i++) {
		if (!strcmp (method, map[i].prefix) || r_str_startswith (method, map[i].prefix)) {
			if (!fn (ss, map[i].cap)) {
				*error = strdup (map[i].errmsg);
				return false;
			}
			return true;
		}
	}
	return true;
}

static bool check_capabilities(ServerState *ss, const char *method, char **error) {
	if (!check_cap (ss, client_caps, has_client_cap, method, error)) {
		return false;
	}
	return check_cap (ss, server_caps, has_server_cap, method, error);
}

// Helper function to create JSON-RPC error responses
// (moved to utils.inc.c earlier, keep this for compatibility if needed)
// static char *jsonrpc_error_response (int code, const char *message, const char *id, const char *uri) { ... }

static char *handle_initialize(ServerState *ss, RJson *params) {
	ss->client_capabilities = r_json_get (params, "capabilities");
	ss->client_info = r_json_get (params, "clientInfo");

	// Create a proper initialize response
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_ks (pj, "protocolVersion", LATEST_PROTOCOL_VERSION);

	pj_k (pj, "serverInfo");
	pj_o (pj);
	pj_ks (pj, "name", ss->info.name);
	pj_ks (pj, "version", ss->info.version);
	pj_end (pj);

	// Capabilities need to be objects with specific structure, not booleans
	pj_k (pj, "capabilities");
	pj_o (pj);

	// Tools capability - needs to be an object
	pj_k (pj, "tools");
	pj_o (pj);
	pj_kb (pj, "listChanged", false);
	pj_end (pj);

	// Prompts capability - object with listChanged
	pj_k (pj, "prompts");
	pj_o (pj);
	pj_kb (pj, "listChanged", false);
	pj_end (pj);

	// Resources capability - empty object since we only support list
	pj_k (pj, "resources");
	pj_o (pj);
	pj_end (pj);

	// For any capability we don't support, don't include it at all
	// Don't add: roots, notifications, sampling

	pj_end (pj); // End capabilities

	if (ss->instructions) {
		pj_ks (pj, "instructions", ss->instructions);
	}

	pj_end (pj);

	// initialization flag is set when notifications/initialized is received
	return pj_drain (pj);
}

static char *handle_list_tools(ServerState *ss, RJson *params) {
	const char *cursor = r_json_get_str (params, "cursor");
	int page_size = 32;
	return tools_build_catalog_json (ss, cursor, page_size);
}

static char *handle_list_prompts(ServerState *ss, RJson *params) {
	const char *cursor = r_json_get_str (params, "cursor");
	int page_size = 32;
	return prompts_build_list_json (ss, cursor, page_size);
}

static char *handle_get_prompt(ServerState *ss, RJson *params) {
	const char *name = r_json_get_str (params, "name");
	if (!name) {
		return jsonrpc_error_response (-32602, "Missing required parameter: name", NULL, NULL);
	}
	RJson *args = (RJson *)r_json_get (params, "arguments");
	char *prompt = prompts_get_json (ss, name, args);
	if (!prompt) {
		return jsonrpc_error_response (-32602, "Unknown prompt name", NULL, NULL);
	}
	return prompt;
}

// Thin wrapper that delegates to the tools module. This keeps r2mcp.c small
// and moves the tool-specific logic into tools.c where it belongs.
static char *handle_call_tool(ServerState *ss, const char *tool_name, RJson *tool_args) {
	return tools_call (ss, tool_name, tool_args);
}

static bool is_valid_mcp_method(const char *method) {
	if (!method || !*method) {
		return false;
	}
	// MCP method names must be lowercase letters with optional '/' or '.' separators
	// Examples: initialize, ping, tools/list, notifications/initialized
	for (int i = 0; method[i]; i++) {
		char c = method[i];
		if (c == '/' || c == '.') {
			continue;
		}
		if (c < 'a' || c > 'z') {
			return false;
		}
	}
	return true;
}

static char *handle_mcp_request(ServerState *ss, const char *method, RJson *params, const char *id) {
	char *error = NULL;
	char *result = NULL;

	// Validate method name format: lowercase, dot-separated
	if (!is_valid_mcp_method (method)) {
		return jsonrpc_error_response (-32601, "Invalid method name: must be lowercase and dot-separated (e.g., tools/list)", id, NULL);
	}

	if (!check_capabilities (ss, method, &error)) {
		char *response = jsonrpc_error_response (-32601, error, id, NULL);
		free (error);
		return response;
	}

	// All requests except 'initialize' require the client to have sent notifications/initialized
	if (strcmp (method, "initialize") && !ss->initialized) {
		return jsonrpc_error_response (-32000, "Client must send notifications/initialized before sending requests", id, NULL);
	}

	if (!strcmp (method, "initialize")) {
		result = handle_initialize (ss, params);
	} else if (!strcmp (method, "notifications/initialized")) {
		ss->initialized = true;
		return NULL; // No response for notifications
	} else if (!strcmp (method, "ping")) {
		result = strdup ("{}");

	} else if (!strcmp (method, "tools/list")) {
		result = handle_list_tools (ss, params);
	} else if (!strcmp (method, "tools/call")) {
		const char *tool_name = r_json_get_str (params, "name");
		if (!tool_name) {
			tool_name = r_json_get_str (params, "tool");
		}
		RJson *tool_args = (RJson *)r_json_get (params, "arguments");
		if (!tool_args) {
			tool_args = (RJson *)r_json_get (params, "args");
		}
		if (ss->svc_baseurl) {
			PJ *pj = pj_new ();
			pj_o (pj);
			pj_ks (pj, "tool", tool_name);
			pj_k (pj, "arguments");
			pj_append_rjson (pj, tool_args);
			pj_k (pj, "available_tools");
			pj_a (pj);
			for (size_t i = 0; tool_specs[i].name; i++) {
				pj_s (pj, tool_specs[i].name);
			}
			pj_end (pj);
			pj_end (pj);
			char *req = pj_drain (pj);
			int rc;
			char *resp = curl_post_capture (ss->svc_baseurl, req, &rc);
			free (req);
			if (resp && rc == 0) {
				RJson *rj = r_json_parse (resp);
				free (resp);
				if (rj) {
					const char *err = r_json_get_str (rj, "error");
					if (err) {
						r_json_free (rj);
						return jsonrpc_error_response (-32000, err, id, NULL);
					}
					const char *r2cmd = r_json_get_str (rj, "r2cmd");
					if (r2cmd) {
						char *cmd_out = r2mcp_cmd (ss, r2cmd);
						char *res = jsonrpc_tooltext_response (cmd_out? cmd_out: "");
						free (cmd_out);
						r_json_free (rj);
						result = res;
					} else {
						const char *new_tool = r_json_get_str (rj, "tool");
						const RJson *new_args = r_json_get (rj, "arguments");
						if (new_tool && strcmp (new_tool, tool_name)) {
							tool_name = new_tool;
						}
						if (new_args) {
							tool_args = (RJson *)new_args;
						}
						result = handle_call_tool (ss, tool_name, tool_args);
						r_json_free (rj);
					}
				} else {
					result = handle_call_tool (ss, tool_name, tool_args);
				}
			} else {
				result = handle_call_tool (ss, tool_name, tool_args);
			}
		} else {
			result = handle_call_tool (ss, tool_name, tool_args);
		}
	} else if (!strcmp (method, "prompts/list")) {
		result = handle_list_prompts (ss, params);
	} else if (!strcmp (method, "prompts/get")) {
		result = handle_get_prompt (ss, params);
	} else if (!strcmp (method, "resources/list")) {
		result = strdup ("{\"resources\":[]}");
	} else if (!strcmp (method, "resources/templates/list")) {
		result = strdup ("{\"resourceTemplates\":[]}");
	} else {
		return jsonrpc_error_response (-32601, "Unknown method", id, NULL);
	}

	char *response = jsonrpc_success_response (ss, result, id);
	free (result);
	return response;
}

// Send a JSON-RPC response to stdout with proper framing
static void send_response(ServerState *ss, const char *response) {
	if (!response) {
		return;
	}

	// Validate response is valid JSON before writing to stdout
	if (!is_valid_json_response (response)) {
		R_LOG_ERROR ("send_response: response is not valid JSON - dropping output");
		return;
	}

	r2mcp_log (ss, ">>>");
	r2mcp_log (ss, response);
	size_t len = strlen (response);
	const bool needsnewline = len == 0 || response[len - 1] != '\n';

	// Write response with proper error handling and partial write support
	const char *ptr = response;
	size_t remaining = len;
	while (remaining > 0) {
		ssize_t written = write (STDOUT_FILENO, ptr, remaining);
		if (written <= 0) {
			if (written == 0) {
				// write () returned 0 - this is an error condition (e.g., invalid fd or pipe broken)
				R_LOG_ERROR ("send_response: write returned 0 to stdout");
				return;
			}
			if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
				continue; // Retry on interrupt or temporary unavailable
			}
			R_LOG_ERROR ("send_response: write error to stdout: %s", strerror (errno));
			return;
		}
		ptr += written;
		remaining -= written;
	}

	if (needsnewline) {
		const char nl = '\n';
		if (write (STDOUT_FILENO, &nl, 1) < 0) {
			R_LOG_ERROR ("send_response: write newline error: %s", strerror (errno));
		}
	}

#if R2__UNIX__
	fsync (STDOUT_FILENO);
#elif R2__WINDOWS__
	FlushFileBuffers (GetStdHandle (STD_OUTPUT_HANDLE));
#endif
}

// Process a JSON-RPC message from the client
static void process_mcp_message(ServerState *ss, const char *msg) {
	r2mcp_log (ss, "<<<");
	r2mcp_log (ss, msg);

	RJson *request = r_json_parse ((char *)msg);
	if (!request) {
		R_LOG_ERROR ("process_mcp_message: received invalid JSON from client");
		char *err = jsonrpc_error_response (-32700, "Parse error: invalid JSON", NULL, NULL);
		send_response (ss, err);
		free (err);
		return;
	}

	RJson *id_json = (RJson *)r_json_get (request, "id");
	const char *method = r_json_get_str (request, "method");
	RJson *params = (RJson *)r_json_get (request, "params");

	// Extract id for error responses (may be NULL for notifications)
	const char *id = NULL;
	char id_buf[32] = { 0 };
	bool has_id = false;
	if (id_json) {
		if (id_json->type == R_JSON_STRING) {
			id = id_json->str_value;
			has_id = true;
		} else if (id_json->type == R_JSON_INTEGER) {
			snprintf (id_buf, sizeof (id_buf), "%lld", (long long)id_json->num.u_value);
			id = id_buf;
			has_id = true;
		}
		// Note: R_JSON_NULL means id is explicitly null, which is a notification per JSON-RPC 2.0
	}

	if (!method) {
		// Per JSON-RPC 2.0, missing method is an invalid request
		char *err = jsonrpc_error_response (-32600, "Invalid Request: missing method", id, NULL);
		send_response (ss, err);
		free (err);
		r_json_free (request);
		return;
	}

	if (has_id) {
		// Request: requires a response (has a non-null id)
		char *response = handle_mcp_request (ss, method, params, id);
		if (response) {
			send_response (ss, response);
			free (response);
		}
	} else {
		// Notification: no response (no id or id is null)
		if (!strcmp (method, "notifications/cancelled")) {
			r2mcp_log (ss, "Received cancelled notification");
		} else if (!strcmp (method, "notifications/initialized")) {
			r2mcp_log (ss, "Received initialized notification");
			ss->initialized = true;
		} else {
			r2mcp_log (ss, "Received unknown notification");
		}
	}

	r_json_free (request);
}

// MCPO protocol-compliant direct mode loop
void r2mcp_eventloop(ServerState *ss) {
	r2mcp_log (ss, "Starting MCP direct mode (stdin/stdout)");

	// Use consistent unbuffered mode for stdout
	setvbuf (stdout, NULL, _IONBF, 0);

	// Set to blocking I/O for simplicity
	set_nonblocking_io (false);

	ReadBuffer *buffer = read_buffer_new ();
	const size_t chunk_size = 32768;
	char *chunk = malloc (chunk_size);

	while (running) {
		// Read data from stdin
		ssize_t bytes_read = read (STDIN_FILENO, chunk, chunk_size);

		if (bytes_read > 0) {
			// Append to our buffer
			read_buffer_append (buffer, chunk, bytes_read);

			// Try to process any complete messages
			char *msg;
			while ((msg = read_buffer_get_message (buffer)) != NULL) {
				r2mcp_log (ss, "Complete message received:");
				r2mcp_log (ss, msg);
				process_mcp_message (ss, msg);
				free (msg);
			}
		} else if (bytes_read == 0) {
			// EOF - stdin closed
			r2mcp_log (ss, "End of input stream - exiting");
			break;
		} else if (errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR) {
			r2mcp_log (ss, "Read error");
			break;
		}
	}

	free (chunk);
	read_buffer_free (buffer);
	r2mcp_log (ss, "Direct mode loop terminated");
}

```

`src/r2mcp.h`:

```h
#pragma once
#include <stdbool.h>
#include <r_core.h>
#include <r_util/r_json.h>
#include <r_util/r_strbuf.h>
#include "readbuffer.h"

/* Version fallback if not provided by build */
#ifndef R2MCP_VERSION
#define R2MCP_VERSION "1.5.6"
#endif

/* Pagination limits for tool responses */
#define R2MCP_DEFAULT_PAGE_SIZE 1000
#define R2MCP_MAX_PAGE_SIZE 10000

typedef struct {
	const char *name;
	const char *version;
} ServerInfo;

typedef struct {
	bool tools;
	bool prompts;
	bool resources;
} ServerCapabilities;

typedef struct {
	RCore *core;
	bool file_opened;
	char *current_file;
} RadareState;

typedef struct {
	ServerInfo info;
	ServerCapabilities capabilities;
	const char *instructions;
	bool initialized;
	bool minimode;
	bool permissive_tools; // allow calling tools not exposed for current mode
	bool enable_run_command_tool;
	/* When true, enable session management tools (list/open/close sessions) */
	bool use_sessions;
	/* When true operate in read-only mode: only expose non-mutating tools */
	bool readonly_mode;
	/* When true, operate in HTTP r2pipe client mode and do NOT use r2 C APIs */
	bool http_mode;
	/* Base URL of the remote r2 webserver (if http_mode is true) */
	char *baseurl;
	/* Base URL of the supervisor control service (if set) */
	char *svc_baseurl;
	/* Optional sandbox path. When set, only allow opening files under this dir */
	char *sandbox;
	/* Optional path to append debug logs when set via -l */
	char *logfile;
	/* Optional custom prompts directory path */
	char *prompts_dir;
	/* When true, load prompts (false when -N flag is used) */
	bool load_prompts;
	/* When true, ignore the analysis level specified in analyze calls */
	bool ignore_analysis_level;
	/* When true, operate in Frida mode */
	bool frida_mode;
	const RJson *client_capabilities;
	const RJson *client_info;
	RadareState rstate;
	RStrBuf *sb;
	/* Optional whitelist of tool names enabled via command line -e options.
	 * When non-NULL, only tools whose name appears in this list will be
	 * registered in the runtime tools registry. Items are heap-allocated
	 * strings and the list should be created with `r_list_newf(free)`.
	 */
	RList *enabled_tools;
	/* Optional blacklist of tool names disabled via command line -D options.
	 * Tools in this list will be excluded from the available tools regardless
	 * of other settings. Items are heap-allocated strings and the list should
	 * be created with `r_list_newf(free)`.
	 */
	RList *disabled_tools;
	void *prompts; // registry of PromptSpec* (RList*), opaque here
} ServerState;

/* Entry point wrapper implemented in r2mcp.c */
int r2mcp_main(int argc, const char **argv);

/* Exposed helpers implemented in r2mcp.c */
void setup_signals(void);
void r2mcp_eventloop(ServerState *ss);
void r2mcp_help(void);
void r2mcp_version(void);
void r2mcp_running_set(int value);

/* Public wrappers for internal r2 helpers (implemented in r2mcp.c) */
bool r2mcp_state_init(ServerState *ss);
void r2mcp_state_fini(ServerState *ss);
char *r2mcp_cmd(ServerState *ss, const char *cmd);
char *r2mcp_cmdf(ServerState *ss, const char *fmt, ...);
void r2mcp_log_pub(ServerState *ss, const char *msg);

// Additional public wrappers exposed so other modules (eg. tools.c) can use
// functionality implemented in r2api.inc.c. These simply forward to the
// internal static helpers so we keep the original separation.
bool r2_open_file(ServerState *ss, const char *filepath);
char *r2_analyze(ServerState *ss, int level);

// Run a small domain-specific language (DSL) used for testing tools from the
// command-line. The DSL describes a sequence of tool calls with arguments and
// prints their results. If core is provided, output goes to r2 console, else stdout.
// Returns 0 on success, non-zero on failure.
int r2mcp_run_dsl_tests(ServerState *ss, const char *dsl, RCore *core);

// HTTP POST helper for svc communication
char *curl_post_capture(const char *url, const char *msg, int *exit_code_out);

```

`src/readbuffer.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake, dnakov */

#include <r_types.h>
#include <r_util.h>
#include "readbuffer.h"

ReadBuffer *read_buffer_new(void) {
	ReadBuffer *buf = R_NEW (ReadBuffer);
	buf->data = malloc (BUFFER_SIZE);
	buf->size = 0;
	buf->capacity = BUFFER_SIZE;
	return buf;
}

void read_buffer_free(ReadBuffer *buf) {
	if (buf) {
		free (buf->data);
		free (buf);
	}
}

void read_buffer_append(ReadBuffer *buf, const char *data, size_t len) {
	if (buf->size + len > buf->capacity) {
		size_t new_capacity = buf->capacity * 2;
		if (new_capacity < buf->size + len) {
			new_capacity = buf->size + len;
		}
		char *new_data = realloc (buf->data, new_capacity);
		if (!new_data) {
			R_LOG_ERROR ("Failed to resize buffer");
			return;
		}
		buf->data = new_data;
		buf->capacity = new_capacity;
	}
	memcpy (buf->data + buf->size, data, len);
	buf->size += len;
}

// Extract a complete JSON message from the buffer, respecting string quoting.
// Returns a heap-allocated message string or NULL if no complete message is available.
char *read_buffer_get_message(ReadBuffer *buf) {
	if (buf->size == 0) {
		return NULL;
	}

	// Ensure the buffer is null-terminated for safety
	if (buf->capacity <= buf->size + 1) {
		buf->capacity = buf->size + 2;
		char *new_data = realloc (buf->data, buf->capacity);
		if (!new_data) {
			return NULL;
		}
		buf->data = new_data;
	}
	buf->data[buf->size] = '\0';

	int brace_count = 0;
	int start_pos = -1;
	bool in_string = false;
	bool escape_next = false;
	size_t i;

	for (i = 0; i < buf->size; i++) {
		const char c = buf->data[i];

		// Handle escape sequences inside strings
		if (escape_next) {
			escape_next = false;
			continue;
		}

		if (in_string) {
			if (c == '\\') {
				escape_next = true;
			} else if (c == '"') {
				in_string = false;
			}
			continue;
		}

		// Outside of a string
		if (c == '"') {
			in_string = true;
			continue;
		}

		if (start_pos == -1) {
			if (c == '{') {
				start_pos = i;
				brace_count = 1;
			}
			continue;
		}

		if (c == '{') {
			brace_count++;
		} else if (c == '}') {
			brace_count--;
			if (brace_count == 0) {
				// Complete message from start_pos to i (inclusive)
				size_t msg_len = i - start_pos + 1;
				char *msg = malloc (msg_len + 1);
				memcpy (msg, buf->data + start_pos, msg_len);
				msg[msg_len] = '\0';

				// Shift remaining data to the front
				size_t remaining = buf->size - (i + 1);
				if (remaining > 0) {
					memmove (buf->data, buf->data + i + 1, remaining);
				}
				buf->size = remaining;
				return msg;
			}
		}
	}

	return NULL;
}

```

`src/readbuffer.h`:

```h
#ifndef R2MCP_READBUFFER_H
#define R2MCP_READBUFFER_H 1

#include <string.h>
#include <stdlib.h>

#define BUFFER_SIZE 65536
typedef struct {
	char *data;
	size_t size;
	size_t capacity;
} ReadBuffer;

ReadBuffer *read_buffer_new(void);
void read_buffer_free(ReadBuffer *buf);
void read_buffer_append(ReadBuffer *buf, const char *data, size_t len);
char *read_buffer_get_message(ReadBuffer *buf);

#endif

```

`src/tools.c`:

```c
/* r2mcp - MIT - Copyright 2025-2026 - pancake */

#include <r_core.h>
#include "r2mcp.h"
#include "tools.h"
#include "validation.h"
#include "utils.inc.c"
#include "jsonrpc.h"

typedef char *(*ToolFunc)(ServerState *ss, RJson *tool_args);

typedef struct {
	const char *name;
	ToolFunc func;
} ToolEntry;

extern ToolSpec tool_specs[];

// Parameter validation helpers
static inline bool validate_required_string_param(RJson *args, const char *param_name, const char **out_value) {
	const char *value = r_json_get_str (args, param_name);
	if (value) {
		*out_value = value;
		return true;
	}
	return false;
}

static bool validate_address_param(RJson *args, const char *param_name, const char **out_address) {
	return validate_required_string_param (args, param_name, out_address);
}

// Helper to wrap command result in JSON response and free the result
static char *tool_cmd_response(char *res) {
	char *response = jsonrpc_tooltext_response (res);
	free (res);
	return response;
}

// Check an optional whitelist of enabled tool names. If ss->enabled_tools is
// NULL, all tools are considered allowed. Otherwise only names present in the
// list are allowed.
static bool tool_allowed_by_whitelist(const ServerState *ss, const char *name) {
	if (!ss || !ss->enabled_tools) {
		return true;
	}
	RListIter *it;
	const char *s;
	r_list_foreach (ss->enabled_tools, it, s) {
		if (!strcmp (s, name)) {
			return true;
		}
	}
	return false;
}

// Check if a tool is disabled via blacklist. If ss->disabled_tools is NULL,
// no tools are disabled. If the tool name is in the blacklist, return false.
static bool tool_not_disabled(const ServerState *ss, const char *name) {
	if (!ss || !ss->disabled_tools) {
		return true;
	}
	RListIter *it;
	const char *s;
	r_list_foreach (ss->disabled_tools, it, s) {
		if (!strcmp (s, name)) {
			return false;
		}
	}
	return true;
}

static inline ToolMode current_mode(const ServerState *ss) {
	ToolMode mode = 0;
	if (ss->http_mode) {
		mode |= TOOL_MODE_HTTP;
	}
	if (ss->frida_mode) {
		mode |= TOOL_MODE_FRIDA;
	}
	if (ss->use_sessions) {
		mode |= TOOL_MODE_SESSIONS;
	}
	if (ss->readonly_mode) {
		mode |= TOOL_MODE_RO;
	}
	if (ss->minimode) {
		mode |= TOOL_MODE_MINI;
	}
	if (mode == 0) {
		mode = TOOL_MODE_NORMAL;
	}
	return mode;
}

static bool tool_matches_mode(const ToolSpec *t, ToolMode mode) {
	return (t->modes & mode) != 0;
}

static RList *tools_filtered_for_mode(const ServerState *ss) {
	ToolMode mode = current_mode (ss);
	RList *out = r_list_new ();
	if (!out) {
		return NULL;
	}
	for (size_t i = 0; tool_specs[i].name; i++) {
		ToolSpec *t = &tool_specs[i];
		if (tool_matches_mode (t, mode) && tool_allowed_by_whitelist (ss, t->name) && tool_not_disabled (ss, t->name)) {
			r_list_append (out, t); // reference only
		}
	}
	return out;
}

bool tools_is_tool_allowed(const ServerState *ss, const char *name) {
	if (ss->permissive_tools) {
		return true;
	}
	if (!name) {
		return false;
	}
	if (!tool_not_disabled (ss, name)) {
		return false;
	}
	ToolMode mode = current_mode (ss);
	for (size_t i = 0; tool_specs[i].name; i++) {
		ToolSpec *t = &tool_specs[i];
		if (!strcmp (t->name, name)) {
			if (!tool_allowed_by_whitelist (ss, name)) {
				return false;
			}
			return tool_matches_mode (t, mode);
		}
	}
	return false;
}

char *tools_build_catalog_json(const ServerState *ss, const char *cursor, int page_size) {
	int start_index = 0;
	if (cursor) {
		start_index = atoi (cursor);
		if (start_index < 0) {
			start_index = 0;
		}
	}

	RList *list = tools_filtered_for_mode (ss);
	if (!list) {
		return strdup ("{\"tools\":[]}");
	}
	int total_tools = r_list_length (list);
	int end_index = start_index + page_size;
	if (end_index > total_tools) {
		end_index = total_tools;
	}

	RStrBuf *sb = r_strbuf_new ("");
	r_strbuf_append (sb, "{\"tools\":[");

	int idx = 0;
	int out_count = 0;
	RListIter *it;
	ToolSpec *t;
	r_list_foreach (list, it, t) {
		if (idx >= start_index && idx < end_index) {
			if (out_count > 0) {
				r_strbuf_append (sb, ",");
			}
			r_strbuf_appendf (sb,
				"{\"name\":\"%s\",\"description\":\"%s\",\"inputSchema\":%s}",
				t->name,
				t->description,
				t->schema_json);
			out_count++;
		}
		idx++;
		if (idx >= end_index) {
			// keep looping for correctness of idx but we could break
		}
	}

	r_strbuf_append (sb, "]");
	if (end_index < total_tools) {
		r_strbuf_appendf (sb, ",\"nextCursor\":\"%d\"", end_index);
	}
	r_strbuf_append (sb, "}");

	r_list_free (list);
	return r_strbuf_drain (sb);
}

void tools_print_table(const ServerState *ss) {
	RTable *table = r_table_new ("tools");
	if (!table) {
		R_LOG_ERROR ("Failed to allocate table");
		return;
	}

	RTableColumnType *s = r_table_type ("string");
	if (!s) {
		R_LOG_WARN ("Table string type unavailable");
		r_table_free (table);
		return;
	}

	r_table_add_column (table, s, "name", 0);
	r_table_add_column (table, s, "modes", 0);
	r_table_add_column (table, s, "description", 0);

	for (size_t i = 0; tool_specs[i].name; i++) {
		ToolSpec *t = &tool_specs[i];
		if (!tool_allowed_by_whitelist (ss, t->name) || !tool_not_disabled (ss, t->name)) {
			continue;
		}
		char modes_buf[8];
		int p = 0;
		if (t->modes & TOOL_MODE_MINI) {
			modes_buf[p++] = 'M';
		}
		if (t->modes & TOOL_MODE_HTTP) {
			modes_buf[p++] = 'H';
		}
		if (t->modes & TOOL_MODE_FRIDA) {
			modes_buf[p++] = 'F';
		}
		if (t->modes & TOOL_MODE_RO) {
			modes_buf[p++] = 'R';
		}
		if (t->modes & TOOL_MODE_SESSIONS) {
			modes_buf[p++] = 'S';
		}
		if (t->modes & TOOL_MODE_NORMAL) {
			modes_buf[p++] = 'N';
		}
		modes_buf[p] = '\0';
		const char *desc = t->description? t->description: "";
		r_table_add_rowf (table, "sss", t->name, modes_buf, desc);
	}

	char *table_str = r_table_tostring (table);
	if (table_str) {
		printf ("%s\n", table_str);
		free (table_str);
	}
	r_table_free (table);
}

// Filter lines in `input` by `pattern` regex. Returns a newly allocated string.
static char *filter_lines_by_regex(const char *input, const char *pattern) {
	const char *src = input? input: "";
	if (!pattern || !*pattern) {
		return strdup (src);
	}
	RStrBuf *sb = r_strbuf_new ("");
	RRegex rx;
	int re_flags = r_regex_flags ("e");
	if (r_regex_init (&rx, pattern, re_flags) != 0) {
		r_strbuf_appendf (sb, "Invalid regex used in filter parameter, try a simpler expression");
		return r_strbuf_drain (sb);
	}
	const char *line_begin = src;
	const char *p = src;
	size_t line_buf_size = 0;
	char *line = NULL;
	for (;;) {
		if (*p == '\n' || *p == '\0') {
			size_t len = (size_t) (p - line_begin);
			if (len + 1 > line_buf_size) {
				size_t new_size = len + 1;
				line = realloc (line, new_size);
				if (!line) {
					break;
				}
				line_buf_size = new_size;
			}
			memcpy (line, line_begin, len);
			line[len] = '\0';
			if (r_regex_exec (&rx, line, 0, 0, 0) == 0) {
				r_strbuf_appendf (sb, "%s\n", line);
			}
			if (*p == '\0') {
				break;
			}
			p++;
			line_begin = p;
			continue;
		}
		p++;
	}
	free (line);
	r_regex_fini (&rx);
	return r_strbuf_drain (sb);
}

static char *filter_named_functions_only(const char *input) {
	const char *src = input? input: "";
	RStrBuf *sb = r_strbuf_new ("");
	const char *line_begin = src;
	const char *p = src;
	size_t line_buf_size = 0;
	char *line = NULL;
	for (;;) {
		if (*p == '\n' || *p == '\0') {
			size_t len = (size_t) (p - line_begin);
			if (len + 1 > line_buf_size) {
				size_t new_size = len + 1;
				line = realloc (line, new_size);
				if (!line) {
					break;
				}
				line_buf_size = new_size;
			}
			memcpy (line, line_begin, len);
			line[len] = '\0';
			bool is_named = true;
			const char *last_dot = r_str_lchr (line, '.');
			if (last_dot && last_dot[1]) {
				if (isdigit (last_dot[1])) {
					is_named = false;
				}
			}
			if (is_named) {
				r_strbuf_appendf (sb, "%s\n", line);
			}
			if (*p == '\0') {
				break;
			}
			p++;
			line_begin = p;
			continue;
		}
		p++;
	}
	free (line);
	return r_strbuf_drain (sb);
}

static char *tool_close_file(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	if (ss->http_mode) {
		return jsonrpc_tooltext_response ("In r2pipe mode we won't close the file.");
	}
	if (ss->rstate.core) {
		free (r2mcp_cmd (ss, "o-*"));
		ss->rstate.file_opened = false;
		ss->frida_mode = false;
		free (ss->rstate.current_file);
		ss->rstate.current_file = NULL;
	}
	return jsonrpc_tooltext_response ("File closed successfully.");
}

static char *tool_list_functions(ServerState *ss, RJson *tool_args) {
	const RJson *only_named_parameter = r_json_get (tool_args, "only_named");
	bool only_named = false;
	if (only_named_parameter) {
		if (only_named_parameter->type == R_JSON_BOOLEAN) {
			only_named = only_named_parameter->num.u_value;
		}
	}

	// Acquire additional parameters `start` and `max_length`.
	int start = 0;
	int max_length = 50;
	const RJson *start_json = r_json_get (tool_args, "start");
	if (start_json && start_json->type == R_JSON_INTEGER) {
		start = (int)start_json->num.u_value;
	}
	const RJson *max_length_json = r_json_get (tool_args, "max_length");
	if (max_length_json && max_length_json->type == R_JSON_INTEGER) {
		max_length = (int)max_length_json->num.s_value;
	}
	
	const char *filter = r_json_get_str (tool_args, "filter");
	char *res;
	if (ss->frida_mode) {
		return jsonrpc_tooltext_response ("In Frida mode we won't list functions. List exports or classes instead.");
	} else {
		res = r2mcp_cmd (ss, "afl,addr/cols/name");
		r_str_trim (res);
		if (R_STR_ISEMPTY (res)) {
			free (res);
			free (r2mcp_cmd (ss, "aaa"));
			res = r2mcp_cmd (ss, "afl,addr/cols/name");
			r_str_trim (res);
			if (R_STR_ISEMPTY (res)) {
				free (res);
				res = strdup ("No functions found. Run the analysis first.");
			}
		}
	}
	// Apply filtering if only_named is true
	if (only_named && R_STR_ISNOTEMPTY (res)) {
		char *filtered = filter_named_functions_only (res);
		if (filtered) {
			free (res);
			res = filtered;
		}
	}
	// Apply regex filter if provided
	if (R_STR_ISNOTEMPTY (filter) && R_STR_ISNOTEMPTY (res)) {
		char *r = filter_lines_by_regex (res, filter);
		free (res);
		res = r;
	}
	// Apply pagination, offset by 2 to skip the header lines
	int total_lines = r_str_char_count (res, '\n') - 2;
	int page_size = (max_length < 0) ? total_lines : max_length;
	char cursor_buf[32];
	snprintf (cursor_buf, sizeof (cursor_buf), "%d", start + 2);
	char *next_cursor = NULL;
	bool has_more = false;
	char *paginated = paginate_text_by_lines (res, cursor_buf, page_size, &has_more, &next_cursor);
	free (res);
	free (next_cursor);
	return tool_cmd_response (paginated);
}

static char *tool_list_files(ServerState *ss, RJson *tool_args) {
	const char *path;
	if (!validate_required_string_param (tool_args, "path", &path)) {
		return jsonrpc_error_missing_param ("path");
	}

	// Security checks
	if (!path || path[0] != '/') {
		return jsonrpc_error_response (-32603, "Relative paths are not allowed. Use an absolute path", NULL, NULL);
	}
	if (strstr (path, "/../") != NULL) {
		return jsonrpc_error_response (-32603, "Path traversal is not allowed (contains '/../')", NULL, NULL);
	}
	if (ss->sandbox && *ss->sandbox) {
		size_t plen = strlen (path);
		size_t slen = strlen (ss->sandbox);
		if (slen == 0 || slen > plen || strncmp (path, ss->sandbox, slen) != 0 ||
			(plen > slen && path[slen] != '/')) {
			return jsonrpc_error_response (-32603, "Access denied: path is outside of the sandbox", NULL, NULL);
		}
	}

	char *cmd = r_str_newf ("ls -q %s", path);
	char *res = r2mcp_cmd (ss, cmd);
	free (cmd);
	return tool_cmd_response (res);
}

static char *tool_list_classes(ServerState *ss, RJson *tool_args) {
	const char *filter = r_json_get_str (tool_args, "filter");
	char *res;
	if (ss->frida_mode) {
		res = r2mcp_cmd (ss, ":ic");
	} else {
		res = r2mcp_cmd (ss, "icqq");
	}

	if (R_STR_ISNOTEMPTY (filter)) {

		char *r = filter_lines_by_regex (res, filter);

		free (res);

		res = r;
	}

	return tool_cmd_response (res);
}

static char *tool_list_methods(ServerState *ss, RJson *tool_args) {
	const char *classname;
	if (!validate_required_string_param (tool_args, "classname", &classname)) {
		return jsonrpc_error_missing_param ("classname");
	}
	if (ss->frida_mode) {
		return tool_cmd_response (r2mcp_cmdf (ss, ":ic %s", classname));
	}
	return tool_cmd_response (r2mcp_cmdf (ss, "'ic %s", classname));
}

static char *tool_list_decompilers(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	return tool_cmd_response (r2mcp_cmd (ss, "e cmd.pdc=?"));
}

static char *tool_list_functions_tree(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	char *res = r2mcp_cmd (ss, "aflmu");

	r_str_trim (res);

	return tool_cmd_response (res);
}

static char *tool_list_imports(ServerState *ss, RJson *tool_args) {
	const char *filter = r_json_get_str (tool_args, "filter");
	char *res;
	if (ss->frida_mode) {
		res = r2mcp_cmd (ss, ":ii");
	} else {
		res = r2mcp_cmd (ss, "iiq");
	}

	if (R_STR_ISNOTEMPTY (filter)) {

		char *r = filter_lines_by_regex (res, filter);

		free (res);

		res = r;
	}

	return tool_cmd_response (res);
}

static char *tool_list_exports(ServerState *ss, RJson *tool_args) {
	const char *filter = r_json_get_str (tool_args, "filter");
	char *res;
	if (ss->frida_mode) {
		res = r2mcp_cmd (ss, ":iE");
	} else {
		res = r2mcp_cmd (ss, "iEq");
	}

	if (R_STR_ISNOTEMPTY (filter)) {

		char *r = filter_lines_by_regex (res, filter);

		free (res);

		res = r;
	}

	return tool_cmd_response (res);
}

static char *tool_list_sections(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	if (ss->frida_mode) {
		return tool_cmd_response (r2mcp_cmd (ss, ":iS"));
	}
	return tool_cmd_response (r2mcp_cmd (ss, "iS;iSS"));
}

static char *tool_list_memory_maps(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	if (ss->frida_mode) {
		return tool_cmd_response (r2mcp_cmd (ss, ":dm"));
	}
	return tool_cmd_response (r2mcp_cmd (ss, "dm"));
}

static char *tool_show_headers(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	if (ss->frida_mode) {
		return tool_cmd_response (r2mcp_cmd (ss, ":i"));
	}
	return tool_cmd_response (r2mcp_cmd (ss, "i;iH"));
}

static char *tool_show_function_details(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	return tool_cmd_response (r2mcp_cmd (ss, "afi"));
}

static char *tool_get_current_address(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	return tool_cmd_response (r2mcp_cmd (ss, "s;fd"));
}

static char *tool_list_symbols(ServerState *ss, RJson *tool_args) {
	const char *filter = r_json_get_str (tool_args, "filter");
	char *res;
	if (ss->frida_mode) {
		res = r2mcp_cmd (ss, ":is");
	} else {
		res = r2mcp_cmd (ss, "isq~!func.,!imp.");
	}

	if (R_STR_ISNOTEMPTY (filter)) {
		char *r = filter_lines_by_regex (res, filter);
		free (res);
		res = r;
	}

	return tool_cmd_response (res);
}

static char *tool_list_entrypoints(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	char *res;
	if (ss->frida_mode) {
		res = r2mcp_cmd (ss, ":ie");
	} else {
		res = r2mcp_cmd (ss, "ies");
	}
	char *o = jsonrpc_tooltext_response_lines (res);
	free (res);
	return o;
}

static char *tool_list_libraries(ServerState *ss, RJson *tool_args) {
	(void)tool_args;
	if (ss->frida_mode) {
		return tool_cmd_response (r2mcp_cmd (ss, ":il"));
	}
	return tool_cmd_response (r2mcp_cmd (ss, "ilq"));
}

static char *tool_calculate(ServerState *ss, RJson *tool_args) {
	const char *expression;
	if (!validate_required_string_param (tool_args, "expression", &expression)) {
		return jsonrpc_error_missing_param ("expression");
	}
	if (!ss->rstate.core || !ss->rstate.core->num) {
		return jsonrpc_error_response (-32611, "Core or number parser unavailable (open a file first)", NULL, NULL);
	}
	RCore *core = ss->rstate.core;
	ut64 calc_result = r_num_math (core->num, expression);
	char *numstr = r_str_newf ("0x%" PFMT64x, (ut64)calc_result);
	char *resp = jsonrpc_tooltext_response (numstr);
	free (numstr);
	return resp;
}

static char *tool_set_comment(ServerState *ss, RJson *tool_args) {
	const char *address, *message;
	if (!validate_address_param (tool_args, "address", &address) ||
		!validate_required_string_param (tool_args, "message", &message)) {
		return jsonrpc_error_missing_param ("address and message");
	}

	char *cmd_cc = r_str_newf ("'@%s'CC %s", address, message);
	char *tmpres_cc = r2mcp_cmd (ss, cmd_cc);
	free (tmpres_cc);
	free (cmd_cc);
	return strdup ("ok");
}

static char *tool_set_function_prototype(ServerState *ss, RJson *tool_args) {
	const char *address, *prototype;
	if (!validate_address_param (tool_args, "address", &address) ||
		!validate_required_string_param (tool_args, "prototype", &prototype)) {
		return jsonrpc_error_missing_param ("address and prototype");
	}
	char *cmd_afs = r_str_newf ("'@%s'afs %s", address, prototype);
	char *tmpres_afs = r2mcp_cmd (ss, cmd_afs);
	free (tmpres_afs);
	free (cmd_afs);
	return strdup ("ok");
}

static char *tool_get_function_prototype(ServerState *ss, RJson *tool_args) {
	const char *address;
	if (!validate_address_param (tool_args, "address", &address)) {
		return jsonrpc_error_missing_param ("address");
	}
	char *s = r_str_newf ("'@%s'afs", address);
	char *res = r2mcp_cmd (ss, s);
	free (s);
	return res;
}

static char *tool_list_strings(ServerState *ss, RJson *tool_args) {
	const char *filter = r_json_get_str (tool_args, "filter");
	const char *cursor = r_json_get_str (tool_args, "cursor");
	int page_size = (int)r_json_get_num (tool_args, "page_size");
	if (page_size <= 0) {
		page_size = R2MCP_DEFAULT_PAGE_SIZE;
	}
	if (page_size > R2MCP_MAX_PAGE_SIZE) {
		page_size = R2MCP_MAX_PAGE_SIZE;
	}

	char *cmd_result;
	if (ss->frida_mode) {
		cmd_result = r2mcp_cmd (ss, ":iz");
	} else {
		cmd_result = r2mcp_cmd (ss, "izqq");
	}
	if (R_STR_ISNOTEMPTY (filter)) {
		char *r = filter_lines_by_regex (cmd_result, filter);
		free (cmd_result);
		cmd_result = r;
	}
	bool has_more = false;
	char *next_cursor = NULL;
	char *paginated = paginate_text_by_lines (cmd_result, cursor, page_size, &has_more, &next_cursor);
	free (cmd_result);
	char *response = jsonrpc_tooltext_response_paginated (paginated, has_more, next_cursor);
	free (paginated);
	free (next_cursor);
	return response;
}

static char *tool_list_all_strings(ServerState *ss, RJson *tool_args) {
	const char *filter = r_json_get_str (tool_args, "filter");
	const char *cursor = r_json_get_str (tool_args, "cursor");
	int page_size = (int)r_json_get_num (tool_args, "page_size");
	if (page_size <= 0) {
		page_size = R2MCP_DEFAULT_PAGE_SIZE;
	}
	if (page_size > R2MCP_MAX_PAGE_SIZE) {
		page_size = R2MCP_MAX_PAGE_SIZE;
	}

	char *cmd_result = r2mcp_cmd (ss, "izzzqq");
	if (R_STR_ISNOTEMPTY (filter)) {
		char *r = filter_lines_by_regex (cmd_result, filter);
		free (cmd_result);
		cmd_result = r;
	}
	if (R_STR_ISEMPTY (cmd_result)) {
		free (cmd_result);
		cmd_result = r_str_newf ("Error: No strings with regex %s", filter);
	}
	bool has_more = false;
	char *next_cursor = NULL;
	char *paginated = paginate_text_by_lines (cmd_result, cursor, page_size, &has_more, &next_cursor);
	free (cmd_result);
	char *response = jsonrpc_tooltext_response_paginated (paginated, has_more, next_cursor);
	free (paginated);
	free (next_cursor);
	return response;
}

static char *tool_analyze(ServerState *ss, RJson *tool_args) {
	if (ss->frida_mode) {
		return jsonrpc_tooltext_response ("Analysis is not available in frida mode. Use list_functions to see exports or run_command with r2frida commands.");
	}
	const int level = (int)r_json_get_num (tool_args, "level");
	char *err = r2_analyze (ss, level);
	char *cmd_result = r2mcp_cmd (ss, "aflc");
	char *errstr;
	if (R_STR_ISNOTEMPTY (err)) {
		errstr = r_str_newf ("\n\n<log>\n%s\n</log>\n", err);
	} else {
		errstr = strdup ("");
	}
	char *text = r_str_newf ("Analysis completed with level %d.\nFound %d functions.%s", level, atoi (cmd_result), errstr);
	char *response = jsonrpc_tooltext_response (text);
	free (err);
	free (errstr);
	free (cmd_result);
	free (text);
	return response;
}

static char *tool_disassemble(ServerState *ss, RJson *tool_args) {
	const char *address;
	if (!validate_address_param (tool_args, "address", &address)) {
		return jsonrpc_error_missing_param ("address");
	}

	RJson *num_instr_json = (RJson *)r_json_get (tool_args, "num_instructions");
	int num_instructions = 10;
	if (num_instr_json && num_instr_json->type == R_JSON_INTEGER) {
		num_instructions = (int)num_instr_json->num.u_value;
	}

	return tool_cmd_response (r2mcp_cmdf (ss, "'@%s'pd %d", address, num_instructions));
}

static char *tool_use_decompiler(ServerState *ss, RJson *tool_args) {
	const char *deco;
	if (!validate_required_string_param (tool_args, "name", &deco)) {
		return jsonrpc_error_missing_param ("name");
	}
	char *decompilersAvailable = r2mcp_cmd (ss, "e cmd.pdc=?");
	const char *response = "ok";
	if (strstr (deco, "ghidra")) {
		if (strstr (decompilersAvailable, "pdg")) {
			free (r2mcp_cmd (ss, "-e cmd.pdc=pdg"));
		} else {
			response = "This decompiler is not available";
		}
	} else if (strstr (deco, "decai")) {
		if (strstr (decompilersAvailable, "decai")) {
			free (r2mcp_cmd (ss, "-e cmd.pdc=decai -d"));
		} else {
			response = "This decompiler is not available";
		}
	} else if (strstr (deco, "r2dec")) {
		if (strstr (decompilersAvailable, "pdd")) {
			free (r2mcp_cmd (ss, "-e cmd.pdc=pdd"));
		} else {
			response = "This decompiler is not available";
		}
	} else {
		response = "Unknown decompiler";
	}
	free (decompilersAvailable);
	return jsonrpc_tooltext_response (response);
}

static char *tool_xrefs_to(ServerState *ss, RJson *tool_args) {
	const char *address;
	if (!validate_address_param (tool_args, "address", &address)) {
		return jsonrpc_error_missing_param ("address");
	}
	return tool_cmd_response (r2mcp_cmdf (ss, "'@%s'axt", address));
}

static char *tool_disassemble_function(ServerState *ss, RJson *tool_args) {
	const char *address;
	if (!validate_address_param (tool_args, "address", &address)) {
		return jsonrpc_error_missing_param ("address");
	}
	const char *cursor = r_json_get_str (tool_args, "cursor");
	int page_size = (int)r_json_get_num (tool_args, "page_size");
	if (page_size <= 0) {
		page_size = R2MCP_DEFAULT_PAGE_SIZE;
	}
	if (page_size > R2MCP_MAX_PAGE_SIZE) {
		page_size = R2MCP_MAX_PAGE_SIZE;
	}
	char *disasm = r2mcp_cmdf (ss, "'@%s'pdf", address);
	bool has_more = false;
	char *next_cursor = NULL;
	char *paginated = paginate_text_by_lines (disasm, cursor, page_size, &has_more, &next_cursor);
	free (disasm);
	char *response = jsonrpc_tooltext_response_paginated (paginated, has_more, next_cursor);
	free (paginated);
	free (next_cursor);
	return response;
}

static char *tool_rename_flag(ServerState *ss, RJson *tool_args) {
	const char *address, *name, *new_name;
	if (!validate_address_param (tool_args, "address", &address) ||
		!validate_required_string_param (tool_args, "name", &name) ||
		!validate_required_string_param (tool_args, "new_name", &new_name)) {
		return jsonrpc_error_missing_param ("address, name, and new_name");
	}
	char *remove_res = r2mcp_cmdf (ss, "'@%s'fr %s %s", address, name, new_name);

	if (R_STR_ISNOTEMPTY (remove_res)) {

		return tool_cmd_response (remove_res);
	}

	free (remove_res);

	return jsonrpc_tooltext_response ("ok");
}

static char *tool_rename_function(ServerState *ss, RJson *tool_args) {
	const char *address, *name;
	if (!validate_address_param (tool_args, "address", &address) ||
		!validate_required_string_param (tool_args, "name", &name)) {
		return jsonrpc_error_missing_param ("address and name");
	}
	free (r2mcp_cmdf (ss, "'@%s'afn %s", address, name));
	return jsonrpc_tooltext_response ("ok");
}

static char *tool_decompile_function(ServerState *ss, RJson *tool_args) {
	const char *address;
	if (!validate_address_param (tool_args, "address", &address)) {
		return jsonrpc_error_missing_param ("address");
	}
	const char *cursor = r_json_get_str (tool_args, "cursor");
	int page_size = (int)r_json_get_num (tool_args, "page_size");
	if (page_size <= 0) {
		page_size = R2MCP_DEFAULT_PAGE_SIZE;
	}
	if (page_size > R2MCP_MAX_PAGE_SIZE) {
		page_size = R2MCP_MAX_PAGE_SIZE;
	}
	char *disasm = r2mcp_cmdf (ss, "'@%s'pdc", address);
	bool has_more = false;
	char *next_cursor = NULL;
	char *paginated = paginate_text_by_lines (disasm, cursor, page_size, &has_more, &next_cursor);
	free (disasm);
	char *response = jsonrpc_tooltext_response_paginated (paginated, has_more, next_cursor);
	free (paginated);
	free (next_cursor);
	return response;
}

static char *tool_run_command(ServerState *ss, RJson *tool_args) {
	const char *command;
	if (!validate_required_string_param (tool_args, "command", &command)) {
		return jsonrpc_error_missing_param ("command");
	}
	return tool_cmd_response (r2mcp_cmd (ss, command));
}

static char *tool_run_javascript(ServerState *ss, RJson *tool_args) {
	const char *script;
	if (!validate_required_string_param (tool_args, "script", &script)) {
		return jsonrpc_error_missing_param ("script");
	}
	char *encoded = r_base64_encode_dyn ((const ut8 *)script, strlen (script));

	if (!encoded) {

		return jsonrpc_error_response (-32603, "Failed to encode script", NULL, NULL);
	}

	char *cmd = r_str_newf ("js base64:%s", encoded);
	char *res = r2mcp_cmd (ss, cmd);
	free (cmd);
	free (encoded);
	return tool_cmd_response (res);
}

static char *tool_list_sessions(ServerState *ss, RJson *tool_args) {
	if (!ss->use_sessions) {
		return jsonrpc_error_response (-32603, "Start r2mcp with -L to support sessions", NULL, NULL);
	}
	(void)tool_args;
	(void)ss;
	// r2agent command doesn't require an open file, run it directly
	char *res = NULL;
	if (ss && ss->http_mode) {
		// In HTTP mode, we can't run r2agent locally, return empty result
		res = strdup ("[]");
	} else {
		res = r_sys_cmd_str ("r2agent -Lj 2>/dev/null", NULL, NULL);
		if (R_STR_ISEMPTY (res)) {
			free (res);
			res = strdup ("[]");
		}
	}
	return tool_cmd_response (res);
}

static char *tool_open_session(ServerState *ss, RJson *tool_args) {
	if (!ss->use_sessions) {
		return jsonrpc_error_response (-32603, "Start r2mcp with -L to support sessions", NULL, NULL);
	}
	const char *url;
	if (!validate_required_string_param (tool_args, "url", &url)) {
		return jsonrpc_error_missing_param ("url");
	}

	// Store the current baseurl if we're not already in HTTP mode
	char *old_baseurl = NULL;
	bool old_http_mode = ss->http_mode;
	if (!ss->http_mode && ss->baseurl) {
		old_baseurl = strdup (ss->baseurl);
	}

	// Set up HTTP mode for this session
	ss->http_mode = true;
	free (ss->baseurl);
	ss->baseurl = strdup (url);

	// Test the connection by running a simple command
	char *test_result = r2mcp_cmd (ss, "i");
	if (!test_result || strstr (test_result, "HTTP request failed")) {
		// Restore previous state if connection failed
		ss->http_mode = old_http_mode;
		free (ss->baseurl);
		ss->baseurl = old_baseurl;
		free (test_result);

		char *error_msg = r_str_newf ("Failed to connect to URL: %s", url);
		char *error_resp = jsonrpc_error_response (-32603, error_msg, NULL, NULL);
		free (error_msg);
		return error_resp;
	}

	free (test_result);
	free (old_baseurl);

	ss->rstate.file_opened = true;

	char *success_msg = r_str_newf ("Successfully connected to remote r2 instance at %s", url);
	char *response = jsonrpc_tooltext_response (success_msg);
	free (success_msg);
	return response;
}

static char *tool_close_session(ServerState *ss, RJson *tool_args) {
	if (!ss->use_sessions) {
		return jsonrpc_error_response (-32603, "Start r2mcp with -L to support sessions", NULL, NULL);
	}
	(void)tool_args;

	if (!ss->http_mode) {
		return jsonrpc_tooltext_response ("No active remote session to close.");
	}

	// Clear the HTTP mode and baseurl
	ss->http_mode = false;
	ss->frida_mode = false;
	free (ss->baseurl);
	ss->baseurl = NULL;

	return jsonrpc_tooltext_response ("Remote session closed successfully.");
}

static char *check_supervisor_permission(ServerState *ss, const char *tool_name, RJson *tool_args, char **new_tool_name_out, RJson **new_tool_args_out, RJson **parsed_json_out) {
	if (!ss->svc_baseurl) {
		return NULL;
	}
	PJ *pj = pj_new ();
	pj_o (pj);
	pj_ks (pj, "tool", tool_name);
	pj_k (pj, "arguments");
	pj_append_rjson (pj, tool_args);
	pj_k (pj, "available_tools");
	pj_a (pj);
	for (size_t i = 0; tool_specs[i].name; i++) {
		pj_s (pj, tool_specs[i].name);
	}
	pj_end (pj);
	pj_end (pj);
	char *req = pj_drain (pj);
	int rc;
	char *resp = curl_post_capture (ss->svc_baseurl, req, &rc);
	free (req);
	if (!resp || rc != 0) {
		free (resp);
		return NULL;
	}
	*parsed_json_out = r_json_parse (resp);
	free (resp);
	if (!*parsed_json_out) {
		return NULL;
	}
	const char *err = r_json_get_str (*parsed_json_out, "error");
	if (err) {
		char *error_resp = jsonrpc_error_response (-32000, err, NULL, NULL);
		r_json_free (*parsed_json_out);
		*parsed_json_out = NULL;
		return error_resp;
	}
	const char *r2cmd = r_json_get_str (*parsed_json_out, "r2cmd");
	if (r2cmd) {
		char *cmd_out = r2mcp_cmd (ss, r2cmd);
		char *res = jsonrpc_tooltext_response (cmd_out? cmd_out: "");
		free (cmd_out);
		if (!strcmp (tool_name, "open_file")) {
			const char *filepath = r_json_get_str (tool_args, "file_path");
			if (filepath) {
				free (ss->rstate.current_file);
				ss->rstate.current_file = strdup (filepath);
				ss->rstate.file_opened = true;
			}
		}
		r_json_free (*parsed_json_out);
		*parsed_json_out = NULL;
		return res;
	}
	const char *new_tool = r_json_get_str (*parsed_json_out, "tool");
	if (new_tool && strcmp (new_tool, tool_name)) {
		*new_tool_name_out = strdup (new_tool);
	}
	const RJson *new_args = r_json_get (*parsed_json_out, "arguments");
	if (new_args) {
		*new_tool_args_out = (RJson *)new_args;
	} else {
		r_json_free (*parsed_json_out);
		*parsed_json_out = NULL;
	}
	return NULL;
}

// Main dispatcher that handles tool calls. Returns heap-allocated JSON
// string representing the tool "result" (caller must free it).
char *tools_call(ServerState *ss, const char *tool_name, RJson *tool_args) {
	RJson nil = { 0 };
	if (!tool_args) {
		tool_args = &nil;
	}
	char *result = NULL;
	char *allocated_tool_name = NULL;
	RJson *parsed_json = NULL;
	if (!tool_name) {
		result = jsonrpc_error_missing_param ("name");
		goto cleanup;
	}
	// Enforce tool availability per mode unless permissive is enabled
	if (!tools_is_tool_allowed (ss, tool_name)) {
		result = jsonrpc_error_tool_not_allowed (tool_name);
		goto cleanup;
	}

	// Supervisor control check
	char *supervisor_override = check_supervisor_permission (ss, tool_name, tool_args, &allocated_tool_name, &tool_args, &parsed_json);
	if (supervisor_override) {
		result = supervisor_override;
		goto cleanup;
	}
	if (allocated_tool_name) {
		tool_name = allocated_tool_name;
	}

	// Special-case: open_file
	if (!strcmp (tool_name, "open_file")) {
		if (ss->http_mode) {
			char *res = r2mcp_cmd (ss, "i");
			char *foo = r_str_newf ("File was already opened, this are the details:\n%s", res);
			char *out = jsonrpc_tooltext_response (foo);
			free (res);
			free (foo);
			result = out;
			goto cleanup;
		}
		const char *filepath;
		if (!validate_required_string_param (tool_args, "file_path", &filepath)) {
			result = jsonrpc_error_missing_param ("file_path");
			goto cleanup;
		}

		char *filteredpath = strdup (filepath);
		r_str_replace_ch (filteredpath, '`', 0, true);
		bool success = r2_open_file (ss, filteredpath);
		free (filteredpath);
		result = jsonrpc_tooltext_response (success? "File opened successfully.": "Failed to open file.");
		goto cleanup;
	}

	// Special-case: open_session
	if (!strcmp (tool_name, "open_session")) {
		result = tool_open_session (ss, tool_args);
		goto cleanup;
	}

	// Special-case: list_sessions
	if (!strcmp (tool_name, "list_sessions")) {
		result = tool_list_sessions (ss, tool_args);
		goto cleanup;
	}

	if (!ss->http_mode && !ss->rstate.file_opened) {
		result = jsonrpc_error_file_required ();
		goto cleanup;
	}

	// Find the tool spec and validate arguments against schema
	ToolSpec *found_tool = NULL;
	for (size_t i = 0; tool_specs[i].name; i++) {
		ToolSpec *t = &tool_specs[i];
		if (!strcmp (tool_name, t->name)) {
			found_tool = t;
			break;
		}
	}

	if (found_tool && found_tool->schema_json) {
		ValidationResult vr = validate_arguments (tool_args, found_tool->schema_json);
		if (!vr.valid) {
			result = jsonrpc_error_response (-32602, vr.error_message, NULL, NULL);
			free (vr.error_message);
			goto cleanup;
		}
	}

	// Dispatch to tool functions
	for (size_t i = 0; tool_specs[i].name; i++) {
		ToolSpec *t = &tool_specs[i];
		if (!strcmp (tool_name, t->name)) {
			result = t->func (ss, tool_args);
			goto cleanup;
		}
	}

	char *tmp = r_str_newf ("Unknown tool: %s", tool_name);
	char *err = jsonrpc_error_response (-32602, tmp, NULL, NULL);
	free (tmp);
	result = err;
	goto cleanup;

cleanup:
	free (allocated_tool_name);
	r_json_free (parsed_json);
	return result;
}
ToolSpec tool_specs[] = {
	{ "open_file", "Opens a binary file with radare2 for analysis <think>Call this tool before any other one from r2mcp. Use an absolute file_path</think>", "{\"type\":\"object\",\"properties\":{\"file_path\":{\"type\":\"string\",\"description\":\"Path to the file to open\"}},\"required\":[\"file_path\"]}", TOOL_MODE_NORMAL | TOOL_MODE_MINI, NULL },
	{ "run_javascript", "Executes JavaScript code using radare2's qjs runtime", "{\"type\":\"object\",\"properties\":{\"script\":{\"type\":\"string\",\"description\":\"The JavaScript code to execute\"}},\"required\":[\"script\"]}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP, tool_run_javascript },
	{ "run_command", "Executes a raw radare2 command directly", "{\"type\":\"object\",\"properties\":{\"command\":{\"type\":\"string\",\"description\":\"The radare2 command to execute\"}},\"required\":[\"command\"]}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP, tool_run_command },
	{ "list_sessions", "Lists available r2agent sessions in JSON format", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_HTTP | TOOL_MODE_RO | TOOL_MODE_SESSIONS, tool_list_sessions },
	{ "open_session", "Connects to a remote r2 instance using r2pipe API", "{\"type\":\"object\",\"properties\":{\"url\":{\"type\":\"string\",\"description\":\"URL of the remote r2 instance to connect to\"}},\"required\":[\"url\"]}", TOOL_MODE_NORMAL | TOOL_MODE_HTTP | TOOL_MODE_SESSIONS, tool_open_session },
	{ "close_session", "Close the currently open remote session", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_HTTP | TOOL_MODE_SESSIONS, tool_close_session },
	{ "close_file", "Close the currently open file", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL, tool_close_file },
	{ "list_functions", "Lists all functions discovered during analysis", "{\"type\":\"object\",\"properties\":{\"only_named\":{\"type\":\"boolean\",\"description\":\"If true, only list functions with named symbols (excludes functions with numeric suffixes like sym.func.1000016c8)\"},\"filter\":{\"type\":\"string\",\"description\":\"Regular expression to filter the results\"},\"start\":{\"type\":\"integer\",\"description\":\"Starting index for pagination (default: 0)\"},\"max_length\":{\"type\":\"integer\",\"description\":\"Maximum number of results to return, -1 for all (default: 50)\"}}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO, tool_list_functions },
	{ "list_functions_tree", "Lists functions and successors (aflmu)", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO, tool_list_functions_tree },
	{ "list_libraries", "Lists all shared libraries linked to the binary", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_libraries },
	{ "list_imports", "Lists imported symbols (note: use list_symbols for addresses with sym.imp. prefix)", "{\"type\":\"object\",\"properties\":{\"filter\":{\"type\":\"string\",\"description\":\"Regular expression to filter the results\"}}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_imports },
	{ "list_exports", "Lists exported symbols from the binary or process", "{\"type\":\"object\",\"properties\":{\"filter\":{\"type\":\"string\",\"description\":\"Regular expression to filter the results\"}}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_exports },
	{ "list_sections", "Displays memory sections and segments from the binary", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_sections },
	{ "list_memory_maps", "Lists memory regions of the process with addresses and permissions", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_FRIDA, tool_list_memory_maps },
	{ "show_function_details", "Displays detailed information about the current function", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_RO, tool_show_function_details },
	{ "get_current_address", "Shows the current position and function name", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_RO, tool_get_current_address },
	{ "show_headers", "Displays binary headers and file information", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_show_headers },
	{ "list_symbols", "Shows all symbols (functions, variables, imports) with addresses", "{\"type\":\"object\",\"properties\":{\"filter\":{\"type\":\"string\",\"description\":\"Regular expression to filter the results\"}}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_symbols },
	{ "list_entrypoints", "Displays program entrypoints, constructors and main function", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_entrypoints },
	{ "list_methods", "Lists all methods belonging to the specified class", "{\"type\":\"object\",\"properties\":{\"classname\":{\"type\":\"string\",\"description\":\"Name of the class to list methods for\"}},\"required\":[\"classname\"]}", TOOL_MODE_NORMAL | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_methods },
	{ "list_classes", "Lists class names from various languages (C++, ObjC, Swift, Java, Dalvik)", "{\"type\":\"object\",\"properties\":{\"filter\":{\"type\":\"string\",\"description\":\"Regular expression to filter the results\"}}}", TOOL_MODE_NORMAL | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_classes },
	{ "list_decompilers", "Shows all available decompiler backends", "{\"type\":\"object\",\"properties\":{}}", TOOL_MODE_NORMAL | TOOL_MODE_RO, tool_list_decompilers },
	{ "rename_function", "Renames the function at the specified address", "{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"New function name\"},\"address\":{\"type\":\"string\",\"description\":\"Address of the function to rename\"}},\"required\":[\"name\",\"address\"]}", TOOL_MODE_NORMAL, tool_rename_function },
	{ "rename_flag", "Renames a local variable or data reference within the specified address", "{\"type\":\"object\",\"properties\":{\"address\":{\"type\":\"string\",\"description\":\"Address of the flag containing the variable or data reference\"},\"name\":{\"type\":\"string\",\"description\":\"Current variable name or data reference\"},\"new_name\":{\"type\":\"string\",\"description\":\"New variable name or data reference\"}},\"required\":[\"address\",\"name\",\"new_name\"]}", TOOL_MODE_NORMAL | TOOL_MODE_HTTP, tool_rename_flag },
	{ "use_decompiler", "Selects which decompiler backend to use (default: pdc)", "{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Name of the decompiler\"}},\"required\":[\"name\"]}", TOOL_MODE_NORMAL, tool_use_decompiler },
	{ "get_function_prototype", "Retrieves the function signature at the specified address", "{\"type\":\"object\",\"properties\":{\"address\":{\"type\":\"string\",\"description\":\"Address of the function\"}},\"required\":[\"address\"]}", TOOL_MODE_NORMAL | TOOL_MODE_RO, tool_get_function_prototype },
	{ "set_function_prototype", "Sets the function signature (return type, name, arguments)", "{\"type\":\"object\",\"properties\":{\"address\":{\"type\":\"string\",\"description\":\"Address of the function\"},\"prototype\":{\"type\":\"string\",\"description\":\"Function signature in C-like syntax\"}},\"required\":[\"address\",\"prototype\"]}", TOOL_MODE_NORMAL, tool_set_function_prototype },
	{ "set_comment", "Adds a comment at the specified address", "{\"type\":\"object\",\"properties\":{\"address\":{\"type\":\"string\",\"description\":\"Address to put the comment in\"},\"message\":{\"type\":\"string\",\"description\":\"Comment text to use\"}},\"required\":[\"address\",\"message\"]}", TOOL_MODE_NORMAL | TOOL_MODE_HTTP, tool_set_comment },
	{ "list_strings", "Lists strings from data sections with optional regex filter", "{\"type\":\"object\",\"properties\":{\"filter\":{\"type\":\"string\",\"description\":\"Regular expression to filter the results\"},\"cursor\":{\"type\":\"string\",\"description\":\"Cursor for pagination (line number to start from)\"},\"page_size\":{\"type\":\"integer\",\"description\":\"Number of lines per page (default: 1000, max: 10000)\"}}}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_list_strings },
	{ "list_all_strings", "Scans the entire binary for strings with optional regex filter", "{\"type\":\"object\",\"properties\":{\"filter\":{\"type\":\"string\",\"description\":\"Regular expression to filter the results\"},\"cursor\":{\"type\":\"string\",\"description\":\"Cursor for pagination (line number to start from)\"},\"page_size\":{\"type\":\"integer\",\"description\":\"Number of lines per page (default: 1000, max: 10000)\"}}}", TOOL_MODE_NORMAL | TOOL_MODE_RO, tool_list_all_strings },
	{ "analyze", "Runs binary analysis with optional depth level", "{\"type\":\"object\",\"properties\":{\"level\":{\"type\":\"number\",\"description\":\"Analysis level (0-4, higher is more thorough)\"}},\"required\":[]}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_FRIDA, tool_analyze },
	{ "xrefs_to", "Finds all code references to the specified address", "{\"type\":\"object\",\"properties\":{\"address\":{\"type\":\"string\",\"description\":\"Address to check for cross-references\"}},\"required\":[\"address\"]}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO, tool_xrefs_to },
	{ "decompile_function", "Show C-like pseudocode of the function in the given address. <think>Use this to inspect the code in a function, do not run multiple times in the same offset</think>", "{\"type\":\"object\",\"properties\":{\"address\":{\"type\":\"string\",\"description\":\"Address of the function to decompile\"},\"cursor\":{\"type\":\"string\",\"description\":\"Cursor for pagination (line number to start from)\"},\"page_size\":{\"type\":\"integer\",\"description\":\"Number of lines per page (default: 1000, max: 10000)\"}},\"required\":[\"address\"]}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO, tool_decompile_function },
	{ "list_files", "Lists files in the specified path using radare2's ls -q command. Files ending with / are directories, otherwise they are files.", "{\"type\":\"object\",\"properties\":{\"path\":{\"type\":\"string\",\"description\":\"Path to list files from\"}},\"required\":[\"path\"]}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_HTTP | TOOL_MODE_RO, tool_list_files },
	{ "disassemble_function", "Shows assembly listing of the function at the specified address", "{\"type\":\"object\",\"properties\":{\"address\":{\"type\":\"string\",\"description\":\"Address of the function to disassemble\"},\"cursor\":{\"type\":\"string\",\"description\":\"Cursor for pagination (line number to start from)\"},\"page_size\":{\"type\":\"integer\",\"description\":\"Number of lines per page (default: 1000, max: 10000)\"}},\"required\":[\"address\"]}", TOOL_MODE_NORMAL | TOOL_MODE_RO, tool_disassemble_function },
	{ "disassemble", "Disassembles a specific number of instructions from an address <think>Use this tool to inspect a portion of memory as code without depending on function analysis boundaries. Use this tool when functions are large and you are only interested on few instructions</think>", "{\"type\":\"object\",\"properties\":{\"address\":{\"type\":\"string\",\"description\":\"Address to start disassembly\"},\"num_instructions\":{\"type\":\"integer\",\"description\":\"Number of instructions to disassemble (default: 10)\"}},\"required\":[\"address\"]}", TOOL_MODE_NORMAL | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_disassemble },
	{ "calculate", "Evaluate a math expression using core->num (r_num_math). Usecases: do proper 64-bit math, resolve addresses for flag names/symbols, and avoid hallucinated results.", "{\"type\":\"object\",\"properties\":{\"expression\":{\"type\":\"string\",\"description\":\"Math expression to evaluate (eg. 0x100 + sym.flag - 4)\"}},\"required\":[\"expression\"]}", TOOL_MODE_NORMAL | TOOL_MODE_MINI | TOOL_MODE_RO | TOOL_MODE_FRIDA, tool_calculate },
	{ NULL, NULL, NULL, 0, NULL }
};

```

`src/tools.h`:

```h
#pragma once

#include <stdbool.h>
#include "r2mcp.h"

typedef enum {
	TOOL_MODE_MINI = 1 << 0,
	TOOL_MODE_HTTP = 1 << 1,
	TOOL_MODE_NORMAL = 1 << 2,
	TOOL_MODE_RO = 1 << 3,
	TOOL_MODE_SESSIONS = 1 << 4,
	TOOL_MODE_FRIDA = 1 << 5,
} ToolMode;

// Tool handler signature: returns heap-allocated JSON string describing
// the tool result (typically jsonrpc_tooltext_response() content or other
// structured JSON). Caller must free the returned string.
typedef char *(*ToolHandler)(ServerState *ss, RJson *args);

typedef struct {
	const char *name;
	const char *description;
	const char *schema_json;
	int modes; // bitmask of ToolMode
	ToolHandler func;
} ToolSpec;

extern ToolSpec tool_specs[];

// Tool flags (for future use). For now, we use one to require an open file.
#define TOOL_FLAG_REQUIRES_OPENFILE (1 << 0)



// Build catalog JSON for the current server mode with optional pagination
char *tools_build_catalog_json(const ServerState *ss, const char *cursor, int page_size);

// Check if a tool is allowed for the current mode (honors permissive flag)
bool tools_is_tool_allowed(const ServerState *ss, const char *name);

// Call a tool by name; returns heap-allocated JSON (tool "result") or
// a JSON error result if the tool is unavailable or arguments are invalid.
// The returned string must be freed by the caller.
char *tools_call(ServerState *ss, const char *tool_name, RJson *args);

// Print a human friendly table of available tools for the current mode
// Columns: name | mini-mode (yes/no) | description
void tools_print_table(const ServerState *ss);

```

`src/utils.inc.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake */

#if R2_VERSION_NUMBER < 50909
static st64 r_json_get_num(const RJson *json, const char *key) {
	R_RETURN_VAL_IF_FAIL (json && key, 0);
	const RJson *field = r_json_get (json, key);
	if (field) {
		switch (field->type) {
		case R_JSON_STRING:
			return r_num_get (NULL, field->str_value);
		case R_JSON_INTEGER:
			return field->num.s_value;
		case R_JSON_BOOLEAN:
			return field->num.u_value;
		case R_JSON_DOUBLE:
			return (int)field->num.dbl_value;
		}
	}
	return 0;
}

static const char *r_json_get_str(const RJson *json, const char *key) {
	R_RETURN_VAL_IF_FAIL (json && key, NULL);
	const RJson *field = r_json_get (json, key);
	if (!field || field->type != R_JSON_STRING) {
		return NULL;
	}
	return field->str_value;
}

#endif

// Helper to paginate text by lines
static inline char *paginate_text_by_lines(char *text, const char *cursor, int page_size, bool *has_more, char **next_cursor) {
	if (!text) {
		if (has_more) {
			*has_more = false;
		}
		if (next_cursor) {
			*next_cursor = NULL;
		}
		return strdup ("");
	}
	RList *lines = r_str_split_list (text, "\n", 0);
	if (!lines) {
		return NULL;
	}
	int total_lines = r_list_length (lines);
	int start_line = 0;
	if (cursor) {
		start_line = atoi (cursor);
		if (start_line < 0) {
			start_line = 0;
		}
	}
	int end_line = start_line + page_size;
	if (end_line > total_lines) {
		end_line = total_lines;
	}
	RStrBuf *sb = r_strbuf_new ("");
	int idx = 0;
	RListIter *it;
	char *line;
	r_list_foreach (lines, it, line) {
		if (idx >= start_line && idx < end_line) {
			if (r_strbuf_length (sb) > 0) {
				r_strbuf_append (sb, "\n");
			}
			r_strbuf_append (sb, line);
		}
		idx++;
	}
	r_list_free (lines);
	char *result = r_strbuf_drain (sb);
	if (has_more) {
		*has_more = end_line < total_lines;
	}
	if (next_cursor) {
		if (end_line < total_lines) {
			*next_cursor = r_str_newf ("%d", end_line);
		} else {
			*next_cursor = NULL;
		}
	}
	return result;
}

static void pj_append_rjson(PJ *pj, RJson *j) {
	if (!j) {
		pj_null (pj);
		return;
	}
	switch (j->type) {
	case R_JSON_NULL:
		pj_null (pj);
		break;
	case R_JSON_BOOLEAN:
		pj_b (pj, j->num.u_value);
		break;
	case R_JSON_INTEGER:
		pj_n (pj, j->num.s_value);
		break;
	case R_JSON_DOUBLE:
		pj_d (pj, j->num.dbl_value);
		break;
	case R_JSON_STRING:
		pj_s (pj, j->str_value);
		break;
	case R_JSON_ARRAY:
		pj_a (pj);
		RJson *child = j->children.first;
		while (child) {
			pj_append_rjson (pj, child);
			child = child->next;
		}
		pj_end (pj);
		break;
	case R_JSON_OBJECT:
		pj_o (pj);
		child = j->children.first;
		while (child) {
			pj_k (pj, child->key);
			pj_append_rjson (pj, child);
			child = child->next;
		}
		pj_end (pj);
		break;
	}
}

// Intentionally no generic require_str_param helper; callers validate params inline

```

`src/validation.c`:

```c
/* r2mcp - MIT - Copyright 2025-2026 - pancake */

#include "validation.h"
#include "jsonrpc.h"

/* Check if a parameter exists and is a string */
ValidationResult validate_required_string(RJson *args, const char *param_name) {
	const RJson *field = r_json_get (args, param_name);
	if (!field || field->type != R_JSON_STRING) {
		char *msg = r_str_newf ("Missing required parameter '%s' (expected string)", param_name);
		return (ValidationResult){ false, msg };
	}
	return (ValidationResult){ true, NULL };
}

/* Check if a parameter exists and is numeric (integer or double) */
ValidationResult validate_required_number(RJson *args, const char *param_name) {
	const RJson *field = r_json_get (args, param_name);
	if (!field || (field->type != R_JSON_INTEGER && field->type != R_JSON_DOUBLE)) {
		char *msg = r_str_newf ("Missing required parameter '%s' (expected number)", param_name);
		return (ValidationResult){ false, msg };
	}
	return (ValidationResult){ true, NULL };
}

/* Check if a parameter exists and is a boolean */
ValidationResult validate_required_boolean(RJson *args, const char *param_name) {
	const RJson *field = r_json_get (args, param_name);
	if (!field || field->type != R_JSON_BOOLEAN) {
		char *msg = r_str_newf ("Missing required parameter '%s' (expected boolean)", param_name);
		return (ValidationResult){ false, msg };
	}
	return (ValidationResult){ true, NULL };
}

/* Check if a parameter exists with any valid type */
ValidationResult validate_required_param(RJson *args, const char *param_name) {
	const RJson *field = r_json_get (args, param_name);
	if (!field) {
		char *msg = r_str_newf ("Missing required parameter '%s'", param_name);
		return (ValidationResult){ false, msg };
	}
	return (ValidationResult){ true, NULL };
}

/* Parse JSON Schema to extract required properties */
static RList *parse_required_properties(const char *schema_json) {
	if (!schema_json || !*schema_json) {
		return NULL;
	}

	/* We need a non-modifiable copy for parsing */
	char *schema_copy = strdup (schema_json);
	if (!schema_copy) {
		return NULL;
	}

	RJson *schema = r_json_parse (schema_copy);
	if (!schema || schema->type != R_JSON_OBJECT) {
		free (schema_copy);
		return NULL;
	}

	RList *required = NULL;
	const RJson *required_json = r_json_get (schema, "required");
	if (required_json && required_json->type == R_JSON_ARRAY) {
		required = r_list_newf (free);
		const RJson *item = required_json->children.first;
		while (item) {
			if (item->type == R_JSON_STRING && item->str_value) {
				r_list_append (required, strdup (item->str_value));
			}
			item = item->next;
		}
	}

	r_json_free (schema);
	free (schema_copy);
	return required;
}

/* Validate arguments against JSON Schema */
ValidationResult validate_arguments(RJson *args, const char *schema_json) {
	if (!schema_json || !*schema_json) {
		/* No schema defined - allow all arguments */
		return (ValidationResult){ true, NULL };
	}

	/* Parse schema to get required properties */
	RList *required = parse_required_properties (schema_json);
	if (!required) {
		/* Schema couldn't be parsed - allow all arguments */
		return (ValidationResult){ true, NULL };
	}

	/* Check each required parameter exists */
	RListIter *it;
	const char *param;
	r_list_foreach (required, it, param) {
		const RJson *field = r_json_get (args, param);
		if (!field) {
			char *msg = r_str_newf ("Missing required parameter '%s'", param);
			r_list_free (required);
			return (ValidationResult){ false, msg };
		}
	}

	r_list_free (required);
	return (ValidationResult){ true, NULL };
}

```

`src/validation.h`:

```h
/* r2mcp - MIT - Copyright 2025-2026 - pancake */
#ifndef VALIDATION_H
#define VALIDATION_H

#include <r_core.h>
#include "r2mcp.h"

/* Validation result - caller must free error_message if not NULL */
typedef struct {
	bool valid;
	char *error_message;
} ValidationResult;

/* Validate tool arguments against the JSON schema in ToolSpec.
 * Returns ValidationResult with valid=true if args match schema.
 * error_message is set if validation fails (caller must free). */
ValidationResult validate_arguments(RJson *args, const char *schema_json);

/* Helper: Check if a required string parameter exists and is a string */
ValidationResult validate_required_string(RJson *args, const char *param_name);

/* Helper: Check if a required numeric parameter exists and is numeric */
ValidationResult validate_required_number(RJson *args, const char *param_name);

/* Helper: Check if a required boolean parameter exists and is a boolean */
ValidationResult validate_required_boolean(RJson *args, const char *param_name);

#endif

```

`svc/Makefile`:

```
CC ?= gcc
PKGCONFIG = pkg-config
R2_CFLAGS = $(shell $(PKGCONFIG) --cflags r_util)
R2_LDFLAGS = $(shell $(PKGCONFIG) --libs r_util r_socket r_cons)
R2PM_BINDIR=$(shell r2pm -H R2PM_BINDIR)
INSTALL_DIR ?= install -d
INSTALL_PROGRAM ?= install -m 755
PREFIX ?= /usr/local

TARGET = r2mcp-svc

all: $(TARGET)

$(TARGET): r2mcp-svc.c
	$(CC) $(R2_CFLAGS) -Wall -Wextra -o $@ $< $(R2_LDFLAGS)

clean:
	rm -f $(TARGET)

install: all
	$(INSTALL_DIR) $(DESTDIR)/$(PREFIX)/bin
	$(INSTALL_PROGRAM) $(TARGET) $(DESTDIR)/$(PREFIX)/bin/$(TARGET)

uninstall:
	rm -f $(DESTDIR)/$(PREFIX)/bin/$(TARGET)

user-install:
	$(INSTALL_DIR) $(DESTDIR)/$(R2PM_BINDIR)
	$(INSTALL_PROGRAM) $(TARGET) $(DESTDIR)/$(R2PM_BINDIR)/$(TARGET)

user-uninstall:
	rm -f $(DESTDIR)/$(R2PM_BINDIR)/$(TARGET)

.PHONY: clean install uninstall

```

`svc/README.md`:

```md
# SuperVisor Console for r2mcp

## Overview

The R2 MCP SBC (Supervisor Control) acts as a supervisor for every tool execution within the R2 MCP (Model Context Protocol) environment. It provides an additional layer of protection and control over what agents execute in headless MCP sessions, where users typically lack real-time oversight.

## Purpose

While some MCP agents offer built-in controls like accept, execute, cancel, reject, or JOLO (Just One Look Over) modes, these capabilities depend on the specific agent implementation rather than the MCP itself. The R2 MCP SBC extends these protection capabilities universally, allowing any agent to benefit from enhanced supervision.

## How It Works

When running the R2 MCP SBC service, it collects all calls made to R2 MCP tools. Upon receiving a connection from an MCP instance, the SBC provides users with options to:

- **Accept**: Allow the tool call to proceed as requested
- **Reject**: Block the tool call entirely
- **Modify**: Alter the query or parameters before execution
- **Respond with Error**: Return a custom error message
- **Provide Different Instructions**: Substitute alternative instructions

## Integration with R2 MCP

The SBC integrates seamlessly with R2 MCP through a simple flag-based mechanism:

- Run R2 MCP with a specific flag specifying the SBC host and port
- R2 MCP will then execute tool calls against the target SBC URL
- The SBC service receives these connections and prompts the user via command-line interface for the desired action

## Control Protocol

The supervision control is implemented using JSON over HTTP, ensuring compatibility and ease of integration.

## User Interface

The SBC provides a command-line tool interface for user interaction and decision-making.

## Default Behavior

By default, R2 MCP operates normally without supervision. When the SBC flag is provided:

- R2 MCP attempts to connect to the specified SBC endpoint
- If connection fails, R2 MCP falls back to normal operation (no supervision)
- If connection succeeds, R2 MCP waits for SBC responses before proceeding with tool executions

This design ensures that supervision is optional and doesn't break existing workflows when the SBC is unavailable.

## Building and Running

To build the R2 MCP-SBC tool:

```bash
make
```

This will create the `r2mcp-svc` executable.

To run the SBC server on a specific port:

```bash
./r2mcp-svc <port>
```

For example:

```bash
./r2mcp-svc 8080
```

The SBC will listen for HTTP POST requests containing JSON tool call data. When a request is received, it will prompt the user interactively for the desired action.

## Integration with R2 MCP

In R2 MCP, use the supervision flag to specify the SBC endpoint:

```
r2mcp --supervise http://localhost:8080
```

If the SBC is unreachable, R2 MCP will operate normally without supervision.



```

`svc/r2mcp-svc.c`:

```c
/* r2mcp - MIT - Copyright 2025 - pancake, dnakov */

#include <r_socket.h>
#include <r_cons.h>
#include <r_util/r_json.h>
#include <r_util/r_str.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

typedef struct {
	bool yolo_mode;
	bool quit;
	bool single_request;
	int port;
	RCons *cons;
} R2McpSvcContext;

static bool parse_args(int argc, char **argv, R2McpSvcContext *ctx) {
	int i = 1;
	for (; i < argc; i++) {
		const char *arg = argv[i];
		if (!strcmp (arg, "-y")) {
			ctx->yolo_mode = true;
		} else if (!strcmp (arg, "-q")) {
			ctx->single_request = true;
		} else if (r_str_startswith (arg, "-")) {
			R_LOG_INFO ("Unknown flag %s", arg);
		} else {
			break;
		}
	}
	if (i != argc - 1) {
		R_LOG_ERROR ("Usage: %s [-y] [-q] <port>", argv[0]);
		return false;
	}
	ctx->port = atoi (argv[i]);
	if (ctx->port <= 0) {
		R_LOG_ERROR ("Invalid port");
		return false;
	}
	return true;
}

static RSocket *setup_server(int port) {
	RSocket *server = r_socket_new (false);
	if (!server) {
		R_LOG_ERROR ("Cannot create socket");
		return NULL;
	}
	char port_str[16];
	sprintf (port_str, "%d", port);
	if (!r_socket_listen (server, port_str, NULL)) {
		R_LOG_ERROR ("Cannot listen on port %s", port_str);
		r_socket_free (server);
		return NULL;
	}
	R_LOG_INFO (Color_GREEN "üöÄ R2MCP Supervisor waiting for requests on port %d" Color_RESET, port);
	return server;
}

static char *handle_modify(R2McpSvcContext *ctx, char *data) {
	r_cons_printf (ctx->cons, Color_MAGENTA "‚úèÔ∏è"
					" Enter new tool name:" Color_RESET " ");
	r_cons_flush (ctx->cons);
	const char *line = r_line_readline (ctx->cons);
	if (!line) {
		return strdup ("{\"error\":\"input failed\"}");
	}
	char *new_tool = strdup (line);
	char *escaped_new_tool = r_str_replace (strdup (new_tool), "\\", "\\\\", 1);
	escaped_new_tool = r_str_replace (escaped_new_tool, "\"", "\\\"", 1);
	char *tool_key = "\"tool\":\"";
	char *pos = strstr (data, tool_key);
	if (!pos) {
		free (escaped_new_tool);
		free (new_tool);
		return strdup ("{\"error\":\"no tool field\"}");
	}
	char *start = pos + strlen (tool_key);
	char *end = strchr (start, '"');
	if (!end) {
		free (escaped_new_tool);
		free (new_tool);
		return strdup ("{\"error\":\"invalid json\"}");
	}
	size_t prefix_len = start - data;
	char *response_body = r_str_newf ("%.*s%s%s", (int)prefix_len, data, escaped_new_tool, end);
	free (escaped_new_tool);
	free (new_tool);
	return response_body;
}

static char *handle_r2cmd(R2McpSvcContext *ctx) {
	r_cons_printf (ctx->cons, Color_CYAN "üñ•Ô∏è"
					" Enter r2 command:" Color_RESET " ");
	r_cons_flush (ctx->cons);
	const char *line = r_line_readline (ctx->cons);
	if (!line) {
		return strdup ("{\"error\":\"input failed\"}");
	}
	char *r2cmd = strdup (line);
	char *escaped = r_str_replace (strdup (r2cmd), "\"", "\\\"", 1);
	char *response_body = r_str_newf ("{\"r2cmd\":\"%s\"}", escaped);
	free (escaped);
	free (r2cmd);
	return response_body;
}

static char *show_menu_and_get_response(char *data, const char *tool, R2McpSvcContext *ctx) {
	r_cons_printf (ctx->cons, "\n" Color_YELLOW "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
				"‚ïë " Color_CYAN "üîß Tool Call Request " Color_YELLOW "‚ïë\n"
				"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n" Color_GREEN "Tool: %s\n" Color_BLUE "Request: %s\n\n"
				"Available Actions:\n" Color_GREEN "1. ‚úÖ Accept\n" Color_RED "2. ‚ùå Reject\n" Color_YELLOW "3. ‚ö° Accept all (YOLO mode)\n" Color_MAGENTA "4. Modify tool\n" Color_CYAN "5. üñ•Ô∏è Run r2 command\n" Color_RED "6. Quit server\n\n" Color_RESET "‚ùì Your choice: ",
		tool? tool: "unknown",
		data);
	r_cons_flush (ctx->cons);

	const char *line = r_line_readline (ctx->cons);
	if (!line) {
		return strdup ("{\"error\":\"input failed\"}");
	}
	char *input = strdup (line);
	int choice = atoi (input);
	free (input);
	switch (choice) {
	case 1: // Accept
		return strdup (data);
	case 2: // Reject
		return strdup ("{\"error\":\"rejected by user\"}");
	case 3: // YOLO
		ctx->yolo_mode = true;
		return strdup (data);
	case 4: // Modify
		return handle_modify (ctx, data);
	case 5: // Run r2 command
		return handle_r2cmd (ctx);
	case 6: // Quit
		ctx->quit = true;
		return strdup ("{\"error\":\"server quit\"}");
	default:
		return strdup ("{\"error\":\"invalid choice\"}");
	}
}

static void handle_request(RSocket *server, R2McpSvcContext *ctx) {
	RSocketHTTPOptions so = { 0 };
	so.timeout = 3;
	fflush (stderr);
	RSocketHTTPRequest *rs = r_socket_http_accept (server, &so);
	if (!rs) {
		return;
	}

	// Only accept POST requests
	if (strcmp (rs->method, "POST")) {
		char *response_body = r_str_newf ("{\"error\":\"Method not allowed\"}");
		r_socket_http_response (rs, 405, response_body, 0, "Content-Type: application/json\r\n");
		free (response_body);
		r_socket_http_free (rs);
		return;
	}

	if (!rs->data) {
		char *response_body = r_str_newf ("{\"error\":\"No data\"}");
		r_socket_http_response (rs, 400, response_body, 0, "Content-Type: application/json\r\n");
		free (response_body);
		r_socket_http_free (rs);
		return;
	}

	// Parse JSON
	char *body_copy = strdup ((char *)rs->data); // r_json_parse modifies the string
	RJson *j = r_json_parse (body_copy);
	if (!j) {
		free (body_copy);
		char *response_body = r_str_newf ("{\"error\":\"Invalid JSON\"}");
		r_socket_http_response (rs, 400, response_body, 0, "Content-Type: application/json\r\n");
		free (response_body);
		r_socket_http_free (rs);
		return;
	}

	const char *tool = r_json_get_str (j, "tool");
	char *response_body = NULL;

	if (ctx->yolo_mode) {
		// Auto accept
		r_cons_printf (ctx->cons, Color_YELLOW "‚ö°"
						" YOLO: Received message:" Color_RESET " %s\n",
			(char *)rs->data);
		r_cons_printf (ctx->cons, Color_YELLOW "‚ö°"
						" YOLO: Tool executed:" Color_RESET " %s\n",
			tool? tool: "unknown");
		r_cons_flush (ctx->cons);
		response_body = strdup ((char *)rs->data);
	} else {
		response_body = show_menu_and_get_response ((char *)rs->data, tool, ctx);
	}

	if (response_body) {
		r_socket_http_response (rs, 200, response_body, 0, "Content-Type: application/json\r\n");
		free (response_body);
	}

	r_json_free (j);
	free (body_copy);
	r_socket_http_free (rs);
	if (ctx->single_request) {
		ctx->quit = true;
	}
}

int main(int argc, char **argv) {
	R2McpSvcContext ctx = { 0 };
	ctx.cons = r_cons_new ();
	if (parse_args (argc, argv, &ctx)) {
		RSocket *server = setup_server (ctx.port);
		if (server) {
			while (!ctx.quit) {
				handle_request (server, &ctx);
			}
			r_socket_free (server);
		}
	}
	r_cons_free (ctx.cons);
	return 0;
}

```

`test.sh`:

```sh
#!/usr/bin/env bash
set -euo pipefail

echo "== Build =="
make -C src -j > /dev/null

BIN="src/r2mcp"

echo "== List tools =="
${BIN} -t | sed -n '1,10p'

echo "== DSL: open_file + listFunctions (no -p) =="
${BIN} -T 'open_file file_path="/bin/ls"; list_functions only_named=true; close_file' | sed -n '1,8p'

echo "== DSL: unquoted value and multiple tools =="
${BIN} -T 'open_file file_path=/bin/ls; show_headers; get_current_address; close_file' | sed -n '1,12p'

echo "== DSL: ensure error when missing open_file =="
set +e
${BIN} -T 'list_functions only_named=true' | grep -q "open_file" && echo "(expected) tool enforces open_file first" || echo "(warning) missing expected open_file hint"
set -e

echo "== OK =="


```