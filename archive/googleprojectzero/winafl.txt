Project Path: arc_googleprojectzero_winafl_h9_a2_6v

Source Tree:

```txt
arc_googleprojectzero_winafl_h9_a2_6v
├── CMakeLists.txt
├── CONTRIBUTING.md
├── ChangeLog
├── LICENSE
├── README.md
├── afl-analyze.c
├── afl-fuzz.c
├── afl-showmap.c
├── afl-staticinstr.c
├── afl-staticinstr.h
├── afl-tmin.c
├── afl_docs
│   ├── COPYING
│   ├── ChangeLog
│   ├── INSTALL
│   ├── QuickStartGuide.txt
│   ├── README
│   ├── env_variables.txt
│   ├── historical_notes.txt
│   ├── notes_for_asan.txt
│   ├── parallel_fuzzing.txt
│   ├── perf_tips.txt
│   ├── sister_projects.txt
│   ├── status_screen.txt
│   ├── technical_details.txt
│   ├── visualization
│   │   └── afl_gzip.png
│   └── vuln_samples
│       ├── bash-cmd-exec.var
│       ├── bash-uninit-mem.var
│       ├── ffmpeg-h264-bad-ptr-800m.mp4
│       ├── ffmpeg-h264-bad-read.mp4
│       ├── ffmpeg-h264-call-stack-overflow.mp4
│       ├── firefox-bmp-leak.bmp
│       ├── firefox-chrome-leak.jpg
│       ├── firefox-gif-leak.gif
│       ├── firefox-gif-leak2.gif
│       ├── jxrlib-crash.jxr
│       ├── jxrlib-crash2.jxr
│       ├── jxrlib-crash3.jxr
│       ├── jxrlib-crash4.jxr
│       ├── lesspipe-cpio-bad-write.cpio
│       ├── libjpeg-sos-leak.jpg
│       ├── libjpeg-turbo-dht-leak.jpg
│       ├── libtiff-bad-write.tif
│       ├── libtiff-uninit-mem.tif
│       ├── libtiff-uninit-mem2.tif
│       ├── libtiff-uninit-mem3.tif
│       ├── libtiff-uninit-mem4.tif
│       ├── libxml2-bad-read.xml
│       ├── msie-dht-leak.jpg
│       ├── msie-jxr-mem-leak.jxr
│       ├── msie-png-mem-leak.png
│       ├── msie-tiff-mem-leak.tif
│       ├── msie-zlib-dos.png
│       ├── openssl-null-ptr.der
│       ├── openssl-null-ptr2.der
│       ├── photoshop-mem-leak.jpg
│       ├── sqlite-bad-free.sql
│       ├── sqlite-bad-ptr.sql
│       ├── sqlite-bad-ptr2.sql
│       ├── sqlite-bad-ptr3.sql
│       ├── sqlite-heap-overflow.sql
│       ├── sqlite-heap-overwrite.sql
│       ├── sqlite-negative-memset.sql
│       ├── sqlite-null-ptr1.sql
│       ├── sqlite-null-ptr10.sql
│       ├── sqlite-null-ptr11.sql
│       ├── sqlite-null-ptr12.sql
│       ├── sqlite-null-ptr13.sql
│       ├── sqlite-null-ptr14.sql
│       ├── sqlite-null-ptr15.sql
│       ├── sqlite-null-ptr2.sql
│       ├── sqlite-null-ptr3.sql
│       ├── sqlite-null-ptr4.sql
│       ├── sqlite-null-ptr5.sql
│       ├── sqlite-null-ptr6.sql
│       ├── sqlite-null-ptr7.sql
│       ├── sqlite-null-ptr8.sql
│       ├── sqlite-null-ptr9.sql
│       ├── sqlite-oob-read.sql
│       ├── sqlite-oob-write.sql
│       ├── sqlite-stack-buf-overflow.sql
│       ├── sqlite-stack-exhaustion.sql
│       ├── sqlite-unint-mem.sql
│       ├── sqlite-use-after-free.sql
│       ├── strings-stack-overflow
│       ├── tcpdump-arp-crash.pcap
│       ├── tcpdump-ppp-crash.pcap
│       ├── unrtf-arbitrary-read.rtf
│       └── unzip-t-mem-corruption.zip
├── afl_post_library
│   ├── CMakeLists.txt
│   └── post_library.c
├── alloc-inl.h
├── config.h
├── custom_net_fuzzer.c
├── custom_net_fuzzer.def
├── custom_winafl_server.c
├── custom_winafl_server.def
├── custom_winafl_server.h
├── debug.h
├── gdiplus.cpp
├── hash.h
├── ipttool.c
├── ipttool.h
├── modules.c
├── modules.h
├── ptdecode.c
├── ptdecode.h
├── readme_dr.md
├── readme_pt.md
├── readme_syzygy.md
├── readme_tinyinst.md
├── screenshots
│   ├── afl-fuzz.gif
│   ├── afl-instr.png
│   └── winafl-cmin.py.png
├── test.cpp
├── test_netmode.cpp
├── test_simple_winsock_client.cpp
├── test_static.cpp
├── testcases
│   ├── README.testcases
│   ├── _extras
│   │   ├── gif.dict
│   │   ├── html_tags.dict
│   │   ├── jpeg.dict
│   │   ├── js.dict
│   │   ├── pdf.dict
│   │   ├── png.dict
│   │   ├── sql.dict
│   │   ├── tiff.dict
│   │   ├── webp.dict
│   │   └── xml.dict
│   ├── archives
│   │   ├── common
│   │   │   ├── ar
│   │   │   │   └── small_archive.a
│   │   │   ├── bzip2
│   │   │   │   └── small_archive.bz2
│   │   │   ├── cab
│   │   │   │   └── small_archive.cab
│   │   │   ├── compress
│   │   │   │   └── small_archive.Z
│   │   │   ├── cpio
│   │   │   │   └── small_archive.cpio
│   │   │   ├── gzip
│   │   │   │   └── small_archive.gz
│   │   │   ├── lzo
│   │   │   │   └── small_archive.lzo
│   │   │   ├── rar
│   │   │   │   └── small_archive.rar
│   │   │   ├── tar
│   │   │   │   └── small_archive.tar
│   │   │   ├── xz
│   │   │   │   └── small_archive.xz
│   │   │   └── zip
│   │   │       └── small_archive.zip
│   │   └── exotic
│   │       ├── arj
│   │       │   └── small_archive.arj
│   │       ├── lha
│   │       │   └── small_archive.lha
│   │       ├── lrzip
│   │       │   └── small_archive.lrz
│   │       ├── lzip
│   │       │   └── small_archive.lz
│   │       ├── lzma
│   │       │   └── small_archive.lzma
│   │       ├── rzip
│   │       │   └── small_archive.rz
│   │       └── zoo
│   │           └── small_archive.zoo
│   ├── images
│   │   ├── bmp
│   │   │   └── not_kitty.bmp
│   │   ├── gif
│   │   │   └── not_kitty.gif
│   │   ├── ico
│   │   │   └── not_kitty.ico
│   │   ├── jp2
│   │   │   └── not_kitty.jp2
│   │   ├── jpeg
│   │   │   └── not_kitty.jpg
│   │   ├── jxr
│   │   │   └── not_kitty.jxr
│   │   ├── png
│   │   │   ├── not_kitty.png
│   │   │   ├── not_kitty_alpha.png
│   │   │   ├── not_kitty_gamma.png
│   │   │   └── not_kitty_icc.png
│   │   ├── tiff
│   │   │   └── not_kitty.tiff
│   │   └── webp
│   │       └── not_kitty.webp
│   ├── multimedia
│   │   └── h264
│   │       └── small_movie.mp4
│   ├── others
│   │   ├── js
│   │   │   └── small_script.js
│   │   ├── pcap
│   │   │   └── small_capture.pcap
│   │   ├── pdf
│   │   │   └── small.pdf
│   │   ├── rtf
│   │   │   └── small_document.rtf
│   │   ├── sql
│   │   │   └── simple_queries.sql
│   │   ├── text
│   │   │   └── hello_world.txt
│   │   └── xml
│   │       └── small_document.xml
│   └── tests
│       ├── big.txt
│       ├── bigalloc.txt
│       ├── crash.txt
│       ├── crash_gs.txt
│       ├── exception.txt
│       ├── hang.txt
│       ├── normal.txt
│       └── small.txt
├── third_party
│   ├── TinyInst
│   ├── processor-trace
│   └── winipt
├── tinyinst_afl.cpp
├── tinyinst_afl.h
├── tinyinst_covmap.cpp
├── tinyinst_covmap.h
├── types.h
├── utils.h
├── winafl-cmin.py
├── winafl-plot.py
├── winafl-whatsup.py
├── winafl.c
├── winaflpt-debug.c
├── winaflpt.c
└── winaflpt.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.6)

if (${USE_COLOR})
    add_definitions(-DUSE_COLOR)
endif()

if (${USE_DRSYMS})
    add_definitions(-DUSE_DRSYMS)
endif()

if (${INTELPT})
    add_definitions(-DINTELPT)
endif()

if (${INTELPT})
  add_subdirectory(third_party/processor-trace)
endif()

if (${TINYINST})
    add_definitions(-DTINYINST)
endif()

if (${TINYINST})
  add_subdirectory(third_party/TinyInst)
endif()

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

project(test)

add_executable(test
  test.cpp
  )

project(test_netmode)

add_executable(test_netmode test_netmode.cpp)

add_executable(test_servermode test_simple_winsock_client.cpp)

if(NOT ("${CMAKE_GENERATOR}" MATCHES "(Win64)" OR "${CMAKE_GENERATOR_PLATFORM}" MATCHES "(64)"))

  project(test_static)

  add_executable(test_static
    test_static.cpp
    afl-staticinstr.c
    )

  target_link_libraries(test_static "psapi.lib")

  set_target_properties(test_static PROPERTIES COMPILE_FLAGS "/EHsc")
  set_target_properties(test_static PROPERTIES LINK_FLAGS "/PROFILE")

endif()

project(test_gdiplus)

add_executable(test_gdiplus
  gdiplus.cpp
  )

target_link_libraries(test_gdiplus gdiplus)

project(afl-analyze)
add_executable(afl-analyze
  afl-analyze.c
  )

project(afl-showmap)

add_executable(afl-showmap
  afl-showmap.c
  )

if (${TINYINST})
  target_link_libraries(afl-showmap winafl_tinyinst)
endif()

project(afl-tmin)

add_executable(afl-tmin
  afl-tmin.c
  )

add_library(custom_winafl_server SHARED custom_winafl_server.c custom_winafl_server.def)

add_library(custom_net_fuzzer SHARED custom_net_fuzzer.c custom_net_fuzzer.def)

if (${INTELPT})

  project(winipt)

  include_directories(third_party/winipt/inc)

  ADD_LIBRARY(winipt STATIC
    ipttool.c
    third_party/winipt/libipt/win32.c
    )

  target_compile_definitions(winipt PRIVATE UNICODE _UNICODE)

  project(winaflpt-debug)

  include_directories(third_party/winipt/inc)
  include_directories(third_party/processor-trace/libipt/internal/include)
  include_directories(${CMAKE_CURRENT_BINARY_DIR}/third_party/processor-trace/libipt/include)

  SET(PT_ADDITIONAL_SOURCES
    winaflpt.c
    ptdecode.c
    third_party/processor-trace/libipt/src/pt_cpu.c
    third_party/processor-trace/libipt/src/windows/pt_cpuid.c
    )

  ADD_EXECUTABLE(winaflpt-debug
    winaflpt-debug.c
    ${PT_ADDITIONAL_SOURCES}
    )

  target_link_libraries(winaflpt-debug winipt)
  target_link_libraries(winaflpt-debug libipt)

  target_link_libraries(winaflpt-debug "psapi.lib")
  target_link_libraries(winaflpt-debug "Dbghelp.lib")

endif()

if (${TINYINST})
  ADD_LIBRARY(winafl_tinyinst STATIC
    tinyinst_covmap.h
    tinyinst_covmap.cpp
    tinyinst_afl.h
    tinyinst_afl.cpp
    )

  target_link_libraries(winafl_tinyinst tinyinst)
  target_link_libraries(winafl_tinyinst "onecore.lib")

endif()


project(afl-fuzz)

SET(AFL_FUZZ_SOURCES afl-fuzz.c)

if (${INTELPT})

  include_directories(third_party/winipt/inc)
  include_directories(third_party/processor-trace/libipt/internal/include)
  include_directories(${CMAKE_CURRENT_BINARY_DIR}/third_party/processor-trace/libipt/include)

  SET(AFL_FUZZ_SOURCES ${AFL_FUZZ_SOURCES} ${PT_ADDITIONAL_SOURCES})

endif()

add_executable(afl-fuzz
  ${AFL_FUZZ_SOURCES}
  )

if (${INTELPT})

  target_link_libraries(afl-fuzz winipt)
  target_link_libraries(afl-fuzz libipt)

  target_link_libraries(afl-fuzz "psapi.lib")
  target_link_libraries(afl-fuzz "Dbghelp.lib")

endif()

if (${TINYINST})
  target_link_libraries(afl-fuzz winafl_tinyinst)
endif()

if (NOT "${DynamoRIO_DIR}" STREQUAL "")

  project(WinAFL)

  set(DynamoRIO_LOG_COMPATIBILITY on)

  find_package(DynamoRIO)
  if (NOT DynamoRIO_FOUND)
    message(FATAL_ERROR "DynamoRIO package required to build")
  endif(NOT DynamoRIO_FOUND)

  if (STATIC_LIBRARY)
    set(libtype STATIC)
  else()
    set(libtype SHARED)
  endif ()

  add_library(winafl ${libtype}
    winafl.c
    modules.c
    )
  configure_DynamoRIO_client(winafl)
  use_DynamoRIO_extension(winafl drmgr)
  use_DynamoRIO_extension(winafl drx)
  use_DynamoRIO_extension(winafl drcontainers)
  use_DynamoRIO_extension(winafl drreg)
  use_DynamoRIO_extension(winafl drwrap)
  if (${USE_DRSYMS})
    use_DynamoRIO_extension(winafl drsyms)
  endif()

  # VS2015 Fix
  if (NOT (MSVC_VERSION LESS 1900))
    target_link_libraries(winafl "libucrt.lib")
    target_link_libraries(winafl "libvcruntime.lib")
  endif()

endif()

```

`CONTRIBUTING.md`:

```md
# How to contribute

We'd love to accept your patches and contributions to this project. There are
just a few small guidelines you need to follow.

## Contributor License Agreement

Contributions to any Google project must be accompanied by a Contributor License
Agreement. This is necessary because you own the copyright to your changes, even
after your contribution becomes part of this project. So this agreement simply
gives us permission to use and redistribute your contributions as part of the
project. Head over to <https://cla.developers.google.com/> to see your current
agreements on file or to sign a new one.

You generally only need to submit a CLA once, so if you've already submitted one
(even if it was for a different project), you probably don't need to do it
again.

## Code reviews

All submissions, including submissions by project members, require review. We
use GitHub pull requests for this purpose. Consult [GitHub Help] for more
information on using pull requests.

[GitHub Help]: https://help.github.com/articles/about-pull-requests/

```

`ChangeLog`:

```
=========
ChangeLog
=========

-----------------------------------
Version 1.16b (based on afl 2.43b):
-----------------------------------

  - Fixed an issue with Intel PT mode where target processes were not
    terminated properly.
    Reported by Jason Shirk
    
  - Added a port of afl-analyze
    Contributed by L4ys

  - DynamoRIO version update - started building prebuilt binaries with
    DynamoRIO 7.1
 
----------------------------------
Version 1.16 (based on afl 2.43b):
----------------------------------

  - Intel PT support.

  - Fix target_path in afl-showmap in drioless mode
    Contributed by L4ys

----------------------------------
Version 1.15 (based on afl 2.43b):
----------------------------------

  - Added -p flag which persists DynamoRIO cache across process restarts.
    This might have a slight positive impact on performance in some scenarios,
    such as where WinAFL persistece can't be used effectively, or
    with very complex targets.

  - Fix custom_net_fuzzer to avoid consuming system resources by
    unclosed sockets.
    Contributed by MostafaSoliman

----------------------------------
Version 1.14 (based on afl 2.43b):
----------------------------------
  
  - Added support for third-party DLLs for custom test cases processing
    This currently comes with (experimental) network fuzzing implementation
    (both server- and client- side)
    Contributed by Maksim Shudrak

  - New "In App Persistence" mode that relaxes target_method restrictions
    if the target process can be made to loop on its own
    Contributed by Guy Inbar
    
  - Implemented setup_post on Windows
    Contributed by Quang Nguyễn

  - Added separate timeout for process initialization and the first run
    Contributed by Netanel Ben Simon

  - Added color support to afl-showmap & afl-tmin
    Contributed by Yoav Alon

  - added winafl-plot.py a winafl replacement for afl-plot
    Contributed by Yoav Alon

  - added winafl-whatsup.py a winafl replacement for afl-whatsup
    Contributed by Yoav Alon

  - Fixed compilation issue on newer versions of DynamoRIO
    Contributed by Yoav Alon
    
  - Other minor fixes and improvements
    Contributed by L4ys, Yoav Alon, Netanel Ben Simon and others

----------------------------------
Version 1.13 (based on afl 2.43b):
----------------------------------

  - Added support for catching failfast-type issues
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team
  
  - Added support for catching Application Verifier errors
    Contributed by yoava333

  - Added support for processor affinity for afl-fuzz and target process
    Contributed by yoava333

  - Added support for ansi terminal on windows 10
    Contributed by yoava333

  - Make sure names of the output files generated by inafl-cmin.py are unique
    Contributed by x9090

  - Fixed a crash on zero sized input files
    Contributed by yoava333

  - Fixed a bug in load_extra that could cause errors or incorrect behavior when reading extras directory
  
  - Fixed a race condition where afl-fuzz could attempt to fuzz the target process while it was getting killed
  
  - fuzzer_pid now gets reported correctly in the fuzzer_stats file
    
----------------------------------
Version 1.12 (based on afl 2.43b):
----------------------------------

  - Windows port of afl-tmin
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team

----------------------------------
Version 1.11 (based on afl 2.43b):
----------------------------------

  - Add support for setting a memory limit (-m flag)
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team

----------------------------------
Version 1.10 (based on afl 2.43b):
----------------------------------

  - Add static instrumentation mode
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team

-----------------------------------
Version 1.09b (based on afl 2.43b):
-----------------------------------

  - Fixed slave mode (broken by 1.09 update)
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team

  - Fixed missing last_crash_time (broken by 1.09 update)
    Contributed by x9090

----------------------------------
Version 1.09 (based on afl 2.43b):
----------------------------------

  - Bringing WinAFL up to speed with AFL 2.43b
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team

  - Fixed a memory leak in fuzz_one
    Contributed by juanvazquez

----------------------------------
Version 1.08 (based on afl 1.96b):
----------------------------------

  - It is now possible to collect coverage only from a thread that executed
    target function using -thread_coverage flag

  - When -target_method flag is used, symbols are now looked up from pdb files
    in addition to exported symbols

  - Added a missing call to classify_counts() from run_target()

----------------------------------
Version 1.07 (based on afl 1.96b):
----------------------------------

  - Previous_offset is now stored in TLS.
    Edge coverage for multithreaded targets should now be more usable.

----------------------------------
Version 1.06 (based on afl 1.96b):
----------------------------------

  - Windows port of afl-cmin
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team
  - Use exe_name instead of the preferred name
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team
  - Add option to choose the calling convention
    Contributed by shawndenbow
  - Fix for building on VS2015
    Contributed by b1ack0wl

----------------------------------
Version 1.05 (based on afl 1.96b):
----------------------------------

  - Windows port of afl-showmap
    Contributed by Axel "0vercl0k" Souchet of MSRC Vulnerabilities and Mitigations Team
  - Expaded README a bit.

----------------------------------
Version 1.04 (based on afl 1.96b):
----------------------------------

  Various fixes / improvements contributed by Axel "0vercl0k" Souchet:
  - Mute stdout/stderr unless AFL_NO_SINKHOLE env variable is set.
  - Allow several slaveless instances to be run on the same machine.
  - Fix getopt to properly handle options without parameters.
  - Automatically remove the child pid file.
  - Case insensitive module name comparison.
  - More debugging messages.

----------------------------------
Version 1.03 (based on afl 1.96b):
----------------------------------

  - Fixed dictionary loading.
	Reported by Hugo Meier.

----------------------------------
Version 1.02 (based on afl 1.96b):
----------------------------------

  - Fixed incorrect quoting of target command line arguments.

  - Debug mode now reports encountered exceptions.

----------------------------------
Version 1.01 (based on afl 1.96b):
----------------------------------

  - Fixed a bug where previous offset wasn't updated in the edge coverage
    instrumentation mode. This effectively caused edge coverage to behave
	the same as basic block coverage.
	Reported by Rodrigo Axel Monroy.

  - Changed the default coverage mode to basic block in order for the default
    configuration to work better with muti-threaded apps.

  - Added -no_follow_children to DR runtime flags. This can fix problems if the
    target process creates a child process.

  - More data in now written to the debug log

----------------------------------
Version 1.00 (based on afl 1.96b):
----------------------------------

  - Initial release.

```

`LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2016 Google Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# WinAFL

```
   Original AFL code written by Michal Zalewski <lcamtuf@google.com>

   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

## Background

AFL is a popular fuzzing tool for coverage-guided fuzzing. The tool combines
fast target execution with clever heuristics to find new execution paths in
the target binary. It has been successfully used to find a large number of
vulnerabilities in real products. For more info about the original project,
please refer to the original documentation at:

http://lcamtuf.coredump.cx/afl/

Unfortunately, the original AFL does not work on Windows due to very
*nix-specific design (e.g. instrumentation, forkserver etc.). This project is
a fork of AFL that uses different instrumentation approach which works on
Windows even for black box binary fuzzing.

## The WinAFL approach

Instead of instrumenting the code at compilation time, WinAFL supports the
following instrumentation modes:
 - Dynamic instrumentation using DynamoRIO (http://dynamorio.org/)
 - Dynamic instrumentation using TinyInst (https://github.com/googleprojectzero/TinyInst)
 - Hardware tracing using Intel PT
 - Static instrumentation via Syzygy

These instrumentation modes are described in more detail in the separate
documents.

<p align="center">
<img alt="afl-fuzz.exe" src="screenshots/afl-fuzz.gif"/>
</p>

To improve the process startup time, WinAFL relies heavily on persistent
fuzzing mode, that is, executing multiple input samples without restarting the
target process. This is accomplished by selecting a target function (that the
user wants to fuzz) and instrumenting it so that it runs in a loop.

#### Known CVEs

WinAFL has been successfully used to identify bugs in Windows software, such as the following:

| Software | Bugs | Found by |
| - | - | - |
| Adobe | [CVE-2018-4985](https://cpr-zero.checkpoint.com/vulns/cprid-2046/), [CVE-2018-5063](https://cpr-zero.checkpoint.com/vulns/cprid-2047/), [CVE-2018-5064](https://cpr-zero.checkpoint.com/vulns/cprid-2048/), [CVE-2018-5065](https://cpr-zero.checkpoint.com/vulns/cprid-2049/), [CVE-2018-5068](https://cpr-zero.checkpoint.com/vulns/cprid-2050/), [CVE-2018-5069](https://cpr-zero.checkpoint.com/vulns/cprid-2051/), [CVE-2018-5070](https://cpr-zero.checkpoint.com/vulns/cprid-2052/), [CVE-2018-12754](https://cpr-zero.checkpoint.com/vulns/cprid-2053/), [CVE-2018-12755](https://cpr-zero.checkpoint.com/vulns/cprid-2054/), [CVE-2018-12764](https://cpr-zero.checkpoint.com/vulns/cprid-2055/), [CVE-2018-12765](https://cpr-zero.checkpoint.com/vulns/cprid-2056/), [CVE-2018-12766](https://cpr-zero.checkpoint.com/vulns/cprid-2057/), [CVE-2018-12767](https://cpr-zero.checkpoint.com/vulns/cprid-2058/), [CVE-2018-12768](https://cpr-zero.checkpoint.com/vulns/cprid-2059/), [CVE-2018-12839](https://cpr-zero.checkpoint.com/vulns/cprid-2060/), [CVE-2018-12840](https://cpr-zero.checkpoint.com/vulns/cprid-2061/), [CVE-2018-12848](https://cpr-zero.checkpoint.com/vulns/cprid-2062/), [CVE-2018-12849](https://cpr-zero.checkpoint.com/vulns/cprid-2063/), [CVE-2018-12850](https://cpr-zero.checkpoint.com/vulns/cprid-2064/), [CVE-2018-12857](https://cpr-zero.checkpoint.com/vulns/cprid-2065/), [CVE-2018-12859](https://cpr-zero.checkpoint.com/vulns/cprid-2066/), [CVE-2018-12860](https://cpr-zero.checkpoint.com/vulns/cprid-2067/), [CVE-2018-12861](https://cpr-zero.checkpoint.com/vulns/cprid-2068/), [CVE-2018-12862](https://cpr-zero.checkpoint.com/vulns/cprid-2069/), [CVE-2018-12863](https://cpr-zero.checkpoint.com/vulns/cprid-2070/), [CVE-2018-12864](https://cpr-zero.checkpoint.com/vulns/cprid-2071/), [CVE-2018-12865](https://cpr-zero.checkpoint.com/vulns/cprid-2072/), [CVE-2018-12866](https://cpr-zero.checkpoint.com/vulns/cprid-2073/), [CVE-2018-12867](https://cpr-zero.checkpoint.com/vulns/cprid-2074/), [CVE-2018-12869](https://cpr-zero.checkpoint.com/vulns/cprid-2075/), [CVE-2018-12870](https://cpr-zero.checkpoint.com/vulns/cprid-2076/), [CVE-2018-12871](https://cpr-zero.checkpoint.com/vulns/cprid-2077/), [CVE-2018-12872](https://cpr-zero.checkpoint.com/vulns/cprid-2078/), [CVE-2018-12873](https://cpr-zero.checkpoint.com/vulns/cprid-2079/), [CVE-2018-12874](https://cpr-zero.checkpoint.com/vulns/cprid-2080/), [CVE-2018-12875](https://cpr-zero.checkpoint.com/vulns/cprid-2081/), [CVE-2018-15927](https://cpr-zero.checkpoint.com/vulns/cprid-2082/), CVE-2018-15928, [CVE-2018-15929](https://cpr-zero.checkpoint.com/vulns/cprid-2083/), [CVE-2018-15930](https://cpr-zero.checkpoint.com/vulns/cprid-2084/), [CVE-2018-15931](https://cpr-zero.checkpoint.com/vulns/cprid-2085/), [CVE-2018-15932](https://cpr-zero.checkpoint.com/vulns/cprid-2086/), [CVE-2018-15933](https://cpr-zero.checkpoint.com/vulns/cprid-2087/), [CVE-2018-15934](https://cpr-zero.checkpoint.com/vulns/cprid-2088/), [CVE-2018-15935](https://cpr-zero.checkpoint.com/vulns/cprid-2089/), [CVE-2018-15936](https://cpr-zero.checkpoint.com/vulns/cprid-2090/), [CVE-2018-15937](https://cpr-zero.checkpoint.com/vulns/cprid-2091/), [CVE-2018-15938](https://cpr-zero.checkpoint.com/vulns/cprid-2092/), [CVE-2018-15952](https://cpr-zero.checkpoint.com/vulns/cprid-2093/), [CVE-2018-15953](https://cpr-zero.checkpoint.com/vulns/cprid-2094/), [CVE-2018-15954](https://cpr-zero.checkpoint.com/vulns/cprid-2095/), [CVE-2018-15955](https://cpr-zero.checkpoint.com/vulns/cprid-2096/), [CVE-2018-15956](https://cpr-zero.checkpoint.com/vulns/cprid-2097/) | Yoav Alon ([@yoavalon](https://twitter.com/yoavalon)) and Netanel Ben-Simon ([@NetanelBenSimon](https://twitter.com/netanelbensimon)) of Check Point Software Technologies
| Adobe | CVE-2018-12853, CVE-2018-16024, CVE-2018-16023, CVE-2018-15995 | Guy Inbar ([@guyio_](https://twitter.com/guyio_))
| Adobe | CVE-2018-16004, CVE-2018-16005, CVE-2018-16007, CVE-2018-16009, CVE-2018-16010, CVE-2018-16043, CVE-2018-16045, CVE-2018-16046, CVE-2018-19719, CVE-2018-19720, CVE-2019-7045 | Sebastian Apelt ([@bitshifter123](https://twitter.com/bitshifter123))
| Microsoft | [CVE-2016-7212](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2016-7212) | Aral Yaman of Noser Engineering AG
| Microsoft | [CVE-2017-0073](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0073), [CVE-2017-0190](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0190), [CVE-2017-11816](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-11816), [CVE-2018-8472](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2018-8472), [CVE-2019-1311](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-1311) | Symeon Paraschoudis ([@symeonp](https://twitter.com/symeonp))
| Microsoft | [CVE-2018-8494](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2018-8494) | Guy Inbar ([@guyio_](https://twitter.com/guyio_))
| Microsoft | [CVE-2018-8464](https://cpr-zero.checkpoint.com/vulns/cprid-2098/) | Yoav Alon ([@yoavalon](https://twitter.com/yoavalon)) and Netanel Ben-Simon ([@NetanelBenSimon](https://twitter.com/netanelbensimon)) of Check Point Research
| Microsoft | [CVE-2019-0538](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0538), [CVE-2019-0576](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0576), [CVE-2019-0577](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0577), [CVE-2019-0579](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0579), [CVE-2019-0580](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0580), [CVE-2019-0879](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0879), [CVE-2019-0889](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0889), [CVE-2019-0891](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0891), [CVE-2019-0899](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0899), [CVE-2019-0902](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0902), [CVE-2019-1243](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-1243), [CVE-2019-1250](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-1250), [CVE-2020-0687](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0687), [CVE-2020-0744](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0744), [CVE-2020-0879](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0879), [CVE-2020-0964](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0964), [CVE-2020-0995](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0995), [CVE-2020-1141](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1141), [CVE-2020-1145](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1145), [CVE-2020-1160](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1160), [CVE-2020-1179](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1179), [CVE-2021-1665](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/analyzing-cve-2021-1665-remote-code-execution-vulnerability-in-windows-gdi/) | Hardik Shah ([@hardik05](https://twitter.com/hardik05)) of McAfee
| Microsoft | [CVE-2021-42276](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-42276), [CVE-2021-28350](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-28350), [CVE-2021-28349](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-28349), [CVE-2021-28348](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-28348) | Simon Barsky ([expend20](https://twitter.com/expend20))
| Microsoft | [CVE-2022-21903](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-21903), [CVE-2022-21904](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_setdibitstodevice-record/), [CVE-2022-21915](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_stretchdibits-record/), [CVE-2022-26934](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_createdibpatternbrushpt-record/), [CVE-2022-29112](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_bitblt-record/), [CVE-2022-35837](https://www.seljan.hu/posts/arbitrary-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_startdoc-record/), [CVE-2022-34728](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_setpixelv-record/), [CVE-2022-38006](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_stretchdibits-record-again/), [CVE-2025-30388](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-30388), [CVE-2025-47984](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-47984), [CVE-2025-53766](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-53766) | [Gábor Selján](https://twitter.com/GaborSeljan)
| Microsoft | [CVE-2021-38665](https://thalium.github.io/blog/posts/leaking-aslr-through-rdp-printer-cache-registry/), [CVE-2021-38666](https://thalium.github.io/blog/posts/deserialization-bug-through-rdp-smart-card-extension/) | Valentino Ricotta with Thalium
| Microsoft | [CVE-2022-26929](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-26929), [CVE-2022-30130](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-30130) | Eran Zimmerman Gonen ([@3r4nz](https://twitter.com/3r4nz))
| FreeRDP | [CVE-2021-37594](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-37594), [CVE-2021-37595](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-37595) | Valentino Ricotta with Thalium
| Kollective | CVE-2018-11672 | Maksim Shudrak ([@MShudrak](https://twitter.com/MShudrak)) of Salesforce
| Mozilla | [CVE-2018-5177](https://bugzilla.mozilla.org/show_bug.cgi?id=1451908) | Guy Inbar ([@guyio_](https://twitter.com/guyio_))
| libxml2 | CVE-2018-14404 | Guy Inbar ([@guyio_](https://twitter.com/guyio_))
| WinRAR | [CVE-2018-20250, CVE-2018-20251, CVE-2018-20252, CVE-2018-20253](https://research.checkpoint.com/2019/extracting-code-execution-from-winrar/) | Nadav Grossman ([@NadavGrossman](https://twitter.com/NadavGrossman)) of Check Point Software Technologies
| XnView | [CVE-2019-13083](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x384e2a.md), [CVE-2019-13084](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x26b739.md), [CVE-2019-13085](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x30ecfa.md), [CVE-2019-13253](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000385474.md), [CVE-2019-13254](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x000000000032e808.md), [CVE-2019-13255](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000327464.md), [CVE-2019-13256](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x000000000032e849.md), [CVE-2019-13257](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x00000000003273aa.md), [CVE-2019-13258](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000328165.md), [CVE-2019-13259](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x000000000032e566.md), [CVE-2019-13260](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000327a07.md), [CVE-2019-13261](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000328384.md), [CVE-2019-13262](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x00000000003283eb.md) | [@expend20](https://twitter.com/expend20) and Anton Kukoba of Apriorit
| IrfanView | [CVE-2019-13242](https://github.com/apriorit/pentesting/blob/master/bugs/irfanview/0x0000000000013a98.md), [CVE-2019-13243](https://github.com/apriorit/pentesting/blob/master/bugs/irfanview/0x00000000000249c6.md) | [@expend20](https://twitter.com/expend20) and Anton Kukoba of Apriorit
| FastStone | [CVE-2019-13244](https://github.com/apriorit/pentesting/blob/master/bugs/fsview/0x0000000000002d7d.md), [CVE-2019-13245](https://github.com/apriorit/pentesting/blob/master/bugs/fsview/0x00000000001a95b1.md), [CVE-2019-13246](https://github.com/apriorit/pentesting/blob/master/bugs/fsview/0x00000000001a9601.md) | [@expend20](https://twitter.com/expend20) and Anton Kukoba of Apriorit
| FastStone | [CVE-2024-9112](https://www.zerodayinitiative.com/advisories/ZDI-24-1273/), [CVE-2024-9113](https://www.zerodayinitiative.com/advisories/ZDI-24-1274/), [CVE-2024-9114](https://www.zerodayinitiative.com/advisories/ZDI-24-1275/) | [@zeze7w](https://x.com/zeze7w) with TeamT5
| ACDSee | [CVE-2019-13247](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000000024ed.md), [CVE-2019-13248](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x0000000000002450.md), [CVE-2019-13249](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000000b9e7a.md), [CVE-2019-13250](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000000b9c2f.md), [CVE-2019-13251](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000000c47ff.md), [CVE-2019-13252](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000001172b0.md), [CVE-2019-15293](https://www.apriorit.com/dev-blog/640-qa-fuzzing-for-closed-source-windows-software) | [@expend20](https://twitter.com/expend20) and Anton Kukoba of Apriorit
| Foxit | [CVE-2019-13330](https://www.zerodayinitiative.com/advisories/ZDI-19-853/), [CVE-2019-13331](https://www.zerodayinitiative.com/advisories/ZDI-19-854/), [CVE-2020-8844](https://www.zerodayinitiative.com/advisories/ZDI-20-200/) | Natnael Samson ([@NattiSamson](https://twitter.com/NattiSamson))
| Rockwell Automation | [CVE-2020-12034, CVE-2020-12038](https://www.us-cert.gov/ics/advisories/icsa-20-140-01) | [Sharon Brizinov](https://sharonbrizinov.com/) and Amir Preminger of Claroty
| F-Secure & WithSecure | CVE-2021-33599, CVE-2021-33602, CVE-2021-40836, CVE-2021-40837, CVE-2022-28875, CVE-2022-28876, CVE-2022-28879, CVE-2022-28881, CVE-2022-28882, CVE-2022-28883, CVE-2022-28884, CVE-2022-28886, CVE-2022-28887 | [@faty420](https://twitter.com/faty420)

(Let me know if you know of any others, and I'll include them in the list)

## Building WinAFL

1. If you are building with DynamoRIO support, download and build
DynamoRIO sources or download DynamoRIO Windows binary package from
https://github.com/DynamoRIO/dynamorio/releases

2. If you are building with Intel PT support, pull third party dependencies by running `git submodule update --init --recursive` from the WinAFL source directory

3. Open Visual Studio Command Prompt (or Visual Studio x64 Win64 Command Prompt
if you want a 64-bit build). Note that you need a 64-bit winafl.dll build if
you are fuzzing 64-bit targets and vice versa.

4. Go to the directory containing the source

5. Type the following commands. Modify the -DDynamoRIO_DIR flag to point to the
location of your DynamoRIO cmake files (either full path or relative to the
source directory).

### For a 32-bit build:

```
mkdir build32
cd build32
cmake -G"Visual Studio 16 2019" -A Win32 .. -DDynamoRIO_DIR=C:\path\to\DynamoRIO\cmake -DINTELPT=1
cmake --build . --config Release
```

### For a 64-bit build:

```
mkdir build64
cd build64
cmake -G"Visual Studio 16 2019" -A x64 .. -DDynamoRIO_DIR=C:\path\to\DynamoRIO\cmake -DINTELPT=1
cmake --build . --config Release
```

### Build configuration options

The following cmake configuration options are supported:

 - `-DDynamoRIO_DIR=..\path\to\DynamoRIO\cmake` - Needed to build the
   winafl.dll DynamoRIO client

 - `-DTINYINST=1` - Enable TinyInst mode. For more information see
   https://github.com/googleprojectzero/winafl/blob/master/readme_tinyinst.md

 - `-DINTELPT=1` - Enable Intel PT mode. For more information see
   https://github.com/googleprojectzero/winafl/blob/master/readme_pt.md

 - `-DUSE_COLOR=1` - color support (Windows 10 Anniversary edition or higher)

 - `-DUSE_DRSYMS=1` - Drsyms support (use symbols when available to obtain
   -target_offset from -target_method). Enabling this has been known to cause
   issues on Windows 10 v1809, though there are workarounds,
   see https://github.com/googleprojectzero/winafl/issues/145

## Using WinAFL

The command line for afl-fuzz on Windows is different than on Linux. Instead of:

```
%s [ afl options ] -- target_cmd_line
```

it now looks like this:

```
afl-fuzz [afl options] -- [instrumentation options] -- target_cmd_line
```

The following afl-fuzz options are supported:

```
  -i dir        - input directory with test cases
  -o dir        - output directory for fuzzer findings
  -t msec       - timeout for each run
  -s            - deliver sample via shared memory
  -D dir        - directory containing DynamoRIO binaries (drrun, drconfig)
  -w path       - path to winafl.dll
  -e            - expert mode to run WinAFL as a DynamoRIO tool
  -P            - use Intel PT tracing mode
  -Y            - enable the static instrumentation mode
  -f file       - location read by the fuzzed program
  -m limit      - memory limit for the target process
  -p            - persist DynamoRIO cache across target process restarts
  -c cpu        - the CPU to run the fuzzed program
  -d            - quick & dirty mode (skips deterministic steps)
  -n            - fuzz without instrumentation (dumb mode)
  -x dir        - optional fuzzer dictionary
  -I msec       - timeout for process initialization and first run
  -T text       - text banner to show on the screen
  -M \\ -S id   - distributed mode
  -C            - crash exploration mode (the peruvian rabbit thing)
  -l path       - a path to user-defined DLL for custom test cases processing
  -A module     - a module identifying a unique process to attach to
```

Please refer to the original AFL documentation for more info on these flags.

To see the supported instrumentation flags, please refer to the documentation
on the specific instrumentation mode you are interested in (see "Instrumentation modes" below).

## How does my target run under WinAFL

When you select a target function and fuzz an application the following happens:

1. Your target runs normally until your target function is reached.
2. WinAFL starts recording coverage
3. Your target function runs until return
4. WinAFL reports coverage, rewrites the input file and patches EIP
   so that the execution jumps back to step 2
5. After your target function runs for the specified number of iterations,
   the target process is killed and restarted. Note that anything that runs
   after the target function returns is never reached.

## How to select a target function

The target function should do these things during its lifetime:

1. Open the input file. This needs to happen within the target function so
   that you can read a new input file for each iteration as the input file is
   rewritten between target function runs.
2. Parse it (so that you can measure coverage of file parsing)
3. Close the input file. This is important because if the input file is
   not closed WinAFL won't be able to rewrite it.
4. Return normally (So that WinAFL can "catch" this return and redirect
   execution. "returning" via ExitProcess() and such won't work)

## Instrumentation modes

The following documents provide information on using different instrumentation
modes with WinAFL:

 - [Dynamic instrumentation using DynamoRIO](https://github.com/googleprojectzero/winafl/blob/master/readme_dr.md)
 - [Dynamic instrumentation using TinyInst](https://github.com/googleprojectzero/winafl/blob/master/readme_tinyinst.md)
 - [Hardware tracing using Intel PT](https://github.com/googleprojectzero/winafl/blob/master/readme_pt.md)
 - [Static instrumentation via Syzygy](https://github.com/googleprojectzero/winafl/blob/master/readme_syzygy.md)

Before using WinAFL for the first time, you should read the documentation for
the specific instrumentation mode you are interested in. These also contain
usage examples.

## Attaching to a running process

The DynamoRIO instrumentation mode supports dynamically attaching to running processes. This option can be used to fuzz processes that cannot be directly launched by WinAFL, such as system services.

To use it, specify the `-A <module>` option to `afl-fuzz.exe`, where `<module>` is the name of a module loaded only by the target process (if the module is loaded by more than one process WinAFL will terminate).

WinAFL will attach to the target process, and fuzz it normally. When the target process terminates (regardless of the reason), WinAFL will not restart it, but simply try to reattach. It is assumed that the target process will be restarted by an external script (or by the system itself). If WinAFL will not find the new target process within 10 seconds, it will terminate.

## Sample delivery via shared memory

WinAFL supports delivering samples via shared memory (as opposed to via a file, which is the default). This can be enabled by giving `-s` option to `afl-fuzz.exe`. Shared memory is faster and can avoid some problems with files (e.g. unable to overwrite the sample file because a target maintains a lock on it). 
If you are using shared memory for sample delivery then you need to make sure that in your harness you specifically read data from shared memory instead of file. Check a simple harness here:

https://github.com/googleprojectzero/Jackalope/blob/6d92931b2cf614699e2a023254d5ee7e20f6e34b/test.cpp#L41  
https://github.com/googleprojectzero/Jackalope/blob/6d92931b2cf614699e2a023254d5ee7e20f6e34b/test.cpp#L111  

## Corpus minimization

WinAFL includes the windows port of afl-cmin in winafl-cmin.py. Please run the
below command to see the options and usage examples:

```
D:\Codes\winafl>python winafl-cmin.py -h
[...]
Examples of use:
 * Typical use
  winafl-cmin.py -D D:\DRIO\bin32 -t 100000 -i in -o minset -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@

 * Dry-run, keep crashes only with 4 workers with a working directory:
  winafl-cmin.py -C --dry-run -w 4 --working-dir D:\dir -D D:\DRIO\bin32 -t 10000 -i in -i C:\fuzz\in -o out_mini -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@

 * Read from specific file
  winafl-cmin.py -D D:\DRIO\bin32 -t 100000 -i in -o minset -f foo.ext -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@

 * Read from specific file with pattern
  winafl-cmin.py -D D:\DRIO\bin32 -t 100000 -i in -o minset -f prefix-@@-foo.ext -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@

 * Typical use with static instrumentation
   winafl-cmin.py -Y -t 100000 -i in -o minset -- test.exe @@
```

<p align="center">
<img alt="winafl-cmin.py" src="screenshots/winafl-cmin.py.png"/>
</p>

## Custom test cases processing

WinAFL supports third party DLLs that can be used to define custom test-cases processing (e.g. to send test cases over network). To enable this option, you need to specify ```-l <path>``` argument.
The DLL should export the following two functions:
```
dll_init()
dll_run(char *data, long size, int fuzz_iterations)
data - content of test case
size - size of test case
fuzz_iterations - defines a current fuzzing iteration number
```

We have implemented two sample DLLs for network-based applications fuzzing that you can customize for your own purposes.

### Network fuzzing

WinAFL's ```custom_net_fuzzer.dll``` allows winAFL to perform network-based applications fuzzing that receive and parse network data. There are several options supported by this DLL that should be provided via the environment variable ```AFL_CUSTOM_DLL_ARGS```:

```
  -a IP address - IP address to send data in
  -U            - use UDP protocol instead of TCP to send data (default TCP)
  -p port       - port to send data in
  -w msec       - delay in milliseconds before actually start fuzzing
```
For example, if your application receives network packets via UDP protocol at port 7714 you should set up the environment variable in the following way: ```set AFL_CUSTOM_DLL_ARGS=-U -p 7714 -a 127.0.0.1 -w 1000 ```

You still need to find target function and make sure that this function receives data from the network, parses it, and returns normally. Also, you can use In App Persistence mode described above if your application runs the target function in a loop by its own.

Additionally, this mode is considered as experimental since we have experienced some problems with stability and performance. However, we found this option very useful and managed to find several vulnerabilities in network-based applications (e.g. in Kollective Kontiki listed above).

There is a second DLL ```custom_winafl_server.dll``` that allows winAFL to act as a server and perform fuzzing of client-based applications. All you need is to set up the port to listen on for incoming connections from your target application. The environment variable ```AFL_CUSTOM_DLL_ARGS=<port_id>``` should be used for this purpose.

#### Note

In case of server fuzzing, if the server socket has the `SO_REUSEADDR` option set like the following code, then this may case `10055` error after some time fuzzing due to the accumulation of `TIME_WAIT` sockets when WinAFL restart the fuzzing process. 
```
setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(int));
```

To avoid this, replace the `SO_REUSEADDR` option by `SO_LINGER` option in the server source code if available.
```
setsockopt(s, SOL_SOCKET, SO_LINGER, (char*)&opt, sizeof(int));
```

## Custom mutators

WinAFL supports loading a custom mutator from a third-party DLL.  You need to implement `dll_mutate_testcase` or `dll_mutate_testcase_with_energy` in your DLL and provide the DLL path to WinAFL via `-l <path>` argument.  WinAFL invokes the custom mutator before all the built-in mutations, and the custom mutator can skip all the built-in mutations by returning a non-zero value.  The `dll_mutate_testcase_with_energy` function is additionally provided an energy value that is equivalent to the number of iterations expected to run in the havoc stage without deterministic mutations. The custom mutator should invoke `common_fuzz_stuff` to run and make WinAFL aware of each new test case.  Below is an example mutator that increments every byte by one: 

```c
u8 dll_mutate_testcase(char **argv, u8 *buf, u32 len, u8 (*common_fuzz_stuff)(char**, u8*, u32))
{
    u8 bailout = 0;
    u8 *newbuf;
    u32 i;
    // duplicate the input buffer
    newbuf = malloc(len);
    if (!newbuf) return bailout;
    memcpy(newbuf, buf, len);
    // increment every byte by one and call common_fuzz_stuff for every new test case
    for (i = 0; i < len; i++) {
       newbuf[i] += 1;
       if (common_fuzz_stuff(argv, newbuf, len)) {
           bailout = 1; // skip the rest of the mutation per common_fuzz_stuff
           break;
       }
    }
    free(newbuf);
    return bailout;
}
```

## FAQ

```
Q: WinAFL reports timeouts while processing initial testcases.
A: You should run your target in debug mode first (-debug flag) and only
   run WinAFL once you get a message in the debug log that everything
   appears to be running normally.

Q: WinAFL runs slower than expected
A: This can commonly happen for several reasons
 - Your target function loads a dll for every iteration. This causes
   DynamoRIO to translate the same code for every iteration which causes
   slowdowns. You will be able to see this in the debug log. To
   resolve, select (or write) your target function differently.
 - Your target function does not close the input file properly, which
   causes WinAFL to kill the process in order to rewrite it. Please refer to
   "How to select a target function" for what a target function should look like.

Q: Can I fuzz DLLs with WinAFL
A: Yes, if you can write a harness that loads a library and runs some
   function within. Write your target function according to "How to select
   a target function" and for best performance, load the dll outside of
   your target function (see the previous question).

Q: Can I fuzz GUI apps with WinAFL
A: Yes, provided that
 - There is a target function that behaves as explained in "How to select
   a target function"
 - The target function is reachable without user interaction
 - The target function runs and returns without user interaction
 If these conditions are not satisfied, you might need to make custom changes
 to WinAFL and/or your target.
```

## Special Thanks

Special thanks to Axel "[0vercl0k](https://twitter.com/0vercl0k)" Souchet of MSRC Vulnerabilities and
Mitigations Team for his contributions!

```

`afl-analyze.c`:

```c
/*
   american fuzzy lop - file format analyzer
   -----------------------------------------

   Written and maintained by Michal Zalewski <lcamtuf@google.com>

   Windows fork written by @_L4ys

   Based on afl-showmap by Axel "0vercl0k" Souchet <0vercl0k@tuxfamily.org>

   Copyright 2016, 2017 Google Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   A nifty utility that grabs an input file and takes a stab at explaining
   its structure by observing how changes to it affect the execution path.

   If the output scrolls past the edge of the screen, pipe it to 'less -r'.

 */

#define _CRT_SECURE_NO_WARNINGS
#define _CRT_RAND_S
#define VERSION             "2.52b"

#define AFL_MAIN

#include <windows.h>

#include "config.h"
#include "types.h"
#include "debug.h"
#include "alloc-inl.h"
#include "hash.h"

#include <io.h>
#include <direct.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <ctype.h>

#include <sys/stat.h>

static s32 child_pid;                 /* PID of the tested program         */

static HANDLE child_handle,
child_thread_handle;
static char *dynamorio_dir;
static char *client_params;

static CRITICAL_SECTION critical_section;
static u64 watchdog_timeout_time;
static u8 watchdog_enabled;
static u8 *target_cmd;                /* command line of target           */

static HANDLE shm_handle;             /* Handle of the SHM region         */
static HANDLE pipe_handle;            /* Handle of the name pipe          */
static u64    name_seed;              /* Random integer to have a unique shm/pipe name */
static HANDLE devnul_handle;          /* Handle of the nul device         */
static u8     sinkhole_stds = 1;      /* Sink-hole stdout/stderr messages?*/
static char   *fuzzer_id = NULL;      /* The fuzzer ID or a randomized
                                         seed allowing multiple instances */

static u8* trace_bits;                /* SHM with instrumentation bitmap   */

static u8 *in_file,                   /* Analyzer input test case          */
          *prog_in,                   /* Targeted program input file       */
          *target_path,               /* Path to target binary             */
          *doc_path;                  /* Path to docs                      */

static u8 *in_data;                   /* Input data for analysis           */

static u32 in_len,                    /* Input data length                 */
           orig_cksum,                /* Original checksum                 */
           total_execs,               /* Total number of execs             */
           exec_hangs,                /* Total number of hangs             */
           exec_tmout = EXEC_TIMEOUT; /* Exec timeout (ms)                 */

static u64 mem_limit = MEM_LIMIT;     /* Memory limit (MB)                 */

static s32 shm_id,                    /* ID of the SHM region              */
           dev_null_fd = -1;          /* FD to /dev/null                   */

static u8  edges_only,                /* Ignore hit counts?                */
           use_hex_offsets,           /* Show hex offsets?                 */
           use_stdin = 1,             /* Use stdin for program input?      */
           drioless = 0;              /* Running without DRIO?             */


static volatile u8
           stop_soon,                 /* Ctrl-C pressed?                   */
           child_timed_out;           /* Child timed out?                  */


/* Constants used for describing byte behavior. */

#define RESP_NONE       0x00          /* Changing byte is a no-op.         */
#define RESP_MINOR      0x01          /* Some changes have no effect.      */
#define RESP_VARIABLE   0x02          /* Changes produce variable paths.   */
#define RESP_FIXED      0x03          /* Changes produce fixed patterns.   */

#define RESP_LEN        0x04          /* Potential length field            */
#define RESP_CKSUM      0x05          /* Potential checksum                */
#define RESP_SUSPECT    0x06          /* Potential "suspect" blob          */


/* Classify tuple counts. This is a slow & naive version, but good enough here. */
#define AREP4(_sym)   (_sym), (_sym), (_sym), (_sym)
#define AREP8(_sym)   AREP4(_sym), AREP4(_sym)
#define AREP16(_sym)  AREP8(_sym), AREP8(_sym)
#define AREP32(_sym)  AREP16(_sym), AREP16(_sym)
#define AREP64(_sym)  AREP32(_sym), AREP32(_sym)
#define AREP128(_sym) AREP64(_sym), AREP64(_sym)
static u8 count_class_lookup[256] = {

  /* 0 - 3:       4 */ 0, 1, 2, 4,
  /* 4 - 7:      +4 */ AREP4(8),
  /* 8 - 15:     +8 */ AREP8(16),
  /* 16 - 31:   +16 */ AREP16(32),
  /* 32 - 127:  +96 */ AREP64(64), AREP32(64),
  /* 128+:     +128 */ AREP128(128)

};

static void classify_counts(u8* mem) {

  u32 i = MAP_SIZE;

  if (edges_only) {

    while (i--) {
      if (*mem) *mem = 1;
      mem++;
    }

  } else {

    while (i--) {
      *mem = count_class_lookup[*mem];
      mem++;
    }

  }

}


/* See if any bytes are set in the bitmap. */

static inline u8 anything_set(void) {

  u32* ptr = (u32*)trace_bits;
  u32  i   = (MAP_SIZE >> 2);

  while (i--) if (*(ptr++)) return 1;

  return 0;

}


/* Get unix time in milliseconds */

static u64 get_cur_time(void) {

    u64 ret;
    FILETIME filetime;
    GetSystemTimeAsFileTime(&filetime);

    ret = (((u64)filetime.dwHighDateTime) << 32) + (u64)filetime.dwLowDateTime;

    return ret / 10000;

}


char *alloc_printf(const char *_str, ...) {

  va_list argptr;
  char* _tmp;
  s32 _len;

  va_start(argptr, _str);
  _len = vsnprintf(NULL, 0, _str, argptr);
  if (_len < 0) FATAL("Whoa, snprintf() fails?!");
  _tmp = ck_alloc(_len + 1);
  vsnprintf(_tmp, (size_t)_len + 1, _str, argptr);
  va_end(argptr);
  return _tmp;

}


/* Get rid of shared memory and temp files (atexit handler). */

static void remove_shm(void) {

  UnmapViewOfFile(trace_bits);
  CloseHandle(shm_handle);
  if (prog_in) _unlink(prog_in); /* Ignore errors */

}


/* Configure shared memory. */

static void setup_shm(void) {

  char* shm_str = NULL;
  unsigned int seeds[2];
  u64 name_seed;
  u8 attempts = 0;

  while(attempts < 5) {
    if(fuzzer_id == NULL) {
      // If it is null, it means we have to generate a random seed to name the instance
      rand_s(&seeds[0]);
      rand_s(&seeds[1]);
      name_seed = ((u64)seeds[0] << 32) | seeds[1];
      fuzzer_id = (char *)alloc_printf("%I64x", name_seed);
    }

    shm_str = (char *)alloc_printf("afl_shm_%s", fuzzer_id);

    shm_handle = CreateFileMapping(
                   INVALID_HANDLE_VALUE,    // use paging file
                   NULL,                    // default security
                   PAGE_READWRITE,          // read/write access
                   0,                       // maximum object size (high-order DWORD)
                   MAP_SIZE,                // maximum object size (low-order DWORD)
                   (char *)shm_str);        // name of mapping object

    if(shm_handle == NULL) {
      if(GetLastError() == ERROR_ALREADY_EXISTS) {
        // We need another attempt to find a unique section name
        attempts++;
        ck_free(shm_str);
        ck_free(fuzzer_id);
        fuzzer_id = NULL;
        continue;
      }
      else {
        PFATAL("CreateFileMapping failed");
      }
    }

    // We found a section name that works!
    break;
  }

  if(attempts == 5) {
    FATAL("Could not find a section name.\n");
  }

  atexit(remove_shm);

  ck_free(shm_str);

  trace_bits = (u8 *)MapViewOfFile(
    shm_handle,          // handle to map object
    FILE_MAP_ALL_ACCESS, // read/write permission
    0,
    0,
    MAP_SIZE
  );

  if (!trace_bits) PFATAL("MapViewOfFile() failed");

}


/* Read initial file. */

static void read_initial_file(void) {

  struct stat st;
  s32 fd = _open(in_file, O_RDONLY | O_BINARY);

  if (fd < 0) PFATAL("Unable to open '%s'", in_file);

  if (fstat(fd, &st) || !st.st_size)
    FATAL("Zero-sized input file.");

  if (st.st_size >= TMIN_MAX_FILE)
    FATAL("Input file is too large (%u MB max)", TMIN_MAX_FILE / 1024 / 1024);

  in_len  = st.st_size;
  in_data = ck_alloc_nozero(in_len);

  ck_read(fd, in_data, in_len, in_file);

  _close(fd);

  OKF("Read %u byte%s from '%s'.", in_len, in_len == 1 ? "" : "s", in_file);

}


/* Write output file. */

static void write_to_file(u8* path, u8* mem, u32 len) {

  s32 ret;

  ret = _open(path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, DEFAULT_PERMISSION);

  if (ret < 0) PFATAL("Unable to create '%s'", path);

  ck_write(ret, mem, len, path);

  _close(ret);

}


/* Handle timeout signal. */

/*static void handle_timeout(int sig) {

  child_timed_out = 1;
  if (child_pid > 0) kill(child_pid, SIGKILL);

}*/


//quoting on Windows is weird
size_t ArgvQuote(char *in, char *out) {
  int needs_quoting = 0;
  size_t size = 0;
  char *p = in;
  size_t i;

  //check if quoting is necessary
  if(strchr(in, ' ')) needs_quoting = 1;
  if(strchr(in, '\"')) needs_quoting = 1;
  if(strchr(in, '\t')) needs_quoting = 1;
  if(strchr(in, '\n')) needs_quoting = 1;
  if(strchr(in, '\v')) needs_quoting = 1;
  if(!needs_quoting) {
    size = strlen(in);
    if(out) memcpy(out, in, size);
    return size;
  }

  if(out) out[size] = '\"';
  size++;

  while(*p) {
    size_t num_backslashes = 0;
    while((*p) && (*p == '\\')) {
      p++;
      num_backslashes++;
    }

    if(*p == 0) {
      for(i = 0; i < (num_backslashes*2); i++) {
        if(out) out[size] = '\\';
        size++;
      }
      break;
    } else if(*p == '\"') {
      for(i = 0; i < (num_backslashes*2 + 1); i++) {
        if(out) out[size] = '\\';
        size++;
      }
      if(out) out[size] = *p;
      size++;
    } else {
      for(i = 0; i < num_backslashes; i++) {
        if(out) out[size] = '\\';
        size++;
      }
      if(out) out[size] = *p;
      size++;
    }

    p++;
  }

  if(out) out[size] = '\"';
  size++;

  return size;
}


char *argv_to_cmd(char** argv) {
  u32 len = 0, i;
  u8* buf, *ret;

  //todo shell-escape

  for (i = 0; argv[i]; i++)
    len += ArgvQuote(argv[i], NULL) + 1;
  
  if(!len) FATAL("Error creating command line");

  buf = ret = ck_alloc(len);

  for (i = 0; argv[i]; i++) {

    u32 l = ArgvQuote(argv[i], buf);

    buf += l;

    *(buf++) = ' ';
  }

  ret[len-1] = 0;

  return ret;
}

static void create_target_process(char** argv) {
  char* cmd;
  char* pipe_name;
  char *buf;
  char *pidfile = NULL;
  FILE *fp;
  size_t pidsize;
  BOOL inherit_handles = TRUE;
  HANDLE hJob = NULL;
  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;

  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  pipe_name = (char *)alloc_printf("\\\\.\\pipe\\afl_pipe_%s", fuzzer_id);

  pipe_handle = CreateNamedPipe(
    pipe_name,                // pipe name
    PIPE_ACCESS_DUPLEX,       // read/write access
    0,
    1,                        // max. instances
    512,                      // output buffer size
    512,                      // input buffer size
    20000,                    // client time-out
    NULL);                    // default security attribute

  if (pipe_handle == INVALID_HANDLE_VALUE) {
    FATAL("CreateNamedPipe failed, GLE=%d.\n", GetLastError());
  }

  target_cmd = argv_to_cmd(argv);

  if (drioless) {
    char *static_config = alloc_printf("%s:1", fuzzer_id);

    if (static_config == NULL) {
      FATAL("Cannot allocate static_config.");
    }

    SetEnvironmentVariable("AFL_STATIC_CONFIG", static_config);
    cmd = alloc_printf("%s", target_cmd);
    ck_free(static_config);
  } else {
    pidfile = alloc_printf("childpid_%s.txt", fuzzer_id);
    cmd = alloc_printf(
      "%s\\drrun.exe -pidfile %s -no_follow_children -c winafl.dll %s -fuzz_iterations 1 -fuzzer_id %s -- %s",
      dynamorio_dir, pidfile, client_params, fuzzer_id, target_cmd
    );
  }

  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));

  if (sinkhole_stds) {
    si.hStdOutput = si.hStdError = devnul_handle;
    si.dwFlags |= STARTF_USESTDHANDLES;
  } else {
    inherit_handles = FALSE;
  }

  if (mem_limit != 0) {
    hJob = CreateJobObject(NULL, NULL);
    if (hJob == NULL) {
      FATAL("CreateJobObject failed, GLE=%d.\n", GetLastError());
    }

    ZeroMemory(&job_limit, sizeof(job_limit));
    job_limit.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_PROCESS_MEMORY;
    job_limit.ProcessMemoryLimit = mem_limit * 1024 * 1024;

    if (!SetInformationJobObject(
      hJob,
      JobObjectExtendedLimitInformation,
      &job_limit,
      sizeof(job_limit)
    )) {
      FATAL("SetInformationJobObject failed, GLE=%d.\n", GetLastError());
    }
  }

  if (!CreateProcess(NULL, cmd, NULL, NULL, inherit_handles, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
    FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
  }

  child_handle = pi.hProcess;
  child_thread_handle = pi.hThread;

  if (mem_limit != 0) {
    if (!AssignProcessToJobObject(hJob, child_handle)) {
      FATAL("AssignProcessToJobObject failed, GLE=%d.\n", GetLastError());
    }
  }

  ResumeThread(child_thread_handle);

  watchdog_timeout_time = get_cur_time() + exec_tmout;
  watchdog_enabled = 1;

  if (!ConnectNamedPipe(pipe_handle, NULL)) {
    if (GetLastError() != ERROR_PIPE_CONNECTED) {
      FATAL("ConnectNamedPipe failed, GLE=%d.\n", GetLastError());
    }
  }

  watchdog_enabled = 0;

  if (drioless == 0) {
    //by the time pipe has connected the pidfile must have been created
    fp = fopen(pidfile, "rb");
    if (!fp) {
      FATAL("Error opening pidfile.txt");
    }
    fseek(fp,0,SEEK_END);
    pidsize = ftell(fp);
    fseek(fp,0,SEEK_SET);
    buf = (char *)malloc(pidsize+1);
    if (!buf) {
        FATAL("Error allocating %Iu bytes", pidsize + 1);
    }
    fread(buf, pidsize, 1, fp);
    buf[pidsize] = 0;
    fclose(fp);
    remove(pidfile);
    child_pid = atoi(buf);
    free(buf);
    ck_free(pidfile);
  }
  else {
    child_pid = pi.dwProcessId;
  }

  ck_free(target_cmd);
  ck_free(cmd);
  ck_free(pipe_name);
}


static void destroy_target_process(int wait_exit) {
  char* kill_cmd;
  BOOL still_alive = TRUE;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  EnterCriticalSection(&critical_section);

  if(!child_handle) {
    goto leave;
  }

  if(WaitForSingleObject(child_handle, wait_exit) != WAIT_TIMEOUT) {
    goto done;
  }

  // nudge the child process only if dynamorio is used
  if(drioless) {
    TerminateProcess(child_handle, 0);
  } else {
    kill_cmd = alloc_printf("%s\\drconfig.exe -nudge_pid %d 0 1", dynamorio_dir, child_pid);

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
      FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    ck_free(kill_cmd);
  }

  still_alive = WaitForSingleObject(child_handle, 2000) == WAIT_TIMEOUT;

  if(still_alive) {
    //wait until the child process exits
    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    kill_cmd = alloc_printf("taskkill /PID %d /F", child_pid);

    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
      FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    ck_free(kill_cmd);

    if(WaitForSingleObject(child_handle, 20000) == WAIT_TIMEOUT) {
      FATAL("Cannot kill child process\n");
    }
  }

  done:
  CloseHandle(child_handle);
  CloseHandle(child_thread_handle);

  child_handle = NULL;
  child_thread_handle = NULL;

  leave:
  //close the pipe
  if(pipe_handle) {
    DisconnectNamedPipe(pipe_handle);
    CloseHandle(pipe_handle);

    pipe_handle = NULL;
  }

  LeaveCriticalSection(&critical_section);
}


DWORD WINAPI watchdog_timer( LPVOID lpParam ) {
  u64 current_time;
  while(1) {
    Sleep(1000);
    current_time = get_cur_time();
    if(watchdog_enabled && (current_time > watchdog_timeout_time)) {
      child_timed_out = 1;
      destroy_target_process(0);
    }
  }
}


static void setup_watchdog_timer() {
  watchdog_enabled = 0;
  InitializeCriticalSection(&critical_section);
  CreateThread(NULL, 0, watchdog_timer, 0, 0, NULL);
}


static int is_child_running() {
   return (child_handle && (WaitForSingleObject(child_handle, 0 ) == WAIT_TIMEOUT));
}

/* Execute target application. Returns exec checksum, or 0 if program
   times out. */

static u32 run_target(char** argv, u8* mem, u32 len, u8 first_run) {

  int status = 0;
  char command[] = "F";
  DWORD num_read;
  char result = 0;
  u32 cksum;

  memset(trace_bits, 0, MAP_SIZE);
  MemoryBarrier();

  write_to_file(prog_in, mem, len);

  if (!is_child_running()) {
      destroy_target_process(0);
      create_target_process(argv);
  }

  child_timed_out = 0;
  memset(trace_bits, 0, MAP_SIZE);
  MemoryBarrier();

  //TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN
  ReadFile(pipe_handle, &result, 1, &num_read, NULL);
  if (result == 'K')
  {
      //a workaround for first cycle
      ReadFile(pipe_handle, &result, 1, &num_read, NULL);
  }
  if (result != 'P')
  {
      FATAL("Unexpected result from pipe! expected 'P', instead received '%c'\n", result);
  }
  //END OF TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN
  WriteFile(
      pipe_handle,  // handle to pipe
      command,      // buffer to write from
      1,            // number of bytes to write
      &num_read,    // number of bytes written
      NULL);        // not overlapped I/O

  watchdog_timeout_time = get_cur_time() + exec_tmout;

  if (exec_tmout) {
      watchdog_enabled = 1;
  }

  ReadFile(pipe_handle, &result, 1, &num_read, NULL);

  if (exec_tmout) {
      watchdog_enabled = 0;
  }

  MemoryBarrier();

  /* Clean up bitmap, analyze exit condition, etc. */

  classify_counts(trace_bits);
  total_execs++;

  destroy_target_process(2000);

  if (stop_soon) {
    SAYF(cRST cLRD "\n+++ Analysis aborted by user +++\n" cRST);
    exit(1);
  }

  /* Always discard inputs that time out. */

  if (child_timed_out) {

    exec_hangs++;
    return 0;

  }

  cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);

  /* We don't actually care if the target is crashing or not,
     except that when it does, the checksum should be different. */

  cksum ^= 0xffffffff;

  if (first_run) orig_cksum = cksum;

  return cksum;

}


#ifdef USE_COLOR

/* Helper function to display a human-readable character. */

static void show_char(u8 val) {

  if (val <= 32 || val >= 127)
    SAYF("#%02x", val);
  else
    SAYF(" %c ", val);

}


/* Show the legend */

static void show_legend(void) {

  SAYF("    " cLGR bgGRA " 01 " cRST " - no-op block              "
              cBLK bgLGN " 01 " cRST " - suspected length field\n"
       "    " cBRI bgGRA " 01 " cRST " - superficial content      "
              cBLK bgYEL " 01 " cRST " - suspected cksum or magic int\n"
       "    " cBLK bgCYA " 01 " cRST " - critical stream          "
              cBLK bgLRD " 01 " cRST " - suspected checksummed block\n"
       "    " cBLK bgMGN " 01 " cRST " - \"magic value\" section\n\n");

}

#endif /* USE_COLOR */


/* Interpret and report a pattern in the input file. */

static void dump_hex(u8* buf, u32 len, u8* b_data) {

  u32 i;

  for (i = 0; i < len; i++) {

#ifdef USE_COLOR
    u32 rlen = 1, off;
#else
    u32 rlen = 1;
#endif /* ^USE_COLOR */

    u8  rtype = b_data[i] & 0x0f;

    /* Look ahead to determine the length of run. */

    while (i + rlen < len && (b_data[i] >> 7) == (b_data[i + rlen] >> 7)) {

      if (rtype < (b_data[i + rlen] & 0x0f)) rtype = b_data[i + rlen] & 0x0f;
      rlen++;

    }

    /* Try to do some further classification based on length & value. */

    if (rtype == RESP_FIXED) {

      switch (rlen) {

        case 2: {

            u16 val = *(u16*)(in_data + i);

            /* Small integers may be length fields. */

            if (val && (val <= in_len || SWAP16(val) <= in_len)) {
              rtype = RESP_LEN;
              break;
            }

            /* Uniform integers may be checksums. */

            if (val && abs(in_data[i] - in_data[i + 1]) > 32) {
              rtype = RESP_CKSUM;
              break;
            }

            break;

          }

        case 4: {

            u32 val = *(u32*)(in_data + i);

            /* Small integers may be length fields. */

            if (val && (val <= in_len || SWAP32(val) <= in_len)) {
              rtype = RESP_LEN;
              break;
            }

            /* Uniform integers may be checksums. */

            if (val && (in_data[i] >> 7 != in_data[i + 1] >> 7 ||
                in_data[i] >> 7 != in_data[i + 2] >> 7 ||
                in_data[i] >> 7 != in_data[i + 3] >> 7)) {
              rtype = RESP_CKSUM;
              break;
            }

            break;

          }

        default: 
            if (rtype == 1 || rtype == 3 || (rtype >= 5 && rtype <= MAX_AUTO_EXTRA - 1))
                break;
            rtype = RESP_SUSPECT;

      }

    }

    /* Print out the entire run. */

#ifdef USE_COLOR

    for (off = 0; off < rlen; off++) {

      /* Every 16 digits, display offset. */

      if (!((i + off) % 16)) {

        if (off) SAYF(cRST cLCY ">");

        if (use_hex_offsets)
          SAYF(cRST cGRA "%s[%06x] " cRST, (i + off) ? "\n" : "", i + off);
        else
          SAYF(cRST cGRA "%s[%06u] " cRST, (i + off) ? "\n" : "", i + off);

      }

      switch (rtype) {

        case RESP_NONE:     SAYF(cLGR bgGRA); break;
        case RESP_MINOR:    SAYF(cBRI bgGRA); break;
        case RESP_VARIABLE: SAYF(cBLK bgCYA); break;
        case RESP_FIXED:    SAYF(cBLK bgMGN); break;
        case RESP_LEN:      SAYF(cBLK bgLGN); break;
        case RESP_CKSUM:    SAYF(cBLK bgYEL); break;
        case RESP_SUSPECT:  SAYF(cBLK bgLRD); break;

      }

      show_char(in_data[i + off]);

      if (off != rlen - 1 && (i + off + 1) % 16) SAYF(" "); else SAYF(cRST " ");

    }

#else

    if (use_hex_offsets)
      SAYF("    Offset %x, length %u: ", i, rlen);
    else
      SAYF("    Offset %u, length %u: ", i, rlen);

    switch (rtype) {

      case RESP_NONE:     SAYF("no-op block\n"); break;
      case RESP_MINOR:    SAYF("superficial content\n"); break;
      case RESP_VARIABLE: SAYF("critical stream\n"); break;
      case RESP_FIXED:    SAYF("\"magic value\" section\n"); break;
      case RESP_LEN:      SAYF("suspected length field\n"); break;
      case RESP_CKSUM:    SAYF("suspected cksum or magic int\n"); break;
      case RESP_SUSPECT:  SAYF("suspected checksummed block\n"); break;

    }

#endif /* ^USE_COLOR */

    i += rlen - 1;

  }

#ifdef USE_COLOR
  SAYF(cRST "\n");
#endif /* USE_COLOR */

}



/* Actually analyze! */

static void analyze(char** argv) {

  u32 i;
  u32 boring_len = 0, prev_xff = 0, prev_x01 = 0, prev_s10 = 0, prev_a10 = 0;

  u8* b_data = ck_alloc(in_len + 1);
  u8  seq_byte = 0;

  b_data[in_len] = 0xff; /* Intentional terminator. */

  ACTF("Analyzing input file (this may take a while)...\n");

#ifdef USE_COLOR
  show_legend();
#endif /* USE_COLOR */

  for (i = 0; i < in_len; i++) {

    u32 xor_ff, xor_01, sub_10, add_10;
    u8  xff_orig, x01_orig, s10_orig, a10_orig;

    /* Perform walking byte adjustments across the file. We perform four
       operations designed to elicit some response from the underlying
       code. */

    in_data[i] ^= 0xff;
    xor_ff = run_target(argv, in_data, in_len, 0);

    in_data[i] ^= 0xfe;
    xor_01 = run_target(argv, in_data, in_len, 0);

    in_data[i] = (in_data[i] ^ 0x01) - 0x10;
    sub_10 = run_target(argv, in_data, in_len, 0);

    in_data[i] += 0x20;
    add_10 = run_target(argv, in_data, in_len, 0);
    in_data[i] -= 0x10;

    /* Classify current behavior. */

    xff_orig = (xor_ff == orig_cksum);
    x01_orig = (xor_01 == orig_cksum);
    s10_orig = (sub_10 == orig_cksum);
    a10_orig = (add_10 == orig_cksum);

    if (xff_orig && x01_orig && s10_orig && a10_orig) {

      b_data[i] = RESP_NONE;
      boring_len++;

    } else if (xff_orig || x01_orig || s10_orig || a10_orig) {

      b_data[i] = RESP_MINOR;
      boring_len++;

    } else if (xor_ff == xor_01 && xor_ff == sub_10 && xor_ff == add_10) {

      b_data[i] = RESP_FIXED;

    } else b_data[i] = RESP_VARIABLE;

    /* When all checksums change, flip most significant bit of b_data. */

    if (prev_xff != xor_ff && prev_x01 != xor_01 &&
        prev_s10 != sub_10 && prev_a10 != add_10) seq_byte ^= 0x80;

    b_data[i] |= seq_byte;

    prev_xff = xor_ff;
    prev_x01 = xor_01;
    prev_s10 = sub_10;
    prev_a10 = add_10;

  } 

  dump_hex(in_data, in_len, b_data);

  SAYF("\n");

  OKF("Analysis complete. Interesting bits: %0.02f%% of the input file.",
      100.0 - ((double)boring_len * 100) / in_len);

  if (exec_hangs)
    WARNF(cLRD "Encountered %u timeouts - results may be skewed." cRST,
          exec_hangs);

  ck_free(b_data);

}



/* Handle Ctrl-C and the like. */

/*static void handle_stop_sig(int sig) {

  stop_soon = 1;

  if (child_pid > 0) kill(child_pid, SIGKILL);

}*/


/* Do basic preparations - persistent fds, filenames, etc. */

static void set_up_environment(void) {

    if (sinkhole_stds) {
        devnul_handle = CreateFile(
            "nul",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
        );

        if (devnul_handle == INVALID_HANDLE_VALUE) {
            PFATAL("Unable to open the nul device.");
        }
    }

    if (!prog_in) {

        u8* use_dir = getenv("TMP");
        prog_in = alloc_printf("%s\\.afl-analyze-temp-%u", use_dir, GetCurrentProcessId());

    }

}

/* Setup signal handlers, duh. */

static void setup_signal_handlers(void) {
  //not implemented on Windows
}


/* Detect @@ in args. */

static void detect_file_args(char** argv) {

  u32 i = 0;
  u8* cwd = _getcwd(NULL, 0);

  if (!cwd) PFATAL("getcwd() failed");

  while (argv[i]) {

    u8* aa_loc = strstr(argv[i], "@@");

    if (aa_loc) {

      u8 *aa_subst, *n_arg;

      aa_subst = prog_in;

      /* Construct a replacement argv value. */

      *aa_loc = 0;
      n_arg = alloc_printf("%s%s%s", argv[i], aa_subst, aa_loc + 2);
      argv[i] = n_arg;
      *aa_loc = '@';

      //if (prog_in[0] != '/') ck_free(aa_subst);

    }

    i++;

  }

  free(cwd); /* not tracked */

}


/* Display usage hints. */

static void usage(u8* argv0) {

  SAYF("\n%s [ options ] -- [instrumentation options] -- \\path\\to\\target_app [ ... ]\n\n"

       "Required parameters:\n\n"

       "  -i file       - input test case to be analyzed by the tool\n"

       "Execution control settings:\n\n"

       "  -f file       - input file read by the tested program (stdin)\n"
       "  -t msec       - timeout for each run (%u ms)\n"
       "  -m megs       - memory limit for child process (%u MB)\n"

       "Analysis settings:\n\n"

       "  -e            - look for edge coverage only, ignore hit counts\n\n"

       "Other stuff:\n\n"

       "  -V            - show version number and exit\n\n"

       "For additional tips, please consult %s/README.\n\n",

       argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);

  exit(1);

}


/* Find binary. */

static void find_binary(u8* fname) {
  // Not implemented on Windows
}


/* Fix up argv for QEMU. */

static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
  //not implemented on Windows
  return NULL;
}


static unsigned int optind;
static char *optarg;

int getopt(int argc, char **argv, char *optstring) {
  char *c;

  optarg = NULL;

  while(1) {
    if(optind == argc) return -1;
    if(strcmp(argv[optind], "--") == 0) return -1;
    if(argv[optind][0] != '-') {
      optind++;
      continue;
    }
    if(!argv[optind][1]) {
      optind++;
      continue;
    }

    c = strchr(optstring, argv[optind][1]);
    if(!c) return -1;
    optind++;
    if(c[1] == ':') {
      if(optind == argc) return -1;
      optarg = argv[optind];
      optind++;
    }

    return (int)(c[0]);
  }
}

static void extract_client_params(u32 argc, char** argv) {
  u32 len = 1, i;
  u32 nclientargs = 0;
  u8* buf;
  u32 opt_start, opt_end;

  if(!argv[optind] || optind >= argc) usage(argv[0]);
  if(strcmp(argv[optind],"--")) usage(argv[0]);

  if(drioless) return;
  optind++;
  opt_start = optind;

  for (i = optind; i < argc; i++) {
    if(strcmp(argv[i],"--") == 0) break;
    nclientargs++;
    len += strlen(argv[i]) + 1;
  }

  if(i == argc) usage(argv[0]);
  opt_end = i;

  buf = client_params = ck_alloc(len);

  for (i = opt_start; i < opt_end; i++) {

    u32 l = strlen(argv[i]);

    memcpy(buf, argv[i], l);
    buf += l;

    *(buf++) = ' ';
  }

  if(buf != client_params) {
    buf--;
  }

  *buf = 0;

  optind = opt_end;

}


/* Main entry point */

int main(int argc, char** argv) {

  s32 opt;
  u8  mem_limit_given = 0, timeout_given = 0, qemu_mode = 0;
  char** use_argv;

  doc_path = "docs";

#ifdef USE_COLOR
  enable_ansi_console();
#endif

  SAYF(cCYA "afl-analyze for Windows " cBRI VERSION cRST " by <l4ys.tw@gmail.com>\n");
  SAYF("Based on WinAFL " cBRI VERSION cRST " by <ifratric@google.com>\n");
  SAYF("Based on AFL " cBRI VERSION cRST " by <lcamtuf@google.com>\n");
  
  while ((opt = getopt(argc,argv,"+i:f:m:t:D:eQYV")) > 0)

    switch (opt) {

      case 'D': /* dynamorio dir */

        if(dynamorio_dir) FATAL("Multiple -D options not supported");
        dynamorio_dir = optarg;
        break;

      case 'i':

        if (in_file) FATAL("Multiple -i options not supported");
        in_file = optarg;
        break;

      case 'f':

        if (prog_in) FATAL("Multiple -f options not supported");
        use_stdin = 0;
        prog_in   = optarg;
        break;

      case 'e':

        if (edges_only) FATAL("Multiple -e options not supported");
        edges_only = 1;
        break;

      case 'm': {

          u8 suffix = 'M';

          if (mem_limit_given) FATAL("Multiple -m options not supported");
          mem_limit_given = 1;

          if (!strcmp(optarg, "none")) {

            mem_limit = 0;
            break;

          }

          if (sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1 ||
              optarg[0] == '-') FATAL("Bad syntax used for -m");

          switch (suffix) {

            case 'T': mem_limit *= 1024 * 1024; break;
            case 'G': mem_limit *= 1024; break;
            case 'k': mem_limit /= 1024; break;
            case 'M': break;

            default:  FATAL("Unsupported suffix or bad syntax for -m");

          }

          if (mem_limit < 5) FATAL("Dangerously low value of -m");

        }

        break;

      case 't':

        if (timeout_given) FATAL("Multiple -t options not supported");
        timeout_given = 1;

        exec_tmout = atoi(optarg);

        if (exec_tmout < 10 || optarg[0] == '-')
          FATAL("Dangerously low value of -t");

        break;

      case 'Q':

        FATAL("QEMU mode not supported on Windows");
        break;
        
      case 'Y':

        if (dynamorio_dir) FATAL("Dynamic-instrumentation (DRIO) is uncompatible with static-instrumentation");
        drioless = 1;

        break;

      case 'V': /* Show version number */

        /* Version number has been printed already, just quit. */
        exit(0);

      default:

        usage(argv[0]);

    }

  if (!in_file) usage(argv[0]);
  if(!drioless) {
    if(optind == argc || !dynamorio_dir) usage(argv[0]);
  }

  extract_client_params(argc, argv);
  optind++;

  if (getenv("AFL_NO_SINKHOLE")) sinkhole_stds = 0;
  
  use_hex_offsets = !!getenv("AFL_ANALYZE_HEX");

  setup_shm();
  setup_watchdog_timer();
  setup_signal_handlers();

  set_up_environment();

  find_binary(argv[optind]);
  detect_file_args(argv + optind);

  use_argv = argv + optind;

  SAYF("\n");
  read_initial_file();

  ACTF("Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...",
       mem_limit, exec_tmout, edges_only ? ", edges only" : "");

  run_target(use_argv, in_data, in_len, 1);

  if (child_timed_out)
    FATAL("Target binary times out (adjusting -t may help).");

  if (!anything_set()) FATAL("No instrumentation detected.");

  analyze(use_argv);

  OKF("We're done here. Have a nice day!\n");

  exit(0);

}

```

`afl-fuzz.c`:

```c
/*
   american fuzzy lop - fuzzer code
   --------------------------------

   Original AFL code written by Michal Zalewski <lcamtuf@google.com>

   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */
#define _CRT_SECURE_NO_WARNINGS

#define AFL_MAIN
#define MESSAGES_TO_STDOUT

#define _GNU_SOURCE
#define _FILE_OFFSET_BITS 64

#define WIN32_LEAN_AND_MEAN /* prevent winsock.h to be included in windows.h */

#define _CRT_RAND_S
#define MAX_SAMPLE_SIZE 1000000

#include <windows.h>
#include <TlHelp32.h>
#include <stdarg.h>
#include <io.h>
#include <direct.h>
#include <pdh.h>
#include <pdhmsg.h>
#pragma comment(lib, "pdh.lib")

#define VERSION "2.43b"
#define WINAFL_VERSION "1.17"

#include "config.h"
#include "types.h"
#include "debug.h"
#include "alloc-inl.h"
#include "hash.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <ctype.h>
#include <fcntl.h>

#include <sys/stat.h>
#include <sys/types.h>

#ifdef TINYINST
int tinyinst_init(int argc, char** argv);
void tinyinst_set_fuzzer_id(char* fuzzer_id);
int tinyinst_run(char** argv, uint32_t timeout);
void tinyinst_killtarget();
#endif

#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)
#  include <sys/sysctl.h>
#endif /* __APPLE__ || __FreeBSD__ || __OpenBSD__ */

/* Lots of globals, but mostly for the status UI and other things where it
   really makes no sense to haul them around as function parameters. */
BOOL use_sample_shared_memory = FALSE;
static u8 *in_dir,                    /* Input directory with test cases  */
          *out_file,                  /* File to fuzz, if any             */
          *out_dir,                   /* Working & output directory       */
          *sync_dir,                  /* Synchronization directory        */
          *sync_id,                   /* Fuzzer ID                        */
          *use_banner,                /* Display banner                   */
          *in_bitmap,                 /* Input bitmap                     */
          *doc_path,                  /* Path to documentation dir        */
          *target_path,               /* Path to target binary            */
          *target_cmd,                /* command line of target           */
          *orig_cmdline;              /* Original command line            */


static u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */
static u32 init_tmout = 0;            /* Configurable init timeout (ms)   */
static u32 hang_tmout = EXEC_TIMEOUT; /* Timeout used for hang det (ms)   */

u64 mem_limit  = MEM_LIMIT;           /* Memory cap for child (MB)        */

static u32 stats_update_freq = 1,     /* Stats update frequency (execs)   */
           drattachpid = 0;	          /* running process id for attach    */

static u8  skip_deterministic,        /* Skip deterministic stages?       */
           force_deterministic,       /* Force deterministic stages?      */
           use_splicing,              /* Recombine input files?           */
           dumb_mode,                 /* Run in non-instrumented mode?    */
           score_changed,             /* Scoring for favorites changed?   */
           kill_signal,               /* Signal that killed the child     */
           resuming_fuzz,             /* Resuming an older fuzzing job?   */
           timeout_given,             /* Specific timeout given?          */
           not_on_tty,                /* stdout is not a tty              */
           term_too_small,            /* terminal dimensions too small    */
           uses_asan,                 /* Target uses ASAN?                */
           no_forkserver,             /* Disable forkserver?              */
           crash_mode,                /* Crash mode! Yeah!                */
           in_place_resume,           /* Attempt in-place resume?         */
           autoresume,                /* Resume if out_dir exists?        */
           auto_changed,              /* Auto-generated tokens changed?   */
           no_cpu_meter_red,          /* Feng shui on the status screen   */
           no_arith,                  /* Skip most arithmetic ops         */
           shuffle_queue,             /* Shuffle input queue?             */
           bitmap_changed = 1,        /* Time to update bitmap?           */
           qemu_mode,                 /* Running in QEMU mode?            */
           skip_requested,            /* Skip request, via SIGUSR1        */
           run_over10m,               /* Run time over 10 minutes?        */
           persistent_mode,           /* Running in persistent mode?      */
           drioless = 0,              /* Running without DRIO?            */
           drattach = 0;	            /* attaching to a running process   */
           use_intelpt = 0;           /* Using Intel PT instrumentation   */
           use_tinyinst = 0;          /* Using TinyInst instrumentation   */
           custom_dll_defined = 0;    /* Custom DLL path defined?         */
           persist_dr_cache = 0;      /* Enable persisting code caches?   */
           expert_mode = 0;           /* Running in expert mode with DRIO?*/

static s32 out_fd,                    /* Persistent fd for out_file       */
           dev_urandom_fd = -1,       /* Persistent fd for /dev/urandom   */
           dev_null_fd = -1,          /* Persistent fd for /dev/null      */
           fsrv_ctl_fd,               /* Fork server control pipe (write) */
           fsrv_st_fd;                /* Fork server status pipe (read)   */

           child_pid = -1,            /* PID of the fuzzed program        */
           out_dir_fd = -1;           /* FD of the lock file              */

HANDLE child_handle, child_thread_handle;
char *dynamorio_dir;
char *drattach_identifier;
char *client_params;
char *winafl_dll_path;
int fuzz_iterations_max = 5000, fuzz_iterations_current;
DWORD ret_exception_code = 0;

CRITICAL_SECTION critical_section;
u64 watchdog_timeout_time;
int watchdog_enabled;

PDH_HQUERY cpuQuery;
PDH_HCOUNTER cpuTotal;

u8* trace_bits;                       /* SHM with instrumentation bitmap  */

static u8  virgin_bits[MAP_SIZE],     /* Regions yet untouched by fuzzing */
           virgin_tmout[MAP_SIZE],    /* Bits we haven't seen in tmouts   */
           virgin_crash[MAP_SIZE];    /* Bits we haven't seen in crashes  */

static u8  var_bytes[MAP_SIZE];       /* Bytes that appear to be variable */

static HANDLE shm_handle;             /* Handle of the SHM region         */

static HANDLE sample_shm_handle;         /* Handle of the use SHM region         */
char* sample_shm_str;

static HANDLE pipe_handle;            /* Handle of the name pipe          */
static OVERLAPPED pipe_overlapped;    /* Overlapped structure of pipe     */

static char   *fuzzer_id = NULL;      /* The fuzzer ID or a randomized 
                                         seed allowing multiple instances */
static HANDLE devnul_handle;          /* Handle of the nul device         */
u8     sinkhole_stds = 1;             /* Sink-hole stdout/stderr messages?*/
u8* shm_sample;

static volatile u8 stop_soon,         /* Ctrl-C pressed?                  */
                   clear_screen = 1,  /* Window resized?                  */
                   child_timed_out;   /* Traced process timed out?        */

static u32 queued_paths,              /* Total number of queued testcases */
           queued_variable,           /* Testcases with variable behavior */
           queued_at_start,           /* Total number of initial inputs   */
           queued_discovered,         /* Items discovered during this run */
           queued_imported,           /* Items imported via -S            */
           queued_favored,            /* Paths deemed favorable           */
           queued_with_cov,           /* Paths with new coverage bytes    */
           pending_not_fuzzed,        /* Queued but not done yet          */
           pending_favored,           /* Pending favored paths            */
           cur_skipped_paths,         /* Abandoned inputs in cur cycle    */
           cur_depth,                 /* Current path depth               */
           max_depth,                 /* Max path depth                   */
           useless_at_start,          /* Number of useless starting paths */
           var_byte_count,            /* Bitmap bytes with var behavior   */
           current_entry,             /* Current queue entry ID           */
           havoc_div = 1;             /* Cycle count divisor for havoc    */

static u64 total_crashes,             /* Total number of crashes          */
           unique_crashes,            /* Crashes with unique signatures   */
           total_tmouts,              /* Total number of timeouts         */
           unique_tmouts,             /* Timeouts with unique signatures  */
           unique_hangs,              /* Hangs with unique signatures     */
           total_execs,               /* Total execve() calls             */
           start_time,                /* Unix start time (ms)             */
           prev_run_time,             /* Runtime read from prev stats file*/
           last_path_time,            /* Time for most recent path (ms)   */
           last_crash_time,           /* Time for most recent crash (ms)  */
           last_hang_time,            /* Time for most recent hang (ms)   */
           last_crash_execs,          /* Exec counter at last crash       */
           queue_cycle,               /* Queue round counter              */
           cycles_wo_finds,           /* Cycles without any new paths     */
           trim_execs,                /* Execs done to trim input files   */
           bytes_trim_in,             /* Bytes coming into the trimmer    */
           bytes_trim_out,            /* Bytes coming outa the trimmer    */
           blocks_eff_total,          /* Blocks subject to effector maps  */
           blocks_eff_select;         /* Blocks selected as fuzzable      */

static u32 subseq_tmouts;             /* Number of timeouts in a row      */

static u8 *stage_name = "init",       /* Name of the current fuzz stage   */
          *stage_short,               /* Short stage name                 */
          *syncing_party;             /* Currently syncing with...        */

static s32 stage_cur, stage_max;      /* Stage progression                */
static s32 splicing_with = -1;        /* Splicing with which test case?   */

static u32 master_id, master_max;     /* Master instance job splitting    */

static u32 syncing_case;              /* Syncing with case #...           */

static s32 stage_cur_byte,            /* Byte offset of current stage op  */
           stage_cur_val;             /* Value used for stage op          */

static u8  stage_val_type;            /* Value type (STAGE_VAL_*)         */

static u64 stage_finds[32],           /* Patterns found per fuzz stage    */
           stage_cycles[32];          /* Execs per fuzz stage             */

static u32 rand_cnt;                  /* Random number counter            */

static u64 total_cal_us,              /* Total calibration time (us)      */
           total_cal_cycles;          /* Total calibration cycles         */

static u64 total_bitmap_size,         /* Total bit count for all bitmaps  */
           total_bitmap_entries;      /* Number of bitmaps counted        */

static u32 cpu_core_count;            /* CPU core count                   */

u64 cpu_aff = 0;       	              /* Selected CPU core                */

static FILE* plot_file;               /* Gnuplot output file              */

struct queue_entry {

  u8* fname;                          /* File name for the test case      */
  u32 len;                            /* Input length                     */

  u8  cal_failed,                     /* Calibration failed?              */
      trim_done,                      /* Trimmed?                         */
      was_fuzzed,                     /* Had any fuzzing done yet?        */
      passed_det,                     /* Deterministic stages passed?     */
      has_new_cov,                    /* Triggers new coverage?           */
      var_behavior,                   /* Variable behavior?               */
      favored,                        /* Currently favored?               */
      fs_redundant;                   /* Marked as redundant in the fs?   */

  u32 bitmap_size,                    /* Number of bits set in bitmap     */
      exec_cksum;                     /* Checksum of the execution trace  */

  u64 exec_us,                        /* Execution time (us)              */
      handicap,                       /* Number of queue cycles behind    */
      depth;                          /* Path depth                       */

  u8* trace_mini;                     /* Trace bytes, if kept             */
  u32 tc_ref;                         /* Trace bytes ref count            */

  struct queue_entry *next,           /* Next element, if any             */
                     *next_100;       /* 100 elements ahead               */

};

static struct queue_entry *queue,     /* Fuzzing queue (linked list)      */
                          *queue_cur, /* Current offset within the queue  */
                          *queue_top, /* Top of the list                  */
                          *q_prev100; /* Previous 100 marker              */

static struct queue_entry*
  top_rated[MAP_SIZE];                /* Top entries for bitmap bytes     */

struct extra_data {
  u8* data;                           /* Dictionary token data            */
  u32 len;                            /* Dictionary token length          */
  u32 hit_cnt;                        /* Use count in the corpus          */
};

static struct extra_data* extras;     /* Extra tokens to fuzz with        */
static u32 extras_cnt;                /* Total number of tokens read      */

static struct extra_data* a_extras;   /* Automatically selected extras    */
static u32 a_extras_cnt;              /* Total number of tokens available */

static u8* (*post_handler)(u8* buf, u32* len);

/* Interesting values, as per config.h */

static s8  interesting_8[]  = { INTERESTING_8 };
static s16 interesting_16[] = { INTERESTING_8, INTERESTING_16 };
static s32 interesting_32[] = { INTERESTING_8, INTERESTING_16, INTERESTING_32 };

/* Fuzzing stages */

enum {
  /* 00 */ STAGE_FLIP1,
  /* 01 */ STAGE_FLIP2,
  /* 02 */ STAGE_FLIP4,
  /* 03 */ STAGE_FLIP8,
  /* 04 */ STAGE_FLIP16,
  /* 05 */ STAGE_FLIP32,
  /* 06 */ STAGE_ARITH8,
  /* 07 */ STAGE_ARITH16,
  /* 08 */ STAGE_ARITH32,
  /* 09 */ STAGE_INTEREST8,
  /* 10 */ STAGE_INTEREST16,
  /* 11 */ STAGE_INTEREST32,
  /* 12 */ STAGE_EXTRAS_UO,
  /* 13 */ STAGE_EXTRAS_UI,
  /* 14 */ STAGE_EXTRAS_AO,
  /* 15 */ STAGE_HAVOC,
  /* 16 */ STAGE_SPLICE
};

/* Stage value types */

enum {
  /* 00 */ STAGE_VAL_NONE,
  /* 01 */ STAGE_VAL_LE,
  /* 02 */ STAGE_VAL_BE
};

/* Execution status fault codes */

enum {
  /* 00 */ FAULT_NONE,
  /* 01 */ FAULT_TMOUT,
  /* 02 */ FAULT_CRASH,
  /* 03 */ FAULT_ERROR,
  /* 04 */ FAULT_NOINST,
  /* 05 */ FAULT_NOBITS
};



/* Get unix time in milliseconds */

u64 get_cur_time(void) {

  u64 ret;
  FILETIME filetime;
  GetSystemTimeAsFileTime(&filetime);

  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;

  return ret / 10000;

}


/* Get unix time in microseconds */

static u64 get_cur_time_us(void) {

  u64 ret;
  FILETIME filetime;
  GetSystemTimeAsFileTime(&filetime);

  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;

  return ret / 10;

}


/* Generate a random number (from 0 to limit - 1). This may
   have slight bias. */

static inline u32 UR(u32 limit) {

  if (!rand_cnt--) {

    u32 seed[2];

    rand_s(&seed[0]);
    rand_s(&seed[1]);

    srand(seed[0]);
    rand_cnt = (RESEED_RNG / 2) + (seed[1] % RESEED_RNG);

  }

  return rand() % limit;

}


/* Shuffle an array of pointers. Might be slightly biased. */

static void shuffle_ptrs(void** ptrs, u32 cnt) {

  u32 i;

  for (i = 0; i < cnt - 2; i++) {

    u32 j = i + UR(cnt - i);
    void *s = ptrs[i];
    ptrs[i] = ptrs[j];
    ptrs[j] = s;

  }

}


static u64 get_process_affinity(u32 process_id) {

  /* if we can't get process affinity we treat it as if he doesn't have affinity */
  u64 affinity = -1ULL;
  DWORD_PTR process_affinity_mask = 0;
  DWORD_PTR system_affinity_mask = 0;

  HANDLE process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, process_id);
  if (process == NULL) {
    return affinity;
  }

  if (GetProcessAffinityMask(process, &process_affinity_mask, &system_affinity_mask)) {
    affinity = (u64)process_affinity_mask;
  }

  CloseHandle(process);

  return affinity;
}

static u32 count_mask_bits(u64 mask) {

  u32 count = 0;

  while (mask) {
    if (mask & 1) {
      count++;
    }
    mask >>= 1;
  }

  return count;
}

static u32 get_bit_idx(u64 mask) {

  u32 i;
	
  for (i = 0; i < 64; i++) {
    if (mask & (1ULL << i)) {
      return i;
    }
  }

  return 0;
}

static void bind_to_free_cpu(void) {

  u8 cpu_used[64];
  u32 i = 0;
  PROCESSENTRY32 process_entry;
  HANDLE process_snap = INVALID_HANDLE_VALUE;

  memset(cpu_used, 0, sizeof(cpu_used));

  if (cpu_core_count < 2) return;

  if (getenv("AFL_NO_AFFINITY")) {

    WARNF("Not binding to a CPU core (AFL_NO_AFFINITY set).");
    return;
  }

  /* Currently winafl doesn't support more than 64 cores */
  if (cpu_core_count > 64) {
    SAYF("\n" cLRD "[-] " cRST
    "Uh-oh, looks like you have %u CPU cores on your system\n"
    "    winafl doesn't support more than 64 cores at the moment\n"
    "    you can set AFL_NO_AFFINITY and try again.\n",
    cpu_core_count);
    FATAL("Too many cpus for automatic binding");
  }

  if (!cpu_aff) {
    ACTF("Checking CPU core loadout...");

    /* Introduce some jitter, in case multiple AFL tasks are doing the same
    thing at the same time... */

    srand(GetTickCount() + GetCurrentProcessId());
    Sleep(R(1000) * 3);

    process_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (process_snap == INVALID_HANDLE_VALUE) {
      FATAL("Failed to create snapshot");
    }

    process_entry.dwSize = sizeof(PROCESSENTRY32);
    if (!Process32First(process_snap, &process_entry)) {
      CloseHandle(process_snap);
      FATAL("Failed to enumerate processes");
    }

    do {
      unsigned long cpu_idx = 0;
      u64 affinity = get_process_affinity(process_entry.th32ProcessID);

      if ((affinity == 0) || (count_mask_bits(affinity) > 1)) continue;

      cpu_idx = get_bit_idx(affinity);
      cpu_used[cpu_idx] = 1;
    } while (Process32Next(process_snap, &process_entry));

    CloseHandle(process_snap);

    /* If the user only uses subset of the core, prefer non-sequential cores
       to avoid pinning two hyper threads of the same core */
    for(i = 0; i < cpu_core_count; i += 2) if (!cpu_used[i]) break;

    /* Fallback to the sequential scan */
    if (i >= cpu_core_count) {
      for(i = 0; i < cpu_core_count; i++) if (!cpu_used[i]) break;
    }

    if (i == cpu_core_count) {
      SAYF("\n" cLRD "[-] " cRST
      "Uh-oh, looks like all %u CPU cores on your system are allocated to\n"
      "    other instances of afl-fuzz (or similar CPU-locked tasks). Starting\n"
      "    another fuzzer on this machine is probably a bad plan, but if you are\n"
      "    absolutely sure, you can set AFL_NO_AFFINITY and try again.\n",
      cpu_core_count);

      FATAL("No more free CPU cores");

    }

    OKF("Found a free CPU core, binding to #%u.", i);

    cpu_aff = 1ULL << i;
  }

  if (!SetProcessAffinityMask(GetCurrentProcess(), (DWORD_PTR)cpu_aff)) {
    FATAL("Failed to set process affinity");
  }

  OKF("Process affinity is set to %I64x.", cpu_aff);
}


#ifndef IGNORE_FINDS

/* Helper function to compare buffers; returns first and last differing offset. We
   use this to find reasonable locations for splicing two files. */

static void locate_diffs(u8* ptr1, u8* ptr2, u32 len, s32* first, s32* last) {

  s32 f_loc = -1;
  s32 l_loc = -1;
  u32 pos;

  for (pos = 0; pos < len; pos++) {

    if (*(ptr1++) != *(ptr2++)) {

      if (f_loc == -1) f_loc = pos;
      l_loc = pos;

    }

  }

  *first = f_loc;
  *last = l_loc;

  return;

}

#endif /* !IGNORE_FINDS */


/* Describe integer. Uses 12 cyclic static buffers for return values. The value
   returned should be five characters or less for all the integers we reasonably
   expect to see. */

static u8* DI(u64 val) {

  static u8 tmp[12][16];
  static u8 cur;

  cur = (cur + 1) % 12;

#define CHK_FORMAT(_divisor, _limit_mult, _fmt, _cast) do { \
    if (val < (_divisor) * (_limit_mult)) { \
      sprintf(tmp[cur], _fmt, ((_cast)val) / (_divisor)); \
      return tmp[cur]; \
    } \
  } while (0)

  /* 0-9999 */
  CHK_FORMAT(1, 10000, "%llu", u64);

  /* 10.0k - 99.9k */
  CHK_FORMAT(1000, 99.95, "%0.01fk", double);

  /* 100k - 999k */
  CHK_FORMAT(1000, 1000, "%lluk", u64);

  /* 1.00M - 9.99M */
  CHK_FORMAT(1000 * 1000, 9.995, "%0.02fM", double);

  /* 10.0M - 99.9M */
  CHK_FORMAT(1000 * 1000, 99.95, "%0.01fM", double);

  /* 100M - 999M */
  CHK_FORMAT(1000 * 1000, 1000, "%lluM", u64);

  /* 1.00G - 9.99G */
  CHK_FORMAT(1000LL * 1000 * 1000, 9.995, "%0.02fG", double);

  /* 10.0G - 99.9G */
  CHK_FORMAT(1000LL * 1000 * 1000, 99.95, "%0.01fG", double);

  /* 100G - 999G */
  CHK_FORMAT(1000LL * 1000 * 1000, 1000, "%lluG", u64);

  /* 1.00T - 9.99G */
  CHK_FORMAT(1000LL * 1000 * 1000 * 1000, 9.995, "%0.02fT", double);

  /* 10.0T - 99.9T */
  CHK_FORMAT(1000LL * 1000 * 1000 * 1000, 99.95, "%0.01fT", double);

  /* 100T+ */
  strcpy(tmp[cur], "infty");
  return tmp[cur];

}


/* Describe float. Similar to the above, except with a single 
   static buffer. */

static u8* DF(double val) {

  static u8 tmp[16];

  if (val < 99.995) {
    sprintf(tmp, "%0.02f", val);
    return tmp;
  }

  if (val < 999.95) {
    sprintf(tmp, "%0.01f", val);
    return tmp;
  }

  return DI((u64)val);

}


/* Describe integer as memory size. */

static u8* DMS(u64 val) {

  static u8 tmp[12][16];
  static u8 cur;

  cur = (cur + 1) % 12;

  /* 0-9999 */
  CHK_FORMAT(1, 10000, "%llu B", u64);

  /* 10.0k - 99.9k */
  CHK_FORMAT(1024, 99.95, "%0.01f kB", double);

  /* 100k - 999k */
  CHK_FORMAT(1024, 1000, "%llu kB", u64);

  /* 1.00M - 9.99M */
  CHK_FORMAT(1024 * 1024, 9.995, "%0.02f MB", double);

  /* 10.0M - 99.9M */
  CHK_FORMAT(1024 * 1024, 99.95, "%0.01f MB", double);

  /* 100M - 999M */
  CHK_FORMAT(1024 * 1024, 1000, "%llu MB", u64);

  /* 1.00G - 9.99G */
  CHK_FORMAT(1024LL * 1024 * 1024, 9.995, "%0.02f GB", double);

  /* 10.0G - 99.9G */
  CHK_FORMAT(1024LL * 1024 * 1024, 99.95, "%0.01f GB", double);

  /* 100G - 999G */
  CHK_FORMAT(1024LL * 1024 * 1024, 1000, "%llu GB", u64);

  /* 1.00T - 9.99G */
  CHK_FORMAT(1024LL * 1024 * 1024 * 1024, 9.995, "%0.02f TB", double);

  /* 10.0T - 99.9T */
  CHK_FORMAT(1024LL * 1024 * 1024 * 1024, 99.95, "%0.01f TB", double);

#undef CHK_FORMAT

  /* 100T+ */
  strcpy(tmp[cur], "infty");
  return tmp[cur];

}


/* Describe time delta. Returns one static buffer, 34 chars of less. */

static u8* DTD(u64 cur_ms, u64 event_ms) {

  static u8 tmp[64];
  u64 delta;
  s32 t_d, t_h, t_m, t_s;

  if (!event_ms) return "none seen yet";

  delta = cur_ms - event_ms;

  t_d = (s32)(delta / 1000 / 60 / 60 / 24);
  t_h = (s32)((delta / 1000 / 60 / 60) % 24);
  t_m = (s32)((delta / 1000 / 60) % 60);
  t_s = (s32)((delta / 1000) % 60);

  sprintf(tmp, "%s days, %u hrs, %u min, %u sec", DI(t_d), t_h, t_m, t_s);
  return tmp;

}


char *alloc_printf(const char *_str, ...) {
	va_list argptr;
    char* _tmp;
	s32 _len;

    va_start(argptr, _str);
    _len = vsnprintf(NULL, 0, _str, argptr);
    if (_len < 0) FATAL("Whoa, snprintf() fails?!");
    _tmp = ck_alloc(_len + 1);
    vsnprintf(_tmp, (size_t)_len + 1, _str, argptr);
    va_end(argptr);
    return _tmp;
  }


/* Mark deterministic checks as done for a particular queue entry. We use the
   .state file to avoid repeating deterministic fuzzing when resuming aborted
   scans. */

static void mark_as_det_done(struct queue_entry* q) {

  u8* fn = strrchr(q->fname, '\\');
  s32 fd;

  fn = alloc_printf("%s\\queue\\.state\\deterministic_done\\%s", out_dir, fn + 1);

  fd = _open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);
  if (fd < 0) PFATAL("Unable to create '%s'", fn);
  _close(fd);

  ck_free(fn);

  q->passed_det = 1;

}


/* Mark as variable. Create symlinks if possible to make it easier to examine
   the files. */

static void mark_as_variable(struct queue_entry* q) {

  u8 *fn = strrchr(q->fname, '\\') + 1, *ldest;

  ldest = alloc_printf("..\\..\\%s", fn);
  fn = alloc_printf("%s\\queue\\.state\\variable_behavior\\%s", out_dir, fn);

  ck_free(ldest);
  ck_free(fn);

  q->var_behavior = 1;

}


/* Mark / unmark as redundant (edge-only). This is not used for restoring state,
   but may be useful for post-processing datasets. */

static void mark_as_redundant(struct queue_entry* q, u8 state) {

  u8* fn;
  s32 fd;

  if (state == q->fs_redundant) return;

  q->fs_redundant = state;

  fn = strrchr(q->fname, '\\');
  fn = alloc_printf("%s\\queue\\.state\\redundant_edges\\%s", out_dir, fn + 1);

  if (state) {

    fd = _open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);
    if (fd < 0) PFATAL("Unable to create '%s'", fn);
    _close(fd);

  } else {

    if (_unlink(fn)) PFATAL("Unable to remove '%s'", fn);

  }

  ck_free(fn);

}


/* Append new test case to the queue. */

static void add_to_queue(u8* fname, u32 len, u8 passed_det) {

  cycles_wo_finds = 0;

  struct queue_entry* q = ck_alloc(sizeof(struct queue_entry));

  q->fname        = fname;
  q->len          = len;
  q->depth        = (u64)cur_depth + 1;
  q->passed_det   = passed_det;

  if (q->depth > max_depth) max_depth = (u32)(q->depth);

  if (queue_top) {

    queue_top->next = q;
    queue_top = q;

  } else q_prev100 = queue = queue_top = q;

  queued_paths++;
  pending_not_fuzzed++;

  /* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */
  if ((queued_paths - 1) % 100 == 0 && queued_paths > 1) {

    q_prev100->next_100 = q;
    q_prev100 = q;

  }

  last_path_time = get_cur_time();

}


/* Destroy the entire queue. */

static void destroy_queue(void) {

  struct queue_entry *q = queue, *n;

  while (q) {

    n = q->next;
    ck_free(q->fname);
    ck_free(q->trace_mini);
    ck_free((char *)q);
    q = n;

  }

}


/* Write bitmap to file. The bitmap is useful mostly for the secret
   -B option, to focus a separate fuzzing session on a particular
   interesting input without rediscovering all the others. */

static void write_bitmap(void) {

  u8* fname;
  s32 fd;

  if (!bitmap_changed) return;
  bitmap_changed = 0;

  fname = alloc_printf("%s\\fuzz_bitmap", out_dir);
  fd = _open(fname, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);

  if (fd < 0) PFATAL("Unable to open '%s'", fname);

  ck_write(fd, virgin_bits, MAP_SIZE, fname);

  _close(fd);
  ck_free(fname);

}


/* Read bitmap from file. This is for the -B option again. */

static void read_bitmap(u8* fname) {

  s32 fd = _open(fname, O_RDONLY | O_BINARY);

  if (fd < 0) PFATAL("Unable to open '%s'", fname);

  ck_read(fd, virgin_bits, MAP_SIZE, fname);

  _close(fd);

}


/* Check if the current execution path brings anything new to the table.
   Update virgin bits to reflect the finds. Returns 1 if the only change is
   the hit-count for a particular tuple; 2 if there are new tuples seen. 
   Updates the map, so subsequent calls will always return 0.

   This function is called after every exec() on a fairly large buffer, so
   it needs to be fast. We do this in 32-bit and 64-bit flavors. */

static inline u8 has_new_bits(u8* virgin_map) {


#ifdef _WIN64

  u64* current = (u64*)trace_bits;
  u64* virgin  = (u64*)virgin_map;

  u32  i = (MAP_SIZE >> 3);

#else

  u32* current = (u32*)trace_bits;
  u32* virgin  = (u32*)virgin_map;

  u32  i = (MAP_SIZE >> 2);

#endif /* ^_WIN64 */

  u8   ret = 0;

  while (i--) {

    /* Optimize for (*current & *virgin) == 0 - i.e., no bits in current bitmap
       that have not been already cleared from the virgin map - since this will
       almost always be the case. */

    if (*current && (*current & *virgin)) {

      if (ret < 2) {

        u8* cur = (u8*)current;
        u8* vir = (u8*)virgin;

        /* Looks like we have not found any new bytes yet; see if any non-zero
           bytes in current[] are pristine in virgin[]. */

#ifdef _WIN64

        if ((cur[0] && vir[0] == 0xff) || (cur[1] && vir[1] == 0xff) ||
            (cur[2] && vir[2] == 0xff) || (cur[3] && vir[3] == 0xff) ||
            (cur[4] && vir[4] == 0xff) || (cur[5] && vir[5] == 0xff) ||
            (cur[6] && vir[6] == 0xff) || (cur[7] && vir[7] == 0xff)) ret = 2;
        else ret = 1;

#else

        if ((cur[0] && vir[0] == 0xff) || (cur[1] && vir[1] == 0xff) ||
            (cur[2] && vir[2] == 0xff) || (cur[3] && vir[3] == 0xff)) ret = 2;
        else ret = 1;

#endif /* ^_WIN64 */

      }

      *virgin &= ~*current;

    }

    current++;
    virgin++;

  }

  if (ret && virgin_map == virgin_bits) bitmap_changed = 1;

  return ret;

}


/* Count the number of bits set in the provided bitmap. Used for the status
   screen several times every second, does not have to be fast. */

static u32 count_bits(u8* mem) {

  u32* ptr = (u32*)mem;
  u32  i   = (MAP_SIZE >> 2);
  u32  ret = 0;

  while (i--) {

    u32 v = *(ptr++);

    /* This gets called on the inverse, virgin bitmap; optimize for sparse
       data. */

    if (v == 0xffffffff) {
      ret += 32;
      continue;
    }

    v -= ((v >> 1) & 0x55555555);
    v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
    ret += (((v + (v >> 4)) & 0xF0F0F0F) * 0x01010101) >> 24;

  }

  return ret;

}

#define FF(_b)  (0xff << ((_b) << 3))

/* Count the number of bytes set in the bitmap. Called fairly sporadically,
   mostly to update the status screen or calibrate and examine confirmed
   new paths. */

static u32 count_bytes(u8* mem) {

  u32* ptr = (u32*)mem;
  u32  i   = (MAP_SIZE >> 2);
  u32  ret = 0;

  while (i--) {

    u32 v = *(ptr++);

    if (!v) continue;
    if (v & FF(0)) ret++;
    if (v & FF(1)) ret++;
    if (v & FF(2)) ret++;
    if (v & FF(3)) ret++;

  }

  return ret;

}


/* Count the number of non-255 bytes set in the bitmap. Used strictly for the
   status screen, several calls per second or so. */

static u32 count_non_255_bytes(u8* mem) {

  u32* ptr = (u32*)mem;
  u32  i   = (MAP_SIZE >> 2);
  u32  ret = 0;

  while (i--) {

    u32 v = *(ptr++);

    /* This is called on the virgin bitmap, so optimize for the most likely
       case. */

    if (v == 0xffffffff) continue;
    if ((v & FF(0)) != FF(0)) ret++;
    if ((v & FF(1)) != FF(1)) ret++;
    if ((v & FF(2)) != FF(2)) ret++;
    if ((v & FF(3)) != FF(3)) ret++;

  }

  return ret;

}


/* Destructively simplify trace by eliminating hit count information
   and replacing it with 0x80 or 0x01 depending on whether the tuple
   is hit or not. Called on every new crash or timeout, should be
   reasonably fast. */

#define AREP4(_sym)   (_sym), (_sym), (_sym), (_sym)
#define AREP8(_sym)   AREP4(_sym), AREP4(_sym)
#define AREP16(_sym)  AREP8(_sym), AREP8(_sym)
#define AREP32(_sym)  AREP16(_sym), AREP16(_sym)
#define AREP64(_sym)  AREP32(_sym), AREP32(_sym)
#define AREP128(_sym) AREP64(_sym), AREP64(_sym)

static const u8 simplify_lookup[256] = {

  /*    4 */ 1, 128, 128, 128,
  /*   +4 */ AREP4(128),
  /*   +8 */ AREP8(128),
  /*  +16 */ AREP16(128),
  /*  +32 */ AREP32(128),
  /*  +64 */ AREP64(128),
  /* +128 */ AREP128(128)

};

#ifdef _WIN64

static void simplify_trace(u64* mem) {

  u32 i = MAP_SIZE >> 3;

  while (i--) {

    /* Optimize for sparse bitmaps. */

    if (*mem) {

      u8* mem8 = (u8*)mem;

      mem8[0] = simplify_lookup[mem8[0]];
      mem8[1] = simplify_lookup[mem8[1]];
      mem8[2] = simplify_lookup[mem8[2]];
      mem8[3] = simplify_lookup[mem8[3]];
      mem8[4] = simplify_lookup[mem8[4]];
      mem8[5] = simplify_lookup[mem8[5]];
      mem8[6] = simplify_lookup[mem8[6]];
      mem8[7] = simplify_lookup[mem8[7]];

    } else *mem = 0x0101010101010101ULL;

    mem++;

  }

}

#else

static void simplify_trace(u32* mem) {

  u32 i = MAP_SIZE >> 2;

  while (i--) {

    /* Optimize for sparse bitmaps. */

    if (*mem) {

      u8* mem8 = (u8*)mem;

      mem8[0] = simplify_lookup[mem8[0]];
      mem8[1] = simplify_lookup[mem8[1]];
      mem8[2] = simplify_lookup[mem8[2]];
      mem8[3] = simplify_lookup[mem8[3]];

    } else *mem = 0x01010101;

    mem++;
  }

}

#endif /* ^_WIN64 */


/* Destructively classify execution counts in a trace. This is used as a
   preprocessing step for any newly acquired traces. Called on every exec,
   must be fast. */

static const u8 count_class_lookup8[256] = {

  /* 0 - 3:       4 */ 0, 1, 2, 4,
  /* 4 - 7:      +4 */ AREP4(8),
  /* 8 - 15:     +8 */ AREP8(16),
  /* 16 - 31:   +16 */ AREP16(32),
  /* 32 - 127:  +96 */ AREP64(64), AREP32(64),
  /* 128+:     +128 */ AREP128(128)

};

static u16 count_class_lookup16[65536];


static void init_count_class16(void) {

  u32 b1, b2;

  for (b1 = 0; b1 < 256; b1++)
    for (b2 = 0; b2 < 256; b2++)
      count_class_lookup16[(b1 << 8) + b2] =
        (count_class_lookup8[b1] << 8) |
        count_class_lookup8[b2];

}


#ifdef _WIN64

static inline void classify_counts(u64* mem) {

  u32 i = MAP_SIZE >> 3;

  while (i--) {

    /* Optimize for sparse bitmaps. */

    if (*mem) {

      u16* mem16 = (u16*)mem;

      mem16[0] = count_class_lookup16[mem16[0]];
      mem16[1] = count_class_lookup16[mem16[1]];
      mem16[2] = count_class_lookup16[mem16[2]];
      mem16[3] = count_class_lookup16[mem16[3]];

    }

    mem++;

  }

}

#else

static inline void classify_counts(u32* mem) {

  u32 i = MAP_SIZE >> 2;

  while (i--) {

    /* Optimize for sparse bitmaps. */

    if (*mem) {

      u16* mem16 = (u16*)mem;

      mem16[0] = count_class_lookup16[mem16[0]];
      mem16[1] = count_class_lookup16[mem16[1]];

    }

    mem++;

  }

}

#endif /* ^_WIN64 */


/* Get rid of shared memory (atexit handler). */

static void remove_shm(void) {

     UnmapViewOfFile(trace_bits);
  	 CloseHandle(shm_handle);
     	
	 if (use_sample_shared_memory) {
	   UnmapViewOfFile(shm_sample);	
	   CloseHandle(sample_shm_handle);
	 }
	
}


/* Compact trace bytes into a smaller bitmap. We effectively just drop the
   count information here. This is called only sporadically, for some
   new paths. */

static void minimize_bits(u8* dst, u8* src) {

  u32 i = 0;

  while (i < MAP_SIZE) {

    if (*(src++)) dst[i >> 3] |= 1 << (i & 7);
    i++;

  }

}


/* When we bump into a new path, we call this to see if the path appears
   more "favorable" than any of the existing ones. The purpose of the
   "favorables" is to have a minimal set of paths that trigger all the bits
   seen in the bitmap so far, and focus on fuzzing them at the expense of
   the rest.

   The first step of the process is to maintain a list of top_rated[] entries
   for every byte in the bitmap. We win that slot if there is no previous
   contender, or if the contender has a more favorable speed x size factor. */

static void update_bitmap_score(struct queue_entry* q) {

  u32 i;
  u64 fav_factor = q->exec_us * q->len;

  /* For every byte set in trace_bits[], see if there is a previous winner,
     and how it compares to us. */

  for (i = 0; i < MAP_SIZE; i++)

    if (trace_bits[i]) {

       if (top_rated[i]) {

         /* Faster-executing or smaller test cases are favored. */

         if (fav_factor > top_rated[i]->exec_us * top_rated[i]->len) continue;

         /* Looks like we're going to win. Decrease ref count for the
            previous winner, discard its trace_bits[] if necessary. */

         if (!--top_rated[i]->tc_ref) {
           ck_free(top_rated[i]->trace_mini);
           top_rated[i]->trace_mini = 0;
         }

       }

       /* Insert ourselves as the new winner. */

       top_rated[i] = q;
       q->tc_ref++;

       if (!q->trace_mini) {
         q->trace_mini = ck_alloc(MAP_SIZE >> 3);
         minimize_bits(q->trace_mini, trace_bits);
       }

       score_changed = 1;

     }

}


/* The second part of the mechanism discussed above is a routine that
   goes over top_rated[] entries, and then sequentially grabs winners for
   previously-unseen bytes (temp_v) and marks them as favored, at least
   until the next run. The favored entries are given more air time during
   all fuzzing steps. */

static void cull_queue(void) {

  struct queue_entry* q;
  static u8 temp_v[MAP_SIZE >> 3];
  u32 i;

  if (dumb_mode || !score_changed) return;

  score_changed = 0;

  memset(temp_v, 255, MAP_SIZE >> 3);

  queued_favored  = 0;
  pending_favored = 0;

  q = queue;

  while (q) {
    q->favored = 0;
    q = q->next;
  }

  /* Let's see if anything in the bitmap isn't captured in temp_v.
     If yes, and if it has a top_rated[] contender, let's use it. */

  for (i = 0; i < MAP_SIZE; i++)
    if (top_rated[i] && (temp_v[i >> 3] & (1 << (i & 7)))) {

      u32 j = MAP_SIZE >> 3;

      /* Remove all bits belonging to the current entry from temp_v. */

      while (j--) 
        if (top_rated[i]->trace_mini[j])
          temp_v[j] &= ~top_rated[i]->trace_mini[j];

      top_rated[i]->favored = 1;
      queued_favored++;

      if (!top_rated[i]->was_fuzzed) pending_favored++;

    }

  q = queue;

  while (q) {
    mark_as_redundant(q, !q->favored);
    q = q->next;
  }

}


static void setup_sample_shm() {
	 unsigned int seeds[2];
	 u64 name_seed;

  SECURITY_DESCRIPTOR sd;
  SECURITY_ATTRIBUTES sa;

  // give everyone access, to allow attached processes to communicate
  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
  SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);

  sa.nLength = sizeof(sa);
  sa.lpSecurityDescriptor = &sd;
  sa.bInheritHandle = FALSE;

	 if (fuzzer_id == NULL) {
	   // If it is null, it means we have to generate a random seed to name the instance
		 rand_s(&seeds[0]);
		 rand_s(&seeds[1]);
		 name_seed = ((u64)seeds[0] << 32) | seeds[1];
		 fuzzer_id = (char*)alloc_printf("%I64x", name_seed);
	 }
	
  sample_shm_str = (char*)alloc_printf("sample_afl_shm_%s", fuzzer_id);
	//SAYF("sample_shm_str:\r\n", sample_shm_str);	

	sample_shm_handle = CreateFileMapping(
			INVALID_HANDLE_VALUE,    // use paging file
			&sa,                     // allow access to everyone
			PAGE_READWRITE,          // read/write access
			0,                       // maximum object size (high-order DWORD)
			MAX_SAMPLE_SIZE + sizeof(uint32_t),                // maximum object size (low-order DWORD)
		  sample_shm_str);        // name of mapping object
		
	if (sample_shm_handle == NULL) {
		FATAL("CreateFileMapping failed doe shm sample, %x", GetLastError());
	}

	shm_sample = (u8*)MapViewOfFile(
			sample_shm_handle,          // handle to map object
			FILE_MAP_ALL_ACCESS, // read/write permission
			0,
			0,
			MAX_SAMPLE_SIZE + sizeof(uint32_t)
		);
	//ck_free(use_shm_str);
	if (!shm_sample) PFATAL("shmat() for sample failed");	

}

/* Configure shared memory and virgin_bits. This is called at startup. */

static void setup_shm(void) {

  char* shm_str;
  unsigned int seeds[2];
  u64 name_seed;
  u8 attempts = 0;

  SECURITY_DESCRIPTOR sd;
  SECURITY_ATTRIBUTES sa;

  // give everyone access, to allow attached processes to communicate
  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
  SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);

  sa.nLength = sizeof(sa);
  sa.lpSecurityDescriptor = &sd;
  sa.bInheritHandle = FALSE;

  while(attempts < 5) {
    if(fuzzer_id == NULL) {
      // If it is null, it means we have to generate a random seed to name the instance
      rand_s(&seeds[0]);
      rand_s(&seeds[1]);
      name_seed = ((u64)seeds[0] << 32) | seeds[1];
      fuzzer_id = (char *)alloc_printf("%I64x", name_seed);
    }

    shm_str = (char *)alloc_printf("afl_shm_%s", fuzzer_id);

    shm_handle = CreateFileMapping(
                   INVALID_HANDLE_VALUE,    // use paging file
                   &sa,                     // allow access to everyone
                   PAGE_READWRITE,          // read/write access
                   0,                       // maximum object size (high-order DWORD)
                   MAP_SIZE,                // maximum object size (low-order DWORD)
                   (char *)shm_str);        // name of mapping object

    if(shm_handle == NULL) {
      if(sync_id) {
        PFATAL("CreateFileMapping failed (check slave id)");
      }

      if(GetLastError() == ERROR_ALREADY_EXISTS) {
        // We need another attempt to find a unique section name
        attempts++;
        ck_free(shm_str);
        ck_free(fuzzer_id);
        fuzzer_id = NULL;
        continue;
      }
      else {
        PFATAL("CreateFileMapping failed");
      }
    }

    // We found a section name that works!
    break;
  }

  if(attempts == 5) {
    FATAL("Could not find a section name.\n");
  }

  atexit(remove_shm);

  ck_free(shm_str);

  trace_bits = (u8 *)MapViewOfFile(
    shm_handle,          // handle to map object
    FILE_MAP_ALL_ACCESS, // read/write permission
    0,
    0,
    MAP_SIZE
  );

  if (!trace_bits) PFATAL("shmat() failed");

}

char* dlerror(){
    static char msg[1024] = {0};
    DWORD errCode = GetLastError();
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, errCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) msg, sizeof(msg)/sizeof(msg[0]), NULL);
    return msg;
}
/* Load postprocessor, if available. */

static void setup_post(void) {
    HMODULE dh;
    u8* fn = getenv("AFL_POST_LIBRARY");
    u32 tlen = 6;

    if (!fn) return;
    ACTF("Loading postprocessor from '%s'...", fn);
    dh = LoadLibraryA(fn);
    if (!dh) FATAL("%s", dlerror());
    post_handler = (u8* (*)(u8*,u32*))GetProcAddress(dh, "afl_postprocess");
    if (!post_handler) FATAL("Symbol 'afl_postprocess' not found.");

    /* Do a quick test. It's better to segfault now than later =) */
    post_handler("hello", &tlen);
    OKF("Postprocessor installed successfully.");
}

int compare_filename(const void *a, const void *b) {
	return strcmp(*((char **)a), *((char **)b));
}

int scandir_sorted(char *in_dir, char ***out) {
	unsigned int cnt=0, cnt2=0;
	WIN32_FIND_DATA fd;
    HANDLE h;
	char *pattern;

	if(in_dir[strlen(in_dir)-1] == '\\') {
		pattern = alloc_printf("%s*", in_dir);
	} else {
		pattern = alloc_printf("%s\\*", in_dir);
	}

	h = FindFirstFile(pattern, &fd);
	if(h == INVALID_HANDLE_VALUE) return -1;

    do {
		if(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) continue;
		if(strcmp(fd.cFileName, "README.txt") == 0) continue;

		cnt++;
    } while(FindNextFile(h, &fd));

	FindClose(h);

	*out = (char **)malloc(cnt*sizeof(char *));

	h = FindFirstFile(pattern, &fd);
	if(h == INVALID_HANDLE_VALUE) return -1;

    do {
		if(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) continue;
		if(strcmp(fd.cFileName, "README.txt") == 0) continue;

		cnt2++;
		if(cnt2>cnt) break;

		(*out)[cnt2-1] = (char *)malloc(strlen(fd.cFileName)+1);
		strcpy((*out)[cnt2-1], fd.cFileName);
    } while(FindNextFile(h, &fd));

	FindClose(h);

	if(cnt2 != cnt) return -1;

	qsort(*out, cnt, sizeof(char *), compare_filename);

	ck_free(pattern);

	return cnt;
}


__int64 FileSize(char *name) {
    WIN32_FILE_ATTRIBUTE_DATA fad;
    if (!GetFileAttributesEx(name, GetFileExInfoStandard, &fad))
        return -1; // error condition, could call GetLastError to find out more
	return (((__int64)fad.nFileSizeHigh) << 32) + fad.nFileSizeLow;
}


/* Read all testcases from the input directory, then queue them for testing.
   Called at startup. */


static void read_testcases(void) {

  char **nl;
  s32 nl_cnt;
  s32 i;
  u8* fn;

  /* Auto-detect non-in-place resumption attempts. */

  fn = alloc_printf("%s\\queue", in_dir);
  if (!_access(fn, 0)) in_dir = fn; else ck_free(fn);

  ACTF("Scanning '%s'...", in_dir);

  /* We use scandir() + alphasort() rather than readdir() because otherwise,
     the ordering  of test cases would vary somewhat randomly and would be
     difficult to control. */

  nl_cnt = scandir_sorted((char *)in_dir, &nl);

  if (nl_cnt < 0) {

    if (errno == ENOENT || errno == ENOTDIR)

      SAYF("\n" cLRD "[-] " cRST
           "The input directory does not seem to be valid - try again. The fuzzer needs\n"
           "    one or more test case to start with - ideally, a small file under 1 kB\n"
           "    or so. The cases must be stored as regular files directly in the input\n"
           "    directory.\n");

    PFATAL("Unable to open '%s'", in_dir);

  }

  if (shuffle_queue && nl_cnt > 1) {

    ACTF("Shuffling queue...");
    shuffle_ptrs((void**)nl, nl_cnt);

  }

  for (i = 0; i < nl_cnt; i++) {

    __int64 st_size;

    u8* fn = alloc_printf("%s\\%s", in_dir, nl[i]);
    u8* dfn = alloc_printf("%s\\.state\\deterministic_done\\%s", in_dir, nl[i]);

    u8  passed_det = 0;

    free(nl[i]); /* not tracked */
 
	st_size = FileSize(fn);

    if (_access(fn, 0) || (st_size < 0))
      PFATAL("Unable to access '%s'", fn);

    if (st_size == 0) {
      ck_free(fn);
      ck_free(dfn);
      continue;
    }

    if (st_size > MAX_FILE) 
      FATAL("Test case '%s' is too big (%s, limit is %s)", fn,
            DMS(st_size), DMS(MAX_FILE));

    /* Check for metadata that indicates that deterministic fuzzing
       is complete for this entry. We don't want to repeat deterministic
       fuzzing when resuming aborted scans, because it would be pointless
       and probably very time-consuming. */

    if (!_access(dfn, 0)) passed_det = 1;
    ck_free(dfn);

    add_to_queue(fn, st_size, passed_det);

  }

  free(nl); /* not tracked */

  if (!queued_paths) {

    SAYF("\n" cLRD "[-] " cRST
         "Looks like there are no valid test cases in the input directory! The fuzzer\n"
         "    needs one or more test case to start with - ideally, a small file under\n"
         "    1 kB or so. The cases must be stored as regular files directly in the\n"
         "    input directory.\n");

    FATAL("No usable test cases in '%s'", in_dir);

  }

  last_path_time = 0;
  queued_at_start = queued_paths;

}


/* Helper function for load_extras. */

static int compare_extras_len(const void* p1, const void* p2) {
  struct extra_data *e1 = (struct extra_data*)p1,
                    *e2 = (struct extra_data*)p2;

  return e1->len - e2->len;
}

static int compare_extras_use_d(const void* p1, const void* p2) {
  struct extra_data *e1 = (struct extra_data*)p1,
                    *e2 = (struct extra_data*)p2;

  return e2->hit_cnt - e1->hit_cnt;
}


/* Read extras from a file, sort by size. */

static void load_extras_file(u8* fname, u32* min_len, u32* max_len,
                             u32 dict_level) {

  FILE* f;
  u8  buf[MAX_LINE];
  u8  *lptr;
  u32 cur_line = 0;

  f = fopen(fname, "r");

  if (!f) PFATAL("Unable to open '%s'", fname);

  while ((lptr = fgets(buf, MAX_LINE, f))) {

    u8 *rptr, *wptr;
    u32 klen = 0;

    cur_line++;

    /* Trim on left and right. */

    while (isspace(*lptr)) lptr++;

    rptr = lptr + strlen(lptr) - 1;
    while (rptr >= lptr && isspace(*rptr)) rptr--;
    rptr++;
    *rptr = 0;

    /* Skip empty lines and comments. */

    if (!*lptr || *lptr == '#') continue;

    /* All other lines must end with '"', which we can consume. */

    rptr--;

    if (rptr < lptr || *rptr != '"')
      FATAL("Malformed name=\"value\" pair in line %u.", cur_line);

    *rptr = 0;

    /* Skip alphanumerics and dashes (label). */

    while (isalnum(*lptr) || *lptr == '_') lptr++;

    /* If @number follows, parse that. */

    if (*lptr == '@') {

      lptr++;
      if ((unsigned)atoi(lptr) > dict_level) continue;
      while (isdigit(*lptr)) lptr++;

    }

    /* Skip whitespace and = signs. */

    while (isspace(*lptr) || *lptr == '=') lptr++;

    /* Consume opening '"'. */

    if (*lptr != '"')
      FATAL("Malformed name=\"keyword\" pair in line %u.", cur_line);

    lptr++;

    if (!*lptr) FATAL("Empty keyword in line %u.", cur_line);

    /* Okay, let's allocate memory and copy data between "...", handling
       \xNN escaping, \\, and \". */

    extras = ck_realloc_block(extras, (extras_cnt + 1) *
               sizeof(struct extra_data));

    wptr = extras[extras_cnt].data = ck_alloc(rptr - lptr);

    while (*lptr) {

      char* hexdigits = "0123456789abcdef";

	  if(((*lptr)<32)||((*lptr)>127)) {
          FATAL("Non-printable characters in line %u.", cur_line);
	  }

      switch (*lptr) {
        case '\\':

          lptr++;

          if (*lptr == '\\' || *lptr == '"') {
            *(wptr++) = *(lptr++);
            klen++;
            break;
          }

          if (*lptr != 'x' || !isxdigit(lptr[1]) || !isxdigit(lptr[2]))
            FATAL("Invalid escaping (not \\xNN) in line %u.", cur_line);

          *(wptr++) =
            ((strchr(hexdigits, tolower(lptr[1])) - hexdigits) << 4) |
            (strchr(hexdigits, tolower(lptr[2])) - hexdigits);

          lptr += 3;
          klen++;

          break;

        default:

          *(wptr++) = *(lptr++);
          klen++;

      }

    }

    extras[extras_cnt].len = klen;

    if (extras[extras_cnt].len > MAX_DICT_FILE)
      FATAL("Keyword too big in line %u (%s, limit is %s)", cur_line,
            DMS(klen), DMS(MAX_DICT_FILE));

    if (*min_len > klen) *min_len = klen;
    if (*max_len < klen) *max_len = klen;

    extras_cnt++;

  }

  fclose(f);

}


/* Read extras from the extras directory and sort them by size. */

static void load_extras(u8* dir) {

  WIN32_FIND_DATA fdata;
  HANDLE h;
  u32 min_len = MAX_DICT_FILE, max_len = 0, dict_level = 0;
  u8* x;
  char *pattern;

  /* If the name ends with @, extract level and continue. */

  if ((x = strchr(dir, '@'))) {

    *x = 0;
    dict_level = atoi(x + 1);

  }

  ACTF("Loading extra dictionary from '%s' (level %u)...", dir, dict_level);

  if(dir[strlen(dir)-1] == '\\') {
    pattern = alloc_printf("%s*", dir);
  } else {
    pattern = alloc_printf("%s\\*", dir);
  }

  h = FindFirstFile(pattern, &fdata);

  if (h == INVALID_HANDLE_VALUE) {
    load_extras_file(dir, &min_len, &max_len, dict_level);
    goto check_and_sort;
  }

  if (x) FATAL("Dictionary levels not supported for directories.");

  do {
	u8* fn = alloc_printf("%s\\%s", dir, fdata.cFileName);
    s32 fd;

	if(fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
      ck_free(fn);
      continue;
	}

    if (_access(fn, 0))
      PFATAL("Unable to access '%s'", fn);

	if ((fdata.nFileSizeHigh > 0) || (fdata.nFileSizeLow > MAX_DICT_FILE))
      FATAL("Extra '%s' is too big (%s, limit is %s)", fn,
            DMS(fdata.nFileSizeLow), DMS(MAX_DICT_FILE));

    if (min_len > fdata.nFileSizeLow) min_len = fdata.nFileSizeLow;
    if (max_len < fdata.nFileSizeLow) max_len = fdata.nFileSizeLow;

    extras = ck_realloc_block(extras, (extras_cnt + 1) *
               sizeof(struct extra_data));

    extras[extras_cnt].data = ck_alloc(fdata.nFileSizeLow);
    extras[extras_cnt].len  = fdata.nFileSizeLow;

    fd = _open(fn, O_RDONLY | O_BINARY);

    if (fd < 0) PFATAL("Unable to open '%s'", fn);

    ck_read(fd, extras[extras_cnt].data, fdata.nFileSizeLow, fn);

    _close(fd);
    ck_free(fn);

    extras_cnt++;

  } while(FindNextFile(h, &fdata));

  ck_free(pattern);
  FindClose(h);

check_and_sort:

  if (!extras_cnt) FATAL("No usable files in '%s'", dir);

  qsort(extras, extras_cnt, sizeof(struct extra_data), compare_extras_len);

  OKF("Loaded %u extra tokens, size range %s to %s.", extras_cnt,
      DMS(min_len), DMS(max_len));

  if (max_len > 32)
    WARNF("Some tokens are relatively large (%s) - consider trimming.",
          DMS(max_len));

  if (extras_cnt > MAX_DET_EXTRAS)
    WARNF("More than %u tokens - will use them probabilistically.",
          MAX_DET_EXTRAS);

}




/* Helper function for maybe_add_auto() */

static inline u8 memcmp_nocase(u8* m1, u8* m2, u32 len) {

  while (len--) if (tolower(*(m1++)) ^ tolower(*(m2++))) return 1;
  return 0;

}


/* Maybe add automatic extra. */

static void maybe_add_auto(u8* mem, u32 len) {

  u32 i;

  /* Allow users to specify that they don't want auto dictionaries. */

  if (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS) return;

  /* Skip runs of identical bytes. */

  for (i = 1; i < len; i++)
    if (mem[0] ^ mem[i]) break;

  if (i == len) return;

  /* Reject builtin interesting values. */

  if (len == 2) {

    i = sizeof(interesting_16) >> 1;

    while (i--) 
      if (*((u16*)mem) == interesting_16[i] ||
          *((u16*)mem) == SWAP16(interesting_16[i])) return;

  }

  if (len == 4) {

    i = sizeof(interesting_32) >> 2;

    while (i--) 
      if (*((u32*)mem) == interesting_32[i] ||
          *((u32*)mem) == SWAP32(interesting_32[i])) return;

  }

  /* Reject anything that matches existing extras. Do a case-insensitive
     match. We optimize by exploiting the fact that extras[] are sorted
     by size. */

  for (i = 0; i < extras_cnt; i++)
    if (extras[i].len >= len) break;

  for (; i < extras_cnt && extras[i].len == len; i++)
    if (!memcmp_nocase(extras[i].data, mem, len)) return;

  /* Last but not least, check a_extras[] for matches. There are no
     guarantees of a particular sort order. */

  auto_changed = 1;

  for (i = 0; i < a_extras_cnt; i++) {

    if (a_extras[i].len == len && !memcmp_nocase(a_extras[i].data, mem, len)) {

      a_extras[i].hit_cnt++;
      goto sort_a_extras;

    }

  }

  /* At this point, looks like we're dealing with a new entry. So, let's
     append it if we have room. Otherwise, let's randomly evict some other
     entry from the bottom half of the list. */

  if (a_extras_cnt < MAX_AUTO_EXTRAS) {

    a_extras = ck_realloc_block(a_extras, (a_extras_cnt + 1) *
                                sizeof(struct extra_data));

    a_extras[a_extras_cnt].data = ck_memdup(mem, len);
    a_extras[a_extras_cnt].len  = len;
    a_extras_cnt++;

  } else {

    i = MAX_AUTO_EXTRAS / 2 +
        UR((MAX_AUTO_EXTRAS + 1) / 2);

    ck_free(a_extras[i].data);

    a_extras[i].data    = ck_memdup(mem, len);
    a_extras[i].len     = len;
    a_extras[i].hit_cnt = 0;

  }

sort_a_extras:

  /* First, sort all auto extras by use count, descending order. */

  qsort(a_extras, a_extras_cnt, sizeof(struct extra_data),
        compare_extras_use_d);

  /* Then, sort the top USE_AUTO_EXTRAS entries by size. */

  qsort(a_extras, MIN(USE_AUTO_EXTRAS, a_extras_cnt),
        sizeof(struct extra_data), compare_extras_len);

}


/* Save automatically generated extras. */

static void save_auto(void) {

  u32 i;

  if (!auto_changed) return;
  auto_changed = 0;

  for (i = 0; i < MIN(USE_AUTO_EXTRAS, a_extras_cnt); i++) {

    u8* fn = alloc_printf("%s\\queue\\.state\\auto_extras\\auto_%06u", out_dir, i);
    s32 fd;

    fd = _open(fn, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);

    if (fd < 0) PFATAL("Unable to create '%s'", fn);

    ck_write(fd, a_extras[i].data, a_extras[i].len, fn);

    _close(fd);
    ck_free(fn);

  }

}


/* Load automatically generated extras. */

static void load_auto(void) {

  u32 i;

  for (i = 0; i < USE_AUTO_EXTRAS; i++) {

    u8  tmp[MAX_AUTO_EXTRA + 1];
    u8* fn = alloc_printf("%s\\.state\\auto_extras\\auto_%06u", in_dir, i);
    s32 fd, len;

    fd = _open(fn, O_RDONLY | O_BINARY, DEFAULT_PERMISSION);

    if (fd < 0) {

      if (errno != ENOENT) PFATAL("Unable to open '%s'", fn);
      ck_free(fn);
      break;

    }

    /* We read one byte more to cheaply detect tokens that are too
       long (and skip them). */

    len = _read(fd, tmp, MAX_AUTO_EXTRA + 1);

    if (len < 0) PFATAL("Unable to read from '%s'", fn);

    if (len >= MIN_AUTO_EXTRA && len <= MAX_AUTO_EXTRA)
      maybe_add_auto(tmp, len);

    _close(fd);
    ck_free(fn);

  }

  if (i) OKF("Loaded %u auto-discovered dictionary tokens.", i);
  else OKF("No auto-generated dictionary tokens to reuse.");

}


/* Destroy extras. */

static void destroy_extras(void) {

  u32 i;

  for (i = 0; i < extras_cnt; i++) 
    ck_free(extras[i].data);

  ck_free((char *)extras);

  for (i = 0; i < a_extras_cnt; i++) 
    ck_free(a_extras[i].data);

  ck_free((char *)a_extras);

}


/* Spin up fork server (instrumented mode only). The idea is explained here:

   http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html

   In essence, the instrumentation allows us to skip execve(), and just keep
   cloning a stopped child. So, we just execute once, and then send commands
   through a pipe. The other part of this logic is in afl-as.h. */

static void init_forkserver(char** argv) {
  //not implemented on Windows
}

//quoting on Windows is weird
size_t ArgvQuote(char *in, char *out) {
	int needs_quoting = 0;
	size_t size = 0;
	char *p = in;
	size_t i;

	//check if quoting is necessary
	if(strchr(in, ' ')) needs_quoting = 1;
	if(strchr(in, '\"')) needs_quoting = 1;
	if(strchr(in, '\t')) needs_quoting = 1;
	if(strchr(in, '\n')) needs_quoting = 1;
	if(strchr(in, '\v')) needs_quoting = 1;
	if(!needs_quoting) {
		size = strlen(in);
		if(out) memcpy(out, in, size);
		return size;
	}

	if(out) out[size] = '\"';
	size++;

	while(*p) {
		size_t num_backslashes = 0;
		while((*p) && (*p == '\\')) {
			p++;
			num_backslashes++;
		}

		if(*p == 0) {
			for(i = 0; i < (num_backslashes*2); i++) {
				if(out) out[size] = '\\';
				size++;
			}
			break;
		} else if(*p == '\"') {
			for(i = 0; i < (num_backslashes*2 + 1); i++) {
				if(out) out[size] = '\\';
				size++;
			}
			if(out) out[size] = *p;
			size++;
		} else {
			for(i = 0; i < num_backslashes; i++) {
				if(out) out[size] = '\\';
				size++;
			}
			if(out) out[size] = *p;
			size++;
		}

		p++;
	}

	if(out) out[size] = '\"';
	size++;

	return size;
}

char *argv_to_cmd(char** argv) {
  u32 len = 0, i;
  u8* buf, *ret;

  //todo shell-escape

  for (i = 0; argv[i]; i++)
    len += ArgvQuote(argv[i], NULL) + 1;
  
  if(!len) FATAL("Error creating command line");

  buf = ret = ck_alloc(len);

  for (i = 0; argv[i]; i++) {

    u32 l = ArgvQuote(argv[i], buf);

	buf += l;

	*(buf++) = ' ';
  }

  ret[len-1] = 0;

  return ret;
}

/*Initialazing overlapped structure and connecting*/
static BOOL OverlappedConnectNamedPipe(HANDLE pipe_h, LPOVERLAPPED overlapped)
{
	ZeroMemory(overlapped, sizeof(*overlapped));
	
	overlapped->hEvent = CreateEvent(
		NULL,    // default security attribute 
		TRUE,    // manual-reset event 
		TRUE,    // initial state = signaled 
		NULL);   // unnamed event object 

	if (overlapped->hEvent == NULL)
	{
		return FALSE;
	}

	if (ConnectNamedPipe(pipe_h, overlapped))
	{
		return FALSE;
	}
	switch (GetLastError())
	{
		// The overlapped connection in progress. 
	case ERROR_IO_PENDING:
		WaitForSingleObject(overlapped->hEvent, INFINITE);
		return TRUE;
		// Client is already connected
	case ERROR_PIPE_CONNECTED:
		return TRUE;
	default:
	{
		return FALSE;
	}
	}
}

static BOOL module_loaded_to_pid(u32 pid, char * module_name)
{
  BOOL found = FALSE;
  MODULEENTRY32 module_entry;
  HANDLE module_snap = INVALID_HANDLE_VALUE;
  char current_module[MAX_PATH];
  size_t chars_converted;

  module_snap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
  if (module_snap == INVALID_HANDLE_VALUE) {
    return FALSE;
  }

  module_entry.dwSize = sizeof(MODULEENTRY32);

  if (!Module32First(module_snap, &module_entry)) {
    CloseHandle(module_snap);
    return FALSE;
  }

  do {
    if (strcmp(module_entry.szModule, module_name) == 0) {
      found = TRUE;
    }
  } while(!found && Module32Next(module_snap, &module_entry));

  CloseHandle(module_snap);
  return found;
}

static u32 find_attach_pid(char * module_name)
{
  u32 attach_pid = 0;
  u8 found = FALSE;
  u32 attempt = 0;

  PROCESSENTRY32 process_entry;
  HANDLE process_snap = INVALID_HANDLE_VALUE;

  do {
    process_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (process_snap == INVALID_HANDLE_VALUE) {
      FATAL("Failed to create snapshot");
    }

    process_entry.dwSize = sizeof(PROCESSENTRY32);
    if (!Process32First(process_snap, &process_entry)) {
      CloseHandle(process_snap);
      FATAL("Failed to enumerate processes");
    }

    do {
      if (module_loaded_to_pid(process_entry.th32ProcessID, module_name)) {
        if (found) {
          FATAL("Attach module loaded to more than one process");
        }
        found = TRUE;
        attach_pid = process_entry.th32ProcessID;
      }
    } while (Process32Next(process_snap, &process_entry));

    CloseHandle(process_snap);

    Sleep(1000);
  } while (!found && (++attempt < MAX_ATTACH_ATTEMPTS));

  return attach_pid;
}

static void create_target_process(char** argv) {
  char *cmd;
  char *pipe_name;
  char *buf;
  char *pidfile;
  char *client_invocation;
  FILE *fp;
  size_t pidsize;
  BOOL inherit_handles = TRUE;

  HANDLE hJob = NULL;
  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  SECURITY_DESCRIPTOR sd;
  SECURITY_ATTRIBUTES sa;

  // give everyone access, to allow attached processes to communicate
  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
  SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);

  sa.nLength = sizeof(sa);
  sa.lpSecurityDescriptor = &sd;
  sa.bInheritHandle = FALSE;

  pipe_name = (char *)alloc_printf("\\\\.\\pipe\\afl_pipe_%s", fuzzer_id);

  pipe_handle = CreateNamedPipe(
    pipe_name,                // pipe name
    PIPE_ACCESS_DUPLEX |      // read/write access 
    FILE_FLAG_OVERLAPPED,     // overlapped mode 
    0,
    1,                        // max. instances
    512,                      // output buffer size
    512,                      // input buffer size
    20000,                    // client time-out
    &sa);                     // allow access to everyone

  if (pipe_handle == INVALID_HANDLE_VALUE) {
    FATAL("CreateNamedPipe failed, GLE=%d.\n", GetLastError());
  }

  target_cmd = argv_to_cmd(argv);

  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));

  if(sinkhole_stds) {
    si.hStdOutput = si.hStdError = devnul_handle;
    si.dwFlags |= STARTF_USESTDHANDLES;
  } else {
    inherit_handles = FALSE;
  }

  if (expert_mode) {
    client_invocation = alloc_printf("-t winafl");
  } else {
    client_invocation = alloc_printf("-c %s", winafl_dll_path);
  }

  if(drioless) {
    char *static_config = alloc_printf("%s:%d", fuzzer_id, fuzz_iterations_max);

    if (static_config == NULL) {
      FATAL("Cannot allocate static_config.");
    }

    SetEnvironmentVariable("AFL_STATIC_CONFIG", static_config);
    cmd = alloc_printf("%s", target_cmd);
    ck_free(static_config);
  }
  else {
    if (drattach) {
      drattachpid = find_attach_pid(drattach_identifier);
      cmd = alloc_printf(
        "%s\\drrun.exe -attach %ld -no_follow_children %s %s -fuzzer_id %s",
        dynamorio_dir, drattachpid, client_invocation, client_params, fuzzer_id);
    } else {
      pidfile = alloc_printf("childpid_%s.txt", fuzzer_id);
      if (persist_dr_cache) {
        cmd = alloc_printf(
          "%s\\drrun.exe -pidfile %s -no_follow_children -persist -persist_dir \"%s\\drcache\" %s %s -fuzzer_id %s -drpersist -- %s",
          dynamorio_dir, pidfile, out_dir, client_invocation, client_params, fuzzer_id, target_cmd);
      } else {
        cmd = alloc_printf(
          "%s\\drrun.exe -pidfile %s -no_follow_children %s %s -fuzzer_id %s -- %s",
          dynamorio_dir, pidfile, client_invocation, client_params, fuzzer_id, target_cmd);
      }
    }
  }
  if(mem_limit || cpu_aff) {
    hJob = CreateJobObject(NULL, NULL);
    if(hJob == NULL) {
      FATAL("CreateJobObject failed, GLE=%d.\n", GetLastError());
    }

    ZeroMemory(&job_limit, sizeof(job_limit));
    if (mem_limit) {
      job_limit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
      job_limit.ProcessMemoryLimit = mem_limit * 1024 * 1024;
    }
	
    if (cpu_aff) {
      job_limit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_AFFINITY;
      job_limit.BasicLimitInformation.Affinity = (DWORD_PTR)cpu_aff;
    }

    if(!SetInformationJobObject(
      hJob,
      JobObjectExtendedLimitInformation,
      &job_limit,
      sizeof(job_limit)
    )) {
      FATAL("SetInformationJobObject failed, GLE=%d.\n", GetLastError());
    }
  }

  if(!CreateProcess(NULL, cmd, NULL, NULL, inherit_handles, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
    FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
  }

  child_handle = pi.hProcess;
  child_thread_handle = pi.hThread;

  if(mem_limit || cpu_aff) {
    if(!AssignProcessToJobObject(hJob, child_handle)) {
      FATAL("AssignProcessToJobObject failed, GLE=%d.\n", GetLastError());
    }
    CloseHandle(hJob);
  }

  ResumeThread(child_thread_handle);

  watchdog_timeout_time = get_cur_time() + exec_tmout;
  watchdog_enabled = 1;

  if(!OverlappedConnectNamedPipe(pipe_handle, &pipe_overlapped)) {
      FATAL("ConnectNamedPipe failed, GLE=%d.\n", GetLastError());
  }

  watchdog_enabled = 0;

  if (drattach) {
    child_pid = drattachpid;

    CloseHandle(child_handle);
    child_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, child_pid);
    if (child_handle == NULL)
    {
      FATAL("OpenProcess failed, GLE=%d.\n", GetLastError());
    }

    CloseHandle(child_thread_handle);
    child_thread_handle = NULL;
  }
  else if (drioless == 0) {
    //by the time pipe has connected the pidfile must have been created
    fp = fopen(pidfile, "rb");
    if(!fp) {
      FATAL("Error opening pidfile.txt");
    }
    fseek(fp,0,SEEK_END);
    pidsize = ftell(fp);
    fseek(fp,0,SEEK_SET);
    buf = (char *)malloc(pidsize+1);
    if (!buf) {
        FATAL("Error allocating %Iu bytes", pidsize + 1);
    }
    fread(buf, pidsize, 1, fp);
    buf[pidsize] = 0;
    fclose(fp);
    remove(pidfile);
    child_pid = atoi(buf);
    free(buf);
    ck_free(pidfile);
  }
  else {
    child_pid = pi.dwProcessId;
  }

  ck_free(client_invocation);
  ck_free(target_cmd);
  ck_free(cmd);
  ck_free(pipe_name);
}


static void destroy_target_process(int wait_exit) {
	char* kill_cmd;
	BOOL still_alive = TRUE;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

#ifdef TINYINST
  if (use_tinyinst) {
    tinyinst_killtarget();
    return;
  }
#endif

	EnterCriticalSection(&critical_section);

  if (drattach) {
    // reset the attach pid for next round
    drattachpid = 0;
  }

	if (!child_handle) {
		goto leave;
	}

	if (WaitForSingleObject(child_handle, wait_exit) != WAIT_TIMEOUT) {
		goto done;
	}

	// nudge the child process only if dynamorio is used
	if (drioless) {
		TerminateProcess(child_handle, 0);
	}
	else {
		kill_cmd = alloc_printf("%s\\drconfig.exe -nudge_pid %d 0 1", dynamorio_dir, child_pid);

		ZeroMemory(&si, sizeof(si));
		si.cb = sizeof(si);
		ZeroMemory(&pi, sizeof(pi));

		if (!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
			FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
		}

		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);

		ck_free(kill_cmd);
	}

	still_alive = WaitForSingleObject(child_handle, 2000) == WAIT_TIMEOUT;

	if (still_alive) {
		//wait until the child process exits
		ZeroMemory(&si, sizeof(si));
		si.cb = sizeof(si);
		ZeroMemory(&pi, sizeof(pi));

		kill_cmd = alloc_printf("taskkill /PID %d /F", child_pid);

		if (!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
			FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
		}

		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);

		ck_free(kill_cmd);

		if (WaitForSingleObject(child_handle, 20000) == WAIT_TIMEOUT) {
			FATAL("Cannot kill child process\n");
		}
	}

done:
  if (child_handle) {
    CloseHandle(child_handle);
    child_handle = NULL;
  }
  if (child_thread_handle) {
    CloseHandle(child_thread_handle);
    child_thread_handle = NULL;
  }

leave:
	//close the pipe
	if (pipe_handle) {
		DisconnectNamedPipe(pipe_handle);
		CloseHandle(pipe_handle);
		CloseHandle(pipe_overlapped.hEvent);

		pipe_handle = NULL;
	}

	LeaveCriticalSection(&critical_section);
}

DWORD WINAPI watchdog_timer( LPVOID lpParam ) {
	u64 current_time;
	while(1) {
		Sleep(1000);
		current_time = get_cur_time();
		if(watchdog_enabled && (current_time > watchdog_timeout_time)) {
			destroy_target_process(0);
		}
	}
}

char ReadCommandFromPipe(u32 timeout)
{
	DWORD num_read;
	char result = 0;
	if (!is_child_running())
	{
		return 0;
	}

	if (ReadFile(pipe_handle, &result, 1, &num_read, &pipe_overlapped) || GetLastError() == ERROR_IO_PENDING)
	{
		//ACTF("ReadFile success or GLE IO_PENDING", result);
		if (WaitForSingleObject(pipe_overlapped.hEvent, timeout) != WAIT_OBJECT_0) {
			// took longer than specified timeout or other error - cancel read
			CancelIo(pipe_handle);
			WaitForSingleObject(pipe_overlapped.hEvent, INFINITE); //wait for cancelation to finish properly.
			result = 0;
		}
	}
	//ACTF("ReadFile GLE %d", GetLastError());
	//ACTF("read from pipe '%c'", result);
	return result;
}

DWORD ReadDWORDFromPipe(u32 timeout)
{
	DWORD num_read;
	DWORD result = 0;

	//char result = 0;
	if (!is_child_running())
	{
		return 0;
	}
		if (ReadFile(pipe_handle, &result, sizeof(DWORD), &num_read, &pipe_overlapped) || GetLastError() == ERROR_IO_PENDING)
		{
			//ACTF("ReadFile success or GLE IO_PENDING");
			if (WaitForSingleObject(pipe_overlapped.hEvent, timeout) != WAIT_OBJECT_0) {
				// took longer than specified timeout or other error - cancel read
				CancelIo(pipe_handle);
				WaitForSingleObject(pipe_overlapped.hEvent, INFINITE); //wait for cancelation to finish properly.
				result = 0;
			}
		}
	
	//ACTF("ReadFile GLE: %d", GetLastError());
	//ACTF("result: '%lu'\r\n", result);
	//ACTF("read so far '%lu'\r\n", read_so_far);
	return result;
}

void WriteCommandToPipe(char cmd)
{
	DWORD num_written;
	//ACTF("write to pipe '%c'", cmd);
	WriteFile(pipe_handle, &cmd, 1, &num_written, &pipe_overlapped);
}

static void setup_watchdog_timer() {
	watchdog_enabled = 0;
	InitializeCriticalSection(&critical_section);
	CreateThread(NULL, 0, watchdog_timer, 0, 0, NULL);
}

static int is_child_running() {
  int ret;

  EnterCriticalSection(&critical_section);
  ret = (child_handle && (WaitForSingleObject(child_handle, 0 ) == WAIT_TIMEOUT));
  LeaveCriticalSection(&critical_section);

  return ret;
}

//Define the function prototypes
typedef int (APIENTRY* dll_run)(char*, long, int);
typedef int (APIENTRY* dll_init)();
typedef u8 (APIENTRY* dll_run_target)(char**, u32, char*, u32);
typedef void (APIENTRY *dll_write_to_testcase)(char*, s32, const void*, u32);
typedef u8 (APIENTRY* dll_mutate_testcase)(char**, u8*, u32, u8 (*)(char **, u8*, u32));
typedef u8 (APIENTRY* dll_trim_testcase)(u32*, u32, u8*, u8*, void (*)(void*, u32), u8 (*)(char**, u32), char**, u32);

// Parameters: argv, in_buf, buffer_length, mutation_iterations, common_fuzz_stuff
typedef u8 (APIENTRY* dll_mutate_testcase_with_energy)(char**, u8*, u32, u32, u8 (*)(char **, u8*, u32));

// custom server functions
dll_run dll_run_ptr = NULL;
dll_init dll_init_ptr = NULL;
dll_run_target dll_run_target_ptr = NULL;
dll_write_to_testcase dll_write_to_testcase_ptr = NULL;
dll_mutate_testcase dll_mutate_testcase_ptr = NULL;
dll_trim_testcase dll_trim_testcase_ptr = NULL;
dll_mutate_testcase_with_energy dll_mutate_testcase_with_energy_ptr = NULL;

char *get_test_case(long *fsize)
{
  /* open generated file */
  s32 fd = out_fd;
  if (out_file != NULL)
    fd = open(out_file, O_RDONLY | O_BINARY);

  *fsize = lseek(fd, 0, SEEK_END);
  lseek(fd, 0, SEEK_SET);

  /* allocate buffer to read the file */
  char *buf = malloc(*fsize);
  ck_read(fd, buf, *fsize, "input file");

  if(out_file != NULL)
    close(fd);

  return buf;
}

/* This function is used to call user-defined server routine to send data back into sample */
static int process_test_case_into_dll(int fuzz_iterations)
{
  int result;
  long fsize;

  char *buf = get_test_case(&fsize);

  result = dll_run_ptr(buf, fsize, fuzz_iterations); /* caller should copy the buffer */

  free(buf);

  if (result == 0)
    FATAL("Unable to process test case, the user-defined DLL returned 0");

  return 1;
}

/* Execute target application, monitoring for timeouts. Return status
   information. The called program will update trace_bits[]. */

static u8 run_target(char** argv, u32 timeout) {
	total_execs++;

  memset(trace_bits, 0, MAP_SIZE);
  MemoryBarrier();

  if (dll_run_target_ptr) {
    return dll_run_target_ptr(argv, timeout, trace_bits, MAP_SIZE);
  }

#ifdef INTELPT
	if (use_intelpt) {
		return run_target_pt(argv, timeout);
	}
#endif

#ifdef TINYINST
  if (use_tinyinst) {
    return tinyinst_run(argv, timeout);
  }
#endif

  //todo watchdog timer to detect hangs
  DWORD num_read, dwThreadId;
  char result = 0;
  
 
  if(sinkhole_stds && devnul_handle == INVALID_HANDLE_VALUE) {
    devnul_handle = CreateFile(
        "nul",
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if(devnul_handle == INVALID_HANDLE_VALUE) {
      PFATAL("Unable to open the nul device.");
    }
  }

  if (dll_init_ptr) {
    if (!dll_init_ptr())
      PFATAL("User-defined custom initialization routine returned 0");
  }

  if(!is_child_running()) {
    destroy_target_process(0);
    create_target_process(argv);
    fuzz_iterations_current = 0;
  }

  if (dll_run_ptr)
    process_test_case_into_dll(fuzz_iterations_current);

  child_timed_out = 0;
  if (fuzz_iterations_current == 0 && init_tmout != 0) {
	  watchdog_timeout_time = get_cur_time() + init_tmout;
  }
  else {
	  watchdog_timeout_time = get_cur_time() + timeout;
  }
  watchdog_enabled = 1;
  result = ReadCommandFromPipe(timeout);
  if (result == 'K')
  {
	  //a workaround for first cycle in app persistent mode
	  result = ReadCommandFromPipe(timeout);
  }
  if (result == 0) 
  {
	  //saves us from getting stuck in corner case.
	  MemoryBarrier();
	  watchdog_enabled = 0;

      destroy_target_process(0);
      return FAULT_TMOUT;
  }
  if (result != 'P')
  {
	  FATAL("Unexpected result from pipe! expected 'P', instead received '%c'\n", result);
  }
  WriteCommandToPipe('F');

  result = ReadCommandFromPipe(timeout); //no need to check for "error(0)" since we are exiting anyway
  //ACTF("result: '%c'", result);
  MemoryBarrier();
  watchdog_enabled = 0;

#ifdef _WIN64
  classify_counts((u64*)trace_bits);
#else
  classify_counts((u32*)trace_bits);
#endif /* ^_WIN64 */

  fuzz_iterations_current++;

  if(fuzz_iterations_current == fuzz_iterations_max) {
	  destroy_target_process(2000);
  }

  if (result == 'K') return FAULT_NONE;

  if (result == 'C') {
	  ret_exception_code = ReadDWORDFromPipe(timeout);
	 // ACTF("destroying target process");
	  destroy_target_process(2000);
	  return FAULT_CRASH;
  }

  destroy_target_process(0);
  return FAULT_TMOUT;
}


/* Write modified data to file for testing. If out_file is set, the old file
   is unlinked and a new one is created. Otherwise, out_fd is rewound and
   truncated. */

static void write_to_testcase(void* mem, u32 len) {

  if (dll_write_to_testcase_ptr) {	  
      dll_write_to_testcase_ptr(out_file, out_fd, mem, len);
      return;
  } else if (use_sample_shared_memory) {        
      //this writes fuzzed data to shared memory, so that it is available to harnes program.
      uint32_t* size_ptr = (uint32_t*)shm_sample;
      unsigned char* data_ptr = shm_sample + 4;
     
      if (len > MAX_SAMPLE_SIZE) len = MAX_SAMPLE_SIZE;
     
      *size_ptr = len;
      memcpy(data_ptr, mem, len);
     
      return;
    }

  s32 fd = out_fd;

  if (out_file) {

    fd = open(out_file, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);

    if (fd < 0) {
      destroy_target_process(0);
      
	  fd = open(out_file, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);
		
      if (fd < 0) PFATAL("Unable to create '%s'", out_file);

	}

  } else lseek(fd, 0, SEEK_SET);

  ck_write(fd, mem, len, out_file);

  if (!out_file) {

    if (_chsize(fd, len)) PFATAL("ftruncate() failed");
    lseek(fd, 0, SEEK_SET);

  } else close(fd);

}


/* The same, but with an adjustable gap. Used for trimming. */

static void write_with_gap(char* mem, u32 len, u32 skip_at, u32 skip_len) {
  
  char* trimmed_mem = malloc(len - skip_len);
  memcpy(trimmed_mem, mem, skip_at); //copy start
  memcpy(trimmed_mem + skip_at, mem + skip_at + skip_len, len - (skip_at + skip_len));
  write_to_testcase(trimmed_mem, len - skip_len);
  free(trimmed_mem);
}


static void show_stats(void);

/* Calibrate a new test case. This is done when processing the input directory
   to warn about flaky or otherwise problematic test cases early on; and when
   new paths are discovered to detect variable behavior and so on. */

static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem,
                         u32 handicap, u8 from_queue) {

  static u8 first_trace[MAP_SIZE];

  u8  fault = 0, new_bits = 0, var_detected = 0, hnb = 0,
      first_run = (q->exec_cksum == 0);

  u64 start_us, stop_us;

  s32 old_sc = stage_cur, old_sm = stage_max;
  u32 use_tmout = exec_tmout;
  u8* old_sn = stage_name;

  /* Be a bit more generous about timeouts when resuming sessions, or when
     trying to calibrate already-added finds. This helps avoid trouble due
     to intermittent latency. */

  if (!from_queue || resuming_fuzz)
    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,
                    exec_tmout * CAL_TMOUT_PERC / 100);

  q->cal_failed++;

  stage_name = "calibration";
  stage_max  = CAL_CYCLES;

  /* Make sure the forkserver is up before we do anything, and let's not
     count its spin-up time toward binary calibration. */

  if (q->exec_cksum) {

    memcpy(first_trace, trace_bits, MAP_SIZE);
    hnb = has_new_bits(virgin_bits);
    if (hnb > new_bits) new_bits = hnb;

  }

  start_us = get_cur_time_us();

  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {

    u32 cksum;

    if (!first_run && !(stage_cur % stats_update_freq)) show_stats();

    write_to_testcase(use_mem, q->len);

    fault = run_target(argv, use_tmout);

    /* stop_soon is set by the handler for Ctrl+C. When it's pressed,
       we want to bail out quickly. */

    if (stop_soon || fault != crash_mode) goto abort_calibration;

    if (!dumb_mode && !stage_cur && !count_bytes(trace_bits)) {
      fault = FAULT_NOINST;
      goto abort_calibration;
    }

    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);

    if (q->exec_cksum != cksum) {

      hnb = has_new_bits(virgin_bits);
      if (hnb > new_bits) new_bits = hnb;

      if (q->exec_cksum) {

        u32 i;

        for (i = 0; i < MAP_SIZE; i++)
          if (!var_bytes[i] && first_trace[i] != trace_bits[i]) {
            var_bytes[i] = 1;
            stage_max    = CAL_CYCLES_LONG;
          }

        var_detected = 1;

      } else {

        q->exec_cksum = cksum;
        memcpy(first_trace, trace_bits, MAP_SIZE);

      }

    }

  }

  stop_us = get_cur_time_us();

  total_cal_us     += stop_us - start_us;
  total_cal_cycles += stage_max;

  /* OK, let's collect some stats about the performance of this test case.
     This is used for fuzzing air time calculations in calculate_score(). */

  q->exec_us     = (stop_us - start_us) / stage_max;
  q->bitmap_size = count_bytes(trace_bits);
  q->handicap    = handicap;
  q->cal_failed  = 0;

  total_bitmap_size += q->bitmap_size;
  total_bitmap_entries++;

  update_bitmap_score(q);

  /* If this case didn't result in new output from the instrumentation, tell
     parent. This is a non-critical problem, but something to warn the user
     about. */

  if (!dumb_mode && first_run && !fault && !new_bits) fault = FAULT_NOBITS;

abort_calibration:

  if (new_bits == 2 && !q->has_new_cov) {
    q->has_new_cov = 1;
    queued_with_cov++;
  }

  /* Mark variable paths. */

  if (var_detected) {

    var_byte_count = count_bytes(var_bytes);

    if (!q->var_behavior) {
      mark_as_variable(q);
      queued_variable++;
    }

  }

  stage_name = old_sn;
  stage_cur  = old_sc;
  stage_max  = old_sm;

  if (!first_run) show_stats();

  return fault;

}


/* Examine map coverage. Called once, for first test case. */

static void check_map_coverage(void) {

  u32 i;

  if (count_bytes(trace_bits) < 100) return;

  for (i = (1 << (MAP_SIZE_POW2 - 1)); i < MAP_SIZE; i++)
    if (trace_bits[i]) return;

  WARNF("Recompile binary with newer version of afl to improve coverage!");

}


/* Perform dry run of all test cases to confirm that the app is working as
   expected. This is done only for the initial inputs, and only once. */

static void perform_dry_run(char** argv) {

  struct queue_entry* q = queue;
  u32 cal_failures = 0;
  u8* skip_crashes = getenv("AFL_SKIP_CRASHES");

  while (q) {

    u8* use_mem;
    u8  res;
    s32 fd;

    u8* fn = strrchr(q->fname, '\\') + 1;

    ACTF("Attempting dry run with '%s'...", fn);

    fd = open(q->fname, O_RDONLY | O_BINARY);
    if (fd < 0) PFATAL("Unable to open '%s'", q->fname);

    use_mem = ck_alloc_nozero(q->len);

    if (read(fd, use_mem, q->len) != q->len)
      FATAL("Short read from '%s'", q->fname);

    close(fd);

    res = calibrate_case(argv, q, use_mem, 0, 1);
    ck_free(use_mem);

    if (stop_soon) return;

    if (res == crash_mode || res == FAULT_NOBITS)
      SAYF(cGRA "    len = %u, map size = %u, exec speed = %llu us\n" cRST, 
           q->len, q->bitmap_size, q->exec_us);

    switch (res) {

      case FAULT_NONE:

        if (q == queue) check_map_coverage();

        if (crash_mode) FATAL("Test case '%s' does *NOT* crash", fn);

        break;

      case FAULT_TMOUT:

        if (timeout_given) {

          /* The -t nn+ syntax in the command line sets timeout_given to '2' and
             instructs afl-fuzz to tolerate but skip queue entries that time
             out. */

          if (timeout_given > 1) {
            WARNF("Test case results in a timeout (skipping)");
            q->cal_failed = CAL_CHANCES;
            cal_failures++;
            break;
          }

          SAYF("\n" cLRD "[-] " cRST
               "The program took more than %u ms to process one of the initial test cases.\n"
               "    In WinAFL, this error could also mean incorrect instrumentation params.\n"
               "    Please make sure instrumentation runs correctly using the debug mode\n"
               "    (see the README) before attempting to run afl-fuzz.\n", exec_tmout);

          FATAL("Test case '%s' results in a timeout", fn);

        } else {

          SAYF("\n" cLRD "[-] " cRST
               "The program took more than %u ms to process one of the initial test cases.\n"
               "    This is bad news; raising the limit with the -t option is possible, but\n"
               "    will probably make the fuzzing process extremely slow.\n\n"

               "    If this test case is just a fluke, the other option is to just avoid it\n"
               "    altogether, and find one that is less of a CPU hog.\n", exec_tmout);

          FATAL("Test case '%s' results in a timeout", fn);

        }

      case FAULT_CRASH:  

        if (crash_mode) break;

        if (skip_crashes) {
          WARNF("Test case results in a crash (skipping)");
          q->cal_failed = CAL_CHANCES;
          cal_failures++;
          break;
        }

        if (mem_limit) {

          SAYF("\n" cLRD "[-] " cRST
               "Oops, the program crashed with one of the test cases provided. There are\n"
               "    several possible explanations:\n\n"

               "    - The test case causes known crashes under normal working conditions. If\n"
               "      so, please remove it. The fuzzer should be seeded with interesting\n"
               "      inputs - but not ones that cause an outright crash.\n\n"

               "    - The current memory limit (%s) is too low for this program, causing\n"
               "      it to die due to OOM when parsing valid files. To fix this, try\n"
               "      bumping it up with the -m setting in the command line. If in doubt,\n"
               "      try something along the lines of:\n\n"

               "      ( ulimit -Sd $[%llu << 10]; \\path\\to\\binary [...] <testcase )\n\n"

               "      Tip: you can use http:\\\\jwilk.net\\software\\recidivm to quickly\n"
               "      estimate the required amount of virtual memory for the binary. Also,\n"
               "      if you are using ASAN, see %s\\notes_for_asan.txt.\n\n"

               "    - Least likely, there is a horrible bug in the fuzzer. If other options\n"
               "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
               DMS(mem_limit << 20), mem_limit - 1, doc_path);

        } else {

          SAYF("\n" cLRD "[-] " cRST
               "Oops, the program crashed with one of the test cases provided. There are\n"
               "    several possible explanations:\n\n"

               "    - The test case causes known crashes under normal working conditions. If\n"
               "      so, please remove it. The fuzzer should be seeded with interesting\n"
               "      inputs - but not ones that cause an outright crash.\n\n"

               "    - Least likely, there is a horrible bug in the fuzzer. If other options\n"
               "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n");

        }

        FATAL("Test case '%s' results in a crash", fn);

      case FAULT_ERROR:

        FATAL("Unable to execute target application ('%s')", argv[0]);

      case FAULT_NOINST:

        FATAL("No instrumentation detected");

      case FAULT_NOBITS: 

        useless_at_start++;

        if (!in_bitmap && !shuffle_queue)
          WARNF("No new instrumentation output, test case may be useless.");

        break;

    }

    if (q->var_behavior) WARNF("Instrumentation output varies across runs.");

    q = q->next;

  }

  if (cal_failures) {

    if (cal_failures == queued_paths)
      FATAL("All test cases time out%s, giving up!",
            skip_crashes ? " or crash" : "");

    WARNF("Skipped %u test cases (%0.02f%%) due to timeouts%s.", cal_failures,
          ((double)cal_failures) * 100 / queued_paths,
          skip_crashes ? " or crashes" : "");

    if (cal_failures * 5 > queued_paths)
      WARNF(cLRD "High percentage of rejected test cases, check settings!");

  }

  OKF("All test cases processed.");

}


/* Helper function: link() if possible, copy otherwise. */

static void link_or_copy(u8* old_path, u8* new_path) {

  s32 i;
  s32 sfd, dfd;
  u8* tmp;

  sfd = open(old_path, O_RDONLY | O_BINARY);
  if (sfd < 0) PFATAL("Unable to open '%s'", old_path);

  dfd = open(new_path, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);
  if (dfd < 0) PFATAL("Unable to create '%s'", new_path);

  tmp = ck_alloc(64 * 1024);

  while ((i = read(sfd, tmp, 64 * 1024)) > 0) 
    ck_write(dfd, tmp, i, new_path);

  if (i < 0) PFATAL("read() failed");

  ck_free(tmp);
  close(sfd);
  close(dfd);

}


static void nuke_resume_dir(void);

/* Create hard links for input test cases in the output directory, choosing
   good names and pivoting accordingly. */

static void pivot_inputs(void) {

  struct queue_entry* q = queue;
  u32 id = 0;

  ACTF("Creating hard links for all input files...");

  while (q) {

    u8  *nfn, *rsl = strrchr(q->fname, '\\');
    u32 orig_id;

    if (!rsl) rsl = q->fname; else rsl++;

    /* If the original file name conforms to the syntax and the recorded
       ID matches the one we'd assign, just use the original file name.
       This is valuable for resuming fuzzing runs. */

#ifndef SIMPLE_FILES
#  define CASE_PREFIX "id:"
#else
#  define CASE_PREFIX "id_"
#endif /* ^!SIMPLE_FILES */

    if (!strncmp(rsl, CASE_PREFIX, 3) &&
        sscanf(rsl + 3, "%06u", &orig_id) == 1 && orig_id == id) {

      u8* src_str;
      u32 src_id;

      resuming_fuzz = 1;
      nfn = alloc_printf("%s\\queue\\%s", out_dir, rsl);

      /* Since we're at it, let's also try to find parent and figure out the
         appropriate depth for this entry. */

      src_str = strchr(rsl + 3, ':');

      if (src_str && sscanf(src_str + 1, "%06u", &src_id) == 1) {

        struct queue_entry* s = queue;
        while (src_id-- && s) s = s->next;
        if (s) q->depth = s->depth + 1;

        if (max_depth < q->depth) max_depth = q->depth;

      }

    } else {

      /* No dice - invent a new name, capturing the original one as a
         substring. */

#ifndef SIMPLE_FILES

      u8* use_name = strstr(rsl, ",orig:");

      if (use_name) use_name += 6; else use_name = rsl;
      nfn = alloc_printf("%s\\queue\\id:%06u,orig:%s", out_dir, id, use_name);

#else

      nfn = alloc_printf("%s\\queue\\id_%06u", out_dir, id);

#endif /* ^!SIMPLE_FILES */

    }

    /* Pivot to the new queue entry. */

    link_or_copy(q->fname, nfn);
    ck_free(q->fname);
    q->fname = nfn;

    /* Make sure that the passed_det value carries over, too. */

    if (q->passed_det) mark_as_det_done(q);

    q = q->next;
    id++;

  }

  if (in_place_resume) nuke_resume_dir();

}


#ifndef SIMPLE_FILES

/* Construct a file name for a new test case, capturing the operation
   that led to its discovery. Uses a static buffer. */

static u8* describe_op(u8 hnb) {

  static u8 ret[256];

  if (syncing_party) {

    sprintf(ret, "sync:%s,src:%06u", syncing_party, syncing_case);

  } else {

    sprintf(ret, "src:%06u", current_entry);

    if (splicing_with >= 0)
      sprintf(ret + strlen(ret), "+%06u", splicing_with);

    sprintf(ret + strlen(ret), ",op:%s", stage_short);

    if (stage_cur_byte >= 0) {

      sprintf(ret + strlen(ret), ",pos:%u", stage_cur_byte);

      if (stage_val_type != STAGE_VAL_NONE)
        sprintf(ret + strlen(ret), ",val:%s%+d", 
                (stage_val_type == STAGE_VAL_BE) ? "be:" : "",
                stage_cur_val);

    } else sprintf(ret + strlen(ret), ",rep:%u", stage_cur_val);

  }

  if (hnb == 2) strcat(ret, ",+cov");

  return ret;

}

#endif /* !SIMPLE_FILES */


/* Write a message accompanying the crash directory :-) */

static void write_crash_readme(void) {

  u8* fn = alloc_printf("%s\\crashes\\README.txt", out_dir);
  s32 fd;
  FILE* f;

  fd = open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);
  ck_free(fn);

  /* Do not die on errors here - that would be impolite. */

  if (fd < 0) return;

  f = fdopen(fd, "w");

  if (!f) {
    close(fd);
    return;
  }

  fprintf(f, "Command line used to find this crash:\n\n"

             "%s\n\n"

             "If you can't reproduce a bug outside of afl-fuzz, be sure to set the same\n"
             "memory limit. The limit used for this fuzzing session was %s.\n\n"

             "Need a tool to minimize test cases before investigating the crashes or sending\n"
             "them to a vendor? Check out the afl-tmin that comes with the fuzzer!\n\n"

             "Found any cool bugs in open-source tools using afl-fuzz? If yes, please drop\n"
             "me a mail at <lcamtuf@coredump.cx> once the issues are fixed - I'd love to\n"
             "add your finds to the gallery at:\n\n"

             "  http:\\\\lcamtuf.coredump.cx\\afl\\\n\n"

             "Thanks :-)\n",

             orig_cmdline, DMS(mem_limit << 20)); /* ignore errors */

  fclose(f);

}


/* Check if the result of an execve() during routine fuzzing is interesting,
   save or queue the input test case for further analysis if so. Returns 1 if
   entry is saved, 0 otherwise. */

static u8 save_if_interesting(char** argv, void* mem, u32 len, u8 fault) {

  u8  *fn,*exception_name = "";
  u8  hnb;
  s32 fd;
  u8  keeping = 0, res;

  if (fault == crash_mode) {

    /* Keep only if there are new bits in the map, add to queue for
       future fuzzing, etc. */

    if (!(hnb = has_new_bits(virgin_bits))) {
      if (crash_mode) total_crashes++;
      return 0;
    }    

#ifndef SIMPLE_FILES

    fn = alloc_printf("%s\\queue\\id:%06u,%s", out_dir, queued_paths,
                      describe_op(hnb));

#else

    fn = alloc_printf("%s\\queue\\id_%06u", out_dir, queued_paths);

#endif /* ^!SIMPLE_FILES */

    add_to_queue(fn, len, 0);

    if (hnb == 2) {
      queue_top->has_new_cov = 1;
      queued_with_cov++;
    }

    queue_top->exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);

    /* Try to calibrate inline; this also calls update_bitmap_score() when
       successful. */

    res = calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0);

    if (res == FAULT_ERROR)
      FATAL("Unable to execute target application");

    fd = open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);
    if (fd < 0) PFATAL("Unable to create '%s'", fn);
    ck_write(fd, mem, len, fn);
    close(fd);

    keeping = 1;

  }

  switch (fault) {

    case FAULT_TMOUT:

      /* Timeouts are not very interesting, but we're still obliged to keep
         a handful of samples. We use the presence of new bits in the
         hang-specific bitmap as a signal of uniqueness. In "dumb" mode, we
         just keep everything. */

      total_tmouts++;

      if (unique_hangs >= KEEP_UNIQUE_HANG) return keeping;

      if (!dumb_mode) {

#ifdef _WIN64
        simplify_trace((u64*)trace_bits);
#else
        simplify_trace((u32*)trace_bits);
#endif /* ^_WIN64 */

        if (!has_new_bits(virgin_tmout)) return keeping;

      }

      unique_tmouts++;

      /* Before saving, we make sure that it's a genuine hang by re-running
         the target with a more generous timeout (unless the default timeout
         is already generous). */

      if (exec_tmout < hang_tmout) {

        u8 new_fault;
        write_to_testcase(mem, len);
        new_fault = run_target(argv, hang_tmout);

        if (stop_soon || new_fault != FAULT_TMOUT) return keeping;

       }

#ifndef SIMPLE_FILES

      fn = alloc_printf("%s\\hangs\\id:%06llu,%s", out_dir,
                        unique_hangs, describe_op(0));

#else

      fn = alloc_printf("%s\\hangs\\id_%06llu", out_dir,
                        unique_hangs);

#endif /* ^!SIMPLE_FILES */

      unique_hangs++;

      last_hang_time = get_cur_time();

      break;

    case FAULT_CRASH:

		switch (ret_exception_code) {
		case EXCEPTION_ACCESS_VIOLATION:
			exception_name = alloc_printf("%s", "EXCEPTION_ACCESS_VIOLATION");
			break;

		case EXCEPTION_ILLEGAL_INSTRUCTION:
			exception_name = alloc_printf("%s", "EXCEPTION_ILLEGAL_INSTRUCTION");
			break;

		case EXCEPTION_PRIV_INSTRUCTION:
			exception_name = alloc_printf("%s", "EXCEPTION_PRIV_INSTRUCTION");
			break;

		case EXCEPTION_INT_DIVIDE_BY_ZERO:
			exception_name = alloc_printf("%s", "EXCEPTION_INT_DIVIDE_BY_ZERO");
			break;

		case STATUS_HEAP_CORRUPTION:
			exception_name = alloc_printf("%s", "STATUS_HEAP_CORRUPTION");
			break;

		case EXCEPTION_STACK_OVERFLOW:
			exception_name = alloc_printf("%s", "EXCEPTION_STACK_OVERFLOW");
			break;

		case STATUS_STACK_BUFFER_OVERRUN:
			exception_name = alloc_printf("%s", "STATUS_STACK_BUFFER_OVERRUN");
			break;

		case STATUS_FATAL_APP_EXIT:
			exception_name = alloc_printf("%s", "STATUS_FATAL_APP_EXIT");
			break;
		default:
			exception_name = alloc_printf("%s", "EXCEPTION_NAME_NOT_AVAILABLE");
		}
      /* This is handled in a manner roughly similar to timeouts,
         except for slightly different limits and no need to re-run test
         cases. */

      total_crashes++;

      if (unique_crashes >= KEEP_UNIQUE_CRASH) return keeping;

      if (!dumb_mode) {

#ifdef _WIN64
        simplify_trace((u64*)trace_bits);
#else
        simplify_trace((u32*)trace_bits);
#endif /* ^_WIN64 */

        if (!has_new_bits(virgin_crash)) return keeping;

      }

      if (!unique_crashes) write_crash_readme();

#ifndef SIMPLE_FILES

      fn = alloc_printf("%s\\crashes\\id:%06llu,sig:%02u,%s", out_dir,
                        unique_crashes, kill_signal, describe_op(0));

#else

      fn = alloc_printf("%s\\crashes\\id_%06llu_%02u_%s", out_dir, unique_crashes,
                        kill_signal, exception_name);

#endif /* ^!SIMPLE_FILES */

      unique_crashes++;

      last_crash_time = get_cur_time();

      last_crash_execs = total_execs;

	  ck_free(exception_name);
	
	  break;

    case FAULT_ERROR: FATAL("Unable to execute target application");

    default: return keeping;

  }

  /* If we're here, we apparently want to save the crash or hang
     test case, too. */

  fd = open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);
  if (fd < 0) PFATAL("Unable to create '%s'", fn);
  ck_write(fd, mem, len, fn);
  close(fd);

  ck_free(fn);

  return keeping;

}


/* When resuming, try to find the queue position to start from. This makes sense
   only when resuming, and when we can find the original fuzzer_stats. */

static u32 find_start_position(void) {

  static u8 tmp[4096]; /* Ought to be enough for anybody. */

  u8  *fn, *off;
  s32 fd, i;
  u32 ret;

  if (!resuming_fuzz) return 0;

  if (in_place_resume) fn = alloc_printf("%s\\fuzzer_stats", out_dir);
  else fn = alloc_printf("%s\\..\\fuzzer_stats", in_dir);

  fd = open(fn, O_RDONLY | O_BINARY);
  ck_free(fn);

  if (fd < 0) return 0;

  i = read(fd, tmp, sizeof(tmp) - 1); (void)i; /* Ignore errors */
  close(fd);

  off = strstr(tmp, "cur_path          : ");
  if (!off) return 0;

  ret = atoi(off + 20);
  if (ret >= queued_paths) ret = 0;
  return ret;

}


/* The same, but for timeouts. The idea is that when resuming sessions without
   -t given, we don't want to keep auto-scaling the timeout over and over
   again to prevent it from growing due to random flukes. */

static void find_timeout(void) {

  static u8 tmp[4096]; /* Ought to be enough for anybody. */

  u8  *fn, *off;
  s32 fd, i;
  u32 ret;

  if (!resuming_fuzz) return;

  if (in_place_resume) fn = alloc_printf("%s\\fuzzer_stats", out_dir);
  else fn = alloc_printf("%s\\..\\fuzzer_stats", in_dir);

  fd = open(fn, O_RDONLY | O_BINARY);
  ck_free(fn);

  if (fd < 0) return;

  i = read(fd, tmp, sizeof(tmp) - 1); (void)i; /* Ignore errors */
  close(fd);

  off = strstr(tmp, "exec_timeout      : ");
  if (!off) return;

  ret = atoi(off + 20);
  if (ret <= 4) return;

  exec_tmout = ret;
  timeout_given = 3;

}

/* Load some of the existing stats file when resuming. */

void load_stats_file(void) {

    FILE* f;
    u8    buf[MAX_LINE];
    u8* lptr;
    u8    fn[MAX_PATH];
    u32   lineno = 0;

    snprintf(fn, MAX_PATH, "%s\\fuzzer_stats", out_dir);
    f = fopen(fn, "r");
    if (!f) {

        WARNF("Unable to load stats file '%s'", fn);
        return;

    }

    while ((lptr = fgets(buf, MAX_LINE, f))) {

        lineno++;
        u8* lstartptr = lptr;
        u8* rptr = lptr + strlen(lptr) - 1;
        u8  keystring[MAX_LINE];
        while (*lptr != ':' && lptr < rptr) {

            lptr++;

        }

        if (*lptr == '\n' || !*lptr) {

            WARNF("Unable to read line %d of stats file", lineno);
            continue;

        }

        if (*lptr == ':') {

            *lptr = 0;
            strcpy(keystring, lstartptr);
            lptr++;
            char* nptr;
            switch (lineno) {

            case 3:
                if (!strcmp(keystring, "run_time          "))
                    prev_run_time = 1000 * strtoull(lptr, &nptr, 10);
                break;
            case 5:
                if (!strcmp(keystring, "cycles_done       "))
                    queue_cycle = strtoull(lptr, &nptr, 10) ? strtoull(lptr, &nptr, 10) + 1 : 0;
                break;
            case 6:
                if (!strcmp(keystring, "execs_done        "))
                    total_execs = strtoull(lptr, &nptr, 10);
                break;
            case 8:
                if (!strcmp(keystring, "paths_total       ")) {

                    u32 paths_total = strtoul(lptr, &nptr, 10);
                    if (paths_total != queued_paths) {
                        WARNF("Queue has been modified, so things might not work, you're on your own!");
                    }

                }
                break;
            case 10:
                if (!strcmp(keystring, "paths_found       "))
                    queued_discovered = strtoul(lptr, &nptr, 10);
                break;
            case 11:
                if (!strcmp(keystring, "paths_imported    "))
                    queued_imported = strtoul(lptr, &nptr, 10);
                break;
            case 12:
                if (!strcmp(keystring, "max_depth         "))
                    max_depth = strtoul(lptr, &nptr, 10);
                break;
            case 19:
                if (!strcmp(keystring, "unique_crashes    "))
                    unique_crashes = strtoull(lptr, &nptr, 10);
                break;
            case 20:
                if (!strcmp(keystring, "unique_hangs      "))
                    unique_hangs = strtoull(lptr, &nptr, 10);
                break;
            default:
                break;

            }

        }

    }

    if (unique_crashes) { write_crash_readme(); }

    return;
}

/* Update stats file for unattended monitoring. */

static void write_stats_file(double bitmap_cvg, double stability, double eps) {

  static double last_bcvg, last_stab, last_eps;

  u64 cur_time = get_cur_time();
  u8* fn = alloc_printf("%s\\fuzzer_stats", out_dir);
  s32 fd;
  FILE* f;

  fd = open(fn, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);

  if (fd < 0) PFATAL("Unable to create '%s'", fn);

  ck_free(fn);

  f = fdopen(fd, "w");

  if (!f) PFATAL("fdopen() failed");

  /* Keep last values in case we're called from another context
     where exec/sec stats and such are not readily available. */

  if (!bitmap_cvg && !stability && !eps) {
    bitmap_cvg = last_bcvg;
    stability  = last_stab;
    eps        = last_eps;
  } else {
    last_bcvg = bitmap_cvg;
    last_stab = stability;
    last_eps  = eps;
  }

  fprintf(f, "start_time        : %llu\n"
             "last_update       : %llu\n"
             "run_time          : %llu\n"
             "fuzzer_pid        : %u\n"
             "cycles_done       : %llu\n"
             "execs_done        : %llu\n"
             "execs_per_sec     : %0.02f\n"
             "paths_total       : %u\n"
             "paths_favored     : %u\n"
             "paths_found       : %u\n"
             "paths_imported    : %u\n"
             "max_depth         : %u\n"
             "cur_path          : %u\n"
             "pending_favs      : %u\n"
             "pending_total     : %u\n"
             "variable_paths    : %u\n"
             "stability         : %0.02f%%\n"
             "bitmap_cvg        : %0.02f%%\n"
             "unique_crashes    : %llu\n"
             "unique_hangs      : %llu\n"
             "last_path         : %llu\n"
             "last_crash        : %llu\n"
             "last_hang         : %llu\n"
             "execs_since_crash : %llu\n"
             "exec_timeout      : %u\n"
             "afl_banner        : %s\n"
             "afl_version       : " VERSION "\n"
             "command_line      : %s\n",
             (start_time - prev_run_time) / 1000, cur_time / 1000, (prev_run_time + cur_time - start_time) / 1000, GetCurrentProcessId(),
             queue_cycle ? (queue_cycle - 1) : 0, total_execs, total_execs / ((double)(prev_run_time + cur_time - start_time) / 1000),
             queued_paths, queued_favored, queued_discovered, queued_imported,
             max_depth, current_entry, pending_favored, pending_not_fuzzed,
             queued_variable, stability, bitmap_cvg, unique_crashes,
             unique_hangs, last_path_time / 1000, last_crash_time / 1000,
             last_hang_time / 1000, total_execs - last_crash_execs,
             exec_tmout, use_banner, orig_cmdline);
             /* ignore errors */

  fclose(f);

}


/* Update the plot file if there is a reason to. */

static void maybe_update_plot_file(double bitmap_cvg, double eps) {

  static u32 prev_qp, prev_pf, prev_pnf, prev_ce, prev_md;
  static u64 prev_qc, prev_uc, prev_uh;

  if ((prev_qp == queued_paths && prev_pf == pending_favored &&
      prev_pnf == pending_not_fuzzed && prev_ce == current_entry &&
      prev_qc == queue_cycle && prev_uc == unique_crashes &&
      prev_uh == unique_hangs && prev_md == max_depth) ||
      (get_cur_time() - start_time <= 60)) return;

  prev_qp  = queued_paths;
  prev_pf  = pending_favored;
  prev_pnf = pending_not_fuzzed;
  prev_ce  = current_entry;
  prev_qc  = queue_cycle;
  prev_uc  = unique_crashes;
  prev_uh  = unique_hangs;
  prev_md  = max_depth;

  /* Fields in the file:

     relative_time, cycles_done, cur_path, paths_total, paths_not_fuzzed,
     favored_not_fuzzed, unique_crashes, unique_hangs, max_depth,
     execs_per_sec */

  fprintf(plot_file, 
          "%llu, %llu, %u, %u, %u, %u, %0.02f%%, %llu, %llu, %u, %0.02f\n",
          ((prev_run_time + get_cur_time() - start_time) / 1000), queue_cycle - 1, current_entry, queued_paths,
          pending_not_fuzzed, pending_favored, bitmap_cvg, unique_crashes,
          unique_hangs, max_depth, eps); /* ignore errors */

  fflush(plot_file);

}



/* A helper function for maybe_delete_out_dir(), deleting all prefixed
   files in a directory. */

static u8 delete_files(u8* path, u8* prefix) {
  char *pattern;
  WIN32_FIND_DATA fd;
  HANDLE h;

  if(_access(path, 0)) return 0;

  if(!prefix) {
	 pattern = alloc_printf("%s\\*", path);
  } else {
	 pattern = alloc_printf("%s\\%s*", path, prefix);
  }

  h = FindFirstFile(pattern, &fd);
  if(h == INVALID_HANDLE_VALUE) {
	  ck_free(pattern);
      return !!_rmdir(path);
  }

  do {
	  if (fd.cFileName[0] != '.' && (!prefix ||
        !strncmp(fd.cFileName, prefix, strlen(prefix)))) {

      u8* fname = alloc_printf("%s\\%s", path, fd.cFileName);
      if (unlink(fname)) PFATAL("Unable to delete '%s'", fname);
      ck_free(fname);

    }

  } while(FindNextFile(h, &fd));

  FindClose(h);

  ck_free(pattern);

  return !!_rmdir(path);

}


static u8 delete_subdirectories(u8* path) {
	char *pattern;
	WIN32_FIND_DATA fd;
	HANDLE h;

	if (_access(path, 0)) return 0;

	pattern = alloc_printf("%s\\*", path);

	h = FindFirstFile(pattern, &fd);
	if (h == INVALID_HANDLE_VALUE) {
		ck_free(pattern);
		return !!_rmdir(path);
	}

	do {
		if (fd.cFileName[0] != '.') {

			u8* fname = alloc_printf("%s\\%s", path, fd.cFileName);
			if (delete_files(fname, NULL)) PFATAL("Unable to delete '%s'", fname);
			ck_free(fname);

		}

	} while (FindNextFile(h, &fd));

	FindClose(h);

	ck_free(pattern);

	return !!_rmdir(path);

}


/* Get the average usage of all processors. */

static double get_cur_utilization(void) {
    PDH_FMT_COUNTERVALUE cpuCounter;

    PdhCollectQueryData(cpuQuery);
    PdhGetFormattedCounterValue(cpuTotal, PDH_FMT_DOUBLE, NULL, &cpuCounter);

    return cpuCounter.doubleValue;
}


/* Delete the temporary directory used for in-place session resume. */

static void nuke_resume_dir(void) {

  u8* fn;

  fn = alloc_printf("%s\\_resume\\.state\\deterministic_done", out_dir);
  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\_resume\\.state\\auto_extras", out_dir);
  if (delete_files(fn, "auto_")) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\_resume\\.state\\redundant_edges", out_dir);
  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\_resume\\.state\\variable_behavior", out_dir);
  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\_resume\\.state", out_dir);
  if (rmdir(fn) && errno != ENOENT) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\_resume", out_dir);
  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  return;

dir_cleanup_failed:

  FATAL("_resume directory cleanup failed");

}


/* Delete fuzzer output directory if we recognize it as ours, if the fuzzer
   is not currently running, and if the last run time isn't too great. */

static void maybe_delete_out_dir(void) {

  FILE* f;
  u8 *fn = alloc_printf("%s\\fuzzer_stats", out_dir);

  /* See if the output directory is locked. If yes, bail out. If not,
     create a lock that will persist for the lifetime of the process
     (this requires leaving the descriptor open).*/

  //out_dir_fd = open(out_dir, O_RDONLY | O_BINARY);
  //if (out_dir_fd < 0) PFATAL("Unable to open '%s'", out_dir);

  f = fopen(fn, "r");

  if (f) {

    u64 start_time, last_update;

    if (fscanf(f, "start_time     : %llu\n"
                  "last_update    : %llu\n", &start_time, &last_update) != 2)
      FATAL("Malformed data in '%s'", fn);

    fclose(f);

    /* Autoresume treats a normal run as in_place_resume if a valid out dir
       already exists. */

    if (!in_place_resume && autoresume) in_place_resume = 1;

    /* Let's see how much work is at stake. */

    if (!in_place_resume && last_update - start_time > OUTPUT_GRACE * 60) {

      SAYF("\n" cLRD "[-] " cRST
           "The job output directory already exists and contains the results of more\n"
           "    than %u minutes worth of fuzzing. To avoid data loss, afl-fuzz will *NOT*\n"
           "    automatically delete this data for you.\n\n"

           "    If you wish to start a new session, remove or rename the directory manually,\n"
           "    or specify a different output location for this job. To resume the old\n"
           "    session, put '-' as the input directory in the command line ('-i -') or\n"
           "    set the AFL_AUTORESUME=1 env variable and try again.\n", OUTPUT_GRACE);

       FATAL("At-risk data found in '%s'", out_dir);

    }

  }

  ck_free(fn);

  /* The idea for in-place resume is pretty simple: we temporarily move the old
     queue/ to a new location that gets deleted once import to the new queue/
     is finished. If _resume/ already exists, the current queue/ may be
     incomplete due to an earlier abort, so we want to use the old _resume/
     dir instead, and we let rename() fail silently. */

  if (in_place_resume) {

    u8* orig_q = alloc_printf("%s\\queue", out_dir);

    in_dir = alloc_printf("%s\\_resume", out_dir);

    (void)rename(orig_q, in_dir); /* Ignore errors */

    OKF("Output directory exists, will attempt session resume.");

    ck_free(orig_q);

  } else {

    OKF("Output directory exists but deemed OK to reuse.");

  }

  ACTF("Deleting old session data...");

  /* Okay, let's get the ball rolling! First, we need to get rid of the entries
     in <out_dir>/.synced/.../id:*, if any are present. */
  if (!in_place_resume) {

    fn = alloc_printf("%s\\.synced", out_dir);
    if (delete_files(fn, NULL)) goto dir_cleanup_failed;
    ck_free(fn);

  }

  /* Next, we need to clean up <out_dir>/queue/.state/ subdirectories: */

  fn = alloc_printf("%s\\queue\\.state\\deterministic_done", out_dir);
  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\queue\\.state\\auto_extras", out_dir);
  if (delete_files(fn, "auto_")) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\queue\\.state\\redundant_edges", out_dir);
  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\queue\\.state\\variable_behavior", out_dir);
  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  /* Then, get rid of the .state subdirectory itself (should be empty by now)
     and everything matching <out_dir>/queue/id:*. */

  fn = alloc_printf("%s\\queue\\.state", out_dir);
  if (rmdir(fn) && errno != ENOENT) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\queue", out_dir);
  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  /* All right, let's do <out_dir>/crashes/id:* and <out_dir>/hangs/id:*. */

  if (!in_place_resume) {

    fn = alloc_printf("%s\\crashes\\README.txt", out_dir);
    unlink(fn); /* Ignore errors */
    ck_free(fn);

  }

  fn = alloc_printf("%s\\crashes", out_dir);

  /* Make backup of the crashes directory if it's not empty and if we're
     doing in-place resume. */

  if (in_place_resume && rmdir(fn)) {

    time_t cur_t = time(0);
    struct tm* t = localtime(&cur_t);

#ifndef SIMPLE_FILES

    u8* nfn = alloc_printf("%s.%04u-%02u-%02u-%02u:%02u:%02u", fn,
                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                           t->tm_hour, t->tm_min, t->tm_sec);

#else

    u8* nfn = alloc_printf("%s_%04u%02u%02u%02u%02u%02u", fn,
                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                           t->tm_hour, t->tm_min, t->tm_sec);

#endif /* ^!SIMPLE_FILES */

    (void)rename(fn, nfn); /* Ignore errors. */
    ck_free(nfn);

  }

  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\hangs", out_dir);

  /* Backup hangs, too. */

  if (in_place_resume && rmdir(fn)) {

    time_t cur_t = time(0);
    struct tm* t = localtime(&cur_t);

#ifndef SIMPLE_FILES

    u8* nfn = alloc_printf("%s.%04u-%02u-%02u-%02u:%02u:%02u", fn,
                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                           t->tm_hour, t->tm_min, t->tm_sec);

#else

    u8* nfn = alloc_printf("%s_%04u%02u%02u%02u%02u%02u", fn,
                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                           t->tm_hour, t->tm_min, t->tm_sec);

#endif /* ^!SIMPLE_FILES */

    (void)rename(fn, nfn); /* Ignore errors. */
    ck_free(nfn);

  }

  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;
  ck_free(fn);

  /* And now, for some finishing touches. */

  fn = alloc_printf("%s\\.cur_input", out_dir);
  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\fuzz_bitmap", out_dir);
  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;
  ck_free(fn);

  if (!in_place_resume) {
    fn  = alloc_printf("%s\\fuzzer_stats", out_dir);
    if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;
    ck_free(fn);
  }

  if (!in_place_resume) {
    fn = alloc_printf("%s\\plot_data", out_dir);
    if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;
    ck_free(fn);
  }

  fn = alloc_printf("%s\\drcache", out_dir);
  if(delete_subdirectories(fn)) goto dir_cleanup_failed;
  ck_free(fn);

  fn = alloc_printf("%s\\ptmodules", out_dir);
  if (delete_files(fn, NULL)) goto dir_cleanup_failed;
  ck_free(fn);

  OKF("Output dir cleanup successful.");

  /* Wow... is that all? If yes, celebrate! */

  return;

dir_cleanup_failed:

  SAYF("\n" cLRD "[-] " cRST
       "Whoops, the fuzzer tried to reuse your output directory, but bumped into\n"
       "    some files that shouldn't be there or that couldn't be removed - so it\n"
       "    decided to abort! This happened while processing this path:\n\n"

       "    %s\n\n"
       "    Please examine and manually delete the files, or specify a different\n"
       "    output location for the tool.\n", fn);

  FATAL("Output directory cleanup failed");

}


static void check_term_size(void);


/* A spiffy retro stats screen! This is called every stats_update_freq
   execve() calls, plus in several other circumstances. */

static void show_stats(void) {

  static u64 last_stats_ms, last_plot_ms, last_ms, last_execs;
  static double avg_exec;
  double t_byte_ratio, stab_ratio;

  u64 cur_ms;
  u32 t_bytes, t_bits;

  u32 banner_len, banner_pad;
  u8  tmp[256];

  cur_ms = get_cur_time();

  /* If not enough time has passed since last UI update, bail out. */

  if (cur_ms - last_ms < 1000 / UI_TARGET_HZ) return;

  /* Check if we're past the 10 minute mark. */

  if (cur_ms - start_time > 10 * 60 * 1000) run_over10m = 1;

  /* Calculate smoothed exec speed stats. */

  if (!last_execs) {
  
    avg_exec = ((double)total_execs) * 1000 / (prev_run_time + cur_ms - start_time);

  } else {

    double cur_avg = ((double)(total_execs - last_execs)) * 1000 /
                     (cur_ms - last_ms);

    /* If there is a dramatic (5x+) jump in speed, reset the indicator
       more quickly. */

    if (cur_avg * 5 < avg_exec || cur_avg / 5 > avg_exec)
      avg_exec = cur_avg;

    avg_exec = avg_exec * (1.0 - 1.0 / AVG_SMOOTHING) +
               cur_avg * (1.0 / AVG_SMOOTHING);

  }

  last_ms = cur_ms;
  last_execs = total_execs;

  /* Tell the callers when to contact us (as measured in execs). */

  stats_update_freq = avg_exec / (UI_TARGET_HZ * 10);
  if (!stats_update_freq) stats_update_freq = 1;

  /* Do some bitmap stats. */

  t_bytes = count_non_255_bytes(virgin_bits);
  t_byte_ratio = ((double)t_bytes * 100) / MAP_SIZE;

  if (t_bytes)
    stab_ratio = 100 - ((double)var_byte_count) * 100 / t_bytes;
  else
    stab_ratio = 100;

  /* Roughly every minute, update fuzzer stats and save auto tokens. */

  if (cur_ms - last_stats_ms > STATS_UPDATE_SEC * 1000) {

    last_stats_ms = cur_ms;
    write_stats_file(t_byte_ratio, stab_ratio, avg_exec);
    save_auto();
    write_bitmap();

  }

  /* Every now and then, write plot data. */

  if (cur_ms - last_plot_ms > PLOT_UPDATE_SEC * 1000) {

    last_plot_ms = cur_ms;
    maybe_update_plot_file(t_byte_ratio, avg_exec);
 
  }

  /* Honor AFL_EXIT_WHEN_DONE. */

  if (!dumb_mode && cycles_wo_finds > 50 && !pending_not_fuzzed &&
      getenv("AFL_EXIT_WHEN_DONE")) stop_soon = 2;

  /* If we're not on TTY, bail out. */

  //if (not_on_tty) return;

  /* Compute some mildly useful bitmap stats. */

  t_bits = (MAP_SIZE << 3) - count_bits(virgin_bits);

  /* Now, for the visuals... */

  if (clear_screen) {

    SAYF(TERM_CLEAR CURSOR_HIDE);
    clear_screen = 0;

    check_term_size();

  }

  SAYF(TERM_HOME);

  if (term_too_small) {

    SAYF(cBRI "Your terminal is too small to display the UI.\n"
         "Please resize terminal window to at least 80x25.\n" cRST);

    return;

  }

  /* Let's start by drawing a centered banner. */

  banner_len = 24 + strlen(VERSION) + strlen(WINAFL_VERSION) + strlen(use_banner);
  banner_pad = (80 - banner_len) / 2;
  memset(tmp, ' ', banner_pad);

  sprintf(tmp + banner_pad, "WinAFL " WINAFL_VERSION " based on %s "
          cLCY VERSION cLGN " (%s)",  crash_mode ? cPIN "PWR" : 
          cYEL "AFL", use_banner);

  SAYF("\n%s\n\n", tmp);

  /* "Handy" shortcuts for drawing boxes... */

#define bSTG    bSTART cGRA
#define bH2     bH bH
#define bH5     bH2 bH2 bH
#define bH10    bH5 bH5
#define bH20    bH10 bH10
#define bH30    bH20 bH10
#define SP5     "     "
#define SP10    SP5 SP5
#define SP20    SP10 SP10

  /* Lord, forgive me this. */

  SAYF(SET_G1 bSTG bLT bH bSTOP cCYA " process timing " bSTG bH30 bH5 bH2 bHB
       bH bSTOP cCYA " overall results " bSTG bH2 bH2 bRT "\n");

  if (dumb_mode) {

    strcpy(tmp, cRST);

  } else {
    u64 min_wo_finds = (cur_ms - last_path_time) / 1000 / 60;

    /* First queue cycle: don't stop now! */
    if (queue_cycle == 1 || min_wo_finds < 15) strcpy(tmp, cMGN); else

    /* Subsequent cycles, but we're still making finds. */
    if (cycles_wo_finds < 25 || min_wo_finds < 30) strcpy(tmp, cYEL); else

    /* No finds for a long time and no test cases to try. */
    if (cycles_wo_finds > 100 && !pending_not_fuzzed && min_wo_finds > 120)
      strcpy(tmp, cLGN);

    /* Default: cautiously OK to stop? */
    else strcpy(tmp, cLBL);

  }

  SAYF(bV bSTOP "        run time : " cRST "%-34s " bSTG bV bSTOP
       "  cycles done : %s%-4s  " bSTG bV "\n",
       DTD(prev_run_time + cur_ms, start_time), tmp, DI(queue_cycle - 1));

  /* We want to warn people about not seeing new paths after a full cycle,
     except when resuming fuzzing or running in non-instrumented mode. */

  if (!dumb_mode && (last_path_time || resuming_fuzz || queue_cycle == 1 ||
      in_bitmap || crash_mode)) {

    SAYF(bV bSTOP "   last new path : " cRST "%-34s ",
         DTD(cur_ms, last_path_time));

  } else {

    if (dumb_mode)

      SAYF(bV bSTOP "   last new path : " cPIN "n/a" cRST 
           " (non-instrumented mode)        ");

     else

      SAYF(bV bSTOP "   last new path : " cRST "none yet " cLRD
           "(odd, check syntax!)      ");

  }

  SAYF(bSTG bV bSTOP "  total paths : " cRST "%-4s  " bSTG bV "\n",
       DI(queued_paths));

  /* Highlight crashes in red if found, denote going over the KEEP_UNIQUE_CRASH
     limit with a '+' appended to the count. */

  sprintf(tmp, "%s%s", DI(unique_crashes),
          (unique_crashes >= KEEP_UNIQUE_CRASH) ? "+" : "");

  SAYF(bV bSTOP " last uniq crash : " cRST "%-34s " bSTG bV bSTOP
       " uniq crashes : %s%-5s " bSTG bV "\n",
       DTD(cur_ms, last_crash_time), unique_crashes ? cLRD : cRST,
       tmp);

  sprintf(tmp, "%s%s", DI(unique_hangs),
         (unique_hangs >= KEEP_UNIQUE_HANG) ? "+" : "");

  SAYF(bV bSTOP "  last uniq hang : " cRST "%-34s " bSTG bV bSTOP 
       "   uniq hangs : " cRST "%-5s " bSTG bV "\n",
       DTD(cur_ms, last_hang_time), tmp);

  SAYF(bVR bH bSTOP cCYA " cycle progress " bSTG bH20 bHB bH bSTOP cCYA
       " map coverage " bSTG bH bHT bH20 bH2 bVL "\n");

  /* This gets funny because we want to print several variable-length variables
     together, but then cram them into a fixed-width field - so we need to
     put them in a temporary buffer first. */

  sprintf(tmp, "%s%s (%0.02f%%)", DI(current_entry),
          queue_cur->favored ? "" : "*",
          ((double)current_entry * 100) / queued_paths);

  SAYF(bV bSTOP "  now processing : " cRST "%-17s " bSTG bV bSTOP, tmp);


  sprintf(tmp, "%0.02f%% / %0.02f%%", ((double)queue_cur->bitmap_size) *
          100 / MAP_SIZE, t_byte_ratio);

  SAYF("    map density : %s%-20s " bSTG bV "\n", t_byte_ratio > 70 ? cLRD : 
       ((t_bytes < 200 && !dumb_mode) ? cPIN : cRST), tmp);

  sprintf(tmp, "%s (%0.02f%%)", DI(cur_skipped_paths),
          ((double)cur_skipped_paths * 100) / queued_paths);

  SAYF(bV bSTOP " paths timed out : " cRST "%-17s " bSTG bV, tmp);

  sprintf(tmp, "%0.02f bits/tuple",
          t_bytes ? (((double)t_bits) / t_bytes) : 0);

  SAYF(bSTOP " count coverage : " cRST "%-20s " bSTG bV "\n", tmp);

  SAYF(bVR bH bSTOP cCYA " stage progress " bSTG bH20 bX bSTOP cCYA
       " findings in depth " bSTG bH20 bVL "\n");

  sprintf(tmp, "%s (%0.02f%%)", DI(queued_favored),
          ((double)queued_favored) * 100 / queued_paths);

  /* Yeah... it's still going on... halp? */

  SAYF(bV bSTOP "  now trying : " cRST "%-21s " bSTG bV bSTOP 
       " favored paths : " cRST "%-21s " bSTG bV "\n", stage_name, tmp);

  if (!stage_max) {

    sprintf(tmp, "%s/-", DI(stage_cur));

  } else {

    sprintf(tmp, "%s/%s (%0.02f%%)", DI(stage_cur), DI(stage_max),
            ((double)stage_cur) * 100 / stage_max);

  }

  SAYF(bV bSTOP " stage execs : " cRST "%-21s " bSTG bV bSTOP, tmp);

  sprintf(tmp, "%s (%0.02f%%)", DI(queued_with_cov),
          ((double)queued_with_cov) * 100 / queued_paths);

  SAYF("  new edges on : " cRST "%-21s " bSTG bV "\n", tmp);

  sprintf(tmp, "%s (%s%s unique)", DI(total_crashes), DI(unique_crashes),
          (unique_crashes >= KEEP_UNIQUE_CRASH) ? "+" : "");

  if (crash_mode) {

    SAYF(bV bSTOP " total execs : " cRST "%-21s " bSTG bV bSTOP
         "   new crashes : %s%-21s " bSTG bV "\n", DI(total_execs),
         unique_crashes ? cLRD : cRST, tmp);

  } else {

    SAYF(bV bSTOP " total execs : " cRST "%-21s " bSTG bV bSTOP
         " total crashes : %s%-21s " bSTG bV "\n", DI(total_execs),
         unique_crashes ? cLRD : cRST, tmp);

  }

  /* Show a warning about slow execution. */

  if (avg_exec < 100) {

    sprintf(tmp, "%s/sec (%s)", DF(avg_exec), avg_exec < 20 ?
            "zzzz..." : "slow!");

    SAYF(bV bSTOP "  exec speed : " cLRD "%-21s ", tmp);

  } else {

    sprintf(tmp, "%s/sec", DF(avg_exec));
    SAYF(bV bSTOP "  exec speed : " cRST "%-21s ", tmp);

  }

  sprintf(tmp, "%s (%s%s unique)", DI(total_tmouts), DI(unique_tmouts),
          (unique_hangs >= KEEP_UNIQUE_HANG) ? "+" : "");

  SAYF (bSTG bV bSTOP "  total tmouts : " cRST "%-21s " bSTG bV "\n", tmp);

  /* Aaaalmost there... hold on! */

  SAYF(bVR bH cCYA bSTOP " fuzzing strategy yields " bSTG bH10 bH bHT bH10
       bH5 bHB bH bSTOP cCYA " path geometry " bSTG bH5 bH2 bVL "\n");

  if (skip_deterministic) {

    strcpy(tmp, "n/a, n/a, n/a");

  } else {

    sprintf(tmp, "%s/%s, %s/%s, %s/%s",
            DI(stage_finds[STAGE_FLIP1]), DI(stage_cycles[STAGE_FLIP1]),
            DI(stage_finds[STAGE_FLIP2]), DI(stage_cycles[STAGE_FLIP2]),
            DI(stage_finds[STAGE_FLIP4]), DI(stage_cycles[STAGE_FLIP4]));

  }

  SAYF(bV bSTOP "   bit flips : " cRST "%-37s " bSTG bV bSTOP "    levels : "
       cRST "%-9s " bSTG bV "\n", tmp, DI(max_depth));

  if (!skip_deterministic)
    sprintf(tmp, "%s/%s, %s/%s, %s/%s",
            DI(stage_finds[STAGE_FLIP8]), DI(stage_cycles[STAGE_FLIP8]),
            DI(stage_finds[STAGE_FLIP16]), DI(stage_cycles[STAGE_FLIP16]),
            DI(stage_finds[STAGE_FLIP32]), DI(stage_cycles[STAGE_FLIP32]));

  SAYF(bV bSTOP "  byte flips : " cRST "%-37s " bSTG bV bSTOP "   pending : "
       cRST "%-9s " bSTG bV "\n", tmp, DI(pending_not_fuzzed));

  if (!skip_deterministic)
    sprintf(tmp, "%s/%s, %s/%s, %s/%s",
            DI(stage_finds[STAGE_ARITH8]), DI(stage_cycles[STAGE_ARITH8]),
            DI(stage_finds[STAGE_ARITH16]), DI(stage_cycles[STAGE_ARITH16]),
            DI(stage_finds[STAGE_ARITH32]), DI(stage_cycles[STAGE_ARITH32]));

  SAYF(bV bSTOP " arithmetics : " cRST "%-37s " bSTG bV bSTOP "  pend fav : "
       cRST "%-9s " bSTG bV "\n", tmp, DI(pending_favored));

  if (!skip_deterministic)
    sprintf(tmp, "%s/%s, %s/%s, %s/%s",
            DI(stage_finds[STAGE_INTEREST8]), DI(stage_cycles[STAGE_INTEREST8]),
            DI(stage_finds[STAGE_INTEREST16]), DI(stage_cycles[STAGE_INTEREST16]),
            DI(stage_finds[STAGE_INTEREST32]), DI(stage_cycles[STAGE_INTEREST32]));

  SAYF(bV bSTOP "  known ints : " cRST "%-37s " bSTG bV bSTOP " own finds : "
       cRST "%-9s " bSTG bV "\n", tmp, DI(queued_discovered));

  if (!skip_deterministic)
    sprintf(tmp, "%s/%s, %s/%s, %s/%s",
            DI(stage_finds[STAGE_EXTRAS_UO]), DI(stage_cycles[STAGE_EXTRAS_UO]),
            DI(stage_finds[STAGE_EXTRAS_UI]), DI(stage_cycles[STAGE_EXTRAS_UI]),
            DI(stage_finds[STAGE_EXTRAS_AO]), DI(stage_cycles[STAGE_EXTRAS_AO]));

  SAYF(bV bSTOP "  dictionary : " cRST "%-37s " bSTG bV bSTOP
       "  imported : " cRST "%-9s " bSTG bV "\n", tmp,
       sync_id ? DI(queued_imported) : (u8*)"n/a");

  sprintf(tmp, "%s/%s, %s/%s",
          DI(stage_finds[STAGE_HAVOC]), DI(stage_cycles[STAGE_HAVOC]),
          DI(stage_finds[STAGE_SPLICE]), DI(stage_cycles[STAGE_SPLICE]));

  SAYF(bV bSTOP "       havoc : " cRST "%-37s " bSTG bV bSTOP, tmp);

  if (t_bytes) sprintf(tmp, "%0.02f%%", stab_ratio);
    else strcpy(tmp, "n/a");

  SAYF(" stability : %s%-9s " bSTG bV "\n", (stab_ratio < 85 && var_byte_count > 40)
       ? cLRD : ((queued_variable && (!persistent_mode || var_byte_count > 20))
       ? cMGN : cRST), tmp);

  if (!bytes_trim_out) {

    sprintf(tmp, "n/a, ");

  } else {

    sprintf(tmp, "%0.02f%%/%s, ",
            ((double)(bytes_trim_in - bytes_trim_out)) * 100 / bytes_trim_in,
            DI(trim_execs));

  }

  if (!blocks_eff_total) {

    u8 tmp2[128];

    sprintf(tmp2, "n/a");
    strcat(tmp, tmp2);

  } else {

    u8 tmp2[128];

    sprintf(tmp2, "%0.02f%%",
            ((double)(blocks_eff_total - blocks_eff_select)) * 100 /
            blocks_eff_total);

    strcat(tmp, tmp2);

  }

  SAYF(bV bSTOP "        trim : " cRST "%-37s " bSTG bVR bH20 bH2 bH bRB "\n"
       bLB bH30 bH20 bH2 bH bRB bSTOP cRST RESET_G1, tmp);

  /* Provide some CPU utilization stats. */

  if (cpu_core_count) {

    u32 cur_utilization = (u32)get_cur_utilization();

    u8* cpu_color = cCYA;

    /* If we could still run one or more processes, use green. */

    if (cpu_core_count > 1 && cur_utilization < 90)
      cpu_color = cLGN;

    /* If we're clearly oversubscribed, use red. */

    if (!no_cpu_meter_red && cur_utilization >= 90) cpu_color = cLRD;

    if (cpu_aff >= 0) {

      SAYF("   " cGRA "[cpu%06I64u: %s%3u%%" cGRA "]\r" cRST,
        cpu_aff, cpu_color, cur_utilization < 999 ? cur_utilization : 999);

    }
    else {

      SAYF(SP10 cGRA "[cpu: %s%3u%%" cGRA "]\r" cRST,
        cpu_color, cur_utilization < 999 ? cur_utilization : 999);

    }

  } else SAYF("\r");

  /* Hallelujah! */

  fflush(0);

}

/* Display quick statistics at the end of processing the input directory,
   plus a bunch of warnings. Some calibration stuff also ended up here,
   along with several hardcoded constants. Maybe clean up eventually. */

static void show_init_stats(void) {

  struct queue_entry* q = queue;
  u32 min_bits = 0, max_bits = 0;
  u64 min_us = 0, max_us = 0;
  u64 avg_us = 0;
  u32 max_len = 0;

  if (total_cal_cycles) avg_us = total_cal_us / total_cal_cycles;

  while (q) {

    if (!min_us || q->exec_us < min_us) min_us = q->exec_us;
    if (q->exec_us > max_us) max_us = q->exec_us;

    if (!min_bits || q->bitmap_size < min_bits) min_bits = q->bitmap_size;
    if (q->bitmap_size > max_bits) max_bits = q->bitmap_size;

    if (q->len > max_len) max_len = q->len;

    q = q->next;

  }

  SAYF("\n");

  if (avg_us > (qemu_mode ? 50000 : 10000)) 
    WARNF(cLRD "The target binary is pretty slow! See %s\\perf_tips.txt.",
          doc_path);

  /* Let's keep things moving with slow binaries. */

  if (avg_us > 50000) havoc_div = 10;     /* 0-19 execs/sec   */
  else if (avg_us > 20000) havoc_div = 5; /* 20-49 execs/sec  */
  else if (avg_us > 10000) havoc_div = 2; /* 50-100 execs/sec */

  if (!resuming_fuzz) {

    if (max_len > 50 * 1024)
      WARNF(cLRD "Some test cases are huge (%s) - see %s\\perf_tips.txt!",
            DMS(max_len), doc_path);
    else if (max_len > 10 * 1024)
      WARNF("Some test cases are big (%s) - see %s\\perf_tips.txt.",
            DMS(max_len), doc_path);

    if (useless_at_start && !in_bitmap)
      WARNF(cLRD "Some test cases look useless. Consider using a smaller set.");

    if (queued_paths > 100)
      WARNF(cLRD "You probably have far too many input files! Consider trimming down.");
    else if (queued_paths > 20)
      WARNF("You have lots of input files; try starting small.");

  }

  OKF("Here are some useful stats:\n\n"

      cGRA "    Test case count : " cRST "%u favored, %u variable, %u total\n"
      cGRA "       Bitmap range : " cRST "%u to %u bits (average: %0.02f bits)\n"
      cGRA "        Exec timing : " cRST "%s to %s us (average: %s us)\n",
      queued_favored, queued_variable, queued_paths, min_bits, max_bits, 
      ((double)total_bitmap_size) / (total_bitmap_entries ? total_bitmap_entries : 1),
      DI(min_us), DI(max_us), DI(avg_us));

  if (!timeout_given) {

    /* Figure out the appropriate timeout. The basic idea is: 5x average or
       1x max, rounded up to EXEC_TM_ROUND ms and capped at 1 second.

       If the program is slow, the multiplier is lowered to 2x or 3x, because
       random scheduler jitter is less likely to have any impact, and because
       our patience is wearing thin =) */

    if (avg_us > 50000) exec_tmout = avg_us * 2 / 1000;
    else if (avg_us > 10000) exec_tmout = avg_us * 3 / 1000;
    else exec_tmout = avg_us * 5 / 1000;

    exec_tmout = MAX(exec_tmout, max_us / 1000);
    exec_tmout = (exec_tmout + EXEC_TM_ROUND) / EXEC_TM_ROUND * EXEC_TM_ROUND;

    if (exec_tmout > EXEC_TIMEOUT) exec_tmout = EXEC_TIMEOUT;

    ACTF("No -t option specified, so I'll use exec timeout of %u ms.", 
         exec_tmout);

    timeout_given = 1;

  } else if (timeout_given == 3) {

    ACTF("Applying timeout settings from resumed session (%u ms).", exec_tmout);

  }

  /* In dumb mode, re-running every timing out test case with a generous time
     limit is very expensive, so let's select a more conservative default. */

  if (dumb_mode && !getenv("AFL_HANG_TMOUT"))
    hang_tmout = MIN(EXEC_TIMEOUT, exec_tmout * 2 + 100);

  OKF("All set and ready to roll!");

}


/* Find first power of two greater or equal to val. */

static u32 next_p2(u32 val) {

  u32 ret = 1;
  while (val > ret) ret <<= 1;
  return ret;

} 


/* Trim all new test cases to save cycles when doing deterministic checks. The
   trimmer uses power-of-two increments somewhere between 1/16 and 1/1024 of
   file size, to keep the stage short and sweet. */

static u8 trim_case(char** argv, struct queue_entry* q, u8* in_buf) {

  static u8 tmp[64];
  static u8 clean_trace[MAP_SIZE];

  u8  needs_write = 0, fault = 0;
  u32 trim_exec = 0;
  u32 remove_len;
  u32 len_p2;

  /* Although the trimmer will be less useful when variable behavior is
     detected, it will still work to some extent, so we don't check for
     this. */

  if (q->len < 5) return 0;

  if (dll_trim_testcase_ptr) {
    // Call the custom trimming function.
    // The trimmed data will be set in in_buf and its length in q->len.
    // The implementation can test for changes in the trace after calling run_target
    // by calculating the hash for trace_bits and comparing it to q->exec_cksum.
    // Checksum function is declared in hash.h.
    // The return value will determine if the trimmed data will be written to a file.
    needs_write = dll_trim_testcase_ptr(&q->len, q->exec_cksum,
      in_buf, trace_bits, write_to_testcase, run_target, argv, exec_tmout);
    goto write_trimmed;
  }

  stage_name = tmp;
  bytes_trim_in += q->len;

  /* Select initial chunk len, starting with large steps. */

  len_p2 = next_p2(q->len);

  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);

  /* Continue until the number of steps gets too high or the stepover
     gets too small. */

  while (remove_len >= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) {

    u32 remove_pos = remove_len;

    sprintf(tmp, "trim %s\\%s", DI(remove_len), DI(remove_len));

    stage_cur = 0;
    stage_max = q->len / remove_len;

    while (remove_pos < q->len) {

      u32 trim_avail = MIN(remove_len, q->len - remove_pos);
      u32 cksum;

      write_with_gap(in_buf, q->len, remove_pos, trim_avail);

      fault = run_target(argv, exec_tmout);
      trim_execs++;

      if (stop_soon || fault == FAULT_ERROR) goto abort_trimming;

      /* Note that we don't keep track of crashes or hangs here; maybe TODO? */

      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);

      /* If the deletion had no impact on the trace, make it permanent. This
         isn't perfect for variable-path inputs, but we're just making a
         best-effort pass, so it's not a big deal if we end up with false
         negatives every now and then. */

      if (cksum == q->exec_cksum) {

        u32 move_tail = q->len - remove_pos - trim_avail;

        q->len -= trim_avail;
        len_p2  = next_p2(q->len);

        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, 
                move_tail);

        /* Let's save a clean trace, which will be needed by
           update_bitmap_score once we're done with the trimming stuff. */

        if (!needs_write) {

          needs_write = 1;
          memcpy(clean_trace, trace_bits, MAP_SIZE);

        }

      } else remove_pos += remove_len;

      /* Since this can be slow, update the screen every now and then. */

      if (!(trim_exec++ % stats_update_freq)) show_stats();
      stage_cur++;

    }

    remove_len >>= 1;

  }

  /* If we have made changes to in_buf, we also need to update the on-disk
     version of the test case. */
write_trimmed:
  if (needs_write) {

    s32 fd;

    fd = open(q->fname, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);

    if (fd < 0) PFATAL("Unable to create '%s'", q->fname);

    ck_write(fd, in_buf, q->len, q->fname);
    close(fd);

    memcpy(trace_bits, clean_trace, MAP_SIZE);
    update_bitmap_score(q);

  }



abort_trimming:

  bytes_trim_out += q->len;
  return fault;

}


/* Write a modified test case, run program, process results. Handle
   error conditions, returning 1 if it's time to bail out. This is
   a helper function for fuzz_one(). */

static u8 common_fuzz_stuff(char** argv, u8* out_buf, u32 len) {

  u8 fault;

  if (post_handler) {

    out_buf = post_handler(out_buf, &len);
    if (!out_buf || !len) return 0;

  }

  write_to_testcase(out_buf, len);

  fault = run_target(argv, exec_tmout);

  if (stop_soon) return 1;

  if (fault == FAULT_TMOUT) {

    if (subseq_tmouts++ > TMOUT_LIMIT) {
      cur_skipped_paths++;
      return 1;
    }

  } else subseq_tmouts = 0;

  /* Users can hit us with SIGUSR1 to request the current input
     to be abandoned. */

  if (skip_requested) {

     skip_requested = 0;
     cur_skipped_paths++;
     return 1;

  }

  /* This handles FAULT_ERROR for us: */
 
  queued_discovered += save_if_interesting(argv, out_buf, len, fault);

  if (!(stage_cur % stats_update_freq) || stage_cur + 1 == stage_max)
    show_stats();

  return 0;

}


/* Helper to choose random block len for block operations in fuzz_one().
   Doesn't return zero, provided that max_len is > 0. */

static u32 choose_block_len(u32 limit) {

  u32 min_value, max_value;
  u32 rlim = MIN(queue_cycle, 3);

  if (!run_over10m) rlim = 1;

  switch (UR(rlim)) {

    case 0:  min_value = 1;
             max_value = HAVOC_BLK_SMALL;
             break;

    case 1:  min_value = HAVOC_BLK_SMALL;
             max_value = HAVOC_BLK_MEDIUM;
             break;

    default:

             if (UR(10)) {

               min_value = HAVOC_BLK_MEDIUM;
               max_value = HAVOC_BLK_LARGE;

             } else {

               min_value = HAVOC_BLK_LARGE;
               max_value = HAVOC_BLK_XL;

             }

  }

  if (min_value >= limit) min_value = 1;

  return min_value + UR(MIN(max_value, limit) - min_value + 1);

}


/* Calculate case desirability score to adjust the length of havoc fuzzing.
   A helper function for fuzz_one(). Maybe some of these constants should
   go into config.h. */

static u32 calculate_score(struct queue_entry* q) {

  u32 avg_exec_us = total_cal_us / total_cal_cycles;
  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;
  u32 perf_score = 100;

  /* Adjust score based on execution speed of this path, compared to the
     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are
     less expensive to fuzz, so we're giving them more air time. */

  if (q->exec_us * 0.1 > avg_exec_us) perf_score = 10;
  else if (q->exec_us * 0.25 > avg_exec_us) perf_score = 25;
  else if (q->exec_us * 0.5 > avg_exec_us) perf_score = 50;
  else if (q->exec_us * 0.75 > avg_exec_us) perf_score = 75;
  else if (q->exec_us * 4 < avg_exec_us) perf_score = 300;
  else if (q->exec_us * 3 < avg_exec_us) perf_score = 200;
  else if (q->exec_us * 2 < avg_exec_us) perf_score = 150;

  /* Adjust score based on bitmap size. The working theory is that better
     coverage translates to better targets. Multiplier from 0.25x to 3x. */

  if (q->bitmap_size * 0.3 > avg_bitmap_size) perf_score *= 3;
  else if (q->bitmap_size * 0.5 > avg_bitmap_size) perf_score *= 2;
  else if (q->bitmap_size * 0.75 > avg_bitmap_size) perf_score *= 1.5;
  else if (q->bitmap_size * 3 < avg_bitmap_size) perf_score *= 0.25;
  else if (q->bitmap_size * 2 < avg_bitmap_size) perf_score *= 0.5;
  else if (q->bitmap_size * 1.5 < avg_bitmap_size) perf_score *= 0.75;

  /* Adjust score based on handicap. Handicap is proportional to how late
     in the game we learned about this path. Latecomers are allowed to run
     for a bit longer until they catch up with the rest. */

  if (q->handicap >= 4) {

    perf_score *= 4;
    q->handicap -= 4;

  } else if (q->handicap) {

    perf_score *= 2;
    q->handicap--;

  }

  /* Final adjustment based on input depth, under the assumption that fuzzing
     deeper test cases is more likely to reveal stuff that can't be
     discovered with traditional fuzzers. */

  if(q->depth >= 4) {
	  if(q->depth < 8) perf_score *= 2;
	  else if(q->depth < 14) perf_score *= 3;
	  else if(q->depth < 26) perf_score *= 4;
	  else perf_score *= 5;
  }

  /* Make sure that we don't go over limit. */

  if (perf_score > HAVOC_MAX_MULT * 100) perf_score = HAVOC_MAX_MULT * 100;

  return perf_score;

}


/* Helper function to see if a particular change (xor_val = old ^ new) could
   be a product of deterministic bit flips with the lengths and stepovers
   attempted by afl-fuzz. This is used to avoid dupes in some of the
   deterministic fuzzing operations that follow bit flips. We also
   return 1 if xor_val is zero, which implies that the old and attempted new
   values are identical and the exec would be a waste of time. */

static u8 could_be_bitflip(u32 xor_val) {

  u32 sh = 0;

  if (!xor_val) return 1;

  /* Shift left until first bit set. */

  while (!(xor_val & 1)) { sh++; xor_val >>= 1; }

  /* 1-, 2-, and 4-bit patterns are OK anywhere. */

  if (xor_val == 1 || xor_val == 3 || xor_val == 15) return 1;

  /* 8-, 16-, and 32-bit patterns are OK only if shift factor is
     divisible by 8, since that's the stepover for these ops. */

  if (sh & 7) return 0;

  if (xor_val == 0xff || xor_val == 0xffff || xor_val == 0xffffffff)
    return 1;

  return 0;

}


/* Helper function to see if a particular value is reachable through
   arithmetic operations. Used for similar purposes. */

static u8 could_be_arith(u32 old_val, u32 new_val, u8 blen) {

  u32 i, ov = 0, nv = 0, diffs = 0;

  if (old_val == new_val) return 1;

  /* See if one-byte adjustments to any byte could produce this result. */

  for (i = 0; i < blen; i++) {

    u8 a = old_val >> (8 * i),
       b = new_val >> (8 * i);

    if (a != b) { diffs++; ov = a; nv = b; }

  }

  /* If only one byte differs and the values are within range, return 1. */

  if (diffs == 1) {

    if ((u8)(ov - nv) <= ARITH_MAX ||
        (u8)(nv - ov) <= ARITH_MAX) return 1;

  }

  if (blen == 1) return 0;

  /* See if two-byte adjustments to any byte would produce this result. */

  diffs = 0;

  for (i = 0; i < blen / 2; i++) {

    u16 a = old_val >> (16 * i),
        b = new_val >> (16 * i);

    if (a != b) { diffs++; ov = a; nv = b; }

  }

  /* If only one word differs and the values are within range, return 1. */

  if (diffs == 1) {

    if ((u16)(ov - nv) <= ARITH_MAX ||
        (u16)(nv - ov) <= ARITH_MAX) return 1;

    ov = SWAP16(ov); nv = SWAP16(nv);

    if ((u16)(ov - nv) <= ARITH_MAX ||
        (u16)(nv - ov) <= ARITH_MAX) return 1;

  }

  /* Finally, let's do the same thing for dwords. */

  if (blen == 4) {

    if ((u32)(old_val - new_val) <= ARITH_MAX ||
        (u32)(new_val - old_val) <= ARITH_MAX) return 1;

    new_val = SWAP32(new_val);
    old_val = SWAP32(old_val);

    if ((u32)(old_val - new_val) <= ARITH_MAX ||
        (u32)(new_val - old_val) <= ARITH_MAX) return 1;

  }

  return 0;

}


/* Last but not least, a similar helper to see if insertion of an 
   interesting integer is redundant given the insertions done for
   shorter blen. The last param (check_le) is set if the caller
   already executed LE insertion for current blen and wants to see
   if BE variant passed in new_val is unique. */

static u8 could_be_interest(u32 old_val, u32 new_val, u8 blen, u8 check_le) {

  u32 i, j;

  if (old_val == new_val) return 1;

  /* See if one-byte insertions from interesting_8 over old_val could
     produce new_val. */

  for (i = 0; i < blen; i++) {

    for (j = 0; j < sizeof(interesting_8); j++) {

      u32 tval = (old_val & ~(0xff << (i * 8))) |
                 (((u8)interesting_8[j]) << (i * 8));

      if (new_val == tval) return 1;

    }

  }

  /* Bail out unless we're also asked to examine two-byte LE insertions
     as a preparation for BE attempts. */

  if (blen == 2 && !check_le) return 0;

  /* See if two-byte insertions over old_val could give us new_val. */

  for (i = 0; i < blen - 1; i++) {

    for (j = 0; j < sizeof(interesting_16) / 2; j++) {

      u32 tval = (old_val & ~(0xffff << (i * 8))) |
                 (((u16)interesting_16[j]) << (i * 8));

      if (new_val == tval) return 1;

      /* Continue here only if blen > 2. */

      if (blen > 2) {

        tval = (old_val & ~(0xffff << (i * 8))) |
               (SWAP16(interesting_16[j]) << (i * 8));

        if (new_val == tval) return 1;

      }

    }

  }

  if (blen == 4 && check_le) {

    /* See if four-byte insertions could produce the same result
       (LE only). */

    for (j = 0; j < sizeof(interesting_32) / 4; j++)
      if (new_val == (u32)interesting_32[j]) return 1;

  }

  return 0;

}


/* Take the current entry from the queue, fuzz it for a while. This
   function is a tad too long... returns 0 if fuzzed successfully, 1 if
   skipped or bailed out. */

static u8 fuzz_one(char** argv) {

  s32 len, fd, temp_len, i, j;
  u8  *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = 0;
  u64 havoc_queued,  orig_hit_cnt, new_hit_cnt;
  u32 splice_cycle = 0, perf_score = 100, orig_perf, prev_cksum, eff_cnt = 1;

  u8  ret_val = 1, doing_det = 0;

  u8  a_collect[MAX_AUTO_EXTRA];
  u32 a_len = 0;

#ifdef IGNORE_FINDS

  /* In IGNORE_FINDS mode, skip any entries that weren't in the
     initial data set. */

  if (queue_cur->depth > 1) return 1;

#else

  if (pending_favored) {

    /* If we have any favored, non-fuzzed new arrivals in the queue,
       possibly skip to them at the expense of already-fuzzed or non-favored
       cases. */

    if ((queue_cur->was_fuzzed || !queue_cur->favored) &&
        UR(100) < SKIP_TO_NEW_PROB) return 1;

  } else if (!dumb_mode && !queue_cur->favored && queued_paths > 10) {

    /* Otherwise, still possibly skip non-favored cases, albeit less often.
       The odds of skipping stuff are higher for already-fuzzed inputs and
       lower for never-fuzzed entries. */

    if (queue_cycle > 1 && !queue_cur->was_fuzzed) {

      if (UR(100) < SKIP_NFAV_NEW_PROB) return 1;

    } else {

      if (UR(100) < SKIP_NFAV_OLD_PROB) return 1;

    }

  }

#endif /* ^IGNORE_FINDS */

  if (not_on_tty)
    ACTF("Fuzzing test case #%u (%u total)...", current_entry, queued_paths);

  /* Map the test case into memory. */

  fd = open(queue_cur->fname, O_RDONLY | O_BINARY);

  if (fd < 0) PFATAL("Unable to open '%s'", queue_cur->fname);

  len = queue_cur->len;

  orig_in = in_buf = (u8 *)ck_alloc_nozero(len);
  _read(fd, in_buf, len);

  close(fd);

  /* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every
     single byte anyway, so it wouldn't give us any performance or memory usage
     benefits. */

  out_buf = ck_alloc_nozero(len);

  subseq_tmouts = 0;

  cur_depth = queue_cur->depth;

  /*******************************************
   * CALIBRATION (only if failed earlier on) *
   *******************************************/

  if (queue_cur->cal_failed) {

    u8 res = FAULT_TMOUT;

    if (queue_cur->cal_failed < CAL_CHANCES) {

      /* Reset exec_cksum to tell calibrate_case to re-execute the testcase
         avoiding the usage of an invalid trace_bits.
         For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */

      queue_cur->exec_cksum = 0;

      res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - 1, 0);

      if (res == FAULT_ERROR)
        FATAL("Unable to execute target application");

    }

    if (stop_soon || res != crash_mode) {
      cur_skipped_paths++;
      goto abandon_entry;
    }

  }

  /************
   * TRIMMING *
   ************/

  if (!dumb_mode && !queue_cur->trim_done) {

    u8 res = trim_case(argv, queue_cur, in_buf);

    if (res == FAULT_ERROR)
      FATAL("Unable to execute target application");

    if (stop_soon) {
      cur_skipped_paths++;
      goto abandon_entry;
    }

    /* Don't retry trimming, even if it failed. */

    queue_cur->trim_done = 1;

    if (len != queue_cur->len) len = queue_cur->len;

  }

  memcpy(out_buf, in_buf, len);

  /*********************
   * PERFORMANCE SCORE *
   *********************/

  orig_perf = perf_score = calculate_score(queue_cur);

  /******************
   * CUSTOM MUTATOR *
   *****************/

  // Prefer a custom mutator that accepts the performance score as an energy value.
  if (dll_mutate_testcase_with_energy_ptr) {
    if (dll_mutate_testcase_with_energy_ptr(argv, in_buf, len, perf_score, common_fuzz_stuff))
      goto abandon_entry;
  }
  else if (dll_mutate_testcase_ptr) {
    if (dll_mutate_testcase_ptr(argv, in_buf, len, common_fuzz_stuff))
      goto abandon_entry;
  }

  /* Skip right away if -d is given, if we have done deterministic fuzzing on
     this entry ourselves (was_fuzzed), or if it has gone through deterministic
     testing in earlier, resumed runs (passed_det). */

  if (skip_deterministic || queue_cur->was_fuzzed || queue_cur->passed_det)
    goto havoc_stage;

  /* Skip deterministic fuzzing if exec path checksum puts this out of scope
     for this master instance. */

  if (master_max && (queue_cur->exec_cksum % master_max) != master_id - 1)
    goto havoc_stage;

  doing_det = 1;

  /*********************************************
   * SIMPLE BITFLIP (+dictionary construction) *
   *********************************************/

#define FLIP_BIT(_ar, _b) do { \
    u8* _arf = (u8*)(_ar); \
    u32 _bf = (_b); \
    _arf[(_bf) >> 3] ^= (128 >> ((_bf) & 7)); \
  } while (0)

  /* Single walking bit. */

  stage_short = "flip1";
  stage_max   = len << 3;
  stage_name  = "bitflip 1\\1";

  stage_val_type = STAGE_VAL_NONE;

  orig_hit_cnt = queued_paths + unique_crashes;

  prev_cksum = queue_cur->exec_cksum;

  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {

    stage_cur_byte = stage_cur >> 3;

    FLIP_BIT(out_buf, stage_cur);

    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;

    FLIP_BIT(out_buf, stage_cur);

    /* While flipping the least significant bit in every byte, pull of an extra
       trick to detect possible syntax tokens. In essence, the idea is that if
       you have a binary blob like this:

       xxxxxxxxIHDRxxxxxxxx

       ...and changing the leading and trailing bytes causes variable or no
       changes in program flow, but touching any character in the "IHDR" string
       always produces the same, distinctive path, it's highly likely that
       "IHDR" is an atomically-checked magic value of special significance to
       the fuzzed format.

       We do this here, rather than as a separate stage, because it's a nice
       way to keep the operation approximately "free" (i.e., no extra execs).
       
       Empirically, performing the check when flipping the least significant bit
       is advantageous, compared to doing it at the time of more disruptive
       changes, where the program flow may be affected in more violent ways.

       The caveat is that we won't generate dictionaries in the -d mode or -S
       mode - but that's probably a fair trade-off.

       This won't work particularly well with paths that exhibit variable
       behavior, but fails gracefully, so we'll carry out the checks anyway.

      */

    if (!dumb_mode && (stage_cur & 7) == 7) {

      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);

      if (stage_cur == stage_max - 1 && cksum == prev_cksum) {

        /* If at end of file and we are still collecting a string, grab the
           final character and force output. */

        if (a_len < MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur >> 3];
        a_len++;

        if (a_len >= MIN_AUTO_EXTRA && a_len <= MAX_AUTO_EXTRA)
          maybe_add_auto(a_collect, a_len);

      } else if (cksum != prev_cksum) {

        /* Otherwise, if the checksum has changed, see if we have something
           worthwhile queued up, and collect that if the answer is yes. */

        if (a_len >= MIN_AUTO_EXTRA && a_len <= MAX_AUTO_EXTRA)
          maybe_add_auto(a_collect, a_len);

        a_len = 0;
        prev_cksum = cksum;

      }

      /* Continue collecting string, but only if the bit flip actually made
         any difference - we don't want no-op tokens. */

      if (cksum != queue_cur->exec_cksum) {

        if (a_len < MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur >> 3];        
        a_len++;

      }

    }

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_FLIP1] += stage_max;

  /* Two walking bits. */

  stage_name  = "bitflip 2\\1";
  stage_short = "flip2";
  stage_max   = (len << 3) - 1;

  orig_hit_cnt = new_hit_cnt;

  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {

    stage_cur_byte = stage_cur >> 3;

    FLIP_BIT(out_buf, stage_cur);
    FLIP_BIT(out_buf, stage_cur + 1);

    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;

    FLIP_BIT(out_buf, stage_cur);
    FLIP_BIT(out_buf, stage_cur + 1);

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_FLIP2]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_FLIP2] += stage_max;

  /* Four walking bits. */

  stage_name  = "bitflip 4\\1";
  stage_short = "flip4";
  stage_max   = (len << 3) - 3;

  orig_hit_cnt = new_hit_cnt;

  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {

    stage_cur_byte = stage_cur >> 3;

    FLIP_BIT(out_buf, stage_cur);
    FLIP_BIT(out_buf, stage_cur + 1);
    FLIP_BIT(out_buf, stage_cur + 2);
    FLIP_BIT(out_buf, stage_cur + 3);

    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;

    FLIP_BIT(out_buf, stage_cur);
    FLIP_BIT(out_buf, stage_cur + 1);
    FLIP_BIT(out_buf, stage_cur + 2);
    FLIP_BIT(out_buf, stage_cur + 3);

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_FLIP4]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_FLIP4] += stage_max;

  /* Effector map setup. These macros calculate:

     EFF_APOS      - position of a particular file offset in the map.
     EFF_ALEN      - length of a map with a particular number of bytes.
     EFF_SPAN_ALEN - map span for a sequence of bytes.

   */

#define EFF_APOS(_p)          ((_p) >> EFF_MAP_SCALE2)
#define EFF_REM(_x)           ((_x) & ((1 << EFF_MAP_SCALE2) - 1))
#define EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))
#define EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)

  /* Initialize effector map for the next step (see comments below). Always
     flag first and last byte as doing something. */

  eff_map    = ck_alloc(EFF_ALEN(len));
  eff_map[0] = 1;

  if (EFF_APOS(len - 1) != 0) {
    eff_map[EFF_APOS(len - 1)] = 1;
    eff_cnt++;
  }

  /* Walking byte. */

  stage_name  = "bitflip 8\\8";
  stage_short = "flip8";
  stage_max   = len;

  orig_hit_cnt = new_hit_cnt;

  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {

    stage_cur_byte = stage_cur;

    out_buf[stage_cur] ^= 0xFF;

    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;

    /* We also use this stage to pull off a simple trick: we identify
       bytes that seem to have no effect on the current execution path
       even when fully flipped - and we skip them during more expensive
       deterministic stages, such as arithmetics or known ints. */

    if (!eff_map[EFF_APOS(stage_cur)]) {

      u32 cksum;

      /* If in dumb mode or if the file is very short, just flag everything
         without wasting time on checksums. */

      if (!dumb_mode && len >= EFF_MIN_LEN)
        cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
      else
        cksum = ~queue_cur->exec_cksum;

      if (cksum != queue_cur->exec_cksum) {
        eff_map[EFF_APOS(stage_cur)] = 1;
        eff_cnt++;
      }

    }

    out_buf[stage_cur] ^= 0xFF;

  }

  /* If the effector map is more than EFF_MAX_PERC dense, just flag the
     whole thing as worth fuzzing, since we wouldn't be saving much time
     anyway. */

  if (eff_cnt != EFF_ALEN(len) &&
      eff_cnt * 100 / EFF_ALEN(len) > EFF_MAX_PERC) {

    memset(eff_map, 1, EFF_ALEN(len));

    blocks_eff_select += EFF_ALEN(len);

  } else {

    blocks_eff_select += eff_cnt;

  }

  blocks_eff_total += EFF_ALEN(len);

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_FLIP8]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_FLIP8] += stage_max;

  /* Two walking bytes. */

  if (len < 2) goto skip_bitflip;

  stage_name  = "bitflip 16\\8";
  stage_short = "flip16";
  stage_cur   = 0;
  stage_max   = len - 1;

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len - 1; i++) {

    /* Let's consult the effector map... */

    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
      stage_max--;
      continue;
    }

    stage_cur_byte = i;

    *(u16*)(out_buf + i) ^= 0xFFFF;

    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
    stage_cur++;

    *(u16*)(out_buf + i) ^= 0xFFFF;


  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_FLIP16] += stage_max;

  if (len < 4) goto skip_bitflip;

  /* Four walking bytes. */

  stage_name  = "bitflip 32\\8";
  stage_short = "flip32";
  stage_cur   = 0;
  stage_max   = len - 3;

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len - 3; i++) {

    /* Let's consult the effector map... */
    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
      stage_max--;
      continue;
    }

    stage_cur_byte = i;

    *(u32*)(out_buf + i) ^= 0xFFFFFFFF;

    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
    stage_cur++;

    *(u32*)(out_buf + i) ^= 0xFFFFFFFF;

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_FLIP32] += stage_max;

skip_bitflip:

  if (no_arith) goto skip_arith;

  /**********************
   * ARITHMETIC INC/DEC *
   **********************/

  /* 8-bit arithmetics. */

  stage_name  = "arith 8\\8";
  stage_short = "arith8";
  stage_cur   = 0;
  stage_max   = 2 * len * ARITH_MAX;

  stage_val_type = STAGE_VAL_LE;

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len; i++) {

    u8 orig = out_buf[i];

    /* Let's consult the effector map... */

    if (!eff_map[EFF_APOS(i)]) {
      stage_max -= 2 * ARITH_MAX;
      continue;
    }

    stage_cur_byte = i;

    for (j = 1; j <= ARITH_MAX; j++) {

      u8 r = orig ^ (orig + j);

      /* Do arithmetic operations only if the result couldn't be a product
         of a bitflip. */

      if (!could_be_bitflip(r)) {

        stage_cur_val = j;
        out_buf[i] = orig + j;

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      r =  orig ^ (orig - j);

      if (!could_be_bitflip(r)) {

        stage_cur_val = -j;
        out_buf[i] = orig - j;

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      out_buf[i] = orig;

    }

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_ARITH8] += stage_max;

  /* 16-bit arithmetics, both endians. */

  if (len < 2) goto skip_arith;

  stage_name  = "arith 16\\8";
  stage_short = "arith16";
  stage_cur   = 0;
  stage_max   = 4 * (len - 1) * ARITH_MAX;

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len - 1; i++) {

    u16 orig = *(u16*)(out_buf + i);

    /* Let's consult the effector map... */

    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
      stage_max -= 4 * ARITH_MAX;
      continue;
    }

    stage_cur_byte = i;

    for (j = 1; j <= ARITH_MAX; j++) {

      u16 r1 = orig ^ (orig + j),
          r2 = orig ^ (orig - j),
          r3 = orig ^ SWAP16(SWAP16(orig) + j),
          r4 = orig ^ SWAP16(SWAP16(orig) - j);

      /* Try little endian addition and subtraction first. Do it only
         if the operation would affect more than one byte (hence the 
         & 0xff overflow checks) and if it couldn't be a product of
         a bitflip. */

      stage_val_type = STAGE_VAL_LE; 

      if ((orig & 0xff) + j > 0xff && !could_be_bitflip(r1)) {

        stage_cur_val = j;
        *(u16*)(out_buf + i) = orig + j;

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;
 
      } else stage_max--;

      if ((orig & 0xff) < j && !could_be_bitflip(r2)) {

        stage_cur_val = -j;
        *(u16*)(out_buf + i) = orig - j;

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      /* Big endian comes next. Same deal. */

      stage_val_type = STAGE_VAL_BE;


      if ((orig >> 8) + j > 0xff && !could_be_bitflip(r3)) {

        stage_cur_val = j;
        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) + j);

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      if ((orig >> 8) < j && !could_be_bitflip(r4)) {

        stage_cur_val = -j;
        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) - j);

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      *(u16*)(out_buf + i) = orig;

    }

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_ARITH16]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_ARITH16] += stage_max;

  /* 32-bit arithmetics, both endians. */

  if (len < 4) goto skip_arith;

  stage_name  = "arith 32\\8";
  stage_short = "arith32";
  stage_cur   = 0;
  stage_max   = 4 * (len - 3) * ARITH_MAX;

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len - 3; i++) {

    u32 orig = *(u32*)(out_buf + i);

    /* Let's consult the effector map... */

    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
      stage_max -= 4 * ARITH_MAX;
      continue;
    }

    stage_cur_byte = i;

    for (j = 1; j <= ARITH_MAX; j++) {

      u32 r1 = orig ^ (orig + j),
          r2 = orig ^ (orig - j),
          r3 = orig ^ SWAP32(SWAP32(orig) + j),
          r4 = orig ^ SWAP32(SWAP32(orig) - j);

      /* Little endian first. Same deal as with 16-bit: we only want to
         try if the operation would have effect on more than two bytes. */

      stage_val_type = STAGE_VAL_LE; 

      if ((orig & 0xffff) + j > 0xffff && !could_be_bitflip(r1)) {

        stage_cur_val = j;
        *(u32*)(out_buf + i) = orig + j;

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      if ((orig & 0xffff) < j && !could_be_bitflip(r2)) {

        stage_cur_val = -j;
        *(u32*)(out_buf + i) = orig - j;

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      /* Big endian next. */

      stage_val_type = STAGE_VAL_BE;

      if ((SWAP32(orig) & 0xffff) + j > 0xffff && !could_be_bitflip(r3)) {

        stage_cur_val = j;
        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) + j);

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      if ((SWAP32(orig) & 0xffff) < j && !could_be_bitflip(r4)) {

        stage_cur_val = -j;
        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) - j);

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      *(u32*)(out_buf + i) = orig;

    }

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_ARITH32]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_ARITH32] += stage_max;

skip_arith:

  /**********************
   * INTERESTING VALUES *
   **********************/

  stage_name  = "interest 8\\8";
  stage_short = "int8";
  stage_cur   = 0;
  stage_max   = len * sizeof(interesting_8);

  stage_val_type = STAGE_VAL_LE;

  orig_hit_cnt = new_hit_cnt;

  /* Setting 8-bit integers. */

  for (i = 0; i < len; i++) {

    u8 orig = out_buf[i];

    /* Let's consult the effector map... */

    if (!eff_map[EFF_APOS(i)]) {
      stage_max -= sizeof(interesting_8);
      continue;
    }

    stage_cur_byte = i;

    for (j = 0; j < sizeof(interesting_8); j++) {

      /* Skip if the value could be a product of bitflips or arithmetics. */

      if (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||
          could_be_arith(orig, (u8)interesting_8[j], 1)) {
        stage_max--;
        continue;
      }

      stage_cur_val = interesting_8[j];
      out_buf[i] = interesting_8[j];

      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;

      out_buf[i] = orig;
      stage_cur++;

    }

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_INTEREST8] += stage_max;

  /* Setting 16-bit integers, both endians. */

  if (no_arith || len < 2) goto skip_interest;

  stage_name  = "interest 16\\8";
  stage_short = "int16";
  stage_cur   = 0;
  stage_max   = 2 * (len - 1) * (sizeof(interesting_16) >> 1);

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len - 1; i++) {

    u16 orig = *(u16*)(out_buf + i);

    /* Let's consult the effector map... */

    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {
      stage_max -= sizeof(interesting_16);
      continue;
    }

    stage_cur_byte = i;

    for (j = 0; j < sizeof(interesting_16) / 2; j++) {

      stage_cur_val = interesting_16[j];

      /* Skip if this could be a product of a bitflip, arithmetics,
         or single-byte interesting value insertion. */

      if (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &&
          !could_be_arith(orig, (u16)interesting_16[j], 2) &&
          !could_be_interest(orig, (u16)interesting_16[j], 2, 0)) {

        stage_val_type = STAGE_VAL_LE;

        *(u16*)(out_buf + i) = interesting_16[j];

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      if ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &&
          !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &&
          !could_be_arith(orig, SWAP16(interesting_16[j]), 2) &&
          !could_be_interest(orig, SWAP16(interesting_16[j]), 2, 1)) {

        stage_val_type = STAGE_VAL_BE;

        *(u16*)(out_buf + i) = SWAP16(interesting_16[j]);
        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

    }

    *(u16*)(out_buf + i) = orig;

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_INTEREST16]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_INTEREST16] += stage_max;

  if (len < 4) goto skip_interest;

  /* Setting 32-bit integers, both endians. */

  stage_name  = "interest 32\\8";
  stage_short = "int32";
  stage_cur   = 0;
  stage_max   = 2 * (len - 3) * (sizeof(interesting_32) >> 2);

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len - 3; i++) {

    u32 orig = *(u32*)(out_buf + i);

    /* Let's consult the effector map... */

    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&
        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {
      stage_max -= sizeof(interesting_32) >> 1;
      continue;
    }

    stage_cur_byte = i;

    for (j = 0; j < sizeof(interesting_32) / 4; j++) {

      stage_cur_val = interesting_32[j];

      /* Skip if this could be a product of a bitflip, arithmetics,
         or word interesting value insertion. */

      if (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &&
          !could_be_arith(orig, interesting_32[j], 4) &&
          !could_be_interest(orig, interesting_32[j], 4, 0)) {

        stage_val_type = STAGE_VAL_LE;

        *(u32*)(out_buf + i) = interesting_32[j];

        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

      if ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &&
          !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &&
          !could_be_arith(orig, SWAP32(interesting_32[j]), 4) &&
          !could_be_interest(orig, SWAP32(interesting_32[j]), 4, 1)) {

        stage_val_type = STAGE_VAL_BE;

        *(u32*)(out_buf + i) = SWAP32(interesting_32[j]);
        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;
        stage_cur++;

      } else stage_max--;

    }

    *(u32*)(out_buf + i) = orig;

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_INTEREST32]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_INTEREST32] += stage_max;

skip_interest:

  /********************
   * DICTIONARY STUFF *
   ********************/

  if (!extras_cnt) goto skip_user_extras;

  /* Overwrite with user-supplied extras. */

  stage_name  = "user extras (over)";
  stage_short = "ext_UO";
  stage_cur   = 0;
  stage_max   = extras_cnt * len;

  stage_val_type = STAGE_VAL_NONE;

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len; i++) {

    u32 last_len = 0;

    stage_cur_byte = i;

    /* Extras are sorted by size, from smallest to largest. This means
       that we don't have to worry about restoring the buffer in
       between writes at a particular offset determined by the outer
       loop. */

    for (j = 0; j < extras_cnt; j++) {

      /* Skip extras probabilistically if extras_cnt > MAX_DET_EXTRAS. Also
         skip them if there's no room to insert the payload, if the token
         is redundant, or if its entire span has no bytes set in the effector
         map. */

      if ((extras_cnt > MAX_DET_EXTRAS && UR(extras_cnt) >= MAX_DET_EXTRAS) ||
          extras[j].len > len - i ||
          !memcmp(extras[j].data, out_buf + i, extras[j].len) ||
          !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, extras[j].len))) {

        stage_max--;
        continue;

      }

      last_len = extras[j].len;
      memcpy(out_buf + i, extras[j].data, last_len);

      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;

      stage_cur++;

    }

    /* Restore all the clobbered memory. */
    memcpy(out_buf + i, in_buf + i, last_len);

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_EXTRAS_UO] += stage_max;

  /* Insertion of user-supplied extras. */

  stage_name  = "user extras (insert)";
  stage_short = "ext_UI";
  stage_cur   = 0;
  stage_max   = extras_cnt * (len + 1);

  orig_hit_cnt = new_hit_cnt;

  ex_tmp = ck_alloc(len + MAX_DICT_FILE);

  for (i = 0; i <= len; i++) {

    stage_cur_byte = i;

    for (j = 0; j < extras_cnt; j++) {

      if (len + extras[j].len > MAX_FILE) {
        stage_max--;
        continue;
      }

      /* Insert token */
      memcpy(ex_tmp + i, extras[j].data, extras[j].len);

      /* Copy tail */
      memcpy(ex_tmp + i + extras[j].len, out_buf + i, len - i);

      if (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) {
        ck_free(ex_tmp);
        goto abandon_entry;
      }

      stage_cur++;

    }

    /* Copy head */
    ex_tmp[i] = out_buf[i];

  }

  ck_free(ex_tmp);

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_EXTRAS_UI] += stage_max;

skip_user_extras:

  if (!a_extras_cnt) goto skip_extras;

  stage_name  = "auto extras (over)";
  stage_short = "ext_AO";
  stage_cur   = 0;
  stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;

  stage_val_type = STAGE_VAL_NONE;

  orig_hit_cnt = new_hit_cnt;

  for (i = 0; i < len; i++) {

    u32 last_len = 0;

    stage_cur_byte = i;

    for (j = 0; j < MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) {

      /* See the comment in the earlier code; extras are sorted by size. */

      if (a_extras[j].len > len - i ||
          !memcmp(a_extras[j].data, out_buf + i, a_extras[j].len) ||
          !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, a_extras[j].len))) {

        stage_max--;
        continue;

      }

      last_len = a_extras[j].len;
      memcpy(out_buf + i, a_extras[j].data, last_len);

      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;

      stage_cur++;

    }

    /* Restore all the clobbered memory. */
    memcpy(out_buf + i, in_buf + i, last_len);

  }

  new_hit_cnt = queued_paths + unique_crashes;

  stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;
  stage_cycles[STAGE_EXTRAS_AO] += stage_max;

skip_extras:

  /* If we made this to here without jumping to havoc_stage or abandon_entry,
     we're properly done with deterministic steps and can mark it as such
     in the .state/ directory. */

  if (!queue_cur->passed_det) mark_as_det_done(queue_cur);

  /****************
   * RANDOM HAVOC *
   ****************/

havoc_stage:

  stage_cur_byte = -1;

  /* The havoc stage mutation code is also invoked when splicing files; if the
     splice_cycle variable is set, generate different descriptions and such. */

  if (!splice_cycle) {

    stage_name  = "havoc";
    stage_short = "havoc";
    stage_max = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) *
                 perf_score / havoc_div / 100;
  } else {

    static u8 tmp[32];

    perf_score = orig_perf;

    sprintf(tmp, "splice %u", splice_cycle);
    stage_name  = tmp;
    stage_short = "splice";
    stage_max   = SPLICE_HAVOC * perf_score / havoc_div / 100;

  }

  if (stage_max < HAVOC_MIN) stage_max = HAVOC_MIN;

  temp_len = len;

  orig_hit_cnt = queued_paths + unique_crashes;

  havoc_queued = queued_paths;

  /* We essentially just do several thousand runs (depending on perf_score)
     where we take the input file and make random stacked tweaks. */

  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {

    u32 use_stacking = 1 << (1 + UR(HAVOC_STACK_POW2));

    stage_cur_val = use_stacking;
 
    for (i = 0; i < use_stacking; i++) {

      switch (UR(15 + ((extras_cnt + a_extras_cnt) ? 2 : 0))) {

        case 0:

          /* Flip a single bit somewhere. Spooky! */

          FLIP_BIT(out_buf, UR(temp_len << 3));
          break;

        case 1: 

          /* Set byte to interesting value. */

          out_buf[UR(temp_len)] = interesting_8[UR(sizeof(interesting_8))];
          break;

        case 2:

          /* Set word to interesting value, randomly choosing endian. */

          if (temp_len < 2) break;

          if (UR(2)) {

            *(u16*)(out_buf + UR(temp_len - 1)) =
              interesting_16[UR(sizeof(interesting_16) >> 1)];

          } else {

            *(u16*)(out_buf + UR(temp_len - 1)) = SWAP16(
              interesting_16[UR(sizeof(interesting_16) >> 1)]);

          }

          break;

        case 3:

          /* Set dword to interesting value, randomly choosing endian. */

          if (temp_len < 4) break;

          if (UR(2)) {
  
            *(u32*)(out_buf + UR(temp_len - 3)) =
              interesting_32[UR(sizeof(interesting_32) >> 2)];

          } else {

            *(u32*)(out_buf + UR(temp_len - 3)) = SWAP32(
              interesting_32[UR(sizeof(interesting_32) >> 2)]);

          }

          break;

        case 4:

          /* Randomly subtract from byte. */

          out_buf[UR(temp_len)] -= 1 + UR(ARITH_MAX);
          break;

        case 5:

          /* Randomly add to byte. */

          out_buf[UR(temp_len)] += 1 + UR(ARITH_MAX);
          break;

        case 6:

          /* Randomly subtract from word, random endian. */

          if (temp_len < 2) break;

          if (UR(2)) {

            u32 pos = UR(temp_len - 1);

            *(u16*)(out_buf + pos) -= 1 + UR(ARITH_MAX);

          } else {

            u32 pos = UR(temp_len - 1);
            u16 num = 1 + UR(ARITH_MAX);

            *(u16*)(out_buf + pos) =
              SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);

          }

          break;

        case 7:

          /* Randomly add to word, random endian. */

          if (temp_len < 2) break;

          if (UR(2)) {

            u32 pos = UR(temp_len - 1);

            *(u16*)(out_buf + pos) += 1 + UR(ARITH_MAX);

          } else {

            u32 pos = UR(temp_len - 1);
            u16 num = 1 + UR(ARITH_MAX);

            *(u16*)(out_buf + pos) =
              SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);

          }

          break;

        case 8:

          /* Randomly subtract from dword, random endian. */

          if (temp_len < 4) break;

          if (UR(2)) {

            u32 pos = UR(temp_len - 3);

            *(u32*)(out_buf + pos) -= 1 + UR(ARITH_MAX);

          } else {

            u32 pos = UR(temp_len - 3);
            u32 num = 1 + UR(ARITH_MAX);

            *(u32*)(out_buf + pos) =
              SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);

          }

          break;

        case 9:

          /* Randomly add to dword, random endian. */

          if (temp_len < 4) break;

          if (UR(2)) {

            u32 pos = UR(temp_len - 3);

            *(u32*)(out_buf + pos) += 1 + UR(ARITH_MAX);

          } else {

            u32 pos = UR(temp_len - 3);
            u32 num = 1 + UR(ARITH_MAX);

            *(u32*)(out_buf + pos) =
              SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);

          }

          break;

        case 10:

          /* Just set a random byte to a random value. Because,
             why not. We use XOR with 1-255 to eliminate the
             possibility of a no-op. */

          out_buf[UR(temp_len)] ^= 1 + UR(255);
          break;

		case 11:
		case 12:

		  {

            /* Delete bytes. We're making this a bit more likely
               than insertion (the next option) in hopes of keeping
               files reasonably small. */

            u32 del_from, del_len;

            if (temp_len < 2) break;

            /* Don't delete too much. */

            del_len = choose_block_len(temp_len - 1);

            del_from = UR(temp_len - del_len + 1);

            memmove(out_buf + del_from, out_buf + del_from + del_len,
                    temp_len - del_from - del_len);

            temp_len -= del_len;

            break;

          }

        case 13:

          if (temp_len + HAVOC_BLK_XL < MAX_FILE) {

            /* Clone bytes (75%) or insert a block of constant bytes (25%). */

            u8  actually_clone = UR(4);
            u32 clone_from, clone_to, clone_len;
            u8* new_buf;

            if (actually_clone) {

              clone_len  = choose_block_len(temp_len);
              clone_from = UR(temp_len - clone_len + 1);

            } else {

              clone_len = choose_block_len(HAVOC_BLK_XL);
              clone_from = 0;

            }

            clone_to   = UR(temp_len);

            new_buf = ck_alloc_nozero(temp_len + clone_len);

            /* Head */

            memcpy(new_buf, out_buf, clone_to);

            /* Inserted part */

            if (actually_clone)
              memcpy(new_buf + clone_to, out_buf + clone_from, clone_len);
            else
              memset(new_buf + clone_to,
                     UR(2) ? UR(256) : out_buf[UR(temp_len)], clone_len);

            /* Tail */
            memcpy(new_buf + clone_to + clone_len, out_buf + clone_to,
                   temp_len - clone_to);

            ck_free(out_buf);
            out_buf = new_buf;
            temp_len += clone_len;

          }

          break;

        case 14: {

            /* Overwrite bytes with a randomly selected chunk (75%) or fixed
               bytes (25%). */

            u32 copy_from, copy_to, copy_len;

            if (temp_len < 2) break;

            copy_len  = choose_block_len(temp_len - 1);

            copy_from = UR(temp_len - copy_len + 1);
            copy_to   = UR(temp_len - copy_len + 1);

            if (UR(4)) {

              if (copy_from != copy_to)
                memmove(out_buf + copy_to, out_buf + copy_from, copy_len);

            } else memset(out_buf + copy_to,
                          UR(2) ? UR(256) : out_buf[UR(temp_len)], copy_len);

            break;

          }

        /* Values 15 and 16 can be selected only if there are any extras
           present in the dictionaries. */

        case 15: {

            /* Overwrite bytes with an extra. */

            if (!extras_cnt || (a_extras_cnt && UR(2))) {

              /* No user-specified extras or odds in our favor. Let's use an
                 auto-detected one. */

              u32 use_extra = UR(a_extras_cnt);
              u32 extra_len = a_extras[use_extra].len;
              u32 insert_at;

              if (extra_len > temp_len) break;

              insert_at = UR(temp_len - extra_len + 1);
              memcpy(out_buf + insert_at, a_extras[use_extra].data, extra_len);

            } else {

              /* No auto extras or odds in our favor. Use the dictionary. */

              u32 use_extra = UR(extras_cnt);
              u32 extra_len = extras[use_extra].len;
              u32 insert_at;

              if (extra_len > temp_len) break;

              insert_at = UR(temp_len - extra_len + 1);
              memcpy(out_buf + insert_at, extras[use_extra].data, extra_len);

            }

            break;

          }

        case 16: {

            u32 use_extra, extra_len, insert_at = UR(temp_len + 1);
            u8* new_buf;

            /* Insert an extra. Do the same dice-rolling stuff as for the
               previous case. */

            if (!extras_cnt || (a_extras_cnt && UR(2))) {

              use_extra = UR(a_extras_cnt);
              extra_len = a_extras[use_extra].len;

              if (temp_len + extra_len >= MAX_FILE) break;

              new_buf = ck_alloc_nozero(temp_len + extra_len);

              /* Head */
              memcpy(new_buf, out_buf, insert_at);

              /* Inserted part */
              memcpy(new_buf + insert_at, a_extras[use_extra].data, extra_len);

            } else {

              use_extra = UR(extras_cnt);
              extra_len = extras[use_extra].len;

              if (temp_len + extra_len >= MAX_FILE) break;

              new_buf = ck_alloc_nozero(temp_len + extra_len);

              /* Head */
              memcpy(new_buf, out_buf, insert_at);

              /* Inserted part */
              memcpy(new_buf + insert_at, extras[use_extra].data, extra_len);

            }

            /* Tail */
            memcpy(new_buf + insert_at + extra_len, out_buf + insert_at,
                   temp_len - insert_at);

            ck_free(out_buf);
            out_buf   = new_buf;
            temp_len += extra_len;

            break;

          }

      }

    }

    if (common_fuzz_stuff(argv, out_buf, temp_len))
      goto abandon_entry;

    /* out_buf might have been mangled a bit, so let's restore it to its
       original size and shape. */

    if (temp_len < len) out_buf = ck_realloc(out_buf, len);
    temp_len = len;
    memcpy(out_buf, in_buf, len);

    /* If we're finding new stuff, let's run for a bit longer, limits
       permitting. */

    if (queued_paths != havoc_queued) {

      if (perf_score <= HAVOC_MAX_MULT * 100) {
        stage_max  *= 2;
        perf_score *= 2;
      }

      havoc_queued = queued_paths;

    }

  }

  new_hit_cnt = queued_paths + unique_crashes;

  if (!splice_cycle) {
    stage_finds[STAGE_HAVOC]  += new_hit_cnt - orig_hit_cnt;
    stage_cycles[STAGE_HAVOC] += stage_max;
  } else {
    stage_finds[STAGE_SPLICE]  += new_hit_cnt - orig_hit_cnt;
    stage_cycles[STAGE_SPLICE] += stage_max;
  }

#ifndef IGNORE_FINDS

  /************
   * SPLICING *
   ************/

  /* This is a last-resort strategy triggered by a full round with no findings.
     It takes the current input file, randomly selects another input, and
     splices them together at some offset, then relies on the havoc
     code to mutate that blob. */

retry_splicing:

  if (use_splicing && splice_cycle++ < SPLICE_CYCLES &&
      queued_paths > 1 && queue_cur->len > 1) {

    struct queue_entry* target;
    u32 tid, split_at;
    u8* new_buf;
    s32 f_diff, l_diff;

    /* First of all, if we've modified in_buf for havoc, let's clean that
       up... */

    if (in_buf != orig_in) {
      ck_free(in_buf);
      in_buf = orig_in;
      len = queue_cur->len;
    }

    /* Pick a random queue entry and seek to it. Don't splice with yourself. */

    do { tid = UR(queued_paths); } while (tid == current_entry);

    splicing_with = tid;
    target = queue;

    while (tid >= 100) { target = target->next_100; tid -= 100; }
    while (tid--) target = target->next;

    /* Make sure that the target has a reasonable length. */

    while (target && (target->len < 2 || target == queue_cur)) {
      target = target->next;
      splicing_with++;
    }

    if (!target) goto retry_splicing;

    /* Read the testcase into a new buffer. */

    fd = open(target->fname, O_RDONLY | O_BINARY);

    if (fd < 0) PFATAL("Unable to open '%s'", target->fname);

    new_buf = ck_alloc_nozero(target->len);

    ck_read(fd, new_buf, target->len, target->fname);

    close(fd);

    /* Find a suitable splicing location, somewhere between the first and
       the last differing byte. Bail out if the difference is just a single
       byte or so. */

    locate_diffs(in_buf, new_buf, MIN(len, target->len), &f_diff, &l_diff);

    if (f_diff < 0 || l_diff < 2 || f_diff == l_diff) {
      ck_free(new_buf);
      goto retry_splicing;
    }

    /* Split somewhere between the first and last differing byte. */

    split_at = f_diff + UR(l_diff - f_diff);

    /* Do the thing. */

    len = target->len;
    memcpy(new_buf, in_buf, split_at);
    in_buf = new_buf;

    ck_free(out_buf);
    out_buf = ck_alloc_nozero(len);
    memcpy(out_buf, in_buf, len);

    goto havoc_stage;

  }

#endif /* !IGNORE_FINDS */

  ret_val = 0;

abandon_entry:

  splicing_with = -1;

  /* Update pending_not_fuzzed count if we made it through the calibration
     cycle and have not seen this entry before. */

  if (!stop_soon && !queue_cur->cal_failed && !queue_cur->was_fuzzed) {
    queue_cur->was_fuzzed = 1;
    pending_not_fuzzed--;
    if (queue_cur->favored) pending_favored--;
  }

  if (in_buf != orig_in) ck_free(in_buf);
  ck_free(orig_in);
  ck_free(out_buf);
  ck_free(eff_map);

  return ret_val;

#undef FLIP_BIT

}


/* Grab interesting test cases from other fuzzers. */

static void sync_fuzzers(char** argv) {

  WIN32_FIND_DATA sd;
  HANDLE h;
  char *find_pattern;

  u32 sync_cnt = 0;

  find_pattern = alloc_printf("%s\\*", sync_dir);
  h = FindFirstFile(find_pattern, &sd);
  if(h == INVALID_HANDLE_VALUE) {
    PFATAL("Unable to open '%s'", sync_dir);
  }

  stage_max = stage_cur = 0;
  cur_depth = 0;

  /* Look at the entries created for every other fuzzer in the sync directory. */

  do {

    static u8 stage_tmp[128];

	WIN32_FIND_DATA qd;
    HANDLE h2;
    u8 *qd_path, *qd_synced_path, *qd_path_pattern;
    u32 min_accept = 0, next_min_accept;

    s32 id_fd;

    /* Skip dot files and our own output directory. */

	if (sd.cFileName[0] == '.' || !strcmp(sync_id, sd.cFileName)) continue;

    /* Skip anything that doesn't have a queue/ subdirectory. */

	qd_path = alloc_printf("%s\\%s\\queue", sync_dir, sd.cFileName);
	qd_path_pattern = alloc_printf("%s\\*", qd_path);

	h2 = FindFirstFile(qd_path_pattern, &qd);
	if(h2 == INVALID_HANDLE_VALUE) {
      ck_free(qd_path_pattern);
      ck_free(qd_path);
      continue;
	}

    /* Retrieve the ID of the last seen test case. */

	qd_synced_path = alloc_printf("%s\\.synced\\%s", out_dir, sd.cFileName);

    id_fd = open(qd_synced_path, O_RDWR | O_BINARY | O_CREAT, DEFAULT_PERMISSION);

    if (id_fd < 0) PFATAL("Unable to create '%s'", qd_synced_path);

    if (read(id_fd, &min_accept, sizeof(u32)) > 0) 
      lseek(id_fd, 0, SEEK_SET);

    next_min_accept = min_accept;

    /* Show stats */    

    sprintf(stage_tmp, "sync %u", ++sync_cnt);
    stage_name = stage_tmp;
    stage_cur  = 0;
    stage_max  = 0;

    /* For every file queued by this fuzzer, parse ID and see if we have looked at
       it before; exec a test case if not. */

    do {

      u8* path;
      s32 fd;
      struct stat st;

      if (qd.cFileName[0] == '.' ||
		  sscanf(qd.cFileName, CASE_PREFIX "%06u", &syncing_case) != 1 || 
          syncing_case < min_accept) continue;

      /* OK, sounds like a new one. Let's give it a try. */

      if (syncing_case >= next_min_accept)
        next_min_accept = syncing_case + 1;

      path = alloc_printf("%s\\%s", qd_path, qd.cFileName);

      fd = open(path, O_RDONLY | O_BINARY);

      /* Allow this to fail in case the other fuzzer is resuming or so... */

      if (fd < 0) {
         ck_free(path);
         continue;
      }
 
      if (fstat(fd, &st)) PFATAL("fstat() failed");

      /* Ignore zero-sized or oversized files. */

      if (st.st_size && st.st_size <= MAX_FILE) {

        u8  fault;
        u8* mem = malloc(st.st_size);
        read(fd, mem, st.st_size);
			
        /* See what happens. We rely on save_if_interesting() to catch major
           errors and save the test case. */

        write_to_testcase(mem, st.st_size);

        fault = run_target(argv, exec_tmout);

        if (stop_soon) return;

        syncing_party = sd.cFileName;
        queued_imported += save_if_interesting(argv, mem, st.st_size, fault);
        syncing_party = 0;

        free(mem);

        if (!(stage_cur++ % stats_update_freq)) show_stats();

      }

      ck_free(path);
      close(fd);

    } while(FindNextFile(h2, &qd));

    ck_write(id_fd, &next_min_accept, sizeof(u32), qd_synced_path);

    close(id_fd);
    FindClose(h2);
    ck_free(qd_path);
    ck_free(qd_synced_path);
	ck_free(qd_path_pattern);
    
  } while(FindNextFile(h, &sd));

  FindClose(h);
  ck_free(find_pattern);

}


/* Handle stop signal (Ctrl-C, etc). */

/*static void handle_stop_sig(int sig) {

  stop_soon = 1; 

  if (child_pid > 0) kill(child_pid, SIGKILL);
  if (forksrv_pid > 0) kill(forksrv_pid, SIGKILL);

}*/


/* Handle skip request (SIGUSR1). */

static void handle_skipreq(int sig) {

  skip_requested = 1;

}

/* Handle timeout (SIGALRM). */

/*static void handle_timeout(int sig) {

  if (child_pid > 0) {

    child_timed_out = 1; 
    kill(child_pid, SIGKILL);

  } else if (child_pid == -1 && forksrv_pid > 0) {

    child_timed_out = 1; 
    kill(forksrv_pid, SIGKILL);

  }

}*/


/* Do a PATH search and find target binary to see that it exists and
   isn't a shell script - a common and painful mistake. We also check for
   a valid ELF header and for evidence of AFL instrumentation. */

static void check_binary(u8* fname) {
	//not implemented on Windows
}


/* Trim and possibly create a banner for the run. */

static void fix_up_banner(u8* name) {

  if (!use_banner) {

    if (sync_id) {

      use_banner = sync_id;

    } else {

      u8* trim = strrchr(name, '\\');
      if (!trim) use_banner = name; else use_banner = trim + 1;

    }

  }

  if (strlen(use_banner) > 40) {

    u8* tmp = ck_alloc(44);
    sprintf(tmp, "%.40s...", use_banner);
    use_banner = tmp;

  }

}


/* Check if we're on TTY. */

static void check_if_tty(void) {
#ifndef USE_COLOR
  not_on_tty = 1;
#endif
}


/* Check terminal dimensions after resize. */

static void check_term_size(void) {
  //not implemented on Windows
}



/* Display usage hints. */

static void usage(u8* argv0) {

  SAYF("\n%s [ afl options ] -- [instrumentation options] -- "
	   "\\path\\to\\fuzzed_app [ ... ]\n\n"

       "Required parameters:\n\n"

       "  -i dir        - input directory with test cases\n"
       "  -o dir        - output directory for fuzzer findings\n"
       "  -t msec       - timeout for each run\n\n"

       "Instrumentation type:\n\n"
        "  -D dir       - directory with DynamoRIO binaries (drrun, drconfig)\n"
        "  -w winafl    - Path to winafl.dll\n"
        "  -P           - use Intel PT tracing mode\n"
        "  -y           - use TinyInst tracing mode\n"
        "  -Y           - enable the static instrumentation mode\n\n"

       "Execution control settings:\n\n"

       "  -f file       - location read by the fuzzed program (stdin)\n"
       "  -m limit      - memory limit for the target process\n"
       "  -p            - persist DynamoRIO cache across target process restarts\n"
       "  -c cpu        - the CPU to run the fuzzed program\n\n"
 
       "Fuzzing behavior settings:\n\n"

       "  -d            - quick & dirty mode (skips deterministic steps)\n"
       "  -n            - fuzz without instrumentation (dumb mode)\n"
       "  -x dir        - optional fuzzer dictionary (see README)\n\n"

       "Other stuff:\n\n"

       "  -I msec       - timeout for process initialization and first run\n"
       "  -T text       - text banner to show on the screen\n"
       "  -M \\ -S id   - distributed mode (see parallel_fuzzing.txt)\n"
       "  -C            - crash exploration mode (the peruvian rabbit thing)\n"
       "  -e            - expert mode to run WinAFL as a DynamoRIO tool\n"
       "  -l path       - a path to user-defined DLL for custom test cases processing\n"
       "  -V            - show version number and exit\n\n"

       "Attach:\n\n"
       "  -A module     - attach to the process that loaded the provided module\n\n"

       "For additional tips, please consult %s\\README.\n\n",

       argv0, doc_path);

  exit(1);

}


/* Prepare output directories and fds. */

static void setup_dirs_fds(void) {

  u8* tmp;
  s32 fd;

  ACTF("Setting up output directories...");

  if (sync_id && mkdir(sync_dir) && errno != EEXIST)
      PFATAL("Unable to create '%s'", sync_dir);

  if (mkdir(out_dir)) {

    if (errno != EEXIST) PFATAL("Unable to create '%s'", out_dir);

    maybe_delete_out_dir();

  } else {

    if (in_place_resume)
      FATAL("Resume attempted but old output directory not found");

    //out_dir_fd = open(out_dir, O_RDONLY | O_BINARY);

  }

  /* Queue directory for any starting & discovered paths. */

  tmp = alloc_printf("%s\\queue", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  /* Top-level directory for queue metadata used for session
     resume and related tasks. */

  tmp = alloc_printf("%s\\queue\\.state\\", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  /* Directory for flagging queue entries that went through
     deterministic fuzzing in the past. */

  tmp = alloc_printf("%s\\queue\\.state\\deterministic_done\\", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  /* Directory with the auto-selected dictionary entries. */

  tmp = alloc_printf("%s\\queue\\.state\\auto_extras\\", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  /* The set of paths currently deemed redundant. */

  tmp = alloc_printf("%s\\queue\\.state\\redundant_edges\\", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  /* The set of paths showing variable behavior. */

  tmp = alloc_printf("%s\\queue\\.state\\variable_behavior\\", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  /* Sync directory for keeping track of cooperating fuzzers. */

  if (sync_id) {

    tmp = alloc_printf("%s\\.synced\\", out_dir);
    
    if (mkdir(tmp) && (!in_place_resume || errno != EEXIST)) 
      PFATAL("Unable to create '%s'", tmp);

    ck_free(tmp);

  }

  /* All recorded crashes. */

  tmp = alloc_printf("%s\\crashes", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  /* All recorded hangs. */

  tmp = alloc_printf("%s\\hangs", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  /* Generally useful file descriptors. */

  //dev_null_fd = open("\\dev\\null", O_RDWR | O_BINARY);
  //if (dev_null_fd < 0) PFATAL("Unable to open \\dev\\null");

  //dev_urandom_fd = open("\\dev\\urandom", O_RDONLY | O_BINARY);
  //if (dev_urandom_fd < 0) PFATAL("Unable to open \\dev\\urandom");

  /* Gnuplot output file. */

  int oflag = O_WRONLY | O_BINARY | O_CREAT;
  tmp = alloc_printf("%s\\plot_data", out_dir);

  if(!in_place_resume) {

    fd = _open(tmp, oflag | O_EXCL, DEFAULT_PERMISSION);
    if (fd < 0) PFATAL("Unable to create '%s'", tmp);
    ck_free(tmp);

    plot_file = fdopen(fd, "w");
    if (!plot_file) PFATAL("fdopen() failed");

    fprintf(plot_file, "# relative_time, cycles_done, cur_path, paths_total, "
                     "pending_total, pending_favs, map_size, unique_crashes, "
                     "unique_hangs, max_depth, execs_per_sec\n");
                     /* ignore errors */
  } else {

    fd = _open(tmp, oflag, DEFAULT_PERMISSION);
    if (fd < 0) PFATAL("Unable to create '%s'", tmp);
    ck_free(tmp);

    plot_file = fdopen(fd, "w");
    if (!plot_file) PFATAL("fdopen() failed");

    fseek(plot_file, 0, SEEK_END);

  }

  fflush(plot_file);

  tmp = alloc_printf("%s\\drcache", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

  tmp = alloc_printf("%s\\ptmodules", out_dir);
  if (mkdir(tmp)) PFATAL("Unable to create '%s'", tmp);
  ck_free(tmp);

}


/* Setup the output file for fuzzed data, if not using -f. */

static void setup_stdio_file(void) {

  if (use_sample_shared_memory) {
    // if using shared memory we dont need to set any file.so we just return.
    return;
  }
  
  u8* fn = alloc_printf("%s\\.cur_input", out_dir);

  out_fd = open(fn, O_RDWR | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);

  if (out_fd < 0) PFATAL("Unable to create '%s'", fn);

  ck_free(fn);

}


/* Make sure that core dumps don't go to a program. */

static void check_crash_handling(void) {

#ifdef __APPLE__

  /* Yuck! There appears to be no simple C API to query for the state of 
     loaded daemons on MacOS X, and I'm a bit hesitant to do something
     more sophisticated, such as disabling crash reporting via Mach ports,
     until I get a box to test the code. So, for now, we check for crash
     reporting the awful way. */
  
  if (system("launchctl list 2>\\dev\\null | grep -q '\\.ReportCrash$'")) return;

  SAYF("\n" cLRD "[-] " cRST
       "Whoops, your system is configured to forward crash notifications to an\n"
       "    external crash reporting utility. This will cause issues due to the\n"
       "    extended delay between the fuzzed binary malfunctioning and this fact\n"
       "    being relayed to the fuzzer via the standard waitpid() API.\n\n"
       "    To avoid having crashes misinterpreted as timeouts, please run the\n"
       "    following commands:\n\n"

       "    SL=\\System\\Library; PL=com.apple.ReportCrash\n"
       "    launchctl unload -w ${SL}\\LaunchAgents\\${PL}.plist\n"
       "    sudo launchctl unload -w ${SL}\\LaunchDaemons\\${PL}.Root.plist\n");

  if (!getenv("AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES"))
    FATAL("Crash reporter detected");

#else

  /* This is Linux specific, but I don't think there's anything equivalent on
     *BSD, so we can just let it slide for now. */

  s32 fd = open("\\proc\\sys\\kernel\\core_pattern", O_RDONLY | O_BINARY);
  u8  fchar;

  if (fd < 0) return;

  ACTF("Checking core_pattern...");

  if (read(fd, &fchar, 1) == 1 && fchar == '|') {

    SAYF("\n" cLRD "[-] " cRST
         "Hmm, your system is configured to send core dump notifications to an\n"
         "    external utility. This will cause issues due to an extended delay\n"
         "    between the fuzzed binary malfunctioning and this information being\n"
         "    eventually relayed to the fuzzer via the standard waitpid() API.\n\n"

         "    To avoid having crashes misinterpreted as timeouts, please log in as root\n"
         "    and temporarily modify \\proc\\sys\\kernel\\core_pattern, like so:\n\n"

         "    echo core >\\proc\\sys\\kernel\\core_pattern\n");

    if (!getenv("AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES"))
      FATAL("Pipe at the beginning of 'core_pattern'");

  }
 
  close(fd);

#endif /* ^__APPLE__ */

}


/* Check CPU governor. */

static void check_cpu_governor(void) {

  FILE* f;
  u8 tmp[128];
  u64 min = 0, max = 0;

  if (getenv("AFL_SKIP_CPUFREQ")) return;

  f = fopen("\\sys\\devices\\system\\cpu\\cpu0\\cpufreq\\scaling_governor", "r");
  if (!f) return;

  ACTF("Checking CPU scaling governor...");

  if (!fgets(tmp, 128, f)) PFATAL("fgets() failed");

  fclose(f);

  if (!strncmp(tmp, "perf", 4)) return;

  f = fopen("\\sys\\devices\\system\\cpu\\cpu0\\cpufreq\\scaling_min_freq", "r");

  if (f) {
    if (fscanf(f, "%llu", &min) != 1) min = 0;
    fclose(f);
  }

  f = fopen("\\sys\\devices\\system\\cpu\\cpu0\\cpufreq\\scaling_max_freq", "r");

  if (f) {
    if (fscanf(f, "%llu", &max) != 1) max = 0;
    fclose(f);
  }

  if (min == max) return;

  SAYF("\n" cLRD "[-] " cRST
       "Whoops, your system uses on-demand CPU frequency scaling, adjusted\n"
       "    between %llu and %llu MHz. Unfortunately, the scaling algorithm in the\n"
       "    kernel is imperfect and can miss the short-lived processes spawned by\n"
       "    afl-fuzz. To keep things moving, run these commands as root:\n\n"

       "    cd \\sys\\devices\\system\\cpu\n"
       "    echo performance | tee cpu*\\cpufreq\\scaling_governor\n\n"

       "    You can later go back to the original state by replacing 'performance' with\n"
       "    'ondemand'. If you don't want to change the settings, set AFL_SKIP_CPUFREQ\n"
       "    to make afl-fuzz skip this check - but expect some performance drop.\n",
       min / 1024, max / 1024);

  FATAL("Suboptimal CPU scaling governor");

}


/* Count the number of logical CPU cores. */

static void get_core_count(void) {

  u32 cur_utilization = 0;
  SYSTEM_INFO sys_info = { 0 };
  GetSystemInfo(&sys_info);
  cpu_core_count = sys_info.dwNumberOfProcessors;

  if (cpu_core_count) {
	PdhOpenQuery(NULL, (DWORD_PTR)NULL, &cpuQuery);
	PdhAddCounter(cpuQuery, TEXT("\\Processor(_Total)\\% Processor Time"), (DWORD_PTR)NULL, &cpuTotal);
	PdhCollectQueryData(cpuQuery);
	Sleep(1000);

	cur_utilization = (u32)get_cur_utilization();

	OKF("You have %u CPU cores with average utilization of %.1u%%.",
	  cpu_core_count, cur_utilization);

    if (cpu_core_count > 1) {

      if (cur_utilization >= 90) {

        WARNF("System under apparent load, performance may be spotty.");

      } else {

        OKF("Try parallel jobs - see %s\\parallel_fuzzing.txt.", doc_path);
  
      }

    }

  } else WARNF("Unable to figure out the number of CPU cores.");

}


/* Validate and fix up out_dir and sync_dir when using -S. */

static void fix_up_sync(void) {

  u8* x = sync_id;

  if (dumb_mode)
    FATAL("-S \\ -M and -n are mutually exclusive");

  if (skip_deterministic) {

    if (force_deterministic)
      FATAL("use -S instead of -M -d");
    else
      FATAL("-S already implies -d");

  }

  while (*x) {

    if (!isalnum(*x) && *x != '_' && *x != '-')
      FATAL("Non-alphanumeric fuzzer ID specified via -S or -M");

    x++;

  }

  if (strlen(sync_id) > 32) FATAL("Fuzzer ID too long");

  x = alloc_printf("%s\\%s", out_dir, sync_id);

  sync_dir = out_dir;
  out_dir  = x;

  if (!force_deterministic) {
    skip_deterministic = 1;
    use_splicing = 1;
  }

}


/* Handle screen resize (SIGWINCH). */

static void handle_resize(int sig) {
  clear_screen = 1;
}


/* Check ASAN options. */

static void check_asan_opts(void) {
  u8* x = getenv("ASAN_OPTIONS");

  if (x && !strstr(x, "abort_on_error=1"))
    FATAL("Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!");

  x = getenv("MSAN_OPTIONS");

  if (x && !strstr(x, "exit_code=" STRINGIFY(MSAN_ERROR)))
    FATAL("Custom MSAN_OPTIONS set without exit_code="
          STRINGIFY(MSAN_ERROR) " - please fix!");

} 


/* Detect @@ in args. */

static void detect_file_args(char** argv) {

  u32 i = 0;
  u8* cwd = getcwd(NULL, 0);

  if (!cwd) PFATAL("getcwd() failed");

  while (argv[i]) {

    u8* aa_loc = strstr(argv[i], "@@");

    if (aa_loc) {

      u8 *aa_subst, *n_arg;

      /* If we don't have a file name chosen yet, use a safe default. */

      if (!out_file)
		  if (!use_sample_shared_memory) {
			  out_file = alloc_printf("%s\\.cur_input", out_dir);
		  } else {
			    //this sets output file as shared memory name which is used by harness program.
			    out_file = sample_shm_str;
		  }
	  
      /* Be sure that we're always using fully-qualified paths. */

      //if (out_file[0] == '\\') aa_subst = out_file;
      //else aa_subst = alloc_printf("%s\\%s", cwd, out_file);
	  aa_subst = out_file;

      /* Construct a replacement argv value. */

      *aa_loc = 0;
      n_arg = alloc_printf("%s%s%s", argv[i], aa_subst, aa_loc + 2);
      argv[i] = n_arg;
      *aa_loc = '@';

      //if (out_file[0] != '\\') ck_free(aa_subst);

    }

    i++;

  }

  free(cwd); /* not tracked */

}


/* Set up signal handlers. More complicated that needs to be, because libc on
   Solaris doesn't resume interrupted reads(), sets SA_RESETHAND when you call
   siginterrupt(), and does other stupid things. */

static void setup_signal_handlers(void) {
  //not implemented on Windows
}


/* Rewrite argv for QEMU. */

static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
  //not implemented on Windows
  return NULL;
}


/* Make a copy of the current command line. */

static void save_cmdline(u32 argc, char** argv) {

  u32 len = 1, i;
  u8* buf;

  for (i = 0; i < argc; i++)
    len += strlen(argv[i]) + 1;
  
  buf = orig_cmdline = ck_alloc(len);

  for (i = 0; i < argc; i++) {

    u32 l = strlen(argv[i]);

    memcpy(buf, argv[i], l);
    buf += l;

    if (i != argc - 1) *(buf++) = ' ';

  }

  *buf = 0;

}

static int optind;
static char *optarg;

static void extract_client_params(u32 argc, char** argv) {
  u32 len = 1, i;
  u32 nclientargs = 0;
  u8* buf;
  u32 opt_start, opt_end;

  if(!argv[optind] || optind >= argc) usage(argv[0]);
  if(strcmp(argv[optind],"--")) usage(argv[0]);

  optind++;
  opt_start = optind;

  for (i = optind; i < argc; i++) {
    if(strcmp(argv[i],"--") == 0) break;
    nclientargs++;
    len += strlen(argv[i]) + 1;
  }

  if(i == argc) usage(argv[0]);
  opt_end = i;

  buf = client_params = ck_alloc(len);

  for (i = opt_start; i < opt_end; i++) {

    u32 l = strlen(argv[i]);

    memcpy(buf, argv[i], l);
    buf += l;

    *(buf++) = ' ';
  }

  if(buf != client_params) {
    buf--;
  }

  *buf = 0;

  optind = opt_end;

  //extract the number of fuzz iterations from client params
  fuzz_iterations_max = 1000;
  for (i = opt_start; i < opt_end; i++) {
    if((strcmp(argv[i], "-fuzz_iterations") == 0) && ((i + 1) < opt_end)) {
      fuzz_iterations_max = atoi(argv[i+1]);
    }
  }

}


//extracts client and target command line params
/*static void parse_cmd_line(char *argv0) {
	char *cmd;
	char *p1, *p2, *p3;
	int client_params_sz;

	cmd = GetCommandLine();
	
	p1 = strstr(cmd, " -- ");
	if(!p1) usage(argv0);
	p1 += 4;

	p2 = strstr(cmd, " -- ");
	if(!p2) usage(argv0);
	p3 = p2 + 4;

	client_params_sz = p2 - p1 + 1;
	client_params = (char *)malloc(client_params_sz);
	memcpy(client_params, p1, client_params_sz);
	client_params[client_params_sz] = 0;
}*/


int getopt(int argc, char **argv, char *optstring) {
  char *c;

  optarg = NULL;

  while(1) {
    if(optind == argc) return -1;
    if(strcmp(argv[optind], "--") == 0) return -1;
    if(argv[optind][0] != '-') {
      optind++;
      continue;
    }
    if(!argv[optind][1]) {
      optind++;
      continue;
    }

    c = strchr(optstring, argv[optind][1]);
    if(!c) return -1;
    optind++;
    if(c[1] == ':') {
      if(optind == argc) return -1;
      optarg = argv[optind];
      optind++;
    }

    return (int)(c[0]);
  }
}

/* This routine is designed to load user-defined library for custom test cases processing */
void load_custom_library(const char *libname)
{
  int result = 0;
  SAYF("Loading custom winAFL server library\n");
  HMODULE hLib = LoadLibraryEx(libname, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
  if (hLib == NULL)
    FATAL("Unable to load custom server library, GetLastError = 0x%x", GetLastError());

  /* init the custom server */
  // Get pointer to user-defined server initialization function using GetProcAddress:
  dll_init_ptr = (dll_init)GetProcAddress(hLib, "dll_init");
  SAYF("dll_init %s defined.\n", dll_init_ptr ? "is" : "isn't");

  // Get pointer to user-defined test cases sending function using GetProcAddress:
  dll_run_ptr = (dll_run)GetProcAddress(hLib, "dll_run");
  SAYF("dll_run_ptr %s defined.\n", dll_run_ptr ? "is" : "isn't");

  // Get pointer to user-defined run_target function using GetProcAddress:
  dll_run_target_ptr = (dll_run_target)GetProcAddress(hLib, "dll_run_target");
  SAYF("dll_run_target %s defined.\n", dll_run_target_ptr ? "is" : "isn't");

  // Get pointer to user-defined write_to_testcase function using GetProcAddress:
  dll_write_to_testcase_ptr = (dll_write_to_testcase)GetProcAddress(hLib, "dll_write_to_testcase");
  SAYF("dll_write_to_testcase %s defined.\n", dll_write_to_testcase_ptr ? "is" : "isn't");

  // Get pointer to user-defined mutate_testcase function using GetProcAddress:
  dll_mutate_testcase_ptr = (dll_mutate_testcase)GetProcAddress(hLib, "dll_mutate_testcase");
  SAYF("dll_mutate_testcase %s defined.\n", dll_mutate_testcase_ptr ? "is" : "isn't");

  // Get pointer to user-defined trim_testcase function using GetProcAddress:
  dll_trim_testcase_ptr = (dll_trim_testcase)GetProcAddress(hLib, "dll_trim_testcase");
  SAYF("dll_trim_testcase %s defined.\n", dll_mutate_testcase_ptr ? "is" : "isn't");

  // Get pointer to user-defined dll_mutate_testcase_with_energy_ptr function using GetProcAddress:
  dll_mutate_testcase_with_energy_ptr = (dll_mutate_testcase_with_energy)GetProcAddress(hLib, "dll_mutate_testcase_with_energy");
  SAYF("dll_mutate_testcase_with_energy %s defined.\n", dll_mutate_testcase_with_energy_ptr ? "is" : "isn't");

  SAYF("Sucessfully loaded and initalized\n");
}

/* Main entry point */
int main(int argc, char** argv) {

  s32 opt;
  u64 prev_queued = 0;
  u32 sync_interval_cnt = 0, seek_to;
  u8  *extras_dir = 0;
  u8  mem_limit_given = 0;

  char** use_argv;

  setup_watchdog_timer();

#ifdef USE_COLOR
  enable_ansi_console();
#endif

  SAYF("WinAFL " WINAFL_VERSION " by <ifratric@google.com>\n");
  SAYF("Based on AFL " cBRI VERSION cRST " by <lcamtuf@google.com>\n");

  doc_path = "afl_docs";

  optind = 1;

  in_dir = NULL;
  out_dir = NULL;
  dynamorio_dir = NULL;
  client_params = NULL;
  winafl_dll_path = NULL;

  while ((opt = getopt(argc, argv, "+i:o:f:m:t:I:T:sdyYnCB:S:M:x:QD:b:l:pPc:w:A:eV")) > 0)

    switch (opt) {
      case 's':
        
        if (use_sample_shared_memory) FATAL("Multiple -s options not supported");
        use_sample_shared_memory = TRUE;
        ACTF("using shared memory mode...");
        break;

      case 'i':

        if (in_dir) FATAL("Multiple -i options not supported");
        in_dir = optarg;

        if (!strcmp(in_dir, "-")) in_place_resume = 1;

        break;

      case 'o': /* output dir */

        if (out_dir) FATAL("Multiple -o options not supported");
        out_dir = optarg;
        break;

      case 'w': /* winafl.dll path */

        if (winafl_dll_path) FATAL("Multiple -w options not supported");
        winafl_dll_path = optarg;
        break;

      case 'D': /* dynamorio dir */

        if (dynamorio_dir) FATAL("Multiple -D options not supported");
        dynamorio_dir = optarg;
        break;

      case 'M': { /* master sync ID */

          u8* c;

          if (sync_id) FATAL("Multiple -S or -M options not supported");
          sync_id = optarg;

          if ((c = strchr(sync_id, ':'))) {

            *c = 0;

            if (sscanf(c + 1, "%u/%u", &master_id, &master_max) != 2 ||
                !master_id || !master_max || master_id > master_max ||
                master_max > 1000000) FATAL("Bogus master ID passed to -M");

          }

          force_deterministic = 1;
          fuzzer_id = sync_id;

        }
        break;

      case 'S':

        if (sync_id) FATAL("Multiple -S or -M options not supported");
        sync_id = ck_strdup(optarg);
        break;

      case 'f': /* target file */

        if (out_file) FATAL("Multiple -f options not supported");
        out_file = optarg;
        break;

      case 'x':

        if (extras_dir) FATAL("Multiple -x options not supported");
        extras_dir = optarg;
        break;

      case 't': {

          u8 suffix = 0;

          if (timeout_given) FATAL("Multiple -t options not supported");

          if (sscanf(optarg, "%u%c", &exec_tmout, &suffix) < 1 ||
              optarg[0] == '-') FATAL("Bad syntax used for -t");

          if (exec_tmout < 5) FATAL("Dangerously low value of -t");

          if (suffix == '+') timeout_given = 2; else timeout_given = 1;

          break;

      }

      case 'I': {

        if (sscanf(optarg, "%u", &init_tmout) < 1) FATAL("Bad syntax used for -I");

        if (init_tmout < 5) FATAL("Dangerously low value of -I");

        break;

      }

      case 'm': {

          u8 suffix = 'M';

          if (mem_limit_given) FATAL("Multiple -m options not supported");
          mem_limit_given = 1;

          if (!strcmp(optarg, "none")) {

            mem_limit = 0;
            break;

          }

          if (sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1 ||
              optarg[0] == '-') FATAL("Bad syntax used for -m");

          switch (suffix) {

            case 'T': mem_limit *= 1024 * 1024; break;
            case 'G': mem_limit *= 1024; break;
            case 'k': mem_limit /= 1024; break;
            case 'M': break;

            default:  FATAL("Unsupported suffix or bad syntax for -m");

          }

          if (mem_limit < 5) FATAL("Dangerously low value of -m");

          break;
      }

      case 'd':

        if (skip_deterministic) FATAL("Multiple -d options not supported");
        skip_deterministic = 1;
        use_splicing = 1;
        break;

      case 'B':

        /* This is a secret undocumented option! It is useful if you find
           an interesting test case during a normal fuzzing process, and want
           to mutate it without rediscovering any of the test cases already
           found during an earlier run.

           To use this mode, you need to point -B to the fuzz_bitmap produced
           by an earlier run for the exact same binary... and that's it.

           I only used this once or twice to get variants of a particular
           file, so I'm not making this an official setting. */

        if (in_bitmap) FATAL("Multiple -B options not supported");

        in_bitmap = optarg;
        read_bitmap(in_bitmap);
        break;

      case 'C':

        if (crash_mode) FATAL("Multiple -C options not supported");
        crash_mode = FAULT_CRASH;
        break;

      case 'n':

        if (dumb_mode) FATAL("Multiple -n options not supported");
        if (getenv("AFL_DUMB_FORKSRV")) dumb_mode = 2; else dumb_mode = 1;

        break;

      case 'T':

        if (use_banner) FATAL("Multiple -T options not supported");
        use_banner = optarg;
        break;

      case 'Q':

        if (qemu_mode) FATAL("Multiple -Q options not supported");
        qemu_mode = 1;

        if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;

        break;

      case 'Y':

        if (dynamorio_dir) FATAL("Dynamic-instrumentation via DRIO is uncompatible with static-instrumentation");
        drioless = 1;

        break;

      case 'l':
        custom_dll_defined = 1;
        load_custom_library(optarg);

        break;

	  case 'p':
		  persist_dr_cache = 1;

		  break;

    case 'P':
#ifdef INTELPT
      use_intelpt = 1;
#else
      FATAL("afl-fuzz was not compiled with Intel PT support");
#endif

      break;

    case 'y':
#ifdef TINYINST
      use_tinyinst = 1;
#else
      FATAL("afl-fuzz was not compiled with TinyInst support");
#endif

      break;

    case 'c':

        if (getenv("AFL_NO_AFFINITY")) FATAL("-c and AFL_NO_AFFINITY are mutually exclusive.");

        if (cpu_aff) {
          FATAL("Multiple -c options not supported");
        } else {
          int cpunum = 0;

          if (sscanf(optarg, "%d", &cpunum) < 1 ||
              cpunum < 0) FATAL("Bad syntax used for -c");

          if (cpunum >= 64)
            FATAL("Uh-oh, winafl doesn't support more than 64 cores at the moment\n");

          cpu_aff = 1ULL << cpunum;
        }

        break;

      case 'A':
        // attaching to a running process with the specified module
        drattach = 1;
        drattach_identifier = optarg;
        break;

      case 'e':
        // use WinAFL as a tool to run alongside DynamoRIO
        if (use_intelpt || use_tinyinst || drioless) FATAL("Expert mode is only available for DynamoRIO");
        if (expert_mode) FATAL("Multiple -e options not supported");
        expert_mode = 1;
        break;

     case 'V': /* Show version number */

        /* Version number has been printed already, just quit. */
        exit(0);

      default:

        usage(argv[0]);

    }

  if (!in_dir || !out_dir || !timeout_given || (!drioless && !dynamorio_dir && !use_intelpt && !use_tinyinst)) usage(argv[0]);

  if (!winafl_dll_path) {
    winafl_dll_path = "winafl.dll";
  } else if (expert_mode) {
    FATAL("-w and -e are mutually exclusive");
  }

  setup_signal_handlers();
  check_asan_opts();

  if (sync_id) fix_up_sync();

  if (use_intelpt) {
#ifdef INTELPT
	  char *modules_dir = alloc_printf("%s\\ptmodules", out_dir);
	  int pt_options = pt_init(argc - optind, argv + optind, modules_dir);
	  ck_free(modules_dir);
	  if (!pt_options) usage(argv[0]);
	  optind += pt_options;
#endif
  } else if (use_tinyinst) {
#ifdef TINYINST
    int tinyinst_options = tinyinst_init(argc - optind, argv + optind);
    if (!tinyinst_options) usage(argv[0]);
    optind += tinyinst_options;
#endif
  } else {
	  extract_client_params(argc, argv);
  }
  optind++;
  
  if (!strcmp(in_dir, out_dir))
    FATAL("Input and output directories can't be the same");

  if (dumb_mode) {

    if (crash_mode) FATAL("-C and -n are mutually exclusive");
    if (qemu_mode)  FATAL("-Q and -n are mutually exclusive");

  }

  if (getenv("AFL_NO_FORKSRV"))    no_forkserver    = 1;
  if (getenv("AFL_NO_CPU_RED"))    no_cpu_meter_red = 1;
  if (getenv("AFL_NO_ARITH"))      no_arith = 1;
  if (getenv("AFL_SHUFFLE_QUEUE")) shuffle_queue    = 1;
  if (getenv("AFL_NO_SINKHOLE"))   sinkhole_stds    = 0;
  if (getenv("AFL_AUTORESUME"))    autoresume       = 1;

  if (dumb_mode == 2 && no_forkserver)
    FATAL("AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive");

  save_cmdline(argc, argv);

  fix_up_banner(argv[optind]);

  check_if_tty();

  get_core_count();

  bind_to_free_cpu();

  check_crash_handling();
  check_cpu_governor();

  setup_post();

  if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE);
  memset(virgin_tmout, 255, MAP_SIZE);
  memset(virgin_crash, 255, MAP_SIZE);

  if (use_intelpt) {
	  trace_bits = VirtualAlloc(0, MAP_SIZE, MEM_COMMIT, PAGE_READWRITE);
  } else {
	  setup_shm();
  }

  if (use_tinyinst) {
#ifdef TINYINST
    tinyinst_set_fuzzer_id(fuzzer_id);
#endif
  }
  
  if (use_sample_shared_memory) {
    setup_sample_shm();
  }
  
  init_count_class16();
  child_handle = NULL;
  pipe_handle = NULL;

  devnul_handle = INVALID_HANDLE_VALUE;

  setup_dirs_fds();
  read_testcases();
  load_auto();

  pivot_inputs();

  if (extras_dir) load_extras(extras_dir);

  if (!timeout_given) find_timeout();

  detect_file_args(argv + optind + 1);

  if (!out_file) setup_stdio_file();

  check_binary(argv[optind]);

  start_time = get_cur_time();

  if (qemu_mode)
    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);
  else
    use_argv = argv + optind;

  perform_dry_run(use_argv);

  cull_queue();

  show_init_stats();

  seek_to = find_start_position();

  start_time = get_cur_time();
  if (in_place_resume || autoresume) load_stats_file();
  write_stats_file(0, 0, 0);
  save_auto();

  if (stop_soon) goto stop_fuzzing;

  /* Woop woop woop */

  while (1) {

    u8 skipped_fuzz;

    cull_queue();

    if (!queue_cur) {

      queue_cycle++;
      current_entry     = 0;
      cur_skipped_paths = 0;
      queue_cur         = queue;

      while (seek_to) {
        current_entry++;
        seek_to--;
        queue_cur = queue_cur->next;
      }

      show_stats();

      if (not_on_tty) {
        ACTF("Entering queue cycle %llu.", queue_cycle);
        fflush(stdout);
      }

      /* If we had a full queue cycle with no new finds, try
         recombination strategies next. */

      if (queued_paths == prev_queued) {

        if (use_splicing) cycles_wo_finds++; else use_splicing = 1;

      } else cycles_wo_finds = 0;

      prev_queued = queued_paths;

      if (sync_id && queue_cycle == 1 && getenv("AFL_IMPORT_FIRST"))
        sync_fuzzers(use_argv);

    }

    skipped_fuzz = fuzz_one(use_argv);

    if (!stop_soon && sync_id && !skipped_fuzz) {
      
      if (!(sync_interval_cnt++ % SYNC_INTERVAL))
        sync_fuzzers(use_argv);

    }

    if (stop_soon) break;

    queue_cur = queue_cur->next;
    current_entry++;

  }

  if (queue_cur) show_stats();

  write_bitmap();
  write_stats_file(0, 0, 0);
  save_auto();

stop_fuzzing:

  SAYF(CURSOR_SHOW cLRD "\n\n+++ Testing %s +++\n" cRST,
       stop_soon == 2 ? "ended via AFL_EXIT_WHEN_DONE" : "aborted by user");

  /* Running for more than 30 minutes but still doing first cycle? */

  if (queue_cycle == 1 && get_cur_time() - start_time > 30 * 60 * 1000) {

    SAYF("\n" cYEL "[!] " cRST
           "Stopped during the first cycle, results may be incomplete.\n"
           "    (For info on resuming, see %s\\README.)\n", doc_path);

  }

  if(devnul_handle != INVALID_HANDLE_VALUE) {
    CloseHandle(devnul_handle);
  }

  fclose(plot_file);
  destroy_queue();
  destroy_extras();
  ck_free(target_path);

  if(fuzzer_id != NULL && fuzzer_id != sync_id)
    ck_free(fuzzer_id);

  alloc_report();

  OKF("We're done here. Have a nice day!\n");

  exit(0);

}

```

`afl-showmap.c`:

```c
/*
   american fuzzy lop - map display utility
   ----------------------------------------

   Written and maintained by Michal Zalewski <lcamtuf@google.com>

   Windows fork written by Axel "0vercl0k" Souchet <0vercl0k@tuxfamily.org>

   Copyright 2017 Google Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   A very simple tool that runs the targeted binary and displays
   the contents of the trace bitmap in a human-readable form. Useful in
   scripts to eliminate redundant inputs and perform other checks.

   Exit code is 2 if the target program crashes; 1 if it times out or
   there is a problem executing it; or 0 if execution is successful.

*/
#define _CRT_SECURE_NO_WARNINGS
#define _CRT_RAND_S  
#define VERSION             "2.36b"

#define AFL_MAIN

#include <windows.h>
#include <stdarg.h>
#include <io.h>
#include <direct.h>

#include "config.h"
#include "types.h"
#include "debug.h"
#include "alloc-inl.h"
#include "hash.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>

#include <sys/stat.h>
#include <sys/types.h>

#ifdef TINYINST
int tinyinst_init(int argc, char** argv);
void tinyinst_set_fuzzer_id(char* fuzzer_id);
int tinyinst_run(char** argv, uint32_t timeout);
void tinyinst_killtarget();
#endif


static s32 child_pid;                 /* PID of the tested program         */

static HANDLE child_handle,
              child_thread_handle;
static char *dynamorio_dir;
static char *client_params;

static CRITICAL_SECTION critical_section;
static u64 watchdog_timeout_time;
static u8 watchdog_enabled;
static u8 *target_cmd;                /* command line of target           */

static HANDLE shm_handle;             /* Handle of the SHM region         */
static HANDLE pipe_handle;            /* Handle of the name pipe          */
static u64    name_seed;              /* Random integer to have a unique shm/pipe name */
static HANDLE devnul_handle;          /* Handle of the nul device         */
static char   *fuzzer_id = NULL;      /* The fuzzer ID or a randomized 
                                         seed allowing multiple instances */

static u8* trace_bits;                /* SHM with instrumentation bitmap   */

static u8 *out_file,                  /* Trace output file                 */
          *doc_path,                  /* Path to docs                      */
          *target_path,               /* Path to target binary             */
          *at_file;                   /* Substitution string for @@        */

static u32 exec_tmout;                /* Exec timeout (ms)                 */

static u64 mem_limit = MEM_LIMIT;     /* Memory limit (MB)                 */

// static s32 shm_id;                    /* ID of the SHM region              */

static u8  quiet_mode,                /* Hide non-essential messages?      */
           edges_only,                /* Ignore hit counts?                */
           cmin_mode,                 /* Generate output in afl-cmin mode? */
           binary_mode,               /* Write output as a binary map      */
           drioless = 0;              /* Running without DRIO?             */
          use_tinyinst = 0;          /* Using TinyInst instrumentation   */

static volatile u8
           stop_soon,                 /* Ctrl-C pressed?                   */
           child_timed_out,           /* Child timed out?                  */
           child_crashed;             /* Child crashed?                    */

/* Classify tuple counts. Instead of mapping to individual bits, as in
   afl-fuzz.c, we map to more user-friendly numbers between 1 and 8. */

#define AREP4(_sym)   (_sym), (_sym), (_sym), (_sym)
#define AREP8(_sym)   AREP4(_sym), AREP4(_sym)
#define AREP16(_sym)  AREP8(_sym), AREP8(_sym)
#define AREP32(_sym)  AREP16(_sym), AREP16(_sym)
#define AREP64(_sym)  AREP32(_sym), AREP32(_sym)
#define AREP128(_sym) AREP64(_sym), AREP64(_sym)

static const u8 count_class_human[256] = {

  /* 0 - 3:       4 */ 0, 1, 2, 3,
  /* 4 - 7:      +4 */ AREP4(4),
  /* 8 - 15:     +8 */ AREP8(5),
  /* 16 - 31:   +16 */ AREP16(6),
  /* 32 - 127:  +96 */ AREP64(7), AREP32(7),
  /* 128+:     +128 */ AREP128(8)

};

static const u8 count_class_binary[256] = {

  /* 0 - 3:       4 */ 0, 1, 2, 4,
  /* 4 - 7:      +4 */ AREP4(8),
  /* 8 - 15:     +8 */ AREP8(16),
  /* 16 - 31:   +16 */ AREP16(32),
  /* 32 - 127:  +96 */ AREP64(64), AREP32(64),
  /* 128+:     +128 */ AREP128(128)

};

static void classify_counts(u8* mem, const u8* map) {

  u32 i = MAP_SIZE;

  if (edges_only) {

    while (i--) {
      if (*mem) *mem = 1;
      mem++;
    }

  } else {

    while (i--) {
     *mem = map[*mem];
      mem++;
    }

  }

}


/* Get unix time in milliseconds */

static u64 get_cur_time(void) {

  u64 ret;
  FILETIME filetime;
  GetSystemTimeAsFileTime(&filetime);

  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;

  return ret / 10000;

}


/* Get unix time in microseconds */

static u64 get_cur_time_us(void) {

  u64 ret;
  FILETIME filetime;
  GetSystemTimeAsFileTime(&filetime);

  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;

  return ret / 10;

}


char *alloc_printf(const char *_str, ...) {

  va_list argptr;
  char* _tmp;
  s32 _len;

  va_start(argptr, _str);
  _len = vsnprintf(NULL, 0, _str, argptr);
  if (_len < 0) FATAL("Whoa, snprintf() fails?!");
  _tmp = ck_alloc(_len + 1);
  vsnprintf(_tmp, (size_t)_len + 1, _str, argptr);
  va_end(argptr);
  return _tmp;

}


/* Get rid of shared memory (atexit handler). */

static void remove_shm(void) {

  UnmapViewOfFile(trace_bits);
  CloseHandle(shm_handle);

}


/* Configure shared memory. */

static void setup_shm(void) {

  char* shm_str = NULL;
  unsigned int seeds[2];
  u64 name_seed;
  u8 attempts = 0;

  while(attempts < 5) {
    if(fuzzer_id == NULL) {
      // If it is null, it means we have to generate a random seed to name the instance
      rand_s(&seeds[0]);
      rand_s(&seeds[1]);
      name_seed = ((u64)seeds[0] << 32) | seeds[1];
      fuzzer_id = (char *)alloc_printf("%I64x", name_seed);
    }

    shm_str = (char *)alloc_printf("afl_shm_%s", fuzzer_id);

    shm_handle = CreateFileMapping(
                   INVALID_HANDLE_VALUE,    // use paging file
                   NULL,                    // default security
                   PAGE_READWRITE,          // read/write access
                   0,                       // maximum object size (high-order DWORD)
                   MAP_SIZE,                // maximum object size (low-order DWORD)
                   (char *)shm_str);        // name of mapping object

    if(shm_handle == NULL) {
      if(GetLastError() == ERROR_ALREADY_EXISTS) {
        // We need another attempt to find a unique section name
        attempts++;
        ck_free(shm_str);
        ck_free(fuzzer_id);
        fuzzer_id = NULL;
        continue;
      }
      else {
        PFATAL("CreateFileMapping failed");
      }
    }

    // We found a section name that works!
    break;
  }

  if(attempts == 5) {
    FATAL("Could not find a section name.\n");
  }

  atexit(remove_shm);

  ck_free(shm_str);

  trace_bits = (u8 *)MapViewOfFile(
    shm_handle,          // handle to map object
    FILE_MAP_ALL_ACCESS, // read/write permission
    0,
    0,
    MAP_SIZE
  );

  if (!trace_bits) PFATAL("MapViewOfFile() failed");

}


/* Write results. */

static u32 write_results(void) {

  s32 fd;
  u32 i, ret = 0;

  u8  cco = !!getenv("AFL_CMIN_CRASHES_ONLY"),
      caa = !!getenv("AFL_CMIN_ALLOW_ANY");

  if (!strncmp(out_file, "/dev/", 5)) {

    fd = _open(out_file, O_WRONLY, DEFAULT_PERMISSION);
    if (fd < 0) PFATAL("Unable to open '%s'", out_file);

  } else if (!strcmp(out_file, "-")) {

    fd = _dup(1);
    if (fd < 0) PFATAL("Unable to open stdout");

  } else {

    fd = _open(out_file, O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);
    if (fd < 0) PFATAL("Unable to create '%s'", out_file);

  }

  if (binary_mode) {

    for (i = 0; i < MAP_SIZE; i++)
      if (trace_bits[i]) ret++;

    ck_write(fd, trace_bits, MAP_SIZE, out_file);
    close(fd);

  } else {


    FILE* f = fdopen(fd, "w");

    if (!f) PFATAL("fdopen() failed");

    for (i = 0; i < MAP_SIZE; i++) {

      if (!trace_bits[i]) continue;
      ret++;

      if (cmin_mode) {

        if (child_timed_out) break;
        if (!caa && child_crashed != cco) break;

        fprintf(f, "%u%u\n", trace_bits[i], i);

      } else fprintf(f, "%06u:%u\n", i, trace_bits[i]);

    }
  
    fclose(f);

  }

  return ret;

}


//quoting on Windows is weird
size_t ArgvQuote(char *in, char *out) {
  int needs_quoting = 0;
  size_t size = 0;
  char *p = in;
  size_t i;

  //check if quoting is necessary
  if(strchr(in, ' ')) needs_quoting = 1;
  if(strchr(in, '\"')) needs_quoting = 1;
  if(strchr(in, '\t')) needs_quoting = 1;
  if(strchr(in, '\n')) needs_quoting = 1;
  if(strchr(in, '\v')) needs_quoting = 1;
  if(!needs_quoting) {
    size = strlen(in);
    if(out) memcpy(out, in, size);
    return size;
  }

  if(out) out[size] = '\"';
  size++;

  while(*p) {
    size_t num_backslashes = 0;
    while((*p) && (*p == '\\')) {
      p++;
      num_backslashes++;
    }

    if(*p == 0) {
      for(i = 0; i < (num_backslashes*2); i++) {
        if(out) out[size] = '\\';
        size++;
      }
      break;
    } else if(*p == '\"') {
      for(i = 0; i < (num_backslashes*2 + 1); i++) {
        if(out) out[size] = '\\';
        size++;
      }
      if(out) out[size] = *p;
      size++;
    } else {
      for(i = 0; i < num_backslashes; i++) {
        if(out) out[size] = '\\';
        size++;
      }
      if(out) out[size] = *p;
      size++;
    }

    p++;
  }

  if(out) out[size] = '\"';
  size++;

  return size;
}


char *argv_to_cmd(char** argv) {
  u32 len = 0, i;
  u8* buf, *ret;

  //todo shell-escape

  for (i = 0; argv[i]; i++)
    len += ArgvQuote(argv[i], NULL) + 1;
  
  if(!len) FATAL("Error creating command line");

  buf = ret = ck_alloc(len);

  for (i = 0; argv[i]; i++) {

    u32 l = ArgvQuote(argv[i], buf);

    buf += l;

    *(buf++) = ' ';
  }

  ret[len-1] = 0;

  return ret;
}


static void create_target_process(char** argv) {
  char *cmd;
  char *pipe_name;
  char *buf;
  char *pidfile;
  FILE *fp;
  size_t pidsize;
  BOOL inherit_handles = TRUE;

  HANDLE hJob = NULL;
  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  pipe_name = (char *)alloc_printf("\\\\.\\pipe\\afl_pipe_%s", fuzzer_id);

  pipe_handle = CreateNamedPipe(
    pipe_name,                // pipe name
    PIPE_ACCESS_DUPLEX,       // read/write access
    0,
    1,                        // max. instances
    512,                      // output buffer size
    512,                      // input buffer size
    20000,                    // client time-out
    NULL);                    // default security attribute

  if (pipe_handle == INVALID_HANDLE_VALUE) {
    FATAL("CreateNamedPipe failed, GLE=%d.\n", GetLastError());
  }

  target_cmd = argv_to_cmd(argv);

  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));

  if(quiet_mode) {
    si.hStdOutput = si.hStdError = devnul_handle;
    si.dwFlags |= STARTF_USESTDHANDLES;
  } else {
    inherit_handles = FALSE;
  }

  if(drioless) {
    char *static_config = alloc_printf("%s:1", fuzzer_id);

    if (static_config == NULL) {
      FATAL("Cannot allocate static_config.");
    }

    SetEnvironmentVariable("AFL_STATIC_CONFIG", static_config);
    cmd = alloc_printf("%s", target_cmd);
    ck_free(static_config);
  } else {
    pidfile = alloc_printf("childpid_%s.txt", fuzzer_id);
    cmd = alloc_printf(
      "%s\\drrun.exe -pidfile %s -no_follow_children -c winafl.dll %s -fuzz_iterations 1 -fuzzer_id %s -- %s",
      dynamorio_dir, pidfile, client_params, fuzzer_id, target_cmd
    );
  }

  if(mem_limit != 0) {
    hJob = CreateJobObject(NULL, NULL);
    if(hJob == NULL) {
      FATAL("CreateJobObject failed, GLE=%d.\n", GetLastError());
    }

    ZeroMemory(&job_limit, sizeof(job_limit));
    job_limit.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_PROCESS_MEMORY;
    job_limit.ProcessMemoryLimit = mem_limit * 1024 * 1024;

    if(!SetInformationJobObject(
      hJob,
      JobObjectExtendedLimitInformation,
      &job_limit,
      sizeof(job_limit)
    )) {
      FATAL("SetInformationJobObject failed, GLE=%d.\n", GetLastError());
    }
  }

  if(!CreateProcess(NULL, cmd, NULL, NULL, inherit_handles, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
    FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
  }

  child_handle = pi.hProcess;
  child_thread_handle = pi.hThread;

  if(mem_limit != 0) {
    if(!AssignProcessToJobObject(hJob, child_handle)) {
      FATAL("AssignProcessToJobObject failed, GLE=%d.\n", GetLastError());
    }
  }

  ResumeThread(child_thread_handle);

  watchdog_timeout_time = get_cur_time() + exec_tmout;
  watchdog_enabled = 1;

  if(!ConnectNamedPipe(pipe_handle, NULL)) {
    if(GetLastError() != ERROR_PIPE_CONNECTED) {
      FATAL("ConnectNamedPipe failed, GLE=%d.\n", GetLastError());
    }
  }

  watchdog_enabled = 0;

  if(drioless == 0) {
    //by the time pipe has connected the pidfile must have been created
    fp = fopen(pidfile, "rb");
    if(!fp) {
      FATAL("Error opening pidfile.txt");
    }
    fseek(fp,0,SEEK_END);
    pidsize = ftell(fp);
    fseek(fp,0,SEEK_SET);
    buf = (char *)malloc(pidsize+1);
    if (!buf) {
        FATAL("Error allocating %Iu bytes", pidsize + 1);
    }
    fread(buf, pidsize, 1, fp);
    buf[pidsize] = 0;
    fclose(fp);
    remove(pidfile);
    child_pid = atoi(buf);
    free(buf);
    ck_free(pidfile);
  }
  else {
    child_pid = pi.dwProcessId;
  }

  ck_free(target_cmd);
  ck_free(cmd);
  ck_free(pipe_name);
}


static void destroy_target_process(int wait_exit) {
  char* kill_cmd;
  BOOL still_alive = TRUE;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

#ifdef TINYINST
  if (use_tinyinst) {
    tinyinst_killtarget();
    return;
  }
#endif

  EnterCriticalSection(&critical_section);

  if(!child_handle) {
    goto leave;
  }

  if(WaitForSingleObject(child_handle, wait_exit) != WAIT_TIMEOUT) {
    goto done;
  }

  // nudge the child process only if dynamorio is used
  if(drioless) {
    TerminateProcess(child_handle, 0);
  } else {
    kill_cmd = alloc_printf("%s\\drconfig.exe -nudge_pid %d 0 1", dynamorio_dir, child_pid);

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
      FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    ck_free(kill_cmd);
  }

  still_alive = WaitForSingleObject(child_handle, 2000) == WAIT_TIMEOUT;

  if(still_alive) {
    //wait until the child process exits
    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    kill_cmd = alloc_printf("taskkill /PID %d /F", child_pid);

    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
      FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    ck_free(kill_cmd);

    if(WaitForSingleObject(child_handle, 20000) == WAIT_TIMEOUT) {
      FATAL("Cannot kill child process\n");
    }
  }

  done:
  CloseHandle(child_handle);
  CloseHandle(child_thread_handle);

  child_handle = NULL;
  child_thread_handle = NULL;

  leave:
  //close the pipe
  if(pipe_handle) {
    DisconnectNamedPipe(pipe_handle); 
    CloseHandle(pipe_handle);

    pipe_handle = NULL;
  }

  LeaveCriticalSection(&critical_section);
}


DWORD WINAPI watchdog_timer( LPVOID lpParam ) {
  u64 current_time;
  while(1) {
    Sleep(1000);
    current_time = get_cur_time();
    if(watchdog_enabled && (current_time > watchdog_timeout_time)) {
      child_timed_out = 1;
      destroy_target_process(0);
    }
  }
}


static void setup_watchdog_timer() {
  watchdog_enabled = 0;
  InitializeCriticalSection(&critical_section);
  CreateThread(NULL, 0, watchdog_timer, 0, 0, NULL);
}


static int is_child_running() {
   return (child_handle && (WaitForSingleObject(child_handle, 0 ) == WAIT_TIMEOUT));
}


/* Execute target application. */

static void run_target(char** argv) {


#ifdef TINYINST
  if (use_tinyinst) {
    return tinyinst_run(argv, exec_tmout);
  }
#endif

  char command[] = "F";
  DWORD num_read;
  char result = 0;

  if(!quiet_mode)
    SAYF("-- Program output begins --\n" cRST);

  if(quiet_mode && devnul_handle == INVALID_HANDLE_VALUE) {
    devnul_handle = CreateFile(
      "nul",
      GENERIC_READ | GENERIC_WRITE,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      NULL,
      OPEN_EXISTING,
      0,
      NULL);

    if(devnul_handle == INVALID_HANDLE_VALUE) {
      PFATAL("Unable to open the nul device.");
    }
  }

  if(!is_child_running()) {
    destroy_target_process(0);
    create_target_process(argv);
  }

  child_timed_out = 0;
  memset(trace_bits, 0, MAP_SIZE);

  //TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN
  ReadFile(pipe_handle, &result, 1, &num_read, NULL);
  if (result == 'K')
  {
	  //a workaround for first cycle
	  ReadFile(pipe_handle, &result, 1, &num_read, NULL);
  }
  if (result != 'P')
  {
	  FATAL("Unexpected result from pipe! expected 'P', instead received '%c'\n", result);
  }
  //END OF TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN
  WriteFile( 
    pipe_handle,  // handle to pipe 
    command,      // buffer to write from 
    1,            // number of bytes to write 
    &num_read,    // number of bytes written 
    NULL);        // not overlapped I/O 


  watchdog_timeout_time = get_cur_time() + exec_tmout;

  if(exec_tmout) {
    watchdog_enabled = 1;
  }

  ReadFile(pipe_handle, &result, 1, &num_read, NULL);

  if(exec_tmout) {
    watchdog_enabled = 0;
  }

  classify_counts(trace_bits, binary_mode ?
                  count_class_binary : count_class_human);

  if(!quiet_mode)
    SAYF(cRST "-- Program output ends --\n");

  child_crashed = result == 'C';

  if(!quiet_mode) {
    if(result == 'K')
      SAYF(cLRD "\n--- Program finished properly ---\n" cRST);
    else if(child_timed_out)
      SAYF(cLRD "\n+++ Program timed off +++\n" cRST);
    else if(stop_soon)
      SAYF(cLRD "\n+++ Program aborted by user +++\n" cRST);
    else if(child_crashed)
      SAYF(cLRD "\n+++ Program crashed +++\n" cRST);
  }


}


/* Do basic preparations - persistent fds, filenames, etc. */

static void set_up_environment(void) {
  // Not supported on Windows
}


/* Setup signal handlers, duh. */

static void setup_signal_handlers(void) {
  // not implemented on Windows
}


/* Detect @@ in args. */

static void detect_file_args(char** argv) {

  u32 i = 0;
  u8* cwd = _getcwd(NULL, 0);

  if(!cwd) PFATAL("getcwd() failed");

  while (argv[i]) {

    u8* aa_loc = strstr(argv[i], "@@");

    if(aa_loc) {

      u8 *aa_subst, *n_arg;

      if(!at_file) FATAL("@@ syntax is not supported by this tool.");

      /* Be sure that we're always using fully-qualified paths. */

      // if(at_file[0] == '/') aa_subst = at_file;
      // else aa_subst = alloc_printf("%s/%s", cwd, at_file);
      aa_subst = out_file;

      /* Construct a replacement argv value. */

      *aa_loc = 0;
      n_arg = alloc_printf("%s%s%s", argv[i], aa_subst, aa_loc + 2);
      argv[i] = n_arg;
      *aa_loc = '@';

      // if(at_file[0] != '/') ck_free(aa_subst);

    }

    i++;

  }

  free(cwd); /* not tracked */

}


/* Show banner. */

static void show_banner(void) {

  SAYF(cCYA "afl-showmap for Windows " cBRI VERSION cRST " by <0vercl0k@tuxfamily.org>\n");
  SAYF("Based on WinAFL " cBRI VERSION cRST " by <ifratric@google.com>\n");
  SAYF("Based on AFL " cBRI VERSION cRST " by <lcamtuf@google.com>\n");

}

/* Display usage hints. */

static void usage(u8* argv0) {

  show_banner();

  SAYF("\n%s [ options ] -- [instrumentation options] -- \\path\\to\\target_app [ ... ]\n\n"

       "Required parameters:\n\n"

       "  -o file       - file to write the trace data to\n"

       "Instrumentation type:\n\n"
       "  -D dir        - directory with DynamoRIO binaries (drrun, drconfig)\n"
       "  -Y            - enable the static instrumentation mode\n\n"

       "Execution control settings:\n\n"

       "  -t msec       - timeout for each run (none)\n"
       "  -m megs       - memory limit for child process (%u MB)\n"

       "Other settings:\n\n"

       "  -q            - sink program's output and don't show messages\n"
       "  -e            - show edge coverage only, ignore hit counts\n"
       "  -V            - show version number and exit\n\n"

       "This tool displays raw tuple data captured by AFL instrumentation.\n"
       "For additional help, consult %s\\README.\n\n" cRST,

       argv0, MEM_LIMIT, doc_path);

  exit(1);

}


/* Find binary. */

static void find_binary(u8* fname) {
  // Not implemented on Windows
}

static unsigned int optind;
static char *optarg;

int getopt(int argc, char **argv, char *optstring) {
  char *c;

  optarg = NULL;

  while(1) {
    if(optind == argc) return -1;
    if(strcmp(argv[optind], "--") == 0) return -1;
    if(argv[optind][0] != '-') {
      optind++;
      continue;
    }
    if(!argv[optind][1]) {
      optind++;
      continue;
    }

    c = strchr(optstring, argv[optind][1]);
    if(!c) return -1;
    optind++;
    if(c[1] == ':') {
      if(optind == argc) return -1;
      optarg = argv[optind];
      optind++;
    }

    return (int)(c[0]);
  }
}

static void extract_client_params(u32 argc, char** argv) {
  u32 len = 1, i;
  u32 nclientargs = 0;
  u8* buf;
  u32 opt_start, opt_end;

  if(!argv[optind] || optind >= argc) usage(argv[0]);
  if(strcmp(argv[optind],"--")) usage(argv[0]);

  if(drioless) return;
  optind++;
  opt_start = optind;

  for (i = optind; i < argc; i++) {
    if(strcmp(argv[i],"--") == 0) break;
    nclientargs++;
    len += strlen(argv[i]) + 1;
  }

  if(i == argc) usage(argv[0]);
  opt_end = i;

  buf = client_params = ck_alloc(len);

  for (i = opt_start; i < opt_end; i++) {

    u32 l = strlen(argv[i]);

    memcpy(buf, argv[i], l);
    buf += l;

    *(buf++) = ' ';
  }

  if(buf != client_params) {
    buf--;
  }

  *buf = 0;

  optind = opt_end;

}

/* Main entry point */

int main(int argc, char** argv) {

  s32 opt;
  u8  mem_limit_given = 0, timeout_given = 0;
  u32 tcnt;
  int i = 0, counter = 0;
  char** use_argv;

  doc_path = "docs";
  optind = 1;
  dynamorio_dir = NULL;
  client_params = NULL;
  use_tinyinst = 0;

#ifdef USE_COLOR
  enable_ansi_console();
#endif

  while ((opt = getopt(argc, argv, "+o:m:t:A:D:eqyZQbY")) > 0)
    switch (opt) {

    case 'y':
        #ifdef TINYINST
              use_tinyinst = 1;
        #else
              FATAL("afl-fuzz was not compiled with TinyInst support");
        #endif
        break;
      
      
      case 'D': /* dynamorio dir */

        if(dynamorio_dir) FATAL("Multiple -D options not supported");
        dynamorio_dir = optarg;
        break;

      case 'o':

        if(out_file) FATAL("Multiple -o options not supported");
        out_file = optarg;
        break;

      case 'm': {

          u8 suffix = 'M';

          if(mem_limit_given) FATAL("Multiple -m options not supported");
          mem_limit_given = 1;

          if(!strcmp(optarg, "none")) {

            mem_limit = 0;
            break;

          }

          if(sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1 ||
              optarg[0] == '-') FATAL("Bad syntax used for -m");

          switch (suffix) {

            case 'T': mem_limit *= 1024 * 1024; break;
            case 'G': mem_limit *= 1024; break;
            case 'k': mem_limit /= 1024; break;
            case 'M': break;

            default:  FATAL("Unsupported suffix or bad syntax for -m");

          }

          if(mem_limit < 5) FATAL("Dangerously low value of -m");

          if(sizeof(int) == 4 && mem_limit > 2000)
            FATAL("Value of -m out of range on 32-bit systems");

        }

        break;

      case 't':

        if(timeout_given) FATAL("Multiple -t options not supported");
        timeout_given = 1;

        if(strcmp(optarg, "none")) {
          exec_tmout = atoi(optarg);

          if(exec_tmout < 20 || optarg[0] == '-')
            FATAL("Dangerously low value of -t");

        }

        break;

      case 'e':

        if(edges_only) FATAL("Multiple -e options not supported");
        edges_only = 1;
        break;

      case 'q':

        if(quiet_mode) FATAL("Multiple -q options not supported");
        quiet_mode = 1;
        break;

      case 'Z':

        /* This is an undocumented option to write data in the syntax expected
           by afl-cmin. Nobody else should have any use for this. */

        cmin_mode  = 1;
        quiet_mode = 1;
        break;

      case 'A':

        FATAL("-A option not supported on Windows");
        /* Another afl-cmin specific feature. */
        at_file = optarg;
        break;

      case 'Q':
        FATAL("QEMU mode not supported on Windows");
        break;

      case 'b':

        /* Secret undocumented mode. Writes output in raw binary format
           similar to that dumped by afl-fuzz in <out_dir/queue/fuzz_bitmap. */

        binary_mode = 1;

      case 'Y':

        if (dynamorio_dir) FATAL("Dynamic-instrumentation (DRIO) is uncompatible with static-instrumentation");
        drioless = 1;
        break;

      case 'V':

        show_banner();
        exit(0);

      default:

        usage(argv[0]);

    }

  if(!out_file) usage(argv[0]);
  if(!drioless) {
    if(optind == argc || (!dynamorio_dir && !use_tinyinst)) usage(argv[0]);
  }

 if (use_tinyinst) {
#ifdef TINYINST
    int tinyinst_options = tinyinst_init(argc - optind, argv + optind);
    if (!tinyinst_options) usage(argv[0]);
    optind += tinyinst_options;
#endif
  } else {
	  extract_client_params(argc, argv);
  }
  optind++;

  setup_shm();

  if (use_tinyinst) {
#ifdef TINYINST
    tinyinst_set_fuzzer_id(fuzzer_id);
#endif
  }



  setup_watchdog_timer();
  setup_signal_handlers();

  set_up_environment();

  find_binary(argv[optind]);

  if(!quiet_mode) {
    show_banner();
    // Find the name of the target executable in the arguments
    for(; i < argc; i++) {
      if(strcmp(argv[i], "--") == 0) counter++;
      if(counter == (drioless ? 1:2)) {
        if(i != (argc - 1)) {
          target_path = argv[i + 1];
        }
        break;
      }
    }
    ACTF("Executing '%s'...\n", target_path);
  }

  detect_file_args(argv + optind);

  use_argv = argv + optind;

  run_target(use_argv);

  tcnt = write_results();

  if(!quiet_mode) {

    if(!tcnt) SAYF("No instrumentation detected");
    OKF("Captured %u tuples in '%s'." cRST, tcnt, out_file);

  }

  exit(child_crashed * 2 + child_timed_out);

}

```

`afl-staticinstr.c`:

```c
/*
   WinAFL persistent loop implementation for statically instrumented target
   -----------------------------------------------------------------------

   Written by Axel "0vercl0k" Souchet <0vercl0k@tuxfamily.org>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0
*/
#include "afl-staticinstr.h"
#include <stdio.h>
#include <psapi.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#define MAP_SIZE 65536
#define STATIC_COV_SECTION_NAME ".syzyafl"
#define STATIC_COV_SECTION_NAME_LEN 8
#define AFL_STATIC_CONFIG_ENV TEXT("AFL_STATIC_CONFIG")
#define AFL_VARIABLE_BEHAVIOR_TRACES_BASE_DIR TEXT("C:\\traces")
#define AFL_VARIABLE_BEHAVIOR_ITERATIONS 10
#define MAX_STRING_SIZE 64

#pragma pack(push, 1)
typedef struct {
    UINT32 __tls_index;
    UINT32 __tls_slot_offset;
    PUINT32 __afl_prev_loc;
    PUCHAR __afl_area_ptr;
    CHAR __afl_area[MAP_SIZE];
} STATIC_COVERAGE_DATA, *PSTATIC_COVERAGE_DATA;
#pragma pack(pop)

//
// The handle to the pipe used to talk with afl-fuzz.exe
//

HANDLE g_winafl_pipe = INVALID_HANDLE_VALUE;

//
// The no fuzzing mode is enabled when a binary is run without
// passing the fuzzing configuration in the AFL_STATIC_CONFIG
// environment variable (running a binary by itself, without
// being run via afl-fuzz.exe will enable this mode for example).
// Under this mode, the persistent loop exits after a single
// iteration.
//

BOOL g_nofuzzing_mode = FALSE;

//
// The no instrumentation mode means the binary is running
// without an AFL instrumented module in its address-space.
// As a result, it means there is no coverage information
// available (g_static_coverage_data is empty). This happens
// when the persistent loop is run without instrumenting any
// modules.
//

BOOL g_noinstrumentation = TRUE;

//
// The number of instrumented modules available in the
// address space.
//

SIZE_T g_ninstrumented_modules = 0;

//
// The coverage data is a pointer to a structure that
// can be found in an instrumented binary, in its '.syzyafl'
// section. A pointer to the coverage map can be found in it,
// but also what type of instrumentation it is using (single/multi thread).
// Note that, it is NULL when g_noinstrumentation is TRUE.

#define kMaximumInstrumentedModules 10
STATIC_COVERAGE_DATA *g_static_coverage_data[kMaximumInstrumentedModules];

//
// The current iterations track the number of iterations the persistent
// loop has been through.
//

SIZE_T g_current_iterations = 0;

//
// The n iterations is the total number total iterations that
// afl-fuzz.exe wants to be run every time the target process is
// spawned. This is configured via the AFL_STATIC_CONFIG environment
// variable.
//

SIZE_T g_niterations = 0;

//
// Some synchronization primitives.
//

CRITICAL_SECTION g_crit_section;
INIT_ONCE g_init_once = INIT_ONCE_STATIC_INIT, g_init_once_bareminimum = INIT_ONCE_STATIC_INIT;

LONG CALLBACK __afl_VectoredHandler(PEXCEPTION_POINTERS ExceptionInfo)

/*++

Routine Description:

    Catch exceptions and let afl-fuzz.exe know when an interesting
    one happened.

Arguments:

    ExceptionInfo - A structure with information about the exception
    that triggered the invocation of the vectored exception handler.

Return Value:

    EXCEPTION_CONTINUE_SEARCH if exception not handled.

--*/


{
    DWORD Dummy;
    EnterCriticalSection(&g_crit_section);

    if(
        ExceptionInfo->ExceptionRecord->ExceptionCode == DBG_PRINTEXCEPTION_C
#ifdef DBG_PRINTEXCEPTION_WIDE_C

        //
        // This define has been introduced in the Windows 10 SDK and doesn't
        // exist in older SDKs.
        //

        || ExceptionInfo->ExceptionRecord->ExceptionCode == DBG_PRINTEXCEPTION_WIDE_C
#endif
    ) {
        _tprintf(TEXT("[*] Received an OutputDebugString exception.\n"));
    }
    else if(ExceptionInfo->ExceptionRecord->ExceptionCode == 0xE06D7363) {

        //
        // https://support.microsoft.com/fr-fr/help/185294/prb-exception-code-0xe06d7363-when-calling-win32-seh-apis
        // https://blogs.msdn.microsoft.com/oldnewthing/20100730-00/?p=13273
        //

        _tprintf(TEXT("[*] Received an MSVC C++ exception.\n"));
    }
    else {
        _tprintf(TEXT("[*] The program just crashed.\n"));
        if(g_nofuzzing_mode == FALSE) {
            WriteFile(g_winafl_pipe, "C", 1, &Dummy, NULL);
            TerminateProcess(GetCurrentProcess(), 0);
        }
    }

    LeaveCriticalSection(&g_crit_section);
    _tprintf(TEXT("[+] Passing it to the program (might trigger a JIT debugger if it can't handle it).\n"));
    return EXCEPTION_CONTINUE_SEARCH;
}

VOID __afl_display_banner()

/*++

Routine Description:

    Displays the AFL persistent loop banner.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _tprintf(TEXT("Persistent loop implementation by <0vercl0k@tuxfamily.org>\n"));
    _tprintf(TEXT("Based on WinAFL by <ifratric@google.com>\n"));
}

BOOL CALLBACK __afl_set_it_up(
    PINIT_ONCE InitOnce, PVOID Parameter, PVOID *Context
)

/*++

Routine Description:

    Sets up the environment: creates the pipe to talk with afl-fuzz.exe,
    maps the coverage byte-map that afl-fuzz.exe will map in and fix-up
    the instrumented module so that its coverage byte-map pointer points
    inside the shared memory section.

Arguments:

    InitOnce - Unused.

    Parameter - Unused.

    Context - Unused.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL Status = TRUE;
    HANDLE MappedFile = NULL;
    PVOID AreaPtr = NULL;
    DWORD SizeNeeded;
    HMODULE Modules[128];
    SIZE_T i = 0;
    TCHAR PipeName[MAX_STRING_SIZE], ShmName[MAX_STRING_SIZE],
          FuzzerId[MAX_STRING_SIZE], StaticConfig[MAX_STRING_SIZE],
          InstrumentedModuleName[MAX_STRING_SIZE];

    UNREFERENCED_PARAMETER(InitOnce);
    UNREFERENCED_PARAMETER(Parameter);
    UNREFERENCED_PARAMETER(Context);

    EnterCriticalSection(&g_crit_section);

    //
    // Let's first figure out if we are running with any instrumented module,
    // in the address space.
    // If not, we turn on the no instrumentation switch.
    //

    Status = EnumProcessModulesEx(GetCurrentProcess(), Modules, sizeof(Modules), &SizeNeeded, LIST_MODULES_32BIT);

    if(Status == FALSE) {
        _tprintf(TEXT("[-] EnumProcessModulesEx failed - too many modules loaded?.\n"));
        TerminateProcess(GetCurrentProcess(), 0);
    }

    for(i = 0; i < SizeNeeded / sizeof(Modules[0]); ++i) {
        PVOID Base = (PVOID)Modules[i];
        PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)((PUCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
        PIMAGE_SECTION_HEADER Sections = (PIMAGE_SECTION_HEADER)(NtHeaders + 1);
        USHORT j = 0;

        for(j = 0; j < NtHeaders->FileHeader.NumberOfSections; ++j) {
            if(memcmp(Sections[j].Name, STATIC_COV_SECTION_NAME, STATIC_COV_SECTION_NAME_LEN) != 0) {
                continue;
            }

            //
            // Make sure we haven't exhausted the number of slots for the static coverage
            // information.
            //

            if(g_ninstrumented_modules == ARRAYSIZE(g_static_coverage_data)) {
                _tprintf(
                    TEXT("[!] You have exhausted the number of instrumented modules (%d).\n"),
                    g_ninstrumented_modules
                );
                break;
            }

            GetModuleBaseName(GetCurrentProcess(), Modules[i], InstrumentedModuleName, MAX_STRING_SIZE);
            g_static_coverage_data[g_ninstrumented_modules] = (STATIC_COVERAGE_DATA*)(
                Sections[j].VirtualAddress + (DWORD)Base
            );

            _tprintf(
                TEXT("[+] Found a statically instrumented module: %s (%s thread mode).\n"),
                InstrumentedModuleName,
                (g_static_coverage_data[g_ninstrumented_modules]->__tls_slot_offset == 0) ?
                TEXT("single") : TEXT("multi")
            );
            g_ninstrumented_modules++;
            g_noinstrumentation = FALSE;
            break;
        }
    }

    if(g_noinstrumentation == TRUE) {
        _tprintf(TEXT("[-] No instrumented module found.\n"));
        Status = FALSE;
    }

    //
    // Let's figure out, if afl-fuzz.exe spawned us or not?
    // If not, we can switch on the no fuzzing mode and exit.
    //

    if(GetEnvironmentVariable(AFL_STATIC_CONFIG_ENV, StaticConfig, MAX_STRING_SIZE) == 0) {
        _tprintf(TEXT("[-] Not running under afl-fuzz.exe.\n"));
        g_nofuzzing_mode = TRUE;
        Status = FALSE;
        goto clean;
    }

    //
    // We are running under afl-fuzz.exe; let's open the pipe used for
    // communication, create a named shared memory section to store the coverage
    // data and fix-up the instrumented module so that its instrumentation writes
    // in the shared memory section's content.
    //

    memset(PipeName, 0, MAX_STRING_SIZE * sizeof(PipeName[0]));
    memset(ShmName, 0, MAX_STRING_SIZE * sizeof(ShmName[0]));

    _tprintf(TEXT("[*] Setting up the environment (%s)..\n"), StaticConfig);
    if(_stscanf_s(StaticConfig, TEXT("%[a-zA-Z0-9]:%u"), FuzzerId, _countof(FuzzerId), &g_niterations) != 2) {
        _tprintf(
            TEXT("[-] The ") AFL_STATIC_CONFIG_ENV TEXT(" environment variable isn't properly formated.\n")
        );
        Status = FALSE;
        goto clean;
    }

    _stprintf_s(PipeName, _countof(PipeName), TEXT("\\\\.\\pipe\\afl_pipe_%s"), FuzzerId);
    _stprintf_s(ShmName, _countof(ShmName), TEXT("afl_shm_%s"), FuzzerId);

    //
    // Connect to the named pipe.
    //

    g_winafl_pipe = CreateFile(
        PipeName,                      // pipe name
        GENERIC_READ | GENERIC_WRITE,  // read and write access
        0,                             // no sharing
        NULL,                          // default security attributes
        OPEN_EXISTING,                 // opens existing pipe
        0,                             // default attributes
        NULL                           // no template file
    );

    if(g_winafl_pipe == INVALID_HANDLE_VALUE) {
        _tprintf(TEXT("[-] Opening the named pipe failed.\n"));
        Status = FALSE;
        goto clean;
    }

    //
    // Get the named shared memory section mapped.
    //

    MappedFile = OpenFileMapping(
        FILE_MAP_ALL_ACCESS,
        FALSE,
        ShmName
    );

    if(MappedFile == NULL) {
        _tprintf(TEXT("[-] Opening the file mapping failed.\n"));
        Status = FALSE;
        goto clean;
    }

    AreaPtr = MapViewOfFile(
        MappedFile,
        FILE_MAP_ALL_ACCESS,
        0,
        0,
        MAP_SIZE
    );

    if(AreaPtr == NULL) {
        _tprintf(TEXT("[-] Mapping a view of the shared memory section failed.\n"));
        Status = FALSE;
        goto clean;
    }

    //
    // Fix up the instrumented modules so that the pointer storing the base
    // of the coverage map points to the shared memory section we just mapped in.
    // The instrumented code will now write the coverage information directly
    // in the shared section.
    //

    for(i = 0; i < g_ninstrumented_modules; ++i) {
        g_static_coverage_data[i]->__afl_area_ptr = (PUCHAR)AreaPtr;
    }

    _tprintf(TEXT("[+] Fixed-up the %d instrumented modules.\n"), g_ninstrumented_modules);

    clean:

    if(g_nofuzzing_mode == FALSE && g_noinstrumentation == TRUE) {

        //
        // It means there is no instrumented module in the address space,
        // and we are being run through AFL..weird. Display a pop-up!
        //

        _tprintf(TEXT("[-] You are running without instrumentation under afl-fuzz.exe.\n"));

        MessageBox(
            NULL,
            TEXT("You are running without instrumentation under afl-fuzz.exe."),
            NULL,
            MB_OK | MB_ICONERROR
        );
    }

    if(MappedFile != NULL) {
        CloseHandle(MappedFile);
    }

    LeaveCriticalSection(&g_crit_section);
    return Status;
}

BOOL CALLBACK __afl_set_up_bareminimum(
    PINIT_ONCE InitOnce, PVOID Parameter, PVOID *Context
)

/*++

Routine Description:

    Installs the vectored exception handler to ease reproducability.
    The VEH gets installed even if running without afl-fuzz.exe, or
    if running a non-instrumented module. This is particularly useful
    for debugging issues found by afl-fuzz.exe on a vanilla target (in
    the case the debugging symbols are a bit funky on an instrumented
    binary for example). Also initialize the critical section.

Arguments:

    InitOnce - Unused.

    Parameter - Unused.

    Context - Unused.

Return Value:

    TRUE.

--*/

{
    UNREFERENCED_PARAMETER(InitOnce);
    UNREFERENCED_PARAMETER(Parameter);
    UNREFERENCED_PARAMETER(Context);

    InitializeCriticalSection(&g_crit_section);

    //
    // Set up the exception handler.
    //

    AddVectoredExceptionHandler(0, __afl_VectoredHandler);

    //
    // Display the banner to know the persistent loop is here.
    //

    __afl_display_banner();
    return TRUE;
}

BOOL __afl_persistent_loop()

/*++

Routine Description:

    Persistent loop implementation.

Arguments:

    None.

Return Value:

    TRUE until the iteration count gets hit, and then FALSE.

--*/

{
    BOOL Status;
    CHAR Command = 0;
    DWORD Dummy;
    SIZE_T i = 0;

    if(g_nofuzzing_mode == TRUE) {

        //
        // Force exit at the first iteration when afl-fuzz isn't detected
        // to fake "normal" execution of instrumented binary.
        //

        Status = FALSE;
        goto clean;
    }

    Status = InitOnceExecuteOnce(
        &g_init_once_bareminimum,
        __afl_set_up_bareminimum,
        NULL,
        NULL
    );

    Status = InitOnceExecuteOnce(
        &g_init_once,
        __afl_set_it_up,
        NULL,
        NULL
    );

    if(Status == FALSE) {
        _tprintf(TEXT("[+] Enabling the no fuzzing mode.\n"));
        g_nofuzzing_mode = TRUE;
        Status = TRUE;
        goto clean;
    }

    //
    // If this not the first time, it means we have to signal afl-fuzz that
    // the previous test-case ended.
    //

    if(g_current_iterations > 0) {
        WriteFile(g_winafl_pipe, "K", 1, &Dummy, NULL);
    }

    if(g_current_iterations == g_niterations) {

        //
        // It is time to stop the machine!
        //

        CloseHandle(g_winafl_pipe);
        g_winafl_pipe = INVALID_HANDLE_VALUE;

        UnmapViewOfFile(g_static_coverage_data[0]->__afl_area_ptr);

        //
        // Redirect the coverage map back into the instrumented binary's
        // .syzyafl section so that the program doesn't crash while exiting.
        //

        for(i = 0; i < g_ninstrumented_modules; ++i) {
            g_static_coverage_data[i]->__afl_area_ptr = (PUCHAR)g_static_coverage_data[i]->__afl_area;
        }

        Status = FALSE;
        goto clean;
    }

    //
    // Tell afl-fuzz that we are ready for the next iteration.
    //

    WriteFile(g_winafl_pipe, "P", 1, &Dummy, NULL);

    //
    // Wait until we have the go from afl-fuzz to go ahead (below call is blocking).
    //

    ReadFile(g_winafl_pipe, &Command, 1, &Dummy, NULL);
    if(Command != 'F') {
        if(Command == 'Q') {
            _tprintf(TEXT("[+] Received the quit signal, exiting.\n"));
        } else {
            _tprintf(TEXT("[-] Received an unknown command from afl-fuzz, exiting (%.2x).\n"), Command);
        }

        TerminateProcess(GetCurrentProcess(), 0);
    }

    clean:

    g_current_iterations++;

#ifdef AFL_STATIC_VARIABLE_BEHAVIOR_DEBUG

    {
        //
        // To ease debugging of variable behavior, we fake a configuration
        // where we run 10 iterations through the persistent loop, and
        // we save to disk the coverage map at every iterations.
        // You can then diff them and understand what parts of the map
        // get changed, and you can then set hardware write access breakpoints
        // to see what is the code writing in the coverage map.
        //

        FILE *CoverageFile = NULL;
        TCHAR CoverageFilename[MAX_STRING_SIZE];

        if(g_current_iterations == 1) {

            //
            // Check various things on the first iteration. This is the
            // only time this block will get executed.
            //

            //
            // We cannot run in this mode if no instrumentation has been found, as
            // there won't be any coverage map.
            //

            if(g_noinstrumentation == TRUE) {
                _tprintf(TEXT(
                    "[-] Cannot run the variable behavior debugging mode without an instrumented module.\n"
                ));
                Status = FALSE;
                goto end;
            }

            //
            // We cannot run in this mode if we are fuzzing right now, display a message
            // box as - most likely - afl-fuzz.exe is sink-holing stdout messages.
            //

            if(g_nofuzzing_mode == FALSE) {
                MessageBox(
                    NULL,
                    TEXT("You are running the target under afl-fuzz.exe with the variable behavior debugging mode."),
                    NULL,
                    MB_OK | MB_ICONERROR
                );
                Status = FALSE;
                goto end;
            }

            //
            // Let the user knows that the variable behavior debugging mode is enabled,
            // and configure the number of iterations.
            //

            _tprintf(TEXT("[+] Enabled the variable behavior debugging mode.\n"));
            g_niterations = AFL_VARIABLE_BEHAVIOR_ITERATIONS;

            //
            // Fix-up all the coverage maps to point into the first one's.
            //

            for(i = 1; i < g_ninstrumented_modules; ++i) {
                g_static_coverage_data[i]->__afl_area_ptr = (PUCHAR)g_static_coverage_data[0]->__afl_area;
            }

            if(IsDebuggerPresent()) {

                //
                // If we are under a debugger, let's give to the user the
                // coverage map base address as it is useful to break on write
                // access to certain bytes in the map to investigate variable
                // behaviors test-cases.
                //

                _tprintf(
                    TEXT("[+] Coverage map base: %p.\n"),
                    g_static_coverage_data[0]->__afl_area_ptr
                );

                //
                // Also breaking so that the user can set its breakpoints before
                // we start running the persistent loop.
                //

                __debugbreak();
            }
        }

        //
        // Force the persistent loop to run again if we need it to.
        //

        if(g_current_iterations == g_niterations) {

            //
            // We are done!
            //

            Status = FALSE;
        } else {

            //
            // Force re-entering the persistent loop again.
            //

            g_nofuzzing_mode = FALSE;
        }

        if(g_current_iterations > 1 && !IsDebuggerPresent()) {

            //
            // Write the coverage map to disk if this is not the first
            // iteration as the instrumented code didn't get a chance
            // to be executed yet. We also don't overwrite the traces if a
            // debugger is attached, as it most likely means that an
            // investigation is on-going.
            //

            _stprintf_s(
                CoverageFilename, _countof(CoverageFilename),
                AFL_VARIABLE_BEHAVIOR_TRACES_BASE_DIR "\\%u.bin", g_current_iterations - 1
            );

            if(_tfopen_s(&CoverageFile, CoverageFilename, TEXT("wb"))) {
                _tprintf(TEXT("[-] Cannot open %s.\n"), CoverageFilename);
            } else {
                fwrite(g_static_coverage_data[0]->__afl_area_ptr, MAP_SIZE, 1, CoverageFile);
                fclose(CoverageFile);
            }
        }
    }

    end:

#endif

    if(g_noinstrumentation == FALSE) {

        //
        // Reset the global state only if we have found an instrumented
        // module earlier - otherwise the g_static_coverage_data array
        // is empty.
        //

        for(i = 0; i < g_ninstrumented_modules; ++i) {
            PUINT32 PerThreadPrevLoc;
            STATIC_COVERAGE_DATA *CurrentCoverageData = g_static_coverage_data[i];
            if(CurrentCoverageData->__tls_slot_offset != 0) {

                //
                // TLS version if we are fuzzing a multithread instrumented binary.
                //

                PUINT32 Base = (PUINT32)(__readfsdword(0x2C) + (4 * CurrentCoverageData->__tls_index));
                PerThreadPrevLoc = (PUINT32)(*Base + CurrentCoverageData->__tls_slot_offset);
            } else {
                PerThreadPrevLoc = (PUINT32)(&CurrentCoverageData->__afl_prev_loc);
            }

            *PerThreadPrevLoc = 0;
        }

        memset(g_static_coverage_data[0]->__afl_area_ptr, 0, MAP_SIZE);
    }

#ifdef AFL_STATIC_VARIABLE_BEHAVIOR_DEBUG

    //
    // Make sure to reinitialize the counter to 0 in order
    // to not exhaust all the slots.
    //

    g_ninstrumented_modules = 0;

#endif

    return Status;
}

#ifdef __cplusplus
}
#endif

```

`afl-staticinstr.h`:

```h
/*
   WinAFL persistent loop implementation for statically instrumented target
   -----------------------------------------------------------------------

   Written by Axel "0vercl0k" Souchet <0vercl0k@tuxfamily.org>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   This header is the glue you need to make afl-fuzz and your statically
   instrumented target play nice together.

   The entry-point __afl_persistent_loop is meant to be called at the start of the harness,
   in a loop like below. The function will set up everything needed to communicate
   and synchronize with afl-fuzz - if it is present (named pipe, shm, etc).

      while(__afl_persistent_loop()) {
          // init state
          // exercise target
          // clear state
      }

   If afl-fuzz isn't detected, then the function will simply return TRUE the first
   time so that the body gets executed once.
*/
#pragma once
#include <Windows.h>
#include <stdint.h>
#include <tchar.h>

#if defined(_M_X64) || defined(__amd64__)
#error Static instrumentation is only available for 32 bit binaries
#endif

//
// Enable the variable behavior debugging mode.
//

// #define AFL_STATIC_VARIABLE_BEHAVIOR_DEBUG

#ifdef __cplusplus
extern "C" {
#endif

BOOL __afl_persistent_loop();

#ifdef __cplusplus
}
#endif

```

`afl-tmin.c`:

```c
/*
   american fuzzy lop - test case minimizer
   ----------------------------------------

   Written and maintained by Michal Zalewski <lcamtuf@google.com>

   Windows fork written by Axel "0vercl0k" Souchet <0vercl0k@tuxfamily.org>

   Copyright 2017 Google Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   A simple test case minimizer that takes an input file and tries to remove
   as much data as possible while keeping the binary in a crashing state
   *or* producing consistent instrumentation output (the mode is auto-selected
   based on the initially observed behavior).

 */
#define _CRT_SECURE_NO_WARNINGS
#define _CRT_RAND_S
#define AFL_MAIN
#define VERSION             "2.51b"

#include <windows.h>

#include "config.h"
#include "types.h"
#include "debug.h"
#include "alloc-inl.h"
#include "hash.h"

#include <io.h>
#include <direct.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>

#include <sys/stat.h>
#include <sys/types.h>

static s32 child_pid;                 /* PID of the tested program         */

static HANDLE child_handle,
              child_thread_handle;
static char *dynamorio_dir;
static char *client_params;
static char *winafl_dll_path;
static const char *winafl_dll_path_default = "winafl.dll";
int fuzz_iterations_max = 1, fuzz_iterations_current;

static CRITICAL_SECTION critical_section;
static u64 watchdog_timeout_time;
static u8 watchdog_enabled;
static u8 *target_cmd;                /* command line of target           */

static u8 *trace_bits,                /* SHM with instrumentation bitmap   */
          *mask_bitmap;               /* Mask for trace bits (-B)          */

static u8 *in_file,                   /* Minimizer input test case         */
          *out_file,                  /* Minimizer output file             */
          *prog_in,                   /* Targeted program input file       */
          *target_path,               /* Path to target binary             */
          *doc_path,                  /* Path to docs                      */
          *at_file;                   /* Substitution string for @@        */

static u8 *in_data,                   /* Input data for trimming           */
          *prev_data;                 /* Data of previous attempt          */

static u32 in_len,                    /* Input data length                 */
           prev_len,                  /* Data length of previous attempt   */
           orig_cksum,                /* Original checksum                 */
           total_execs,               /* Total number of execs             */
           missed_hangs,              /* Misses due to hangs               */
           missed_crashes,            /* Misses due to crashes             */
           missed_paths,              /* Misses due to exec path diffs     */
           exec_tmout = EXEC_TIMEOUT; /* Exec timeout (ms)                 */
           del_len_limit = 1;         /* Minimum block deletion length     */

static u64 mem_limit = MEM_LIMIT,     /* Memory limit (MB)                 */
           start_time;                /* Tick count at the beginning       */

static HANDLE shm_handle;             /* Handle of the SHM region         */
static HANDLE pipe_handle;            /* Handle of the name pipe          */
static u64    name_seed;              /* Random integer to have a unique shm/pipe name */
static HANDLE devnul_handle;          /* Handle of the nul device         */
static u8     sinkhole_stds = 1;      /* Sink-hole stdout/stderr messages?*/
static char   *fuzzer_id = NULL;      /* The fuzzer ID or a randomized
                                         seed allowing multiple instances */

static u8  crash_mode,                /* Crash-centric mode?               */
           exit_crash,                /* Treat non-zero exit as crash?     */
           edges_only,                /* Ignore hit counts?                */
           exact_mode,                /* Require path match for crashes?   */
           no_minimize = 0,           /* Skip minimization phase           */
           no_normalize = 0,          /* Skip normalization phases         */
           single_pass = 0,           /* Run only a single pass            */
           dump_on_abort = 1,         /* Dump partial results to a file on Ctrl+C */
           use_stdin = 1,             /* Use stdin for program input?      */
           drioless = 0;

static volatile u8
           stop_soon,                 /* Ctrl-C pressed?                   */
           child_timed_out;           /* Child timed out?                  */


/* Classify tuple counts. This is a slow & naive version, but good enough here. */
#define AREP4(_sym)   (_sym), (_sym), (_sym), (_sym)
#define AREP8(_sym)   AREP4(_sym), AREP4(_sym)
#define AREP16(_sym)  AREP8(_sym), AREP8(_sym)
#define AREP32(_sym)  AREP16(_sym), AREP16(_sym)
#define AREP64(_sym)  AREP32(_sym), AREP32(_sym)
#define AREP128(_sym) AREP64(_sym), AREP64(_sym)

static const u8 count_class_lookup[256] = {

  /* 0 - 3:       4 */ 0, 1, 2, 4,
  /* 4 - 7:      +4 */ AREP4(8),
  /* 8 - 15:     +8 */ AREP8(16),
  /* 16 - 31:   +16 */ AREP16(32),
  /* 32 - 127:  +96 */ AREP64(64), AREP32(64),
  /* 128+:     +128 */ AREP128(128)

};

static void classify_counts(u8* mem) {

  u32 i = MAP_SIZE;

  if (edges_only) {

    while (i--) {
      if (*mem) *mem = 1;
      mem++;
    }

  } else {

    while (i--) {
      *mem = count_class_lookup[*mem];
      mem++;
    }

  }

}


/* Apply mask to classified bitmap (if set). */

static void apply_mask(u32* mem, u32* mask) {

  u32 i = (MAP_SIZE >> 2);

  if (!mask) return;

  while (i--) {

    *mem &= ~*mask;
    mem++;
    mask++;

  }

}


/* See if any bytes are set in the bitmap. */

static inline u8 anything_set(void) {

  u32* ptr = (u32*)trace_bits;
  u32  i   = (MAP_SIZE >> 2);

  while (i--) if (*(ptr++)) return 1;

  return 0;

}


/* Get unix time in milliseconds */

static u64 get_cur_time(void) {

  u64 ret;
  FILETIME filetime;
  GetSystemTimeAsFileTime(&filetime);

  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;

  return ret / 10000;

}


/* Get unix time in microseconds */

static u64 get_cur_time_us(void) {

  u64 ret;
  FILETIME filetime;
  GetSystemTimeAsFileTime(&filetime);

  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;

  return ret / 10;

}


char *alloc_printf(const char *_str, ...) {

  va_list argptr;
  char* _tmp;
  s32 _len;

  va_start(argptr, _str);
  _len = vsnprintf(NULL, 0, _str, argptr);
  if (_len < 0) FATAL("Whoa, snprintf() fails?!");
  _tmp = ck_alloc(_len + 1);
  vsnprintf(_tmp, (size_t)_len + 1, _str, argptr);
  va_end(argptr);
  return _tmp;

}


/* Get rid of shared memory and temp files (atexit handler). */

static void remove_shm(void) {

  UnmapViewOfFile(trace_bits);
  CloseHandle(shm_handle);
  if (prog_in) unlink(prog_in); /* Ignore errors */

}


/* Configure shared memory. */

static void setup_shm(void) {

  char* shm_str = NULL;
  unsigned int seeds[2];
  u64 name_seed;
  u8 attempts = 0;

  while(attempts < 5) {
    if(fuzzer_id == NULL) {
      // If it is null, it means we have to generate a random seed to name the instance
      rand_s(&seeds[0]);
      rand_s(&seeds[1]);
      name_seed = ((u64)seeds[0] << 32) | seeds[1];
      fuzzer_id = (char *)alloc_printf("%I64x", name_seed);
    }

    shm_str = (char *)alloc_printf("afl_shm_%s", fuzzer_id);

    shm_handle = CreateFileMapping(
                   INVALID_HANDLE_VALUE,    // use paging file
                   NULL,                    // default security
                   PAGE_READWRITE,          // read/write access
                   0,                       // maximum object size (high-order DWORD)
                   MAP_SIZE,                // maximum object size (low-order DWORD)
                   (char *)shm_str);        // name of mapping object

    if(shm_handle == NULL) {
      if(GetLastError() == ERROR_ALREADY_EXISTS) {
        // We need another attempt to find a unique section name
        attempts++;
        ck_free(shm_str);
        ck_free(fuzzer_id);
        fuzzer_id = NULL;
        continue;
      }
      else {
        PFATAL("CreateFileMapping failed");
      }
    }

    // We found a section name that works!
    break;
  }

  if(attempts == 5) {
    FATAL("Could not find a section name.\n");
  }

  atexit(remove_shm);

  ck_free(shm_str);

  trace_bits = (u8 *)MapViewOfFile(
    shm_handle,          // handle to map object
    FILE_MAP_ALL_ACCESS, // read/write permission
    0,
    0,
    MAP_SIZE
  );

  if (!trace_bits) PFATAL("MapViewOfFile() failed");

}


/* Read initial file. */

static void read_initial_file(void) {

  struct stat st;
  s32 fd = _open(in_file, O_RDONLY | O_BINARY);

  if (fd < 0) PFATAL("Unable to open '%s'", in_file);

  if (fstat(fd, &st) || !st.st_size)
    FATAL("Zero-sized input file.");

  if (st.st_size >= TMIN_MAX_FILE)
    FATAL("Input file is too large (%u MB max)", TMIN_MAX_FILE / 1024 / 1024);

  in_len  = st.st_size;
  in_data = ck_alloc_nozero(in_len);
  prev_len = -1;
  prev_data = ck_alloc_nozero(in_len);

  ck_read(fd, in_data, in_len, in_file);

  _close(fd);

  OKF("Read %u byte%s from '%s'.", in_len, in_len == 1 ? "" : "s", in_file);

}


/* Write output file. */

static void write_to_file(u8* path, u8* mem, u32 len) {

  s32 ret;

  ret = _open(path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, DEFAULT_PERMISSION);

  if (ret < 0) PFATAL("Unable to create '%s'", path);

  ck_write(ret, mem, len, path);

  _close(ret);

}

//quoting on Windows is weird
size_t ArgvQuote(char *in, char *out) {
  int needs_quoting = 0;
  size_t size = 0;
  char *p = in;
  size_t i;

  //check if quoting is necessary
  if(strchr(in, ' ')) needs_quoting = 1;
  if(strchr(in, '\"')) needs_quoting = 1;
  if(strchr(in, '\t')) needs_quoting = 1;
  if(strchr(in, '\n')) needs_quoting = 1;
  if(strchr(in, '\v')) needs_quoting = 1;
  if(!needs_quoting) {
    size = strlen(in);
    if(out) memcpy(out, in, size);
    return size;
  }

  if(out) out[size] = '\"';
  size++;

  while(*p) {
    size_t num_backslashes = 0;
    while((*p) && (*p == '\\')) {
      p++;
      num_backslashes++;
    }

    if(*p == 0) {
      for(i = 0; i < (num_backslashes*2); i++) {
        if(out) out[size] = '\\';
        size++;
      }
      break;
    } else if(*p == '\"') {
      for(i = 0; i < (num_backslashes*2 + 1); i++) {
        if(out) out[size] = '\\';
        size++;
      }
      if(out) out[size] = *p;
      size++;
    } else {
      for(i = 0; i < num_backslashes; i++) {
        if(out) out[size] = '\\';
        size++;
      }
      if(out) out[size] = *p;
      size++;
    }

    p++;
  }

  if(out) out[size] = '\"';
  size++;

  return size;
}


char *argv_to_cmd(char** argv) {
  u32 len = 0, i;
  u8* buf, *ret;

  //todo shell-escape

  for (i = 0; argv[i]; i++)
    len += ArgvQuote(argv[i], NULL) + 1;

  if(!len) FATAL("Error creating command line");

  buf = ret = ck_alloc(len);

  for (i = 0; argv[i]; i++) {

    u32 l = ArgvQuote(argv[i], buf);

    buf += l;

    *(buf++) = ' ';
  }

  ret[len-1] = 0;

  return ret;
}


static void create_target_process(char** argv) {
  char* cmd;
  char* pipe_name;
  char *buf;
  char *pidfile = NULL;
  FILE *fp;
  size_t pidsize;
  BOOL inherit_handles = TRUE;
  HANDLE hJob = NULL;
  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;

  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  pipe_name = (char *)alloc_printf("\\\\.\\pipe\\afl_pipe_%s", fuzzer_id);

  pipe_handle = CreateNamedPipe(
    pipe_name,                // pipe name
    PIPE_ACCESS_DUPLEX,       // read/write access
    0,
    1,                        // max. instances
    512,                      // output buffer size
    512,                      // input buffer size
    20000,                    // client time-out
    NULL);                    // default security attribute

  if (pipe_handle == INVALID_HANDLE_VALUE) {
    FATAL("CreateNamedPipe failed, GLE=%d.\n", GetLastError());
  }

  target_cmd = argv_to_cmd(argv);

  if (drioless) {
    char *static_config = alloc_printf("%s:1", fuzzer_id);

    if (static_config == NULL) {
      FATAL("Cannot allocate static_config.");
    }

    SetEnvironmentVariable("AFL_STATIC_CONFIG", static_config);
    cmd = alloc_printf("%s", target_cmd);
    ck_free(static_config);
  } else {
    pidfile = alloc_printf("childpid_%s.txt", fuzzer_id);
    if (winafl_dll_path == NULL) {
      winafl_dll_path = winafl_dll_path_default;
    }
    cmd = alloc_printf(
      "%s\\drrun.exe -pidfile %s -no_follow_children -c %s %s -fuzz_iterations 1 -fuzzer_id %s -- %s",
      dynamorio_dir, pidfile, winafl_dll_path, client_params, fuzzer_id, target_cmd
    );
  }

  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));

  if (sinkhole_stds) {
    si.hStdOutput = si.hStdError = devnul_handle;
    si.dwFlags |= STARTF_USESTDHANDLES;
  } else {
    inherit_handles = FALSE;
  }

  if (mem_limit != 0) {
    hJob = CreateJobObject(NULL, NULL);
    if (hJob == NULL) {
      FATAL("CreateJobObject failed, GLE=%d.\n", GetLastError());
    }

    ZeroMemory(&job_limit, sizeof(job_limit));
    job_limit.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_PROCESS_MEMORY;
    job_limit.ProcessMemoryLimit = mem_limit * 1024 * 1024;

    if (!SetInformationJobObject(
      hJob,
      JobObjectExtendedLimitInformation,
      &job_limit,
      sizeof(job_limit)
    )) {
      FATAL("SetInformationJobObject failed, GLE=%d.\n", GetLastError());
    }
  }

  if (!CreateProcess(NULL, cmd, NULL, NULL, inherit_handles, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
    FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
  }

  child_handle = pi.hProcess;
  child_thread_handle = pi.hThread;

  if (mem_limit != 0) {
    if (!AssignProcessToJobObject(hJob, child_handle)) {
      FATAL("AssignProcessToJobObject failed, GLE=%d.\n", GetLastError());
    }
  }

  ResumeThread(child_thread_handle);

  watchdog_timeout_time = get_cur_time() + exec_tmout;
  watchdog_enabled = 1;

  if (!ConnectNamedPipe(pipe_handle, NULL)) {
    if (GetLastError() != ERROR_PIPE_CONNECTED) {
      FATAL("ConnectNamedPipe failed, GLE=%d.\n", GetLastError());
    }
  }

  watchdog_enabled = 0;

  if (drioless == 0) {
    //by the time pipe has connected the pidfile must have been created
    fp = fopen(pidfile, "rb");
    if (!fp) {
      FATAL("Error opening pidfile.txt");
    }
    fseek(fp,0,SEEK_END);
    pidsize = ftell(fp);
    fseek(fp,0,SEEK_SET);
    buf = (char *)malloc(pidsize+1);
    if (!buf) {
        FATAL("Error allocating %Iu bytes", pidsize + 1);
    }
    fread(buf, pidsize, 1, fp);
    buf[pidsize] = 0;
    fclose(fp);
    remove(pidfile);
    child_pid = atoi(buf);
    free(buf);
    ck_free(pidfile);
  }
  else {
    child_pid = pi.dwProcessId;
  }

  ck_free(target_cmd);
  ck_free(cmd);
  ck_free(pipe_name);
}


static void destroy_target_process(int wait_exit) {
  char* kill_cmd;
  BOOL still_alive = TRUE;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  BOOL no_hang = (wait_exit == -1);

  // Hack, to allow telling this function not to hang.
  // If the target process is terminating and still has pending I/O, it won't actually finish.
  //  Calling DisconnectNamedPipe or CloseHandle on the pipe handle may hang indefinitely.
  //  Skipping those calls might leak the target process (for a while or indefinitely),
  //  but at least the current process would be allowed to finish.
  if (wait_exit == -1) {
    wait_exit = 0;
  }
  EnterCriticalSection(&critical_section);

  if(!child_handle) {
    goto leave;
  }

  if(WaitForSingleObject(child_handle, wait_exit) != WAIT_TIMEOUT) {
    goto done;
  }

  // nudge the child process only if dynamorio is used
  if(drioless) {
    TerminateProcess(child_handle, 0);
  } else {
    kill_cmd = alloc_printf("%s\\drconfig.exe -nudge_pid %d 0 1", dynamorio_dir, child_pid);

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
      FATAL("CreateProcess(drconfig) failed, GLE=%d.\n", GetLastError());
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    ck_free(kill_cmd);
  }

  still_alive = WaitForSingleObject(child_handle, 2000) == WAIT_TIMEOUT;

  if(still_alive) {
    //wait until the child process exits
    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    kill_cmd = alloc_printf("taskkill /PID %d /F", child_pid);

    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
      FATAL("CreateProcess(taskkill) failed, GLE=%d.\n", GetLastError());
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    ck_free(kill_cmd);

    if(WaitForSingleObject(child_handle, 20000) == WAIT_TIMEOUT) {
      FATAL("Cannot kill child process\n");
    }
  }

  done:
  CloseHandle(child_handle);
  CloseHandle(child_thread_handle);

  child_handle = NULL;
  child_thread_handle = NULL;

  leave:
  //close the pipe
  if(pipe_handle) {
    if (!no_hang) {
      DisconnectNamedPipe(pipe_handle);
      CloseHandle(pipe_handle);
    }

    pipe_handle = NULL;
  }

  LeaveCriticalSection(&critical_section);
}


DWORD WINAPI watchdog_timer( LPVOID lpParam ) {
  u64 current_time;
  while(1) {
    Sleep(1000);
    current_time = get_cur_time();
    if(watchdog_enabled && (current_time > watchdog_timeout_time)) {
      child_timed_out = 1;
      destroy_target_process(0);
    }
  }
}


static void setup_watchdog_timer() {
  watchdog_enabled = 0;
  InitializeCriticalSection(&critical_section);
  CreateThread(NULL, 0, watchdog_timer, 0, 0, NULL);
}


static int is_child_running() {
   return (child_handle && (WaitForSingleObject(child_handle, 0 ) == WAIT_TIMEOUT));
}


/* Execute target application. Returns 0 if the changes are a dud, or
   1 if they should be kept. */

static u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {

  char command[] = "F";
  DWORD num_read;
  char result = 0;
  u8 child_crashed;
  u32 cksum;

  // Skip run if buffer is identical to previous run
  if ((len == prev_len) && (0 == memcmp(prev_data, mem, len))) return 0;

  prev_len = len;
  memcpy(prev_data, mem, len);

  write_to_file(prog_in, mem, len);

  if(!is_child_running()) {
    destroy_target_process(0);
    create_target_process(argv);
    fuzz_iterations_current = 0;
  }

  child_timed_out = 0;
  memset(trace_bits, 0, MAP_SIZE);
  MemoryBarrier();

  //TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN
  ReadFile(pipe_handle, &result, 1, &num_read, NULL);
  if (result == 'K')
  {
	  //a workaround for first cycle
	  ReadFile(pipe_handle, &result, 1, &num_read, NULL);
  }
  if (result != 'P')
  {
      if (result == 0) {
          FATAL("Reading from pipe failed! GLE=%lu\n", GetLastError()); // This may happen if the target process crashes before reaching the target function
      }
	  FATAL("Unexpected result from pipe! expected 'P', instead received '%c'\n", result);
  }
  //END OF TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN
  WriteFile(
    pipe_handle,  // handle to pipe
    command,      // buffer to write from
    1,            // number of bytes to write
    &num_read,    // number of bytes written
    NULL);        // not overlapped I/O

  watchdog_timeout_time = get_cur_time() + exec_tmout;

  if(exec_tmout) {
    watchdog_enabled = 1;
  }

  ReadFile(pipe_handle, &result, 1, &num_read, NULL);

  if(exec_tmout) {
    watchdog_enabled = 0;
  }

  MemoryBarrier();

  /* Clean up bitmap, analyze exit condition, etc. */

  classify_counts(trace_bits);
  apply_mask((u32*)trace_bits, (u32*)mask_bitmap);
  total_execs++;
  fuzz_iterations_current++;

  if(fuzz_iterations_current == fuzz_iterations_max) {
    destroy_target_process(2000);
  }

  if (stop_soon) {
    SAYF(cRST cLRD "\n+++ Minimization aborted by user +++\n" cRST);
    Sleep(200); // Allow time to dump partial results
    exit(1);
  }

  child_crashed = result == 'C';

  /* Always discard inputs that time out. */

  if (child_timed_out) {

    missed_hangs++;
    return 0;

  }

  /* Handle crashing inputs depending on current mode. */

  if (child_crashed) {

    if (first_run) crash_mode = 1;

    if (crash_mode) {

      if (!exact_mode) return 1;

    } else {

      missed_crashes++;
      return 0;

    }

  } else

  /* Handle non-crashing inputs appropriately. */

  if (crash_mode) {

    missed_paths++;
    return 0;

  }

  cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
  if (first_run) orig_cksum = cksum;

  if (orig_cksum == cksum) return 1;

  missed_paths++;
  return 0;

}


/* Find first power of two greater or equal to val. */

static u32 next_p2(u32 val) {

  u32 ret = 1;
  while (val > ret) ret <<= 1;
  return ret;

}


/* Actually minimize! */

static void minimize(char** argv) {

  static u32 alpha_map[256];

  u8* tmp_buf = ck_alloc_nozero(in_len);
  u32 orig_len = in_len, stage_o_len;

  u32 del_len, set_len, del_pos, set_pos, i, alpha_size, cur_pass = 0;
  u32 syms_removed, alpha_del0 = 0, alpha_del1, alpha_del2, alpha_d_total = 0;
  u8  changed_any, prev_del;

  /***********************
   * BLOCK NORMALIZATION *
   ***********************/

  if (no_normalize) goto next_pass;
  set_len    = next_p2(in_len / TMIN_SET_STEPS);
  set_pos    = 0;

  if (set_len < TMIN_SET_MIN_SIZE) set_len = TMIN_SET_MIN_SIZE;

  ACTF(cBRI "Stage #0: " cRST "One-time block normalization...");

  while (set_pos < in_len) {

    u8  res;
    u32 use_len = MIN(set_len, in_len - set_pos);

    for (i = 0; i < use_len; i++)
      if (in_data[set_pos + i] != '0') break;

    if (i != use_len) {

      memcpy(tmp_buf, in_data, in_len);
      memset(tmp_buf + set_pos, '0', use_len);

      res = run_target(argv, tmp_buf, in_len, 0);

      if (res) {

        memset(in_data + set_pos, '0', use_len);
        changed_any = 1;
        alpha_del0 += use_len;

      }

    }

    set_pos += set_len;

  }

  alpha_d_total += alpha_del0;

  OKF("Block normalization complete, %u byte%s replaced.", alpha_del0,
      alpha_del0 == 1 ? "" : "s");

next_pass:

  ACTF(cYEL "--- " cBRI "Pass #%u " cYEL "---", ++cur_pass);
  changed_any = 0;

  /******************
   * BLOCK DELETION *
   ******************/

  if (no_minimize) goto alphabet_minimization;
  del_len = next_p2(in_len / TRIM_START_STEPS);
  stage_o_len = in_len;

  ACTF(cBRI "Stage #1: " cRST "Removing blocks of data...");

next_del_blksize:

  if (!del_len) del_len = 1;
  del_pos  = 0;
  prev_del = 1;

  SAYF(cGRA "    Block length = %u, remaining size = %u\n" cRST,
       del_len, in_len);

  while (del_pos < in_len) {

    u8  res;
    s32 tail_len;

    tail_len = in_len - del_pos - del_len;
    if (tail_len < 0) tail_len = 0;

    /* If we have processed at least one full block (initially, prev_del == 1),
       and we did so without deleting the previous one, and we aren't at the
       very end of the buffer (tail_len > 0), and the current block is the same
       as the previous one... skip this step as a no-op. */

    if (!prev_del && tail_len && !memcmp(in_data + del_pos - del_len,
        in_data + del_pos, del_len)) {

      del_pos += del_len;
      continue;

    }

    prev_del = 0;

    /* Head */
    memcpy(tmp_buf, in_data, del_pos);

    /* Tail */
    memcpy(tmp_buf + del_pos, in_data + del_pos + del_len, tail_len);

    res = run_target(argv, tmp_buf, del_pos + tail_len, 0);

    if (res) {

      memcpy(in_data, tmp_buf, (size_t)del_pos + tail_len);
      prev_del = 1;
      in_len   = del_pos + tail_len;

      changed_any = 1;

    } else del_pos += del_len;

  }

  if (del_len > del_len_limit && in_len >= 1) {

    del_len /= 2;
    goto next_del_blksize;

  }

  OKF("Block removal complete, %u bytes deleted.", stage_o_len - in_len);

  if (!in_len && changed_any)
    WARNF(cLRD "Down to zero bytes - check the command line and mem limit!" cRST);

  if (cur_pass > 1 && !changed_any) goto finalize_all;

  /*************************
   * ALPHABET MINIMIZATION *
   *************************/

alphabet_minimization:
  if (no_normalize) goto finalize_all;
  alpha_size   = 0;
  alpha_del1   = 0;
  syms_removed = 0;

  memset(alpha_map, 0, 256 * sizeof(u32));

  for (i = 0; i < in_len; i++) {
    if (!alpha_map[in_data[i]]) alpha_size++;
    alpha_map[in_data[i]]++;
  }

  ACTF(cBRI "Stage #2: " cRST "Minimizing symbols (%u code point%s)...",
       alpha_size, alpha_size == 1 ? "" : "s");

  for (i = 0; i < 256; i++) {

    u32 r;
    u8 res;

    if (i == '0' || !alpha_map[i]) continue;

    memcpy(tmp_buf, in_data, in_len);

    for (r = 0; r < in_len; r++)
      if (tmp_buf[r] == i) tmp_buf[r] = '0';

    res = run_target(argv, tmp_buf, in_len, 0);

    if (res) {

      memcpy(in_data, tmp_buf, in_len);
      syms_removed++;
      alpha_del1 += alpha_map[i];
      changed_any = 1;

    }

  }

  alpha_d_total += alpha_del1;

  OKF("Symbol minimization finished, %u symbol%s (%u byte%s) replaced.",
      syms_removed, syms_removed == 1 ? "" : "s",
      alpha_del1, alpha_del1 == 1 ? "" : "s");

  /**************************
   * CHARACTER MINIMIZATION *
   **************************/

  alpha_del2 = 0;

  ACTF(cBRI "Stage #3: " cRST "Character minimization...");

  memcpy(tmp_buf, in_data, in_len);

  for (i = 0; i < in_len; i++) {

    u8 res, orig = tmp_buf[i];

    if (orig == '0') continue;
    tmp_buf[i] = '0';

    res = run_target(argv, tmp_buf, in_len, 0);

    if (res) {

      in_data[i] = '0';
      alpha_del2++;
      changed_any = 1;

    } else tmp_buf[i] = orig;

  }

  alpha_d_total += alpha_del2;

  OKF("Character minimization done, %u byte%s replaced.",
      alpha_del2, alpha_del2 == 1 ? "" : "s");

  if (changed_any && !single_pass) goto next_pass;

finalize_all:

  SAYF("\n"
       cGRA "      Finished minimizing : " cRST "%hs\n"
       cGRA "     File size reduced by : " cRST "%0.02f%% (to %u byte%s)\n"
       cGRA "    Characters simplified : " cRST "%0.02f%%\n"
       cGRA "     Number of execs done : " cRST "%u\n"
       cGRA "          Fruitless execs : " cRST "path=%u crash=%u hang=%s%u\n"
       cGRA "             Elapsed time : " cRST "%.3f secs\n\n",
       in_file,
       100 - ((double)in_len) * 100 / orig_len, in_len, in_len == 1 ? "" : "s",
       ((double)(alpha_d_total)) * 100 / (in_len ? in_len : 1),
       total_execs,
       missed_paths, missed_crashes, missed_hangs ? cLRD : "", missed_hangs,
       (GetTickCount64() - start_time) / 1000.0);

  if (total_execs > 50 && missed_hangs * 10 > total_execs)
    WARNF(cLRD "Frequent timeouts - results may be skewed." cRST);

}


/* Do basic preparations - persistent fds, filenames, etc. */

static void set_up_environment(void) {

  if (sinkhole_stds) {
    devnul_handle = CreateFile(
      "nul",
      GENERIC_READ | GENERIC_WRITE,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      NULL,
      OPEN_EXISTING,
      0,
      NULL
    );

    if (devnul_handle == INVALID_HANDLE_VALUE) {
      PFATAL("Unable to open the nul device.");
    }
  }

  if (!prog_in) {

    u8* use_dir = getenv("TMP");
    prog_in = alloc_printf("%s\\.afl-tmin-temp-%u", use_dir, getpid());

  }

}


/* Handle stop signal (Ctrl-C, etc). */

static void handle_stop_sig(int sig) {

  u8 dump_path[MAX_PATH];
  DWORD num_read = 0;

  stop_soon = 1;

  destroy_target_process(-1);

  if (dump_on_abort) {
    // Dump to a file whatever was achieved so far - even if we're not done
    strcpy_s(dump_path, MAX_PATH, out_file);
    strcat_s(dump_path, MAX_PATH, ".dmp");

    write_to_file(dump_path, in_data, in_len);

    ACTF("Dumped partially-minimized file to: %hs", dump_path);
  }
  Sleep(200); // Allow time for other cleanup

  exit(1);

}


/* Setup signal handlers, duh. */

static void setup_signal_handlers(void) {
  signal(SIGINT, handle_stop_sig);
  //signal(SIGTERM, handle_stop_sig);
  //signal(SIGBREAK, handle_stop_sig);
  //signal(SIGABRT, handle_stop_sig);
}


/* Detect @@ in args. */

static void detect_file_args(char** argv) {

  u32 i = 0;
  u8* cwd = getcwd(NULL, 0);

  if (!cwd) PFATAL("getcwd() failed");

  while (argv[i]) {

    u8* aa_loc = strstr(argv[i], "@@");

    if (aa_loc) {

      u8 *aa_subst, *n_arg;

      aa_subst = prog_in;

      /* Construct a replacement argv value. */

      *aa_loc = 0;
      n_arg = alloc_printf("%s%s%s", argv[i], aa_subst, aa_loc + 2);
      argv[i] = n_arg;
      *aa_loc = '@';

      //if (out_file[0] != '\\') ck_free(aa_subst);

    }

    i++;

  }

  free(cwd); /* not tracked */

}


/* Display usage hints. */

static void usage(u8* argv0) {

  SAYF("\n%s [ options ] -- [instrumentation options] -- \\path\\to\\target_app [ ... ]\n\n"

       "Required parameters:\n\n"

       "  -i file       - input test case to be shrunk by the tool\n"
       "  -o file       - final output location for the minimized data\n\n"

       "Instrumentation type:\n\n"
       "  -D dir        - directory with DynamoRIO binaries (drrun, drconfig)\n"
       "  -w winafl     - Path to winafl.dll\n"
       "  -Y            - enable the static instrumentation mode\n\n"

       "Execution control settings:\n\n"

       "  -f file       - input file read by the tested program (stdin)\n"
       "  -t msec       - timeout for each run (%u ms)\n"
       "  -m megs       - memory limit for child process (%u MB)\n"

       "Minimization settings:\n\n"

       "  -e            - solve for edge coverage only, ignore hit counts\n"
       "  -l bytes      - set minimum block deletion length to speed up minimization\n"
       "  -x            - treat non-zero exit codes as crashes\n"
       "  -N            - only normalize, skip length minimization. Implies -S\n"
       "  -M            - only minimize length, skip normalization. Implies -S\n"
       "  -S            - single pass only\n\n"

       "Other stuff:\n\n"

       "  -V            - show version number and exit\n\n"

       "For additional tips, please consult %s/README.\n\n",

       argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);

  exit(1);

}


/* Find binary. */

static void find_binary(u8* fname) {
  // Not implemented on Windows
}


/* Read mask bitmap from file. This is for the -B option. */

static void read_bitmap(u8* fname) {

  s32 fd = _open(fname, O_RDONLY | O_BINARY);

  if (fd < 0) PFATAL("Unable to open '%s'", fname);

  ck_read(fd, mask_bitmap, MAP_SIZE, fname);

  _close(fd);

}

static unsigned int optind;
static char *optarg;

int getopt(int argc, char **argv, char *optstring) {
  char *c;

  optarg = NULL;

  while(1) {
    if(optind == argc) return -1;
    if(strcmp(argv[optind], "--") == 0) return -1;
    if(argv[optind][0] != '-') {
      optind++;
      continue;
    }
    if(!argv[optind][1]) {
      optind++;
      continue;
    }

    c = strchr(optstring, argv[optind][1]);
    if(!c) return -1;
    optind++;
    if(c[1] == ':') {
      if(optind == argc) return -1;
      optarg = argv[optind];
      optind++;
    }

    return (int)(c[0]);
  }
}


static void extract_client_params(u32 argc, char** argv) {
  u32 len = 1, i;
  u32 nclientargs = 0;
  u8* buf;
  u32 opt_start, opt_end;

  if(!argv[optind] || optind >= argc) usage(argv[0]);
  if(strcmp(argv[optind],"--")) usage(argv[0]);

  if(drioless) return;
  optind++;
  opt_start = optind;

  for (i = optind; i < argc; i++) {
    if(strcmp(argv[i],"--") == 0) break;
    nclientargs++;
    len += strlen(argv[i]) + 1;
  }

  if(i == argc) usage(argv[0]);
  opt_end = i;

  buf = client_params = ck_alloc(len);

  for (i = opt_start; i < opt_end; i++) {

    u32 l = strlen(argv[i]);

    memcpy(buf, argv[i], l);
    buf += l;

    *(buf++) = ' ';
  }

  if(buf != client_params) {
    buf--;
  }

  *buf = 0;

  optind = opt_end;

}


/* Main entry point */

int main(int argc, char** argv) {

  s32 opt;
  u8  mem_limit_given = 0, timeout_given = 0, del_limit_given = 0;
  char** use_argv;
  errno_t status;

  start_time = GetTickCount64();
  doc_path = "docs";
  optind = 1;
  dynamorio_dir = NULL;
  client_params = NULL;
  winafl_dll_path = NULL;

#ifdef USE_COLOR
  enable_ansi_console();
#endif

  SAYF(cCYA "afl-tmin for Windows " cBRI VERSION cRST " by <0vercl0k@tuxfamily.org>\n");
  SAYF("Based on WinAFL " cBRI VERSION cRST " by <ifratric@google.com>\n");
  SAYF("Based on AFL " cBRI VERSION cRST " by <lcamtuf@google.com>\n");

  while ((opt = getopt(argc,argv,"+i:o:w:f:m:t:B:D:l:xeQYVNMS")) > 0)

    switch (opt) {

      case 'D': /* dynamorio dir */

        if(dynamorio_dir) FATAL("Multiple -D options not supported");
        dynamorio_dir = optarg;
        break;

      case 'i':

        if (in_file) FATAL("Multiple -i options not supported");
        in_file = optarg;
        break;

      case 'o':

        if (out_file) FATAL("Multiple -o options not supported");
        out_file = optarg;
        status = _access_s(out_file, 2); // Check writability
        if (status != 0 && GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            if (status == ENOENT && GetLastError() == ERROR_PATH_NOT_FOUND) FATAL("Output folder doesn't exist");
            FATAL("Output path not writable. status=%d, GLE=%lu", status, GetLastError());
        }
        break;

      case 'w': /* winafl.dll path */

        if (winafl_dll_path) FATAL("Multiple -w options not supported");
        winafl_dll_path = optarg;
        break;

      case 'f':

        if (prog_in) FATAL("Multiple -f options not supported");
        use_stdin = 0;
        prog_in   = optarg;
        break;

      case 'e':

        if (edges_only) FATAL("Multiple -e options not supported");
        edges_only = 1;
        break;

      case 'x':

        if (exit_crash) FATAL("Multiple -x options not supported");
        exit_crash = 1;
        break;

      case 'm': {

          u8 suffix = 'M';

          if (mem_limit_given) FATAL("Multiple -m options not supported");
          mem_limit_given = 1;

          if (!strcmp(optarg, "none")) {

            mem_limit = 0;
            break;

          }

          if (sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1 ||
              optarg[0] == '-') FATAL("Bad syntax used for -m");

          switch (suffix) {

            case 'T': mem_limit *= 1024 * 1024; break;
            case 'G': mem_limit *= 1024; break;
            case 'k': mem_limit /= 1024; break;
            case 'M': break;

            default:  FATAL("Unsupported suffix or bad syntax for -m");

          }

          if (mem_limit < 5) FATAL("Dangerously low value of -m");

          if (sizeof(int) == 4 && mem_limit > 2000)
            FATAL("Value of -m out of range on 32-bit systems");

        }

        break;

      case 't':

        if (timeout_given) FATAL("Multiple -t options not supported");
        timeout_given = 1;

        exec_tmout = atoi(optarg);

        if (exec_tmout < 10 || optarg[0] == '-')
          FATAL("Dangerously low value of -t");

        break;

      case 'l':
        if (del_limit_given) FATAL("Multiple -l options not supported");
        del_limit_given = 1;

        if (no_minimize) FATAL("-M and -l incompatible");

        if (!optarg) FATAL("Wrong usage of -l");
        if (optarg[0] == '-') FATAL("Dangerously low value of -l");

        del_len_limit = atoi(optarg);
        if (del_len_limit < 1 || del_len_limit > TMIN_MAX_FILE) FATAL("Value of -l out of range between 1 and TMIN_MAX_FILE");

        break;

      case 'B': /* load bitmap */

        /* This is a secret undocumented option! It is speculated to be useful
           if you have a baseline "boring" input file and another "interesting"
           file you want to minimize.

           You can dump a binary bitmap for the boring file using
           afl-showmap -b, and then load it into afl-tmin via -B. The minimizer
           will then minimize to preserve only the edges that are unique to
           the interesting input file, but ignoring everything from the
           original map.

           The option may be extended and made more official if it proves
           to be useful. */

        if (mask_bitmap) FATAL("Multiple -B options not supported");
        mask_bitmap = ck_alloc(MAP_SIZE);
        read_bitmap(optarg);
        break;

      case 'Q':
        FATAL("QEMU mode not supported on Windows");
        break;

      case 'Y':

        if (dynamorio_dir) FATAL("Dynamic-instrumentation via DRIO is uncompatible with static-instrumentation");
        drioless = 1;

        break;

      case 'V': /* Show version number */

        /* Version number has been printed already, just quit. */
        exit(0);

      case 'N':

        if (no_minimize) FATAL("Multiple -N options not supported");
        if (no_normalize) FATAL("-N and -M mutually exclusive");
        no_minimize = 1;
        break;

      case 'M':

        if (no_normalize) FATAL("Multiple -M options not supported");
        if (no_minimize) FATAL("-N and -M mutually exclusive");
        if (del_limit_given) FATAL("-M and -l incompatible");
        no_normalize = 1;
        break;

      case 'S':

        if (single_pass) FATAL("Multiple -S options not supported");
        single_pass = 1;
        break;


      default:

        usage(argv[0]);

    }

  if(!in_file || !out_file) usage(argv[0]);
  if(!drioless) {
    if(optind == argc || !dynamorio_dir) usage(argv[0]);
  }
  if (no_normalize || no_minimize) single_pass = 1;

  extract_client_params(argc, argv);
  optind++;

  if (getenv("AFL_NO_SINKHOLE")) sinkhole_stds = 0;
  if (getenv("AFL_TMIN_EXACT")) exact_mode = 1;
  if (getenv("AFL_TMIN_DONT_DUMP_ON_ABORT")) dump_on_abort = 0;

  setup_shm();
  setup_watchdog_timer();

  set_up_environment();

  find_binary(argv[optind]);
  detect_file_args(argv + optind);

  use_argv = argv + optind;

  SAYF("\n");

  read_initial_file();
  setup_signal_handlers();

  ACTF("Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...",
       mem_limit, exec_tmout, edges_only ? ", edges only" : "");

  run_target(use_argv, in_data, in_len, 1);

  if (child_timed_out)
    FATAL("Target binary times out (adjusting -t may help).");

  if (!crash_mode) {

     OKF("Program terminates normally, minimizing in "
         cCYA "instrumented" cRST " mode.");

     if (!anything_set()) FATAL("No instrumentation detected.");

  } else {

     OKF("Program exits with a signal, minimizing in " cMGN "%scrash" cRST
         " mode.", exact_mode ? "EXACT " : "");

  }

  minimize(use_argv);

  ACTF("Writing output to '%s'...", out_file);

  unlink(prog_in);
  prog_in = NULL;

  write_to_file(out_file, in_data, in_len);

  OKF("We're done here. Have a nice day!\n");

  exit(0);

}

```

`afl_docs/COPYING`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`afl_docs/ChangeLog`:

```
=========
ChangeLog
=========

  This is the list of all noteworthy changes made in every public release of
  the tool. See README for the general instruction manual.

----------------
Staying informed
----------------

Want to stay in the loop on major new features? Join our mailing list by
sending a mail to <afl-users+subscribe@googlegroups.com>.

Not sure if you should upgrade? The lowest currently recommended version
is 1.92b. If you're stuck on an earlier release, it's strongly advisable
to get on with the times.

--------------
Version 1.96b:
--------------

  - Added -fpic to CFLAGS for the clang plugin, as suggested by Hanno Boeck.

  - Made another clang change (IRBuilder) suggested by Jeff Trull.

  - Fixed several typos, spotted by Jakub Wilk.

  - Added support for AFL_SHUFFLE_QUEUE, based on discussions with
    Christian Holler.

--------------
Version 1.95b:
--------------

  - Fixed a harmless bug when handling -B. Spotted by Jacek Wielemborek.

  - Made the exit message a bit more accurate when AFL_EXIT_WHEN_DONE is set.

  - Added some error-checking for old-style forkserver syntax. Suggested by
    Ben Nagy.

  - Switched from exit() to _exit() in injected code to avoid snafus with
    destructors in C++ code. Spotted by sunblate.

  - Made a change to avoid spuriously setting __AFL_SHM_ID when 
    AFL_DUMB_FORKSRV is set in conjunction with -n. Spotted by Jakub Wilk.

--------------
Version 1.94b:
--------------

  - Changed allocator alignment to improve support for non-x86 systems (now
    that llvm_mode makes this more feasible).

  - Fixed a minor typo in afl-cmin. Spotted by Jonathan Neuschafer.

  - Fixed an obscure bug that would affect people trying to use afl-gcc
    with $TMP set but $TMPDIR absent. Spotted by Jeremy Barnes.

--------------
Version 1.93b:
--------------

  - Hopefully fixed a problem with MacOS X and persistent mode, spotted by
    Leo Barnes.

--------------
Version 1.92b:
--------------

  - Made yet another C++ fix (namespaces). Reported by Daniel Lockyer.

--------------
Version 1.91b:
--------------

  - Made another fix to make 1.90b actually work properly with C++ (d'oh).
    Problem spotted by Daniel Lockyer.

--------------
Version 1.90b:
--------------

  - Fixed a minor typo spotted by Kai Zhao; and made several other minor updates
    to docs.

  - Updated the project URL for python-afl. Requested by Jakub Wilk.

  - Fixed a potential problem with deferred mode signatures getting optimized
    out by the linker (with --gc-sections).

--------------
Version 1.89b:
--------------

  - Revamped the support for persistent and deferred forkserver modes.
    Both now feature simpler syntax and do not require companion env
    variables. Suggested by Jakub Wilk.

  - Added a bit more info about afl-showmap. Suggested by Jacek Wielemborek.

--------------
Version 1.88b:
--------------

  - Made AFL_EXIT_WHEN_DONE work in non-tty mode. Issue spotted by
    Jacek Wielemborek.

--------------
Version 1.87b:
--------------

  - Added QuickStartGuide.txt, a one-page quick start doc.

  - Fixed several typos spotted by Dominique Pelle.

  - Revamped several parts of README.

--------------
Version 1.86b:
--------------

  - Added support for AFL_SKIP_CRASHES, which is a very hackish solution to
    the problem of resuming sessions with intermittently crashing inputs.

  - Removed the hard-fail terminal size check, replaced with a dynamic
    warning shown in place of the UI. Based on feedback from Christian Holler.

  - Fixed a minor typo in show_stats. Spotted by Dingbao Xie.

--------------
Version 1.85b:
--------------

  - Fixed a garbled sentence in notes on parallel fuzzing. Thanks to Jakub Wilk.

  - Fixed a minor glitch in afl-cmin. Spotted by Jonathan Foote.

--------------
Version 1.84b:
--------------

  - Made SIMPLE_FILES behave as expected when naming backup directories for
    crashes and hangs.

  - Added the total number of favored paths to fuzzer_stats. Requested by
    Ben Nagy.

  - Made afl-tmin, afl-fuzz, and afl-cmin reject negative values passed to
    -t and -m, since they generally won't work as expected.

  - Made a fix for no lahf / sahf support on older versions of FreeBSD.
    Patch contributed by Alex Moneger.

--------------
Version 1.83b:
--------------

  - Fixed a problem with xargs -d on non-Linux systems in afl-cmin. Spotted by
    teor2345 and Ben Nagy.

  - Fixed an implicit declaration in LLVM mode on MacOS X. Reported by 
    Kai Zhao.

--------------
Version 1.82b:
--------------

  - Fixed a harmless but annoying race condition in persistent mode - signal
    delivery is a bit more finicky than I thought.

  - Updated the documentation to explain persistent mode a bit better.

  - Tweaked AFL_PERSISTENT to force AFL_NO_VAR_CHECK.

--------------
Version 1.81b:
--------------

  - Added persistent mode for in-process fuzzing. See llvm_mode/README.llvm.
    Inspired by Kostya Serebryany and Christian Holler.

  - Changed the in-place resume code to preserve crashes/README.txt. Suggested
    by Ben Nagy.

  - Included a potential fix for LLVM mode issues on MacOS X, based on the
    investigation done by teor2345.

--------------
Version 1.80b:
--------------

  - Made afl-cmin tolerant of whitespaces in filenames. Suggested by 
    Jonathan Neuschafer and Ketil Froyn.

  - Added support for AFL_EXIT_WHEN_DONE, as suggested by Michael Rash.

--------------
Version 1.79b:
--------------

  - Added support for dictionary levels, see testcases/README.testcases.

  - Reworked the SQL dictionary to use levels.

  - Added a note about Preeny.

--------------
Version 1.78b:
--------------

  - Added a dictionary for PDF, contributed by Ben Nagy.

  - Added several references to afl-cov, a new tool by Michael Rash.

  - Fixed a problem with crash reporter detection on MacOS X, as reported by
    Louis Dassy.

--------------
Version 1.77b:
--------------

  - Extended the -x option to support single-file dictionaries.

  - Replaced factory-packaged dictionaries with file-based variants.

  - Removed newlines from HTML keywords in testcases/_extras/html/.

--------------
Version 1.76b:
--------------

  - Very significantly reduced the number of duplicate execs during
    deterministic checks, chiefly in int16 and int32 stages. Confirmed
    identical path yields. This should improve early-stage efficiency by
    around 5-10%.

  - Reduced the likelihood of duplicate non-deterministic execs by
    bumping up lowest stacking factor from 1 to 2. Quickly confirmed
    that this doesn't seem to have significant impact on coverage with
    libpng.

  - Added a note about integrating afl-fuzz with third-party tools.

--------------
Version 1.75b:
--------------

  - Improved argv_fuzzing to allow it to emit empty args. Spotted by Jakub
    Wilk.

  - afl-clang-fast now defines __AFL_HAVE_MANUAL_INIT. Suggested by Jakub Wilk.

  - Fixed a libtool-related bug with afl-clang-fast that would make some
    ./configure invocations generate incorrect output. Spotted by Jakub Wilk.

  - Removed flock() on Solaris. This means no locking on this platform,
    but so be it. Problem reported by Martin Carpenter.

  - Fixed a typo. Reported by Jakub Wilk.

--------------
Version 1.74b:
--------------

  - Added an example argv[] fuzzing wrapper in experimental/argv_fuzzing.
    Reworked the bash example to be faster, too.

  - Clarified llvm_mode prerequisites for FreeBSD.

  - Improved afl-tmin to use /tmp if cwd is not writeable.

  - Removed redundant includes for sys/fcntl.h, which caused warnings with
    some nitpicky versions of libc.

  - Added a corpus of basic HTML tags that parsers are likely to pay attention
    to (no attributes).

  - Added EP_EnabledOnOptLevel0 to llvm_mode, so that the instrumentation is
    inserted even when AFL_DONT_OPTIMIZE=1 is set.

  - Switched qemu_mode to use the newly-released QEMU 2.3.0, which contains
    a couple of minor bugfixes.

--------------
Version 1.73b:
--------------

  - Fixed a pretty stupid bug in effector maps that could sometimes cause
    AFL to fuzz slightly more than necessary; and in very rare circumstances,
    could lead to SEGV if eff_map is aligned with page boundary and followed
    by an unmapped page. Spotted by Jonathan Gray.

--------------
Version 1.72b:
--------------

  - Fixed a glitch in non-x86 install, spotted by Tobias Ospelt.

  - Added a minor safeguard to llvm_mode Makefile following a report from
    Kai Zhao.

--------------
Version 1.71b:
--------------

  - Fixed a bug with installed copies of AFL trying to use QEMU mode. Spotted
    by G.M. Lime.

  - Added last path / crash / hang times to fuzzer_stats, suggested by
    Richard Hipp.

  - Fixed a typo, thanks to Jakub Wilk.

--------------
Version 1.70b:
--------------

  - Modified resumption code to reuse the original timeout value when resuming
    a session if -t is not given. This prevents timeout creep in continuous
    fuzzing.

  - Added improved error messages for failed handshake when AFL_DEFER_FORKSRV
    is set.

  - Made a slight improvement to llvm_mode/Makefile based on feedback from
    Jakub Wilk.

  - Refreshed several bits of documentation.

  - Added a more prominent note about the MacOS X trade-offs to Makefile.

--------------
Version 1.69b:
--------------

  - Added support for deferred initialization in LLVM mode. Suggested by
    Richard Godbee.

--------------
Version 1.68b:
--------------

  - Fixed a minor PRNG glitch that would make the first seconds of a fuzzing
    job deterministic. Thanks to Andreas Stieger.

  - Made tmp[] static in the LLVM runtime to keep Valgrind happy (this had
    no impact on anything else). Spotted by Richard Godbee.

  - Clarified the footnote in README.

--------------
Version 1.67b:
--------------

  - Made one more correction to llvm_mode Makefile, spotted by Jakub Wilk.

--------------
Version 1.66b:
--------------

  - Added CC / CXX support to llvm_mode Makefile. Requested by Charlie Eriksen.

  - Fixed 'make clean' with gmake. Suggested by Oliver Schneider.

  - Fixed 'make -j n clean all'. Suggested by Oliver Schneider.

  - Removed build date and time from banners to give people deterministic
    builds. Requested by Jakub Wilk.

--------------
Version 1.65b:
--------------

  - Fixed a snafu with some leftover code in afl-clang-fast.

  - Corrected even moar typos.

--------------
Version 1.64b:
--------------

  - Further simplified afl-clang-fast runtime by reverting .init_array to
    __attribute__((constructor(0)). This should improve compatibility with
    non-ELF platforms.

  - Fixed a problem with afl-clang-fast and -shared libraries. Simplified
    the code by getting rid of .preinit_array and replacing it with a .comm
    object. Problem reported by Charlie Eriksen.

  - Removed unnecessary instrumentation density adjustment for the LLVM mode.
    Reported by Jonathan Neuschafer.

--------------
Version 1.63b:
--------------

  - Updated cgroups_asan/ with a new version from Sam, made a couple changes
    to streamline it and keep parallel afl instances in separate groups.

  - Fixed typos, thanks to Jakub Wilk.

--------------
Version 1.62b:
--------------

  - Improved the handling of -x in afl-clang-fast,

  - Improved the handling of low AFL_INST_RATIO settings for QEMU and
    LLVM modes.

  - Fixed the llvm-config bug for good (thanks to Tobias Ospelt).

--------------
Version 1.61b:
--------------

  - Fixed an obscure bug compiling OpenSSL with afl-clang-fast. Patch by
    Laszlo Szekeres.

  - Fixed a 'make install' bug on non-x86 systems, thanks to Tobias Ospelt.

  - Fixed a problem with half-broken llvm-config on Odroid, thanks to
    Tobias Ospelt. (There is another odd bug there that hasn't been fully
    fixed - TBD).

--------------
Version 1.60b:
--------------

  - Allowed experimental/llvm_instrumentation/ to graduate to llvm_mode/.

  - Removed experimental/arm_support/, since it's completely broken and likely
    unnecessary with LLVM support in place.

  - Added ASAN cgroups script to experimental/asan_cgroups/, updated existing
    docs. Courtesy Sam Hakim and David A. Wheeler.

  - Refactored afl-tmin to reduce the number of execs in common use cases.
    Ideas from Jonathan Neuschafer and Turo Lamminen.

  - Added a note about CLAs at the bottom of README.

  - Renamed testcases_readme.txt to README.testcases for some semblance of
    consistency.

  - Made assorted updates to docs.

  - Added MEM_BARRIER() to afl-showmap and afl-tmin, just to be safe.

--------------
Version 1.59b:
--------------

  - Imported Laszlo Szekeres' experimental LLVM instrumentation into
    experimental/llvm_instrumentation. I'll work on including it in the 
    "mainstream" version soon.

  - Fixed another typo, thanks to Jakub Wilk.

--------------
Version 1.58b:
--------------

  - Added a workaround for abort() behavior in -lpthread programs in QEMU mode.
    Spotted by Aidan Thornton.

  - Made several documentation updates, including links to the static
    instrumentation tool (sister_projects.txt).

--------------
Version 1.57b:
--------------

  - Fixed a problem with exception handling on some versions of MacOS X.
    Spotted by Samir Aguiar and Anders Wang Kristensen.

  - Tweaked afl-gcc to use BIN_PATH instead of a fixed string in help
    messages.

--------------
Version 1.56b:
--------------

  - Renamed related_work.txt to historical_notes.txt.

  - Made minor edits to the ASAN doc.

  - Added docs/sister_projects.txt with a list of inspired or closely
    related utilities.

--------------
Version 1.55b:
--------------

  - Fixed a glitch with afl-showmap opening /dev/null with O_RDONLY when
    running in quiet mode. Spotted by Tyler Nighswander.

--------------
Version 1.54b:
--------------

  - Added another postprocessor example for PNG.

  - Made a cosmetic fix to realloc() handling in experimental/post_library/,
    suggested by Jakub Wilk.

  - Improved -ldl handling. Suggested by Jakub Wilk.

--------------
Version 1.53b:
--------------

  - Fixed an -l ordering issue that is apparently still a problem on Ubuntu.
    Spotted by William Robinet.

--------------
Version 1.52b:
--------------

  - Added support for file format postprocessors. Requested by Ben Nagy. This
    feature is intentionally buried, since it's fairly easy to misuse and
    useful only in some scenarios. See experimental/post_library/.

--------------
Version 1.51b:
--------------

  - Made it possible to properly override LD_BIND_NOW after one very unusual
    report of trouble.

  - Cleaned up typos, thanks to Jakub Wilk.

  - Fixed a bug in AFL_DUMB_FORKSRV.

--------------
Version 1.50b:
--------------

  - Fixed a flock() bug that would prevent dir reuse errors from kicking
    in every now and then.

  - Renamed references to ppvm (the project is now called recidivm).

  - Made improvements to file descriptor handling to avoid leaving some fds
    unnecessarily open in the child process.

  - Fixed a typo or two.

--------------
Version 1.49b:
--------------

  - Added code to save original command line in fuzzer_stats and
    crashes/README.txt. Also saves fuzzer version in fuzzer_stats.
    Requested by Ben Nagy.

--------------
Version 1.48b:
--------------

  - Fixed a bug with QEMU fork server crashes when translation is attempted
    after a jump to an invalid pointer in the child process (i.e., after
    bumping into a particularly nasty security bug in the tested binary).
    Reported by Tyler Nighswander.

--------------
Version 1.47b:
--------------

  - Fixed a bug with afl-cmin in -Q mode complaining about binary being not
    instrumented. Thanks to Jonathan Neuschafer for the bug report.

  - Fixed another bug with argv handling for afl-fuzz in -Q mode. Reported
    by Jonathan Neuschafer.

  - Improved the use of colors when showing crash counts in -C mode.

--------------
Version 1.46b:
--------------

  - Improved instrumentation performance on 32-bit systems by getting rid of
    xor-swap (oddly enough, xor-swap is still faster on 64-bit) and tweaking
    alignment.

  - Made path depth numbers more accurate with imported test cases.

--------------
Version 1.45b:
--------------

  - Added support for SIMPLE_FILES in config.h for folks who don't like
    descriptive file names. Generates very simple names without colons,
    commas, plus signs, dashes, etc.

  - Replaced zero-sized files with symlinks in the variable behavior state
    dir to simplify examining the relevant test cases.

  - Changed the period of limited-range block ops from 5 to 10 minutes based
    on a couple of experiments. The basic goal of this delay timer behavior
    is to better support jobs that are seeded with completely invalid files,
    in which case, the first few queue cycles may be completed very quickly
    without discovering new paths. Should have no effect on well-seeded jobs.

  - Made several minor updates to docs.

--------------
Version 1.44b:
--------------

  - Corrected two bungled attempts to get the -C mode work properly
    with afl-cmin (accounting for the short-lived releases tagged 1.42 and
    1.43b) - sorry.

  - Removed AFL_ALLOW_CRASHES in favor of the -C mode in said tool.

  - Said goodbye to Hello Kitty, as requested by Padraig Brady.

--------------
Version 1.41b:
--------------

  - Added AFL_ALLOW_CRASHES=1 to afl-cmin. Allows crashing inputs in the
    output corpus. Changed the default behavior to disallow it.

  - Made the afl-cmin output dir default to 0700, not 0755, to be consistent
    with afl-fuzz; documented the rationale for 0755 in afl-plot.

  - Lowered the output dir reuse time limit to 25 minutes as a dice-roll
    compromise after a discussion on afl-users@.

  - Made afl-showmap accept -o /dev/null without borking out.

  - Added support for crash / hang info in exit codes of afl-showmap.

  - Tweaked block operation scaling to also factor in ballpark run time
    in cases where queue passes take very little time.

  - Fixed typos and made improvements to several docs.

--------------
Version 1.40b:
--------------

  - Switched to smaller block op sizes during the first passes over the
    queue. Helps keep test cases small.

  - Added memory barrier for run_target(), just in case compilers get
    smarter than they are today.

  - Updated a bunch of docs.

--------------
Version 1.39b:
--------------

  - Added the ability to skip inputs by sending SIGUSR1 to the fuzzer.

  - Reworked several portions of the documentation.

  - Changed the code to reset splicing perf scores between runs to keep
    them closer to intended length.

  - Reduced the minimum value of -t to 5 for afl-fuzz (~200 exec/sec)
    and to 10 for auxiliary tools (due to the absence of a fork server).

  - Switched to more aggressive default timeouts (rounded up to 25 ms
    versus 50 ms - ~40 execs/sec) and made several other cosmetic changes
    to the timeout code.

--------------
Version 1.38b:
--------------

  - Fixed a bug in the QEMU build script, spotted by William Robinet.

  - Improved the reporting of skipped bitflips to keep the UI counters a bit
    more accurate.

  - Cleaned up related_work.txt and added some non-goals.

  - Fixed typos, thanks to Jakub Wilk.

--------------
Version 1.37b:
--------------

  - Added effector maps, which detect regions that do not seem to respond
    to bitflips and subsequently exclude them from more expensive steps
    (arithmetics, known ints, etc). This should offer significant performance
    improvements with quite a few types of text-based formats, reducing the
    number of deterministic execs by a factor of 2 or so.

  - Cleaned up mem limit handling in afl-cmin.

  - Switched from uname -i to uname -m to work around Gentoo-specific
    issues with coreutils when building QEMU. Reported by William Robinet.

  - Switched from PID checking to flock() to detect running sessions.
    Problem, against all odds, bumped into by Jakub Wilk.

  - Added SKIP_COUNTS and changed the behavior of COVERAGE_ONLY in config.h.
    Useful only for internal benchmarking.

  - Made improvements to UI refresh rates and exec/sec stats to make them
    more stable.

  - Made assorted improvements to the documentation and to the QEMU build
    script.

  - Switched from perror() to strerror() in error macros, thanks to Jakub
    Wilk for the nag.

  - Moved afl-cmin back to bash, wasn't thinking straight. It has to stay
    on bash because other shells may have restrictive limits on array sizes.

--------------
Version 1.36b:
--------------

  - Switched afl-cmin over to /bin/sh. Thanks to Jonathan Gray.

  - Fixed an off-by-one bug in queue limit check when resuming sessions
    (could cause NULL ptr deref if you are *really* unlucky).

  - Fixed the QEMU script to tolerate i686 if returned by uname -i. Based on
    a problem report from Sebastien Duquette.

  - Added multiple references to Jakub's ppvm tool.

  - Made several minor improvements to the Makefile.

  - Believe it or not, fixed some typos. Thanks to Jakub Wilk.

--------------
Version 1.35b:
--------------

  - Cleaned up regular expressions in some of the scripts to avoid errors
    on *BSD systems. Spotted by Jonathan Gray.

--------------
Version 1.34b:
--------------

  - Performed a substantial documentation and program output cleanup to
    better explain the QEMU feature.

--------------
Version 1.33b:
--------------

  - Added support for AFL_INST_RATIO and AFL_INST_LIBS in the QEMU mode.

  - Fixed a stack allocation crash in QEMU mode (bug in QEMU, fixed with
    an extra patch applied to the downloaded release).

  - Added code to test the QEMU instrumentation once the afl-qemu-trace
    binary is built.

  - Modified afl-tmin and afl-showmap to search $PATH for binaries and to
    better handle QEMU support.

  - Added a check for instrumented binaries when passing -Q to afl-fuzz.

--------------
Version 1.32b:
--------------

  - Fixed 'make install' following the QEMU changes. Spotted by Hanno Boeck.

  - Fixed EXTRA_PAR handling in afl-cmin.

--------------
Version 1.31b:
--------------

  - Hallelujah! Thanks to Andrew Griffiths, we now support very fast, black-box
    instrumentation of binary-only code. See qemu_mode/README.qemu.

    To use this feature, you need to follow the instructions in that
    directory and then run afl-fuzz with -Q.

--------------
Version 1.30b:
--------------

  - Added -s (summary) option to afl-whatsup. Suggested by Jodie Cunningham.

  - Added a sanity check in afl-tmin to detect minimization to zero len or
    excess hangs.

  - Fixed alphabet size counter in afl-tmin.

  - Slightly improved the handling of -B in afl-fuzz.

  - Fixed process crash messages with -m none.

--------------
Version 1.29b:
--------------

  - Improved the naming of test cases when orig: is already present in the file
    name.

  - Made substantial improvements to technical_details.txt.

--------------
Version 1.28b:
--------------

  - Made a minor tweak to the instrumentation to preserve the directionality
    of tuples (i.e., A -> B != B -> A) and to maintain the identity of tight
    loops (A -> A). You need to recompile targeted binaries to leverage this.

  - Cleaned up some of the afl-whatsup stats.

  - Added several sanity checks to afl-cmin.

--------------
Version 1.27b:
--------------

  - Made afl-tmin recursive. Thanks to Hanno Boeck for the tip.

  - Added docs/technical_details.txt.

  - Changed afl-showmap search strategy in afl-cmap to just look into the
    same place that afl-cmin is executed from. Thanks to Jakub Wilk.

  - Removed current_todo.txt and cleaned up the remaining docs.

--------------
Version 1.26b:
--------------

  - Added total execs/sec stat for afl-whatsup.

  - afl-cmin now auto-selects between cp or ln. Based on feedback from
    Even Huus.

  - Fixed a typo. Thanks to Jakub Wilk.

  - Made afl-gotcpu a bit more accurate by using getrusage instead of
    times. Thanks to Jakub Wilk.

  - Fixed a memory limit issue during the build process on NetBSD-current.
    Reported by Thomas Klausner.

--------------
Version 1.25b:
--------------

  - Introduced afl-whatsup, a simple tool for querying the status of
    local synced instances of afl-fuzz.

  - Added -x compiler to clang options on Darwin. Suggested by Filipe
    Cabecinhas.

  - Improved exit codes for afl-gotcpu.

  - Improved the checks for -m and -t values in afl-cmin. Bug report
    from Evan Huus.

--------------
Version 1.24b:
--------------

  - Introduced afl-getcpu, an experimental tool to empirically measure
    CPU preemption rates. Thanks to Jakub Wilk for the idea.

--------------
Version 1.23b:
--------------

  - Reverted one change to afl-cmin that actually made it slower.

--------------
Version 1.22b:
--------------

  - Reworked afl-showmap.c to support normal options, including -o, -q,
    -e. Also added support for timeouts and memory limits.

  - Made changes to afl-cmin and other scripts to accommodate the new
    semantics.

  - Officially retired AFL_EDGES_ONLY.

  - Fixed another typo in afl-tmin, courtesy of Jakub Wilk.

--------------
Version 1.21b:
--------------

  - Graduated minimize_corpus.sh to afl-cmin. It is now a first-class
    utility bundled with the fuzzer. 

  - Made significant improvements to afl-cmin to make it faster, more
    robust, and more versatile.

  - Refactored some of afl-tmin code to make it a bit more readable.

  - Made assorted changes to the doc to document afl-cmin and other stuff.

--------------
Version 1.20b:
--------------

  - Added AFL_DUMB_FORKSRV, as requested by Jakub Wilk. This works only
    in -n mode and allows afl-fuzz to run with "dummy" fork servers that
    don't output any instrumentation, but follow the same protocol.

  - Renamed AFL_SKIP_CHECKS to AFL_SKIP_BIN_CHECK to make it at least
    somewhat descriptive.

  - Switched to using clang as the default assembler on MacOS X to work
    around Xcode issues with newer builds of clang. Testing and patch by
    Nico Weber.

  - Fixed a typo (via Jakub Wilk).

--------------
Version 1.19b:
--------------

  - Improved exec failure detection in afl-fuzz and afl-showmap.

  - Improved Ctrl-C handling in afl-showmap.

  - Added afl-tmin, a handy instrumentation-enabled minimizer.

--------------
Version 1.18b:
--------------

  - Fixed a serious but short-lived bug in the resumption behavior introduced
    in version 1.16b.

  - Added -t nn+ mode for soft-skipping timing-out paths.

--------------
Version 1.17b:
--------------

  - Fixed a compiler warning introduced in 1.16b for newer versions of GCC.
    Thanks to Jakub Wilk and Ilfak Guilfanov.

  - Improved the consistency of saving fuzzer_stats, bitmap info, and
    auto-dictionaries when aborting fuzzing sessions.

  - Made several noticeable performance improvements to deterministic arith
    and known int steps.

--------------
Version 1.16b:
--------------

  - Added a bit of code to make resumption pick up from the last known
    offset in the queue, rather than always rewinding to the start. Suggested
    by Jakub Wilk.

  - Switched to tighter timeout control for slow programs (3x rather than
    5x average exec speed at init).

--------------
Version 1.15b:
--------------

  - Added support for AFL_NO_VAR_CHECK to speed up resumption and inhibit
    variable path warnings for some programs.

  - Made the trimmer run even for variable paths, since there is no special
    harm in doing so and it can be very beneficial if the trimming still
    pans out.

  - Made the UI a bit more descriptive by adding "n/a" instead of "0" in a
    couple of corner cases.

--------------
Version 1.14b:
--------------

  - Added a (partial) dictionary for JavaScript.

  - Added AFL_NO_CPU_RED, as suggested by Jakub Wilk.

  - Tweaked the havoc scaling logic added in 1.12b.

--------------
Version 1.13b:
--------------

  - Improved the performance of minimize_corpus.sh by switching to a
    sort-based approach.

  - Made several minor revisions to the docs.

--------------
Version 1.12b:
--------------

  - Made an improvement to dictionary generation to avoid runs of identical
    bytes.

  - Added havoc cycle scaling to help with slow binaries in -d mode. Based on
    a thread with Sami Liedes.

  - Added AFL_SYNC_FIRST for afl-fuzz. This is useful for those who obsess
    over stats, no special purpose otherwise.

  - Switched to more robust box drawing codes, suggested by Jakub Wilk.

  - Created faster 64-bit variants of several critical-path bitmap functions
    (sorry, no difference on 32 bits).

  - Fixed moar typos, as reported by Jakub Wilk.

--------------
Version 1.11b:
--------------

  - Added a bit more info about dictionary strategies to the status screen.

--------------
Version 1.10b:
--------------

  - Revised the dictionary behavior to use insertion and overwrite in
    deterministic steps, rather than just the latter. This improves coverage
    with SQL and the like.

  - Added a mention of "*" in status_screen.txt, as suggested by Jakub Wilk.

--------------
Version 1.09b:
--------------

  - Corrected a cosmetic problem with 'extras' stage count not always being
    accurate in the stage yields view.

  - Fixed a typo reported by Jakub Wilk and made some minor documentation
    improvements.

--------------
Version 1.08b:
--------------

  - Fixed a div-by-zero bug in the newly-added code when using a dictionary.

--------------
Version 1.07b:
--------------

  - Added code that automatically finds and extracts syntax tokens from the
    input corpus.

  - Fixed a problem with ld dead-code removal option on MacOS X, reported
    by Filipe Cabecinhas.

  - Corrected minor typos spotted by Jakub Wilk.

  - Added a couple of more exotic archive format samples.

--------------
Version 1.06b:
--------------

  - Switched to slightly more accurate (if still not very helpful) reporting
    of short read and short write errors. These theoretically shouldn't happen
    unless you kill the forkserver or run out of disk space. Suggested by
    Jakub Wilk.

  - Revamped some of the allocator and debug code, adding comments and
    cleaning up other mess.

  - Tweaked the odds of fuzzing non-favored test cases to make sure that
    baseline coverage of all inputs is reached sooner.

--------------
Version 1.05b:
--------------

  - Added a dictionary for WebP.

  - Made some additional performance improvements to minimize_corpus.sh,
    getting deeper into the bash woods.

--------------
Version 1.04b:
--------------

  - Made substantial performance improvements to minimize_corpus.sh with
    large datasets, albeit at the expense of having to switch back to bash
    (other shells may have limits on array sizes, etc).

  - Tweaked afl-showmap to support the format used by the new script.

--------------
Version 1.03b:
--------------

  - Added code to skip README.txt in the input directory to make the crash
    exploration mode work better. Suggested by Jakub Wilk.

  - Added a dictionary for SQLite.

--------------
Version 1.02b:
--------------

  - Reverted the ./ search path in minimize_corpus.sh because people did
    not like it.

  - Added very explicit warnings not to run various shell scripts that
    read or write to /tmp/ (since this is generally a pretty bad idea on
    multi-user systems).

  - Added a check for /tmp binaries and -f locations in afl-fuzz.

--------------
Version 1.01b:
--------------

  - Added dictionaries for XML and GIF.

--------------
Version 1.00b:
--------------

  - Slightly improved the performance of minimize_corpus.sh, especially on
    Linux.

  - Made a couple of improvements to calibration timeouts for resumed scans.

--------------
Version 0.99b:
--------------

  - Fixed minimize_corpus.sh to work with dash, as suggested by Jakub Wilk.

  - Modified minimize_corpus.sh to try locate afl-showmap in $PATH and ./.
    The first part requested by Jakub Wilk.

  - Added support for afl-as --version, as required by one funky build
    script. Reported by William Robinet.

--------------
Version 0.98b:
--------------

  - Added a dictionary for TIFF.

  - Fixed another cosmetic snafu with stage exec counts for -x.

  - Switched afl-plot to /bin/sh, since it seems bashism-free. Also tried
    to remove any obvious bashisms from other experimental/ scripts,
    most notably including minimize_corpus.sh and triage_crashes.sh.
    Requested by Jonathan Gray.

--------------
Version 0.97b:
--------------

  - Fixed cosmetic issues around the naming of -x strategy files.

  - Added a dictionary for JPEG.

  - Fixed a very rare glitch when running instrumenting 64-bit code that makes
    heavy use of xmm registers that are also touched by glibc.

--------------
Version 0.96b:
--------------

  - Added support for extra dictionaries, provided testcases/_extras/png/
    as a demo.

  - Fixed a minor bug in number formatting routines used by the UI.

  - Added several additional PNG test cases that are relatively unlikely
    to be hit by chance.

  - Fixed afl-plot syntax for gnuplot 5.x. Reported by David Necas.

--------------
Version 0.95b:
--------------

  - Cleaned up the OSX ReportCrash code. Thanks to Tobias Ospelt for help.

  - Added some extra tips for AFL_NO_FORKSERVER on OSX.

  - Refreshed the INSTALL file.

--------------
Version 0.94b:
--------------

  - Added in-place resume (-i-) to address a common user complaint.

  - Added an awful workaround for ReportCrash on MacOS X. Problem
    spotted by Joseph Gentle.

--------------
Version 0.93b:
--------------

  - Fixed the link() workaround, as reported by Jakub Wilk.

--------------
Version 0.92b:
--------------

  - Added support for reading test cases from another filesystem.
    Requested by Jakub Wilk.

  - Added pointers to the mailing list.

  - Added a sample PDF document.

--------------
Version 0.91b:
--------------

  - Refactored minimize_corpus.sh to make it a bit more user-friendly and to
    select for smallest files, not largest bitmaps. Offers a modest corpus
    size improvement in most cases.

  - Slightly improved the performance of splicing code.

--------------
Version 0.90b:
--------------

  - Moved to an algorithm where paths are marked as preferred primarily based
    on size and speed, rather than bitmap coverage. This should offer
    noticeable performance gains in many use cases.

  - Refactored path calibration code; calibration now takes place as soon as a
    test case is discovered, to facilitate better prioritization decisions later
    on.

  - Changed the way of marking variable paths to avoid .state metadata
    inconsistencies.

  - Made sure that calibration routines always create a new test case to avoid
    hypothetical problems with utilities that modify the input file.

  - Added bitmap saturation to fuzzer stats and plot data.

  - Added a testcase for JPEG XR.

  - Added a tty check for the colors warning in Makefile, to keep distro build
    logs tidy. Suggested by Jakub Wilk.

--------------
Version 0.89b:
--------------

  - Renamed afl-plot.sh to afl-plot, as requested by Padraig Brady.

  - Improved the compatibility of afl-plot with older versions of gnuplot.

  - Added banner information to fuzzer_stats, populated it to afl-plot.

--------------
Version 0.88b:
--------------

  - Added support for plotting, with design and implementation based on a
    prototype design proposed by Michael Rash. Huge thanks!

  - Added afl-plot.sh, which allows you to, well, generate a nice plot using
    this data.

  - Refactored the code slightly to make more frequent updates to fuzzer_stats
    and to provide more detail about synchronization.

  - Added a fflush(stdout) call for non-tty operation, as requested by 
    Joonas Kuorilehto.

  - Added some detail to fuzzer_stats for parity with plot_file.

--------------
Version 0.87b:
--------------

  - Added support for MSAN, via AFL_USE_MSAN, same gotchas as for ASAN.

--------------
Version 0.86b:
--------------

  - Added AFL_NO_FORKSRV, allowing the forkserver to be bypassed. Suggested
    by Ryan Govostes.

  - Simplified afl-showmap.c to make use of the no-forkserver mode.

  - Made minor improvements to crash_triage.sh, as suggested by Jakub Wilk.

--------------
Version 0.85b:
--------------

  - Fixed the CPU counting code - no sysctlbyname() on OpenBSD, d'oh. Bug
    reported by Daniel Dickman.

  - Made a slight correction to error messages - the advice on testing
    with ulimit was a tiny bit off by a factor of 1024.

--------------
Version 0.84b:
--------------

  - Added support for the CPU widget on some non-Linux platforms (I hope).
    Based on feedback from Ryan Govostes.

  - Cleaned up the changelog (very meta).

--------------
Version 0.83b:
--------------

  - Added experimental/clang_asm_normalize/ and related notes in 
    env_variables.txt and afl-as.c. Thanks to Ryan Govostes for the idea.

  - Added advice on hardware utilization in README.

--------------
Version 0.82b:
--------------

  - Made additional fixes for Xcode support, juggling -Q and -q flags. Thanks to
    Ryan Govostes.

  - Added a check for __asm__ blocks and switches to .intel_syntax in assembly.
    Based on feedback from Ryan Govostes.

--------------
Version 0.81b:
--------------

  - A workaround for Xcode 6 as -Q flag glitch. Spotted by Ryan Govostes.

  - Improved Solaris build instructions, as suggested by Martin Carpenter.

  - Fix for a slightly busted path scoring conditional. Minor practical impact.

--------------
Version 0.80b:
--------------

  - Added a check for $PATH-induced loops. Problem noticed by Kartik Agaram.

  - Added AFL_KEEP_ASSEMBLY for easier troubleshooting.

  - Added an override for AFL_USE_ASAN if set at afl compile time. Requested by
    Hanno Boeck.

--------------
Version 0.79b:
--------------

  - Made minor adjustments to path skipping logic.

  - Made several documentation updates to reflect the path selection changes
    made in 0.78b.

--------------
Version 0.78b:
--------------

  - Added a CPU governor check. Bug report from Joe Zbiciak.

  - Favored paths are now selected strictly based on new edges, not hit
    counts. This speeds up the first pass by a factor of 3-6x without
    significantly impacting ultimate coverage (tested with libgif, libpng,
    libjpeg).

    It also allows some performance & memory usage improvements by making
    some of the in-memory bitmaps much smaller.

  - Made multiple significant performance improvements to bitmap checking
    functions, plus switched to a faster hash.

  - Owing largely to these optimizations, bumped the size of the bitmap to
    64k and added a warning to detect older binaries that rely on smaller
    bitmaps.

--------------
Version 0.77b:
--------------

  - Added AFL_SKIP_CHECKS to bypass binary checks when really warranted.
    Feature requested by Jakub Wilk.

  - Fixed a couple of typos.

  - Added a warning for runs that are aborted early on.

--------------
Version 0.76b:
--------------

  - Incorporated another signal handling fix for Solaris. Suggestion
    submitted by Martin Carpenter.

--------------
Version 0.75b:
--------------

  - Implemented a slightly more "elegant" kludge for the %llu glitch (see
    types.h).

  - Relaxed CPU load warnings to stay in sync with reality.

--------------
Version 0.74b:
--------------

  - Switched to more responsive exec speed averages and better UI speed
    scaling.

  - Fixed a bug with interrupted reads on Solaris. Issue spotted by Martin
    Carpenter.

--------------
Version 0.73b:
--------------

  - Fixed a stray memcpy() instead of memmove() on overlapping buffers.
    Mostly harmless but still dumb. Mistake spotted thanks to David Higgs.

--------------
Version 0.72b:
--------------

  - Bumped map size up to 32k. You may want to recompile instrumented
    binaries (but nothing horrible will happen if you don't).

  - Made huge performance improvements for bit-counting functions.

  - Default optimizations now include -funroll-loops. This should have
    interesting effects on the instrumentation. Frankly, I'm just going to
    ship it and see what happens next. I have a good feeling about this.

  - Made a fix for stack alignment crash on MacOS X 10.10; looks like the 
    rhetorical question in the comments in afl-as.h has been answered.
    Tracked down by Mudge Zatko.

--------------
Version 0.71b:
--------------

  - Added a fix for the nonsensical MacOS ELF check. Spotted by Mudge Zatko.

  - Made some improvements to ASAN checks.

--------------
Version 0.70b:
--------------

  - Added explicit detection of ASANified binaries.

  - Fixed compilation issues on Solaris. Reported by Martin Carpenter.

--------------
Version 0.69b:
--------------

  - Improved the detection of non-instrumented binaries.

  - Made the crash counter in -C mode accurate.

  - Fixed an obscure install bug that made afl-as non-functional with the tool
    installed to /usr/bin instead of /usr/local/bin. Found by Florian Kiersch.

  - Fixed for a cosmetic SIGFPE when Ctrl-C is pressed while the fork server
    is spinning up.

--------------
Version 0.68b:
--------------

  - Added crash exploration mode! Woot!

--------------
Version 0.67b:
--------------

  - Fixed several more typos, the project is now cartified 100% typo-free.
    Thanks to Thomas Jarosch and Jakub Wilk.

  - Made a change to write fuzzer_stats early on.

  - Fixed a glitch when (not!) running on MacOS X as root. Spotted by Tobias
    Ospelt.

  - Made it possible to override -O3 in Makefile. Suggested by Jakub Wilk.

--------------
Version 0.66b:
--------------

  - Fixed a very obscure issue with build systems that use gcc as an assembler
    for hand-written .s files; this would confuse afl-as. Affected nss, reported
    by Hanno Boeck.

  - Fixed a bug when cleaning up synchronized fuzzer output dirs. Issue reported
    by Thomas Jarosch.

--------------
Version 0.65b:
--------------

  - Cleaned up shell printf escape codes in Makefile. Reported by Jakub Wilk.

  - Added more color to fuzzer_stats, provided short documentation of the file
    format, and made several other stats-related improvements.

--------------
Version 0.64b:
--------------

  - Enabled GCC support on MacOS X.

--------------
Version 0.63b:
--------------

  - Provided a new, simplified way to pass data in files (@@). See README.

  - Made additional fixes for 64-bit MacOS X, working around a crashing bug in
    their linker (umpf) and several other things. It's alive!

  - Added a minor workaround for a bug in 64-bit FreeBSD (clang -m32 -g doesn't
    work on that platform, but clang -m32 does, so we no longer insert -g).

  - Added a build-time warning for inverse video terminals and better
    instructions in status_screen.txt.

--------------
Version 0.62b:
--------------

  - Made minor improvements to the allocator, as suggested by Tobias Ospelt.

  - Added example instrumented memcmp() in experimental/instrumented_cmp.

  - Added a speculative fix for MacOS X (clang detection, again).

  - Fixed typos in parallel_fuzzing.txt. Problems spotted by Thomas Jarosch.

--------------
Version 0.61b:
--------------

  - Fixed a minor issue with clang detection on systems with a clang cc
    wrapper, so that afl-gcc doesn't confuse it with GCC.

  - Made cosmetic improvements to docs and to the CPU load indicator.

  - Fixed a glitch with crash removal (README.txt left behind, d'oh).

--------------
Version 0.60b:
--------------

  - Fixed problems with jump tables generated by exotic versions of GCC. This
    solves an outstanding problem on OpenBSD when using afl-gcc + PIE (not
    present with afl-clang).

  - Fixed permissions on one of the sample archives.

  - Added a lahf / sahf workaround for OpenBSD (their assembler doesn't know
    about these opcodes).

  - Added docs/INSTALL.

--------------
Version 0.59b:
--------------

  - Modified 'make install' to also install test cases.

  - Provided better pointers to installed README in afl-fuzz.

  - More work on RLIMIT_AS for OpenBSD.

--------------
Version 0.58b:
--------------

  - Added a core count check on Linux.

  - Refined the code for the lack-of-RLIMIT_AS case on OpenBSD.

  - Added a rudimentary CPU utilization meter to help with optimal loading.

--------------
Version 0.57b:
--------------

  - Made fixes to support FreeBSD and OpenBSD: use_64bit is now inferred if not
    explicitly specified when calling afl-as, and RLIMIT_AS is behind an #ifdef.
    Thanks to Fabian Keil and Jonathan Gray for helping troubleshoot this.

  - Modified 'make install' to also install docs (in /usr/local/share/doc/afl).

  - Fixed a typo in status_screen.txt.

  - Made a couple of Makefile improvements as proposed by Jakub Wilk.

--------------
Version 0.56b:
--------------

  - Added probabilistic instrumentation density reduction in ASAN mode. This
    compensates for ASAN-specific branches in a crude but workable way.

  - Updated notes_for_asan.txt.

--------------
Version 0.55b:
--------------

  - Implemented smarter out_dir behavior, automatically deleting directories
    that don't contain anything of special value. Requested by several folks,
    including Hanno Boeck.

  - Added more detail in fuzzer_stats (start time, run time, fuzzer PID).

  - Implemented support for configurable install prefixes in Makefile
    ($PREFIX), as requested by Luca Barbato.

  - Made it possible to resume by doing -i <out_dir>, without having to specify
    -i <out_dir>/queue/.

--------------
Version 0.54b:
--------------

  - Added a fix for -Wformat warning messages (oops, I thought this had been in
    place for a while).

--------------
Version 0.53b:
--------------

  - Redesigned the crash & hang duplicate detection code to better deal with
    fault conditions that can be reached in a multitude of ways.

    The old approach could be compared to hashing stack traces to de-dupe
    crashes, a method prone to crash count inflation. The alternative I
    wanted to avoid would be equivalent to just looking at crash %eip,
    which can have false negatives in common functions such as memcpy().

    The middle ground currently used in afl-fuzz can be compared to looking
    at every line item in the stack trace and tagging crashes as unique if
    we see any function name that we haven't seen before (or if something that
    we have *always* seen there suddenly disappears). We do the comparison
    without paying any attention to ordering or hit counts. This can still
    cause some crash inflation early on, but the problem will quickly taper
    off. So, you may get 20 dupes instead of 5,000.
    
  - Added a fix for harmless but absurd trim ratios shown if the first exec in
    the trimmer timed out. Spotted by @EspenGx.

--------------
Version 0.52b:
--------------

  - Added a quick summary of the contents in experimental/.

  - Made a fix to the process of writing fuzzer_stats.

  - Slightly reorganized the .state/ directory, now recording redundant paths,
    too. Note that this breaks the ability to properly resume older sessions 
    - sorry about that.

    (To fix this, simply move <out_dir>/.state/* from an older run
    to <out_dir>/.state/deterministic_done/*.)

--------------
Version 0.51b:
--------------

  - Changed the search order for afl-as to avoid the problem with older copies
    installed system-wide; this also means that I can remove the Makefile check
    for that.

  - Made it possible to set instrumentation ratio of 0%.

  - Introduced some typos, fixed others.

  - Fixed the test_prev target in Makefile, as reported by Ozzy Johnson.

--------------
Version 0.50b:
--------------

  - Improved the 'make install' logic, as suggested by Padraig Brady.

  - Revamped various bits of the documentation, especially around perf_tips.txt;
    based on the feedback from Alexander Cherepanov.

  - Added AFL_INST_RATIO to afl-as. The only case where this comes handy is
    ffmpeg, at least as far as I can tell. (Trivia: the current version of 
    ffmpeg ./configure also ignores CC and --cc, probably unintentionally).

  - Added documentation for all environmental variables (env_variables.txt).

  - Implemented a visual warning for excessive or insufficient bitmap density.

  - Changed afl-gcc to add -O3 by default; use AFL_DONT_OPTIMIZE if you don't
    like that. Big speed gain for ffmpeg, so seems like a good idea.

  - Made a regression fix to afl-as to ignore .LBB labels in gcc mode.

--------------
Version 0.49b:
--------------

  - Fixed more typos, as found by Jakub Wilk.

  - Added support for clang!

  - Changed AFL_HARDEN to *not* include ASAN by default. Use AFL_USE_ASAN if
    needed. The reasons for this are in notes_for_asan.txt.

  - Switched from configure auto-detection to isatty() to keep afl-as and
    afl-gcc quiet.

  - Improved installation process to properly create symlinks, rather than
    copies of binaries.

--------------
Version 0.48b:
--------------

  - Improved afl-fuzz to force-set ASAN_OPTIONS=abort_on_error=1. Otherwise,
    ASAN crashes wouldn't be caught at all. Reported by Hanno Boeck.

  - Improved Makefile mkdir logic, as suggested by Hanno Boeck.

  - Improved the 64-bit instrumentation to properly save r8-r11 registers in
    the x86 setup code. The old behavior could cause rare problems running
    *without* instrumentation when the first function called in a particular
    .o file has 5+ parameters. No impact on code running under afl-fuzz or
    afl-showmap. Issue spotted by Padraig Brady.

--------------
Version 0.47b:
--------------

  - Fixed another Makefile bug for parallel builds of afl. Problem identified
    by Richard W. M. Jones.

  - Added support for suffixes for -m.

  - Updated the documentation and added notes_for_asan.txt. Based on feedback
    from Hanno Boeck, Ben Laurie, and others.

  - Moved the project to http://lcamtuf.coredump.cx/afl/.

--------------
Version 0.46b:
--------------

  - Cleaned up Makefile dependencies for parallel builds. Requested by 
    Richard W. M. Jones.

  - Added support for DESTDIR in Makefile. Once again suggested by
    Richard W. M. Jones :-)

  - Removed all the USE_64BIT stuff; we now just auto-detect compilation mode.
    As requested by many callers to the show.

  - Fixed rare problems with programs that use snippets of assembly and
    switch between .code32 and .code64. Addresses a glitch spotted by
    Hanno Boeck with compiling ToT gdb.

--------------
Version 0.45b:
--------------

  - Implemented a test case trimmer. Results in 20-30% size reduction for many
    types of work loads, with very pronounced improvements in path discovery
    speeds.

  - Added better warnings for various problems with input directories.

  - Added a Makefile warning for older copies, based on counterintuitive
    behavior observed by Hovik Manucharyan.

  - Added fuzzer_stats file for status monitoring. Suggested by @dronesec.

  - Fixed moar typos, thanks to Alexander Cherepanov.

  - Implemented better warnings for ASAN memory requirements, based on calls
    from several angry listeners.

  - Switched to saner behavior with non-tty stdout (less output generated,
    no ANSI art).

--------------
Version 0.44b:
--------------

  - Added support for AFL_CC and AFL_CXX, based on a patch from Ben Laurie.

  - Replaced afl-fuzz -S -D with -M for simplicity.

  - Added a check for .section .text; lack of this prevented main() from
    getting instrumented for some users. Reported by Tom Ritter.

  - Reorganized the testcases/ directory.

  - Added an extra check to confirm that the build is operational.

  - Made more consistent use of color reset codes, as suggested by Oliver
    Kunz.

--------------
Version 0.43b:
--------------

  - Fixed a bug with 64-bit gcc -shared relocs.

  - Removed echo -e from Makefile for compatibility with dash. Suggested
    by Jakub Wilk.

  - Added status_screen.txt.

  - Added experimental/canvas_harness.

  - Made a minor change to the Makefile GCC check. Suggested by Hanno Boeck.

--------------
Version 0.42b:
--------------

  - Fixed a bug with red zone handling for 64-bit (oops!). Problem reported by
    Felix Groebert.

  - Implemented horribly experimental ARM support in experimental/arm_support.

  - Made several improvements to error messages.

  - Added AFL_QUIET to silence afl-gcc and afl-as when using wonky build
    systems. Reported by Hanno Boeck.

  - Improved check for 64-bit compilation, plus several sanity checks
    in Makefile.

--------------
Version 0.41b:
--------------

  - Fixed a fork served bug for processes that call execve().

  - Made minor compatibility fixes to Makefile, afl-gcc; suggested by Jakub
    Wilk.

  - Fixed triage_crashes.sh to work with the new layout of output directories.
    Suggested by Jakub Wilk.

  - Made multiple performance-related improvements to the injected
    instrumentation.

  - Added visual indication of the number of imported paths.

  - Fixed afl-showmap to make it work well with new instrumentation.

  - Added much better error messages for crashes when importing test cases
    or otherwise calibrating the binary.

--------------
Version 0.40b:
--------------

  - Added support for parallelized fuzzing. Inspired by earlier patch
    from Sebastian Roschke.

  - Added an example in experimental/distributed_fuzzing/.

--------------
Version 0.39b:
--------------

  - Redesigned status screen, now 90% more spiffy.

  - Added more verbose and user-friendly messages for some common problems.

  - Modified the resumption code to reconstruct path depth.

  - Changed the code to inhibit core dumps and improve the ability to detect
    SEGVs.

  - Added a check for redirection of core dumps to programs.

  - Made a minor improvement to the handling of variable paths.

  - Made additional performance tweaks to afl-fuzz, chiefly around mem limits.

  - Added performance_tips.txt.

--------------
Version 0.38b:
--------------

  - Fixed an fd leak and +cov tracking bug resulting from changes in 0.37b.

  - Implemented auto-scaling for screen update speed.

  - Added a visual indication when running in non-instrumented mode.

--------------
Version 0.37b:
--------------

  - Added fuzz state tracking for more seamless resumption of aborted
    fuzzing sessions.

  - Removed the -D option, as it's no longer necessary.

  - Refactored calibration code and improved startup reporting.

  - Implemented dynamically scaled timeouts, so that you don't need to
    play with -t except in some very rare cases.

  - Added visual notification for slow binaries.

  - Improved instrumentation to explicitly cover the other leg of every
    branch.

--------------
Version 0.36b:
--------------

  - Implemented fork server support to avoid the overhead of execve(). A
    nearly-verbatim design from Jann Horn; still pending part 2 that would
    also skip initial setup steps (thinking about reliable heuristics now).

  - Added a check for shell scripts used as fuzz targets.

  - Added a check for fuzz jobs that don't seem to be finding anything.

  - Fixed the way IGNORE_FINDS works (was a bit broken after adding splicing
    and path skip heuristics).

--------------
Version 0.35b:
--------------

  - Properly integrated 64-bit instrumentation into afl-as.

--------------
Version 0.34b:
--------------

  - Added a new exec count classifier (the working theory is that it gets
    meaningful coverage with fewer test cases spewed out).

--------------
Version 0.33b:
--------------

  - Switched to new, somewhat experimental instrumentation that tries to
    target only arcs, rather than every line. May be fragile, but is a lot
    faster (2x+).

  - Made several other cosmetic fixes and typo corrections, thanks to
    Jakub Wilk.

--------------
Version 0.32b:
--------------

  - Another take at fixing the C++ exception thing. Reported by Jakub Wilk.

--------------
Version 0.31b:
--------------

  - Made another fix to afl-as to address a potential problem with newer
    versions of GCC (introduced in 0.28b). Thanks to Jann Horn.

--------------
Version 0.30b:
--------------

  - Added more detail about the underlying operations in file names.

--------------
Version 0.29b:
--------------

  - Made some general improvements to chunk operations.

--------------
Version 0.28b:
--------------

  - Fixed C++ exception handling in newer versions of GCC. Problem diagnosed
    by Eberhard Mattes.

  - Fixed the handling of the overflow flag. Once again, thanks to
    Eberhard Mattes.

--------------
Version 0.27b:
--------------

  - Added prioritization of new paths over the already-fuzzed ones.

  - Included spliced test case ID in the output file name.

  - Fixed a rare, cosmetic null ptr deref after Ctrl-C.

  - Refactored the code to make copies of test cases in the output directory.

  - Switched to better output file names, keeping track of stage and splicing
    sources.

--------------
Version 0.26b:
--------------

  - Revamped storage of testcases, -u option removed,

  - Added a built-in effort minimizer to get rid of potentially redundant
    inputs,

  - Provided a testcase count minimization script in experimental/,

  - Made miscellaneous improvements to directory and file handling.

  - Fixed a bug in timeout detection.

--------------
Version 0.25b:
--------------

  - Improved count-based instrumentation.

  - Improved the hang deduplication logic.

  - Added -cov prefixes for test cases.

  - Switched from readdir() to scandir() + alphasort() to preserve ordering of
    test cases.

  - Added a splicing strategy.

  - Made various minor UI improvements and several other bugfixes.

--------------
Version 0.24b:
--------------

  - Added program name to the status screen, plus the -T parameter to go with
    it.

--------------
Version 0.23b:
--------------

  - Improved the detection of variable behaviors.

  - Added path depth tracking,

  - Improved the UI a bit,

  - Switched to simplified (XOR-based) tuple instrumentation.

--------------
Version 0.22b:
--------------

  - Refactored the handling of long bitflips and some swaps.

  - Fixed the handling of gcc -pipe, thanks to anonymous reporter.

--------------
Version 0.21b:
--------------

  - Initial public release.

```

`afl_docs/INSTALL`:

```
=========================
Installation instructions
=========================

  This document provides basic installation instructions and discusses known
  issues for a variety of platforms. See README for the general instruction
  manual.

1) Linux on x86
---------------

This platform is expected to work well. Compile the program with:

$ make

You can start using the fuzzer without installation, but it is also possible to
install it with:

# make install

There are no special dependencies to speak of; you will need GNU make and a
working compiler (gcc or clang). Some of the optional scripts bundled with the
program may depend on bash, gdb, and similar basic tools.

If you are using clang, please review llvm_mode/README.llvm; the LLVM
integration mode can offer substantial performance gains compared to the
traditional approach.

You may have to change several settings to get optimal results (most notably,
disable crash reporting utilities and switch to a different CPU governor), but
afl-fuzz will guide you through that if necessary.

2) OpenBSD, FreeBSD, NetBSD on x86
----------------------------------

Similarly to Linux, these platforms are expected to work well and are
regularly tested. Compile everything with GNU make:

$ gmake

Note that BSD make will *not* work; if you do not have gmake on your system,
please install it first. As on Linux, you can use the fuzzer itself without
installation, or install it with:

# gmake install

Keep in mind that if you are using csh as your shell, the syntax of some of the
shell commands given in the README and other docs will be different.

The llvm_mode requires a dynamically linked, fully-operational installation of
clang. At least on FreeBSD, the clang binaries are static and do not include
some of the essential tools, so if you want to make it work, you may need to
follow the instructions in llvm_mode/README.llvm.

Beyond that, everything should work as advertised.

The QEMU mode is currently supported only on Linux. I think it's just a QEMU
problem, I couldn't get a vanilla copy of user-mode emulation support working
correctly on BSD at all.

3) MacOS X on x86
-----------------

MacOS X should work, but there are some gotchas due to the idiosyncrasies of
the platform. On top of this, I have limited release testing capabilities
and depend mostly on user feedback.

To build AFL, install Xcode and follow the general instructions for Linux.

The Xcode 'gcc' tool is just a wrapper for clang, so be sure to use afl-clang
to compile any instrumented binaries; afl-gcc will fail unless you have GCC
installed from another source (in which case, please specify AFL_CC and
AFL_CXX to point to the "real" GCC binaries).

Only 64-bit compilation will work on the platform; porting the 32-bit
instrumentation would require a fair amount of work due to the way OS X
handles relocations, and today, virtually all MacOS X boxes are 64-bit.

The crash reporting daemon that comes by default with MacOS X will cause
problems with fuzzing. You need to turn it off by following the instructions
provided here: http://goo.gl/CCcd5u

The fork() semantics on OS X are a bit unusual compared to other unix systems
and definitely don't look POSIX-compliant. This means two things:

  - Fuzzing will be probably slower than on Linux. In fact, some folks report
    considerable performance gains by running the jobs inside a Linux VM on
    MacOS X.

  - Some non-portable, platform-specific code may be incompatible with the
    AFL forkserver. If you run into any problems, set AFL_NO_FORKSRV=1 in the
    environment before starting afl-fuzz.

User emulation mode of QEMU does not appear to be supported on MacOS X, so
black-box instrumentation mode (-Q) will not work.

The llvm_mode requires a fully-operational installation of clang. The one that
comes with Xcode is missing some of the essential headers and helper tools.
See llvm_mode/README.llvm for advice on how to build the compiler from scratch.

4) Linux or *BSD on non-x86 systems
-----------------------------------

Standard build will fail on non-x86 systems, but you should be able to
leverage two other options:

  - The LLVM mode (see llvm_mode/README.llvm), which does not rely on
    x86-specific assembly shims,

  - The QEMU mode (see qemu_mode/README.qemu), which can be also used for
    fuzzing cross-platform binaries.

In both cases, you will need to set AFL_NOX86=1 before running make or gmake.

5) Solaris on x86
-----------------

The fuzzer reportedly works on Solaris, but I have not tested this first-hand,
and the user base is fairly small, so I don't have a lot of feedback.

To get the ball rolling, you will need to use GNU make and GCC or clang. I'm
being told that the stock version of GCC that comes with the platform does not
work properly due to its reliance on a hardcoded location for 'as' (completely
ignoring the -B parameter or $PATH).

To fix this, you may want to build stock GCC from the source, like so:

$ ./configure --prefix=$HOME/gcc --with-gnu-as --with-gnu-ld \
  --with-gmp-include=/usr/include/gmp --with-mpfr-include=/usr/include/mpfr
$ make
$ sudo make install

Do *not* specify --with-as=/usr/gnu/bin/as - this will produce a GCC binary that
ignores the -B flag and you will be back to square one.

If you have system-wide crash reporting enabled, you may run into problems
similar to the gotchas for Linux and MacOS X, but I have not verified this.
More information about AppCrash can be found here:

  http://www.oracle.com/technetwork/server-storage/solaris10/app-crash-142906.html

User emulation mode of QEMU is not available on Solaris, so black-box
instrumentation mode (-Q) will not work.

6) Everything else
------------------

You're on your own. On POSIX-compliant systems, you may be able to compile and
run the fuzzer; and the LLVM mode may offer a way to instrument non-x86 code.

The fuzzer will not run on Windows. It will also not work under Cygwin. It
could be ported to the latter platform fairly easily, but it's a pretty bad
idea, because Cygwin is extremely slow. It makes much more sense to use
VirtualBox or so to run a hardware-accelerated Linux VM; it will run around
20x faster or so. If you have a *really* compelling use case for Cygwin, let
me know.

Although Android on x86 should theoretically work, the stock kernel has SHM
support compiled out, so you will need to address this issue first. It's
possible that all you need is this:

  https://github.com/pelya/android-shmem

```

`afl_docs/QuickStartGuide.txt`:

```txt
=====================
AFL quick start guide
=====================

You should read docs/README. It's pretty short. If you really can't, here's
how to hit the ground running:

1) Compile AFL with 'make'. If build fails, see docs/INSTALL for tips.

2) Find or write a reasonably fast and simple program that takes data from
   a file or stdin, processes it in a test-worthy way, then exits cleanly.
   If testing a network service, modify it to run in the foreground and read
   from stdin. When fuzzing a format that uses checksums, comment out the
   checksum verification code, too.

   The program must crash properly when a fault is encountered. Watch out for
   custom SIGSEGV or SIGABRT handlers and background processes.

3) Compile the program / library to be fuzzed using afl-gcc. A common way to
   do this would be:

   CC=/path/to/afl-gcc CXX=/path/to/afl-g++ ./configure --disable-shared
   make clean all

   If program build fails, ping <afl-users@googlegroups.com>.

4) Get a small but valid input file that makes sense to the program. When
   fuzzing verbose syntax (SQL, HTTP, etc), create a dictionary as described in
   testcases/README.testcases, too.

5) If the program reads from stdin, run 'afl-fuzz' like so:

   ./afl-fuzz -i testcase_dir -o findings_dir -- \
     /path/to/tested/program [...program's cmdline...]

   If the program takes input from a file, you can put @@ in the program's
   command line; AFL will put an auto-generated file name in there for you.

6) Investigate anything shown in red in the fuzzer UI by promptly consulting
   docs/status_screen.txt.

That's it. Sit back, relax, and - time permitting - try to skim through the
following files:

  - docs/README               - A general introduction to AFL,
  - docs/perf_tips.txt        - Simple tips on how to fuzz more quickly,
  - docs/status_screen.txt    - An explanation of the tidbits shown in the UI,
  - docs/parallel_fuzzing.txt - Advice on running AFL on multiple cores.

```

`afl_docs/README`:

```
==================
american fuzzy lop
==================

  Written and maintained by Michal Zalewski <lcamtuf@google.com>

  Copyright 2013, 2014, 2015 Google Inc. All rights reserved.
  Released under terms and conditions of Apache License, Version 2.0.

  For new versions and additional information, check out:
  http://lcamtuf.coredump.cx/afl/

  To compare notes with other users or get notified about major new features,
  send a mail to <afl-users+subscribe@googlegroups.com>.

  ** See QuickStartGuide.txt if you don't have time to read this file. **

1) Challenges of guided fuzzing
-------------------------------

Fuzzing is one of the most powerful and proven strategies for identifying
security issues in real-world software; it is responsible for the vast
majority of remote code execution and privilege escalation bugs found to date
in security-critical software.

Unfortunately, fuzzing is also relatively shallow; blind, random mutations
make it very unlikely to reach certain code paths in the tested code, leaving
some vulnerabilities firmly outside the reach of this technique.

There have been numerous attempts to solve this problem. One of the early
approaches - pioneered by Tavis Ormandy - is corpus distillation. The method
relies on coverage signals to select a subset of interesting seeds from a
massive, high-quality corpus of candidate files, and then fuzz them by
traditional means. The approach works exceptionally well, but requires such
a corpus to be readily available. In addition, block coverage measurements
provide only a very simplistic understanding of program state, and are less
useful for guiding the fuzzing effort in the long haul.

Other, more sophisticated research has focused on techniques such as program
flow analysis ("concolic execution"), symbolic execution, or static analysis.
All these methods are extremely promising in experimental settings, but tend
to suffer from reliability and performance problems in practical uses - and
currently do not offer a viable alternative to "dumb" fuzzing techniques.

2) The afl-fuzz approach
------------------------

American Fuzzy Lop is a brute-force fuzzer coupled with an exceedingly simple
but rock-solid instrumentation-guided genetic algorithm. It uses a modified
form of edge coverage to effortlessly pick up subtle, local-scale changes to
program control flow.

Simplifying a bit, the overall algorithm can be summed up as:

  1) Load user-supplied initial test cases into the queue,

  2) Take next input file from the queue,

  3) Attempt to trim the test case to the smallest size that doesn't alter
     the measured behavior of the program,

  4) Repeatedly mutate the file using a balanced and well-researched variety
     of traditional fuzzing strategies,

  5) If any of the generated mutations resulted in a new state transition
     recorded by the instrumentation, add mutated output as a new entry in the
     queue.

  6) Go to 2.

The discovered test cases are also periodically culled to eliminate ones that
have been obsoleted by newer, higher-coverage finds; and undergo several other
instrumentation-driven effort minimization steps.

As a side result of the fuzzing process, the tool creates a small,
self-contained corpus of interesting test cases. These are extremely useful
for seeding other, labor- or resource-intensive testing regimes - for example,
for stress-testing browsers, office applications, graphics suites, or
closed-source tools.

The fuzzer is thoroughly tested to deliver out-of-the-box performance far
superior to blind fuzzing or coverage-only tools.

3) Instrumenting programs for use with AFL
------------------------------------------

When source code is available, instrumentation can be injected by a companion
tool that works as a drop-in replacement for gcc or clang in any standard build
process for third-party code.

The instrumentation has a fairly modest performance impact; in conjunction with
other optimizations implemented by afl-fuzz, most programs can be fuzzed as fast
or even faster than possible with traditional tools.

The correct way to recompile the target program may vary depending on the
specifics of the build process, but a nearly-universal approach would be:

$ CC=/path/to/afl/afl-gcc ./configure
$ make clean all

For C++ programs, you'd would also want to set CXX=/path/to/afl/afl-g++.

The clang wrappers (afl-clang and afl-clang++) can be used in the same way;
clang users may also opt to leverage a higher-performance instrumentation mode,
as described in llvm_mode/README.llvm.

When testing libraries, you need to find or write a simple program that reads
data from stdin or from a file and passes it to the tested library. In such a
case, it is essential to link this executable against a static version of the
instrumented library, or to make sure that the correct .so file is loaded at
runtime (usually by setting LD_LIBRARY_PATH). The simplest option is a static
build, usually possible via:

$ CC=/path/to/afl/afl-gcc ./configure --disable-shared

Setting AFL_HARDEN=1 when calling 'make' will cause the CC wrapper to
automatically enable code hardening options that make it easier to detect
simple memory bugs.

PS. ASAN users are advised to review notes_for_asan.txt file for important
caveats.

4) Instrumenting binary-only apps
---------------------------------

When source code is *NOT* available, the fuzzer offers experimental support for
fast, on-the-fly instrumentation of black-box binaries. This is accomplished
with a version of QEMU running in the lesser-known "user space emulation" mode.

QEMU is a project separate from AFL, but you can conveniently build the
feature by doing:

$ cd qemu_mode
$ ./build_qemu_support.sh

For additional instructions and caveats, see qemu_mode/README.qemu.

The mode is approximately 2-5x slower than compile-time instrumentation, is
less conducive to parallelization, and may have some other quirks.

5) Choosing initial test cases
------------------------------

To operate correctly, the fuzzer requires one or more starting file that
contains a good example of the input data normally expected by the targeted
application. There are two basic rules:

  - Keep the files small. Under 1 kB is ideal, although not strictly necessary.
    For a discussion of why size matters, see perf_tips.txt.

  - Use multiple test cases only if they are functionally different from
    each other. There is no point in using fifty different vacation photos
    to fuzz an image library.

You can find many good examples of starting files in the testcases/ subdirectory
that comes with this tool.

PS. If a large corpus of data is available for screening, you may want to use
the afl-cmin utility to identify a subset of functionally distinct files that
exercise different code paths in the target binary.

6) Fuzzing binaries
-------------------

The fuzzing process itself is carried out by the afl-fuzz utility. This program
requires a read-only directory with initial test cases, a separate place to
store its findings, plus a path to the binary to test.

For target binaries that accept input directly from stdin, the usual syntax is:

$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]

For programs that take input from a file, use '@@' to mark the location in
the target's command line where the input file name should be placed. The
fuzzer will substitute this for you:

$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@

You can also use the -f option to have the mutated data written to a specific
file. This is useful if the program expects a particular file extension or so.

Non-instrumented binaries can be fuzzed in the QEMU mode (add -Q in the command
line) or in a traditional, blind-fuzzer mode (specify -n).

You can use -t and -m to override the default timeout and memory limit for the
executed process; rare examples of targets that may need these settings touched
include compilers and video decoders.

Tips for optimizing fuzzing performance are discussed in perf_tips.txt.

Note that afl-fuzz starts by performing an array of deterministic fuzzing
steps, which can take several days. If you want quick & dirty results right
away, akin to zzuf or honggfuzz, add the -d option to the command line.

7) Interpreting output
----------------------

See the status_screen.txt file for information on how to interpret the
displayed stats and monitor the health of the process. Be sure to consult this
file especially if any UI elements are highlighted in red.

The fuzzing process will continue until you press Ctrl-C. At minimum, you want
to allow the fuzzer to complete one queue cycle, which may take anywhere from a
couple of hours to a week or so.

There are three subdirectories created within the output directory and updated
in real time:

  - queue/   - test cases for every distinctive execution path, plus all the
               starting files given by the user. This is the synthesized corpus
               mentioned in section 2.

               Before using this corpus for any other purposes, you can shrink
               it to a smaller size using the afl-cmin tool. The tool will find
               a smaller subset of files offering equivalent edge coverage.

  - crashes/ - unique test cases that cause the tested program to receive a
               fatal signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are 
               grouped by the received signal.

  - hangs/   - unique test cases that cause the tested program to time out. Note
               that when default (aggressive) timeout settings are in effect,
               this can be slightly noisy due to latency spikes and other
               natural phenomena.

Crashes and hangs are considered "unique" if the associated execution paths
involve any state transitions not seen in previously-recorded faults. If a
single bug can be reached in multiple ways, there will be some count inflation
early in the process, but this should quickly taper off.

The file names for crashes and hangs are correlated with parent, non-faulting
queue entries. This should help with debugging.

When you can't reproduce a crash found by afl-fuzz, the most likely cause is
that you are not setting the same memory limit as used by the tool. Try:

$ LIMIT_MB=50
$ ( ulimit -Sv $[LIMIT_MB << 10]; /path/to/tested_binary ... )

Change LIMIT_MB to match the -m parameter passed to afl-fuzz. On OpenBSD,
also change -Sv to -Sd.

Any existing output directory can be also used to resume aborted jobs; try:

$ ./afl-fuzz -i- -o existing_output_dir [...etc...]

If you have gnuplot installed, you can also generate some pretty graphs for any
active fuzzing task using afl-plot. For an example of how this looks like,
see http://lcamtuf.coredump.cx/afl/plot/.

8) Parallelized fuzzing
-----------------------

Every instance of afl-fuzz takes up roughly one core. This means that on
multi-core systems, parallelization is necessary to fully utilize the hardware.
For tips on how to fuzz a common target on multiple cores or multiple networked
machines, please refer to parallel_fuzzing.txt.

9) Fuzzer dictionaries
----------------------

By default, afl-fuzz mutation engine is optimized for compact data formats -
say, images, multimedia, compressed data, regular expression syntax, or shell
scripts. It is somewhat less suited for languages with particularly verbose and
redundant verbiage - notably including HTML, SQL, or JavaScript.

To avoid the hassle of building syntax-aware tools, afl-fuzz provides a way to
seed the fuzzing process with an optional dictionary of language keywords,
magic headers, or other special tokens associated with the targeted data type
- and use that to reconstruct the underlying grammar on the go:

  http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html

To use this feature, you first need to create a dictionary in one of the two
formats discussed in testcases/README.testcases; and then point the fuzzer to
it via the -x option in the command line.

There is no way to provide more structured descriptions of the underlying
syntax, but the fuzzer will likely figure out some of this based on the
instrumentation feedback alone. This actually works in practice, say:

  http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html

PS. Even when no explicit dictionary is given, afl-fuzz will try to extract
existing syntax tokens in the input corpus by watching the instrumentation
very closely during deterministic byte flips. This works for some types of
parsers and grammars, but isn't nearly as good as the -x mode.

10) Crash triage
----------------

The coverage-based grouping of crashes usually produces a small data set that
can be quickly triaged manually or with a very simple GDB or Valgrind script.
Every crash is also traceable to its parent non-crashing test case in the
queue, making it easier to diagnose faults.

Having said that, it's important to acknowledge that some fuzzing crashes can be
difficult quickly evaluate for exploitability without a lot of debugging and
code analysis work. To assist with this task, afl-fuzz supports a very unique
"crash exploration" mode enabled with the -C flag.

In this mode, the fuzzer takes one or more crashing test cases as the input,
and uses its feedback-driven fuzzing strategies to very quickly enumerate all
code paths that can be reached in the program while keeping it in the
crashing state.

Mutations that do not result in a crash are rejected; so are any changes that
do not affect the execution path.

The output is a small corpus of files that can be very rapidly examined to see
what degree of control the attacker has over the faulting address, or whether
it is possible to get past an initial out-of-bounds read - and see what lies
beneath.

Oh, one more thing: for test case minimization, give afl-tmin a try. The tool
can be operated in a very simple way:

$ ./afl-tmin -i test_case -o minimized_result -- /path/to/program [...]

The tool works with crashing and non-crashing test cases alike. In the crash
mode, it will happily accept instrumented and non-instrumented binaries. In the
non-crashing mode, the minimizer relies on standard AFL instrumentation to make
the file simpler without altering the execution path.

The minimizer accepts the -m, -t, -f and @@ syntax in a manner compatible with
afl-fuzz.

11) Common-sense risks
----------------------

Please keep in mind that, similarly to many other computationally-intensive
tasks, fuzzing may put strain on your hardware and on the OS. In particular:

  - Your CPU will run hot and will need adequate cooling. In most cases, if
    cooling is insufficient or stops working properly, CPU speeds will be
    automatically throttled. That said, especially when fuzzing on less
    suitable hardware (laptops, smartphones, etc), it's not entirely impossible
    for something to blow up.

  - Targeted programs may end up erratically grabbing gigabytes of memory or
    filling up disk space with junk files. AFL tries to enforce basic memory
    limits, but can't prevent each and every possible mishap. The bottom line
    is that you shouldn't be fuzzing on systems where the prospect of data loss
    is not an acceptable risk.

  - Fuzzing involves billions of reads and writes to the filesystem. On modern
    systems, this will be usually heavily cached, resulting in fairly modest
    "physical" I/O - but there are many factors that may alter this equation.
    It is your responsibility to monitor for potential trouble; with very heavy
    I/O, the lifespan of many HDDs and SSDs may be reduced.

    A good way to monitor disk I/O on Linux is the 'iostat' command:

    $ iostat -d 3 -x -k [...optional disk ID...]

12) Known limitations & areas for improvement
---------------------------------------------

Here are some of the most important caveats for AFL:

  - AFL detects faults by checking for the first spawned process dying due to
    a signal (SIGSEGV, SIGABRT, etc). Programs that install custom handlers for
    these signals may need to have the relevant code commented out. In the same
    vein, faults in child processed spawned by the fuzzed target may evade
    detection unless you manually add some code to catch that.

  - As with any other brute-force tool, the fuzzer offers limited coverage if
    encryption, checksums, cryptographic signatures, or compression are used to
    wholly wrap the actual data format to be tested.

    To work around this, you can comment out the relevant checks (see
    experimental/libpng_no_checksum/ for inspiration); if this is not possible,
    you can also write a postprocessor, as explained in
    experimental/post_library/.

  - There are some unfortunate trade-offs with ASAN and 64-bit binaries. This
    isn't due to any specific fault of afl-fuzz; see notes_for_asan.txt for
    tips.

  - There is no direct support for fuzzing network services, background
    daemons, or interactive apps that require UI interaction to work. You may
    need to make simple code changes to make them behave in a more traditional
    way. Preeny may offer a relatively simple option, too - see:
    https://github.com/zardus/preeny

    Some useful tips for modifying network-based services can be also found at:
    https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop

  - AFL doesn't output human-readable coverage data. If you want to monitor
    coverage, use afl-cov from Michael Rash: https://github.com/mrash/afl-cov

Beyond this, see INSTALL for platform-specific tips.

13) Special thanks
------------------

Many of the improvements to afl-fuzz wouldn't be possible without feedback,
bug reports, or patches from:

  Jann Horn                             Hanno Boeck
  Felix Groebert                        Jakub Wilk
  Richard W. M. Jones                   Alexander Cherepanov
  Tom Ritter                            Hovik Manucharyan
  Sebastian Roschke                     Eberhard Mattes
  Padraig Brady                         Ben Laurie
  @dronesec                             Luca Barbato
  Tobias Ospelt                         Thomas Jarosch
  Martin Carpenter                      Mudge Zatko
  Joe Zbiciak                           Ryan Govostes
  Michael Rash                          William Robinet
  Jonathan Gray                         Filipe Cabecinhas
  Nico Weber                            Jodie Cunningham
  Andrew Griffiths                      Parker Thompson
  Jonathan Neuschfer                    Tyler Nighswander
  Ben Nagy                              Samir Aguiar
  Aidan Thornton                        Aleksandar Nikolich
  Sam Hakim                             Laszlo Szekeres
  David A. Wheeler                      Turo Lamminen
  Andreas Stieger                       Richard Godbee
  Louis Dassy                           teor2345
  Alex Moneger                          Dmitry Vyukov
  Keegan McAllister                     Kostya Serebryany
  Richo Healey                          Martijn Bogaard
  rc0r                                  Jonathan Foote
  Christian Holler                      Dominique Pelle
  Jacek Wielemborek                     Leo Barnes
  Jeremy Barnes                         Jeff Trull

Thank you!

14) Contact
-----------

Questions? Concerns? Bug reports? The author can be usually reached at
<lcamtuf@google.com>.

There is also a mailing list for the project; to join, send a mail to
<afl-users+subscribe@googlegroups.com>. Or, if you prefer to browse
archives first, try:

  https://groups.google.com/group/afl-users

PS. If you wish to submit raw code to be incorporated into the project, please
be aware that the copyright on most of AFL is claimed by Google. While you do
retain copyright on your contributions, they do ask people to agree to a simple
CLA first:

  https://cla.developers.google.com/clas

Sorry about the hassle. Of course, no CLA is required for feature requests or
bug reports.

```

`afl_docs/env_variables.txt`:

```txt
=======================
Environmental variables
=======================

  This document discusses the environment variables used by American Fuzzy Lop
  to expose various exotic functions that may be (rarely) useful for power
  users or for some types of custom fuzzing setups. See README for the general
  instruction manual.

1) Settings for afl-gcc, afl-clang, and afl-as
----------------------------------------------

Because they can't directly accept command-line options, the compile-time
tools make fairly broad use of environmental variables:

  - Setting AFL_HARDEN automatically adds code hardening options when invoking
    the downstream compiler. This currently includes -D_FORTIFY_SOURCE=2 and
    -fstack-protector-all. The setting is useful for catching non-crashing
    memory bugs at the expense of a very slight (sub-5%) performance loss.

  - By default, the wrapper appends -O3 to optimize builds. Very rarely, this
    will cause problems in programs built with -Werror, simply because -O3
    enables more thorough code analysis and can spew out additional warnings.
    To disable optimizations, set AFL_DONT_OPTIMIZE.

  - Setting AFL_USE_ASAN automatically enables ASAN, provided that your
    compiler supports that. Note that fuzzing with ASAN is mildly challenging
    - see notes_for_asan.txt.

    (You can also enable MSAN via AFL_USE_MSAN; ASAN and MSAN come with the
    same gotchas; the modes are mutually exclusive. UBSAN and other exotic
    sanitizers are not officially supported yet, but are easy to get to work
    by hand.)

  - Setting AFL_CC, AFL_CXX, and AFL_AS lets you use alternate downstream
    compilation tools, rather than the default 'clang', 'gcc', or 'as' binaries
    in your $PATH.

  - AFL_PATH can be used to point afl-gcc to an alternate location of afl-as.
    One possible use of this is experimental/clang_asm_normalize/, which lets
    you instrument hand-written assembly when compiling clang code by plugging
    a normalizer into the chain. (There is no equivalent feature for GCC.)

  - Setting AFL_INST_RATIO to a percentage between 0 and 100% controls the
    probability of instrumenting every branch. This is (very rarely) useful
    when dealing with exceptionally complex programs that saturate the output
    bitmap. Examples include v8, ffmpeg, and perl.

    (If this ever happens, afl-fuzz will warn you ahead of the time by
    displaying the "bitmap density" field in fiery red.)

    Setting AFL_INST_RATIO to 0 is a valid choice. This will instrument only
    the transitions between function entry points, but not individual branches.

  - TMPDIR is used by afl-as for temporary files; if this variable is not set,
    the tool defaults to /tmp.

  - Setting AFL_KEEP_ASSEMBLY prevents afl-as from deleting instrumented
    assembly files. Useful for troubleshooting problems or understanding how
    the tool works. To get them in a predictable place, try something like:

    mkdir assembly_here
    TMPDIR=$PWD/assembly_here AFL_KEEP_ASSEMBLY=1 make clean all

  - Setting AFL_QUIET will prevent afl-cc and afl-as banners from being
    displayed during compilation, in case you find them distracting.

2) Settings for afl-clang-fast
------------------------------

The native LLVM instrumentation helper accepts a subset of the settings
discussed in section #1, with the exception of:

  - AFL_AS, since this toolchain does not directly invoke GNU as.

  - TMPDIR and AFL_KEEP_ASSEMBLY, since no temporary assembly files are
    created.

Note that AFL_INST_RATIO will behave a bit differently than for afl-gcc,
because functions are *not* instrumented unconditionally - so low values
will have a more striking effect. For this tool, 0 is not a valid choice.

3) Settings for afl-fuzz
------------------------

The main fuzzer binary accepts several options that disable a couple of sanity
checks or alter some of the more exotic semantics of the tool:

  - Setting AFL_AUTORESUME will resume a fuzz run (same as providing `-i -`)
    for an existing out folder, even if a different `-i` was provided.
    Without this setting, afl-fuzz will refuse execution for a long-fuzzed out dir.

  - Setting AFL_SKIP_CPUFREQ skips the check for CPU scaling policy. This is
    useful if you can't change the defaults (e.g., no root access to the
    system) and are OK with some performance loss.

  - Setting AFL_NO_FORKSRV disables the forkserver optimization, reverting to
    fork + execve() call for every tested input. This is useful mostly when
    working with unruly libraries that create threads or do other crazy
    things when initializing (before the instrumentation has a chance to run).

    Note that this setting inhibits some of the user-friendly diagnostics
    normally done when starting up the forkserver and causes a pretty
    significant performance drop.

  - Setting AFL_NO_VAR_CHECK skips the detection of variable test cases,
    greatly speeding up session resumption and path discovery for complex
    multi-threaded apps (but depriving you of a potentially useful signal
    in more orderly programs).

  - AFL_EXIT_WHEN_DONE causes afl-fuzz to terminate when all existing paths
    have been fuzzed and there were no new finds for a while. This would be
    normally indicated by the cycle counter in the UI turning green. May be
    convenient for some types of automated jobs.

  - AFL_SKIP_CRASHES causes AFL to tolerate crashing files in the input
    queue. This can help with rare situations where a program crashes only
    intermittently, but it's not really recommended under normal operating
    conditions.

  - AFL_SHUFFLE_QUEUE randomly reorders the input queue on startup. Requested
    by some users for unorthodox parallelized fuzzing setups, but not
    advisable otherwise.

  - When developing custom instrumentation on top of afl-fuzz, you can use
    AFL_SKIP_BIN_CHECK to inhibit the checks for non-instrumented binaries
    and shell scripts; and AFL_DUMB_FORKSRV in conjunction with the -n
    setting to instruct afl-fuzz to still follow the fork server protocol
    without expecting any instrumentation data in return.

  - When running in the -M or -S mode, setting AFL_IMPORT_FIRST causes the
    fuzzer to import test cases from other instances before doing anything
    else. This makes the "own finds" counter in the UI more accurate
    Beyond counter aesthetics, not much else should change.

  - Setting AFL_POST_LIBRARY allows you to configure a postprocessor for
    mutated files - say, to fix up checksums. See experimental/post_library/
    for more.

  - The CPU widget shown at the bottom of the screen is fairly simplistic and
    may complain of high load prematurely, especially on systems with low core
    counts. To avoid the alarming red color, you can set AFL_NO_CPU_RED.

  - In QEMU mode (-Q), AFL_PATH will be searched for afl-qemu-trace.

  - If you are Jakub, you may need AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES.
    Others need not apply.

4) Settings for afl-qemu-trace
------------------------------

The QEMU wrapper used to instrument binary-only code supports several settings:

  - It is possible to set AFL_INST_RATIO to skip the instrumentation on some
    of the basic blocks, which can be useful when dealing with very complex
    binaries.

  - Setting AFL_INST_LIBS causes the translator to also instrument the code
    inside any dynamically linked libraries (notably including glibc).

  - The underlying QEMU binary will recognize any standard "user space
    emulation" variables (e.g., QEMU_STACK_SIZE), but there should be no
    reason to touch them.

5) Settings for afl-cmin
------------------------

The corpus minimization script offers very little customization:

  - Setting AFL_PATH offers a way to specify the location of afl-showmap
    and afl-qemu-trace (the latter only in -Q mode).

  - AFL_KEEP_TRACES makes the tool keep traces and other metadata used for
    minimization and normally deleted at exit. The files can be found in the
    <out_dir>/.traces/*.

6) Settings for afl-tmin
------------------------

Virtually nothing to play with. Well, in QEMU mode (-Q), AFL_PATH will be
searched for afl-qemu-trace. In addition to this, TMPDIR may be used if a
temporary file can't be created in the current working directory.

7) Third-party variables set by afl-fuzz & other tools
------------------------------------------------------

Several variables are not directly interpreted by afl-fuzz, but are set to
optimal values if not already present in the environment:

  - By default, LD_BIND_NOW is set to speed up fuzzing by forcing the
    linker to do all the work before the fork server kicks in. You can
    override this by setting LD_BIND_LAZY beforehand, but it is almost
    certainly pointless.

  - By default, ASAN_OPTIONS are set to:

    abort_on_error=1
    detect_leaks=0
    allocator_may_return_null=1

    If you want to set your own options, be sure to include abort_on_error=1 -
    otherwise, the fuzzer will not be able to detect crashes in the tested
    app.

  - In the same vein, by default, MSAN_OPTIONS are set to:

    exit_code=86
    msan_track_origins=0

    Be sure to include the first one when customizing anything, since MSAN
    doesn't call abort() on error, and we need a way to detect faults.

```

`afl_docs/historical_notes.txt`:

```txt
================
Historical notes
================

  This doc talks about the rationale of some of the high-level design decisions
  for American Fuzzy Lop. It's adopted from a discussion with Rob Graham.
  See README for the general instruction manual, and technical_details.txt for
  additional implementation-level insights.

1) Influences
-------------

In short, afl-fuzz is inspired chiefly by the work done by Tavis Ormandy back
in 2007. Tavis did some very persuasive experiments using gcov block coverage
to select optimal test cases out of a large corpus of data, and then using
them as a starting point for traditional fuzzing workflows.

(By "persuasive", I mean: netting a significant number of interesting
vulnerabilities.)

In parallel to this, both Tavis and I were interested in evolutionary fuzzing.
Tavis had his experiments, and I was working on a tool called bunny-the-fuzzer,
released somewhere in 2007.

Bunny used a generational algorithm not much different from afl-fuzz, but
also tried to reason about the relationship between various input bits and
the internal state of the program, with hopes of deriving some additional value
from that. The reasoning / correlation part was probably in part inspired by
other projects done around the same time by Will Drewry and Chris Evans.

The state correlation approach sounded very sexy on paper, but ultimately, made
the fuzzer complicated, brittle, and cumbersome to use; every other target
program would require a tweak or two. Because Bunny didn't fare a whole lot
better than less sophisticated brute-force tools, I eventually decided to write
it off. You can still find its original documentation at:

  https://code.google.com/p/bunny-the-fuzzer/wiki/BunnyDoc

There has been a fair amount of independent work, too. Most notably, a few
weeks earlier that year, Jared DeMott had a Defcon presentation about a
coverage-driven fuzzer that relied on coverage as a fitness function.

Jared's approach was by no means identical to what afl-fuzz does, but it was in
the same ballpark. His fuzzer tried to explicitly solve for the maximum coverage
with a single input file; in comparison, afl simply selects for cases that do
something new (which yields better results - see technical_details.txt).

A few years later, Gabriel Campana released fuzzgrind, a tool that relied purely
on Valgrind and a constraint solver to maximize coverage without any brute-force
bits; and Microsoft Research folks talked extensively about their still
non-public, solver-based SAGE framework.

In the past six years or so, I've also seen a fair number of academic papers
that dealt with smart fuzzing (focusing chiefly on symbolic execution) and a
couple papers that discussed proof-of-concept applications of genetic
algorithms with the same goals in mind. I'm unconvinced how practical most of
these experiments were; I suspect that many of them suffer from the
bunny-the-fuzzer's curse of being cool on paper and in carefully designed
experiments, but failing the ultimate test of being able to find new,
worthwhile security bugs in otherwise well-fuzzed, real-world software.

In some ways, the baseline that the "cool" solutions have to compete against is
a lot more impressive than it may seem, making it difficult for competitors to
stand out. For a singular example, check out the work by Gynvael and Mateusz
Jurczyk, applying "dumb" fuzzing to ffmpeg, a prominent and security-critical
component of modern browsers and media players:

  http://googleonlinesecurity.blogspot.com/2014/01/ffmpeg-and-thousand-fixes.html

Effortlessly getting comparable results with state-of-the-art symbolic execution
in equally complex software still seems fairly unlikely, and hasn't been
demonstrated in practice so far.

But I digress; ultimately, attribution is hard, and glorying the fundamental
concepts behind AFL is probably a waste of time. The devil is very much in the
often-overlooked details, which brings us to...

2) Design goals for afl-fuzz
----------------------------

In short, I believe that the current implementation of afl-fuzz takes care of
several itches that seemed impossible to scratch with other tools:

1) Speed. It's genuinely hard to compete with brute force when your "smart"
   approach is resource-intensive. If your instrumentation makes it 10x more
   likely to find a bug, but runs 100x slower, your users are getting a bad
   deal.

   To avoid starting with a handicap, afl-fuzz is meant to let you fuzz most of
   the intended targets at roughly their native speed - so even if it doesn't
   add value, you do not lose much.

   On top of this, the tool leverages instrumentation to actually reduce the
   amount of work in a couple of ways: for example, by carefully trimming the
   corpus or skipping non-functional but non-trimmable regions in the input
   files.

2) Rock-solid reliability. It's hard to compete with brute force if your
   approach is brittle and fails unexpectedly. Automated testing is attractive
   because it's simple to use and scalable; anything that goes against these
   principles is an unwelcome trade-off and means that your tool will be used
   less often and with less consistent results.

   Most of the approaches based on symbolic execution, taint tracking, or
   complex syntax-aware instrumentation are currently fairly unreliable with
   real-world targets. Perhaps more importantly, their failure modes can render
   them strictly worse than "dumb" tools, and such degradation can be difficult
   for less experienced users to notice and correct.

   In contrast, afl-fuzz is designed to be rock solid, chiefly by keeping it
   simple. In fact, at its core, it's designed to be just a very good
   traditional fuzzer with a wide range of interesting, well-researched
   strategies to go by. The fancy parts just help it focus the effort in
   places where it matters the most.

3) Simplicity. The author of a testing framework is probably the only person
   who truly understands the impact of all the settings offered by the tool -
   and who can dial them in just right. Yet, even the most rudimentary fuzzer
   frameworks often come with countless knobs and fuzzing ratios that need to
   be guessed by the operator ahead of the time. This can do more harm than 
   good.

   AFL is designed to avoid this as much as possible. The three knobs you
   can play with are the output file, the memory limit, and the ability to
   override the default, auto-calibrated timeout. The rest is just supposed to
   work. When it doesn't, user-friendly error messages outline the probable
   causes and workarounds, and get you back on track right away.

4) Chainability. Most general-purpose fuzzers can't be easily employed
   against resource-hungry or interaction-heavy tools, necessitating the
   creation of custom in-process fuzzers or the investment of massive CPU
   power (most of which is wasted on tasks not directly related to the code
   we actually want to test).

   AFL tries to scratch this itch by allowing users to use more lightweight
   targets (e.g., standalone image parsing libraries) to create small
   corpora of interesting test cases that can be fed into a manual testing
   process or a UI harness later on.

As mentioned in technical_details.txt, AFL does all this not by systematically
applying a single overarching CS concept, but by experimenting with a variety
of small, complementary methods that were shown to reliably yields results
better than chance. The use of instrumentation is a part of that toolkit, but is
far from being the most important one.

Ultimately, what matters is that afl-fuzz is designed to find cool bugs - and
has a pretty robust track record of doing just that.

```

`afl_docs/notes_for_asan.txt`:

```txt
==================================
Notes for using ASAN with afl-fuzz
==================================

  This file discusses some of the caveats for fuzzing under ASAN, and suggests
  a handful of alternatives. See README for the general instruction manual.

1) Short version
----------------

ASAN on 64-bit systems requests a lot of memory in a way that can't be easily
distinguished from a misbehaving program bent on crashing your system.

Because of this, fuzzing with ASAN is recommended only in four scenarios:

  - On 32-bit systems, where we can always enforce a reasonable memory limit
    (-m 800 or so is a good starting point),

  - On 64-bit systems only if you can do one of the following:

    - Compile the binary in 32-bit mode (gcc -m32),

    - Precisely gauge memory needs using http://jwilk.net/software/recidivm .

    - Limit the memory available to process using cgroups on Linux (see
      experimental/asan_cgroups).

To compile with ASAN, set AFL_USE_ASAN=1 before calling 'make clean all'. The
afl-gcc / afl-clang wrappers will pick that up and add the appropriate flags.
Note that ASAN is incompatible with -static, so be mindful of that.

(You can also use AFL_USE_MSAN=1 to enable MSAN instead.)

There is also the option of generating a corpus using a non-ASAN binary, and
then feeding it to an ASAN-instrumented one to check for bugs. This is faster,
and can give you somewhat comparable results.

2) Long version
---------------

ASAN allocates a huge region of virtual address space for bookkeeping purposes.
Most of this is never actually accessed, so the OS never has to allocate any
real pages of memory for the process, and the VM grabbed by ASAN is essentially
"free" - but the mapping counts against the standard OS-enforced limit
(RLIMIT_AS, aka ulimit -v).

On our end, afl-fuzz tries to protect you from processes that go off-rails
and start consuming all the available memory in a vain attempt to parse a
malformed input file. This happens surprisingly often, so enforcing such a limit
is important for almost any fuzzer: the alternative is for the kernel OOM
handler to step in and start killing random processes to free up resources.
Needless to say, that's not a very nice prospect to live with.

Unfortunately, un*x systems offer no portable way to limit the amount of
pages actually given to a process in a way that distinguishes between that
and the harmless "land grab" done by ASAN. In principle, there are three standard
ways to limit the size of the heap:

  - The RLIMIT_AS mechanism (ulimit -v) caps the size of the virtual space -
    but as noted, this pays no attention to the number of pages actually
    in use by the process, and doesn't help us here.

  - The RLIMIT_DATA mechanism (ulimit -d) seems like a good fit, but it applies
    only to the traditional sbrk() / brk() methods of requesting heap space;
    modern allocators, including the one in glibc, routinely rely on mmap()
    instead, and circumvent this limit completely.

  - Finally, the RLIMIT_RSS limit (ulimit -m) sounds like what we need, but
    doesn't work on Linux - mostly because nobody felt like implementing it.

There are also cgroups, but they are Linux-specific, not universally available
even on Linux systems, and they require root permissions to set up; I'm a bit
hesitant to make afl-fuzz require root permissions just for that. That said,
if you are on Linux and want to use cgroups, check out the contributed script
that ships in experimental/asan_cgroups/.

In settings where cgroups aren't available, we have no nice, portable way to
avoid counting the ASAN allocation toward the limit. On 32-bit systems, or for
binaries compiled in 32-bit mode (-m32), this is not a big deal: ASAN needs
around 600-800 MB or so, depending on the compiler - so all you need to do is
to specify -m that is a bit higher than that.

On 64-bit systems, the situation is more murky, because the ASAN allocation
is completely outlandish - around 17.5 TB in older versions, and closer to
20 TB with newest ones. The actual amount of memory on your system is
(probably!) just a tiny fraction of that - so unless you dial the limit
with surgical precision, you will get no protection from OOM bugs.

On my system, the amount of memory grabbed by ASAN with a slightly older
version of gcc is around 17,825,850 MB; for newest clang, it's 20,971,600.
But there is no guarantee that these numbers are stable, and if you get them
wrong by "just" a couple gigs or so, you will be at risk.

To get the precise number, you can use the recidivm tool developed by Jakub
Wilk (http://jwilk.net/software/recidivm). In absence of this, ASAN is *not*
recommended when fuzzing 64-bit binaries, unless you are confident that they
are robust and enforce reasonable memory limits (in which case, you can
specify '-m none' when calling afl-fuzz).

Using recidivm or running with no limits aside, there are two other decent
alternatives: build a corpus of test cases using a non-ASAN binary, and then
examine them with ASAN, Valgrind, or other heavy-duty tools in a more
controlled setting; or compile the target program with -m32 (32-bit mode)
if your system supports that.

3) Interactions with the QEMU mode
----------------------------------

ASAN, MSAN, and other sanitizers appear to be incompatible with QEMU user
emulation, so please do not try to use them with the -Q option; QEMU doesn't
seem to appreciate the shadow VM trick used by these tools, and will likely
just allocate all your physical memory, then crash.

4) What about UBSAN?
--------------------

Some folks expressed interest in fuzzing with UBSAN. This isn't officially
supported, because many installations of UBSAN don't offer a consistent way
to abort() on fault conditions or to terminate with a distinctive exit code.

That said, some versions of the library can be binary-patched to address this
issue, while newer releases support explicit compile-time flags - see this
mailing list thread for tips:

  https://groups.google.com/forum/#!topic/afl-users/GyeSBJt4M38

```

`afl_docs/parallel_fuzzing.txt`:

```txt
=========================
Tips for parallel fuzzing
=========================

  This document talks about synchronizing afl-fuzz jobs on a single machine
  or across a fleet of systems. See README for the general instruction manual.

1) Introduction
---------------

Every copy of afl-fuzz will take up one CPU core. This means that on an
n-core system, you can almost always run around n concurrent fuzzing jobs with
virtually no performance hit (you can use the afl-gotcpu tool to make sure).

In fact, if you rely on just a single job on a multi-core system, you will
be underutilizing the hardware. So, parallelization is usually the right
way to go.

When targeting multiple unrelated binaries or using the tool in "dumb" (-n)
mode, it is perfectly fine to just start up several fully separate instances
of afl-fuzz. The picture gets more complicated when you want to have multiple
fuzzers hammering a common target: if a hard-to-hit but interesting test case
is synthesized by one fuzzer, the remaining instances will not be able to use
that input to guide their work.

To help with this problem, afl-fuzz offers a simple way to synchronize test
cases on the fly.

2) Single-system parallelization
--------------------------------

If you wish to parallelize a single job across multiple cores on a local
system, simply create a new, empty output directory ("sync dir") that will be
shared by all the instances of afl-fuzz; and then come up with a naming scheme
for every instance - say, "fuzzer01", "fuzzer02", etc. 

Run the first one ("master", -M) like this:

$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 [...other stuff...]

...and then, start up secondary (-S) instances like this:

$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 [...other stuff...]
$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 [...other stuff...]

Each fuzzer will keep its state in a separate subdirectory, like so:

  /path/to/sync_dir/fuzzer01/

Each instance will also periodically rescan the top-level sync directory
for any test cases found by other fuzzers - and will incorporate them into
its own fuzzing when they are deemed interesting enough.

The only difference between the -M and -S modes is that the master instance
will still perform deterministic checks; while the slaves will proceed straight
to random tweaks. If you don't want to do deterministic fuzzing at all, it's OK
to run all instances with -S. With very slow or complex targets, or when running
heavily parallelized jobs, this is usually a good plan.

You can monitor the progress of your jobs from the command line with the
provided afl-whatsup tool. When the instances are no longer finding new paths,
it's probably time to stop.

WARNING: Exercise caution when explicitly specifying the -f option. Each fuzzer
must use a separate temporary file; otherwise, things will go south. One safe
example may be:

$ ./afl-fuzz [...] -S fuzzer10 -f file10.txt ./fuzzed/binary @@
$ ./afl-fuzz [...] -S fuzzer11 -f file11.txt ./fuzzed/binary @@
$ ./afl-fuzz [...] -S fuzzer12 -f file12.txt ./fuzzed/binary @@

This is not a concern if you use @@ without -f and let afl-fuzz come up with the
file name.

3) Multi-system parallelization
-------------------------------

The basic operating principle for multi-system parallelization is similar to
the mechanism explained in section 2. The key difference is that you need to
write a simple script that performs two actions:

  - Uses SSH with authorized_keys to connect to every machine and retrieve
    a tar archive of the /path/to/sync_dir/<fuzzer_id>/queue/ directories for
    every <fuzzer_id> local to the machine. It's best to use a naming scheme
    that includes host name in the fuzzer ID, so that you can do something
    like:

    for s in {1..10}; do
      ssh user@host${s} "tar -czf - sync/host${s}_fuzzid*/[qf]*" >host${s}.tgz
    done

  - Distributes and unpacks these files on all the remaining machines, e.g.:

    for s in {1..10}; do
      for d in {1..10}; do
        test "$s" = "$d" && continue
        ssh user@host${d} 'tar -kxzf -' <host${s}.tgz
      done
    done

There is an example of such a script in experimental/distributed_fuzzing/;
you can also find a more featured, experimental tool developed by
Martijn Bogaard at:

  https://github.com/MartijnB/disfuzz-afl

Another client-server implementation from Richo Healey is:

  https://github.com/richo/roving

Note that these third-party tools are unsafe to run on systems exposed to the
Internet or to untrusted users.

When developing custom test case sync code, there are several optimizations
to keep in mind:

  - The synchronization does not have to happen very often; running the
    task every 30 minutes or so may be perfectly fine.

  - There is no need to synchronize crashes/ or hangs/; you only need to
    copy over queue/* (and ideally, also fuzzer_stats).

  - It is not necessary (and not advisable!) to overwrite existing files;
    the -k option in tar is a good way to avoid that.

  - There is no need to fetch directories for fuzzers that are not running
    locally on a particular machine, and were simply copied over onto that
    system during earlier runs.

  - For large fleets, you will want to consolidate tarballs for each host,
    as this will let you use n SSH connections for sync, rather than n*(n-1).

    You may also want to implement staged synchronization. For example, you
    could have 10 groups of systems, with group 1 pushing test cases only
    to group 2; group 2 pushing them only to group 3; and so on, with group
    eventually 10 feeding back to group 1.

    This arrangement would allow test interesting cases to propagate across
    the fleet without having to copy every fuzzer queue to every single host.

  - You do not want a "master" instance of afl-fuzz on every system; you should
    run them all with -S, and just designate a single process somewhere within
    the fleet to run with -M.

It is *not* advisable to skip the synchronization script and run the fuzzers
directly on a network filesystem; unexpected latency and unkillable processes
in I/O wait state can mess things up.

4) Remote monitoring and data collection
----------------------------------------

You can use screen, nohup, tmux, or something equivalent to run remote
instances of afl-fuzz. If you redirect the program's output to a file, it will
automatically switch from a fancy UI to more limited status reports. There is
also basic machine-readable information always written to the fuzzer_stats file
in the output directory. Locally, that information can be interpreted with
afl-whatsup.

In principle, you can use the status screen of the master (-M) instance to
monitor the overall fuzzing progress and decide when to stop. In this
mode, the most important signal is just that no new paths are being found
for a longer while. If you do not have a master instance, just pick any
single slave and go by that.

You can also rely on that instance's output directory to collect the
synthesized corpus that covers all the noteworthy paths discovered anywhere
within the fleet. The slave (-S) instances do not require any special
monitoring, other than just making sure that they are up.

Keep in mind that crashing inputs are *not* automatically propagated to the
master instance, so you may still want to monitor for crashes fleet-wide
from within your synchronization or health checking scripts (see afl-whatsup).

5) Asymmetric setups
--------------------

It is perhaps worth noting that all of the following is permitted:

  - Running afl-fuzz with conjunction with other guided tools that can extend
    coverage (e.g., via concolic execution). Third-party tools simply need to
    follow the protocol described above for pulling new test cases from
    out_dir/<fuzzer_id>/queue/* and writing their own finds to sequentially
    numbered id:nnnnnn files in out_dir/<ext_tool_id>/queue/*.

  - Running some of the synchronized fuzzers with different (but related)
    target binaries. For example, simultaneously stress-testing several
    different JPEG parsers (say, IJG jpeg and libjpeg-turbo) while sharing
    the discovered test cases can have synergistic effects and improve the
    overall coverage.

    (In this case, running one -M instance per each binary is a good plan.)

  - Having some of the fuzzers invoke the binary in different ways.
    For example, 'djpeg' supports several DCT modes, configurable with
    a command-line flag, while 'dwebp' supports incremental and one-shot
    decoding. In some scenarios, going after multiple distinct modes and then
    pooling test cases will improve coverage.

  - Much less convincingly, running the synchronized fuzzers with different
    starting test cases (e.g., progressive and standard JPEG) or dictionaries.
    The synchronization mechanism ensures that the test sets will get fairly
    homogeneous over time, but it introduces some initial variability.

```

`afl_docs/perf_tips.txt`:

```txt
=================================
Tips for performance optimization
=================================

  This file provides tips for troubleshooting slow or wasteful fuzzing jobs.
  See README for the general instruction manual.

1) Keep your test cases small
-----------------------------

This is probably the single most important step to take! Large test cases do
not merely take more time and memory to be parsed by the tested binary, but
also make the fuzzing process dramatically less efficient in several other
ways.

To illustrate, let's say that you're randomly flipping bits in a file, one bit
at a time. Let's assume that if you flip bit #47, you will hit a security bug;
flipping any other bit just results in an invalid document.

Now, if your starting test case is 100 bytes long, you will have a 71% chance of
triggering the bug within the first 1,000 execs - not bad! But if the test case
is 1 kB long, the probability that we will randomly hit the right pattern in
the same timeframe goes down to 11%. And if it has 10 kB of non-essential
cruft, the odds plunge to 1%.

On top of that, with larger inputs, the binary may be now running 5-10x times
slower than before - so the overall drop in fuzzing efficiency may be easily
as high as 500x or so.

In practice, this means that you shouldn't fuzz image parsers with your
vacation photos. Generate a tiny 16x16 picture instead, and run it through
jpegtran or pngcrunch for good measure. The same goes for most other types
of documents.

There's plenty of small starting test cases in ../testcases/* - try them out
or submit new ones!

If you want to start with a larger, third-party corpus, run afl-cmin with an
aggressive timeout on that data set first.

2) Use a simpler target
-----------------------

Consider using a simpler target binary in your fuzzing work. For example, for
image formats, bundled utilities such as djpeg, readpng, or gifhisto are
considerably (10-20x) faster than the convert tool from ImageMagick - all while
exercising roughly the same library-level image parsing code.

Even if you don't have a lightweight harness for a particular target, remember
that you can always use another, related library to generate a corpus that will
be then manually fed to a more resource-hungry program later on.

3) Use LLVM instrumentation
---------------------------

When fuzzing slow targets, you can gain 2x performance improvement by using
the LLVM-based instrumentation mode described in llvm_mode/README.llvm. Note
that this mode requires the use of clang and will not work with GCC.

The LLVM mode also offers a "persistent", in-process fuzzing mode that can
work well for certain types of self-contained libraries, and for fast targets,
can offer performance gains up to 5-10x; and a "deferred fork server" mode
that can offer huge benefits for programs with high startup overhead. Both
modes require you to edit the source code of the fuzzed program, but the
changes often amount to just strategically placing a single line or two.

4) Profile and optimize the binary
----------------------------------

Check for any parameters or settings that obviously improve performance. For
example, the djpeg utility that comes with IJG jpeg and libjpeg-turbo can be
called with:

  -dct fast -nosmooth -onepass -dither none -scale 1/4

...and that will speed things up. There is a corresponding drop in the quality
of decoded images, but it's probably not something you care about.

In some programs, it is possible to disable output altogether, or at least use
an output format that is computationally inexpensive. For example, with image
transcoding tools, converting to a BMP file will be a lot faster than to PNG.

With some laid-back parsers, enabling "strict" mode (i.e., bailing out after
first error) may result in smaller files and improved run time without
sacrificing coverage; for example, for sqlite, you may want to specify -bail.

If the program is still too slow, you can use strace -tt or an equivalent
profiling tool to see if the targeted binary is doing anything silly.
Sometimes, you can speed things up simply by specifying /dev/null as the
config file, or disabling some compile-time features that aren't really needed
for the job (try ./configure --help). One of the notoriously resource-consuming
things would be calling other utilities via exec*(), popen(), system(), or
equivalent calls; for example, tar can invoke external decompression tools
when it decides that the input file is a compressed archive.

Some programs may also intentionally call sleep(), usleep(), or nanosleep();
vim is a good example of that.

In programs that are slow due to unavoidable initialization overhead, you may
want to try the LLVM deferred forkserver mode (see llvm_mode/README.llvm),
which can give you speed gains up to 10x, as mentioned above.

Last but not least, if you are using ASAN and the performance is unacceptable,
consider turning it off for now, and manually examining the generated corpus
with an ASAN-enabled binary later on.

5) Instrument just what you need
--------------------------------

Instrument just the libraries you actually want to stress-test right now, one
at a time. Let the program use system-wide, non-instrumented libraries for
any functionality you don't actually want to fuzz. For example, in most
cases, it doesn't make to instrument libgmp just because you're testing a
crypto app that relies on it for bignum math.

Beware of programs that come with oddball third-party libraries bundled with
their source code (Spidermonkey is a good example of this). Check ./configure
options to use non-instrumented system-wide copies instead.

6) Parallelize your fuzzers
---------------------------

The fuzzer is designed to need ~1 core per job. This means that on a, say,
4-core system, you can easily run four parallel fuzzing jobs with relatively
little performance hit. For tips on how to do that, see parallel_fuzzing.txt.

The afl-gotcpu utility can help you understand if you still have idle CPU
capacity on your system. (It won't tell you about memory bandwidth, cache
misses, or similar factors, but they are less likely to be a concern.)

7) Keep memory use and timeouts in check
----------------------------------------

If you have increased the -m or -t limits more than truly necessary, consider
dialing them back down.

For programs that are nominally very fast, but get sluggish for some inputs,
you can also try setting -t values that are more punishing than what afl-fuzz
dares to use on its own. On fast and idle machines, going down to -t 5 may be
a viable plan.

The -m parameter is worth looking at, too. Some programs can end up spending
a fair amount of time allocating and initializing megabytes of memory when
presented with pathological inputs. Low -m values can make them give up sooner
and not waste CPU time.

8) Check OS configuration
-------------------------

There are several OS-level factors that may affect fuzzing speed:

  - High system load. Use idle machines where possible. Kill any non-essential
    CPU hogs (idle browser windows, media players, complex screensavers, etc).

  - Network filesystems, either used for fuzzer input / output, or accessed by
    the fuzzed binary to read configuration files (pay special attention to the
    home directory - many programs search it for dot-files).

  - On-demand CPU scaling. The Linux 'ondemand' governor performs its analysis
    on a particular schedule and is known to underestimate the needs of
    short-lived processes spawned by afl-fuzz (or any other fuzzer). On Linux,
    this can be fixed with:

    cd /sys/devices/system/cpu
    echo performance | tee cpu*/cpufreq/scaling_governor

    On other systems, the impact of CPU scaling will be different; when fuzzing,
    use OS-specific tools to find out if all cores are running at full speed.

  - Suboptimal scheduling strategies. The significance of this will vary from
    one target to another, but on Linux, you may want to make sure that the
    following options are set:

    echo 1 >/proc/sys/kernel/sched_child_runs_first
    echo 1 >/proc/sys/kernel/sched_autogroup_enabled

    Setting a different scheduling policy for the fuzzer process - say
    SCHED_RR - can usually speed things up, too, but needs to be done with
    care.

9) If all other options fail, use -d
------------------------------------

For programs that are genuinely slow, in cases where you really can't escape
using huge input files, or when you simply want to get quick and dirty results
early on, you can always resort to the -d mode.

The mode causes afl-fuzz to skip all the deterministic fuzzing steps, which
makes output a lot less neat and makes the testing a bit less in-depth, but
it will give you an experience more familiar from other fuzzing tools.

```

`afl_docs/sister_projects.txt`:

```txt
===============
Sister projects
===============

  This doc lists some of the projects that are inspired by, derived from,
  designed for, or meant to integrate with AFL. See README for the general
  instruction manual.

----------------------------
Support for other languages:
----------------------------

Python AFL (Jakub Wilk)
-----------------------

  Allows fuzz-testing of Python programs. Uses custom instrumentation and its
  own forkserver.

  http://jwilk.net/software/python-afl

Go-fuzz (Dmitry Vyukov)
-----------------------

  AFL-inspired guided fuzzing approach for Go targets:

  https://github.com/dvyukov/go-fuzz

afl.rs (Keegan McAllister)
--------------------------

  Allows Rust features to be easily fuzzed with AFL (using the LLVM mode).

  https://github.com/kmcallister/afl.rs

AFL for GCJ Java and other GCC frontends (-)
--------------------------------------------

  GCC Java programs are actually supported out of the box - simply rename
  afl-gcc to afl-gcj. Unfortunately, by default, unhandled exceptions in GCJ do
  not result in abort() being called, so you will need to manually add a
  top-level exception handler that exits with SIGABRT or something equivalent.

  Other GCC-supported languages should be fairly easy to get working, but may
  face similar problems. See https://gcc.gnu.org/frontends.html for a list of
  options.

AFL-style in-process fuzzer for LLVM (Kostya Serebryany)
--------------------------------------------------------

  Provides an evolutionary instrumentation-guided fuzzing harness that allows
  some programs to be fuzzed without the fork / execve overhead. (Similar
  functionality is now available as the "persistent" feature described in
  ../llvm_mode/README.llvm.)

  http://llvm.org/docs/LibFuzzer.html

AFL fixup shim (Ben Nagy)
-------------------------

  Allows AFL_POST_LIBRARY postprocessors to be written in arbitrary languages
  that don't have C / .so bindings. Includes examples in Go.

  https://github.com/bnagy/aflfix

----------------
Network fuzzing:
----------------

Preeny (Yan Shoshitaishvili)
----------------------------

  Provides a fairly simple way to convince dynamically linked network-centric
  programs to read from a file or not fork. Not AFL-specific, but described as
  useful by many users. Some assembly required.

  https://github.com/zardus/preeny

-------------------------------------------
Distributed fuzzing and related automation:
-------------------------------------------

roving (Richo Healey)
---------------------

  A client-server architecture for effortlessly orchestrating AFL runs across
  a fleet of machines. You don't want to use this on systems that face the
  Internet or live in other untrusted environments.

  https://github.com/richo/roving

Distfuzz-AFL (Martijn Bogaard)
------------------------------

  Simplifies the management of afl-fuzz instances on remote machines. The
  author notes that the current implementation isn't secure and should not
  be exposed on the Internet.

  https://github.com/MartijnB/disfuzz-afl

afl-launch (Ben Nagy)
---------------------

  Batch AFL launcher utility with a simple CLI.

  https://github.com/bnagy/afl-launch

AFL Utils (rc0r)
----------------

  Simplifies the triage of discovered crashes, start parallel instances, etc.

  https://github.com/rc0r/afl-utils

afl-fuzzing-scripts (Tobias Ospelt)
-----------------------------------

  Simplifies starting up multiple parallel AFL jobs.

  https://github.com/floyd-fuh/afl-fuzzing-scripts/

afl-sid (Jacek Wielemborek)
---------------------------

  Allows users to more conveniently build and deploy AFL via Docker.

  https://github.com/d33tah/afl-sid

-------------------------------------
Crash triage, coverage analysis, etc:
-------------------------------------

afl-crash-analyzer (Tobias Ospelt)
----------------------------------

  Makes it easier to navigate and annotate crashing test cases.

  https://github.com/floyd-fuh/afl-crash-analyzer/

Crashwalk (Ben Nagy)
--------------------

  AFL-aware tool to annotate and sort through crashing test cases.

  https://github.com/bnagy/crashwalk

afl-cov (Michael Rash)
----------------------

  Produces human-readable coverage data based on the output queue of afl-fuzz.

  https://github.com/mrash/afl-cov

RecidiVM (Jakub Wilk)
---------------------

  Makes it easy to estimate memory usage limits when fuzzing with ASAN or MSAN.

  http://jwilk.net/software/recidivm

-------------------------------
Narrow-purpose or experimental:
-------------------------------

Pause and resume scripts (Ben Nagy)
-----------------------------------

  Simple automation to suspend and resume groups of fuzzing jobs.

  https://gist.github.com/bnagy/8f0eb29eb125653f73fd

Static binary-only instrumentation (Aleksandar Nikolich)
--------------------------------------------------------

  Allows black-box binaries to be instrumented statically (i.e., by modifying
  the binary ahead of the time, rather than translating it on the run). Author
  reports better performance compared to QEMU, but occasional translation
  errors with stripped binaries.

  https://github.com/vrtadmin/moflow/tree/master/afl-dyninst

AFL PIN (Parker Thompson)
-------------------------

  Early-stage Intel PIN instrumentation support (from before we settled on
  faster-running QEMU).

  https://github.com/mothran/aflpin

AFL-style instrumentation in llvm (Kostya Serebryany)
-----------------------------------------------------

  Allows AFL-equivalent instrumentation to be injected at compiler level.
  This is currently not supported by AFL as-is, but may be useful in other
  projects.

  https://code.google.com/p/address-sanitizer/wiki/AsanCoverage#Coverage_counters

AFL JS (Han Choongwoo)
----------------------

  One-off optimizations to speed up the fuzzing of JavaScriptCore (now likely
  superseded by LLVM deferred forkserver init - see llvm_mode/README.llvm).

  https://github.com/tunz/afl-fuzz-js

AFL harness for fwknop (Michael Rash)
-------------------------------------

  An example of a fairly involved integration with AFL.

  https://github.com/mrash/fwknop/tree/master/test/afl

Building harnesses for DNS servers (Jonathan Foote, Ron Bowes)
--------------------------------------------------------------

  Two articles outlining the general principles and showing some example code.

  https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop
  https://goo.gl/j9EgFf

Fuzzer shell for SQLite (Richard Hipp)
--------------------------------------

  A simple SQL shell designed specifically for fuzzing the underlying library.

  http://www.sqlite.org/src/artifact/9e7e273da2030371


```

`afl_docs/status_screen.txt`:

```txt
===============================
Understanding the status screen
===============================

  This document provides an overview of the status screen - plus tips for
  troubleshooting any warnings and red text shown in the UI. See README for
  the general instruction manual.

0) A note about colors
----------------------

The status screen and error messages use colors to keep things readable and
attract your attention to the most important details. For example, red almost
always means "consult this doc" :-)

Unfortunately, the UI will render correctly only if your terminal is using
traditional un*x palette (white text on black background) or something close
to that.

If you are using inverse video, you may want to change your settings, say:

  - For GNOME Terminal, go to Edit > Profile preferences, select the "colors"
    tab, and from the list of built-in schemes, choose "white on black".

  - For the MacOS X Terminal app, go to Preferences > Settings, click on
    the "Pro" color scheme, and select "Use bright colors for bold text".
    Then, open a new window using the "Pro" scheme via the Shell > New Window
    menu (or make "Pro" your default).

Alternatively, if you really like your current colors, you can edit config.h
to comment out USE_COLORS, then do 'make clean all'.

I'm not aware of any other simple way to make this work without causing
other side effects - sorry about that.

With that out of the way, let's talk about what's actually on the screen...

1) Process timing
-----------------

  +----------------------------------------------------+
  |        run time : 0 days, 8 hrs, 32 min, 43 sec    |
  |   last new path : 0 days, 0 hrs, 6 min, 40 sec     |
  | last uniq crash : none seen yet                    |
  |  last uniq hang : 0 days, 1 hrs, 24 min, 32 sec    |
  +----------------------------------------------------+

This section is fairly self-explanatory: it tells you how long the fuzzer has
been running and how much time has elapsed since its most recent finds. This is
broken down into "paths" (a shorthand for test cases that trigger new execution
patterns), crashes, and hangs.

When it comes to timing: there is no hard rule, but most fuzzing jobs should be
expected to run for days or weeks; in fact, for a moderately complex project, the
first pass will probably take a day or so. Every now and then, some jobs
will be allowed to run for months.

There's one important thing to watch out for: if the tool is not finding new
paths within several minutes of starting, you're probably not invoking the
target binary correctly and it never gets to parse the input files we're
throwing at it; another possible explanations are that the default memory limit
(-m) is too restrictive, and the program exits after failing to allocate a
buffer very early on; or that the input files are patently invalid and always
fail a basic header check.

If there are no new paths showing up for a while, you will eventually see a big
red warning in this section, too :-)

2) Overall results
------------------

  +-----------------------+
  |  cycles done : 0      |
  |  total paths : 2095   |
  | uniq crashes : 0      |
  |   uniq hangs : 19     |
  +-----------------------+

The first field in this section gives you the count of queue passes done so far
- that is, the number of times the fuzzer went over all the interesting test
cases discovered so far, fuzzed them, and looped back to the very beginning.
Every fuzzing session should be allowed to complete at least one cycle; and
ideally, should run much longer than that.

As noted earlier, the first pass can take a day or longer, so sit back and
relax. If you want to get broader but more shallow coverage right away, try
the -d option - it gives you a more familiar experience by skipping the
deterministic fuzzing steps. It is, however, inferior to the standard mode in
a couple of subtle ways.

To help make the call on when to hit Ctrl-C, the cycle counter is color-coded.
It is shown in magenta during the first pass, progresses to yellow if new finds
are still being made in subsequent rounds, then blue when that ends - and
finally, turns green after the fuzzer hasn't been seeing any action for a
longer while.

The remaining fields in this part of the screen should be pretty obvious:
there's the number of test cases ("paths") discovered so far, and the number of
unique faults. The test cases, crashes, and hangs can be explored in real-time
by browsing the output directory, as discussed in the README.

3) Cycle progress
-----------------

  +-------------------------------------+
  |  now processing : 1296 (61.86%)     |
  | paths timed out : 0 (0.00%)         |
  +-------------------------------------+

This box tells you how far along the fuzzer is with the current queue cycle: it
shows the ID of the test case it is currently working on, plus the number of
inputs it decided to ditch because they were persistently timing out.

The "*" suffix sometimes shown in the first line means that the currently
processed path is not "favored" (a property discussed later on, in section 6).

If you feel that the fuzzer is progressing too slowly, see the note about the
-d option in section 2 of this doc.

4) Map coverage
---------------

  +--------------------------------------+
  |    map density : 4763 (29.07%)       |
  | count coverage : 4.03 bits/tuple     |
  +--------------------------------------+

The section provides some trivia about the coverage observed by the
instrumentation embedded in the target binary.

The first line in the box tells you how many branch tuples we have already
hit, in proportion to how much the bitmap can hold. Be wary of extremes:

  - Absolute numbers below 200 or so suggest one of three things: that the
    program is extremely simple; that it is not instrumented properly (e.g.,
    due to being linked against a non-instrumented copy of the target
    library); or that it is bailing out prematurely on your input test cases.
    The fuzzer will try to mark this in pink, just to make you aware.

  - Percentages over 70% may very rarely happen with very complex programs
    that make heavy use of template-generated code.

    Because high bitmap density makes it harder for the fuzzer to reliably
    discern new program states, I recommend recompiling the binary with
    AFL_INST_RATIO=10 or so and trying again (see env_variables.txt).

    The fuzzer will flag high percentages in red. Chances are, you will never
    see that unless you're fuzzing extremely hairy software (say, v8, perl,
    ffmpeg).

The other line deals with the variability in tuple hit counts seen in the
binary. In essence, if every taken branch is always taken a fixed number of
times for all the inputs we have tried, this will read "1.00". As we manage
to trigger other hit counts for every branch, the needle will start to move
toward "8.00" (every bit in the 8-bit map hit), but will probably never
reach that extreme.

Together, the values can be useful for comparing the coverage of several
different fuzzing jobs that rely on the same instrumented binary.

5) Stage progress
-----------------

  +-------------------------------------+
  |  now trying : interest 32/8         |
  | stage execs : 3996/34.4k (11.62%)   |
  | total execs : 27.4M                 |
  |  exec speed : 891.7/sec             |
  +-------------------------------------+

This part gives you an in-depth peek at what the fuzzer is actually doing right
now. It tells you about the current stage, which can be any of:

  - calibration - a pre-fuzzing stage where the execution path is examined
    to detect anomalies, establish baseline execution speed, and so on. Executed
    very briefly whenever a new find is being made.

  - trim L/S - another pre-fuzzing stage where the test case is trimmed to the
    shortest form that still produces the same execution path. The length (L)
    and stepover (S) are chosen in general relationship to file size.

  - bitflip L/S - deterministic bit flips. There are L bits toggled at any given
    time, walking the input file with S-bit increments. The current L/S variants
    are: 1/1, 2/1, 4/1, 8/8, 16/8, 32/8.

  - arith L/8 - deterministic arithmetics. The fuzzer tries to subtract or add
    small integers to 8-, 16-, and 32-bit values. The stepover is always 8 bits.

  - interest L/8 - deterministic value overwrite. The fuzzer has a list of known
    "interesting" 8-, 16-, and 32-bit values to try. The stepover is 8 bits.

  - extras - deterministic injection of dictionary terms. This can be shown as
    "user" or "auto", depending on whether the fuzzer is using a user-supplied
    dictionary (-x) or an auto-created one. You will also see "over" or "insert",
    depending on whether the dictionary words overwrite existing data or are
    inserted by offsetting the remaining data to accommodate their length.

  - havoc - a sort-of-fixed-length cycle with stacked random tweaks. The
    operations attempted during this stage include bit flips, overwrites with
    random and "interesting" integers, block deletion, block duplication, plus
    assorted dictionary-related operations (if a dictionary is supplied in the
    first place).

  - splice - a last-resort strategy that kicks in after the first full queue
    cycle with no new paths. It is equivalent to 'havoc', except that it first
    splices together two random inputs from the queue at some arbitrarily
    selected midpoint.

  - sync - a stage used only when -M or -S is set (see parallel_fuzzing.txt).
    No real fuzzing is involved, but the tool scans the output from other
    fuzzers and imports test cases as necessary. The first time this is done,
    it may take several minutes or so.

The remaining fields should be fairly self-evident: there's the exec count
progress indicator for the current stage, a global exec counter, and a
benchmark for the current program execution speed. This may fluctuate from
one test case to another, but the benchmark should be ideally over 500 execs/sec
most of the time - and if it stays below 100, the job will probably take very
long.

The fuzzer will explicitly warn you about slow targets, too. If this happens,
see the perf_tips.txt file included with the fuzzer for ideas on how to speed
things up.

6) Findings in depth
--------------------

  +--------------------------------------+
  | favored paths : 879 (41.96%)         |
  |  new edges on : 423 (20.19%)         |
  | total crashes : 0 (0 unique)         |
  |   total hangs : 24 (19 unique)       |
  +--------------------------------------+

This gives you several metrics that are of interest mostly to complete nerds.
The section includes the number of paths that the fuzzer likes the most based
on a minimization algorithm baked into the code (these will get considerably
more air time), and the number of test cases that actually resulted in better
edge coverage (versus just pushing the branch hit counters up). There are also
additional, more detailed counters for crashes and hangs.

7) Fuzzing strategy yields
--------------------------

  +-----------------------------------------------------+
  |   bit flips : 57/289k, 18/289k, 18/288k             |
  |  byte flips : 0/36.2k, 4/35.7k, 7/34.6k             |
  | arithmetics : 53/2.54M, 0/537k, 0/55.2k             |
  |  known ints : 8/322k, 12/1.32M, 10/1.70M            |
  |  dictionary : 9/52k, 1/53k, 1/24k                   |
  |       havoc : 1903/20.0M, 0/0                       |
  |        trim : 20.31%/9201, 17.05%                   |
  +-----------------------------------------------------+

This is just another nerd-targeted section keeping track of how many paths we
have netted, in proportion to the number of execs attempted, for each of the
fuzzing strategies discussed earlier on. This serves to convincingly validate
assumptions about the usefulness of the various approaches taken by afl-fuzz.

The trim strategy stats in this section are a bit different than the rest.
The first number in this line shows the ratio of bytes removed from the input
files; the second one corresponds to the number of execs needed to achieve this
goal. Finally, the third number shows the proportion of bytes that, although
not possible to remove, were deemed to have no effect and were excluded from
some of the more expensive deterministic fuzzing steps.

8) Path geometry
----------------

  +---------------------+
  |    levels : 5       |
  |   pending : 1570    |
  |  pend fav : 583     |
  | own finds : 0       |
  |  imported : 0       |
  |  variable : 0       |
  +---------------------+

The first field in this section tracks the path depth reached through the
guided fuzzing process. In essence: the initial test cases supplied by the
user are considered "level 1". The test cases that can be derived from that
through traditional fuzzing are considered "level 2"; the ones derived by
using these as inputs to subsequent fuzzing rounds are "level 3"; and so forth.
The maximum depth is therefore a rough proxy for how much value you're getting
out of the instrumentation-guided approach taken by afl-fuzz.

The next field shows you the number of inputs that have not gone through any
fuzzing yet. The same stat is also given for "favored" entries that the fuzzer
really wants to get to in this queue cycle (the non-favored entries may have to
wait a couple of cycles to get their chance).

Next, we have the number of new paths found during this fuzzing section and
imported from other fuzzer instances when doing parallelized fuzzing; and the
number of inputs that produce seemingly variable behavior in the tested binary.

That last bit is actually fairly interesting. There are four quasi-common
explanations for variable behavior of the tested program:

  - Use of uninitialized memory in conjunction with some intrinsic sources of
    entropy in the tested binary. This can be indicative of a security bug.

  - Multiple threads executing at once in semi-random order. Not a big deal,
    but to avoid hiccups, it's best to restrict instrumented programs to a
    single thread. Check compile-time options or run-time flags. For example,
    for ImageMagick, you can try --without-threads --disable-openmp; for
    ffmpeg, look for --disable-pthreads instead.

  - Attempts to create files that were already created during previous runs, or
    otherwise interact with some form of persistent state. This is harmless,
    but you may want to instruct the targeted program to write to stdout or to
    /dev/null to avoid surprises (and disable the creation of temporary files
    and similar artifacts, if applicable).

  - Hitting functionality that is actually designed to behave randomly. For
    example, when fuzzing sqlite, the fuzzer will dutifully detect variable
    behavior once the mutation engine generates something like:

    select random();

Less likely causes may include running out of disk space, SHM handles, or other
globally limited resources.

The paths where variable behavior is detected are marked with a matching entry
in the <out_dir>/queue/.state/variable_behavior/ directory, so you can look
them up easily.

If you can't suppress variable behavior and don't want to see these warnings,
simply set AFL_NO_VAR_CHECK=1 in the environment before running afl-fuzz. This
will also dramatically speed up session resumption.

9) CPU load
-----------

  [cpu: 25%]

This tiny widget shows the apparent CPU utilization on the local system. It is
calculated by taking the number of processes in the "runnable" state, and then
comparing it to the number of logical cores on the system.

If the value is shown in green, you are using fewer CPU cores than available on
your system and can probably parallelize to improve performance; for tips on
how to do that, see parallel_fuzzing.txt.

If the value is shown in red, your CPU is *possibly* oversubscribed, and
running additional fuzzers may not give you any benefits.

Of course, this benchmark is very simplistic; it tells you how many processes
are ready to run, but not how resource-hungry they may be. It also doesn't
distinguish between physical cores, logical cores, and virtualized CPUs; the
performance characteristics of each of these will differ quite a bit.

If you want a more accurate measurement, you can run the afl-gotcpu utility
from the command line.

10) Addendum: status and plot files
-----------------------------------

For unattended operation, some of the key status screen information can be also
found in a machine-readable format in the fuzzer_stats file in the output
directory. This includes:

  - start_time     - unix time indicating the start time of afl-fuzz
  - last_update    - unix time corresponding to the last update of this file
  - fuzzer_pid     - PID of the fuzzer process
  - cycles_done    - queue cycles completed so far
  - execs_done     - number of execve() calls attempted
  - execs_per_sec  - current number of execs per second
  - paths_total    - total number of entries in the queue
  - paths_found    - number of entries discovered through local fuzzing
  - paths_imported - number of entries imported from other instances
  - max_depth      - number of levels in the generated data set
  - cur_path       - currently processed entry number
  - pending_favs   - number of favored entries still waiting to be fuzzed
  - pending_total  - number of all entries waiting to be fuzzed
  - variable_paths - number of test cases showing variable behavior
  - unique_crashes - number of unique crashes recorded
  - unique_hangs   - number of unique hangs encountered

Most of these map directly to the UI elements discussed earlier on.

On top of that, you can also find an entry called 'plot_data', containing a
plottable history for most of these fields. If you have gnuplot installed, you
can turn this into a nice progress report with the included 'afl-plot' tool.

```

`afl_docs/technical_details.txt`:

```txt
===================================
Technical "whitepaper" for afl-fuzz
===================================

  This document provides a quick overview of the guts of American Fuzzy Lop.
  See README for the general instruction manual; and for a discussion of
  motivations and design goals behind AFL, see historical_notes.txt.

0) Design statement
-------------------

American Fuzzy Lop does its best not to focus on any singular principle of
operation and not be a proof-of-concept for any specific theory. The tool can
be thought of as a collection of hacks that have been tested in practice,
found to be surprisingly effective, and have been implemented in the simplest,
most robust way I could think of at the time.

Many of the resulting features are made possible thanks to the availability of
lightweight instrumentation that served as a foundation for the tool, but this
mechanism should be thought of merely as a means to an end. The only true
governing principles are speed, reliability, and ease of use.

1) Coverage measurements
------------------------

The instrumentation injected into compiled programs captures branch (edge)
coverage, along with coarse branch-taken hit counts. The code injected at
branch points is essentially equivalent to:

  cur_location = <COMPILE_TIME_RANDOM>;
  shared_mem[cur_location ^ prev_location]++; 
  prev_location = cur_location >> 1;

The cur_location value is generated randomly to simplify the process of
linking complex projects and keep the XOR output distributed uniformly.

The shared_mem[] array is a 64 kB SHM region passed to the instrumented binary
by the caller. Every byte set in the output map can be thought of as a hit for
a particular (branch_src, branch_dst) tuple in the instrumented code.

The size of the map is chosen so that collisions are sporadic with almost all
of the intended targets, which usually sport between 2k and 10k discoverable
branch points:

   Branch cnt | Colliding tuples | Example targets
  ------------+------------------+-----------------
        1,000 | 0.75%            | giflib, lzo
        2,000 | 1.5%             | zlib, tar, xz
        5,000 | 3.5%             | libpng, libwebp
       10,000 | 7%               | libxml
       20,000 | 14%              | sqlite
       50,000 | 30%              | -

At the same time, its size is small enough to allow the map to be analyzed
in a matter of microseconds on the receiving end, and to effortlessly fit
within L2 cache.

This form of coverage provides considerably more insight into the execution
path of the program than simple block coverage. In particular, it trivially
distinguishes between the following execution traces:

  A -> B -> C -> D -> E (tuples: AB, BC, CD, DE)
  A -> B -> D -> C -> E (tuples: AB, BD, DC, CE)

This aids the discovery of subtle fault conditions in the underlying code,
because security vulnerabilities are more often associated with unexpected
or incorrect state transitions than with merely reaching a new basic block.

The reason for the shift operation in the last line of the pseudocode shown
earlier in this section is to preserve the directionality of tuples (without
this, A ^ B would be indistinguishable from B ^ A) and to retain the identity
of tight loops (otherwise, A ^ A would be obviously equal to B ^ B).

The absence of simple saturating arithmetic opcodes on Intel CPUs means that
the hit counters can sometimes wrap around to zero. Since this is a fairly
unlikely and localized event, it's seen as an acceptable performance trade-off.

2) Detecting new behaviors
--------------------------

The fuzzer maintains a global map of tuples seen in previous executions; this
data can be rapidly compared with individual traces and updated in just a couple
of dword- or qword-wide instructions and a simple loop.

When a mutated input produces an execution trace containing new tuples, the
corresponding input file is preserved and routed for additional processing
later on (see section #3). Inputs that do not trigger new local-scale state
transitions in the execution trace are discarded, even if their overall
instrumentation output pattern is unique.

This approach allows for a very fine-grained and long-term exploration of
program state while not having to perform any computationally intensive and
fragile global comparisons of complex execution traces, and while avoiding the
scourge of path explosion.

To illustrate the properties of the algorithm, consider that the second trace
shown below would be considered substantially new because of the presence of
new tuples (CA, AE):

  #1: A -> B -> C -> D -> E
  #2: A -> B -> C -> A -> E

At the same time, with #2 processed, the following pattern will not be seen
as unique, despite having a markedly different execution path:

  #3: A -> B -> C -> A -> B -> C -> A -> B -> C -> D -> E

In addition to detecting new tuples, the fuzzer also considers coarse tuple
hit counts. These are divided into several buckets:

  1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+

To some extent, the number of buckets is an implementation artifact: it allows
an in-place mapping of an 8-bit counter generated by the instrumentation to
an 8-position bitmap relied on by the fuzzer executable to keep track of the
already-seen execution counts for each tuple.

Changes within the range of a single bucket are ignored; transition from one
bucket to another is flagged as an interesting change in program control flow,
and is routed to the evolutionary process outlined in the section below.

The hit count behavior provides a way to distinguish between potentially
interesting control flow changes, such as a block of code being executed
twice when it was normally hit only once. At the same time, it is fairly
insensitive to empirically less notable changes, such as a loop going from
47 cycles to 48. The counters also provide some degree of "accidental"
immunity against tuple collisions in dense trace maps.

The execution is policed fairly heavily through memory and execution time
limits; by default, the timeout is set at 5x the initially-calibrated
execution speed, rounded up to 20 ms. The aggressive timeouts are meant to
prevent dramatic fuzzer performance degradation by descending into tarpits
that, say, improve coverage by 1% while being 100x slower; we pragmatically
reject them and hope that the fuzzer will find a less expensive way to reach
the same code. Empirical testing strongly suggests that more generous time
limits are not worth the cost.

3) Evolving the input queue
---------------------------

Mutated test cases that produced new state transitions within the program are
added to the input queue and used as a starting point for future rounds of
fuzzing. They supplement, but do not automatically replace, existing finds.

This approach allows the tool to progressively explore various disjoint and
possibly mutually incompatible features of the underlying data format, as
shown in this image:

  http://lcamtuf.coredump.cx/afl/afl_gzip.png

Several practical examples of the results of this algorithm are discussed
here:

  http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html
  http://lcamtuf.blogspot.com/2014/11/afl-fuzz-nobody-expects-cdata-sections.html

The synthetic corpus produced by this process is essentially a compact
collection of "hmm, this does something new!" input files, and can be used to
seed any other testing processes down the line (for example, to manually
stress-test resource-intensive desktop apps).

With this approach, the queue for most targets grows to somewhere between 1k
and 10k entries; approximately 10-30% of this is attributable to the discovery
of new tuples, and the remainder is associated with changes in hit counts.

The following table compares the relative ability to discover file syntax and
explore program states when using several different approaches to guided
fuzzing. The instrumented target was GNU patch 2.7.3 compiled with -O3 and
seeded with a dummy text file; the session consisted of a single pass over the
input queue with afl-fuzz:

    Fuzzer guidance | Blocks  | Edges   | Edge hit | Highest-coverage
      strategy used | reached | reached | cnt var  | test case generated
  ------------------+---------+---------+----------+---------------------------
     (Initial file) | 156     | 163     | 1.00     | (none)
                    |         |         |          |
    Blind fuzzing S | 182     | 205     | 2.23     | First 2 B of RCS diff
    Blind fuzzing L | 228     | 265     | 2.23     | First 4 B of -c mode diff
     Block coverage | 855     | 1,130   | 1.57     | Almost-valid RCS diff
      Edge coverage | 1,452   | 2,070   | 2.18     | One-chunk -c mode diff
          AFL model | 1,765   | 2,597   | 4.99     | Four-chunk -c mode diff

The first entry for blind fuzzing ("S") corresponds to executing just a single
round of testing; the second set of figures ("L") shows the fuzzer running in a
loop for a number of execution cycles comparable with that of the instrumented
runs, which required more time to fully process the growing queue.

Roughly similar results have been obtained in a separate experiment where the
fuzzer was modified to compile out all the random fuzzing stages and leave just
a series of rudimentary, sequential operations such as walking bit flips.
Because this mode would be incapable of altering the size of the input file,
the sessions were seeded with a valid unified diff:

    Queue extension | Blocks  | Edges   | Edge hit | Number of unique
      strategy used | reached | reached | cnt var  | crashes found
  ------------------+---------+---------+----------+------------------
     (Initial file) | 624     | 717     | 1.00     | -
                    |         |         |          |
      Blind fuzzing | 1,101   | 1,409   | 1.60     | 0
     Block coverage | 1,255   | 1,649   | 1.48     | 0
      Edge coverage | 1,259   | 1,734   | 1.72     | 0
          AFL model | 1,452   | 2,040   | 3.16     | 1

Some of the earlier work on evolutionary fuzzing suggested maintaining just a
single test case and selecting for mutations that improve coverage. At least
in the tests described above, this "greedy" method appeared to offer no
substantial benefits over blind fuzzing.

4) Culling the corpus
---------------------

The progressive state exploration approach outlined above means that some of
the test cases synthesized later on in the game may have edge coverage that
is a strict superset of the coverage provided by their ancestors.

To optimize the fuzzing effort, AFL periodically re-evaluates the queue using a
fast algorithm that selects a smaller subset of test cases that still cover
every tuple seen so far, and whose characteristics make them particularly
favorable to the tool.

The algorithm works by assigning every queue entry a score proportional to its
execution latency and file size; and then selecting lowest-scoring candidates
for each tuple.

The tuples are then processed sequentially using a simple workflow:

  1) Find next tuple not yet in the temporary working set,

  2) Locate the winning queue entry for this tuple,

  3) Register *all* tuples present in that entry's trace in the working set,

  4) Go to #1 if there are any missing tuples in the set.

The generated corpus of "favored" entries is usually 5-10x smaller than the
starting data set. Non-favored entries are not discarded, but they are skipped
with varying probabilities when encountered in the queue:

  - If there are new, yet-to-be-fuzzed favorites present in the queue, 99%
    of non-favored entries will be skipped to get to the favored ones.

  - If there are no new favorites:

    - If the current non-favored entry was fuzzed before, it will be skipped
      95% of the time.

    - If it hasn't gone through any fuzzing rounds yet, the odds of skipping
      drop down to 75%.

Based on empirical testing, this provides a reasonable balance between queue
cycling speed and test case diversity.

Slightly more sophisticated but much slower culling can be performed on input
or output corpora with afl-cmin. This tool permanently discards the redundant
entries and produces a smaller corpus suitable for use with afl-fuzz or
external tools.

5) Trimming input files
-----------------------

File size has a dramatic impact on fuzzing performance, both because large
files make the target binary slower, and because they reduce the likelihood
that a mutation would touch important format control structures, rather than
redundant data blocks. This is discussed in more detail in perf_tips.txt.

The possibility of a bad starting corpus provided by the user aside, some
types of mutations can have the effect of iteratively increasing the size of
the generated files, so it is important to counter this trend.

Luckily, the instrumentation feedback provides a simple way to automatically
trim down input files while ensuring that the changes made to the files have no
impact on the execution path.

The built-in trimmer in afl-fuzz attempts to sequentially remove blocks of data
with variable length and stepover; any deletion that doesn't affect the checksum
of the trace map is committed to disk. The trimmer is not designed to be
particularly thorough; instead, it tries to strike a balance between precision
and the number of execve() calls spent on the process. The average per-file
gains are around 5-20%.

The standalone afl-tmin tool uses a more exhaustive, iterative algorithm, and
also attempts to perform alphabet normalization on the trimmed files.

6) Fuzzing strategies
---------------------

The feedback provided by the instrumentation makes it easy to understand the
value of various fuzzing strategies and optimize their parameters so that they
work equally well across a wide range of file types. The strategies used by
afl-fuzz are generally format-agnostic and are discussed in more detail here:

  http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html

It is somewhat notable that especially early on, most of the work done by
afl-fuzz is actually highly deterministic, and progresses to random stacked
modifications and test case splicing only at a later stage. The deterministic
strategies include:

  - Sequential bit flips with varying lengths and stepovers,

  - Sequential addition and subtraction of small integers,

  - Sequential insertion of known interesting integers (0, 1, INT_MAX, etc),

The non-deterministic steps include stacked bit flips, insertions, deletions,
arithmetics, and splicing of different test cases.

Their relative yields and execve() costs have been investigated and are
discussed in the aforementioned blog post.

For the reasons discussed in historical_notes.txt (chiefly, performance,
simplicity, and reliability), AFL generally does not try to reason about the
relationship between specific mutations and program states; the fuzzing steps
are nominally blind, and are guided only by the evolutionary design of the
input queue.

That said, there is one (trivial) exception to this rule: when a new queue
entry goes through the initial set of deterministic fuzzing steps, and some
regions in the file are observed to have no effect on the checksum of the
execution path, they may be excluded from the remaining phases of
deterministic fuzzing - and proceed straight to random tweaks. Especially for
verbose, human-readable data formats, this can reduce the number of execs by
10-40% or so without an appreciable drop in coverage. In extreme cases, such
as normally block-aligned tar archives, the gains can be as high as 90%.

Because the underlying "effector maps" are local every queue entry and remain
in force only during deterministic stages that do not alter the size or the
general layout of the underlying file, this mechanism appears to work very
reliably and proved to be simple to implement.

7) Dictionaries
---------------

The feedback provided by the instrumentation makes it easy to automatically
identify syntax tokens in some types of input files, and to detect that certain
combinations of predefined or auto-detected dictionary terms constitute a
valid grammar for the tested parser.

A discussion of how these features are implemented within afl-fuzz can be found
here:

  http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html

In essence, when basic, typically easily-obtained syntax tokens are combined
together in a purely random manner, the instrumentation and the evolutionary
design of the queue together provide a feedback mechanism to differentiate
between meaningless mutations and ones that trigger new behaviors in the
instrumented code - and to incrementally build more complex syntax on top of
this discovery.

The dictionaries have been shown to enable the fuzzer to rapidly reconstruct
the grammar of highly verbose and complex languages such as JavaScript, SQL,
or XML; several examples of generated SQL statements are given in the blog
post mentioned above.

8) De-duping crashes
--------------------

De-duplication of crashes is one of the more important problems for any
competent fuzzing tool. Many of the naive approaches run into problems; in
particular, looking just at the faulting address may lead to completely
unrelated issues being clustered together if the fault happens in a common
library function (say, strcmp, strcpy); while checksumming call stack
backtraces can lead to extreme crash count inflation if the fault can be
reached through a number of different, possibly recursive code paths.

The solution implemented in afl-fuzz considers a crash unique if any of two
conditions are met:

  - The crash trace includes a tuple not seen in any of the previous crashes,

  - The crash trace is missing a tuple that was always present in earlier
    faults.

The approach is vulnerable to some path count inflation early on, but exhibits
a very strong self-limiting effect, similar to the execution path analysis
logic that is the cornerstone of afl-fuzz.

9) Investigating crashes
------------------------

The exploitability of many types of crashes can be ambiguous; afl-fuzz tries
to address this by providing a crash exploration mode where a known-faulting
test case is fuzzed in a manner very similar to the normal operation of the
fuzzer, but with a constraint that causes any non-crashing mutations to be
thrown away.

A detailed discussion of the value of this approach can be found here:

  http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html

The method uses instrumentation feedback to explore the state of the crashing
program to get past the ambiguous faulting condition and then isolate the
newly-found inputs for human review.

On the subject of crashes, it is worth noting that in contrast to normal
queue entries, crashing inputs are *not* trimmed; they are kept exactly as
discovered to make it easier to compare them to the parent, non-crashing entry
in the queue. That said, afl-tmin can be used to shrink them at will.

10) The fork server
-------------------

To improve performance, afl-fuzz uses a "fork server", where the fuzzed process
goes through execve(), linking, and libc initialization only once, and is then
cloned from a stopped process image by leveraging copy-on-write. The
implementation is described in more detail here:

  http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html

The fork server is an integral aspect of the injected instrumentation and
simply stops at the first instrumented function to await commands from
afl-fuzz.

With fast targets, the fork server can offer considerable performance gains,
usually between 1.5x and 2x. It is also possible to:

  - Use the fork server in manual ("deferred") mode, skipping over larger,
    user-selected chunks of initialization code. With some targets, this can
    produce 10x+ performance gains.

  - Enable "persistent" mode, where a single process is used to try out
    multiple inputs, greatly limiting the overhead of repetitive fork()
    calls. As with the previous mode, this requires custom modifications,
    but can improve the performance of fast targets by a factor of 5 or more
    - approximating the benefits of in-process fuzzing jobs.

11) Parallelization
-------------------

The parallelization mechanism relies on periodically examining the queues
produced by independently-running instances on other CPU cores or on remote
machines, and then selectively pulling in the test cases that produce behaviors
not yet seen by the fuzzer at hand.

This allows for extreme flexibility in fuzzer setup, including running synced
instances against different parsers of a common data format, often with
synergistic effects.

For more information about this design, see parallel_fuzzing.txt.

12) Binary-only instrumentation
-------------------------------

Instrumentation of black-box, binary-only targets is accomplished with the
help of a separately-built version of QEMU in "user emulation" mode. This also
allows the execution of cross-architecture code - say, ARM binaries on x86.

QEMU uses basic blocks as translation units; the instrumentation is implemented
on top of this and uses a model roughly analogous to the compile-time hooks:

  if (block_address > elf_text_start && block_address < elf_text_end) {

    cur_location = (block_address >> 4) ^ (block_address << 8);
    shared_mem[cur_location ^ prev_location]++; 
    prev_location = cur_location >> 1;

  }

The shift-and-XOR-based scrambling in the second line is used to mask the
effects of instruction alignment.

The start-up of binary translators such as QEMU, DynamoRIO, and PIN is fairly
slow; to counter this, the QEMU mode leverages a fork server similar to that
used for compiler-instrumented code, effectively spawning copies of an
already-initialized process paused at _start.

First-time translation of a new basic block also incurs substantial latency. To
eliminate this problem, the AFL fork server is extended by providing a channel
between the running emulator and the parent process. The channel is used
to notify the parent about the addresses of any newly-encountered blocks and to
add them to the translation cache that will be replicated for future child
processes.

As a result of these two optimizations, the overhead of the QEMU mode is
roughly 2-5x, compared to 100x+ for PIN.

```

`afl_docs/vuln_samples/bash-cmd-exec.var`:

```var
() { _; } >_[$($())] { id; }
```

`afl_docs/vuln_samples/bash-uninit-mem.var`:

```var
() { x() { _; }; x() { _; } <<a; }
```

`afl_docs/vuln_samples/libxml2-bad-read.xml`:

```xml
<!DOCTYPEd[<!ENTITY
S	""><!ENTITY %
N	"<!ELEMENT<![INCLUDE0"<!ENTITYL%N;
```

`afl_docs/vuln_samples/sqlite-bad-free.sql`:

```sql
create table t0(o CHar(0)CHECK(0&O>O));insert into t0
select randomblob(0)-trim(0);

```

`afl_docs/vuln_samples/sqlite-bad-ptr.sql`:

```sql
SELECT 0 UNION SELECT 0 ORDER BY 1 COLLATE"""""""";

```

`afl_docs/vuln_samples/sqlite-bad-ptr2.sql`:

```sql
PRAGMA foreign_keys=1;CREATE TABLE t1("""0"PRIMARY KEy REFERENCES t1 ON DELETE SET NULL);REPLACE INTO t1 SELECT(0);

```

`afl_docs/vuln_samples/sqlite-heap-overflow.sql`:

```sql
DROP TABLE IF EXISTS t;CREATE VIRTUAL TABLE t0 USING fts4();insert into t0 select zeroblob(0);SAVEPOINT O;insert into t0
select(0);SAVEPOINT E;insert into t0 SELECT 0 UNION SELECT 0'x'ORDER BY x;

```

`afl_docs/vuln_samples/sqlite-heap-overwrite.sql`:

```sql
ATTACH "file:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA?mode=memory&cache=shared" AS x;
```

`afl_docs/vuln_samples/sqlite-negative-memset.sql`:

```sql
SELECT*from(select"",zeroblob(0),zeroblob(1E9),zeroblob(0),zeroblob(150000000),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(1E9),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0)),(select"",zeroblob(1E9),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(1E9),(0),zeroblob(150000000),(0),zeroblob(0),(0)EXCEPT select zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0),zeroblob(0));

```

`afl_docs/vuln_samples/sqlite-null-ptr1.sql`:

```sql
create table t0(t);insert into t0
select strftime();

```

`afl_docs/vuln_samples/sqlite-null-ptr10.sql`:

```sql
SELECT fts3_tokenizer(@0());

```

`afl_docs/vuln_samples/sqlite-null-ptr11.sql`:

```sql
select''like''like''like#0;

```

`afl_docs/vuln_samples/sqlite-null-ptr12.sql`:

```sql
PRAGMA e;select lower(0);select lower(0)"a",""GROUP BY a ORDER BY a;

```

`afl_docs/vuln_samples/sqlite-null-ptr13.sql`:

```sql
WITH x AS(SELECT*FROM t)SELECT""EXCEPT SELECT 0 ORDER BY 0 COLLATE"";

```

`afl_docs/vuln_samples/sqlite-null-ptr14.sql`:

```sql
CREATE VIRTUAL TABLE x USING fts4();VALUES(0,0),(0,0),(0,0),(0,0);PRAGMA writable_schema=ON;UPDATE sqlite_master SET sql=''WHERE name='';UPDATE sqlite_master SET sql='CREATE table t(d CHECK(T(#0)';SAVEPOINT K;SAVEPOINT T;SAVEPOINT T;ANALYZE;ROLLBACK;SAVEPOINT E;DROP TABLE IF EXISTS t;

```

`afl_docs/vuln_samples/sqlite-null-ptr15.sql`:

```sql
CREATE VIRTUAL TABLE t4 USING fts4(0,b,c,notindexed=0);INSERT INTO t4 VALUES('','','0');BEGIN;INSERT INTO t4 VALUES('','','0');INSERT INTO t4(t4)VALUES('integrity-check');

```

`afl_docs/vuln_samples/sqlite-null-ptr2.sql`:

```sql
DETACH(select group_concat(q));

```

`afl_docs/vuln_samples/sqlite-null-ptr3.sql`:

```sql
select(select strftime());

```

`afl_docs/vuln_samples/sqlite-null-ptr4.sql`:

```sql
select n()AND+#00;

```

`afl_docs/vuln_samples/sqlite-null-ptr5.sql`:

```sql
select e.*,0 from(s,(L))e;

```

`afl_docs/vuln_samples/sqlite-null-ptr6.sql`:

```sql
PRAGMA encoding='UTF16';CREATE VIRTUAL TABLE È USING s;
```

`afl_docs/vuln_samples/sqlite-null-ptr7.sql`:

```sql
CREATE VIRTUAL TABLE t USING fts4(tokenize=);

```

`afl_docs/vuln_samples/sqlite-null-ptr8.sql`:

```sql
CREATE TABLE p(a UNIQUE,PRIMARY KEY('a'))WITHOUT rowid;

```

`afl_docs/vuln_samples/sqlite-null-ptr9.sql`:

```sql
CREATE TABLE t0(z);WITH d(x)AS(SELECT*UNION SELECT 0)INSERT INTO t0 SELECT 0 FROM d;

```

`afl_docs/vuln_samples/sqlite-oob-read.sql`:

```sql
create table t0(‰ DEFAULT(0=0)NOT/**/NULL);REPLACE into t0 select'';
```

`afl_docs/vuln_samples/sqlite-oob-write.sql`:

```sql
CREATE VIRTUAL TABLE t0 USING fts4(x,order=DESC);
INSERT INTO t0(docid,x)VALUES(-1E0,'0(o');
INSERT INTO t0 VALUES('');
INSERT INTO t0 VALUES('');
INSeRT INTO t0 VALUES('o');
SELECT docid FROM t0 WHERE t0 MATCH'"0*o"';

```

`afl_docs/vuln_samples/sqlite-stack-buf-overflow.sql`:

```sql
SELECT printf('%*.*f',90000||006000000&6600000000,00000000000000000909000000000000.0000000000000000)""WHERE"">"";

```

`afl_docs/vuln_samples/sqlite-stack-exhaustion.sql`:

```sql
CREATE VIRTUAL TABLE t0 USING fts4(content=t0);

```

`afl_docs/vuln_samples/sqlite-unint-mem.sql`:

```sql
REATE VIRTUAL TABLE t0 USING fts4(prefix=0);INSERT INTO t0 VALUES(0);

```

`afl_docs/vuln_samples/sqlite-use-after-free.sql`:

```sql
create table t(s);PRAGMA writable_schema=ON;UPDATE sqlite_master SET sql='ANALYZE;CREATE VIRTUAL TABLE t USING fts3;DROP TABLE t;DROP TABLE EXISTS t';PRAGMA r;SAVEPOINT T;ANALYZE;ROLLBACK;SAVEPOINT E;DROP TABLE IF EXISTS t;

```

`afl_docs/vuln_samples/strings-stack-overflow`:

```
$$@$$$@$o
S…Ôo
S…Ô
```

`afl_post_library/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.6)

project(post_library)

set(CMAKE_CXX_FLAGS_RELEASE "/MT")
set(CMAKE_CXX_FLAGS_DEBUG "/MTd")

set(CMAKE_C_FLAGS_RELEASE "/MT")
set(CMAKE_C_FLAGS_DEBUG "/MTd")

add_library(post_library SHARED
  post_library.c
  )



```

`afl_post_library/post_library.c`:

```c
/*
   american fuzzy lop - postprocessor library example
   --------------------------------------------------
   Written and maintained by Michal Zalewski <lcamtuf@google.com>
   Copyright 2015 Google Inc. All rights reserved.
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:
     http://www.apache.org/licenses/LICENSE-2.0
   Postprocessor libraries can be passed to afl-fuzz to perform final cleanup
   of any mutated test cases - for example, to fix up checksums in PNG files.
   Please heed the following warnings:
   1) In almost all cases, it is more productive to comment out checksum logic
      in the targeted binary (as shown in ../libpng_no_checksum/). One possible
      exception is the process of fuzzing binary-only software in QEMU mode.
   2) The use of postprocessors for anything other than checksums is questionable
      and may cause more harm than good. AFL is normally pretty good about
      dealing with length fields, magic values, etc.
   3) Postprocessors that do anything non-trivial must be extremely robust to
      gracefully handle malformed data and other error conditions - otherwise,
      they will crash and take afl-fuzz down with them. Be wary of reading past
      *len and of integer overflows when calculating file offsets.
   In other words, THIS IS PROBABLY NOT WHAT YOU WANT - unless you really,
   honestly know what you're doing =)
   With that out of the way: the postprocessor library is passed to afl-fuzz
   via AFL_POST_LIBRARY. The library must be compiled with:
     gcc -shared -Wall -O3 post_library.so.c -o post_library.so
   AFL will call the afl_postprocess() function for every mutated output buffer.
   From there, you have three choices:
   1) If you don't want to modify the test case, simply return the original
      buffer pointer ('in_buf').
   2) If you want to skip this test case altogether and have AFL generate a
      new one, return NULL. Use this sparingly - it's faster than running
      the target program with patently useless inputs, but still wastes CPU
      time.
   3) If you want to modify the test case, allocate an appropriately-sized
      buffer, move the data into that buffer, make the necessary changes, and
      then return the new pointer. You can update *len if necessary, too.
      Note that the buffer will *not* be freed for you. To avoid memory leaks,
      you need to free it or reuse it on subsequent calls (as shown below).
      *** DO NOT MODIFY THE ORIGINAL 'in_buf' BUFFER. ***
    Aight. The example below shows a simple postprocessor that tries to make
    sure that all input files start with "GIF89a".
    PS. If you don't like C, you can try out the unix-based wrapper from
    Ben Nagy instead: https://github.com/bnagy/aflfix
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Header that must be present at the beginning of every test case: */

#define HEADER "GIF89a"

/* The actual postprocessor routine called by afl-fuzz: */
#ifdef __cplusplus
extern "C" {
#endif
#ifdef _MSC_VER
    __declspec(dllexport)
#endif
    const unsigned char* afl_postprocess(const unsigned char* in_buf,
                                         unsigned int* len) {

      static unsigned char* saved_buf;
      unsigned char* new_buf;

      /* Skip execution altogether for buffers shorter than 6 bytes (just to
         show how it's done). We can trust *len to be sane. */

      if (*len < strlen(HEADER)) return NULL;

      /* Do nothing for buffers that already start with the expected header. */

      if (!memcmp(in_buf, HEADER, strlen(HEADER))) return in_buf;

      /* Allocate memory for new buffer, reusing previous allocation if
         possible. */

      new_buf = realloc(saved_buf, *len);

      /* If we're out of memory, the most graceful thing to do is to return the
         original buffer and give up on modifying it. Let AFL handle OOM on its
         own later on. */

      if (!new_buf) return in_buf;
      saved_buf = new_buf;

      /* Copy the original data to the new location. */

      memcpy(new_buf, in_buf, *len);

      /* Insert the new header. */

      memcpy(new_buf, HEADER, strlen(HEADER));

      /* Return modified buffer. No need to update *len in this particular case,
         as we're not changing it. */

      return new_buf;

    }
#ifdef __cplusplus
}
#endif
```

`alloc-inl.h`:

```h
/*
   american fuzzy lop - error-checking, memory-zeroing alloc routines
   ------------------------------------------------------------------

   Original AFL code written by Michal Zalewski <lcamtuf@google.com>

   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

#ifndef _HAVE_ALLOC_INL_H
#define _HAVE_ALLOC_INL_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config.h"
#include "types.h"
#include "debug.h"

/* User-facing macro to sprintf() to a dynamically allocated buffer. */
/*
#define alloc_printf(_str, ...) ({ \
    u8* _tmp; \
    s32 _len = snprintf(NULL, 0, _str); \
    if (_len < 0) FATAL("Whoa, snprintf() fails?!"); \
    _tmp = ck_alloc(_len + 1); \
    snprintf((char*)_tmp, _len + 1, _str); \
    _tmp; \
  })
*/

/* Macro to enforce allocation limits as a last-resort defense against
   integer overflows. */

#define ALLOC_CHECK_SIZE(_s) do { \
    if ((_s) > MAX_ALLOC) \
      ABORT("Bad alloc request: %u bytes", (_s)); \
  } while (0)

/* Macro to check malloc() failures and the like. */

#define ALLOC_CHECK_RESULT(_r, _s) do { \
    if (!(_r)) \
      ABORT("Out of memory: can't allocate %u bytes", (_s)); \
  } while (0)

/* Magic tokens used to mark used / freed chunks. */

#define ALLOC_MAGIC_C1  0xFF00FF00 /* Used head (dword)  */
#define ALLOC_MAGIC_F   0xFE00FE00 /* Freed head (dword) */
#define ALLOC_MAGIC_C2  0xF0       /* Used tail (byte)   */

/* Positions of guard tokens in relation to the user-visible pointer. */

#define ALLOC_C1(_ptr)  (((u32*)(_ptr))[-2])
#define ALLOC_S(_ptr)   (((u32*)(_ptr))[-1])
#define ALLOC_C2(_ptr)  (((u8*)(_ptr))[ALLOC_S(_ptr)])

#define ALLOC_OFF_HEAD  8
#define ALLOC_OFF_TOTAL (ALLOC_OFF_HEAD + 1)

/* Allocator increments for ck_realloc_block(). */

#define ALLOC_BLK_INC    256

/* Sanity-checking macros for pointers. */

#define CHECK_PTR(_p) do { \
    if (_p) { \
      if (ALLOC_C1(_p) ^ ALLOC_MAGIC_C1) {\
        if (ALLOC_C1(_p) == ALLOC_MAGIC_F) \
          ABORT("Use after free."); \
        else ABORT("Corrupted head alloc canary."); \
      } \
      if (ALLOC_C2(_p) ^ ALLOC_MAGIC_C2) \
        ABORT("Corrupted tail alloc canary."); \
    } \
  } while (0)

#define CHECK_PTR_EXPR(_p) ({ \
    typeof (_p) _tmp = (_p); \
    CHECK_PTR(_tmp); \
    _tmp; \
  })


/* Allocate a buffer, explicitly not zeroing it. Returns NULL for zero-sized
   requests. */

static inline void* DFL_ck_alloc_nozero(u32 size) {

  char* ret;

  if (!size) return NULL;

  ALLOC_CHECK_SIZE(size);
  ret = malloc((size_t)size + ALLOC_OFF_TOTAL);
  ALLOC_CHECK_RESULT(ret, size);

  ret += ALLOC_OFF_HEAD;

  ALLOC_C1(ret) = ALLOC_MAGIC_C1;
  ALLOC_S(ret)  = size;
  ALLOC_C2(ret) = ALLOC_MAGIC_C2;

  return ret;

}


/* Allocate a buffer, returning zeroed memory. */

static inline void* DFL_ck_alloc(u32 size) {

  void* mem;

  if (!size) return NULL;
  mem = DFL_ck_alloc_nozero(size);

  return memset(mem, 0, size);

}


/* Free memory, checking for double free and corrupted heap. When DEBUG_BUILD
   is set, the old memory will be also clobbered with 0xFF. */

static inline void DFL_ck_free(char* mem) {

  if (!mem) return;

  CHECK_PTR(mem);

#ifdef DEBUG_BUILD

  /* Catch pointer issues sooner. */
  memset(mem, 0xFF, ALLOC_S(mem));

#endif /* DEBUG_BUILD */

  ALLOC_C1(mem) = ALLOC_MAGIC_F;

  free(mem - ALLOC_OFF_HEAD);

}


/* Re-allocate a buffer, checking for issues and zeroing any newly-added tail.
   With DEBUG_BUILD, the buffer is always reallocated to a new addresses and the
   old memory is clobbered with 0xFF. */

static inline void* DFL_ck_realloc(char* orig, u32 size) {

  char* ret;
  u32   old_size = 0;

  if (!size) {

    DFL_ck_free(orig);
    return NULL;

  }

  if (orig) {

    CHECK_PTR(orig);

#ifndef DEBUG_BUILD
    ALLOC_C1(orig) = ALLOC_MAGIC_F;
#endif /* !DEBUG_BUILD */

    old_size  = ALLOC_S(orig);
    orig     -= ALLOC_OFF_HEAD;

    ALLOC_CHECK_SIZE(old_size);

  }

  ALLOC_CHECK_SIZE(size);

#ifndef DEBUG_BUILD

  ret = realloc(orig, (size_t)size + ALLOC_OFF_TOTAL);
  ALLOC_CHECK_RESULT(ret, size);

#else

  /* Catch pointer issues sooner: force relocation and make sure that the
     original buffer is wiped. */

  ret = malloc(size + ALLOC_OFF_TOTAL);
  ALLOC_CHECK_RESULT(ret, size);

  if (orig) {

    memcpy(ret + ALLOC_OFF_HEAD, orig + ALLOC_OFF_HEAD, MIN(size, old_size));
    memset(orig + ALLOC_OFF_HEAD, 0xFF, old_size);

    ALLOC_C1(orig + ALLOC_OFF_HEAD) = ALLOC_MAGIC_F;

    free(orig);

  }

#endif /* ^!DEBUG_BUILD */

  ret += ALLOC_OFF_HEAD;

  ALLOC_C1(ret) = ALLOC_MAGIC_C1;
  ALLOC_S(ret)  = size;
  ALLOC_C2(ret) = ALLOC_MAGIC_C2;

  if (size > old_size)
    memset(ret + old_size, 0, size - old_size);

  return ret;

}


/* Re-allocate a buffer with ALLOC_BLK_INC increments (used to speed up
   repeated small reallocs without complicating the user code). */

static inline void* DFL_ck_realloc_block(void* orig, u32 size) {

#ifndef DEBUG_BUILD

  if (orig) {

    CHECK_PTR(orig);

    if (ALLOC_S(orig) >= size) return orig;

    size += ALLOC_BLK_INC;

  }

#endif /* !DEBUG_BUILD */

  return DFL_ck_realloc(orig, size);

}


/* Create a buffer with a copy of a string. Returns NULL for NULL inputs. */

static inline u8* DFL_ck_strdup(u8* str) {

  char* ret;
  u32   size;

  if (!str) return NULL;

  size = strlen((char*)str) + 1;

  ALLOC_CHECK_SIZE(size);
  ret = malloc((size_t)size + ALLOC_OFF_TOTAL);
  ALLOC_CHECK_RESULT(ret, size);

  ret += ALLOC_OFF_HEAD;

  ALLOC_C1(ret) = ALLOC_MAGIC_C1;
  ALLOC_S(ret)  = size;
  ALLOC_C2(ret) = ALLOC_MAGIC_C2;

  return memcpy(ret, str, size);

}


/* Create a buffer with a copy of a memory block. Returns NULL for zero-sized
   or NULL inputs. */

static inline void* DFL_ck_memdup(void* mem, u32 size) {

  char* ret;

  if (!mem || !size) return NULL;

  ALLOC_CHECK_SIZE(size);
  ret = malloc((size_t)size + ALLOC_OFF_TOTAL);
  ALLOC_CHECK_RESULT(ret, size);
  
  ret += ALLOC_OFF_HEAD;

  ALLOC_C1(ret) = ALLOC_MAGIC_C1;
  ALLOC_S(ret)  = size;
  ALLOC_C2(ret) = ALLOC_MAGIC_C2;

  return memcpy(ret, mem, size);

}


/* Create a buffer with a block of text, appending a NUL terminator at the end.
   Returns NULL for zero-sized or NULL inputs. */

static inline u8* DFL_ck_memdup_str(u8* mem, u32 size) {

  u8* ret;

  if (!mem || !size) return NULL;

  ALLOC_CHECK_SIZE(size);
  ret = malloc((size_t)size + ALLOC_OFF_TOTAL + 1);
  ALLOC_CHECK_RESULT(ret, size);
  
  ret += ALLOC_OFF_HEAD;

  ALLOC_C1(ret) = ALLOC_MAGIC_C1;
  ALLOC_S(ret)  = size;
  ALLOC_C2(ret) = ALLOC_MAGIC_C2;

  memcpy(ret, mem, size);
  ret[size] = 0;

  return ret;

}


#ifndef DEBUG_BUILD

/* In non-debug mode, we just do straightforward aliasing of the above functions
   to user-visible names such as ck_alloc(). */

#define ck_alloc          DFL_ck_alloc
#define ck_alloc_nozero   DFL_ck_alloc_nozero
#define ck_realloc        DFL_ck_realloc
#define ck_realloc_block  DFL_ck_realloc_block
#define ck_strdup         DFL_ck_strdup
#define ck_memdup         DFL_ck_memdup
#define ck_memdup_str     DFL_ck_memdup_str
#define ck_free           DFL_ck_free

#define alloc_report()

#else

/* In debugging mode, we also track allocations to detect memory leaks, and the
   flow goes through one more layer of indirection. */

/* Alloc tracking data structures: */

#define ALLOC_BUCKETS     4096

struct TRK_obj {
  void *ptr;
  char *file, *func;
  u32  line;
};

#ifdef AFL_MAIN

struct TRK_obj* TRK[ALLOC_BUCKETS];
u32 TRK_cnt[ALLOC_BUCKETS];

#  define alloc_report() TRK_report()

#else

extern struct TRK_obj* TRK[ALLOC_BUCKETS];
extern u32 TRK_cnt[ALLOC_BUCKETS];

#  define alloc_report()

#endif /* ^AFL_MAIN */

/* Bucket-assigning function for a given pointer: */

#define TRKH(_ptr) (((((u32)(_ptr)) >> 16) ^ ((u32)(_ptr))) % ALLOC_BUCKETS)


/* Add a new entry to the list of allocated objects. */

static inline void TRK_alloc_buf(void* ptr, const char* file, const char* func,
                                 u32 line) {

  u32 i, bucket;

  if (!ptr) return;

  bucket = TRKH(ptr);

  /* Find a free slot in the list of entries for that bucket. */

  for (i = 0; i < TRK_cnt[bucket]; i++)

    if (!TRK[bucket][i].ptr) {

      TRK[bucket][i].ptr  = ptr;
      TRK[bucket][i].file = (char*)file;
      TRK[bucket][i].func = (char*)func;
      TRK[bucket][i].line = line;
      return;

    }

  /* No space available - allocate more. */

  TRK[bucket] = DFL_ck_realloc_block(TRK[bucket],
    (TRK_cnt[bucket] + 1) * sizeof(struct TRK_obj));

  TRK[bucket][i].ptr  = ptr;
  TRK[bucket][i].file = (char*)file;
  TRK[bucket][i].func = (char*)func;
  TRK[bucket][i].line = line;

  TRK_cnt[bucket]++;

}


/* Remove entry from the list of allocated objects. */

static inline void TRK_free_buf(void* ptr, const char* file, const char* func,
                                u32 line) {

  u32 i, bucket;

  if (!ptr) return;

  bucket = TRKH(ptr);

  /* Find the element on the list... */

  for (i = 0; i < TRK_cnt[bucket]; i++)

    if (TRK[bucket][i].ptr == ptr) {

      TRK[bucket][i].ptr = 0;
      return;

    }

  WARNF("ALLOC: Attempt to free non-allocated memory in %s (%s:%u)",
        func, file, line);

}


/* Do a final report on all non-deallocated objects. */

static inline void TRK_report(void) {

  u32 i, bucket;

  fflush(0);

  for (bucket = 0; bucket < ALLOC_BUCKETS; bucket++)
    for (i = 0; i < TRK_cnt[bucket]; i++)
      if (TRK[bucket][i].ptr)
        WARNF("ALLOC: Memory never freed, created in %s (%s:%u)",
              TRK[bucket][i].func, TRK[bucket][i].file, TRK[bucket][i].line);

}


/* Simple wrappers for non-debugging functions: */

static inline void* TRK_ck_alloc(u32 size, const char* file, const char* func,
                                 u32 line) {

  void* ret = DFL_ck_alloc(size);
  TRK_alloc_buf(ret, file, func, line);
  return ret;

}


static inline void* TRK_ck_realloc(void* orig, u32 size, const char* file,
                                   const char* func, u32 line) {

  void* ret = DFL_ck_realloc(orig, size);
  TRK_free_buf(orig, file, func, line);
  TRK_alloc_buf(ret, file, func, line);
  return ret;

}


static inline void* TRK_ck_realloc_block(void* orig, u32 size, const char* file,
                                         const char* func, u32 line) {

  void* ret = DFL_ck_realloc_block(orig, size);
  TRK_free_buf(orig, file, func, line);
  TRK_alloc_buf(ret, file, func, line);
  return ret;

}


static inline void* TRK_ck_strdup(u8* str, const char* file, const char* func,
                                  u32 line) {

  void* ret = DFL_ck_strdup(str);
  TRK_alloc_buf(ret, file, func, line);
  return ret;

}


static inline void* TRK_ck_memdup(void* mem, u32 size, const char* file,
                                  const char* func, u32 line) {

  void* ret = DFL_ck_memdup(mem, size);
  TRK_alloc_buf(ret, file, func, line);
  return ret;

}


static inline void* TRK_ck_memdup_str(void* mem, u32 size, const char* file,
                                      const char* func, u32 line) {

  void* ret = DFL_ck_memdup_str(mem, size);
  TRK_alloc_buf(ret, file, func, line);
  return ret;

}


static inline void TRK_ck_free(void* ptr, const char* file,
                                const char* func, u32 line) {

  TRK_free_buf(ptr, file, func, line);
  DFL_ck_free(ptr);

}

/* Aliasing user-facing names to tracking functions: */

#define ck_alloc(_p1) \
  TRK_ck_alloc(_p1, __FILE__, __FUNCTION__, __LINE__)

#define ck_alloc_nozero(_p1) \
  TRK_ck_alloc(_p1, __FILE__, __FUNCTION__, __LINE__)

#define ck_realloc(_p1, _p2) \
  TRK_ck_realloc(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)

#define ck_realloc_block(_p1, _p2) \
  TRK_ck_realloc_block(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)

#define ck_strdup(_p1) \
  TRK_ck_strdup(_p1, __FILE__, __FUNCTION__, __LINE__)

#define ck_memdup(_p1, _p2) \
  TRK_ck_memdup(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)

#define ck_memdup_str(_p1, _p2) \
  TRK_ck_memdup_str(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)

#define ck_free(_p1) \
  TRK_ck_free(_p1, __FILE__, __FUNCTION__, __LINE__)

#endif /* ^!DEBUG_BUILD */

#endif /* ! _HAVE_ALLOC_INL_H */

```

`config.h`:

```h
/*
   american fuzzy lop - vaguely configurable bits
   ----------------------------------------------

   Original AFL code written by Michal Zalewski <lcamtuf@google.com>

   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

#ifndef _HAVE_CONFIG_H
#define _HAVE_CONFIG_H

#define inline __inline

#include "types.h"

/******************************************************
 *                                                    *
 *  Settings that may be of interest to power users:  *
 *                                                    *
 ******************************************************/

/* Default file permission umode when creating files (default: 0600) */
#define DEFAULT_PERMISSION  0600

/* Comment out to disable terminal colors: */

// #define USE_COLOR

/* Comment out to disable fancy ANSI boxes and use poor man's 7-bit UI: */

//#define FANCY_BOXES

/* Default timeout for fuzzed code (milliseconds). This is the upper bound,
   also used for detecting hangs; the actual value is auto-scaled: */

#define EXEC_TIMEOUT        1000

/* Timeout rounding factor when auto-scaling (milliseconds): */

#define EXEC_TM_ROUND       20

/* Default memory limit for child process (MB): */

#ifndef _WIN64 
#  define MEM_LIMIT         0
#else
#  define MEM_LIMIT         0
#endif /* ^!_WIN64 */

/* Default memory limit when running in QEMU mode (MB): */

#define MEM_LIMIT_QEMU      200

/* Number of calibration cycles per every new test case (and for test
   cases that show variable behavior): */

#define CAL_CYCLES          8
#define CAL_CYCLES_LONG     40

/* Number of subsequent timeouts before abandoning an input file: */

#define TMOUT_LIMIT         250

/* Maximum number of unique hangs or crashes to record: */

#define KEEP_UNIQUE_HANG    500
#define KEEP_UNIQUE_CRASH   5000

/* Baseline number of random tweaks during a single 'havoc' stage: */

#define HAVOC_CYCLES        256
#define HAVOC_CYCLES_INIT   1024


/* Maximum multiplier for the above (should be a power of two, beware
   of 32-bit int overflows): */

#define HAVOC_MAX_MULT      16

/* Absolute minimum number of havoc cycles (after all adjustments): */

#define HAVOC_MIN           16

/* Maximum stacking for havoc-stage tweaks. The actual value is calculated
   like this: 

   n = random between 1 and HAVOC_STACK_POW2
   stacking = 2^n

   In other words, the default (n = 7) produces 2, 4, 8, 16, 32, 64, or
   128 stacked tweaks: */

#define HAVOC_STACK_POW2    7

/* Caps on block sizes for cloning and deletion operations. Each of these
   ranges has a 33% probability of getting picked, except for the first
   two cycles where smaller blocks are favored: */

#define HAVOC_BLK_SMALL     32
#define HAVOC_BLK_MEDIUM    128
#define HAVOC_BLK_LARGE     1500

/* Extra-large blocks, selected very rarely (<5% of the time): */

#define HAVOC_BLK_XL        32768

/* Probabilities of skipping non-favored entries in the queue, expressed as
   percentages: */

#define SKIP_TO_NEW_PROB    99 /* ...when there are new, pending favorites */
#define SKIP_NFAV_OLD_PROB  95 /* ...no new favs, cur entry already fuzzed */
#define SKIP_NFAV_NEW_PROB  75 /* ...no new favs, cur entry not fuzzed yet */

/* Splicing cycle count: */

#define SPLICE_CYCLES       15

/* Nominal per-splice havoc cycle length: */

#define SPLICE_HAVOC        32

/* Maximum offset for integer addition / subtraction stages: */

#define ARITH_MAX           35

/* Limits for the test case trimmer. The absolute minimum chunk size; and
   the starting and ending divisors for chopping up the input file: */

#define TRIM_MIN_BYTES      4
#define TRIM_START_STEPS    16
#define TRIM_END_STEPS      1024

/* Maximum size of input file, in bytes (keep under 100MB): */

#define MAX_FILE            (1 * 1024 * 1024)

/* The same, for the test case minimizer: */

#define TMIN_MAX_FILE       (10 * 1024 * 1024)

/* Block normalization steps for afl-tmin: */

#define TMIN_SET_MIN_SIZE   4
#define TMIN_SET_STEPS      128

/* Maximum dictionary token size (-x), in bytes: */

#define MAX_DICT_FILE       128

/* Length limits for auto-detected dictionary tokens: */

#define MIN_AUTO_EXTRA      3
#define MAX_AUTO_EXTRA      32

/* Maximum number of user-specified dictionary tokens to use in deterministic
   steps; past this point, the "extras/user" step will be still carried out,
   but with proportionally lower odds: */

#define MAX_DET_EXTRAS      200

/* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing
   (first value), and to keep in memory as candidates. The latter should be much
   higher than the former. */

#define USE_AUTO_EXTRAS     50
#define MAX_AUTO_EXTRAS     (USE_AUTO_EXTRAS * 10)

/* Scaling factor for the effector map used to skip some of the more
   expensive deterministic steps. The actual divisor is set to
   2^EFF_MAP_SCALE2 bytes: */

#define EFF_MAP_SCALE2      3

/* Minimum input file length at which the effector logic kicks in: */

#define EFF_MIN_LEN         128

/* Maximum effector density past which everything is just fuzzed
   unconditionally (%): */

#define EFF_MAX_PERC        90

/* UI refresh frequency (Hz): */

#define UI_TARGET_HZ        1

/* Fuzzer stats file and plot update intervals (sec): */

#define STATS_UPDATE_SEC    60
#define PLOT_UPDATE_SEC     5

/* Smoothing divisor for CPU load and exec speed stats (1 - no smoothing). */

#define AVG_SMOOTHING       16

/* Sync interval (every n havoc cycles): */

#define SYNC_INTERVAL       5

/* Output directory reuse grace period (minutes): */

#define OUTPUT_GRACE        25

/* Uncomment to use simple file names (id_NNNNNN): */

#define SIMPLE_FILES

/* List of interesting values to use in fuzzing. */

#define INTERESTING_8 \
  -128,          /* Overflow signed 8-bit when decremented  */ \
  -1,            /*                                         */ \
   0,            /*                                         */ \
   1,            /*                                         */ \
   16,           /* One-off with common buffer size         */ \
   32,           /* One-off with common buffer size         */ \
   64,           /* One-off with common buffer size         */ \
   100,          /* One-off with common buffer size         */ \
   127           /* Overflow signed 8-bit when incremented  */

#define INTERESTING_16 \
  -32768,        /* Overflow signed 16-bit when decremented */ \
  -129,          /* Overflow signed 8-bit                   */ \
   128,          /* Overflow signed 8-bit                   */ \
   255,          /* Overflow unsig 8-bit when incremented   */ \
   256,          /* Overflow unsig 8-bit                    */ \
   512,          /* One-off with common buffer size         */ \
   1000,         /* One-off with common buffer size         */ \
   1024,         /* One-off with common buffer size         */ \
   4096,         /* One-off with common buffer size         */ \
   32767         /* Overflow signed 16-bit when incremented */

#define INTERESTING_32 \
  -2147483648LL, /* Overflow signed 32-bit when decremented */ \
  -100663046,    /* Large negative number (endian-agnostic) */ \
  -32769,        /* Overflow signed 16-bit                  */ \
   32768,        /* Overflow signed 16-bit                  */ \
   65535,        /* Overflow unsig 16-bit when incremented  */ \
   65536,        /* Overflow unsig 16 bit                   */ \
   100663045,    /* Large positive number (endian-agnostic) */ \
   2147483647    /* Overflow signed 32-bit when incremented */

/***********************************************************
 *                                                         *
 *  Really exotic stuff you probably don't want to touch:  *
 *                                                         *
 ***********************************************************/

/* Call count interval between reseeding the libc PRNG from /dev/urandom: */

#define RESEED_RNG          10000

/* Maximum line length passed from GCC to 'as' and used for parsing
   configuration files: */

#define MAX_LINE            8192

/* Environment variable used to pass SHM ID to the called program. */

#define SHM_ENV_VAR         "__AFL_SHM_ID"

/* Other less interesting, internal-only variables. */

#define CLANG_ENV_VAR       "__AFL_CLANG_MODE"
#define AS_LOOP_ENV_VAR     "__AFL_AS_LOOPCHECK"
#define PERSIST_ENV_VAR     "__AFL_PERSISTENT"
#define DEFER_ENV_VAR       "__AFL_DEFER_FORKSRV"

/* In-code signatures for deferred and persistent mode. */

#define PERSIST_SIG         "##SIG_AFL_PERSISTENT##"
#define DEFER_SIG           "##SIG_AFL_DEFER_FORKSRV##"

/* Distinctive bitmap signature used to indicate failed execution: */

#define EXEC_FAIL_SIG       0xfee1dead

/* Distinctive exit code used to indicate MSAN trip condition: */

#define MSAN_ERROR          86

/* Designated file descriptors for forkserver commands (the application will
   use FORKSRV_FD and FORKSRV_FD + 1): */

#define FORKSRV_FD          198

/* Fork server init timeout multiplier: we'll wait the user-selected
   timeout plus this much for the fork server to spin up. */

#define FORK_WAIT_MULT      10

/* Calibration timeout adjustments, to be a bit more generous when resuming
   fuzzing sessions or trying to calibrate already-added internal finds.
   The first value is a percentage, the other is in milliseconds: */

#define CAL_TMOUT_PERC      125
#define CAL_TMOUT_ADD       50

/* Number of chances to calibrate a case before giving up: */

#define CAL_CHANCES         3

/* Map size for the traced binary (2^MAP_SIZE_POW2). Must be greater than
   2; you probably want to keep it under 18 or so for performance reasons
   (adjusting AFL_INST_RATIO when compiling is probably a better way to solve
   problems with complex programs). You need to recompile the target binary
   after changing this - otherwise, SEGVs may ensue. */

#define MAP_SIZE_POW2       16
#define MAP_SIZE            (1 << MAP_SIZE_POW2)

/* Maximum allocator request size (keep well under INT_MAX): */

#define MAX_ALLOC           0x40000000

/* A made-up hashing seed: */

#define HASH_CONST          0xa5b35705

/* Constants for afl-gotcpu to control busy loop timing: */

#define  CTEST_TARGET_MS    5000
#define  CTEST_BUSY_CYCLES  (10 * 1000 * 1000)

/* Uncomment this to use inferior block-coverage-based instrumentation. Note
   that you need to recompile the target binary for this to have any effect: */

// #define COVERAGE_ONLY

/* Uncomment this to ignore hit counts and output just one bit per tuple.
   As with the previous setting, you will need to recompile the target
   binary: */

// #define SKIP_COUNTS

/* Uncomment this to use instrumentation data to record newly discovered paths,
   but do not use them as seeds for fuzzing. This is useful for conveniently
   measuring coverage that could be attained by a "dumb" fuzzing algorithm: */

// #define IGNORE_FINDS

#define MAX_ATTACH_ATTEMPTS 10

#endif /* ! _HAVE_CONFIG_H */

```

`custom_net_fuzzer.c`:

```c
/*
custom_net_fuzzer - a shared DLL to enable network fuzzing in winAFL
-------------------------------------------------------------

Written and maintained by Maksim Shudrak <mxmssh@gmail.com>

Copyright 2018 Salesforce Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

#include "custom_winafl_server.h"

static u8  enable_socket_fuzzing = 0; /* Enable network fuzzing           */
static u8  is_TCP = 1;                /* TCP or UDP                       */
static u32 target_port = 0x0;         /* Target port to send test cases   */
static u32 socket_init_delay = SOCKET_INIT_DELAY; /* Socket init delay    */
static u8 *target_ip_address = NULL;  /* Target IP to send test cases     */


static SOCKET ListenSocket = INVALID_SOCKET;
static SOCKET ClientSocket = INVALID_SOCKET;

static void send_data_tcp(const char *buf, const int buf_len, int first_time) {
    static struct sockaddr_in si_other;
    static int slen = sizeof(si_other);
    static WSADATA wsa;
    int s;

    if (first_time == 0x0) {
        /* wait while the target process open the socket */
        Sleep(socket_init_delay);

        if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
            FATAL("WSAStartup failed. Error Code : %d", WSAGetLastError());

        // setup address structure
        memset((char *)&si_other, 0, sizeof(si_other));
        si_other.sin_family = AF_INET;
        si_other.sin_port = htons(target_port);
        si_other.sin_addr.S_un.S_addr = inet_addr((char *)target_ip_address);
    }

    /* In case of TCP we need to open a socket each time we want to establish
    * connection. In theory we can keep connections always open but it might
    * cause our target behave differently (probably there are a bunch of
    * applications where we should apply such scheme to trigger interesting
    * behavior).
    */
    if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) == SOCKET_ERROR)
        FATAL("socket() failed with error code : %d", WSAGetLastError());

    // Connect to server.
    if (connect(s, (SOCKADDR *)& si_other, slen) == SOCKET_ERROR)
        FATAL("connect() failed with error code : %d", WSAGetLastError());

    // Send our buffer
    if (send(s, buf, buf_len, 0) == SOCKET_ERROR)
        FATAL("send() failed with error code : %d", WSAGetLastError());

    // shutdown the connection since no more data will be sent
    if (shutdown(s, 0x1/*SD_SEND*/) == SOCKET_ERROR)
        FATAL("shutdown failed with error: %d\n", WSAGetLastError());
    // close the socket to avoid consuming much resources
    if (closesocket(s) == SOCKET_ERROR)
        FATAL("closesocket failed with error: %d\n", WSAGetLastError());
}

static void send_data_udp(const char *buf, const int buf_len, int first_time) {
    static struct sockaddr_in si_other;
    static int s, slen = sizeof(si_other);
    static WSADATA wsa;

    if (first_time == 0x0) {
        /* wait while the target process open the socket */
        Sleep(socket_init_delay);

        if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
            FATAL("WSAStartup failed. Error Code : %d", WSAGetLastError());

        if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR)
            FATAL("socket() failed with error code : %d", WSAGetLastError());

        // setup address structure
        memset((char *)&si_other, 0, sizeof(si_other));
        si_other.sin_family = AF_INET;
        si_other.sin_port = htons(target_port);
        si_other.sin_addr.S_un.S_addr = inet_addr((char *)target_ip_address);
    }

    // send the data
    if (sendto(s, buf, buf_len, 0, (struct sockaddr *) &si_other, slen) == SOCKET_ERROR)
        FATAL("sendto() failed with error code : %d", WSAGetLastError());
}

#define DEFAULT_BUFLEN 4096

CUSTOM_SERVER_API int APIENTRY dll_run(char *data, long size, int fuzz_iterations) {
    if (is_TCP)
        send_data_tcp(data, size, fuzz_iterations);
    else
        send_data_udp(data, size, fuzz_iterations);
    return 1;
}

static int optind;
static u8 *optarg;

int getopt(int argc, char **argv, char *optstring) {
    char *c;
    optarg = NULL;
    int i = 0;

    while (1) {
        if (optind == argc) return -1;

        if (argv[optind][0] != '-') {
            optind++;
            continue;
        }
        if (!argv[optind][1]) {
            optind++;
            continue;
        }

        c = strchr(optstring, argv[optind][1]);
        if (!c) {
            optind++;
            continue;
        }

        optind++;
        if (c[1] == ':') {
            if (optind == argc) return -1;
            optarg = argv[optind];
            optind++;
        }

        return (int)(c[0]);
    }
}

void usage() {
    printf("Network fuzzing options:\n\n"\
    "  -a            - IP address to send data in\n"\
    "  -U            - Use UDP (default TCP)\n"\
    "  -p            - Port to send data in\n"\
    "  -w            - Delay in milliseconds before start sending data\n");
    exit(1);
}
static int optind;
static u8 *optarg;

#define MAX_ARGS 28

char **convert_to_array(char *args, int *argc) {
    int element_id = 0;
    int last_element_offset = 0;
    char *c = NULL;

    int length = strlen(args);
    char **argv = malloc(MAX_ARGS * sizeof (char *));

    while (args) {
        c = strchr(args, ' ');
        if (!c)
            break;

        int len = c - args;
        if (len <= 0)
            break;

        char *element = malloc(len);
        memcpy(element, args, len);
        element[len] = '\0';

        argv[element_id] = element;

        element_id++;
        if (element_id >= MAX_ARGS) {
            usage();
            break;
        }

        args = c + 1;
    }
    argv[element_id] = strdup(args);

    *argc = element_id + 1;
    return argv;
}

CUSTOM_SERVER_API int APIENTRY dll_init() {
    s32 opt;
    static int iSendResult;
    static int first_time = 0x1;
    int argc;

    if (!first_time)
        return 1;

    char *args = getenv("AFL_CUSTOM_DLL_ARGS");

    char **argv = convert_to_array(args, &argc);

    if (args == NULL)
        usage();

    while ((opt = getopt(argc, argv, "Ua:p:w:")) > 0) {
        switch (opt) {
        case 'a':
            target_ip_address = ck_strdup(optarg);

            break;

        case 'U':
            is_TCP = 0;

            break;

        case 'p':
            if (sscanf(optarg, "%u", &target_port) < 1 ||
                optarg[0] == '-') FATAL("Bad syntax used for -p");

            break;

        case 'w':
            if (sscanf(optarg, "%u", &socket_init_delay) < 1 ||
                optarg[0] == '-') FATAL("Bad syntax used for -w");

            break;
        default:
            break;
        }
    }

    if (target_ip_address == NULL || target_port == 0)
        usage();

    printf("Ready to begin fuzzing. Target IP= %s, target port = %d\n",
           target_ip_address, target_port);
    first_time = 0x0;
    return 1;
}

```

`custom_net_fuzzer.def`:

```def
EXPORTS
dll_init
dll_run

```

`custom_winafl_server.c`:

```c
/*
custom_winafl_server - a shared DLL to enable server-mode fuzzing in winAFL:
-------------------------------------------------------------

Written and maintained by Maksim Shudrak <mxmssh@gmail.com>

Copyright 2018 Salesforce Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

#include "custom_winafl_server.h"

static SOCKET ListenSocket = INVALID_SOCKET;
static SOCKET ClientSocket = INVALID_SOCKET;

#define DEFAULT_BUFLEN 4096

//#define DEBUG_SERVER 1

/* open data and send it back into TCP/UDP socket (winAFL is a server) */
static int send_response(char *buf, long fsize, SOCKET ClientSocket) {
	/* send our test case */
#ifdef DEBUG_SERVER
    printf("Sending %s\n", buf);
#endif
    int iSendResult = send(ClientSocket, buf, fsize, 0);
	if (iSendResult == SOCKET_ERROR) {
		printf("send failed with error: %d\n", WSAGetLastError());
		closesocket(ClientSocket);
		WSACleanup();
		ExitProcess(-1);
		return 0;
	}
#ifdef DEBUG_SERVER
	printf("Bytes sent: %d\n", iSendResult);
#endif

	return 1;
}

static int recv_loop(SOCKET ClientSocket) {
	int iResult;
	char recvbuf[DEFAULT_BUFLEN];
	int recvbuflen = DEFAULT_BUFLEN;

	do {
		iResult = recv(ClientSocket, recvbuf, recvbuflen, 0);
		if (iResult > 0) {
#ifdef DEBUG_SERVER
			printf("Bytes received: %d\n", iResult);
#endif
		}
		else if (iResult == 0) {
#ifdef DEBUG_SERVER
			printf("Connection closing...\n");
#endif
		}
		else {
			printf("recv failed with error: %d\n", WSAGetLastError());
			closesocket(ClientSocket);
			WSACleanup();
			ExitProcess(-1);
			return 0;
		}
	} while (iResult > 0);
	return 1;
}

#define DEFAULT_BUFLEN 4096

typedef struct _test_case_struct {
	long size;
	char *data;
} test_case_struct;

/* server-mode routings */
DWORD WINAPI handle_incoming_connection(LPVOID lpParam) {
	static int iResult;
	test_case_struct *test_case = (test_case_struct *)lpParam;

#ifdef DEBUG_SERVER
	printf("Handling incoming connections\n");
#endif

	// Accept a client socket
	ClientSocket = accept(ListenSocket, NULL, NULL);
	if (ClientSocket == INVALID_SOCKET) {
		printf("accept failed with error: %d\n", WSAGetLastError());
		closesocket(ListenSocket);
		WSACleanup();
		ExitProcess(-1);
		return 0;
	}

	recv_loop(ClientSocket);

	/* answer with test case to our client */
	int res = send_response(test_case->data, test_case->size, ClientSocket);

	if (!res) {
		printf("Failed to send response");
		ExitProcess(-1);
		return 0;
	}

	// shutdown the connection since we're done
	iResult = shutdown(ClientSocket, SD_SEND);
	if (iResult == SOCKET_ERROR) {
		printf("shutdown failed with error: %d\n", WSAGetLastError());
		closesocket(ClientSocket);
		WSACleanup();
		ExitProcess(-1);
		return 0;
	}
	free(test_case->data);
	free(test_case);
	return 1;
}

HANDLE hr = NULL;

CUSTOM_SERVER_API int APIENTRY dll_run(char *data, long size, int fuzz_iterations) {
	DWORD dwThreadId;
	test_case_struct *test_case = (test_case_struct *)malloc(sizeof(test_case_struct));
	test_case->data = (char *)malloc(size);

	memcpy(test_case->data, data, size);
	test_case->size = size;

	/* we have to create a second thread to avoid blocking winAFL in recv */
	if (hr != NULL)
		WaitForSingleObject(hr, INFINITE); /* we have to wait our previous thread to finish exec */
	hr = CreateThread(NULL, 0, handle_incoming_connection, (LPVOID)test_case, 0, &dwThreadId);
	if (hr == NULL)
		return 0;

	return 1;
}

void usage() {
	printf("Please setup AFL_CUSTOM_DLL_ARGS=<port_number>\n");
	exit(1);
}

/* winAFL is a TCP server now (TODO: implement UDP server) */
CUSTOM_SERVER_API int APIENTRY dll_init() {
	static WSADATA wsaData;
	static int iResult;
    s32 opt;
	static struct addrinfo *result = NULL;
	static struct addrinfo hints;
	static int iSendResult;

	static int first_time = 0x1;
    unsigned char *server_bind_port = NULL;

	if (!first_time)
		return 1;

    server_bind_port = getenv("AFL_CUSTOM_DLL_ARGS");
    if (server_bind_port == NULL)
        usage();

	printf("Initializing custom winAFL server\n");

	// Initialize Winsock
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0) {
		printf("WSAStartup failed with error: %d\n", iResult);
		return 0;
	}

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;

	// Resolve the server address and port
	iResult = getaddrinfo(NULL, server_bind_port, &hints, &result);
	if (iResult != 0) {
		printf("getaddrinfo failed with error: %d\n", iResult);
		WSACleanup();
		return 0;
	}

	// Create a SOCKET for connecting to server
	ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	if (ListenSocket == INVALID_SOCKET) {
		printf("socket failed with error: %ld\n", WSAGetLastError());
		freeaddrinfo(result);
		WSACleanup();
		return 0;
	}

	// Setup the TCP listening socket
	iResult = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);
	if (iResult == SOCKET_ERROR) {
		printf("bind failed with error: %d\n", WSAGetLastError());
		freeaddrinfo(result);
		closesocket(ListenSocket);
		WSACleanup();
		return 0;
	}

	freeaddrinfo(result);

	iResult = listen(ListenSocket, SOMAXCONN);
	if (iResult == SOCKET_ERROR) {
		printf("listen failed with error: %d\n", WSAGetLastError());
		closesocket(ListenSocket);
		WSACleanup();
		ExitProcess(-1);
		return 0;
	}

	printf("WinAFL server is listening on port %s\n", server_bind_port);
	first_time = 0x0;

	return 1;
}
```

`custom_winafl_server.def`:

```def
EXPORTS
dll_init
dll_run

```

`custom_winafl_server.h`:

```h
/*
custom_winafl_server - a shared DLL to enable server-mode fuzzing in winAFL:
-------------------------------------------------------------

Written and maintained by Maksim Shudrak <mxmssh@gmail.com>

Copyright 2018 Salesforce Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#pragma once

#define WIN32_LEAN_AND_MEAN /* prevent winsock.h to be included in windows.h */

#include <stdio.h>
#include <tchar.h>
#include <Windows.h>
#include <wininet.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdlib.h>

#include <winsock2.h>
#include <ws2tcpip.h>


#pragma comment(lib,"ws2_32.lib") //Winsock Library
#pragma comment( lib, "wininet")

#include "alloc-inl.h"

#define CUSTOM_SERVER_API __declspec(dllexport)

CUSTOM_SERVER_API int APIENTRY dll_init();
CUSTOM_SERVER_API int APIENTRY dll_run(char *data, long size, int fuzz_iterations);

/* Default delay in milliseconds to let the target open a socket and start listen for
 * incoming packages.
*/
#define SOCKET_INIT_DELAY 30000
```

`debug.h`:

```h
/*
   american fuzzy lop - debug / error handling macros
   --------------------------------------------------

   Original AFL code written by Michal Zalewski <lcamtuf@google.com>

   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

#ifndef _HAVE_DEBUG_H
#define _HAVE_DEBUG_H

#include <errno.h>

#include "types.h"
#include "config.h"

#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
#endif

/*******************
 * Terminal colors *
 *******************/

#ifdef USE_COLOR

#  define cBLK "\x1b[0;30m"
#  define cRED "\x1b[0;31m"
#  define cGRN "\x1b[0;32m"
#  define cBRN "\x1b[0;33m"
#  define cBLU "\x1b[0;34m"
#  define cMGN "\x1b[0;35m"
#  define cCYA "\x1b[0;36m"
#  define cLGR "\x1b[0;37m"
#  define cGRA "\x1b[1;30m"
#  define cLRD "\x1b[1;31m"
#  define cLGN "\x1b[1;32m"
#  define cYEL "\x1b[1;33m"
#  define cLBL "\x1b[1;34m"
#  define cPIN "\x1b[1;35m"
#  define cLCY "\x1b[1;36m"
#  define cBRI "\x1b[1;37m"
#  define cRST "\x1b[0m"

#  define bgBLK "\x1b[40m"
#  define bgRED "\x1b[41m"
#  define bgGRN "\x1b[42m"
#  define bgBRN "\x1b[43m"
#  define bgBLU "\x1b[44m"
#  define bgMGN "\x1b[45m"
#  define bgCYA "\x1b[46m"
#  define bgLGR "\x1b[47m"
#  define bgGRA "\x1b[100m"
#  define bgLRD "\x1b[101m"
#  define bgLGN "\x1b[102m"
#  define bgYEL "\x1b[103m"
#  define bgLBL "\x1b[104m"
#  define bgPIN "\x1b[105m"
#  define bgLCY "\x1b[106m"
#  define bgBRI "\x1b[107m"

#else

#  define cBLK ""
#  define cRED ""
#  define cGRN ""
#  define cBRN ""
#  define cBLU ""
#  define cMGN ""
#  define cCYA ""
#  define cLGR ""
#  define cGRA ""
#  define cLRD ""
#  define cLGN ""
#  define cYEL ""
#  define cLBL ""
#  define cPIN ""
#  define cLCY ""
#  define cBRI ""
#  define cRST ""

#  define bgBLK ""
#  define bgRED ""
#  define bgGRN ""
#  define bgBRN ""
#  define bgBLU ""
#  define bgMGN ""
#  define bgCYA ""
#  define bgLGR ""
#  define bgGRA ""
#  define bgLRD ""
#  define bgLGN ""
#  define bgYEL ""
#  define bgLBL ""
#  define bgPIN ""
#  define bgLCY ""
#  define bgBRI ""

#endif /* ^USE_COLOR */

/*************************
 * Box drawing sequences *
 *************************/

#ifdef FANCY_BOXES

#  define SET_G1   "\x1b)0"       /* Set G1 for box drawing    */
#  define RESET_G1 "\x1b)B"       /* Reset G1 to ASCII         */
#  define bSTART   "\x0e"         /* Enter G1 drawing mode     */
#  define bSTOP    "\x0f"         /* Leave G1 drawing mode     */
#  define bH       "q"            /* Horizontal line           */
#  define bV       "x"            /* Vertical line             */
#  define bLT      "l"            /* Left top corner           */
#  define bRT      "k"            /* Right top corner          */
#  define bLB      "m"            /* Left bottom corner        */
#  define bRB      "j"            /* Right bottom corner       */
#  define bX       "n"            /* Cross                     */
#  define bVR      "t"            /* Vertical, branch right    */
#  define bVL      "u"            /* Vertical, branch left     */
#  define bHT      "v"            /* Horizontal, branch top    */
#  define bHB      "w"            /* Horizontal, branch bottom */

#else

#  define SET_G1   ""
#  define RESET_G1 ""
#  define bSTART   ""
#  define bSTOP    ""
#  define bH       "-"
#  define bV       "|"
#  define bLT      "+"
#  define bRT      "+"
#  define bLB      "+"
#  define bRB      "+"
#  define bX       "+"
#  define bVR      "+"
#  define bVL      "+"
#  define bHT      "+"
#  define bHB      "+"

#endif /* ^FANCY_BOXES */

/***********************
 * Misc terminal codes *
 ***********************/

#ifdef USE_COLOR

#define TERM_HOME     "\x1b[H"
#define TERM_CLEAR    TERM_HOME "\x1b[2J"
#define cEOL          "\x1b[0K"
#define CURSOR_HIDE   "\x1b[?25l"
#define CURSOR_SHOW   "\x1b[?25h"

#else

#define TERM_HOME     ""
#define TERM_CLEAR    ""
#define cEOL          ""
#define CURSOR_HIDE   ""
#define CURSOR_SHOW   ""

#endif /* ^USE_COLORS */

/************************
 * Debug & error macros *
 ************************/

/* Just print stuff to the appropriate stream. */

#ifdef MESSAGES_TO_STDOUT
#  define SAYF(...)    printf(__VA_ARGS__)
#else 
#  define SAYF(...)    fprintf(stderr, __VA_ARGS__)
#endif /* ^MESSAGES_TO_STDOUT */

/* Show a prefixed warning. */

#define WARNF(...) do { \
    SAYF(cYEL "[!] " cBRI "WARNING: " cRST __VA_ARGS__); \
    SAYF(cRST "\n"); \
  } while (0)

/* Show a prefixed "doing something" message. */

#define ACTF(...) do { \
    SAYF(cLBL "[*] " cRST __VA_ARGS__); \
    SAYF(cRST "\n"); \
  } while (0)

/* Show a prefixed "success" message. */

#define OKF(...) do { \
    SAYF(cLGN "[+] " cRST __VA_ARGS__); \
    SAYF(cRST "\n"); \
  } while (0)

/* Show a prefixed fatal error message (not used in afl). */

#define BADF(...) do { \
    SAYF(cLRD "\n[-] " cRST __VA_ARGS__); \
    SAYF(cRST "\n"); \
  } while (0)

/* Die with a verbose non-OS fatal error message. */

#define FATAL(...) do { \
    SAYF(bSTOP RESET_G1 CURSOR_SHOW cLRD "\n[-] PROGRAM ABORT : " cBRI __VA_ARGS__); \
    SAYF(cLRD "\n         Location : " cRST "%s(), %s:%u\n\n", \
         __FUNCTION__, __FILE__, __LINE__); \
    exit(1); \
  } while (0)

/* Die by calling abort() to provide a core dump. */

#define ABORT(...) do { \
    SAYF(bSTOP RESET_G1 CURSOR_SHOW cLRD "\n[-] PROGRAM ABORT : " cBRI __VA_ARGS__); \
    SAYF(cLRD "\n    Stop location : " cRST "%s(), %s:%u\n\n", \
         __FUNCTION__, __FILE__, __LINE__); \
    abort(); \
  } while (0)

/* Die while also including the output of perror(). */

#define PFATAL(...) do { \
    fflush(stdout); \
    SAYF(bSTOP RESET_G1 CURSOR_SHOW cLRD "\n[-]  SYSTEM ERROR : " cBRI __VA_ARGS__); \
    SAYF(cLRD "\n    Stop location : " cRST "%s(), %s:%u\n", \
         __FUNCTION__, __FILE__, __LINE__); \
    SAYF(cLRD "       OS message : " cRST "%s\n", strerror(errno)); \
    exit(1); \
  } while (0)

/* Die with FAULT() or PFAULT() depending on the value of res (used to
   interpret different failure modes for read(), write(), etc). */

#define RPFATAL(res, ...) do { \
    if (res < 0) PFATAL(__VA_ARGS__); else FATAL(__VA_ARGS__); \
  } while (0)

/* Error-checking versions of read() and write() that call RPFATAL() as
   appropriate. */

#define ck_write(fd, buf, len, fn) do { \
    u32 _len = (len); \
    s32 _res = _write(fd, buf, _len); \
    if (_res != _len) RPFATAL(_res, "Short write to %s", fn); \
  } while (0)

#define ck_read(fd, buf, len, fn) do { \
    u32 _len = (len); \
    s32 _res = _read(fd, buf, _len); \
    if (_res != _len) RPFATAL(_res, "Short read from %s", fn); \
  } while (0)


static void enable_ansi_console(void) {
  // Set output mode to handle virtual terminal sequences
  DWORD mode = 0;
  HANDLE console_handle = GetStdHandle(STD_OUTPUT_HANDLE);
  if (console_handle == INVALID_HANDLE_VALUE) {
    return;
  }

  if (!GetConsoleMode(console_handle, &mode)) {
    return;
  }

  mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
  // Ignore errors
  SetConsoleMode(console_handle, mode);
}


#endif /* ! _HAVE_DEBUG_H */

```

`gdiplus.cpp`:

```cpp
/*
   WinAFL - GDI+ test binary (image parsing)
   -----------------------------------------

   Written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

#include <stdio.h>
#include <windows.h>
#include <gdiplus.h>

using namespace Gdiplus;

wchar_t* charToWChar(const char* text)
{
    size_t size = strlen(text) + 1;
    wchar_t* wa = new wchar_t[size];
    mbstowcs(wa,text,size);
    return wa;
}

int main(int argc, char** argv)
{
	if(argc < 2) {
		printf("Usage: %s <image file>\n", argv[0]);
		return 0;
	}

	GdiplusStartupInput gdiplusStartupInput;
	ULONG_PTR gdiplusToken;
	GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

	Image *image = NULL;
	//*thumbnail=NULL;

	image = new Image(charToWChar(argv[1]));
	if(image && (Ok == image->GetLastStatus())) {
		//printf("Image loaded\n");
		/*thumbnail = image->GetThumbnailImage(100, 100, NULL, NULL);
		if(thumbnail && (Ok == thumbnail->GetLastStatus())) {
			//printf("Thumbnail created\n");
		}*/
	}

	//printf("Done\n");

	if(image) delete image;
	//if(thumbnail) delete thumbnail;

	GdiplusShutdown(gdiplusToken);

	return 0;
}


```

`hash.h`:

```h
/*
   american fuzzy lop - hashing function
   -------------------------------------

   Original AFL code written by Michal Zalewski <lcamtuf@google.com>

   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

/* 
   The hash32() function is a variant of MurmurHash3, a good
   non-cryptosafe hashing function developed by Austin Appleby.

   For simplicity, this variant does *NOT* accept buffer lengths
   that are not divisible by 8 bytes. The 32-bit version is otherwise
   similar to the original; the 64-bit one is a custom hack with
   mostly-unproven properties.

   Austin's original code is public domain.

*/

#ifndef _HAVE_HASH_H
#define _HAVE_HASH_H

#include "types.h"

#ifdef _WIN64

#define ROL64(_x, _r)  ((((u64)(_x)) << (_r)) | (((u64)(_x)) >> (64 - (_r))))

static inline u32 hash32(const void* key, u32 len, u32 seed) {

  const u64* data = (u64*)key;
  u64 h1 = seed ^ len;

  len >>= 3;

  while (len--) {

    u64 k1 = *data++;

    k1 *= 0x87c37b91114253d5ULL;
    k1  = ROL64(k1, 31);
    k1 *= 0x4cf5ad432745937fULL;

    h1 ^= k1;
    h1  = ROL64(h1, 27);
    h1  = h1 * 5 + 0x52dce729;

  }

  h1 ^= h1 >> 33;
  h1 *= 0xff51afd7ed558ccdULL;
  h1 ^= h1 >> 33;
  h1 *= 0xc4ceb9fe1a85ec53ULL;
  h1 ^= h1 >> 33;

  return h1;

}

#else 

#define ROL32(_x, _r)  ((((u32)(_x)) << (_r)) | (((u32)(_x)) >> (32 - (_r))))

static inline u32 hash32(const void* key, u32 len, u32 seed) {

  const u32* data  = (u32*)key;
  u32 h1 = seed ^ len;

  len >>= 2;

  while (len--) {

    u32 k1 = *data++;

    k1 *= 0xcc9e2d51;
    k1  = ROL32(k1, 15);
    k1 *= 0x1b873593;

    h1 ^= k1;
    h1  = ROL32(h1, 13);
    h1  = h1 * 5 + 0xe6546b64;

  }

  h1 ^= h1 >> 16;
  h1 *= 0x85ebca6b;
  h1 ^= h1 >> 13;
  h1 *= 0xc2b2ae35;
  h1 ^= h1 >> 16;

  return h1;

}

#endif /* ^_WIN64 */

#endif /* !_HAVE_HASH_H */

```

`ipttool.c`:

```c
/*
Copyright 2018 Alex Ionescu. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and
   the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions
   and the following disclaimer in the documentation and/or other materials provided with the
   distribution.

THIS SOFTWARE IS PROVIDED BY ALEX IONESCU ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ALEX IONESCU
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those of the authors and
should not be interpreted as representing official policies, either expressed or implied, of Alex Ionescu.
*/

#include <Windows.h>
#include <stdio.h>
#include <libipt.h>

#define IPT_TOOL_USE_MTC_TIMING_PACKETS     0x01
#define IPT_TOOL_USE_CYC_TIMING_PACKETS     0x02
#define IPT_TOOL_TRACE_KERNEL_MODE          0x04
#define IPT_TOOL_TRACE_ALL_MODE             0x08

#define IPT_TOOL_VALID_FLAGS                \
    (IPT_TOOL_USE_MTC_TIMING_PACKETS |      \
     IPT_TOOL_USE_CYC_TIMING_PACKETS |      \
     IPT_TOOL_TRACE_KERNEL_MODE |           \
     IPT_TOOL_TRACE_ALL_MODE)

FORCEINLINE
DWORD
ConvertToPASizeToSizeOption (
    _In_ DWORD dwSize
    )
{
    DWORD dwIndex;

    //
    // Cap the size to 128MB. Sizes below 4KB will result in 0 anyway.
    //
    if (dwSize > (128 * 1024 * 1024))
    {
        dwSize = 128 * 1024 * 1024;
    }

    //
    // Find the nearest power of two that's set (align down)
    //
    BitScanReverse(&dwIndex, dwSize);

    //
    // The value starts at 4KB
    //
    dwIndex -= 12;
    return dwIndex;
}

BOOL
EnableIpt (
    VOID
    )
{
    SC_HANDLE hScm, hSc;
    BOOL bRes;
    bRes = FALSE;

    //
    // Open a handle to the SCM
    //
    hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hScm != NULL)
    {
        //
        // Open a handle to the IPT Service
        //
        hSc = OpenService(hScm, L"Ipt", SERVICE_START);
        if (hSc != NULL)
        {
            //
            // Start it
            //
            bRes = StartService(hSc, 0, NULL);
            if ((bRes == FALSE) &&
                (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING))
            {
                //
                // If it's already started, that's OK
                //
                bRes = TRUE;
            }
            else if (bRes == FALSE)
            {
                wprintf(L"[-] Unable to start IPT Service (err=%d)\n",
                        GetLastError());
                if (GetLastError() == ERROR_NOT_SUPPORTED)
                {
                    wprintf(L"[-] This is likely due to missing PT support\n");
                }
            }

            //
            // Done with the service
            //
            CloseServiceHandle(hSc);
        }
        else
        {
            wprintf(L"[-] Unable to open IPT Service (err=%d). "
                    L"Are you running Windows 10 1809?\n",
                    GetLastError());
        }

        //
        // Done with the SCM
        //
        CloseServiceHandle(hScm);
    }
    else
    {
        wprintf(L"[-] Unable to open a handle to the SCM (err=%d)\n",
                GetLastError());
    }

    //
    // Return the result
    //
    return bRes;
}

BOOL
EnableAndValidateIptServices (
    VOID
    )
{
    WORD wTraceVersion;
    DWORD dwBufferVersion;
    BOOL bRes;

    //
    // First enable IPT
    //
    bRes = EnableIpt();
    if (bRes == FALSE)
    {
        wprintf(L"[-] Intel PT Service could not be started!\n");
        goto Cleanup;
    }

    //
    // Next, check if the driver uses a dialect we understand
    //
    bRes = GetIptBufferVersion(&dwBufferVersion);
    if (bRes == FALSE)
    {
        wprintf(L"[-] Failed to communicate with IPT Service: (err=%d)\n",
                GetLastError());
        goto Cleanup;
    }
    if (dwBufferVersion != IPT_BUFFER_MAJOR_VERSION_CURRENT)
    {
        wprintf(L"[-] IPT Service buffer version is not supported: %d\n",
                dwBufferVersion);
        goto Cleanup;
    }

    //
    // Then, check if the driver uses trace versions we speak
    //
    bRes = GetIptTraceVersion(&wTraceVersion);
    if (bRes == FALSE)
    {
        wprintf(L"[-] Failed to get Trace Version from IPT Service (err=%d)\n",
                GetLastError());
        goto Cleanup;
    }
    if (wTraceVersion != IPT_TRACE_VERSION_CURRENT)
    {
        wprintf(L"[-] IPT Service trace version is not supported %d\n",
                wTraceVersion);
        goto Cleanup;
    }

Cleanup:
    //
    // Return result
    //
    return bRes;
}

BOOL
ConfigureTraceFlags (
    _In_ DWORD dwFlags,
    _Inout_ PIPT_OPTIONS pOptions
    )
{
    BOOL bRes;
    bRes = FALSE;

    if (dwFlags & ~IPT_TOOL_VALID_FLAGS)
    {
        wprintf(L"[-] Invalid flags: %x\n", dwFlags);
        goto Cleanup;
    }

    //
    // If the user didn't specify MTC, but wants CYC, set MTC too as the IPT
    // driver wil enable those packets anyway.
    //
    if ((dwFlags & IPT_TOOL_USE_CYC_TIMING_PACKETS) &&
        !(dwFlags & IPT_TOOL_USE_MTC_TIMING_PACKETS))
    {
        wprintf(L"[*] CYC Packets require MTC packets, adjusting flags!\n");
        dwFlags |= IPT_TOOL_USE_MTC_TIMING_PACKETS;
    }

    //
    // If the user didn't specify MTC, but wants CYC, set MTC too as the IPT
    // driver wil enable those packets anyway.
    //
    if ((dwFlags & (IPT_TOOL_TRACE_KERNEL_MODE | IPT_TOOL_TRACE_ALL_MODE)) ==
        (IPT_TOOL_TRACE_KERNEL_MODE | IPT_TOOL_TRACE_ALL_MODE))
    {
        wprintf(L"[-] Cannot enable both `kernel` and `user + kernel` tracing."
                L" Please pick a single flag to use!\n");
        goto Cleanup;
    }

    //
    // There are no matching options for process tradces
    //
    pOptions->MatchSettings = IptMatchByAnyApp;

    //
    // Choose the right timing setting
    //
    if (dwFlags & IPT_TOOL_USE_MTC_TIMING_PACKETS)
    {
        pOptions->TimingSettings = IptEnableMtcPackets;
        pOptions->MtcFrequency = 3; // FIXME
    }
    else if (dwFlags & IPT_TOOL_USE_CYC_TIMING_PACKETS)
    {
        pOptions->TimingSettings = IptEnableCycPackets;
        pOptions->CycThreshold = 1; // FIXME
    }
    else
    {
        pOptions->TimingSettings = IptNoTimingPackets;
    }

    //
    // Choose the right mode setting
    //
    if (dwFlags & IPT_TOOL_TRACE_KERNEL_MODE)
    {
        pOptions->ModeSettings = IptCtlKernelModeOnly;
    }
    else if (dwFlags & IPT_TOOL_TRACE_ALL_MODE)
    {
        pOptions->ModeSettings = IptCtlUserAndKernelMode;
    }
    else
    {
        pOptions->ModeSettings = IptCtlUserModeOnly;
    }

    //
    // Print out chosen options
    //
    bRes = TRUE;
    /*wprintf(L"[+] Tracing Options:\n"
            L"           Match by: %s\n"
            L"         Trace mode: %s\n"
            L"     Timing packets: %s\n",
            L"Any process",
            (pOptions->ModeSettings == IptCtlUserAndKernelMode) ?
            L"Kernel and user-mode" :
            (pOptions->ModeSettings == IptCtlKernelModeOnly) ?
            L"Kernel-mode only" : L"User-mode only",
            (pOptions->TimingSettings == IptEnableMtcPackets) ?
            L"MTC Packets" :
            (pOptions->TimingSettings == IptEnableCycPackets) ?
            L"CYC Packets" : L"No  Packets");*/

Cleanup:
    //
    // Return result
    //
    return bRes;
}

BOOL
ConfigureBufferSize (
    _In_ DWORD dwSize,
    _Inout_ PIPT_OPTIONS pOptions
    )
{
    BOOL bRes;
    bRes = FALSE;

    //
    // Warn the user about incorrect values
    //
    if (!((dwSize) && ((dwSize & (~dwSize + 1)) == dwSize)))
    {
        wprintf(L"[*] Size will be aligned to a power of 2\n");
    }
    else if (dwSize < 4096)
    {
        wprintf(L"[*] Size will be set to minimum of 4KB\n");
    }
    else if (dwSize > (128 * 1024 * 1024))
    {
        wprintf(L"[*] Size will be set to a maximum of 128MB\n");
    }

    //
    // Compute the size option
    //
    pOptions->TopaPagesPow2 = ConvertToPASizeToSizeOption(dwSize);
    bRes = TRUE;
    /*wprintf(L"[+] Using size: %d bytes\n",
            1 << (pOptions->TopaPagesPow2 + 12));*/

    //
    // Return result
    //
    return bRes;
}

PIPT_TRACE_DATA GetIptTrace(HANDLE hProcess)
{
	BOOL bRes;
	DWORD dwTraceSize;
	PIPT_TRACE_DATA pTraceData;

	//
	// Get the size of the trace
	//
	bRes = GetProcessIptTraceSize(hProcess, &dwTraceSize);
	if (bRes == FALSE)
	{
		wprintf(L"[-] Failed to query trace size (err=%d). "
			L"Are you sure one is active?\n",
			GetLastError());
		return NULL;
	}

	//
	// Allocate a local buffer
	//
	pTraceData = HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		dwTraceSize);
	if (pTraceData == NULL)
	{
		wprintf(L"[-] Out of memory while trying to allocate trace data\n");
		return NULL;
	}

	//
	// Query the trace
	//
	// wprintf(L"[+] Found active trace with %d bytes so far\n", dwTraceSize);
	bRes = GetProcessIptTrace(hProcess, pTraceData, dwTraceSize);
	if (bRes == FALSE)
	{
		wprintf(L"[-] Failed to query trace (err=%d)\n",
			GetLastError());
		return NULL;
	}

	return pTraceData;
}
```

`ipttool.h`:

```h
BOOL EnableAndValidateIptServices(VOID);
BOOL ConfigureBufferSize(_In_ DWORD dwSize, _Inout_ PIPT_OPTIONS pOptions);
BOOL ConfigureTraceFlags(_In_ DWORD dwFlags, _Inout_ PIPT_OPTIONS pOptions);
PIPT_TRACE_DATA GetIptTrace(HANDLE hProcess);

```

`modules.c`:

```c
/* ***************************************************************************
 * Copyright (c) 2012-2013 Google, Inc.  All rights reserved.
 * ***************************************************************************/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Google, Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/*
Utilities for keeping track of (un)loaded modules in DynamoRIO clients.
Copied from the DyanmoRIO project, http://dynamorio.org/
*/

#include "modules.h"
#include "utils.h"

#include <string.h>

/* we use direct map cache to avoid locking */
static inline void
global_module_cache_add(module_entry_t **cache, module_entry_t *entry)
{
    cache[entry->id % NUM_GLOBAL_MODULE_CACHE] = entry;
}

/* Maintains LRU order in thread-private caches. A new/recent entry is moved to
 * the front, and all other entries are shifted back to make place. For new
 * entries, shifting results in the oldest entry being discarded.
 */
static inline void
thread_module_cache_adjust(module_entry_t **cache,
                           module_entry_t  *entry,
                           uint pos,
                           uint max_pos)
{
    uint i;
    ASSERT(pos < max_pos, "wrong pos");
    for (i = pos; i > 0; i--)
        cache[i] = cache[i-1];
    cache[0] = entry;
}

static inline void
thread_module_cache_add(module_entry_t **cache, uint cache_size,
                        module_entry_t *entry)
{
    thread_module_cache_adjust(cache, entry, cache_size - 1, cache_size);
}

static void
module_table_entry_free(void *entry)
{
    dr_free_module_data(((module_entry_t *)entry)->data);
    dr_global_free(entry, sizeof(module_entry_t));
}

void
module_table_load(module_table_t *table, const module_data_t *data)
{
    module_entry_t *entry = NULL;
    module_data_t  *mod;
    int i;
    /* Some apps repeatedly unload and reload the same module,
     * so we will try to re-use the old one.
     */
    ASSERT(data != NULL, "data must not be NULL");
    drvector_lock(&table->vector);
    /* Assuming most recently loaded entries are most likely to be unloaded,
     * we iterate the module table in a backward way for better performance.
     */
    for (i = table->vector.entries-1; i >= 0; i--) {
        entry = drvector_get_entry(&table->vector, i);
        mod   = entry->data;
        if (entry->unload &&
            /* If the same module is re-loaded at the same address,
             * we will try to use the existing entry.
             */
            mod->start       == data->start        &&
            mod->end         == data->end          &&
            mod->entry_point == data->entry_point  &&
#ifdef WINDOWS
            mod->checksum    == data->checksum     &&
            mod->timestamp   == data->timestamp    &&
#endif
            /* If a module w/ no name (there are some) is loaded, we will
             * keep making new entries.
             */
            dr_module_preferred_name(data) != NULL &&
            dr_module_preferred_name(mod)  != NULL &&
            strcmp(dr_module_preferred_name(data),
                   dr_module_preferred_name(mod)) == 0) {
            entry->unload = false;
            break;
        }
        entry = NULL;
    }
    if (entry == NULL) {
        entry = dr_global_alloc(sizeof(*entry));
        entry->id = table->vector.entries;
        entry->unload = false;
        entry->data = dr_copy_module_data(data);
        drvector_append(&table->vector, entry);
    }
    drvector_unlock(&table->vector);
    global_module_cache_add(table->cache, entry);
}

static inline bool
pc_is_in_module(module_entry_t *entry, app_pc pc)
{
    if (entry != NULL && !entry->unload && entry->data != NULL) {
        module_data_t *mod = entry->data;
        if (pc >= mod->start && pc < mod->end)
            return true;
    }
    return false;
}

module_entry_t *
module_table_lookup(module_entry_t **cache, int cache_size,
                    module_table_t *table, app_pc pc)
{
    module_entry_t *entry;
    int i;

    /* We assume we never change an entry's data field, even on unload,
     * and thus it is ok to check its value without a lock.
     */
    /* lookup thread module cache */
    if (cache != NULL) {
        for (i = 0; i < cache_size; i++) {
            entry = cache[i];
            if (pc_is_in_module(entry, pc)) {
                if (i > 0)
                    thread_module_cache_adjust(cache, entry, i, cache_size);
                return entry;
            }
        }
    }
    /* lookup global module cache */
    /* we use a direct map cache, so it is ok to access it without lock */
    for (i = 0; i < NUM_GLOBAL_MODULE_CACHE; i++) {
        entry = table->cache[i];
        if (pc_is_in_module(entry, pc))
            return entry;
    }
    /* lookup module table */
    entry = NULL;
    drvector_lock(&table->vector);
    for (i = table->vector.entries - 1; i >= 0; i--) {
        entry = drvector_get_entry(&table->vector, i);
        ASSERT(entry != NULL, "fail to get module entry");
        if (pc_is_in_module(entry, pc)) {
            global_module_cache_add(table->cache, entry);
            if (cache != NULL)
                thread_module_cache_add(cache, cache_size, entry);
            break;
        }
        entry = NULL;
    }
    drvector_unlock(&table->vector);
    return entry;
}

void
module_table_unload(module_table_t *table, const module_data_t *data)
{
    module_entry_t *entry = module_table_lookup(NULL, 0, table, data->start);
    if (entry != NULL) {
        entry->unload = true;
    } else {
        ASSERT(false, "fail to find the module to be unloaded");
    }
}

/* assuming caller holds the lock */
void
module_table_entry_print(module_entry_t *entry, file_t log, bool print_all_info)
{
    const char *name;
    module_data_t *data;
    const char *full_path = "<unknown>";
    data = entry->data;
    name = dr_module_preferred_name(data);
    if (data->full_path != NULL && data->full_path[0] != '\0')
        full_path = data->full_path;

    if (print_all_info) {
        dr_fprintf(log, "%3u, "PFX", "PFX", "PFX", %s, %s",
                   entry->id, data->start, data->end, data->entry_point,
                   (name == NULL || name[0] == '\0') ? "<unknown>" : name,
                   full_path);
#ifdef WINDOWS
        dr_fprintf(log, ", 0x%08x, 0x%08x", data->checksum, data->timestamp);
#endif /* WINDOWS */
        dr_fprintf(log, "\n");
    } else {
        dr_fprintf(log, " %u, %llu, %s\n", entry->id,
                   (uint64)(data->end - data->start), full_path);
    }
}

void
module_table_print(module_table_t *table, file_t log, bool print_all_info)
{
    uint i;
    module_entry_t *entry;
    if (log == INVALID_FILE) {
        /* It is possible that failure on log file creation is caused by the
         * running process not having enough privilege, so this is not a
         * release-build fatal error
         */
        ASSERT(false, "invalid log file");
        return;
    }
    drvector_lock(&table->vector);
    dr_fprintf(log, "Module Table: %u\n", table->vector.entries);

    if (print_all_info) {
        dr_fprintf(log, "Module Table: id, base, end, entry, unload, name, path");
#ifdef WINDOWS
        dr_fprintf(log, ", checksum, timestamp");
#endif
        dr_fprintf(log, "\n");
    }

    for (i = 0; i < table->vector.entries; i++) {
        entry = drvector_get_entry(&table->vector, i);
        module_table_entry_print(entry, log, print_all_info);
    }
    drvector_unlock(&table->vector);
}

module_table_t *
module_table_create()
{
    module_table_t *table = dr_global_alloc(sizeof(*table));
    memset(table->cache, 0, sizeof(table->cache));
    drvector_init(&table->vector, 16, false, module_table_entry_free);
    return table;
}

void
module_table_destroy(module_table_t *table)
{
    drvector_delete(&table->vector);
    dr_global_free(table, sizeof(*table));
}

```

`modules.h`:

```h
/* ***************************************************************************
 * Copyright (c) 2012-2013 Google, Inc.  All rights reserved.
 * ***************************************************************************/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Google, Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/*
Utilities for keeping track of (un)loaded modules in DynamoRIO clients.
Copied from the DyanmoRIO project, http://dynamorio.org/
*/

#ifndef CLIENTS_COMMON_MODULES_H_
#define CLIENTS_COMMON_MODULES_H_

#include "dr_api.h"
#include "drvector.h"

#define NUM_GLOBAL_MODULE_CACHE 8

typedef struct _module_entry_t {
    int  id;
    bool unload; /* if the module is unloaded */
    module_data_t *data;
} module_entry_t;

typedef struct _module_table_t {
    drvector_t vector;
    /* for quick query without lock, assuming pointer-aligned */
    module_entry_t *cache[NUM_GLOBAL_MODULE_CACHE];
} module_table_t;

void
module_table_load(module_table_t *table, const module_data_t *data);

/* To avoid data race, proper sychronization on module table is required for
 * accessing module table entry.
 */
module_entry_t *
module_table_lookup(module_entry_t **cache, int cache_size,
                    module_table_t *table, app_pc pc);

/* To avoid data race, proper sychronization on module table is required for
 * accessing module table entry.
 */
void
module_table_entry_print(module_entry_t *entry, file_t log, bool print_all_info);

void
module_table_unload(module_table_t *table, const module_data_t *data);

void
module_table_print(module_table_t *table, file_t log, bool print_all_info);

module_table_t *
module_table_create();

void
module_table_destroy(module_table_t *table);

#endif /* CLIENTS_COMMON_MODULES_H_ */

```

`ptdecode.c`:

```c
/*
  WinAFL - Intel PT decoding
  ------------------------------------------------

  Written and maintained by Ivan Fratric <ifratric@google.com>

  Copyright 2016 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include "windows.h"

#include "intel-pt.h"
#include "pt_cpu.h"
#include "pt_cpuid.h"
#include "pt_opcodes.h"
#include "pt_retstack.h"
#include "pt_block_decoder.h"

#include "types.h"
#include "config.h"
#include "debug.h"

#include "winaflpt.h"
#include "ptdecode.h"

#define PPT_EXT 0xFF

uint32_t previous_offset;
uint64_t previous_ip;

extern address_range* coverage_ip_ranges;
extern size_t num_ip_ranges;
static address_range* current_range;

extern u8 *trace_bits;

#define MAX_TRACELET_SIZE 100 // just a hint, the tracelets could end up larger
#define MIN_TRACELET_SIZE 20 // just a hint, the tracelets could end up smaller

unsigned char opc_lut[] = {
	0x02, 0x08, 0xff, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,
	0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x0f, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,
	0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,
	0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,
	0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,
	0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x11, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,
	0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,
	0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,
	0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,
	0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x0b, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,
	0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,
	0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12
};

unsigned char ext_lut[] = {
	0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x13, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x19, 0x0a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x17, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char opc_size_lut[] = {
	0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01,
	0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01,
	0x01, 0x05, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01,
	0x01, 0x05, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x02, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01,
	0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01,
	0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01,
	0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01,
	0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x02, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x09, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x09, 0x01, 0x01,
	0x01, 0x09, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x09, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01
};

unsigned char ext_size_lut[] = {
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char psb[16] = {
	0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,
	0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82
};

static unsigned char psb_and_psbend[18] = {
	0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,
	0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,
	0x02, 0x23
};

typedef struct decoder_state_t {
	uint64_t query_ip;
	uint64_t block_ip;
	uint8_t mode;
} decoder_state;

typedef struct tracelet_cache_node_t {
	uint64_t hash;
	size_t size;

	struct tracelet_cache_node_t *hash_prev;
	struct tracelet_cache_node_t *hash_next;

	struct tracelet_cache_node_t *lru_prev;
	struct tracelet_cache_node_t *lru_next;

	decoder_state state_prev;
	decoder_state state_next;

	uint8_t stack_removed;
	uint8_t stack_added;

	uint64_t *stack_prev;
	uint64_t *stack_next;

	uint32_t tracelet_size;
	unsigned char * tracelet;

	uint32_t map_update_size;
	uint32_t *map_offsets;
	uint8_t *map_updates;

} tracelet_cache_node;

struct tracelet_cahe_t {
	tracelet_cache_node **hashtable;

	tracelet_cache_node *lru_first;
	tracelet_cache_node *lru_last;

	size_t size;
	size_t num_entries;

	size_t max_size;
	size_t max_entries;
};

static struct tracelet_cahe_t tracelet_cache;

struct coverage_cache_t {
	uint32_t index_buffer[MAP_SIZE];
	// need + 2 for edge coverage
	uint32_t map_offsets[MAP_SIZE + 2];
	uint8_t counters[MAP_SIZE + 2];
	uint32_t size;
};

void tracelet_coverage_init(struct coverage_cache_t *coverage_cache) {
	memset(coverage_cache->index_buffer, 0, MAP_SIZE * sizeof(coverage_cache->index_buffer[0]));
	coverage_cache->size = 0;
}

void tracelet_coverage_clear(struct coverage_cache_t *coverage_cache, int coverage_kind) {
	if (!coverage_cache->size) return;

	uint32_t from = 0;
	uint32_t to = coverage_cache->size;

	if (coverage_kind == COVERAGE_EDGE) {
		// the first and the last value have special meaning
		// in the case of edge coverage
		from++;
		to--;
	}

	for (uint32_t i = from; i < to; i++) {
		coverage_cache->index_buffer[coverage_cache->map_offsets[i]] = 0;
	}
	coverage_cache->size = 0;
}

void tracelet_coverage_add_bb(struct coverage_cache_t *coverage_cache, uint32_t offset) {
	offset = offset % MAP_SIZE;

	if (coverage_cache->index_buffer[offset]) {
		coverage_cache->counters[coverage_cache->index_buffer[offset] - 1]++;
	} else {
		coverage_cache->index_buffer[offset] = coverage_cache->size + 1;
		coverage_cache->map_offsets[coverage_cache->size] = offset;
		coverage_cache->counters[coverage_cache->size] = 1;
		coverage_cache->size++;
	}
}

void tracelet_coverage_add_edge(struct coverage_cache_t *coverage_cache, uint32_t offset) {
	uint32_t edge;
	// don't touch the global previous_offset while building the cache
	// we'll update everything once the cache gets replayed
	uint32_t previous_offset;

	if (!coverage_cache->size) {
		// store the first offset as the first value
		coverage_cache->map_offsets[0] = offset;
		coverage_cache->counters[0] = 0;
		coverage_cache->size = 2;
	} else {
		previous_offset = coverage_cache->map_offsets[coverage_cache->size - 1];

		edge = (offset ^ previous_offset) % MAP_SIZE;

		if (coverage_cache->index_buffer[edge]) {
			coverage_cache->counters[coverage_cache->index_buffer[edge]]++;
		} else {
			coverage_cache->index_buffer[edge] = coverage_cache->size - 1;
			coverage_cache->map_offsets[coverage_cache->size - 1] = edge;
			coverage_cache->counters[coverage_cache->size - 1] = 1;
			coverage_cache->size++;
		}
	}

	// always store the previous offset as the last value
	previous_offset = offset >> 1;
	coverage_cache->map_offsets[coverage_cache->size - 1] = previous_offset;
	coverage_cache->counters[coverage_cache->size - 1] = 0;
}

static inline uint64_t djb2(unsigned char *data, size_t size) {
	uint64_t hash = 5381;

	for (size_t i = 0; i < size; i++) {
		hash = (hash << 5) + hash + data[i];
	}

	return hash;
}

void tracelet_cache_init(size_t max_entries, size_t max_size) {
	tracelet_cache.max_entries = max_entries;
	tracelet_cache.max_size = max_size;

	tracelet_cache.hashtable = (tracelet_cache_node **)calloc(max_entries, sizeof(tracelet_cache_node *));

	tracelet_cache.lru_first = NULL;
	tracelet_cache.lru_last = NULL;

	tracelet_cache.size = 0;
	tracelet_cache.num_entries = 0;
}

// sets the node as the least recently used
void cache_node_touch(tracelet_cache_node *node) {
	// printf("accessing %p in cache\n", node);

	if (!node->lru_prev) return; //already at the beginning
	else node->lru_prev->lru_next = node->lru_next;

	if (node->lru_next) node->lru_next->lru_prev = node->lru_prev;
	else tracelet_cache.lru_last = node->lru_prev;

	node->lru_prev = NULL;
	node->lru_next = tracelet_cache.lru_first;
	if (node->lru_next) node->lru_next->lru_prev = node;
	tracelet_cache.lru_first = node;
}

void cache_node_remove(tracelet_cache_node *node) {
	// printf("removing %p from cache\n", node);

	if (node->lru_prev) node->lru_prev->lru_next = node->lru_next;
	else tracelet_cache.lru_first = node->lru_next;

	if (node->lru_next) node->lru_next->lru_prev = node->lru_prev;
	else tracelet_cache.lru_last = node->lru_prev;

	if (node->hash_prev) node->hash_prev->hash_next = node->hash_next;
	else tracelet_cache.hashtable[node->hash % tracelet_cache.max_entries] = node->hash_next;

	if (node->hash_next) node->hash_next->hash_prev = node->hash_prev;

	tracelet_cache.num_entries--;
	tracelet_cache.size -= node->size;

	free(node);
}

void cache_remove_lru() {
	tracelet_cache_node *node = tracelet_cache.lru_last;
	if (node) cache_node_remove(node);
}

void cache_node_add(tracelet_cache_node *node) {
	// printf("adding %p to cache\n", node);

	while (tracelet_cache.num_entries >= tracelet_cache.max_entries) cache_remove_lru();
	while ((tracelet_cache.size + node->size) >= tracelet_cache.max_size) cache_remove_lru();

	tracelet_cache_node *prev_first;

	prev_first = tracelet_cache.hashtable[node->hash % tracelet_cache.max_entries];
	tracelet_cache.hashtable[node->hash % tracelet_cache.max_entries] = node;

	node->hash_prev = NULL;
	node->hash_next = prev_first;
	if (prev_first) prev_first->hash_prev = node;

	prev_first = tracelet_cache.lru_first;
	tracelet_cache.lru_first = node;

	node->lru_prev = NULL;
	node->lru_next = prev_first;
	if (prev_first) prev_first->lru_prev = node;
	else tracelet_cache.lru_last = node;

	tracelet_cache.num_entries++;
	tracelet_cache.size += node->size;
}

tracelet_cache_node *cache_find_node(uint64_t hash, decoder_state *state, unsigned char *tracelet, size_t tracelet_size, struct pt_retstack *retstack) {
	tracelet_cache_node *node = tracelet_cache.hashtable[hash % tracelet_cache.max_entries];

	while (node) {
		if ((node->hash == hash) &&
			(node->state_prev.block_ip == state->block_ip) &&
			(node->state_prev.query_ip == state->query_ip) &&
			(node->state_prev.mode == state->mode) &&
			(node->tracelet_size == tracelet_size) &&
			(memcmp(node->tracelet, tracelet, tracelet_size) == 0))
		{

			uint8_t top = retstack->top;
			size_t i;
			for (i = 0; i < node->stack_removed; i++) {
				if (top == retstack->bottom) break;
				top = (!top ? pt_retstack_size : top - 1);
				if (retstack->stack[top] != node->stack_prev[i]) break;
			}
			if (i == node->stack_removed) return node; // finally

		}
		node = node->hash_next;
	}

	return NULL;
}

void dump_lut(unsigned char *lut, char *lutname) {
	printf("unsigned char %s[] = {\n", lutname);
	for (int i = 0; i<32; i++) {
		printf("\t");
		for (int j = 0; j<8; j++) {
			printf("0x%02x", lut[i * 8 + j]);
			if (j != 7) printf(", ");
		}
		if (i != 31) printf(",\n");
		else printf("\n");
	}
	printf("};\n\n");
}

// function that was used to build the lookup tables for the packet decoder
void build_luts() {
	for (int i = 0; i<256; i++) {
		opc_lut[i] = ppt_invalid;
	}

	for (int i = 0; i<256; i++) {
		ext_lut[i] = ppt_invalid;
	}

	for (int i = 0; i<256; i++) {
		opc_size_lut[i] = 0;
		ext_size_lut[i] = 0;
	}

	//ext packets
	opc_lut[pt_opc_ext] = PPT_EXT;
	opc_size_lut[pt_opc_ext] = 1; // not really important

								  //pad packet
	opc_lut[pt_opc_pad] = ppt_pad;
	opc_size_lut[pt_opc_pad] = 1;

	//tip packet
	for (int i = 0; i<8; i++) {
		unsigned char opcode = (unsigned char)((i << 5) + 0xd);

		if (i == 0) {
			opc_lut[opcode] = ppt_tip;
			opc_size_lut[opcode] = 1;
		}
		else if (i == 1) {
			opc_lut[opcode] = ppt_tip;
			opc_size_lut[opcode] = 1 + 2;
		}
		else if (i == 2) {
			opc_lut[opcode] = ppt_tip;
			opc_size_lut[opcode] = 1 + 4;
		}
		else if ((i == 3) || (i == 4)) {
			opc_lut[opcode] = ppt_tip;
			opc_size_lut[opcode] = 1 + 6;
		}
		else if (i == 6) {
			opc_lut[opcode] = ppt_tip;
			opc_size_lut[opcode] = 1 + 8;
		}
	}

	//tip.pge packet
	for (int i = 0; i<8; i++) {
		unsigned char opcode = (unsigned char)((i << 5) + 0x11);

		if (i == 0) {
			opc_lut[opcode] = ppt_tip_pge;
			opc_size_lut[opcode] = 1;
		}
		else if (i == 1) {
			opc_lut[opcode] = ppt_tip_pge;
			opc_size_lut[opcode] = 1 + 2;
		}
		else if (i == 2) {
			opc_lut[opcode] = ppt_tip_pge;
			opc_size_lut[opcode] = 1 + 4;
		}
		else if ((i == 3) || (i == 4)) {
			opc_lut[opcode] = ppt_tip_pge;
			opc_size_lut[opcode] = 1 + 6;
		}
		else if (i == 6) {
			opc_lut[opcode] = ppt_tip_pge;
			opc_size_lut[opcode] = 1 + 8;
		}
	}

	//tip.pgd packet
	for (int i = 0; i<8; i++) {
		unsigned char opcode = (unsigned char)((i << 5) + 0x1);

		if (i == 0) {
			opc_lut[opcode] = ppt_tip_pgd;
			opc_size_lut[opcode] = 1;
		}
		else if (i == 1) {
			opc_lut[opcode] = ppt_tip_pgd;
			opc_size_lut[opcode] = 1 + 2;
		}
		else if (i == 2) {
			opc_lut[opcode] = ppt_tip_pgd;
			opc_size_lut[opcode] = 1 + 4;
		}
		else if ((i == 3) || (i == 4)) {
			opc_lut[opcode] = ppt_tip_pgd;
			opc_size_lut[opcode] = 1 + 6;
		}
		else if (i == 6) {
			opc_lut[opcode] = ppt_tip_pgd;
			opc_size_lut[opcode] = 1 + 8;
		}
	}

	//fup packet
	for (int i = 0; i<8; i++) {
		unsigned char opcode = (unsigned char)((i << 5) + 0x1d);

		if (i == 0) {
			opc_lut[opcode] = ppt_fup;
			opc_size_lut[opcode] = 1;
		}
		else if (i == 1) {
			opc_lut[opcode] = ppt_fup;
			opc_size_lut[opcode] = 1 + 2;
		}
		else if (i == 2) {
			opc_lut[opcode] = ppt_fup;
			opc_size_lut[opcode] = 1 + 4;
		}
		else if ((i == 3) || (i == 4)) {
			opc_lut[opcode] = ppt_fup;
			opc_size_lut[opcode] = 1 + 6;
		}
		else if (i == 6) {
			opc_lut[opcode] = ppt_fup;
			opc_size_lut[opcode] = 1 + 8;
		}
	}

	//mode packet
	opc_lut[pt_opc_mode] = ppt_mode;
	opc_size_lut[pt_opc_mode] = 2;

	//tsc packet
	opc_lut[pt_opc_tsc] = ppt_tsc;
	opc_size_lut[pt_opc_tsc] = 8;

	//mtc packet
	opc_lut[pt_opc_mtc] = ppt_mtc;
	opc_size_lut[pt_opc_mtc] = 2;

	//cyc packet
	for (int i = 0; i<64; i++) {
		unsigned char opcode = (unsigned char)((i << 2) + 0x3);
		opc_lut[opcode] = ppt_cyc;
		opc_size_lut[opcode] = 1;
	}

	//tnt packets
	for (int i = 1; i <= 6; i++) {
		for (int bits = 0; bits<(1 << i); bits++) {
			unsigned char opcode = (unsigned char)((1 << (i + 1)) + (bits << 1));
			opc_lut[opcode] = ppt_tnt_8;
			opc_size_lut[opcode] = 1;
		}
	}

	//////extensions///////

	//psb packet
	ext_lut[pt_ext_psb] = ppt_psb;
	ext_size_lut[pt_ext_psb] = 16;

	//long tnt packet
	ext_lut[pt_ext_tnt_64] = ppt_tnt_64;
	ext_size_lut[pt_ext_tnt_64] = 8;

	//pip packet
	ext_lut[pt_ext_pip] = ppt_pip;
	ext_size_lut[pt_ext_pip] = 8;

	//ovf packet
	ext_lut[pt_ext_ovf] = ppt_ovf;
	ext_size_lut[pt_ext_ovf] = 2;

	//psbend packet
	ext_lut[pt_ext_psbend] = ppt_psbend;
	ext_size_lut[pt_ext_psbend] = 2;

	//cbr packet
	ext_lut[pt_ext_cbr] = ppt_cbr;
	ext_size_lut[pt_ext_cbr] = 4;

	//tma packet
	ext_lut[pt_ext_tma] = ppt_tma;
	ext_size_lut[pt_ext_tma] = 7;

	//stop packet
	ext_lut[pt_ext_stop] = ppt_stop;
	ext_size_lut[pt_ext_stop] = 2;

	//vmcs packet
	ext_lut[pt_ext_vmcs] = ppt_vmcs;
	ext_size_lut[pt_ext_vmcs] = 7;

	//exstop packet
	ext_lut[pt_ext_exstop] = ppt_exstop;
	ext_size_lut[pt_ext_exstop] = 2;

	//exstop-ip packet
	ext_lut[pt_ext_exstop_ip] = ppt_exstop;
	ext_size_lut[pt_ext_exstop_ip] = 2;

	//mwait packet
	ext_lut[pt_ext_mwait] = ppt_mwait;
	ext_size_lut[pt_ext_mwait] = 10;

	//pwre packet
	ext_lut[pt_ext_pwre] = ppt_pwre;
	ext_size_lut[pt_ext_pwre] = 4;

	//pwrx packet
	ext_lut[pt_ext_pwrx] = ppt_pwrx;
	ext_size_lut[pt_ext_pwrx] = 7;

	//ptw packet
	for (int i = 0; i<2; i++) {
		for (int j = 0; j<2; j++) {
			unsigned char opcode = (unsigned char)((i << 7) + (j << 5) + 0x12);
			ext_lut[opcode] = ppt_ptw;
			if (j == 0) {
				ext_size_lut[opcode] = 6;
			}
			else if (j == 1) {
				ext_size_lut[opcode] = 10;
			}
		}
	}

	//ext2
	ext_lut[pt_ext_ext2] = PPT_EXT;
	ext_size_lut[pt_ext_ext2] = 1; // not really important

	dump_lut(opc_lut, "opc_lut");
	dump_lut(ext_lut, "ext_lut");
	dump_lut(opc_size_lut, "opc_size_lut");
	dump_lut(ext_size_lut, "ext_size_lut");
}

// sign extend
inline static uint64_t sext(uint64_t val, uint8_t sign) {
	uint64_t signbit, mask;

	signbit = 1ull << (sign - 1);
	mask = ~0ull << sign;

	return val & signbit ? val | mask : val & ~mask;
}

// finds the next psb packet in the data buffer
bool findpsb(unsigned char **data, size_t *size) {
	if (*size < 16) return false;

	if (memcmp(*data, psb, sizeof(psb)) == 0) return true;

	for (size_t i = 0; i < (*size - sizeof(psb) - 1); i++) {
		if (((*data)[i] == psb[0]) && ((*data)[i+1] == psb[1])) {
			if (memcmp((*data) + i, psb, sizeof(psb)) == 0) {
				*data = *data + i;
				*size = *size - i;
				return true;
			}
		}
	}

	return false;
}

// checks if the IP address is in one of the modules we are interested in
// and updates the coverage map
inline static int update_coverage_map(uint64_t next_ip, int coverage_kind) {
	uint32_t offset;

	if (next_ip < current_range->start) {
		do {
			current_range--;
		} while (next_ip < current_range->start);
	} else if (next_ip > current_range->end) {
		do {
			current_range++;
		} while (next_ip > current_range->end);
	}

	if (!current_range->collect) return 0;

	// printf("ip: %p\n", (void*)next_ip);

	offset = (uint32_t)(next_ip - current_range->start);

	switch (coverage_kind) {
	case COVERAGE_BB:
		trace_bits[offset % MAP_SIZE]++;
		break;
	case COVERAGE_EDGE:
		trace_bits[(offset ^ previous_offset) % MAP_SIZE]++;
		previous_offset = offset >> 1;
	break;
	}

	return 1;
}

// checks if the IP address is in one of the modules we are interested in
// and updates the coverage_cache datastructure
inline static int update_coverage_cache(struct coverage_cache_t *coverage_cache,
	uint64_t next_ip, int coverage_kind)
{

	uint32_t offset;

	if (next_ip < current_range->start) {
		do {
			current_range--;
		} while (next_ip < current_range->start);
	}
	else if (next_ip > current_range->end) {
		do {
			current_range++;
		} while (next_ip > current_range->end);
	}

	if (!current_range->collect) return 0;

	// printf("ip: %p\n", (void*)next_ip);

	offset = (uint32_t)(next_ip - current_range->start);

	switch (coverage_kind) {
	case COVERAGE_BB:
		tracelet_coverage_add_bb(coverage_cache, offset);
		break;
	case COVERAGE_EDGE:
		tracelet_coverage_add_edge(coverage_cache, offset);
		break;
	}

	return 1;
}

// gets the opcode and the size of the next packet in the trace buffer
static inline int get_next_opcode(unsigned char **data_p, size_t *size_p, 
	unsigned char *opcode_p, unsigned char *opcodesize_p)
{

	unsigned char *data = *data_p;
	size_t size = *size_p;

	unsigned char opcode = opc_lut[*data];
	unsigned char opcodesize = opc_size_lut[*data];
    
    // handle extensions
    if(opcode == PPT_EXT) {
      if(size < 2) return 0;

      opcode = ext_lut[*(data+1)];
      opcodesize = ext_size_lut[*(data+1)];

      // second-level extension
      if(opcode == PPT_EXT) {
        if(size < 3) return 0;
        
        // currently there is only one possibility
        if((*(data+2)) == 0x88) {
          opcode = ppt_mnt;
          opcodesize = 11;
        } else {
          opcode = ppt_invalid;
          opcodesize = 0;
        }
      }
    } else if(opcode == ppt_cyc) {
      // special handling for cyc packets since
      // they don't have a predetermined size
      if(*data & 4) {
        opcodesize = 2;

        while(1) {
          if(size < opcodesize) return 0;
          if(!((*(data + (opcodesize - 1))) & 1)) break;
          opcodesize++;
        }
      }
    }

	if (size < opcodesize) return 0;

	*opcode_p = opcode;
	*opcodesize_p = opcodesize;

	return 1;
}

static inline uint64_t decode_ip(unsigned char *data) {
	uint64_t next_ip;

	switch ((*data) >> 5) {
	case 0:
		next_ip = previous_ip;
		break;
	case 1:
		next_ip = (previous_ip & 0xFFFFFFFFFFFF0000ULL) | *((uint16_t *)(data + 1));
		break;
	case 2:
		next_ip = (previous_ip & 0xFFFFFFFF00000000ULL) | *((uint32_t *)(data + 1));
		break;
	case 3:
		next_ip = sext(*((uint32_t *)(data + 1)) | ((uint64_t)(*((uint16_t *)(data + 5))) << 32), 48);
		break;
	case 4:
		next_ip = (previous_ip & 0xFFFF000000000000ULL) | *((uint32_t *)(data + 1)) | ((uint64_t)(*((uint16_t *)(data + 5))) << 32);
		break;
	case 6:
		next_ip = *((uint64_t *)(data + 1));
		break;
	}
	previous_ip = next_ip;

	return next_ip;
}

// returns the type of the first packet or ppt_invalid
int get_next_tracelet(unsigned char **data, size_t *size,
	unsigned char **tracelet_data, size_t *tracelet_size)
{
	unsigned char opcode;
	unsigned char opcodesize;
	unsigned char previous_opcode = ppt_invalid;
	int ret = ppt_tnt_8;

	while (*size) {

		if (!get_next_opcode(data, size, &opcode, &opcodesize))
			return ppt_invalid;

		if (opcode == ppt_invalid) return ppt_invalid;

		// printf("packet type: %d\n", opcode);

		switch (opcode) {
		case ppt_tnt_8:
		case ppt_tnt_64:
			// merge tiny tracelets
			if (*tracelet_size > MIN_TRACELET_SIZE) {
				// always cut before tnt preceeded by non-tnt
				if (previous_opcode != ppt_invalid &&
					previous_opcode != ppt_tnt_8 &&
					previous_opcode != ppt_tnt_64)
				{
					return ret;
				}
				// cut very long streams of tnt packets
				if (*tracelet_size > MAX_TRACELET_SIZE) {
					return ret;
				}
			}
			memcpy(*tracelet_data, *data, opcodesize);
			*tracelet_data += opcodesize;
			*tracelet_size += opcodesize;
			*size -= opcodesize;
			*data += opcodesize;
			previous_opcode = opcode;
			break;
		case ppt_psb:
			// let the caller know there is a psb in this tracelet
			ret = ppt_psb;
		case ppt_psbend:
		case ppt_fup:
		case ppt_tip:
		case ppt_tip_pge:
		case ppt_tip_pgd:
		case ppt_ovf:
		case ppt_mode:
			// just copy these packets
			memcpy(*tracelet_data, *data, opcodesize);
			*tracelet_data += opcodesize;
			*tracelet_size += opcodesize;
			*size -= opcodesize;
			*data += opcodesize;
			previous_opcode = opcode;
			break;
		default:
			// skip over all other packets
			*size -= opcodesize;
			*data += opcodesize;
			break;
		}
	}

	return ret;
}

// checks if the trace starts with the expected IP address
int check_trace_start(unsigned char *data, size_t size, uint64_t expected_ip) {
	unsigned char opcode;
	unsigned char opcodesize;

	previous_ip = 0;

	while (size) {
		if (!get_next_opcode(&data, &size, &opcode, &opcodesize)) return 0;

		switch (opcode) {
		case ppt_tip_pge:
			if (decode_ip(data) == expected_ip) return 1;
			else return 0;
		case ppt_fup:
		case ppt_tip:
		case ppt_tnt_8:
		case ppt_tnt_64:
		case ppt_tip_pgd:
		case ppt_invalid:
			return 0;
		default:
			break;
		}

		size -= opcodesize;
		data += opcodesize;
	}

	return 0;
}

// fast decoder that decodes only tip (and related packets)
// and skips over the reset
void decode_trace_tip_fast(unsigned char *data, size_t size, int coverage_kind) {
  uint64_t next_ip;

  unsigned char opcode;
  unsigned char opcodesize;

  previous_offset = 0;
  previous_ip = 0;
  current_range = &(coverage_ip_ranges[0]);

  if (size < sizeof(psb)) return;

  if (!findpsb(&data, &size)) {
	  FATAL("No sync packets in trace\n");
	  return;
  }

  while(size) {

	if (!get_next_opcode(&data, &size, &opcode, &opcodesize)) return;

    if(opcode == ppt_invalid) {
      printf("Decoding error\n");
	  if (findpsb(&data, &size)) continue;
	  else return;
    }

	// printf("packet type: %d\n", opcode);

    switch (opcode) {
    case ppt_fup:
    case ppt_tip:
    case ppt_tip_pge:
    case ppt_tip_pgd:
	  next_ip = decode_ip(data);
      break;
    default:
      break;
    }

	if (opcode == ppt_tip) {
		// printf("ip: %p\n", (void*)next_ip);
		update_coverage_map(next_ip, coverage_kind);
	}

    size -= opcodesize;
    data += opcodesize;
  }
}

// process a sinle IPT packet and update AFL map
inline static void process_packet(struct pt_packet *packet, int coverage_kind) {
	// printf("packet type: %d\n", packet->type);

	if ((packet->type != ppt_tip) && (packet->type != ppt_tip_pge) && (packet->type != ppt_tip_pgd) && (packet->type != ppt_fup)) {
		return;
	}

	uint64_t next_ip;
	switch (packet->payload.ip.ipc) {
	case pt_ipc_update_16:
		next_ip = (previous_ip & 0xFFFFFFFFFFFF0000ULL) | (packet->payload.ip.ip & 0xFFFF);
		break;
	case pt_ipc_update_32:
		next_ip = (previous_ip & 0xFFFFFFFF00000000ULL) | (packet->payload.ip.ip & 0xFFFFFFFF);
		break;
	case pt_ipc_update_48:
		next_ip = (previous_ip & 0xFFFF000000000000ULL) | (packet->payload.ip.ip & 0xFFFFFFFFFFFF);
		break;
	case pt_ipc_sext_48:
		next_ip = sext(packet->payload.ip.ip, 48);
		break;
	case pt_ipc_full:
		next_ip = packet->payload.ip.ip;
		break;
	default:
		return;
	}

	previous_ip = next_ip;

	if (packet->type == ppt_tip) {
		// printf("ip: %p\n", (void*)next_ip);
		update_coverage_map(next_ip, coverage_kind);
	}
}

// decodes only TIP packets using the reference implementation
void decode_trace_tip_reference(unsigned char *trace_data, size_t trace_size,
	int coverage_kind)
{
	// printf("analyzing trace\n");

	struct pt_packet_decoder *decoder;
	struct pt_config ptc;
	struct pt_packet packet;

	previous_offset = 0;
	previous_ip = 0;
	current_range = &(coverage_ip_ranges[0]);

	pt_config_init(&ptc);
	pt_cpu_read(&ptc.cpu);
	pt_cpu_errata(&ptc.errata, &ptc.cpu);
	ptc.begin = trace_data;
	ptc.end = trace_data + trace_size;

	decoder = pt_pkt_alloc_decoder(&ptc);
	if (!decoder) {
		FATAL("Error allocating decoder\n");
	}

	for (;;) {
		if (pt_pkt_sync_forward(decoder) < 0) {
			// printf("No more sync packets\n");
			break;
		}

		for (;;) {
			if (pt_pkt_next(decoder, &packet, sizeof(packet)) < 0) {
				// printf("Error reding packet\n");
				break;
			}

			process_packet(&packet, coverage_kind);
		}
	}

	pt_pkt_free_decoder(decoder);
}


// looks up if we already have the tracelet in cache and if so update
// the state and coverage from the cache entry
inline static bool process_tracelet_from_cache(uint64_t hash,
	decoder_state *state, unsigned char *tracelet, 
	size_t tracelet_size, struct pt_retstack *retstack,
	int coverage_kind)
{

	tracelet_cache_node *cache_node = cache_find_node(hash, state, tracelet, tracelet_size, retstack);

	if (!cache_node) return false;

	// mark the node as least recently used
	cache_node_touch(cache_node);

	// update state from cache
	*state = cache_node->state_next;

	// update stack if needed
	if (cache_node->stack_removed || cache_node->stack_added) {
		uint8_t top, bottom;
		top = retstack->top;
		bottom = retstack->bottom;

		for (uint32_t i = 0; i < cache_node->stack_removed; i++) {
			top = (!top ? pt_retstack_size : top - 1);
		}

		for (uint32_t i = 0; i < cache_node->stack_added; i++) {
			retstack->stack[top] = cache_node->stack_next[i];
			top = (top == pt_retstack_size ? 0 : top + 1);
			if (bottom == top) bottom = (bottom == pt_retstack_size ? 0 : bottom + 1);
		}

		retstack->top = top;
		retstack->bottom = bottom;
	}

	// update trace_bits
	switch (coverage_kind) {
	case COVERAGE_BB:
		for (uint32_t i = 0; i < cache_node->map_update_size; i++) {
			trace_bits[cache_node->map_offsets[i]] += cache_node->map_updates[i];
		}
		break;
	case COVERAGE_EDGE:
		if (cache_node->map_update_size) {
			trace_bits[(cache_node->map_offsets[0] ^ previous_offset) % MAP_SIZE]++;
			for (uint32_t i = 1; i < cache_node->map_update_size - 1; i++) {
				trace_bits[cache_node->map_offsets[i]] += cache_node->map_updates[i];
			}
			previous_offset = cache_node->map_offsets[cache_node->map_update_size - 1];
		}
		break;
	}

	return true;
}

// processes a tracelet using the reference decoder
inline static int process_tracelet_reference(struct pt_block_decoder *decoder,
	uint8_t *tracelet_end, decoder_state *state_before, decoder_state *state_after,
	struct pt_retstack *retstack_before, int *stack_added, int *stack_removed,
	struct coverage_cache_t *coverage_cache, int coverage_kind,
	bool first_tracelet, bool track_stack, bool *skip_next)
{

	int stack_last;
	int status;

	struct pt_event event;
	struct pt_block block;

	decoder->query.config.end = tracelet_end;
	status = pt_blk_sync_set(decoder, 0);

	if (status < 0) return status;

	// restore state
	if (!first_tracelet) {
		decoder->query.ip.ip = state_before->query_ip;
		decoder->query.ip.have_ip = 1;
		decoder->query.ip.suppressed = 0;
		decoder->enabled = 1;
		decoder->mode = state_before->mode;
		decoder->ip = state_before->block_ip;
		decoder->retstack = *retstack_before;
	}

	stack_last = retstack_before->top;

	*stack_added = 0;
	*stack_removed = 0;

	tracelet_coverage_clear(coverage_cache, coverage_kind);

	for (;;) {
		// we aren't really interested in events
		// but have to empty the event queue
		while (status & pts_event_pending) {
			status = pt_blk_event(decoder, &event, sizeof(event));
			if (status < 0)
				break;

			// printf("event %d\n", event.type);
		}

		if (status < 0) {
			break;
		}

		status = pt_blk_next(decoder, &block, sizeof(block));

		if (track_stack) {
			if (decoder->retstack.top != stack_last) {
				if ((decoder->retstack.top == stack_last - 1) ||
					(decoder->retstack.top == 64) && (stack_last == 0)) {
					*stack_added -= 1;
					if (*stack_added < *stack_removed) *stack_removed = *stack_added;
				}
				else if ((decoder->retstack.top == stack_last + 1) ||
					(decoder->retstack.top == 0) && (stack_last == 64)) {
					*stack_added += 1;
				}
				else {
					FATAL("Error: unexpected stack change");
				}
				stack_last = decoder->retstack.top;
			}
		}

		if (status < 0) {
			// printf("status: %d\n", status);
			break;
		}

		if (!*skip_next) {
			*skip_next = false;
			update_coverage_cache(coverage_cache, block.ip, coverage_kind);
			// printf("ip: %p, %d %d\n", (void *)block.ip, status, block.iclass);
		}

		// Sometimes, due to asynchronous events and other reasons (?)
		// the tracing of a basic block will break in the middle of it
		// and the subsequent basic block will continue where the previous
		// one was broken, resulting in new coverage detected where there
		// was none.
		// Currently, this is resolved by examining the instruction class of
		// the last instruction in the basic block. If it is not one of the 
		// instructions that normally terminate a basic block, we will simply
		// ignore the subsequent block.
		// Another way to do this could be to compute the address of the next
		// instruction after the basic block, and only ignore a subsequent block
		// if it starts on that address
		if (block.iclass == ptic_other) *skip_next = true;
		else *skip_next = false;
	}

	state_after->query_ip = decoder->query.ip.ip;
	state_after->mode = decoder->mode;
	state_after->block_ip = block.ip;

	switch (coverage_kind) {
	case COVERAGE_BB:
		for (uint32_t i = 0; i < coverage_cache->size; i++) {
			trace_bits[coverage_cache->map_offsets[i]] += coverage_cache->counters[i];
		}
		break;
	case COVERAGE_EDGE:
		if (coverage_cache->size) {
			trace_bits[(coverage_cache->map_offsets[0] ^ previous_offset) % MAP_SIZE]++;
			for (uint32_t i = 1; i < coverage_cache->size - 1; i++) {
				trace_bits[coverage_cache->map_offsets[i]] += coverage_cache->counters[i];
			}
			previous_offset = coverage_cache->map_offsets[coverage_cache->size - 1];
		}
		break;
	}

	return status;
}


// constructs the cache node from the decoder state, tracelet etc
// and adds it to the cache
static inline void add_cache_node(
	uint8_t *tracelet, size_t tracelet_size, uint64_t hash,
	decoder_state *state_before, decoder_state *state_after,
	struct pt_retstack *retstack_before, struct pt_retstack *retstack_after,
	int stack_added, int stack_removed,
	struct coverage_cache_t *coverage_cache)
{
	stack_removed = -stack_removed;
	stack_added += stack_removed;

	if (stack_removed > (pt_retstack_size + 1)) stack_removed = (pt_retstack_size + 1);

	if (stack_added < 0) stack_added = 0;
	if (stack_added >(pt_retstack_size + 1)) stack_added = (pt_retstack_size + 1);

	size_t node_size = sizeof(tracelet_cache_node) +
		stack_removed * sizeof(uint64_t) + stack_added * sizeof(uint64_t) +
		coverage_cache->size * sizeof(uint32_t) + coverage_cache->size * sizeof(uint8_t) +
		tracelet_size;

	tracelet_cache_node *cache_node = (tracelet_cache_node *)malloc(node_size);

	cache_node->size = node_size;
	cache_node->hash = hash;

	uint8_t* ptr = (uint8_t*)cache_node + sizeof(tracelet_cache_node);
	cache_node->stack_prev = (uint64_t *)ptr;
	cache_node->stack_removed = stack_removed;
	ptr += stack_removed * sizeof(uint64_t);
	cache_node->stack_next = (uint64_t *)ptr;
	cache_node->stack_added = stack_added;
	ptr += stack_added * sizeof(uint64_t);
	cache_node->map_offsets = (uint32_t *)ptr;
	ptr += coverage_cache->size * sizeof(uint32_t);
	cache_node->map_updates = ptr;
	cache_node->map_update_size = coverage_cache->size;
	ptr += coverage_cache->size * sizeof(uint8_t);
	cache_node->tracelet = ptr;
	cache_node->tracelet_size = (uint32_t)tracelet_size;

	uint8_t top;
	top = retstack_before->top;
	for (int i = 0; i < stack_removed; i++) {
		top = (!top ? pt_retstack_size : top - 1);
		cache_node->stack_prev[i] = retstack_before->stack[top];
	}

	top = retstack_after->top;
	for (int i = 0; i < stack_added; i++) {
		top = (!top ? pt_retstack_size : top - 1);
		cache_node->stack_next[stack_added - i - 1] = retstack_after->stack[top];
	}

	memcpy(cache_node->map_offsets, coverage_cache->map_offsets, coverage_cache->size * sizeof(uint32_t));
	memcpy(cache_node->map_updates, coverage_cache->counters, coverage_cache->size * sizeof(uint8_t));

	memcpy(cache_node->tracelet, tracelet, tracelet_size);

	cache_node->state_prev = *state_before;
	cache_node->state_next = *state_after;

	cache_node_add(cache_node);
}

// uses a faster basic block decoder to decode the full trace
// tl;dr the faster decoder is essentially a caching layer on top of the
// reference decoder
// needs to have access to executable memory of the process that generated
// the trace (passed through pt_image)
void analyze_trace_full_fast(unsigned char *trace_data, size_t trace_size,
	int coverage_kind, struct pt_image *image, bool skip_first_bb)
{
	// some stats
	int num_tracelets=0, num_cache_hits=0;

	size_t tracelet_buffer_size = trace_size + sizeof(psb_and_psbend);
	unsigned char *tracelet_buffer = malloc(tracelet_buffer_size);
	size_t tracelet_size;

	memcpy(tracelet_buffer, psb_and_psbend, sizeof(psb_and_psbend));
	unsigned char *buffer_after_psb = tracelet_buffer + sizeof(psb_and_psbend);
	unsigned char *tracelet_start;

	decoder_state state, state_next;
	struct pt_retstack retstack;
	retstack.top = 0;
	retstack.bottom = 0;

	uint64_t hash;

	int stack_removed;
	int stack_added;

	struct pt_block_decoder *decoder;
	struct pt_config config;

	bool skip_next = skip_first_bb;
	bool first_tracelet = true;
	bool use_cache = false;

	previous_offset = 0;
	previous_ip = 0;
	current_range = &(coverage_ip_ranges[0]);

	struct coverage_cache_t *coverage_cache =
		(struct coverage_cache_t *)malloc(sizeof(struct coverage_cache_t));
	tracelet_coverage_init(coverage_cache);

	pt_config_init(&config);
	pt_cpu_read(&config.cpu);
	pt_cpu_errata(&config.errata, &config.cpu);
	config.begin = tracelet_buffer;
	config.end = tracelet_buffer + tracelet_buffer_size;

	// This is important not only for accurate coverage, but also because
	// if we don't set it, the decoder is sometimes going to break
	// blocks on these instructions anyway, resulting in new coverage being
	// detected where there in fact was none.
	// See also skip_next comment below
	config.flags.variant.block.end_on_call = 1;
	config.flags.variant.block.end_on_jump = 1;

	decoder = pt_blk_alloc_decoder(&config);
	if (!decoder) {
		FATAL("Error allocating decoder\n");
	}

	int ret = pt_blk_set_image(decoder, image);

	int status;

	if (!findpsb(&trace_data, &trace_size)) {
		FATAL("No sync packets in trace\n");
		return;
	}

	for (;;) {
		tracelet_start = buffer_after_psb;
		tracelet_size = 0;

		int ret = get_next_tracelet(&trace_data, &trace_size, &tracelet_start, &tracelet_size);

		if (!tracelet_size) break;

		if (ret == ppt_invalid) {
			if (!findpsb(&trace_data, &trace_size)) {
				break;
			}
			first_tracelet = true;
			skip_next = true;
			continue;
		}
		else if (ret == ppt_psb) {
			// don't use cache for tracelets containing psb
			// psbs are going to mess up our stack tracking
			use_cache = false;
		}
		else {
			use_cache = true;
		}

		if (skip_next) {
			use_cache = false;
		}

		num_tracelets++;

		// printf("tracelet size: %llu\n", tracelet_size);

		hash = djb2(buffer_after_psb, tracelet_size);

		// printf("hash: %llx\n", hash);

		if (use_cache &&
			process_tracelet_from_cache(hash, &state, buffer_after_psb,
				tracelet_size, &retstack, coverage_kind))
		{
			num_cache_hits++;
			continue;
		}

		status = process_tracelet_reference(decoder, tracelet_start,
			&state, &state_next, &retstack, &stack_added, &stack_removed,
			coverage_cache, coverage_kind, first_tracelet, use_cache,
			&skip_next);

		first_tracelet = false;

		if ((status < 0) && (status != -pte_eos)) {
			if (!findpsb(&trace_data, &trace_size)) {
				printf("cant't sync\n");
				break;
			}
			skip_next = true;
			continue;
		}

		if (use_cache && !skip_next) {
			// create a new cache node and add it to the cache
			add_cache_node(buffer_after_psb, tracelet_size, hash,
				&state, &state_next, &retstack, &decoder->retstack,
				stack_added, stack_removed, coverage_cache);
		}

		// switch state
		state = state_next;
		retstack = decoder->retstack;
	}

	free(coverage_cache);
	free(tracelet_buffer);

	pt_blk_free_decoder(decoder);

	// printf("Cache hits: %d/%d (%g%%)\n", num_cache_hits, num_tracelets,
	// 	((float)num_cache_hits / num_tracelets) * 100);
	// printf("tracelet cache num entries: %llu, size: %llu\n",
	// 	tracelet_cache.num_entries, tracelet_cache.size);
}

// uses Intel's reference basic block decoder to decode the full trace
// needs to have access to executable memory of the process that generated
// the trace (passed through pt_image)
void analyze_trace_full_reference(unsigned char *trace_data, size_t trace_size,
	int coverage_kind, struct pt_image *image, bool skip_first_bb) {

	struct pt_block_decoder *decoder;
	struct pt_config config;
	struct pt_event event;
	struct pt_block block;

	bool skip_next = skip_first_bb;

	previous_offset = 0;
	previous_ip = 0;
	current_range = &(coverage_ip_ranges[0]);

	pt_config_init(&config);
	pt_cpu_read(&config.cpu);
	pt_cpu_errata(&config.errata, &config.cpu);
	config.begin = trace_data;
	config.end = trace_data + trace_size;

	// This is important not only for accurate coverage, but also because
	// if we don't set it, the decoder is sometimes going to break
	// blocks on these instructions anyway, resulting in new coverage being
	// detected where there in fact was none.
	// See also skip_next comment below
	config.flags.variant.block.end_on_call = 1;
	config.flags.variant.block.end_on_jump = 1;

	decoder = pt_blk_alloc_decoder(&config);
	if (!decoder) {
		FATAL("Error allocating decoder\n");
	}

	int ret = pt_blk_set_image(decoder, image);

	int status;

	for (;;) {
		status = pt_blk_sync_forward(decoder);
		if (status < 0) {
			// printf("cant't sync\n");
			break;
		}

		for (;;) {

			// we aren't really interested in events
			// but have to empty the event queue
			while (status & pts_event_pending) {
				status = pt_blk_event(decoder, &event, sizeof(event));
				if (status < 0)
					break;

				// printf("event %d\n", event.type);
			}

			if (status < 0)
				break;

			status = pt_blk_next(decoder, &block, sizeof(block));

			if (status < 0) {
				break;
			}

			if (!skip_next) {
				skip_next = false;
				update_coverage_map(block.ip, coverage_kind);
				// printf("ip: %p, %d %d\n", (void *)block.ip, status, block.iclass);
			}

			// Sometimes, due to asynchronous events and other reasons (?)
			// the tracing of a basic block will break in the middle of it
			// and the subsequent basic block will continue where the previous
			// one was broken, resulting in new coverage detected where there
			// was none.
			// Currently, this is resolved by examining the instruction class of
			// the last instruction in the basic block. If it is not one of the 
			// instructions that normally terminate a basic block, we will simply
			// ignore the subsequent block.
			// Another way to do this could be to compute the address of the next
			// instruction after the basic block, and only ignore a subsequent block
			// if it starts on that address
			if (block.iclass == ptic_other) skip_next = true;
			else skip_next = false;
		}
	}

	pt_blk_free_decoder(decoder);
}

```

`ptdecode.h`:

```h
/*
  WinAFL - Intel PT decoding
  ------------------------------------------------

  Written and maintained by Ivan Fratric <ifratric@google.com>

  Copyright 2016 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

typedef struct _address_range {
	uint64_t start;
	uint64_t end;
	char collect; // collect coverage for range or not
} address_range;

int check_trace_start(unsigned char *data, size_t size, uint64_t expected_ip);

void tracelet_cache_init(size_t max_entries, size_t max_size);

void analyze_trace_full_reference(unsigned char *trace_data, size_t trace_size, int coverage_kind, struct pt_image *image, bool skip_first_bb);
void analyze_trace_full_fast(unsigned char *trace_data, size_t trace_size, int coverage_kind, struct pt_image *image, bool skip_first_bb);
void decode_trace_tip_fast(unsigned char *data, size_t size, int coverage_kind);
void decode_trace_tip_reference(unsigned char *trace_data, size_t trace_size, int coverage_kind);
```

`readme_dr.md`:

```md
# Dynamorio Instrumentation mode

## How it works

This mode relies on dynamic instrumentation using DynamoRIO
(http://dynamorio.org/) to measure and extract target coverage. This approach
has been found to introduce an overhead about 2x compared to the native
execution speed, which is comparable to the original AFL in binary
instrumentation mode.

In order to use it you need to

 - download and build DynamoRIO sources or download DynamoRIO Windows binary
package from https://github.com/DynamoRIO/dynamorio/wiki/Downloads

 - Specify the `-DDynamoRIO_DIR` option when building WinAFL

## Supported instrumentation flags

The following instrumentation options are supported in the DynamoRIO mode:

```
  -covtype         - the type of coverage being recorded. Supported options are
                     bb (basic block, default) or edge.

  -coverage_module - module for which to record coverage. Multiple module flags
                     are supported.

  -target_module   - module which contains the target function to be fuzzed.
                     Either -target_method or -target_offset need to be
                     specified together with this option.

  -target_method   - name of the method to fuzz in persistent mode. For this to
                     work either the method needs to be exported or the symbols
                     for target_module need to be available. Otherwise use
                     -target_offset instead.

  -target_offset   - offset of the method to fuzz from the start of the module.

  -fuzz_iterations - Maximum number of iterations for the target function to run
                     before restarting the target process.

  -nargs           - Number of arguments the fuzzed method takes. This is used
                     to save/restore the arguments between runs.

  -call_convention - The default calling convention is cdecl on 32-bit x86
                     platforms and Microsoft x64 for Visual Studio 64-bit
                     applications. Possible values:
                         * fastcall: fastcall
                         * ms64: Microsoft x64 (Visual Studio)
                         * stdcall: cdecl or stdcall
                         * thiscall: thiscall

  -debug           - Debug mode. Does not try to connect to the server. Outputs
                     a log file containing loaded modules, opened files and
                     coverage information.

  -logdir          - specifies in which directory the log file will be written
                     (only to be used with -debug).

  -thread_coverage - If set, WinAFL will only collect coverage from a thread
                     that executed the target function
```

## Using

Note: If you are using pre-built binaries you'll need to download DynamoRIO
release 7.1.0-1 from https://github.com/DynamoRIO/dynamorio/wiki/Downloads.
If you built WinAFL from source, you can use whatever version of DynamoRIO
you used to build WinAFL.

In general, you should perform the following steps when fuzzing a new target:

1. Make sure your target is running correctly without instrumentations.

2. Open the target binary in WinDbg and locate the function you want to fuzz.
Note the offset of the function from the start of the module. For example, if
you want to fuzz the main function and happen to have symbols around, you can
use the following windbg command:

```
x test!main
```

3. Make sure that the target is running correctly under DynamoRIO. For this
purpose you can use the standalone debug mode of WinAFL client which does not
require connecting to afl-fuzz. Make sure you use the drrun.exe and winafl.dll
version which corresponds to your target (32 vs. 64 bit).

Example command line:

```
path\to\DynamoRIO\bin64\drrun.exe -c winafl.dll -debug
-target_module test_gdiplus.exe -target_offset 0x16e0 -fuzz_iterations 10
-nargs 2 -- test_gdiplus.exe input.bmp
```

You should see the output corresponding to your target function being run 10
times after which the target executable will exit. A .log file should be
created in the current directory. The log file contains useful information
such as the files and modules loaded by the target as well as the dump of AFL
coverage map. In the log you should see pre_fuzz_handler and post_fuzz_handler
being run exactly 10 times as well as your input file being open in each
iteration. Note the list of loaded modules for setting the -coverage_module
flag. Note that you must use the same values for module names as seen in the
log file (not case sensitive).

4. Now you should be ready to fuzz the target. First, make sure that both
afl-fuzz.exe and winafl.dll are in the current directory. As stated earlier,
the command line for afl-fuzz on Windows is:

```
afl-fuzz [afl options] -- [instrumentation options] -- target_cmd_line
```

Please refer above for the list of supported AFL and instrumentation options.

In AFL options, you must specify the DynamoRIO binaries directory via the new
-D option. You need to match the DynamoRIO and winafl.dll build (32 vs. 64 bit)
to the target binary. -t (timeout) option is mandatory for WinAFL as execution
time can vary significantly under instrumentation so it's not a good idea to
rely on the auto-determined values.

You can use the same WinAFL options as in step 2 but remember to exclude the
-debug flag and you'll probably want to increase the iteration count.

As in afl-fuzz on Linux you can replace the input file parameter of the target
binary with @@.

An example command line would look like:

```
afl-fuzz.exe -i in -o out -D C:\work\winafl\DynamoRIO\bin64 -t 20000 --
-coverage_module gdiplus.dll -coverage_module WindowsCodecs.dll
-fuzz_iterations 5000 -target_module test_gdiplus.exe -target_offset 0x16e0
-nargs 2 -- test_gdiplus.exe @@
```

Alternately, if symbols for test_gdiplus.exe are available, you can use
-target_method instead of -target_offset like so:

```
afl-fuzz.exe -i in -o out -D C:\work\winafl\DynamoRIO\bin64 -t 20000 --
-coverage_module gdiplus.dll -coverage_module WindowsCodecs.dll
-fuzz_iterations 5000 -target_module test_gdiplus.exe -target_method main
-nargs 2 -- test_gdiplus.exe @@
```

That's it. Happy fuzzing!


## In App Persistence mode

This feature is a tweak for the traditional "target function" approach and aims
to loosen the requirements of the target function to do both reading
an input file and processing the input file.

In some applications it's quite challenging to find a target function
that with a simple execution redirection won't break global states and will do
both reading and processing of inputs.

This mode assumes that the target application will actually loop
the target function by itself, and will handle properly its global state.
For example a udp server handling packets or a js interpreter running inside
a while loop.

This mode works as following:
1. Your target runs until hitting the target function.
2. The afl server starts instrumenting the target.
3. Your target runs until hitting the target function again.
4. The afl server stops instrumenting current cycle and starts a new one.

Usage:

Add the following option to the winafl arguments:
`-persistence_mode in_app`

`-nargs` isn't necessary in this mode.

Example usage on the supplied test.exe:

```
afl-fuzz.exe -i in -o out -D <dynamorio bin path> -t 100+ -- -coverage_module test.exe -fuzz_iterations 5000 -target_module test.exe -target_offset 0x1000 -persistence_mode in_app -- test.exe @@ loop
```


## Expert mode

The DynamoRIO client implemented in the `winafl.dll` can be packaged up with
DynamoRIO to create an end-user tool, hence using `drrun` for WinAFL is made
simpler by the `-t` option. This is possible by running `afl-fuzz.exe` in
expert mode enabled by the `-e` switch.

First, create a file in the `tools` subdirectory of the root of DynamoRIO called
`winafl.drrun32` or `winafl.drrun64`, depending on the target architecture. The
`CLIENT_REL` or `CLIENT_ABS` options enable `drrun` to locate the WinAFL client
library. This file can also modify the default DynamoRIO runtime options (see
DynamoRIO Runtime Options) via `DR_OP=` lines. As an example for a 32-bit build,
this file should contain at least the following line:

```
CLIENT_REL=tools/lib32/release/winafl.dll
```

The `-msgbox_mask` option controls whether DynamoRIO uses pop-up message boxes
when presenting information. As an example, append the following lines to this
file to disable out of memory notices in case the target process reaches the
memory limit specified with the `-m` option:

```
DR_OP=-msgbox_mask
DR_OP=0x0
```

Tool options can also be specified via `TOOL_OP=` lines. As an example, append
the following lines to this file for a complete configuration to start fuzzing
using the supplied `test_gdiplus.exe`:

```
TOOL_OP=-covtype
TOOL_OP=edge
TOOL_OP=-coverage_module
TOOL_OP=gdiplus.dll
TOOL_OP=-fuzz_iterations
TOOL_OP=1000
TOOL_OP=-target_module
TOOL_OP=test_gdiplus.exe
TOOL_OP=-target_method
TOOL_OP=main
TOOL_OP=-nargs
TOOL_OP=2
```

Now you can omit the client parameters from the command line as all the required
options are set in the tool configuration file.

Make sure that the target is running correctly using WinAFL as a DynamoRIO tool:

```
drrun.exe -t winafl -debug -- test_gdiplus.exe input.bmp
```

If everything appears to be working correctly, launch `afl-fuzz.exe` in expert
mode using the `-e` switch:

```
afl-fuzz.exe -e -i in -o out -D <dynamorio bin path> -t 100+ -- -- test_gdiplus.exe @@
```

```

`readme_pt.md`:

```md
# WinAFL Intel PT mode

## How it works

Intel PT (Processor Tracing) is a feature on modern Intel CPUs that allows tracing code executed by the CPU. If the trace collection is enabled, the CPU generates a highly compressed trace of the instructions executed. This trace can be retrieved and decoded in software later.

Windows from Windows 10 v1809 include an Intel PT driver. Although this is, at this time, undocumented and there is no official API, Alex Ionescu wrote the [WinIPT library](https://github.com/ionescu007/winipt) for interacting with it. This is what WinAFL uses for trace collection.

When a target is fuzzed with WinAFL in Intel PT mode, WinAFL opens the target in a debugger. The debugger implenents the WinAFL persistence (looping over target function without the need to restart the process for every iteration), monitors for crashes, loaded modules etc. Before every iteration, the debugger enables Intel PT tracing for the target process and, after the iteration finishes, the trace is retrived and analyzed, updating the AFL coverage map.

## Building and using

To build WinAFL with Intel PT support `-DINTELPT=1` must be added to the build options.

To use the Intel PT mode set the -P flag (without any arguments) instead of -D flag (for DynamoRIO) when calling afl-fuzz.exe. Intel PT tracing mode understands the same instrumentation flags as the [DynamoRIO mode](https://github.com/googleprojectzero/winafl/blob/master/readme_dr.md), as well as several others:

 - `-trace_size <size>` The size (in bytes) of trace information to collect for every iteration. See remarks below. The size *must* be a factor of two larger than 4096.
 
 - `-decoder <decoder>` The decoder to use to process the trace. Supported options are `tip`, `tip_ref` and `full` (default). For more info, see the separate section on decoders below.
 
 - `-nopersistent_trace` By default, due to large performance hit associated, WinAFL will not restart tracing for each iteration. If this optimization ever causes problems, it can be turned off via this flag. Mostly here for debugging reasons.

 - `-trace_cache_size <size>` The size (in bytes) of trace cache. Used only in combination with the `full` decorer.

Like the DynamoRIO mode, Intel PT mode also has the "debug" option which can be used to check if the target is running correctly under instrumentation. In general, before starting a new fuzzing session, you should use this to check if your instrumentation flags are correct for a given target. In the case of Intel PT mode, this is done via a separate binary, `winaflpt-debug.exe`. The usage is

```
winaflpt-debug.exe -debug [instrumentation options] -- [target command line]
```

if the `-debug` flag is specified, `winaflpt-debug.exe` will generate a log file (`debug.log`) which contains information about how your target was running under instrumentation (specifically, which modules are loaded, how many iterations were executed etc.)

Example:

```
winaflpt-debug.exe -debug -coverage_module test.exe -fuzz_iterations 10 -target_module test.exe -target_method main -nargs 2 -- test.exe @@
```

When you verified that there weren't any problems in this step, you should be ready to fuzz your target. You can use the same instrumentation flags, but remember to remove the `-debug` flag and you'll probably want to increase the `-fuzz_iterations` count.

Fuzzing example:

```
afl-fuzz.exe -i testin -o testout -P -t 20000 -- -coverage_module test.exe -fuzz_iterations 2000 -target_module test.exe -target_method main -nargs 2 -- test.exe @@
```

## Limitations and other remarks

 - A relatively recent Intel CPU with the Processor Tracing feature is needed for this mode and Windows 10 v1809 is needed to be able to interact with it. Running WinAFL inside a VM won't work unless the VM software explicitly supports Intel PT.

 - The CPU writes trace information into a ring buffer. If the space in the ring buffer is not sufficient to store the full trace of the iteration execution, the buffer will wrap around and only the last `trace_size` bytes (or a little less, depending on the synchronization packets) will be available for processing. You should set the `trace_size` flags to be able to contain the full trace for a sample that exhibits full target behavior. The default `trace_size` should be sufficient for most targets, however reducing it might increase performance for small targets and you might want to increase it if you get trace buffer overflow warnings.
 
 - Currently, WinAFL will only record the trace from a thread that executes the target function. In most cases this is desirable, but not always. Currently, Intel PT driver does collect information from all threads and the debugger gets information about threads being created and threads exiting. However, when the debugger gets the EXIT_THREAD_DEBUG_EVENT, it is too late and the trace information for this thread is already lost. WinAFL could read out the trace while the thread is still running, however there would be a gap between the last time the trace was read out and the time the thread exited. This would result in a non-deterministic trace with a part of it cut off and, likely, not recording trace for very short threads. Thus, to address this problem deterministically, a better way of tracking thread exits is needed.

## Decoders

The following trace decoders are available:
 
 - `full_ref` Uses [Intel's reference implementation](https://github.com/01org/processor-trace) to fully decode the trace. Note that full trace decoding introduces a significant overhead. Full trace decoding requires information about the code being executed. WinAFL accomplishes this by saving the memory from all executable modules in the process once they are loaded. However, if the instruction pointer ever ends up outside of an executable module (e.g. due to target using some kind of JIT), the decoding is going to fail and the trace will be decoded only partially. Additinally, if the target modifies executable modules on the fly, the result of the decoding is going to be unpredictable.

 - `full` (default) A custom decoder that adds a trace caching layer on top of Intel's reference decoder. Like the `full_ref` decoder it fully decodes all basic blocks in the trace (also provided that code is't generated / modified dynamically), but is significantly faster. For technical details on how this decoder works, see the separate section below.
   
 - `tip_ref` Uses Intel's reference decoder implementation and decodes only the packets that contain the raw IP address (emitted for e.g. indirect jumps and calls, sometimes returns) but don't decode other packets, e.g. containing info about indirect jumps. This option does not require having any information on the code being executed and is much faster than full decoding. This is similar to how Intel PT is used in [Honggfuzz](https://github.com/google/honggfuzz).
   
 - `tip` A faster custom implementation of the `tip_ref` decoder. It should behave the same as `tip_ref`

## The fast full decoder

Note: This section contains technical details about the `full` decoder, and is not a required reading if you are only interested in using WinAFL.

The "fast" decoder is in fact a caching layer on top of the Intel's reference decoder. It exploits the fact that, when fuzzing, most of the iterations (especially subsequent iterations) will have mostly identical coverage. At the same time, they won’t have completely identical coverage (due to e.g. not the same paths taken in allocators) or completely identical trace (due to e.g. asynchronous events occurring at different times). However, large parts of the trace are going to be the same.

The fast decoder splits the trace into parts (called tracelets) and processes each tracelet separately. When a tracelet is seen for the first time, it is processed using the reference decoder, and, on the high level, the following information is stored and cached:
 - the tracelet itself
 - decoder state before executing the tracelet
 - coverage corresponding to tracelet
 - decoder state after executing the tracelet

Next time the same tracelet is seen *and* the decoder state is the same, coverage and the decoder state are updated from cache.

Note however that traces can't be split into tracelets at random points, partly because of the reference decoder implementation details but also due to out-of-order packet feature of Intel PT: If the CPU has a TNT packet that is not full (and thus not yet sent), to save space CPU is also going to delay other packets (e.g. TIP packets) until the TNT packet gets filled. At the point when TNT packet gets filled, the TNT packet is going to get sent together with all delayed packets. To resolve this issue, tracelets are always cut *before* a TNT packet (which implies that the previous TNT packet was sent togerher with all the delayed packets). This approach seems to also play nicely with the reference decoder implementation.

Another issue that the decoder must solve is the return address compression: Intel PT expects the decoder to keep track of the call stack and, when the return instruction is encountered, if the actual return address matches the one on the decoder stack, instead of emitting the entire return address, Intel PT is only going to emit a single bit that indicates the return address should be taken from the decoder call stack. To support this feature, the "fast" decoder monitors call stack changes when the tracelet is first executed and the relevant changes are saved together with the "before" and "after" state. Specifically, each tracelet cache entry contains the data consumed from the stack during the traclet execution (these need to match the top of the decoder stack in order for the states to "match") and the values added to the stack during the tracelet execution (these are used to update the decoder state).

```

`readme_syzygy.md`:

```md
# Statically instrument a binary via [syzygy](https://github.com/google/syzygy)

## Background

[syzygy](https://github.com/google/syzygy) provides a framework able to _decompose_
PE32 binaries with full PDB. _Decomposing_ a binary is the term used to mean taking
in input a PE32 binary and its PDB, analyze and decompose every functions, every blocks
of code / data in a safe way and present it to transformation "passes".
A transformation pass is a class that transforms the binary in some way; an example is the [syzyasan](https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/asan_transform.h)
transformation for example. Once the pass has transformed the binary, it passes it back
to the framework which is able to _relink_ an output binary (with the transformations applied
of course).

[AFL instrumentation](https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/afl_transform.cc) has been added to [syzygy](https://github.com/google/syzygy)'s instrumenter allowing users to instrument PE32
binaries with private symbols statically.

<p align="center">
<img alt="afl instrumentation under IDA" src="screenshots/afl-instr.png"/>
</p>

## How to write a target function

In order to prepare your target, you need to first include `afl-staticinstr.h` then invoke `__afl_persistent_loop` like in `test_static.cpp`:

```
int fuzz(int argc, char**argv) {
  while(__afl_persistent_loop()) {
    test(argc, argv);
  }
  return 1;
}
```

`__afl_persistent_loop`'s implementation lives inside `afl-staticinstr.c` and basically reproduces what the DynamoRIO plugin is doing in `pre_fuzz_handler` and `post_fuzz_handler`. Every points mentioned in "How to select a target function" applies here too.

You can invoke AFL tools with the flag `-Y` to enable the static instrumentation mode during fuzzing, corpus minimizing or during test-case minimizing:

```
afl-fuzz.exe -Y -i minset -o o1 -t 10000 -- -fuzz_iterations 5000 -- test_static.instr.exe @@
winafl-cmin.py -Y -t 100000 -i in -o minset -- test_static.instr.exe @@
afl-tmin.exe -Y -i ..\testcases\tests\big.txt -o big.min.txt -- test_static.instr.exe @@
```

## Building instrument.exe

For convenience, a version of instrument.exe confirmed to work with WinAFL is included in the bin32 directory. If you want to build it yourself follow the instructions below.

In order to clone [syzygy](https://github.com/google/syzygy/)'s repository you can follow the instructions outlined here: [SyzygyDevelopmentGuide](https://github.com/google/syzygy/wiki/SyzygyDevelopmentGuide). Once you have `depot_tools` and the repository cloned, you can compile instrument.exe like this:

```
C:\syzygy\src>ninja -C out\Release instrument
```

The current recommended revision of the instrumenter is the following: [190dbfe](https://github.com/google/syzygy/commit/190dbfe74c6f5b5913820fa66d9176877924d7c5)(v0.8.32.0).

## Registering msdia140

Make sure to register `msdia140.dll` on your system by executing once the below command:

```
regsvr32 /s msdia140.dll
```

## Instrumenting a target

Your target binary must have been compiled with the [/PROFILE](https://msdn.microsoft.com/en-us/library/ays5x7b0.aspx) linker flag in order to generate a full PDB.

```
C:\>instrument.exe --mode=afl --input-image=test_static.exe --output-image=test_static.instr.exe --force-decompose --multithread --cookie-check-hook
[0718/224840:INFO:application_impl.h(46)] Syzygy Instrumenter Version 0.8.32.0 (0000000).
[0718/224840:INFO:application_impl.h(48)] Copyright (c) Google Inc. All rights reserved.
[0718/224840:INFO:afl_instrumenter.cc(116)] Force decomposition mode enabled.
[0718/224840:INFO:afl_instrumenter.cc(122)] Thread-safe instrumentation mode enabled.
[0718/224840:INFO:afl_instrumenter.cc(128)] Cookie check hook mode enabled.
[...]
[0718/224840:INFO:security_cookie_check_hook_transform.cc(67)] Found a __report_gsfailure implementation, hooking it now.
[0718/224840:INFO:add_implicit_tls_transform.cc(77)] The binary doesn't have any implicit TLS slot defined, injecting one.
[0718/224840:INFO:afl_transform.cc(144)] Placing TLS slot at offset +4.
[0718/224840:INFO:afl_transform.cc(237)] Code Blocks instrumented: 92 (95%)
[...]
[0718/224841:INFO:pe_relinker.cc(240)] PE relinker finished.

C:\>test_static.instr.exe test
Persistent loop implementation by <0vercl0k@tuxfamily.org>
Based on WinAFL by <ifratric@google.com>
[+] Found a statically instrumented module: test_static.instr.exe (multi thread mode).
[-] Not running under afl-fuzz.exe.
[+] Enabling the no fuzzing mode.
Error opening file
```

### Available options

```
--config=<path>         Specifies a JSON file describing, either
                        a whitelist of functions to instrument or
                        a blacklist of functions to not instrument.
--cookie-check-hook     Hooks __security_cookie_check.
--force-decompose       Forces block decomposition.
--multithread           Uses a thread-safe instrumentation.
```

* config: The JSON file allows you to scope down the instrumentation to a set of function
names. You can either [white list](https://github.com/google/syzygy/blob/master/syzygy/instrument/test_data/afl-good-whitelist.json), or [black list](https://github.com/google/syzygy/blob/master/syzygy/instrument/test_data/afl-good-blacklist.json) functions. It can be very useful to blacklist
functions generating variable behaviors.

* cookie-check-hook: This ensures that the /GS cookie check function generates an exception that
our [VEH](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681420(v=vs.85).aspx) can catch. Failfast exceptions are not catchable by any EH mechanisms in-proc, so we leverage
[syzygy](https://github.com/google/syzygy) to rewrite the cookie check function in order to generate
[an exception we can catch](https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/security_cookie_check_hook_transform.cc#L81).

* force-decompose: This switch lets you override the decision that [syzygy](https://github.com/google/syzygy/blob/master/syzygy/pe/pe_transform_policy.cc#L175) makes when evaluating
if a function is safe to decompose. If you turn on this flag, your instrumentation coverage will be
higher but you might end-up in an executable that *crashes* in weird ways. Only use if you know what you
are doing.

* multithread: This switch turns on the thread-safe instrumentation. The major difference with the single
thread instrumentation is that `__afl_prev_loc` will be stored in a TLS slot.

## Limitations

With great power comes great responsibility, so here is the list of limitations:

1. Instrumentation is limited to PE 32bits binaries with full PDB symbols (linker flag `/PROFILE`).

2. [syzygy](https://github.com/google/syzygy/) defines [several pre-requirements](https://github.com/google/syzygy/blob/master/syzygy/pe/pe_transform_policy.cc#L175) for being able to decompose safely a block; this might explain why your instrumentation percentage is low.


```

`readme_tinyinst.md`:

```md
# TinyInst instrumentation

TinyInst is a lightweight dynamic instrumentation library that can be used to instrument only selected module(s) in the process, while leaving the rest of the process to run natively. WinAFL includes a custom TinyInst client that can collect both basic block and edge coverage into an AFL coverage map.

## Building and using

To build WinAFL with TinyInst support, `-DTINYINST=1` must be added to the build options. For the full building instructions, see the main readme.

Similar to other modes, the usage is

```
afl-fuzz -y [afl options] -- [instrumentation options] -- target_cmd_line
```

where the `-y` flag is used to select TinyInst mode.

The full list of instrumentation options can be found in the [TinyInst readme](https://github.com/googleprojectzero/TinyInst). Note that, while these options are mostly similar to instrumentation options in DynamoRIO mode:
  - Some flags have differen names, e.g. `-instrument_module` (TinyInst) vs. `-coverage_module` (DynamoRIO).
  - Some additional flags are needed to take advantage of persistence mode, specifically `-persist` and `-loop` flags.

Instead of listing all of the options from TinyInst readme, let's examine a basic usage example

```
afl-fuzz.exe -y -i in -o out -t 20000 -- -instrument_module gdiplus.dll -instrument_module WindowsCodecs.dll -target_module test_gdiplus.exe -target_method main -nargs 2 -iterations 5000 -persist -loop -- C:\work\winafl\build64\bin\RelWithDebInfo\test_gdiplus.exe @@
```

which fuzzes the `test_gdiplus` harness included with WinAFL. As stated previously, `-y` is used to select the TinyInst mode. `-i in -o out -t 20000` are standard afl flags used to set input and output directories as well as the timeout, respectively.

`-instrument_module` specifies which module to instrument. This is similar to `-coverage_module` flag in DynamoRIO mode. There can be multiple `-instrument_module` flags for different modules. In our example, we'll be instrumenting (collecting coverage from) two modules, `gdiplus.dll` and `WindowsCodecs.dll`

`-target_module` and `-target_method` specify which function to run in WinAFL's persistent mode. `-target_module` identifies the module where the function is located (`test_gdiplus.exe` in the example), while `-target_method` specifies the name of the function (main in this case). In case where the symbols (function names) aren't available for the target module, `-target_offset` can be used instead, which specifies the offset in memory from start of the module to the target function (for example `-target_offset 0x16a0`).

`nargs` specifies how many arguments the target function takes in order to be able to restore the arguments for every run.

`-persist` instructs TinyInst to use the persistent mode and keep the target process alive when the target function returns.

`-loop` instructs TinyInst to jump to the start of target function after it returns. `-persist` and `-loop` together enable the "classic" WinAFL persistent mode. However there might be cases where one of these flags is desirable without the other, for example in case where the target process calls the target function repeatedly on its own, `-persist` flag can be used without `-loop`

`-iterations` specifies how many times to run the target function in persistent mode without restarting the target process.

To debug issues, it might be useful to run the target under TinyInst but without the fuzzer. This can be done using `litecov.exe` tool that comes with TinyInst. For example, running `litecov.exe` with the same instrumentation optios as above (except the number of iteration reduced)

```
litecov.exe -instrument_module gdiplus.dll -instrument_module WindowsCodecs.dll -target_module test_gdiplus.exe -target_method main -nargs 2 -iterations 10 -persist -loop -- C:\work\winafl\build64\bin\RelWithDebInfo\test_gdiplus.exe in\in.txt
```

might produce the following output

```
Instrumented module gdiplus.dll, code size: 1409024
Target function returned normally
Found 1094 new offsets in gdiplus.dll
Target function returned normally
Found 1 new offsets in gdiplus.dll
Target function returned normally
Target function returned normally
Target function returned normally
Target function returned normally
Target function returned normally
Target function returned normally
Target function returned normally
Target function returned normally
```

This lets us know that
 - There was code executing in the gdiplus.dll module and TinyInst collected some coverage from it.
 - The target function ran 10 times (as expected) and returned normally every time (i.e. no crashes or hangs)

So it gives us a good indication that the instrumentation options are set correctly and the target is running correctly under TinyInst.

There are additional flags that can be useful for debugging such as `-trace_debug_events` which, among other things, lists modules loaded by the target process. Note that `-trace_debug_events` might report exceptions in the target process, but these don't necessarily mean crashes or errors (as long as you don't see a message about the process crashing) as TinyInst uses exceptions under the hood.


```

`test.cpp`:

```cpp
/*
   WinAFL - A simple test binary that crashes on certain inputs:
     - 'test1' with a normal write access violation at NULL
     - 'test2' with a /GS stack cookie violation
   -------------------------------------------------------------

   Written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <windows.h>
#include <string.h>


int __declspec(noinline) test_target(char* input_file_path, char* argv_0)
{
	char *crash = NULL;
	FILE *fp = fopen(input_file_path, "rb");
	char c;
	if (!fp) {
		printf("Error opening file\n");
		return 0;
	}
	if (fread(&c, 1, 1, fp) != 1) {
		printf("Error reading file\n");
		fclose(fp);
		return 0;
	}
	if (c != 't') {
		printf("Error 1\n");
		fclose(fp);
		return 0;
	}
	if (fread(&c, 1, 1, fp) != 1) {
		printf("Error reading file\n");
		fclose(fp);
		return 0;
	}
	if (c != 'e') {
		printf("Error 2\n");
		fclose(fp);
		return 0;
	}
	if (fread(&c, 1, 1, fp) != 1) {
		printf("Error reading file\n");
		fclose(fp);
		return 0;
	}
	if (c != 's') {
		printf("Error 3\n");
		fclose(fp);
		return 0;
	}
	if (fread(&c, 1, 1, fp) != 1) {
		printf("Error reading file\n");
		fclose(fp);
		return 0;
	}
	if (c != 't') {
		printf("Error 4\n");
		fclose(fp);
		return 0;
	}
	printf("!!!!!!!!!!OK!!!!!!!!!!\n");

	if (fread(&c, 1, 1, fp) != 1) {
		printf("Error reading file\n");
		fclose(fp);
		return 0;
	}
	if (c == '1') {
		// cause a crash
		crash[0] = 1;
	}
	else if (c == '2') {
		char buffer[5] = { 0 };
		// stack-based overflow to trigger the GS cookie corruption
		for (int i = 0; i < 5; ++i)
			strcat(buffer, argv_0);
		printf("buffer: %s\n", buffer);
	}
	else {
		printf("Error 5\n");
	}
	fclose(fp);
	return 0;
}

int main(int argc, char** argv)
{
    if(argc < 2) {
        printf("Usage: %s <input file>\n", argv[0]);
        return 0;
    }

	if (argc == 3 && !strcmp(argv[2], "loop"))
	{
		//loop inside application and call target infinitey
		while (true)
		{
			test_target(argv[1], argv[0]);
		}
	}
	else
	{
		//regular single target call
		return test_target(argv[1], argv[0]);
	}
}

```

`test_netmode.cpp`:

```cpp
/*
   WinAFL - A simple binary to test winAFL ability perform fuzzing over network:
   -------------------------------------------------------------

   Written and maintained by Maksim Shudrak <mxmssh@gmail.com>

   Copyright 2018 Salesforce Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

/* cmd line to find the crash:
 * set AFL_CUSTOM_DLL_ARGS=-U -p 7714 -a 127.0.0.1 -w 1000
 * C:\Users\max\Desktop\winafl\winafl_fork\build\Debug>afl-fuzz.exe -l custom_net_fuzzer.dll 
 * -i in -o out -D ..\..\dr_release\bin32 -t 20000 -- -target_module test_netmode.exe -target_method 
 * recv_func -coverage_module test_netmode.exe -fuzz_iterations 5000 -nargs 1 -- test_netmode.exe
 */

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>

#pragma comment(lib,"ws2_32.lib") //Winsock Library

#define DEFAULT_PORT 7714
#define BUFSIZE 4096

/* TODO: test for TCP */

void error(const char *msg) {
	printf("[ERROR] %s %d\n", msg, WSAGetLastError());
    exit(-1);
}

struct sockaddr_in serveraddr;	  /* server's addr */

void recv_func(int sockfd)
{	
    char *buf;
	struct sockaddr_in clientaddr;	  /* client addr */
	int clientlen = sizeof(clientaddr);
    int n = 0;

    buf = (char *)malloc(BUFSIZE);

    /* receiving over UDP */
    n = recvfrom(sockfd, buf, BUFSIZE, 0, (struct sockaddr *)&clientaddr, &clientlen);
    if (n < 0)
        error("ERROR in recvfrom");

    if (buf[0] == 'P') {
		if (buf[1] == 'W') {
			if (buf[2] == 'N') {
				if (buf[3] == 'I') {
					if (buf[4] == 'T') {
						printf("Found it!\n");
						((VOID(*)())0x0)();
					}
				}
			}
		}
	}

    printf("Received %d bytes, content = %s\n", n, buf);
    free(buf);
}

int main(int argc, char** argv)
{
	int sockfd;
	int portno = DEFAULT_PORT;
	int optval;
	static WSADATA wsaData;
	static int iResult;

	// Initialize Winsock
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);

	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0)
		error("ERROR opening socket");

	optval = 1;
    /* UDP */
	setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char *)&optval, sizeof(int));

	memset((char *)&serveraddr, 0, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons((unsigned short)portno);

	if (bind(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0)
		error("ERROR on binding");
	while (1) {
		recv_func(sockfd);
	}
    return 0;
}

```

`test_simple_winsock_client.cpp`:

```cpp
/*
A client to test winAFL ability act as a TCP/IP fuzzing server:
-------------------------------------------------------------

Written and maintained by Maksim Shudrak <mxmssh@gmail.com>

Copyright 2018 Salesforce Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/* cmd line to launch the fuzzer:
 * set AFL_CUSTOM_DLL_ARGS=1337
 * afl-fuzz.exe -l custom_winafl_server.dll -i in -o out -D ..\..\dr_release\bin32 
 * -t 20000 -- -target_module test_servermode.exe -target_method main -coverage_module
 * test_servermode.exe -fuzz_iterations 5000 -nargs 2 -- test_servermode.exe 127.0.0.1
 */

/* TODO: improve performance of this client under fuzzer */

#pragma once

#define WIN32_LEAN_AND_MEAN

#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>

// Need to link with Ws2_32.lib, Mswsock.lib, and Advapi32.lib
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")

#define DEFAULT_BUFLEN 512
#define DEFAULT_PORT "1337"

void parse_buffer(char *buf) {
	if (buf[0] == 'P') {
		if (buf[1] == 'W') {
			if (buf[2] == 'N') {
				if (buf[3] == 'I') {
					if (buf[4] == 'T') {
						printf("Found it!\n");
						((VOID(*)())0x0)();
					}
				}
			}
		}
	}
}

void recv_loop(SOCKET ConnectSocket) {
	char recvbuf[DEFAULT_BUFLEN];
	int iResult;
	int recvbuflen = DEFAULT_BUFLEN;
	// Receive until the peer closes the connection
	do {

		iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);
		if (iResult > 0)
			printf("Bytes received: %d\n", iResult);
		else if (iResult == 0)
			printf("Connection closed\n");
		else
			printf("recv failed with error: %d\n", WSAGetLastError());

	} while (iResult > 0);
	parse_buffer(recvbuf);

}

typedef struct _test_case_struct {
	long size;
	char *data;
} test_case_struct;

int __cdecl main(int argc, char **argv)
{
	WSADATA wsaData;
	SOCKET ConnectSocket = INVALID_SOCKET;
	struct addrinfo *result = NULL,
		*ptr = NULL,
		hints;
	char *sendbuf = "this is a test";
	int iResult;

	// Validate the parameters
	if (argc != 2) {
		printf("usage: %s server-name\n", argv[0]);
		return 1;
	}

	// Initialize Winsock
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0) {
		printf("WSAStartup failed with error: %d\n", iResult);
		return 1;
	}
	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	// Resolve the server address and port
	iResult = getaddrinfo(argv[1], DEFAULT_PORT, &hints, &result);
	if (iResult != 0) {
		printf("getaddrinfo failed with error: %d\n", iResult);
		WSACleanup();
		return 1;
	}
	// Attempt to connect to an address until one succeeds
	for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {

		// Create a SOCKET for connecting to server
		ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,
			ptr->ai_protocol);
		if (ConnectSocket == INVALID_SOCKET) {
			printf("socket failed with error: %ld\n", WSAGetLastError());
			WSACleanup();
			return 1;
		}

		// Connect to server.
		iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
		if (iResult == SOCKET_ERROR) {
			closesocket(ConnectSocket);
			ConnectSocket = INVALID_SOCKET;
			continue;
		}
		break;
	}

	freeaddrinfo(result);

	if (ConnectSocket == INVALID_SOCKET) {
		printf("Unable to connect to server!\n");
		WSACleanup();
		return 1;
	}

	// Send an initial buffer
	iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);
	if (iResult == SOCKET_ERROR) {
		printf("send failed with error: %d\n", WSAGetLastError());
		closesocket(ConnectSocket);
		WSACleanup();
		return 1;
	}

	printf("Bytes Sent: %ld\n", iResult);

	// shutdown the connection since no more data will be sent
	iResult = shutdown(ConnectSocket, SD_SEND);
	if (iResult == SOCKET_ERROR) {
		printf("shutdown failed with error: %d\n", WSAGetLastError());
		closesocket(ConnectSocket);
		WSACleanup();
		return 1;
	}

	recv_loop(ConnectSocket);

	// cleanup
	closesocket(ConnectSocket);
	WSACleanup();

	return 0;
}


```

`test_static.cpp`:

```cpp
/*
   WinAFL - A simple test binary that exercises various behaviors
   depending on inputs:
     - 'test1' crashes with a normal write access violation at NULL
     - 'test2' crashes with a /GS stack cookie violation
     - 'test3' triggers a hang
     - 'test4' triggers an exception that is caught and handled
     - 'test5' triggers an OutputDebugString
     - 'test6' triggers an allocation of 120MB (and a crash if the
               allocation fails)
   -------------------------------------------------------------

   Written by Axel "0vercl0k" Souchet <0vercl0k@tuxfamily.org>

   Copyright 2017 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include "afl-staticinstr.h"

int test(int argc, char **argv) {
    char *crash = NULL;
    FILE *fp = fopen(argv[1], "rb");
    char c;
    if (!fp) {
        printf("Error opening file\n");
        goto end;
    }
    if (fread(&c, 1, 1, fp) != 1) {
        printf("Error reading file\n");
        goto clean;
    }
    if (c != 't') {
        printf("Error 1\n");
        goto clean;
    }
    if (fread(&c, 1, 1, fp) != 1) {
        printf("Error reading file\n");
        goto clean;
    }
    if (c != 'e') {
        printf("Error 2\n");
        goto clean;
    }
    if (fread(&c, 1, 1, fp) != 1) {
        printf("Error reading file\n");
        goto clean;
    }
    if (c != 's') {
        printf("Error 3\n");
        goto clean;
    }
    if (fread(&c, 1, 1, fp) != 1) {
        printf("Error reading file\n");
        goto clean;
    }
    if (c != 't') {
        printf("Error 4\n");
        goto clean;
    }
    printf("!!!!!!!!!!OK!!!!!!!!!!\n");

    if (fread(&c, 1, 1, fp) != 1) {
        printf("Error reading file\n");
        goto clean;
    }
    if (c == '1') {
        crash[0] = 1;
    }
    else if (c == '2') {
        char buffer[5] = { 0 };
        strcat(buffer, argv[0]);
    }
    else if (c == '3') {
        printf("triggering a hang\n");
        Sleep(50 * 1000);
    }
    else if (c == '4') {
        try {
            throw int(1337);
        }
        catch (...) {
            printf("Caught its ok!\n");
        }
    }
    else if (c == '5') {
        OutputDebugString(TEXT("hello!"));
    }
    else if (c == '6') {
        printf("allocating 120MB\n");
        char *buffer = (char*)malloc((1024 * 1024) * 120);
        *buffer = 0;
        free(buffer);
    }
    else {
        printf("Error 5\n");
    }

    clean:
    fclose(fp);

    end:
    return EXIT_SUCCESS;
}

#pragma optimize("", off)
int fuzz(int argc, char**argv) {
    while(__afl_persistent_loop()) {
        test(argc, argv);
    }
    return 1;
}
#pragma optimize("", on)

int main(int argc, char** argv)
{
    if(argc < 2) {
        printf("Usage: %s <input file>\n", argv[0]);
        return 0;
    }

    return fuzz(argc, argv);
}

```

`testcases/README.testcases`:

```testcases
===============================
AFL test cases and dictionaries
===============================

  (See ../docs/README for the general instruction manual.)

1) Starting test cases
----------------------

The archives/, images/, multimedia/, and others/ subdirectories contain small,
standalone files that can be used to seed afl-fuzz when testing parsers for a
variety of common data formats.

There is probably not much to be said about these files, except that they were
optimized for size and stripped of any non-essential fluff. Some directories
contain several examples that exercise various features of the underlying format.
For example, there is a PNG file with and without a color profile.

Additional test cases are always welcome; the current "most wanted" list
includes:

  - JBIG,
  - Ogg Vorbis,
  - Ogg Theora,
  - MP3,
  - AAC,
  - WebM,
  - Small JPEG with a color profile,
  - Small fonts.

2) Dictionaries
---------------

The _extras/ subdirectory contains a set of dictionaries that can be used in
conjunction with the -x option to allow the fuzzer to effortlessly explore the
grammar of some of the more verbose data formats or languages. The basic
principle behind the operation of fuzzer dictionaries is outlined in section 9
of the "main" README for the project.

Custom dictionaries can be added at will. They should consist of a
reasonably-sized set of rudimentary syntax units that the fuzzer will then try
to clobber together in various ways. Snippets between 2 and 16 bytes are usually
the sweet spot.

Custom dictionaries can be created in two ways:

  - By creating a new directory and placing each token in a separate file, in
    which case, there is no need to escape or otherwise format the data.

  - By creating a flat text file where tokens are listed one per line in the
    format of name="value". The alphanumeric name is ignored and can be omitted,
    although it is a convenient way to document the meaning of a particular
    token. The value must appear in quotes, with hex escaping (\xNN) applied to
    all non-printable, high-bit, or otherwise problematic characters (\\ and \"
    shorthands are recognized, too).

The fuzzer auto-selects the appropriate mode depending on whether the -x
parameter is a file or a directory.

In the file mode, every name field can be optionally followed by @<num>, e.g.:

  keyword_foo@1 = "foo"

Such entries will be loaded only if the requested dictionary level is equal or
higher than this number. The default level is zero; a higher value can be set
by appending @<num> to the dictionary file name, like so:

  -x path/to/dictionary.dct@2

Good examples of dictionaries can be found in _extras/xml.dict and
_extras/png.dict.

```

`testcases/_extras/gif.dict`:

```dict
#
# AFL dictionary for GIF images
# -----------------------------
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

header_87a="87a"
header_89a="89a"
header_gif="GIF"

marker_2c=","
marker_3b=";"

section_2101="!\x01\x12"
section_21f9="!\xf9\x04"
section_21fe="!\xfe"
section_21ff="!\xff\x11"

```

`testcases/_extras/html_tags.dict`:

```dict
#
# AFL dictionary for HTML parsers (tags only)
# -------------------------------------------
#
# A basic collection of HTML tags likely to matter to HTML parsers. Does *not*
# include any attributes or attribute values.
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

tag_a="<a>"
tag_abbr="<abbr>"
tag_acronym="<acronym>"
tag_address="<address>"
tag_annotation_xml="<annotation-xml>"
tag_applet="<applet>"
tag_area="<area>"
tag_article="<article>"
tag_aside="<aside>"
tag_audio="<audio>"
tag_b="<b>"
tag_base="<base>"
tag_basefont="<basefont>"
tag_bdi="<bdi>"
tag_bdo="<bdo>"
tag_bgsound="<bgsound>"
tag_big="<big>"
tag_blink="<blink>"
tag_blockquote="<blockquote>"
tag_body="<body>"
tag_br="<br>"
tag_button="<button>"
tag_canvas="<canvas>"
tag_caption="<caption>"
tag_center="<center>"
tag_cite="<cite>"
tag_code="<code>"
tag_col="<col>"
tag_colgroup="<colgroup>"
tag_data="<data>"
tag_datalist="<datalist>"
tag_dd="<dd>"
tag_del="<del>"
tag_desc="<desc>"
tag_details="<details>"
tag_dfn="<dfn>"
tag_dir="<dir>"
tag_div="<div>"
tag_dl="<dl>"
tag_dt="<dt>"
tag_em="<em>"
tag_embed="<embed>"
tag_fieldset="<fieldset>"
tag_figcaption="<figcaption>"
tag_figure="<figure>"
tag_font="<font>"
tag_footer="<footer>"
tag_foreignobject="<foreignobject>"
tag_form="<form>"
tag_frame="<frame>"
tag_frameset="<frameset>"
tag_h1="<h1>"
tag_h2="<h2>"
tag_h3="<h3>"
tag_h4="<h4>"
tag_h5="<h5>"
tag_h6="<h6>"
tag_head="<head>"
tag_header="<header>"
tag_hgroup="<hgroup>"
tag_hr="<hr>"
tag_html="<html>"
tag_i="<i>"
tag_iframe="<iframe>"
tag_image="<image>"
tag_img="<img>"
tag_input="<input>"
tag_ins="<ins>"
tag_isindex="<isindex>"
tag_kbd="<kbd>"
tag_keygen="<keygen>"
tag_label="<label>"
tag_legend="<legend>"
tag_li="<li>"
tag_link="<link>"
tag_listing="<listing>"
tag_main="<main>"
tag_malignmark="<malignmark>"
tag_map="<map>"
tag_mark="<mark>"
tag_marquee="<marquee>"
tag_math="<math>"
tag_menu="<menu>"
tag_menuitem="<menuitem>"
tag_meta="<meta>"
tag_meter="<meter>"
tag_mglyph="<mglyph>"
tag_mi="<mi>"
tag_mn="<mn>"
tag_mo="<mo>"
tag_ms="<ms>"
tag_mtext="<mtext>"
tag_multicol="<multicol>"
tag_nav="<nav>"
tag_nextid="<nextid>"
tag_nobr="<nobr>"
tag_noembed="<noembed>"
tag_noframes="<noframes>"
tag_noscript="<noscript>"
tag_object="<object>"
tag_ol="<ol>"
tag_optgroup="<optgroup>"
tag_option="<option>"
tag_output="<output>"
tag_p="<p>"
tag_param="<param>"
tag_plaintext="<plaintext>"
tag_pre="<pre>"
tag_progress="<progress>"
tag_q="<q>"
tag_rb="<rb>"
tag_rp="<rp>"
tag_rt="<rt>"
tag_rtc="<rtc>"
tag_ruby="<ruby>"
tag_s="<s>"
tag_samp="<samp>"
tag_script="<script>"
tag_section="<section>"
tag_select="<select>"
tag_small="<small>"
tag_source="<source>"
tag_spacer="<spacer>"
tag_span="<span>"
tag_strike="<strike>"
tag_strong="<strong>"
tag_style="<style>"
tag_sub="<sub>"
tag_summary="<summary>"
tag_sup="<sup>"
tag_svg="<svg>"
tag_table="<table>"
tag_tbody="<tbody>"
tag_td="<td>"
tag_template="<template>"
tag_textarea="<textarea>"
tag_tfoot="<tfoot>"
tag_th="<th>"
tag_thead="<thead>"
tag_time="<time>"
tag_title="<title>"
tag_tr="<tr>"
tag_track="<track>"
tag_tt="<tt>"
tag_u="<u>"
tag_ul="<ul>"
tag_var="<var>"
tag_video="<video>"
tag_wbr="<wbr>"
tag_xmp="<xmp>"

```

`testcases/_extras/jpeg.dict`:

```dict
#
# AFL dictionary for JPEG images
# ------------------------------
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

header_jfif="JFIF\x00"
header_jfxx="JFXX\x00"

section_ffc0="\xff\xc0"
section_ffc2="\xff\xc2"
section_ffc4="\xff\xc4"
section_ffd0="\xff\xd0"
section_ffd8="\xff\xd8"
section_ffd9="\xff\xd9"
section_ffda="\xff\xda"
section_ffdb="\xff\xdb"
section_ffdd="\xff\xdd"
section_ffe0="\xff\xe0"
section_ffe1="\xff\xe1"
section_fffe="\xff\xfe"

```

`testcases/_extras/js.dict`:

```dict
#
# AFL dictionary for JavaScript
# -----------------------------
#
# Contains basic reserved keywords and syntax building blocks.
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

keyword_arguments="arguments"
keyword_break="break"
keyword_case="case"
keyword_catch="catch"
keyword_const="const"
keyword_continue="continue"
keyword_debugger="debugger"
keyword_decodeURI="decodeURI"
keyword_default="default"
keyword_delete="delete"
keyword_do="do"
keyword_else="else"
keyword_escape="escape"
keyword_eval="eval"
keyword_export="export"
keyword_finally="finally"
keyword_for="for (a=0;a<2;a++)"
keyword_function="function"
keyword_if="if"
keyword_in="in"
keyword_instanceof="instanceof"
keyword_isNaN="isNaN"
keyword_let="let"
keyword_new="new"
keyword_parseInt="parseInt"
keyword_return="return"
keyword_switch="switch"
keyword_this="this"
keyword_throw="throw"
keyword_try="try"
keyword_typeof="typeof"
keyword_var="var"
keyword_void="void"
keyword_while="while"
keyword_with="with"

misc_1=" 1"
misc_a="a"
misc_array=" [1]"
misc_assign=" a=1"
misc_code_block=" {1}"
misc_colon_num=" 1:"
misc_colon_string=" 'a':"
misc_comma=" ,"
misc_comment_block=" /* */"
misc_comment_line=" //"
misc_cond=" 1?2:3"
misc_dec=" --"
misc_div=" /"
misc_equals=" ="
misc_fn=" a()"
misc_identical=" ==="
misc_inc=" ++"
misc_minus=" -"
misc_modulo=" %"
misc_parentheses=" ()"
misc_parentheses_1=" (1)"
misc_parentheses_1x4=" (1,1,1,1)"
misc_parentheses_a=" (a)"
misc_period="."
misc_plus=" +"
misc_plus_assign=" +="
misc_regex=" /a/g"
misc_rol=" <<<"
misc_semicolon=" ;"
misc_serialized_object=" {'a': 1}"
misc_string=" 'a'"
misc_unicode=" '\\u0001'"

object_Array=" Array"
object_Boolean=" Boolean"
object_Date=" Date"
object_Function=" Function"
object_Infinity=" Infinity"
object_Int8Array=" Int8Array"
object_Math=" Math"
object_NaN=" NaN"
object_Number=" Number"
object_Object=" Object"
object_RegExp=" RegExp"
object_String=" String"
object_Symbol=" Symbol"
object_false=" false"
object_null=" null"
object_true=" true"

prop_charAt=".charAt"
prop_concat=".concat"
prop_constructor=".constructor"
prop_destructor=".destructor"
prop_length=".length"
prop_match=".match"
prop_proto=".__proto__"
prop_prototype=".prototype"
prop_slice=".slice"
prop_toCode=".toCode"
prop_toString=".toString"
prop_valueOf=".valueOf"

```

`testcases/_extras/pdf.dict`:

```dict
#
# AFL dictionary for PDF
# ----------------------
#
# This is a pretty big PDF dictionary constructed by Ben by manually reviewing
# the spec and combining that with the data pulled out of a corpus of sample
# PDFs.
#
# Contributed by Ben Nagy <ben@iagu.net>
#

"#"
"%"
"%%"
"%%EOF"
"%FDF-1.7"
"%PDF-1.7"
"("
"(/xdp:xdp)"
"(\\001)"
"(config)"
"(datasets)"
"(template)"
"(xdp:xdp)"
")"
"-1"
"-1.0"
".."
"/"
"/#23clipboard"
"/.notdef"
"/1"
"/1.0"
"/1.3"
"/3D"
"/3DA"
"/3DAnimationStyle"
"/3DB"
"/3DD"
"/3DI"
"/3DLightingScheme"
"/3DRenderMode"
"/3DV"
"/3DView"
"/90pv-RKSJ-H"
"/A"
"/A0"
"/A85"
"/AA"
"/AAIC"
"/AAPL"
"/ABCDEF+ACaslonPro-Regular"
"/ABCDEF+AJensonPro-LtIt"
"/ABCDEF+AdobeCorpID-MinionRg"
"/ABCDEF+Arial,Bold"
"/ABCDEF+BankGothicMdBT"
"/ABCDEF+Bauhaus-Heavy"
"/ABCDEF+BluesClues"
"/ABCDEF+BodegaSans"
"/ABCDEF+BodoniMTCondensed"
"/ABCDEF+BookAntiqua"
"/ABCDEF+CMBX10"
"/ABCDEF+CaflischScriptPro-Regular"
"/ABCDEF+CityBlueprint"
"/ABCDEF+CourierNewPSMT"
"/ABCDEF+FixedsysExcelsior2.00"
"/ABCDEF+MSTT31854bd45bo188067S00"
"/ABCDEF+MinionPro-BoldCnIt"
"/ABCDEF+MyriadMM-It_400_300_"
"/ABCDEF+Wingdings"
"/ABCDEF+ZapfDingbats"
"/AC"
"/ADBE"
"/ADB_DEVICE_DEFAULT_STYLE"
"/ADB_DefaultStyle"
"/ADB_NO_TRAP_STYLE"
"/AE"
"/AESV2"
"/AGaramond"
"/AH"
"/AI8DstIndex"
"/AI8SrcIndex"
"/AIMetaData"
"/AIPDFPrivateData1"
"/AIS"
"/AL"
"/AN"
"/AP"
"/AS"
"/ASCII85Decode"
"/ASCIIHexDecode"
"/ASomewhatLongerName"
"/AU"
"/Aacute"
"/Acc.#20Prod.#202501#20#2F2#20#20"
"/Accounts#20payable"
"/AccurateScreens"
"/Acircumflex"
"/AcroForm"
"/Action"
"/Actual"
"/Add"
"/Adieresis"
"/Adobe"
"/Adobe#20PDF#20Library"
"/Adobe.PPKLite"
"/AdobeCorpID-Acrobat"
"/AdobeCorpID-MinionRg"
"/AdobePhotoshop"
"/Agrave"
"/All"
"/AllKO"
"/AllOn"
"/Alt"
"/Alternate"
"/AlternatePresentations"
"/Alternates"
"/Amex"
"/And"
"/Angle"
"/Annot"
"/Annots"
"/AntiAlias"
"/AnyOn"
"/Apag_PDFX_Checkup"
"/App"
"/Architecture-Normal"
"/Arial"
"/Aring"
"/Art"
"/ArtBox"
"/Article"
"/Artifact"
"/Artwork"
"/Ascent"
"/Aspect"
"/Assistant"
"/Atilde"
"/AuthEvent"
"/Author"
"/Avenir-Heavy"
"/Avenir-MediumOblique"
"/AvgWidth"
"/BBox"
"/BC"
"/BCL"
"/BDC"
"/BDL"
"/BE"
"/BFSOL"
"/BG"
"/BG2"
"/BM"
"/BMC"
"/BS"
"/BW"
"/Bank"
"/BaseEncoding"
"/BaseFont"
"/BaseState"
"/BaseVersion"
"/Birch"
"/BitsPerComponent"
"/BitsPerCoordinate"
"/BitsPerFlag"
"/BitsPerSample"
"/Bl"
"/BlCDel"
"/BlMiNu"
"/Black"
"/BlackIs1"
"/BlackOP"
"/BlackPoint"
"/BleedBox"
"/Blend"
"/Block"
"/Blue"
"/BluesClues"
"/Bookshelf"
"/Border"
"/Bounds"
"/BoxColorInfo"
"/Btn"
"/BulmerMT-BoldDisplay"
"/ByteRange"
"/C"
"/C0"
"/C0_0"
"/C1"
"/C2W"
"/C3"
"/CALS_AIS"
"/CALS_BM"
"/CALS_HT"
"/CALS_SMASK"
"/CALS_ca"
"/CAM"
"/CB"
"/CC"
"/CCH"
"/CCITTFaxDecode"
"/CD"
"/CDL"
"/CEN"
"/CF"
"/CFM"
"/CI"
"/CIDFontType0"
"/CIDFontType0C"
"/CIDFontType2"
"/CIDInit"
"/CIDSet"
"/CIDSystemInfo"
"/CIDToGIDMap"
"/CMV_LabBar"
"/CMV_LabControl"
"/CMYK"
"/CMYK#20#2880,#208,#2034,#200#29"
"/CMap"
"/CMapName"
"/CMapType"
"/CMapVersion"
"/CO"
"/CP"
"/CS"
"/CS0"
"/CT"
"/CV"
"/CalGray"
"/CalRGB"
"/CapHeight"
"/Caption"
"/Caslon540BT-Roman"
"/CaslonBT-Bold"
"/CaslonBT-BoldItalic"
"/Catalog"
"/Category"
"/Ccedilla"
"/CenturySchoolbookBT-Roman"
"/Ch"
"/Chair"
"/Chap"
"/Chaparral-Display"
"/CharProcs"
"/CharSet"
"/CheckSum"
"/Circle"
"/ClarendonBT-Black"
"/ClassMap"
"/Clearface-Black"
"/Clip"
"/ClippedText"
"/Cn"
"/Collection"
"/CollectionItem"
"/CollectionSchema"
"/CollectionSubitem"
"/Color"
"/ColorBurn"
"/ColorDodge"
"/ColorMatch"
"/ColorSpace"
"/ColorTransform"
"/ColorType"
"/Colorants"
"/Colors"
"/Columns"
"/ComicSansMS,Bold"
"/Comment"
"/Comments"
"/Company"
"/Compatibility"
"/Compatible"
"/Components"
"/CompressArt"
"/Condensed"
"/Configs"
"/Consultant"
"/ContainerVersion"
"/Contents"
"/Coords"
"/Copy"
"/Copy#20center"
"/Cor"
"/Corner#20surface"
"/CosineDot"
"/Count"
"/Cour"
"/Courier"
"/Create"
"/CreationDate"
"/Creator"
"/CreatorInfo"
"/CreatorVersion"
"/CropBox"
"/CropFixed"
"/CropRect"
"/Crypt"
"/CryptFilter"
"/CryptFilterDecodeParms"
"/Cs12"
"/Cs3"
"/Cyan"
"/D"
"/DA"
"/DCTDecode"
"/DIC#202525p*"
"/DIS"
"/DL"
"/DOS"
"/DP"
"/DR"
"/DS"
"/DSz"
"/DV"
"/DW"
"/DamagedRowsBeforeError"
"/Darken"
"/Data"
"/Date"
"/Decode"
"/DecodeParms"
"/DefEmbeddedFile"
"/Default"
"/DefaultCryptFilter"
"/DefaultForPrinting"
"/DefaultRGB"
"/Delete"
"/Delta"
"/DescendantFonts"
"/Descent"
"/Description"
"/Design"
"/Dest"
"/DestOutputProfile"
"/DestOutputProfileRef"
"/Dests"
"/DeviceCMYK"
"/DeviceGray"
"/DeviceN"
"/DeviceRGB"
"/Difference"
"/Differences"
"/DigestLocation"
"/DigestMethod"
"/DigestValue"
"/Dimmed"
"/Direction"
"/DisplayDocTitle"
"/Dissolve"
"/Div"
"/Dm"
"/DocMDP"
"/DocOpen"
"/Document"
"/Documents"
"/Domain"
"/Door"
"/DotGain"
"/Draw"
"/Dt"
"/Dur"
"/Dynamic#20connector"
"/E"
"/EF"
"/EFF"
"/EMC"
"/Eacute"
"/EarlyChange"
"/Ecircumflex"
"/Edieresis"
"/Editable"
"/Egrave"
"/EmbedFonts"
"/EmbedICCProfile"
"/Embedded"
"/EmbeddedFile"
"/EmbeddedFiles"
"/Encode"
"/EncodedByteAlign"
"/Encoding"
"/Encrypt"
"/EncryptMetadata"
"/EndIndent"
"/EndOfBlock"
"/EndOfLine"
"/Euro"
"/Euro.037"
"/Event"
"/ExData"
"/Exchange-Pro"
"/Exclude"
"/Exclusion"
"/Executive"
"/Export"
"/ExportCrispy"
"/ExportState"
"/ExtGState"
"/Extend"
"/Extends"
"/ExtensionLevel"
"/Extensions"
"/F1"
"/F1.0"
"/F12"
"/F13"
"/F3"
"/F5"
"/F6"
"/F7"
"/F8"
"/FB"
"/FD"
"/FDecodeParms"
"/FFilter"
"/FICL"
"/FM"
"/FOV"
"/FRM"
"/FS"
"/FT"
"/Facilities"
"/Fade"
"/False"
"/Feature"
"/FedEx#20Orange"
"/FedEx#20Purple"
"/Field"
"/Fields"
"/Figure"
"/File"
"/Files"
"/Filespec"
"/FillIn"
"/Filter"
"/First"
"/FirstChar"
"/FirstPage"
"/Fit"
"/FitB"
"/FitBH"
"/FitBV"
"/FitH"
"/FitR"
"/FitV"
"/FitWindow"
"/FixedPrint"
"/Flags"
"/FlateDecode"
"/Fm0"
"/Fm4"
"/Fo"
"/Focoltone#201047"
"/Font"
"/FontBBox"
"/FontDescriptor"
"/FontFamily"
"/FontFile"
"/FontFile2"
"/FontMatrix"
"/FontName"
"/FontStretch"
"/FontWeight"
"/Form"
"/FormEx"
"/FormType"
"/FreeText"
"/FreeTextCallout"
"/Frequency"
"/FullSave"
"/FullScreen"
"/Function"
"/FunctionType"
"/Functions"
"/Futura-Bold"
"/Futura-CondensedExtraBold"
"/G"
"/G02"
"/GLGR"
"/GS0"
"/GS1"
"/GS2"
"/GTS"
"/GTS_PDFA1"
"/GTS_PDFX"
"/GTS_PDFXConformance"
"/GTS_PDFXVersion"
"/GWG#20Green"
"/Gamma"
"/Garamond"
"/Georgia,Bold"
"/GoTo"
"/GoTo3DView"
"/GoToE"
"/GoToR"
"/Gold"
"/Goudy"
"/Gray"
"/Green"
"/GreymantleMVB"
"/GrotesqueMT"
"/Group"
"/H"
"/HDAG_Tools"
"/HKana"
"/HT"
"/HT2"
"/Halftone"
"/HalftoneName"
"/HalftoneType"
"/HardLight"
"/HeBo"
"/Head1"
"/Headlamp"
"/Height"
"/HeiseiMin"
"/Helv"
"/Helvetica"
"/Helvetica-Bold"
"/Helvetica-BoldOblique"
"/Helvetica-Condensed"
"/HelveticaNeue-Black"
"/Hide"
"/HonMincho-M"
"/Horizontal"
"/Hue"
"/I"
"/I0"
"/IC"
"/ICCBased"
"/ICCVersion"
"/ID"
"/IDS"
"/IDTree"
"/IEC"
"/IF"
"/IN"
"/ISO32000Registry"
"/ISO_PDFE1"
"/ISO_PDFEVersion"
"/IT"
"/ITO"
"/ITP"
"/IV"
"/IX"
"/Icircumflex"
"/Icon"
"/Identity"
"/Identity-H"
"/IgnEP"
"/Illustrator"
"/Illustrator8.0"
"/Im0"
"/Im1"
"/Im2"
"/Im3"
"/Im4"
"/Image"
"/Image1"
"/ImageB"
"/ImageC"
"/ImageI"
"/ImageMask"
"/ImageResources"
"/ImageType"
"/Import"
"/ImportData"
"/ImpressBT-Regular"
"/Index"
"/Indexed"
"/Info"
"/Information#20services"
"/Ink"
"/InkList"
"/InsertPages"
"/Insignia"
"/IntegerItem"
"/Intent"
"/Interpolate"
"/ItalicAngle"
"/ItcKabel-Ultra"
"/Item1"
"/Item2"
"/JBIG2Decode"
"/JBIG2Globals"
"/JPXDecode"
"/JS"
"/JT"
"/JTC"
"/JTF"
"/JTFile"
"/JTM"
"/JavaScript"
"/JobTicketContents"
"/Justify"
"/Keywords"
"/Kids"
"/L"
"/L1"
"/L1a"
"/L1b"
"/L2R"
"/L50188"
"/LBody"
"/LI"
"/LL"
"/LLE"
"/LLO"
"/LS"
"/LSP"
"/LZW"
"/LZWDecode"
"/Lab"
"/Lang"
"/Last"
"/LastChar"
"/LastItem"
"/LastModified"
"/Lateral#20file"
"/Launch"
"/Layout"
"/Lbl"
"/Leading"
"/Legal"
"/Length"
"/Length1"
"/Length2"
"/Length3"
"/LetterspaceFlags"
"/Lighten"
"/Limits"
"/Line"
"/LineDimension"
"/LineHeight"
"/Linear"
"/Linearized"
"/Link"
"/Locked"
"/LogoGreen"
"/LrTb"
"/Lslash"
"/Luminosity"
"/M"
"/MB"
"/MC"
"/MC0"
"/MCD"
"/MCID"
"/MCR"
"/MD5"
"/MH"
"/MIT"
"/MK"
"/MMType1"
"/MP"
"/MR"
"/MS"
"/MUX#20#2F#20DEMUX"
"/Mac"
"/MacRomanEncoding"
"/Magenta"
"/Manager"
"/MarkInfo"
"/Marked"
"/MarkedPDF"
"/Marker#20board"
"/Markup3D"
"/Mask"
"/Mastercard"
"/Matrix"
"/Max"
"/MaxLen"
"/MaxWidth"
"/Me"
"/Measure"
"/MediaBox"
"/MetaData"
"/Min"
"/MinionMM"
"/MissingWidth"
"/MixedContainer"
"/MixingHints"
"/ModDate"
"/Mode"
"/Modify"
"/Movie"
"/Msg"
"/MurrayHillBT-Bold"
"/MxGeom"
"/MxLaNu"
"/MxPts"
"/MyriadPro-Black"
"/NA"
"/NChannel"
"/ND"
"/NL"
"/NM"
"/NR"
"/Name"
"/Name1"
"/Named"
"/Names"
"/NeedsRendering"
"/NewCenturySchlbk-Italic"
"/NewWindow"
"/Next"
"/NextPage"
"/No"
"/NonEFontNoWarn"
"/NonStruct"
"/None"
"/Normal"
"/Not"
"/NotDefSpecial"
"/NumBlock"
"/Nums"
"/OB"
"/OBJR"
"/OC"
"/OC2"
"/OC3"
"/OC4"
"/OCG"
"/OCGs"
"/OCL"
"/OCMD"
"/OCProperties"
"/OE"
"/OFF"
"/OLN"
"/ON"
"/OOL"
"/OPBG"
"/OPBS"
"/OPI"
"/OPM"
"/OS"
"/OT"
"/Oacute"
"/Obj"
"/ObjStm"
"/Ocircumflex"
"/Odieresis"
"/Ograve"
"/Omega"
"/OneColumn"
"/Online"
"/Open"
"/OpenAction"
"/Operation"
"/Opt"
"/OptionSet"
"/Options"
"/Or"
"/Orange"
"/Order"
"/Ordering"
"/OriginalLayerName"
"/Oslash"
"/Otilde"
"/Outlines"
"/OutputCondition"
"/OutputConditionIdentifier"
"/OutputIntent"
"/OutputIntents"
"/Overlay"
"/P0"
"/P1"
"/P2"
"/P2,#2300ff007900000000,PANTONE#20151#20C"
"/PANTONE"
"/PANTONE#20158-5#20CVS"
"/PANTONE#20221#20CVU"
"/PANTONE#203405#20C"
"/PANTONE#20399#20CVC"
"/PANTONE#20Blue#20072#20C"
"/PANTONE#20Orange#20021#20C"
"/PANTONE#20Orange#20021#20CVC"
"/PANTONE#20Yellow#20C"
"/PC"
"/PDFDocEncoding"
"/PIX"
"/PO"
"/PS"
"/PUBLISHER"
"/PZ"
"/Pa0"
"/Page"
"/PageElement"
"/PageLabels"
"/PageLayout"
"/PageMode"
"/PageRange"
"/Pages"
"/PaintType"
"/Palatino,Bold"
"/Pale#20Brown.c"
"/Panose"
"/Paper#20tray"
"/Para"
"/Params"
"/Parent"
"/ParentTree"
"/ParentTreeNextKey"
"/Part"
"/Pattern"
"/PatternType"
"/PcZ"
"/Perceptual"
"/Perms"
"/Pg"
"/Pgf"
"/PieceInfo"
"/PitStop"
"/Placement"
"/Play"
"/Polygon"
"/PolygonCloud"
"/Popup"
"/Position"
"/PowerUpPDF"
"/PrOut"
"/PrRGBGra"
"/PrRGBIma"
"/Predictor"
"/PresSteps"
"/PreserveRB"
"/Prev"
"/PrevPage"
"/Preview"
"/Print"
"/PrintRecord"
"/PrintScaling"
"/PrintState"
"/PrintStyle"
"/Printed"
"/PrintingOrder"
"/Private"
"/ProcSet"
"/Process"
"/ProcessBlue"
"/ProcessGreen"
"/ProcessRed"
"/Producer"
"/ProfileCS"
"/ProfileName"
"/Prop_Build"
"/Properties"
"/Proportional"
"/PubSec"
"/Q"
"/QuadPoints"
"/R1"
"/RBGroups"
"/RC"
"/RD"
"/REC"
"/REx"
"/RF"
"/RGB"
"/RI"
"/RICMYKGra"
"/RICMYKIma"
"/RICalGra"
"/RICalIma"
"/RIDefault"
"/RIDevNGra"
"/RIDevNIma"
"/RIRGBGra"
"/RIRGBIma"
"/RL"
"/RM"
"/RV"
"/Range"
"/Rect"
"/Red"
"/Redact"
"/Ref"
"/Reference"
"/Registry"
"/RegistryName"
"/RelativeColorimetric"
"/Rendition"
"/Renditions"
"/Requirements"
"/ResetForm"
"/Resolution"
"/Resources"
"/ReversedChars"
"/RoleMap"
"/Root"
"/Rotate"
"/Round"
"/RoundTrip"
"/RoundtripVersion"
"/Router"
"/Rows"
"/RunLengthDecode"
"/Ryumin"
"/SA"
"/SBDraft"
"/SC"
"/SE"
"/SFSSL"
"/SFTWS"
"/SI"
"/SL"
"/SLA"
"/SM"
"/SMask"
"/SMaskInData"
"/SP"
"/SPS"
"/STL"
"/SU"
"/SW"
"/Saturation"
"/SaveAs"
"/SaveContents"
"/SaveResource"
"/SavedBy"
"/Scaron"
"/Schema"
"/Screen"
"/Sect"
"/SemiCondensed"
"/SemiExpanded"
"/Separation"
"/SeparationInfo"
"/SetOCGState"
"/SettingsFileName"
"/Sh0"
"/Sh1"
"/Shading"
"/ShadingType"
"/Shape"
"/Sig"
"/SigFlags"
"/SigRef"
"/Signature"
"/Signed"
"/SinglePage"
"/Size"
"/SlideShow"
"/SoftLight"
"/Solid"
"/Solidities"
"/SomeName"
"/Sort"
"/Sound"
"/Space"
"/SpaceAfter"
"/SpaceBefore"
"/Span"
"/SpawnTemplate"
"/SpdrArt"
"/SpiderInfo"
"/Split"
"/Spot"
"/Spot1"
"/Spot2"
"/SpotFunction"
"/SpotMap"
"/St"
"/Stamp"
"/StandardImageFileData"
"/Star"
"/Start"
"/StartIndent"
"/StartResource"
"/State"
"/StdCF"
"/StemH"
"/StemV"
"/Stm"
"/StmF"
"/Stop"
"/Story"
"/StrF"
"/StrikeOut"
"/StringItem"
"/StructElem"
"/StructParent"
"/StructParents"
"/StructTreeRoot"
"/Style"
"/SubFilter"
"/SubType"
"/Subdictionary"
"/Subform"
"/Subj"
"/Subject"
"/SubmitForm"
"/SubmitStandalone"
"/SubsetFontsBelow"
"/SubsetFontsRatio"
"/Supplement"
"/Swiss721BT-Black"
"/Switch"
"/T"
"/T1"
"/T1_0"
"/TB"
"/TC"
"/TCS"
"/TF"
"/TID"
"/TK"
"/TM"
"/TO"
"/TOC"
"/TOCI"
"/TOYO#200004pc"
"/TP"
"/TR"
"/TR2"
"/TRUMATCH#206-e"
"/TS"
"/TSV"
"/TT"
"/TT0"
"/TTRefMan"
"/TU"
"/TV"
"/TW"
"/TWS"
"/TWY"
"/Tabs"
"/TagSuspect"
"/TargetCS"
"/Technical"
"/Template"
"/TemplateInstantiated"
"/Templates"
"/Text"
"/TextAlign"
"/TextBox"
"/TextIndent"
"/The"
"/This"
"/Thorn"
"/Thread"
"/Threads"
"/Thumb"
"/Thumbnail"
"/Thumbs"
"/Ti"
"/TiBI"
"/TilingType"
"/Times-BoldItalic"
"/Times-Roman"
"/Title"
"/ToUnicode"
"/Toggle"
"/Trans"
"/TransferFunction"
"/TransformMethod"
"/TransformParams"
"/Transparency"
"/TrapInfo"
"/TrapMagicNumber"
"/TrapRegions"
"/TrapSet"
"/Trapped"
"/Trapping"
"/TrappingDetails"
"/TrappingParameters"
"/TrimBox"
"/True"
"/TrueType"
"/TrustedMode"
"/TwoColumnLeft"
"/Tx"
"/Type"
"/Type0"
"/U3D"
"/UA"
"/UCR"
"/UCR2"
"/UIDOffset"
"/UR"
"/UR3"
"/URI"
"/URL"
"/URLs"
"/Uacute"
"/Ucircumflex"
"/Udieresis"
"/Ugrave"
"/Univers-BoldExt"
"/Unix"
"/Unknown"
"/Usage"
"/UseAttachments"
"/UseNone"
"/UseOC"
"/UseOutlines"
"/UseThumbs"
"/UsedCMYK"
"/UserProperties"
"/UserUnit"
"/V2"
"/VA"
"/VE"
"/VP"
"/Verdana,Bold"
"/Version"
"/Vertical"
"/VeryLastItem"
"/View"
"/ViewerPreferences"
"/Visa"
"/Visible"
"/Volume"
"/W2"
"/WAI"
"/WAN"
"/WMode"
"/WP"
"/WarnockPro-BoldIt"
"/Watermark"
"/WebCapture"
"/Which"
"/WhiteBG"
"/WhitePoint"
"/Widget"
"/Width"
"/Widths"
"/Win"
"/WinAnsiEncoding"
"/Window"
"/Windows"
"/Work#20surface"
"/Workbook"
"/Worksheet"
"/WritingMode"
"/X"
"/X1"
"/XFA"
"/XHeight"
"/XML"
"/XN"
"/XObject"
"/XRef"
"/XRefStm"
"/XStep"
"/XUID"
"/XYZ"
"/Y"
"/YStep"
"/Yacute"
"/Ydieresis"
"/Yellow"
"/Z"
"/Z7KNXbN"
"/ZaDb"
"/ZapfDingbats"
"/Zcaron"
"/Zoom"
"/_No_paragraph_style_"
"/a1"
"/acute"
"/adbe.pkcs7.detached"
"/ampersand"
"/apple"
"/approxequal"
"/asciicircum"
"/asciitilde"
"/asterisk"
"/at"
"/audio#2Fmpeg"
"/b"
"/backslash"
"/bar"
"/blank"
"/braceleft"
"/braceright"
"/bracketleft"
"/bracketright"
"/breve"
"/brokenbar"
"/bullet"
"/c108"
"/cCompKind"
"/cCompQuality"
"/cCompression"
"/cRes"
"/cResolution"
"/ca"
"/caron"
"/cedilla"
"/cent"
"/circumflex"
"/colon"
"/comma"
"/copyright"
"/currency"
"/dagger"
"/daggerdbl"
"/degree"
"/deviceNumber"
"/dieresis"
"/divide"
"/dollar"
"/dotaccent"
"/dotlessi"
"/dotlessj"
"/eight"
"/ellipsis"
"/emdash"
"/endash"
"/equal"
"/eth"
"/exclam"
"/exclamdown"
"/f"
"/ff"
"/ffi"
"/ffl"
"/fi"
"/five"
"/fl"
"/florin"
"/four"
"/fraction"
"/gCompKind"
"/gCompQuality"
"/gCompression"
"/gRes"
"/gResolution"
"/germandbls"
"/go1"
"/grave"
"/greater"
"/greaterequal"
"/guillemotleft"
"/guillemotright"
"/guilsinglleft"
"/guilsinglright"
"/hungarumlaut"
"/hyphen"
"/iacute"
"/idieresis"
"/igrave"
"/infinity"
"/integral"
"/j"
"/k"
"/less"
"/lessequal"
"/logicalnot"
"/lozenge"
"/lt#20blue"
"/mCompKind"
"/mCompression"
"/mRes"
"/mResolution"
"/macron"
"/minus"
"/mu"
"/multiply"
"/n"
"/n0"
"/nine"
"/notequal"
"/ntilde"
"/numbersign"
"/o"
"/ogonek"
"/one"
"/onehalf"
"/onequarter"
"/onesuperior"
"/op"
"/ordfeminine"
"/ordmasculine"
"/p"
"/pageH"
"/pageV"
"/paragraph"
"/parenleft"
"/parenright"
"/partialdiff"
"/pdf"
"/pdfx"
"/percent"
"/period"
"/periodcentered"
"/perthousand"
"/pi"
"/plus"
"/plusminus"
"/pms#208400"
"/printX"
"/product"
"/question"
"/questiondown"
"/quotedbl"
"/quotedblbase"
"/quotedblleft"
"/quotedblright"
"/quoteleft"
"/quoteright"
"/quotesinglbase"
"/quotesingle"
"/r"
"/radical"
"/registered"
"/ring"
"/s"
"/s1"
"/sd1"
"/sd2"
"/section"
"/semicolon"
"/seven"
"/six"
"/slash"
"/sterling"
"/summation"
"/thinspace"
"/three"
"/threequarters"
"/threesuperior"
"/tilde"
"/trademark"
"/two"
"/twosuperior"
"/u"
"/underscore"
"/v"
"/w"
"/y1"
"/yen"
"/yes"
"/zero"
"0 R"
"1"
"1.0"
"<"
"<<"
">"
">>"
"Adobe.PPKLite"
"Adobe.PubSec"
"B*"
"BDC"
"BI"
"BMC"
"BT"
"BX"
"CS"
"DP"
"Do"
"EI"
"EMC"
"ET"
"EX"
"Entrust.PPKEF"
"ID"
"MP"
"R"
"T*"
"TJ"
"TL"
"Tc"
"Td"
"Tf"
"Tj"
"Tm"
"Tr"
"Ts"
"Tw"
"W*"
"["
"[0.0 0.0 0.0 0.0 0.0 0.0]"
"[1 1 1]"
"[1.0 -1.0 1.0 -1.0]"
"[1.0 -1.0]"
"\\"
"]"
"abs"
"adbe.pkcs7.s3"
"adbe.pkcs7.s4"
"adbe.pkcs7.s5"
"add"
"and"
"atan"
"begin"
"beginarrangedfont"
"beginbfchar"
"begincidrange"
"begincmap"
"begincodespacerange"
"beginnotdefchar"
"beginnotdefrange"
"beginusematrix"
"bitshift"
"ceiling"
"cm"
"copy"
"cos"
"cvi"
"cvr"
"d0"
"d1"
"div"
"dup"
"end"
"endarrangedfont"
"endbfchar"
"endcidrange"
"endcmap"
"endcodespacerange"
"endnotdefchar"
"endnotdefrange"
"endobj"
"endstream"
"endusematrix"
"eq"
"exch"
"exp"
"f*"
"false"
"findresource"
"floor"
"ge"
"gs"
"gt"
"idiv"
"if"
"ifelse"
"index"
"le"
"ln"
"log"
"lt"
"mod"
"mul"
"ne"
"neg"
"not"
"null"
"obj"
"or"
"page"
"pop"
"re"
"rg"
"ri"
"roll"
"round"
"sin"
"sqrt"
"startxref"
"stream"
"sub"
"trailer"
"true"
"truncate"
"usecmap"
"usefont"
"xor"
"xref"
"{"
"}"

```

`testcases/_extras/png.dict`:

```dict
#
# AFL dictionary for PNG images
# -----------------------------
#
# Just the basic, standard-originating sections; does not include vendor
# extensions.
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

header_png="\x89PNG\x0d\x0a\x1a\x0a"

section_IDAT="IDAT"
section_IEND="IEND"
section_IHDR="IHDR"
section_PLTE="PLTE"
section_bKGD="bKGD"
section_cHRM="cHRM"
section_fRAc="fRAc"
section_gAMA="gAMA"
section_gIFg="gIFg"
section_gIFt="gIFt"
section_gIFx="gIFx"
section_hIST="hIST"
section_iCCP="iCCP"
section_iTXt="iTXt"
section_oFFs="oFFs"
section_pCAL="pCAL"
section_pHYs="pHYs"
section_sBIT="sBIT"
section_sCAL="sCAL"
section_sPLT="sPLT"
section_sRGB="sRGB"
section_sTER="sTER"
section_tEXt="tEXt"
section_tIME="tIME"
section_tRNS="tRNS"
section_zTXt="zTXt"

```

`testcases/_extras/sql.dict`:

```dict
#
# AFL dictionary for SQL
# ----------------------
#
# Modeled based on SQLite documentation, contains some number of SQLite
# extensions. Other dialects of SQL may benefit from customized dictionaries.
#
# If you append @1 to the file name when loading this dictionary, afl-fuzz
# will also additionally load a selection of pragma keywords that are very
# specific to SQLite (and are probably less interesting from the security
# standpoint, because they are usually not allowed in non-privileged
# contexts).
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

function_abs=" abs(1)"
function_avg=" avg(1)"
function_changes=" changes()"
function_char=" char(1)"
function_coalesce=" coalesce(1,1)"
function_count=" count(1)"
function_date=" date(1,1,1)"
function_datetime=" datetime(1,1,1)"
function_decimal=" decimal(1,1)"
function_glob=" glob(1,1)"
function_group_concat=" group_concat(1,1)"
function_hex=" hex(1)"
function_ifnull=" ifnull(1,1)"
function_instr=" instr(1,1)"
function_julianday=" julianday(1,1,1)"
function_last_insert_rowid=" last_insert_rowid()"
function_length=" length(1)"
function_like=" like(1,1)"
function_likelihood=" likelihood(1,1)"
function_likely=" likely(1)"
function_load_extension=" load_extension(1,1)"
function_lower=" lower(1)"
function_ltrim=" ltrim(1,1)"
function_max=" max(1,1)"
function_min=" min(1,1)"
function_nullif=" nullif(1,1)"
function_printf=" printf(1,1)"
function_quote=" quote(1)"
function_random=" random()"
function_randomblob=" randomblob(1)"
function_replace=" replace(1,1,1)"
function_round=" round(1,1)"
function_rtrim=" rtrim(1,1)"
function_soundex=" soundex(1)"
function_sqlite_compileoption_get=" sqlite_compileoption_get(1)"
function_sqlite_compileoption_used=" sqlite_compileoption_used(1)"
function_sqlite_source_id=" sqlite_source_id()"
function_sqlite_version=" sqlite_version()"
function_strftime=" strftime(1,1,1,1)"
function_substr=" substr(1,1,1)"
function_sum=" sum(1)"
function_time=" time(1,1,1)"
function_total=" total(1)"
function_total_changes=" total_changes()"
function_trim=" trim(1,1)"
function_typeof=" typeof(1)"
function_unicode=" unicode(1)"
function_unlikely=" unlikely(1)"
function_upper=" upper(1)"
function_varchar=" varchar(1)"
function_zeroblob=" zeroblob(1)"

keyword_ABORT="ABORT"
keyword_ACTION="ACTION"
keyword_ADD="ADD"
keyword_AFTER="AFTER"
keyword_ALL="ALL"
keyword_ALTER="ALTER"
keyword_ANALYZE="ANALYZE"
keyword_AND="AND"
keyword_AS="AS"
keyword_ASC="ASC"
keyword_ATTACH="ATTACH"
keyword_AUTOINCREMENT="AUTOINCREMENT"
keyword_BEFORE="BEFORE"
keyword_BEGIN="BEGIN"
keyword_BETWEEN="BETWEEN"
keyword_BY="BY"
keyword_CASCADE="CASCADE"
keyword_CASE="CASE"
keyword_CAST="CAST"
keyword_CHECK="CHECK"
keyword_COLLATE="COLLATE"
keyword_COLUMN="COLUMN"
keyword_COMMIT="COMMIT"
keyword_CONFLICT="CONFLICT"
keyword_CONSTRAINT="CONSTRAINT"
keyword_CREATE="CREATE"
keyword_CROSS="CROSS"
keyword_CURRENT_DATE="CURRENT_DATE"
keyword_CURRENT_TIME="CURRENT_TIME"
keyword_CURRENT_TIMESTAMP="CURRENT_TIMESTAMP"
keyword_DATABASE="DATABASE"
keyword_DEFAULT="DEFAULT"
keyword_DEFERRABLE="DEFERRABLE"
keyword_DEFERRED="DEFERRED"
keyword_DELETE="DELETE"
keyword_DESC="DESC"
keyword_DETACH="DETACH"
keyword_DISTINCT="DISTINCT"
keyword_DROP="DROP"
keyword_EACH="EACH"
keyword_ELSE="ELSE"
keyword_END="END"
keyword_ESCAPE="ESCAPE"
keyword_EXCEPT="EXCEPT"
keyword_EXCLUSIVE="EXCLUSIVE"
keyword_EXISTS="EXISTS"
keyword_EXPLAIN="EXPLAIN"
keyword_FAIL="FAIL"
keyword_FOR="FOR"
keyword_FOREIGN="FOREIGN"
keyword_FROM="FROM"
keyword_FULL="FULL"
keyword_GLOB="GLOB"
keyword_GROUP="GROUP"
keyword_HAVING="HAVING"
keyword_IF="IF"
keyword_IGNORE="IGNORE"
keyword_IMMEDIATE="IMMEDIATE"
keyword_IN="IN"
keyword_INDEX="INDEX"
keyword_INDEXED="INDEXED"
keyword_INITIALLY="INITIALLY"
keyword_INNER="INNER"
keyword_INSERT="INSERT"
keyword_INSTEAD="INSTEAD"
keyword_INTERSECT="INTERSECT"
keyword_INTO="INTO"
keyword_IS="IS"
keyword_ISNULL="ISNULL"
keyword_JOIN="JOIN"
keyword_KEY="KEY"
keyword_LEFT="LEFT"
keyword_LIKE="LIKE"
keyword_LIMIT="LIMIT"
keyword_MATCH="MATCH"
keyword_NATURAL="NATURAL"
keyword_NO="NO"
keyword_NOT="NOT"
keyword_NOTNULL="NOTNULL"
keyword_NULL="NULL"
keyword_OF="OF"
keyword_OFFSET="OFFSET"
keyword_ON="ON"
keyword_OR="OR"
keyword_ORDER="ORDER"
keyword_OUTER="OUTER"
keyword_PLAN="PLAN"
keyword_PRAGMA="PRAGMA"
keyword_PRIMARY="PRIMARY"
keyword_QUERY="QUERY"
keyword_RAISE="RAISE"
keyword_RECURSIVE="RECURSIVE"
keyword_REFERENCES="REFERENCES"
keyword_REGEXP="REGEXP"
keyword_REINDEX="REINDEX"
keyword_RELEASE="RELEASE"
keyword_RENAME="RENAME"
keyword_REPLACE="REPLACE"
keyword_RESTRICT="RESTRICT"
keyword_RIGHT="RIGHT"
keyword_ROLLBACK="ROLLBACK"
keyword_ROW="ROW"
keyword_SAVEPOINT="SAVEPOINT"
keyword_SELECT="SELECT"
keyword_SET="SET"
keyword_TABLE="TABLE"
keyword_TEMP="TEMP"
keyword_TEMPORARY="TEMPORARY"
keyword_THEN="THEN"
keyword_TO="TO"
keyword_TRANSACTION="TRANSACTION"
keyword_TRIGGER="TRIGGER"
keyword_UNION="UNION"
keyword_UNIQUE="UNIQUE"
keyword_UPDATE="UPDATE"
keyword_USING="USING"
keyword_VACUUM="VACUUM"
keyword_VALUES="VALUES"
keyword_VIEW="VIEW"
keyword_VIRTUAL="VIRTUAL"
keyword_WHEN="WHEN"
keyword_WHERE="WHERE"
keyword_WITH="WITH"
keyword_WITHOUT="WITHOUT"

operator_concat=" || "
operator_ebove_eq=" >="

snippet_1eq1=" 1=1"
snippet_at=" @1"
snippet_backticks=" `a`"
snippet_blob=" blob"
snippet_brackets=" [a]"
snippet_colon=" :1"
snippet_comment=" /* */"
snippet_date="2001-01-01"
snippet_dollar=" $1"
snippet_dotref=" a.b"
snippet_fmtY="%Y"
snippet_int=" int"
snippet_neg1=" -1"
snippet_pair=" a,b"
snippet_parentheses=" (1)"
snippet_plus2days="+2 days"
snippet_qmark=" ?1"
snippet_semicolon=" ;"
snippet_star=" *"
snippet_string_pair=" \"a\",\"b\""

string_dbl_q=" \"a\""
string_escaped_q=" 'a''b'"
string_single_q=" 'a'"

pragma_application_id@1=" application_id"
pragma_auto_vacuum@1=" auto_vacuum"
pragma_automatic_index@1=" automatic_index"
pragma_busy_timeout@1=" busy_timeout"
pragma_cache_size@1=" cache_size"
pragma_cache_spill@1=" cache_spill"
pragma_case_sensitive_like@1=" case_sensitive_like"
pragma_checkpoint_fullfsync@1=" checkpoint_fullfsync"
pragma_collation_list@1=" collation_list"
pragma_compile_options@1=" compile_options"
pragma_count_changes@1=" count_changes"
pragma_data_store_directory@1=" data_store_directory"
pragma_database_list@1=" database_list"
pragma_default_cache_size@1=" default_cache_size"
pragma_defer_foreign_keys@1=" defer_foreign_keys"
pragma_empty_result_callbacks@1=" empty_result_callbacks"
pragma_encoding@1=" encoding"
pragma_foreign_key_check@1=" foreign_key_check"
pragma_foreign_key_list@1=" foreign_key_list"
pragma_foreign_keys@1=" foreign_keys"
pragma_freelist_count@1=" freelist_count"
pragma_full_column_names@1=" full_column_names"
pragma_fullfsync@1=" fullfsync"
pragma_ignore_check_constraints@1=" ignore_check_constraints"
pragma_incremental_vacuum@1=" incremental_vacuum"
pragma_index_info@1=" index_info"
pragma_index_list@1=" index_list"
pragma_integrity_check@1=" integrity_check"
pragma_journal_mode@1=" journal_mode"
pragma_journal_size_limit@1=" journal_size_limit"
pragma_legacy_file_format@1=" legacy_file_format"
pragma_locking_mode@1=" locking_mode"
pragma_max_page_count@1=" max_page_count"
pragma_mmap_size@1=" mmap_size"
pragma_page_count@1=" page_count"
pragma_page_size@1=" page_size"
pragma_parser_trace@1=" parser_trace"
pragma_query_only@1=" query_only"
pragma_quick_check@1=" quick_check"
pragma_read_uncommitted@1=" read_uncommitted"
pragma_recursive_triggers@1=" recursive_triggers"
pragma_reverse_unordered_selects@1=" reverse_unordered_selects"
pragma_schema_version@1=" schema_version"
pragma_secure_delete@1=" secure_delete"
pragma_short_column_names@1=" short_column_names"
pragma_shrink_memory@1=" shrink_memory"
pragma_soft_heap_limit@1=" soft_heap_limit"
pragma_stats@1=" stats"
pragma_synchronous@1=" synchronous"
pragma_table_info@1=" table_info"
pragma_temp_store@1=" temp_store"
pragma_temp_store_directory@1=" temp_store_directory"
pragma_threads@1=" threads"
pragma_user_version@1=" user_version"
pragma_vdbe_addoptrace@1=" vdbe_addoptrace"
pragma_vdbe_debug@1=" vdbe_debug"
pragma_vdbe_listing@1=" vdbe_listing"
pragma_vdbe_trace@1=" vdbe_trace"
pragma_wal_autocheckpoint@1=" wal_autocheckpoint"
pragma_wal_checkpoint@1=" wal_checkpoint"
pragma_writable_schema@1=" writable_schema"

```

`testcases/_extras/tiff.dict`:

```dict
#
# AFL dictionary for TIFF images
# ------------------------------
#
# Just the basic, standard-originating sections; does not include vendor
# extensions.
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

header_ii="II*\x00"
header_mm="MM\x00*"

section_100="\x00\x01"
section_101="\x01\x01"
section_102="\x02\x01"
section_103="\x03\x01"
section_106="\x06\x01"
section_107="\x07\x01"
section_10D="\x0d\x01"
section_10E="\x0e\x01"
section_10F="\x0f\x01"
section_110="\x10\x01"
section_111="\x11\x01"
section_112="\x12\x01"
section_115="\x15\x01"
section_116="\x16\x01"
section_117="\x17\x01"
section_11A="\x1a\x01"
section_11B="\x1b\x01"
section_11C="\x1c\x01"
section_11D="\x1d\x01"
section_11E="\x1e\x01"
section_11F="\x1f\x01"
section_122="\"\x01"
section_123="#\x01"
section_124="$\x01"
section_125="%\x01"
section_128="(\x01"
section_129=")\x01"
section_12D="-\x01"
section_131="1\x01"
section_132="2\x01"
section_13B=";\x01"
section_13C="<\x01"
section_13D="=\x01"
section_13E=">\x01"
section_13F="?\x01"
section_140="@\x01"
section_FE="\xfe\x00"
section_FF="\xff\x00"

```

`testcases/_extras/webp.dict`:

```dict
#
# AFL dictionary for WebP images
# ------------------------------
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

header_RIFF="RIFF"
header_WEBP="WEBP"

section_ALPH="ALPH"
section_ANIM="ANIM"
section_ANMF="ANMF"
section_EXIF="EXIF"
section_FRGM="FRGM"
section_ICCP="ICCP"
section_VP8="VP8 "
section_VP8L="VP8L"
section_VP8X="VP8X"
section_XMP="XMP "

```

`testcases/_extras/xml.dict`:

```dict
#
# AFL dictionary for XML
# ----------------------
#
# Several basic syntax elements and attributes, modeled on libxml2.
#
# Created by Michal Zalewski <lcamtuf@google.com>
#

attr_encoding=" encoding=\"1\""
attr_generic=" a=\"1\""
attr_href=" href=\"1\""
attr_standalone=" standalone=\"no\""
attr_version=" version=\"1\""
attr_xml_base=" xml:base=\"1\""
attr_xml_id=" xml:id=\"1\""
attr_xml_lang=" xml:lang=\"1\""
attr_xml_space=" xml:space=\"1\""
attr_xmlns=" xmlns=\"1\""

entity_builtin="&lt;"
entity_decimal="&#1;"
entity_external="&a;"
entity_hex="&#x1;"

string_any="ANY"
string_brackets="[]"
string_cdata="CDATA"
string_col_fallback=":fallback"
string_col_generic=":a"
string_col_include=":include"
string_dashes="--"
string_empty="EMPTY"
string_empty_dblquotes="\"\""
string_empty_quotes="''"
string_entities="ENTITIES"
string_entity="ENTITY"
string_fixed="#FIXED"
string_id="ID"
string_idref="IDREF"
string_idrefs="IDREFS"
string_implied="#IMPLIED"
string_nmtoken="NMTOKEN"
string_nmtokens="NMTOKENS"
string_notation="NOTATION"
string_parentheses="()"
string_pcdata="#PCDATA"
string_percent="%a"
string_public="PUBLIC"
string_required="#REQUIRED"
string_schema=":schema"
string_system="SYSTEM"
string_ucs4="UCS-4"
string_utf16="UTF-16"
string_utf8="UTF-8"
string_xmlns="xmlns:"

tag_attlist="<!ATTLIST"
tag_cdata="<![CDATA["
tag_close="</a>"
tag_doctype="<!DOCTYPE"
tag_element="<!ELEMENT"
tag_entity="<!ENTITY"
tag_ignore="<![IGNORE["
tag_include="<![INCLUDE["
tag_notation="<!NOTATION"
tag_open="<a>"
tag_open_close="<a />"
tag_open_exclamation="<!"
tag_open_q="<?"
tag_sq2_close="]]>"
tag_xml_q="<?xml?>"

```

`testcases/archives/common/ar/small_archive.a`:

```a
!<arch>
limerick/       1415337776  500   500   100640  191       `
There was a young man from Japan
Whose limericks never would scan.
When asked why that was,
He replied "It's because
I always try to cram as many words into the last line as I possibly can."


```

`testcases/others/js/small_script.js`:

```js
if (1==1) eval('1');
```

`testcases/others/rtf/small_document.rtf`:

```rtf
{\rtf1\pard Test\par}
```

`testcases/others/sql/simple_queries.sql`:

```sql
create table t1(one smallint);
insert into t1 values(1);
select * from t1;

```

`testcases/others/text/hello_world.txt`:

```txt
hello

```

`testcases/others/xml/small_document.xml`:

```xml
<a b="c">d</a>

```

`testcases/tests/big.txt`:

```txt
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

`testcases/tests/bigalloc.txt`:

```txt
test6
```

`testcases/tests/crash.txt`:

```txt
test1
```

`testcases/tests/crash_gs.txt`:

```txt
test2
```

`testcases/tests/exception.txt`:

```txt
test4 

```

`testcases/tests/hang.txt`:

```txt
test3
```

`testcases/tests/normal.txt`:

```txt
abcdefgh
```

`testcases/tests/small.txt`:

```txt
0
```

`tinyinst_afl.cpp`:

```cpp
/*
Copyright 2023 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https ://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "tinyinst_covmap.h"
#include "tinyinst_afl.h"
#include "common.h"

static TinyInstCovMap* instrumentation;
static bool persist;
static int num_iterations;
static int cur_iteration;

enum {
  /* 00 */ FAULT_NONE,
  /* 01 */ FAULT_TMOUT,
  /* 02 */ FAULT_CRASH,
  /* 03 */ FAULT_ERROR,
  /* 04 */ FAULT_NOINST,
  /* 05 */ FAULT_NOBITS
};

extern "C" int tinyinst_init(int argc, char** argv) {
  int lastoption = -1;
  for (int i = 1; i < argc; i++) {
    if (strcmp(argv[i], "--") == 0) {
      lastoption = i;
      break;
    }
  }

  if (lastoption <= 0) return 0;

  instrumentation = new TinyInstCovMap();
  instrumentation->Init(lastoption - 1, argv + 1);

  persist = GetBinaryOption("-persist", lastoption - 1, argv + 1, false);
  num_iterations = GetIntOption("-iterations", lastoption - 1, argv + 1, 1);
  cur_iteration = 0;

  return lastoption;
}

extern "C" void tinyinst_set_fuzzer_id(char *fuzzer_id) {
  std::string shm_name = "afl_shm_default";
  if (fuzzer_id) {
    shm_name = std::string("afl_shm_") + std::string(fuzzer_id);
  }
  instrumentation->SetSHMName(shm_name);
}

int get_argc(char** argv) {
  int argc = 0;
  while (1) {
    if (!(*argv)) break;
    argv++;
    argc++;
  }
  return argc;
}

extern "C" int tinyinst_run(char** argv, uint32_t timeout) {
  uint32_t init_timeout = timeout;
  DebuggerStatus status;
  int ret = FAULT_ERROR;

  if (instrumentation->IsTargetFunctionDefined()) {
    if (cur_iteration == num_iterations) {
      instrumentation->Kill();
      cur_iteration = 0;
    }
  }

  uint32_t timeout1 = timeout;
  if (instrumentation->IsTargetFunctionDefined()) {
    timeout1 = init_timeout;
  }

  if (instrumentation->IsTargetAlive() && persist) {
    status = instrumentation->Continue(timeout1);
  } else {
    instrumentation->Kill();
    cur_iteration = 0;
    status = instrumentation->Run(get_argc(argv), argv, timeout1);
  }

  // if target function is defined,
  // we should wait until it is hit
  if (instrumentation->IsTargetFunctionDefined()) {
    if (status != DEBUGGER_TARGET_START) {
      // try again with a clean process
      WARN("Target function not reached, retrying with a clean process\n");
      instrumentation->Kill();
      cur_iteration = 0;
      status = instrumentation->Run(get_argc(argv), argv, init_timeout);
    }

    if (status != DEBUGGER_TARGET_START) {
      switch (status) {
      case DEBUGGER_CRASHED:
        FATAL("Process crashed before reaching the target method\n");
        break;
      case DEBUGGER_HANGED:
        FATAL("Process hanged before reaching the target method\n");
        break;
      case DEBUGGER_PROCESS_EXIT:
        FATAL("Process exited before reaching the target method\n");
        break;
      default:
        FATAL("An unknown problem occured before reaching the target method\n");
        break;
      }
    }

    status = instrumentation->Continue(timeout);
  }

  switch (status) {
  case DEBUGGER_CRASHED:
    ret = FAULT_CRASH;
    instrumentation->Kill();
    break;
  case DEBUGGER_HANGED:
    ret = FAULT_TMOUT;
    instrumentation->Kill();
    break;
  case DEBUGGER_PROCESS_EXIT:
    ret = FAULT_NONE;
    if (instrumentation->IsTargetFunctionDefined()) {
      WARN("Process exit during target function\n");
      ret = FAULT_TMOUT;
    }
    break;
  case DEBUGGER_TARGET_END:
    if (instrumentation->IsTargetFunctionDefined()) {
      ret = FAULT_NONE;
      cur_iteration++;
    }
    else {
      FATAL("Unexpected status received from the debugger\n");
    }
    break;
  default:
    FATAL("Unexpected status received from the debugger\n");
    break;
  }

  return ret;
}

extern "C" void tinyinst_killtarget() {
  instrumentation->Kill();
}
```

`tinyinst_afl.h`:

```h
/*
Copyright 2023 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https ://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef TINYINST_AFL_H
#define TINYINST_AFL_H

extern "C" int tinyinst_init(int argc, char** argv);
extern "C" void tinyinst_set_fuzzer_id(char* fuzzer_id);
extern "C" int tinyinst_run(char** argv, uint32_t timeout);
extern "C" void tinyinst_killtarget();

#endif // TINYINST_AFL_H

```

`tinyinst_covmap.cpp`:

```cpp
/*
Copyright 2023 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https ://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "windows.h"
#include "tinyinst_covmap.h"
#include "common.h"

void TinyInstCovMap::Init(int argc, char **argv) {
  TinyInst::Init(argc, argv);

  coverage_type = COVTYPE_BB;
  char *option = GetOption("-covtype", argc, argv);
  if (option) {
    if (strcmp(option, "bb") == 0)
      coverage_type = COVTYPE_BB;
    else if (strcmp(option, "edge") == 0)
      coverage_type = COVTYPE_EDGE;
    else
      FATAL("Unknown coverage type");
  }

  map_address = NULL;
}

void TinyInstCovMap::SetSHMName(std::string &shm_name) {
  this->shm_name = shm_name;
}

void TinyInstCovMap::OnModuleInstrumented(ModuleInfo* module) {
  TinyInst::OnModuleInstrumented(module);

  EnsureSharedMemory();
}

void TinyInstCovMap::EnsureSharedMemory() {
  if (map_address) return;

  if (shm_name.empty()) FATAL("Shared memory name is not set");

  HANDLE map_file;

  map_file = OpenFileMapping(
    FILE_MAP_ALL_ACCESS,
    FALSE,
    shm_name.c_str());

  if (map_file == NULL) FATAL("Error mapping shared memory");

  map_address = MapViewOfFile2(map_file,
    GetChildProcessHandle(),
    0,
    0,
    MAP_SIZE,
    0,
    PAGE_READWRITE);

  if (!map_address) FATAL("Error mapping shared memory");

  CloseHandle(map_file);
}

void TinyInstCovMap::EmitCoverageInstrumentation(ModuleInfo *module,
                                          uint32_t map_offset) {

  // common x86 assembly codes
  unsigned char PUSH_F[] = { 0x9c };
  unsigned char POP_F[] = { 0x9d };
  unsigned char PUSH_RAX[] = { 0x50 };
  unsigned char POP_RAX[] = { 0x58 };
  unsigned char INC_ADDR[] = { 0xFE, 0x05, 0xAA, 0xAA, 0xAA, 0xAA };
  unsigned char MOV_RAX_IMM64[] = { 0x48, 0xB8, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };
  unsigned char INC_MEM_RAX[] = { 0xFE, 0x00 };

  size_t address = (size_t)map_address + map_offset;

  if (sp_offset) {
    assembler_->OffsetStack(module, -sp_offset);
  }

  // pushf
  WriteCode(module, PUSH_F, sizeof(PUSH_F));

  if (child_ptr_size == 4) {

    // inc byte ptr[addr]
    WriteCode(module, INC_ADDR, sizeof(INC_ADDR));
    *(uint32_t*)(module->instrumented_code_local +
      module->instrumented_code_allocated - 4) =
      (uint32_t)address;

  } else {

    // push rax
    WriteCode(module, PUSH_RAX, sizeof(PUSH_RAX));

    // mov rax, addr
    WriteCode(module, MOV_RAX_IMM64, sizeof(MOV_RAX_IMM64));
    *(uint64_t*)(module->instrumented_code_local +
      module->instrumented_code_allocated - 8) =
      (uint64_t)address;

    // inc byte ptr[rax]
    WriteCode(module, INC_MEM_RAX, sizeof(INC_MEM_RAX));

    // pop rax
    WriteCode(module, POP_RAX, sizeof(POP_RAX));

  }

  // popf
  WriteCode(module, POP_F, sizeof(POP_F));

  if (sp_offset) {
    assembler_->OffsetStack(module, sp_offset);
  }
}

void TinyInstCovMap::InstrumentBasicBlock(ModuleInfo *module, size_t bb_address) {
  if (coverage_type != COVTYPE_BB) return;

  uint32_t offset = GetBBOffset(module, bb_address);

  EmitCoverageInstrumentation(module, offset);
}

void TinyInstCovMap::InstrumentEdge(ModuleInfo *previous_module,
                             ModuleInfo *next_module, size_t previous_address,
                             size_t next_address) {
  if (coverage_type != COVTYPE_EDGE) return;

  uint32_t coverage_code =
      GetEdgeOffset(previous_module, next_module, previous_address, next_address);

  EmitCoverageInstrumentation(previous_module, coverage_code);
}

uint32_t TinyInstCovMap::GetBBOffset(ModuleInfo *module, size_t bb_address) {
  uint32_t offset = (uint32_t)((size_t)bb_address - (size_t)module->min_address);
  return offset % MAP_SIZE;
}

uint32_t TinyInstCovMap::GetEdgeOffset(ModuleInfo *module1,
                                     ModuleInfo *module2,
                                     size_t edge_address1,
                                     size_t edge_address2)
{
  uint32_t offset1 = 0;
  if (module1 && edge_address1)
    offset1 = (uint32_t)((size_t)edge_address1 - (size_t)module1->min_address);
  uint32_t offset2 = 0;
  if (module2 && edge_address2)
    offset2 = (uint32_t)((size_t)edge_address2 - (size_t)module2->min_address);

  return ((offset1 >> 1) ^ offset2) % MAP_SIZE;
}

void TinyInstCovMap::OnModuleEntered(ModuleInfo *module, size_t entry_address) {
  TinyInst::OnModuleEntered(module, entry_address);

  if (coverage_type == COVTYPE_BB) return;

  if (!map_address) return;

  uint8_t map_byte = 0;
  uint32_t map_offset = GetEdgeOffset(0, module, 0, entry_address);

  RemoteRead((char*)map_address + map_offset, &map_byte, sizeof(map_byte));
  map_byte++;
  RemoteWrite((char*)map_address + map_offset, &map_byte, sizeof(map_byte));
}

void TinyInstCovMap::OnProcessExit() {
  map_address = NULL;
  TinyInst::OnProcessExit();
}

```

`tinyinst_covmap.h`:

```h
/*
Copyright 2023 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https ://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef TINYINST_COVMAP_H
#define TINYINST_COVMAP_H

#include <string>
#include "tinyinst.h"

#define MAP_SIZE 65536

enum CovType {
  COVTYPE_BB,
  COVTYPE_EDGE
};

class TinyInstCovMap : public TinyInst {
public:
  virtual void Init(int argc, char **argv) override;
  void SetSHMName(std::string& shm_name);

protected:
  virtual void OnProcessExit() override;

  virtual void OnModuleInstrumented(ModuleInfo* module) override;
  virtual void OnModuleEntered(ModuleInfo *module, size_t entry_address) override;

  virtual void InstrumentBasicBlock(ModuleInfo *module, size_t bb_address) override;
  virtual void InstrumentEdge(ModuleInfo *previous_module,
                              ModuleInfo *next_module,
                              size_t previous_address,
                              size_t next_address) override;

  void EmitCoverageInstrumentation(ModuleInfo *module, uint32_t map_offset);

  uint32_t GetBBOffset(ModuleInfo* module, size_t bb_address);
  uint32_t GetEdgeOffset(ModuleInfo* module1,
                         ModuleInfo* module2,
                         size_t edge_address1,
                         size_t edge_address2);

private:
  void EnsureSharedMemory();

  CovType coverage_type;
  void* map_address;
  std::string shm_name;
};

#endif // TINYINST_COVMAP_H

```

`types.h`:

```h
/*
   american fuzzy lop - type definitions and minor macros
   ------------------------------------------------------

   Original AFL code written by Michal Zalewski <lcamtuf@google.com>

   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

#ifndef _HAVE_TYPES_H
#define _HAVE_TYPES_H

#include <stdint.h>
#include <stdlib.h>

typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;

/*

   Ugh. There is an unintended compiler / glibc #include glitch caused by
   combining the u64 type an %llu in format strings, necessitating a workaround.

   In essence, the compiler is always looking for 'unsigned long long' for %llu.
   On 32-bit systems, the u64 type (aliased to uint64_t) is expanded to
   'unsigned long long' in <bits/types.h>, so everything checks out.

   But on 64-bit systems, it is #ifdef'ed in the same file as 'unsigned long'.
   Now, it only happens in circumstances where the type happens to have the
   expected bit width, *but* the compiler does not know that... and complains
   about 'unsigned long' being unsafe to pass to %llu.

 */

#ifdef _WIN64
typedef unsigned long long u64;
#else
typedef uint64_t u64;
#endif /* ^sizeof(...) */

typedef int8_t   s8;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;

#ifndef MIN
#  define MIN(_a,_b) ((_a) > (_b) ? (_b) : (_a))
#  define MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))
#endif /* !MIN */

#define SWAP16(x) (((x) >> 8) | ((x) << 8))
#define SWAP32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) | (((x) & 0x0000FF00) << 8) | ((x) << 24))

#define R(x) (rand() % (x))

#define STRINGIFY_INTERNAL(x) #x
#define STRINGIFY(x) STRINGIFY_INTERNAL(x)

#define MEM_BARRIER() \
  asm volatile("" ::: "memory")

#endif /* ! _HAVE_TYPES_H */

```

`utils.h`:

```h
/* ***************************************************************************
 * Copyright (c) 2012-2013 Google, Inc.  All rights reserved.
 * ***************************************************************************/

/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Google, Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/*
DynamoRIO utility macros. Copied from the DyanmoRIO project,
http://dynamorio.org/
*/


#ifndef CLIENTS_COMMON_UTILS_H_
#define CLIENTS_COMMON_UTILS_H_

#include "dr_api.h"

#ifdef DEBUG
# define ASSERT(x, msg) DR_ASSERT_MSG(x, msg)
# define IF_DEBUG(x) x
#else
# define ASSERT(x, msg) /* nothing */
# define IF_DEBUG(x) /* nothing */
#endif

/* XXX: should be moved to DR API headers? */
#define BUFFER_SIZE_BYTES(buf)      sizeof(buf)
#define BUFFER_SIZE_ELEMENTS(buf)   (BUFFER_SIZE_BYTES(buf) / sizeof((buf)[0]))
#define BUFFER_LAST_ELEMENT(buf)    (buf)[BUFFER_SIZE_ELEMENTS(buf) - 1]
#define NULL_TERMINATE_BUFFER(buf)  BUFFER_LAST_ELEMENT(buf) = 0
#define ALIGNED(x, alignment) ((((ptr_uint_t)x) & ((alignment)-1)) == 0)
#define TESTANY(mask, var) (((mask) & (var)) != 0)
#define TEST  TESTANY

#ifdef WINDOWS
# define IF_WINDOWS(x) x
# define IF_UNIX_ELSE(x,y) y
#else
# define IF_WINDOWS(x)
# define IF_UNIX_ELSE(x,y) x
#endif

/* Checks for both debug and release builds: */
#define USAGE_CHECK(x, msg) DR_ASSERT_MSG(x, msg)

static inline generic_func_t
cast_to_func(void *p)
{
#ifdef WINDOWS
#  pragma warning(push)
#  pragma warning(disable : 4055)
#endif
    return (generic_func_t) p;
#ifdef WINDOWS
#  pragma warning(pop)
#endif
}

#endif /* CLIENTS_COMMON_UTILS_H_ */

```

`winafl-cmin.py`:

```py
#
#    american fuzzy lop - corpus minimization tool
#    ----------------------------------------
#
#    Original code written by Michal Zalewski <lcamtuf@google.com>
#
#    Windows fork written by Axel "0vercl0k" Souchet <0vercl0k@tuxfamily.org>
#
#    Copyright 2017 Google Inc. All rights reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at:
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#
from __future__ import print_function

import argparse
import collections
import logging
import multiprocessing
import os
import shutil
import subprocess
import sys
import time
import re
from textwrap import dedent, wrap

nul = open(os.devnull, 'wb')

AFLShowMapResult = collections.namedtuple(
    'AFLShowMapResult', [
        'returncode', 'path', 'filesize', 'tuples'
    ]
)


class AFLShowMapWorker(object):
    '''This class abstracts away the interaction with afl-showmap.exe
    and plays nice with the multiprocessing module'''
    def __init__(self, args):
        self.args = args

    @staticmethod
    def _to_showmap_options(args, trace_name = '-'):
        '''Takes the argparse namespace, and convert it to the list of options used
        to invoke afl-showmap.exe'''
        r = [
            'afl-showmap.exe', '-o', trace_name, '-m', args.memory_limit
        ]

        if os.getenv('AFL_NO_SINKHOLE') is None:
            r.append('-q')

        if args.edges_only:
            r.append('-e')

        if args.time_limit > 0:
            r.extend(['-t', '%d' % args.time_limit])
        else:
            r.extend(['-t', 'none'])

        if args.static_instr:
            r.append('-Y')
        else:
            if args.tinyinst_instr:
                r.append('-y')
                r.append('--')
                for mod in args.instrument_modules:
                    r.extend(['-instrument_module', mod])
            else:
                r.extend(['-D', args.dynamorio_dir])
                r.append('--')
                for mod in args.coverage_modules:
                    r.extend(['-coverage_module', mod])

            r.extend(['-target_module', args.target_module])
            if args.target_method is None:
                r.extend(['-target_offset', '0x%x' % args.target_offset])
            else:
                r.extend(['-target_method', args.target_method])
            r.extend(['-nargs', '%d' % args.nargs])
            r.extend(['-covtype', args.covtype])
            if args.call_convention is not None:
                r.extend(['-call_convention', args.call_convention])

        r.append('--')
        r.extend(args.target_cmdline)
        return r

    def __call__(self, input_file):
        '''Runs afl-showmap.exe on a specific target and extracts
        the tuples from the generated trace'''
        current_process = multiprocessing.current_process()
        fileread = None
        if self.args.file_read is not None:
            # It means that the target expects to have '@@' replaced with a
            # constant path file. First step, is to copy the input to
            # this location
            fileread = self.args.file_read.replace(
                '@@', current_process.name
            )
            if os.path.isfile(fileread):
                os.remove(fileread)
            shutil.copyfile(input_file, fileread)

        trace_name = 'worker.%d.trace.bin' % current_process.pid
        opts = AFLShowMapWorker._to_showmap_options(self.args, trace_name)
        # If we have a '@@' marker in the command line, it has to be replaced
        # by an actual file. It is either directly the input testcase, or the
        # file specified by the -f option.
        if opts.count('@@') > 0:
            # TODO(0vercl0k): handle inputs via stdin as opposed to '@@' & -f
            idx = opts.index('@@')
            opts[idx] = input_file if fileread is None else fileread

        # Make sure there isn't a trace that hasn't been properly cleaned
        if os.path.isfile(trace_name):
            os.remove(trace_name)

        p = subprocess.Popen(opts, close_fds = True)
        p.wait()

        if fileread is not None:
            # Clean it up
            os.remove(fileread)

        # Read the trace file and populate the tuple store
        tuples = {}
        if os.path.isfile(trace_name):
            with open(trace_name, 'r') as f:
                for line in f.readlines():
                    tuple_id, hitcount = map(int, line.split(':', 1))
                    tuples[tuple_id] = hitcount

            # Clean it up
            os.remove(trace_name)
        return AFLShowMapResult(
            p.returncode, input_file,
            os.path.getsize(input_file), tuples
        )


def target_offset(opt):
    '''Validates that the target_offset is actually an integer, else
    raises an ArgumentTypeError exception back to the argparse parser.'''
    try:
        return int(opt, 0)
    except ValueError:
        raise argparse.ArgumentTypeError('must be an integer')


def memory_limit(opt):
    '''Validates that the -m parameter is properly formatted, else
    raises an ArgumentTypeError exception back to the argparse parser.'''
    if re.match(r'^\d+[TGkM]?$', opt) or opt == 'none':
        return opt
    raise argparse.ArgumentTypeError('must be an integer followed by either: '
                                     'T, G, M, k or nothing; or none')


def setup_argparse():
    '''Sets up the argparse configuration.'''
    parser = argparse.ArgumentParser(
        formatter_class = argparse.RawDescriptionHelpFormatter,
        epilog = '\n'.join(wrap(dedent(
            '''
            Examples of use:
             * Typical use
              winafl-cmin.py -D D:\\DRIO\\bin32 -t 100000 -i in -o minset -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@

             * Dry-run, keep crashes only with 4 workers with a working directory:
              winafl-cmin.py -C --dry-run -w 4 --working-dir D:\\dir -D D:\\DRIO\\bin32 -t 10000 -i in -i C:\\fuzz\\in -o out_mini -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@

             * Read from specific file
              winafl-cmin.py -D D:\\DRIO\\bin32 -t 100000 -i in -o minset -f foo.ext -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@

             * Read from specific file with pattern
              winafl-cmin.py -D D:\\DRIO\\bin32 -t 100000 -i in -o minset -f prefix-@@-foo.ext -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@

             * Typical use with static instrumentation
              winafl-cmin.py -Y -t 100000 -i in -o minset -- test.instr.exe @@
            
             * Typical use with TinyInst mode instrumentation
             winafl-cmin.py -y -t 100000 -i in -o minset -instrument_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@
            '''
        ), 100, replace_whitespace = False))
    )

    group = parser.add_argument_group('basic parameters')
    group.add_argument(
        '-i', '--input', action = 'append', required = True,
        metavar = 'dir', help = 'input directory with the starting corpus.'
        ' Multiple input directories are supported'
    )
    group.add_argument(
        '-o', '--output', required = True,
        metavar = 'dir', help = 'output directory for minimized files'
    )
    group.add_argument(
        '--crash-dir', required=False,
        metavar='dir', help='output directory for crashing files'
    )
    group.add_argument(
        '--hang-dir', required=False,
        metavar='dir', help='output directory for hanging files'
    )
    group.add_argument(
        '-n', '--dry-run', action = 'store_true', default = False,
        help = 'do not really populate the output directory'
    )
    group.add_argument(
        '--working-dir', default = os.getcwd(),
        metavar = 'dir', help = 'directory containing afl-showmap.exe,'
        'winafl.dll, the target binary, etc.'
    )
    group.add_argument(
        '-v', '--verbose', action = 'store_const',
        default = logging.INFO, const = logging.DEBUG
    )

    group = parser.add_argument_group('instrumentation settings')
    instr_type = group.add_mutually_exclusive_group(required = True)
    instr_type.add_argument(
        '-Y', '--static-instr', action = 'store_true',
        help = 'use the static instrumentation mode'
    )

    instr_type.add_argument(
        '-D', '--dynamorio_dir',
        metavar = 'dir', help = 'directory containing DynamoRIO binaries (drrun, drconfig)'
    )

    instr_type.add_argument(
        '-y', '--tinyinst_instr', action = 'store_true',
        help = 'use the TinyInst instrumentation mode'
    )


    instr_module = group.add_mutually_exclusive_group(required = True)
    instr_module.add_argument(
        '-coverage_module', dest = 'coverage_modules', default = None,
        action = 'append', metavar = 'module', help = 'module for which to record coverage.'
        ' Multiple module flags are supported'
    )

    instr_module.add_argument(
        '-instrument_module', dest = 'instrument_modules', default = None,
        action = 'append', metavar = 'module', help = 'module for which to record coverage.'
        ' Multiple module flags are supported'
    )


    group.add_argument(
        '-covtype', choices = ('edge', 'bb'), default = 'bb',
        help = 'the type of coverage being recorded (defaults to bb)'
    )
    group.add_argument(
        '-call_convention', choices = ('stdcall', 'fastcall', 'thiscall', 'ms64'),
        default = 'stdcall', help = 'the calling convention of the target_method'
    )
    
    group.add_argument(
        '-target_module', default = None, metavar = 'module',
        help = 'module which contains the target function to be fuzzed'
    )

    group.add_argument(
        '-nargs', type = int, default = None, metavar = 'nargs',
        help = 'number of arguments the fuzzed method takes. This is used to save/restore'
        ' the arguments between runs'
    )

    group = group.add_mutually_exclusive_group()
    group.add_argument(
        '-target_method', default = None, metavar = 'method',
        help = 'name of the method to fuzz in persistent mode.'
        ' A symbol for the method needs to be exported for this to work'
    )
    group.add_argument(
        '-target_offset', default = None, type = target_offset, metavar = 'rva offset',
        help = 'offset of the method to fuzz from the start of the module'
    )


    group = parser.add_argument_group('execution control settings')
    group.add_argument(
        '-t', '--time-limit', type = int, default = 0,
        metavar = 'msec', help = 'timeout for each run (none)'
    )
    group.add_argument(
        '-m', '--memory-limit', default = 'none', type = memory_limit,
        metavar = 'megs', help = 'memory limit for child process'
    )
    # Note(0vercl0k): If you use -f, which means you want the input file at
    # a specific location (and a specific name), we have to force the pool
    # process to contain only a single worker as there is a unique location
    # specified by -f.. unless you provide a pattern with @@ like
    # c:\dir\prefix@@suffix where @@ will be replaced with a unique identifier.
    group.add_argument(
        '-f', '--file-read', default = None,
        metavar = 'file', help = 'location read by the fuzzed program. '
        'Usage of @@ is encouraged to keep parallelization possible'
    )

    group = parser.add_argument_group('minimization settings')
    group.add_argument(
        '-C', '--crash-only', action = 'store_true', default = False,
        help = 'keep crashing inputs in output directory, reject everything else'
    )
    group.add_argument(
        '-e', '--edges-only', action = 'store_true', default = False,
        help = 'solve for edge coverage only, ignore hit counts'
    )
    group.add_argument(
        '-w', '--workers', type = int, default = multiprocessing.cpu_count(),
        metavar = 'n', help = 'The number of worker processes (default: cpu count)'
    )
    group.add_argument(
        '--skip-dry-run', action = 'store_true', default = False,
        help = 'Skip the dry-run step even if it failed'
    )
    parser.add_argument(
        'target_cmdline', nargs = argparse.REMAINDER,
        help = 'target command line'
    )
    return parser.parse_args()


def validate_args(args):
    '''Validate command-line arguments'''
    # Validate that the first argument is an executable
    if not os.path.isfile(args.target_cmdline[0]):
        logging.error(
            '[!] The target command line\'s first argument needs to'
            ' be an existing executable file.'
        )
        return False

    # If we are not seeing the '@@' marker somewhere and that we are not
    # specifying an input file with -f, then it means something is wrong
    if args.file_read is None and '@@' not in args.target_cmdline:
        logging.error(
            '[!] The target command line needs to include the "@@" marker'
            ' or -f to specify the input file.'
        )
        return False

    # Another sanity check on the root of crash directory
    if args.crash_dir and os.path.isdir(os.path.split(args.crash_dir)[0]) is False:
        logging.error(
            '[!] The output crash directory %r is not a directory', args.crash_dir
        )
        return False

    # Another sanity check on the root of hang directory
    if args.hang_dir and os.path.isdir(os.path.split(args.hang_dir)[0]) is False:
        logging.error(
            '[!] The output hangs directory %r is not a directory', args.hang_dir
        )
        return False

    if os.path.isdir(args.working_dir) is False:
        logging.error(
            '[!] The working directory %r is not a directory', args.working_dir
        )
        return False

    # Regardless of DRIO being used or not, we need afl-showmap.exe
    afl_showmap_path = os.path.join(args.working_dir, 'afl-showmap.exe')
    if not os.path.isfile(afl_showmap_path):
        logging.error('[!] afl-showmap.exe needs to be in %s.', args.working_dir)
        return False

    # Make sure the output directory doesn't exist yet, or exists but is empty
    if os.path.isabs(args.output):
        output_dir_path = args.output
    else:
        output_dir_path = os.path.join(args.working_dir, args.output)
    if args.dry_run is False:
        if os.path.isdir(output_dir_path) and os.listdir(output_dir_path):
            logging.error(
                '[!] %s already exists, please remove it to avoid data loss.',
                args.output
            )
            return False
        if os.path.lexists(output_dir_path) and not os.path.isdir(output_dir_path):
            logging.error(
                '[!] File %s already exists, can\'t create a directory with the same name.',
                args.output
            )
            return False

    if not args.static_instr:
        if None in [args.target_module, args.nargs]:
                logging.error(
                    '[!] , -target_module and -nargs are required'
                    ' options to use the dynamic instrumentation mode.'
                )
                return False
            
        if args.target_method is None and args.target_offset is None:
            logging.error(
                '[!] -target_method or -target_offset is required to use the'
                ' dynamic instrumentation mode'
            )
            return False
         
        if not args.tinyinst_instr:
            # Make sure we have all the arguments we need
            if len(args.coverage_modules) == 0:
                logging.error(
                    '[!] -coverage_module is a required option to use'
                    'the dynamic instrumentation'
                )
                return False

            # If we are using DRIO, one of the thing we need is the DRIO client
            winafl_path = os.path.join(args.working_dir, 'winafl.dll')
            if not os.path.isfile(winafl_path):
                logging.error(
                    '[!] winafl.dll needs to be in %s.', args.working_dir
                )
                return False
        else:
             # Make sure we have all the arguments we need
            if len(args.instrument_modules) == 0:
                logging.error(
                    '[!] -instrument_module is a required option to use'
                    'the dynamic instrumentation'
                )
                return False

    if args.file_read is not None and '@@' not in args.file_read:
        # When a particular input file is specified, first
        # check if the file already exists, because we don't want to overwrite
        # a potentially interesting test case.
        if os.path.isabs(args.file_read):
            file_read_path = args.file_read
        else:
            file_read_path = os.path.join(args.working_dir, args.file_read)
        if os.path.isfile(file_read_path):
            logging.error(
                '[!] %s already exists, please remove it to avoid data loss.',
                args.file_read
            )
            return False

    for i in args.input:
        if os.path.isabs(i):
            dir_path = i
        else:
            dir_path = os.path.join(args.working_dir, i)

        if not os.path.isdir(dir_path):
            logging.error(
                '[!] Specified input directory "%s" does not exist',
                i
            )
            return False

    return True


def target_dry_run(args, test_input):
    logging.info('[*] Testing the target binary...')
    f = AFLShowMapWorker(args)
    results = list(map(f, (test_input, test_input)))
    if results[0] != results[1]:
        logging.error('[!] Dry-run failed, 2 executions resulted differently:')
        logging.error(
            '  Tuples matching? %r',
            results[0].tuples == results[1].tuples
        )
        logging.error(
            '  Return codes matching? %r',
            results[0].returncode == results[1].returncode
        )

        if not args.skip_dry_run:
            return False

    logging.info('[+] OK, %d tuples recorded.', len(results[0].tuples))
    return True


def run_all_inputs(args, inputs):
    nprocesses = args.workers
    if args.file_read is not None and '@@' not in args.file_read:
        # If you are providing -f, but doesn't specify '@@' in the command line
        # of the target, it might be a sign that you are doing something wrong.
        if '@@' not in args.target_cmdline:
            logging.warn(
                "[ ] You specified the -f option without using '@@' in your "
                "command line, this does not sound right."
            )

        logging.info('[+] Worker pool size: 1 (because no "@@" in the -f option)..')
        # Keep in mind that if you want the input files to be named and placed
        # by your liking by specifying -f path/foo.ext we have to set the pool
        # size to 1 in order to make it work.
        nprocesses = 1

    # Record stats about the original input set.
    #  The aggregated size of every input files.
    totalsize = 0
    #  The size of the input set.
    inputs_len = len(inputs)

    logging.info(
        '[+] Found %d test cases across: %s.',
        inputs_len, ', '.join(args.input)
    )

    logging.info('[*] Instantiating %d worker processes.', nprocesses)
    p = multiprocessing.Pool(processes = nprocesses)
    # This tracks every unique tuples and their popularities
    uniq_tuples = collections.Counter()
    # This will associate a tuple with the currently fittest file exercising
    # this particular tuple.
    candidates = {}
    # This tracks every files that triggered a hang.
    hang_files = []
    # This tracks every files that triggered a crash.
    crash_files = []
    # This tracks every files that generated an empty set of tuples.
    # You might get those if the dynamically instrumented target module doesn't
    # get hit because the testcase is so malformed that it won't pass a
    # function called before for example; hence will return an empty tuple set.
    empty_tuple_files = []
    # The default return code is no crash.
    wanted_returncode = 0
    if args.crash_only:
        logging.info('[+] Crash only mode enabled.')
        wanted_returncode = 2

    # Counter tracking how many files we have been through already.
    i = 1
    for result in p.imap_unordered(
        AFLShowMapWorker(args),
        inputs
    ):
        print('\rProcessing file %d/%d...' % (i, inputs_len), end=' ')
        i += 1
        # If the set of tuples is empty, something weird happened
        if len(result.tuples) == 0:
            logging.debug(
                '[x] The input file %s generated an empty set of tuples,'
                ' skipping it (ret = %d).',
                result.path, result.returncode
            )
            empty_tuple_files.append(result.path)
            continue

        if result.returncode != wanted_returncode:
            if result.returncode == 1:
                hang_files.append(result.path)

            # If the mode crash only is enabled, we track the non-crashing
            # test cases in the same tuple.
            if (result.returncode == 2 and args.crash_only is False) or \
               (result.returncode == 0 and args.crash_only):
                crash_files.append(result.path)

            if args.crash_only is False:
                logging.debug(
                    '[x] The input file %s triggered a %s, skipping it.',
                    result.path,
                    'hang' if result.returncode == 1 else 'crash'
                )
            else:
                logging.debug(
                    '[x] The input file %s triggered a %s, skipping it.',
                    result.path,
                    'hang' if result.returncode == 1 else 'non crash'
                )

            continue

        totalsize += result.filesize

        # Generate the list of unique tuples while processing the results,
        # also keep track of their popularities.
        uniq_tuples.update(result.tuples.keys())

        # Keep an updated dictionary mapping a tuple to the fittest file
        # of all the paths.
        for tuple_id, tuple_hitcount in result.tuples.items():
            fileinfo = {
                'size' : result.filesize,
                'path' : result.path,
                'tuples' : result.tuples,
                'hitcount' : tuple_hitcount
            }

            if tuple_id in candidates:
                candidate = candidates[tuple_id]
                # If the candidate has a higher hitcount, we keep it.
                if tuple_hitcount > candidate['hitcount']:
                    candidates[tuple_id] = fileinfo
                elif tuple_hitcount == candidate['hitcount']:
                    # If the candidate has the same hitcount, but a
                    # smaller size, we keep it.
                    if result.filesize < candidate['size']:
                        candidates[tuple_id] = fileinfo
                    elif result.filesize == candidate['size']:
                        # If the candidate has the same hitcount and
                        # size, but exercise a bigger number of tuples,
                        # we keep it.
                        if len(result.tuples) > len(candidate['tuples']):
                            candidate[tuple_id] = fileinfo
            else:
                candidates[tuple_id] = fileinfo
    p.close()

    len_crash_files, len_hang_files, len_empty_tuple_files = map(
        len, (crash_files, hang_files, empty_tuple_files)
    )
    effective_len = len(inputs) - (
        len_crash_files + len_hang_files + len_empty_tuple_files
    )
    print()

    logging.info(
        '[+] Found %d unique tuples across %d files',
        len(uniq_tuples), effective_len
    )
    if len_hang_files > 0:
        logging.info('  - %d files triggered a hang', len_hang_files)
        for hang_file in hang_files:
            logging.debug('    - %s generated a hang', hang_file)

    if len_crash_files > 0:
        logging.info(
            '  - %d files %s a crash',
            len_crash_files,
            'did not trigger' if args.crash_only else 'triggered'
        )
        for crash_file in crash_files:
            logging.debug('    - %s generated a crash', crash_file)

    if len_empty_tuple_files > 0:
        logging.info(
            '  - %d files resulted in an empty tuple set',
            len_empty_tuple_files
        )
        for empty_tuple_file in empty_tuple_files:
            logging.debug('    - %s generated an empty tuple', empty_tuple_file)

    return uniq_tuples, candidates, effective_len, totalsize, crash_files, hang_files


def find_best_candidates(uniq_tuples, candidates):
    # Using the same strategy as in afl-cmin, quoting lcamtuf:
    # '''
    # The "best" part is understood simply as the smallest input that
    # includes a particular tuple in its trace. Empirical evidence
    # suggests that this produces smaller datasets than more involved
    # algorithms that could be still pulled off in a shell script.
    # '''
    minset = []
    minsetsize = 0
    remaining_tuples = list(uniq_tuples)
    len_uniq_tuples = len(uniq_tuples)
    for tuple_ in uniq_tuples:
        if tuple_ not in remaining_tuples:
            # It means we already deleted this tuple, as it was exercised
            # as part of another test case.
            continue

        # Pick the current best file candidate for this tuple.
        candidate = candidates[tuple_]

        # Remove the other tuples also exercised by the candidate
        # from the remaining_tuples list.
        for tuple_exercised in candidate['tuples']:
            # Remove the tuples exercised if we have not
            # removed them already from the
            # remaining_tuples list.
            if tuple_exercised in remaining_tuples:
                remaining_tuples.remove(tuple_exercised)

        # Keep track of the final minset and its size.
        minset.append(candidate['path'])
        minsetsize += candidate['size']

        # We are now done with this tuple, we can get rid of it.
        del candidates[tuple_]

        print('\rProcessing tuple %d/%d...' % (
            len_uniq_tuples - len(remaining_tuples),
            len_uniq_tuples
        ), end=' ')

        # If we don't have any more tuples left, we are done.
        if len(remaining_tuples) == 0:
            break

    return minset, minsetsize


def do_unique_copy(filepaths, dest_dir):
    try:
        os.makedirs(dest_dir)
    except Exception:
        if not os.path.isdir(dest_dir):
            raise
    num_digits = len(str(len(filepaths)-1))
    for i, fpath in enumerate(filepaths):
        filename = os.path.basename(fpath)
        dest_path = os.path.join(dest_dir, 'id_' + str(i).zfill(num_digits) + "_" + filename)
        shutil.copy(fpath, dest_path)


def main(argc, argv):
    print('corpus minimization tool for WinAFL by <0vercl0k@tuxfamily.org>')
    print('Based on WinAFL by <ifratric@google.com>')
    print('Based on AFL by <lcamtuf@google.com>')

    logging.basicConfig(
        filename = 'winafl-cmin.log',
        level = logging.DEBUG,
        format = '%(asctime)s [%(levelname)-5.5s] [%(funcName)s] %(message)s'
    )

    args = setup_argparse()
    cli_handler = logging.StreamHandler(sys.stdout)
    cli_handler.setLevel(args.verbose)
    logging.getLogger().addHandler(cli_handler)

    # Interestingly enough, if the user uses '.. -- target.exe -option foo ..'
    # argparse will add '--' in the target_cmdline option, so we need to
    # strip it off manually here.
    if args.target_cmdline[0] == '--':
        del args.target_cmdline[0]

    logging.debug(
                    '[+] winafl-cmin launched with the following arguments: %s',
                    ' '.join(sys.argv)
                )

    if not validate_args(args):
        return 1

    os.chdir(args.working_dir)
    logging.info('[+] CWD changed to %s.', args.working_dir)
    if args.static_instr is True:
        logging.info('[+] Dynamorio-less mode is enabled.')

    # Go get all the input files we want to have a look at
    logging.debug(
        'Inspecting the following directories: %s',
        ', '.join(args.input)
    )
    inputs = []
    for path in args.input:
        for root, dirs, files in os.walk(path):
            for file_ in files:
                inputs.append(os.path.join(root, file_))

    if not inputs:
        logging.error('  Input directories do not contain any files!')
        return 1

    # Do a dry run with the first file in the set
    if not target_dry_run(args, inputs[0]):
        return 1

    t0 = time.time()
    uniq_tuples, candidates, effective_len, totalsize, crash_files, hang_files = run_all_inputs(args, inputs)

    logging.info('[*] Finding best candidates for each tuple...')

    minset, minsetsize = find_best_candidates(uniq_tuples, candidates)

    print()
    logging.info('[+] Original set was composed of %d files', len(inputs))
    logging.info(
        '[+] Effective set was composed of %d files (total size %.2f MB).',
        effective_len, (totalsize / 1024.) / 1024.
    )
    logging.info(
        '[+] Narrowed down to %d files (total size %.2f MB).',
        len(minset), (minsetsize / 1024.) / 1024.
    )

    if args.dry_run is False:
        logging.info(
            '[*] Saving the minset in %s...', os.path.abspath(args.output)
        )
        do_unique_copy(minset, args.output)

        if args.crash_dir and crash_files:
            logging.info(
                '[+] Saving %d crashing files to %s',
                len(crash_files), args.crash_dir
            )
            do_unique_copy(crash_files, args.crash_dir)

        if args.hang_dir and hang_files:
            logging.info(
                '[+] Saving %d hanging files to %s',
                len(hang_files), args.hang_dir
            )
            do_unique_copy(hang_files, args.hang_dir)

    logging.info('[+] Time elapsed: %d seconds', time.time() - t0)
    return 0


if __name__ == '__main__':
    sys.exit(main(len(sys.argv), sys.argv))

```

`winafl-plot.py`:

```py
import os
import argparse
import tempfile
import time
import subprocess
import re

FUZZER_STATS_RX = re.compile('([a-zA-Z_]+)\s+:\s+(.+?)\n')

TEMPLATE = r'''
<table style="font-family: 'Trebuchet MS', 'Tahoma', 'Arial', 'Helvetica'">
<tr><td style="width: 18ex"><b>Banner:</b></td><td>{banner}</td></tr>
<tr><td><b>Directory:</b></td><td>{fuzzer_dir}</td></tr>
<tr><td><b>Generated on:</b></td><td>{date}</td></tr>
</table>
<p>
<img src="high_freq.png" width=1000 height=300><p>
<img src="low_freq.png" width=1000 height=200><p>
<img src="exec_speed.png" width=1000 height=200>
'''.strip()

GNUPLOT_CMDS = '''
set terminal png truecolor enhanced size 1000,300 butt

set output '{outdir}/high_freq.png'

#set xdata time
#set timefmt '%s'
#set format x "%b %d\\n%H:%M"
set tics font 'small'
unset mxtics
unset mytics

set grid xtics linetype 0 linecolor rgb '#e0e0e0'
set grid ytics linetype 0 linecolor rgb '#e0e0e0'
set border linecolor rgb '#50c0f0'
set tics textcolor rgb '#000000'
set key outside

set autoscale xfixmin
set autoscale xfixmax

set xlabel "relative time in seconds" font "small"

plot '{fuzzer_dir}/plot_data' using 1:4 with filledcurve x1 title 'total paths' linecolor rgb '#000000' fillstyle transparent solid 0.2 noborder, \\
     '' using 1:3 with filledcurve x1 title 'current path' linecolor rgb '#f0f0f0' fillstyle transparent solid 0.5 noborder, \\
     '' using 1:5 with lines title 'pending paths' linecolor rgb '#0090ff' linewidth 3, \\
     '' using 1:6 with lines title 'pending favs' linecolor rgb '#c00080' linewidth 3, \\
     '' using 1:2 with lines title 'cycles done' linecolor rgb '#c000f0' linewidth 3

set terminal png truecolor enhanced size 1000,200 butt
set output '{outdir}/low_freq.png'

plot '{fuzzer_dir}/plot_data' using 1:8 with filledcurve x1 title '' linecolor rgb '#c00080' fillstyle transparent solid 0.2 noborder, \\
     '' using 1:8 with lines title ' uniq crashes' linecolor rgb '#c00080' linewidth 3, \\
     '' using 1:9 with lines title 'uniq hangs' linecolor rgb '#c000f0' linewidth 3, \\
     '' using 1:10 with lines title 'levels' linecolor rgb '#0090ff' linewidth 3

set terminal png truecolor enhanced size 1000,200 butt
set output '{outdir}/exec_speed.png'

plot '{fuzzer_dir}/plot_data' using 1:11 with filledcurve x1 title '' linecolor rgb '#0090ff' fillstyle transparent solid 0.2 noborder, \\
     '{fuzzer_dir}/plot_data' using 1:11 with lines title '    execs/sec' linecolor rgb '#0090ff' linewidth 3 smooth bezier;
'''


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('sync_dir', help='sync directory for afl')
    parser.add_argument('out_dir', help='output directory for plot')

    args = parser.parse_args()
    return args


def parse_fuzzer_stats(path):
    data = ''
    with open(path, 'rb') as f:
        data = f.read().decode('utf-8')

    stats = dict(FUZZER_STATS_RX.findall(data))

    # parse to int / float
    for key, value in stats.items():
        if not value.isdecimal():
            continue

        if not value.isnumeric():
            stats[key] = float(value)
            continue

        stats[key] = int(value)

    return stats


def main():
    args = parse_arguments()

    # get banner
    stats_path = os.path.join(args.sync_dir, 'fuzzer_stats')
    stats = parse_fuzzer_stats(stats_path)
    banner = stats['afl_banner']

    # format date in a compatible manner
    date = time.strftime('%a %b %d %H:%M:%S DST %Y', time.localtime())

    try:
        os.makedirs(args.out_dir)
    except OSError:
        pass

    # write html file
    index_html = os.path.join(args.out_dir, 'index.html')
    with open(index_html, 'wb') as f:
        f.write(TEMPLATE.format(outdir=args.out_dir,
                                fuzzer_dir=args.sync_dir,
                                date=date,
                                banner=banner).encode('utf-8'))

    tmp_file = tempfile.NamedTemporaryFile(delete=False)
    tmp_file.write(GNUPLOT_CMDS.format(outdir=args.out_dir,
                                       fuzzer_dir=args.sync_dir).encode('utf-8'))
    tmp_file.flush()

    # run gnuplot
    try:
        subprocess.check_output(['gnuplot', '-c', tmp_file.name])
    except subprocess.CalledProcessError as e:
        print("Error: failed to run gnuplot, output = {}".format(e))
    except OSError:
        print("Error: gnuplot was not found, make sure that gnuplot is installed and in PATH")

    try:
        os.unlink(tmp_file.name)
    except OSError:
        pass


if __name__ == '__main__':
    main()

```

`winafl-whatsup.py`:

```py
import os
import re
import sys
import glob
import ctypes
import argparse

FUZZER_STATS_RX = re.compile(r'([a-zA-Z_]+)\s+:\s+(.+?)\n')


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--summary', default=False, action='store_true',
                        help='skip all per-fuzzer trivia and show just the \
                        summary results.'
                        )
    parser.add_argument('afl_sync_dir', help='path to afl sync directory')

    args = parser.parse_args()
    return args


def get_cur_time():
    class FileTime(ctypes.Structure):
        _pack_ = 1
        _fields_ = [('dwLowDateTime', ctypes.c_uint32),
                    ('dwHighDateTime', ctypes.c_uint32)]

    file_time = FileTime()
    GetSystemTimeAsFileTime = ctypes.windll.kernel32.GetSystemTimeAsFileTime
    GetSystemTimeAsFileTime(ctypes.byref(file_time))

    ret = (file_time.dwHighDateTime << 32) + file_time.dwLowDateTime

    return ret / 10000000


def is_process_running(pid):
    # not very pythonic, but I didn't want to require external dependencies
    OpenProcess = ctypes.windll.kernel32.OpenProcess
    CloseHandle = ctypes.windll.kernel32.CloseHandle

    SYNCHRONIZE = 0x00100000
    process = OpenProcess(SYNCHRONIZE, False, ctypes.c_uint32(pid))
    if not process:
        return False

    CloseHandle(process)
    return True


def parse_fuzzer_stats(path):
    data = ''
    with open(path, 'rb') as f:
        data = f.read().decode('utf-8')

    stats = dict(FUZZER_STATS_RX.findall(data))

    # parse to int / float
    for key, value in stats.items():
        if not value.isdecimal():
            continue

        if not value.isnumeric():
            stats[key] = float(value)
            continue

        stats[key] = int(value)

    return stats


def main():
    args = parse_arguments()

    if not os.path.isdir(args.afl_sync_dir):
        print("error: {} is not a directory".format(args.afl_sync_dir))
        return 1

    if os.path.isdir(os.path.join(args.afl_sync_dir, 'queue')):
        print("[-] Error: parameter is an individual output directory, not a sync dir.")
        return 1

    print("status check tool for afl-fuzz by <lcamtuf@google.com>\n")

    verbose = not args.summary

    # stats for all fuzzers
    alive_count = 0
    dead_count = 0
    total_time = 0
    total_execs = 0
    total_eps = 0
    total_crashes = 0
    total_pfav = 0
    total_pending = 0

    if verbose:
        print("Individual fuzzers")
        print("==================\n")

    fuzzer_stats_path = os.path.join(args.afl_sync_dir, '*', 'fuzzer_stats')
    for stats_path in glob.glob(fuzzer_stats_path):
        try:
            stats = parse_fuzzer_stats(stats_path)

            start_time = stats['start_time']
            run_time = get_cur_time() - start_time
            run_days = int(((run_time / 60) / 60) / 24)
            run_hours = int((run_time / 60 / 60) % 24)

            if verbose:
                print(">>> {} ({} days, {} hours) <<<\n".
                      format(stats['afl_banner'], run_days, run_hours))

            if not is_process_running(stats['fuzzer_pid']):
                if verbose:
                    print("  Instance is dead_count or running remotely, skipping.\n")
                dead_count += 1
                continue

            alive_count += 1
            execs_done = stats['execs_done']
            exec_sec = float(execs_done) / run_time
            path_percent = (float(stats['cur_path']) * 100) / stats['paths_total']

            total_time += run_time
            total_eps += exec_sec
            total_execs += execs_done
            total_crashes += stats['unique_crashes']
            total_pending += stats['pending_total']
            total_pfav += stats['pending_favs']

            if verbose:
                print("  cycle {}, lifetime speed {:.2f} exec/sec, path {}/{} {:.2f}%".
                      format(stats['cycles_done'], exec_sec, stats['cur_path'],
                             stats['paths_total'], path_percent))

                if stats['unique_crashes'] == 0:
                    print("  pending {}/{}, coverage {}, no crashes yet".
                          format(stats['pending_favs'], stats['pending_total'],
                                 stats['bitmap_cvg']))
                else:
                    print("  pending {}/{}, coverage {}, crash count {} (!)".
                          format(stats['pending_favs'], stats['pending_total'],
                                 stats['bitmap_cvg'], stats['unique_crashes']))

                print("")
        except UnicodeDecodeError:
            print("error in parsing fuzzer_stat: {}, seems to be corrupt?".format(stats_path))
            continue

    total_days = int(total_time / 60 / 60 / 24)
    total_hours = int((total_time / 60 / 60) % 24)

    print("Summary stats")
    print("=============")
    print("")

    print("       Fuzzers alive : {}".format(alive_count))

    if dead_count > 0:
        print("      Dead or remote : {} (excluded from stats)".format(dead_count))

    print("      Total run time : {} days, {} hours".format(total_days, total_hours))
    print("         Total execs : {} million".format(int(total_execs / 1000 / 1000)))
    print("    Cumulative speed : {:.2f} execs/sec".format(total_eps))
    print("       Pending paths : {} faves, {} total".format(total_pfav, total_pending))
    if alive_count > 0:
        print("  Pending per fuzzer : {:.2f} faves, {:.2f} total (on average)".
              format(total_pfav / float(alive_count),
                     total_pending / float(alive_count)))

        print("       Crashes found : {} locally unique".format(total_crashes))

    print("")

    return 0


if __name__ == '__main__':
    sys.exit(main())

```

`winafl.c`:

```c
/*
   WinAFL - DynamoRIO client (instrumentation) code
   ------------------------------------------------

   Written and maintained by Ivan Fratric <ifratric@google.com>

   Copyright 2016 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

#define _CRT_SECURE_NO_WARNINGS

#define MAP_SIZE 65536

#include "dr_api.h"
#include "drmgr.h"
#include "drx.h"
#include "drreg.h"
#include "drwrap.h"

#ifdef USE_DRSYMS
#include "drsyms.h"
#endif

#include "modules.h"
#include "utils.h"
#include "hashtable.h"
#include "drtable.h"
#include "limits.h"
#include <string.h>
#include <stdlib.h>
#include <windows.h>

#define UNKNOWN_MODULE_ID USHRT_MAX

#ifndef PF_FASTFAIL_AVAILABLE
#define PF_FASTFAIL_AVAILABLE 23
#endif

#ifndef STATUS_FATAL_APP_EXIT
#define STATUS_FATAL_APP_EXIT ((DWORD)0x40000015L)
#endif

#ifndef STATUS_HEAP_CORRUPTION
#define STATUS_HEAP_CORRUPTION 0xC0000374
#endif

static uint verbose;

#define NOTIFY(level, fmt, ...) do {          \
    if (verbose >= (level))                   \
        dr_fprintf(STDERR, fmt, __VA_ARGS__); \
} while (0)

#define OPTION_MAX_LENGTH MAXIMUM_PATH

#define COVERAGE_BB 0
#define COVERAGE_EDGE 1

#ifndef INOUT
#define INOUT
#endif

//fuzz modes
enum persistence_mode_t { native_mode = 0,	in_app = 1,};

typedef struct _target_module_t {
    char module_name[MAXIMUM_PATH];
    struct _target_module_t *next;
} target_module_t;

typedef struct _winafl_option_t {
    /* Use nudge to notify the process for termination so that
     * event_exit will be called.
     */
    bool nudge_kills;
    bool debug_mode;
	  int persistence_mode;
    int coverage_kind;
    char logdir[MAXIMUM_PATH];
    target_module_t *target_modules;
    char fuzz_module[MAXIMUM_PATH];
    char fuzz_method[MAXIMUM_PATH];
    char pipe_name[MAXIMUM_PATH];
    char shm_name[MAXIMUM_PATH];
    unsigned long fuzz_offset;
    int fuzz_iterations;
    void **func_args;
    int num_fuz_args;
    drwrap_callconv_t callconv;
    bool thread_coverage;
    bool no_loop;
	bool dr_persist_cache;
} winafl_option_t;
static winafl_option_t options;

#define NUM_THREAD_MODULE_CACHE 4

typedef struct _winafl_data_t {
    module_entry_t *cache[NUM_THREAD_MODULE_CACHE];
    file_t  log;
    unsigned char *fake_afl_area; //used for thread_coverage
    unsigned char *afl_area;
} winafl_data_t;
static winafl_data_t winafl_data;

static int winafl_tls_field;

typedef struct _fuzz_target_t {
    reg_t xsp;            /* stack level at entry to the fuzz target */
    app_pc func_pc;
    int iteration;
} fuzz_target_t;
static fuzz_target_t fuzz_target;

typedef struct _debug_data_t {
    int pre_handler_called;
    int post_handler_called;
} debug_data_t;
static debug_data_t debug_data;

static module_table_t *module_table;
static client_id_t client_id;

static volatile bool go_native;

static void
event_exit(void);

static void
event_thread_exit(void *drcontext);

static HANDLE pipe;

/****************************************************************************
 * Nudges
 */

enum {
    NUDGE_TERMINATE_PROCESS = 1,
};

static void
event_nudge(void *drcontext, uint64 argument)
{
    int nudge_arg = (int)argument;
    int exit_arg  = (int)(argument >> 32);
    if (nudge_arg == NUDGE_TERMINATE_PROCESS) {
        static int nudge_term_count;
        /* handle multiple from both NtTerminateProcess and NtTerminateJobObject */
        uint count = dr_atomic_add32_return_sum(&nudge_term_count, 1);
        if (count == 1) {
            dr_exit_process(exit_arg);
        }
    }
    ASSERT(nudge_arg == NUDGE_TERMINATE_PROCESS, "unsupported nudge");
    ASSERT(false, "should not reach"); /* should not reach */
}

static bool
event_soft_kill(process_id_t pid, int exit_code)
{
    /* we pass [exit_code, NUDGE_TERMINATE_PROCESS] to target process */
    dr_config_status_t res;
    res = dr_nudge_client_ex(pid, client_id,
                             NUDGE_TERMINATE_PROCESS | (uint64)exit_code << 32,
                             0);
    if (res == DR_SUCCESS) {
        /* skip syscall since target will terminate itself */
        return true;
    }
    /* else failed b/c target not under DR control or maybe some other
     * error: let syscall go through
     */
    return false;
}

/****************************************************************************
 * Event Callbacks
 */

char ReadCommandFromPipe()
{
	DWORD num_read;
	char result;
	ReadFile(pipe, &result, 1, &num_read, NULL);
	return result;
}

void WriteCommandToPipe(char cmd)
{
	DWORD num_written;
	WriteFile(pipe, &cmd, 1, &num_written, NULL);
}

void WriteDWORDCommandToPipe(DWORD data)
{
	DWORD num_written;
	WriteFile(pipe, &data, sizeof(DWORD), &num_written, NULL);
}


static void
dump_winafl_data()
{
    dr_write_file(winafl_data.log, winafl_data.afl_area, MAP_SIZE);
}

static bool
onexception(void *drcontext, dr_exception_t *excpt) {
    DWORD exception_code = excpt->record->ExceptionCode;

    if(options.debug_mode)
        dr_fprintf(winafl_data.log, "Exception caught: %x\n", exception_code);

    if((exception_code == EXCEPTION_ACCESS_VIOLATION) ||
       (exception_code == EXCEPTION_ILLEGAL_INSTRUCTION) ||
       (exception_code == EXCEPTION_PRIV_INSTRUCTION) ||
       (exception_code == EXCEPTION_INT_DIVIDE_BY_ZERO) ||
       (exception_code == STATUS_HEAP_CORRUPTION) ||
       (exception_code == EXCEPTION_STACK_OVERFLOW) ||
       (exception_code == STATUS_STACK_BUFFER_OVERRUN) ||
       (exception_code == STATUS_FATAL_APP_EXIT)) {
            if(options.debug_mode) {
                dr_fprintf(winafl_data.log, "crashed\n");
            } else {
				WriteCommandToPipe('C');
				WriteDWORDCommandToPipe(exception_code);				
            }
            dr_exit_process(1);
    }
    return true;
}

static void event_thread_init(void *drcontext)
{
  void **thread_data;

  thread_data = (void **)dr_thread_alloc(drcontext, 2 * sizeof(void *));
  thread_data[0] = 0;
  if(options.thread_coverage) {
    thread_data[1] = winafl_data.fake_afl_area;
  } else {
    thread_data[1] = winafl_data.afl_area;
  }
  drmgr_set_tls_field(drcontext, winafl_tls_field, thread_data);
}

static void event_thread_exit(void *drcontext)
{
  void *data = drmgr_get_tls_field(drcontext, winafl_tls_field);
  dr_thread_free(drcontext, data, 2 * sizeof(void *));
}

static dr_emit_flags_t
instrument_bb_coverage(void *drcontext, void *tag, instrlist_t *bb, instr_t *inst,
                      bool for_trace, bool translating, void *user_data)
{
    static bool debug_information_output = false;
    app_pc start_pc;
    module_entry_t **mod_entry_cache;
    module_entry_t *mod_entry;
    const char *module_name;
    uint offset;
    target_module_t *target_modules;
    bool should_instrument;
    unsigned char *afl_map;
	dr_emit_flags_t ret;

    if (!drmgr_is_first_instr(drcontext, inst))
        return DR_EMIT_DEFAULT;

    start_pc = dr_fragment_app_pc(tag);

    mod_entry_cache = winafl_data.cache;
    mod_entry = module_table_lookup(mod_entry_cache,
                                                NUM_THREAD_MODULE_CACHE,
                                                module_table, start_pc);

    if (mod_entry == NULL || mod_entry->data == NULL) return DR_EMIT_DEFAULT;

    module_name = dr_module_preferred_name(mod_entry->data);

    should_instrument = false;
    target_modules = options.target_modules;
    while(target_modules) {
        if(_stricmp(module_name, target_modules->module_name) == 0) {
            should_instrument = true;
            if(options.debug_mode && debug_information_output == false) {
                dr_fprintf(winafl_data.log, "Instrumenting %s with the 'bb' mode\n", module_name);
                debug_information_output = true;
            }
            break;
        }
        target_modules = target_modules->next;
    }
    if(!should_instrument) return DR_EMIT_DEFAULT | DR_EMIT_PERSISTABLE;

    offset = (uint)(start_pc - mod_entry->data->start);
    offset &= MAP_SIZE - 1;

    afl_map = winafl_data.afl_area;

    drreg_reserve_aflags(drcontext, bb, inst);

    if(options.thread_coverage || options.dr_persist_cache) {
      reg_id_t reg;
      opnd_t opnd1, opnd2;
      instr_t *new_instr;

      drreg_reserve_register(drcontext, bb, inst, NULL, &reg);

      drmgr_insert_read_tls_field(drcontext, winafl_tls_field, bb, inst, reg);

      opnd1 = opnd_create_reg(reg);
      opnd2 = OPND_CREATE_MEMPTR(reg, sizeof(void *));
      new_instr = INSTR_CREATE_mov_ld(drcontext, opnd1, opnd2);
      instrlist_meta_preinsert(bb, inst, new_instr);

      opnd1 = OPND_CREATE_MEM8(reg, offset);
      new_instr = INSTR_CREATE_inc(drcontext, opnd1);
      instrlist_meta_preinsert(bb, inst, new_instr);

      drreg_unreserve_register(drcontext, bb, inst, reg);

	  ret = DR_EMIT_DEFAULT | DR_EMIT_PERSISTABLE;

	} else {

      instrlist_meta_preinsert(bb, inst,
          INSTR_CREATE_inc(drcontext, OPND_CREATE_ABSMEM
          (&(afl_map[offset]), OPSZ_1)));

	  ret = DR_EMIT_DEFAULT;
    }

    drreg_unreserve_aflags(drcontext, bb, inst);

    return ret;
}

static dr_emit_flags_t
instrument_edge_coverage(void *drcontext, void *tag, instrlist_t *bb, instr_t *inst,
                      bool for_trace, bool translating, void *user_data)
{
    static bool debug_information_output = false;
    app_pc start_pc;
    module_entry_t **mod_entry_cache;
    module_entry_t *mod_entry;
    reg_id_t reg, reg2, reg3;
    opnd_t opnd1, opnd2;
    instr_t *new_instr;
    const char *module_name;
    uint offset;
    target_module_t *target_modules;
    bool should_instrument;
	dr_emit_flags_t ret;

    if (!drmgr_is_first_instr(drcontext, inst))
        return DR_EMIT_DEFAULT;

    start_pc = dr_fragment_app_pc(tag);

    mod_entry_cache = winafl_data.cache;
    mod_entry = module_table_lookup(mod_entry_cache,
                                                NUM_THREAD_MODULE_CACHE,
                                                module_table, start_pc);

     if (mod_entry == NULL || mod_entry->data == NULL) return DR_EMIT_DEFAULT;

    module_name = dr_module_preferred_name(mod_entry->data);

    should_instrument = false;
    target_modules = options.target_modules;
    while(target_modules) {
        if(_stricmp(module_name, target_modules->module_name) == 0) {
            should_instrument = true;
            if(options.debug_mode && debug_information_output == false) {
                dr_fprintf(winafl_data.log, "Instrumenting %s with the 'edge' mode\n", module_name);
                debug_information_output = true;
            }
            break;
        }
        target_modules = target_modules->next;
    }
    if(!should_instrument) return DR_EMIT_DEFAULT | DR_EMIT_PERSISTABLE;

    offset = (uint)(start_pc - mod_entry->data->start);
    offset &= MAP_SIZE - 1;

    drreg_reserve_aflags(drcontext, bb, inst);
    drreg_reserve_register(drcontext, bb, inst, NULL, &reg);
    drreg_reserve_register(drcontext, bb, inst, NULL, &reg2);
    drreg_reserve_register(drcontext, bb, inst, NULL, &reg3);

    //reg2 stores AFL area, reg 3 stores previous offset

    //load the pointer to previous offset in reg3
    drmgr_insert_read_tls_field(drcontext, winafl_tls_field, bb, inst, reg3);

    //load address of shm into reg2
    if(options.thread_coverage || options.dr_persist_cache) {
      opnd1 = opnd_create_reg(reg2);
      opnd2 = OPND_CREATE_MEMPTR(reg3, sizeof(void *));
      new_instr = INSTR_CREATE_mov_ld(drcontext, opnd1, opnd2);
      instrlist_meta_preinsert(bb, inst, new_instr);

	  ret = DR_EMIT_DEFAULT | DR_EMIT_PERSISTABLE;

	} else {
      opnd1 = opnd_create_reg(reg2);
      opnd2 = OPND_CREATE_INTPTR((uint64)winafl_data.afl_area);
      new_instr = INSTR_CREATE_mov_imm(drcontext, opnd1, opnd2);
      instrlist_meta_preinsert(bb, inst, new_instr);

	  ret = DR_EMIT_DEFAULT;
    }

    //load previous offset into register
    opnd1 = opnd_create_reg(reg);
    opnd2 = OPND_CREATE_MEMPTR(reg3, 0);
    new_instr = INSTR_CREATE_mov_ld(drcontext, opnd1, opnd2);
    instrlist_meta_preinsert(bb, inst, new_instr);

    //xor register with the new offset
    opnd1 = opnd_create_reg(reg);
    opnd2 = OPND_CREATE_INT32(offset);
    new_instr = INSTR_CREATE_xor(drcontext, opnd1, opnd2);
    instrlist_meta_preinsert(bb, inst, new_instr);

    //increase the counter at reg + reg2
    opnd1 = opnd_create_base_disp(reg2, reg, 1, 0, OPSZ_1);
    new_instr = INSTR_CREATE_inc(drcontext, opnd1);
    instrlist_meta_preinsert(bb, inst, new_instr);

    //store the new value
    offset = (offset >> 1)&(MAP_SIZE - 1);
    opnd1 = OPND_CREATE_MEMPTR(reg3, 0);
    opnd2 = OPND_CREATE_INT32(offset);
    new_instr = INSTR_CREATE_mov_st(drcontext, opnd1, opnd2);
    instrlist_meta_preinsert(bb, inst, new_instr);

    drreg_unreserve_register(drcontext, bb, inst, reg3);
    drreg_unreserve_register(drcontext, bb, inst, reg2);
    drreg_unreserve_register(drcontext, bb, inst, reg);
    drreg_unreserve_aflags(drcontext, bb, inst);

    return ret;
}

static void
pre_loop_start_handler(void *wrapcxt, INOUT void **user_data)
{
	void *drcontext = drwrap_get_drcontext(wrapcxt);

	if (!options.debug_mode) {
		//let server know we finished a cycle, redundunt on first cycle.
		WriteCommandToPipe('K');

		if (fuzz_target.iteration == options.fuzz_iterations) {
			dr_exit_process(0);
		}
		fuzz_target.iteration++;

		//let server know we are starting a new cycle
		WriteCommandToPipe('P'); 

		//wait for server acknowledgement for cycle start
		char command = ReadCommandFromPipe(); 

		if (command != 'F') {
			if (command == 'Q') {
				dr_exit_process(0);
			}
			else {
				char errorMessage[] = "unrecognized command received over pipe: ";
				errorMessage[sizeof(errorMessage)-2] = command;
				DR_ASSERT_MSG(false, errorMessage);
			}
		}
	}
	else {
		debug_data.pre_handler_called++;
		dr_fprintf(winafl_data.log, "In pre_loop_start_handler: %d\n", debug_data.pre_handler_called);
	}

	memset(winafl_data.afl_area, 0, MAP_SIZE);

	if (options.coverage_kind == COVERAGE_EDGE || options.thread_coverage) {
		void **thread_data = (void **)drmgr_get_tls_field(drcontext, winafl_tls_field);
		thread_data[0] = 0;
		thread_data[1] = winafl_data.afl_area;
	}
}

static void
pre_fuzz_handler(void *wrapcxt, INOUT void **user_data)
{
    char command = 0;
    int i;
    void *drcontext;

    app_pc target_to_fuzz = drwrap_get_func(wrapcxt);
    dr_mcontext_t *mc = drwrap_get_mcontext_ex(wrapcxt, DR_MC_ALL);
    drcontext = drwrap_get_drcontext(wrapcxt);

    fuzz_target.xsp = mc->xsp;
    fuzz_target.func_pc = target_to_fuzz;

    if(!options.debug_mode) {
		WriteCommandToPipe('P');
		command = ReadCommandFromPipe();

        if(command != 'F') {
            if(command == 'Q') {
                dr_exit_process(0);
            } else {
                DR_ASSERT_MSG(false, "unrecognized command received over pipe");
            }
        }
    } else {
        debug_data.pre_handler_called++;
        dr_fprintf(winafl_data.log, "In pre_fuzz_handler\n");
    }

    //save or restore arguments
    if (!options.no_loop) {
        if (fuzz_target.iteration == 0) {
            for (i = 0; i < options.num_fuz_args; i++)
                options.func_args[i] = drwrap_get_arg(wrapcxt, i);
        } else {
            for (i = 0; i < options.num_fuz_args; i++)
                drwrap_set_arg(wrapcxt, i, options.func_args[i]);
        }
    }

    memset(winafl_data.afl_area, 0, MAP_SIZE);

    if(options.coverage_kind == COVERAGE_EDGE || options.thread_coverage) {
        void **thread_data = (void **)drmgr_get_tls_field(drcontext, winafl_tls_field);
        thread_data[0] = 0;
        thread_data[1] = winafl_data.afl_area;
    }
}

static void
post_fuzz_handler(void *wrapcxt, void *user_data)
{
    dr_mcontext_t *mc;
    void *drcontext;
    mc = drwrap_get_mcontext(wrapcxt);

    if(options.no_loop && (options.coverage_kind == COVERAGE_EDGE || options.thread_coverage)) {
        // no_loo and thread_coverage are enabled.
        // It is possible that the thread will return to a thread queue
        // in which case it can later call other functions than the target.
        // Therefore, coverage measurement must be stopped for this thread.
        drcontext = drwrap_get_drcontext(wrapcxt);
        void **thread_data = (void **)drmgr_get_tls_field(drcontext, winafl_tls_field);
        thread_data[1] = winafl_data.fake_afl_area;
    }


    if(!options.debug_mode) {
		WriteCommandToPipe('K');
    } else {
        debug_data.post_handler_called++;
        dr_fprintf(winafl_data.log, "In post_fuzz_handler\n");
    }

    /* We don't need to reload context in case of network-based fuzzing. */
    if (options.no_loop)
        return;

    fuzz_target.iteration++;
    if(fuzz_target.iteration == options.fuzz_iterations) {
        dr_exit_process(0);
    }

    mc->xsp = fuzz_target.xsp;
    mc->pc = fuzz_target.func_pc;
	drwrap_redirect_execution(wrapcxt);
}

static void
createfilew_interceptor(void *wrapcxt, INOUT void **user_data)
{
    wchar_t *filenamew = (wchar_t *)drwrap_get_arg(wrapcxt, 0);
    if(options.debug_mode)
        dr_fprintf(winafl_data.log, "In OpenFileW, reading %ls\n", filenamew);
}

static void
createfilea_interceptor(void *wrapcxt, INOUT void **user_data)
{
    char *filename = (char *)drwrap_get_arg(wrapcxt, 0);
    if(options.debug_mode)
        dr_fprintf(winafl_data.log, "In OpenFileA, reading %s\n", filename);
}

static void
verfierstopmessage_interceptor_pre(void *wrapctx, INOUT void **user_data)
{
    EXCEPTION_RECORD exception_record = { 0 };
    dr_exception_t dr_exception = { 0 };
    dr_exception.record = &exception_record;
    exception_record.ExceptionCode = STATUS_HEAP_CORRUPTION;

    onexception(NULL, &dr_exception);
}

static void
recvfrom_interceptor(void *wrapcxt, INOUT void **user_data)
{
    if (options.debug_mode)
        dr_fprintf(winafl_data.log, "In recvfrom\n");
}

static void
recv_interceptor(void *wrapcxt, INOUT void **user_data)
{
    if (options.debug_mode)
        dr_fprintf(winafl_data.log, "In recv\n");
}

static void
isprocessorfeaturepresent_interceptor_pre(void *wrapcxt, INOUT void **user_data)
{
    DWORD feature = (DWORD)drwrap_get_arg(wrapcxt, 0);
    *user_data = (void*)feature;
}

static void
isprocessorfeaturepresent_interceptor_post(void *wrapcxt, void *user_data)
{
    DWORD feature = (DWORD)user_data;
    if(feature == PF_FASTFAIL_AVAILABLE) {
        if(options.debug_mode) {
            dr_fprintf(winafl_data.log, "About to make IsProcessorFeaturePresent(%d) returns 0\n", feature);
        }

        // Make the software thinks that _fastfail() is not supported.
        drwrap_set_retval(wrapcxt, (void*)0);
    }
}

static void
unhandledexceptionfilter_interceptor_pre(void *wrapcxt, INOUT void **user_data)
{
    PEXCEPTION_POINTERS exception = (PEXCEPTION_POINTERS)drwrap_get_arg(wrapcxt, 0);
    dr_exception_t dr_exception = { 0 };

    // Fake an exception
    dr_exception.record = exception->ExceptionRecord;
    onexception(NULL, &dr_exception);
}

static void
event_module_unload(void *drcontext, const module_data_t *info)
{
    module_table_unload(module_table, info);
}

static void
event_module_load(void *drcontext, const module_data_t *info, bool loaded)
{
    const char *module_name = info->names.exe_name;
    app_pc to_wrap = 0;

    if (module_name == NULL) {
        // In case exe_name is not defined, we will fall back on the preferred name.
        module_name = dr_module_preferred_name(info);
    }

    if(options.debug_mode)
        dr_fprintf(winafl_data.log, "Module loaded, %s\n", module_name);

    if(options.fuzz_module[0]) {
        if(_stricmp(module_name, options.fuzz_module) == 0) {
            if(options.fuzz_offset) {
                to_wrap = info->start + options.fuzz_offset;
            } else {
                //first try exported symbols
                to_wrap = (app_pc)dr_get_proc_address(info->handle, options.fuzz_method);
                if(!to_wrap) {
                    //if that fails, try with the symbol access library
#ifdef USE_DRSYMS
                    drsym_init(0);
                    drsym_lookup_symbol(info->full_path, options.fuzz_method, (size_t *)(&to_wrap), 0);
                    drsym_exit();
#endif
                    DR_ASSERT_MSG(to_wrap, "Can't find specified method in target_module");
                    to_wrap += (size_t)info->start;
                }
            }
			if (options.persistence_mode == native_mode)
			{
				drwrap_wrap_ex(to_wrap, pre_fuzz_handler, post_fuzz_handler, NULL, options.callconv);
			}
			if (options.persistence_mode == in_app)
			{
				drwrap_wrap_ex(to_wrap, pre_loop_start_handler, NULL, NULL, options.callconv);
			}
        }

        if (options.debug_mode && (_stricmp(module_name, "WS2_32.dll") == 0)) {
            to_wrap = (app_pc)dr_get_proc_address(info->handle, "recvfrom");
            bool result = drwrap_wrap(to_wrap, recvfrom_interceptor, NULL);
            to_wrap = (app_pc)dr_get_proc_address(info->handle, "recv");
            result = drwrap_wrap(to_wrap, recv_interceptor, NULL);
        }

        if(options.debug_mode && (_stricmp(module_name, "KERNEL32.dll") == 0)) {
            to_wrap = (app_pc)dr_get_proc_address(info->handle, "CreateFileW");
            drwrap_wrap(to_wrap, createfilew_interceptor, NULL);
            to_wrap = (app_pc)dr_get_proc_address(info->handle, "CreateFileA");
            drwrap_wrap(to_wrap, createfilea_interceptor, NULL);
        }

        if(_stricmp(module_name, "kernelbase.dll") == 0) {
            // Since Win8, software can use _fastfail() to trigger an exception that cannot be caught.
            // This is a problem for winafl as it also means DR won't be able to see it. Good thing is that
            // usually those routines (__report_gsfailure for example) accounts for platforms that don't
            // have support for fastfail. In those cases, they craft an exception record and pass it
            // to UnhandledExceptionFilter.
            //
            // To work around this we set up two hooks:
            //   (1) IsProcessorFeaturePresent(PF_FASTFAIL_AVAILABLE): to lie and pretend that the
            //       platform doesn't support fastfail.
            //   (2) UnhandledExceptionFilter: to intercept the exception record and forward it
            //       to winafl's exception handler.
            to_wrap = (app_pc)dr_get_proc_address(info->handle, "IsProcessorFeaturePresent");
            drwrap_wrap(to_wrap, isprocessorfeaturepresent_interceptor_pre, isprocessorfeaturepresent_interceptor_post);
            to_wrap = (app_pc)dr_get_proc_address(info->handle, "UnhandledExceptionFilter");
            drwrap_wrap(to_wrap, unhandledexceptionfilter_interceptor_pre, NULL);
        }
    }

    if (_stricmp(module_name, "verifier.dll") == 0) {
        to_wrap = (app_pc)dr_get_proc_address(info->handle, "VerifierStopMessage");
        drwrap_wrap(to_wrap, verfierstopmessage_interceptor_pre, NULL);
    }

    module_table_load(module_table, info);
}

static void
event_exit(void)
{
    if(options.debug_mode) {
        if(debug_data.pre_handler_called == 0) {
            dr_fprintf(winafl_data.log, "WARNING: Target function was never called. Incorrect target_offset?\n");
        } else if(debug_data.post_handler_called == 0 && options.persistence_mode != in_app) {
            dr_fprintf(winafl_data.log, "WARNING: Post-fuzz handler was never reached. Did the target function return normally?\n");
        } else if(debug_data.pre_handler_called == 1 && options.persistence_mode == in_app) {
            dr_fprintf(winafl_data.log, "WARNING: Only hit pre_loop_start_handler once, Is your target function in a loop?\n");
        } else {
            dr_fprintf(winafl_data.log, "Everything appears to be running normally.\n");
        }

        dr_fprintf(winafl_data.log, "Coverage map follows:\n");
        dump_winafl_data();
        dr_close_file(winafl_data.log);
    }

    /* destroy module table */
    module_table_destroy(module_table);

    drx_exit();
    drmgr_exit();
}

static void
event_init(void)
{
    char buf[MAXIMUM_PATH];

    module_table = module_table_create();

    memset(winafl_data.cache, 0, sizeof(winafl_data.cache));
    memset(winafl_data.afl_area, 0, MAP_SIZE);

    if(options.debug_mode) {
        debug_data.pre_handler_called = 0;
        debug_data.post_handler_called = 0;

        winafl_data.log =
            drx_open_unique_appid_file(options.logdir, dr_get_process_id(),
                                   "afl", "proc.log",
                                   DR_FILE_ALLOW_LARGE,
                                   buf, BUFFER_SIZE_ELEMENTS(buf));
        if (winafl_data.log != INVALID_FILE) {
            dr_log(NULL, LOG_ALL, 1, "winafl: log file is %s\n", buf);
            NOTIFY(1, "<created log file %s>\n", buf);
        }
    }

    fuzz_target.iteration = 0;
}


static void
setup_pipe() {
    pipe = CreateFile(
         options.pipe_name,   // pipe name
         GENERIC_READ |  // read and write access
         GENERIC_WRITE,
         0,              // no sharing
         NULL,           // default security attributes
         OPEN_EXISTING,  // opens existing pipe
         0,              // default attributes
         NULL);          // no template file

    if (pipe == INVALID_HANDLE_VALUE) DR_ASSERT_MSG(false, "error connecting to pipe");
}

static void
setup_shmem() {
   HANDLE map_file;

   map_file = OpenFileMapping(
                   FILE_MAP_ALL_ACCESS,   // read/write access
                   FALSE,                 // do not inherit the name
                   options.shm_name);            // name of mapping object

   if (map_file == NULL) DR_ASSERT_MSG(false, "error accesing shared memory");

   winafl_data.afl_area = (unsigned char *) MapViewOfFile(map_file, // handle to map object
               FILE_MAP_ALL_ACCESS,  // read/write permission
               0,
               0,
               MAP_SIZE);

   if (winafl_data.afl_area == NULL) DR_ASSERT_MSG(false, "error accesing shared memory");
}

static void
options_init(client_id_t id, int argc, const char *argv[])
{
    int i;
    const char *token;
    target_module_t *target_modules;
    /* default values */
	options.persistence_mode = native_mode;
    options.nudge_kills = true;
    options.debug_mode = false;
    options.thread_coverage = false;
    options.coverage_kind = COVERAGE_BB;
    options.target_modules = NULL;
    options.fuzz_module[0] = 0;
    options.fuzz_method[0] = 0;
    options.fuzz_offset = 0;
    options.fuzz_iterations = 1000;
    options.no_loop = false;
    options.func_args = NULL;
    options.num_fuz_args = 0;
    options.callconv = DRWRAP_CALLCONV_DEFAULT;
	options.dr_persist_cache = false;
    dr_snprintf(options.logdir, BUFFER_SIZE_ELEMENTS(options.logdir), ".");

    strcpy(options.pipe_name, "\\\\.\\pipe\\afl_pipe_default");
    strcpy(options.shm_name, "afl_shm_default");

    for (i = 1/*skip client*/; i < argc; i++) {
        token = argv[i];
        if (strcmp(token, "-no_nudge_kills") == 0)
            options.nudge_kills = false;
        else if (strcmp(token, "-nudge_kills") == 0)
            options.nudge_kills = true;
        else if (strcmp(token, "-thread_coverage") == 0)
            options.thread_coverage = true;
        else if (strcmp(token, "-debug") == 0)
            options.debug_mode = true;
        else if (strcmp(token, "-logdir") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing logdir path");
            strncpy(options.logdir, argv[++i], BUFFER_SIZE_ELEMENTS(options.logdir));
        }
        else if (strcmp(token, "-fuzzer_id") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing fuzzer id");
            strcpy(options.pipe_name, "\\\\.\\pipe\\afl_pipe_");
            strcpy(options.shm_name, "afl_shm_");
            strcat(options.pipe_name, argv[i+1]);
            strcat(options.shm_name, argv[i+1]);
            i++;
        }
        else if (strcmp(token, "-covtype") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing coverage type");
            token = argv[++i];
            if(strcmp(token, "bb")==0) options.coverage_kind = COVERAGE_BB;
            else if (strcmp(token, "edge")==0) options.coverage_kind = COVERAGE_EDGE;
            else USAGE_CHECK(false, "invalid coverage type");
        }
        else if (strcmp(token, "-coverage_module") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing module");
            target_modules = options.target_modules;
            options.target_modules = (target_module_t *)dr_global_alloc(sizeof(target_module_t));
            options.target_modules->next = target_modules;
            strncpy(options.target_modules->module_name, argv[++i], BUFFER_SIZE_ELEMENTS(options.target_modules->module_name));
        }
        else if (strcmp(token, "-target_module") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing module");
            strncpy(options.fuzz_module, argv[++i], BUFFER_SIZE_ELEMENTS(options.fuzz_module));
        }
        else if (strcmp(token, "-target_method") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing method");
            strncpy(options.fuzz_method, argv[++i], BUFFER_SIZE_ELEMENTS(options.fuzz_method));
        }
        else if (strcmp(token, "-fuzz_iterations") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing number of iterations");
            options.fuzz_iterations = atoi(argv[++i]);
        }
        else if (strcmp(token, "-nargs") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing number of arguments");
            options.num_fuz_args = atoi(argv[++i]);
        }
        else if (strcmp(token, "-target_offset") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing offset");
            options.fuzz_offset = strtoul(argv[++i], NULL, 0);
        }
        else if (strcmp(token, "-verbose") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing -verbose number");
            token = argv[++i];
            if (dr_sscanf(token, "%u", &verbose) != 1) {
                USAGE_CHECK(false, "invalid -verbose number");
            }
        }
        else if (strcmp(token, "-call_convention") == 0) {
            USAGE_CHECK((i + 1) < argc, "missing calling convention");
            ++i;
            if (strcmp(argv[i], "stdcall") == 0)
                options.callconv = DRWRAP_CALLCONV_CDECL;
            else if (strcmp(argv[i], "fastcall") == 0)
                options.callconv = DRWRAP_CALLCONV_FASTCALL;
            else if (strcmp(argv[i], "thiscall") == 0)
                options.callconv = DRWRAP_CALLCONV_THISCALL;
            else if (strcmp(argv[i], "ms64") == 0)
                options.callconv = DRWRAP_CALLCONV_MICROSOFT_X64;
            else
                NOTIFY(0, "Unknown calling convention, using default value instead.\n");
		}
		else if (strcmp(token, "-no_loop") == 0) {
			options.no_loop = true;
		}
		else if (strcmp(token, "-drpersist") == 0) {
			options.dr_persist_cache = true;
		}
		else if (strcmp(token, "-persistence_mode") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing mode arg: '-fuzz_mode' arg");
			const char* mode = argv[++i];
			if (strcmp(mode, "in_app") == 0)
			{
				options.persistence_mode = in_app;
			}
			else
			{
				options.persistence_mode = native_mode;
			}
		}
        else {
            NOTIFY(0, "UNRECOGNIZED OPTION: \"%s\"\n", token);
            USAGE_CHECK(false, "invalid option");
        }
    }

    if(options.fuzz_module[0] && (options.fuzz_offset == 0) && (options.fuzz_method[0] == 0)) {
       USAGE_CHECK(false, "If target_module is specified, then either target_method or target_offset must be as well");
    }

    if(options.num_fuz_args) {
        options.func_args = (void **)dr_global_alloc(options.num_fuz_args * sizeof(void *));
    }
}

DR_EXPORT void
dr_client_main(client_id_t id, int argc, const char *argv[])
{
    drreg_options_t ops = {sizeof(ops), 2 /*max slots needed: aflags*/, false};

    dr_set_client_name("WinAFL", "https://github.com/googleprojectzero/winafl/issues");

    drmgr_init();
    drx_init();
    drreg_init(&ops);
    drwrap_init();

    options_init(id, argc, argv);

    drmgr_register_exit_event(event_exit);

    drmgr_register_exception_event(onexception);

    if(options.coverage_kind == COVERAGE_BB) {
        drmgr_register_bb_instrumentation_event(NULL, instrument_bb_coverage, NULL);
    } else if(options.coverage_kind == COVERAGE_EDGE) {
        drmgr_register_bb_instrumentation_event(NULL, instrument_edge_coverage, NULL);
    }

    drmgr_register_module_load_event(event_module_load);
    drmgr_register_module_unload_event(event_module_unload);
    dr_register_nudge_event(event_nudge, id);

    client_id = id;

    if (options.nudge_kills)
        drx_register_soft_kills(event_soft_kill);

    if(options.thread_coverage) {
        winafl_data.fake_afl_area = (unsigned char *)dr_global_alloc(MAP_SIZE);
    }

    if(!options.debug_mode) {
        setup_pipe();
        setup_shmem();
    } else {
        winafl_data.afl_area = (unsigned char *)dr_global_alloc(MAP_SIZE);
    }

    if(options.coverage_kind == COVERAGE_EDGE || options.thread_coverage || options.dr_persist_cache) {
        winafl_tls_field = drmgr_register_tls_field();
        if(winafl_tls_field == -1) {
            DR_ASSERT_MSG(false, "error reserving TLS field");
        }
        drmgr_register_thread_init_event(event_thread_init);
        drmgr_register_thread_exit_event(event_thread_exit);
    }

    event_init();
}

```

`winaflpt-debug.c`:

```c
#include <stdio.h>
#include <stdbool.h>
#include <direct.h>
#include "windows.h"

#include "types.h"
#include "config.h"
#include "debug.h"
#include "alloc-inl.h"

#include "winaflpt.h"

u8 *trace_bits;

u8 sinkhole_stds = 0;
u64 mem_limit = 0;
u64 cpu_aff = 0;

// todo the below functions are copied from afl-fuzz.c
// they should be taken out to a separate file to avoid duplication

u64 get_cur_time(void) {

	u64 ret;
	FILETIME filetime;
	GetSystemTimeAsFileTime(&filetime);

	ret = (((u64)filetime.dwHighDateTime) << 32) + (u64)filetime.dwLowDateTime;

	return ret / 10000;

}

//quoting on Windows is weird
size_t ArgvQuote(char *in, char *out) {
	int needs_quoting = 0;
	size_t size = 0;
	char *p = in;
	size_t i;

	//check if quoting is necessary
	if (strchr(in, ' ')) needs_quoting = 1;
	if (strchr(in, '\"')) needs_quoting = 1;
	if (strchr(in, '\t')) needs_quoting = 1;
	if (strchr(in, '\n')) needs_quoting = 1;
	if (strchr(in, '\v')) needs_quoting = 1;
	if (!needs_quoting) {
		size = strlen(in);
		if (out) memcpy(out, in, size);
		return size;
	}

	if (out) out[size] = '\"';
	size++;

	while (*p) {
		size_t num_backslashes = 0;
		while ((*p) && (*p == '\\')) {
			p++;
			num_backslashes++;
		}

		if (*p == 0) {
			for (i = 0; i < (num_backslashes * 2); i++) {
				if (out) out[size] = '\\';
				size++;
			}
			break;
		}
		else if (*p == '\"') {
			for (i = 0; i < (num_backslashes * 2 + 1); i++) {
				if (out) out[size] = '\\';
				size++;
			}
			if (out) out[size] = *p;
			size++;
		}
		else {
			for (i = 0; i < num_backslashes; i++) {
				if (out) out[size] = '\\';
				size++;
			}
			if (out) out[size] = *p;
			size++;
		}

		p++;
	}

	if (out) out[size] = '\"';
	size++;

	return size;
}


char *argv_to_cmd(char** argv) {
	u32 len = 0, i;
	u8* buf, *ret;

	//todo shell-escape

	for (i = 0; argv[i]; i++)
		len += ArgvQuote(argv[i], NULL) + 1;

	if (!len) FATAL("Error creating command line");

	buf = ret = ck_alloc(len);

	for (i = 0; argv[i]; i++) {

		u32 l = ArgvQuote(argv[i], buf);

		buf += l;

		*(buf++) = ' ';
	}

	ret[len - 1] = 0;

	return ret;
}


int main(int argc, char **argv)
{
	_mkdir(".\\ptmodules");
	int target_opt_ind = pt_init(argc, argv, ".\\ptmodules");
	if (!target_opt_ind) {
		printf("Usage: %s <instrumentation-options> -- <target command line>\n", argv[0]);
		return 0;
	}

	debug_target_pt(argv + target_opt_ind + 1);

	return 0;
}

```

`winaflpt.c`:

```c
/*
  WinAFL - Intel PT instrumentation and presistence via debugger code 
  ------------------------------------------------

  Written and maintained by Ivan Fratric <ifratric@google.com>

  Copyright 2016 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

#define  _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdbool.h>
#include "windows.h"
#include "psapi.h"
#include "dbghelp.h"

#include "libipt.h"
#include "ipttool.h"

#include "intel-pt.h"

#include "types.h"
#include "config.h"
#include "debug.h"
#include "alloc-inl.h"

#include "winaflpt.h"

#include "ptdecode.h"

// tests the custom decoders gainst the corresponding
// reference implementatopns from Intel
// used only for debugging
// #define DECODER_CORRECTNESS_TEST

u64 get_cur_time(void);
char *argv_to_cmd(char** argv);

#define CALLCONV_MICROSOFT_X64 0
#define CALLCONV_THISCALL 1
#define CALLCONV_FASTCALL 2
#define CALLCONV_CDECL 3
#define CALLCONV_DEFAULT 4

#define BREAKPOINT_UNKNOWN 0
#define BREAKPOINT_ENTRYPOINT 1
#define BREAKPOINT_MODULELOADED 2
#define BREAKPOINT_FUZZMETHOD 3

#define WINAFL_LOOP_EXCEPTION 0x0AF1

#define DEBUGGER_PROCESS_EXIT 0
#define DEBUGGER_FUZZMETHOD_REACHED 1
#define DEBUGGER_FUZZMETHOD_END 2
#define DEBUGGER_CRASHED 3
#define DEBUGGER_HANGED 4

#define DECODER_TIP_FAST 0
#define DECODER_TIP_REFERENCE 1
#define DECODER_FULL_FAST 2
#define DECODER_FULL_REFERENCE 3

static HANDLE child_handle, child_thread_handle;
static HANDLE devnul_handle = INVALID_HANDLE_VALUE;
static int fuzz_iterations_current;

static DWORD fuzz_thread_id;

static DEBUG_EVENT dbg_debug_event;
static DWORD dbg_continue_status;
static bool dbg_continue_needed;
static uint64_t dbg_timeout_time;

static bool child_entrypoint_reached;

static unsigned char *trace_buffer;
static size_t trace_size;

extern u8 *trace_bits;

extern HANDLE child_handle, child_thread_handle;
extern int fuzz_iterations_current;

extern HANDLE devnul_handle;
extern u8 sinkhole_stds;

extern u64 mem_limit;
extern u64 cpu_aff;

extern char *fuzzer_id;

static FILE *debug_log = NULL;

static struct pt_image_section_cache *section_cache;
static char section_cache_dir[MAX_PATH];

static int wow64_target = 0;
static size_t child_ptr_size = sizeof(void *);

address_range* coverage_ip_ranges = NULL;
size_t num_ip_ranges = 0;
static bool need_build_ranges = true;

static size_t last_ring_buffer_offset = 0;

#define USAGE_CHECK(condition, message) if(!(condition)) FATAL("%s\n", message);

enum {
	/* 00 */ FAULT_NONE,
	/* 01 */ FAULT_TMOUT,
	/* 02 */ FAULT_CRASH,
	/* 03 */ FAULT_ERROR,
	/* 04 */ FAULT_NOINST,
	/* 05 */ FAULT_NOBITS
};

typedef struct _module_info_t {
	char module_name[MAX_PATH];
	int isid;
	void *base;
	size_t size;
	struct _module_info_t *next;
} module_info_t;

static module_info_t *all_modules = NULL;

typedef struct _winafl_option_t {
	bool debug_mode;
	int coverage_kind;
	module_info_t *coverage_modules;
	char fuzz_module[MAX_PATH];
	char fuzz_method[MAX_PATH];
	unsigned long fuzz_offset;
	int fuzz_iterations;
	int num_fuz_args;
	int callconv;
	int decoder;
	bool thread_coverage;
	unsigned long trace_buffer_size;
	unsigned long trace_cache_size;
	bool persistent_trace;

	void **func_args;
	void *sp;
	void *fuzz_address;
} winafl_option_t;
static winafl_option_t options;

struct winafl_breakpoint {
	void *address;
	int type;
	unsigned char original_opcode;
	char module_name[MAX_PATH];
	void *module_base;
	struct winafl_breakpoint *next;
};
struct winafl_breakpoint *breakpoints;

static void
winaflpt_options_init(int argc, const char *argv[])
{
	int i;
	const char *token;
	module_info_t *coverage_modules;
	/* default values */
	options.debug_mode = false;
	options.coverage_kind = COVERAGE_BB;
	options.coverage_modules = NULL;
	options.fuzz_module[0] = 0;
	options.fuzz_method[0] = 0;
	options.fuzz_offset = 0;
	options.fuzz_iterations = 1000;
	options.func_args = NULL;
	options.num_fuz_args = 0;
	options.thread_coverage = true;
	options.callconv = CALLCONV_DEFAULT;
	options.decoder = DECODER_FULL_FAST;
	options.trace_buffer_size = TRACE_BUFFER_SIZE_DEFAULT;
	options.trace_cache_size = 0;
	options.persistent_trace = true;

	for (i = 0; i < argc; i++) {
		token = argv[i];
		if (strcmp(token, "-thread_coverage") == 0)
			options.thread_coverage = true;
		else if (strcmp(token, "-debug") == 0)
			options.debug_mode = true;
		else if (strcmp(token, "-nopersistent_trace") == 0)
			options.persistent_trace = false;
		else if (strcmp(token, "-covtype") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing coverage type");
			token = argv[++i];
			if (strcmp(token, "bb") == 0) options.coverage_kind = COVERAGE_BB;
			else if (strcmp(token, "edge") == 0) options.coverage_kind = COVERAGE_EDGE;
			else USAGE_CHECK(false, "invalid coverage type");
		}
		else if (strcmp(token, "-coverage_module") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing module");
			coverage_modules = options.coverage_modules;
			options.coverage_modules = (module_info_t *)malloc(sizeof(module_info_t));
			options.coverage_modules->next = coverage_modules;
			options.coverage_modules->isid = 0;
			options.coverage_modules->base = NULL;
			options.coverage_modules->size = 0;
			strncpy(options.coverage_modules->module_name, argv[++i], MAX_PATH);
		}
		else if (strcmp(token, "-target_module") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing module");
			strncpy(options.fuzz_module, argv[++i], MAX_PATH);
		}
		else if (strcmp(token, "-target_method") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing method");
			strncpy(options.fuzz_method, argv[++i], MAX_PATH);
		}
		else if (strcmp(token, "-fuzz_iterations") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing number of iterations");
			options.fuzz_iterations = atoi(argv[++i]);
		}
		else if (strcmp(token, "-nargs") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing number of arguments");
			options.num_fuz_args = atoi(argv[++i]);
		}
		else if (strcmp(token, "-target_offset") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing offset");
			options.fuzz_offset = strtoul(argv[++i], NULL, 0);
		}
		else if (strcmp(token, "-trace_size") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing trace size");
			options.trace_buffer_size = strtoul(argv[++i], NULL, 0);
		}
		else if (strcmp(token, "-trace_cache_size") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing trace cache size");
			options.trace_cache_size = strtoul(argv[++i], NULL, 0);
		}
		else if (strcmp(token, "-call_convention") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing calling convention");
			++i;
			if (strcmp(argv[i], "stdcall") == 0)
				options.callconv = CALLCONV_CDECL;
			else if (strcmp(argv[i], "fastcall") == 0)
				options.callconv = CALLCONV_FASTCALL;
			else if (strcmp(argv[i], "thiscall") == 0)
				options.callconv = CALLCONV_THISCALL;
			else if (strcmp(argv[i], "ms64") == 0)
				options.callconv = CALLCONV_MICROSOFT_X64;
			else
				FATAL("Unknown calling convention");
		} else if (strcmp(token, "-decoder") == 0) {
			USAGE_CHECK((i + 1) < argc, "missing decoder");
			++i;
			if (strcmp(argv[i], "tip") == 0)
				options.decoder = DECODER_TIP_FAST;
			else if (strcmp(argv[i], "tip_ref") == 0)
				options.decoder = DECODER_TIP_REFERENCE;
			else if (strcmp(argv[i], "full") == 0)
				options.decoder = DECODER_FULL_FAST;
			else if (strcmp(argv[i], "full_ref") == 0)
				options.decoder = DECODER_FULL_REFERENCE;
			else
				FATAL("Unknown decoder value");
		} else {
			FATAL("UNRECOGNIZED OPTION: \"%s\"\n", token);
		}
	}

	if (options.fuzz_module[0] && (options.fuzz_offset == 0) && (options.fuzz_method[0] == 0)) {
		FATAL("If fuzz_module is specified, then either fuzz_method or fuzz_offset must be as well");
	}

	if (options.num_fuz_args) {
		options.func_args = (void **)malloc(options.num_fuz_args * sizeof(void *));
	}
}

int address_range_compare(const void * a, const void * b) {
	if (((address_range *)a)->start >= ((address_range *)b)->start) return 1;
	else return -1;
}

void build_address_ranges() {
	int num_loaded_modules;
	module_info_t *current_module;

	if (coverage_ip_ranges) free(coverage_ip_ranges);

	if (!options.coverage_modules) {
		num_ip_ranges = 1;
		coverage_ip_ranges = (address_range*)malloc(num_ip_ranges * sizeof(address_range));
		coverage_ip_ranges[0].start = 0;
		coverage_ip_ranges[0].end = 0xFFFFFFFFFFFFFFFFULL;
		coverage_ip_ranges[0].collect = 1;
		return;
	}
	
	// count loaded modules
	num_loaded_modules = 0;
	current_module = options.coverage_modules;
	while (current_module) {
		if (current_module->size > 0) {
			num_loaded_modules++;
		}
		current_module = current_module->next;
	}

	address_range* tmp_buf = (address_range*)malloc(num_loaded_modules * sizeof(address_range));

	num_loaded_modules = 0;
	current_module = options.coverage_modules;
	while (current_module) {
		if (current_module->size > 0) {
			tmp_buf[num_loaded_modules].start = (uint64_t)current_module->base;
			tmp_buf[num_loaded_modules].end = (uint64_t)current_module->base + current_module->size - 1;
			tmp_buf[num_loaded_modules].collect = 1;
			num_loaded_modules++;
		}
		current_module = current_module->next;
	}

	qsort(tmp_buf, num_loaded_modules, sizeof(address_range), address_range_compare);

	num_ip_ranges = (size_t)num_loaded_modules * 2 + 1;
	coverage_ip_ranges = (address_range*)malloc(num_ip_ranges * sizeof(address_range));

	uint64_t current_address = 0;
	for (int i = 0; i < num_loaded_modules; i++) {
		coverage_ip_ranges[2 * i].start = current_address;
		coverage_ip_ranges[2 * i].end = tmp_buf[i].start - 1;
		coverage_ip_ranges[2 * i].collect = 0;
		coverage_ip_ranges[2 * i + 1] = tmp_buf[i];
		current_address = tmp_buf[i].end + 1;
	}
	coverage_ip_ranges[2 * num_loaded_modules].start = current_address;
	coverage_ip_ranges[2 * num_loaded_modules].end = 0xFFFFFFFFFFFFFFFFULL;
	coverage_ip_ranges[2 * num_loaded_modules].collect = 0;

	free(tmp_buf);
}

// appends new data to the trace_buffer
void append_trace_data(unsigned char *trace_data, size_t append_size) {
	size_t space_left = options.trace_buffer_size - trace_size;

	if (!space_left) {
		// stop collecting trace if the trace buffer is full;
		printf("Warning: Trace buffer is full\n");
		return;
	}

	if (append_size > space_left) {
		append_size = space_left;
	}

	if (append_size == 0) return;

	memcpy(trace_buffer + trace_size, trace_data, append_size);
	trace_size += append_size;
}


// returns true if the ring buffer was overflowed
bool collect_thread_trace(PIPT_TRACE_HEADER traceHeader) {
	// printf("ring offset: %u\n", traceHeader->RingBufferOffset);

	bool trace_buffer_overflow = false;

	unsigned char psb_and_psbend[] = {
		0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,
		0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,
		0x02, 0x23
	};

	trace_size = 0;

	if (options.persistent_trace) {

		// an ugly hack: trace might not start with a psb (synchronization) packet
		// so we are just adding one. This assumes the state has been properly
		// flushed when a breakpoint between two iterations has been hit
		// which does appear to be the case. However, if this doesn't occur
		// persistent tracing will not work properly
		append_trace_data(psb_and_psbend, sizeof(psb_and_psbend));

		// first, optimistically assume the buffer didn't overflow
		if (traceHeader->RingBufferOffset > last_ring_buffer_offset) {
			append_trace_data(traceHeader->Trace + last_ring_buffer_offset, traceHeader->RingBufferOffset - last_ring_buffer_offset);
		}
		else if (traceHeader->RingBufferOffset < last_ring_buffer_offset) {
			append_trace_data(traceHeader->Trace + last_ring_buffer_offset, traceHeader->TraceSize - last_ring_buffer_offset);
			append_trace_data(traceHeader->Trace, traceHeader->RingBufferOffset);
		}

		if (!check_trace_start(trace_buffer, trace_size, (uint64_t)options.fuzz_address)) {
			// most likely the ring buffer overflowd, extract what we can (trace tail)

			trace_size = 0;
			trace_buffer_overflow = true;

			printf("Warning: Trace buffer overflowed, trace will be truncated\n");
			if (options.debug_mode) fprintf(debug_log, "Trace buffer overflowed, trace will be truncated\n");

			char *trailing_data = traceHeader->Trace + traceHeader->RingBufferOffset;
			size_t trailing_size = traceHeader->TraceSize - traceHeader->RingBufferOffset;
			append_trace_data(trailing_data, trailing_size);

			append_trace_data(traceHeader->Trace, traceHeader->RingBufferOffset);

		}

		last_ring_buffer_offset = traceHeader->RingBufferOffset;

	} else {

		// check if the trace buffer overflowed

		char *trailing_data = traceHeader->Trace + traceHeader->RingBufferOffset;
		size_t trailing_size = traceHeader->TraceSize - traceHeader->RingBufferOffset;
		if (findpsb(&trailing_data, &trailing_size)) {
			trace_buffer_overflow = true;
			printf("Warning: Trace buffer overflowed, trace will be truncated\n");
			if (options.debug_mode) fprintf(debug_log, "Trace buffer overflowed, trace will be truncated\n");
			append_trace_data(trailing_data, trailing_size);
		}

		append_trace_data(traceHeader->Trace, traceHeader->RingBufferOffset);
	}

	return trace_buffer_overflow;
}

// parse PIPT_TRACE_DATA, extract trace bits and add them to the trace_buffer
// returns true if the trace ring buffer overflowed
bool collect_trace(PIPT_TRACE_DATA pTraceData)
{
	bool trace_buffer_overflow = false;

	PIPT_TRACE_HEADER traceHeader;
	DWORD dwTraceSize;

	dwTraceSize = pTraceData->TraceSize;

	traceHeader = (PIPT_TRACE_HEADER)pTraceData->TraceData;

	while (dwTraceSize > (unsigned)(FIELD_OFFSET(IPT_TRACE_HEADER, Trace))) {
		if (traceHeader->ThreadId == fuzz_thread_id) {
			trace_buffer_overflow = collect_thread_trace(traceHeader);
		}

		dwTraceSize -= (FIELD_OFFSET(IPT_TRACE_HEADER, Trace) + traceHeader->TraceSize);

		traceHeader = (PIPT_TRACE_HEADER)(traceHeader->Trace +
			traceHeader->TraceSize);
	}

	return trace_buffer_overflow;
}

// returns an array of handles for all modules loaded in the target process
DWORD get_all_modules(HMODULE **modules) {
	DWORD module_handle_storage_size = 1024 * sizeof(HMODULE);
	HMODULE *module_handles = (HMODULE *)malloc(module_handle_storage_size);
	DWORD hmodules_size;
	while (true) {
		if (!EnumProcessModulesEx(child_handle, module_handles, module_handle_storage_size, &hmodules_size, LIST_MODULES_ALL)) {
			FATAL("EnumProcessModules failed, %x\n", GetLastError());
		}
		if (hmodules_size <= module_handle_storage_size) break;
		module_handle_storage_size *= 2;
		module_handles = (HMODULE *)realloc(module_handles, module_handle_storage_size);
	}
	*modules = module_handles;
	return hmodules_size / sizeof(HMODULE);
}

// parses PE headers and gets the module entypoint
void *get_entrypoint(void *base_address) {
	unsigned char headers[4096];
	size_t num_read = 0;
	if (!ReadProcessMemory(child_handle, base_address, headers, 4096, &num_read) || (num_read != 4096)) {
		FATAL("Error reading target memory\n");
	}
	DWORD pe_offset;
	pe_offset = *((DWORD *)(headers + 0x3C));
	char *pe = headers + pe_offset;
	DWORD signature = *((DWORD *)pe);
	if (signature != 0x00004550) {
		FATAL("PE signature error\n");
	}
	pe = pe + 0x18;
	WORD magic = *((WORD *)pe);
	if ((magic != 0x10b) && (magic != 0x20b)) {
		FATAL("Unknown PE magic value\n");
	} 
	DWORD entrypoint_offset = *((DWORD *)(pe + 16));
	if (entrypoint_offset == 0) return NULL;
	return (char *)base_address + entrypoint_offset;
}

// adds a breakpoint at a specified address
// type, module_name and module_base are all additional information
// that can be accessed later when the breakpoint gets hit
void add_breakpoint(void *address, int type, char *module_name, void *module_base) {
	struct winafl_breakpoint *new_breakpoint = (struct winafl_breakpoint *)malloc(sizeof(struct winafl_breakpoint));
	size_t rwsize = 0;
	if(!ReadProcessMemory(child_handle, address, &(new_breakpoint->original_opcode), 1, &rwsize) || (rwsize != 1)) {
		FATAL("Error reading target memory\n");
	}
	rwsize = 0;	
	unsigned char cc = 0xCC;
	if (!WriteProcessMemory(child_handle, address, &cc, 1, &rwsize) || (rwsize != 1)) {
		FATAL("Error writing target memory\n");
	}
	FlushInstructionCache(child_handle, address, 1);
	new_breakpoint->address = address;
	new_breakpoint->type = type;
	if (module_name) {
		strcpy(new_breakpoint->module_name, module_name);
	} else {
		new_breakpoint->module_name[0] = 0;
	}
	new_breakpoint->module_base = module_base;
	new_breakpoint->next = breakpoints;
	breakpoints = new_breakpoint;
}


// damn it Windows, why don't you have a GetProcAddress
// that works on another process
DWORD get_proc_offset(char *data, char *name) {
	DWORD pe_offset;
	pe_offset = *((DWORD *)(data + 0x3C));
	char *pe = data + pe_offset;
	DWORD signature = *((DWORD *)pe);
	if (signature != 0x00004550) {
		return 0;
	}
	pe = pe + 0x18;
	WORD magic = *((WORD *)pe);
	DWORD exporttableoffset;
	if (magic == 0x10b) {
		exporttableoffset = *(DWORD *)(pe + 96);
	} else if (magic == 0x20b) {
		exporttableoffset = *(DWORD *)(pe + 112);
	} else {
		return 0;
	}

	if (!exporttableoffset) return 0;
	char *exporttable = data + exporttableoffset;

	DWORD numentries = *(DWORD *)(exporttable + 24);
	DWORD addresstableoffset = *(DWORD *)(exporttable + 28);
	DWORD nameptrtableoffset = *(DWORD *)(exporttable + 32);
	DWORD ordinaltableoffset = *(DWORD *)(exporttable + 36);
	DWORD *nameptrtable = (DWORD *)(data + nameptrtableoffset);
	WORD *ordinaltable = (WORD *)(data + ordinaltableoffset);
	DWORD *addresstable = (DWORD *)(data + addresstableoffset);

	DWORD i;
	for (i = 0; i < numentries; i++) {
		char *nameptr = data + nameptrtable[i];
		if (strcmp(name, nameptr) == 0) break;
	}

	if (i == numentries) return 0;

	WORD oridnal = ordinaltable[i];
	DWORD offset = addresstable[oridnal];

	return offset;
}

// attempt to obtain the fuzz_offset in various ways
char *get_fuzz_method_offset(HMODULE module) {
	MODULEINFO module_info;
	GetModuleInformation(child_handle, module, &module_info, sizeof(module_info));

	// if fuzz_offset is defined, use that
	if (options.fuzz_offset) {
		return (char *)module_info.lpBaseOfDll + options.fuzz_offset;
	}

	// try the exported symbols next
	BYTE *modulebuf = (BYTE *)malloc(module_info.SizeOfImage);
	size_t num_read;
	if (!ReadProcessMemory(child_handle, module_info.lpBaseOfDll, modulebuf, module_info.SizeOfImage, &num_read) || (num_read != module_info.SizeOfImage)) {
		FATAL("Error reading target memory\n");
	}
	DWORD fuzz_offset = get_proc_offset(modulebuf, options.fuzz_method);
	free(modulebuf);
	if (fuzz_offset) {
		return (char *)module + fuzz_offset;
	}

	// finally, try the debug symbols
	char *fuzz_method = NULL;
	char base_name[MAX_PATH];
	GetModuleBaseNameA(child_handle, module, (LPSTR)(&base_name), sizeof(base_name));

	char module_path[MAX_PATH];
	if(!GetModuleFileNameExA(child_handle, module, module_path, sizeof(module_path))) return NULL;
	
	ULONG64 buffer[(sizeof(SYMBOL_INFO) +
		MAX_SYM_NAME * sizeof(TCHAR) +
		sizeof(ULONG64) - 1) /
		sizeof(ULONG64)];
	PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;
	pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
	pSymbol->MaxNameLen = MAX_SYM_NAME;
	SymInitialize(child_handle, NULL, false);
	DWORD64 sym_base_address = SymLoadModuleEx(child_handle, NULL, module_path, NULL, 0, 0, NULL, 0);
	if (SymFromName(child_handle, options.fuzz_method, pSymbol)) {
		options.fuzz_offset = (unsigned long)(pSymbol->Address - sym_base_address);
		fuzz_method = (char *)module_info.lpBaseOfDll + options.fuzz_offset;
	}
	SymCleanup(child_handle);

	return fuzz_method;
}

// should we collect coverage for this module
module_info_t *is_coverage_module(char *module_name) {
	module_info_t *current_module = options.coverage_modules;
	while (current_module) {
		if (_stricmp(module_name, current_module->module_name) == 0) {
			return current_module;
		}
		current_module = current_module->next;
	}
	return NULL;
}

// check if the same module was already loaded
module_info_t *get_loaded_module(char *module_name, void *base) {
	module_info_t *current_module = all_modules;
	while (current_module) {
		if (_stricmp(module_name, current_module->module_name) == 0) {
			if (base == NULL || base == current_module->base) {
				return current_module;
			}
		}
		current_module = current_module->next;
	}
	return NULL;
}

// find if there is a *different* module that previously occupied
// the same space
module_info_t *get_intersecting_module(char *module_name, void *base, DWORD size) {
	module_info_t *current_module = all_modules;
	while (current_module) {
		if (((uint64_t)current_module->base + current_module->size <= (uint64_t)base) || 
			((uint64_t)base + size <= (uint64_t)current_module->base)) {
			current_module = current_module->next;
			continue;
		}
		return current_module;
	}
	return NULL;
}


void on_coverage_module_loaded(HMODULE module, module_info_t *target_module) {
	MODULEINFO module_info;
	GetModuleInformation(child_handle, module, &module_info, sizeof(module_info));

	target_module->base = module_info.lpBaseOfDll;
	target_module->size = module_info.SizeOfImage;

	need_build_ranges = true;
}

size_t ReadProcessMemory_tolerant(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize) {
	LPCVOID end_address = (char *)lpBaseAddress + nSize;
	LPCVOID cur_address = lpBaseAddress;
	MEMORY_BASIC_INFORMATION meminfobuf;
	size_t size_read;
	size_t total_size_read = 0;

	while (cur_address < end_address) {
		size_t ret = VirtualQueryEx(hProcess, (LPCVOID)cur_address, &meminfobuf, sizeof(MEMORY_BASIC_INFORMATION));
		if (!ret) break;

		size_t offset = (size_t)meminfobuf.BaseAddress - (size_t)lpBaseAddress;
		size_t to_read = meminfobuf.RegionSize;
		if ((offset + to_read) > nSize) {
			to_read = nSize - offset;
		}

		if (ReadProcessMemory(child_handle, meminfobuf.BaseAddress, (char *)lpBuffer + offset, to_read, &size_read)) {
			total_size_read += size_read;
		}

		cur_address = (char *)meminfobuf.BaseAddress + meminfobuf.RegionSize;
	}

	return total_size_read;
}

void add_module_to_section_cache(HMODULE module, char *module_name) {
	module_info_t *loaded_module;
	MODULEINFO module_info;
	GetModuleInformation(child_handle, module, &module_info, sizeof(module_info));

	// handle the case where module was loaded previously
	loaded_module = get_loaded_module(module_name, module_info.lpBaseOfDll);
	if (loaded_module) {
		// same module loaded on the same address, skip
		return;
	}

	// this will *probably* never happen but check for it anyway
	loaded_module = get_intersecting_module(module_name, module_info.lpBaseOfDll, module_info.SizeOfImage);
	if (loaded_module) {
		FATAL("Module %s loaded in the address range that module %s previously occupied. This is currently unsupported.",
			module_name, loaded_module->module_name);
	}

	loaded_module = (module_info_t *)malloc(sizeof(module_info_t));
	strcpy(loaded_module->module_name, module_name);
	loaded_module->base = module_info.lpBaseOfDll;
	loaded_module->size = module_info.SizeOfImage;

	// todo put these files in a separate directory and clean it periodically
	char tmpfilename[MAX_PATH];
	sprintf(tmpfilename, "%s\\sectioncache_%p.dat", section_cache_dir, module_info.lpBaseOfDll);

	BYTE *modulebuf = (BYTE *)malloc(module_info.SizeOfImage);
	size_t num_read;
	if (!ReadProcessMemory(child_handle, module_info.lpBaseOfDll, modulebuf, module_info.SizeOfImage, &num_read) || (num_read != module_info.SizeOfImage)) {
		if (!ReadProcessMemory_tolerant(child_handle, module_info.lpBaseOfDll, modulebuf, module_info.SizeOfImage)) {
			FATAL("Error reading memory for module %s", module_name);
		}
	}

	// this is pretty horrible, writing a file only to be read again
	// but libipt only supports reading sections from file, not memory
	FILE *fp = fopen(tmpfilename, "wb");
	if (!fp) {
		FATAL("Error opening image cache file.");
	}
	fwrite(modulebuf, 1, module_info.SizeOfImage, fp);
	fclose(fp);

	loaded_module->isid = pt_iscache_add_file(section_cache, tmpfilename, 0, module_info.SizeOfImage, (uint64_t)module_info.lpBaseOfDll);

	free(modulebuf);

	if (loaded_module->isid <= 0) {
		FATAL("Error adding file to pt cache.");
	}

	loaded_module->next = all_modules;
	all_modules = loaded_module;
}

// called when a potentialy interesting module gets loaded
void on_module_loaded(HMODULE module, char *module_name) {
	MODULEINFO module_info;
	GetModuleInformation(child_handle, module, &module_info, sizeof(module_info));
	// printf("In on_module_loaded, name: %s, base: %p\n", module_name, module_info.lpBaseOfDll);

	module_info_t *coverage_module = is_coverage_module(module_name);
	if (coverage_module) {
		on_coverage_module_loaded(module, coverage_module);
	}

	if (options.decoder == DECODER_FULL_FAST || options.decoder == DECODER_FULL_REFERENCE) {
		add_module_to_section_cache(module, module_name);
	}

	if (_stricmp(module_name, options.fuzz_module) == 0) {
		char * fuzz_address = get_fuzz_method_offset(module);
		if (!fuzz_address) {
			FATAL("Error determining target method address\n");
		}

		// printf("Fuzz method address: %p\n", fuzz_address);
		options.fuzz_address = fuzz_address;

		add_breakpoint(fuzz_address, BREAKPOINT_FUZZMETHOD, NULL, 0);
	}
}

void read_stack(void *stack_addr, void **buffer, size_t numitems) {
	size_t numrw = 0;
#ifdef _WIN64
	if (wow64_target) {
		uint32_t *buf32 = (uint32_t *)malloc(numitems * child_ptr_size);
		ReadProcessMemory(child_handle, stack_addr, buf32, numitems * child_ptr_size, &numrw);
		for (size_t i = 0; i < numitems; i++) {
			buffer[i] = (void *)((size_t)buf32[i]);
		}
		free(buf32);
		return;
	}
#endif
	ReadProcessMemory(child_handle, stack_addr, buffer, numitems * child_ptr_size, &numrw);
}

void write_stack(void *stack_addr, void **buffer, size_t numitems) {
	size_t numrw = 0;
#ifdef _WIN64
	if (wow64_target) {
		uint32_t *buf32 = (uint32_t *)malloc(numitems * child_ptr_size);
		for (size_t i = 0; i < numitems; i++) {
			buf32[i] = (uint32_t)((size_t)buffer[i]);
		}
		WriteProcessMemory(child_handle, stack_addr, buf32, numitems * child_ptr_size, &numrw);
		free(buf32);
		return;
	}
#endif
	WriteProcessMemory(child_handle, stack_addr, buffer, numitems * child_ptr_size, &numrw);
}

// called when the target method is called *for the first time only*
void on_target_method(DWORD thread_id) {
	// printf("in OnTargetMethod\n");

	fuzz_thread_id = thread_id;

	size_t numrw = 0;

	CONTEXT lcContext;
	lcContext.ContextFlags = CONTEXT_ALL;
	HANDLE thread_handle = OpenThread(THREAD_ALL_ACCESS, FALSE, thread_id);
	GetThreadContext(thread_handle, &lcContext);

	// read out and save the params
#ifdef _WIN64
	options.sp = (void *)lcContext.Rsp;
#else
	options.sp = (void *)lcContext.Esp;
#endif

	switch (options.callconv) {
#ifdef _WIN64
	case CALLCONV_DEFAULT:
	case CALLCONV_MICROSOFT_X64:
		if (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Rcx;
		if (options.num_fuz_args > 1) options.func_args[1] = (void *)lcContext.Rdx;
		if (options.num_fuz_args > 2) options.func_args[2] = (void *)lcContext.R8;
		if (options.num_fuz_args > 3) options.func_args[3] = (void *)lcContext.R9;
		if (options.num_fuz_args > 4) {
			read_stack((void *)(lcContext.Rsp + 5 * child_ptr_size), options.func_args + 4, options.num_fuz_args - 4);
		}
		break;
	case CALLCONV_CDECL:
		if (options.num_fuz_args > 0) {
			read_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args, options.num_fuz_args);
		}
		break;
	case CALLCONV_FASTCALL:
		if (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Rcx;
		if (options.num_fuz_args > 1) options.func_args[1] = (void *)lcContext.Rdx;
		if (options.num_fuz_args > 3) {
			read_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args + 2, options.num_fuz_args - 2);
		}
		break;
	case CALLCONV_THISCALL:
		if (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Rcx;
		if (options.num_fuz_args > 3) {
			read_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args + 1, options.num_fuz_args - 1);
		}
		break;
#else
	case CALLCONV_MICROSOFT_X64:
		FATAL("X64 callong convention not supported for 32-bit targets");
		break;
	case CALLCONV_DEFAULT:
	case CALLCONV_CDECL:
		if (options.num_fuz_args > 0) {
			read_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args, options.num_fuz_args);
		}
		break;
	case CALLCONV_FASTCALL:
		if (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Ecx;
		if (options.num_fuz_args > 1) options.func_args[1] = (void *)lcContext.Edx;
		if (options.num_fuz_args > 3) {
			read_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args + 2, options.num_fuz_args - 2);
		}
		break;
	case CALLCONV_THISCALL:
		if (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Ecx;
		if (options.num_fuz_args > 3) {
			read_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args + 1, options.num_fuz_args - 1);
		}
		break;
#endif
	default:
		break;
	}

	// todo store any target-specific additional context here

	// modify the return address on the stack so that an exception is triggered
	// when the target function finishes executing
	// another option would be to allocate a block of executable memory
	// and point return address over there, but this is quicker
	size_t return_address = WINAFL_LOOP_EXCEPTION;
	WriteProcessMemory(child_handle, options.sp, &return_address, child_ptr_size, &numrw);

	CloseHandle(thread_handle);
}

// called every time the target method returns
void on_target_method_ended(DWORD thread_id) {
	// printf("in OnTargetMethodEnded\n");

	CONTEXT lcContext;
	lcContext.ContextFlags = CONTEXT_ALL;
	HANDLE thread_handle = OpenThread(THREAD_ALL_ACCESS, FALSE, thread_id);
	GetThreadContext(thread_handle, &lcContext);

	// restore params
#ifdef _WIN64
	lcContext.Rip = (size_t)options.fuzz_address;
	lcContext.Rsp = (size_t)options.sp;
#else
	lcContext.Eip = (size_t)options.fuzz_address;
	lcContext.Esp = (size_t)options.sp;
#endif

	switch (options.callconv) {
#ifdef _WIN64
	case CALLCONV_DEFAULT:
	case CALLCONV_MICROSOFT_X64:
		if (options.num_fuz_args > 0) lcContext.Rcx = (size_t)options.func_args[0];
		if (options.num_fuz_args > 1) lcContext.Rdx = (size_t)options.func_args[1];
		if (options.num_fuz_args > 2) lcContext.R8 = (size_t)options.func_args[2];
		if (options.num_fuz_args > 3) lcContext.R9 = (size_t)options.func_args[3];
		if (options.num_fuz_args > 4) {
			write_stack((void *)(lcContext.Rsp + 5 * child_ptr_size), options.func_args + 4, options.num_fuz_args - 4);
		}
		break;
	case CALLCONV_CDECL:
		if (options.num_fuz_args > 0) {
			write_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args, options.num_fuz_args);
	}
		break;
	case CALLCONV_FASTCALL:
		if (options.num_fuz_args > 0) lcContext.Rcx = (size_t)options.func_args[0];
		if (options.num_fuz_args > 1) lcContext.Rdx = (size_t)options.func_args[1];
		if (options.num_fuz_args > 3) {
			write_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args + 2, options.num_fuz_args - 2);
		}
		break;
	case CALLCONV_THISCALL:
		if (options.num_fuz_args > 0) lcContext.Rcx = (size_t)options.func_args[0];
		if (options.num_fuz_args > 3) {
			write_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args + 1, options.num_fuz_args - 1);
		}
		break;
#else
	case CALLCONV_MICROSOFT_X64:
		FATAL("X64 callong convention not supported for 32-bit targets");
		break;
	case CALLCONV_DEFAULT:
	case CALLCONV_CDECL:
		if (options.num_fuz_args > 0) {
			write_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args, options.num_fuz_args);
		}
		break;
	case CALLCONV_FASTCALL:
		if (options.num_fuz_args > 0) lcContext.Ecx = (size_t)options.func_args[0];
		if (options.num_fuz_args > 1) lcContext.Edx = (size_t)options.func_args[1];
		if (options.num_fuz_args > 3) {
			write_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args + 2, options.num_fuz_args - 2);
		}
		break;
	case CALLCONV_THISCALL:
		if (options.num_fuz_args > 0) lcContext.Ecx = (size_t)options.func_args[0];
		if (options.num_fuz_args > 3) {
			write_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args + 1, options.num_fuz_args - 1);
		}
		break;
#endif
	default:
		break;
	}

	// todo restore any target-specific additional context here

	SetThreadContext(thread_handle, &lcContext);
	CloseHandle(thread_handle);
}

// called when process entrypoint gets reached
void on_entrypoint() {
	// printf("Entrypoint\n");

	HMODULE *module_handles = NULL;
	DWORD num_modules = get_all_modules(&module_handles);
	for (DWORD i = 0; i < num_modules; i++) {
		char base_name[MAX_PATH];
		GetModuleBaseNameA(child_handle, module_handles[i], (LPSTR)(&base_name), sizeof(base_name));
		if(options.debug_mode) fprintf(debug_log, "Module loaded: %s\n", base_name);
		on_module_loaded(module_handles[i], base_name);
	}
	if(module_handles) free(module_handles);

	child_entrypoint_reached = true;
}

// called when the debugger hits a breakpoint
int handle_breakpoint(void *address, DWORD thread_id) {
	int ret = BREAKPOINT_UNKNOWN;
	size_t rwsize = 0;
	struct winafl_breakpoint *previous = NULL;
	struct winafl_breakpoint *current = breakpoints;
	while (current) {
		if (current->address == address) {
			// unlink the breakpoint
			if (previous) previous->next = current->next;
			else breakpoints = current->next;
			// restore address
			if (!WriteProcessMemory(child_handle, address, &current->original_opcode, 1, &rwsize) || (rwsize != 1)) {
				FATAL("Error writing child memory\n");
			}
			FlushInstructionCache(child_handle, address, 1);
			// restore context
			CONTEXT lcContext;
			lcContext.ContextFlags = CONTEXT_ALL;
			HANDLE thread_handle = OpenThread(THREAD_ALL_ACCESS, FALSE, thread_id);
			GetThreadContext(thread_handle, &lcContext);
#ifdef _WIN64
			lcContext.Rip--;
#else
			lcContext.Eip--;
#endif
			SetThreadContext(thread_handle, &lcContext);
			CloseHandle(thread_handle);
			// handle breakpoint
			switch (current->type) {
			case BREAKPOINT_ENTRYPOINT:
				on_entrypoint();
				break;
			case BREAKPOINT_MODULELOADED:
				on_module_loaded((HMODULE)current->module_base, current->module_name);
				break;
			case BREAKPOINT_FUZZMETHOD:
				on_target_method(thread_id);
				break;
			default:
				break;
			}
			// return the brekpoint type
			ret = current->type;
			// delete the breakpoint object
			free(current);
			//done
			break;
		}
		previous = current;
		current = current->next;
	}
	return ret;
}

// standard debugger loop that listens to relevant events in the target process
int debug_loop()
{
	bool alive = true;

	LPDEBUG_EVENT DebugEv = &dbg_debug_event;

	while(alive)
	{

		BOOL wait_ret = WaitForDebugEvent(DebugEv, 100);

		// printf("time: %lld\n", get_cur_time_us());

		if (wait_ret) {
			dbg_continue_needed = true;
		} else {
			dbg_continue_needed = false;
		}

		if (get_cur_time() > dbg_timeout_time) return DEBUGGER_HANGED;

		if (!wait_ret) {
			//printf("WaitForDebugEvent returned 0\n");
			continue;
		}

		dbg_continue_status = DBG_CONTINUE;

		// printf("eventCode: %x\n", DebugEv->dwDebugEventCode);

		switch (DebugEv->dwDebugEventCode)
		{
		case EXCEPTION_DEBUG_EVENT:
			// printf("exception code: %x\n", DebugEv->u.Exception.ExceptionRecord.ExceptionCode);

			switch (DebugEv->u.Exception.ExceptionRecord.ExceptionCode)
			{
			case EXCEPTION_BREAKPOINT:
			case 0x4000001f: //STATUS_WX86_BREAKPOINT
			{
				void *address = DebugEv->u.Exception.ExceptionRecord.ExceptionAddress;
				// printf("Breakpoint at address %p\n", address);
				int breakpoint_type = handle_breakpoint(address, DebugEv->dwThreadId);
				if (breakpoint_type == BREAKPOINT_UNKNOWN) {
					dbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;
				} else if (breakpoint_type == BREAKPOINT_FUZZMETHOD) {
					dbg_continue_status = DBG_CONTINUE;
					return DEBUGGER_FUZZMETHOD_REACHED;
				} else {
					dbg_continue_status = DBG_CONTINUE;
				}
				break;
			}

			case EXCEPTION_ACCESS_VIOLATION: {
				if ((size_t)DebugEv->u.Exception.ExceptionRecord.ExceptionAddress == WINAFL_LOOP_EXCEPTION) {
					on_target_method_ended(DebugEv->dwThreadId);
					dbg_continue_status = DBG_CONTINUE;
					return DEBUGGER_FUZZMETHOD_END;
				} else {
					dbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;
					return DEBUGGER_CRASHED;
				}
				break;
			}

			case EXCEPTION_ILLEGAL_INSTRUCTION:
			case EXCEPTION_PRIV_INSTRUCTION:
			case EXCEPTION_INT_DIVIDE_BY_ZERO:
			case EXCEPTION_STACK_OVERFLOW:
			case STATUS_HEAP_CORRUPTION:
			case STATUS_STACK_BUFFER_OVERRUN:
			case STATUS_FATAL_APP_EXIT:
				dbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;
				return DEBUGGER_CRASHED;
				break;

			default:
				dbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;
				break;
			}

			break;

		case CREATE_THREAD_DEBUG_EVENT:
			break;

		case CREATE_PROCESS_DEBUG_EVENT: {
			// add a brekpoint to the process entrypoint
			void *entrypoint = get_entrypoint(DebugEv->u.CreateProcessInfo.lpBaseOfImage);
			add_breakpoint(entrypoint, BREAKPOINT_ENTRYPOINT, NULL, 0);
			CloseHandle(DebugEv->u.CreateProcessInfo.hFile);
			break;
		}

		case EXIT_THREAD_DEBUG_EVENT:
			break;

		case EXIT_PROCESS_DEBUG_EVENT:
			alive = false;
			break;

		case LOAD_DLL_DEBUG_EVENT: {
			// Don't do anything until the processentrypoint is reached.
			// Before that time we can't do much anyway, a lot of calls are going to fail
			// Modules loaded before entrypoint is reached are going to be enumerated at that time
			if (child_entrypoint_reached) {
				char filename[MAX_PATH];
				GetFinalPathNameByHandleA(DebugEv->u.LoadDll.hFile, (LPSTR)(&filename), sizeof(filename), 0);
				char *base_name = strrchr(filename, '\\');
				if (base_name) base_name += 1;
				else base_name = filename;
				// printf("Module loaded: %s %p\n", base_name, DebugEv->u.LoadDll.lpBaseOfDll);
				if (options.debug_mode) fprintf(debug_log, "Module loaded: %s\n", base_name);
				// module isn't fully loaded yet. Instead of processing it now,
				// add a breakpoint to the module's entrypoint
				if ((_stricmp(base_name, options.fuzz_module) == 0) || 
					is_coverage_module(base_name) ||
					options.decoder == DECODER_FULL_REFERENCE ||
					options.decoder == DECODER_FULL_FAST)
				{
					void *entrypoint = get_entrypoint(DebugEv->u.LoadDll.lpBaseOfDll);
					// printf("module %s entrypoint %p\n", base_name, entrypoint);
					// if there is no entrypoint assume resource-only dll
					if (entrypoint) {
						add_breakpoint(entrypoint, BREAKPOINT_MODULELOADED,
							base_name, DebugEv->u.LoadDll.lpBaseOfDll);
					} else {
						printf("Warning: module %s has no entrypoint, "
							"assuming resource-only. "
							"If you believe this is not the case, "
							"please file a bug\n", base_name);
					}
				}
			}
			CloseHandle(DebugEv->u.LoadDll.hFile);
			break;
		}

		case UNLOAD_DLL_DEBUG_EVENT:
			break;

		case OUTPUT_DEBUG_STRING_EVENT:
			break;

		case RIP_EVENT:
			break;
		}

		ContinueDebugEvent(DebugEv->dwProcessId,
			DebugEv->dwThreadId,
			dbg_continue_status);
	}

	return DEBUGGER_PROCESS_EXIT;
}

// a simpler debugger loop that just waits for the process to exit
void wait_process_exit()
{
	bool alive = true;

	LPDEBUG_EVENT DebugEv = &dbg_debug_event;

	while (alive)
	{
		dbg_continue_status = DBG_CONTINUE;

		if (!WaitForDebugEvent(DebugEv, 100)) {
			continue;
		}

		//printf("eventCode: %x\n", DebugEv->dwDebugEventCode);

		switch (DebugEv->dwDebugEventCode)
		{
		case EXCEPTION_DEBUG_EVENT:
			dbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;
			break;

		case CREATE_PROCESS_DEBUG_EVENT:
			CloseHandle(DebugEv->u.CreateProcessInfo.hFile);
			break;

		case EXIT_PROCESS_DEBUG_EVENT:
			alive = false;
			break;

		case LOAD_DLL_DEBUG_EVENT:
			CloseHandle(DebugEv->u.LoadDll.hFile);
			break;

		default:
			break;
		}

		ContinueDebugEvent(DebugEv->dwProcessId,
			DebugEv->dwThreadId,
			dbg_continue_status);
	}
}

// starts the target process
void start_process(char *cmd) {
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;
	HANDLE hJob = NULL;
	JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;

	breakpoints = NULL;

	if (sinkhole_stds && devnul_handle == INVALID_HANDLE_VALUE) {
		devnul_handle = CreateFile(
			"nul",
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			0,
			NULL);

		if (devnul_handle == INVALID_HANDLE_VALUE) {
			PFATAL("Unable to open the nul device.");
		}
	}
	BOOL inherit_handles = TRUE;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	// todo the below is duplicating code from afl-fuzz.c a lot
	// this should be taken out to a separate function
	if (sinkhole_stds) {
		si.hStdOutput = si.hStdError = devnul_handle;
		si.dwFlags |= STARTF_USESTDHANDLES;
	}
	else {
		inherit_handles = FALSE;
	}

	if (mem_limit || cpu_aff) {
		hJob = CreateJobObject(NULL, NULL);
		if (hJob == NULL) {
			FATAL("CreateJobObject failed, GLE=%d.\n", GetLastError());
		}

		ZeroMemory(&job_limit, sizeof(job_limit));
		if (mem_limit) {
			job_limit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
			job_limit.ProcessMemoryLimit = (size_t)(mem_limit * 1024 * 1024);
		}

		if (cpu_aff) {
			job_limit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_AFFINITY;
			job_limit.BasicLimitInformation.Affinity = (DWORD_PTR)cpu_aff;
		}

		if (!SetInformationJobObject(
			hJob,
			JobObjectExtendedLimitInformation,
			&job_limit,
			sizeof(job_limit)
		)) {
			FATAL("SetInformationJobObject failed, GLE=%d.\n", GetLastError());
		}
	}

	if (!CreateProcessA(NULL, cmd, NULL, NULL, inherit_handles, DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS, NULL, NULL, &si, &pi)) {
		FATAL("CreateProcess failed, GLE=%d.\n", GetLastError());
	}

	child_handle = pi.hProcess;
	child_thread_handle = pi.hThread;
	child_entrypoint_reached = false;

	if (mem_limit || cpu_aff) {
		if (!AssignProcessToJobObject(hJob, child_handle)) {
			FATAL("AssignProcessToJobObject failed, GLE=%d.\n", GetLastError());
		}
	}

	BOOL wow64current, wow64remote;
	if (!IsWow64Process(child_handle, &wow64remote)) {
		FATAL("IsWow64Process failed");
	}
	if (wow64remote) {
		wow64_target = 1;
		child_ptr_size = 4;
		if (options.callconv == CALLCONV_DEFAULT) {
			options.callconv = CALLCONV_CDECL;
		}
	}
	if (!IsWow64Process(GetCurrentProcess(), &wow64current)) {
		FATAL("IsWow64Process failed");
	}
	if (wow64current && wow64remote && (options.decoder == DECODER_FULL_REFERENCE || options.decoder == DECODER_FULL_FAST)) {
		FATAL("For full Intel PT decoding on 64-bit windows, you must use a 64-bit WinAFL build even on 32-bit targets");
	}
}

// called to resume the target process if it is waiting on a debug event
void resumes_process() {
	ContinueDebugEvent(dbg_debug_event.dwProcessId,
		dbg_debug_event.dwThreadId,
		dbg_continue_status);
}

void kill_process() {
	// end tracing
	if (options.persistent_trace) {
		if (!StopProcessIptTracing(child_handle)) {
			printf("Error stopping ipt trace\n");
		}
	}

	TerminateProcess(child_handle, 0);

	if(dbg_continue_needed) resumes_process();

	wait_process_exit();

	CloseHandle(child_handle);
	CloseHandle(child_thread_handle);

	child_handle = NULL;
	child_thread_handle = NULL;

	// delete any breakpoints that weren't hit
	struct winafl_breakpoint *breakpoint = breakpoints;
	while (breakpoint) {
		struct winafl_breakpoint *tmp = breakpoint;
		breakpoint = breakpoint->next;
		free(tmp);
	}
	breakpoints = NULL;
}

int run_target_pt(char **argv, uint32_t timeout) {
	int debugger_status;
	int ret;

	if (!child_handle) {

		char *cmd = argv_to_cmd(argv);
		start_process(cmd);
		ck_free(cmd);

		// wait until the target method is reached
		dbg_timeout_time = get_cur_time() + timeout;
		debugger_status = debug_loop();

		if (debugger_status != DEBUGGER_FUZZMETHOD_REACHED) {
			switch (debugger_status) {
			case DEBUGGER_CRASHED:
				FATAL("Process crashed before reaching the target method\n");
				break;
			case DEBUGGER_HANGED:
				FATAL("Process hanged before reaching the target method\n");
				break;
			case DEBUGGER_PROCESS_EXIT:
				FATAL("Process exited before reaching the target method\n");
				break;
			default:
				FATAL("An unknown problem occured before reaching the target method\n");
				break;
			}
		}

		fuzz_iterations_current = 0;
	}

	if(options.debug_mode) fprintf(debug_log, "iteration %d\n", fuzz_iterations_current);

	// start tracing
	if ((!options.persistent_trace) || (fuzz_iterations_current == 0)) {
		IPT_OPTIONS ipt_options;
		memset(&ipt_options, 0, sizeof(IPT_OPTIONS));
		ipt_options.OptionVersion = 1;
		ConfigureBufferSize(options.trace_buffer_size, &ipt_options);
		ConfigureTraceFlags(0, &ipt_options);
		if (!StartProcessIptTracing(child_handle, ipt_options)) {
			FATAL("ipt tracing error\n");
		}
		last_ring_buffer_offset = 0;
	}

	dbg_timeout_time = get_cur_time() + timeout;

	// printf("iteration start\n");

	resumes_process();
	debugger_status = debug_loop();

	// printf("iteration end\n");

	// collect trace
	bool trace_buffer_overflowed = false;
	PIPT_TRACE_DATA trace_data = GetIptTrace(child_handle);
	if (!trace_data) {
		printf("Error getting ipt trace\n");
	} else {
		trace_buffer_overflowed = collect_trace(trace_data);
		HeapFree(GetProcessHeap(), 0, trace_data);
	}

	// end tracing
	if (!options.persistent_trace) {
		if (!StopProcessIptTracing(child_handle)) {
			printf("Error stopping ipt trace\n");
		}
	}

	if (need_build_ranges) {
		build_address_ranges();
		need_build_ranges = false;
	}

	// process trace

	// printf("decoding trace of %llu bytes\n", trace_size);

	struct pt_image *image = NULL;
	if ((options.decoder == DECODER_FULL_FAST) || (options.decoder == DECODER_FULL_REFERENCE)) {
		image = pt_image_alloc("winafl_image");
		module_info_t *cur_module = all_modules;
		while (cur_module) {
			if (cur_module->isid > 0) {
				int ret = pt_image_add_cached(image, section_cache, cur_module->isid, NULL);
			}
			cur_module = cur_module->next;
		}
	}

	if (options.decoder == DECODER_TIP_FAST) {
		decode_trace_tip_fast(trace_buffer, trace_size, options.coverage_kind);
#ifdef DECODER_CORRECTNESS_TEST
		printf("Testing decoder correctness\n");
		unsigned char *fast_trace_bits = (unsigned char *)malloc(MAP_SIZE);
		memcpy(fast_trace_bits, trace_bits, MAP_SIZE);
		memset(trace_bits, 0, MAP_SIZE);
		decode_trace_tip_reference(trace_buffer, trace_size, options.coverage_kind);
		if (memcmp(fast_trace_bits, trace_bits, MAP_SIZE)) {
			FATAL("Fast decoder returned different coverage than the reference decoder");
		}
		free(fast_trace_bits);
#endif
	} else if (options.decoder == DECODER_TIP_REFERENCE) {
		decode_trace_tip_reference(trace_buffer, trace_size, options.coverage_kind);
	} else if (options.decoder == DECODER_FULL_FAST) {
		analyze_trace_full_fast(trace_buffer, trace_size, options.coverage_kind, image, trace_buffer_overflowed);
#ifdef DECODER_CORRECTNESS_TEST
		printf("Testing decoder correctness\n");
		unsigned char *fast_trace_bits = (unsigned char *)malloc(MAP_SIZE);
		memcpy(fast_trace_bits, trace_bits, MAP_SIZE);
		memset(trace_bits, 0, MAP_SIZE);
		analyze_trace_full_reference(trace_buffer, trace_size, options.coverage_kind, image, trace_buffer_overflowed);
		if (memcmp(fast_trace_bits, trace_bits, MAP_SIZE)) {
			FATAL("Fast decoder returned different coverage than the reference decoder");
		}
		free(fast_trace_bits);
#endif
	} else if (options.decoder == DECODER_FULL_REFERENCE) {
		analyze_trace_full_reference(trace_buffer, trace_size, options.coverage_kind, image, trace_buffer_overflowed);
	}

	if(image) pt_image_free(image);

	if (debugger_status == DEBUGGER_PROCESS_EXIT) {
		CloseHandle(child_handle);
		CloseHandle(child_thread_handle);
		child_handle = NULL;
		child_thread_handle = NULL;
		ret = FAULT_TMOUT; //treat it as a hang
	} else if (debugger_status == DEBUGGER_HANGED) {
		kill_process();
		ret = FAULT_TMOUT;
	} else if (debugger_status == DEBUGGER_CRASHED) {
		kill_process();
		ret = FAULT_CRASH;
	} else if (debugger_status == DEBUGGER_FUZZMETHOD_END) {
		ret = FAULT_NONE;
	}

	fuzz_iterations_current++;
	if (fuzz_iterations_current == options.fuzz_iterations && child_handle != NULL) {
		kill_process();
	}

	return ret;
}

int pt_init(int argc, char **argv, char *module_dir) {
	child_handle = NULL;
	child_thread_handle = NULL;

	int lastoption = -1;
	for (int i = 1; i < argc; i++) {
		if (strcmp(argv[i], "--") == 0) {
			lastoption = i;
			break;
		}
	}

	if (lastoption <= 0) return 0;

	winaflpt_options_init(lastoption - 1, argv + 1);
	trace_buffer = (unsigned char *)malloc(options.trace_buffer_size);

	if (!EnableAndValidateIptServices()) {
		FATAL("No IPT\n");
	} else {
		printf("IPT service enebled\n");
	}

	if (options.debug_mode) {
		debug_log = fopen("debug.log", "w");
		if (!debug_log) {
			FATAL("Can't open debug log for writing");
		}
	}

	if (options.decoder == DECODER_FULL_FAST || options.decoder == DECODER_FULL_REFERENCE) {
		section_cache = pt_iscache_alloc("winafl_cache");
	}
	strcpy(section_cache_dir, module_dir);

	if (options.decoder == DECODER_FULL_FAST) {
		if (!options.trace_cache_size) {
			// simple heuristics for determining tracelet cache size
			// within reasonable bounds
			options.trace_cache_size = options.trace_buffer_size * 10;
			if (options.trace_cache_size < TRACE_CACHE_SIZE_MIN)
				options.trace_cache_size = TRACE_CACHE_SIZE_MIN;
			if (options.trace_cache_size > TRACE_CACHE_SIZE_MAX)
				options.trace_cache_size = TRACE_CACHE_SIZE_MAX;

		}
		tracelet_cache_init(options.trace_cache_size / 100, options.trace_cache_size);
	}

	return lastoption;
}

void debug_target_pt(char **argv) {
	trace_bits = (u8 *)malloc(MAP_SIZE);
	u8 * trace_bits_saved = (u8 *)malloc(MAP_SIZE);

	for (int i = 0; i < options.fuzz_iterations; i++) {
		int ret = run_target_pt(argv, 0xFFFFFFFF);

		// detect variable coverage, could indicate a decoding issue
		// skip 1st iteration, will likely hit more coverage
		if (i == 1) {
			memcpy(trace_bits_saved, trace_bits, MAP_SIZE);
		} else if(i > 1) {
			if (memcmp(trace_bits_saved, trace_bits, MAP_SIZE)) {
				// printf("Info: Variable coverage detected\n");
			}
		}

		switch (ret) {
		case FAULT_NONE:
			if(debug_log) fprintf(debug_log, "Iteration finished normally\n");
			break;
		case FAULT_CRASH:
			if (debug_log) fprintf(debug_log, "Target crashed\n");
			break;
		case FAULT_TMOUT:
			if (debug_log) fprintf(debug_log, "Target hanged\n");
			break;
		}
	}

	if (debug_log) {
		fprintf(debug_log, "Coverage map (hex): \n");
		size_t map_pos = 0;
		while (1) {
			for (int i = 0; i < 16; i++) {
				if (map_pos == MAP_SIZE) break;
				fprintf(debug_log, "%02X", trace_bits[map_pos]);
				map_pos++;
			}
			fprintf(debug_log, "\n");
			if (map_pos == MAP_SIZE) break;
		}
	}

	if (debug_log) fclose(debug_log);
}

```

`winaflpt.h`:

```h
/*
  WinAFL - Intel PT instrumentation and presistence via debugger code
  ------------------------------------------------

  Written and maintained by Ivan Fratric <ifratric@google.com>

  Copyright 2016 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

#define COVERAGE_BB 0
#define COVERAGE_EDGE 1

#define TRACE_BUFFER_SIZE_DEFAULT (128*1024) //should be a power of 2

#define TRACE_CACHE_SIZE_MIN 10000000
#define TRACE_CACHE_SIZE_MAX 100000000

bool findpsb(unsigned char **data, size_t *size);

int run_target_pt(char **argv, uint32_t timeout);
int pt_init(int argc, char **argv, char *module_dir);
void debug_target_pt(char **argv);
```