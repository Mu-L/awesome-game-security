Project Path: arc_emanuele-f_PCAPdroid_2e1i4jay

Source Tree:

```txt
arc_emanuele-f_PCAPdroid_2e1i4jay
├── CHANGELOG.md
├── COPYING
├── ICONS_LICENSE
│   ├── FontAwesome
│   │   └── LICENSE.txt
│   └── app_icon
│       ├── Attribution.txt
│       ├── LICENSE.CC_BY_NC_3.txt
│       └── LICENSE.txt
├── README.md
├── app
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       ├── debug
│       │   └── res
│       │       └── values
│       │           └── strings.xml
│       ├── main
│       │   ├── AndroidManifest.xml
│       │   ├── java
│       │   │   └── com
│       │   │       ├── emanuelef
│       │   │       │   └── remote_capture
│       │   │       │       ├── ActionReceiver.java
│       │   │       │       ├── AppsLoader.java
│       │   │       │       ├── AppsResolver.java
│       │   │       │       ├── Billing.java
│       │   │       │       ├── Blacklists.java
│       │   │       │       ├── BootReceiver.java
│       │   │       │       ├── CaptureHelper.java
│       │   │       │       ├── CaptureService.java
│       │   │       │       ├── Cidr.java
│       │   │       │       ├── ConnectionsRegister.java
│       │   │       │       ├── Geolocation.java
│       │   │       │       ├── HTTPReassembly.java
│       │   │       │       ├── HarWriter.java
│       │   │       │       ├── HttpLog.java
│       │   │       │       ├── Log.java
│       │   │       │       ├── MitmAddon.java
│       │   │       │       ├── MitmReceiver.java
│       │   │       │       ├── PCAPdroid.java
│       │   │       │       ├── PersistableUriPermission.java
│       │   │       │       ├── ReversedLinesFileReader.java
│       │   │       │       ├── Utils.java
│       │   │       │       ├── VpnReconnectService.java
│       │   │       │       ├── WebSocketDecoder.java
│       │   │       │       ├── ZstdDecoder.java
│       │   │       │       ├── activities
│       │   │       │       │   ├── AboutActivity.java
│       │   │       │       │   ├── AppDetailsActivity.java
│       │   │       │       │   ├── AppFilterActivity.java
│       │   │       │       │   ├── AppsActivity.java
│       │   │       │       │   ├── BaseActivity.java
│       │   │       │       │   ├── CaptureCtrl.java
│       │   │       │       │   ├── ConnectionDetailsActivity.java
│       │   │       │       │   ├── ConnectionsActivity.java
│       │   │       │       │   ├── EditFilterActivity.java
│       │   │       │       │   ├── EditListActivity.java
│       │   │       │       │   ├── ErrorActivity.java
│       │   │       │       │   ├── FirewallActivity.java
│       │   │       │       │   ├── HttpDetailsActivity.java
│       │   │       │       │   ├── HttpLogFilterActivity.java
│       │   │       │       │   ├── LogviewActivity.java
│       │   │       │       │   ├── MainActivity.java
│       │   │       │       │   ├── MalwareDetection.java
│       │   │       │       │   ├── MenuActionHandler.java
│       │   │       │       │   ├── MitmSetupWizard.java
│       │   │       │       │   ├── OnBoardingActivity.java
│       │   │       │       │   ├── PayloadExportActivity.java
│       │   │       │       │   ├── StatsActivity.java
│       │   │       │       │   └── prefs
│       │   │       │       │       ├── EditCtrlPermissions.java
│       │   │       │       │       ├── PortMapActivity.java
│       │   │       │       │       ├── SettingsActivity.java
│       │   │       │       │       └── VpnExemptionsActivity.java
│       │   │       │       ├── adapters
│       │   │       │       │   ├── AppsAdapter.java
│       │   │       │       │   ├── AppsStatsAdapter.java
│       │   │       │       │   ├── AppsTogglesAdapter.java
│       │   │       │       │   ├── BlacklistsAdapter.java
│       │   │       │       │   ├── ConnectionsAdapter.java
│       │   │       │       │   ├── CtrlPermissionsAdapter.java
│       │   │       │       │   ├── HttpLogAdapter.java
│       │   │       │       │   ├── ListEditAdapter.java
│       │   │       │       │   ├── PayloadAdapter.java
│       │   │       │       │   ├── PortMappingAdapter.java
│       │   │       │       │   └── PrefSpinnerAdapter.java
│       │   │       │       ├── fragments
│       │   │       │       │   ├── AppOverview.java
│       │   │       │       │   ├── AppsFragment.java
│       │   │       │       │   ├── AppsToggles.java
│       │   │       │       │   ├── BlacklistsFragment.java
│       │   │       │       │   ├── ConnectionOverview.java
│       │   │       │       │   ├── ConnectionPayload.java
│       │   │       │       │   ├── ConnectionsFragment.java
│       │   │       │       │   ├── DataViewContainerFragment.java
│       │   │       │       │   ├── EditListFragment.java
│       │   │       │       │   ├── FirewallStatus.java
│       │   │       │       │   ├── HttpLogFragment.java
│       │   │       │       │   ├── HttpPayloadFragment.java
│       │   │       │       │   ├── LogviewFragment.java
│       │   │       │       │   ├── MalwareStatusFragment.java
│       │   │       │       │   ├── StatusFragment.java
│       │   │       │       │   ├── mitmwizard
│       │   │       │       │   │   ├── Done.java
│       │   │       │       │   │   ├── InstallAddon.java
│       │   │       │       │   │   ├── InstallCertificate.java
│       │   │       │       │   │   ├── Intro.java
│       │   │       │       │   │   └── StepFragment.java
│       │   │       │       │   └── prefs
│       │   │       │       │       ├── DnsSettings.java
│       │   │       │       │       ├── GeoipSettings.java
│       │   │       │       │       ├── PortMapFragment.java
│       │   │       │       │       ├── SettingsSubFragment.java
│       │   │       │       │       └── Socks5Settings.java
│       │   │       │       ├── interfaces
│       │   │       │       │   ├── AppStateListener.java
│       │   │       │       │   ├── AppsLoadListener.java
│       │   │       │       │   ├── BlacklistsStateListener.java
│       │   │       │       │   ├── CaptureStartListener.java
│       │   │       │       │   ├── ConnectionsListener.java
│       │   │       │       │   ├── DrawableLoader.java
│       │   │       │       │   ├── FragmentViewCreatedListener.java
│       │   │       │       │   ├── MitmListener.java
│       │   │       │       │   ├── PayloadHostActivity.java
│       │   │       │       │   ├── PcapDumper.java
│       │   │       │       │   └── TextAdapter.java
│       │   │       │       ├── model
│       │   │       │       │   ├── AppDescriptor.java
│       │   │       │       │   ├── AppState.java
│       │   │       │       │   ├── AppStats.java
│       │   │       │       │   ├── BlacklistDescriptor.java
│       │   │       │       │   ├── Blocklist.java
│       │   │       │       │   ├── CaptureSettings.java
│       │   │       │       │   ├── CaptureStats.java
│       │   │       │       │   ├── ConnectionDescriptor.java
│       │   │       │       │   ├── ConnectionUpdate.java
│       │   │       │       │   ├── CtrlPermissions.java
│       │   │       │       │   ├── FilterDescriptor.java
│       │   │       │       │   ├── Geomodel.java
│       │   │       │       │   ├── HttpLogFilterDescriptor.java
│       │   │       │       │   ├── ListInfo.java
│       │   │       │       │   ├── MatchList.java
│       │   │       │       │   ├── PayloadChunk.java
│       │   │       │       │   ├── PortMapping.java
│       │   │       │       │   └── Prefs.java
│       │   │       │       ├── pcap_dump
│       │   │       │       │   ├── FileDumper.java
│       │   │       │       │   ├── HTTPServer.java
│       │   │       │       │   ├── TCPDumper.java
│       │   │       │       │   └── UDPDumper.java
│       │   │       │       └── views
│       │   │       │           ├── AppSelectDialog.java
│       │   │       │           ├── AppsListView.java
│       │   │       │           ├── EmptyRecyclerView.java
│       │   │       │           ├── PrefSpinner.java
│       │   │       │           └── RuleAddDialog.java
│       │   │       └── pcapdroid
│       │   │           └── mitm
│       │   │               └── MitmAPI.java
│       │   ├── jni
│       │   │   ├── CMakeLists.txt
│       │   │   ├── common
│       │   │   │   ├── CMakeLists.txt
│       │   │   │   ├── jni_utils.c
│       │   │   │   ├── jni_utils.h
│       │   │   │   ├── memtrack.h
│       │   │   │   ├── uid_lru.c
│       │   │   │   ├── uid_lru.h
│       │   │   │   ├── uid_resolver.c
│       │   │   │   ├── uid_resolver.h
│       │   │   │   ├── utils.c
│       │   │   │   └── utils.h
│       │   │   ├── core
│       │   │   │   ├── CMakeLists.txt
│       │   │   │   ├── blacklist.c
│       │   │   │   ├── blacklist.h
│       │   │   │   ├── capture_pcap.c
│       │   │   │   ├── capture_vpn.c
│       │   │   │   ├── crc32.c
│       │   │   │   ├── errors.h
│       │   │   │   ├── ip_lru.c
│       │   │   │   ├── ip_lru.h
│       │   │   │   ├── jni_impl.c
│       │   │   │   ├── log_writer.c
│       │   │   │   ├── log_writer.h
│       │   │   │   ├── ndpi_config.c
│       │   │   │   ├── pcap_dump.c
│       │   │   │   ├── pcap_dump.h
│       │   │   │   ├── pcap_reader.c
│       │   │   │   ├── pcap_reader.h
│       │   │   │   ├── pcapdroid.c
│       │   │   │   ├── pcapdroid.h
│       │   │   │   ├── port_map.c
│       │   │   │   ├── port_map.h
│       │   │   │   ├── ushark_dll.c
│       │   │   │   └── ushark_dll.h
│       │   │   ├── pcapd
│       │   │   │   ├── CMakeLists.txt
│       │   │   │   ├── README.md
│       │   │   │   ├── nl_utils.c
│       │   │   │   ├── nl_utils.h
│       │   │   │   ├── pcapd.c
│       │   │   │   ├── pcapd.h
│       │   │   │   └── pcapd_priv.h
│       │   │   ├── tests
│       │   │   │   ├── CMakeLists.txt
│       │   │   │   ├── Makefile
│       │   │   │   ├── README.md
│       │   │   │   ├── fuzz
│       │   │   │   │   ├── CMakeLists.txt
│       │   │   │   │   ├── fuzz_capture.c
│       │   │   │   │   └── fuzz_pcapd.c
│       │   │   │   ├── fuzz_utils.c
│       │   │   │   ├── pcap
│       │   │   │   │   ├── crash-593ec6ead7a1bf23faa96d03cbd74c315bcf67fc
│       │   │   │   │   ├── http_proxy.pcap
│       │   │   │   │   ├── invalid_or_unsupported.pcap
│       │   │   │   │   ├── metadata.pcap
│       │   │   │   │   └── two_flows.pcap
│       │   │   │   ├── test
│       │   │   │   │   ├── CMakeLists.txt
│       │   │   │   │   ├── blacklist.c
│       │   │   │   │   ├── dpi.c
│       │   │   │   │   ├── dump_api.c
│       │   │   │   │   ├── pcap_reader.c
│       │   │   │   │   └── root_capture.c
│       │   │   │   ├── test_utils.c
│       │   │   │   └── test_utils.h
│       │   │   ├── third_party
│       │   │   │   ├── libchash.c
│       │   │   │   └── libchash.h
│       │   │   └── zstd
│       │   │       ├── CMakeLists.txt
│       │   │       └── zstd_jni.c
│       │   └── res
│       │       ├── anim
│       │       │   ├── slide_in_left.xml
│       │       │   ├── slide_in_right.xml
│       │       │   ├── slide_out_left.xml
│       │       │   └── slide_out_right.xml
│       │       ├── drawable
│       │       │   ├── banner.xml
│       │       │   ├── drawer_background.png
│       │       │   ├── dump_modes.jpg
│       │       │   ├── firewall_block.jpg
│       │       │   ├── http_inspection.jpg
│       │       │   ├── ic_add.xml
│       │       │   ├── ic_app_crash.xml
│       │       │   ├── ic_apps.xml
│       │       │   ├── ic_arrow_drop_down.xml
│       │       │   ├── ic_baseline_javascript.xml
│       │       │   ├── ic_block.xml
│       │       │   ├── ic_book.xml
│       │       │   ├── ic_bug.xml
│       │       │   ├── ic_check_solid.xml
│       │       │   ├── ic_close.xml
│       │       │   ├── ic_content_copy.xml
│       │       │   ├── ic_content_copy_small.xml
│       │       │   ├── ic_copyright.xml
│       │       │   ├── ic_exclamation_triangle_solid.xml
│       │       │   ├── ic_expand_more.xml
│       │       │   ├── ic_external.xml
│       │       │   ├── ic_file_export.xml
│       │       │   ├── ic_file_import.xml
│       │       │   ├── ic_filter.xml
│       │       │   ├── ic_help.xml
│       │       │   ├── ic_hourglass_top.xml
│       │       │   ├── ic_image.xml
│       │       │   ├── ic_info.xml
│       │       │   ├── ic_launcher_background.xml
│       │       │   ├── ic_launcher_foreground.xml
│       │       │   ├── ic_location_dot.xml
│       │       │   ├── ic_lock.xml
│       │       │   ├── ic_lock_open.xml
│       │       │   ├── ic_lock_open_alt.xml
│       │       │   ├── ic_logo.xml
│       │       │   ├── ic_media_stop.xml
│       │       │   ├── ic_money.xml
│       │       │   ├── ic_navigate_before.xml
│       │       │   ├── ic_navigate_next.xml
│       │       │   ├── ic_play_arrow.xml
│       │       │   ├── ic_refresh.xml
│       │       │   ├── ic_reset.xml
│       │       │   ├── ic_save.xml
│       │       │   ├── ic_save_alt_small.xml
│       │       │   ├── ic_search.xml
│       │       │   ├── ic_select_all.xml
│       │       │   ├── ic_settings.xml
│       │       │   ├── ic_share.xml
│       │       │   ├── ic_shield.xml
│       │       │   ├── ic_shopping_cart.xml
│       │       │   ├── ic_short_text.xml
│       │       │   ├── ic_skull.xml
│       │       │   ├── ic_sort.xml
│       │       │   ├── ic_stacked_bar_chart.xml
│       │       │   ├── ic_swap_horiz.xml
│       │       │   ├── ic_telegram.xml
│       │       │   ├── ic_text_snippet.xml
│       │       │   ├── malware_notification.jpg
│       │       │   ├── reply.xml
│       │       │   ├── rounded_bg.xml
│       │       │   ├── splash_screen.xml
│       │       │   └── tab_switch_button_background.xml
│       │       ├── drawable-v23
│       │       │   └── splash_screen.xml
│       │       ├── font
│       │       │   └── sourcecodepro_regular.ttf
│       │       ├── layout
│       │       │   ├── about_activity.xml
│       │       │   ├── active_filter_chip.xml
│       │       │   ├── activity_stats.xml
│       │       │   ├── add_port_mapping_dialog.xml
│       │       │   ├── add_rule_dialog.xml
│       │       │   ├── app_installed_item.xml
│       │       │   ├── app_item.xml
│       │       │   ├── app_overview.xml
│       │       │   ├── app_selection_item.xml
│       │       │   ├── apps_selector.xml
│       │       │   ├── apps_stats.xml
│       │       │   ├── blacklist_item.xml
│       │       │   ├── choice_chip.xml
│       │       │   ├── connection_item.xml
│       │       │   ├── connection_overview.xml
│       │       │   ├── connection_payload.xml
│       │       │   ├── connections.xml
│       │       │   ├── ctrl_consent.xml
│       │       │   ├── data_view_container.xml
│       │       │   ├── dropdown_item.xml
│       │       │   ├── edit_filter_activity.xml
│       │       │   ├── error_activity.xml
│       │       │   ├── firewall_status.xml
│       │       │   ├── fragment_activity.xml
│       │       │   ├── fragment_mitm_wizard.xml
│       │       │   ├── http_log_filter_activity.xml
│       │       │   ├── http_req_item.xml
│       │       │   ├── license_dialog.xml
│       │       │   ├── logview_fragment.xml
│       │       │   ├── main_activity.xml
│       │       │   ├── malware_detection_blacklists.xml
│       │       │   ├── malware_detection_status.xml
│       │       │   ├── mitm_wizard_activity.xml
│       │       │   ├── nav_header.xml
│       │       │   ├── payload_item.xml
│       │       │   ├── port_mapping_item.xml
│       │       │   ├── quick_settings_item.xml
│       │       │   ├── rule_item.xml
│       │       │   ├── scrollable_dialog.xml
│       │       │   ├── simple_list.xml
│       │       │   ├── simple_list_activity.xml
│       │       │   ├── status.xml
│       │       │   ├── tabs_activity.xml
│       │       │   └── tabs_activity_fixed.xml
│       │       ├── menu
│       │       │   ├── about_menu.xml
│       │       │   ├── app_context_menu.xml
│       │       │   ├── app_overview_menu.xml
│       │       │   ├── apps_menu.xml
│       │       │   ├── blacklists_menu.xml
│       │       │   ├── connection_context_menu.xml
│       │       │   ├── connection_details_menu.xml
│       │       │   ├── connections_cab.xml
│       │       │   ├── connections_menu.xml
│       │       │   ├── copy_share_menu.xml
│       │       │   ├── ctrl_permissions_menu.xml
│       │       │   ├── docs_menu.xml
│       │       │   ├── edit_filter_menu.xml
│       │       │   ├── firewall_menu.xml
│       │       │   ├── hint_menu.xml
│       │       │   ├── http_details_menu.xml
│       │       │   ├── http_log_cab.xml
│       │       │   ├── http_log_menu.xml
│       │       │   ├── list_edit_cab.xml
│       │       │   ├── list_edit_menu.xml
│       │       │   ├── log_menu.xml
│       │       │   ├── main_menu.xml
│       │       │   ├── nav_items.xml
│       │       │   ├── port_mapping_menu.xml
│       │       │   └── search_menu.xml
│       │       ├── mipmap-anydpi-v26
│       │       │   ├── ic_launcher.xml
│       │       │   └── ic_launcher_round.xml
│       │       ├── mipmap-hdpi
│       │       │   ├── banner.png
│       │       │   ├── ic_launcher.png
│       │       │   └── ic_launcher_round.png
│       │       ├── mipmap-mdpi
│       │       │   ├── banner.png
│       │       │   ├── ic_launcher.png
│       │       │   └── ic_launcher_round.png
│       │       ├── mipmap-television-xhdpi
│       │       │   └── ic_launcher.png
│       │       ├── mipmap-xhdpi
│       │       │   ├── banner.png
│       │       │   ├── ic_launcher.png
│       │       │   └── ic_launcher_round.png
│       │       ├── mipmap-xxhdpi
│       │       │   ├── ic_launcher.png
│       │       │   └── ic_launcher_round.png
│       │       ├── mipmap-xxxhdpi
│       │       │   ├── ic_launcher.png
│       │       │   └── ic_launcher_round.png
│       │       ├── navigation
│       │       │   └── mitm_wizard_graph.xml
│       │       ├── resources.properties
│       │       ├── values
│       │       │   ├── arrays.xml
│       │       │   ├── colors.xml
│       │       │   ├── dimens.xml
│       │       │   ├── strings.xml
│       │       │   └── styles.xml
│       │       ├── values-ar
│       │       │   └── strings.xml
│       │       ├── values-az
│       │       │   └── strings.xml
│       │       ├── values-de
│       │       │   └── strings.xml
│       │       ├── values-es
│       │       │   └── strings.xml
│       │       ├── values-fr
│       │       │   └── strings.xml
│       │       ├── values-in
│       │       │   └── strings.xml
│       │       ├── values-it
│       │       │   └── strings.xml
│       │       ├── values-ja
│       │       │   └── strings.xml
│       │       ├── values-ko
│       │       │   └── strings.xml
│       │       ├── values-nb-rNO
│       │       │   └── strings.xml
│       │       ├── values-night-v8
│       │       │   ├── colors.xml
│       │       │   └── styles.xml
│       │       ├── values-pl
│       │       │   └── strings.xml
│       │       ├── values-pt-rBR
│       │       │   └── strings.xml
│       │       ├── values-ru
│       │       │   └── strings.xml
│       │       ├── values-sw600dp
│       │       │   └── dimens.xml
│       │       ├── values-ta
│       │       │   └── strings.xml
│       │       ├── values-tr
│       │       │   └── strings.xml
│       │       ├── values-uk
│       │       │   └── strings.xml
│       │       ├── values-zh-rCN
│       │       │   └── strings.xml
│       │       └── xml
│       │           ├── dns_preferences.xml
│       │           ├── geoip_preferences.xml
│       │           ├── locales_config.xml
│       │           ├── root_preferences.xml
│       │           └── socks5_preferences.xml
│       └── test
│           └── java
│               └── com
│                   └── emanuelef
│                       └── remote_capture
│                           ├── CidrTest.java
│                           ├── ConnectionsRegisterTest.java
│                           ├── FilterDescriptorTest.java
│                           ├── HTTPReassemblyTest.java
│                           ├── HarWriterTest.java
│                           ├── HttpLogFilterDescriptorTest.java
│                           ├── HttpLogTest.java
│                           ├── MatchListTest.java
│                           ├── PortMappingTest.java
│                           ├── TestPCAPdroid.java
│                           ├── UtilsTest.java
│                           ├── WebSocketDecoderTest.java
│                           ├── Whitebox.java
│                           └── adapters
│                               ├── ConnectionsAdapterTest.java
│                               └── PayloadAdapterTest.java
├── build.gradle
├── docs
│   ├── app_api.md
│   ├── edge-to-edge.md
│   ├── how_it_works.md
│   ├── languages.md
│   ├── testing.md
│   └── work_profiles.md
├── fastlane
│   └── metadata
│       └── android
│           ├── ar
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── de
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── en-US
│           │   ├── full_description.txt
│           │   ├── images
│           │   │   ├── featureGraphic.png
│           │   │   ├── icon.png
│           │   │   ├── phoneScreenshots
│           │   │   │   ├── 1.jpg
│           │   │   │   ├── 2.jpg
│           │   │   │   ├── 3.jpg
│           │   │   │   └── 4.jpg
│           │   │   └── tvScreenshots
│           │   │       ├── 1.png
│           │   │       └── 2.png
│           │   └── short_description.txt
│           ├── es
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── id
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── it
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── ko-KR
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── nb-NO
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── pl-PL
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── pt-BR
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── ru
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── tr
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           ├── uk
│           │   ├── full_description.txt
│           │   └── short_description.txt
│           └── vi
│               └── short_description.txt
├── funding.json
├── generated
│   ├── README.md
│   ├── libpcap
│   │   ├── config.h
│   │   ├── grammar.c
│   │   ├── grammar.h
│   │   ├── scanner.c
│   │   └── scanner.h
│   ├── nDPI
│   │   ├── ndpi_api.h
│   │   ├── ndpi_config.h
│   │   └── ndpi_define.h
│   └── refresh.sh
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── settings.gradle
├── submodules
│   ├── MaxMind-DB-Reader-java
│   ├── PCAPdroid-ushark-bin
│   ├── libpcap
│   ├── nDPI
│   ├── zdtun
│   └── zstd
└── tools
    ├── pcapdroid.lua
    ├── pcapdroid_mitm.py
    ├── pcapdroid_udpdump.lua
    ├── udp_receiver.py
    ├── weblate.py
    └── weblate_status

```

`CHANGELOG.md`:

```md
# Changelog

Releases available at https://github.com/emanuele-f/PCAPdroid/releases

## [1.9.1] - 2026-02-22
- Fix minor crashes
- Switch to facebook/zstd and build from the source

## [1.9.0] - 2026-02-12
- New HTTP requests view
- Export HTTP data in the HAR format
- Add Portuguese (BR) translation
- Support the zstd compression
- Fix HTTP/2 handling (possible mismatch of requests and replies)
- Fix WebSocket data loading from PCAP file
- Fix buffer overruns and leaks when decrypting PCAP files
- New language selector on Android 12 and below
- Select and export individual connections
- Pretty-print JSON in HTTP data
- Support using domain names in port mapping
- Add toggle to show system apps
- Export data in background threads to avoid UI hangs
- Fix ushark crash on x86_64 when decrypting PCAP files (F-Droid only)

## [1.8.8] - 2025-09-03
- Support 16 KB page size devices
- Make PCAP/CSV file name prefix configurable
- Fix possible invalid Pcapng block length with root
- New API options: full_payload, keylog filename, decryption rules (credits: c4rl2s0n)

## [1.8.7] - 2025-07-24
- Minor fixes
- Update billing library (Play build)

## [1.8.6] - 2025-05-13
- Add TCP exporter dump mode (pcap-over-ip)
- Allow PCAPdroid capture control without prompt via API key

## [1.8.5] - 2025-04-25
- Fix GeoIP db download with Arabic language

## [1.8.4] - 2025-03-23
- Fix possible unaligned memory access on ARMv7 in libndpi.so (is_stun)
- Fix minor crashes on specific devices
- Remove BUILD_TIME for reproducible F-Droid builds
- Change icons and add banners according to the Android TV guidelines
- Update translations

## [1.8.3] - 2025-03-08
- Fix crash when adding a protocol filter
- Fix possible Skus deserialization errors (Play build)
- Fix empty state not visible in edit list views
- Support building ushark from the source (F-Droid)
- Update NDK to r26d

## [1.8.2] - 2025-03-04
- Fix crash on capture start with port mapping rules

## [1.8.1] - 2025-03-04
- Fix crash on capture start if the geolocation db was downloaded

## [1.8.0] - 2025-03-03
- Android 15 support with edge-to-edge UI
- Decrypt TLS traffic in PCAP/Pcapng files (Wireshark integration)
- New firewall rules: block by country and by CIDR
- Add support for PCAPdroid extensions in Pcapng
- Reduce blacklists RAM usage by ~25 MB and increase limit to 1500k rules
- Show detailed error information for failed connections in VPN mode
- New UI filter to show connections bigger than a given bytes threshold
- Add Azerbaijani translation (Jamil Farajov)
- Add Tamil translation (credits: தமிழ்நேரம்)
- Update nDPI to 4.12 and reduce library size by 66%
- Enable r8 minify to reduce apk size
- Update to Java 17 and enable desugaring to support older devices

## [1.7.5] - 2024-11-09
- Fix root capture stall when target apps are set

## [1.7.4] - 2024-10-16
- Fix root capture start in some non-magisk su binaries (credits: jackyzy823)
- The mitm addon now uses mitmproxy 11
- Include the package name in the CSV output (credits: Chris Vanstone)

## [1.7.3] - 2024-09-07
- Allow setting the app language from the system (for Android 13+)
- Mitm addon v1.2: allow public files write, fix enabled addons reset, fix addons reload
- You can now use a compatible mitm addon with the same major version
- Detect always-on VPN enabled after capture start
- Catch possible crash in getUserBadgedIcon in Android 8
- Disable unfinished languages: fr, ja, ko, nb, pl, pt

## [1.7.2] - 2024-04-20
- Fix broken PCAP file loading feature
- Minor enhancements

## [1.7.1] - 2024-03-28
- Add toggle for auto-reconnection on third-party VPN termination
- Fix uninstalled apps not removed from app filter
- Add IPv6 bytes stats (credits: myzhan)

## [1.7.0] - 2024-02-10
- Select multiple target apps
- Copy/export the connections payload
- Android 14 support
- mitmproxy 10.1.6 and Doze fix
- Ability to block QUIC only on decryption
- Fix decryption status for QUIC connections
- Fix inaccurate firewall grace period
- Integrations to run with Tor and DNSCrypt
- Use your own mitmproxy addons (experimental)
- Remove mitm-addon permission
- Show termux main app instead of its sub-apps
- Use ISO 8601 dates in CSV export

## [1.6.9] - 2023-12-04
- Fix root capture start on some devices
- Fix root permission incorrectly requested on read from pcap file
- Fix capture control modal incorrectly shown
- Fix possible crash on null CaptureSettings
- Fix possible SecurityException while opening PCAP file

## [1.6.8] - 2023-09-01
- Fix root capture/pcap loading in playstore build due to AAB packaging
- Fix possible permission denied error on PCAP file open

## [1.6.7] - 2023-08-31
- Fix root capture start failure due to short timeout
- Fix NumberFormatException in PCAP open / CSV export
- Add Ukrainian translation (credits: odkate)
- Do not resolve socks5 server host if disabled

## [1.6.6] - 2023-08-28
- Add ability to open PCAP/PCAPNG files
- Add Arabic translation (credits: Mustafa Hamed Kathem)
- Fix app not blocked by firewall after reinstallation
- Fix DNS from unknown app incorrectly blocked in firewall whitelist mode
- Support IPv6 and host names in socks5 mode

## [1.6.5] - 2023-06-15
- Add ability to inject javascript into web pages (PCAPdroid-mitm)
- TLS decryption is now rule-based, it only applies to specified connections
- App icon on Android 13 can be themed now (credits: incycledream)
- Allow exporting the SSLKEYLOG after anomalous app stop
- IPv6 fixes: fix ICMPv6, fix crash on invalid DNS, capture of ULA traffic

## [1.6.4] - 2023-04-24
- Fix QR code activation crash on Android 32+
- Update translations

## [1.6.3] - 2023-04-23
- Add paid features activation via QR code for non-Play builds
- Fix firewall not working when loading duplicate domain rules
- Fix repeated local TCP connection attempts on some devices when private DNS is enabled
- Minor bug fixes

## [1.6.2] - 2023-03-31
- Update mitm addon to mitmproxy 9.0.1
- Add SOCKS5 authentication via username and password
- Add workaround for mitm addon connection failure
- Update German translation (credits: Mario Herrmann)

## [1.6.1] - 2023-02-10
- Fix Android TV navigation
- Fix minor crashes

## [1.6.0] - 2023-01-16
- Add firewall whitelist mode: block everything, unless whitelisted
- Add pcapng format: removes the need for a separate SSLKEYLOG (paid feature)
- Add port mapping: redirect traffic to given hosts/ports
- Custom rules can now be added from the UI
- DNS servers are now configurable
- Add TLS decryption whitelist
- Simplify PCAP dump to file
- Sort apps by total/sent/received bytes
- Full payload can now be disabled in TLS decryption mode
- Support custom mitmproxy options
- The application and the mitmproxy logs can now be viewed in-app
- Apps stats can now be reset

## [1.5.6] - 2022-09-24
- Extend STUN compatibility
- Fix Whatsapp calls being dropped (no-root)
- Add ability to skip TLS certificate installation
- Fix paid features docs URLs and appearance on first app start
- Fix capture stopped with always-on and start-on-boot

## [1.5.5] - 2022-08-25
- You can now buy unlock tokens to access paid features in non-Play builds
- Fix minor crashes and ANR
- Fix JNI leaks and prevent local references overflow
- Fix deprecations

## [1.5.4] - 2022-08-04
- Unblock newly installed apps via notification action (firewall)
- Fix context menu action possibly applied to wrong item
- Fix ICMPv6 not captured with root and app filter
- Fix package search with uppercase letters
- Fix PCAP file selection dialog sometimes not appearing

## [1.5.3] - 2022-07-13
- Add support for Android 13 Tiramisu
- Add VPN exemptions to exclude specific apps from the VPN
- Ability to set IPv6-only VPN mode
- Add filter to only show cleartext connections
- Ability to block newly installed apps (firewall)
- Ability to temporary unblock an app (firewall)
- Show scam-prevention messages
- Deny sending traffic to remote servers via CaptureCtrl to prevent scams
- Fix possible IllegalStateException in the status view

## [1.5.2] - 2022-06-22
- Add ability to only show the connections allowed by the firewall
- Monitor memory usage and disable full payload on low memory
- Fix possible SecurityException in Android 11
- Fix crash on tap on uninstalled app
- Fix ANR on first root capture start

## [1.5.1] - 2022-06-07
- Resolve correct apps details with work profiles in root mode
- Fix app filter icon not shown on capture start
- Fix crash on screen rotation in connection details
- Fix some occasional crashes

## [1.5.0] - 2022-06-02
- No-root firewall: block apps, domains and IP addresses (paid feature)
- Ability to decrypt TLS traffic, display decrypted data, export the SSLKEYLOGFILE
- Inspect HTTP requests and replies thanks to the built-in decoders (brotli, deflate, gzip)
- Uploads in VPN mode are now faster and less cpu intensive
- Inspect the full connections' payload as hexdump/text
- Add ability to import/export rules
- Fix uid resolution failing with root after some time
- Fix PCAP dump of invalid/unsupported packets in root
- Reduce APK size: geolocation db is now optional
- Intent-based API now reports traffic stats
- Add app on-boarding on first start
- Add ability to disable blocking of private DNS
- Add German translation (credits: Robin)
- Add Indonesian translation (credits: Reza Almanda)
- Add Turkish translation (credits: Oğuz Ersen)
- Minor fixes and improvements

## [1.4.8] - 2022-04-22
- Fix corrupted PCAP file on Android 10+ when overwriting existing file
- Start the capture by tapping "Ready"
- Allow inspecting connections after the capture is stopped
- Support UDP STUN in non-root mode
- Faster uid resolution and other improvements

## [1.4.7] - 2022-02-10
- Fix unsolicited capture start when swiping the app from recent apps
- Fix ForegroundServiceStartNotAllowedException in Android 12
- Fix ANR when stopping the capture
- Fix empty stats when there is no traffic
- Update to nDPI 4.2

## [1.4.6] - 2022-02-06
- Improve capture performance when PCAP dump is enabled
- Always-on VPN is now fully supported
- Add Norwegian translation (credits: Allan Nordhøy)
- Add French translation (credits: J. Lavoie and Maxime Leroy)
- Fix Android 11/12 crash when invoked via the Intent-based API
- Fix SecurityException crash on Android TV with PCAP file dump
- Fix packets truncated with root on devices with sw/hw offloading
- Fix use-after-free in root mode
- Fix memory leak with HTTP server PCAP dump when a client disconnects
- Add native code testing and fuzzing

## [1.4.5] - 2022-01-06
- Reduce the memory usage, in particular during the capture
- Malware detection now blocks malicious connections in non-root mode (paid feature)
- Add ability to filter connections by capture interface in root mode
- Add spanish translation (credits: sguinetti)
- Improve stability: add tests, bounds checks, synchronization
- Fix crashes when no activity is available to handle intents
- Fix crash in root mode when the internet interface goes down
- Workaround for crash due to IndexOutOfBoundsException in RecyclerView
- Fix long press on a connection which is being updated
- Re-enable always-on VPN support
- Improve Android TV support, support devices with no wifi

## [1.4.4] - 2021-11-23
- New malware detection overview: show blacklists and detection status
- Show destination country and ASN in the connection details
- Add ability to start the capture at boot
- Reduce packet processing delay during UI updates
- Fix no Internet when a custom private DNS is set
- Add ability to grant persistent capture control permissions

## [1.4.3] - 2021-10-30
- Implement blacklist-based malware detection with alerts (paid feature)
- Filter connections: only plaintext, state (e.g. only open), not hidden, malicious
- Fix a bug which, in rare cases, caused the connections view to stop being updated
- Fix some closed connections being marked with the Unknown protocol
- Improve netd app resolution with root capture
- Ability to copy host/IP/URL/plaintext on long press
- Added whois IP lookup button
- "Whitelist" is now called "Hidden Connections"

## [1.4.2] - 2021-09-11
- Ability to select the capture interface in root mode
- Ability to start/stop the capture from other apps via Intent
- Improve pcapd error reporting
- The copy action now also dumps the request plaintext

## [1.4.1] - 2021-07-31
- Fix crash in some devices with PCAPdroid trailer
- Add ability to build on Windows

## [1.4.0] - 2021-07-20
- Ability to export app name to Wireshark (PCAPdroid trailer)
- Add apps details page with app metadata and permissions
- Allow searching by source and destination port
- Packet capture optimizations
- Add in-app purchases to remove ads
- Add packet drops for root capture
- Add IPv6 and ICMP support for root capture
- Fix root capture stall in some cases
- Fix PCAP dump in root mode
- Fix truncated full size packets in root mode and handle fragments
- PCAP timestamps in root mode now correspond to the capture timestamps
- Fix ping to known DNS servers being blocked

## [1.3.9] - 2021-06-16
This release brings a set of new features to make it easier to spot unwanted connections!

- Long press a connection to whitelist it, making it easy to filter out background traffic
- Add ability to search connections
- Most netd DNS connections are now resolved into actual apps
- Add Brazilian translation (credits: mezysinc)
- Add Japanese translation (credits: Akihiro Nagai)

## [1.3.8] - 2021-06-03
- Fix monodirectional connections with LINUX_SLL in root mode
- Show plaintext request data (e.g. HTTP headers) in the connection details

## [1.3.7] - 2021-05-19
- Handle DLT_LINUX_SLL to fix some root daemon start issues

## [1.3.6] - 2021-05-01
- Implement root based capture to run with other VPN apps
- Fix bad URL when an HTTP proxy is used

## [1.3.5] - 2021-04-14
- Fix delays and slow downs with big uploads
- Add SOCKS5 client, allowing to use the official mitmproxy
- Implement MSS and TCP window scaling options

## [1.3.4] - 2021-03-30
- Add dark theme
- Android TV: fix file selection and other improvements
- Fix UDP broadcast connections

## [1.3.3] - 2021-03-25
- You can now donate! Check out the user guide for instructions
- Add IPv6 support
- Reduce background battery and RAM consumption
- Add russian translation (credits: rikishi)
- Add italian translation
- Add ability to switch between system language and english
- Improve TCP and DNS connections handling
- Connection details stats now automatically refresh
- Fix DNS resolution failures on main network change

## [1.3.2] - 2021-03-09
- Add ICMP connections support
- Reduce app icons load time and RAM usage
- Fix crash in Bitmap.createBitmap

## [1.3.1] - 2021-03-07
- Fix startup crash before Oreo

## [1.3.0] - 2021-03-05
- Retain the connections log during the whole capture
- Add Android TV support
- New app layout for easier interaction
- Export the connections log to a CSV file
- Filter the connections log by app
- New Apps view to review the total traffic and connections by app
- Clipboard copy and export of the connection details
- Add persistent notification while capture is running
- Apps can now conveniently searched via the searchbar

## [1.2.16] - 2021-02-23
- Fix non-selectable text in connections details
- Fix start button not working on first app run

## [1.2.15] - 2021-02-20
- Improve connections stability
- Report fatal native errors to the user

## [1.2.14] - 2021-02-14
- Fix DNS resolution not working when an IPv6 DNS server is configured

## [1.2.13] - 2021-02-12
- More sockets checks to prevent crashes
- Add stats view with traffic and debug information
- UI improvements: apps loading toast, start button position
- ViewPager2 migration (credits: TacoTheDank <SkytkRSfan3895@gmail.com>)

## [1.2.12] - 2021-01-26
- minSdkVersion is now 21 (Lollipop)
- Improve DNS traffic capture when an app filter is set

## [1.2.11] - 2021-01-25
- Fix empty apps list in Android 11

## [1.2.10] - 2021-01-23
- Ask confirmation when another VPNService is running
- Rework modules dependencies

## [1.2.9] - 2021-01-17
- Fix crash when app is stopped from the system VPN settings

## [1.2.8] - 2021-01-11
- Improve TCP connections stability with big packets
- Add chinese translation (credits: sr093906)
- Update nDPI and gradle dependencies
- Fix some crashes

## [1.2.7] - 2021-01-07
- Fix app ID not resolved on android >= Q
- Resolve system apps UIDs

## [1.2.6] - 2020-11-16
- Add support for TLS decryption via mitmproxy
- Fix occasional crash due to null ConnDescriptor in array
- Connections view consistency fixed when app filter is in use
- Update nDPI to 3.4 stable
- Add links: rate app, telegram channel, user guide

## [1.2.5] - 2020-09-20
- Fix crash on subsequent app runs

## [1.2.4] - 2020-09-18
- Traffic monitoring fix
- JNI fixes and optimizations

## [1.2.3] - 2020-02-19
- Add polish translation (Atrate <Atrate@protonmail.com>)
- Add more compact layout for screens lower than 480dp
- JNI crashes fixes

## [1.2.2] - 2020-01-11
- Fix crash while clicking on the HTTP server URL
- Improve local HTTP server IP detection

## [1.2.1] - 2020-01-06
- New embedded HTTP server to easily download the PCAP from multiple devices
- Choose how to dump packets: HTTP server, UDP exporter, none.
- App renamed to PCAPdroid, changed version scheme, added changelog

# Older Releases

Releases available at https://github.com/emanuele-f/RemoteCapture/releases

## [1.2] - 2020-01-01
- New tab to display the active connections, with server name and traffic volume
- Show server name, DNS query, L7 protocol information from nDPI
- Click on a connection to show its details
- Use the system DNS server (fallback to 8.8.8.8 only if not available)

## [1.1] - 2019-11-03
- Fix app state loading after resume
- Add option to enable/disable unknown app traffic capture
- Add UDP receiver python script to easily pause and resume capture

## [1.0] - 2019-10-26
- Capture apps traffic without root
- Send captured traffic via UDP
- Show captured traffic realtime statistics
- Apply a filter to only capture traffic for the selected app

```

`COPYING`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`ICONS_LICENSE/FontAwesome/LICENSE.txt`:

```txt
Font Awesome Free License
-------------------------

Font Awesome Free is free, open source, and GPL friendly. You can use it for
commercial projects, open source projects, or really almost whatever you want.
Full Font Awesome Free license: https://fontawesome.com/license/free.

# Icons: CC BY 4.0 License (https://creativecommons.org/licenses/by/4.0/)
In the Font Awesome Free download, the CC BY 4.0 license applies to all icons
packaged as SVG and JS file types.

# Fonts: SIL OFL 1.1 License (https://scripts.sil.org/OFL)
In the Font Awesome Free download, the SIL OFL license applies to all icons
packaged as web and desktop font files.

# Code: MIT License (https://opensource.org/licenses/MIT)
In the Font Awesome Free download, the MIT license applies to all non-font and
non-icon files.

# Attribution
Attribution is required by MIT, SIL OFL, and CC BY licenses. Downloaded Font
Awesome Free files already contain embedded comments with sufficient
attribution, so you shouldn't need to do anything additional when using these
files normally.

We've kept attribution comments terse, so we ask that you do not actively work
to remove them from files, especially code. They're a great way for folks to
learn about Font Awesome.

# Brand Icons
All brand icons are trademarks of their respective owners. The use of these
trademarks does not indicate endorsement of the trademark holder by Font
Awesome, nor vice versa. **Please do not use brand logos for any purpose except
to represent the company, product, or service to which they refer.**

```

`ICONS_LICENSE/app_icon/Attribution.txt`:

```txt
APP Icon from Freepik

https://www.flaticon.com/free-icon/search-code-interface-symbol-of-a-magnifier-with-binary-code-numbers_36191
```

`ICONS_LICENSE/app_icon/LICENSE.CC_BY_NC_3.txt`:

```txt
Attribution-NonCommercial 3.0 Unported

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS.
1. Definitions
"Adaptation" means a work based upon the Work, or upon the Work and other pre-existing works, such as a translation, adaptation, derivative work, arrangement of music or other alterations of a literary or artistic work, or phonogram or performance and includes cinematographic adaptations or any other form in which the Work may be recast, transformed, or adapted including in any form recognizably derived from the original, except that a work that constitutes a Collection will not be considered an Adaptation for the purpose of this License. For the avoidance of doubt, where the Work is a musical work, performance or phonogram, the synchronization of the Work in timed-relation with a moving image ("synching") will be considered an Adaptation for the purpose of this License.
"Collection" means a collection of literary or artistic works, such as encyclopedias and anthologies, or performances, phonograms or broadcasts, or other works or subject matter other than works listed in Section 1(f) below, which, by reason of the selection and arrangement of their contents, constitute intellectual creations, in which the Work is included in its entirety in unmodified form along with one or more other contributions, each constituting separate and independent works in themselves, which together are assembled into a collective whole. A work that constitutes a Collection will not be considered an Adaptation (as defined above) for the purposes of this License.
"Distribute" means to make available to the public the original and copies of the Work or Adaptation, as appropriate, through sale or other transfer of ownership.
"Licensor" means the individual, individuals, entity or entities that offer(s) the Work under the terms of this License.
"Original Author" means, in the case of a literary or artistic work, the individual, individuals, entity or entities who created the Work or if no individual or entity can be identified, the publisher; and in addition (i) in the case of a performance the actors, singers, musicians, dancers, and other persons who act, sing, deliver, declaim, play in, interpret or otherwise perform literary or artistic works or expressions of folklore; (ii) in the case of a phonogram the producer being the person or legal entity who first fixes the sounds of a performance or other sounds; and, (iii) in the case of broadcasts, the organization that transmits the broadcast.
"Work" means the literary and/or artistic work offered under the terms of this License including without limitation any production in the literary, scientific and artistic domain, whatever may be the mode or form of its expression including digital form, such as a book, pamphlet and other writing; a lecture, address, sermon or other work of the same nature; a dramatic or dramatico-musical work; a choreographic work or entertainment in dumb show; a musical composition with or without words; a cinematographic work to which are assimilated works expressed by a process analogous to cinematography; a work of drawing, painting, architecture, sculpture, engraving or lithography; a photographic work to which are assimilated works expressed by a process analogous to photography; a work of applied art; an illustration, map, plan, sketch or three-dimensional work relative to geography, topography, architecture or science; a performance; a broadcast; a phonogram; a compilation of data to the extent it is protected as a copyrightable work; or a work performed by a variety or circus performer to the extent it is not otherwise considered a literary or artistic work.
"You" means an individual or entity exercising rights under this License who has not previously violated the terms of this License with respect to the Work, or who has received express permission from the Licensor to exercise rights under this License despite a previous violation.
"Publicly Perform" means to perform public recitations of the Work and to communicate to the public those public recitations, by any means or process, including by wire or wireless means or public digital performances; to make available to the public Works in such a way that members of the public may access these Works from a place and at a place individually chosen by them; to perform the Work to the public by any means or process and the communication to the public of the performances of the Work, including by public digital performance; to broadcast and rebroadcast the Work by any means including signs, sounds or images.
"Reproduce" means to make copies of the Work by any means including without limitation by sound or visual recordings and the right of fixation and reproducing fixations of the Work, including storage of a protected performance or phonogram in digital form or other electronic medium.
2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or restrict any uses free from copyright or rights arising from limitations or exceptions that are provided for in connection with the copyright protection under copyright law or other applicable laws.
3. License Grant. Subject to the terms and conditions of this License, Licensor hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for the duration of the applicable copyright) license to exercise the rights in the Work as stated below:
to Reproduce the Work, to incorporate the Work into one or more Collections, and to Reproduce the Work as incorporated in the Collections;
to create and Reproduce Adaptations provided that any such Adaptation, including any translation in any medium, takes reasonable steps to clearly label, demarcate or otherwise identify that changes were made to the original Work. For example, a translation could be marked "The original work was translated from English to Spanish," or a modification could indicate "The original work has been modified.";
to Distribute and Publicly Perform the Work including as incorporated in Collections; and,
to Distribute and Publicly Perform Adaptations.
The above rights may be exercised in all media and formats whether now known or hereafter devised. The above rights include the right to make such modifications as are technically necessary to exercise the rights in other media and formats. Subject to Section 8(f), all rights not expressly granted by Licensor are hereby reserved, including but not limited to the rights set forth in Section 4(d).
4. Restrictions. The license granted in Section 3 above is expressly made subject to and limited by the following restrictions:
You may Distribute or Publicly Perform the Work only under the terms of this License. You must include a copy of, or the Uniform Resource Identifier (URI) for, this License with every copy of the Work You Distribute or Publicly Perform. You may not offer or impose any terms on the Work that restrict the terms of this License or the ability of the recipient of the Work to exercise the rights granted to that recipient under the terms of the License. You may not sublicense the Work. You must keep intact all notices that refer to this License and to the disclaimer of warranties with every copy of the Work You Distribute or Publicly Perform. When You Distribute or Publicly Perform the Work, You may not impose any effective technological measures on the Work that restrict the ability of a recipient of the Work from You to exercise the rights granted to that recipient under the terms of the License. This Section 4(a) applies to the Work as incorporated in a Collection, but this does not require the Collection apart from the Work itself to be made subject to the terms of this License. If You create a Collection, upon notice from any Licensor You must, to the extent practicable, remove from the Collection any credit as required by Section 4(c), as requested. If You create an Adaptation, upon notice from any Licensor You must, to the extent practicable, remove from the Adaptation any credit as required by Section 4(c), as requested.
You may not exercise any of the rights granted to You in Section 3 above in any manner that is primarily intended for or directed toward commercial advantage or private monetary compensation. The exchange of the Work for other copyrighted works by means of digital file-sharing or otherwise shall not be considered to be intended for or directed toward commercial advantage or private monetary compensation, provided there is no payment of any monetary compensation in connection with the exchange of copyrighted works.
If You Distribute, or Publicly Perform the Work or any Adaptations or Collections, You must, unless a request has been made pursuant to Section 4(a), keep intact all copyright notices for the Work and provide, reasonable to the medium or means You are utilizing: (i) the name of the Original Author (or pseudonym, if applicable) if supplied, and/or if the Original Author and/or Licensor designate another party or parties (e.g., a sponsor institute, publishing entity, journal) for attribution ("Attribution Parties") in Licensor's copyright notice, terms of service or by other reasonable means, the name of such party or parties; (ii) the title of the Work if supplied; (iii) to the extent reasonably practicable, the URI, if any, that Licensor specifies to be associated with the Work, unless such URI does not refer to the copyright notice or licensing information for the Work; and, (iv) consistent with Section 3(b), in the case of an Adaptation, a credit identifying the use of the Work in the Adaptation (e.g., "French translation of the Work by Original Author," or "Screenplay based on original Work by Original Author"). The credit required by this Section 4(c) may be implemented in any reasonable manner; provided, however, that in the case of a Adaptation or Collection, at a minimum such credit will appear, if a credit for all contributing authors of the Adaptation or Collection appears, then as part of these credits and in a manner at least as prominent as the credits for the other contributing authors. For the avoidance of doubt, You may only use the credit required by this Section for the purpose of attribution in the manner set out above and, by exercising Your rights under this License, You may not implicitly or explicitly assert or imply any connection with, sponsorship or endorsement by the Original Author, Licensor and/or Attribution Parties, as appropriate, of You or Your use of the Work, without the separate, express prior written permission of the Original Author, Licensor and/or Attribution Parties.
For the avoidance of doubt:
Non-waivable Compulsory License Schemes. In those jurisdictions in which the right to collect royalties through any statutory or compulsory licensing scheme cannot be waived, the Licensor reserves the exclusive right to collect such royalties for any exercise by You of the rights granted under this License;
Waivable Compulsory License Schemes. In those jurisdictions in which the right to collect royalties through any statutory or compulsory licensing scheme can be waived, the Licensor reserves the exclusive right to collect such royalties for any exercise by You of the rights granted under this License if Your exercise of such rights is for a purpose or use which is otherwise than noncommercial as permitted under Section 4(b) and otherwise waives the right to collect royalties through any statutory or compulsory licensing scheme; and,
Voluntary License Schemes. The Licensor reserves the right to collect royalties, whether individually or, in the event that the Licensor is a member of a collecting society that administers voluntary licensing schemes, via that society, from any exercise by You of the rights granted under this License that is for a purpose or use which is otherwise than noncommercial as permitted under Section 4(c).
Except as otherwise agreed in writing by the Licensor or as may be otherwise permitted by applicable law, if You Reproduce, Distribute or Publicly Perform the Work either by itself or as part of any Adaptations or Collections, You must not distort, mutilate, modify or take other derogatory action in relation to the Work which would be prejudicial to the Original Author's honor or reputation. Licensor agrees that in those jurisdictions (e.g. Japan), in which any exercise of the right granted in Section 3(b) of this License (the right to make Adaptations) would be deemed to be a distortion, mutilation, modification or other derogatory action prejudicial to the Original Author's honor and reputation, the Licensor will waive or not assert, as appropriate, this Section, to the fullest extent permitted by the applicable national law, to enable You to reasonably exercise Your right under Section 3(b) of this License (right to make Adaptations) but not otherwise.
5. Representations, Warranties and Disclaimer
UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
7. Termination
This License and the rights granted hereunder will terminate automatically upon any breach by You of the terms of this License. Individuals or entities who have received Adaptations or Collections from You under this License, however, will not have their licenses terminated provided such individuals or entities remain in full compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this License.
Subject to the above terms and conditions, the license granted here is perpetual (for the duration of the applicable copyright in the Work). Notwithstanding the above, Licensor reserves the right to release the Work under different license terms or to stop distributing the Work at any time; provided, however that any such election will not serve to withdraw this License (or any other license that has been, or is required to be, granted under the terms of this License), and this License will continue in full force and effect unless terminated as stated above.
8. Miscellaneous
Each time You Distribute or Publicly Perform the Work or a Collection, the Licensor offers to the recipient a license to the Work on the same terms and conditions as the license granted to You under this License.
Each time You Distribute or Publicly Perform an Adaptation, Licensor offers to the recipient a license to the original Work on the same terms and conditions as the license granted to You under this License.
If any provision of this License is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this License, and without further action by the parties to this agreement, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.
No term or provision of this License shall be deemed waived and no breach consented to unless such waiver or consent shall be in writing and signed by the party to be charged with such waiver or consent.
This License constitutes the entire agreement between the parties with respect to the Work licensed here. There are no understandings, agreements or representations with respect to the Work not specified here. Licensor shall not be bound by any additional provisions that may appear in any communication from You. This License may not be modified without the mutual written agreement of the Licensor and You.
The rights granted under, and the subject matter referenced, in this License were drafted utilizing the terminology of the Berne Convention for the Protection of Literary and Artistic Works (as amended on September 28, 1979), the Rome Convention of 1961, the WIPO Copyright Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996 and the Universal Copyright Convention (as revised on July 24, 1971). These rights and subject matter take effect in the relevant jurisdiction in which the License terms are sought to be enforced according to the corresponding provisions of the implementation of those treaty provisions in the applicable national law. If the standard suite of rights granted under applicable copyright law includes additional rights not granted under this License, such additional rights are deemed to be included in the License; this License is not intended to restrict the license of any rights under applicable law.

```

`ICONS_LICENSE/app_icon/LICENSE.txt`:

```txt
License
=======

Icons generated with the Android Material Icon Generator are licensed under the Creative Commons Attribution-NonCommercial 3.0 License (https://creativecommons.org/licenses/by-nc/3.0/).

For commercial usage, please submit a request under https://goo.gl/forms/zX8GZ3Jz89SRyHdJ2 or send us an email to material-icons@bitdroid.de.


Google Material Icons License
=============================

This license applies to the Google Material Icons, which can be seen on the front page of the Android Material icon generator.

(Copied from https://github.com/google/material-design-icons)
We have made these icons available for you to incorporate them into your
products under the Creative Common Attribution 4.0 International License (CC-BY
4.0, https://creativecommons.org/licenses/by/4.0/). Feel free to remix and
re-share these icons and documentation in your products.  We'd love attribution
in your app's *about* screen, but it's not required.  The only thing we ask is
that you not re-sell the icons themselves.
```

`README.md`:

```md
# PCAPdroid

PCAPdroid is a privacy-friendly open source app which lets you track, analyze and block the connections made by the other apps in your device. It also allows you to export a PCAP dump of the traffic, inspect HTTP, decrypt TLS traffic and much more!

PCAPdroid simulates a VPN in order to capture the network traffic without root. It does not use a remote VPN server, instead data is processed locally on the device.

<p align="center">
<img src="https://raw.githubusercontent.com/emanuele-f/PCAPdroid/master/fastlane/metadata/android/en-US/images/phoneScreenshots/1.jpg" width="190" />
<img src="https://raw.githubusercontent.com/emanuele-f/PCAPdroid/master/fastlane/metadata/android/en-US/images/phoneScreenshots/2.jpg" width="190" />
</p>

Features:

- Log and examine the connections made by user and system apps
- Extract the SNI, DNS query, HTTP URL and the remote IP address
- Inspect HTTP requests and replies thanks to the built-in decoders
- Inspect the full connections payload as hexdump/text
- [Decrypt the HTTPS/TLS traffic](https://emanuele-f.github.io/PCAPdroid/tls_decryption) and export the SSLKEYLOGFILE
- Dump the traffic to a PCAP file, download it from a browser, or stream it to a remote receiver for real-time analysis (e.g. Wireshark)
- Create rules to filter out the good traffic and easily spot anomalies
- Identify the country and ASN of remote server via offline DB lookups
- On rooted devices, capture the traffic while other VPN apps are running

Paid features:

- [Firewall](https://emanuele-f.github.io/PCAPdroid/paid_features#51-firewall): create rules to block individual apps, domains and IP addresses
- [Malware detection](https://emanuele-f.github.io/PCAPdroid/paid_features#52-malware-detection): detect malicious connections by using third-party blacklists
- [PCAPng format](https://emanuele-f.github.io/PCAPdroid/paid_features#53-pcapng-format): makes it easier to export and analyze decrypted traffic

If you plan to use PCAPdroid to perform packet analysis, please check out <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>the specific section</a> of the manual.

<a href="https://f-droid.org/packages/com.emanuelef.remote_capture">
    <img src="https://fdroid.gitlab.io/artwork/badge/get-it-on.png"
    alt="Get it on F-Droid"
    height="80">
</a> <a href='https://play.google.com/store/apps/details?id=com.emanuelef.remote_capture'><img height="80" alt='Get it on Google Play' src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png'/></a>

You can test the latest features before the official release by adding the [Beta repository](https://pcapdroid.org/fdroid/repo/) to the F-Droid app.

## User Guide

Check out the [quick start instructions](https://emanuele-f.github.io/PCAPdroid/quick_start) or the full [User Guide](https://emanuele-f.github.io/PCAPdroid).

## Sponsors

The PCAPdroid project is sponsored by [AVEQ GmbH](https://aveq.info).

If you want to sponsor this project [drop me an email](mailto:black.silver@hotmail.it?subject=PCAPdroid%20sponsorship).

## Community

You can help the PCAPdroid project in many ways:

- [Make a donation](https://emanuele-f.github.io/PCAPdroid/donate)
- Translate the app on [Weblate](https://hosted.weblate.org/engage/pcapdroid/)
<a href="https://hosted.weblate.org/engage/pcapdroid/">
  <img src="https://hosted.weblate.org/widgets/pcapdroid/-/app/multi-auto.svg" alt="Translation status" />
</a>

- [Discuss](https://github.com/emanuele-f/PCAPdroid/discussions) new features
- Improve the app theme and layout
- Star the project on Github and on [Google Play](https://play.google.com/store/apps/details?id=com.emanuelef.remote_capture)
- Of course provide code pull requests!

Join the international PCAPdroid community [on Telegram](https://t.me/PCAPdroid) or [on Matrix](https://matrix.to/#/#pcapdroid:matrix.org).

## Integrating into your APP

Some features of PCAPdroid can be integrated into a third-party app to provide packet capture capabilities.

- For rooted devices, the [pcapd daemon](https://github.com/emanuele-f/PCAPdroid/tree/master/app/src/main/jni/pcapd) can be directly integrated into your APK to capture network packets.
- For all the devices, PCAPdroid [exposes an API](https://github.com/emanuele-f/PCAPdroid/blob/master/docs/app_api.md) to control the packet capture and send the captured packets via UDP to your app. This requires to install PCAPdroid along with your app.

## Open Source

PCAPdroid is powered by open source technologies.

- [nDPI](https://github.com/ntop/nDPI): deep packet inspection library, provides the connections metadata
- [mitmproxy](https://github.com/mitmproxy/mitmproxy): a local proxy for the TLS decryption
- [zdtun](https://github.com/emanuele-f/zdtun): minimal TCP/IP stack for the non-root capture

For the complete list of third party libraries check out the "About" page in the app.

## Building

1. On Windows, install [gitforwindows](https://gitforwindows.org)
2. Clone this repo
3. Inside the repo dir, run `git submodule update --init`. The `submodules` directory should get populated.
4. Open the project in Android Studio, install the appropriate SDK and the NDK
5. Build the app

*Note*: If you get "No valid CMake executable was found", be sure to install the CMake version used by PCAPdroid (currently [3.22.1](https://github.com/emanuele-f/PCAPdroid/blob/master/app/build.gradle)) from the SDK manager


```

`app/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    ndkVersion "28.2.13676358"

    defaultConfig {
        applicationId "com.emanuelef.remote_capture"
        minSdkVersion 21
        compileSdk 35
        targetSdk 35
        versionCode 91
        versionName "1.9.1"

        // only include full translations
        // NOTE: keep in sync with locales_config.xml
        resourceConfigurations += ["en", "ar", "az", "de", "es", "in", "it", "pl", "pt-rBR", "ru", "ta", "tr",
                                   "uk", "zh-rCN"]
    }

    flavorDimensions = ["type"]

    productFlavors {
        /* Note: alphabetical order determines the default flavor, which is standard */
        standard {
            dimension "type"
        }

        withoutUshark {
            dimension "type"
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            // Use a different app ID for debug to allow its coexistence with release builds
            applicationIdSuffix '.debug'
            versionNameSuffix '-beta'
            pseudoLocalesEnabled true

            if(project.hasProperty("doNotStrip")) {
                // NOTE: packagingOptions will also affect the "release" build, so the "doNotStrip"
                // guard is required
                packagingOptions {
                    // NOTE: unstripped nDPI library takes up about 4 MB!
                    //doNotStrip '**.so'
                    doNotStrip '**/libpcapd.so'
                    doNotStrip '**/libcapture.so'
                }
            }
        }
    }

    buildFeatures {
        buildConfig = true
    }

    packagingOptions {
        jniLibs {
            // NOTE: needed to unpack libpcapd.so when installed as app bundle
            useLegacyPackaging = true
        }
    }

    externalNativeBuild {
        cmake {
            path file('src/main/jni/CMakeLists.txt')
            version "3.22.1"
        }
    }

    compileOptions {
        encoding "UTF-8"
        coreLibraryDesugaringEnabled true // support devices running older Java versions
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    sourceSets {
        main.java.srcDirs += '../submodules/MaxMind-DB-Reader-java/src/main/java'

        // Note: must use "setRoot" to make this a per-flavor setting
        standard.setRoot('../submodules/PCAPdroid-ushark-bin/release')
    }

    testOptions {
        // needed by robolectric
        unitTests.includeAndroidResources = true
        unitTests.all {
            systemProperty "java.library.path", "${buildDir}/hostJni"
        }
    }
    namespace 'com.emanuelef.remote_capture'
}

// Build zstd JNI for the host platform (needed by unit tests)
tasks.register('buildHostZstdJni') {
    def jniSrcDir = file("src/main/jni/zstd")
    def cmakeBuildDir = "${buildDir}/hostJni/cmake"
    def outputDir = "${buildDir}/hostJni"

    inputs.dir(jniSrcDir)
    inputs.dir("${rootDir}/submodules/zstd/lib")
    outputs.dir(outputDir)

    doLast {
        exec {
            commandLine 'cmake', '-S', jniSrcDir, '-B', cmakeBuildDir,
                "-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=${outputDir}"
        }
        exec {
            commandLine 'cmake', '--build', cmakeBuildDir
        }
    }
}

tasks.configureEach { task ->
    if (task.name.startsWith("test") && task.name.endsWith("UnitTest")) {
        task.dependsOn buildHostZstdJni
    }
}

dependencies {
// Tests
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'androidx.test:core:1.7.0'
    testImplementation "org.robolectric:robolectric:4.16.1"

// AndroidX
    implementation 'androidx.appcompat:appcompat:1.7.1'
    implementation 'androidx.constraintlayout:constraintlayout:2.2.1'
    implementation 'androidx.fragment:fragment:1.8.9'
    implementation 'androidx.localbroadcastmanager:localbroadcastmanager:1.1.0'
    implementation 'androidx.preference:preference:1.2.1'
    implementation 'androidx.recyclerview:recyclerview:1.4.0'
    implementation "androidx.navigation:navigation-fragment:2.9.7"
    implementation "androidx.navigation:navigation-ui:2.9.7"
    coreLibraryDesugaring 'com.android.tools:desugar_jdk_libs:2.1.5'

// Google
    implementation 'com.google.android.material:material:1.13.0'
    implementation 'com.google.code.gson:gson:2.13.2'
    implementation 'org.brotli:dec:0.1.2'

// Third-party
    implementation 'cat.ereza:customactivityoncrash:2.4.0'
    implementation 'com.github.KaKaVip:Android-Flag-Kit:v0.1'
    implementation 'com.github.AppIntro:AppIntro:6.2.0'
    implementation 'com.github.androidmads:QRGenerator:1.0.1'
}

```

`app/proguard-rules.pro`:

```pro
-keepattributes LineNumberTable,SourceFile
-renamesourcefileattribute SourceFile
-dontobfuscate

# some classes are required by the native code, keep them all for now
-keep class com.emanuelef.remote_capture.** { *; }
-keep class com.pcapdroid.mitm.** { *; }
-keep class com.maxmind.db.** { *; }
```

`app/src/debug/res/values/strings.xml`:

```xml
<resources>
    <string name="pcapdroid_app_name" translatable="false">PCAPdroid (beta)</string>
</resources>

```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission-sdk-23 android:name="android.permission.QUERY_ALL_PACKAGES" /> <!-- https://developer.android.com/preview/privacy/package-visibility -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.WRITE_CLIPS" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" tools:ignore="ScopedStorage" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE"/>

    <!-- Required with root to properly resolve UIDs cross-users/profiles. Granted via root -->
    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS" android:protectionLevel="signature"  tools:ignore="ProtectedPermissions" />

    <uses-feature android:name="android.software.leanback" android:required="false" />
    <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
    <uses-feature android:name="android.hardware.wifi" android:required="false" />

    <application
        android:name=".PCAPdroid"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/pcapdroid_app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:banner="@drawable/banner"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        android:allowBackup="true"
        tools:replace="android:label"
        android:localeConfig="@xml/locales_config"
        tools:targetApi="tiramisu">

        <activity
            android:name=".activities.MainActivity"
            android:theme="@style/AppTheme.SplashScreen"
            android:launchMode="singleTop"
            android:exported="true">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
                <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
            </intent-filter>
        </activity>

        <activity
            android:name=".activities.CaptureCtrl"
            android:theme="@style/AppTheme.Floating"
            android:launchMode="singleTop"
            android:exported="true" />
        <activity
            android:name=".activities.prefs.EditCtrlPermissions"
            android:parentActivityName=".activities.prefs.SettingsActivity" />

        <activity
            android:name=".activities.OnBoardingActivity" />
        <activity
            android:name=".activities.ErrorActivity" />
        <activity
            android:name=".activities.ConnectionDetailsActivity" />
        <activity
            android:name=".activities.AppDetailsActivity" />
        <activity
            android:name=".activities.ConnectionsActivity" />
        <activity
            android:name=".activities.HttpDetailsActivity" />
        <activity
            android:name=".activities.AppsActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.MainActivity" />
        <activity
            android:name=".activities.StatsActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.MainActivity"/>
        <activity
            android:name=".activities.prefs.SettingsActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.MainActivity" />
        <activity
            android:name=".activities.prefs.VpnExemptionsActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.prefs.SettingsActivity" />
        <activity
            android:name=".activities.prefs.PortMapActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.prefs.SettingsActivity" />
        <activity
            android:name=".activities.AboutActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.MainActivity" />
        <activity
            android:name=".activities.LogviewActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.MainActivity" />
        <activity
            android:name=".activities.MalwareDetection"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.MainActivity" />
        <activity
            android:name=".activities.FirewallActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.MainActivity" />
        <activity
            android:name=".activities.EditListActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.EditFilterActivity" />
        <activity
            android:name=".activities.EditFilterActivity"
            android:launchMode="singleTop" />
        <activity
            android:name=".activities.HttpLogFilterActivity"
            android:launchMode="singleTop" />
        <activity
            android:name=".activities.MitmSetupWizard"
            android:launchMode="singleTop" />
        <activity
            android:name=".activities.AppFilterActivity"
            android:launchMode="singleTop"
            android:parentActivityName=".activities.MainActivity" />

        <service
            android:name=".CaptureService"
            android:permission="android.permission.BIND_VPN_SERVICE"
            android:foregroundServiceType="specialUse"
            android:exported="false">

            <property android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="run the VpnService to monitor network traffic"/>

            <intent-filter>
                <action android:name="android.net.VpnService" />
            </intent-filter>
        </service>
        <service
            android:name=".VpnReconnectService"
            android:foregroundServiceType="specialUse"
            android:exported="false">

            <property android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="waits for the termination of the active VpnService"/>
        </service>

        <receiver android:name="com.emanuelef.remote_capture.ActionReceiver" />

        <receiver
            android:name=".BootReceiver"
            android:exported="false">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED"/>
                <action android:name="android.intent.action.QUICKBOOT_POWERON"/>
            </intent-filter>
        </receiver>
    </application>

</manifest>
```

`app/src/main/java/com/emanuelef/remote_capture/ActionReceiver.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import androidx.core.app.NotificationManagerCompat;

import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.Blocklist;

public class ActionReceiver extends BroadcastReceiver {
    public static final String EXTRA_UNBLOCK_APP = "unblock_app";
    private static final String TAG = "TAG";

    @Override
    public void onReceive(Context context, Intent intent) {
        String unblock_app = intent.getStringExtra(EXTRA_UNBLOCK_APP);

        if((unblock_app != null) && !unblock_app.isEmpty()) {
            Log.d(TAG, "unblock_app: " + unblock_app);
            Blocklist blocklist = PCAPdroid.getInstance().getBlocklist();
            blocklist.removeApp(unblock_app);
            blocklist.saveAndReload();

            // remove notification
            NotificationManagerCompat man = NotificationManagerCompat.from(context);
            man.cancel(CaptureService.NOTIFY_ID_APP_BLOCKED);

            AppDescriptor app = AppsResolver.resolveInstalledApp(context.getPackageManager(), unblock_app, 0);
            String label = (app != null) ? app.getName() : unblock_app;
            Utils.showToastLong(context, R.string.app_unblocked, label);
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/AppsLoader.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.annotation.SuppressLint;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.util.ArrayMap;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.loader.app.LoaderManager;
import androidx.loader.content.AsyncTaskLoader;
import androidx.loader.content.Loader;

import com.emanuelef.remote_capture.interfaces.AppsLoadListener;
import com.emanuelef.remote_capture.model.AppDescriptor;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class AppsLoader implements LoaderManager.LoaderCallbacks<ArrayList<AppDescriptor>> {
    private static final String TAG = "AppsLoader";
    private static final int OPERATION_LOAD_APPS_INFO = 23;
    private AppsLoadListener mListener;
    private final AppCompatActivity mContext;
    private static final String TERMUX_PACKAGE = "com.termux";

    public AppsLoader(AppCompatActivity context) {
        mContext = context;
    }

    public AppsLoader setAppsLoadListener(AppsLoadListener listener) {
        mListener = listener;
        return this;
    }

    @SuppressLint("QueryPermissionsNeeded")
    private ArrayList<AppDescriptor> asyncLoadAppsInfo() {
        final PackageManager pm = mContext.getPackageManager();
        ArrayList<AppDescriptor> apps = new ArrayList<>();
        ArrayMap<Integer, Integer> uid_to_pos = new ArrayMap<>();

        Log.d(TAG, "Loading APPs...");
        List<PackageInfo> packs = Utils.getInstalledPackages(pm, 0);

        String app_package = mContext.getApplicationContext().getPackageName();

        Log.d(TAG, "num apps (system+user): " + packs.size());
        long tstart = Utils.now();

        PackageInfo termuxPkgInfo = null;

        // NOTE: a single uid can correspond to multiple packages, only take the first package found.
        // The VPNService in android works with UID, so this choice is not restrictive.
        for (int i = 0; i < packs.size(); i++) {
            PackageInfo p = packs.get(i);
            String package_name = p.applicationInfo.packageName;

            if (package_name.equals(TERMUX_PACKAGE))
                termuxPkgInfo = p;

            if(!uid_to_pos.containsKey(p.applicationInfo.uid) && !package_name.equals(app_package)) {
                int uid = p.applicationInfo.uid;
                AppDescriptor app = new AppDescriptor(pm, p);

                uid_to_pos.put(uid, apps.size());
                apps.add(app);

                //Log.d(TAG, appName + " - " + package_name + " [" + uid + "]" + (is_system ? " - SYS" : " - USR"));
            }
        }

        if (termuxPkgInfo != null) {
            // termux packages share the same UID. Use the main package if available. See #253
            int uid = termuxPkgInfo.applicationInfo.uid;
            Integer pos = uid_to_pos.get(uid);

            if (pos != null) {
                apps.remove(pos.intValue());
                apps.add(new AppDescriptor(pm, termuxPkgInfo));
            }
        }

        Collections.sort(apps);

        Log.d(TAG, packs.size() + " apps loaded in " + (Utils.now() - tstart) +" seconds");
        return apps;
    }

    @NonNull
    @Override
    public Loader<ArrayList<AppDescriptor>> onCreateLoader(int opid, @Nullable Bundle args) {
        return new AsyncTaskLoader<ArrayList<AppDescriptor>>(mContext) {
            @NonNull
            @Override
            public ArrayList<AppDescriptor> loadInBackground() {
                ArrayList<AppDescriptor> empty_res = new ArrayList<>();

                if(opid == OPERATION_LOAD_APPS_INFO)
                    return asyncLoadAppsInfo();

                Log.e(TAG, "unknown loader op: " + opid);
                return empty_res;
            }
        };
    }

    @Override
    public void onLoadFinished(@NonNull Loader<ArrayList<AppDescriptor>> loader, ArrayList<AppDescriptor> data) {
        if(mListener != null)
            mListener.onAppsInfoLoaded(data);

        finishLoader();
    }

    @Override
    public void onLoaderReset(@NonNull Loader<ArrayList<AppDescriptor>> loader) {
        Log.d(TAG, "onLoaderReset");
    }

    private void runLoader(int opid, ArrayList<AppDescriptor> data) {
        LoaderManager lm = LoaderManager.getInstance(mContext);
        Loader<ArrayList<AppDescriptor>> loader = lm.getLoader(opid);

        Bundle bundle = new Bundle();
        bundle.putSerializable("apps", data);

        Log.d(TAG, "Existing loader " + opid + "? " + (loader != null));

        loader = lm.initLoader(opid, bundle, this);
        loader.forceLoad();
    }

    private void finishLoader() {
        // Destroy the loader to reduce the memory usage and also to possibly load new apps on next run
        LoaderManager lm = LoaderManager.getInstance(mContext);
        lm.destroyLoader(OPERATION_LOAD_APPS_INFO);
    }

    public AppsLoader loadAllApps() {
        // IMPORTANT: loading all the icons is not a good idea, as they consume much memory
        runLoader(OPERATION_LOAD_APPS_INFO, null);
        return this;
    }

    public void abort() {
        finishLoader();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/AppsResolver.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.graphics.drawable.Drawable;
import android.util.ArrayMap;
import android.util.SparseArray;

import com.emanuelef.remote_capture.interfaces.DrawableLoader;
import com.emanuelef.remote_capture.model.AppDescriptor;

import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class AppsResolver {
    private static final String TAG = "AppsResolver";
    private static final SparseArray<AppDescriptor> mMappedUids = new SparseArray<>();
    private static final ArrayMap<String, AppDescriptor> mMappedPackages = new ArrayMap<>();
    private final SparseArray<AppDescriptor> mApps;
    private final PackageManager mPm;
    private final Context mContext;
    private Method getPackageInfoAsUser;
    private boolean mFallbackToGlobalResolution;
    private Drawable mVirtualAppIcon;

    public AppsResolver(Context context) {
        mApps = new SparseArray<>();
        mContext = context;
        mPm = context.getPackageManager();

        initVirtualApps();
    }

    private void initVirtualApps() {
        // Use loaders to only load the bitmap in memory if requested via AppDescriptor.getIcon()
        final DrawableLoader virtualIconLoader = () -> {
            // cache this to avoid copies
            if(mVirtualAppIcon == null)
                mVirtualAppIcon = ContextCompat.getDrawable(mContext, android.R.drawable.sym_def_app_icon);
            return mVirtualAppIcon;
        };
        final DrawableLoader unknownIconLoader = () -> ContextCompat.getDrawable(mContext, android.R.drawable.ic_menu_help);

        // https://android.googlesource.com/platform/system/core/+/master/libcutils/include/private/android_filesystem_config.h
        // NOTE: these virtual apps cannot be used as a permanent filter (via addAllowedApplication)
        // as they miss a valid package name
        mApps.put(Utils.UID_UNKNOWN, new AppDescriptor(mContext.getString(R.string.unknown_app),
             unknownIconLoader, "unknown", Utils.UID_UNKNOWN, true)
            .setDescription(mContext.getString(R.string.unknown_app_info)));
        mApps.put(0, new AppDescriptor("Root",
                virtualIconLoader,"root", 0, true)
                .setDescription(mContext.getString(R.string.root_app_info)));
        mApps.put(1000, new AppDescriptor("Android",
                virtualIconLoader,"android", 1000, true)
                .setDescription(mContext.getString(R.string.android_app_info)));
        mApps.put(1001, new AppDescriptor(mContext.getString(R.string.phone_app),
                virtualIconLoader,"phone", 1001, true)
                .setDescription(mContext.getString(R.string.phone_app_info)));
        mApps.put(1013, new AppDescriptor("MediaServer",
                virtualIconLoader,"mediaserver", 1013, true));
        mApps.put(1020, new AppDescriptor("MulticastDNSResponder",
                virtualIconLoader,"multicastdnsresponder", 1020, true));
        mApps.put(1021, new AppDescriptor("GPS",
                virtualIconLoader,"gps", 1021, true));
        mApps.put(1051, new AppDescriptor("netd",
                virtualIconLoader,"netd", 1051, true)
                 .setDescription(mContext.getString(R.string.netd_app_info)));
        mApps.put(9999, new AppDescriptor("Nobody",
                virtualIconLoader,"nobody", 9999, true));
    }

    public synchronized static void clearMappedApps() {
        mMappedUids.clear();
        mMappedPackages.clear();
    }

    // Map the uid to the given package_name and app_name
    // This is need for apps which are not installed in this device
    public synchronized static void addMappedApp(int uid, String packageName, String appName) {
        AppDescriptor dsc = new AppDescriptor(appName, null, packageName, uid, false);
        mMappedUids.put(uid, dsc);
        mMappedPackages.put(packageName, dsc);
    }

    private synchronized static AppDescriptor getMappedApp(int uid) {
        return mMappedUids.get(uid);
    }

    private synchronized static AppDescriptor getMappedApp(String packageName) {
        return mMappedPackages.get(packageName);
    }

    // Get the AppDescriptor corresponding to the given package name
    // No caching occurs. Virtual apps cannot be used.
    // This is public to provide a fast resolution alternative to getAppByPackage
    public static AppDescriptor resolveInstalledApp(PackageManager pm, String packageName, int pm_flags, boolean warn_not_found) {
        AppDescriptor dsc = getMappedApp(packageName);
        if (dsc != null)
            return dsc;

        PackageInfo pinfo;

        try {
            pinfo = Utils.getPackageInfo(pm, packageName, pm_flags);
        } catch (PackageManager.NameNotFoundException e) {
            if(warn_not_found)
                Log.w(TAG, "could not retrieve package: " + packageName);
            return null;
        }

        return new AppDescriptor(pm, pinfo);
    }

    public static AppDescriptor resolveInstalledApp(PackageManager pm, String packageName, int pm_flags) {
        return resolveInstalledApp(pm, packageName, pm_flags, true);
    }

    @SuppressLint("DiscouragedPrivateApi")
    public @Nullable AppDescriptor getAppByUid(int uid, int pm_flags) {
        AppDescriptor dsc = getMappedApp(uid);
        if (dsc != null)
            return dsc;

        AppDescriptor app = mApps.get(uid);
        if(app != null)
            return app;

        // Map the uid to the package name(s)
        String[] packages = null;

        try {
            packages = mPm.getPackagesForUid(uid);
        } catch (SecurityException e) {
            // A SecurityException is normally raised when trying to query a package of another user/profile
            // without holding the INTERACT_ACROSS_USERS/INTERACT_ACROSS_PROFILES permissions
            e.printStackTrace();
        }

        if((packages == null) || (packages.length < 1)) {
            Log.w(TAG, "could not retrieve package: uid=" + uid);
            return null;
        }

        // Impose order to guarantee that a uid is always mapped to the same package name.
        // The mapping may change if a package sharing this UID is installed/removed.
        // For simplicity we ignore this change at runtime, and only address it in persistent data
        // (e.g. in the MatchList to ensure that a user can always remove rules see #257)
        String packageName = packages[0];
        for(String pkg: packages) {
            if(pkg.compareTo(packageName) < 0)
                packageName = pkg;
        }

        // In case of root capture, we may be capturing traffic of different users/work profiles.
        // To get the correct label and icon, try to resolve the app as the specific user of the connection.
        if(!mFallbackToGlobalResolution && CaptureService.isCapturingAsRoot()) {
            try {
                if(getPackageInfoAsUser == null)
                    getPackageInfoAsUser = PackageManager.class.getDeclaredMethod("getPackageInfoAsUser", String.class, int.class, int.class);

                PackageInfo pinfo = (PackageInfo) getPackageInfoAsUser.invoke(mPm, packageName, pm_flags, Utils.getUserId(uid));
                if(pinfo != null)
                    app = new AppDescriptor(mPm, pinfo);
            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                Log.w(TAG, "getPackageInfoAsUser call fails, falling back to standard resolution");
                e.printStackTrace();
                mFallbackToGlobalResolution = true;
            }
        }

        if(app == null)
            app = resolveInstalledApp(mPm, packageName, pm_flags);

        if(app != null)
            mApps.put(uid, app);

        return app;
    }

    public @Nullable AppDescriptor getAppByPackage(String package_name, int pm_flags) {
        int uid = getUid(package_name);
        if(uid == Utils.UID_NO_FILTER)
            return null;

        return getAppByUid(uid, pm_flags);
    }

    /* Lookup a UID by package name (including virtual apps).
     * UID_NO_FILTER is returned if no match is found. */
    public int getUid(String package_name) {
        AppDescriptor dsc = getMappedApp(package_name);
        if (dsc != null)
            return dsc.getUid();

        if(!package_name.contains(".")) {
            // This is a virtual app
            for(int i=0; i<mApps.size(); i++) {
                AppDescriptor app = mApps.valueAt(i);

                if(app.getPackageName().equals(package_name))
                    return app.getUid();
            }
        } else {
            try {
                return Utils.getPackageUid(mPm, package_name, 0);
            } catch (PackageManager.NameNotFoundException e) {
                Log.w(TAG, "Could not retrieve package " + package_name);
                //e.printStackTrace();
            }
        }

        // Not found
        return Utils.UID_NO_FILTER;
    }

    public void clear() {
        mApps.clear();
        initVirtualApps();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/Billing.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import android.provider.Settings;

import androidx.collection.ArraySet;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.model.Prefs;

import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

/* Billing stub */
public class Billing {
    private static final String TAG = "Billing";
    private static final String KEY = "ME4wEAYHKoZIzj0CAQYFK4EEACEDOgAE6cS1N1P0kaiuxq0g70OVVE0uIOD+t809" +
            "Etg3k2h11k8uNvfkx3mL1HTjQyzSfdueyY4DqTW7+sk=";
    private static final String PEER_SKU_KEY = "peer_skus";

    // SKUs
    public static final String SUPPORTER_SKU = "pcapdroid_supporter";
    public static final String UNLOCK_TOKEN_SKU = "unlock_code";
    public static final String MALWARE_DETECTION_SKU = "malware_detection";
    public static final String FIREWALL_SKU = "no_root_firewall";
    public static final String PCAPNG_SKU = "pcapng";
    public static final List<String> ALL_SKUS = Arrays.asList(
            SUPPORTER_SKU, UNLOCK_TOKEN_SKU, MALWARE_DETECTION_SKU, FIREWALL_SKU, PCAPNG_SKU
    );

    // Resources used in the play build, referenced here to avoid being marked as unused resources
    private static final int[] res_placeholder = {
            R.string.billing_connecting, R.string.pending_transaction,
            R.string.feature_not_available, R.string.show_me,
            R.string.loading, R.string.purchased,
            R.string.no_items_for_purchase, R.string.billing_failure,
            R.string.learn_more, R.string.buy_action,
            R.string.can_use_purchased_feature, R.drawable.ic_shopping_cart,
            R.string.firewall_summary, R.string.no_root_firewall,
            R.string.unlock_token, R.string.unlock_token_summary, R.string.unlock_token_error,
            R.string.license_service_unavailable, R.string.requesting_unlock_token, R.string.show_action, R.string.unlock_token_msg1,
            R.string.qr_license_confirm, R.string.qr_purchase_required, R.string.license_limit_reached,
            R.string.license_error, R.string.requesting_license
    };

    protected final Context mContext;
    protected SharedPreferences mPrefs;

    // this is initialized in MainActivity
    private static final ArraySet<String> mPeerSkus = new ArraySet<>();

    protected Billing(Context ctx) {
        mContext = ctx;
        mPrefs = PreferenceManager.getDefaultSharedPreferences(ctx);

        // Load peer skus
        Set<String> peer_skus = mPrefs.getStringSet(PEER_SKU_KEY, null);
        if(peer_skus != null)
            mPeerSkus.addAll(peer_skus);
    }

    public static Billing newInstance(Context ctx) {
        return new Billing(ctx);
    }

    public boolean isAvailable(String sku) {
        return isPurchased(sku);
    }

    public boolean isPurchased(String sku) {
        if(mPeerSkus.contains(sku))
            return true;

        return !getLicense().isEmpty();
    }

    public boolean isPlayStore() {
        return false;
    }

    public String getLicense() {
        return mPrefs.getString("license", "");
    }

    public void connectBilling() {}
    public void disconnectBilling() {}

    public boolean setLicense(String license) {
        boolean valid = true;
        if(!isValidLicense(license)) {
            license = "";
            valid = false;
        }

        mPrefs.edit()
                .putString("license", license)
                .apply();

        return valid;
    }

    public boolean isValidLicense(String license) {
        if(license.isEmpty())
            return false;

        try {
            // license data provided by the user
            byte[] data = Utils.base32Decode(license);
            if((data.length != 60) || (data[0] != 'v') || (data[1] != '1'))
                return false;

            KeyFactory keyFactory = KeyFactory.getInstance("EC");
            PublicKey pk = keyFactory.generatePublic(new X509EncodedKeySpec(android.util.Base64.decode(KEY, android.util.Base64.DEFAULT)));
            Signature sig = Signature.getInstance("SHA1withECDSA");
            sig.initVerify(pk);

            String msg = SUPPORTER_SKU + "@" + getInstallationId();
            sig.update(msg.getBytes(StandardCharsets.US_ASCII));
            return sig.verify(getASN1(data, 4));
        } catch (NoSuchAlgorithmException | InvalidKeySpecException | InvalidKeyException
                | SignatureException | IllegalArgumentException e) {
            Log.d(TAG, e.getMessage());
            return false;
        }
    }

    @SuppressWarnings("deprecation")
    public String getInstallationId() {
        // NOTE: On Android >= O, the ID is unique to each combination of package, key, user and device
        String installation_id = (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) ?
                Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.ANDROID_ID) :
                Build.SERIAL;

        try {
            // Calculate the MD5 to provide a consistent output and to increase privacy on Android < O
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            byte[] digest = md5.digest(installation_id.getBytes());
            installation_id = "M" + Utils.byteArrayToHex(digest, 8);
        } catch (NoSuchAlgorithmException e) {
            // Should never happen
            e.printStackTrace();
            installation_id = "D" + installation_id;
        }

        return installation_id;
    }

    private byte[] getASN1(byte[] signature, int offset) {
        int r_len = 28;

        if((signature.length - offset) != 2*r_len)
            throw new IllegalArgumentException("invalid signature length");

        int r_extra = (signature[offset] < 0) ? 1 : 0;
        int n_extra = (signature[offset + r_len] < 0) ? 1 : 0;
        int tot_len = 2*r_len + 6 + r_extra + n_extra;
        byte[] rv = new byte[tot_len];
        int i = 0;

        rv[i++] = 0x30; rv[i++] = (byte)(tot_len - 2);

        rv[i++] = 0x02; rv[i++] = (byte)(r_len + r_extra);
        if(r_extra > 0) rv[i++] = 0x00;
        System.arraycopy(signature, offset, rv, i, r_len);
        i += 28;

        rv[i++] = 0x02; rv[i++] = (byte)(r_len + n_extra);
        if(n_extra > 0) rv[i++] = 0x00;
        System.arraycopy(signature, offset + r_len, rv, i, r_len);

        return rv;
    }

    public boolean isFirewallVisible() {
        if(!isPurchased(Billing.FIREWALL_SKU))
            return false;

        if(CaptureService.isServiceActive())
            return !CaptureService.isCapturingAsRoot() && !CaptureService.isReadingFromPcapFile();
        else
            return !Prefs.isRootCaptureEnabled(mPrefs);
    }

    public void handlePeerSkus(Set<String> skus) {
        if(skus.equals(mPeerSkus))
            return; // nothing changed

        mPeerSkus.clear();
        mPeerSkus.addAll(skus);

        Log.i(TAG, "Peer skus updated: " + skus);

        mPrefs.edit()
                .putStringSet(PEER_SKU_KEY, mPeerSkus)
                .apply();
    }

    public void clearPeerSkus() {
        handlePeerSkus(new ArraySet<>());
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/Blacklists.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.SystemClock;
import android.util.ArrayMap;

import androidx.collection.ArraySet;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.interfaces.BlacklistsStateListener;
import com.emanuelef.remote_capture.model.BlacklistDescriptor;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import java.io.File;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;

/* Represents the malware blacklists.
 * The blacklists are hard-coded via the Blacklists.addList calls. Blacklists update is performed
 * as follows:
 *
 * 1. If Blacklists.needsUpdate return true, Blacklists.update downloads the blacklists files
 * 2. The reloadBlacklists native method is called to inform the capture thread
 * 3. The capture thread loads the blacklists in memory
 * 4. When the loading is complete, the Blacklists.onNativeLoaded method is called.
 *
 * NOTE: use via PCAPdroid.getInstance().getBlacklists()
 */
public class Blacklists {
    public static final String PREF_BLACKLISTS_STATUS = "blacklists_status";
    public static final long BLACKLISTS_UPDATE_MILLIS = 86400 * 1000; // 1d
    private static final String TAG = "Blacklists";
    private final ArrayList<BlacklistDescriptor> mLists = new ArrayList<>();
    private final ArrayMap<String, BlacklistDescriptor> mListByFname = new ArrayMap<>();
    private final ArrayList<BlacklistsStateListener> mListeners = new ArrayList<>();
    private final SharedPreferences mPrefs;
    private final Context mContext;
    private boolean mUpdateInProgress;
    private boolean mStopRequest;
    private long mLastUpdate;
    private long mLastUpdateMonotonic;
    private int mNumDomainRules;
    private int mNumIPRules;

    public Blacklists(Context ctx) {
        mLastUpdate = 0;
        mLastUpdateMonotonic = -BLACKLISTS_UPDATE_MILLIS;
        mNumDomainRules = 0;
        mNumIPRules = 0;
        mContext = ctx;
        mUpdateInProgress = false;
        mPrefs = PreferenceManager.getDefaultSharedPreferences(ctx);

        // Domains
        addList("Maltrail", BlacklistDescriptor.Type.DOMAIN_BLACKLIST,"maltrail-malware-domains.txt",
                "https://raw.githubusercontent.com/stamparm/aux/master/maltrail-malware-domains.txt");

        // IPs
        addList("Emerging Threats", BlacklistDescriptor.Type.IP_BLACKLIST, "emerging-Block-IPs.txt",
                "https://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt");
        addList("DigitalSide Threat-Intel", BlacklistDescriptor.Type.IP_BLACKLIST,  "digitalsideit_ips.txt",
                "https://raw.githubusercontent.com/davidonzo/Threat-Intel/master/lists/latestips.txt");

        // To review
        //https://github.com/StevenBlack/hosts
        //https://phishing.army/download/phishing_army_blocklist.txt
        //https://snort.org/downloads/ip-block-list

        deserialize();
        checkFiles();
    }

    private void addList(String label, BlacklistDescriptor.Type tp, String fname, String url) {
        BlacklistDescriptor item = new BlacklistDescriptor(label, tp, fname, url);
        mLists.add(item);
        mListByFname.put(fname, item);
    }

    public void deserialize() {
        String serialized = mPrefs.getString(PREF_BLACKLISTS_STATUS, "");
        if(!serialized.isEmpty()) {
            JsonObject obj = JsonParser.parseString(serialized).getAsJsonObject();
            mLastUpdate = obj.getAsJsonPrimitive("last_update").getAsLong();
            mNumDomainRules = obj.getAsJsonPrimitive("num_domain_rules").getAsInt();
            mNumIPRules = obj.getAsJsonPrimitive("num_ip_rules").getAsInt();

            // set the monotonic time based on the last update wall clock time
            long millis_since_last_update = System.currentTimeMillis() - mLastUpdate;
            if (millis_since_last_update > 0)
                mLastUpdateMonotonic = SystemClock.elapsedRealtime() - millis_since_last_update;

            JsonObject blacklists_obj = obj.getAsJsonObject("blacklists");
            if(blacklists_obj != null) { // support old format
                for(Map.Entry<String, JsonElement> bl_entry: blacklists_obj.entrySet()) {
                    BlacklistDescriptor bl = mListByFname.get(bl_entry.getKey());
                    if(bl != null) {
                        JsonObject bl_obj = bl_entry.getValue().getAsJsonObject();

                        bl.num_rules = bl_obj.getAsJsonPrimitive("num_rules").getAsInt();
                        bl.setUpdated(bl_obj.getAsJsonPrimitive("last_update").getAsLong());
                    }
                }
            }
        }
    }

    private static class Serializer implements JsonSerializer<Blacklists> {
        @Override
        public JsonElement serialize(Blacklists src, Type typeOfSrc, JsonSerializationContext context) {
            JsonObject blacklists_obj = new JsonObject();

            for(BlacklistDescriptor bl: src.mLists) {
                JsonObject bl_obj = new JsonObject();

                bl_obj.add("num_rules", new JsonPrimitive(bl.num_rules));
                bl_obj.add("last_update", new JsonPrimitive(bl.getLastUpdate()));
                blacklists_obj.add(bl.fname, bl_obj);
            }

            JsonObject rv = new JsonObject();
            rv.add("last_update", new JsonPrimitive(src.mLastUpdate));
            rv.add("num_domain_rules", new JsonPrimitive(src.mNumDomainRules));
            rv.add("num_ip_rules", new JsonPrimitive(src.mNumIPRules));
            rv.add("blacklists", blacklists_obj);

            return rv;
        }
    }

    public String toJson() {
        Gson gson = new GsonBuilder().registerTypeAdapter(getClass(), new Serializer())
                .create();
        return gson.toJson(this);
    }

    public void save() {
        mPrefs.edit()
                .putString(PREF_BLACKLISTS_STATUS, toJson())
                .apply();
    }

    private String getListPath(BlacklistDescriptor bl) {
        return mContext.getFilesDir().getPath() + "/malware_bl/" + bl.fname;
    }

    private void checkFiles() {
        ArraySet<File> validLists = new ArraySet<>();

        // Ensure that all the lists files exist, otherwise force update
        for(BlacklistDescriptor bl: mLists) {
            File f = new File(getListPath(bl));
            validLists.add(f);

            if(!f.exists()) {
                // must update
                mLastUpdateMonotonic = -BLACKLISTS_UPDATE_MILLIS;
            }
        }

        // Ensure that the only the specified lists exist
        File bldir = new File(mContext.getFilesDir().getPath() + "/malware_bl");
        bldir.mkdir();
        File[] files = bldir.listFiles();
        if(files != null) {
            for(File f: files) {
                if(!validLists.contains(f)) {
                    Log.i(TAG, "Removing unknown list: " + f.getPath());

                    //noinspection ResultOfMethodCallIgnored
                    f.delete();
                }
            }
        }
    }

    public boolean needsUpdate(boolean firstUpdate) {
        long now = SystemClock.elapsedRealtime();
        return (((now - mLastUpdateMonotonic) >= BLACKLISTS_UPDATE_MILLIS)
                || (firstUpdate && (getNumUpdatedBlacklists() < getNumBlacklists())));
    }

    // NOTE: invoked in a separate thread (CaptureService.mBlacklistsUpdateThread)
    public void update() {
        mUpdateInProgress = true;
        mStopRequest = false;
        for(BlacklistDescriptor bl: mLists)
            bl.setUpdating();
        notifyListeners();

        Log.i(TAG, "Updating " + mLists.size() + " blacklists...");

        for(BlacklistDescriptor bl: mLists) {
            if(mStopRequest) {
                Log.i(TAG, "Stop request received, abort");
                break;
            }

            Log.i(TAG, "\tupdating " + bl.fname + "...");

            if(Utils.downloadFile(bl.url, getListPath(bl)))
                bl.setUpdated(System.currentTimeMillis());
            else
                bl.setOutdated();

            notifyListeners();
        }

        mLastUpdate = System.currentTimeMillis();
        mLastUpdateMonotonic = SystemClock.elapsedRealtime();
        notifyListeners();
    }

    public static class NativeBlacklistStatus {
        public final String fname;
        public final int num_rules;

        public NativeBlacklistStatus(String fname, int num_rules) {
            this.fname = fname;
            this.num_rules = num_rules;
        }
    }

    // Called when the blacklists are loaded in memory by the native code
    public void onNativeLoaded(NativeBlacklistStatus[] loaded_blacklists) {
        int num_loaded = 0;
        int num_domains = 0;
        int num_ips = 0;
        ArraySet<String> loaded = new ArraySet<>();

        for(NativeBlacklistStatus bl_status: loaded_blacklists) {
            if(bl_status == null)
                break;

            BlacklistDescriptor bl = mListByFname.get(bl_status.fname);
            if(bl != null) {
                // Update the number of rules
                bl.num_rules = bl_status.num_rules;
                bl.loaded = true;
                loaded.add(bl.fname);

                if(bl.type == BlacklistDescriptor.Type.DOMAIN_BLACKLIST)
                    num_domains += bl_status.num_rules;
                else
                    num_ips += bl_status.num_rules;

                num_loaded++;
            } else
                Log.w(TAG, "Loaded unknown blacklist " + bl_status.fname);
        }

        for(BlacklistDescriptor bl: mLists) {
            if(!loaded.contains(bl.fname)) {
                Log.w(TAG, "Blacklist not loaded: " + bl.fname);
                bl.loaded = false;
            }
        }

        Log.i(TAG, "Blacklists loaded: " + num_loaded + " lists, " + num_domains + " domains, " + num_ips + " IPs");
        mNumDomainRules = num_domains;
        mNumIPRules = num_ips;
        mUpdateInProgress = false;
        notifyListeners();
    }

    public Iterator<BlacklistDescriptor> iter() {
        return mLists.iterator();
    }

    public int getNumLoadedDomainRules() {
        return mNumDomainRules;
    }

    public int getNumLoadedIPRules() {
        return mNumIPRules;
    }

    public long getLastUpdate() {
        return mLastUpdate;
    }

    public int getNumBlacklists() {
        return mLists.size();
    }

    public int getNumUpdatedBlacklists() {
        int ctr = 0;

        for(BlacklistDescriptor bl: mLists) {
            if(bl.isUpToDate())
                ctr++;
        }

        return ctr;
    }

    private void notifyListeners() {
        for(BlacklistsStateListener listener: mListeners)
            listener.onBlacklistsStateChanged();
    }

    public void addOnChangeListener(BlacklistsStateListener listener) {
        mListeners.add(listener);
    }

    public void removeOnChangeListener(BlacklistsStateListener listener) {
        mListeners.remove(listener);
    }

    public boolean isUpdateInProgress() {
        return mUpdateInProgress;
    }

    public void abortUpdate() {
        mStopRequest = true;
    }
}


```

`app/src/main/java/com/emanuelef/remote_capture/BootReceiver.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.VpnService;

import androidx.core.content.ContextCompat;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.model.CaptureSettings;
import com.emanuelef.remote_capture.model.Prefs;

public class BootReceiver extends BroadcastReceiver {
    private static final String TAG = "BootReceiver";

    @Override
    public void onReceive(Context context, Intent intent) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
        String action = intent.getAction();
        Log.d(TAG, "onReceive: " + action);

        if(!action.equals(Intent.ACTION_BOOT_COMPLETED) && !action.equals("android.intent.action.QUICKBOOT_POWERON")) {
            Log.w(TAG, "Unexpected action: " + action);
            return;
        }

        if(!Prefs.startAtBoot(prefs))
            return;

        if(CaptureService.isServiceActive()) {
            // this can happen, for example, if always-on VPN is enabled, which causes PCAPdroid
            // to be started early
            Log.i(TAG, "Service already active, nothing to do");
            return;
        }

        CaptureSettings settings = new CaptureSettings(context, prefs);

        if(!settings.root_capture) {
            Intent vpnPrepareIntent = VpnService.prepare(context);
            if(vpnPrepareIntent != null) {
                // Cannot perform the VPN setup without an Activity
                Utils.showToastLong(context, R.string.vpn_setup_failed);
                return;
            }
        }

        Log.i(TAG, "Starting capture service");
        Intent capIntent = new Intent(context, CaptureService.class);
        capIntent.putExtra("settings", settings);
        ContextCompat.startForegroundService(context, capIntent);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/CaptureHelper.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.net.VpnService;

import com.emanuelef.remote_capture.interfaces.CaptureStartListener;
import com.emanuelef.remote_capture.model.CaptureSettings;

import androidx.activity.ComponentActivity;
import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.core.content.ContextCompat;

public class CaptureHelper {
    private static final String TAG = "CaptureHelper";
    private final Context mContext;
    private final @Nullable ActivityResultLauncher<Intent> mLauncher;
    private CaptureSettings mSettings;
    private CaptureStartListener mListener;

    public CaptureHelper(ComponentActivity activity) {
        mContext = activity;
        mLauncher = activity.registerForActivityResult(
                new ActivityResultContracts.StartActivityForResult(), this::captureServiceResult);
    }

    /** Note: This constructor does not handle the first-time VPN prepare */
    public CaptureHelper(Context context) {
        mContext = context;
        mLauncher = null;
    }

    private void captureServiceResult(final ActivityResult result) {
        if(result.getResultCode() == Activity.RESULT_OK)
            startCaptureOk();
        else if(mListener != null) {
            Utils.showToastLong(mContext, R.string.vpn_setup_failed);
            mListener.onCaptureStartResult(false);
        }
    }

    private void startCaptureOk() {
        final Intent intent = new Intent(mContext, CaptureService.class);
        intent.putExtra("settings", mSettings);

        ContextCompat.startForegroundService(mContext, intent);
        if(mListener != null)
            mListener.onCaptureStartResult(true);
    }

    public void startCapture(CaptureSettings settings) {
        if(CaptureService.isServiceActive())
            CaptureService.stopService();

        mSettings = settings;

        if(settings.root_capture || settings.readFromPcap()) {
            startCaptureOk();
            return;
        }

        Intent vpnPrepareIntent = null;
        try {
            vpnPrepareIntent = VpnService.prepare(mContext);
        } catch (RuntimeException e) {
            e.printStackTrace();
        }

        if(vpnPrepareIntent != null) {
            final Intent prepareIntent = vpnPrepareIntent;

            if (mLauncher != null)
                new AlertDialog.Builder(mContext)
                        .setMessage(R.string.vpn_setup_msg)
                        .setPositiveButton(R.string.ok, (dialog, whichButton) -> {
                            try {
                                mLauncher.launch(prepareIntent);
                            } catch (ActivityNotFoundException e) {
                                Utils.showToastLong(mContext, R.string.no_intent_handler_found);
                                mListener.onCaptureStartResult(false);
                            }
                        })
                        .setOnCancelListener(dialog -> {
                            Utils.showToastLong(mContext, R.string.vpn_setup_failed);
                            mListener.onCaptureStartResult(false);
                        })
                        .show();
            else if (mListener != null)
                mListener.onCaptureStartResult(false);
        } else
            startCaptureOk();
    }

    public void setListener(CaptureStartListener listener) {
        mListener = listener;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/CaptureService.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.annotation.TargetApi;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.net.ConnectivityManager;
import android.net.LinkProperties;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.Uri;
import android.net.VpnService;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.os.ParcelFileDescriptor;
import android.provider.Settings;
import android.util.Pair;
import android.util.SparseArray;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;
import androidx.core.content.ContextCompat;
import androidx.lifecycle.LifecycleOwner;
import androidx.lifecycle.MutableLiveData;
import androidx.lifecycle.Observer;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.activities.CaptureCtrl;
import com.emanuelef.remote_capture.activities.ConnectionsActivity;
import com.emanuelef.remote_capture.activities.FirewallActivity;
import com.emanuelef.remote_capture.activities.MainActivity;
import com.emanuelef.remote_capture.fragments.ConnectionsFragment;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.BlacklistDescriptor;
import com.emanuelef.remote_capture.model.Blocklist;
import com.emanuelef.remote_capture.model.CaptureSettings;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.ConnectionUpdate;
import com.emanuelef.remote_capture.model.FilterDescriptor;
import com.emanuelef.remote_capture.model.MatchList;
import com.emanuelef.remote_capture.model.PortMapping;
import com.emanuelef.remote_capture.model.Prefs;
import com.emanuelef.remote_capture.model.CaptureStats;
import com.emanuelef.remote_capture.pcap_dump.FileDumper;
import com.emanuelef.remote_capture.pcap_dump.HTTPServer;
import com.emanuelef.remote_capture.interfaces.PcapDumper;
import com.emanuelef.remote_capture.pcap_dump.TCPDumper;
import com.emanuelef.remote_capture.pcap_dump.UDPDumper;
import com.pcapdroid.mitm.MitmAPI;

import java.io.File;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class CaptureService extends VpnService implements Runnable {
    private static final String TAG = "CaptureService";
    private static final String VpnSessionName = "PCAPdroid VPN";
    private static final String NOTIFY_CHAN_VPNSERVICE = "VPNService";
    private static final String NOTIFY_CHAN_MALWARE_DETECTION = "Malware detection";
    private static final String NOTIFY_CHAN_OTHER = "Other";
    private static final int VPN_MTU = 10000;
    public static final int NOTIFY_ID_VPNSERVICE = 1;
    public static final int NOTIFY_ID_LOW_MEMORY = 2;
    public static final int NOTIFY_ID_APP_BLOCKED = 3;
    private static CaptureService INSTANCE;
    private static boolean HAS_ERROR = false;
    final ReentrantLock mLock = new ReentrantLock();
    final Condition mCaptureStopped = mLock.newCondition();
    private ParcelFileDescriptor mParcelFileDescriptor;
    private boolean mIsAlwaysOnVPN;
    private boolean mRevoked;
    private SharedPreferences mPrefs;
    private CaptureSettings mSettings;
    private Billing mBilling;
    private Handler mHandler;
    private Thread mCaptureThread;
    private Thread mBlacklistsUpdateThread;
    private Thread mConnUpdateThread;
    private Thread mDumperThread;
    private MitmReceiver mMitmReceiver;
    private final LinkedBlockingDeque<Pair<ConnectionDescriptor[], ConnectionUpdate[]>> mPendingUpdates = new LinkedBlockingDeque<>(32);
    private AtomicInteger mNumUpdatesInProgress = new AtomicInteger();
    private LinkedBlockingDeque<byte[]> mDumpQueue;
    private String vpn_ipv4;
    private String vpn_dns;
    private String dns_server;
    private long last_bytes;
    private int last_connections;
    private int[] mAppFilterUids;
    private PcapDumper mDumper;
    private ConnectionsRegister conn_reg;
    private HttpLog mHttpLog;
    private Uri mPcapUri;
    private String mPcapFname;
    private NotificationCompat.Builder mStatusBuilder;
    private NotificationCompat.Builder mMalwareBuilder;
    private long mMonitoredNetwork;
    private Network mUnderlyingNetwork;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private AppsResolver mNativeAppsResolver; // can only be accessed by native code to avoid concurrency issues
    private Geolocation mNativeGeolocation;   // only native
    private boolean mMalwareDetectionEnabled;
    private boolean mBlacklistsUpdateRequested;
    private boolean mFirewallEnabled;
    private boolean mBlockPrivateDns;
    private boolean mDnsEncrypted;
    private boolean mStrictDnsNoticeShown;
    private boolean mQueueFull;
    private boolean mStopping;
    private Blacklists mBlacklists;
    private Blocklist mBlocklist;
    private MatchList mMalwareWhitelist;
    private MatchList mFirewallWhitelist;
    private MatchList mDecryptionList;
    private SparseArray<String> mIfIndexToName;
    private boolean mSocks5Enabled;
    private String mSocks5Address;
    private int mSocks5Port;
    private String mSocks5Auth;
    private static final MutableLiveData<CaptureStats> lastStats = new MutableLiveData<>();
    private static final MutableLiveData<ServiceStatus> serviceStatus = new MutableLiveData<>();
    private boolean mLowMemory;
    private BroadcastReceiver mNewAppsInstallReceiver;
    private Utils.PrivateDnsMode mPrivateDnsMode;

    /* The maximum connections to log into the ConnectionsRegister. Older connections are dropped.
     * Max estimated memory usage: less than 4 MB (+8 MB with payload mode minimal). */
    public static final int CONNECTIONS_LOG_SIZE = 8192;

    /* The IP address of the virtual network interface */
    public static final String VPN_IP_ADDRESS = "10.215.173.1";
    public static final String VPN_IP6_ADDRESS = "fd00:2:fd00:1:fd00:1:fd00:1";

    /* The DNS server IP address to use to internally analyze the DNS requests.
     * It must be in the same subnet of the VPN network interface.
     * After the analysis, requests will be routed to the primary DNS server. */
    public static final String VPN_VIRTUAL_DNS_SERVER = "10.215.173.2";

    public enum ServiceStatus {
        STOPPED,
        STARTED
    }

    static {
        /* Load native library */
        try {
            System.loadLibrary("capture");
            CaptureService.initPlatformInfo(Utils.getAppVersionString(), Utils.getDeviceModel(), Utils.getOsVersion());
        } catch (UnsatisfiedLinkError e) {
            // This should only happen while running tests
            //e.printStackTrace();
        }
    }

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base.createConfigurationContext(Utils.getLocalizedConfig(base)));
    }

    @Override
    public void onCreate() {
        Log.d(CaptureService.TAG, "onCreate");
        AppsResolver.clearMappedApps();
        mNativeAppsResolver = new AppsResolver(this);
        mNativeGeolocation = new Geolocation(this);
        mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        mSettings = new CaptureSettings(this, mPrefs); // initialize to prevent NULL pointer exceptions in methods (e.g. isRootCapture)

        INSTANCE = this;
        super.onCreate();
    }

    private int abortStart() {
        stopService();
        updateServiceStatus(ServiceStatus.STOPPED);
        return START_NOT_STICKY;
    }

    private static boolean alwaysOnVpnErrorLogged = false;

    // Android does not provide a reliable API to track the always-on VPN state
    // This function tries to detect but may fail to do so
    private boolean isAlwaysOnVpnDetected() {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q)
            return isAlwaysOn();

        try {
            String always_on_vpn_app = Settings.Secure.getString(getContentResolver(), "always_on_vpn_app");
            return always_on_vpn_app.equals(getPackageName());
        } catch (Exception e) {
            if (!alwaysOnVpnErrorLogged) {
                Log.w(TAG, "Querying the always-on VPN state failed: " + e);
                alwaysOnVpnErrorLogged = true;
            }
            return false;
        }
    }

    @Override
    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
        mStopping = false;

        // startForeground must always be called since the Service is being started with
        // ContextCompat.startForegroundService.
        // NOTE: since Android 12, startForeground cannot be called when the app is in background
        // (unless invoked via an Intent).
        setupNotifications();
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
            startForeground(NOTIFY_ID_VPNSERVICE, getStatusNotification(), ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE);
        else
            startForeground(NOTIFY_ID_VPNSERVICE, getStatusNotification());

        // NOTE: onStartCommand may be called when the capture is already running, e.g. if the user
        // turns on the always-on VPN while the capture is running in root mode
        if(mCaptureThread != null) {
            // Restarting the capture requires calling stopAndJoinThreads, which is blocking.
            // Choosing not to support this right now.
            Log.e(TAG, "Restarting the capture is not supported");
            return abortStart();
        }

        if (VpnReconnectService.isAvailable())
            VpnReconnectService.stopService();

        mHandler = new Handler(Looper.getMainLooper());
        mBilling = Billing.newInstance(this);

        Log.d(CaptureService.TAG, "onStartCommand");

        // NOTE: a null intent may be delivered due to START_STICKY
        // It can be simulated by starting the capture, putting PCAPdroid in the background and then running:
        //  adb shell ps | grep remote_capture | awk '{print $2}' | xargs adb shell run-as com.emanuelef.remote_capture.debug kill
        CaptureSettings settings = ((intent == null) ? null : Utils.getSerializableExtra(intent, "settings", CaptureSettings.class));
        if(settings == null) {
            // Use the settings from mPrefs

            // An Intent without extras is delivered in case of always on VPN
            // https://developer.android.com/guide/topics/connectivity/vpn#always-on
            mIsAlwaysOnVPN = (intent != null);
            Log.i(CaptureService.TAG, "Missing capture settings, using SharedPrefs");
        } else {
            // Use the provided settings
            mSettings = settings;
            mIsAlwaysOnVPN = false;

            if(!settings.decryption_rules_json.isBlank()) {
                PCAPdroid.getInstance()
                    .getDecryptionList()
                    .fromJson(settings.decryption_rules_json);
            }
        }

        mIsAlwaysOnVPN |= isAlwaysOnVpnDetected();

        Log.d(TAG, "alwaysOn? " + mIsAlwaysOnVPN);
        if(mIsAlwaysOnVPN) {
            mSettings.root_capture = false;
            mSettings.input_pcap_path = null;
        }

        if(mSettings.readFromPcap()) {
            // Disable incompatible settings
            mSettings.dump_mode = Prefs.DumpMode.NONE;
            mSettings.app_filter.clear();
            mSettings.socks5_enabled = false;
            mSettings.tls_decryption = false;
            mSettings.root_capture = false;
            mSettings.auto_block_private_dns = false;
            mSettings.capture_interface = mSettings.input_pcap_path;
        }

        // Retrieve DNS server
        String fallbackDnsV4 = Prefs.getDnsServerV4(mPrefs);
        dns_server = fallbackDnsV4;
        mBlockPrivateDns = false;
        mStrictDnsNoticeShown = false;
        mDnsEncrypted = false;
        setPrivateDnsBlocked(false);

        // Map network interfaces
        mIfIndexToName = new SparseArray<>();

        Enumeration<NetworkInterface> ifaces = Utils.getNetworkInterfaces();
        while(ifaces.hasMoreElements()) {
            NetworkInterface iface = ifaces.nextElement();

            Log.d(TAG, "ifidx " + iface.getIndex() + " -> " + iface.getName());
            mIfIndexToName.put(iface.getIndex(), iface.getName());
        }

        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            ConnectivityManager cm = (ConnectivityManager) getSystemService(Service.CONNECTIVITY_SERVICE);
            Network net = cm.getActiveNetwork();
            mUnderlyingNetwork = net;

            if(net != null) {
                handleLinkProperties(cm.getLinkProperties(net));

                if(Prefs.useSystemDns(mPrefs) || mSettings.root_capture) {
                    dns_server = Utils.getDnsServer(cm, net);
                    if (dns_server == null)
                        dns_server = fallbackDnsV4;
                    else {
                        mMonitoredNetwork = net.getNetworkHandle();
                        registerNetworkCallbacks();
                    }
                } else
                    dns_server = fallbackDnsV4;
            }
        }

        vpn_dns = VPN_VIRTUAL_DNS_SERVER;
        vpn_ipv4 = VPN_IP_ADDRESS;
        last_bytes = 0;
        last_connections = 0;
        mLowMemory = false;
        conn_reg = new ConnectionsRegister(this, CONNECTIONS_LOG_SIZE);
        mHttpLog = mSettings.full_payload ? new HttpLog() : null;
        mDumper = null;
        mDumpQueue = null;
        mPendingUpdates.clear();
        mPcapFname = null;
        HAS_ERROR = false;

        // Possibly allocate the dumper
        if(mSettings.dump_mode == Prefs.DumpMode.HTTP_SERVER)
            mDumper = new HTTPServer(this, mSettings.http_server_port, mSettings.pcapng_format);
        else if(mSettings.dump_mode == Prefs.DumpMode.PCAP_FILE) {
            mPcapFname = !mSettings.pcap_name.isEmpty() ? mSettings.pcap_name : Utils.getUniquePcapFileName(this, mSettings.pcapng_format);

            if(!mSettings.pcap_uri.isEmpty())
                mPcapUri = Uri.parse(mSettings.pcap_uri);
            else
                mPcapUri = Utils.getDownloadsUri(this, mPcapFname);

            if(mPcapUri == null)
                return abortStart();

            mDumper = new FileDumper(this, mPcapUri);
        } else if(mSettings.dump_mode == Prefs.DumpMode.UDP_EXPORTER) {
            InetAddress addr;

            try {
                addr = InetAddress.getByName(mSettings.collector_address);
            } catch (UnknownHostException e) {
                reportError(e.getLocalizedMessage());
                e.printStackTrace();
                return abortStart();
            }

            mDumper = new UDPDumper(new InetSocketAddress(addr, mSettings.collector_port), mSettings.pcapng_format);
        } else if(mSettings.dump_mode == Prefs.DumpMode.TCP_EXPORTER) {
            InetAddress addr;

            try {
                addr = InetAddress.getByName(mSettings.collector_address);
            } catch (UnknownHostException e) {
                reportError(e.getLocalizedMessage());
                e.printStackTrace();
                return abortStart();
            }

            mDumper = new TCPDumper(new InetSocketAddress(addr, mSettings.collector_port), mSettings.pcapng_format);
        }

        if(mDumper != null)
            // Max memory usage = (JAVA_PCAP_BUFFER_SIZE * 64) = 32 MB
            mDumpQueue = new LinkedBlockingDeque<>(64);

        mSocks5Address = "";
        mSocks5Enabled = mSettings.socks5_enabled || mSettings.tls_decryption;
        if(mSocks5Enabled) {
            if(mSettings.tls_decryption) {
                // Built-in decryption
                mSocks5Address = "127.0.0.1";
                mSocks5Port = MitmReceiver.TLS_DECRYPTION_PROXY_PORT;
                mSocks5Auth = Utils.genRandomString(8) + ":" + Utils.genRandomString(8);

                mMitmReceiver = new MitmReceiver(this, mSettings, mSocks5Auth);
                try {
                    if(!mMitmReceiver.start())
                        return abortStart();
                } catch (IOException e) {
                    e.printStackTrace();
                    return abortStart();
                }
            } else {
                // SOCKS5 proxy
                mSocks5Address = mSettings.socks5_proxy_address;
                mSocks5Port = mSettings.socks5_proxy_port;

                if(!mSettings.socks5_username.isEmpty() && !mSettings.socks5_password.isEmpty())
                    mSocks5Auth = mSettings.socks5_username + ":" + mSettings.socks5_password;
                else
                    mSocks5Auth = null;
            }
        }

        if(mSettings.tls_decryption && !mSettings.root_capture && !mSettings.readFromPcap())
            mDecryptionList = PCAPdroid.getInstance().getDecryptionList();
        else
            mDecryptionList = null;

        if ((mSettings.app_filter != null) && (!mSettings.app_filter.isEmpty())) {
            ArrayList<Integer> uids = new ArrayList<>();

            for (String package_name: mSettings.app_filter) {
                int uid;

                try {
                    uid = Utils.getPackageUid(getPackageManager(), package_name, 0);
                } catch (PackageManager.NameNotFoundException e) {
                    e.printStackTrace();
                    continue;
                }

                uids.add(uid);
            }

            // populate the array only with resolved UIDs
            mAppFilterUids = new int[uids.size()];

            int i = 0;
            for (Integer uid: uids)
                mAppFilterUids[i++] = uid;
        } else
            mAppFilterUids = new int[0];

        mMalwareDetectionEnabled = !mSettings.readFromPcap() && Prefs.isMalwareDetectionEnabled(this, mPrefs);
        mFirewallEnabled = !mSettings.readFromPcap() && Prefs.isFirewallEnabled(this, mPrefs);

        if(!mSettings.root_capture && !mSettings.readFromPcap()) {
            Log.i(TAG, "Using DNS server " + dns_server);

            // VPN
            /* In order to see the DNS packets into the VPN we must set an internal address as the DNS
             * server. */
            Builder builder = new Builder()
                    .setMtu(VPN_MTU);

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q)
                builder.setMetered(false);

            if (getIPv4Enabled() == 1) {
                builder.addAddress(vpn_ipv4, 30)
                        .addRoute("0.0.0.0", 1)
                        .addRoute("128.0.0.0", 1)
                        .addDnsServer(vpn_dns);
            }

            if (getIPv6Enabled() == 1) {
                builder.addAddress(VPN_IP6_ADDRESS, 128);

                // Route unicast IPv6 addresses
                builder.addRoute("2000::", 3);
                builder.addRoute("fc00::", 7);

                try {
                    builder.addDnsServer(InetAddress.getByName(Prefs.getDnsServerV6(mPrefs)));
                } catch (UnknownHostException | IllegalArgumentException e) {
                    Log.w(TAG, "Could not set IPv6 DNS server");
                }
            }

            if ((mSettings.app_filter != null) && (!mSettings.app_filter.isEmpty())) {
                Log.d(TAG, "Setting app filter: " + mSettings.app_filter);

                try {
                    // NOTE: the API requires a package name, however it is converted to a UID
                    // (see Vpn.java addUserToRanges). This means that vpn routing happens on a UID basis,
                    // not on a package-name basis!
                    for (String package_name: mSettings.app_filter)
                        builder.addAllowedApplication(package_name);
                } catch (PackageManager.NameNotFoundException e) {
                    String msg = String.format(getResources().getString(R.string.app_not_found), mSettings.app_filter);
                    Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
                    return abortStart();
                }
            } else {
                // VPN exceptions
                Set<String> exceptions = mPrefs.getStringSet(Prefs.PREF_VPN_EXCEPTIONS, new HashSet<>());
                for(String packageName: exceptions) {
                    try {
                        builder.addDisallowedApplication(packageName);
                    } catch (PackageManager.NameNotFoundException e) {
                        e.printStackTrace();
                    }
                }

                if(mSettings.tls_decryption) {
                    // Exclude the mitm addon traffic in case system-wide decryption is performed
                    // Important: cannot call addDisallowedApplication with addAllowedApplication
                    try {
                        builder.addDisallowedApplication(MitmAPI.PACKAGE_NAME);
                    } catch (PackageManager.NameNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }

            // Port mappings are loaded in resolveHosts() to allow domain resolution

            try {
                mParcelFileDescriptor = builder.setSession(CaptureService.VpnSessionName).establish();
            } catch (IllegalArgumentException | IllegalStateException | SecurityException e) {
                e.printStackTrace();
                Utils.showToast(this, R.string.vpn_setup_failed);
                return abortStart();
            }
        }

        mMalwareWhitelist = PCAPdroid.getInstance().getMalwareWhitelist();
        mBlacklists = PCAPdroid.getInstance().getBlacklists();
        if(mMalwareDetectionEnabled && !mBlacklists.needsUpdate(true))
            reloadBlacklists();
        checkBlacklistsUpdates(true);

        mBlocklist = PCAPdroid.getInstance().getBlocklist();
        mFirewallWhitelist = PCAPdroid.getInstance().getFirewallWhitelist();

        mNumUpdatesInProgress.set(0);
        mConnUpdateThread = new Thread(this::connUpdateWork, "UpdateListener");
        mConnUpdateThread.start();

        if(mDumper != null) {
            mDumperThread = new Thread(this::dumpWork, "DumperThread");
            mDumperThread.start();
        }

        if(mFirewallEnabled) {
            mNewAppsInstallReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    // executed on the main thread
                    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
                        boolean newInstall = !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                        String packageName = intent.getData().getSchemeSpecificPart();

                        if(newInstall && Prefs.blockNewApps(mPrefs)) {
                            if(!mBlocklist.addApp(packageName))
                                return;

                            mBlocklist.save();
                            reloadBlocklist();

                            AppDescriptor app = AppsResolver.resolveInstalledApp(getPackageManager(), packageName, 0);
                            String label = (app != null) ? app.getName() : packageName;

                            Log.i(TAG, "Blocking newly installed app: " + packageName + ((app != null) ? " - " + app.getUid() : ""));

                            PendingIntent pi = PendingIntent.getActivity(CaptureService.this, 0,
                                    new Intent(CaptureService.this, FirewallActivity.class), Utils.getIntentFlags(0));

                            PendingIntent unblockIntent = PendingIntent.getBroadcast(CaptureService.this, 0,
                                    new Intent(CaptureService.this, ActionReceiver.class)
                                            .putExtra(ActionReceiver.EXTRA_UNBLOCK_APP, packageName), Utils.getIntentFlags(PendingIntent.FLAG_UPDATE_CURRENT));

                            // Notify the user
                            NotificationManagerCompat man = NotificationManagerCompat.from(context);
                            if(man.areNotificationsEnabled()) {
                                Notification notification = new NotificationCompat.Builder(CaptureService.this, NOTIFY_CHAN_OTHER)
                                        .setContentIntent(pi)
                                        .setSmallIcon(R.drawable.ic_logo)
                                        .setColor(ContextCompat.getColor(CaptureService.this, R.color.colorPrimary))
                                        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                                        .setCategory(NotificationCompat.CATEGORY_STATUS)
                                        .setContentTitle(getString(R.string.app_blocked))
                                        .setContentText(getString(R.string.app_blocked_info, label))
                                        .setAutoCancel(true)
                                        .addAction(R.drawable.ic_check_solid, getString(R.string.action_unblock), unblockIntent)
                                        .build();

                                man.notify(NOTIFY_ID_APP_BLOCKED, notification);
                            }
                        }
                    }
                }
            };

            IntentFilter filter = new IntentFilter();
            filter.addAction(Intent.ACTION_PACKAGE_ADDED);
            filter.addDataScheme("package");
            registerReceiver(mNewAppsInstallReceiver, filter);
        }

        // Start the native capture thread
        mQueueFull = false;
        mCaptureThread = new Thread(this, "PacketCapture");
        mCaptureThread.start();

        // If the service is killed (e.g. due to low memory), then restart it with a NULL intent
        return START_STICKY;
    }

    @Override
    public void onRevoke() {
        Log.d(CaptureService.TAG, "onRevoke");
        mRevoked = true;
        stopService();
        super.onRevoke();
    }

    @Override
    public void onDestroy() {
        Log.d(CaptureService.TAG, "onDestroy");

        // Do not nullify INSTANCE to allow its settings and the connections register to be accessible
        // after the capture is stopped
        //INSTANCE = null;

        unregisterNetworkCallbacks();

        if(mBlacklists != null)
            mBlacklists.abortUpdate();

        if(mCaptureThread != null)
            mCaptureThread.interrupt();
        if(mBlacklistsUpdateThread != null)
            mBlacklistsUpdateThread.interrupt();

        if(mNewAppsInstallReceiver != null) {
            unregisterReceiver(mNewAppsInstallReceiver);
            mNewAppsInstallReceiver = null;
        }

        super.onDestroy();
    }

    private void setupNotifications() {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);

            // VPN running notification channel
            NotificationChannel chan = new NotificationChannel(NOTIFY_CHAN_VPNSERVICE,
                    NOTIFY_CHAN_VPNSERVICE, NotificationManager.IMPORTANCE_LOW); // low: no sound
            chan.setShowBadge(false);
            nm.createNotificationChannel(chan);

            // Blacklisted connection notification channel
            chan = new NotificationChannel(NOTIFY_CHAN_MALWARE_DETECTION,
                    getString(R.string.malware_detection), NotificationManager.IMPORTANCE_HIGH);
            nm.createNotificationChannel(chan);

            // Other notifications
            chan = new NotificationChannel(NOTIFY_CHAN_OTHER,
                    getString(R.string.other_prefs), NotificationManager.IMPORTANCE_DEFAULT);
            nm.createNotificationChannel(chan);
        }

        // Status notification builder
        PendingIntent pi = PendingIntent.getActivity(this, 0,
                new Intent(this, MainActivity.class), Utils.getIntentFlags(PendingIntent.FLAG_UPDATE_CURRENT));
        mStatusBuilder = new NotificationCompat.Builder(this, NOTIFY_CHAN_VPNSERVICE)
                .setSmallIcon(R.drawable.ic_logo)
                .setColor(ContextCompat.getColor(this, R.color.colorPrimary))
                .setContentIntent(pi)
                .setOngoing(true)
                .setAutoCancel(false)
                .setContentTitle(getResources().getString(R.string.capture_running))
                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                .setCategory(NotificationCompat.CATEGORY_STATUS)
                .setPriority(NotificationCompat.PRIORITY_LOW); // see IMPORTANCE_LOW

        // Malware notification builder
        mMalwareBuilder = new NotificationCompat.Builder(this, NOTIFY_CHAN_MALWARE_DETECTION)
                .setSmallIcon(R.drawable.ic_skull)
                .setAutoCancel(true)
                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                .setCategory(NotificationCompat.CATEGORY_STATUS)
                .setPriority(NotificationCompat.PRIORITY_HIGH); // see IMPORTANCE_HIGH
    }

    private Notification getStatusNotification() {
        String msg = String.format(getString(R.string.notification_msg),
                Utils.formatBytes(last_bytes), Utils.formatNumber(this, last_connections));

        mStatusBuilder.setContentText(msg);

        return mStatusBuilder.build();
    }

    private void updateNotification() {
        if(mStopping)
            return;

        Notification notification = getStatusNotification();
        NotificationManagerCompat.from(this).notify(NOTIFY_ID_VPNSERVICE, notification);
    }

    public void notifyBlacklistedConnection(ConnectionDescriptor conn) {
        int uid = conn.uid;

        AppsResolver resolver = new AppsResolver(this);
        AppDescriptor app = resolver.getAppByUid(conn.uid, 0);
        if(app == null)
            return;

        FilterDescriptor filter = new FilterDescriptor();
        filter.onlyBlacklisted = true;

        Intent intent = new Intent(this, ConnectionsActivity.class)
                .putExtra(ConnectionsFragment.FILTER_EXTRA, filter)
                .putExtra(ConnectionsFragment.QUERY_EXTRA, app.getPackageName());
        PendingIntent pi = PendingIntent.getActivity(this, 0,
                intent, Utils.getIntentFlags(PendingIntent.FLAG_UPDATE_CURRENT));

        String rule_label;
        if(conn.isBlacklistedHost())
            rule_label = MatchList.getRuleLabel(this, MatchList.RuleType.HOST, conn.info);
        else
            rule_label = MatchList.getRuleLabel(this, MatchList.RuleType.IP, conn.dst_ip);
        String content = String.format(
                getResources().getString(R.string.malicious_connection_description),
                app.getName(),
                rule_label);

        mMalwareBuilder
                .setContentIntent(pi)
                .setWhen(System.currentTimeMillis())
                .setContentTitle(getResources().getString(R.string.malware_detection))
                .setStyle(new NotificationCompat.BigTextStyle().bigText(content))
                .setContentText(content);
        Notification notification = mMalwareBuilder.build();

        // Use the UID as the notification ID to group alerts from the same app
        mHandler.post(() -> Utils.sendImportantNotification(this, uid, notification));
    }

    public void notifyLowMemory(CharSequence msg) {
        Notification notification = new NotificationCompat.Builder(this, NOTIFY_CHAN_OTHER)
                .setAutoCancel(true)
                .setSmallIcon(R.drawable.ic_logo)
                .setColor(ContextCompat.getColor(this, R.color.colorPrimary))
                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                .setCategory(NotificationCompat.CATEGORY_STATUS)
                .setWhen(System.currentTimeMillis())
                .setContentTitle(getString(R.string.low_memory))
                .setContentText(msg)
                .build();

        mHandler.post(() -> Utils.sendImportantNotification(this, NOTIFY_ID_LOW_MEMORY, notification));
    }

    @RequiresApi(api = Build.VERSION_CODES.M)
    private void registerNetworkCallbacks() {
        if(mNetworkCallback != null)
            return;

        String fallbackDns = Prefs.getDnsServerV4(mPrefs);
        ConnectivityManager cm = (ConnectivityManager) getSystemService(Service.CONNECTIVITY_SERVICE);
        mNetworkCallback = new ConnectivityManager.NetworkCallback() {
            @Override
            public void onLost(@NonNull Network network) {
                Log.d(TAG, "onLost " + network);

                // If the network goes offline we roll back to the fallback DNS server to
                // avoid possibly using a private IP DNS server not reachable anymore
                if(network.getNetworkHandle() == mMonitoredNetwork) {
                    Log.i(TAG, "Main network " + network + " lost, using fallback DNS " + fallbackDns);
                    dns_server = fallbackDns;
                    mMonitoredNetwork = 0;
                    unregisterNetworkCallbacks();

                    // change native
                    setDnsServer(dns_server);
                }
            }

            @RequiresApi(api = Build.VERSION_CODES.O)
            @Override
            public void onLinkPropertiesChanged(@NonNull Network network, @NonNull LinkProperties linkProperties) {
                Log.d(TAG, "onLinkPropertiesChanged " + network);

                if(network.getNetworkHandle() == mMonitoredNetwork)
                    handleLinkProperties(linkProperties);
            }
        };

        try {
            Log.d(TAG, "registerNetworkCallback");
            cm.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).build(),
                    mNetworkCallback);
        } catch (SecurityException e) {
            // this is a bug in Android 11 - https://issuetracker.google.com/issues/175055271?pli=1
            e.printStackTrace();

            Log.w(TAG, "registerNetworkCallback failed, DNS server detection disabled");
            dns_server = fallbackDns;
            mNetworkCallback = null;
        }
    }

    private void unregisterNetworkCallbacks() {
        if(mNetworkCallback != null) {
            ConnectivityManager cm = (ConnectivityManager) getSystemService(Service.CONNECTIVITY_SERVICE);

            try {
                Log.d(TAG, "unregisterNetworkCallback");
                cm.unregisterNetworkCallback(mNetworkCallback);
            } catch(IllegalArgumentException e) {
                Log.w(TAG, "unregisterNetworkCallback failed: " + e);
            }

            mNetworkCallback = null;
        }
    }

    private void handleLinkProperties(LinkProperties linkProperties) {
        if(linkProperties == null)
            return;

        if(android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.P) {
            mPrivateDnsMode = Utils.getPrivateDnsMode(linkProperties);
            Log.i(TAG, "Private DNS: " + mPrivateDnsMode);

            if(mSettings.readFromPcap()) {
                mDnsEncrypted = false;
                setPrivateDnsBlocked(false);
            } else if(!mSettings.root_capture && mSettings.auto_block_private_dns) {
                mDnsEncrypted = mPrivateDnsMode.equals(Utils.PrivateDnsMode.STRICT);
                boolean opportunistic_mode = mPrivateDnsMode.equals(Utils.PrivateDnsMode.OPPORTUNISTIC);

                /* Private DNS can be in one of these modes:
                 *  1. Off
                 *  2. Automatic (default): also called "opportunistic", only use it if not blocked
                 *  3. Strict: private DNS is enforced, Internet unavailable if blocked. User must set a specific DNS server.
                 * When in opportunistic mode, PCAPdroid will block private DNS connections to force the use of plain-text
                 * DNS queries, which can be extracted by PCAPdroid. */
                if (mBlockPrivateDns != opportunistic_mode) {
                    mBlockPrivateDns = opportunistic_mode;
                    setPrivateDnsBlocked(mBlockPrivateDns);
                }
            } else {
                // in root capture we don't block private DNS requests in opportunistic mode
                mDnsEncrypted = !mPrivateDnsMode.equals(Utils.PrivateDnsMode.DISABLED);
                setPrivateDnsBlocked(false);
            }

            if(mDnsEncrypted && !mStrictDnsNoticeShown) {
                mStrictDnsNoticeShown = true;
                Utils.showToastLong(this, R.string.private_dns_message_notice);
            }
        }
    }

    private void signalServicesTermination() {
        mPendingUpdates.offer(new Pair<>(null, null));
        stopPcapDump();
    }

    // NOTE: do not call this on the main thread, otherwise it will be an ANR
    private void stopAndJoinThreads() {
        signalServicesTermination();

        Log.d(TAG, "Joining threads...");

        while((mConnUpdateThread != null) && (mConnUpdateThread.isAlive())) {
            try {
                Log.d(TAG, "Joining conn update thread...");
                mConnUpdateThread.join();
            } catch (InterruptedException ignored) {
                mPendingUpdates.offer(new Pair<>(null, null));
            }
        }
        mConnUpdateThread = null;

        while((mDumperThread != null) && (mDumperThread.isAlive())) {
            try {
                Log.d(TAG, "Joining dumper thread...");
                mDumperThread.join();
            } catch (InterruptedException ignored) {
                stopPcapDump();
            }
        }
        mDumperThread = null;
        mDumper = null;

        if(mMitmReceiver != null) {
            try {
                mMitmReceiver.stop();
            } catch (IOException e) {
                e.printStackTrace();
            }
            mMitmReceiver = null;
        }
    }

    /* Stops the running Service. The SERVICE_STATUS_STOPPED notification is sent asynchronously
     * when mCaptureThread terminates. */
    @SuppressWarnings("deprecation")
    public static void stopService() {
        CaptureService captureService = INSTANCE;
        Log.d(TAG, "stopService called (instance? " + (captureService != null) + ")");

        if(captureService == null)
            return;

        captureService.mStopping = true;
        stopPacketLoop();

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
            captureService.stopForeground(STOP_FOREGROUND_REMOVE);
        else
            captureService.stopForeground(true);

        captureService.stopSelf();
    }

    /* Check if the VPN service was launched */
    public static boolean isServiceActive() {
        return((INSTANCE != null) &&
                (INSTANCE.mCaptureThread != null));
    }

    public static MitmReceiver.Status getMitmProxyStatus() {
        if((INSTANCE == null) || (INSTANCE.mMitmReceiver == null))
            return MitmReceiver.Status.NOT_STARTED;

        return INSTANCE.mMitmReceiver.getProxyStatus();
    }

    public static boolean isLowMemory() {
        return((INSTANCE != null) && (INSTANCE.mLowMemory));
    }

    public static boolean isAlwaysOnVPN() {
        return((INSTANCE != null) && INSTANCE.mIsAlwaysOnVPN);
    }

    public static boolean checkAlwaysOnVpnActivated() {
        CaptureService instance = INSTANCE;
        if (instance == null)
            return false;

        if (!instance.mIsAlwaysOnVPN && instance.isAlwaysOnVpnDetected()) {
            Log.i(TAG, "Always-on VPN was activated");
            instance.mIsAlwaysOnVPN = true;
            return true;
        }

        return false;
    }

    @RequiresApi(api = Build.VERSION_CODES.Q)
    public static boolean isLockdownVPN() {
        return ((INSTANCE != null) && INSTANCE.isLockdownEnabled());
    }

    private void checkBlacklistsUpdates(boolean firstUpdate) {
        if(!mMalwareDetectionEnabled || (mBlacklistsUpdateThread != null))
            return;

        if(mBlacklistsUpdateRequested || mBlacklists.needsUpdate(firstUpdate)) {
            mBlacklistsUpdateThread = new Thread(this::updateBlacklistsWork, "Blacklists Update");
            mBlacklistsUpdateThread.start();
        }
    }

    private void updateBlacklistsWork() {
        mBlacklistsUpdateRequested = false;
        mBlacklists.update();
        reloadBlacklists();
        mBlacklistsUpdateThread = null;
    }

    private String getIfname(int ifidx) {
        if(ifidx <= 0)
            return "";

        String rv = mIfIndexToName.get(ifidx);
        if(rv != null)
            return rv;

        // Not found, try to retrieve it
        NetworkInterface iface = null;
        try {
            iface = NetworkInterface.getByIndex(ifidx);
        } catch (SocketException ignored) {}
        rv = (iface != null) ? iface.getName() : "";

        // store it even if not found, to avoid looking up it again
        mIfIndexToName.put(ifidx, rv);
        return rv;
    }

    public static Set<String> getAppFilter() {
        return((INSTANCE != null) ? INSTANCE.mSettings.app_filter : null);
    }

    public static Uri getPcapUri() {
        return ((INSTANCE != null) ? INSTANCE.mPcapUri : null);
    }

    public static String getPcapFname() {
        return ((INSTANCE != null) ? INSTANCE.mPcapFname : null);
    }

    public static boolean isUserDefinedPcapUri() {
        return (INSTANCE == null || !INSTANCE.mSettings.pcap_uri.isEmpty());
    }

    public static long getBytes() {
        return((INSTANCE != null) ? INSTANCE.last_bytes : 0);
    }

    public static String getCollectorAddress() {
        return((INSTANCE != null) ? INSTANCE.mSettings.collector_address : "");
    }

    public static int getCollectorPort() {
        return((INSTANCE != null) ? INSTANCE.mSettings.collector_port : 0);
    }

    public static int getHTTPServerPort() {
        return((INSTANCE != null) ? INSTANCE.mSettings.http_server_port : 0);
    }

    public static Prefs.DumpMode getDumpMode() {
        return((INSTANCE != null) ? INSTANCE.mSettings.dump_mode : Prefs.DumpMode.NONE);
    }

    public static String getDNSServer() {
        return((INSTANCE != null) ? INSTANCE.getDnsServer() : "");
    }

    public static boolean isDNSEncrypted() {
        return((INSTANCE != null) && INSTANCE.mDnsEncrypted);
    }

    public static @NonNull CaptureService requireInstance() {
        CaptureService inst = INSTANCE;
        assert(inst != null);
        return(inst);
    }

    public static @Nullable ConnectionsRegister getConnsRegister() {
        return((INSTANCE != null) ? INSTANCE.conn_reg : null);
    }

    public static @Nullable HttpLog getHttpLog() {
        return((INSTANCE != null) ? INSTANCE.mHttpLog : null);
    }

    public static @NonNull ConnectionsRegister requireConnsRegister() {
        ConnectionsRegister reg = getConnsRegister();

        assert(reg != null);

        return reg;
    }

    public static boolean isCapturingAsRoot() {
        return((INSTANCE != null) &&
                (INSTANCE.isRootCapture() == 1));
    }

    public static boolean isDecryptingTLS() {
        return((INSTANCE != null) &&
                (INSTANCE.isTlsDecryptionEnabled() == 1));
    }

    public static boolean isReadingFromPcapFile() {
        return((INSTANCE != null) &&
                (INSTANCE.isPcapFileCapture() == 1));
    }

    public static boolean isIPv6Enabled() {
        return((INSTANCE != null) &&
                (INSTANCE.getIPv6Enabled() == 1));
    }

    public static boolean isDecryptionListEnabled() {
        return(INSTANCE != null && (INSTANCE.mDecryptionList != null));
    }

    public static Prefs.PayloadMode getCurPayloadMode() {
        if(INSTANCE == null)
            return Prefs.PayloadMode.MINIMAL;

        return INSTANCE.mSettings.full_payload ? Prefs.PayloadMode.FULL : Prefs.PayloadMode.MINIMAL;
    }

    public static void requestBlacklistsUpdate() {
        if(INSTANCE != null) {
            INSTANCE.mBlacklistsUpdateRequested = true;

            // Wake the update thread to run the blacklist thread
            INSTANCE.mPendingUpdates.offer(new Pair<>(new ConnectionDescriptor[0], new ConnectionUpdate[0]));
        }
    }

    public static String getInterfaceName(int ifidx) {
        String ifname = null;

        if(INSTANCE != null)
            ifname = INSTANCE.getIfname(ifidx);
        return (ifname != null) ? ifname : "";
    }

    public static CaptureSettings getCaptureSettings() {
        return((INSTANCE != null) ? INSTANCE.mSettings : null);
    }

    private String resolveHost(String host) {
        if((Build.VERSION.SDK_INT < Build.VERSION_CODES.M) || (mUnderlyingNetwork == null))
            return null;

        try {
            return mUnderlyingNetwork.getByName(host).getHostAddress();
        } catch (UnknownHostException e) {
            return null;
        }
    }

    // Resolve hostnames that the native code needs as IPs.
    // Uses the underlying (non-VPN) network to avoid routing through the VPN tunnel.
    private boolean resolveHosts() {
        if(mSocks5Enabled && !mSettings.tls_decryption && !mSocks5Address.isEmpty()
                && !Utils.validateIpAddress(mSocks5Address))
        {
            String resolved = resolveHost(mSocks5Address);
            if(resolved == null) {
                Log.e(TAG, "Could not resolve SOCKS5 proxy: " + mSocks5Address);
                mHandler.post(() -> Utils.showToastLong(this, R.string.host_resolution_failed, mSocks5Address));
                return false;
            }
            Log.i(TAG, "Resolved SOCKS5 proxy: " + mSocks5Address + " -> " + resolved);
            mSocks5Address = resolved;
        }

        if(Prefs.isPortMappingEnabled(mPrefs)) {
            PortMapping portMap = new PortMapping(this);
            Iterator<PortMapping.PortMap> it = portMap.iter();

            while(it.hasNext()) {
                PortMapping.PortMap mapping = it.next();
                String ip = mapping.redirect_host;

                if(!Utils.validateIpAddress(ip)) {
                    String resolved = resolveHost(ip);
                    if(resolved == null) {
                        Log.e(TAG, "Could not resolve port mapping host: " + ip);
                        final String failedHost = ip;
                        mHandler.post(() -> Utils.showToastLong(this, R.string.host_resolution_failed, failedHost));
                        return false;
                    }
                    Log.i(TAG, "Resolved port mapping host: " + ip + " -> " + resolved);
                    ip = resolved;
                }

                addPortMapping(mapping.ipproto, mapping.orig_port, mapping.redirect_port, ip);
            }
        }

        return true;
    }

    // Inside the mCaptureThread
    @Override
    public void run() {
        boolean hostResolved = resolveHosts();
        mUnderlyingNetwork = null;

        if(!hostResolved) {
            // fall through to cleanup
        } else if(mSettings.root_capture || mSettings.readFromPcap()) {
            // Check for INTERACT_ACROSS_USERS, required to query apps of other users/work profiles
            if(mSettings.root_capture && (checkCallingOrSelfPermission(Utils.INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED)) {
                boolean success = Utils.rootGrantPermission(this, Utils.INTERACT_ACROSS_USERS);
                mHandler.post(() -> Utils.showToast(this, success ? R.string.permission_granted : R.string.permission_grant_fail, "INTERACT_ACROSS_USERS"));
            }

            runPacketLoop(-1, this, Build.VERSION.SDK_INT);
        } else {
            if(mParcelFileDescriptor != null) {
                int fd = mParcelFileDescriptor.getFd();
                int fd_setsize = getFdSetSize();

                if((fd > 0) && (fd < fd_setsize)) {
                    Log.d(TAG, "VPN fd: " + fd + " - FD_SETSIZE: " + fd_setsize);
                    runPacketLoop(fd, this, Build.VERSION.SDK_INT);

                    // if always-on VPN is stopped, it's not an always-on anymore
                    mIsAlwaysOnVPN = false;
                } else
                    Log.e(TAG, "Invalid VPN fd: " + fd);
            }
        }

        // After the capture is stopped
        if(mMalwareDetectionEnabled)
            mBlacklists.save();

        // Important: the fd must be closed to properly terminate the VPN
        if(mParcelFileDescriptor != null) {
            try {
                mParcelFileDescriptor.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            mParcelFileDescriptor = null;
        }

        // NOTE: join the threads here instead in onDestroy to avoid ANR
        stopAndJoinThreads();

        stopService();

        mLock.lock();
        mCaptureThread = null;
        mCaptureStopped.signalAll();
        mLock.unlock();

        // Notify
        mHandler.post(() -> {
            updateServiceStatus(ServiceStatus.STOPPED);
            CaptureCtrl.notifyCaptureStopped(this, getStats());
        });
    }

    private void connUpdateWork() {
        while(true) {
            Pair<ConnectionDescriptor[], ConnectionUpdate[]> item;
            try {
                item = mPendingUpdates.take();
            } catch (InterruptedException e) {
                continue;
            }

            if(item.first == null) { // termination request
                Log.i(TAG, "Connection update thread exit requested");
                break;
            }

            ConnectionDescriptor[] new_conns = item.first;
            ConnectionUpdate[] conns_updates = item.second;

            checkBlacklistsUpdates(false);
            if(mBlocklist.checkGracePeriods())
                mHandler.post(this::reloadBlocklist);

            if(!mLowMemory)
                checkAvailableHeap();

            // synchronize the conn_reg to ensure that newConnections and connectionsUpdates run atomically
            // thus preventing the ConnectionsAdapter from interleaving other operations
            synchronized (conn_reg) {
                if(new_conns.length > 0)
                    conn_reg.newConnections(new_conns);

                if(conns_updates.length > 0)
                    conn_reg.connectionsUpdates(conns_updates);
            }

            int val = mNumUpdatesInProgress.decrementAndGet();
            assert(val >= 0);

            if ((val == 0) && (mHttpLog != null))
                mHttpLog.stopConnectionsUpdates();
        }
    }

    private void dumpWork() {
        Log.d(TAG, "Starting the dumper");

        try {
            mDumper.startDumper();
        } catch (IOException | SecurityException e) {
            e.printStackTrace();
            reportError(e.getLocalizedMessage());
            mHandler.post(CaptureService::stopPacketLoop);
            return;
        }

        Log.d(TAG, "Dumper running");

        while(true) {
            byte[] data;
            try {
                data = mDumpQueue.take();
            } catch (InterruptedException e) {
                continue;
            }

            if(data.length == 0) // termination request
                break;

            try {
                mDumper.dumpData(data);
            } catch (IOException e) {
                // Stop the capture
                e.printStackTrace();
                reportError(e.getLocalizedMessage());
                mHandler.post(CaptureService::stopPacketLoop);
                break;
            }
        }

        try {
            mDumper.stopDumper();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void checkAvailableHeap() {
        // This does not account per-app jvm limits
        long availableHeap = Utils.getAvailableHeap();

        if(availableHeap <= Utils.LOW_HEAP_THRESHOLD) {
            Log.w(TAG, "Detected low HEAP memory: " + Utils.formatBytes(availableHeap));
            handleLowMemory();
        }
    }

    // NOTE: this is only called on low system memory (e.g. obtained via getMemoryInfo). The app
    // may still run out of heap memory, whose monitoring requires polling (see checkAvailableHeap)
    @Override
    @SuppressWarnings("deprecation")
    public void onTrimMemory(int level) {
        // NOTE: most trim levels are not available anymore since API 34
        String lvlStr = Utils.trimlvl2str(level);
        boolean lowMemory = (level != TRIM_MEMORY_UI_HIDDEN) && (level >= TRIM_MEMORY_RUNNING_LOW);
        boolean critical = lowMemory && (level >= TRIM_MEMORY_COMPLETE);

        Log.d(TAG, "onTrimMemory: " + lvlStr + " - low=" + lowMemory + ", critical=" + critical);

        if(critical && !mLowMemory)
            handleLowMemory();
    }

    private void handleLowMemory() {
        Log.w(TAG, "handleLowMemory called");
        mLowMemory = true;
        boolean fullPayload = getCurPayloadMode() == Prefs.PayloadMode.FULL;

        if(fullPayload) {
            Log.w(TAG, "Disabling full payload");

            // Disable full payload for new connections
            mSettings.full_payload = false;
            setPayloadMode(Prefs.PayloadMode.NONE.ordinal());

            if(mSettings.tls_decryption) {
                // TLS decryption without payload has little use, stop the capture all together
                stopService();
                notifyLowMemory(getString(R.string.capture_stopped_low_memory));
            } else {
                // Release memory for existing connections
                if(conn_reg != null) {
                    conn_reg.releasePayloadMemory();

                    // *possibly* call the gc
                    System.gc();

                    Log.i(TAG, "Memory stats full payload release:\n" + Utils.getMemoryStats(this));
                }

                notifyLowMemory(getString(R.string.full_payload_disabled));
            }
        } else {
            // TODO lower memory consumption (e.g. reduce connections register size)
            Log.w(TAG, "low memory detected, expect crashes");
            notifyLowMemory(getString(R.string.low_memory_info));
        }
    }

    /* The following methods are called from native code */

    public String getVpnIPv4() {
        return(vpn_ipv4);
    }

    public String getVpnDns() {
        return(vpn_dns);
    }

    public String getDnsServer() {
        return(dns_server);
    }

    public String getIpv6DnsServer() { return(Prefs.getDnsServerV6(mPrefs)); }

    public int getSocks5Enabled() { return mSocks5Enabled ? 1 : 0; }

    public String getSocks5ProxyAddress() {  return(mSocks5Address); }

    public int getSocks5ProxyPort() {  return(mSocks5Port);  }

    public String getSocks5ProxyAuth() {  return(mSocks5Auth);  }

    public int getIPv4Enabled() { return((mSettings.ip_mode != Prefs.IpMode.IPV6_ONLY) ? 1 : 0); }

    public int getIPv6Enabled() { return((mSettings.ip_mode != Prefs.IpMode.IPV4_ONLY) ? 1 : 0); }

    public int isVpnCapture() { return (isRootCapture() | isPcapFileCapture()) == 1 ? 0 : 1; }

    public int isRootCapture() { return(mSettings.root_capture ? 1 : 0); }

    public int isPcapFileCapture() { return(mSettings.readFromPcap() ? 1 : 0); }

    public int isTlsDecryptionEnabled() { return mSettings.tls_decryption ? 1 : 0; }

    public int malwareDetectionEnabled() { return(mMalwareDetectionEnabled ? 1 : 0); }

    public int firewallEnabled() { return(mFirewallEnabled ? 1 : 0); }

    public int dumpExtensionsEnabled() { return(mSettings.dump_extensions ? 1 : 0); }

    public int isPcapngEnabled() { return(mSettings.pcapng_format ? 1 : 0); }

    public int[] getAppFilterUids() { return(mAppFilterUids); }

    public int getMitmAddonUid() {
        return MitmAddon.getUid(this);
    }

    public String getCaptureInterface() { return(mSettings.capture_interface); }

    public int getSnaplen() {  return mSettings.snaplen; }

    public int getMaxPktsPerFlow() {  return mSettings.max_pkts_per_flow; }

    public int getMaxDumpSize() {  return mSettings.max_dump_size; }

    public int getPayloadMode() { return getCurPayloadMode().ordinal(); }

    public int getVpnMTU()      { return VPN_MTU; }

    public int getBlockQuickMode() { return mSettings.block_quic_mode.ordinal(); }

    // returns 1 if dumpPcapData should be called
    public int pcapDumpEnabled() {
        return((mSettings.dump_mode != Prefs.DumpMode.NONE) ? 1 : 0);
    }

    public String getPcapDumperBpf() { return((mDumper != null) ? mDumper.getBpf() : ""); }

    @Override
    public boolean protect(int socket) {
        // Do not call protect in root mode
        if(mSettings.root_capture)
            return true;

        return super.protect(socket);
    }

    // from NetGuard
    @TargetApi(Build.VERSION_CODES.Q)
    public int getUidQ(int protocol, String saddr, int sport, String daddr, int dport) {
        if (protocol != 6 /* TCP */ && protocol != 17 /* UDP */)
            return Utils.UID_UNKNOWN;

        ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
        if (cm == null)
            return Utils.UID_UNKNOWN;

        InetSocketAddress local = new InetSocketAddress(saddr, sport);
        InetSocketAddress remote = new InetSocketAddress(daddr, dport);

        Log.d(TAG, "Get uid local=" + local + " remote=" + remote);
        return cm.getConnectionOwnerUid(protocol, local, remote);
    }

    public void startConnectionsUpdate() {
        int val = mNumUpdatesInProgress.incrementAndGet();
        assert(val >= 0);

        if ((val == 1) && (mHttpLog != null))
            mHttpLog.startConnectionsUpdates();
    }

    public void updateConnections(ConnectionDescriptor[] new_conns, ConnectionUpdate[] conns_updates) {
        if(mQueueFull)
            // if the queue is full, stop receiving updates to avoid inconsistent incr_ids
            return;

        // Put the update into a queue to avoid performing much work on the capture thread.
        // This will be processed by mConnUpdateThread.
        if(!mPendingUpdates.offer(new Pair<>(new_conns, conns_updates))) {
            Log.e(TAG, "The updates queue is full, this should never happen!");
            mQueueFull = true;
            mHandler.post(CaptureService::stopPacketLoop);
        }
    }

    public static boolean isUsharkAvailable(Context ctx) {
        return new File(getLibprogPath(ctx, "ushark")).exists();
    }

    // called from native
    public void sendStatsDump(CaptureStats stats) {
        //Log.d(TAG, "sendStatsDump");

        last_bytes = stats.bytes_sent + stats.bytes_rcvd;
        last_connections = stats.tot_conns;
        mHandler.post(this::updateNotification);

        // notify the observers
        lastStats.postValue(stats);
    }

    // called from native
    private void sendServiceStatus(String cur_status) {
        updateServiceStatus(cur_status.equals("started") ? ServiceStatus.STARTED : ServiceStatus.STOPPED);
    }

    private void updateServiceStatus(ServiceStatus cur_status) {
        // notify the observers
        // NOTE: new subscribers will receive the STOPPED status right after their registration
        serviceStatus.postValue(cur_status);

        if(cur_status == ServiceStatus.STARTED) {
            if(mMalwareDetectionEnabled)
                reloadMalwareWhitelist();
            if(mDecryptionList != null)
                reloadDecryptionList();
            reloadBlocklist();
            reloadFirewallWhitelist();
        } else if (cur_status == ServiceStatus.STOPPED) {
            if (mRevoked && Prefs.restartOnDisconnect(mPrefs) && !mIsAlwaysOnVPN && (isVpnCapture() == 1)) {
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
                    Log.i(TAG, "VPN disconnected, starting reconnect service");

                    final Intent intent = new Intent(this, VpnReconnectService.class);
                    ContextCompat.startForegroundService(this, intent);
                }
            }
        }
    }

    // NOTE: to be invoked only by the native code
    public String getApplicationByUid(int uid) {
        AppDescriptor dsc = mNativeAppsResolver.getAppByUid(uid, 0);

        if(dsc == null)
            return "";

        return dsc.getName();
    }

    public String getPackageNameByUid(int uid) {
        AppDescriptor dsc = mNativeAppsResolver.getAppByUid(uid, 0);

        if(dsc == null)
            return "";

        return dsc.getPackageName();
    }

    public void loadUidMapping(int uid, String package_name, String app_name) {
        if (uid < 0)
            return;

        AppDescriptor dsc = mNativeAppsResolver.getAppByUid(uid, 0);

        if ((dsc == null) || !dsc.getPackageName().equals(package_name)) {
            // This uid corresponds to a different app than the one on the Pcapng
            AppsResolver.addMappedApp(uid, package_name, app_name);
        }
    }

    public String getCountryCode(String host) {
        if (mNativeGeolocation.isAvailable()) {
            try {
                InetAddress addr = InetAddress.getByName(host);
                return mNativeGeolocation.getCountryCode(addr);
            } catch (UnknownHostException ignored) {}
        }

        return "";
    }

    /* Exports a PCAP data chunk */
    public void dumpPcapData(byte[] data) {
        if((mDumper != null) && (data.length > 0)) {
            while(true) {
                try {
                    // wait until the queue has space to insert the data. If the queue is full, we
                    // will experience slow-downs/drops but this is expected
                    mDumpQueue.put(data);
                    break;
                } catch (InterruptedException e) {
                    // retry
                }
            }
        }
    }

    public void stopPcapDump() {
        if((mDumpQueue != null) && (mDumperThread != null) && (mDumperThread.isAlive()))
            mDumpQueue.offer(new byte[0]);
    }

    public void reportError(String msg) {
        HAS_ERROR = true;

        mHandler.post(() -> {
            String err = msg;

            // Try to get a translated string (see errors.h)
            switch (msg) {
                case "Unsupported PCAP/Pcapng file":
                    err = getString(R.string.unsupported_pcap_file);
                    break;
                case "Invalid PCAP/Pcapng file":
                    err = getString(R.string.invalid_pcap_file);
                    break;
                case "Could not open the capture interface":
                    err = getString(R.string.capture_interface_open_error);
                    break;
                case "Unsupported datalink":
                    err = getString(R.string.unsupported_pcap_datalink);
                    break;
                case "The specified PCAP/Pcapng file does not exist":
                    err = getString(R.string.pcap_file_not_exists);
                    break;
                case "pcapd daemon start failure":
                    if(mSettings.root_capture)
                        err = getString(R.string.root_capture_pcapd_start_failure);
                    break;
                case "pcapd daemon did not spawn":
                    if(mSettings.root_capture)
                        err = getString(R.string.root_capture_start_failed);
                    break;
                case "PCAP/Pcapng read error":
                    err = getString(R.string.pcap_read_error);
                    break;
            }

            Toast.makeText(this, err, Toast.LENGTH_LONG).show();
        });
    }

    public String getWorkingDir() {
        return getCacheDir().getAbsolutePath();
    }
    public String getPersistentDir() { return getFilesDir().getAbsolutePath(); }

    public String getLibprogPath(String prog_name) {
        return getLibprogPath(this, prog_name);
    }

    public static String getLibprogPath(Context ctx, String prog_name) {
        // executable binaries are stored into the /lib folder of the app
        String dir = ctx.getApplicationInfo().nativeLibraryDir;
        return(dir + "/lib" + prog_name + ".so");
    }

    public void notifyBlacklistsLoaded(Blacklists.NativeBlacklistStatus[] loaded_blacklists) {
        // this is invoked from the packet capture thread. Use the handler to save time.
        mHandler.post(() -> mBlacklists.onNativeLoaded(loaded_blacklists));
    }

    public BlacklistDescriptor[] getBlacklistsInfo() {
        BlacklistDescriptor[] blsinfo = new BlacklistDescriptor[mBlacklists.getNumBlacklists()];
        int i = 0;

        Iterator<BlacklistDescriptor> it = mBlacklists.iter();
        while(it.hasNext())
            blsinfo[i++] = it.next();

        return blsinfo;
    }

    public void reloadBlocklist() {
        if(!mBilling.isFirewallVisible())
            return;

        Log.i(TAG, "reloading firewall blocklist");
        reloadBlocklist(mBlocklist.toListDescriptor());
    }

    public void reloadFirewallWhitelist() {
        if(!mBilling.isFirewallVisible())
            return;

        Log.i(TAG, "reloading firewall whitelist");
        reloadFirewallWhitelist(Prefs.isFirewallWhitelistMode(mPrefs) ? mFirewallWhitelist.toListDescriptor() : null);
    }

    public static void reloadMalwareWhitelist() {
        if((INSTANCE == null) || !INSTANCE.mMalwareDetectionEnabled)
            return;

        Log.i(TAG, "reloading malware whitelist");
        reloadMalwareWhitelist(INSTANCE.mMalwareWhitelist.toListDescriptor());
    }

    public static void reloadDecryptionList() {
        if((INSTANCE == null) || (INSTANCE.mDecryptionList == null))
            return;

        Log.i(TAG, "reloading TLS decryption whitelist");
        reloadDecryptionList(INSTANCE.mDecryptionList.toListDescriptor());
    }

    public static void setFirewallEnabled(boolean enabled) {
        if(INSTANCE == null)
            return;

        INSTANCE.mFirewallEnabled = enabled;
        nativeSetFirewallEnabled(enabled);
    }

    public static @NonNull CaptureStats getStats() {
        CaptureStats stats = lastStats.getValue();
        return((stats != null) ? stats : new CaptureStats());
    }

    public static void observeStats(LifecycleOwner lifecycleOwner, Observer<CaptureStats> observer) {
        lastStats.observe(lifecycleOwner, observer);
    }

    public static void observeStatus(LifecycleOwner lifecycleOwner, Observer<ServiceStatus> observer) {
        serviceStatus.observe(lifecycleOwner, observer);
    }

    public static void waitForCaptureStop() {
        if(INSTANCE == null)
            return;

        Log.d(TAG, "waitForCaptureStop " + Thread.currentThread().getName());
        INSTANCE.mLock.lock();
        try {
            while(INSTANCE.mCaptureThread != null) {
                try {
                    INSTANCE.mCaptureStopped.await();
                } catch (InterruptedException ignored) {}
            }
        } finally {
            INSTANCE.mLock.unlock();
        }
        Log.d(TAG, "waitForCaptureStop done " + Thread.currentThread().getName());
    }

    public static boolean hasError() {
        return HAS_ERROR;
    }

    public static @Nullable Utils.PrivateDnsMode getPrivateDnsMode() {
        return isServiceActive() ? INSTANCE.mPrivateDnsMode : null;
    }

    public static native int initLogger(String path, int level);
    public static native int writeLog(int logger, int lvl, String message);
    private static native void initPlatformInfo(String appver, String device, String os);
    private static native void runPacketLoop(int fd, CaptureService vpn, int sdk);
    private static native void stopPacketLoop();
    private static native int getFdSetSize();
    private static native void setPrivateDnsBlocked(boolean to_block);
    private static native void setDnsServer(String server);
    private static native void addPortMapping(int ipproto, int orig_port, int redirect_port, String redirect_ip);
    private static native void reloadBlacklists();
    private static native boolean reloadBlocklist(MatchList.ListDescriptor blocklist);
    private static native boolean reloadFirewallWhitelist(MatchList.ListDescriptor whitelist);
    private static native boolean reloadMalwareWhitelist(MatchList.ListDescriptor whitelist);
    private static native boolean reloadDecryptionList(MatchList.ListDescriptor whitelist);
    public static native void askStatsDump();
    public static native byte[] getPcapHeader();
    public static native void nativeSetFirewallEnabled(boolean enabled);
    public static native int getNumCheckedMalwareConnections();
    public static native int getNumCheckedFirewallConnections();
    public static native int rootCmd(String prog, String args);
    public static native void setPayloadMode(int mode);
    public static native List<String> getL7Protocols();
    public static native void dumpMasterSecret(byte[] secret);
    public static native boolean hasSeenDumpExtensions();
    public static native boolean extractKeylogFromPcapng(String pcapng_path, String out_path);
}

```

`app/src/main/java/com/emanuelef/remote_capture/Cidr.java`:

```java
/*
 * The MIT License
 *
 * Copyright (c) 2013 Edin Dazdarevic (edin.dazdarevic@gmail.com)

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * */

package com.emanuelef.remote_capture;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

/**
 * A class that enables to get an IP range from CIDR specification. It supports
 * both IPv4 and IPv6.
 */
public class Cidr {
    private static final String TAG = "CIDR";
    private final InetAddress inetAddress;
    private final String stringCidr;
    private final int prefixLength;
    private InetAddress startAddress;
    private InetAddress endAddress;
    private BigInteger startAddressBigInt;
    private BigInteger endAddressBigInt;

    public Cidr(String cidr) throws UnknownHostException, IllegalArgumentException {
        stringCidr = cidr;

        /* split CIDR to address and prefix part */
        if (cidr.contains("/")) {
            int index = cidr.indexOf("/");
            String addressPart = cidr.substring(0, index);
            String networkPart = cidr.substring(index + 1);

            inetAddress = InetAddress.getByName(addressPart);
            prefixLength = Integer.parseInt(networkPart);

            calculate();
        } else {
            Log.w(TAG, "Invalid CIDR: " + cidr);
            throw new IllegalArgumentException("not an valid CIDR format!");
        }
    }

    private void calculate() throws UnknownHostException {
        ByteBuffer maskBuffer;
        int targetSize;
        if (inetAddress.getAddress().length == 4) {
            maskBuffer =
                    ByteBuffer
                            .allocate(4)
                            .putInt(-1);
            targetSize = 4;
        } else {
            maskBuffer = ByteBuffer.allocate(16)
                    .putLong(-1L)
                    .putLong(-1L);
            targetSize = 16;
        }

        BigInteger mask = (new BigInteger(1, maskBuffer.array())).not().shiftRight(prefixLength);

        ByteBuffer buffer = ByteBuffer.wrap(inetAddress.getAddress());
        BigInteger ipVal = new BigInteger(1, buffer.array());

        BigInteger startIp = ipVal.and(mask);
        BigInteger endIp = startIp.add(mask.not());

        byte[] startIpArr = toBytes(startIp.toByteArray(), targetSize);
        byte[] endIpArr = toBytes(endIp.toByteArray(), targetSize);

        this.startAddress = InetAddress.getByAddress(startIpArr);
        this.startAddressBigInt = new BigInteger(1, this.startAddress.getAddress());

        this.endAddress = InetAddress.getByAddress(endIpArr);
        this.endAddressBigInt = new BigInteger(1, this.endAddress.getAddress());

    }

    private byte[] toBytes(byte[] array, int targetSize) {
        int counter = 0;
        List<Byte> newArr = new ArrayList<Byte>();
        while (counter < targetSize && (array.length - 1 - counter >= 0)) {
            newArr.add(0, array[array.length - 1 - counter]);
            counter++;
        }

        int size = newArr.size();
        for (int i = 0; i < (targetSize - size); i++) {

            newArr.add(0, (byte) 0);
        }

        byte[] ret = new byte[newArr.size()];
        for (int i = 0; i < newArr.size(); i++) {
            ret[i] = newArr.get(i);
        }
        return ret;
    }

    public String getNetworkAddress() {
        return this.startAddress.getHostAddress();
    }

    public String getBroadcastAddress() {
        return this.endAddress.getHostAddress();
    }

    public boolean isInRange(String ipAddress) throws UnknownHostException {
        InetAddress address = InetAddress.getByName(ipAddress);
        return isInRange(address);
    }

    public boolean isInRange(InetAddress address) {
        BigInteger start = this.startAddressBigInt;
        BigInteger end = this.endAddressBigInt;
        BigInteger target = new BigInteger(1, address.getAddress());

        if (start.compareTo(target) > 0){
            return false; //start is higher than address -> is not in range
        }
        return end.compareTo(target) >= 0; // end is higher or equal -> is in range
    }

    @Override
    public boolean equals(@Nullable Object obj) {
        if (!(obj instanceof Cidr other))
            return super.equals(obj);

        return (other.startAddress.equals(startAddress)) &&
                (other.endAddress.equals(endAddress));
    }

    @NonNull
    @Override
    public String toString() {
        return stringCidr;
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/ConnectionsRegister.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;
import android.util.SparseArray;
import android.util.SparseIntArray;

import androidx.annotation.Nullable;
import androidx.collection.ArraySet;

import com.emanuelef.remote_capture.interfaces.ConnectionsListener;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.AppStats;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.ConnectionUpdate;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;

/* A container for the connections. This is used to store active/closed connections until the capture
 * is stopped. Active connections are also kept in the native side.
 *
 * The ConnectionsRegister can store up to _size items, after which rollover occurs and older
 * connections are replaced with the new ones. Via the addListener method it's possible to listen
 * for connections changes (connections added/removed/updated). The usual listener for such events
 * is the ConnectionsFragment, which then forwards them to the ConnectionsAdapter.
 *
 * Connections are added/updated by the CaptureService in a separate thread. The getter methods are
 * instead called on the UI thread, usually by the ConnectionsAdapter. Methods are synchronized to
 * provide threads safety on this class. Concurrent access to the ConnectionDescriptors fields can
 * occur during connectionsUpdates but it's not protected, check out the ConnectionDescriptor class
 * for more details.
 */
public class ConnectionsRegister {
    private static final String TAG = "ConnectionsRegister";

    private final ConnectionDescriptor[] mItemsRing;
    private int mTail;
    private final int mSize;
    private int mCurItems;
    private int mUntrackedItems; // number of old connections which were discarded due to the rollover
    private int mNumMalicious;
    private int mNumBlocked;
    private long mLastFirewallBlock;
    private long mMaxBytes;
    private final SparseArray<AppStats> mAppsStats;
    private final SparseIntArray mConnsByIface;
    private final ArrayList<ConnectionsListener> mListeners;
    private final Geolocation mGeo;
    private final AppsResolver mAppsResolver;

    public ConnectionsRegister(Context ctx, int _size) {
        mTail = 0;
        mCurItems = 0;
        mUntrackedItems = 0;
        mMaxBytes = 0;
        mSize = _size;
        mGeo = new Geolocation(ctx);
        mItemsRing = new ConnectionDescriptor[mSize];
        mListeners = new ArrayList<>();
        mAppsStats = new SparseArray<>(); // uid -> AppStats
        mConnsByIface = new SparseIntArray();
        mAppsResolver = new AppsResolver(ctx);
    }

    // returns the position in mItemsRing of the oldest connection
    private synchronized int firstPos() {
        return (mCurItems < mSize) ? 0 : mTail;
    }

    // returns the position in mItemsRing of the newest connection
    private synchronized int lastPos() {
        return (mTail - 1 + mSize) % mSize;
    }

    private void processConnectionStatus(ConnectionDescriptor conn, AppStats stats) {
        boolean is_blacklisted = conn.isBlacklisted();

        if(!conn.alerted && is_blacklisted) {
            CaptureService.requireInstance().notifyBlacklistedConnection(conn);
            conn.alerted = true;
            mNumMalicious++;
        } else if(conn.alerted && !is_blacklisted) {
            // the connection was whitelisted
            conn.alerted = false;
            mNumMalicious--;
        }

        if(!conn.block_accounted && conn.is_blocked) {
            mNumBlocked++;
            stats.numBlockedConnections++;
            conn.block_accounted = true;
        } else if(conn.block_accounted && !conn.is_blocked) {
            mNumBlocked--;
            stats.numBlockedConnections--;
            conn.block_accounted = false;
        }

        if(conn.is_blocked)
            mLastFirewallBlock = Math.max(conn.last_seen, mLastFirewallBlock);
    }

    // called by the CaptureService in a separate thread when new connections should be added to the register
    public synchronized void newConnections(ConnectionDescriptor[] conns) {
        if(conns.length > mSize) {
            // this should only occur while testing with small register sizes
            // take the most recent connections
            mUntrackedItems += conns.length - mSize;
            conns = Arrays.copyOfRange(conns, conns.length - mSize, conns.length);
        }

        int out_items = conns.length - Math.min((mSize - mCurItems), conns.length);
        int insert_pos = mCurItems;
        boolean recalcMaxBytes = false;
        ConnectionDescriptor[] removedItems = null;

        //Log.d(TAG, "newConnections[" + mNumItems + "/" + mSize +"]: insert " + conns.length +
        //        " items at " + mTail + " (removed: " + out_items + " at " + firstPos() + ")");

        // Remove old connections
        if(out_items > 0) {
            int pos = firstPos();
            removedItems = new ConnectionDescriptor[out_items];

            for(int i=0; i<out_items; i++) {
                ConnectionDescriptor conn = mItemsRing[pos];

                if(conn != null) {
                    if(conn.ifidx > 0) {
                        int num_conn = mConnsByIface.get(conn.ifidx);
                        if(--num_conn <= 0)
                            mConnsByIface.delete(conn.ifidx);
                        else
                            mConnsByIface.put(conn.ifidx, num_conn);
                    }

                    if(conn.isBlacklisted())
                        mNumMalicious--;

                    if ((conn.sent_bytes + conn.rcvd_bytes) == mMaxBytes)
                        recalcMaxBytes = true;
                }

                removedItems[i] = conn;
                pos = (pos + 1) % mSize;
            }
        }

        // Add new connections
        for(ConnectionDescriptor conn: conns) {
            mItemsRing[mTail] = conn;
            mTail = (mTail + 1) % mSize;
            mCurItems = Math.min(mCurItems + 1, mSize);

            // update the apps stats
            int uid = conn.uid;
            AppStats stats = getAppsStatsOrCreate(uid);

            if(conn.ifidx > 0) {
                int num_conn = mConnsByIface.get(conn.ifidx);
                mConnsByIface.put(conn.ifidx, num_conn + 1);
            }

            // ASN (country is set by native code)
            conn.asn = mGeo.getASN(conn.getDstAddr());
            //Log.d(TAG, "IP geolocation: IP=" + conn.dst_ip + " -> country=" + conn.country + ", ASN: " + conn.asn);

            AppDescriptor app = mAppsResolver.getAppByUid(conn.uid, 0);
            if(app != null)
                conn.encrypted_payload = Utils.hasEncryptedPayload(app, conn);

            processConnectionStatus(conn, stats);

            stats.numConnections++;
            stats.rcvdBytes += conn.rcvd_bytes;
            stats.sentBytes += conn.sent_bytes;

            long totBytes = conn.sent_bytes + conn.rcvd_bytes;
            if (totBytes > mMaxBytes) {
                mMaxBytes = totBytes;
                recalcMaxBytes = false;
            }
        }

        mUntrackedItems += out_items;

        if (recalcMaxBytes)
            calculateMaxBytes();

        for(ConnectionsListener listener: mListeners) {
            if(out_items > 0)
                listener.connectionsRemoved(0, removedItems);

            if(conns.length > 0)
                listener.connectionsAdded(insert_pos - out_items, conns);
        }
    }

    private synchronized void calculateMaxBytes() {
        long maxBytes = 0;

        for(int i = 0; i < mCurItems; i++) {
            ConnectionDescriptor conn = mItemsRing[i];
            maxBytes = Math.max(maxBytes, conn.sent_bytes + conn.rcvd_bytes);
        }

        mMaxBytes = maxBytes;
    }

    // called by the CaptureService in a separate thread when connections should be updated
    public synchronized void connectionsUpdates(ConnectionUpdate[] updates) {
        if(mCurItems == 0)
            return;

        int first_pos = firstPos();
        int last_pos = lastPos();
        int first_id = mItemsRing[first_pos].incr_id;
        int last_id = mItemsRing[last_pos].incr_id;
        int []changed_pos = new int[updates.length];
        int k = 0;

        Log.d(TAG, "connectionsUpdates: items=" + mCurItems + ", first_id=" + first_id + ", last_id=" + last_id);

        for(ConnectionUpdate update: updates) {
            int id = update.incr_id;

            // ignore updates for untracked items
            if((id >= first_id) && (id <= last_id)) {
                int pos = ((id - first_id) + first_pos) % mSize;
                ConnectionDescriptor conn = mItemsRing[pos];
                assert(conn.incr_id == id);

                // update the app stats
                AppStats stats = getAppsStatsOrCreate(conn.uid);
                stats.sentBytes += update.sent_bytes - conn.sent_bytes;
                stats.rcvdBytes += update.rcvd_bytes - conn.rcvd_bytes;
                mMaxBytes = Math.max(mMaxBytes, update.sent_bytes + update.rcvd_bytes);

                //Log.d(TAG, "update " + update.incr_id + " -> " + update.update_type);
                conn.processUpdate(update);
                processConnectionStatus(conn, stats);

                changed_pos[k++] = (pos + mSize - first_pos) % mSize;
            }
        }

        if(k == 0)
            // no updates for items in the ring
            return;

        if(k != updates.length)
            // some untracked items where skipped, shrink the array
            changed_pos = Arrays.copyOf(changed_pos, k);

        for(ConnectionsListener listener: mListeners)
            listener.connectionsUpdated(changed_pos);
    }

    public synchronized void reset() {
        for(int i = 0; i< mSize; i++)
            mItemsRing[i] = null;

        mCurItems = 0;
        mUntrackedItems = 0;
        mTail = 0;
        mAppsStats.clear();

        for(ConnectionsListener listener: mListeners)
            listener.connectionsChanges(mCurItems);
    }

    public synchronized void addListener(ConnectionsListener listener) {
        mListeners.add(listener);

        // Send the first update to sync it
        listener.connectionsChanges(mCurItems);

        Log.d(TAG, "(add) new connections listeners size: " + mListeners.size());
    }

    public synchronized void removeListener(ConnectionsListener listener) {
        mListeners.remove(listener);

        Log.d(TAG, "(remove) new connections listeners size: " + mListeners.size());
    }

    public int getConnCount() {
        return mCurItems;
    }

    public int getUntrackedConnCount() {
        return mUntrackedItems;
    }

    // get the i-th oldest connection
    public synchronized @Nullable ConnectionDescriptor getConn(int i) {
        if((i < 0) || (i >= mCurItems))
            return null;

        int pos = (firstPos() + i) % mSize;
        return mItemsRing[pos];
    }

    public synchronized int getConnPositionById(int incr_id) {
        if(mCurItems <= 0)
            return -1;

        ConnectionDescriptor first = mItemsRing[firstPos()];
        ConnectionDescriptor last = mItemsRing[lastPos()];

        if((incr_id < first.incr_id) || (incr_id > last.incr_id))
            return -1;

        return(incr_id - first.incr_id);
    }

    public synchronized @Nullable ConnectionDescriptor getConnById(int incr_id) {
        int pos = getConnPositionById(incr_id);
        if(pos < 0)
            return null;

        return getConn(pos);
    }

    public synchronized AppStats getAppStats(int uid) {
        return mAppsStats.get(uid);
    }

    public synchronized List<AppStats> getAppsStats() {
        ArrayList<AppStats> rv = new ArrayList<>(mAppsStats.size());

        for(int i=0; i<mAppsStats.size(); i++) {
            // Create a clone to avoid concurrency issues
            AppStats stats = mAppsStats.valueAt(i).clone();

            rv.add(stats);
        }

        return rv;
    }

    private synchronized AppStats getAppsStatsOrCreate(int uid) {
        AppStats stats = mAppsStats.get(uid);
        if(stats == null) {
            stats = new AppStats(uid);
            mAppsStats.put(uid, stats);
        }

        return stats;
    }

    public synchronized void resetAppsStats() {
        mAppsStats.clear();
    }

    public synchronized Set<Integer> getSeenUids() {
        ArraySet<Integer> rv = new ArraySet<>();

        for(int i=0; i<mAppsStats.size(); i++)
            rv.add(mAppsStats.keyAt(i));

        return rv;
    }

    public int getNumMaliciousConnections() {
        return mNumMalicious;
    }

    public int getNumBlockedConnections() {
        return mNumBlocked;
    }

    public long getLastFirewallBlock() {
        return mLastFirewallBlock;
    }

    public synchronized boolean hasSeenMultipleInterfaces() {
        return(mConnsByIface.size() > 1);
    }

    // Returns a sorted list of seen network interfaces
    public synchronized List<String> getSeenInterfaces() {
        List<String> rv = new ArrayList<>();

        for(int i=0; i<mConnsByIface.size(); i++) {
            int ifidx = mConnsByIface.keyAt(i);
            String ifname = CaptureService.getInterfaceName(ifidx);

            if(!ifname.isEmpty())
                rv.add(ifname);
        }

        Collections.sort(rv);
        return rv;
    }

    public synchronized void releasePayloadMemory() {
        Log.i(TAG, "releaseFullPayloadMemory called");

        for(int i=0; i<mCurItems; i++) {
            ConnectionDescriptor conn = mItemsRing[i];
            conn.dropPayload();
        }
    }

    public synchronized long getMaxBytes() {
        return mMaxBytes;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/Geolocation.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.annotation.SuppressLint;
import android.content.Context;

import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.model.Geomodel;
import com.maxmind.db.Reader;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

/* A class to query geolocation info from IP addresses. */
public class Geolocation {
    private static final String TAG = "Geolocation";
    private final Context mContext;
    private Reader mCountryReader;
    private Reader mAsnReader;

    public Geolocation(Context ctx) {
        mContext = ctx;
        openDb();
    }

    @Override
    public void finalize() {
        Utils.safeClose(mCountryReader);
        Utils.safeClose(mAsnReader);
        mCountryReader = null;
        mAsnReader = null;
    }

    private void openDb() {
        try {
            mCountryReader = new Reader(getCountryFile(mContext));
            Log.d(TAG, "Country DB loaded: " + mCountryReader.getMetadata());

            mAsnReader = new Reader(getAsnFile(mContext));
            Log.d(TAG, "ASN DB loaded: " + mAsnReader.getMetadata());
        } catch (IOException e) {
            Log.i(TAG, "Geolocation is not available");
        }
    }

    public boolean isAvailable() {
        return (mCountryReader != null) && (mAsnReader != null);
    }

    public static boolean isAvailable(Context ctx) {
        Date builtDate = Geolocation.getDbDate(ctx);
        return (builtDate != null);
    }

    private static File getCountryFile(Context ctx) {
        return new File(ctx.getFilesDir() + "/dbip_country_lite.mmdb");
    }

    private static File getAsnFile(Context ctx) {
        return new File(ctx.getFilesDir() + "/dbip_asn_lite.mmdb");
    }

    public static Date getDbDate(File file) throws IOException {
        try(Reader reader = new Reader(file)) {
            return reader.getMetadata().getBuildDate();
        }
    }

    public static @Nullable Date getDbDate(Context ctx) {
        try {
            return getDbDate(getCountryFile(ctx));
        } catch (IOException ignored) {
            return null;
        }
    }

    public static long getDbSize(Context ctx) {
        return getCountryFile(ctx).length() + getAsnFile(ctx).length();
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    public static void deleteDb(Context ctx) {
        getCountryFile(ctx).delete();
        getAsnFile(ctx).delete();
    }

    @SuppressLint("SimpleDateFormat")
    public static boolean downloadDb(Context ctx) {
        String dateid = new SimpleDateFormat("yyyy-MM", Locale.US).format(new Date());
        String country_url = "https://download.db-ip.com/free/dbip-country-lite-" + dateid + ".mmdb.gz";
        String asn_url = "https://download.db-ip.com/free/dbip-asn-lite-" + dateid + ".mmdb.gz";

        try {
            return downloadAndUnzip(ctx, "country", country_url, getCountryFile(ctx)) &&
                    downloadAndUnzip(ctx, "asn", asn_url, getAsnFile(ctx));
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    private static boolean downloadAndUnzip(Context ctx, String label, String url, File dst) throws IOException {
        File tmp_file = new File(ctx.getCacheDir() + "/geoip_db.zip");

        boolean rv = Utils.downloadFile(url, tmp_file.getAbsolutePath());
        if(!rv) {
            Log.w(TAG, "Could not download " + label + " db from " +  url);
            return false;
        }

        try(FileInputStream is = new FileInputStream(tmp_file.getAbsolutePath())) {
            if(!Utils.ungzip(is, dst.getAbsolutePath())) {
                Log.w(TAG, "ungzip of " + tmp_file + " failed");
                return false;
            }

            // Verify - throws IOException on error
            getDbDate(dst);

            return true;
        } finally {
            //noinspection ResultOfMethodCallIgnored
            tmp_file.delete();
        }
    }

    public String getCountryCode(InetAddress addr) {
        if(mCountryReader != null) {
            try {
                Geomodel.CountryResult res = mCountryReader.get(addr, Geomodel.CountryResult.class);
                if ((res != null) && (res.country != null))
                    return res.country.isoCode;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        // fallback
        return "";
    }

    public Geomodel.ASN getASN(InetAddress addr) {
        if(mAsnReader != null) {
            try {
                Geomodel.ASN res = mAsnReader.get(addr, Geomodel.ASN.class);
                if (res != null)
                    return res;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        // fallback
        return new Geomodel.ASN();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/HTTPReassembly.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import com.emanuelef.remote_capture.model.PayloadChunk;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.zip.GZIPInputStream;
import java.util.zip.InflaterInputStream;
import java.util.zip.Inflater;
import org.brotli.dec.BrotliInputStream;

public class HTTPReassembly {
    private static final String TAG = "HTTPReassembly";
    private static final int MAX_HEADERS_SIZE = 1024;
    private boolean mReadingHeaders;
    private boolean mChunkedEncoding;
    private ContentEncoding mContentEncoding;
    private int mContentLength;
    private int mHeadersSize;
    private int mBodySize;
    private final ArrayList<PayloadChunk> mHeaders = new ArrayList<>();
    private final ArrayList<PayloadChunk> mBody = new ArrayList<>();
    private final ReassemblyListener mListener;
    private final boolean mDumpPayload;
    private boolean mReassembleChunks;
    private boolean mSwitchingProtocols = false;
    private boolean mWebsocketUpgrade = false;
    private boolean mInvalidHttp;
    private PayloadChunk mFirstChunk;
    private WebSocketDecoder mWebSocketDecoder;

    /**
     * @param reassembleChunks if false, all the chunks will be considered as RAW chunks
     * @param listener a listener for the reassembly
     * @param dumpPayload if false, PayloadChunk notified via onChunkReassembled will have no payload
     */
    public HTTPReassembly(boolean reassembleChunks, ReassemblyListener listener, boolean dumpPayload) {
        mListener = listener;
        mReassembleChunks = reassembleChunks;
        mDumpPayload = dumpPayload;
        reset();
    }

    public HTTPReassembly(boolean reassembleChunks, ReassemblyListener listener) {
        this(reassembleChunks, listener, true);
    }

    private enum ContentEncoding {
        UNKNOWN,
        GZIP,
        DEFLATE,
        BROTLI,
        ZSTD,
    }

    private boolean isTx() {
        return (mFirstChunk != null) && mFirstChunk.is_sent;
    }

    private void reset() {
        mReadingHeaders = true;
        mContentEncoding = ContentEncoding.UNKNOWN;
        mChunkedEncoding = false;
        mContentLength = -1;
        mFirstChunk = null;
        mHeadersSize = 0;
        mHeaders.clear();
        mBody.clear();

        // Do not reset, these affects the whole connection
        //upgradeFound = false;
        //mInvalidHttp = false;
    }

    public interface ReassemblyListener {
        void onChunkReassembled(PayloadChunk chunk);
    }

    private void log_d(String msg) {
        Log.d(TAG + "(" + (isTx() ? "TX" : "RX") + ")", msg);
    }

    /* The request/response tab shows reassembled HTTP chunks.
     * Reassembling chunks is requires when using a content-encoding like gzip since we can only
     * decode the data when we have the full chunk and we cannot determine data bounds.
     *
     * When reading data via the MitmReceiver, mitmproxy already performs chunks reassembly and
     * also handles HTTP/2 so that we only get the payload.
     *
     * Similarly, also ushark performs HTTP/2 request/reply reassembly, so we always get the whole
     * HTTP headers and body in a single chunk. With ushark, though, HTTP/2 replies may arrive in
     * a different order (due to HTTP/2 multiplexing). chunk.stream_id is used by ConnectionDescriptor
     * to associate the reply to the correct request.
     */
    public void handleChunk(PayloadChunk chunk) {
        if (mSwitchingProtocols) {
            if (mWebsocketUpgrade) {
                chunk.type = PayloadChunk.ChunkType.WEBSOCKET;

                if (mDumpPayload) {
                    // when reading from ushark, pass all the Websocket data to the decoder
                    if (mWebSocketDecoder == null) {
                        // Initialize decoder - all future chunks will be routed through it
                        // Filter out control frames (ping/pong/close) as they're not relevant for payload display
                        mWebSocketDecoder = new WebSocketDecoder(decoded -> {
                            if (!WebSocketDecoder.isControlOpcode(decoded.wsOpcode))
                                mListener.onChunkReassembled(decoded);
                        });
                    }

                    mWebSocketDecoder.handleChunk(chunk);
                }
            }

            // protocols switched, not HTTP anymore
            return;
        }

        int body_start = 0;
        byte[] payload = chunk.payload;
        boolean chunked_complete = false;

        if (mFirstChunk == null)
            mFirstChunk = chunk.withPayload(null);

        if(mReadingHeaders) {
            // Reading the HTTP headers
            int headers_end = Utils.getEndOfHTTPHeaders(payload);
            int headers_size = (headers_end == 0) ? payload.length : headers_end;
            boolean is_first_line = (mHeadersSize == 0);
            mHeadersSize += headers_size;

            try(BufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(payload, 0, headers_size)))) {
                String line = reader.readLine();

                if (is_first_line && (line != null)) {
                    if (chunk.is_sent) {
                        int first_space = line.indexOf(' ');
                        int second_space = line.indexOf(' ', first_space + 1);

                        if ((first_space > 0) && (second_space > 0)) {
                            mFirstChunk.httpMethod = line.substring(0, first_space).toUpperCase();
                            mFirstChunk.httpVersion = line.substring(second_space + 1);
                            String path = line.substring(first_space + 1, second_space);

                            if (!path.startsWith("/")) {
                                // it may include the protocol and host
                                int proto_sep = path.indexOf("://");

                                if (proto_sep > 0)
                                    path = path.substring(proto_sep + 3);

                                int slash = path.indexOf('/');
                                if (slash > 0) {
                                    mFirstChunk.httpHost = path.substring(0, slash);
                                    path = path.substring(slash);
                                }
                            }

                            int query_start = path.indexOf('?');
                            if (query_start >= 0) {
                                mFirstChunk.httpQuery = path.substring(query_start);
                                path = path.substring(0, query_start);
                            }

                            mFirstChunk.httpPath = path;

                            //log_d(mFirstChunk.httpMethod + " " + mFirstChunk.httpPath);
                        }
                    } else if (line.startsWith("HTTP/")) {
                        int first_space = line.indexOf(' ');
                        if (first_space > 0) {
                            mFirstChunk.httpVersion = line.substring(0, first_space);

                            try {
                                // NOTE: the response status may be missing when the response is reconstructed by the ushark HTTP2 reassembly
                                int second_space = line.indexOf(' ', first_space + 1);

                                mFirstChunk.httpResponseCode = Integer.parseInt(line.substring(first_space + 1,
                                        (second_space > 0) ? second_space : line.length()));

                                if (second_space > 0)
                                    mFirstChunk.httpResponseStatus = line.substring(second_space + 1);
                            } catch (NumberFormatException ignored) {}
                        }
                    }
                }

                while((line != null) && (!line.isEmpty())) {
                    line = line.toLowerCase();
                    //log_d("[HEADER] " + line);

                    if(line.startsWith("content-encoding: ")) {
                        String contentEncoding = line.substring(18);

                        log_d("Content-Encoding: " + contentEncoding);

                        switch (contentEncoding) {
                            case "gzip":
                                mContentEncoding = ContentEncoding.GZIP;
                                break;
                            case "deflate":
                                // test with http://carsten.codimi.de/gzip.yaws/daniels.html?deflate=on
                                mContentEncoding = ContentEncoding.DEFLATE;
                                break;
                            case "br":
                                // test with google.com
                                mContentEncoding = ContentEncoding.BROTLI;
                                break;
                            case "zstd":
                                mContentEncoding = ContentEncoding.ZSTD;
                                break;
                        }
                    } else if(line.startsWith("content-type: ")) {
                        int endIdx = line.indexOf(";");
                        mFirstChunk.httpContentType = line.substring(14, (endIdx > 0) ? endIdx : line.length());

                        log_d("Content-Type: " + mFirstChunk.httpContentType);
                    } else if(line.startsWith("content-length: ")) {
                        try {
                            mContentLength = Integer.parseInt(line.substring(16));
                            log_d("Content-Length: " + mContentLength);
                        } catch (NumberFormatException ignored) {}
                    } else if(line.startsWith("upgrade: ")) {
                        log_d("Upgrade found, stop parsing");
                        mSwitchingProtocols = true;
                        mReassembleChunks = false;

                        if (line.startsWith("upgrade: websocket")) {
                            log_d("websocket upgrade");
                            mWebsocketUpgrade = true;
                        }
                    } else if(line.equals("transfer-encoding: chunked")) {
                        log_d("Detected chunked encoding");
                        mChunkedEncoding = true;
                    } else if(line.startsWith("host: ")) {
                        log_d("Detected HTTP host");
                        mFirstChunk.httpHost = line.substring(6);
                    }

                    line = reader.readLine();
                }
            } catch (IOException ignored) {}

            if(headers_end > 0) {
                mReadingHeaders = false;
                body_start = headers_end;

                if (mDumpPayload)
                    mHeaders.add(chunk.subchunk(0, body_start));
            } else {
                if(mHeadersSize > MAX_HEADERS_SIZE) {
                    log_d("Assuming not HTTP");

                    // Assume this is not valid HTTP traffic
                    mReadingHeaders = false;
                    mReassembleChunks = false;
                    mInvalidHttp = true;
                }

                // Headers span all the packet
                if (mDumpPayload)
                    mHeaders.add(chunk);
                body_start = payload.length;
            }
        }

        // When mReassembleChunks is false, each chunk should be passed to the mListener
        if(!mReassembleChunks)
            mReadingHeaders = false;

        boolean httpRst = false;
        if (mReadingHeaders && chunk.isHttp2Rst()) {
            mReadingHeaders = false;
            httpRst = true;
        }

        if(!mReadingHeaders) {
            // Reading HTTP body
            int body_size = payload.length - body_start;
            int new_body_start = -1;

            if(mChunkedEncoding && (mContentLength < 0) && (body_size > 0)) {
                try(BufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(payload, body_start, body_size)))) {
                    String line = reader.readLine();
                    if(line != null) {
                        try {
                            // Each chunk starts with the chunk length
                            mContentLength = Integer.parseInt(line, 16);
                            body_start += line.length() + 2;
                            body_size -= line.length() + 2;

                            log_d("Chunk length: " + mContentLength);

                            if(mContentLength == 0)
                                chunked_complete = true;
                        } catch (NumberFormatException ignored) {}
                    }
                } catch (IOException ignored) {}
            }

            // NOTE: Content-Length is optional in HTTP/2.0, mitmproxy reconstructs the entire message
            if(body_size > 0) {
                if(mContentLength > 0) {
                    //log_d("body: " + body_size + " / " + mContentLength);
                    if(body_size < mContentLength)
                        mContentLength -= body_size;
                    else {
                        body_size = mContentLength;
                        new_body_start = body_start + mContentLength;
                        mContentLength = -1;

                        // With chunked encoding, skip the trailing \r\n
                        if(mChunkedEncoding)
                            new_body_start += 2;
                    }
                }

                if (mDumpPayload) {
                    if ((body_start == 0) && (body_size == chunk.payload.length))
                        mBody.add(chunk);
                    else
                        mBody.add(chunk.subchunk(body_start, body_size));
                }

                mBodySize += body_size;
            }

            if(chunked_complete || !mReassembleChunks)
                mChunkedEncoding = false;

            if(((mContentLength <= 0) || !mReassembleChunks)
                    && !mChunkedEncoding) {
                PayloadChunk to_add;

                if (mDumpPayload) {
                    // Reassemble the chunks (NOTE: gzip is applied only after all the chunks are collected)
                    PayloadChunk headers = reassembleChunks(mHeaders);
                    PayloadChunk body = !mBody.isEmpty() ? reassembleChunks(mBody) : null;

                    //log_d("mContentLength=" + mContentLength + ", mReassembleChunks=" + mReassembleChunks + ", mChunkedEncoding=" + mChunkedEncoding);

                    if ((body != null) && (mContentEncoding != ContentEncoding.UNKNOWN))
                        decodeBody(body);

                    if (body != null) {
                        // Reassemble headers and body into a single chunk
                        byte[] reassembly = new byte[headers.payload.length + body.payload.length];
                        System.arraycopy(headers.payload, 0, reassembly, 0, headers.payload.length);
                        System.arraycopy(body.payload, 0, reassembly, headers.payload.length, body.payload.length);

                        to_add = body.withPayload(reassembly);
                    } else
                        to_add = headers;
                } else
                    to_add = mFirstChunk;

                if (mInvalidHttp)
                    to_add.type = PayloadChunk.ChunkType.RAW;
                else {
                    to_add.httpContentType = mFirstChunk.httpContentType;
                    to_add.httpResponseCode = mFirstChunk.httpResponseCode;
                    to_add.httpResponseStatus = mFirstChunk.httpResponseStatus;
                    to_add.httpMethod = mFirstChunk.httpMethod;
                    to_add.httpHost = mFirstChunk.httpHost;
                    to_add.httpPath = mFirstChunk.httpPath;
                    to_add.httpQuery = mFirstChunk.httpQuery;
                    to_add.httpVersion = mFirstChunk.httpVersion;
                    to_add.httpBodyLength = mBodySize;

                    if (httpRst)
                        // this is necessary when mDumpPayload=false, to ensure that
                        // the chunk is marked as HTTP RST
                        to_add.setHttpRst();
                }

                mBodySize = 0;

                if ((to_add.type == PayloadChunk.ChunkType.HTTP)) {
                    Log.d(TAG, "Reassembled HTTP " +
                            (to_add.isHttp2Rst() ? "RST" : (to_add.is_sent ? "request" : "response")));
                }

                mListener.onChunkReassembled(to_add);
                reset(); // mReadingHeaders = true
            }

            if((new_body_start > 0) && (chunk.payload.length > new_body_start)) {
                // Part of this chunk should be processed as a new chunk
                handleChunk(chunk.subchunk(new_body_start, chunk.payload.length - new_body_start));
            }
        }
    }

    private void decodeBody(PayloadChunk body) {
        InputStream inputStream = null;

        //log_d("Decoding as " + mContentEncoding.name().toLowerCase());

        try(ByteArrayInputStream bis = new ByteArrayInputStream(body.payload)) {
            switch (mContentEncoding) {
                case GZIP:
                    inputStream = new GZIPInputStream(bis);
                    break;
                case DEFLATE:
                    inputStream = new InflaterInputStream(bis, new Inflater(true));
                    break;
                case BROTLI:
                    inputStream = new BrotliInputStream(bis);
                    break;
                case ZSTD:
                    body.payload = ZstdDecoder.decompress(body.payload);
                    break;
            }

            if(inputStream != null) {
                try(ByteArrayOutputStream bos = new ByteArrayOutputStream()) {
                    byte[] buf = new byte[1024];
                    int read;

                    while ((read = inputStream.read(buf)) != -1)
                        bos.write(buf, 0, read);

                    // success
                    body.payload = bos.toByteArray();
                }
            }
        } catch (IOException ignored) {
            log_d(mContentEncoding.name().toLowerCase() + " decoding failed");
            //ignored.printStackTrace();
        } finally {
            Utils.safeClose(inputStream);
        }
    }

    private PayloadChunk reassembleChunks(ArrayList<PayloadChunk> chunks) {
        if(chunks.size() == 1)
            return chunks.get(0);

        int size = 0;
        for(PayloadChunk chunk: chunks)
            size += chunk.payload.length;

        byte[] reassembly = new byte[size];
        int sofar = 0;

        for(PayloadChunk chunk: chunks) {
            System.arraycopy(chunk.payload, 0, reassembly, sofar, chunk.payload.length);
            sofar += chunk.payload.length;
        }

        return chunks.get(0).withPayload(reassembly);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/HarWriter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;
import android.util.Base64;

import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.PayloadChunk;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Writes HTTP log data to HAR 1.2 format using streaming output.
 * See: http://www.softwareishard.com/blog/har-12-spec/
 */
public class HarWriter {
    private static final String TAG = "HarWriter";
    private final Context mContext;
    private final List<HttpLog.HttpRequest> mRequests;

    public HarWriter(Context context, List<HttpLog.HttpRequest> requests) {
        mContext = context;
        mRequests = requests;
    }

    public HarWriter(Context context, HttpLog.HttpRequest request) {
        mContext = context;
        mRequests = Collections.singletonList(request);
    }

    public void write(OutputStream out) throws IOException {
        JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));
        writer.setIndent("  ");

        writer.beginObject();
        writer.name("log");
        writeLog(writer);
        writer.endObject();

        writer.flush();
    }

    private void writeLog(JsonWriter writer) throws IOException {
        writer.beginObject();

        writer.name("version").value("1.2");

        writer.name("creator");
        writeCreator(writer);

        writer.name("entries");
        writeEntries(writer);

        writer.endObject();
    }

    private void writeCreator(JsonWriter writer) throws IOException {
        writer.beginObject();
        writer.name("name").value("PCAPdroid");
        writer.name("version").value(Utils.getAppVersion(mContext));
        writer.endObject();
    }

    private void writeEntries(JsonWriter writer) throws IOException {
        writer.beginArray();

        for (int i = 0; i < mRequests.size(); i++) {
            if (Thread.interrupted())
                throw new InterruptedIOException("Export cancelled");

            HttpLog.HttpRequest req = mRequests.get(i);
            if (req == null)
                continue;

            try {
                writeEntry(writer, req);
            } catch (Exception e) {
                Log.w(TAG, "Failed to serialize entry " + i + ": " + e.getMessage());
                e.printStackTrace();
            }
        }

        writer.endArray();
    }

    private void writeEntry(JsonWriter writer, HttpLog.HttpRequest req) throws IOException {
        ConnectionDescriptor conn = req.conn;

        writer.beginObject();
        writer.name("startedDateTime").value(Utils.formatMillisIso8601(mContext, req.timestamp));

        // time (total elapsed time in ms)
        long time = -1;
        if (req.reply != null) {
            PayloadChunk replyChunk = conn.getHttpResponseChunk(req.reply.firstChunkPos);
            if (replyChunk != null)
                time = replyChunk.timestamp - req.timestamp;
        }
        writer.name("time").value(time);

        writer.name("serverIPAddress").value(conn.dst_ip);
        writer.name("connection").value(String.valueOf(conn.incr_id));

        writer.name("request");
        writeRequest(writer, req);

        writer.name("response");
        writeResponse(writer, req);

        // cache (required, but empty as we don't track caching)
        writer.name("cache");
        writer.beginObject();
        writer.endObject();

        writer.name("timings");
        writeTimings(writer);

        writeWebSocketMessages(writer, conn, req);

        writer.endObject();
    }

    private void writeRequest(JsonWriter writer, HttpLog.HttpRequest req) throws IOException {
        ConnectionDescriptor conn = req.conn;

        writer.beginObject();
        writer.name("method").value(req.method != null ? req.method : "");
        writer.name("url").value(req.getUrl());

        PayloadChunk reqChunk = conn.getHttpRequestChunk(req.firstChunkPos);
        String httpVersion = "HTTP/1.1";
        List<String[]> requestHeaders = new ArrayList<>();
        int headersSize = -1;

        if (reqChunk != null) {
            if (!reqChunk.httpVersion.isEmpty())
                httpVersion = reqChunk.httpVersion;

            if (reqChunk.payload != null) {
                String httpText = new String(reqChunk.payload, StandardCharsets.UTF_8);
                requestHeaders = parseHeaders(httpText);
                headersSize = getHeadersSize(reqChunk.payload);
            }
        }

        writer.name("httpVersion").value(httpVersion);

        writer.name("cookies");
        writeRequestCookies(writer, requestHeaders);

        writer.name("headers");
        writeHeaders(writer, requestHeaders);

        writer.name("queryString");
        writeQueryString(writer, req.query);

        if ((req.method != null) && (req.method.equals("POST") || req.method.equals("PUT") || req.method.equals("PATCH"))) {
            writer.name("postData");
            writePostData(writer, reqChunk, requestHeaders);
        }

        writer.name("headersSize").value(headersSize);
        writer.name("bodySize").value(req.bodyLength);
        writer.endObject();
    }

    private void writeResponse(JsonWriter writer, HttpLog.HttpRequest req) throws IOException {
        HttpLog.HttpReply reply = req.reply;
        ConnectionDescriptor conn = req.conn;

        writer.beginObject();

        if ((reply == null) || req.httpRst) {
            // No response available - return minimal response object
            writer.name("status").value(0);
            writer.name("statusText").value("");
            writer.name("httpVersion").value("");
            writer.name("cookies");
            writer.beginArray();
            writer.endArray();
            writer.name("headers");
            writer.beginArray();
            writer.endArray();
            writer.name("content");
            writer.beginObject();
            writer.endObject();
            writer.name("redirectURL").value("");
            writer.name("headersSize").value(-1);
            writer.name("bodySize").value(-1);
            writer.endObject();
            return;
        }

        writer.name("status").value(reply.responseCode);
        writer.name("statusText").value(reply.responseStatus != null ? reply.responseStatus : "");

        PayloadChunk respChunk = conn.getHttpResponseChunk(reply.firstChunkPos);
        String httpVersion = "HTTP/1.1";
        List<String[]> responseHeaders = new ArrayList<>();
        int headersSize = -1;

        if (respChunk != null) {
            if (!respChunk.httpVersion.isEmpty())
                httpVersion = respChunk.httpVersion;

            if (respChunk.payload != null) {
                String httpText = new String(respChunk.payload, StandardCharsets.UTF_8);
                responseHeaders = parseHeaders(httpText);
                headersSize = getHeadersSize(respChunk.payload);
            }
        }

        writer.name("httpVersion").value(httpVersion);

        writer.name("cookies");
        writeResponseCookies(writer, responseHeaders);

        writer.name("headers");
        writeHeaders(writer, responseHeaders);

        writer.name("content");
        writeContent(writer, reply, respChunk);

        String redirectURL = getHeaderValue(responseHeaders, "location");
        writer.name("redirectURL").value(redirectURL != null ? redirectURL : "");
        writer.name("headersSize").value(headersSize);
        writer.name("bodySize").value(reply.bodyLength);
        writer.endObject();
    }

    private void writeContent(JsonWriter writer, HttpLog.HttpReply reply, PayloadChunk respChunk) throws IOException {
        writer.beginObject();
        writer.name("size").value(reply.bodyLength);

        String mimeType = reply.contentType != null ? reply.contentType : "application/octet-stream";
        writer.name("mimeType").value(mimeType);

        if ((respChunk != null) && (respChunk.payload != null)) {
            byte[] body = extractBody(respChunk.payload);
            if ((body != null) && (body.length > 0)) {
                if (isTextContent(body, reply.contentType))
                    writer.name("text").value(new String(body, StandardCharsets.UTF_8));
                else {
                    writer.name("text").value(Base64.encodeToString(body, Base64.NO_WRAP));
                    writer.name("encoding").value("base64");
                }
            }
        }

        writer.endObject();
    }

    private void writePostData(JsonWriter writer, PayloadChunk reqChunk, List<String[]> requestHeaders) throws IOException {
        writer.beginObject();

        String contentType = getHeaderValue(requestHeaders, "content-type");
        writer.name("mimeType").value(contentType != null ? contentType : "");

        if ((reqChunk != null) && (reqChunk.payload != null)) {
            byte[] body = extractBody(reqChunk.payload);
            if ((body != null) && (body.length > 0))
                writer.name("text").value(new String(body, StandardCharsets.UTF_8));
        }

        // params empty - we don't parse form data
        writer.name("params");
        writer.beginArray();
        writer.endArray();

        writer.endObject();
    }

    private void writeTimings(JsonWriter writer) throws IOException {
        writer.beginObject();

        writer.name("send").value(-1);
        writer.name("wait").value(-1);
        writer.name("receive").value(-1);

        // Optional fields
        writer.name("blocked").value(-1);
        writer.name("dns").value(-1);
        writer.name("connect").value(-1);
        writer.name("ssl").value(-1);

        writer.endObject();
    }

    private void writeHeaders(JsonWriter writer, List<String[]> headers) throws IOException {
        writer.beginArray();
        for (String[] header : headers) {
            writer.beginObject();
            writer.name("name").value(header[0]);
            writer.name("value").value(header[1]);
            writer.endObject();
        }
        writer.endArray();
    }

    private void writeQueryString(JsonWriter writer, String query) throws IOException {
        writer.beginArray();

        if ((query != null) && !query.isEmpty()) {
            // Remove leading '?'
            if (query.startsWith("?"))
                query = query.substring(1);

            String[] pairs = query.split("&");
            for (String pair : pairs) {
                int eqPos = pair.indexOf('=');

                // Decode first, then write - to avoid leaving JSON in invalid state on exception
                String name, value;
                try {
                    if (eqPos > 0) {
                        name = URLDecoder.decode(pair.substring(0, eqPos), "UTF-8");
                        value = URLDecoder.decode(pair.substring(eqPos + 1), "UTF-8");
                    } else {
                        name = URLDecoder.decode(pair, "UTF-8");
                        value = "";
                    }
                } catch (Exception e) {
                    // Skip malformed parameter
                    continue;
                }

                writer.beginObject();
                writer.name("name").value(name);
                writer.name("value").value(value);
                writer.endObject();
            }
        }

        writer.endArray();
    }

    private void writeRequestCookies(JsonWriter writer, List<String[]> headers) throws IOException {
        writer.beginArray();

        for (String[] header : headers) {
            if (header[0].equalsIgnoreCase("Cookie")) {
                String value = header[1];

                // Parse: name1=value1; name2=value2
                String[] pairs = value.split(";");
                for (String pair : pairs) {
                    pair = pair.trim();

                    int eqPos = pair.indexOf('=');
                    if (eqPos > 0) {
                        writer.beginObject();
                        writer.name("name").value(pair.substring(0, eqPos));
                        writer.name("value").value(pair.substring(eqPos + 1));
                        writer.endObject();
                    }
                }
            }
        }

        writer.endArray();
    }

    private void writeResponseCookies(JsonWriter writer, List<String[]> headers) throws IOException {
        writer.beginArray();

        for (String[] header : headers) {
            if (header[0].equalsIgnoreCase("Set-Cookie")) {
                String value = header[1];

                // Parse: name=value; Path=/; Domain=.example.com; HttpOnly; Secure; SameSite=Lax
                String[] parts = value.split(";");

                // First part is name=value
                if (parts.length > 0) {
                    int eqPos = parts[0].indexOf('=');
                    if (eqPos > 0) {
                        writer.beginObject();
                        writer.name("name").value(parts[0].substring(0, eqPos).trim());
                        writer.name("value").value(parts[0].substring(eqPos + 1).trim());

                        // Parse attributes with defaults
                        String path = "/";
                        String domain = "";
                        boolean httpOnly = false;
                        boolean secure = false;
                        String sameSite = null;
                        String expires = null;

                        for (int i = 1; i < parts.length; i++) {
                            String attr = parts[i].trim();
                            String attrLower = attr.toLowerCase();

                            if (attrLower.startsWith("path="))
                                path = attr.substring(5);
                            else if (attrLower.startsWith("domain="))
                                domain = attr.substring(7);
                            else if (attrLower.equals("httponly"))
                                httpOnly = true;
                            else if (attrLower.equals("secure"))
                                secure = true;
                            else if (attrLower.startsWith("samesite="))
                                sameSite = attr.substring(9);
                            else if (attrLower.startsWith("expires="))
                                expires = attr.substring(8);
                        }

                        writer.name("path").value(path);
                        writer.name("domain").value(domain);
                        writer.name("httpOnly").value(httpOnly);
                        writer.name("secure").value(secure);
                        if (sameSite != null)
                            writer.name("sameSite").value(sameSite);
                        if (expires != null) {
                            String isoExpires = Utils.httpDateToIso8601(expires);
                            if (isoExpires != null)
                                writer.name("expires").value(isoExpires);
                        }

                        writer.endObject();
                    }
                }
            }
        }

        writer.endArray();
    }

    private List<String[]> parseHeaders(String httpText) {
        List<String[]> headers = new ArrayList<>();
        int headerEnd = Utils.getEndOfHTTPHeaders(httpText.getBytes(StandardCharsets.UTF_8));
        if (headerEnd == 0) headerEnd = httpText.length();

        String headerSection = httpText.substring(0, Math.min(headerEnd, httpText.length()));
        String[] lines = headerSection.split("\r\n");

        // Skip first line (request line or status line)
        for (int i = 1; i < lines.length; i++) {
            int colonPos = lines[i].indexOf(':');
            if (colonPos > 0) {
                headers.add(new String[]{
                        lines[i].substring(0, colonPos),
                        lines[i].substring(colonPos + 1).trim()
                });
            }
        }

        return headers;
    }

    private byte[] extractBody(byte[] payload) {
        int headerEnd = Utils.getEndOfHTTPHeaders(payload);
        if ((headerEnd <= 0) || (headerEnd >= payload.length))
            return null;

        byte[] body = new byte[payload.length - headerEnd];
        System.arraycopy(payload, headerEnd, body, 0, body.length);
        return body;
    }

    private int getHeadersSize(byte[] payload) {
        int headerEnd = Utils.getEndOfHTTPHeaders(payload);
        return headerEnd > 0 ? headerEnd : -1;
    }

    private boolean isTextContent(byte[] body, String contentType) {
        if (contentType != null) {
            String ct = contentType.toLowerCase();
            if (ct.startsWith("text/") || ct.contains("json") ||
                ct.contains("xml") || ct.contains("javascript") || ct.contains("html"))
                return true;
            if (ct.startsWith("image/") || ct.startsWith("audio/") ||
                ct.startsWith("video/") || ct.equals("application/octet-stream"))
                return false;
        }

        // Check first bytes using Utils.isPrintable()
        int checkLen = Math.min(body.length, 16);
        for (int i = 0; i < checkLen; i++) {
            if (!Utils.isPrintable(body[i]))
                return false;
        }
        return true;
    }

    private String getHeaderValue(List<String[]> headers, String name) {
        for (String[] header : headers) {
            if (header[0].equalsIgnoreCase(name))
                return header[1];
        }
        return null;
    }

    /**
     * Add WebSocket messages to entry if this is a WebSocket connection.
     * Uses Chrome DevTools extension format.
     */
    private void writeWebSocketMessages(JsonWriter writer, ConnectionDescriptor conn, HttpLog.HttpRequest req) throws IOException {
        if ((req.reply == null) || !req.hasWebsocketData())
            return;

        ArrayList<PayloadChunk> wsChunks;

        if (CaptureService.isReadingFromPcapFile()) {
            // When reading from PCAP, chunks contain raw data that must be processed
            // through HTTPReassembly to decode WebSocket frames
            wsChunks = new ArrayList<>();
            HTTPReassembly.ReassemblyListener listener = chunk -> {
                if ((chunk.type == PayloadChunk.ChunkType.WEBSOCKET) &&
                        !WebSocketDecoder.isControlOpcode(chunk.wsOpcode))
                    wsChunks.add(chunk);
            };
            HTTPReassembly httpReq = new HTTPReassembly(true, listener);
            HTTPReassembly httpRes = new HTTPReassembly(true, listener);

            int startPos = req.firstChunkPos;
            synchronized (conn) {
                for (int i = startPos; i < conn.getNumPayloadChunks(); i++) {
                    PayloadChunk chunk = conn.getPayloadChunk(i);
                    if ((chunk == null) || (chunk.type == PayloadChunk.ChunkType.RAW))
                        continue;

                    if (chunk.is_sent)
                        httpReq.handleChunk(chunk);
                    else
                        httpRes.handleChunk(chunk);
                }
            }
        } else {
            // Live capture: chunks are already decoded by mitmproxy
            wsChunks = new ArrayList<>();
            int startPos = req.reply.firstChunkPos + 1;

            synchronized (conn) {
                for (int i = startPos; i < conn.getNumPayloadChunks(); i++) {
                    PayloadChunk chunk = conn.getPayloadChunk(i);
                    if ((chunk != null) && (chunk.type == PayloadChunk.ChunkType.WEBSOCKET))
                        wsChunks.add(chunk);
                }
            }
        }

        if (wsChunks.isEmpty())
            return;

        // Chrome DevTools extension
        writer.name("_resourceType").value("websocket");
        writer.name("_webSocketMessages");
        writer.beginArray();

        for (PayloadChunk chunk : wsChunks) {
            writer.beginObject();
            writer.name("type").value(chunk.is_sent ? "send" : "receive");
            writer.name("time").value(chunk.timestamp / 1000.0);

            // Use wsOpcode if available, otherwise guess from content
            int opcode;
            if (chunk.wsOpcode > 0)
                opcode = chunk.wsOpcode;
            else {
                boolean isText = (chunk.payload == null) || (chunk.payload.length == 0) ||
                        isTextContent(chunk.payload, null);
                opcode = isText ? WebSocketDecoder.OPCODE_TEXT : WebSocketDecoder.OPCODE_BINARY;
            }
            writer.name("opcode").value(opcode);

            if ((chunk.payload != null) && (chunk.payload.length > 0)) {
                if (opcode == WebSocketDecoder.OPCODE_TEXT)
                    writer.name("data").value(new String(chunk.payload, StandardCharsets.UTF_8));
                else
                    writer.name("data").value(Base64.encodeToString(chunk.payload, Base64.NO_WRAP));
            } else
                writer.name("data").value("");

            writer.endObject();
        }

        writer.endArray();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/HttpLog.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.model.ConnectionDescriptor;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Objects;

public class HttpLog {
    private static final String TAG = "HttpLog";
    private final ArrayList<HttpRequest> mHttpRequests = new ArrayList<>();
    private final ArrayList<HttpRequest> mPendingHttpRequests = new ArrayList<>();
    private final ArrayList<HttpReply> mPendingHttpReplies = new ArrayList<>();
    private Listener mListener;
    private boolean mConnUpdateInProgress = false;

    public static class HttpRequest implements Comparable<HttpRequest> {
        public final ConnectionDescriptor conn;
        public final int firstChunkPos;
        public String method = "";
        public String host = "";
        public String path = "";
        public String query = "";
        public String decryptionError = "";
        public HttpReply reply;
        public int bodyLength = 0;
        public int streamId = 0;
        public long timestamp = 0;
        public boolean httpRst = false;
        private int idx = -1;

        public HttpRequest(ConnectionDescriptor conn, int firstChunkPos) {
            this.conn = conn;
            this.firstChunkPos = firstChunkPos;
        }

        public int getPosition() {
            return idx;
        }

        public String getProtoAndHost() {
            // host is empty for addDecryptionError() requests
            String hostOrDomain = !host.isEmpty() ? host :
                    Objects.requireNonNullElse(conn.info, "");;
            String l7proto = conn.l7proto.toLowerCase();
            String proto = "";

            if (l7proto.startsWith("http"))
                proto = conn.isCleartext() ? "http://" : "https://";

            return proto + hostOrDomain;
        }

        public boolean matches(String filter) {
            filter = filter.toLowerCase();

            return getUrl().toLowerCase().contains(filter) ||
                    ((reply != null) && reply.contentType.toLowerCase().contains(filter));
        }

        public String getUrl() {
            return String.format("%s%s%s", getProtoAndHost(), path, query);
        }

        @Override
        @NonNull
        public String toString() {
            return "HTTP request: " + method + " " + getUrl();
        }

        @Override
        public int compareTo(HttpRequest o) {
            return Long.compare(timestamp, o.timestamp);
        }

        public boolean hasWebsocketData() {
            return conn.hasWebsocketData();
        }
    }

    public static class HttpReply {
        public final HttpRequest request;
        public final int firstChunkPos;
        public String contentType;
        public String responseStatus;
        public int responseCode = 0;
        public int bodyLength = 0;

        public HttpReply(@NonNull HttpRequest in_reply_to, int firstChunkPos) {
            request = in_reply_to;
            this.firstChunkPos = firstChunkPos;
        }

        @Override
        @NonNull
        public String toString() {
            return "HTTP reply: " + responseCode + " " +
                    responseStatus + " - " + contentType + " - " +
                    bodyLength + " B";
        }
    }

    public interface Listener {
        void onHttpRequestAdded(int pos);
        void onHttpRequestUpdated(int pos);
        void onHttpRequestsClear();
    }

    public synchronized void setListener(Listener listener) {
        mListener = listener;
    }

    public synchronized void startConnectionsUpdates() {
        Log.d(TAG, "startConnectionsUpdates");
        mConnUpdateInProgress = true;
    }

    public synchronized void stopConnectionsUpdates() {
        Log.d(TAG, "stopConnectionsUpdates");
        mConnUpdateInProgress = false;

        // sort requests by ascending timestamp, as the order may be wrong due to the connections update batching
        Collections.sort(mPendingHttpRequests);

        for (HttpRequest req: mPendingHttpRequests)
            addHttpRequest(req);
        mPendingHttpRequests.clear();

        for (HttpReply reply: mPendingHttpReplies)
            addHttpReply(reply);
        mPendingHttpReplies.clear();
    }

    public synchronized void addHttpRequest(HttpRequest req) {
        if (mConnUpdateInProgress) {
            // during the connections update, the sort order may be wrong due to batching
            // so enqueue until the update is finished
            mPendingHttpRequests.add(req);
            return;
        }

        req.idx = mHttpRequests.size();
        mHttpRequests.add(req);

        if (mListener != null)
            mListener.onHttpRequestAdded(req.idx);
    }

    public synchronized void addHttpReply(HttpReply reply) {
        assert (reply.request.reply == reply);

        if (mConnUpdateInProgress) {
            mPendingHttpReplies.add(reply);
            return;
        }

        if (mListener != null)
            // info from the HTTP reply is now available
            mListener.onHttpRequestUpdated(reply.request.idx);
    }

    public synchronized void addDecryptionError(ConnectionDescriptor conn, long tstamp, String error) {
        HttpRequest req = new HttpRequest(conn, 0);
        req.timestamp = tstamp;
        req.decryptionError = error;
        addHttpRequest(req);
    }

    public synchronized void clear() {
        mHttpRequests.clear();

        if (mListener != null)
            mListener.onHttpRequestsClear();
    }

    public synchronized @Nullable HttpRequest getRequest(int pos) {
        if ((pos < 0) || (pos >= mHttpRequests.size()))
            return null;
        return mHttpRequests.get(pos);
    }

    public synchronized int getSize() {
        return mHttpRequests.size();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/Log.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

public class Log {
    public static final int LOG_LEVEL_INFO = 4;
    public static final String DEFAULT_LOGGER_PATH = "pcapdroid.log";
    public static final String ROOT_LOGGER_PATH = "pcapd.log";
    public static final String MITM_LOGGER_PATH = "mitmaddon.log";
    public static int DEFAULT_LOGGER;
    public static int MITMADDON_LOGGER;

    public static void init(String cachedir) {
        DEFAULT_LOGGER = CaptureService.initLogger(cachedir + "/" + DEFAULT_LOGGER_PATH, LOG_LEVEL_INFO);
        MITMADDON_LOGGER = CaptureService.initLogger(cachedir + "/" + MITM_LOGGER_PATH, LOG_LEVEL_INFO);
    }

    public static void writeLog(int logger, int level, @Nullable String tag, @NonNull String message) {
        if(!PCAPdroid.isUnderTest())
            CaptureService.writeLog(logger, level, ((tag != null) ? ("[" + tag + "] ") : "") + message);
    }

    public static void d(@Nullable String tag, @NonNull String message) {
        android.util.Log.d(tag, message);
    }

    public static void i(@Nullable String tag, @NonNull String message) {
        android.util.Log.i(tag, message);
        writeLog(DEFAULT_LOGGER, android.util.Log.INFO, tag, message);
    }

    public static void i(int logger, @NonNull String message) {
        writeLog(logger, android.util.Log.INFO, null, message);
    }

    public static void w(@Nullable String tag, @NonNull String message) {
        android.util.Log.w(tag, message);
        writeLog(DEFAULT_LOGGER, android.util.Log.WARN, tag, message);
    }

    public static void w(int logger, @NonNull String message) {
        writeLog(logger, android.util.Log.WARN, null, message);
    }

    public static void e(@Nullable String tag, @NonNull String message) {
        android.util.Log.e(tag, message);
        writeLog(DEFAULT_LOGGER, android.util.Log.ERROR, tag, message);
    }

    public static void e(int logger, @NonNull String message) {
        writeLog(logger, android.util.Log.ERROR, null, message);
    }

    public static void wtf(@Nullable String tag, @NonNull String message) {
        android.util.Log.wtf(tag, message);
        writeLog(DEFAULT_LOGGER, android.util.Log.ASSERT, tag, message); // ANDROID_LOG_FATAL
    }

    public static void level(int logger, int level, @NonNull String message) {
        switch (level) {
            case android.util.Log.INFO:
                Log.i(logger, message);
                break;
            case android.util.Log.WARN:
                Log.w(logger, message);
                break;
            case android.util.Log.ERROR:
                Log.e(logger, message);
                break;
        }
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/MitmAddon.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022-24 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.Messenger;
import android.os.ParcelFileDescriptor;
import android.os.PowerManager;
import android.os.RemoteException;

import androidx.annotation.NonNull;
import androidx.core.content.pm.PackageInfoCompat;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.interfaces.MitmListener;
import com.emanuelef.remote_capture.model.Prefs;
import com.pcapdroid.mitm.MitmAPI;

import java.io.IOException;
import java.lang.ref.WeakReference;

public class MitmAddon {
    public static final long PACKAGE_VERSION_CODE = 21;
    public static final String PACKAGE_VERSION_NAME = "1.4";
    public static final String REPOSITORY = "https://github.com/emanuele-f/PCAPdroid-mitm";
    private static final String TAG = "MitmAddon";
    private final Context mContext;
    private final MitmListener mReceiver;
    private final Messenger mMessenger;
    private Messenger mService;
    private boolean mStopRequested;

    public MitmAddon(Context ctx, MitmListener receiver) {
        // Important: the application context is required here, otherwise bind/unbind will not work properly
        mContext = ctx.getApplicationContext();
        mReceiver = receiver;
        mMessenger = new Messenger(new ReplyHandler(ctx.getMainLooper(), receiver));
    }

    private final ServiceConnection mConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName className, IBinder service) {
            Log.i(TAG, "Service connected");
            mService = new Messenger(service);

            if(mStopRequested)
                stopProxy();
            else
                mReceiver.onMitmServiceConnect();
        }

        @Override
        public void onServiceDisconnected(ComponentName className) {
            Log.i(TAG, "Service disconnected");
            disconnect(); // call unbind to prevent new connections
            mReceiver.onMitmServiceDisconnect();
        }

        @Override
        public void onBindingDied(ComponentName name) {
            Log.w(TAG, "onBindingDied");
            disconnect();
            mReceiver.onMitmServiceDisconnect();
        }

        @Override
        public void onNullBinding(ComponentName name) {
            Log.w(TAG, "onNullBinding");
            disconnect();
            mReceiver.onMitmServiceDisconnect();
        }
    };

    public static long getInstalledVersion(Context ctx) {
        try {
            PackageInfo pInfo = Utils.getPackageInfo(ctx.getPackageManager(), MitmAPI.PACKAGE_NAME, 0);
            return PackageInfoCompat.getLongVersionCode(pInfo);
        } catch (PackageManager.NameNotFoundException e) {
            return -1;
        }
    }

    public static @NonNull String getInstalledVersionName(Context ctx) {
        try {
            PackageInfo pInfo = Utils.getPackageInfo(ctx.getPackageManager(), MitmAPI.PACKAGE_NAME, 0);
            return pInfo.versionName;
        } catch (PackageManager.NameNotFoundException e) {
            return "";
        }
    }

    public static int getUid(Context ctx) {
        try {
            return Utils.getPackageUid(ctx.getPackageManager(), MitmAPI.PACKAGE_NAME, 0);
        } catch (PackageManager.NameNotFoundException e) {
            return -1;
        }
    }

    // Returns a non-empty string if a newer, compatible addon version is available
    // Use ignoreNewVersion to silence this
    public static @NonNull String getNewVersionAvailable(Context ctx) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);

        if (Prefs.isIgnoredMitmVersion(prefs, PACKAGE_VERSION_NAME))
            // update was ignored by the user
            return "";

        // NOTE: currently for the update check we only rely on the addon version hard-coded
        // in the source
        try {
            PackageInfo pInfo = Utils.getPackageInfo(ctx.getPackageManager(), MitmAPI.PACKAGE_NAME, 0);

            if (PackageInfoCompat.getLongVersionCode(pInfo) >= PACKAGE_VERSION_CODE)
                // same version or better installed
                return "";

            if (Utils.isSemanticVersionCompatible(PACKAGE_VERSION_NAME, pInfo.versionName))
                return PACKAGE_VERSION_NAME;
        } catch (PackageManager.NameNotFoundException ignored) {}

        return "";
    }

    public static void ignoreNewVersion(Context ctx) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        prefs.edit()
                .putString(Prefs.PREF_IGNORED_MITM_VERSION, PACKAGE_VERSION_NAME)
                .apply();
    }

    // returns true only if a compatible addon version is installed
    public static boolean isInstalled(Context ctx) {
        try {
            PackageInfo pInfo = Utils.getPackageInfo(ctx.getPackageManager(), MitmAPI.PACKAGE_NAME, 0);
            return Utils.isSemanticVersionCompatible(PACKAGE_VERSION_NAME, pInfo.versionName);
        } catch (PackageManager.NameNotFoundException ignored) {
            return false;
        }
    }

    public static String getGithubReleaseUrl(String version) {
        return REPOSITORY + "/releases/download/v" +
                version + "/PCAPdroid-mitm_v" + version + "_" + Build.SUPPORTED_ABIS[0] + ".apk";
    }

    public static void setCAInstallationSkipped(Context ctx, boolean skipped) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        prefs.edit()
                .putBoolean(Prefs.PREF_CA_INSTALLATION_SKIPPED, skipped)
                .apply();
    }

    public static boolean isCAInstallationSkipped(Context ctx) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        return prefs.getBoolean(Prefs.PREF_CA_INSTALLATION_SKIPPED, false);
    }

    public static void setDecryptionSetupDone(Context ctx, boolean done) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        prefs.edit()
                .putBoolean(Prefs.PREF_TLS_DECRYPTION_SETUP_DONE, done)
                .apply();
    }

    public static boolean needsSetup(Context ctx) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);

        if(!Prefs.isTLSDecryptionSetupDone(prefs))
            return true;

        // Perform some other quick checks just in case the env has changed
        if(!isInstalled(ctx)) {
            setDecryptionSetupDone(ctx, false);
            return true;
        }

        return false;
    }

    private static class ReplyHandler extends Handler {
        private final WeakReference<MitmListener> mReceiver;

        ReplyHandler(Looper looper, MitmListener receiver) {
            super(looper);
            mReceiver = new WeakReference<>(receiver);
        }

        @Override
        public void handleMessage(@NonNull Message msg) {
            Log.d(TAG, "Message: " + msg.what);

            MitmListener receiver = mReceiver.get();
            if(receiver == null)
                return;

            if(msg.what == MitmAPI.MSG_GET_CA_CERTIFICATE) {
                String ca_pem = null;

                if(msg.getData() != null) {
                    Bundle res = msg.getData();
                    ca_pem = res.getString(MitmAPI.CERTIFICATE_RESULT);
                }

                receiver.onMitmGetCaCertificateResult(ca_pem);
            }
        }
    }

    // Asynchronously connect to the service. The onConnect callback will be called.
    public boolean connect(int extra_flags) {
        Intent intent = new Intent();
        intent.setComponent(new ComponentName(MitmAPI.PACKAGE_NAME, MitmAPI.MITM_SERVICE));

        if(!mContext.bindService(intent, mConnection, Context.BIND_AUTO_CREATE |
                Context.BIND_ALLOW_ACTIVITY_STARTS | extra_flags)) {
            try {
                mContext.unbindService(mConnection);
            } catch (IllegalArgumentException ignored) {
                Log.w(TAG, "unbindService failed");
            }
            mService = null;
            return false;
        }
        return true;
    }

    // This must be always called after connect, e.g. in the OnDestroy
    public void disconnect() {
        if(mService != null) {
            Log.i(TAG, "Unbinding service...");
            try {
                mContext.unbindService(mConnection);
            } catch (IllegalArgumentException ignored) {
                Log.w(TAG, "unbindService failed");
            }
            mService = null;
        }
    }

    public boolean isConnected() {
        return (mService != null);
    }

    public boolean requestCaCertificate() {
        if(mService == null) {
            Log.e(TAG, "Not connected");
            return false;
        }

        Message msg = Message.obtain(null, MitmAPI.MSG_GET_CA_CERTIFICATE);
        msg.replyTo = mMessenger;
        try {
            mService.send(msg);
            return true;
        } catch (RemoteException e) {
            e.printStackTrace();
            return false;
        }
    }

    // Start the mitm proxy and returns a ParcelFileDescriptor for the data communication.
    // The proxy can be stopped by closing the descriptor and then calling disconnect().
    public ParcelFileDescriptor startProxy(MitmAPI.MitmConfig conf) {
        if(mService == null) {
            Log.e(TAG, "Not connected");
            return null;
        }

        ParcelFileDescriptor[] pair;
        try {
            pair = ParcelFileDescriptor.createReliableSocketPair();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }

        // Note: ParcelFileDescriptor must be passed as parcelable
        Message msg = Message.obtain(null, MitmAPI.MSG_START_MITM, 0, 0, pair[0]);

        Bundle bundle = new Bundle();
        bundle.putSerializable(MitmAPI.MITM_CONFIG, conf);
        msg.setData(bundle);

        try {
            mService.send(msg);
        } catch (RemoteException | NullPointerException e) {
            e.printStackTrace();
            Utils.safeClose(pair[0]);
            Utils.safeClose(pair[1]);
            return null;
        }

        // The other end of the pipe is sent, close it locally
        Utils.safeClose(pair[0]);

        return pair[1];
    }

    public boolean stopProxy() {
        if(mService == null) {
            Log.i(TAG, "Not connected, postponing stop message");
            mStopRequested = true;
            return true;
        }

        Log.i(TAG, "Send stop message");
        Message msg = Message.obtain(null, MitmAPI.MSG_STOP_MITM);
        try {
            mService.send(msg);
            mStopRequested = false;
            return true;
        } catch (RemoteException e) {
            e.printStackTrace();
            return false;
        }
    }

    // NOTE: doze could be disabled by PCAPdroid itself, however this is moved to the addon to avoid
    // any issues with the REQUEST_IGNORE_BATTERY_OPTIMIZATIONS Google Play policies
    public boolean disableDoze() {
        if(mService == null)
            return false;

        Log.i(TAG, "Send disable doze");
        Message msg = Message.obtain(null, MitmAPI.MSG_DISABLE_DOZE);
        try {
            mService.send(msg);
            return true;
        } catch (RemoteException e) {
            e.printStackTrace();
            return false;
        }
    }

    public static boolean isDozeEnabled(Context context) {
        final PowerManager manager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);

        return (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) && (manager != null)
                && !manager.isIgnoringBatteryOptimizations(MitmAPI.PACKAGE_NAME);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/MitmReceiver.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022-24 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;
import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.os.SystemClock;
import android.util.LruCache;
import android.util.SparseArray;

import androidx.lifecycle.LifecycleOwner;
import androidx.lifecycle.MutableLiveData;
import androidx.lifecycle.Observer;

import com.emanuelef.remote_capture.interfaces.ConnectionsListener;
import com.emanuelef.remote_capture.interfaces.MitmListener;
import com.emanuelef.remote_capture.model.CaptureSettings;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.PayloadChunk;
import com.emanuelef.remote_capture.model.PayloadChunk.ChunkType;
import com.emanuelef.remote_capture.model.Prefs;
import com.pcapdroid.mitm.MitmAPI;

import org.jetbrains.annotations.Nullable;

import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;

/* A receiver for the mitm addon messages.
 *
 * The mitm addon sends TCP messages via a socket, containing an header and the plaintext.
 *
 * The header is an ASCII string in the following format:
 *   "timestamp:port:msg_type:msg_length\n"
 * - timestamp: milliseconds timestamp for the message
 * - port: the TCP local port used by the SOCKS5 client
 * - msg_type: type of message, see parseMsgType for possible values
 * - msg_length: the message length in bytes
 *
 * The raw message data follows the header.
 */
public class MitmReceiver implements Runnable, ConnectionsListener, MitmListener {
    private static final String TAG = "MitmReceiver";
    public static final int TLS_DECRYPTION_PROXY_PORT = 7780;
    private Thread mThread;
    private final ConnectionsRegister mReg;
    private final Context mContext;
    private final MitmAddon mAddon;
    private final MitmAPI.MitmConfig mConfig;
    private final boolean mPcapngFormat;
    private final boolean mRootCapture;
    private static final MutableLiveData<Status> proxyStatus = new MutableLiveData<>(Status.NOT_STARTED);
    private ParcelFileDescriptor mSocketFd;
    private BufferedOutputStream mKeylog;

    // Shared state
    private final LruCache<Integer, Integer> mPortToConnId = new LruCache<>(64);
    private final SparseArray<ArrayList<PendingMessage>> mPendingMessages = new SparseArray<>();

    private enum MsgType {
        UNKNOWN,
        RUNNING,
        TLS_ERROR,
        HTTP_ERROR,
        HTTP_REQUEST,
        HTTP_REPLY,
        TCP_CLIENT_MSG,
        TCP_SERVER_MSG,
        TCP_ERROR,
        WEBSOCKET_CLIENT_MSG,
        WEBSOCKET_SERVER_MSG,
        DATA_TRUNCATED,
        MASTER_SECRET,
        LOG,
        JS_INJECTED
    }

    private static class PendingMessage {
        MsgType type;
        byte[] msg;
        int port;
        long pendingSince;
        long when;

        PendingMessage(MsgType _type, byte[] _msg, int _port, long _now) {
            type = _type;
            msg = _msg;
            port = _port;
            pendingSince = SystemClock.elapsedRealtime();
            when = _now;
        }
    }

    public enum Status {
        NOT_STARTED,
        STARTING,
        START_ERROR,
        RUNNING
    }

    public MitmReceiver(Context ctx, CaptureSettings settings, String proxyAuth) {
        mContext = ctx;
        mReg = CaptureService.requireConnsRegister();
        mAddon = new MitmAddon(mContext, this);
        mPcapngFormat = settings.pcapng_format;
        mRootCapture = settings.root_capture;

        mConfig = new MitmAPI.MitmConfig();
        mConfig.proxyPort = TLS_DECRYPTION_PROXY_PORT;
        mConfig.proxyAuth = proxyAuth;
        mConfig.dumpMasterSecrets = (CaptureService.getDumpMode() != Prefs.DumpMode.NONE);
        mConfig.additionalOptions = settings.mitmproxy_opts;
        mConfig.shortPayload = !settings.full_payload;

        /* upstream certificate verification is disabled because the app does not provide a way to let the user
           accept a given cert. Moreover, it provides a workaround for a bug with HTTPS proxies described in
           https://github.com/mitmproxy/mitmproxy/issues/5109 */
        mConfig.sslInsecure = true;

        // root capture uses transparent mode (redirection via iptables)
        mConfig.transparentMode = settings.root_capture;

        //noinspection ResultOfMethodCallIgnored
        getKeylogFilePath(mContext).delete();
    }

    public static File getKeylogFilePath(Context ctx) {
        return new File(ctx.getCacheDir(), "SSLKEYLOG.txt");
    }

    public boolean start() throws IOException {
        Log.d(TAG, "starting");
        proxyStatus.postValue(Status.STARTING);

        if(!mAddon.connect(Context.BIND_IMPORTANT)) {
            Utils.showToastLong(mContext, R.string.mitm_start_failed);
            return false;
        }

        mReg.addListener(this);
        return true;
    }

    public void stop() throws IOException {
        Log.d(TAG, "stopping");

        mReg.removeListener(this);

        ParcelFileDescriptor fd = mSocketFd;
        mSocketFd = null;
        Utils.safeClose(fd); // possibly wake mThread

        // send explicit stop message, as the addon may not be waked when the fd is closed
        mAddon.stopProxy();

        // on some devices, calling close on the socket is not enough to stop the thread,
        // the service must be unbound
        mAddon.disconnect();

        while((mThread != null) && (mThread.isAlive())) {
            try {
                Log.d(TAG, "Joining receiver thread...");
                mThread.join();
            } catch (InterruptedException ignored) {}
        }
        mThread = null;

        Log.d(TAG, "stop done");
    }

    @Override
    public void run() {
        if(mSocketFd == null) {
            Log.e(TAG, "Null socket, abort");
            proxyStatus.postValue(Status.NOT_STARTED);
            return;
        }

        Log.i(TAG, "Receiving data...");
        try(DataInputStream istream = new DataInputStream(new ParcelFileDescriptor.AutoCloseInputStream(mSocketFd))) {
            while(mAddon.isConnected()) {
                String msg_type;
                int port;
                int msg_len;
                long tstamp;

                // Read the header
                @SuppressWarnings("deprecation")
                String header = istream.readLine();

                if(header == null) {
                    // received when the addon is stopped
                    CaptureService.stopService();
                    break;
                }

                StringTokenizer tk = new StringTokenizer(header);
                //Log.d(TAG, "[HEADER] " + header);

                try {
                    // timestamp:port:msg_type:msg_length\n
                    String tk_tstamp = tk.nextToken(":");
                    String tk_port = tk.nextToken();
                    msg_type = tk.nextToken();
                    String tk_len = tk.nextToken();

                    tstamp = Long.parseLong(tk_tstamp);
                    port = Integer.parseInt(tk_port);
                    msg_len = Integer.parseInt(tk_len);
                } catch (NoSuchElementException | NumberFormatException e) {
                    CaptureService.requireInstance().reportError("[BUG] Invalid header received from the mitm plugin");
                    CaptureService.stopService();
                    break;
                }

                if((msg_len < 0) || (msg_len > 67108864)) { /* max 64 MB */
                    Log.w(TAG, "Ignoring bad message length: " + msg_len);
                    istream.skipBytes(msg_len);
                    continue;
                }

                MsgType type = parseMsgType(msg_type);
                //Log.d(TAG, "MSG." + type.name() + "[" + msg_len + " B]: port=" + port);

                byte[] msg;
                try {
                    msg = new byte[msg_len];
                } catch (OutOfMemoryError ignored) {
                    Log.w(TAG, "Ignoring message causing OOM (length: " + msg_len + ")");
                    istream.skipBytes(msg_len);
                    continue;
                }
                istream.readFully(msg);

                if(type == MsgType.MASTER_SECRET)
                    logMasterSecret(msg);
                else if(type == MsgType.LOG) {
                    handleLog(msg);
                } else if(type == MsgType.RUNNING) {
                    Log.i(TAG, "MITM proxy is running");
                    proxyStatus.postValue(Status.RUNNING);
                } else {
                    ConnectionDescriptor conn = getConnByLocalPort(port);
                    //Log.d(TAG, "MSG." + type.name() + "[" + msg_len + " B]: port=" + port + ", match=" + (conn != null));

                    if(conn != null)
                        handleMessage(conn, type, msg, tstamp);
                    else
                        // We may receive a message before seeing the connection in connectionsAdded
                        addPendingMessage(new PendingMessage(type, msg, port, tstamp));
                }
            }
        } catch (IOException e) {
            if(mSocketFd != null) // ignore termination
                e.printStackTrace();
        } finally {
            Utils.safeClose(mKeylog);
            mKeylog = null;
        }

        if(proxyStatus.getValue() == Status.STARTING)
            proxyStatus.postValue(Status.START_ERROR);
        else
            proxyStatus.postValue(Status.NOT_STARTED);

        Log.i(TAG, "End receiving data");
    }

    private boolean isSent(MsgType type) {
        switch (type) {
            case HTTP_REQUEST:
            case TCP_CLIENT_MSG:
            case WEBSOCKET_CLIENT_MSG:
                return true;
            default:
                return false;
        }
    }

    private ChunkType getChunkType(MsgType type) {
        switch (type) {
            case HTTP_REQUEST:
            case HTTP_REPLY:
                return ChunkType.HTTP;
            case WEBSOCKET_CLIENT_MSG:
            case WEBSOCKET_SERVER_MSG:
                return ChunkType.WEBSOCKET;
            default:
                return ChunkType.RAW;
        }
    }

    private void handleMessage(ConnectionDescriptor conn, MsgType type, byte[] message, long tstamp) {
        // NOTE: we are possibly accessing the conn concurrently
        if((type == MsgType.TLS_ERROR) || (type == MsgType.HTTP_ERROR) || (type == MsgType.TCP_ERROR)) {
            conn.decryption_error = new String(message, StandardCharsets.US_ASCII);

            // see ConnectionDescriptor.processUpdate
            if(conn.status == ConnectionDescriptor.CONN_STATUS_CLOSED)
                conn.status = ConnectionDescriptor.CONN_STATUS_CLIENT_ERROR;

            HttpLog httpLog = CaptureService.getHttpLog();
            if (httpLog != null)
                httpLog.addDecryptionError(conn, tstamp, conn.decryption_error);
        } else if(type == MsgType.DATA_TRUNCATED) {
            conn.setPayloadTruncatedByAddon();
        } else if(type == MsgType.JS_INJECTED) {
            conn.js_injected_scripts = new String(message, StandardCharsets.US_ASCII);
        } else
            conn.addPayloadChunkMitm(new PayloadChunk(message, getChunkType(type), isSent(type), tstamp, 0));
    }

    private synchronized void addPendingMessage(PendingMessage pending) {
        // Purge unresolved connections (should not happen, just in case)
        if(mPendingMessages.size() > 32) {
            long now = SystemClock.elapsedRealtime();

            for(int i = mPendingMessages.size()-1; i>=0; i--) {
                ArrayList<PendingMessage> pp = mPendingMessages.valueAt(i);

                if((now - pp.get(0).pendingSince) > 5000 /* 5 sec */) {
                    Log.w(TAG, "Dropping " + pp.size() + " old messages");
                    mPendingMessages.remove(mPendingMessages.keyAt(i));
                }
            }
        }

        int idx = mPendingMessages.indexOfKey(pending.port);
        ArrayList<PendingMessage> pp;

        if(idx < 0) {
            pp = new ArrayList<>();
            mPendingMessages.put(pending.port, pp);
        } else
            pp = mPendingMessages.valueAt(idx);

        pp.add(pending);
    }

    private static MsgType parseMsgType(String str) {
        switch (str) {
            case "running":
                return MsgType.RUNNING;
            case "tls_err":
                return MsgType.TLS_ERROR;
            case "http_err":
                return MsgType.HTTP_ERROR;
            case "http_req":
                return MsgType.HTTP_REQUEST;
            case "http_rep":
                return MsgType.HTTP_REPLY;
            case "tcp_climsg":
                return MsgType.TCP_CLIENT_MSG;
            case "tcp_srvmsg":
                return MsgType.TCP_SERVER_MSG;
            case "tcp_err":
                return MsgType.TCP_ERROR;
            case "ws_climsg":
                return MsgType.WEBSOCKET_CLIENT_MSG;
            case "ws_srvmsg":
                return MsgType.WEBSOCKET_SERVER_MSG;
            case "trunc":
                return MsgType.DATA_TRUNCATED;
            case "secret":
                return MsgType.MASTER_SECRET;
            case "log":
                return MsgType.LOG;
            case "js_inject":
                return MsgType.JS_INJECTED;
            default:
                return MsgType.UNKNOWN;
        }
    }

    private void logMasterSecret(byte[] master_secret) throws IOException {
        // When decrypting as root, currently we capture the mitmproxy <-> internet
        // traffic instead of the app <-> mitmproxy one. This makes the keylog useless
        if (mRootCapture)
            return;

        if(mPcapngFormat)
            CaptureService.dumpMasterSecret(master_secret);
        else {
            if(mKeylog == null)
                mKeylog = new BufferedOutputStream(
                        mContext.getContentResolver().openOutputStream(
                                Uri.fromFile(getKeylogFilePath(mContext)), "rwt"));

            mKeylog.write(master_secret);
            mKeylog.write(0xa);
        }
    }

    private void handleLog(byte[] message) {
        try {
            String msg = new String(message, StandardCharsets.US_ASCII);

            // format: 1:message
            if (msg.length() < 3)
                return;

            int lvl = Integer.parseInt(msg.substring(0, 1));
            Log.level(Log.MITMADDON_LOGGER, lvl, msg.substring(2));
        } catch (NumberFormatException ignored) {}
    }

    public Status getProxyStatus() {
        return proxyStatus.getValue();
    }

    public static void observeStatus(LifecycleOwner lifecycleOwner, Observer<Status> observer) {
        proxyStatus.observe(lifecycleOwner, observer);
    }

    @Override
    public void connectionsChanges(int num_connetions) {}
    @Override
    public void connectionsRemoved(int start, ConnectionDescriptor[] conns) {}
    @Override
    public void connectionsUpdated(int[] positions) {}

    @Override
    public void connectionsAdded(int start, ConnectionDescriptor[] conns) {
        synchronized(this) {
            // Save the latest port->ID mapping
            for(ConnectionDescriptor conn: conns) {
                //Log.d(TAG, "[+] port " + conn.local_port);
                mPortToConnId.put(conn.local_port, conn.incr_id);

                // Check if the message has already been received
                int pending_idx = mPendingMessages.indexOfKey(conn.local_port);
                if(pending_idx >= 0) {
                    ArrayList<PendingMessage> pp = mPendingMessages.valueAt(pending_idx);
                    mPendingMessages.removeAt(pending_idx);

                    for(PendingMessage pending: pp) {
                        //Log.d(TAG, "(pending) MSG." + pending.type.name() + "[" + pending.message.length + " B]: port=" + pending.port);
                        handleMessage(conn, pending.type, pending.msg, pending.when);
                    }
                }
            }
        }
    }

    @Override
    public void onMitmServiceConnect() {
        // Ensure that no other instance is running
        mAddon.stopProxy();

        // when connected, verify that the certificate is installed before starting the proxy.
        // will continue on onMitmGetCaCertificateResult.
        if(!mAddon.requestCaCertificate())
            mAddon.disconnect();
    }

    @Override
    public void onMitmGetCaCertificateResult(@Nullable String ca_pem) {
        if(!MitmAddon.isCAInstallationSkipped(mContext) && !Utils.isCAInstalled(ca_pem)) {
            // The certificate has been uninstalled from the system
            Utils.showToastLong(mContext, R.string.cert_reinstall_required);
            MitmAddon.setDecryptionSetupDone(mContext, false);
            CaptureService.stopService();
            return;
        }

        // Certificate installation verified, start the proxy
        mSocketFd = mAddon.startProxy(mConfig);
        if(mSocketFd == null) {
            mAddon.disconnect();
            return;
        }

        if (MitmAddon.isDozeEnabled(mContext)) {
            Utils.showToastLong(mContext, R.string.mitm_doze_notice);
            mAddon.disableDoze();
        }

        if(mThread != null)
            mThread.interrupt();

        mThread = new Thread(MitmReceiver.this);
        mThread.start();
    }

    @Override
    public void onMitmServiceDisconnect() {
        // Stop the capture if running, CaptureService will call MitmReceiver::stop
        CaptureService.stopService();
    }

    ConnectionDescriptor getConnByLocalPort(int local_port) {
        Integer conn_id;

        synchronized(this) {
            conn_id = mPortToConnId.get(local_port);
        }
        if(conn_id == null)
            return null;

        ConnectionDescriptor conn = mReg.getConnById(conn_id);
        if((conn == null) || (conn.local_port != local_port))
            return null;

        // success
        return conn;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/PCAPdroid.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.app.Application;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;

import androidx.annotation.NonNull;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.activities.ErrorActivity;
import com.emanuelef.remote_capture.model.Blocklist;
import com.emanuelef.remote_capture.model.CtrlPermissions;
import com.emanuelef.remote_capture.model.MatchList;
import com.emanuelef.remote_capture.model.Prefs;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Set;

import cat.ereza.customactivityoncrash.config.CaocConfig;

/* The PCAPdroid app class.
 * This class is instantiated before anything else, and its reference is stored in the mInstance.
 * Global state is stored into this class via singletons. Contrary to static singletons, this does
 * not require passing the localized Context to the singletons getters methods.
 *
 * IMPORTANT: do not override getResources() with mLocalizedContext, otherwise the Webview used for ads will crash!
 * https://stackoverflow.com/questions/56496714/android-webview-causing-runtimeexception-at-webviewdelegate-getpackageid
 */
public class PCAPdroid extends Application {
    private static final String TAG = "PCAPdroid";
    private MatchList mVisMask;
    private MatchList mMalwareWhitelist;
    private MatchList mFirewallWhitelist;
    private MatchList mDecryptionList;
    private Blocklist mBlocklist;
    private Blacklists mBlacklists;
    private CtrlPermissions mCtrlPermissions;
    private Context mLocalizedContext;
    private boolean mIsDecryptingPcap = false;
    private boolean mIsUsharkAvailable = false;
    private String mLoadedPcapBasename = null;
    private static WeakReference<PCAPdroid> mInstance;
    protected static boolean isUnderTest = false;

    @Override
    public void onCreate() {
        super.onCreate();

        if(!isUnderTest())
            Log.init(getCacheDir().getAbsolutePath());

        Utils.BuildType buildtp = Utils.getVerifiedBuild(this);
        Log.i(TAG, "Build type: " + buildtp);

        CaocConfig.Builder builder = CaocConfig.Builder.create();
        if((buildtp == Utils.BuildType.PLAYSTORE) || (buildtp == Utils.BuildType.UNKNOWN)) {
            // Disabled to get reports via the Android system reporting facility and for unsupported builds
            builder.enabled(false);
        } else {
            builder.errorDrawable(R.drawable.ic_app_crash)
                    .errorActivity(ErrorActivity.class);
        }
        builder.apply();

        mInstance = new WeakReference<>(this);
        mLocalizedContext = createConfigurationContext(Utils.getLocalizedConfig(this));
        mIsUsharkAvailable = CaptureService.isUsharkAvailable(this);

        // Listen to package events
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_PACKAGE_ADDED);
        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
        filter.addDataScheme("package");
        registerReceiver(new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
                    boolean newInstall = !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                    String packageName = intent.getData().getSchemeSpecificPart();
                    Log.d(TAG, "ACTION_PACKAGE_ADDED [new=" + newInstall + "]: " + packageName);

                    if(newInstall)
                        checkUidMapping(packageName);
                } else if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
                    boolean isUpdate = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                    String packageName = intent.getData().getSchemeSpecificPart();
                    Log.d(TAG, "ACTION_PACKAGE_REMOVED [update=" + isUpdate + "]: " + packageName);

                    if(!isUpdate) {
                        checkUidMapping(packageName);
                        removeUninstalledAppsFromAppFilter();
                    }
                }
            }
        }, filter);

        removeUninstalledAppsFromAppFilter();
    }

    public static @NonNull PCAPdroid getInstance() {
        return mInstance.get();
    }

    public static boolean isUnderTest() {
        return isUnderTest;
    }

    public MatchList getVisualizationMask() {
        if(mVisMask == null)
            mVisMask = new MatchList(mLocalizedContext, Prefs.PREF_VISUALIZATION_MASK);

        return mVisMask;
    }

    public Blacklists getBlacklists() {
        if(mBlacklists == null)
            mBlacklists = new Blacklists(mLocalizedContext);
        return mBlacklists;
    }

    public MatchList getMalwareWhitelist() {
        if(mMalwareWhitelist == null)
            mMalwareWhitelist = new MatchList(mLocalizedContext, Prefs.PREF_MALWARE_WHITELIST);
        return mMalwareWhitelist;
    }

    public Blocklist getBlocklist() {
        if(mBlocklist == null)
            mBlocklist = new Blocklist(mLocalizedContext);
        return mBlocklist;
    }

    // use some safe defaults to guarantee basic services
    private void initFirewallWhitelist() {
        mFirewallWhitelist.addApp(0 /* root */);
        mFirewallWhitelist.addApp(1000 /* android */);
        mFirewallWhitelist.addApp(getPackageName() /* PCAPdroid */);

        // see also https://github.com/microg/GmsCore/issues/1508#issuecomment-876269198
        mFirewallWhitelist.addApp("com.google.android.gms" /* Google Play Services */);
        mFirewallWhitelist.addApp("com.google.android.gsf" /* Google Services Framework (push notifications) */);
        mFirewallWhitelist.addApp("com.google.android.ims" /* Carrier Services */);
        mFirewallWhitelist.addApp("com.sec.spp.push" /* Samsung Push Service */);
        mFirewallWhitelist.save();
    }

    private void checkUidMapping(String pkg) {
        if(mVisMask != null)
            mVisMask.uidMappingChanged(pkg);

        // When an app is installed/uninstalled, recheck the UID mappings.
        // In particular:
        //  - On app uninstall, invalidate any package_name -> UID mapping
        //  - On app install, add the new package_name -> UID mapping
        if((mMalwareWhitelist != null) && mMalwareWhitelist.uidMappingChanged(pkg))
            CaptureService.reloadMalwareWhitelist();

        if((mFirewallWhitelist != null) && mFirewallWhitelist.uidMappingChanged(pkg)) {
            if(CaptureService.isServiceActive())
                CaptureService.requireInstance().reloadFirewallWhitelist();
        }

        if((mDecryptionList != null) && mDecryptionList.uidMappingChanged(pkg))
            CaptureService.reloadDecryptionList();

        if((mBlocklist != null) && mBlocklist.uidMappingChanged(pkg)) {
            if(CaptureService.isServiceActive())
                CaptureService.requireInstance().reloadBlocklist();
        }
    }

    private void removeUninstalledAppsFromAppFilter() {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        Set<String> filter = Prefs.getAppFilter(prefs);
        ArrayList<String> to_remove = new ArrayList<>();
        PackageManager pm = getPackageManager();

        for (String package_name: filter) {
            try {
                Utils.getPackageInfo(pm, package_name, 0);
            } catch (PackageManager.NameNotFoundException e) {
                Log.i(TAG, "Package " + package_name + " uninstalled, removing from app filter");
                to_remove.add(package_name);
            }
        }

        if (!to_remove.isEmpty()) {
            filter.removeAll(to_remove);
            prefs.edit()
                    .putStringSet(Prefs.PREF_APP_FILTER, filter)
                    .apply();
        }
    }

    public MatchList getFirewallWhitelist() {
        if(mFirewallWhitelist == null) {
            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
            mFirewallWhitelist = new MatchList(mLocalizedContext, Prefs.PREF_FIREWALL_WHITELIST);

            if(!Prefs.isFirewallWhitelistInitialized(prefs)) {
                initFirewallWhitelist();
                Prefs.setFirewallWhitelistInitialized(prefs);
            }
        }
        return mFirewallWhitelist;
    }

    public MatchList getDecryptionList() {
        if(mDecryptionList == null)
            mDecryptionList = new MatchList(mLocalizedContext, Prefs.PREF_DECRYPTION_LIST);

        return mDecryptionList;
    }

    public CtrlPermissions getCtrlPermissions() {
        if(mCtrlPermissions == null)
            mCtrlPermissions = new CtrlPermissions(this);
        return mCtrlPermissions;
    }

    public void setIsDecryptingPcap(boolean val) {
        mIsDecryptingPcap = val;
    }

    public boolean isDecryptingPcap() {
        return mIsDecryptingPcap;
    }

    public boolean isUsharkAvailable() {
        return mIsUsharkAvailable;
    }

    public void setLoadedPcapBasename(String basename) {
        mLoadedPcapBasename = basename;
    }

    public String getLoadedPcapBasename() {
        return mLoadedPcapBasename;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/PersistableUriPermission.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.UriPermission;
import android.net.Uri;

import androidx.activity.ComponentActivity;
import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.preference.PreferenceManager;

// If an app asks to dump to a PCAP file, ensure that PCAPdroid has such a permission.
// When dumping to the external storage, the first time it's necessary to get a persistable
// permission, which requires the user to manually select the output file from the UI.
public class PersistableUriPermission {
    private static final String TAG = "PersistableUriPermission";
    private static final String PREF_KEY = "persistable_uri";

    /* FLAG_GRANT_READ_URI_PERMISSION required for showPcapActionDialog (e.g. when auto-started at boot) */
    private static int PERSIST_MODE = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;

    public String key = "";
    public Uri persistableUri;
    private String mNewKey;
    private final Context mCtx;
    private final SharedPreferences mPrefs;
    private PupListener mListener;
    private final ActivityResultLauncher<Intent> mPcapLauncher;

    public interface PupListener {
        void onUriChecked(Uri grantedUri);
    }

    public PersistableUriPermission(ComponentActivity activity) {
        mCtx = activity;
        mPrefs = PreferenceManager.getDefaultSharedPreferences(mCtx);
        mPcapLauncher = activity.registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), this::pcapFileResult);
        reload();
    }

    public void reload() {
        String k = mPrefs.getString(PREF_KEY, "");
        int sep = k.indexOf("|");
        if(sep < 0)
            return;

        key = k.substring(0, sep);
        persistableUri = Uri.parse(k.substring(sep + 1));
    }

    public void save() {
        String serialized = key + "|" + persistableUri;
        mPrefs.edit().putString(PREF_KEY, serialized).apply();
    }

    public void checkPermission(String perm_key, boolean pcapng_format, PupListener listener) {
        boolean hasPermission = false;
        boolean keyChanged = !perm_key.equals(key);
        mNewKey = perm_key;
        mListener = listener;

        // Revoke the previous permissions and check
        for(UriPermission permission : mCtx.getContentResolver().getPersistedUriPermissions()) {
            if(keyChanged || !permission.getUri().equals(persistableUri)) {
                Log.d(TAG, "Releasing URI permission: " + permission.getUri().toString());
                mCtx.getContentResolver().releasePersistableUriPermission(permission.getUri(), PERSIST_MODE);
            } else
                hasPermission = true;
        }

        if(!hasPermission)
            openFileSelector(pcapng_format);
        else
            mListener.onUriChecked(persistableUri);
    }

    private void openFileSelector(boolean pcapng_format) {
        boolean noFileDialog = false;
        String fname = Utils.getUniquePcapFileName(mCtx, pcapng_format);
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        intent.putExtra(Intent.EXTRA_TITLE, fname);

        if(Utils.supportsFileDialog(mCtx, intent)) {
            try {
                mPcapLauncher.launch(intent);
            } catch (ActivityNotFoundException e) {
                noFileDialog = true;
            }
        } else
            noFileDialog = true;

        if(noFileDialog) {
            Log.w(TAG, "No app found to handle file selection");
            Utils.showToastLong(mCtx, R.string.no_activity_file_selection);
            mListener.onUriChecked(null);
        }
    }

    private void pcapFileResult(final ActivityResult result) {
        if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
            Uri uri = result.getData().getData();
            boolean persistable = (result.getData().getFlags() & Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION) != 0;

            /* Request a persistent permission to write this URI without invoking the system picker.
             * This is needed to write to the URI when invoking PCAPdroid from other apps via Intents
             * or when starting the capture at boot. */
            if(persistable) {
                try {
                    mCtx.getContentResolver().takePersistableUriPermission(uri, PERSIST_MODE);

                    // save the persistable uri to use it for the next capture
                    persistableUri = uri;
                    key = mNewKey;
                    save();
                } catch (SecurityException e) {
                    // This should never occur
                    Log.e(TAG, "Could not get PersistableUriPermission");
                    e.printStackTrace();
                }
            }

            mListener.onUriChecked(uri);
        } else
            mListener.onUriChecked(null);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/ReversedLinesFileReader.java`:

```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.emanuelef.remote_capture;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.StandardCharsets;

/**
 * Reads lines in a file reversely (similar to a BufferedReader, but starting at
 * the last line). Useful for e.g. searching in log files.
 *
 * @since 2.2
 */
public class ReversedLinesFileReader implements Closeable {
    private final int blockSize;
    private final Charset encoding;
    private final RandomAccessFile randomAccessFile;
    private final long totalByteLength;
    private final long totalBlockCount;
    private final byte[][] newLineSequences;
    private final int avoidNewlineSplitBufferSize;
    private final int byteDecrement;
    private FilePart currentFilePart;
    private boolean trailingNewlineOfFileSkipped = false;
    /**
     * Creates a ReversedLinesFileReader with default block size of 4KB and the
     * platform's default encoding.
     *
     * @param file
     *            the file to be read
     * @throws IOException  if an I/O error occurs
     * @deprecated 2.5 use {@link #ReversedLinesFileReader(File, Charset)} instead
     */
    @Deprecated
    public ReversedLinesFileReader(final File file) throws IOException {
        this(file, 4096, Charset.defaultCharset());
    }
    /**
     * Creates a ReversedLinesFileReader with default block size of 4KB and the
     * specified encoding.
     *
     * @param file
     *            the file to be read
     * @param charset the encoding to use
     * @throws IOException  if an I/O error occurs
     * @since 2.5
     */
    public ReversedLinesFileReader(final File file, final Charset charset) throws IOException {
        this(file, 4096, charset);
    }
    /**
     * Creates a ReversedLinesFileReader with the given block size and encoding.
     *
     * @param file
     *            the file to be read
     * @param blockSize
     *            size of the internal buffer (for ideal performance this should
     *            match with the block size of the underlying file system).
     * @param encoding
     *            the encoding of the file
     * @throws IOException  if an I/O error occurs
     * @since 2.3
     */
    public ReversedLinesFileReader(final File file, final int blockSize, final Charset encoding) throws IOException {
        this.blockSize = blockSize;
        this.encoding = encoding;
        randomAccessFile = new RandomAccessFile(file, "r");
        totalByteLength = randomAccessFile.length();
        int lastBlockLength = (int) (totalByteLength % blockSize);
        if (lastBlockLength > 0) {
            totalBlockCount = totalByteLength / blockSize + 1;
        } else {
            totalBlockCount = totalByteLength / blockSize;
            if (totalByteLength > 0) {
                lastBlockLength = blockSize;
            }
        }
        currentFilePart = new FilePart(totalBlockCount, lastBlockLength, null);
        // --- check & prepare encoding ---
        final Charset charset = encoding;
        final CharsetEncoder charsetEncoder = charset.newEncoder();
        final float maxBytesPerChar = charsetEncoder.maxBytesPerChar();
        if (maxBytesPerChar == 1f) {
            // all one byte encodings are no problem
            byteDecrement = 1;
        } else if (charset == StandardCharsets.UTF_8) {
            // UTF-8 works fine out of the box, for multibyte sequences a second UTF-8 byte can never be a newline byte
            // http://en.wikipedia.org/wiki/UTF-8
            byteDecrement = 1;
        } else if (charset == Charset.forName("Shift_JIS")) {
            // Same as for UTF-8
            // http://www.herongyang.com/Unicode/JIS-Shift-JIS-Encoding.html
            byteDecrement = 1;
        } else if (charset == StandardCharsets.UTF_16BE || charset == StandardCharsets.UTF_16LE) {
            // UTF-16 new line sequences are not allowed as second tuple of four byte sequences,
            // however byte order has to be specified
            byteDecrement = 2;
        } else if (charset == StandardCharsets.UTF_16) {
            throw new UnsupportedEncodingException("For UTF-16, you need to specify the byte order (use UTF-16BE or UTF-16LE)");
        } else {
            throw new UnsupportedEncodingException("Encoding " + encoding + " is not supported yet (feel free to submit a patch)");
        }
        // NOTE: The new line sequences are matched in the order given, so it is important that \r\n is BEFORE \n
        newLineSequences = new byte[][] { "\r\n".getBytes(encoding), "\n".getBytes(encoding), "\r".getBytes(encoding) };
        avoidNewlineSplitBufferSize = newLineSequences[0].length;
    }
    /**
     * Returns the lines of the file from bottom to top.
     *
     * @return the next line or null if the start of the file is reached
     * @throws IOException  if an I/O error occurs
     */
    public String readLine() throws IOException {
        String line = currentFilePart.readLine();
        while (line == null) {
            currentFilePart = currentFilePart.rollOver();
            if (currentFilePart != null) {
                line = currentFilePart.readLine();
            } else {
                // no more fileparts: we're done, leave line set to null
                break;
            }
        }
        // aligned behaviour with BufferedReader that doesn't return a last, empty line
        if("".equals(line) && !trailingNewlineOfFileSkipped) {
            trailingNewlineOfFileSkipped = true;
            line = readLine();
        }
        return line;
    }
    /**
     * Closes underlying resources.
     *
     * @throws IOException  if an I/O error occurs
     */
    public void close() throws IOException {
        randomAccessFile.close();
    }
    private class FilePart {
        private final long no;
        private final byte[] data;
        private byte[] leftOver;
        private int currentLastBytePos;
        /**
         * ctor
         * @param no the part number
         * @param length its length
         * @param leftOverOfLastFilePart remainder
         * @throws IOException if there is a problem reading the file
         */
        private FilePart(final long no, final int length, final byte[] leftOverOfLastFilePart) throws IOException {
            this.no = no;
            final int dataLength = length + (leftOverOfLastFilePart != null ? leftOverOfLastFilePart.length : 0);
            this.data = new byte[dataLength];
            final long off = (no - 1) * blockSize;
            // read data
            if (no > 0 /* file not empty */) {
                randomAccessFile.seek(off);
                final int countRead = randomAccessFile.read(data, 0, length);
                if (countRead != length) {
                    throw new IllegalStateException("Count of requested bytes and actually read bytes don't match");
                }
            }
            // copy left over part into data arr
            if (leftOverOfLastFilePart != null) {
                System.arraycopy(leftOverOfLastFilePart, 0, data, length, leftOverOfLastFilePart.length);
            }
            this.currentLastBytePos = data.length - 1;
            this.leftOver = null;
        }
        /**
         * Handles block rollover
         *
         * @return the new FilePart or null
         * @throws IOException if there was a problem reading the file
         */
        private FilePart rollOver() throws IOException {
            if (currentLastBytePos > -1) {
                throw new IllegalStateException("Current currentLastCharPos unexpectedly positive... "
                        + "last readLine() should have returned something! currentLastCharPos=" + currentLastBytePos);
            }
            if (no > 1) {
                return new FilePart(no - 1, blockSize, leftOver);
            } else {
                // NO 1 was the last FilePart, we're finished
                if (leftOver != null) {
                    throw new IllegalStateException("Unexpected leftover of the last block: leftOverOfThisFilePart="
                            + new String(leftOver, encoding));
                }
                return null;
            }
        }
        /**
         * Reads a line.
         *
         * @return the line or null
         */
        private String readLine() {
            String line = null;
            int newLineMatchByteCount;
            final boolean isLastFilePart = no == 1;
            int i = currentLastBytePos;
            while (i > -1) {
                if (!isLastFilePart && i < avoidNewlineSplitBufferSize) {
                    // avoidNewlineSplitBuffer: for all except the last file part we
                    // take a few bytes to the next file part to avoid splitting of newlines
                    createLeftOver();
                    break; // skip last few bytes and leave it to the next file part
                }
                // --- check for newline ---
                if ((newLineMatchByteCount = getNewLineMatchByteCount(data, i)) > 0 /* found newline */) {
                    final int lineStart = i + 1;
                    final int lineLengthBytes = currentLastBytePos - lineStart + 1;
                    if (lineLengthBytes < 0) {
                        throw new IllegalStateException("Unexpected negative line length="+lineLengthBytes);
                    }
                    final byte[] lineData = new byte[lineLengthBytes];
                    System.arraycopy(data, lineStart, lineData, 0, lineLengthBytes);
                    line = new String(lineData, encoding);
                    currentLastBytePos = i - newLineMatchByteCount;
                    break; // found line
                }
                // --- move cursor ---
                i -= byteDecrement;
                // --- end of file part handling ---
                if (i < 0) {
                    createLeftOver();
                    break; // end of file part
                }
            }
            // --- last file part handling ---
            if (isLastFilePart && leftOver != null) {
                // there will be no line break anymore, this is the first line of the file
                line = new String(leftOver, encoding);
                leftOver = null;
            }
            return line;
        }
        /**
         * Creates the buffer containing any left over bytes.
         */
        private void createLeftOver() {
            final int lineLengthBytes = currentLastBytePos + 1;
            if (lineLengthBytes > 0) {
                // create left over for next block
                leftOver = new byte[lineLengthBytes];
                System.arraycopy(data, 0, leftOver, 0, lineLengthBytes);
            } else {
                leftOver = null;
            }
            currentLastBytePos = -1;
        }
        /**
         * Finds the new-line sequence and return its length.
         *
         * @param data buffer to scan
         * @param i start offset in buffer
         * @return length of newline sequence or 0 if none found
         */
        private int getNewLineMatchByteCount(final byte[] data, final int i) {
            for (final byte[] newLineSequence : newLineSequences) {
                boolean match = true;
                for (int j = newLineSequence.length - 1; j >= 0; j--) {
                    final int k = i + j - (newLineSequence.length - 1);
                    match &= k >= 0 && data[k] == newLineSequence[j];
                }
                if (match) {
                    return newLineSequence.length;
                }
            }
            return 0;
        }
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/Utils.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-25 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.Manifest;
import android.annotation.SuppressLint;
import android.app.ActivityManager;
import android.app.Notification;
import android.app.PendingIntent;
import android.app.UiModeManager;
import android.content.ActivityNotFoundException;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.ComponentCallbacks2;
import android.content.ComponentName;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.Signature;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.content.res.XmlResourceParser;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Point;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.ConnectivityManager;
import android.net.InetAddresses;
import android.net.LinkProperties;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.Uri;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.provider.DocumentsContract;
import android.provider.MediaStore;
import android.provider.OpenableColumns;
import android.provider.Settings;
import android.text.SpannableString;
import android.text.SpannedString;
import android.text.TextUtils;
import android.text.method.LinkMovementMethod;
import android.text.style.StyleSpan;
import android.util.Patterns;
import android.view.Display;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.view.WindowMetrics;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.ComponentActivity;
import androidx.activity.EdgeToEdge;
import androidx.activity.result.ActivityResultLauncher;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatDelegate;
import androidx.appcompat.widget.SearchView;
import androidx.core.app.NotificationManagerCompat;
import androidx.core.content.ContextCompat;
import androidx.core.graphics.Insets;
import androidx.core.text.HtmlCompat;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.preference.PreferenceManager;
import androidx.viewpager2.widget.ViewPager2;

import com.emanuelef.remote_capture.interfaces.TextAdapter;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.Prefs;
import com.google.android.material.tabs.TabLayout;

import org.xmlpull.v1.XmlPullParser;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.Closeable;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.InterfaceAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Random;
import java.util.TimeZone;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;

import javax.net.ssl.HttpsURLConnection;

public class Utils {
    static final String TAG = "Utils";
    public static final String INTERACT_ACROSS_USERS = "android.permission.INTERACT_ACROSS_USERS";
    public static final String PCAPDROID_WEBSITE = "https://pcapdroid.org";
    public static final int PER_USER_RANGE = 100000;
    public static final int UID_UNKNOWN = -1;
    public static final int UID_NO_FILTER = -2;
    public static final int LOW_HEAP_THRESHOLD = 10485760 /* 10 MB */;
    private static Boolean rootAvailable = null;
    private static Locale primaryLocale = null;
    private static String[] l7Protocols = null;

    public enum BuildType {
        UNKNOWN,
        DEBUG,
        GITHUB,     // Github release
        FDROID,     // F-droid release
        PLAYSTORE,  // Google play release
    }

    public enum PrivateDnsMode {
        DISABLED,
        OPPORTUNISTIC,
        STRICT;

        @NonNull
        @Override
        public String toString() {
            return super.toString().toLowerCase();
        }
    }

    public static String[] list2array(List<String> l) {
        return l.toArray(new String[0]);
    }

    public static String formatBytes(long bytes) {
        long divisor;
        String suffix;
        if(bytes < 1024) return bytes + " B";

        if(bytes < 1024*1024)               { divisor = 1024;           suffix = "KB"; }
        else if(bytes < 1024*1024*1024)     { divisor = 1024*1024;      suffix = "MB"; }
        else                                { divisor = 1024*1024*1024; suffix = "GB"; }

        return String.format("%.1f %s", ((float)bytes) / divisor, suffix);
    }

    public static String formatIntShort(long val) {
        long divisor;
        String suffix;
        if(val < 1000) return Long.toString(val);

        if(val < 1000*1000)                { divisor = 1000;           suffix = "K"; }
        else if(val < 1000*1000*1000)      { divisor = 1000*1000;      suffix = "M"; }
        else                               { divisor = 1000*1000*1000; suffix = "G"; }

        return String.format("%.1f %s", ((float)val) / divisor, suffix);
    }

    @SuppressWarnings("deprecation")
    public static Locale getPrimaryLocale(Context context) {
        if(primaryLocale == null) {
            Configuration config = context.getResources().getConfiguration();

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
                primaryLocale = config.getLocales().get(0);
            else
                primaryLocale = config.locale;
        }

        return primaryLocale;
    }

    @SuppressWarnings("deprecation")
    public static int getSmallerDisplayDimension(Context ctx) {
        WindowManager manager = (WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE);

        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            WindowMetrics windowMetrics = manager.getCurrentWindowMetrics();
            return Math.min(windowMetrics.getBounds().width(), windowMetrics.getBounds().width());
        } else {
            Display display = manager.getDefaultDisplay();
            Point point = new Point();
            display.getSize(point);
            return Math.min(point.x, point.y);
        }
    }

    public static String getCountryName(Context context, String country_code) {
        Locale cur_locale = getPrimaryLocale(context);
        return(new Locale(cur_locale.getCountry(), country_code)).getDisplayCountry();
    }

    public static boolean isRTL(Context ctx) {
        String locale_name = getPrimaryLocale(ctx).getDisplayName();
        if(locale_name.isEmpty())
            return false;

        final int direction = Character.getDirectionality(locale_name.charAt(0));
        return direction == Character.DIRECTIONALITY_RIGHT_TO_LEFT ||
                direction == Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC;
    }

    public static String formatNumber(Context context, long num) {
        Locale locale = getPrimaryLocale(context);
        return String.format(locale, "%,d", num);
    }

    public static String formatDuration(long seconds) {
        if(seconds == 0)
            return "< 1 s";
        else if(seconds < 60)
            return String.format("%d s", seconds);
        else if(seconds < 3600)
            return String.format("> %d m", seconds / 60);
        else
            return String.format("> %d h", seconds / 3600);
    }

    public static String formatEpochShort(Context context, long epoch) {
        if(epoch == 0)
            return "-";

        long now = Utils.now();
        Locale locale = getPrimaryLocale(context);

        if((now - epoch) < (24 * 3600)) {
            final DateFormat fmt = new SimpleDateFormat("HH:mm:ss", locale);
            return fmt.format(new Date(epoch * 1000));
        }

        DateFormat fmt = new SimpleDateFormat("dd MMM, HH:mm:ss", locale);
        return fmt.format(new Date(epoch * 1000));
    }

    public static String formatEpochMin(Context context, long epoch) {
        if(epoch == 0)
            return "-";

        long now = Utils.now();
        Locale locale = getPrimaryLocale(context);

        if((now - epoch) < (24 * 3600)) {
            final DateFormat fmt = new SimpleDateFormat("HH:mm", locale);
            return fmt.format(new Date(epoch * 1000));
        }

        DateFormat fmt = new SimpleDateFormat("dd MMM", locale);
        return fmt.format(new Date(epoch * 1000));
    }

    public static String formatEpochFull(Context context, long epoch) {
        Locale locale = getPrimaryLocale(context);
        DateFormat fmt = new SimpleDateFormat("MM/dd/yy HH:mm:ss", locale);

        return fmt.format(new Date(epoch * 1000));
    }

    public static String formatMillisIso8601(Context context, long millis) {
        Locale locale = getPrimaryLocale(context);

        String pattern;
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N)
            pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX";
        else
            pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ";

        DateFormat fmt = new SimpleDateFormat(pattern, locale);
        String rv = fmt.format(new Date(millis));

        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.N) {
            // convert RFC 822 (+0100 or -0500) -> ISO 8601 timezone (+01:00 or -05:00)
            int l = rv.length();
            if ((l > 5) && ((rv.charAt(l - 5) == '+') || (rv.charAt(l - 5) == '-')))
                rv = rv.substring(0, l - 2) + ":" + rv.substring(l - 2);
        }

        return rv;
    }

    public static String httpDateToIso8601(String httpDate) {
        if (httpDate == null)
            return null;

        String[] patterns = {
            "EEE, dd-MMM-yyyy HH:mm:ss zzz",  // Fri, 05-Feb-2027 15:30:34 GMT
            "EEE, dd MMM yyyy HH:mm:ss zzz",  // RFC 1123: Fri, 05 Feb 2027 15:30:34 GMT
            "EEEE, dd-MMM-yy HH:mm:ss zzz",   // RFC 850: Friday, 05-Feb-27 15:30:34 GMT
            "EEE MMM d HH:mm:ss yyyy"         // ANSI C asctime: Fri Feb  5 15:30:34 2027
        };

        Date date = null;
        for (String pattern : patterns) {
            try {
                SimpleDateFormat parser = new SimpleDateFormat(pattern, Locale.US);
                parser.setTimeZone(TimeZone.getTimeZone("GMT"));
                date = parser.parse(httpDate);
                break;
            } catch (ParseException ignored) {}
        }

        if (date == null)
            return null;

        SimpleDateFormat iso8601 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
        iso8601.setTimeZone(TimeZone.getTimeZone("UTC"));
        return iso8601.format(date);
    }

    public static String formatEpochMillis(Context context, long millis) {
        Locale locale = getPrimaryLocale(context);
        DateFormat fmt = new SimpleDateFormat("MM/dd/yy HH:mm:ss.SSS", locale);

        return fmt.format(new Date(millis));
    }

    public static String formatInteger(Context context, int val) {
        Locale locale = getPrimaryLocale(context);
        return String.format(locale, "%d", val);
    }

    public static Configuration getLocalizedConfig(Context context) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
        Configuration config = context.getResources().getConfiguration();
        String appLocale = Prefs.getAppLocale(prefs);

        // On Android 33+, app language is configured from the system settings
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            return config;

        if (appLocale == null)
            return config;

        Locale locale = Locale.forLanguageTag(appLocale);
        Locale.setDefault(locale);
        config.setLocale(locale);

        return config;
    }

    public static String[] getSupportedLocales(Context context) {
        ArrayList<String> locales = new ArrayList<>();
        try {
            XmlResourceParser parser = context.getResources().getXml(R.xml.locales_config);
            int eventType;
            while ((eventType = parser.next()) != XmlPullParser.END_DOCUMENT) {
                if ((eventType == XmlPullParser.START_TAG) && "locale".equals(parser.getName())) {
                    String name = parser.getAttributeValue(
                            "http://schemas.android.com/apk/res/android", "name");
                    if (name != null)
                        locales.add(name);
                }
            }
            parser.close();
        } catch (Exception e) {
            Log.e(TAG, "getSupportedLocales: " + e.getMessage());
        }
        return locales.toArray(new String[0]);
    }

    public static String proto2str(int proto) {
        switch(proto) {
            case 6:     return "TCP";
            case 17:    return "UDP";
            case 1:     return "ICMP";
            default:    return(Integer.toString(proto));
        }
    }

    public static String[] getL7Protocols() {
        if(l7Protocols == null) {
            List<String> protos = CaptureService.getL7Protocols();

            if (protos != null) {
                Collections.sort(protos, String.CASE_INSENSITIVE_ORDER);
                l7Protocols = protos.toArray(new String[0]);
            }
        }

        return l7Protocols;
    }

    public static String getDnsServer(ConnectivityManager cm, Network net) {
        LinkProperties props = cm.getLinkProperties(net);

        if(props != null) {
            List<InetAddress> dns_servers = props.getDnsServers();

            for(InetAddress addr : dns_servers) {
                // Get the first IPv4 DNS server
                if(addr instanceof Inet4Address) {
                    return addr.getHostAddress();
                }
            }
        }

        return null;
    }

    // https://gist.github.com/mathieugerard/0de2b6f5852b6b0b37ed106cab41eba1
    // API level 31 requires building a NetworkRequest, which in turn requires an asynchronous callback.
    // Using the deprecated API instead to keep things simple.
    // https://developer.android.com/reference/android/net/wifi/WifiManager#getConnectionInfo()
    @SuppressWarnings("deprecation")
    public static String getLocalWifiIpAddress(Context context) {
        WifiManager wifiManager = (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        if(wifiManager == null)
            return(null);

        WifiInfo connInfo = wifiManager.getConnectionInfo();
        if(connInfo != null) {
            int ipAddress = connInfo.getIpAddress();

            if(ipAddress == 0)
                return(null);

            if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)) {
                ipAddress = Integer.reverseBytes(ipAddress);
            }

            byte[] ipByteArray = BigInteger.valueOf(ipAddress).toByteArray();

            String ipAddressString;
            try {
                ipAddressString = InetAddress.getByAddress(ipByteArray).getHostAddress();
            } catch (UnknownHostException ex) {
                return(null);
            }

            return ipAddressString;
        }

        return(null);
    }

    public static String getLocalIPAddress(Context context) {
        InetAddress vpn_ip;

        try {
            vpn_ip = InetAddress.getByName(CaptureService.VPN_IP_ADDRESS);
        } catch (UnknownHostException e) {
            return "";
        }

        // try to get the WiFi IP address first
        String wifi_ip = getLocalWifiIpAddress(context);

        if((wifi_ip != null) && (!wifi_ip.equals("0.0.0.0"))) {
            Log.d("getLocalIPAddress", "Using WiFi IP: " + wifi_ip);
            return wifi_ip;
        }

        // otherwise search for other network interfaces
        // https://stackoverflow.com/questions/6064510/how-to-get-ip-address-of-the-device-from-code
        try {
            List<NetworkInterface> interfaces = Collections.list(NetworkInterface.getNetworkInterfaces());
            for (NetworkInterface intf : interfaces) {
                if(!intf.isVirtual()) {
                    List<InetAddress> addrs = Collections.list(intf.getInetAddresses());
                    for (InetAddress addr : addrs) {
                        if (!addr.isLoopbackAddress()
                                && addr.isSiteLocalAddress() /* Exclude public IPs */
                                && !addr.equals(vpn_ip)) {
                            String sAddr = addr.getHostAddress();

                            if ((sAddr != null) && (addr instanceof Inet4Address) && !sAddr.equals("0.0.0.0")) {
                                Log.d("getLocalIPAddress", "Using interface '" + intf.getName() + "' IP: " + sAddr);
                                return sAddr;
                            }
                        }
                    }
                }
            }
        } catch (Exception ignored) { }

        // Fallback
        Log.d("getLocalIPAddress", "Using fallback IP");
        return "127.0.0.1";
    }

    public static boolean subnetContains(InetAddress subnet, int prefix, InetAddress address) {
        int addrlen = subnet.getAddress().length;
        ByteBuffer maskBuf = ByteBuffer.allocate(addrlen);

        for(int i=0; i<addrlen / 4; i++)
            maskBuf.putInt(-1);

        // 0xFFFFF...0000000
        BigInteger mask = ((new BigInteger(1, maskBuf.array())).shiftRight(prefix)).not();

        BigInteger start = new BigInteger(1, subnet.getAddress()).and(mask);
        BigInteger end = start.add(mask.not());
        BigInteger toCheck = new BigInteger(1, address.getAddress());

        return((toCheck.compareTo(start) >= 0) && (toCheck.compareTo(end) <= 0));
    }

    public static boolean subnetContains(String subnet, int prefix, String address) {
        try {
            return subnetContains(InetAddress.getByName(subnet), prefix, InetAddress.getByName(address));
        } catch (UnknownHostException ignored) {
            return false;
        }
    }

    public static boolean isLocalNetworkAddress(InetAddress checkAddress) {
        try {
            List<NetworkInterface> interfaces = Collections.list(NetworkInterface.getNetworkInterfaces());
            for (NetworkInterface intf : interfaces) {
                if(!intf.isVirtual()) {
                    List<InterfaceAddress> addrs = intf.getInterfaceAddresses();
                    for (InterfaceAddress addr : addrs) {
                        if(subnetContains(addr.getAddress(), addr.getNetworkPrefixLength(), checkAddress))
                            return true;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return false;
    }

    public static boolean isLocalNetworkAddress(String checkAddress) {
        // this check is necessary as otherwise host resolution would be triggered on the main thread
        if(!validateIpAddress(checkAddress))
            return false;

        try {
            return isLocalNetworkAddress(InetAddress.getByName(checkAddress));
        } catch (UnknownHostException ignored) {
            return false;
        }
    }

    // returns current timestamp in seconds
    public static long now() {
        Calendar calendar = Calendar.getInstance();
        return(calendar.getTimeInMillis() / 1000);
    }

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                    + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }

    // https://stackoverflow.com/questions/9655181/how-to-convert-a-byte-array-to-a-hex-string-in-java
    private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
    public static String byteArrayToHex(byte[] bytes, int size) {
        char[] hexChars = new char[size * 2];

        for (int j = 0; j < size; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
        }
        return new String(hexChars);
    }

    // Adapted from https://gist.github.com/jen20/906db194bd97c14d91df
    public static String hexdump(byte[] array, int offset, int length) {
        final int width = 16;
        final int half = width / 2;

        StringBuilder builder = new StringBuilder();

        for (int rowOffset = offset; rowOffset < offset + length; rowOffset += width) {
            for (int index = 0; index < width; index++) {
                if(index == half)
                    builder.append(" ");

                if (rowOffset + index < length)
                    builder.append(String.format("%02x ", array[rowOffset + index]));
                else
                    builder.append("   ");
            }

            if (rowOffset < length) {
                int asciiWidth = Math.min(width, length - rowOffset);
                builder.append(" ");

                builder.append(new String(array, rowOffset, asciiWidth,
                        StandardCharsets.US_ASCII).replaceAll("[^ -~]", "."));
            }

            builder.append("\n");
        }

        return builder.toString();
    }

    public static String hexdump(byte[] array) {
        return hexdump(array, 0, array.length);
    }

    // Splits the provided data into individual PCAP/PCAPNG records. Intended to be used with data received
    // via CaptureService::dumpPcapData
    public static Iterator<Integer> iterPcapRecords(byte[] data, boolean pcapng_format) {
        final ByteBuffer buf = ByteBuffer.wrap(data);
        buf.order(ByteOrder.nativeOrder());

        if(pcapng_format) {
            // PCAPNG
            return new Iterator<Integer>() {
                @Override
                public boolean hasNext() {
                    // 12: min block size
                    return(buf.remaining() >= 12);
                }

                @Override
                public Integer next() {
                    int total_len = buf.getInt(buf.position() + 4);
                    buf.position(buf.position() + total_len);
                    return total_len;
                }
            };
        } else {
            // PCAP
            return new Iterator<Integer>() {
                @Override
                public boolean hasNext() {
                    // 16: sizeof(pcap_rec)
                    return(buf.remaining() > 16);
                }

                @Override
                public Integer next() {
                    int rec_len = buf.getInt(buf.position() + 8) + 16;
                    buf.position(buf.position() + rec_len);
                    return rec_len;
                }
            };
        }
    }

    // API level 31 requires building a NetworkRequest, which in turn requires an asynchronous callback.
    // Using the deprecated API instead to keep things simple.
    // https://developer.android.com/reference/android/net/ConnectivityManager#getAllNetworks()
    @SuppressWarnings("deprecation")
    public static Network getRunningVpn(Context context) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        if(cm != null) {
            try {
                Network[] networks = cm.getAllNetworks();

                for(Network net : networks) {
                    NetworkCapabilities cap = cm.getNetworkCapabilities(net);

                    if ((cap != null) && cap.hasTransport(NetworkCapabilities.TRANSPORT_VPN)) {
                        Log.d("hasVPNRunning", "detected VPN connection: " + net.toString());
                        return net;
                    }
                }
            } catch (SecurityException e) {
                // this is a bug in Android 11 - https://issuetracker.google.com/issues/175055271?pli=1
                e.printStackTrace();
            }
        }

        return null;
    }

    public static void showToast(Context context, int id, Object... args) {
        String msg = context.getResources().getString(id, (Object[]) args);
        Toast.makeText(context, msg, Toast.LENGTH_SHORT).show();
    }

    public static void showToastLong(Context context, int id, Object... args) {
        String msg = context.getResources().getString(id, (Object[]) args);
        Toast.makeText(context, msg, Toast.LENGTH_LONG).show();
    }

    public static void showHelpDialog(Context context, int id) {
        String msg = context.getResources().getString(id);
        showHelpDialog(context, msg);
    }

    // NOTE: to get clickable links, retrieve the msg via Utils.getText()
    public static void showHelpDialog(Context context, CharSequence msg) {
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        builder.setTitle(R.string.hint);
        builder.setMessage(msg);
        builder.setCancelable(true);
        builder.setNeutralButton(R.string.ok,
                (dialog, id1) -> dialog.cancel());

        AlertDialog alert = builder.create();
        alert.show();

        TextView tv = alert.findViewById(android.R.id.message);
        if (tv != null)
            tv.setMovementMethod(LinkMovementMethod.getInstance());
    }

    public static String getUniqueFileName(Context context, String ext) {
        Locale locale = getPrimaryLocale(context);
        final DateFormat fmt = new SimpleDateFormat("dd_MMM_HH_mm_ss", locale);

        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(context);
        return Prefs.getFilenamePrefix(p) + fmt.format(new Date()) + "." + ext;
    }

    public static String getUniquePcapFileName(Context context, boolean pcapng_format) {
        return(Utils.getUniqueFileName(context, pcapng_format ? "pcapng" : "pcap"));
    }

    // Returns the export filename with the given extension.
    // If a PCAP file was loaded by the user, uses that filename as base.
    // Otherwise, generates a unique filename based on date/time.
    public static String getExportFileName(Context context, String ext) {
        String loadedBasename = PCAPdroid.getInstance().getLoadedPcapBasename();
        if (loadedBasename != null)
            return loadedBasename + "." + ext;
        return getUniqueFileName(context, ext);
    }

    public static @Nullable BitmapDrawable scaleDrawable(Resources res, Drawable drawable, int new_x, int new_y) {
        if((new_x <= 0) || (new_y <= 0))
            return null;

        try {
            Bitmap bitmap = Bitmap.createBitmap(new_x, new_y, Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);

            // may throw OutOfMemoryError
            drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
            drawable.draw(canvas);

            return new BitmapDrawable(res, bitmap);
        } catch (Exception e) {
            Log.w(TAG, "scaleDrawable(" + new_x + ", " + new_y + ") failed: " + e.getMessage());
            return null;
        }
    }

    // Converts a TableLayout (two columns, label and value) to a string which can be copied
    // If value is a ViewGroup, extract the first TextView from it
    public static String table2Text(TableLayout table) {
        StringBuilder builder = new StringBuilder();

        for (int i = 0; i < table.getChildCount(); i++) {
            View v = table.getChildAt(i);

            if ((v instanceof TableRow) && (v.getVisibility() == View.VISIBLE)
                    && (((TableRow) v).getChildCount() == 2)) {
                View label = ((TableRow) v).getChildAt(0);
                View value = ((TableRow) v).getChildAt(1);

                if(value instanceof ViewGroup) {
                    // Try to find first TextView child
                    ViewGroup group = (ViewGroup) value;
                    for(int c=0; c<group.getChildCount(); c++) {
                        View view = group.getChildAt(c);

                        if(view instanceof TextView) {
                            value = view;
                            break;
                        }
                    }
                }

                if((label instanceof TextView) && (value instanceof TextView)) {
                    builder.append(((TextView) label).getText());
                    builder.append(": ");
                    builder.append(((TextView) value).getText());
                    builder.append("\n");
                }
            }
        }

        return builder.toString();
    }

    public static String adapter2Text(TextAdapter adapter) {
        StringBuilder builder = new StringBuilder();

        for(int i=0; i< adapter.getCount(); i++) {
            String text = adapter.getItemText(i);

            builder.append(text);
            builder.append("\n");
        }

        return builder.toString();
    }

    public static boolean isTv(Context context) {
        UiModeManager uiModeManager = (UiModeManager) context.getSystemService(Context.UI_MODE_SERVICE);

        if(uiModeManager == null)
            return false;

        return(uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION);
    }

    public static String getAppVersion(Context context) {
        String appver;

        try {
            PackageInfo pInfo = Utils.getPackageInfo(context.getPackageManager(), context.getPackageName(), 0);
            String version = pInfo.versionName;
            boolean isRelease = version.contains(".");

            appver = isRelease ? ("v" + version) : version;
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, "Could not retrieve package version");
            appver = "";
        }

        return appver;
    }

    public static boolean supportsFileDialog(Context context, Intent intent) {
        // https://commonsware.com/blog/2017/12/27/storage-access-framework-missing-action.html
        ComponentName comp = intent.resolveActivity(context.getPackageManager());

        return((comp != null) && (!"com.google.android.tv.frameworkpackagestubs".equals(comp.getPackageName())));
    }

    public static boolean supportsFileDialog(Context context) {
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        return supportsFileDialog(context, intent);
    }

    public static boolean launchFileDialog(Context context, Intent intent, ActivityResultLauncher<Intent> launcher) {
        if(Utils.supportsFileDialog(context, intent)) {
            try {
                launcher.launch(intent);
                return true;
            } catch (ActivityNotFoundException | IllegalStateException ignored) {}
        }

        Utils.showToastLong(context, R.string.no_activity_file_selection);
        return false;
    }

    // Get a URI to write a file into the downloads folder, into a folder named "PCAPdroid"
    // If the file exists, it's overwritten
    public static Uri getDownloadsUri(Context context, String fname) {
        ContentValues values = new ContentValues();

        //values.put(MediaStore.MediaColumns.MIME_TYPE, "text/plain");
        values.put(MediaStore.MediaColumns.DISPLAY_NAME, fname);
        String selectQuery = "";

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            // On Android Q+ cannot directly access the external dir. Must use RELATIVE_PATH instead.
            // Important: trailing "/" required for the selectQuery
            String relPath = Environment.DIRECTORY_DOWNLOADS + "/PCAPdroid/";
            selectQuery = MediaStore.MediaColumns.RELATIVE_PATH + "='" + relPath + "' AND " +
                MediaStore.MediaColumns.DISPLAY_NAME + "='" + fname + "'";
            values.put(MediaStore.MediaColumns.RELATIVE_PATH, relPath);
        } else {
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                if(context.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                    Utils.showToastLong(context, R.string.external_storage_perm_required);
                    return(null);
                }
            }

            // NOTE: context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS) returns an app internal folder
            File downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);
            File folder = new File(downloadsDir + "/PCAPdroid");
            try {
                folder.mkdirs();
            } catch (Exception ignored) {}
            if(!folder.exists())
                folder = downloadsDir;

            String path = folder + "/" + fname;
            Log.d(TAG, "getDownloadsUri: path=" + path);
            selectQuery = MediaStore.MediaColumns.DATA + "='" + path + "'";
            values.put(MediaStore.MediaColumns.DATA, path);
        }

        Uri externalUri = MediaStore.Files.getContentUri("external");

        // if the file with given name already exists, overwrite it
        try (Cursor cursor = context.getContentResolver().query(externalUri, new String[]{MediaStore.MediaColumns._ID}, selectQuery, null, null)) {
            if ((cursor != null) && cursor.moveToFirst()) {
                long id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID));
                Uri existingUri = ContentUris.withAppendedId(externalUri, id);

                Log.d(TAG, "getDownloadsUri: overwriting file " + existingUri);
                return existingUri;
            }
        } catch (Exception ignored) {}

        try {
            Uri newUri = context.getContentResolver().insert(externalUri, values);
            Log.d(TAG, "getDownloadsUri: new file " + newUri);
            return newUri;
        } catch (Exception e) {
            // On some devices, it may trigger "IllegalArgumentException: Volume external_primary not found"
            Log.e(TAG, "getDownloadsUri failed:" + e.getMessage());
            Utils.showToastLong(context, R.string.write_ext_storage_failed);
            return(null);
        }
    }

    public static boolean isRootAvailable() {
        if(rootAvailable == null) {
            String path = System.getenv("PATH");
            rootAvailable = false;

            if(path != null) {
                Log.d("isRootAvailable", "PATH = " + path);

                for(String part : path.split(":")) {
                    File f = new File(part + "/su");

                    if(f.exists()) {
                        Log.d("isRootAvailable", "'su' binary found at " + f.getAbsolutePath());
                        rootAvailable = true;
                        break;
                    }
                }
            }
        }

        return rootAvailable;
    }

    public static void copyToClipboard(Context ctx, String contents) {
        try {
            ClipboardManager clipboard = (ClipboardManager) ctx.getSystemService(Context.CLIPBOARD_SERVICE);
            ClipData clip = ClipData.newPlainText(ctx.getString(R.string.stats), contents);
            clipboard.setPrimaryClip(clip);

            // Only show a toast for Android 12 and lower
            if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.S_V2)
                Utils.showToast(ctx, R.string.copied);
        } catch (Exception e) {
            Log.e(TAG, "copyToClipboard failed: " + e.getMessage());
            Utils.showToastLong(ctx, R.string.error);
        }
    }

    public static void shareText(Context ctx, String subject, String contents) {
        Intent intent = new Intent(android.content.Intent.ACTION_SEND);
        intent.setType("text/plain");
        intent.putExtra(android.content.Intent.EXTRA_SUBJECT, subject);
        intent.putExtra(android.content.Intent.EXTRA_TEXT, contents);

        startActivity(ctx, Intent.createChooser(intent, ctx.getResources().getString(R.string.share)));
    }

    // Formats a string resource like "text: %1s" by applying the specified style to the "text:" and "value" ("%1s")
    public static SpannableString formatTextValue(Context ctx, StyleSpan textStyle, StyleSpan valStyle, int resid, String value) {
        String fmt = ctx.getResources().getString(resid);
        String textAndValue = String.format(fmt, value);
        SpannableString s = new SpannableString(textAndValue);
        int valOffset = fmt.length() - 4;

        if(!isRTL(ctx)) {
            if (textStyle != null)
                s.setSpan(textStyle, 0, valOffset, 0);
            if (valStyle != null)
                s.setSpan(valStyle, valOffset, textAndValue.length(), 0);
        } else {
            if (textStyle != null)
                s.setSpan(textStyle, textAndValue.length() - valOffset, textAndValue.length(), 0);
            if (valStyle != null)
                s.setSpan(valStyle, 0, textAndValue.length() - valOffset, 0);
        }

        return s;
    }

    // www.example.org -> example.org
    public static String cleanDomain(String domain) {
        if(domain.startsWith("www."))
            domain = domain.substring(4);
        return domain;
    }

    // a.example.org -> example.org
    public static String getSecondLevelDomain(String domain) {
        int tldPos = domain.lastIndexOf(".");

        if(tldPos <= 0)
            return domain;

        int rootPos = domain.substring(0, tldPos).lastIndexOf(".");

        if(rootPos <= 0)
            return domain;

        return domain.substring(rootPos + 1);
    }

    public static String tcpFlagsToStr(int flags) {
        final String []flags_s = {"FIN", "SYN", "RST", "PSH", "ACK", "URG", "ECN", "CWR"};
        final StringBuilder builder = new StringBuilder();
        boolean first = true;

        for(int i=0; i<flags_s.length; i++) {
            if((flags & (1 << i)) != 0) {
                if(!first)
                    builder.append(" ");
                builder.append(flags_s[i]);
                first = false;
            }
        }

        return builder.toString();
    }

    public static int getIntentFlags(int flags) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
            flags |= PendingIntent.FLAG_IMMUTABLE;
        return flags;
    }

    public static boolean ungzip(InputStream is, String dst) {
        try(GZIPInputStream gis = new GZIPInputStream(is)) {
            try(BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst))) {
                byte[] bytesIn = new byte[4096];
                int read;
                while ((read = gis.read(bytesIn)) != -1)
                    bos.write(bytesIn, 0, read);
            }
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public static boolean downloadFile(String _url, String path) {
        boolean has_contents = false;

        try (FileOutputStream out = new FileOutputStream(path + ".tmp")) {
            try (BufferedOutputStream bos = new BufferedOutputStream(out)) {
                URL url = new URL(_url);

                HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
                try {
                    // Necessary otherwise the connection will stay open
                    con.setRequestProperty("Connection", "Close");
                    con.setConnectTimeout(5000);
                    con.setReadTimeout(5000);

                    try(InputStream in = new BufferedInputStream(con.getInputStream())) {
                        byte[] bytesIn = new byte[4096];
                        int read;
                        while ((read = in.read(bytesIn)) != -1) {
                            bos.write(bytesIn, 0, read);
                            has_contents |= (read > 0);
                        }
                    } catch (SocketTimeoutException _ignored) {
                        Log.w(TAG, "Timeout while fetching " + _url);
                    }
                } finally {
                    con.disconnect();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        if(!has_contents) {
            try {
                //noinspection ResultOfMethodCallIgnored
                (new File(path + ".tmp")).delete(); // if exists
            } catch (Exception ignored) {
                // ignore
            }
            return false;
        }

        // Only write the target path if it was successful
        return (new File(path + ".tmp")).renameTo(new File(path));
    }

    public static String shorten(String s, int maxlen) {
        if(s.length() > maxlen)
            s = s.substring(0, maxlen - 1) + "…";

        return s;
    }

    // NOTE: base32 padding not supported
    public static byte[] base32Decode(String s) {
        s = s.toUpperCase().replace("\n", "");
        byte[] rv = new byte[s.length() * 5 / 8];
        int i = 0;
        int bitsRemaining = 8;
        byte curByte = 0;

        for(int k=0; k<s.length(); k++) {
            int val;
            char c = s.charAt(k);

            if((c >= '2') && (c <= '7'))
                val = 26 + (c - '2');
            else if((c >= 'A') && (c <= 'Z'))
                val = (c - 'A');
            else
                throw new IllegalArgumentException("invalid BASE32 string or unsupported padding");

            // https://stackoverflow.com/questions/641361/base32-decoding
            if(bitsRemaining > 5) {
                int mask = val << (bitsRemaining - 5);
                curByte = (byte)(curByte | mask);
                bitsRemaining -= 5;
            } else {
                int mask = val >> (5 - bitsRemaining);
                curByte = (byte)(curByte | mask);
                rv[i++] = curByte;
                curByte = (byte)(val << (3 + bitsRemaining));
                bitsRemaining += 3;
            }
        }

        if(i < rv.length)
            rv[i] = curByte;

        return rv;
    }

    public static void startActivity(Context ctx, Intent intent) {
        try {
            ctx.startActivity(intent);
        } catch (ActivityNotFoundException | SecurityException e) {
            showToastLong(ctx, R.string.no_intent_handler_found);
        }
    }

    // Runs the specified runnable now if on the UI thread, otherwise enqueue it to the Handler
    public static void runOnUi(Runnable r, Handler h) {
        if(Looper.getMainLooper().getThread() == Thread.currentThread())
            r.run();
        else
            h.post(r);
    }

    public static void safeClose(Closeable obj) {
        if(obj == null)
            return;

        try {
            obj.close();
        } catch (IOException e) {
            Log.w(TAG, e.getLocalizedMessage());
        }
    }

    // Returns true on the playstore branch
    public static boolean isPlaystore() {
        return false;
    }

    @SuppressWarnings("deprecation")
    public static BuildType getVerifiedBuild(Context ctx, String package_name) {
        try {
            Signature[] signatures;

            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                // NOTE: PCAPdroid does not use multiple signatures
                PackageInfo pInfo = Utils.getPackageInfo(ctx.getPackageManager(), package_name, PackageManager.GET_SIGNING_CERTIFICATES);
                signatures = (pInfo.signingInfo == null) ? null : pInfo.signingInfo.getSigningCertificateHistory();
            } else {
                @SuppressLint("PackageManagerGetSignatures")
                PackageInfo pInfo = Utils.getPackageInfo(ctx.getPackageManager(), package_name, PackageManager.GET_SIGNATURES);
                signatures = pInfo.signatures;
            }

            // can be null in robolectric tests
            if((signatures == null) || (signatures.length < 1))
                return BuildType.UNKNOWN;

            MessageDigest sha1 = MessageDigest.getInstance("SHA");
            sha1.update(signatures[0].toByteArray());

            // keytool -printcert -jarfile file.apk
            String hex = byteArrayToHex(sha1.digest(), sha1.getDigestLength());
            switch(hex) {
                case "511140392BFF2CFB4BD825895DD6510CE1807F6D":
                    return BuildType.DEBUG;
                case "EE953D4F988C8AC17575DFFAA1E3BBCE2E29E81D":
                    return isPlaystore() ? BuildType.PLAYSTORE : BuildType.GITHUB;
                case "72777D6939EF150099219BBB68C17220DB28EA8E":
                    return BuildType.FDROID;
            }
        } catch (PackageManager.NameNotFoundException | NoSuchAlgorithmException e) {
            Log.e(TAG, "Could not determine the build type");
        }
        return BuildType.UNKNOWN;
    }

    public static BuildType getVerifiedBuild(Context ctx) {
        return getVerifiedBuild(ctx, ctx.getPackageName());
    }

    public static X509Certificate x509FromPem(String pem) {
        int begin = pem.indexOf('\n') + 1;
        int end = pem.indexOf('-', begin);

        if((begin > 0) && (end > begin)) {
            String cert64 = pem.substring(begin, end);
            //Log.d(TAG, "Cert: " + cert64);
            try {
                CertificateFactory cf = CertificateFactory.getInstance("X.509");
                byte[] cert_data = android.util.Base64.decode(cert64, android.util.Base64.DEFAULT);
                return (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(cert_data));
            } catch (CertificateException e) {
                e.printStackTrace();
            }
        }

        return null;
    }

    public static boolean isCAInstalled(X509Certificate ca_cert) {
        try {
            KeyStore ks = KeyStore.getInstance("AndroidCAStore");
            ks.load(null, null);
            return ks.getCertificateAlias(ca_cert) != null;
        } catch (KeyStoreException | CertificateException | IOException | NoSuchAlgorithmException e) {
            e.printStackTrace();
            return false;
        }
    }

    public static boolean isCAInstalled(String ca_pem) {
        if(ca_pem == null)
            return false;

        X509Certificate ca_cert = x509FromPem(ca_pem);
        if(ca_cert == null)
            return false;

        return isCAInstalled(ca_cert);
    }

    // Like Files.copy(src.toPath(), out);
    public static void copy(File src, OutputStream out) throws IOException {
        try(FileInputStream in = new FileInputStream(src)) {
            byte[] bytesIn = new byte[4096];
            int read;
            while((read = in.read(bytesIn)) != -1)
                out.write(bytesIn, 0, read);
        }
    }

    public static void copy(InputStream in, File dst) throws IOException {
        try(FileOutputStream out = new FileOutputStream(dst)) {
            byte[] bytesIn = new byte[4096];
            int read;
            while((read = in.read(bytesIn)) != -1)
                out.write(bytesIn, 0, read);
        }
    }

    public static boolean hasEncryptedPayload(AppDescriptor app, ConnectionDescriptor conn) {
        return(
            // Telegram
            app.getPackageName().equals("org.telegram.messenger") ||

            // Whatsapp
            ((conn.info != null) && conn.info.equals("g.whatsapp.net") && !conn.l7proto.equals("DNS")) ||

            // Google GCM
            // https://stackoverflow.com/questions/15571576/which-port-and-protocol-does-google-cloud-messaging-gcm-use
            ((app.getUid() == 1000) && (conn.dst_port >= 5228) && (conn.dst_port <= 5230)) ||

            // Google APN
            // https://keabird.com/blogs/2014/09/19/ports-to-be-whitelisted-for-iosandroid-push-notification/
            ((app.getUid() == 1000) && ((conn.dst_port == 2195) || (conn.dst_port == 2196) || (conn.dst_port == 5223)))
        );
    }

    /* Detects and returns the end of the HTTP request/response headers. 0 is returned if not found. */
    public static int getEndOfHTTPHeaders(byte[] buf) {
        for(int i = 0; i <= (buf.length - 4); i++) {
            if((buf[i] == '\r') && (buf[i+1] == '\n') && (buf[i+2] == '\r') && (buf[i+3] == '\n'))
                return i+4;
        }
        return 0;
    }

    public static String genRandomString(int length) {
        String charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        StringBuilder sb = new StringBuilder(length);
        Random rnd = new Random();

        for(int i = 0; i < length; i++)
            sb.append(charset.charAt(rnd.nextInt(charset.length())));

        return sb.toString();
    }

    public static void setDecryptionIcon(ImageView icon, ConnectionDescriptor conn) {
        int color;

        switch(conn.getDecryptionStatus()) {
            case DECRYPTED:
                color = R.color.ok;
                break;
            case NOT_DECRYPTABLE:
                color = R.color.warning;
                break;
            case ERROR:
                color = R.color.danger;
                break;
            default:
                color = R.color.lightGray;
        }

        Context context = icon.getContext();
        int resid = (conn.isCleartext() || conn.isDecrypted()) ? R.drawable.ic_lock_open : R.drawable.ic_lock;

        icon.setColorFilter(ContextCompat.getColor(context, color));
        icon.setImageDrawable(ContextCompat.getDrawable(context, resid));
    }

    public static boolean isPrintable(byte c) {
        return ((c >= 32) && (c <= 126)) || (c == '\r') || (c == '\n') || (c == '\t');
    }

    // Get a CharSequence which properly displays clickable links obtained by formatting a parametric
    // string resource with the provided args. See setTextUrls
    // https://stackoverflow.com/questions/23503642/how-to-use-formatted-strings-together-with-placeholders-in-android
    public static CharSequence getText(Context context, int resid, String... args) {
        for(int i = 0; i < args.length; ++i)
            args[i] = TextUtils.htmlEncode(args[i]);

        String htmlOnly = String.format(HtmlCompat.toHtml(new SpannedString(context.getText(resid)),
                HtmlCompat.TO_HTML_PARAGRAPH_LINES_CONSECUTIVE), (Object[]) args);
        //Log.d(TAG, htmlOnly);
        return HtmlCompat.fromHtml(htmlOnly, HtmlCompat.FROM_HTML_MODE_LEGACY);
    }

    // Format a resource containing URLs and display it in a TextView, making URls clickable
    public static void setTextUrls(TextView tv, int resid, String... args) {
        CharSequence text = getText(tv.getContext(), resid, args);
        tv.setText(text);
        tv.setMovementMethod(LinkMovementMethod.getInstance());
    }

    public static int getPCAPdroidUid(Context context) {
        // NOTE: when called from a work profile, it correctly returns the work profile UID
        AppDescriptor app = AppsResolver.resolveInstalledApp(context.getPackageManager(), BuildConfig.APPLICATION_ID, 0);
        if(app != null)
            return app.getUid();
        return Utils.UID_UNKNOWN;
    }

    // returns the user ID of a given app uid
    public static int getUserId(int uid) {
        return  uid / PER_USER_RANGE;
    }

    @SuppressLint("DefaultLocale")
    public static boolean rootGrantPermission(Context context, String perm) {
        return CaptureService.rootCmd("pm", String.format("grant --user %d %s %s", getUserId(getPCAPdroidUid(context)), BuildConfig.APPLICATION_ID, perm)) == 0;
    }

    // Returns the available dalvik vm heap size for this app. Exceeding this size will result into
    // an OOM exception
    public static long getAvailableHeap() {
        Runtime runtime = Runtime.getRuntime();

        // maxMemory: max memory which can be allocated on this app vm (should correspond to getMemoryClass)
        // totalMemory: currently allocated memory (used/unused) by the vm
        // freeMemory: free portion of the totalMemory
        long unallocated = runtime.maxMemory() - runtime.totalMemory();
        return unallocated + runtime.freeMemory();
    }

    @SuppressWarnings("deprecation")
    public static String trimlvl2str(int lvl) {
        // NOTE: most trim levels are not available anymore since API 34
        switch (lvl) {
            case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:         return "TRIM_MEMORY_UI_HIDDEN";
            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:  return "TRIM_MEMORY_RUNNING_MODERATE";
            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:       return "TRIM_MEMORY_RUNNING_LOW";
            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:  return "TRIM_MEMORY_RUNNING_CRITICAL";
            case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:        return "TRIM_MEMORY_BACKGROUND";
            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:          return "TRIM_MEMORY_MODERATE";
            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:          return "TRIM_MEMORY_COMPLETE";
            default:                                                return "TRIM_UNKNOWN";
        }
    }

    public static String getMemoryStats(Context context) {
        // This accounts system-wide limits
        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
        activityManager.getMemoryInfo(memoryInfo);

        ActivityManager.RunningAppProcessInfo memState = new ActivityManager.RunningAppProcessInfo();
        ActivityManager.getMyMemoryState(memState);

        // This accounts app-specific limits (dalvik heap)
        Runtime runtime = Runtime.getRuntime();
        long heapAvailable = getAvailableHeap();
        boolean heapLow = heapAvailable <= LOW_HEAP_THRESHOLD;

        return "[Runtime] free: " + Utils.formatBytes(runtime.freeMemory()) + ", max: " + Utils.formatBytes(runtime.maxMemory()) + ", allocated: " + Utils.formatBytes(runtime.totalMemory()) + ", available: " + Utils.formatBytes(heapAvailable) + ", low=" + heapLow +
                "\n[MemoryState] pid: " + memState.pid + ", trimlevel: " + trimlvl2str(memState.lastTrimLevel) +
                "\n[MemoryInfo] available: " + Utils.formatBytes(memoryInfo.availMem) + ", total: " + Utils.formatBytes(memoryInfo.totalMem) + ", lowthresh: " + Utils.formatBytes(memoryInfo.threshold) + ", low=" + memoryInfo.lowMemory +
                "\n[MemoryClass] standard: " + activityManager.getMemoryClass() + " MB, large: " + activityManager.getLargeMemoryClass() + " MB";
    }

    public static void sendImportantNotification(Context context, int id, Notification notification) {
        NotificationManagerCompat man = NotificationManagerCompat.from(context);

        if(!man.areNotificationsEnabled()) {
            String title = notification.extras.getString(Notification.EXTRA_TITLE);
            String description = notification.extras.getString(Notification.EXTRA_TEXT);
            String text = title + " - " + description;

            Log.w(TAG, "Important notification not sent because notifications are disabled: " + text);

            // Try with toast (will only work if PCAPdroid is in the foreground)
            Toast.makeText(context, text, Toast.LENGTH_SHORT).show();
        } else
            man.notify(id, notification);
    }

    // Set the SearchView query and expand it
    public static void setSearchQuery(SearchView searchView, MenuItem searchItem, String query) {
        searchView.setIconified(false);
        searchItem.expandActionView();

        searchView.setIconified(false);
        searchItem.expandActionView();

        // Delay otherwise the query won't be set when the activity is just started
        searchView.post(() -> searchView.setQuery(query, true));
    }

    public static boolean backHandleSearchview(SearchView searchView) {
        if((searchView != null) && !searchView.isIconified()) {
            // Required to close the SearchView when the search submit button was not pressed
            searchView.setIconified(true);
            return true;
        }

        return false;
    }

    public static String getDeviceModel() {
        if(Build.MODEL.startsWith(Build.MANUFACTURER))
            return Build.MANUFACTURER;
        else
            return Build.MANUFACTURER + " " + Build.MODEL;
    }

    public static String getOsVersion() {
        return "Android " + Build.VERSION.RELEASE + " (SDK " + Build.VERSION.SDK_INT + ")";
    }

    public static String getBuildInfo(Context ctx) {
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        boolean rooted = Utils.isRootAvailable();

        return "Build type: " + Utils.getVerifiedBuild(ctx).toString().toLowerCase() +
                (!PCAPdroid.getInstance().isUsharkAvailable() ? " (withoutUshark)" : "") + "\n" +
                "Build version: " + BuildConfig.VERSION_NAME + "\n" +
                "Current date: " + dateFormat.format(new Date()) + "\n" +
                "Device: " + getDeviceModel() + (rooted ? " (rooted)" : "") + "\n" +
                "OS version: " + getOsVersion() + "\n";
    }

    // https://stackoverflow.com/questions/16704597/how-do-you-get-the-user-defined-device-name-in-android
    public static @Nullable String getDeviceName(Context ctx) {
        try {
            if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.S)
                // NOTE: on Android 32+ this generates a security exception
                return Settings.Secure.getString(ctx.getContentResolver(), "bluetooth_name");

            return Settings.Global.getString(ctx.getContentResolver(), Settings.Global.DEVICE_NAME);
        } catch (Exception e) {
            Log.d(TAG, "getDeviceName failed: " + e);
            return null;
        }
    }

    public static String getAppVersionString() {
        return "PCAPdroid v" + BuildConfig.VERSION_NAME;
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    public static @Nullable <T extends Serializable> T getSerializableExtra(Intent intent, String key, Class<T> clazz) {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            return intent.getSerializableExtra(key, clazz);
        else {
            try {
                return (T)intent.getSerializableExtra(key);
            } catch (ClassCastException unused) {
                return null;
            }
        }
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    public static @Nullable <T extends Serializable> T getSerializable(Bundle bundle, String key, Class<T> clazz) {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            return bundle.getSerializable(key, clazz);
        else {
            try {
                return (T)bundle.getSerializable(key);
            } catch (ClassCastException unused) {
                return null;
            }
        }
    }

    @SuppressWarnings({"deprecation"})
    public static PackageInfo getPackageInfo(PackageManager pm, String package_name, int flags) throws PackageManager.NameNotFoundException {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            return pm.getPackageInfo(package_name, PackageManager.PackageInfoFlags.of(flags));
        else
            return pm.getPackageInfo(package_name, flags);
    }

    @SuppressWarnings({"deprecation"})
    public static int getPackageUid(PackageManager pm, String package_name, int flags) throws PackageManager.NameNotFoundException {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            return pm.getPackageUid(package_name, PackageManager.PackageInfoFlags.of(flags));
        else if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
            return pm.getPackageUid(package_name, 0);
        else
            return pm.getApplicationInfo(package_name, 0).uid;
    }

    @SuppressLint({"QueryPermissionsNeeded"})
    @SuppressWarnings({"deprecation"})
    public static List<PackageInfo> getInstalledPackages(PackageManager pm, int flags) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            return pm.getInstalledPackages(PackageManager.PackageInfoFlags.of(flags));
        else
            return pm.getInstalledPackages(flags);
    }

    public static boolean validatePort(String value) {
        try {
            int val = Integer.parseInt(value);
            return((val > 0) && (val < 65535));
        } catch(NumberFormatException e) {
            return false;
        }
    }

    // from bouncycastle
    private static boolean isValidIPv6(String address) {
        if (address.length() == 0)
            return false;

        char firstChar = address.charAt(0);
        if (firstChar != ':' && Character.digit(firstChar, 16) < 0)
            return false;

        int segmentCount = 0;
        String temp = address + ":";
        boolean doubleColonFound = false;

        int pos = 0, end;
        while (pos < temp.length() && (end = temp.indexOf(':', pos)) >= pos)  {
            if (segmentCount == 8)
                return false;

            if (pos != end)  {
                String value = temp.substring(pos, end);

                if (end == temp.length() - 1 && value.indexOf('.') > 0) {
                    // add an extra one as address covers 2 words.
                    if (++segmentCount == 8)
                        return false;
                    if (!validateIpv4Address(value))
                        return false;
                }
                else if (!isParseableIPv6Segment(temp, pos, end))
                    return false;
            } else {
                if (end != 1 && end != temp.length() - 1 && doubleColonFound)
                    return false;
                doubleColonFound = true;
            }

            pos = end + 1;
            ++segmentCount;
        }

        return segmentCount == 8 || doubleColonFound;
    }

    private static boolean isParseableIPv6Segment(String s, int pos, int end) {
        return isParseable(s, pos, end, 16, 4, true, 0x0000, 0xFFFF);
    }

    private static boolean isParseable(String s, int pos, int end, int radix,
                                       int maxLength, boolean allowLeadingZero,
                                       int minValue, int maxValue) {
        int length = end - pos;
        if (length < 1 | length > maxLength)
            return false;

        boolean checkLeadingZero = length > 1 & !allowLeadingZero;
        if (checkLeadingZero && Character.digit(s.charAt(pos), radix) <= 0)
            return false;

        int value = 0;
        while (pos < end) {
            char c = s.charAt(pos++);
            int d = Character.digit(c, radix);
            if (d < 0)
            {
                return false;
            }

            value *= radix;
            value += d;
        }

        return value >= minValue & value <= maxValue;
    }

    @SuppressWarnings("deprecation")
    public static boolean validateIpAddress(String value) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q)
            return (InetAddresses.isNumericAddress(value));
        else {
            Matcher matcher = Patterns.IP_ADDRESS.matcher(value);
            return(matcher.matches());
        }
    }

    // https://mkyong.com/regular-expressions/how-to-validate-ip-address-with-regular-expression/
    private static final Pattern IPV4_PATTERN = Pattern.compile(
            "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\.(?!$)|$)){4}$");

    public static boolean validateIpv4Address(String s) {
        Matcher matcher = IPV4_PATTERN.matcher(s);
        return matcher.matches();
    }

    public static boolean validateIpv6Address(String s) {
        return isValidIPv6(s) && !validateIpv4Address(s);
    }

    public static boolean validateCidr(String value) {
        int slash = value.indexOf('/');
        if (slash < 0)
            return validateIpAddress(value);

        int prefix;
        try {
            prefix = Integer.parseInt(value.substring(slash + 1));
        } catch (NumberFormatException ignored) {
            return false;
        }

        String ip_addr = value.substring(0, slash);
        if (!validateIpAddress(ip_addr))
            return false;

        boolean is_v6 = (ip_addr.indexOf(':') >= 0);
        return (prefix >= 0) &&
                ((is_v6 && (prefix <= 128)) ||
                (!is_v6 && (prefix <= 32)));
    }

    // rough validation
    public static boolean validateHost(String host) {
        int len = host.length();
        if((len < 2) || (len > 67))
            return false;
        if((host.charAt(0) == '-') || (host.charAt(len-1) == '-'))
            return false;
        if(host.matches(".*[A-Z\\s?!=`@].*"))
            return false;
        return true;
    }

    public static String uriToFilePath(Context ctx, Uri uri) {
        if (uri == null)
            return null;

        // https://gist.github.com/r0b0t3d/492f375ec6267a033c23b4ab8ab11e6a
        if (isExternalStorageDocument(uri)) {
            final String docId = DocumentsContract.getDocumentId(uri);
            final String[] split = docId.split(":");
            final String type = split[0];

            if ("primary".equalsIgnoreCase(type))
                return Environment.getExternalStorageDirectory() + "/" + split[1];
        } else if(isDownloadsDocument(uri)) {
            return downloadsUriToPath(ctx, uri);
        } else if("content".equalsIgnoreCase(uri.getScheme()))
            return mediastoreUriToPath(ctx, uri);
        else if ("file".equalsIgnoreCase(uri.getScheme()))
            return uri.getPath();
        return null;
    }

    private static String mediastoreUriToPath(Context ctx, Uri uri) {
        String[] proj = { MediaStore.Files.FileColumns.DATA };
        try(Cursor cursor = ctx.getContentResolver().query(uri, proj, null, null, null)) {
            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
            if(cursor.moveToFirst())
                return cursor.getString(column_index);
        } catch (Exception ignored) {}

        return null;
    }

    private static String downloadsUriToPath(Context ctx, Uri uri) {
        final String id = DocumentsContract.getDocumentId(uri);
        if(id == null)
            return null;

        // Starting with Android O, this "id" is not necessarily a long (row number),
        // but might also be a "raw:/some/file/path" URL
        if (id.startsWith("raw:/")) {
            return Uri.parse(id).getPath();
        } else {
            long id_long;
            try {
                id_long = Long.parseLong(id);
            } catch (NumberFormatException ignored) {
                return null;
            }

            String[] contentUriPrefixesToTry = new String[]{
                    "content://downloads/public_downloads",
                    "content://downloads/my_downloads"
            };
            for (String contentUriPrefix : contentUriPrefixesToTry) {
                final Uri contentUri = ContentUris.withAppendedId(
                        Uri.parse(contentUriPrefix), id_long);
                String path = mediastoreUriToPath(ctx, contentUri);
                if(path != null)
                    return path;
            }
        }

        return null;
    }

    public static boolean isExternalStorageDocument(Uri uri) {
        return "com.android.externalstorage.documents".equals(uri.getAuthority());
    }

    public static boolean isDownloadsDocument(Uri uri) {
        return "com.android.providers.downloads.documents".equals(uri.getAuthority());
    }

    public static class UriStat {
        public String name;
        public long size;
    }

    // NOTE: in Android 7, the file size of a newly written file can be 0/less than actual size
    public static UriStat getUriStat(Context ctx, Uri uri) {
        String uri_str = uri.toString();
        File uriFile = null;

        // in some devices, cursor.isNull(sizeIndex) is true, which causes size to be 0
        // try to resolve the original path and access it as a file
        String fpath = uriToFilePath(ctx, uri);
        if(fpath != null) {
            Log.d(TAG, "getUriStat: resolved to file " + fpath);
            uriFile = new File(fpath);
        } else if(uri_str.startsWith("file://"))
            uriFile = new File(uri_str.substring(7));

        if((uriFile != null) && (uriFile.exists())) {
            // retrieve via file
            UriStat info = new UriStat();
            info.name = uriFile.getName();
            info.size = uriFile.length();
            return info;
        }

        // retrieve via content uri
        // https://developer.android.com/training/secure-file-sharing/retrieve-info.html#RetrieveFileInfo
        try(Cursor cursor = ctx.getContentResolver().query(uri, null, null, null, null)) {
            if((cursor == null) || !cursor.moveToFirst())
                return null;

            UriStat info = new UriStat();

            int sizeIndex = cursor.getColumnIndexOrThrow(OpenableColumns.SIZE);
            int idx = cursor.getColumnIndexOrThrow(OpenableColumns.DISPLAY_NAME);
            info.name = (idx >= 0) ? cursor.getString(idx) : "*unknown*";
            info.size = !cursor.isNull(sizeIndex) ? cursor.getLong(sizeIndex) : -1;

            return info;
        } catch (Exception e) {
            return null;
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.P)
    public static PrivateDnsMode getPrivateDnsMode(@NonNull LinkProperties linkProperties) {
        if(linkProperties.getPrivateDnsServerName() != null)
            return PrivateDnsMode.STRICT;
        else if(linkProperties.isPrivateDnsActive())
            return PrivateDnsMode.OPPORTUNISTIC;
        else
            return PrivateDnsMode.DISABLED;
    }

    /// Enables edge-to-edge. Must be called in all the activities before super.onCreate
    // https://medium.com/androiddevelopers/insets-handling-tips-for-android-15s-edge-to-edge-enforcement-872774e8839b
    public static void enableEdgeToEdge(ComponentActivity activity) {
        EdgeToEdge.enable(activity);

        // use light icons even with the light theme
        Window window = activity.getWindow();
        WindowCompat.getInsetsController(window, window.getDecorView())
                .setAppearanceLightStatusBars(false);
    }

    /// Fixes dispatching of insets to ViewPager2 children
    // https://issuetracker.google.com/issues/145617093#comment10
    public static void fixViewPager2Insets(ViewPager2 pager) {
        AtomicReference<WindowInsetsCompat> lastInsets = new AtomicReference<>();

        ViewCompat.setOnApplyWindowInsetsListener(pager, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());

            // in horizontal orientation, ensure that pager content stays visible
            ViewGroup.MarginLayoutParams mlp = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
            mlp.leftMargin = insets.left;
            mlp.rightMargin = insets.right;
            v.setLayoutParams(mlp);

            var remainingInsets = windowInsets.inset(insets.left, insets.top, insets.right, 0);
            lastInsets.set(remainingInsets);

            return remainingInsets;
        });

        pager.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() {
            @Override
            public void onPageSelected(int position) {
                super.onPageSelected(position);

                // NOTE: this is not very reliable, but postDelayed is necessary to let rendering complete
                new Handler(Looper.getMainLooper()).postDelayed(() -> {
                    View view = pager.getChildAt(0);
                    WindowInsetsCompat insets = lastInsets.get();

                    if ((view != null) && (insets != null) && !insets.isConsumed())
                        // manually dispatch to children
                        ViewCompat.dispatchApplyWindowInsets(view, insets);
                }, 5);
            }
        });
    }

    public static void fixListviewInsetsBottom(ListView lv) {
        ViewCompat.setOnApplyWindowInsetsListener(lv, (v, windowInsets) -> {
            var insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());
            v.setPadding(0, 0, 0, insets.bottom);

            return WindowInsetsCompat.CONSUMED;
        });

        lv.setClipToPadding(false);
    }

    // to be used with tabs_activity_fixed, having tabMode "scrollable"
    public static void fixScrollableTabLayoutInsets(TabLayout tl) {
        ViewCompat.setOnApplyWindowInsetsListener(tl, (v, windowInsets) -> {
            var insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());

            ViewGroup.MarginLayoutParams mlp = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
            mlp.leftMargin = insets.left;
            mlp.rightMargin = insets.right;
            v.setLayoutParams(mlp);

            return windowInsets;
        });
    }

    public static @NonNull Enumeration<NetworkInterface> getNetworkInterfaces() {
        try {
            Enumeration<NetworkInterface> ifs = NetworkInterface.getNetworkInterfaces();
            if(ifs != null)
                return ifs;
        } catch (SocketException | NullPointerException e) {
            // NullPointerException can be thrown on Android < 31 with virtual interface without a
            // parent interface
            e.printStackTrace();
        }

        return Collections.enumeration(new ArrayList<>());
    }

    public static boolean isReadable(String path) {
        try(FileInputStream ignored = new FileInputStream(path)) {
            return true;
        } catch (Exception ignored) {
            return false;
        }
    }

    public static boolean isPcapng(Context ctx, Uri uri) {
        try (InputStream in_stream = ctx.getContentResolver().openInputStream(uri)) {
            try (DataInputStream data_in = new DataInputStream(in_stream)) {
                int block_type = data_in.readInt();
                data_in.skipBytes(4);
                int magic = data_in.readInt();

                return ((block_type == 0x0A0D0D0A) &&
                        ((magic == 0x1a2b3c4d) || (magic == 0x4d3c2b1a)));
            }
        } catch (IOException | RuntimeException e) {
            Log.w(TAG, "Reading " + uri + " failed: " + e);
        }

        return false;
    }

    public static int getMajorVersion(String ver) {
        int start_idx = 0;

        // optionally starts with "v"
        if (ver.startsWith("v"))
            start_idx = 1;

        int end_idx = ver.indexOf('.');
        if (end_idx < 0)
            return -1;

        try {
            return Integer.parseInt(ver.substring(start_idx, end_idx));
        } catch (NumberFormatException ignored) {
            return -1;
        }
    }

    // true if the two provided versions are semantically compatible (i.e. same major)
    public static boolean isSemanticVersionCompatible(String a, String b) {
        int va = getMajorVersion(a);
        return (va >= 0) && (va == getMajorVersion(b));
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/VpnReconnectService.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-24 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ServiceInfo;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.core.app.NotificationCompat;
import androidx.core.content.ContextCompat;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.activities.MainActivity;
import com.emanuelef.remote_capture.model.CaptureSettings;

/**
 * Service which waits for other apps VPNService to terminate before
 * restarting the capture.
 */
@RequiresApi(api = Build.VERSION_CODES.M)
public class VpnReconnectService extends Service {
    private static final String TAG = "VpnReconnectService";
    private static final String NOTIFY_CHAN_VPNRECONNECT = "VPN Reconnection";
    public static final int NOTIFY_ID_VPNRECONNECT = 10;
    private static final String STOP_ACTION = "stop";

    private static VpnReconnectService INSTANCE;
    private Handler mHandler;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private Network mActiveVpnNetwork;

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        Log.d(TAG, "onCreate");
        mHandler = new Handler(Looper.getMainLooper());

        INSTANCE = this;
        super.onCreate();
    }

    @Override
    public void onDestroy() {
        Log.d(TAG, "onDestroy");

        unregisterNetworkCallback();
        INSTANCE = null;
        super.onDestroy();
    }

    @Override
    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand");

        if ((intent != null) && (intent.getAction() != null) && (intent.getAction().equals(STOP_ACTION))) {
            Utils.showToastLong(this, R.string.vpn_reconnection_aborted);
            stopService();
            return START_NOT_STICKY;
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
            startForeground(NOTIFY_ID_VPNRECONNECT, buildNotification(), ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE);
        else
            startForeground(NOTIFY_ID_VPNRECONNECT, buildNotification());

        mHandler.postDelayed(() -> {
            Log.i(TAG, "Could not detect a VPN within the timeout, automatic reconnection aborted");
            stopService();
        }, 10000);

        if (!registerNetworkCallbacks()) {
            stopService();
            return START_NOT_STICKY;
        }

        return START_STICKY;
    }

    private Notification buildNotification() {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);

            NotificationChannel chan = new NotificationChannel(NOTIFY_CHAN_VPNRECONNECT,
                    NOTIFY_CHAN_VPNRECONNECT, NotificationManager.IMPORTANCE_LOW); // low: no sound
            chan.setShowBadge(false);
            nm.createNotificationChannel(chan);
        }

        // Status notification builder
        PendingIntent startMainApp = PendingIntent.getActivity(this, 0,
                new Intent(this, MainActivity.class), Utils.getIntentFlags(PendingIntent.FLAG_UPDATE_CURRENT));

        Intent abortReconnectIntent = new Intent(this, VpnReconnectService.class);
        abortReconnectIntent.setAction(STOP_ACTION);
        PendingIntent abortReconnect = PendingIntent.getService(this, 0, abortReconnectIntent, Utils.getIntentFlags(0));

        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFY_CHAN_VPNRECONNECT)
                .setSmallIcon(R.drawable.ic_logo)
                .setColor(ContextCompat.getColor(this, R.color.colorPrimary))
                .setContentIntent(startMainApp)
                .setDeleteIntent(abortReconnect)
                .setOngoing(true)
                .setAutoCancel(false)
                .setContentTitle(getString(R.string.vpn_reconnection))
                .setContentText(getString(R.string.waiting_for_vpn_disconnect))
                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                .setCategory(NotificationCompat.CATEGORY_STATUS)
                .setPriority(NotificationCompat.PRIORITY_LOW); // see IMPORTANCE_LOW

        Log.d(TAG, "running");
        return builder.build();
    }

    private void checkAvailableNetwork(ConnectivityManager cm, Network network) {
        if (network.equals(mActiveVpnNetwork))
            return;

        NetworkCapabilities cap = cm.getNetworkCapabilities(network);
        if ((cap != null) && cap.hasTransport(NetworkCapabilities.TRANSPORT_VPN)) {
            mActiveVpnNetwork = network;
            Log.d(TAG, "Detected active VPN network: " + mActiveVpnNetwork);

            // cancel the deadline timer / onLost timer
            mHandler.removeCallbacksAndMessages(null);
        }
    }

    private boolean registerNetworkCallbacks() {
        ConnectivityManager cm = (ConnectivityManager) getSystemService(Service.CONNECTIVITY_SERVICE);

        mNetworkCallback = new ConnectivityManager.NetworkCallback() {
            @Override
            public void onAvailable(@NonNull Network network) {
                Log.d(TAG, "onAvailable: " + network);

                checkAvailableNetwork(cm, network);
            }

            @Override
            public void onLost(@NonNull Network network) {
                Log.d(TAG, "onLost: " + network);

                // NOTE: when onLost is called, the TRANSPORT_VPN capability may already have been removed
                if (network.equals(mActiveVpnNetwork)) {
                    // NOTE: onAvailable and onLost may be called multiple times before the actual VPN is started.
                    // Use a debounce delay to prevent mis-detection
                    mHandler.postDelayed(() -> {
                        Log.i(TAG, "Active VPN disconnected, starting the capture");
                        unregisterNetworkCallback();

                        Context ctx = VpnReconnectService.this;
                        CaptureSettings settings = new CaptureSettings(ctx, PreferenceManager.getDefaultSharedPreferences(ctx));

                        CaptureHelper helper = new CaptureHelper(ctx);
                        helper.setListener(success -> stopService());
                        helper.startCapture(settings);
                    }, 3000);
                }
            }
        };

        try {
            Log.d(TAG, "registerNetworkCallback");

            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN);

            // necessary to see other apps network events on Android 12+
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S)
                builder.setIncludeOtherUidNetworks(true);

            cm.registerNetworkCallback(builder.build(), mNetworkCallback);
        } catch (SecurityException e) {
            // this is a bug in Android 11 - https://issuetracker.google.com/issues/175055271?pli=1
            e.printStackTrace();

            Log.e(TAG, "registerNetworkCallback failed");
            mNetworkCallback = null;
            return false;
        }

        // The VPN may already be active
        Network net = Utils.getRunningVpn(this);
        if (net != null)
            checkAvailableNetwork(cm, net);

        return true;
    }

    private void unregisterNetworkCallback() {
        if(mNetworkCallback != null) {
            ConnectivityManager cm = (ConnectivityManager) getSystemService(Service.CONNECTIVITY_SERVICE);

            try {
                Log.d(TAG, "unregisterNetworkCallback");
                cm.unregisterNetworkCallback(mNetworkCallback);
            } catch(IllegalArgumentException e) {
                Log.w(TAG, "unregisterNetworkCallback failed: " + e);
            }

            mNetworkCallback = null;
        }
    }

    @SuppressLint("ObsoleteSdkInt")
    @RequiresApi(api = Build.VERSION_CODES.BASE)
    public static boolean isAvailable() {
        return android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M;
    }

    @SuppressWarnings("deprecation")
    public static void stopService() {
        Log.d(TAG, "stopService called");
        VpnReconnectService service = INSTANCE;
        if (service == null)
            return;

        service.unregisterNetworkCallback();

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
            service.stopForeground(STOP_FOREGROUND_REMOVE);
        else
            service.stopForeground(true);

        service.stopSelf();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/WebSocketDecoder.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.util.Log;

import com.emanuelef.remote_capture.model.PayloadChunk;

import java.io.ByteArrayOutputStream;
import java.util.ArrayList;

// RFC 6455 WebSocket frame decoder
public class WebSocketDecoder {
    private static final String TAG = "WebSocketDecoder";

    // RFC 6455 Section 5.2
    public static final int OPCODE_CONTINUATION = 0x0;
    public static final int OPCODE_TEXT = 0x1;
    public static final int OPCODE_BINARY = 0x2;
    public static final int OPCODE_CLOSE = 0x8;
    public static final int OPCODE_PING = 0x9;
    public static final int OPCODE_PONG = 0xA;

    private static final int MAX_PENDING_CHUNKS = 100;
    private static final int MAX_FRAME_SIZE = 16 * 1024 * 1024;
    private static final int MAX_FRAGMENT_SIZE = 64 * 1024 * 1024;

    public enum ParseStatus {
        INCOMPLETE,
        SUCCESS,
        ERROR
    }

    public static class FrameParseResult {
        public ParseStatus status;
        public int opcode;
        public boolean fin;
        public byte[] payload;
        public int bytesConsumed;
        public String errorMessage;

        static FrameParseResult incomplete() {
            FrameParseResult r = new FrameParseResult();
            r.status = ParseStatus.INCOMPLETE;
            return r;
        }

        static FrameParseResult success(int opcode, boolean fin, byte[] payload, int bytesConsumed) {
            FrameParseResult r = new FrameParseResult();
            r.status = ParseStatus.SUCCESS;
            r.opcode = opcode;
            r.fin = fin;
            r.payload = payload;
            r.bytesConsumed = bytesConsumed;
            return r;
        }

        static FrameParseResult error(String message) {
            FrameParseResult r = new FrameParseResult();
            r.status = ParseStatus.ERROR;
            r.errorMessage = message;
            return r;
        }
    }

    public interface DecodedFrameListener {
        void onWebSocketFrame(PayloadChunk decoded);
    }

    private final DecodedFrameListener mListener;

    // Pending chunks waiting to form a complete frame
    private final ArrayList<PayloadChunk> mPendingChunks = new ArrayList<>();
    private int mPendingOffset;

    // Fragment reassembly state (for FIN=0 messages)
    private ByteArrayOutputStream mFragmentBuffer;
    private int mFragmentOpcode = -1;
    private long mFragmentTimestamp;
    private int mFragmentStreamId;

    public WebSocketDecoder(DecodedFrameListener listener) {
        mListener = listener;
    }

    public void handleChunk(PayloadChunk chunk) {
        if ((chunk.payload == null) || (chunk.payload.length == 0))
            return;

        if (mPendingChunks.size() >= MAX_PENDING_CHUNKS) {
            Log.w(TAG, "Too many pending chunks, emitting as raw");
            emitPendingAsRaw();
        }

        int pendingBytes = getTotalPendingBytes();
        if ((pendingBytes + chunk.payload.length) > MAX_FRAME_SIZE) {
            Log.w(TAG, "Pending bytes limit exceeded, emitting as raw");
            emitPendingAsRaw();
        }

        mPendingChunks.add(chunk);

        while (true) {
            FrameParseResult result = parseFrame(chunk.is_sent);

            if (result.status == ParseStatus.INCOMPLETE)
                break;

            if (result.status == ParseStatus.ERROR) {
                Log.w(TAG, "Frame parse error: " + result.errorMessage);
                emitPendingAsRaw();
                break;
            }

            consumeBytes(result.bytesConsumed);
            handleParsedFrame(result, chunk);
        }
    }

    private FrameParseResult parseFrame(boolean isSent) {
        int available = getTotalPendingBytes();

        if (available < 2)
            return FrameParseResult.incomplete();

        int byte0 = readByte(0) & 0xFF;
        int byte1 = readByte(1) & 0xFF;

        boolean fin = (byte0 & 0x80) != 0;
        int rsv = (byte0 >> 4) & 0x07;
        int opcode = byte0 & 0x0F;
        boolean masked = (byte1 & 0x80) != 0;
        int payloadLen = byte1 & 0x7F;

        if (rsv != 0)
            Log.d(TAG, "RSV bits set: " + rsv + " (might be extension)");

        if (isSent && !masked)
            Log.w(TAG, "Client frame should be masked but isn't");
        else if (!isSent && masked)
            Log.w(TAG, "Server frame should not be masked but is");

        int headerSize = 2;
        long actualPayloadLen = payloadLen;

        if (payloadLen == 126) {
            headerSize += 2;
            if (available < headerSize)
                return FrameParseResult.incomplete();
            actualPayloadLen = ((readByte(2) & 0xFF) << 8) | (readByte(3) & 0xFF);
        } else if (payloadLen == 127) {
            headerSize += 8;
            if (available < headerSize)
                return FrameParseResult.incomplete();
            actualPayloadLen = 0;
            for (int i = 0; i < 8; i++)
                actualPayloadLen = (actualPayloadLen << 8) | (readByte(2 + i) & 0xFF);
            if (actualPayloadLen < 0)
                return FrameParseResult.error("Payload length overflow");
        }

        if (actualPayloadLen > MAX_FRAME_SIZE)
            return FrameParseResult.error("Payload too large: " + actualPayloadLen);

        // RFC 6455 Section 5.5: Control frame validation
        if (opcode >= OPCODE_CLOSE) {
            if (!fin)
                Log.w(TAG, "Control frame with FIN=0 (RFC violation: control frames MUST NOT be fragmented)");
            if (actualPayloadLen > 125)
                Log.w(TAG, "Control frame payload " + actualPayloadLen + " > 125 bytes (RFC violation)");
        }

        byte[] maskingKey = null;
        if (masked) {
            if (available < (headerSize + 4))
                return FrameParseResult.incomplete();
            maskingKey = new byte[4];
            for (int i = 0; i < 4; i++)
                maskingKey[i] = readByte(headerSize + i);
            headerSize += 4;
        }

        int totalFrameSize = headerSize + (int) actualPayloadLen;
        if (available < totalFrameSize)
            return FrameParseResult.incomplete();

        byte[] payload = new byte[(int) actualPayloadLen];
        for (int i = 0; i < actualPayloadLen; i++)
            payload[i] = readByte(headerSize + i);

        if (masked)
            unmaskPayload(payload, maskingKey);

        return FrameParseResult.success(opcode, fin, payload, totalFrameSize);
    }

    private void handleParsedFrame(FrameParseResult result, PayloadChunk originalChunk) {
        int opcode = result.opcode;
        boolean fin = result.fin;
        byte[] payload = result.payload;

        // Control frames are always complete and can be interleaved with fragments
        if (opcode >= OPCODE_CLOSE) {
            emitFrame(opcode, fin, payload, false, originalChunk);
            return;
        }

        if ((opcode != OPCODE_CONTINUATION) && !fin) {
            if (mFragmentBuffer != null)
                Log.w(TAG, "New fragment started while previous incomplete");
            mFragmentBuffer = new ByteArrayOutputStream();
            mFragmentOpcode = opcode;
            mFragmentTimestamp = originalChunk.timestamp;
            mFragmentStreamId = originalChunk.stream_id;
            try {
                mFragmentBuffer.write(payload);
            } catch (Exception e) {
                Log.e(TAG, "Error writing to fragment buffer", e);
            }
            return;
        }

        if (opcode == OPCODE_CONTINUATION) {
            if (mFragmentBuffer == null) {
                Log.w(TAG, "Continuation frame without start");
                emitFrame(opcode, fin, payload, false, originalChunk);
                return;
            }

            if ((mFragmentBuffer.size() + payload.length) > MAX_FRAGMENT_SIZE) {
                Log.w(TAG, "Fragment size limit exceeded");
                mFragmentBuffer = null;
                return;
            }

            try {
                mFragmentBuffer.write(payload);
            } catch (Exception e) {
                Log.e(TAG, "Error writing to fragment buffer", e);
            }

            if (fin) {
                byte[] reassembled = mFragmentBuffer.toByteArray();
                PayloadChunk chunk = createDecodedChunk(
                    mFragmentOpcode, true, reassembled, true,
                    originalChunk.is_sent, mFragmentTimestamp, mFragmentStreamId
                );
                mFragmentBuffer = null;
                mFragmentOpcode = -1;
                mListener.onWebSocketFrame(chunk);
            }
            return;
        }

        emitFrame(opcode, fin, payload, false, originalChunk);
    }

    private void emitFrame(int opcode, boolean fin, byte[] payload, boolean wasFragmented, PayloadChunk originalChunk) {
        PayloadChunk chunk = createDecodedChunk(
            opcode, fin, payload, wasFragmented,
            originalChunk.is_sent, originalChunk.timestamp, originalChunk.stream_id
        );
        mListener.onWebSocketFrame(chunk);
    }

    private PayloadChunk createDecodedChunk(int opcode, boolean fin, byte[] payload, boolean wasFragmented,
                                            boolean isSent, long timestamp, int streamId) {
        PayloadChunk chunk = new PayloadChunk(payload, PayloadChunk.ChunkType.WEBSOCKET, isSent, timestamp, streamId);
        chunk.wsOpcode = opcode;
        chunk.wsIsFinal = fin;
        chunk.wsWasFragmented = wasFragmented;
        return chunk;
    }

    private void emitPendingAsRaw() {
        for (PayloadChunk chunk : mPendingChunks) {
            chunk.type = PayloadChunk.ChunkType.RAW;
            chunk.wsOpcode = -1;
            mListener.onWebSocketFrame(chunk);
        }
        mPendingChunks.clear();
        mPendingOffset = 0;
    }

    private int getTotalPendingBytes() {
        int total = -mPendingOffset;
        for (PayloadChunk c : mPendingChunks)
            total += c.payload.length;
        return total;
    }

    private byte readByte(int pos) {
        int remaining = pos;
        boolean first = true;
        for (PayloadChunk c : mPendingChunks) {
            int start = first ? mPendingOffset : 0;
            int available = c.payload.length - start;
            if (remaining < available)
                return c.payload[start + remaining];
            remaining -= available;
            first = false;
        }
        throw new IndexOutOfBoundsException("Position " + pos + " out of bounds");
    }

    private void consumeBytes(int count) {
        while ((count > 0) && !mPendingChunks.isEmpty()) {
            PayloadChunk first = mPendingChunks.get(0);
            int available = first.payload.length - mPendingOffset;
            if (count >= available) {
                mPendingChunks.remove(0);
                mPendingOffset = 0;
                count -= available;
            } else {
                mPendingOffset += count;
                count = 0;
            }
        }
    }

    private static void unmaskPayload(byte[] payload, byte[] maskingKey) {
        for (int i = 0; i < payload.length; i++)
            payload[i] = (byte) (payload[i] ^ maskingKey[i % 4]);
    }

    public static boolean isControlOpcode(int opcode) {
        return opcode >= OPCODE_CLOSE;
    }

    public static boolean isValidOpcode(int opcode) {
        return (opcode == OPCODE_CONTINUATION) ||
               (opcode == OPCODE_TEXT) ||
               (opcode == OPCODE_BINARY) ||
               (opcode == OPCODE_CLOSE) ||
               (opcode == OPCODE_PING) ||
               (opcode == OPCODE_PONG);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/ZstdDecoder.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import java.io.IOException;

public class ZstdDecoder {
    static {
        System.loadLibrary("zstd_dec");
    }

    /**
     * Decompress a zstd-compressed byte array.
     * @param src the compressed data
     * @return the decompressed data
     * @throws IOException on decompression error
     */
    public static native byte[] decompress(byte[] src) throws IOException;
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/AboutActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.app.Service;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.ConnectivityManager;
import android.net.LinkProperties;
import android.net.Network;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.SystemClock;
import android.text.method.LinkMovementMethod;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.core.content.ContextCompat;
import androidx.core.graphics.Insets;
import androidx.core.text.HtmlCompat;
import androidx.core.view.MenuProvider;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;

import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.MitmAddon;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.Prefs;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.net.ssl.HttpsURLConnection;

import androidmads.library.qrgenearator.QRGContents;
import androidmads.library.qrgenearator.QRGEncoder;

public class AboutActivity extends BaseActivity implements MenuProvider {
    private static final String TAG = "AboutActivity";
    private ExecutorService mQrReqExecutor;
    private HttpsURLConnection mQrCon;
    private boolean mDialogClosing = false;
    private long mQrStartTime = 0;
    private long mQrDeadline = 0;
    private Handler mHandler;
    private AlertDialog mLicenseDialog;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.about);
        setContentView(R.layout.about_activity);
        addMenuProvider(this);

        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.scrollView), (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());
            v.setPadding(insets.left, insets.top, insets.right, 0);

            return WindowInsetsCompat.CONSUMED;
        });

        mHandler = new Handler(Looper.getMainLooper());
        TextView appVersion = findViewById(R.id.app_version);
        appVersion.setText("PCAPdroid " + Utils.getAppVersion(this));

        ((TextView)findViewById(R.id.app_license)).setMovementMethod(LinkMovementMethod.getInstance());
        ((TextView)findViewById(R.id.opensource_licenses)).setMovementMethod(LinkMovementMethod.getInstance());

        TextView wsLicenses = findViewById(R.id.wireshark_licenses);
        wsLicenses.setMovementMethod(LinkMovementMethod.getInstance());
        wsLicenses.setVisibility(PCAPdroid.getInstance().isUsharkAvailable() ? View.VISIBLE : View.GONE);

        TextView sourceLink = findViewById(R.id.app_source_link);
        String localized = sourceLink.getText().toString();
        sourceLink.setText(HtmlCompat.fromHtml("<a href='" + MainActivity.GITHUB_PROJECT_URL + "'>" + localized + "</a>", HtmlCompat.FROM_HTML_MODE_LEGACY));
        sourceLink.setMovementMethod(LinkMovementMethod.getInstance());
    }

    @Override
    protected void onStop() {
        stopQrExecutor();
        super.onStop();
    }

    private void stopQrExecutor() {
        // necessary to interrupt the executor thread
        if(mQrCon != null)
            mQrCon.disconnect();
        mQrCon = null;

        if(mQrReqExecutor != null)
            mQrReqExecutor.shutdownNow();
        mQrReqExecutor = null;

        mHandler.removeCallbacksAndMessages(null);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.about_menu, menu);

        Billing billing = Billing.newInstance(this);
        if(billing.isPlayStore())
            menu.findItem(R.id.paid_features).setVisible(false);
    }

    @Override
    public boolean onMenuItemSelected(MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.paid_features) {
            showLicenseDialog();
            return true;
        } else if(id == R.id.on_boarding) {
            Intent intent = new Intent(this, OnBoardingActivity.class);
            intent.putExtra(OnBoardingActivity.ENABLE_BACK_BUTTON, true);
            startActivity(intent);
            return true;
        } else if(id == R.id.build_info) {
            String deviceInfo = Utils.getBuildInfo(this) + "\n\n" +
                    Prefs.asString(this);

            // Private DNS
            Utils.PrivateDnsMode dns_mode = CaptureService.getPrivateDnsMode();
            if(dns_mode == null) {
                if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                    ConnectivityManager cm = (ConnectivityManager) getSystemService(Service.CONNECTIVITY_SERVICE);
                    Network net = cm.getActiveNetwork();

                    if(net != null) {
                        LinkProperties lp = cm.getLinkProperties(net);
                        if (lp != null)
                            dns_mode = Utils.getPrivateDnsMode(lp);
                    }
                }
            }

            if(dns_mode != null)
                deviceInfo += "\n" + "PrivateDnsMode: " + dns_mode;

            String mitm_version = MitmAddon.getInstalledVersionName(this);
            if (!mitm_version.isEmpty()) {
                deviceInfo += "\n" + "MitmAddonVersion: " + mitm_version;
                deviceInfo += "\n" + "MitmBatteryOptimized: " + (MitmAddon.isDozeEnabled(this) ? "true" : "false");
            }

            LayoutInflater inflater = LayoutInflater.from(this);
            View view = inflater.inflate(R.layout.scrollable_dialog, null);
            ((TextView)view.findViewById(R.id.text)).setText(deviceInfo);

            final String deviceInfoStr = deviceInfo;
            new AlertDialog.Builder(this)
                    .setTitle(R.string.build_info)
                    .setView(view)
                    .setPositiveButton(R.string.ok, (dialogInterface, i) -> {})
                    .setNeutralButton(R.string.copy_to_clipboard, (dialogInterface, i) ->
                            Utils.copyToClipboard(this, deviceInfoStr)).show();
            return true;
        }

        return false;
    }

    private void showLicenseDialog() {
        Billing billing = Billing.newInstance(this);
        LayoutInflater inflater = getLayoutInflater();
        final View content = inflater.inflate(R.layout.license_dialog, null);

        String instId = billing.getInstallationId();
        TextView instIdText = content.findViewById(R.id.installation_id);
        instIdText.setText(instId);

        mDialogClosing = false;
        final View showQr = content.findViewById(R.id.show_qr_code);
        showQr.setOnClickListener(v -> showQrCode(content, instId));

        if(Utils.isTv(this) && !billing.isPurchased(Billing.SUPPORTER_SKU)) {
            instIdText.setOnClickListener(v -> Utils.shareText(this, getString(R.string.installation_id), instId));
            showQrCode(content, instId);
        }

        TextView validationRc = content.findViewById(R.id.validation_rc);
        EditText licenseCode = content.findViewById(R.id.license_code);
        licenseCode.setText(billing.getLicense());
        Utils.setTextUrls((content.findViewById(R.id.paid_features_msg)), R.string.access_paid_features_msg, MainActivity.PAID_FEATURES_URL);

        content.findViewById(R.id.copy_id).setOnClickListener(v -> Utils.copyToClipboard(this, instId));

        mLicenseDialog = new AlertDialog.Builder(this)
                .setView(content)
                .setPositiveButton(R.string.ok, (dialog, whichButton) -> {
                    boolean was_valid = billing.isPurchased(Billing.SUPPORTER_SKU);
                    billing.setLicense(licenseCode.getText().toString());

                    if(!was_valid && billing.isPurchased(Billing.SUPPORTER_SKU))
                        Utils.showToastLong(this, R.string.paid_features_unlocked);
                })
                .setOnDismissListener(dialog -> {
                    mDialogClosing = true;
                    mLicenseDialog = null;
                    stopQrExecutor();
                })
                .setNeutralButton(R.string.validate, (dialog, which) -> {}) // see below
                .create();

        mLicenseDialog.show();
        mLicenseDialog.getButton(AlertDialog.BUTTON_NEUTRAL).setOnClickListener(v -> {
            boolean valid = billing.isValidLicense(licenseCode.getText().toString());
            validationRc.setText(valid ? R.string.valid : R.string.invalid);
            validationRc.setTextColor(ContextCompat.getColor(this, valid ? R.color.ok : R.color.danger));
        });
        mLicenseDialog.getWindow().setLayout(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
    }

    private void showQrCode(View dialog, String instId) {
        View qrBox = dialog.findViewById(R.id.qr_box);
        View qrLoading = dialog.findViewById(R.id.qr_code_loading);
        View showQr = dialog.findViewById(R.id.show_qr_code);
        View qrInfo = dialog.findViewById(R.id.qr_info_text);

        showQr.setVisibility(View.GONE);
        qrLoading.setVisibility(View.VISIBLE);
        qrBox.setVisibility(View.GONE);
        qrInfo.setVisibility(View.GONE);

        mQrReqExecutor = Executors.newSingleThreadExecutor();
        Handler handler = new Handler(Looper.getMainLooper());

        // start activation
        mQrReqExecutor.execute(() -> {
            try {
                URL url = new URL(Utils.PCAPDROID_WEBSITE + "/getlicense/qr_activation");
                HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
                mQrCon = con;

                try {
                    con.setRequestProperty("User-Agent", Utils.getAppVersionString());
                    con.setRequestMethod("POST");
                    con.setUseCaches(false);
                    con.setAllowUserInteraction(false);
                    con.setDoInput(true);
                    con.setDoOutput(true);
                    con.setConnectTimeout(5000);

                    // Send POST request
                    try (BufferedOutputStream os = new BufferedOutputStream(con.getOutputStream())) {
                        os.write(("installation_id=" + instId).getBytes());
                    }

                    int rc = con.getResponseCode();
                    Log.d(TAG, "QR HTTP response: " + rc);
                    if (rc != 200) {
                        handler.post(() ->
                                hideQrCode(dialog, "QR request failed with code " + rc));
                        return;
                    }

                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {
                        // Step 1: get QR request ID
                        String timeout_s = parseSseLine(reader.readLine());
                        String qr_req_id = parseSseLine(reader.readLine());
                        if ((qr_req_id == null) || (timeout_s == null)) {
                            handler.post(() ->
                                    hideQrCode(dialog, "Invalid QR request ID"));
                            return;
                        }
                        int timeout_ms = Integer.parseInt(timeout_s) * 1000;
                        long deadline = SystemClock.elapsedRealtime() + timeout_ms;
                        Log.d(TAG, "QR request_id=" + qr_req_id + ", timeout=" + timeout_ms + " ms");

                        // Step 2: generate QR code
                        Bitmap qrBitmap = genQrCode(instId, qr_req_id);
                        handler.post(() -> onQrRequestReady(dialog, qrBitmap, deadline));

                        // Step 3: wait license
                        String license = parseSseLine(reader.readLine());
                        if(license == null) {
                            handler.post(() ->
                                hideQrCode(dialog, getString(R.string.qr_code_expired)));
                            return;
                        }
                        handler.post(() -> onQrLicenseReceived(dialog, license));
                    }
                } finally {
                    con.disconnect();
                }
            } catch (IOException | NumberFormatException e) {
                e.printStackTrace();

                handler.post(() -> {
                    if(e instanceof EOFException)
                        hideQrCode(dialog, getString(R.string.qr_code_expired));
                    else
                        hideQrCode(dialog, getString(R.string.connection_error, e.getMessage()));
                });
            }
        });
    }

    private String parseSseLine(String line) {
        if(line == null)
            return null;

        if(line.startsWith("data: "))
            line = line.substring(6);
        return line;
    }

    private Bitmap genQrCode(String instId, String qrReqId) {
        float maxDp = 180f;
        int maxPx = (int) TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                maxDp,
                getResources().getDisplayMetrics()
        );
        int smallerDimension = Math.min(Utils.getSmallerDisplayDimension(this) / 2, maxPx);

        String device_name = Utils.getDeviceName(this);
        if(device_name == null)
            device_name = Utils.getDeviceModel();

        String qrData = "pcapdroid://get_license?installation_id="+ instId +"&qr_request_id=" + qrReqId + "&device=" + Uri.encode(device_name);
        Log.d(TAG, "QR activation URI: " + qrData);

        QRGEncoder qrgEncoder = new QRGEncoder(qrData, null, QRGContents.Type.TEXT, smallerDimension);
        return qrgEncoder.getBitmap(0);
    }

    private void onQrRequestReady(View dialog, Bitmap qrcode, long deadline) {
        View qrBox = dialog.findViewById(R.id.qr_box);
        ImageView qrImage = dialog.findViewById(R.id.qr_code);
        View qrLoading = dialog.findViewById(R.id.qr_code_loading);
        View qrInfo = dialog.findViewById(R.id.qr_info_text);

        mQrStartTime = SystemClock.elapsedRealtime();
        mQrDeadline = deadline;
        updateQrProgress(dialog);

        qrImage.setImageBitmap(qrcode);
        qrBox.setVisibility(View.VISIBLE);
        qrInfo.setVisibility(View.VISIBLE);
        qrLoading.setVisibility(View.GONE);
    }

    private void updateQrProgress(View dialog) {
        ProgressBar qrProgress = dialog.findViewById(R.id.qr_remaining_time);
        if(qrProgress == null)
            return;

        long interval = mQrDeadline - mQrStartTime;
        int progress = Math.min((int)((SystemClock.elapsedRealtime() - mQrStartTime) * 100 / interval), 100);
        qrProgress.setProgress(100 - progress);

        mHandler.postDelayed(() -> updateQrProgress(dialog), 1000);
    }

    private void onQrLicenseReceived(View dialog, String license) {
        EditText licenseCode = dialog.findViewById(R.id.license_code);
        Billing billing = Billing.newInstance(this);
        boolean was_valid = billing.isPurchased(Billing.SUPPORTER_SKU);

        if(billing.setLicense(license)) {
            licenseCode.setText(license);

            Utils.showToast(this, R.string.license_activation_ok);
            if(!was_valid)
                Utils.showToastLong(this, R.string.paid_features_unlocked);

            hideQrCode(dialog, null);
            if(mLicenseDialog != null)
                mLicenseDialog.dismiss();
        } else
            hideQrCode(dialog, getString(R.string.invalid_license));
    }

    private void hideQrCode(View dialog, @Nullable String error_msg) {
        View showQr = dialog.findViewById(R.id.show_qr_code);
        View qrLoading = dialog.findViewById(R.id.qr_code_loading);
        View qrBox = dialog.findViewById(R.id.qr_box);
        View qrInfo = dialog.findViewById(R.id.qr_info_text);

        qrBox.setVisibility(View.GONE);
        qrInfo.setVisibility(View.GONE);
        qrLoading.setVisibility(View.GONE);
        showQr.setVisibility(View.VISIBLE);

        if((error_msg != null) && !mDialogClosing)
            Toast.makeText(this, error_msg, Toast.LENGTH_LONG).show();

        stopQrExecutor();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/AppDetailsActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.content.Intent;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.recyclerview.widget.RecyclerView;
import androidx.viewpager2.adapter.FragmentStateAdapter;
import androidx.viewpager2.widget.ViewPager2;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.fragments.AppOverview;
import com.emanuelef.remote_capture.fragments.ConnectionsFragment;
import com.emanuelef.remote_capture.model.FilterDescriptor;
import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;

public class AppDetailsActivity extends BaseActivity {
    private static final String TAG = "AppDetailsActivity";
    public static final String APP_UID_EXTRA = "app_uid";
    private ViewPager2 mPager;
    private int mUid;

    private static final int POS_OVERVIEW = 0;
    private static final int POS_CONNECTIONS = 1;
    private static final int POS_TOTAL = 2;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.app_details);
        displayBackAction();
        setContentView(R.layout.tabs_activity);

        mUid = getIntent().getIntExtra(APP_UID_EXTRA, Utils.UID_UNKNOWN);
        setupUidFilter();

        mPager = findViewById(R.id.pager);
        Utils.fixViewPager2Insets(mPager);
        setupTabs();
    }

    private void setupUidFilter() {
        Intent intent = getIntent();
        if(intent == null) {
            intent = new Intent();
            setIntent(intent);
        }

        FilterDescriptor filter = new FilterDescriptor();
        filter.uid = mUid;
        intent.putExtra(ConnectionsFragment.FILTER_EXTRA, filter);
    }

    private class StateAdapter extends FragmentStateAdapter {
        StateAdapter(final FragmentActivity fa) { super(fa); }

        @NonNull
        @Override
        public Fragment createFragment(int position) {
            //Log.d(TAG, "createFragment");
            switch (position) {
                case POS_CONNECTIONS:
                    // APP_UID_EXTRA is passed (see setupUidFilter)
                    return new ConnectionsFragment();
                case POS_OVERVIEW:
                default:
                    return AppOverview.newInstance(mUid);
            }
        }

        @Override
        public int getItemCount() {
            return POS_TOTAL;
        }

        public int getPageTitle(final int position) {
            switch(position) {
                case POS_CONNECTIONS:
                    return R.string.connections_view;
                case POS_OVERVIEW:
                default:
                    return R.string.overview;
            }
        }
    }

    private void setupTabs() {
        StateAdapter pageAdapter = new StateAdapter(this);
        mPager.setAdapter(pageAdapter);

        new TabLayoutMediator(findViewById(R.id.tablayout), mPager, (tab, position) ->
                tab.setText(getString(pageAdapter.getPageTitle(position)))
        ).attach();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // This is required to properly handle the DPAD down press on Android TV, to properly
        // focus the tab content
        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
            View view = getCurrentFocus();

            Log.d(TAG, "onKeyDown focus " + view.getClass().getName());

            if (view instanceof TabLayout.TabView) {
                int pos = mPager.getCurrentItem();
                View focusOverride = null;

                Log.d(TAG, "TabLayout.TabView focus pos " + pos);

                if (pos == POS_OVERVIEW)
                    focusOverride = findViewById(R.id.app_overview);
                else if (pos == POS_CONNECTIONS)
                    focusOverride = findViewById(R.id.connections);

                if (focusOverride != null) {
                    focusOverride.requestFocus();
                    return true;
                }
            }
        } else if(keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
            // Clicking "right" from the connections view goes to the fab down item
            if (mPager.getCurrentItem() == POS_CONNECTIONS) {
                RecyclerView rview = findViewById(R.id.connections_view);

                if (rview.getFocusedChild() != null) {
                    Log.d(TAG, "onKeyDown (right) focus " + rview.getFocusedChild());

                    View fab = findViewById(R.id.fabDown);

                    if (fab != null) {
                        fab.requestFocus();
                        return true;
                    }
                }
            }
        }

        return super.onKeyDown(keyCode, event);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/AppFilterActivity.java`:

```java
package com.emanuelef.remote_capture.activities;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.collection.ArraySet;
import androidx.core.view.MenuProvider;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.fragments.AppsToggles;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.Prefs;

import java.util.Set;

public class AppFilterActivity extends BaseActivity implements MenuProvider {
    private static final String TAG = "AppFilterActivity";
    private AppFilterFragment mFragment;

    @Override
    @SuppressWarnings("deprecation")
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.target_apps);
        setContentView(R.layout.fragment_activity);
        addMenuProvider(this);
        displayBackAction();

        if (savedInstanceState != null)
            mFragment = (AppFilterFragment) getSupportFragmentManager().getFragment(savedInstanceState, "fragment");
        if (mFragment == null)
            mFragment = new AppFilterFragment();

        getSupportFragmentManager().beginTransaction()
                .replace(R.id.fragment, mFragment)
                .commit();

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
            overrideActivityTransition(OVERRIDE_TRANSITION_OPEN, 0, 0);
        else
            overridePendingTransition(0, 0);
    }

    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);
        getSupportFragmentManager().putFragment(outState, "fragment", mFragment);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.hint_menu, menu);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if (id == R.id.show_hint) {
            Utils.showHelpDialog(this, R.string.target_apps_help);
            return true;
        }

        return false;
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onBackPressed() {
        if(mFragment.onBackPressed())
            return;

        super.onBackPressed();

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
            overrideActivityTransition(OVERRIDE_TRANSITION_CLOSE, 0, 0);
        else
            overridePendingTransition(0, 0);
    }

    public static class AppFilterFragment extends AppsToggles {
        private final Set<String> mSelectedApps = new ArraySet<>();
        private @Nullable SharedPreferences mPrefs;

        @Override
        public void onAttach(@NonNull Context context) {
            super.onAttach(context);
            mPrefs = PreferenceManager.getDefaultSharedPreferences(context);
            assert mPrefs != null;

            mSelectedApps.clear();

            Set<String> saved = Prefs.getStringSet(mPrefs, Prefs.PREF_APP_FILTER);
            if(!saved.isEmpty()) {
                Log.d(TAG, "Loading " + saved.size() + " target apps");
                mSelectedApps.addAll(saved);
            }
        }

        @Override
        public void onDetach() {
            super.onDetach();
            mPrefs = null;
        }

        @Override
        protected Set<String> getCheckedApps() {
            return mSelectedApps;
        }

        @Override
        public void onAppToggled(AppDescriptor app, boolean checked) {
            String packageName = app.getPackageName();
            if(mSelectedApps.contains(packageName) == checked)
                return; // nothing to do

            if(checked)
                mSelectedApps.add(packageName);
            else
                mSelectedApps.remove(packageName);

            Log.d(TAG, "Saving " + mSelectedApps.size() + " target apps");

            if(mPrefs == null)
                return;

            mPrefs.edit()
                    .putStringSet(Prefs.PREF_APP_FILTER, mSelectedApps)
                    .apply();
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/AppsActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.os.Bundle;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.fragments.AppsFragment;

public class AppsActivity extends BaseActivity {
    private static final String TAG = "AppsActivity";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setTitle(R.string.apps);
        setContentView(R.layout.fragment_activity);

        getSupportFragmentManager().beginTransaction()
                .replace(R.id.fragment, new AppsFragment())
                .commit();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/BaseActivity.java`:

```java
package com.emanuelef.remote_capture.activities;

import android.content.Context;
import android.os.Bundle;
import android.view.MenuItem;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.appcompat.app.ActionBar;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;

import java.util.List;

public class BaseActivity extends AppCompatActivity {
    private boolean mBackAction = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Utils.enableEdgeToEdge(this);
        super.onCreate(savedInstanceState);
    }

    @Override
    public void setContentView(int res)  {
        super.setContentView(res);

        View toolbar = findViewById(R.id.toolbar);
        if (toolbar != null) {
            // Fix padding of content below the toolbar
            ViewCompat.setOnApplyWindowInsetsListener(toolbar, (view, insets) -> {
                int topInset = insets.getInsets(WindowInsetsCompat.Type.statusBars() |
                        WindowInsetsCompat.Type.systemBars() | WindowInsetsCompat.Type.displayCutout()).top;
                if (topInset > 0)
                    view.setPadding(0, topInset, 0, 0); // Shift the toolbar down if needed

                return insets;
            });
        }
    }

    @Override
    protected void attachBaseContext(Context base) {
        // Ensure that the selected locale is used
        applyOverrideConfiguration(Utils.getLocalizedConfig(base));
        super.attachBaseContext(base);
    }

    protected void displayBackAction() {
        ActionBar actionBar = getSupportActionBar();

        if(actionBar != null) {
            actionBar.setDisplayHomeAsUpEnabled(true);
            mBackAction = true;
        }
    }

    protected Fragment getFragment(Class targetClass) {
        List<Fragment> fragments = getSupportFragmentManager().getFragments();

        for(Fragment fragment : fragments) {
            if(targetClass.isInstance(fragment))
                return fragment;
        }

        return null;
    }

    protected Fragment getFragmentAtPos(int pos) {
        return getSupportFragmentManager().findFragmentByTag("f" + pos);
    }

    @Override
    @SuppressWarnings("deprecation")
    public boolean onOptionsItemSelected(@NonNull MenuItem item) {
        if(mBackAction && (item.getItemId() == android.R.id.home)) {
            onBackPressed();
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/CaptureCtrl.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.View;
import android.view.Window;
import android.view.WindowInsets;
import android.view.WindowInsetsController;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.RadioButton;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.BuildConfig;
import com.emanuelef.remote_capture.CaptureHelper;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.PersistableUriPermission;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.CaptureSettings;
import com.emanuelef.remote_capture.model.CtrlPermissions;
import com.emanuelef.remote_capture.model.CaptureStats;
import com.emanuelef.remote_capture.model.Prefs;

import java.util.HashSet;

public class CaptureCtrl extends AppCompatActivity {
    public static final String ACTION_START = "start";
    public static final String ACTION_STOP = "stop";
    public static final String ACTION_STATUS = "get_status";
    public static final String ACTION_PEER_INFO = "get_peer_info";
    public static final String ACTION_NOTIFY_STATUS = "com.emanuelef.remote_capture.CaptureStatus";
    private static final String TAG = "CaptureCtrl";
    private static AppDescriptor mStarterApp = null; // the app which started the capture, may be unknown
    private static String mReceiverClass = null;
    private CaptureHelper mCapHelper;
    private CtrlPermissions mPermissions;

    private PersistableUriPermission persistableUriPermission;

    @Override
    @SuppressWarnings("deprecation")
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        // Important: calls must occur in the following order:
        //  requestWindowFeature -> setContentView -> getInsetsController()
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.ctrl_consent);

        // define here since it calls registerForActivityResult
        persistableUriPermission = new PersistableUriPermission(this);

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            final WindowInsetsController insetsController = getWindow().getInsetsController();
            if (insetsController != null)
                insetsController.hide(WindowInsets.Type.statusBars());
        } else {
            getWindow().setFlags(
                    WindowManager.LayoutParams.FLAG_FULLSCREEN,
                    WindowManager.LayoutParams.FLAG_FULLSCREEN
            );
        }
        getWindow().addFlags(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
        super.onCreate(savedInstanceState);

        mCapHelper = new CaptureHelper(this);
        mCapHelper.setListener(success -> {
            setResult(success ? RESULT_OK : RESULT_CANCELED, null);
            finish();
        });

        Intent intent = getIntent();
        String action = intent.getStringExtra("action");
        String api_key = intent.getStringExtra("api_key");

        if(action == null) {
            Log.e(TAG, "no action provided");
            abort();
            return;
        }

        if(action.equals(ACTION_PEER_INFO)) {
            getPeerInfo();
            return;
        }

        if(api_key != null) {
            // authenticate via API key
            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
            String my_key = Prefs.getApiKey(prefs);

            if (!my_key.isEmpty() && my_key.equals(api_key)) {
                processRequest(intent, action);
                return;
            }
        }

        // Check if a control permission rule was set
        mPermissions = PCAPdroid.getInstance().getCtrlPermissions();
        AppDescriptor app = getCallingApp();
        if(app != null) {
            CtrlPermissions.ConsentType consent = mPermissions.getConsent(app.getPackageName());

            if(consent == CtrlPermissions.ConsentType.ALLOW) {
                processRequest(intent, action);
                return;
            } else if(consent == CtrlPermissions.ConsentType.DENY) {
                abort();
                return;
            }
        }

        if(isControlApp(action)) {
            processRequest(intent, action);
            return;
        }

        // Show authorization window
        findViewById(R.id.allow_btn).setOnClickListener(v -> controlAction(intent, action, true));
        findViewById(R.id.deny_btn).setOnClickListener(v -> controlAction(intent, action, false));

        if(app != null) {
            ((TextView)findViewById(R.id.app_name)).setText(app.getName());
            ((TextView)findViewById(R.id.app_package)).setText(app.getPackageName());
            ((ImageView)findViewById(R.id.app_icon)).setImageDrawable(app.getIcon());
        } else
            findViewById(R.id.caller_app).setVisibility(View.GONE);

        new Handler(Looper.getMainLooper()).postDelayed(() -> {
                    Button btn = findViewById(R.id.allow_btn);
                    btn.setTextColor(0xFF0099CC);
                    btn.setEnabled(true);
                }, 1500);
    }

    private AppDescriptor getCallingApp() {
        String callp = getCallingPackage();
        return (callp != null) ? AppsResolver.resolveInstalledApp(getPackageManager(), callp, 0) : null;
    }

    private void controlAction(Intent intent, String action, boolean allow) {
        AppDescriptor app = getCallingApp();
        if(app != null) {
            boolean is_forever = ((RadioButton)findViewById(R.id.choice_forever)).isChecked();
            if(is_forever) {
                Log.d(TAG, (allow ? "Grant" : "Deny") + " forever to " + app.getPackageName());
                mPermissions.add(app.getPackageName(), allow ? CtrlPermissions.ConsentType.ALLOW : CtrlPermissions.ConsentType.DENY);
            }
        }

        if(!allow)
            abort();
        else
            processRequest(intent, action);
    }

    @Override
    protected void onDestroy() {
        mCapHelper = null;
        super.onDestroy();
    }

    private boolean isControlApp(@NonNull String action) {
        // By default, only the app which started the capture can perform other actions
        return !action.equals(ACTION_START) && (mStarterApp != null)
                && (mStarterApp.getPackageName().equals(getCallingPackage()));
    }

    @Override
    public void onStart() {
        super.onStart();
        getWindow().setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT);
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onBackPressed() {
        abort();
        super.onBackPressed();
    }

    private void abort(boolean show_toast) {
        if(show_toast)
            Utils.showToast(this, R.string.ctrl_consent_denied);
        setResult(RESULT_CANCELED, null);
        finish();
    }

    private void abort() {
        abort(true);
    }

    // Check if the capture is requesting to send traffic to a remote server.
    // For security reasons, this is only allowed if such server is already configured by
    // the user in the app prefs.
    // see also MainActivity.showRemoteServerAlert
    private String checkRemoteServerNotAllowed(CaptureSettings settings) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);

        boolean exporterEnabled = (settings.dump_mode == Prefs.DumpMode.UDP_EXPORTER) ||
                (settings.dump_mode == Prefs.DumpMode.TCP_EXPORTER);

        if(exporterEnabled &&
                !Utils.isLocalNetworkAddress(settings.collector_address) &&
                !Prefs.getCollectorIp(prefs).equals(settings.collector_address))
            return settings.collector_address;

        if(settings.socks5_enabled &&
                !Utils.isLocalNetworkAddress(settings.socks5_proxy_address) &&
                !Prefs.getSocks5ProxyHost(prefs).equals(settings.socks5_proxy_address))
            return settings.socks5_proxy_address;

        // ok
        return null;
    }

    private void processRequest(Intent req_intent, @NonNull String action) {
        Intent res = new Intent();
        Utils.showToast(this, R.string.ctrl_consent_allowed);

        if(action.equals(ACTION_START)) {
            mStarterApp = getCallingApp();
            mReceiverClass = req_intent.getStringExtra("broadcast_receiver");
            Log.d(TAG, "Starting capture, caller=" + mStarterApp);

            CaptureSettings settings = new CaptureSettings(this, req_intent);
            String disallowedServer = checkRemoteServerNotAllowed(settings);
            if(disallowedServer != null) {
                Utils.showToastLong(this, R.string.remote_server_warning, disallowedServer);
                abort();
                return;
            }

            PCAPdroid.getInstance().setIsDecryptingPcap(false);

            if(!settings.pcap_uri.isEmpty()) {
                persistableUriPermission.checkPermission(settings.pcap_uri, settings.pcapng_format, granted_uri -> {
                    Log.d(TAG, "persistable uri granted? " + granted_uri);

                    if(granted_uri != null) {
                        settings.pcap_uri = granted_uri.toString();
                        mCapHelper.startCapture(settings);
                    } else
                        abort();
                });
            } else
                // will call the mCapHelper listener
                mCapHelper.startCapture(settings);
            return;
        } else if(action.equals(ACTION_STOP)) {
            Log.d(TAG, "Stopping capture");

            CaptureService.stopService();
            mStarterApp = null;

            // stopService returns immediately, need to wait for capture stop
            CaptureService.waitForCaptureStop();

            putStats(res, CaptureService.getStats());
        } else if(action.equals(ACTION_STATUS)) {
            Log.d(TAG, "Returning status");

            res.putExtra("running", CaptureService.isServiceActive());
            res.putExtra("version_name", BuildConfig.VERSION_NAME);
            res.putExtra("version_code", BuildConfig.VERSION_CODE);

            putStats(res, CaptureService.getStats());
        } else {
            Log.e(TAG, "unknown action: " + action);
            abort();
            return;
        }

        setResult(RESULT_OK, res);
        finish();
    }

    public static void notifyCaptureStopped(Context ctx, CaptureStats stats) {
        if(stats != null)
            Log.d(TAG, "notifyCaptureStopped: " + (stats.pkts_sent + stats.pkts_rcvd) + " pkts");

        if((mStarterApp != null) && (mReceiverClass != null)) {
            Log.d(TAG, "Notifying receiver");

            Intent intent = new Intent(ACTION_NOTIFY_STATUS);
            intent.putExtra("running", false);
            if(stats != null)
                putStats(intent, stats);
            intent.setComponent(new ComponentName(mStarterApp.getPackageName(), mReceiverClass));

            try {
                ctx.sendBroadcast(intent);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        mStarterApp = null;
        mReceiverClass = null;
    }

    private static void putStats(Intent intent, CaptureStats stats) {
        intent.putExtra("bytes_sent", stats.bytes_sent);
        intent.putExtra("bytes_rcvd", stats.bytes_rcvd);
        intent.putExtra("ipv6_bytes_sent", stats.ipv6_bytes_sent);
        intent.putExtra("ipv6_bytes_rcvd", stats.ipv6_bytes_rcvd);
        intent.putExtra("bytes_dumped", stats.pcap_dump_size);
        intent.putExtra("pkts_sent", stats.pkts_sent);
        intent.putExtra("pkts_rcvd", stats.pkts_rcvd);
        intent.putExtra("pkts_dropped", stats.pkts_dropped);
    }

    // A request sent from a debug build of PCAPdroid to a non-debug one
    private void getPeerInfo() {
        // Verify the peer app
        String package_name = getCallingPackage();
        if((package_name == null) || !package_name.equals(BuildConfig.APPLICATION_ID + ".debug")) {
            Log.w(TAG, "getPeerInfo: package name mismatch");
            abort(false);
            return;
        }

        Billing billing = Billing.newInstance(this);
        billing.setLicense(billing.getLicense());

        Intent res = new Intent();
        HashSet<String> purchased = new HashSet<>();

        for(String sku: Billing.ALL_SKUS) {
            if(billing.isPurchased(sku))
                purchased.add(sku);
        }

        res.putExtra("skus", purchased);

        setResult(RESULT_OK, res);
        finish();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/ConnectionDetailsActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-24 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.viewpager2.adapter.FragmentStateAdapter;
import androidx.viewpager2.widget.ViewPager2;

import android.annotation.SuppressLint;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.fragments.ConnectionOverview;
import com.emanuelef.remote_capture.fragments.ConnectionPayload;
import com.emanuelef.remote_capture.interfaces.ConnectionsListener;
import com.emanuelef.remote_capture.interfaces.PayloadHostActivity;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.PayloadChunk;
import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;

import java.util.ArrayList;

public class ConnectionDetailsActivity extends PayloadExportActivity implements ConnectionsListener, PayloadHostActivity {
    private static final String TAG = "ConnectionDetails";
    public static final String CONN_ID_KEY = "conn_id";
    public static final String FILTERED_IDS_KEY = "filtered_ids";
    private static final int MAX_CHUNKS_TO_CHECK = 10;
    private ConnectionDescriptor mConn;
    private ViewPager2 mPager;
    private StateAdapter mPagerAdapter;
    private Handler mHandler;
    private int mCurChunks;
    private boolean mListenerSet;
    private boolean mHasPayload;
    private boolean mHasHttpTab;
    private boolean mHasWsTab;
    private final ArrayList<PayloadHostActivity.ConnUpdateListener> mListeners = new ArrayList<>();
    private int mConnId;
    private ArrayList<Integer> mFilteredIds;
    private int mFilteredIndex;
    private MenuItem mMenuPrev;
    private MenuItem mMenuNext;
    private MenuItem mMenuCopy;
    private MenuItem mMenuShare;
    private MenuItem mMenuDisplayAs;
    private Boolean mDisplayMode;

    private static final int POS_OVERVIEW = 0;
    private static final int POS_WEBSOCKET = 1;
    private static final int POS_HTTP = 2;
    private static final int POS_RAW_PAYLOAD = 3;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        displayBackAction();
        setContentView(R.layout.tabs_activity_fixed);

        mConnId = getIntent().getIntExtra(CONN_ID_KEY, -1);

        mFilteredIds = getIntent().getIntegerArrayListExtra(FILTERED_IDS_KEY);
        mFilteredIndex = -1;

        if (mFilteredIds != null) {
            for (int i = 0; i < mFilteredIds.size(); i++) {
                if (mFilteredIds.get(i) == mConnId) {
                    mFilteredIndex = i;
                    break;
                }
            }
            Log.d(TAG, "Using filtered navigation: " + mFilteredIds.size() + " items, index=" + mFilteredIndex);
        }

        if(mConnId != -1) {
            ConnectionsRegister reg = CaptureService.getConnsRegister();
            if(reg != null) {
                mConn = reg.getConnById(mConnId);
                setTitle(String.format(getString(R.string.connection_number), mConnId + 1));
            }
        } else
            setTitle(R.string.connection_details);

        if(mConn == null) {
            Log.w(TAG, "Connection with ID " + mConnId + " not found");
            finish();
            return;
        }

        mHandler = new Handler(Looper.getMainLooper());

        mPager = findViewById(R.id.pager);
        Utils.fixViewPager2Insets(mPager);
        setupTabs();
    }

    @Override
    public void onResume() {
        super.onResume();
        registerConnsListener();
    }

    @Override
    public void onPause() {
        super.onPause();
        unregisterConnsListener();
    }

    private void setupTabs() {
        mPagerAdapter = new StateAdapter(this);
        mPager.setAdapter(mPagerAdapter);

        var tabLayout = (TabLayout) findViewById(R.id.tablayout);
        Utils.fixScrollableTabLayoutInsets(tabLayout);
        new TabLayoutMediator(tabLayout, mPager, (tab, position) ->
                tab.setText(getString(mPagerAdapter.getPageTitle(position)))
        ).attach();

        mPager.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() {
            @Override
            public void onPageSelected(int position) {
                updateMenuVisibility();
            }
        });

        mCurChunks = 0;
        recheckTabs();
    }

    private class StateAdapter extends FragmentStateAdapter {
        StateAdapter(final FragmentActivity fa) { super(fa); }

        @NonNull
        @Override
        public Fragment createFragment(int position) {
            //Log.d(TAG, "createFragment");
            int pos = getVisibleTabsPositions()[position];
            int conn_id = mConn.incr_id;

            switch (pos) {
                case POS_WEBSOCKET:
                    return ConnectionPayload.newInstance(PayloadChunk.ChunkType.WEBSOCKET, conn_id);
                case POS_HTTP:
                    return ConnectionPayload.newInstance(PayloadChunk.ChunkType.HTTP, conn_id);
                case POS_RAW_PAYLOAD:
                    return ConnectionPayload.newInstance(PayloadChunk.ChunkType.RAW, conn_id);
                case POS_OVERVIEW:
                default:
                    return ConnectionOverview.newInstance(conn_id);
            }
        }

        @Override
        public int getItemCount() {  return 1 + (mHasPayload ? 1 : 0) + (mHasHttpTab ? 1 : 0) + (mHasWsTab ? 1 : 0);  }

        public int getPageTitle(final int position) {
            int pos = getVisibleTabsPositions()[position];

            switch (pos) {
                case POS_WEBSOCKET:
                    return R.string.websocket;
                case POS_HTTP:
                    return R.string.http;
                case POS_RAW_PAYLOAD:
                    return R.string.payload;
                case POS_OVERVIEW:
                default:
                    return R.string.overview;
            }
        }

        public int[] getVisibleTabsPositions() {
            int[] visible = new int[getItemCount()];
            int i = 0;

            visible[i++] = POS_OVERVIEW;

            if(mHasWsTab)
                visible[i++] = POS_WEBSOCKET;
            if(mHasHttpTab)
                visible[i++] = POS_HTTP;
            if(mHasPayload)
                visible[i] = POS_RAW_PAYLOAD;

            return visible;
        }
    }

    private void registerConnsListener() {
        ConnectionsRegister reg = CaptureService.getConnsRegister();

        if((reg != null) && !mListenerSet) {
            if(mConn.status < ConnectionDescriptor.CONN_STATUS_CLOSED) {
                Log.d(TAG, "Adding connections listener");
                reg.addListener(this);
                mListenerSet = true;
            }
        }

        dispatchConnUpdate();
    }

    private void unregisterConnsListener() {
        if(mListenerSet) {
            ConnectionsRegister reg = CaptureService.getConnsRegister();

            if(reg != null) {
                Log.d(TAG, "Removing connections listener");
                reg.removeListener(this);
            }

            mListenerSet = false;
        }
    }

    @Override
    public void connectionsChanges(int num_connetions) {}

    @Override
    public void connectionsAdded(int start, ConnectionDescriptor []conns) {}

    @Override
    public void connectionsRemoved(int start, ConnectionDescriptor []conns) {}

    @Override
    public void connectionsUpdated(int[] positions) {
        ConnectionsRegister reg = CaptureService.getConnsRegister();

        if(reg == null)
            return;

        for(int pos : positions) {
            ConnectionDescriptor conn = reg.getConn(pos);

            if((conn != null) && (conn.incr_id == mConn.incr_id)) {
                mHandler.post(this::dispatchConnUpdate);
                break;
            }
        }
    }

    @Override
    public void addConnUpdateListener(PayloadHostActivity.ConnUpdateListener listener) {
        mListeners.add(listener);
    }

    @Override
    public void removeConnUpdateListener(PayloadHostActivity.ConnUpdateListener listener) {
        mListeners.remove(listener);
    }

    @SuppressLint("NotifyDataSetChanged")
    private void recheckTabs() {
        if(mHasHttpTab && mHasWsTab)
            return;

        int max_check = Math.min(mConn.getNumPayloadChunks(), MAX_CHUNKS_TO_CHECK);
        boolean changed = false;

        if(!mHasPayload && (max_check > 0)) {
            mHasPayload = true;
            changed = true;
        }

        for(int i=mCurChunks; i<max_check; i++) {
            PayloadChunk chunk = mConn.getPayloadChunk(i);
            if(chunk == null)
                continue;

            if(!mHasHttpTab && (chunk.type == PayloadChunk.ChunkType.HTTP)) {
                mHasHttpTab = true;
                changed = true;
            } else if (!mHasWsTab && (chunk.type == PayloadChunk.ChunkType.WEBSOCKET)) {
                mHasWsTab = true;
                changed = true;
            }
        }

        if(changed)
            mPagerAdapter.notifyDataSetChanged();

        mCurChunks = max_check;
    }

    private void dispatchConnUpdate() {
        for(PayloadHostActivity.ConnUpdateListener listener: mListeners)
            listener.connectionUpdated();

        if((mCurChunks < MAX_CHUNKS_TO_CHECK) && (mConn.getNumPayloadChunks() > mCurChunks))
            recheckTabs();

        if(mConn.status >= ConnectionDescriptor.CONN_STATUS_CLOSED)
            unregisterConnsListener();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.connection_details_menu, menu);

        mMenuPrev = menu.findItem(R.id.navigate_before);
        mMenuNext = menu.findItem(R.id.navigate_next);
        mMenuCopy = menu.findItem(R.id.copy_to_clipboard);
        mMenuShare = menu.findItem(R.id.share);
        mMenuDisplayAs = menu.findItem(R.id.display_as);

        updateNavigationButtons();
        updateMenuVisibility();
        return true;
    }

    private void updateNavigationButtons() {
        if(mMenuPrev == null || mMenuNext == null)
            return;

        ArrayList<Integer> ids = (mFilteredIds != null) ? mFilteredIds : getAllConnectionIds();
        boolean hasPrev = false;
        boolean hasNext = false;

        if(ids != null) {
            int currentIndex = ids.indexOf(mConnId);
            if(currentIndex >= 0) {
                hasPrev = currentIndex > 0;
                hasNext = currentIndex < ids.size() - 1;
            }
        }

        mMenuPrev.setEnabled(hasPrev);
        if(mMenuPrev.getIcon() != null)
            mMenuPrev.getIcon().setAlpha(hasPrev ? 255 : 80);

        mMenuNext.setEnabled(hasNext);
        if(mMenuNext.getIcon() != null)
            mMenuNext.getIcon().setAlpha(hasNext ? 255 : 80);
    }

    public void updateMenuVisibility() {
        if(mMenuCopy == null || mMenuShare == null || mMenuDisplayAs == null)
            return;

        int currentTab = mPager.getCurrentItem();
        int[] visibleTabs = mPagerAdapter.getVisibleTabsPositions();
        int currentPos = (currentTab < visibleTabs.length) ? visibleTabs[currentTab] : POS_OVERVIEW;

        boolean isOverview = (currentPos == POS_OVERVIEW);
        mMenuCopy.setVisible(isOverview);
        mMenuShare.setVisible(isOverview);

        boolean isPayload = (currentPos == POS_WEBSOCKET || currentPos == POS_HTTP || currentPos == POS_RAW_PAYLOAD);
        mMenuDisplayAs.setVisible(isPayload);

        if(isPayload) {
            Fragment currentFragment = getCurrentFragment();
            if(currentFragment instanceof ConnectionPayload payloadFragment) {
                if(mDisplayMode == null)
                    mDisplayMode = payloadFragment.guessDisplayAsPrintable();

                payloadFragment.setDisplayMode(mDisplayMode);

                if(mDisplayMode) {
                    mMenuDisplayAs.setTitle(R.string.display_as_hexdump);
                } else {
                    mMenuDisplayAs.setTitle(R.string.display_as_text);
                }
            }
        }
    }

    @Override
    public boolean onOptionsItemSelected(@NonNull MenuItem item) {
        int itemId = item.getItemId();

        if(itemId == R.id.navigate_before) {
            navigateToPrevious();
            return true;
        } else if(itemId == R.id.navigate_next) {
            navigateToNext();
            return true;
        } else if(itemId == R.id.display_as) {
            if(mDisplayMode != null) {
                mDisplayMode = !mDisplayMode;
                updateMenuVisibility();
            }
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    private Fragment getCurrentFragment() {
        int currentTab = mPager.getCurrentItem();
        String tag = "f" + mPagerAdapter.getItemId(currentTab);
        return getSupportFragmentManager().findFragmentByTag(tag);
    }

    private void navigateToPrevious() {
        ArrayList<Integer> ids = (mFilteredIds != null) ? mFilteredIds : getAllConnectionIds();
        if(ids == null)
            return;

        int currentIndex = ids.indexOf(mConnId);
        if(currentIndex > 0) {
            mConnId = ids.get(currentIndex - 1);
            if(mFilteredIds != null)
                mFilteredIndex = currentIndex - 1;
            loadConnection();
        }
    }

    private void navigateToNext() {
        ArrayList<Integer> ids = (mFilteredIds != null) ? mFilteredIds : getAllConnectionIds();
        if(ids == null)
            return;

        int currentIndex = ids.indexOf(mConnId);
        if(currentIndex >= 0 && currentIndex < ids.size() - 1) {
            mConnId = ids.get(currentIndex + 1);
            if(mFilteredIds != null)
                mFilteredIndex = currentIndex + 1;
            loadConnection();
        }
    }

    private ArrayList<Integer> getAllConnectionIds() {
        ConnectionsRegister reg = CaptureService.getConnsRegister();
        if(reg == null)
            return null;

        ArrayList<Integer> ids = new ArrayList<>();
        synchronized (reg) {
            for(int i = 0; i < reg.getConnCount(); i++) {
                ConnectionDescriptor conn = reg.getConn(i);
                if(conn != null)
                    ids.add(conn.incr_id);
            }
        }
        return ids;
    }

    private void loadConnection() {
        ConnectionsRegister reg = CaptureService.getConnsRegister();
        if(reg != null) {
            mConn = reg.getConnById(mConnId);

            if(mConn != null) {
                setTitle(String.format(getString(R.string.connection_number), mConnId + 1));

                unregisterConnsListener();

                int currentTab = mPager.getCurrentItem();

                mHasPayload = false;
                mHasHttpTab = false;
                mHasWsTab = false;
                mCurChunks = 0;

                setupTabs();

                int newItemCount = mPagerAdapter.getItemCount();
                if (currentTab < newItemCount) {
                    mPager.setCurrentItem(currentTab, false);
                } else {
                    mPager.setCurrentItem(0, false);
                }

                if(mConn.status < ConnectionDescriptor.CONN_STATUS_CLOSED)
                    registerConnsListener();

                updateNavigationButtons();
                updateMenuVisibility();
            } else {
                Log.w(TAG, "Connection with ID " + mConnId + " not found");
            }
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // This is required to properly handle the DPAD down press on Android TV, to properly
        // focus the tab content
        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
            View view = getCurrentFocus();

            Log.d(TAG, "onKeyDown focus " + view.getClass().getName());

            if (view instanceof TabLayout.TabView) {
                int pos = mPager.getCurrentItem();
                View focusOverride = null;

                Log.d(TAG, "TabLayout.TabView focus pos " + pos);

                if (pos == POS_OVERVIEW)
                    focusOverride = findViewById(R.id.connection_overview);
                else
                    focusOverride = findViewById(R.id.payload);

                if (focusOverride != null) {
                    focusOverride.requestFocus();
                    return true;
                }
            }
        }

        return super.onKeyDown(keyCode, event);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/ConnectionsActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.os.Bundle;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.fragments.ConnectionsFragment;

public class ConnectionsActivity extends BaseActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.connections_view);
        displayBackAction(); // Use explicit back to restore the AppDetailsActivity state
        setContentView(R.layout.fragment_activity);

        getSupportFragmentManager().beginTransaction()
                .replace(R.id.fragment, new ConnectionsFragment())
                .commit();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/EditFilterActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */
package com.emanuelef.remote_capture.activities;

import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.util.Pair;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.CheckBox;

import androidx.annotation.NonNull;
import androidx.appcompat.app.ActionBar;
import androidx.core.view.MenuProvider;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.Status;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.DecryptionStatus;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.FilteringStatus;
import com.emanuelef.remote_capture.model.FilterDescriptor;
import com.emanuelef.remote_capture.model.ListInfo;
import com.emanuelef.remote_capture.model.Prefs;
import com.google.android.material.chip.Chip;
import com.google.android.material.chip.ChipGroup;
import com.google.android.material.slider.Slider;

import java.util.Arrays;
import java.util.ArrayList;

public class EditFilterActivity extends BaseActivity implements MenuProvider {
    public static final String FILTER_DESCRIPTOR = "filter";
    private static final String TAG = "EditFilterActivity";
    private FilterDescriptor mFilter;
    private CheckBox mHideMasked;
    private CheckBox mOnlyBlacklisted;
    private CheckBox mOnlyCleartext;
    private ArrayList<Pair<FilteringStatus, Chip>> mFirewallChips;
    private ArrayList<Pair<Status, Chip>> mStatusChips;
    private ArrayList<Pair<DecryptionStatus, Chip>> mDecChips;
    private ChipGroup mInterfaceGroup;
    private Slider mSizeSider;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.edit_filter_activity);
        setTitle(R.string.edit_filter);
        addMenuProvider(this);

        ActionBar actionBar = getSupportActionBar();
        if(actionBar != null) {
            actionBar.setDisplayHomeAsUpEnabled(true);
            actionBar.setHomeAsUpIndicator(R.drawable.ic_close);
        }

        Intent intent = getIntent();
        if(intent != null) {
            FilterDescriptor desc = Utils.getSerializableExtra(intent, FILTER_DESCRIPTOR, FilterDescriptor.class);
            if(desc != null)
                mFilter = desc;
        }
        if(mFilter == null)
            mFilter = new FilterDescriptor();

        mHideMasked = findViewById(R.id.not_hidden);
        mOnlyBlacklisted = findViewById(R.id.only_blacklisted);
        mOnlyCleartext = findViewById(R.id.only_cleartext);
        mInterfaceGroup = findViewById(R.id.interfaces);
        mSizeSider = findViewById(R.id.size_slider);

        findViewById(R.id.edit_mask).setOnClickListener(v -> {
            Intent editIntent = new Intent(this, EditListActivity.class);
            editIntent.putExtra(EditListActivity.LIST_TYPE_EXTRA, ListInfo.Type.VISUALIZATION_MASK);
            startActivity(editIntent);
        });

        mFirewallChips = new ArrayList<>(Arrays.asList(
                new Pair<>(FilteringStatus.BLOCKED, findViewById(R.id.status_blocked)),
                new Pair<>(FilteringStatus.ALLOWED, findViewById(R.id.status_allowed))
        ));

        mStatusChips = new ArrayList<>(Arrays.asList(
                new Pair<>(Status.STATUS_ACTIVE, findViewById(R.id.status_active)),
                new Pair<>(Status.STATUS_CLOSED, findViewById(R.id.status_closed)),
                new Pair<>(Status.STATUS_UNREACHABLE, findViewById(R.id.status_unreachable)),
                new Pair<>(Status.STATUS_ERROR, findViewById(R.id.status_error))
        ));

        mDecChips = new ArrayList<>(Arrays.asList(
                new Pair<>(DecryptionStatus.DECRYPTED, findViewById(R.id.dec_status_decrypted)),
                new Pair<>(DecryptionStatus.NOT_DECRYPTABLE, findViewById(R.id.dec_status_not_decryptable)),
                new Pair<>(DecryptionStatus.ERROR, findViewById(R.id.dec_status_error))
        ));

        if (PCAPdroid.getInstance().isDecryptingPcap()) {
            // unable to show the following statuses
            findViewById(R.id.dec_status_not_decryptable).setVisibility(View.GONE);
            findViewById(R.id.dec_status_error).setVisibility(View.GONE);
        }

        if(CaptureService.isDecryptingTLS() || PCAPdroid.getInstance().isDecryptingPcap()) {
            findViewById(R.id.decryption_status_label).setVisibility(View.VISIBLE);
            findViewById(R.id.decryption_status_group).setVisibility(View.VISIBLE);
            mOnlyCleartext.setVisibility(View.GONE);
        }

        Billing billing = Billing.newInstance(this);
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);

        if(!Prefs.isMalwareDetectionEnabled(this, prefs))
            mOnlyBlacklisted.setVisibility(View.GONE);

        if(billing.isFirewallVisible()) {
            findViewById(R.id.firewall_label).setVisibility(View.VISIBLE);
            findViewById(R.id.firewall_group).setVisibility(View.VISIBLE);
        }

        ConnectionsRegister reg = CaptureService.getConnsRegister();
        if((reg != null) && (reg.hasSeenMultipleInterfaces())) {
            LayoutInflater inflater = getLayoutInflater();

            // Create the chips
            for(String ifname: reg.getSeenInterfaces()) {
                Chip chip = (Chip) inflater.inflate(R.layout.choice_chip, mInterfaceGroup, false);
                chip.setText(ifname);
                mInterfaceGroup.addView(chip);
            }

            mInterfaceGroup.setVisibility(View.VISIBLE);
            findViewById(R.id.interfaces_label).setVisibility(View.VISIBLE);
        }

        if (reg != null) {
            long minSizeKB = mFilter.minSize / 1024;
            long maxSizeKB = reg.getMaxBytes() / 1024;
            maxSizeKB = Math.max(maxSizeKB, minSizeKB);

            if (maxSizeKB >= 2) {
                mSizeSider.setValueTo(maxSizeKB);
                mSizeSider.setLabelFormatter(value -> Utils.formatBytes(((long) value) * 1024));
                mSizeSider.setVisibility(View.VISIBLE);
                findViewById(R.id.size_slider_label).setVisibility(View.VISIBLE);
            }
        }

        model2view();
    }

    private <T> void setCheckedChip(ArrayList<Pair<T, Chip>> chipMap, T curValue) {
        for(Pair<T, Chip> mapping: chipMap) {
            Chip chip = mapping.second;
            chip.setChecked(mapping.first.equals(curValue));
        }
    }

    private <T> T getCheckedChip(ArrayList<Pair<T, Chip>> chipMap, T defaultValue) {
        for(Pair<T, Chip> mapping: chipMap) {
            Chip chip = mapping.second;

            if(chip.isChecked())
                return mapping.first;
        }

        return defaultValue;
    }

    private void model2view() {
        mHideMasked.setChecked(!mFilter.showMasked);
        mOnlyBlacklisted.setChecked(mFilter.onlyBlacklisted);
        mOnlyCleartext.setChecked(mFilter.onlyCleartext);

        long minSizeKB = mFilter.minSize / 1024;
        if (minSizeKB > 0)
            mSizeSider.setValue(minSizeKB);

        setCheckedChip(mStatusChips, mFilter.status);
        setCheckedChip(mDecChips, mFilter.decStatus);
        setCheckedChip(mFirewallChips, mFilter.filteringStatus);

        if(mFilter.iface != null) {
            int num_chips = mInterfaceGroup.getChildCount();
            for(int i=0; i<num_chips; i++) {
                Chip chip = (Chip) mInterfaceGroup.getChildAt(i);
                if(chip.getText().equals(mFilter.iface)) {
                    chip.setChecked(true);
                    break;
                }
            }
        }
    }

    private void view2model() {
        mFilter.showMasked = !mHideMasked.isChecked();
        mFilter.onlyBlacklisted = mOnlyBlacklisted.isChecked();
        mFilter.onlyCleartext = mOnlyCleartext.isChecked();

        mFilter.status = getCheckedChip(mStatusChips, Status.STATUS_INVALID);
        mFilter.decStatus = getCheckedChip(mDecChips, DecryptionStatus.INVALID);
        mFilter.filteringStatus = getCheckedChip(mFirewallChips, FilteringStatus.INVALID);
        mFilter.minSize = ((long) mSizeSider.getValue()) * 1024;

        int num_chips = mInterfaceGroup.getChildCount();
        for(int i=0; i<num_chips; i++) {
            Chip chip = (Chip) mInterfaceGroup.getChildAt(i);
            if(chip.isChecked()) {
                mFilter.iface = chip.getText().toString();
                break;
            }
        }
    }

    private void finishOk() {
        view2model();
        Intent intent = new Intent();
        intent.putExtra(FILTER_DESCRIPTOR, mFilter);
        setResult(RESULT_OK, intent);
        finish();
    }

    @Override
    public boolean onSupportNavigateUp() {
        finishOk();
        return true;
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onBackPressed() {
        finishOk();
        super.onBackPressed();
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.edit_filter_menu, menu);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        if(item.getItemId() == R.id.reset_changes) {
            mFilter.clear();
            model2view();
            return true;
        }

        return false;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/EditListActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.os.Bundle;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.ListInfo;
import com.emanuelef.remote_capture.model.MatchList;

/* An activity to edit a MatchList, specified via LIST_INFO_EXTRA */
public class EditListActivity extends BaseActivity {
    private static final String TAG = "EditListActivity";
    public static final String LIST_TYPE_EXTRA = "list_type";
    private static final String FITS_SYSTEM_WINDOWS_ARG = "fits_system_windows";
    private ListInfo mListInfo;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if(getIntent() == null) {
            Log.e(TAG, "null intent");
            finish();
            return;
        }

        ListInfo.Type ltype = Utils.getSerializableExtra(getIntent(), LIST_TYPE_EXTRA, ListInfo.Type.class);
        if(ltype == null) {
            Log.e(TAG, "null list info");
            finish();
            return;
        }

        mListInfo = new ListInfo(ltype);

        setTitle(mListInfo.getTitle());
        setContentView(R.layout.fragment_activity);

        getSupportFragmentManager().beginTransaction()
                .replace(R.id.fragment, mListInfo.newFragment())
                .commit();
    }

    public MatchList getList() {
        return mListInfo.getList();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/ErrorActivity.java`:

```java
/*
 * Copyright 2014-2017 Eduard Ereza Martínez
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * You may obtain a copy of the License at
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.emanuelef.remote_capture.activities;

import android.annotation.SuppressLint;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.TypedArray;
import android.net.Uri;
import android.os.Bundle;
import android.util.TypedValue;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.res.ResourcesCompat;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.Prefs;

import cat.ereza.customactivityoncrash.CustomActivityOnCrash;
import cat.ereza.customactivityoncrash.config.CaocConfig;

public final class ErrorActivity extends AppCompatActivity {

    @SuppressLint("PrivateResource")
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        Utils.enableEdgeToEdge(this);
        super.onCreate(savedInstanceState);

        View toolbar = findViewById(R.id.toolbar);
        if (toolbar != null) {
            // Fix padding of content below the toolbar
            ViewCompat.setOnApplyWindowInsetsListener(toolbar, (view, insets) -> {
                int topInset = insets.getInsets(WindowInsetsCompat.Type.statusBars() |
                        WindowInsetsCompat.Type.systemBars() | WindowInsetsCompat.Type.displayCutout()).top;
                if (topInset > 0)
                    view.setPadding(0, topInset, 0, 0); // Shift the toolbar down if needed

                return WindowInsetsCompat.CONSUMED;
            });
        }

        //This is needed to avoid a crash if the developer has not specified
        //an app-level theme that extends Theme.AppCompat
        TypedArray a = obtainStyledAttributes(R.styleable.AppCompatTheme);
        if (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) {
            setTheme(R.style.Theme_AppCompat_Light_DarkActionBar);
        }
        a.recycle();

        setContentView(com.emanuelef.remote_capture.R.layout.error_activity);

        //Close/restart button logic:
        //If a class if set, use restart.
        //Else, use close and just finish the app.
        //It is recommended that you follow this logic if implementing a custom error activity.
        Button restartButton = findViewById(R.id.customactivityoncrash_error_activity_restart_button);

        final CaocConfig config = CustomActivityOnCrash.getConfigFromIntent(getIntent());

        if (config == null) {
            //This should never happen - Just finish the activity to avoid a recursive crash.
            finish();
            return;
        }

        if (config.isShowRestartButton() && config.getRestartActivityClass() != null) {
            restartButton.setText(R.string.customactivityoncrash_error_activity_restart_app);
            restartButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    CustomActivityOnCrash.restartApplication(ErrorActivity.this, config);
                }
            });
        } else {
            restartButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    CustomActivityOnCrash.closeApplication(ErrorActivity.this, config);
                }
            });
        }

        Button moreInfoButton = findViewById(R.id.customactivityoncrash_error_activity_more_info_button);

        if (config.isShowErrorDetails()) {
            moreInfoButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    //We retrieve all the error data and show it

                    AlertDialog dialog = new AlertDialog.Builder(ErrorActivity.this)
                            .setTitle(R.string.customactivityoncrash_error_activity_error_details_title)
                            .setMessage(getErrorDetails())
                            .setPositiveButton(R.string.customactivityoncrash_error_activity_error_details_close, null)
                            .setNeutralButton(R.string.customactivityoncrash_error_activity_error_details_copy,
                                    new DialogInterface.OnClickListener() {
                                        @Override
                                        public void onClick(DialogInterface dialog, int which) {
                                            copyErrorToClipboard();
                                        }
                                    })
                            .show();
                    TextView textView = dialog.findViewById(android.R.id.message);
                    if (textView != null) {
                        textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimension(R.dimen.customactivityoncrash_error_activity_error_details_text_size));
                    }
                }
            });
        } else {
            moreInfoButton.setVisibility(View.GONE);
        }

        Button emailButton = ((Button)findViewById(com.emanuelef.remote_capture.R.id.report_button));
        Intent emailIntent = new Intent(Intent.ACTION_SENDTO);
        emailIntent.setData(Uri.parse("mailto:"));
        emailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{"Emanuele Faranda <black.silver@hotmail.it>"});
        emailIntent.putExtra(Intent.EXTRA_SUBJECT, "PCAPdroid crash");
        if(emailIntent.resolveActivity(getPackageManager()) != null) {
            emailButton.setOnClickListener(v -> {
                String errorInformation = getErrorDetails();
                emailIntent.putExtra(Intent.EXTRA_TEXT, errorInformation);
                Utils.startActivity(this, emailIntent);
            });
        } else
            emailButton.setVisibility(View.GONE);

        Integer defaultErrorActivityDrawableId = config.getErrorDrawable();
        ImageView errorImageView = findViewById(R.id.customactivityoncrash_error_activity_image);

        if (defaultErrorActivityDrawableId != null) {
            errorImageView.setImageDrawable(ResourcesCompat.getDrawable(getResources(), defaultErrorActivityDrawableId, getTheme()));
        }
    }

    private void copyErrorToClipboard() {
        String errorInformation = getErrorDetails();

        ClipboardManager clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);

        //Are there any devices without clipboard...?
        if (clipboard != null) {
            ClipData clip = ClipData.newPlainText(getString(R.string.customactivityoncrash_error_activity_error_details_clipboard_label), errorInformation);
            clipboard.setPrimaryClip(clip);
            Toast.makeText(ErrorActivity.this, R.string.customactivityoncrash_error_activity_error_details_copied, Toast.LENGTH_SHORT).show();
        }
    }

    @NonNull
    public static String getAllErrorDetailsFromIntent(@NonNull Context context, @NonNull Intent intent) {
        String errorDetails = Utils.getBuildInfo(context);
        errorDetails += "\nStack trace:  \n";
        errorDetails += CustomActivityOnCrash.getStackTraceFromIntent(intent);

        String activityLog = CustomActivityOnCrash.getActivityLogFromIntent(intent);
        if (activityLog != null) {
            errorDetails += "\nUser actions: \n";
            errorDetails += activityLog;
        }

        errorDetails += "\n" + Prefs.asString(context);
        return errorDetails;
    }

    private String getErrorDetails() {
        return getAllErrorDetailsFromIntent(ErrorActivity.this, getIntent());
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/activities/FirewallActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.annotation.SuppressLint;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.preference.PreferenceManager;
import androidx.viewpager2.adapter.FragmentStateAdapter;
import androidx.viewpager2.widget.ViewPager2;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.fragments.EditListFragment;
import com.emanuelef.remote_capture.fragments.FirewallStatus;
import com.emanuelef.remote_capture.model.ListInfo;
import com.emanuelef.remote_capture.model.Prefs;
import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;

public class FirewallActivity extends BaseActivity {
    private static final String TAG = "Firewall";
    private ViewPager2 mPager;
    private StateAdapter mPagerAdapter;
    private boolean mHasWhitelist = false;
    private SharedPreferences mPrefs;

    private static final int POS_STATUS = 0;
    private static final int POS_BLOCKLIST = 1;
    private static final int POS_WHITELIST = 2;
    private static final int TOTAL_COUNT = 3;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.firewall);
        setContentView(R.layout.tabs_activity);

        mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        mPager = findViewById(R.id.pager);
        Utils.fixViewPager2Insets(mPager);
        setupTabs();
    }

    private class StateAdapter extends FragmentStateAdapter {
        StateAdapter(final FragmentActivity fa) { super(fa); }

        @NonNull
        @Override
        public Fragment createFragment(int position) {
            Log.d(TAG, "createFragment");

            switch (position) {
                default: // Deliberate fall-through to status tab
                case POS_STATUS:
                    return new FirewallStatus();
                case POS_BLOCKLIST:
                    return EditListFragment.newInstance(ListInfo.Type.BLOCKLIST);
                case POS_WHITELIST:
                    return EditListFragment.newInstance(ListInfo.Type.FIREWALL_WHITELIST);
            }
        }

        @Override
        public int getItemCount() {  return mHasWhitelist ? TOTAL_COUNT : (TOTAL_COUNT - 1);  }

        public int getPageTitle(final int position) {
            switch (position) {
                default: // Deliberate fall-through to status tab
                case POS_STATUS:
                    return R.string.status;
                case POS_BLOCKLIST:
                    return R.string.blocklist;
                case POS_WHITELIST:
                    return R.string.whitelist;
            }
        }
    }

    @SuppressLint("NotifyDataSetChanged")
    public void recheckTabs() {
        boolean whitelist_mode = Prefs.isFirewallWhitelistMode(mPrefs);
        if(mHasWhitelist == whitelist_mode)
            return;

        mHasWhitelist = whitelist_mode;
        mPagerAdapter.notifyDataSetChanged();
    }

    private void setupTabs() {
        mPagerAdapter = new StateAdapter(this);
        mPager.setAdapter(mPagerAdapter);

        new TabLayoutMediator(findViewById(R.id.tablayout), mPager, (tab, position) ->
                tab.setText(getString(mPagerAdapter.getPageTitle(position)))
        ).attach();

        recheckTabs();

        // TODO fix DPAD navigation on Android TV, see MainActivity.onKeyDown
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // This is required to properly handle the DPAD down press on Android TV, to properly
        // focus the tab content
        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
            View view = getCurrentFocus();

            Log.d(TAG, "onKeyDown focus " + view.getClass().getName());

            if (view instanceof TabLayout.TabView) {
                int pos = mPager.getCurrentItem();
                View focusOverride = null;

                Log.d(TAG, "TabLayout.TabView focus pos " + pos);

                if (pos == POS_STATUS)
                    focusOverride = findViewById(R.id.firewall_status);
                else if ((pos == POS_BLOCKLIST) || (pos == POS_WHITELIST))
                    focusOverride = findViewById(R.id.listview);

                if (focusOverride != null) {
                    focusOverride.requestFocus();
                    return true;
                }
            }
        }

        return super.onKeyDown(keyCode, event);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/HttpDetailsActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

import androidx.activity.result.ActivityResult;
import androidx.appcompat.app.AlertDialog;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.viewpager2.adapter.FragmentStateAdapter;
import androidx.viewpager2.widget.ViewPager2;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.HarWriter;
import com.emanuelef.remote_capture.HttpLog;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.fragments.ConnectionPayload;
import com.emanuelef.remote_capture.fragments.HttpPayloadFragment;
import com.emanuelef.remote_capture.interfaces.ConnectionsListener;
import com.emanuelef.remote_capture.interfaces.PayloadHostActivity;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.PayloadChunk;
import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HttpDetailsActivity extends PayloadExportActivity implements ConnectionsListener, PayloadHostActivity {
    private static final String TAG = "HttpRequestDetailsActivity";
    public static final String HTTP_REQ_POS_KEY = "req_pos";
    public static final String FILTERED_POSITIONS_KEY = "filtered_positions";
    private HttpLog.HttpRequest mHttpReq;
    private ViewPager2 mPager;
    private StateAdapter mPagerAdapter;
    private int mReqPos;
    private ArrayList<Integer> mFilteredPositions;
    private int mFilteredIndex;
    private MenuItem mMenuPrev;
    private MenuItem mMenuNext;
    private MenuItem mMenuDisplayAs;
    private Boolean mDisplayMode;
    private Uri mHarFname;
    private AlertDialog mAlertDialog;

    private final ActivityResultLauncher<Intent> harFileLauncher =
            registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), this::harFileResult);

    private static final int POS_REQUEST = 0;
    private static final int POS_REPLY = 1;
    private static final int POS_WEBSOCKET = 2;
    private boolean mHasWebsocket = false;
    private final ArrayList<PayloadHostActivity.ConnUpdateListener> mListeners = new ArrayList<>();
    private Handler mHandler;
    private boolean mListenerSet;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        displayBackAction();
        setContentView(R.layout.tabs_activity_fixed);

        mReqPos = getIntent().getIntExtra(HTTP_REQ_POS_KEY, -1);

        // Get filtered positions if provided
        mFilteredPositions = getIntent().getIntegerArrayListExtra(FILTERED_POSITIONS_KEY);
        mFilteredIndex = -1;

        // Find the index of the current position in the filtered list
        if (mFilteredPositions != null) {
            for (int i = 0; i < mFilteredPositions.size(); i++) {
                if (mFilteredPositions.get(i) == mReqPos) {
                    mFilteredIndex = i;
                    break;
                }
            }
            Log.d(TAG, "Using filtered navigation: " + mFilteredPositions.size() + " items, index=" + mFilteredIndex);
        }

        if(mReqPos != -1) {
            setTitle(String.format(getString(R.string.http_request_number), mReqPos + 1));

            HttpLog httpLog = CaptureService.getHttpLog();
            if(httpLog != null)
                mHttpReq = httpLog.getRequest(mReqPos);
        } else
            setTitle(R.string.http_requests);

        if(mHttpReq == null) {
            Log.w(TAG, "HTTP request with position " + mReqPos + " not found");
            finish();
            return;
        }

        // Check if this HTTP request has associated websocket data
        mHasWebsocket = mHttpReq.hasWebsocketData();

        mHandler = new Handler(Looper.getMainLooper());

        mPager = findViewById(R.id.pager);
        Utils.fixViewPager2Insets(mPager);
        setupTabs();
    }

    @Override
    public void onResume() {
        super.onResume();
        registerConnsListener();
    }

    @Override
    public void onPause() {
        super.onPause();
        unregisterConnsListener();
    }

    @Override
    protected void onDestroy() {
        if(mAlertDialog != null)
            mAlertDialog.dismiss();

        super.onDestroy();
    }

    private void setupTabs() {
        mPagerAdapter = new StateAdapter(this);
        mPager.setAdapter(mPagerAdapter);

        var tabLayout = (TabLayout) findViewById(R.id.tablayout);
        Utils.fixScrollableTabLayoutInsets(tabLayout);
        new TabLayoutMediator(tabLayout, mPager, (tab, position) ->
                tab.setText(getString(mPagerAdapter.getPageTitle(position)))
        ).attach();

        mPager.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() {
            @Override
            public void onPageSelected(int position) {
                updateMenuVisibility();
            }
        });
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.http_details_menu, menu);

        mMenuPrev = menu.findItem(R.id.navigate_before);
        mMenuNext = menu.findItem(R.id.navigate_next);
        mMenuDisplayAs = menu.findItem(R.id.display_as);

        updateNavigationButtons();
        updateMenuVisibility();
        return true;
    }

    private void updateNavigationButtons() {
        if(mMenuPrev == null || mMenuNext == null)
            return;

        boolean hasPrev, hasNext;

        if (mFilteredPositions != null) {
            // Using filtered navigation
            hasPrev = mFilteredIndex > 0;
            hasNext = mFilteredIndex < mFilteredPositions.size() - 1;
        } else {
            // Using unfiltered navigation
            HttpLog httpLog = CaptureService.getHttpLog();
            int httpLogSize = (httpLog != null) ? httpLog.getSize() : 0;
            hasPrev = mReqPos > 0;
            hasNext = mReqPos < httpLogSize - 1;
        }

        mMenuPrev.setEnabled(hasPrev);
        if(mMenuPrev.getIcon() != null)
            mMenuPrev.getIcon().setAlpha(hasPrev ? 255 : 80);

        mMenuNext.setEnabled(hasNext);
        if(mMenuNext.getIcon() != null)
            mMenuNext.getIcon().setAlpha(hasNext ? 255 : 80);
    }

    @Override
    public void updateMenuVisibility() {
        if(mMenuDisplayAs == null)
            return;

        mMenuDisplayAs.setVisible(true);

        Fragment currentFragment = getCurrentFragment();
        if(currentFragment instanceof HttpPayloadFragment payloadFragment) {
            if(mDisplayMode == null)
                mDisplayMode = true;

            payloadFragment.setDisplayMode(mDisplayMode);

            if(mDisplayMode)
                mMenuDisplayAs.setTitle(R.string.display_as_hexdump);
            else
                mMenuDisplayAs.setTitle(R.string.display_as_text);
        } else if(currentFragment instanceof ConnectionPayload wsFragment) {
            if(mDisplayMode == null)
                mDisplayMode = true;

            wsFragment.setDisplayMode(mDisplayMode);

            if(mDisplayMode)
                mMenuDisplayAs.setTitle(R.string.display_as_hexdump);
            else
                mMenuDisplayAs.setTitle(R.string.display_as_text);
        }
    }

    private Fragment getCurrentFragment() {
        int currentTab = mPager.getCurrentItem();
        String tag = "f" + mPagerAdapter.getItemId(currentTab);
        return getSupportFragmentManager().findFragmentByTag(tag);
    }

    @Override
    public boolean onOptionsItemSelected(@NonNull MenuItem item) {
        int itemId = item.getItemId();

        if(itemId == R.id.navigate_before) {
            navigateToPrevious();
            return true;
        } else if(itemId == R.id.navigate_next) {
            navigateToNext();
            return true;
        } else if(itemId == R.id.display_as) {
            if(mDisplayMode != null) {
                mDisplayMode = !mDisplayMode;
                updateMenuVisibility();
            }
            return true;
        } else if(itemId == R.id.save_as_har) {
            openHarFileSelector();
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    private void navigateToPrevious() {
        if (mFilteredPositions != null) {
            if (mFilteredIndex > 0) {
                mFilteredIndex--;
                mReqPos = mFilteredPositions.get(mFilteredIndex);
                loadHttpRequest();
            }
        } else {
            if (mReqPos > 0) {
                mReqPos--;
                loadHttpRequest();
            }
        }
    }

    private void navigateToNext() {
        if (mFilteredPositions != null) {
            if (mFilteredIndex < mFilteredPositions.size() - 1) {
                mFilteredIndex++;
                mReqPos = mFilteredPositions.get(mFilteredIndex);
                loadHttpRequest();
            }
        } else {
            HttpLog httpLog = CaptureService.getHttpLog();
            int httpLogSize = (httpLog != null) ? httpLog.getSize() : 0;

            if (mReqPos < httpLogSize - 1) {
                mReqPos++;
                loadHttpRequest();
            }
        }
    }

    private void loadHttpRequest() {
        HttpLog httpLog = CaptureService.getHttpLog();
        if(httpLog != null) {
            mHttpReq = httpLog.getRequest(mReqPos);

            if(mHttpReq != null) {
                setTitle(String.format(getString(R.string.http_request_number), mReqPos + 1));

                // Check if this HTTP request has associated websocket data
                mHasWebsocket = mHttpReq.hasWebsocketData();

                int currentTab = mPager.getCurrentItem();

                setupTabs();

                // Restore tab position if still valid for the new request
                int newItemCount = mPagerAdapter.getItemCount();
                if (currentTab < newItemCount) {
                    // Tab is still valid, restore it
                    mPager.setCurrentItem(currentTab, false);
                } else {
                    // Tab not available (e.g., no response), fall back to first tab
                    mPager.setCurrentItem(0, false);
                }

                updateNavigationButtons();
                updateMenuVisibility();
            } else {
                Log.w(TAG, "HTTP request with position " + mReqPos + " not found");
            }
        }
    }

    private void registerConnsListener() {
        ConnectionsRegister reg = CaptureService.getConnsRegister();

        if((reg != null) && !mListenerSet) {
            if(mHttpReq.conn.status < ConnectionDescriptor.CONN_STATUS_CLOSED) {
                Log.d(TAG, "Adding connections listener");
                reg.addListener(this);
                mListenerSet = true;
            }
        }

        dispatchConnUpdate();
    }

    private void unregisterConnsListener() {
        if(mListenerSet) {
            ConnectionsRegister reg = CaptureService.getConnsRegister();

            if(reg != null) {
                Log.d(TAG, "Removing connections listener");
                reg.removeListener(this);
            }

            mListenerSet = false;
        }
    }

    @Override
    public void connectionsChanges(int num_connections) {}

    @Override
    public void connectionsAdded(int start, ConnectionDescriptor[] conns) {}

    @Override
    public void connectionsRemoved(int start, ConnectionDescriptor[] conns) {}

    @Override
    public void connectionsUpdated(int[] positions) {
        ConnectionsRegister reg = CaptureService.getConnsRegister();

        if((reg == null) || (mHttpReq == null))
            return;

        for(int pos : positions) {
            ConnectionDescriptor conn = reg.getConn(pos);

            if((conn != null) && (conn.incr_id == mHttpReq.conn.incr_id)) {
                mHandler.post(this::dispatchConnUpdate);
                break;
            }
        }
    }

    @Override
    public void addConnUpdateListener(PayloadHostActivity.ConnUpdateListener listener) {
        mListeners.add(listener);
    }

    @Override
    public void removeConnUpdateListener(PayloadHostActivity.ConnUpdateListener listener) {
        mListeners.remove(listener);
    }

    private void dispatchConnUpdate() {
        for(PayloadHostActivity.ConnUpdateListener listener: mListeners)
            listener.connectionUpdated();

        // Check if websocket tab needs to be added
        if(!mHasWebsocket && (mHttpReq != null) && mHttpReq.hasWebsocketData()) {
            mHasWebsocket = true;
            mPagerAdapter.notifyDataSetChanged();
        }

        if((mHttpReq != null) && (mHttpReq.conn.status >= ConnectionDescriptor.CONN_STATUS_CLOSED))
            unregisterConnsListener();
    }

    private void openHarFileSelector() {
        if (mHttpReq == null)
            return;

        boolean noFileDialog = false;
        String fname = Utils.getExportFileName(this, "har");
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        intent.putExtra(Intent.EXTRA_TITLE, fname);

        if(Utils.supportsFileDialog(this, intent)) {
            try {
                harFileLauncher.launch(intent);
            } catch (ActivityNotFoundException e) {
                noFileDialog = true;
            }
        } else
            noFileDialog = true;

        if(noFileDialog) {
            Log.d(TAG, "No app found to handle file selection");

            Uri uri = Utils.getDownloadsUri(this, fname);

            if(uri != null) {
                mHarFname = uri;
                exportHar();
            } else
                Utils.showToastLong(this, R.string.no_activity_file_selection);
        }
    }

    private void exportHar() {
        if(mHarFname == null || mHttpReq == null)
            return;

        Log.d(TAG, "Writing HAR file: " + mHarFname);

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Handler handler = new Handler(Looper.getMainLooper());
        final boolean[] cancelled = {false};

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(R.string.exporting);
        builder.setMessage(R.string.export_in_progress);
        builder.setNegativeButton(android.R.string.cancel, (dialog, which) -> {
            Log.i(TAG, "Abort HAR export");
            cancelled[0] = true;
            executor.shutdownNow();
        });

        mAlertDialog = builder.create();
        mAlertDialog.setCanceledOnTouchOutside(false);
        mAlertDialog.show();

        mAlertDialog.setOnCancelListener(dialog -> {
            Log.i(TAG, "Abort HAR export (back button)");
            cancelled[0] = true;
            executor.shutdownNow();
        });
        mAlertDialog.setOnDismissListener(dialog -> mAlertDialog = null);

        final Uri harFname = mHarFname;
        final HttpLog.HttpRequest httpReq = mHttpReq;
        mHarFname = null;

        executor.execute(() -> {
            boolean success = false;

            try {
                OutputStream stream = getContentResolver().openOutputStream(harFname, "rwt");

                if(stream != null) {
                    HarWriter writer = new HarWriter(HttpDetailsActivity.this, httpReq);
                    writer.write(stream);
                    stream.close();
                    success = true;
                }
            } catch (IOException e) {
                if(!cancelled[0])
                    e.printStackTrace();
            }

            if(cancelled[0])
                return;

            final boolean result = success;
            final Utils.UriStat stat = result ? Utils.getUriStat(HttpDetailsActivity.this, harFname) : null;

            handler.post(() -> {
                if(mAlertDialog != null)
                    mAlertDialog.dismiss();

                if(result) {
                    if(stat != null)
                        Utils.showToast(HttpDetailsActivity.this, R.string.file_saved_with_name, stat.name);
                    else
                        Utils.showToast(HttpDetailsActivity.this, R.string.save_ok);
                } else
                    Utils.showToast(HttpDetailsActivity.this, R.string.cannot_write_file);
            });
        });
    }

    private void harFileResult(final ActivityResult result) {
        if((result.getResultCode() == RESULT_OK) && (result.getData() != null)) {
            mHarFname = result.getData().getData();
            exportHar();
        } else {
            mHarFname = null;
        }
    }

    private class StateAdapter extends FragmentStateAdapter {
        StateAdapter(final FragmentActivity fa) { super(fa); }

        @NonNull
        @Override
        public Fragment createFragment(int position) {
            //Log.d(TAG, "createFragment");
            int req_pos = mHttpReq.getPosition();
            int pos = getVisibleTabsPositions()[position];

            switch (pos) {
                case POS_REPLY:
                    return HttpPayloadFragment.newInstance(req_pos, true);
                case POS_WEBSOCKET:
                    return ConnectionPayload.newInstance(PayloadChunk.ChunkType.WEBSOCKET, mHttpReq.conn.incr_id);
                case POS_REQUEST:
                default:
                    return HttpPayloadFragment.newInstance(req_pos, false);
            }
        }

        @Override
        public int getItemCount() {
            // Request tab is always shown
            // Reply tab shown if there's a reply
            // Websocket tab shown if there's websocket data
            int count = 1;  // Request tab
            if (mHttpReq.reply != null)
                count++;    // Reply tab
            if (mHasWebsocket)
                count++;    // Websocket tab
            return count;
        }

        public int getPageTitle(final int position) {
            int pos = getVisibleTabsPositions()[position];

            switch (pos) {
                case POS_REPLY:
                    return R.string.response;
                case POS_WEBSOCKET:
                    return R.string.websocket;
                default:
                    return R.string.request;
            }
        }

        public int[] getVisibleTabsPositions() {
            int[] visible = new int[getItemCount()];
            int i = 0;

            visible[i++] = POS_REQUEST;

            if (mHttpReq.reply != null)
                visible[i++] = POS_REPLY;
            if (mHasWebsocket)
                visible[i] = POS_WEBSOCKET;

            return visible;
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/HttpLogFilterActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */
package com.emanuelef.remote_capture.activities;

import android.content.Intent;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.appcompat.app.ActionBar;
import androidx.collection.ArraySet;
import androidx.core.view.MenuProvider;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.HttpLog;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.HttpLogFilterDescriptor;
import com.google.android.material.chip.Chip;
import com.google.android.material.chip.ChipGroup;
import com.google.android.material.slider.Slider;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

public class HttpLogFilterActivity extends BaseActivity implements MenuProvider {
    public static final String FILTER_DESCRIPTOR = "http_log_filter";
    private static final String TAG = "HttpLogFilterActivity";
    private HttpLogFilterDescriptor mFilter;
    private ChipGroup mMethodGroup;
    private ChipGroup mContentTypeGroup;
    private ChipGroup mHttpStatusGroup;
    private Slider mPayloadSizeSlider;
    private Chip mDecryptionErrorChip;
    private Chip mDecryptionNoErrorChip;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.http_log_filter_activity);
        setTitle(R.string.edit_filter);
        addMenuProvider(this);

        ActionBar actionBar = getSupportActionBar();
        if(actionBar != null) {
            actionBar.setDisplayHomeAsUpEnabled(true);
            actionBar.setHomeAsUpIndicator(R.drawable.ic_close);
        }

        Intent intent = getIntent();
        if(intent != null) {
            HttpLogFilterDescriptor desc = Utils.getSerializableExtra(intent, FILTER_DESCRIPTOR, HttpLogFilterDescriptor.class);
            if(desc != null)
                mFilter = desc;
        }
        if(mFilter == null)
            mFilter = new HttpLogFilterDescriptor();

        mMethodGroup = findViewById(R.id.method_group);
        mContentTypeGroup = findViewById(R.id.content_type_group);
        mHttpStatusGroup = findViewById(R.id.http_status_group);
        mPayloadSizeSlider = findViewById(R.id.payload_size_slider);
        mDecryptionErrorChip = findViewById(R.id.decryption_error_chip);
        mDecryptionNoErrorChip = findViewById(R.id.decryption_no_error_chip);

        // Populate filters from captured data
        HttpLog httpLog = CaptureService.getHttpLog();
        if(httpLog != null) {
            ArraySet<String> methods = new ArraySet<>();
            Set<String> contentTypes = new HashSet<>();
            Set<Integer> httpStatuses = new HashSet<>();
            long maxPayloadSize = 0;
            boolean hasDecryptionErrors = false;

            synchronized (httpLog) {
                for (int i = 0; i < httpLog.getSize(); i++) {
                    HttpLog.HttpRequest req = httpLog.getRequest(i);
                    if (req != null) {
                        if (req.method != null && !req.method.isEmpty())
                            methods.add(req.method.toUpperCase());

                        if (req.reply != null) {
                            if (req.reply.contentType != null && !req.reply.contentType.isEmpty())
                                contentTypes.add(req.reply.contentType);
                            if (req.reply.responseCode > 0)
                                httpStatuses.add(req.reply.responseCode);

                            int totalSize = req.bodyLength + req.reply.bodyLength;
                            if (totalSize > maxPayloadSize)
                                maxPayloadSize = totalSize;
                        }

                        if (!req.decryptionError.isEmpty())
                            hasDecryptionErrors = true;
                    }
                }
            }

            // Create method chips
            if (!methods.isEmpty()) {
                LayoutInflater inflater = getLayoutInflater();
                ArrayList<String> sortedMethods = new ArrayList<>(methods);
                sortedMethods.sort(String::compareTo);

                for (String method : sortedMethods) {
                    Chip chip = (Chip) inflater.inflate(R.layout.choice_chip, mMethodGroup, false);
                    chip.setText(method);
                    mMethodGroup.addView(chip);
                }
                mMethodGroup.setVisibility(View.VISIBLE);
                findViewById(R.id.method_label).setVisibility(View.VISIBLE);
            }

            // Create content-type chips
            if (!contentTypes.isEmpty()) {
                LayoutInflater inflater = getLayoutInflater();
                for (String contentType : contentTypes) {
                    Chip chip = (Chip) inflater.inflate(R.layout.choice_chip, mContentTypeGroup, false);
                    chip.setText(contentType);
                    mContentTypeGroup.addView(chip);
                }
                mContentTypeGroup.setVisibility(View.VISIBLE);
                findViewById(R.id.content_type_label).setVisibility(View.VISIBLE);
            }

            // Create HTTP status chips
            if (!httpStatuses.isEmpty()) {
                LayoutInflater inflater = getLayoutInflater();
                ArrayList<Integer> sortedStatuses = new ArrayList<>(httpStatuses);
                sortedStatuses.sort(Integer::compareTo);

                for (Integer status : sortedStatuses) {
                    Chip chip = (Chip) inflater.inflate(R.layout.choice_chip, mHttpStatusGroup, false);
                    chip.setText(String.valueOf(status));
                    mHttpStatusGroup.addView(chip);
                }
                mHttpStatusGroup.setVisibility(View.VISIBLE);
                findViewById(R.id.http_status_label).setVisibility(View.VISIBLE);
            }

            // Setup payload size slider
            long minSizeKB = mFilter.minPayloadSize / 1024;
            long maxSizeKB = maxPayloadSize / 1024;
            maxSizeKB = Math.max(maxSizeKB, minSizeKB);

            if (maxSizeKB >= 2) {
                mPayloadSizeSlider.setValueTo(maxSizeKB);
                mPayloadSizeSlider.setLabelFormatter(value -> Utils.formatBytes(((long) value) * 1024));
                mPayloadSizeSlider.setVisibility(View.VISIBLE);
                findViewById(R.id.payload_size_label).setVisibility(View.VISIBLE);
            }
        }

        model2view();
    }

    private void model2view() {
        long minSizeKB = mFilter.minPayloadSize / 1024;
        if (minSizeKB > 0)
            mPayloadSizeSlider.setValue(minSizeKB);

        // Set decryption error filter
        if (mFilter.decryptionError != null) {
            if (mFilter.decryptionError) {
                mDecryptionErrorChip.setChecked(true);
            } else {
                mDecryptionNoErrorChip.setChecked(true);
            }
        }

        // Set method
        if(mFilter.method != null) {
            int num_chips = mMethodGroup.getChildCount();
            for(int i=0; i<num_chips; i++) {
                Chip chip = (Chip) mMethodGroup.getChildAt(i);
                if(chip.getText().toString().equalsIgnoreCase(mFilter.method)) {
                    chip.setChecked(true);
                    break;
                }
            }
        }

        // Set content type
        if(mFilter.contentType != null) {
            int num_chips = mContentTypeGroup.getChildCount();
            for(int i=0; i<num_chips; i++) {
                Chip chip = (Chip) mContentTypeGroup.getChildAt(i);
                if(chip.getText().equals(mFilter.contentType)) {
                    chip.setChecked(true);
                    break;
                }
            }
        }

        // Set HTTP status
        if(mFilter.httpStatus != null) {
            int num_chips = mHttpStatusGroup.getChildCount();
            for(int i=0; i<num_chips; i++) {
                Chip chip = (Chip) mHttpStatusGroup.getChildAt(i);
                if(chip.getText().equals(String.valueOf(mFilter.httpStatus))) {
                    chip.setChecked(true);
                    break;
                }
            }
        }
    }

    private void view2model() {
        mFilter.minPayloadSize = ((long) mPayloadSizeSlider.getValue()) * 1024;

        // Get decryption error filter
        if (mDecryptionErrorChip.isChecked()) {
            mFilter.decryptionError = true;
        } else if (mDecryptionNoErrorChip.isChecked()) {
            mFilter.decryptionError = false;
        } else {
            mFilter.decryptionError = null;
        }

        // Get method
        int num_chips = mMethodGroup.getChildCount();
        mFilter.method = null;
        for(int i=0; i<num_chips; i++) {
            Chip chip = (Chip) mMethodGroup.getChildAt(i);
            if(chip.isChecked()) {
                mFilter.method = chip.getText().toString();
                break;
            }
        }

        // Get content type
        num_chips = mContentTypeGroup.getChildCount();
        mFilter.contentType = null;
        for(int i=0; i<num_chips; i++) {
            Chip chip = (Chip) mContentTypeGroup.getChildAt(i);
            if(chip.isChecked()) {
                mFilter.contentType = chip.getText().toString();
                break;
            }
        }

        // Get HTTP status
        num_chips = mHttpStatusGroup.getChildCount();
        mFilter.httpStatus = null;
        for(int i=0; i<num_chips; i++) {
            Chip chip = (Chip) mHttpStatusGroup.getChildAt(i);
            if(chip.isChecked()) {
                try {
                    mFilter.httpStatus = Integer.parseInt(chip.getText().toString());
                } catch (NumberFormatException e) {
                    // ignore
                }
                break;
            }
        }
    }

    private void finishOk() {
        view2model();
        Intent intent = new Intent();
        intent.putExtra(FILTER_DESCRIPTOR, mFilter);
        setResult(RESULT_OK, intent);
        finish();
    }

    @Override
    public boolean onSupportNavigateUp() {
        finishOk();
        return true;
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onBackPressed() {
        finishOk();
        super.onBackPressed();
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.edit_filter_menu, menu);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        if(item.getItemId() == R.id.reset_changes) {
            mFilter.clear();
            model2view();
            return true;
        }

        return false;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/LogviewActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.os.Bundle;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.viewpager2.adapter.FragmentStateAdapter;
import androidx.viewpager2.widget.ViewPager2;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.fragments.LogviewFragment;
import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;

public class LogviewActivity extends BaseActivity implements MenuProvider {
    private static final String TAG = "LogviewActivity";
    private ViewPager2 mPager;
    private StateAdapter mPagerAdapter;

    private static final int POS_APP_LOG = 0;
    private static final int POS_ROOT_LOG = 1;
    private static final int POS_MITM_LOG = 2;
    private static final int NUM_POS = 3;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.app_log);
        setContentView(R.layout.tabs_activity_fixed);
        addMenuProvider(this);

        mPager = findViewById(R.id.pager);
        Utils.fixViewPager2Insets(mPager);
        setupTabs();
    }

    private void setupTabs() {
        mPagerAdapter = new StateAdapter(this);
        mPager.setAdapter(mPagerAdapter);

        var tabLayout = (TabLayout) findViewById(R.id.tablayout);
        Utils.fixScrollableTabLayoutInsets(tabLayout);
        new TabLayoutMediator(tabLayout, mPager, (tab, position) ->
                tab.setText(getString(mPagerAdapter.getPageTitle(position)))
        ).attach();
    }

    private static class StateAdapter extends FragmentStateAdapter {
        final String mCacheDir;

        StateAdapter(final FragmentActivity fa) {
            super(fa);
            mCacheDir = fa.getCacheDir().getAbsolutePath();
        }

        @NonNull
        @Override
        public Fragment createFragment(int pos) {
            switch (pos) {
                case POS_APP_LOG:
                    return LogviewFragment.newInstance(mCacheDir + "/" + Log.DEFAULT_LOGGER_PATH);
                case POS_ROOT_LOG:
                    return LogviewFragment.newInstance(mCacheDir + "/" + Log.ROOT_LOGGER_PATH);
                case POS_MITM_LOG:
                default:
                    return LogviewFragment.newInstance(mCacheDir + "/" + Log.MITM_LOGGER_PATH);
            }
        }

        @Override
        public int getItemCount() {
            return NUM_POS;
        }

        public int getPageTitle(final int pos) {
            switch (pos) {
                case POS_APP_LOG:
                    return R.string.app;
                case POS_ROOT_LOG:
                    return R.string.root;
                case POS_MITM_LOG:
                default:
                    return R.string.mitm_addon;
            }
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // This is required to properly handle the DPAD down press on Android TV, to properly
        // focus the tab content
        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
            View view = getCurrentFocus();

            Log.d(TAG, "onKeyDown focus " + view.getClass().getName());

            if (view instanceof TabLayout.TabView) {
                int pos = mPager.getCurrentItem();
                View focusOverride = null;

                Log.d(TAG, "TabLayout.TabView focus pos " + pos);

                focusOverride = findViewById(R.id.scrollView);

                if (focusOverride != null) {
                    focusOverride.requestFocus();
                    return true;
                }
            }
        }

        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.log_menu, menu);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();
        LogviewFragment fragment = (LogviewFragment) getFragmentAtPos(mPager.getCurrentItem());
        if(fragment == null)
            return false;

        String logText = fragment.getLog();

        if(id == R.id.reload) {
            fragment.reloadLog();
            return true;
        } else if(id == R.id.copy_to_clipboard) {
            Utils.copyToClipboard(this, logText);
            return true;
        } else if(id == R.id.share) {
            Utils.shareText(this, getString(R.string.app_log), logText);
            return true;
        }

        return false;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/MainActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.Manifest;
import android.content.ActivityNotFoundException;
import android.content.ClipData;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.net.Uri;

import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts.RequestPermission;
import androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult;
import androidx.annotation.NonNull;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.ActionBarDrawerToggle;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.widget.Toolbar;
import androidx.core.content.pm.PackageInfoCompat;
import androidx.core.graphics.Insets;
import androidx.core.view.GravityCompat;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.drawerlayout.widget.DrawerLayout;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.preference.PreferenceManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.viewpager2.adapter.FragmentStateAdapter;
import androidx.viewpager2.widget.ViewPager2;

import android.os.Build;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.BuildConfig;
import com.emanuelef.remote_capture.CaptureHelper;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.MitmReceiver;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.VpnReconnectService;
import com.emanuelef.remote_capture.activities.prefs.SettingsActivity;
import com.emanuelef.remote_capture.fragments.ConnectionsFragment;
import com.emanuelef.remote_capture.fragments.DataViewContainerFragment;
import com.emanuelef.remote_capture.fragments.StatusFragment;
import com.emanuelef.remote_capture.interfaces.AppStateListener;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.AppState;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.model.Blocklist;
import com.emanuelef.remote_capture.model.CaptureSettings;
import com.emanuelef.remote_capture.MitmAddon;
import com.emanuelef.remote_capture.model.CaptureStats;
import com.emanuelef.remote_capture.model.ListInfo;
import com.emanuelef.remote_capture.model.Prefs;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.google.android.material.navigation.NavigationView;
import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashSet;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MainActivity extends BaseActivity implements NavigationView.OnNavigationItemSelectedListener {
    private Billing mIab;
    private ViewPager2 mPager;
    private AppState mState;
    private AppStateListener mListener;
    private File mKeylogFile;
    private DrawerLayout mDrawer;
    private SharedPreferences mPrefs;
    private NavigationView mNavView;
    private CaptureHelper mCapHelper;
    private AlertDialog mPcapLoadDialog;
    private Uri mPcapUri;
    private ExecutorService mPcapExecutor;

    // helps detecting duplicate state reporting of STOPPED in MutableLiveData
    private boolean mWasStarted = false;
    private boolean mStartPressed = false;
    private boolean mDecEmptyRulesNoticeShown = false;
    private boolean mExtensionsNoticeShown = false;
    private boolean mOpenPcapDecrypt = false;
    private boolean mDecryptPcap = false;

    private static final String TAG = "Main";

    private static final int POS_STATUS = 0;
    private static final int POS_CONNECTIONS = 1;
    private static final int TOTAL_COUNT = 2;

    public static final String TELEGRAM_GROUP_NAME = "PCAPdroid";
    public static final String GITHUB_PROJECT_URL = "https://github.com/emanuele-f/PCAPdroid";
    public static final String DOCS_URL = "https://emanuele-f.github.io/PCAPdroid";
    public static final String PRIVACY_POLICY_URL = DOCS_URL + "/privacy";
    public static final String DONATE_URL = "https://emanuele-f.github.io/PCAPdroid/donate";
    public static final String TLS_DECRYPTION_DOCS_URL = DOCS_URL + "/tls_decryption";
    public static final String PAID_FEATURES_URL = DOCS_URL + "/paid_features";
    public static final String FIREWALL_DOCS_URL = PAID_FEATURES_URL + "#51-firewall";
    public static final String MALWARE_DETECTION_DOCS_URL = PAID_FEATURES_URL + "#52-malware-detection";
    public static final String API_DOCS_URL = GITHUB_PROJECT_URL + "/blob/master/docs/app_api.md";
    public static final String PCAPNG_DOCS_URL = PAID_FEATURES_URL + "#53-pcapng-format";

    private final ActivityResultLauncher<Intent> sslkeyfileExportLauncher =
            registerForActivityResult(new StartActivityForResult(), this::sslkeyfileExportResult);
    private final ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new RequestPermission(), isGranted ->
                Log.d(TAG, "Write permission " + (isGranted ? "granted" : "denied"))
            );
    private final ActivityResultLauncher<Intent> peerInfoLauncher =
            registerForActivityResult(new StartActivityForResult(), this::peerInfoResult);
    private final ActivityResultLauncher<Intent> pcapFileOpenLauncher =
            registerForActivityResult(new StartActivityForResult(), this::pcapFileOpenResult);
    private final ActivityResultLauncher<Intent> keylogFileOpenLauncher =
            registerForActivityResult(new StartActivityForResult(), this::keylogFileOpenResult);

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setTheme(R.style.AppTheme_NoActionBar);
        super.onCreate(savedInstanceState);

        setContentView(R.layout.main_activity);
        setTitle("PCAPdroid");
        mPrefs = PreferenceManager.getDefaultSharedPreferences(this);

        int appver = Prefs.getAppVersion(mPrefs);
        if(appver <= 0) {
            // First run, start on-boarding
            // only refresh app version on on-boarding done
            Intent intent = new Intent(MainActivity.this, OnBoardingActivity.class);
            startActivity(intent);
            finish();
            return;
        } else {
            if (appver < 90)
                showWhatsNew();

            Prefs.refreshAppVersion(mPrefs);
        }

        mIab = Billing.newInstance(this);
        mIab.setLicense(mIab.getLicense());

        initPeerAppInfo();
        initAppState();
        checkPermissions();

        mCapHelper = new CaptureHelper(this);
        mCapHelper.setListener(success -> {
            if(!success) {
                Log.w(TAG, "Capture start failed");
                appStateReady();
            }
        });

        mPager = findViewById(R.id.pager);
        Utils.fixViewPager2Insets(mPager);
        setupTabs();

        /* Register for service status */
        CaptureService.observeStatus(this, serviceStatus -> {
            Log.d(TAG, "Service status: " + serviceStatus.name());

            if (serviceStatus == CaptureService.ServiceStatus.STARTED) {
                appStateRunning();
                mWasStarted = true;
            } else if(mWasStarted) { /* STARTED -> STOPPED */
                // The service may still be active (on premature native termination)
                if (CaptureService.isServiceActive())
                    CaptureService.stopService();

                mKeylogFile = MitmReceiver.getKeylogFilePath(MainActivity.this);
                if(!mKeylogFile.exists() || !CaptureService.isDecryptingTLS())
                    mKeylogFile = null;

                Log.d(TAG, "sslkeylog? " + (mKeylogFile != null));

                CaptureSettings settings = CaptureService.getCaptureSettings();

                // do not show "PCAP saved" dialog and keylog export if capture was started through API
                if((settings != null) && settings.api_capture) {
                    if(mKeylogFile != null) {
                        // save SSLKEYLOGFILE to Downloads directory
                        if (!settings.sslkeylog_name.isBlank()) {
                            Uri uri = Utils.getDownloadsUri(MainActivity.this, settings.sslkeylog_name);
                            if (uri != null) {
                                try (OutputStream out = getContentResolver().openOutputStream(uri, "rwt")) {
                                    Utils.copy(mKeylogFile, out);
                                    Utils.showToast(this, R.string.save_ok);
                                } catch (IOException e) {
                                    e.printStackTrace();
                                    Utils.showToastLong(this, R.string.export_failed);
                                }
                            } else
                                Log.e(TAG, "Cannot export keylog to " + settings.sslkeylog_name);
                        }

                        // if capture was started through API, we automatically delete the keylog here after optionally dumping it to provided file
                        //noinspection ResultOfMethodCallIgnored
                        mKeylogFile.delete();
                        mKeylogFile = null;
                    }

                    // reset the decryption list after API capture in case it was set
                    if(!settings.decryption_rules_json.isBlank())
                        PCAPdroid.getInstance().getDecryptionList().reload();
                } else {
                    if ((Prefs.getDumpMode(mPrefs) == Prefs.DumpMode.PCAP_FILE)) {
                        showPcapActionDialog();

                        // will export the keylogfile after saving/sharing pcap
                    } else if (mKeylogFile != null)
                        startExportSslkeylogfile();
                }
                appStateReady();
                mWasStarted = false;
                mStartPressed = false;
            } else /* STOPPED -> STOPPED */
                appStateReady();
        });
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        if(!CaptureService.isServiceActive()) {
            boolean ignored = getTmpPcapPath().delete();
        }

        mCapHelper = null;
    }

    @Override
    protected void onPostCreate(Bundle savedInstanceState) {
        super.onPostCreate(savedInstanceState);
        setupNavigationDrawer();
    }

    @Override
    protected void onResume() {
        super.onResume();

        if(mNavView != null) {
            Menu navMenu = mNavView.getMenu();
            navMenu.findItem(R.id.tls_decryption).setVisible(Prefs.getTlsDecryptionEnabled(mPrefs) && !Prefs.isRootCaptureEnabled(mPrefs));
        }

        checkPaidDrawerEntries();
    }

    private void setupNavigationDrawer() {
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        mDrawer = findViewById(R.id.drawer_layout);
        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, mDrawer, toolbar, R.string.open_nav_drawer, R.string.close_nav_drawer);
        mDrawer.addDrawerListener(toggle);
        toggle.syncState();

        ViewCompat.setOnApplyWindowInsetsListener(mDrawer, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());

            // layout hamburger menu and drawer when in horizontal orientation
            ViewGroup.MarginLayoutParams mlp = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
            mlp.leftMargin = insets.left;
            mlp.rightMargin = insets.right;

            // only pass down the vertical insets
            return windowInsets.inset(insets.left, 0, insets.right, 0);
        });

        mNavView = findViewById(R.id.nav_view);
        mNavView.setNavigationItemSelectedListener(this);
        View header = mNavView.getHeaderView(0);

        TextView appVer = header.findViewById(R.id.app_version);
        String verStr = Utils.getAppVersion(this);
        appVer.setText(verStr);
        appVer.setOnClickListener((ev) -> {
            // e.g. it can be "1.5.2" or "1.5.2-2f2d3c8"
            String ref = verStr;
            int sep = ref.indexOf('-');
            if(sep != -1)
                ref = ref.substring(sep + 1);

            Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(GITHUB_PROJECT_URL + "/tree/" + ref));
            Utils.startActivity(this, browserIntent);
        });
    }

    private void showWhatsNew() {
        new AlertDialog.Builder(this)
                .setTitle(R.string.whats_new)
                .setMessage(
                        "- New HTTP requests view\n" +
                        "- Export HTTP data in the HAR format\n" +
                        "- Add Portuguese (BR) translation\n" +
                        "- Support the zstd compression\n" +
                        "- Pretty-print JSON in HTTP data\n" +
                        "- Fix HTTP/2 and WebSocket handling\n"
                )
                .setNeutralButton(R.string.ok, (dialogInterface, i) -> {})
                .show();
    }

    // keep this in a separate function, used by play billing code
    private void checkPaidDrawerEntries() {
        if(mNavView == null)
            return;
        Menu navMenu = mNavView.getMenu();
        navMenu.findItem(R.id.malware_detection).setVisible(Prefs.isMalwareDetectionEnabled(this, mPrefs));
        navMenu.findItem(R.id.firewall).setVisible(mIab.isFirewallVisible());
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onBackPressed() {
        if(mDrawer.isDrawerOpen(GravityCompat.START))
            mDrawer.closeDrawer(GravityCompat.START, true);
        else {
            if(mPager.getCurrentItem() == POS_CONNECTIONS) {
                Fragment container = getFragmentAtPos(POS_CONNECTIONS);

                if((container != null) && (container instanceof DataViewContainerFragment)) {
                    if(((DataViewContainerFragment)container).onBackPressed())
                        return;
                }
            }

            super.onBackPressed();
        }
    }

    private void checkPermissions() {
        if(Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                // Needed to write PCAP files
                if (checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                    try {
                        requestPermissionLauncher.launch(Manifest.permission.WRITE_EXTERNAL_STORAGE);
                    } catch (ActivityNotFoundException e) {
                        Utils.showToastLong(this, R.string.no_intent_handler_found);
                    }
                }
            }
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if(checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {
                if(shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)) {
                    AlertDialog dialog = new AlertDialog.Builder(this)
                            .setMessage(R.string.notifications_notice)
                            .setPositiveButton(R.string.ok, (d, whichButton) -> requestNotificationPermission())
                            .show();

                    dialog.setCanceledOnTouchOutside(false);
                } else
                    requestNotificationPermission();
            }
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
    private void requestNotificationPermission() {
        try {
            requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);
        } catch (ActivityNotFoundException e) {
            Utils.showToastLong(this, R.string.no_intent_handler_found);
        }
    }

    // On debug builds, if the user also has the non-debug app installed (peer app), unlock the
    // already-purchased features also on this beta app
    private void initPeerAppInfo() {
        if(!BuildConfig.APPLICATION_ID.equals("com.emanuelef.remote_capture.debug"))
            return;

        final String peerAppPackage = "com.emanuelef.remote_capture";

        AppDescriptor peer = AppsResolver.resolveInstalledApp(getPackageManager(), peerAppPackage, 0);
        if(peer == null) {
            Log.d(TAG, "Peer app not found");
            mIab.clearPeerSkus();
            return;
        }

        PackageInfo pInfo = peer.getPackageInfo();
        if((pInfo == null) || (PackageInfoCompat.getLongVersionCode(pInfo) < 56)) {
            Log.d(TAG, "Unsupported peer app version found");
            mIab.clearPeerSkus();
            return;
        }

        // Verify that the peer signature
        Utils.BuildType buildType = Utils.getVerifiedBuild(this, peerAppPackage);
        if((buildType != Utils.BuildType.FDROID) && (buildType != Utils.BuildType.PLAYSTORE) && (buildType != Utils.BuildType.GITHUB)) {
            Log.d(TAG, "Unsupported peer app build: " + buildType.name());
            mIab.clearPeerSkus();
            return;
        }

        Log.d(TAG, "Valid peer app found (" + pInfo.versionName + " - " + PackageInfoCompat.getLongVersionCode(pInfo) + ")");
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setClassName(peerAppPackage, "com.emanuelef.remote_capture.activities.CaptureCtrl");
        intent.putExtra("action", "get_peer_info");

        try {
            peerInfoLauncher.launch(intent);
        } catch (ActivityNotFoundException e) {
            Log.d(TAG, "Peer app launch failed");
            mIab.clearPeerSkus();
        }
    }

    private void peerInfoResult(final ActivityResult result) {
        if((result.getResultCode() == RESULT_OK) && (result.getData() != null)) {
            Intent data = result.getData();

            try {
                @SuppressWarnings("unchecked")
                HashSet<String> skus = Utils.getSerializableExtra(data, "skus", HashSet.class);

                if(skus != null) {
                    Log.d(TAG, "Found peer app info");

                    mIab.handlePeerSkus(skus);

                    // success
                    return;
                }
            } catch (ClassCastException ignored) {}
        }

        // fail
        Log.d(TAG, "Invalid peer app result");
        mIab.clearPeerSkus();
    }

    private static class MainStateAdapter extends FragmentStateAdapter {
        MainStateAdapter(final FragmentActivity fa) { super(fa); }

        @NonNull
        @Override
        public Fragment createFragment(int position) {
            Log.d(TAG, "createFragment");

            switch (position) {
                default: // Deliberate fall-through to status tab
                case POS_STATUS:
                    return new StatusFragment();
                case POS_CONNECTIONS:
                    return new DataViewContainerFragment();
            }
        }

        @Override
        public int getItemCount() {  return TOTAL_COUNT;  }

        public int getPageTitle(final int position) {
            switch (position) {
                default: // Deliberate fall-through to status tab
                case POS_STATUS:
                    return R.string.status;
                case POS_CONNECTIONS:
                    return R.string.connections_view;
            }
        }
    }

    private void setupTabs() {
        final MainStateAdapter stateAdapter = new MainStateAdapter(this);
        mPager.setAdapter(stateAdapter);

        new TabLayoutMediator(findViewById(R.id.tablayout), mPager, (tab, position) ->
                tab.setText(getString(stateAdapter.getPageTitle(position)))
        ).attach();

        View switchButton = findViewById(R.id.tab_switch_button);
        if (switchButton != null) {
            switchButton.setOnClickListener(v -> {
                if (mPager.getCurrentItem() != POS_CONNECTIONS) {
                    // Switch to Connections tab first, then toggle after fragment is created
                    mPager.setCurrentItem(POS_CONNECTIONS);
                    mPager.post(this::toggleDataView);
                } else {
                    toggleDataView();
                }
            });
        }
    }

    private void toggleDataView() {
        Fragment container = getFragmentAtPos(POS_CONNECTIONS);
        if (container instanceof DataViewContainerFragment) {
            ((DataViewContainerFragment) container).toggleView();
        }
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // This is required to properly handle the DPAD down press on Android TV, to properly
        // focus the tab content
        if(keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
            View view = getCurrentFocus();

            Log.d(TAG, "onKeyDown focus " + view.getClass().getName());

            if(view instanceof TabLayout.TabView) {
                int pos = mPager.getCurrentItem();
                View focusOverride = null;

                Log.d(TAG, "TabLayout.TabView focus pos " + pos);

                if(pos == POS_STATUS)
                    focusOverride = findViewById(R.id.main_screen);
                else if(pos == POS_CONNECTIONS)
                    focusOverride = findViewById(R.id.connections_view);

                if(focusOverride != null) {
                    focusOverride.requestFocus();
                    return true;
                }
            }
        } else if(keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
            // Clicking "right" from the connections view goes to the fab down item
            if(mPager.getCurrentItem() == POS_CONNECTIONS) {
                RecyclerView rview = findViewById(R.id.connections_view);

                if(rview.getFocusedChild() != null) {
                    Log.d(TAG, "onKeyDown (right) focus " + rview.getFocusedChild());

                    View fab = findViewById(R.id.fabDown);

                    if(fab != null) {
                        fab.requestFocus();
                        return true;
                    }
                }
            }
        }

        return super.onKeyDown(keyCode, event);
    }

    public boolean onNavigationItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.item_apps) {
            if(CaptureService.getConnsRegister() != null) {
                Intent intent = new Intent(MainActivity.this, AppsActivity.class);
                startActivity(intent);
            } else
                Utils.showToast(this, R.string.start_capture_first);
        } else if(id == R.id.malware_detection) {
            Intent intent = new Intent(MainActivity.this, MalwareDetection.class);
            startActivity(intent);
        } else if(id == R.id.tls_decryption) {
            Intent intent = new Intent(MainActivity.this, EditListActivity.class);
            intent.putExtra(EditListActivity.LIST_TYPE_EXTRA, ListInfo.Type.DECRYPTION_LIST);
            startActivity(intent);
        } else if(id == R.id.firewall) {
            Intent intent = new Intent(MainActivity.this, FirewallActivity.class);
            startActivity(intent);
        } else if(id == R.id.open_log) {
            Intent intent = new Intent(MainActivity.this, LogviewActivity.class);
            startActivity(intent);
        } else if (id == R.id.action_donate) {
            Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(DONATE_URL));
            Utils.startActivity(this, browserIntent);
        } else if (id == R.id.action_open_telegram) {
            openTelegram();
        } else if (id == R.id.action_open_user_guide) {
            Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(DOCS_URL));
            Utils.startActivity(this, browserIntent);
        } else if (id == R.id.action_stats) {
            if(mState == AppState.running) {
                Intent intent = new Intent(MainActivity.this, StatsActivity.class);
                startActivity(intent);
            } else
                Utils.showToast(this, R.string.start_capture_first);
        } else if (id == R.id.action_about) {
            Intent intent = new Intent(MainActivity.this, AboutActivity.class);
            startActivity(intent);
        } else if (id == R.id.action_share_app) {
            String description = getString(R.string.about_text);
            String getApp = getString(R.string.get_app);
            String url = "https://play.google.com/store/apps/details?id=com.emanuelef.remote_capture";

            Intent intent = new Intent(android.content.Intent.ACTION_SEND);
            intent.setType("text/plain");
            intent.putExtra(android.content.Intent.EXTRA_TEXT, description + "\n" + getApp + "\n" + url);

            Utils.startActivity(this, Intent.createChooser(intent, getResources().getString(R.string.share)));
        }

        return false;
    }

    public void setAppStateListener(AppStateListener listener) {
        mListener = listener;
    }

    private void notifyAppState() {
        if(mListener != null)
            mListener.appStateChanged(mState);
    }

    public void appStateReady() {
        mState = AppState.ready;
        notifyAppState();
        updateTabSwitchButton();

        if(mPcapLoadDialog != null)
            checkLoadedPcap();
    }

    public void appStateStarting() {
        mState = AppState.starting;
        notifyAppState();
    }

    public void appStateRunning() {
        mState = AppState.running;
        notifyAppState();
        updateTabSwitchButton();

        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q)
            checkVpnLockdownNotice();
        else if(mStartPressed) { // STOPPED -> STARTED
            if(CaptureService.isDecryptingTLS() && !CaptureService.isCapturingAsRoot())
                checkDecryptionRulesNotice();
        }

        if (mIab.isFirewallVisible()) {
            Blocklist blocklist = PCAPdroid.getInstance().getBlocklist();
            if (blocklist.hasCountryRules())
                blocklist.showNoticeIfGeoMissing(this);
        }
    }

    public void appStateStopping() {
        mState = AppState.stopping;
        notifyAppState();
    }

    private void updateTabSwitchButton() {
        View switchButton = findViewById(R.id.tab_switch_button);
        if (switchButton != null) {
            boolean httpLogAvailable = (CaptureService.getHttpLog() != null);
            switchButton.setVisibility(httpLogAvailable ? android.view.View.VISIBLE : android.view.View.GONE);
        }
    }

    private void checkDecryptionRulesNotice() {
        if(!mDecEmptyRulesNoticeShown && PCAPdroid.getInstance().getDecryptionList().isEmpty()) {
            new AlertDialog.Builder(this)
                    .setMessage(R.string.tls_decryption_no_rules_notice)
                    .setPositiveButton(R.string.yes, (d, whichButton) -> {
                        Intent intent = new Intent(MainActivity.this, EditListActivity.class);
                        intent.putExtra(EditListActivity.LIST_TYPE_EXTRA, ListInfo.Type.DECRYPTION_LIST);
                        startActivity(intent);
                    })
                    .setNegativeButton(R.string.no, (d, whichButton) -> {
                    })
                    .show();
            mDecEmptyRulesNoticeShown = true;
        }
    }

    private void dismissPcapLoadDialog() {
        if(mPcapLoadDialog != null) {
            mPcapLoadDialog.dismiss();
            mPcapLoadDialog = null;
        }

        mPcapExecutor = null;
        mPcapUri = null;
    }

    private void checkLoadedPcap() {
        dismissPcapLoadDialog();

        if(!CaptureService.hasError()) {
            // pcap file loaded successfully
            ConnectionsRegister reg = CaptureService.getConnsRegister();

            if((reg != null) && (reg.getConnCount() > 0)
                    && !CaptureService.hasSeenDumpExtensions()
                    && !mExtensionsNoticeShown
            ) {
                new AlertDialog.Builder(this)
                        .setMessage(getString(R.string.pcapdroid_trailer_notice,
                                getString(R.string.unknown_app), getString(R.string.dump_extensions)))
                        .setPositiveButton(R.string.ok, (d, whichButton) -> mExtensionsNoticeShown = true)
                        .show();
            } else
                Utils.showToastLong(this, R.string.pcap_load_success);

            mPager.setCurrentItem(POS_CONNECTIONS);
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.Q)
    private void checkVpnLockdownNotice() {
        if(!Prefs.lockdownVpnNoticeShown(mPrefs) && Prefs.isFirewallEnabled(this, mPrefs) && !CaptureService.isLockdownVPN()) {
            AlertDialog dialog = new AlertDialog.Builder(this)
                    .setMessage(R.string.vpn_lockdown_notice)
                    .setPositiveButton(R.string.yes, (d, whichButton) -> Utils.startActivity(this, new Intent("android.net.vpn.SETTINGS")))
                    .setNegativeButton(R.string.no, (d, whichButton) -> {})
                    .show();
            dialog.setCanceledOnTouchOutside(false);

            Prefs.setLockdownVpnNoticeShown(mPrefs);
        }
    }

    private void openTelegram() {
        Intent intent;

        try {
            Utils.getPackageInfo(getPackageManager(), "org.telegram.messenger", 0);

            // Open directly into the telegram app
            intent = new Intent(Intent.ACTION_VIEW, Uri.parse("tg://resolve?domain=" + TELEGRAM_GROUP_NAME));
        } catch (Exception e) {
            // Telegram not found, open in the browser
            intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://t.me/" + TELEGRAM_GROUP_NAME));
        }

        Utils.startActivity(this, intent);
    }

    /*private void rateApp() {
        try {
            // If playstore is installed
            startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=" + this.getPackageName())));
        } catch (android.content.ActivityNotFoundException e) {
            // If playstore is not available
            startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://play.google.com/store/apps/details?id=" + this.getPackageName())));
        }
    }*/

    @Override
    public boolean onOptionsItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.action_start) {
            mStartPressed = true;
            startCapture();
            return true;
        } else if(id == R.id.action_stop) {
            stopCapture();
            return true;
        } else if(id == R.id.open_pcap) {
            selectOpenPcapFile(false);
            return true;
        } else if(id == R.id.decrypt_pcap) {
            selectOpenPcapFile(true);
            return true;
        } else if (id == R.id.action_settings) {
            Intent intent = new Intent(MainActivity.this, SettingsActivity.class);
            startActivity(intent);
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    private void initAppState() {
        boolean is_active = CaptureService.isServiceActive();

        if (!is_active) {
            appStateReady();

            // PCAPdroid could have been closed unexpectedly (e.g. due to low memory), try to export
            // the keylog file if exists
            mKeylogFile = MitmReceiver.getKeylogFilePath(MainActivity.this);
            if(mKeylogFile.exists())
                startExportSslkeylogfile();
        } else
            appStateRunning();
    }

    private void doStartCaptureService(String input_pcap_path) {
        if (mCapHelper == null) {
            Log.e(TAG, "Activity destroyed, capture cannot start");
            return;
        }

        appStateStarting();

        // Clear loaded basename if this is a new capture (not from loaded file)
        if (input_pcap_path == null)
            PCAPdroid.getInstance().setLoadedPcapBasename(null);

        PCAPdroid.getInstance().setIsDecryptingPcap(mDecryptPcap);
        mDecryptPcap = false;

        CaptureSettings settings = new CaptureSettings(this, mPrefs);
        settings.input_pcap_path = input_pcap_path;

        // to properly show decrypted PCAP files, full payload must be enabled
        if (PCAPdroid.getInstance().isDecryptingPcap())
            settings.full_payload = true;

        mCapHelper.startCapture(settings);
    }

    public void startCapture() {
        if (VpnReconnectService.isAvailable())
            VpnReconnectService.stopService();

        if(showRemoteServerAlert())
            return;

        if(Prefs.getTlsDecryptionEnabled(mPrefs)) {
            if (MitmAddon.needsSetup(this)) {
                Intent intent = new Intent(this, MitmSetupWizard.class);
                startActivity(intent);
                return;
            }

            if (!MitmAddon.getNewVersionAvailable(this).isEmpty()) {
                new AlertDialog.Builder(this)
                        .setTitle(R.string.update_available)
                        .setMessage(R.string.mitm_addon_update_available)
                        .setCancelable(false)
                        .setPositiveButton(R.string.update_action, (dialog, whichButton) -> {
                            Intent intent = new Intent(this, MitmSetupWizard.class);
                            startActivity(intent);
                        })
                        .setNegativeButton(R.string.cancel_action, (dialog, whichButton) -> {
                            MitmAddon.ignoreNewVersion(this);
                            startCapture();
                        })
                        .show();

                return;
            }
        }

        if(!Prefs.isRootCaptureEnabled(mPrefs) && (Utils.getRunningVpn(this) != null)) {
            new AlertDialog.Builder(this)
                    .setTitle(R.string.active_vpn_detected)
                    .setMessage(R.string.disconnect_vpn_confirm)
                    .setPositiveButton(R.string.ok, (dialog, whichButton) -> doStartCaptureService(null))
                    .setNegativeButton(R.string.cancel_action, (dialog, whichButton) -> {})
                    .show();
        } else
            doStartCaptureService(null);
    }

    public void stopCapture() {
        appStateStopping();
        CaptureService.stopService();
    }

    // see also CaptureCtrl.checkRemoteServerNotAllowed
    private boolean showRemoteServerAlert() {
        if(mPrefs.getBoolean(Prefs.PREF_REMOTE_COLLECTOR_ACK, false))
            return false; // already acknowledged

        boolean exporterEnabled = (Prefs.getDumpMode(mPrefs) == Prefs.DumpMode.UDP_EXPORTER) ||
                (Prefs.getDumpMode(mPrefs) == Prefs.DumpMode.TCP_EXPORTER);

        if((exporterEnabled && !Utils.isLocalNetworkAddress(Prefs.getCollectorIp(mPrefs))) ||
                (Prefs.getSocks5Enabled(mPrefs) && !Utils.isLocalNetworkAddress(Prefs.getSocks5ProxyHost(mPrefs)))) {
            Log.i(TAG, "Showing possible scan notice");

            AlertDialog dialog = new AlertDialog.Builder(this)
                    .setTitle(R.string.warning)
                    .setMessage(R.string.remote_collector_notice)
                    .setPositiveButton(R.string.ok, (d, whichButton) -> mPrefs.edit().putBoolean(Prefs.PREF_REMOTE_COLLECTOR_ACK, true).apply())
                    .show();
            dialog.setCanceledOnTouchOutside(false);
            return true;
        }

        return false;
    }

    public void showPcapActionDialog() {
        Log.d(TAG, "showPcapActionDialog called");

        if(CaptureService.isUserDefinedPcapUri())
            return;

        Uri pcapUri = CaptureService.getPcapUri();
        if(pcapUri == null)
            return;

        CaptureStats stats = CaptureService.getStats();
        Log.d(TAG, "Pcap dump size is " + stats.pcap_dump_size);

        if(stats.pcap_dump_size <= 0) {
            deletePcapFile(pcapUri); // empty file, delete
            return;
        }

        String pcapName = CaptureService.getPcapFname();
        if(pcapName == null)
            pcapName = "unknown";

        String message = String.format(getResources().getString(R.string.pcap_file_action), pcapName, Utils.formatBytes(stats.pcap_dump_size));

        AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);
        builder.setMessage(message);

        builder.setPositiveButton(R.string.share, (dialog, which) -> {
            Intent sendIntent = new Intent(Intent.ACTION_SEND);
            sendIntent.setType("application/cap");
            sendIntent.putExtra(Intent.EXTRA_STREAM, pcapUri);
            sendIntent.setClipData(ClipData.newRawUri("", pcapUri));
            sendIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

            Utils.startActivity(this, Intent.createChooser(sendIntent, getResources().getString(R.string.share)));
        });
        builder.setNegativeButton(R.string.delete, (dialog, which) -> deletePcapFile(pcapUri));
        builder.setNeutralButton(R.string.ok, (dialog, which) -> {});
        builder.setOnDismissListener(dialogInterface -> {
            // also export the keylog
            if(mKeylogFile != null)
                startExportSslkeylogfile();
        });

        AlertDialog dialog = builder.create();
        dialog.setCanceledOnTouchOutside(false);
        dialog.show();
    }

    private void deletePcapFile(Uri pcapUri) {
        boolean deleted = false;

        // The getContentResolver().delete in some Android versions does not work, try to delete
        // using file path first
        String fpath = Utils.uriToFilePath(this, pcapUri);
        if(fpath != null) {
            Log.d(TAG, "deletePcapFile: path=" + fpath);

            try {
                deleted = new File(fpath).delete();
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            Log.d(TAG, "deletePcapFile: uri=" + pcapUri);

            try {
                deleted = (getContentResolver().delete(pcapUri, null, null) == 1);
            } catch (UnsupportedOperationException | SecurityException e) {
                e.printStackTrace();
            }
        }

        if(!deleted)
            Utils.showToast(MainActivity.this, R.string.delete_error);
    }

    public AppState getState() {
        return(mState);
    }

    private void startExportSslkeylogfile() {
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        intent.putExtra(Intent.EXTRA_TITLE, "sslkeylogfile.txt");

        Log.d(TAG, "startExportSslkeylogfile: launching dialog");
        Utils.launchFileDialog(this, intent, sslkeyfileExportLauncher);
    }

    private void sslkeyfileExportResult(final ActivityResult result) {
        if((result.getResultCode() == RESULT_OK) && (result.getData() != null) && (mKeylogFile != null)) {
            try(OutputStream out = getContentResolver().openOutputStream(result.getData().getData(), "rwt")) {
                Utils.copy(mKeylogFile, out);
                Utils.showToast(this, R.string.save_ok);
            } catch (IOException e) {
                e.printStackTrace();
                Utils.showToastLong(this, R.string.export_failed);
            }
        }

        if(mKeylogFile != null) {
            // upon closing the dialog, delete the keylog

            //noinspection ResultOfMethodCallIgnored
            mKeylogFile.delete();
            mKeylogFile = null;
        }
    }

    private void selectOpenPcapFile(boolean decrypt) {
        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");

        Log.d(TAG, "selectOpenPcapFile: launching dialog");
        mOpenPcapDecrypt = decrypt;
        if (mOpenPcapDecrypt)
            Utils.showToast(this, R.string.select_the_pcap_file);
        Utils.launchFileDialog(this, intent, pcapFileOpenLauncher);
    }

    private void pcapFileOpenResult(final ActivityResult result) {
        if ((result.getResultCode() == RESULT_OK) && (result.getData() != null)) {
            Uri uri = result.getData().getData();
            if (uri == null)
                return;

            Log.d(TAG, "pcapFileOpenResult: " + uri);
            if (mOpenPcapDecrypt && !Utils.isPcapng(this, uri)) {
                // Ask to select the keylog
                Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
                intent.addCategory(Intent.CATEGORY_OPENABLE);
                intent.setType("*/*");

                Log.i(TAG, "separate keylog file needed, launching dialog");
                mPcapUri = uri;
                Utils.showToast(this, R.string.select_the_keylog_file);
                Utils.launchFileDialog(this, intent, keylogFileOpenLauncher);
            } else
                startOpenPcap(uri, null);
        }
    }

    private void keylogFileOpenResult(final ActivityResult result) {
        if ((result.getResultCode() == RESULT_OK) && (result.getData() != null)) {
            Uri uri = result.getData().getData();
            if (uri == null)
                return;

            Log.d(TAG, "keylogFileOpenResult: " + uri);
            startOpenPcap(mPcapUri, uri);
        }
    }

    private void startOpenPcap(Uri pcap_uri, Uri keylog_uri) {
        // Extract and store the base filename (without extension)
        Utils.UriStat stat = Utils.getUriStat(this, pcap_uri);
        if (stat != null && stat.name != null) {
            String name = stat.name;
            int dotIndex = name.lastIndexOf('.');
            String basename = (dotIndex > 0) ? name.substring(0, dotIndex) : name;
            PCAPdroid.getInstance().setLoadedPcapBasename(basename);
        } else {
            PCAPdroid.getInstance().setLoadedPcapBasename(null);
        }

        mPcapExecutor = Executors.newSingleThreadExecutor();

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(R.string.loading);
        builder.setMessage(R.string.pcap_load_in_progress);

        mPcapLoadDialog = builder.create();
        mPcapLoadDialog.setCanceledOnTouchOutside(false);
        mPcapLoadDialog.setOnCancelListener(dialogInterface -> {
            Log.i(TAG, "Abort PCAP loading");

            if (mPcapExecutor != null) {
                mPcapExecutor.shutdownNow();
                mPcapExecutor = null;
            }

            if (CaptureService.isServiceActive())
                CaptureService.stopService();

            Utils.showToastLong(this, R.string.pcap_file_load_aborted);
        });
        mPcapLoadDialog.setOnDismissListener(dialog -> mPcapLoadDialog = null);
        mPcapLoadDialog.show();

        // get an actual file path which can be read from the native side
        String path = Utils.uriToFilePath(this, pcap_uri);
        if((path == null) || !Utils.isReadable(path)) {
            // Unable to get a direct file path (e.g. for files in Downloads). Copy file to the
            // cache directory
            File out = getTmpPcapPath();
            out.deleteOnExit();
            String abs_path = out.getAbsolutePath();

            // PCAP file can be big, copy in a different thread
            mPcapExecutor.execute(() -> {
                try (InputStream in_stream = getContentResolver().openInputStream(pcap_uri)) {
                    Utils.copy(in_stream, out);
                } catch (IOException | RuntimeException e) {
                    e.printStackTrace();

                    runOnUiThread(() -> {
                        Utils.showToastLong(this, R.string.copy_error);
                        dismissPcapLoadDialog();
                    });
                    return;
                }

                runOnUiThread(() -> continueOpenPcap(abs_path, keylog_uri));
            });
        } else {
            Log.d(TAG, "pcapFileOpenResult: path: " + path);
            continueOpenPcap(path, keylog_uri);
        }
    }

    private void continueOpenPcap(String pcap_path, Uri keylog_uri) {
        //noinspection ResultOfMethodCallIgnored
        getKeylogPath().delete();

        if (mOpenPcapDecrypt)
            loadKeylogfile(pcap_path, keylog_uri);
        else
            doStartCaptureService(pcap_path);
    }

    private void loadKeylogfile(String pcap_path, Uri keylog_uri) {
        mPcapExecutor.execute(() -> {
            File out = getKeylogPath();
            out.deleteOnExit();

            if (keylog_uri != null) {
                // keylog is in a separate file
                try (InputStream in_stream = getContentResolver().openInputStream(keylog_uri)) {
                    Utils.copy(in_stream, out);
                } catch (IOException | RuntimeException e) {
                    e.printStackTrace();

                    runOnUiThread(() -> {
                        Utils.showToastLong(this, R.string.keylog_read_error);
                        dismissPcapLoadDialog();
                    });
                    return;
                }

                runOnUiThread(() -> {
                    mDecryptPcap = true;
                    doStartCaptureService(pcap_path);
                });
            } else {
                // keylog is from PCAPNG
                boolean success = CaptureService.extractKeylogFromPcapng(pcap_path, out.getAbsolutePath());

                runOnUiThread(() -> {
                    if (success && out.exists()) {
                        mDecryptPcap = true;
                        doStartCaptureService(pcap_path);
                    } else {
                        Utils.showToastLong(this, R.string.keylog_read_error);
                        dismissPcapLoadDialog();
                    }
                });
            }
        });
    }

    private File getTmpPcapPath() {
        return new File(getCacheDir() + "/tmp.pcap");
    }

    private File getKeylogPath() {
        // NOTE: keep in sync with run_libpcap
        return new File(getCacheDir() + "/sslkeylog.txt");
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/MalwareDetection.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.viewpager2.adapter.FragmentStateAdapter;
import androidx.viewpager2.widget.ViewPager2;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.fragments.EditListFragment;
import com.emanuelef.remote_capture.fragments.BlacklistsFragment;
import com.emanuelef.remote_capture.fragments.MalwareStatusFragment;
import com.emanuelef.remote_capture.model.ListInfo;
import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;

public class MalwareDetection extends BaseActivity {
    private static final String TAG = "MalwareStats";
    private ViewPager2 mPager;

    private static final int POS_STATUS = 0;
    private static final int POS_BLACKLISTS = 1;
    private static final int POS_WHITELIST = 2;
    private static final int TOTAL_COUNT = 3;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.malware_detection);
        setContentView(R.layout.tabs_activity);

        mPager = findViewById(R.id.pager);
        Utils.fixViewPager2Insets(mPager);
        setupTabs();
    }

    private static class StateAdapter extends FragmentStateAdapter {
        StateAdapter(final FragmentActivity fa) { super(fa); }

        @NonNull
        @Override
        public Fragment createFragment(int position) {
            Log.d(TAG, "createFragment");

            switch (position) {
                default: // Deliberate fall-through to status tab
                case POS_STATUS:
                    return new MalwareStatusFragment();
                case POS_BLACKLISTS:
                    return new BlacklistsFragment();
                case POS_WHITELIST:
                    return EditListFragment.newInstance(ListInfo.Type.MALWARE_WHITELIST);
            }
        }

        @Override
        public int getItemCount() {  return TOTAL_COUNT;  }

        public int getPageTitle(final int position) {
            switch (position) {
                default: // Deliberate fall-through to status tab
                case POS_STATUS:
                    return R.string.status;
                case POS_BLACKLISTS:
                    return R.string.blacklists;
                case POS_WHITELIST:
                    return R.string.whitelist;
            }
        }
    }

    private void setupTabs() {
        final StateAdapter stateAdapter = new StateAdapter(this);
        mPager.setAdapter(stateAdapter);

        new TabLayoutMediator(findViewById(R.id.tablayout), mPager, (tab, position) ->
                tab.setText(getString(stateAdapter.getPageTitle(position)))
        ).attach();

        // TODO fix DPAD navigation on Android TV, see MainActivity.onKeyDown
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // This is required to properly handle the DPAD down press on Android TV, to properly
        // focus the tab content
        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
            View view = getCurrentFocus();

            Log.d(TAG, "onKeyDown focus " + view.getClass().getName());

            if (view instanceof TabLayout.TabView) {
                int pos = mPager.getCurrentItem();
                View focusOverride = null;

                Log.d(TAG, "TabLayout.TabView focus pos " + pos);

                if (pos == POS_STATUS)
                    focusOverride = findViewById(R.id.mw_detection_status);
                else if ((pos == POS_BLACKLISTS) || (pos == POS_WHITELIST))
                    focusOverride = findViewById(R.id.listview);

                if (focusOverride != null) {
                    focusOverride.requestFocus();
                    return true;
                }
            }
        }

        return super.onKeyDown(keyCode, event);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/MenuActionHandler.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.view.MenuItem;

/**
 * Interface for fragments to handle menu actions delegated from ConnectionDetailsActivity.
 * This allows the activity to centralize menu handling while fragments handle their specific actions.
 */
public interface MenuActionHandler {
    /**
     * Handle a menu item selection for this fragment.
     * @param item The menu item that was selected
     * @return true if the menu item was handled, false otherwise
     */
    boolean handleMenuAction(MenuItem item);
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/MitmSetupWizard.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.os.Bundle;

import com.emanuelef.remote_capture.R;

public class MitmSetupWizard extends BaseActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.mitm_wizard_activity);
        setTitle(R.string.mitm_setup_wizard);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/OnBoardingActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.text.method.LinkMovementMethod;
import android.util.DisplayMetrics;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.constraintlayout.widget.ConstraintLayout;
import androidx.core.content.ContextCompat;
import androidx.core.widget.TextViewCompat;
import androidx.fragment.app.Fragment;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.Prefs;
import com.github.appintro.AppIntro;
import com.github.appintro.AppIntroBaseFragment;
import com.github.appintro.model.SliderPagerBuilder;

import org.jetbrains.annotations.Nullable;

public class OnBoardingActivity extends AppIntro {
    private static final String TAG = "OnBoardingActivity";
    public static final String ENABLE_BACK_BUTTON = "back_enabled";

    public static class OnBoardingFragment extends AppIntroBaseFragment {
        @Override
        protected int getLayoutId() {
            return R.layout.appintro_fragment_intro;
        }

        public static OnBoardingFragment createInstance(CharSequence title, CharSequence description, int imageRes, int imageTint, boolean imageAutosize) {
            OnBoardingFragment fragment = new OnBoardingFragment();
            Bundle args = new SliderPagerBuilder()
                    .title(title)
                    //.description(description) see below
                    .imageDrawable(imageRes)
                    .backgroundColorRes(R.color.backgroundColor)
                    .titleColorRes(R.color.colorAccent)
                    .descriptionColorRes(R.color.colorTabText)
                    .build().toBundle();

            args.putCharSequence("pd_descr", description);
            args.putInt("pd_image_tint", imageTint);
            args.putBoolean("pd_image_autosz", imageAutosize);
            fragment.setArguments(args);

            return fragment;
        }

        @Nullable
        @Override
        public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
            View view = super.onCreateView(inflater, container, savedInstanceState);
            if(view == null)
                return null;

            Bundle args = getArguments();
            assert args != null;
            DisplayMetrics metrics = getResources().getDisplayMetrics();

            // fixes links from Utils.getText not clickable
            TextView tv = view.findViewById(R.id.description);
            tv.setAutoLinkMask(0);
            tv.setMovementMethod(LinkMovementMethod.getInstance());
            tv.setText(args.getCharSequence("pd_descr"));
            tv.setGravity(Gravity.START | Gravity.CENTER_VERTICAL);

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                // Disable auto-sizing, as it makes the text not readable
                TextViewCompat.setAutoSizeTextTypeWithDefaults(tv, TextView.AUTO_SIZE_TEXT_TYPE_NONE);
            }
            tv.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14);

            // Fix excessive vertical padding, causing scroll
            ViewGroup.LayoutParams lp = tv.getLayoutParams();
            if(lp instanceof ConstraintLayout.LayoutParams) {
                ConstraintLayout.LayoutParams params = (ConstraintLayout.LayoutParams) lp;
                params.setMargins(0, (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, metrics), 0, 0);
                tv.setPadding(tv.getPaddingLeft(), 0, tv.getPaddingRight(), 0);
                tv.setLayoutParams(params);
            }

            // fix drawable tint and size
            ImageView image = view.findViewById(R.id.image);
            int tint = args.getInt("pd_image_tint");
            if(tint > 0)
                image.setColorFilter(ContextCompat.getColor(view.getContext(), tint));
            if(args.getBoolean("pd_image_autosz")) {
                image.setAdjustViewBounds(true);
                ViewGroup.LayoutParams params = image.getLayoutParams();
                params.height = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 120, metrics);
            }

            return view;
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        boolean backEnabled = false;
        Billing billing = Billing.newInstance(this);
        setImmersiveMode();

        Intent intent = getIntent();
        if(intent != null)
            backEnabled = intent.getBooleanExtra(ENABLE_BACK_BUTTON, false);

        addSlide(OnBoardingFragment.createInstance(getString(R.string.welcome_to_pcapdroid),
                getText(R.string.app_intro_welcome_msg),
                R.drawable.ic_logo, R.color.colorAccent, true));

        addSlide(OnBoardingFragment.createInstance(getString(R.string.privacy_first),
                Utils.getText(this, R.string.app_intro_privacy_msg,
                        MainActivity.PRIVACY_POLICY_URL, MainActivity.GITHUB_PROJECT_URL),
                R.drawable.ic_shield, R.color.colorAccent, true));

        addSlide(OnBoardingFragment.createInstance(getString(R.string.traffic_inspection),
                Utils.getText(this, R.string.app_intro_traffic_inspection,
                        MainActivity.TLS_DECRYPTION_DOCS_URL),
                R.drawable.http_inspection, 0, false));

        if(billing.isPlayStore()) {
            addSlide(OnBoardingFragment.createInstance(getString(R.string.firewall),
                    Utils.getText(this, R.string.app_intro_firewall_msg,
                            MainActivity.FIREWALL_DOCS_URL),
                    R.drawable.firewall_block, 0, false));

            addSlide(OnBoardingFragment.createInstance(getString(R.string.malware_detection),
                    Utils.getText(this, R.string.app_intro_malware_detection,
                            MainActivity.MALWARE_DETECTION_DOCS_URL),
                    R.drawable.malware_notification, 0, false));
        }

        addSlide(OnBoardingFragment.createInstance(getString(R.string.traffic_dump),
                Utils.getText(this, R.string.app_intro_traffic_dump,
                        MainActivity.DOCS_URL + "/dump_modes",
                        MainActivity.DOCS_URL + "/advanced_features#45-pcapdroid-extensions"),
                R.drawable.dump_modes, 0, false));

        addSlide(OnBoardingFragment.createInstance(getString(R.string.country_and_asn),
                getText(R.string.app_intro_geolocation_msg),
                R.drawable.ic_location_dot, R.color.colorAccent, true));

        showStatusBar(true);
        setSkipButtonEnabled(true);
        setIndicatorEnabled(true);
        setSystemBackButtonLocked(!backEnabled);

        // Theme
        int colorAccent = ContextCompat.getColor(this, R.color.colorAccent);
        setIndicatorColor(colorAccent, ContextCompat.getColor(this, R.color.colorAccentLight));
        setBackArrowColor(colorAccent);
        setColorSkipButton(colorAccent);
        setNextArrowColor(colorAccent);
        setBackArrowColor(colorAccent);
        setColorDoneText(colorAccent);
    }

    @Override
    protected void onSkipPressed(@Nullable Fragment currentFragment) {
        Log.d(TAG, "onSkipPressed");
        super.onSkipPressed(currentFragment);
        runMainActivity();
    }

    @Override
    protected void onDonePressed(@Nullable Fragment currentFragment) {
        Log.d(TAG, "onDonePressed");
        super.onDonePressed(currentFragment);
        runMainActivity();
    }

    private void runMainActivity() {
        Prefs.refreshAppVersion(PreferenceManager.getDefaultSharedPreferences(this));

        Intent intent = new Intent(this, MainActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        startActivity(intent);
        finish();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/PayloadExportActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import android.content.Intent;

import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.adapters.PayloadAdapter;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

public class PayloadExportActivity extends BaseActivity implements PayloadAdapter.ExportPayloadHandler {
    private String mStringPayloadToExport;
    private byte[] mRawPayloadToExport;

    private final ActivityResultLauncher<Intent> payloadExportLauncher =
            registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), this::payloadExportResult);

    @Override
    public void exportPayload(String payload) {
        mStringPayloadToExport = payload;
        mRawPayloadToExport = null;

        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("text/plain");
        intent.putExtra(Intent.EXTRA_TITLE, Utils.getUniqueFileName(this, "txt"));

        Utils.launchFileDialog(this, intent, payloadExportLauncher);
    }

    @Override
    public void exportPayload(byte[] payload, String contentType, String fname) {
        mStringPayloadToExport = null;
        mRawPayloadToExport = payload;

        if (fname.isEmpty()) {
            String ext;

            switch (contentType) {
                case "text/html":
                    ext = "html";
                    break;
                case "application/octet-stream":
                    ext = "bin";
                    break;
                case "application/json":
                    ext = "json";
                    break;
                default:
                    ext = "txt";
            }

            fname = Utils.getUniqueFileName(this, ext);
        }

        /* This is an unmapped mime type, which allows the user to specify the file,
         * extension instead of Android forcing it, see
         * https://android.googlesource.com/platform/external/mime-support/+/fa3f892f28db393b1411f046877ee48179f6a4cf/mime.types */
        final String generic_mime = "application/http";

        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(generic_mime);
        intent.putExtra(Intent.EXTRA_TITLE, fname);

        Utils.launchFileDialog(this, intent, payloadExportLauncher);
    }

    private void payloadExportResult(final ActivityResult result) {
        if ((mRawPayloadToExport == null) && (mStringPayloadToExport == null))
            return;

        if((result.getResultCode() == RESULT_OK) && (result.getData() != null) && (result.getData().getData() != null)) {
            try(OutputStream out = getContentResolver().openOutputStream(result.getData().getData(), "rwt")) {
                if (out != null) {
                    if (mStringPayloadToExport != null) {
                        try (OutputStreamWriter writer = new OutputStreamWriter(out)) {
                            writer.write(mStringPayloadToExport);
                        }
                    } else
                        out.write(mRawPayloadToExport);
                    Utils.showToast(this, R.string.save_ok);
                } else
                    Utils.showToastLong(this, R.string.export_failed);
            } catch (IOException e) {
                e.printStackTrace();
                Utils.showToastLong(this, R.string.export_failed);
            }
        }

        mRawPayloadToExport = null;
        mStringPayloadToExport = null;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/StatsActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities;

import androidx.annotation.NonNull;
import androidx.core.view.MenuProvider;

import android.app.ActivityManager;
import android.content.Context;
import android.graphics.Color;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.TableLayout;
import android.widget.TextView;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.CaptureStats;

import java.util.Locale;

public class StatsActivity extends BaseActivity implements MenuProvider {
    private TextView mBytesSent;
    private TextView mBytesRcvd;
    private TextView mIPv6BytesSent;
    private TextView mIPv6BytesRcvd;
    private TextView mIPv6BytesPercentage;
    private TextView mPacketsSent;
    private TextView mPacketsRcvd;
    private TextView mActiveConns;
    private TextView mDroppedConns;
    private TextView mDroppedPkts;
    private TextView mTotConns;
    private TextView mHeapUsage;
    private TextView mMemUsage;
    private TextView mLowMem;
    private TextView mOpenSocks;
    private TextView mDnsServer;
    private TextView mDnsQueries;
    private TableLayout mTable;
    private TextView mAllocStats;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.stats);
        displayBackAction();
        setContentView(R.layout.activity_stats);
        addMenuProvider(this);

        mTable = findViewById(R.id.table);
        mBytesSent = findViewById(R.id.bytes_sent);
        mBytesRcvd = findViewById(R.id.bytes_rcvd);
        mIPv6BytesSent = findViewById(R.id.ipv6_bytes_sent);
        mIPv6BytesRcvd = findViewById(R.id.ipv6_bytes_rcvd);
        mIPv6BytesPercentage = findViewById(R.id.ipv6_bytes_percentage);
        mPacketsSent = findViewById(R.id.packets_sent);
        mPacketsRcvd = findViewById(R.id.packets_rcvd);
        mActiveConns = findViewById(R.id.active_connections);
        mDroppedConns = findViewById(R.id.dropped_connections);
        mDroppedPkts = findViewById(R.id.pkts_dropped);
        mTotConns = findViewById(R.id.tot_connections);
        mHeapUsage = findViewById(R.id.heap_usage);
        mMemUsage = findViewById(R.id.mem_usage);
        mLowMem = findViewById(R.id.low_mem_detected);
        mOpenSocks = findViewById(R.id.open_sockets);
        mDnsQueries = findViewById(R.id.dns_queries);
        mDnsServer = findViewById(R.id.dns_server);
        mAllocStats = findViewById(R.id.alloc_stats);

        if(CaptureService.isCapturingAsRoot()) {
            findViewById(R.id.open_sockets_row).setVisibility(View.GONE);
            findViewById(R.id.row_dropped_connections).setVisibility(View.GONE);
        } else {
            if (!CaptureService.isReadingFromPcapFile() && !CaptureService.isIPv6Enabled()) {
                // vpn mode without IPv6
                findViewById(R.id.ipv6_bytes_sent_row).setVisibility(View.GONE);
                findViewById(R.id.ipv6_bytes_rcvd_row).setVisibility(View.GONE);
                findViewById(R.id.ipv6_bytes_percentage_row).setVisibility(View.GONE);
            }

            findViewById(R.id.row_pkts_dropped).setVisibility(View.GONE);
        }

        // Listen for stats updates
        CaptureService.observeStats(this, this::updateStats);

        CaptureService.askStatsDump();
    }

    private void updateStats(CaptureStats stats) {
        mBytesSent.setText(Utils.formatBytes(stats.bytes_sent));
        mBytesRcvd.setText(Utils.formatBytes(stats.bytes_rcvd));

        mIPv6BytesSent.setText(Utils.formatBytes(stats.ipv6_bytes_sent));
        mIPv6BytesRcvd.setText(Utils.formatBytes(stats.ipv6_bytes_rcvd));

        long tot_bytes = stats.bytes_sent + stats.bytes_rcvd;
        long percentage = (tot_bytes > 0) ?
                ((stats.ipv6_bytes_sent + stats.ipv6_bytes_rcvd) * 100 / tot_bytes) : 0;
        mIPv6BytesPercentage.setText(
                String.format(Utils.getPrimaryLocale(this),"%d%%", percentage));

        mPacketsSent.setText(Utils.formatIntShort(stats.pkts_sent));
        mPacketsRcvd.setText(Utils.formatIntShort(stats.pkts_rcvd));
        mActiveConns.setText(Utils.formatNumber(this, stats.active_conns));
        mDroppedConns.setText(Utils.formatNumber(this, stats.num_dropped_conns));
        mDroppedPkts.setText(Utils.formatNumber(this, stats.pkts_dropped));
        mTotConns.setText(Utils.formatNumber(this, stats.tot_conns));
        mOpenSocks.setText(Utils.formatNumber(this, stats.num_open_sockets));
        mDnsQueries.setText(Utils.formatNumber(this, stats.num_dns_queries));

        updateMemoryStats();

        if(!CaptureService.isDNSEncrypted()) {
            findViewById(R.id.dns_server_row).setVisibility(View.VISIBLE);
            findViewById(R.id.dns_queries_row).setVisibility(View.VISIBLE);
            mDnsServer.setText(CaptureService.getDNSServer());
        } else {
            findViewById(R.id.dns_server_row).setVisibility(View.GONE);
            findViewById(R.id.dns_queries_row).setVisibility(View.GONE);
        }

        if(stats.num_dropped_conns > 0)
            mDroppedConns.setTextColor(Color.RED);

        if(stats.alloc_summary != null) {
            mAllocStats.setVisibility(View.VISIBLE);
            mAllocStats.setText(stats.alloc_summary);
        }
    }

    private void updateMemoryStats() {
        Locale locale = Utils.getPrimaryLocale(this);
        long heapAvailable = Utils.getAvailableHeap();
        long heapMax = Runtime.getRuntime().maxMemory();

        ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
        ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
        activityManager.getMemoryInfo(memoryInfo);

        mHeapUsage.setText(String.format(locale, "%s / %s (%d%%)", Utils.formatBytes(heapMax - heapAvailable),
                Utils.formatBytes(heapMax),
                (heapMax - heapAvailable) * 100 / heapMax));

        mMemUsage.setText(String.format(locale, "%s / %s (%d%%)", Utils.formatBytes(memoryInfo.totalMem - memoryInfo.availMem),
                Utils.formatBytes(memoryInfo.totalMem),
                (memoryInfo.totalMem - memoryInfo.availMem) * 100 / memoryInfo.totalMem));

        mLowMem.setText(getString(CaptureService.isLowMemory() ? R.string.yes : R.string.no));
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.copy_share_menu, menu);
    }

    private String getContents() {
        return Utils.table2Text(mTable);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.copy_to_clipboard) {
            Utils.copyToClipboard(this, getContents());
            return true;
        } else if(id == R.id.share) {
            Utils.shareText(this, getString(R.string.stats), getContents());
            return true;
        }

        return false;
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/activities/prefs/EditCtrlPermissions.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities.prefs;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Bundle;
import android.view.ActionMode;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.AbsListView;
import android.widget.ListView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.core.view.MenuProvider;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.BaseActivity;
import com.emanuelef.remote_capture.activities.MainActivity;
import com.emanuelef.remote_capture.adapters.CtrlPermissionsAdapter;
import com.emanuelef.remote_capture.model.CtrlPermissions;
import com.emanuelef.remote_capture.model.Prefs;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Base64;

public class EditCtrlPermissions extends BaseActivity implements MenuProvider {
    private static final String TAG = "EditCtrlPermissions";
    private TextView mEmptyText;
    private CtrlPermissionsAdapter mAdapter;
    private ListView mListView;
    private CtrlPermissions mPermissions;
    private MenuItem mShowApiKey;
    private final ArrayList<CtrlPermissions.Rule> mSelected = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setTitle(R.string.control_permissions);
        setContentView(R.layout.simple_list_activity);
        addMenuProvider(this);

        findViewById(R.id.simple_list).setFitsSystemWindows(true);
        mEmptyText = findViewById(R.id.list_empty);
        mEmptyText.setText(R.string.no_permissions_set_info);
        mListView = findViewById(R.id.listview);

        mPermissions = PCAPdroid.getInstance().getCtrlPermissions();
        mAdapter = new CtrlPermissionsAdapter(this, mPermissions);
        mListView.setAdapter(mAdapter);
        mListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
        mListView.setMultiChoiceModeListener(new AbsListView.MultiChoiceModeListener() {

            @Override
            public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                MenuInflater inflater = getMenuInflater();
                inflater.inflate(R.menu.list_edit_cab, menu);
                return true;
            }

            @Override
            public boolean onPrepareActionMode(ActionMode mode, Menu menu) { return false; }

            @Override
            public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
                int id = item.getItemId();

                if(id == R.id.delete_entry) {
                    if(mSelected.size() >= mAdapter.getCount()) {
                        mAdapter.clear();
                        mPermissions.removeAll();
                    } else {
                        for(CtrlPermissions.Rule rule : mSelected) {
                            mAdapter.remove(rule);
                            mPermissions.remove(rule.package_name);
                        }
                    }

                    mode.finish();
                    recheckListSize();
                    return true;
                } else if(id == R.id.select_all) {
                    if(mSelected.size() >= mAdapter.getCount())
                        mode.finish();
                    else {
                        for(int i=0; i<mAdapter.getCount(); i++) {
                            if(!mListView.isItemChecked(i))
                                mListView.setItemChecked(i, true);
                        }
                    }
                }

                return false;
            }

            @Override
            public void onDestroyActionMode(ActionMode mode) {
                mSelected.clear();
            }

            @Override
            public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) {
                CtrlPermissions.Rule item = mAdapter.getItem(position);

                if(checked)
                    mSelected.add(item);
                else
                    mSelected.remove(item);

                mode.setTitle(getString(R.string.n_selected, mSelected.size()));
            }
        });
        Utils.fixListviewInsetsBottom(mListView);

        recheckListSize();
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
        inflater.inflate(R.menu.ctrl_permissions_menu, menu);

        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        mShowApiKey = menu.findItem(R.id.show_api_key);

        if (Prefs.getApiKey(prefs).isEmpty())
            mShowApiKey.setVisible(false);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.user_guide) {
            Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(MainActivity.API_DOCS_URL));
            Utils.startActivity(this, browserIntent);
            return true;
        } else if (id == R.id.generate_api_key) {
            generateApiKey(false);
            return true;
        } else if (id == R.id.show_api_key) {
            showApiKey();
            return true;
        }

        return false;
    }

    private void recheckListSize() {
        mEmptyText.setVisibility((mAdapter.getCount() == 0) ? View.VISIBLE : View.GONE);
    }

    private void generateApiKey(boolean confirmOverwrite) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        if (!confirmOverwrite && !Prefs.getApiKey(prefs).isEmpty()) {
            new AlertDialog.Builder(this)
                    .setTitle(R.string.warning)
                    .setMessage(R.string.api_key_discard_confirm)
                    .setPositiveButton(R.string.ok, (dialog, whichButton) -> generateApiKey(true))
                    .setNegativeButton(R.string.cancel_action, (dialog, whichButton) -> {})
                    .show();
            return;
        }

        final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        final int key_length = 32;
        SecureRandom random = new SecureRandom();
        StringBuilder apiKey = new StringBuilder(key_length);
        for (int i = 0; i < key_length; i++) {
            int index = random.nextInt(chars.length());
            apiKey.append(chars.charAt(index));
        }

        prefs.edit()
                .putString(Prefs.PREF_API_KEY, apiKey.toString())
                .apply();

        if (mShowApiKey != null)
            mShowApiKey.setVisible(true);
        showApiKey();
    }

    private void showApiKey() {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        String key = Prefs.getApiKey(prefs);
        if (key.isEmpty())
            return;

        new AlertDialog.Builder(this)
                .setTitle(R.string.api_key)
                .setMessage(key)
                .setPositiveButton(R.string.ok, (dialogInterface, i) -> {})
                .setNeutralButton(R.string.copy_to_clipboard, (dialogInterface, i) ->
                        Utils.copyToClipboard(this, key)).show();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/prefs/PortMapActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities.prefs;

import android.os.Bundle;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.activities.BaseActivity;
import com.emanuelef.remote_capture.fragments.prefs.PortMapFragment;

public class PortMapActivity extends BaseActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.port_mapping);
        setContentView(R.layout.fragment_activity);

        getSupportFragmentManager().beginTransaction()
                .replace(R.id.fragment, new PortMapFragment())
                .commit();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/prefs/SettingsActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities.prefs;

import android.app.LocaleManager;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.LocaleList;
import android.provider.Settings;
import android.system.Os;
import android.system.OsConstants;
import android.text.InputType;
import android.util.AttributeSet;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;
import androidx.preference.DropDownPreference;
import androidx.preference.EditTextPreference;
import androidx.preference.Preference;
import androidx.preference.PreferenceFragmentCompat;
import androidx.preference.PreferenceManager;
import androidx.preference.SwitchPreference;

import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.MitmAddon;
import com.emanuelef.remote_capture.VpnReconnectService;
import com.emanuelef.remote_capture.activities.BaseActivity;
import com.emanuelef.remote_capture.activities.MainActivity;
import com.emanuelef.remote_capture.activities.MitmSetupWizard;
import com.emanuelef.remote_capture.fragments.prefs.DnsSettings;
import com.emanuelef.remote_capture.fragments.prefs.GeoipSettings;
import com.emanuelef.remote_capture.fragments.prefs.Socks5Settings;
import com.emanuelef.remote_capture.interfaces.FragmentViewCreatedListener;
import com.emanuelef.remote_capture.model.Prefs;
import com.emanuelef.remote_capture.R;

import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Locale;

public class SettingsActivity extends BaseActivity implements PreferenceFragmentCompat.OnPreferenceStartFragmentCallback,
        FragmentManager.OnBackStackChangedListener,
        FragmentViewCreatedListener {
    private static final String TAG = "SettingsActivity";
    private static final String ACTION_LANG_RESTART = "lang_restart";
    public static final String TARGET_PREF_EXTRA = "target_pref";
    private WindowInsetsCompat mInsets = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.title_activity_settings); // note: setting via manifest does not honor custom locale
        displayBackAction();
        setContentView(R.layout.fragment_activity);

        getSupportFragmentManager()
                .beginTransaction()
                .replace(R.id.fragment, new SettingsFragment(), "root")
                .commit();

        getSupportFragmentManager().addOnBackStackChangedListener(this);
    }

    @Nullable
    @Override
    public View onCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) {
        View view = super.onCreateView(parent, name, context, attrs);
        if (view != null)
            ViewCompat.setOnApplyWindowInsetsListener(view, (v, windowInsets) -> {
                mInsets = windowInsets;
                return windowInsets;
            });

        return view;
    }

    @Override
    public void onFragmentViewCreated(@NonNull View view) {
        // necessary, otherwise insets are not dispatched after fragment replace
        if (mInsets != null)
            ViewCompat.dispatchApplyWindowInsets(view, mInsets);
    }

    @Override
    public boolean onPreferenceStartFragment(@NonNull PreferenceFragmentCompat caller, @NonNull Preference pref) {
        PreferenceFragmentCompat targetFragment = null;
        String prefKey = pref.getKey();

        Log.d(TAG, "startFragment: " + prefKey);

        if(prefKey.equals("geolocation")) {
            targetFragment = new GeoipSettings();
            setTitle(R.string.geolocation);
        } else if(prefKey.equals("dns_settings")) {
            targetFragment = new DnsSettings();
            setTitle(R.string.dns_servers);
        } else if(prefKey.equals("socks5_settings")) {
            targetFragment = new Socks5Settings();
            setTitle(R.string.socks5_proxy);
        }

        if(targetFragment != null) {
            getSupportFragmentManager()
                    .beginTransaction()
                    .replace(R.id.fragment, targetFragment, pref.getKey())
                    .setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN)
                    .addToBackStack(pref.getKey())
                    .commit();
            return true;
        }

        return false;
    }

    @Override
    public void onBackStackChanged() {
        Fragment f = getSupportFragmentManager().findFragmentById(R.id.fragment);
        if(f instanceof SettingsFragment) {
            setTitle(R.string.title_activity_settings);

            var view = f.getView();
            if ((mInsets != null) && (view != null))
                ViewCompat.dispatchApplyWindowInsets(view, mInsets);
        }
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onBackPressed() {
        Fragment f = getSupportFragmentManager().findFragmentById(R.id.fragment);
        if(f instanceof SettingsFragment) {
            Intent intent = getIntent();

            if ((intent != null) && SettingsActivity.ACTION_LANG_RESTART.equals(intent.getAction())) {
                // Use a custom intent to provide "up" navigation after ACTION_LANG_RESTART took place
                intent = new Intent(this, MainActivity.class);
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                startActivity(intent);
                finish();
                return;
            }
        }

        // default behavior
        super.onBackPressed();
    }

    public static class SettingsFragment extends PreferenceFragmentCompat {
        private SwitchPreference mTlsDecryption;
        private SwitchPreference mFullPayloadEnabled;
        private SwitchPreference mRootCaptureEnabled;
        private SwitchPreference mAutoBlockPrivateDNS;
        private EditTextPreference mMitmproxyOpts;
        private DropDownPreference mIpMode;
        private DropDownPreference mCapInterface;
        private DropDownPreference mBlockQuic;
        private Preference mVpnExceptions;
        private Preference mSocks5Settings;
        private Preference mDnsSettings;
        private Preference mPortMapping;
        private Preference mMitmWizard;
        private SwitchPreference mMalwareDetectionEnabled;
        private SwitchPreference mPcapngEnabled;
        private SwitchPreference mRestartOnDisconnect;
        private Billing mIab;
        private boolean mHasStartedMitmWizard;
        private boolean mRootDecryptionNoticeShown = false;

        @Override
        public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
            setPreferencesFromResource(R.xml.root_preferences, rootKey);
            mIab = Billing.newInstance(requireContext());

            setupExporterPrefs();
            setupHttpServerPrefs();
            setupTrafficInspectionPrefs();
            setupCapturePrefs();
            setupSecurityPrefs();
            setupOtherPrefs();

            socks5ProxyHideShow(mTlsDecryption.isChecked(), rootCaptureEnabled());
            mBlockQuic.setVisible(!rootCaptureEnabled());
            rootCaptureHideShow(rootCaptureEnabled());

            Intent intent = requireActivity().getIntent();
            if(intent != null) {
                String target_pref = intent.getStringExtra(TARGET_PREF_EXTRA);
                if(target_pref != null)
                    scrollToPreference(target_pref);
            }
        }

        @Override
        public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
            super.onViewCreated(view, savedInstanceState);

            ViewCompat.setOnApplyWindowInsetsListener(view, (v, windowInsets) -> {
                Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                        WindowInsetsCompat.Type.displayCutout());
                v.setPadding(insets.left, insets.top, insets.right, insets.bottom);

                return WindowInsetsCompat.CONSUMED;
            });
        }

        @Override
        public void onResume() {
            super.onResume();

            if(mHasStartedMitmWizard && !MitmAddon.needsSetup(requireContext())) {
                Log.d(TAG, "mitm setup complete, enabling");
                mTlsDecryption.setChecked(true);
                mFullPayloadEnabled.setChecked(true);
            }
            mHasStartedMitmWizard = false;
        }

        private @NonNull <T extends Preference> T requirePreference(String key) {
            T pref = findPreference(key);
            if(pref == null)
                throw new IllegalStateException();
            return pref;
        }

        @SuppressWarnings("deprecation")
        private void setupExporterPrefs() {
            /* Collector IP validation */
            EditTextPreference mRemoteCollectorIp = requirePreference(Prefs.PREF_COLLECTOR_IP_KEY);
            mRemoteCollectorIp.setOnPreferenceChangeListener((preference, newValue) -> Utils.validateIpAddress(newValue.toString()));

            /* Collector port validation */
            EditTextPreference mRemoteCollectorPort = requirePreference(Prefs.PREF_COLLECTOR_PORT_KEY);
            mRemoteCollectorPort.setOnBindEditTextListener(editText -> editText.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_SIGNED));
            mRemoteCollectorPort.setOnPreferenceChangeListener((preference, newValue) -> Utils.validatePort(newValue.toString()));
        }

        private void setupHttpServerPrefs() {
            /* HTTP Server port validation */
            EditTextPreference mHttpServerPort = requirePreference(Prefs.PREF_HTTP_SERVER_PORT);
            mHttpServerPort.setOnPreferenceChangeListener((preference, newValue) -> Utils.validatePort(newValue.toString()));
        }

        private boolean rootCaptureEnabled() {
            return Utils.isRootAvailable() && mRootCaptureEnabled.isChecked();
        }

        private boolean isPcapngEnabled() {
            return mIab.isPurchased(Billing.PCAPNG_SKU) && mPcapngEnabled.isChecked();
        }

        private void refreshInterfaces() {
            ArrayList<String> labels = new ArrayList<>();
            ArrayList<String> values = new ArrayList<>();

            labels.add(getString(R.string.internet));
            values.add("@inet");
            labels.add(getString(R.string.all_interfaces));
            values.add("any");

            try {
                Enumeration<NetworkInterface> ifaces = Utils.getNetworkInterfaces();

                while (ifaces.hasMoreElements()) {
                    NetworkInterface iface = ifaces.nextElement();
                    if(!iface.isUp())
                        continue;

                    String name = iface.getName();
                    labels.add(name);
                    values.add(name);
                }
            } catch (SocketException e) {
                e.printStackTrace();
            }

            mCapInterface.setEntryValues(values.toArray(new String[0]));
            mCapInterface.setEntries(labels.toArray(new String[0]));
        }

        private void setupCapturePrefs() {
            mCapInterface = requirePreference(Prefs.PREF_CAPTURE_INTERFACE);
            refreshInterfaces();

            mRootCaptureEnabled = requirePreference(Prefs.PREF_ROOT_CAPTURE);
            if(Utils.isRootAvailable()) {
                mRootCaptureEnabled.setOnPreferenceChangeListener((preference, newValue) -> {
                    rootCaptureHideShow((Boolean) newValue);
                    return checkDecrpytionWithRoot((Boolean) newValue, mTlsDecryption.isChecked());
                });
            } else
                mRootCaptureEnabled.setVisible(false);

            mRestartOnDisconnect = requirePreference(Prefs.PREF_RESTART_ON_DISCONNECT);
            mRestartOnDisconnect.setVisible(VpnReconnectService.isAvailable());

            mDnsSettings = requirePreference("dns_settings");;
            mVpnExceptions = requirePreference(Prefs.PREF_VPN_EXCEPTIONS);
            mVpnExceptions.setOnPreferenceClickListener(preference -> {
                Intent intent = new Intent(requireContext(), VpnExemptionsActivity.class);
                startActivity(intent);
                return true;
            });
        }

        private void setupSecurityPrefs() {
            mMalwareDetectionEnabled = requirePreference(Prefs.PREF_MALWARE_DETECTION);

            if(!mIab.isAvailable(Billing.MALWARE_DETECTION_SKU)) {
                getPreferenceScreen().removePreference(requirePreference("security"));
                return;
            }

            // Billing code here
        }

        @SuppressWarnings("deprecation")
        private void setupTrafficInspectionPrefs() {
            mAutoBlockPrivateDNS = requirePreference("auto_block_private_dns");

            mTlsDecryption = requirePreference(Prefs.PREF_TLS_DECRYPTION_KEY);
            mTlsDecryption.setOnPreferenceChangeListener((preference, newValue) -> {
                boolean enabled = (boolean) newValue;
                Context ctx = requireContext();

                if (enabled && (Os.sysconf(OsConstants._SC_PAGE_SIZE) == 16384)) {
                    Utils.showToastLong(ctx, R.string.tls_decryption_not_supported_16KB);
                    return false;
                }

                if(!checkDecrpytionWithRoot(rootCaptureEnabled(), (boolean) newValue))
                    return false;

                if(enabled && MitmAddon.needsSetup(ctx)) {
                    mHasStartedMitmWizard = true;
                    Intent intent = new Intent(ctx, MitmSetupWizard.class);
                    startActivity(intent);
                    return false;
                }

                mMitmWizard.setVisible((boolean) newValue);
                mMitmproxyOpts.setVisible((boolean) newValue);
                socks5ProxyHideShow((boolean) newValue, rootCaptureEnabled());
                return true;
            });

            mPcapngEnabled = requirePreference("pcapng_format");

            if(mIab.isAvailable(Billing.PCAPNG_SKU)) {
                mPcapngEnabled.setOnPreferenceClickListener((preference -> {
                    // Billing code here

                    return false;
                }));
                if(!mIab.isPurchased(Billing.PCAPNG_SKU))
                    mPcapngEnabled.setChecked(false);
            } else
                mPcapngEnabled.setVisible(false);

            mFullPayloadEnabled = requirePreference(Prefs.PREF_FULL_PAYLOAD);
            mBlockQuic = requirePreference(Prefs.PREF_BLOCK_QUIC);
            mMitmproxyOpts = requirePreference(Prefs.PREF_MITMPROXY_OPTS);
            mMitmproxyOpts.setVisible(mTlsDecryption.isChecked());
            mMitmWizard = requirePreference("mitm_setup_wizard");
            mMitmWizard.setVisible(mTlsDecryption.isChecked());
            mMitmWizard.setOnPreferenceClickListener(preference -> {
                mHasStartedMitmWizard = true;
                Intent intent = new Intent(requireContext(), MitmSetupWizard.class);
                startActivity(intent);
                return true;
            });

            mSocks5Settings = requirePreference("socks5_settings");
        }

        private void socks5ProxyHideShow(boolean tlsDecryption, boolean rootEnabled) {
            mSocks5Settings.setVisible(!tlsDecryption && !rootEnabled);
        }

        private void setupAppLanguagePref() {
            DropDownPreference appLang = requirePreference(Prefs.PREF_APP_LANGUAGE);
            Preference appLangExternal = requirePreference("app_language_external");

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                // On Android 33+, app language is configurable from the system settings
                appLang.setVisible(false);
                appLangExternal.setVisible(true);

                LocaleList locales = requireContext().getSystemService(LocaleManager.class)
                        .getApplicationLocales();
                if (locales.equals(LocaleList.getEmptyLocaleList()))
                    appLangExternal.setSummary(getString(R.string.system_default));
                else if (!locales.isEmpty())
                    appLangExternal.setSummary(locales.get(0).getDisplayName());

                appLangExternal.setOnPreferenceClickListener(preference -> {
                    Intent intent = new Intent(Settings.ACTION_APP_LOCALE_SETTINGS);
                    intent.setData(Uri.fromParts("package", requireContext().getPackageName(), null));
                    startActivity(intent);
                    return true;
                });
            } else {
                // Populate supported languages dynamically from locales_config.xml
                String[] supportedLocales = Utils.getSupportedLocales(requireContext());
                String[] entryValues = new String[supportedLocales.length + 1];
                CharSequence[] entryLabels = new CharSequence[supportedLocales.length + 1];

                entryValues[0] = "system";
                entryLabels[0] = getString(R.string.system_default);

                for (int i = 0; i < supportedLocales.length; i++) {
                    Locale locale = Locale.forLanguageTag(supportedLocales[i]);
                    entryValues[i + 1] = supportedLocales[i];
                    String name = locale.getDisplayName(locale);
                    entryLabels[i + 1] = name.substring(0, 1).toUpperCase(locale) + name.substring(1);
                }

                appLang.setEntries(entryLabels);
                appLang.setEntryValues(entryValues);

                SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());

                if (SettingsActivity.ACTION_LANG_RESTART.equals(requireActivity().getIntent().getAction()))
                    scrollToPreference(appLang);

                // Current locale applied via BaseActivity.attachBaseContext
                appLang.setOnPreferenceChangeListener((preference, newValue) -> {
                    if (prefs.edit().putString(Prefs.PREF_APP_LANGUAGE, newValue.toString()).commit()) {
                        // Restart the activity to apply the language change
                        Intent intent = new Intent(requireContext(), SettingsActivity.class);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                        intent.setAction(SettingsActivity.ACTION_LANG_RESTART);
                        startActivity(intent);

                        Runtime.getRuntime().exit(0);
                    }

                    return false;
                });
            }
        }

        private void setupOtherPrefs() {
            setupAppLanguagePref();

            mPortMapping = requirePreference(Prefs.PREF_PORT_MAPPING);
            mPortMapping.setOnPreferenceClickListener(preference -> {
                Intent intent = new Intent(requireContext(), PortMapActivity.class);
                startActivity(intent);
                return true;
            });

            mIpMode = requirePreference(Prefs.PREF_IP_MODE);

            Preference ctrlPerm = requirePreference("control_permissions");
            ctrlPerm.setOnPreferenceClickListener(preference -> {
                Intent intent = new Intent(requireContext(), EditCtrlPermissions.class);
                startActivity(intent);
                return true;
            });
        }

        private void rootCaptureHideShow(boolean enabled) {
            if(enabled) {
                mAutoBlockPrivateDNS.setVisible(false);
                mBlockQuic.setVisible(false);
                mSocks5Settings.setVisible(false);
            } else {
                mAutoBlockPrivateDNS.setVisible(true);
                mBlockQuic.setVisible(true);
                socks5ProxyHideShow(mTlsDecryption.isChecked(), false);
            }

            if (VpnReconnectService.isAvailable())
                mRestartOnDisconnect.setVisible(!enabled);

            mIpMode.setVisible(!enabled);
            mCapInterface.setVisible(enabled);
            mVpnExceptions.setVisible(!enabled);
            mDnsSettings.setVisible(!enabled);
            mPortMapping.setVisible(!enabled);
        }

        private boolean checkDecrpytionWithRoot(boolean rootEnabled, boolean tlsDecryption) {
            if(mRootDecryptionNoticeShown || !rootEnabled || !tlsDecryption)
                return true;

            new AlertDialog.Builder(requireContext())
                    .setMessage(R.string.tls_decryption_with_root_msg)
                    .setPositiveButton(R.string.ok, (dialog, whichButton) -> {
                        mRootCaptureEnabled.setChecked(true);
                        mTlsDecryption.setChecked(true);

                        mRootDecryptionNoticeShown = true;
                    })
                    .show();

            return false;
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/activities/prefs/VpnExemptionsActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.activities.prefs;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.MenuItem;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.collection.ArraySet;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.activities.BaseActivity;
import com.emanuelef.remote_capture.fragments.AppsToggles;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.Prefs;

import java.util.Set;

public class VpnExemptionsActivity extends BaseActivity {
    private VpnExceptionsFragment mFragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(R.string.vpn_exemptions);
        setContentView(R.layout.fragment_activity);
        displayBackAction();

        if(savedInstanceState != null)
            mFragment = (VpnExceptionsFragment) getSupportFragmentManager().getFragment(savedInstanceState, "fragment");
        if(mFragment == null)
            mFragment = new VpnExceptionsFragment();

        getSupportFragmentManager().beginTransaction()
                .replace(R.id.fragment, mFragment)
                .commit();
    }

    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);
        getSupportFragmentManager().putFragment(outState, "fragment", mFragment);
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onBackPressed() {
        if(mFragment.onBackPressed())
            return;

        super.onBackPressed();
    }

    public static class VpnExceptionsFragment extends AppsToggles {
        private static final String TAG = "VpnExceptions";
        private final Set<String> mExcludedApps = new ArraySet<>();
        private @Nullable SharedPreferences mPrefs;

        @Override
        public void onAttach(@NonNull Context context) {
            super.onAttach(context);
            mPrefs = PreferenceManager.getDefaultSharedPreferences(context);
            assert mPrefs != null;

            mExcludedApps.clear();
            Set<String> saved = mPrefs.getStringSet(Prefs.PREF_VPN_EXCEPTIONS, null);
            if(saved != null) {
                Log.d(TAG, "Loading " + saved.size() + " exceptions");
                mExcludedApps.addAll(saved);
            }
        }

        @Override
        public void onDetach() {
            super.onDetach();
            mPrefs = null;
        }

        @Override
        protected Set<String> getCheckedApps() {
            return mExcludedApps;
        }

        @Override
        public void onAppToggled(AppDescriptor app, boolean checked) {
            String packageName = app.getPackageName();
            if(mExcludedApps.contains(packageName) == checked)
                return; // nothing to do

            if(checked)
                mExcludedApps.add(packageName);
            else
                mExcludedApps.remove(packageName);

            Log.d(TAG, "Saving " + mExcludedApps.size() + " exceptions");

            if(mPrefs == null)
                return;

            mPrefs.edit()
                    .putStringSet(Prefs.PREF_VPN_EXCEPTIONS, mExcludedApps)
                    .apply();
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/AppsAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.R;

import java.util.List;

public class AppsAdapter extends RecyclerView.Adapter<AppsAdapter.AppViewHolder> {
    private final LayoutInflater mLayoutInflater;
    private View.OnClickListener mListener;
    private List<AppDescriptor> listStorage;

    public AppsAdapter(Context context, List<AppDescriptor> customizedListView) {
        mLayoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        listStorage = customizedListView;
        mListener = null;
    }

    public static class AppViewHolder extends RecyclerView.ViewHolder {
        TextView textInListView;
        ImageView imageInListView;
        TextView packageInListView;

        public AppViewHolder(View view) {
            super(view);

            textInListView = view.findViewById(R.id.app_name);
            imageInListView = view.findViewById(R.id.app_icon);
            packageInListView= view.findViewById(R.id.app_package);
        }
    }

    @NonNull
    @Override
    public AppsAdapter.AppViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = mLayoutInflater.inflate(R.layout.app_installed_item, parent, false);
        AppViewHolder recyclerViewHolder = new AppViewHolder(view);

        if(mListener != null)
            view.setOnClickListener(mListener);

        return(recyclerViewHolder);
    }

    @Override
    public void onBindViewHolder(@NonNull AppViewHolder holder, int position) {
        AppDescriptor app = getItem(position);

        holder.textInListView.setText(app.getName());
        holder.packageInListView.setText(app.getPackageName());

        if(app.getIcon() != null)
            holder.imageInListView.setImageDrawable(app.getIcon());
    }

    @Override
    public int getItemCount() {
        return listStorage.size();
    }

    public AppDescriptor getItem(int pos) {
        if((pos < 0) || (pos > listStorage.size()))
            return null;

        return listStorage.get(pos);
    }

    public void setApps(List<AppDescriptor> apps) {
        listStorage = apps;
        notifyDataSetChanged();
    }

    public void setOnClickListener(final View.OnClickListener listener) {
        mListener = listener;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/AppsStatsAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.drawable.Drawable;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.core.content.ContextCompat;
import androidx.preference.PreferenceManager;
import androidx.recyclerview.widget.RecyclerView;

import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.AppStats;
import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.model.Blocklist;
import com.emanuelef.remote_capture.model.MatchList;
import com.emanuelef.remote_capture.model.Prefs;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class AppsStatsAdapter extends RecyclerView.Adapter<AppsStatsAdapter.ViewHolder> {
    private static final String TAG = "AppsStatsAdapter";
    private final Context mContext;
    private final SharedPreferences mPrefs;
    private final LayoutInflater mLayoutInflater;
    private final Drawable mUnknownIcon;
    private final Blocklist mBlocklist;
    private final MatchList mWhitelist;
    private final boolean mFirewallAvailable;
    private View.OnClickListener mListener;
    private List<AppStats> mStats;
    private final AppsResolver mApps;
    private AppStats mSelectedItem;
    private SortField mSortField;

    public enum SortField {
        NAME,
        TOTAL_BYTES,
        BYTES_SENT,
        BYTES_RCVD
    }

    public class ViewHolder extends RecyclerView.ViewHolder {
        ImageView icon;
        ImageView blockedFlag;
        ImageView whitelistedFlag;
        ImageView tempUnblocked;
        TextView info;
        TextView sent_rcvd;
        TextView traffic;

        ViewHolder(View itemView) {
            super(itemView);

            icon = itemView.findViewById(R.id.icon);
            blockedFlag = itemView.findViewById(R.id.blocked);
            whitelistedFlag = itemView.findViewById(R.id.whitelisted);
            tempUnblocked = itemView.findViewById(R.id.temp_unblocked);
            info = itemView.findViewById(R.id.app_info);
            sent_rcvd = itemView.findViewById(R.id.sent_rcvd);
            traffic = itemView.findViewById(R.id.traffic);
        }

        public void bindAppStats(AppStats stats) {
            Drawable appIcon;

            // NOTE: can be null
            AppDescriptor app = (mApps != null) ? mApps.getAppByUid(stats.getUid(), 0) : null;

            appIcon = ((app != null) && (app.getIcon() != null)) ? app.getIcon() : mUnknownIcon;
            icon.setImageDrawable(appIcon);

            String info_txt = (app != null) ? app.getName() : Integer.toString(stats.getUid());

            if(stats.numConnections > 1)
                info_txt += " (" + Utils.formatNumber(mContext, stats.numConnections) + ")";

            info.setText(info_txt);

            boolean isGracedApp = mBlocklist.isExemptedApp(stats.getUid());
            boolean isBlockedApp = mBlocklist.matchesApp(stats.getUid());
            boolean isWhitelistedApp = mWhitelist.matchesApp(stats.getUid());
            boolean isWhitelistEnabled = Prefs.isFirewallEnabled(mContext, mPrefs) && Prefs.isFirewallWhitelistMode(mPrefs);

            sent_rcvd.setText(mContext.getString(R.string.rcvd_and_sent, Utils.formatBytes(stats.rcvdBytes), Utils.formatBytes(stats.sentBytes)));
            traffic.setText(Utils.formatBytes(stats.sentBytes + stats.rcvdBytes));
            blockedFlag.setVisibility(isBlockedApp ? View.VISIBLE : View.GONE);
            whitelistedFlag.setVisibility(isWhitelistEnabled && isWhitelistedApp ? View.VISIBLE : View.GONE);
            tempUnblocked.setVisibility(isGracedApp ? View.VISIBLE : View.GONE);
        }
    }

    public AppsStatsAdapter(Context context) {
        mContext = context;
        mApps = new AppsResolver(context);
        mLayoutInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mUnknownIcon = ContextCompat.getDrawable(mContext, R.drawable.ic_image);
        mPrefs = PreferenceManager.getDefaultSharedPreferences(mContext);
        mBlocklist = PCAPdroid.getInstance().getBlocklist();
        mWhitelist = PCAPdroid.getInstance().getFirewallWhitelist();
        mListener = null;
        mStats = new ArrayList<>();
        mFirewallAvailable = Billing.newInstance(context).isFirewallVisible();
        mSortField = SortField.NAME;
        setHasStableIds(true);
    }

    @Override
    public int getItemCount() {
        return mStats.size();
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = mLayoutInflater.inflate(R.layout.app_item, parent, false);

        if(mListener != null)
            view.setOnClickListener(mListener);

        ViewHolder holder = new ViewHolder(view);

        if(mFirewallAvailable) {
            // Enable the ability to show the context menu
            view.setLongClickable(true);

            view.setOnLongClickListener(v -> {
                // see registerForContextMenu
                mSelectedItem = getItem(holder.getAbsoluteAdapterPosition());
                return false;
            });
        }

        return holder;
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        AppStats stats = getItem(position);

        if(stats == null)
            return;

        holder.bindAppStats(stats);
    }

    @Override
    public long getItemId(int pos) {
        AppStats stats = getItem(pos);

        return((stats != null) ? stats.getUid() : Utils.UID_UNKNOWN);
    }

    public AppStats getItem(int pos) {
        return mStats.get(pos);
    }

    public AppStats getSelectedItem() {
        return mSelectedItem;
    }

    public void notifyItemChanged(AppStats app) {
        int pos = mStats.indexOf(app);
        if(pos >= 0)
            notifyItemChanged(pos);
    }

    public String getItemPackage(int pos) {
        AppStats stats = getItem(pos);

        if(stats == null)
            return null;

        AppDescriptor descr = mApps.getAppByUid(stats.getUid(), 0);

        return((descr != null) ? descr.getPackageName() : null);
    }

    public void setClickListener(View.OnClickListener listener) {
        mListener = listener;
    }

    @SuppressLint("NotifyDataSetChanged")
    public void setStats(List<AppStats> stats) {
        Collections.sort(stats, (o1, o2) -> {
            AppDescriptor a1 = mApps.getAppByUid(o1.getUid(), 0);
            AppDescriptor a2 = mApps.getAppByUid(o2.getUid(), 0);

            if((a1 == null) && (a2 == null))
                return 0;

            if(a1 == null)
                return -1;

            if(a2 == null)
                return 1;

            switch (mSortField) {
                case TOTAL_BYTES:
                    return -Long.compare(o1.rcvdBytes + o1.sentBytes,
                            o2.rcvdBytes + o2.sentBytes);
                case BYTES_SENT:
                    return -Long.compare(o1.sentBytes, o2.sentBytes);
                case BYTES_RCVD:
                    return -Long.compare(o1.rcvdBytes, o2.rcvdBytes);
                case NAME:
                default:
                    return a1.compareTo(a2);
            }
        });

        mStats = stats;
        notifyDataSetChanged();
    }

    public SortField getSortField() {
        return mSortField;
    }

    @SuppressLint("NotifyDataSetChanged")
    public void setSortField(SortField field) {
        mSortField = field;
        setStats(mStats);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/AppsTogglesAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.annotation.SuppressLint;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.SwitchCompat;
import androidx.recyclerview.widget.RecyclerView;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.model.AppDescriptor;

import java.util.ArrayList;
import java.util.Collections;
import androidx.collection.ArraySet;
import java.util.List;
import java.util.Set;

public class AppsTogglesAdapter extends RecyclerView.Adapter<AppsTogglesAdapter.AppViewHolder> {
    private static final String TAG = "AppToggleAdapter";
    private final LayoutInflater mLayoutInflater;
    private final Set<String> mCheckedItems;
    private AppToggleListener mListener;
    private String mFilter = "";
    private boolean mShowSystemApps = false;
    private List<AppDescriptor> mApps = new ArrayList<>();
    private final List<AppDescriptor> mFilteredApps = new ArrayList<>();
    private @Nullable RecyclerView mRecyclerView;

    public AppsTogglesAdapter(Context context, Set<String> checkedItems) {
        mLayoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mCheckedItems = new ArraySet<>(checkedItems);
        mListener = null;
    }

    public interface AppToggleListener {
        void onAppToggled(AppDescriptor app, boolean checked);
    }

    public static class AppViewHolder extends RecyclerView.ViewHolder {
        TextView appName;
        TextView packageName;
        ImageView icon;
        SwitchCompat toggle;

        public AppViewHolder(View view) {
            super(view);

            appName = view.findViewById(R.id.app_name);
            icon = view.findViewById(R.id.icon);
            packageName = view.findViewById(R.id.app_package);
            toggle = view.findViewById(R.id.toggle_btn);
        }
    }

    @Override
    public void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) {
        super.onAttachedToRecyclerView(recyclerView);
        mRecyclerView = recyclerView;
    }

    @Override
    public void onDetachedFromRecyclerView(@NonNull RecyclerView recyclerView) {
        super.onDetachedFromRecyclerView(recyclerView);
        mRecyclerView = null;
    }

    @NonNull
    @Override
    public AppsTogglesAdapter.AppViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = mLayoutInflater.inflate(R.layout.app_selection_item, parent, false);
        AppViewHolder recyclerViewHolder = new AppViewHolder(view);

        view.setOnClickListener((v) -> {
            if(mRecyclerView != null) {
                int pos = recyclerViewHolder.getAbsoluteAdapterPosition();
                AppDescriptor app = getItem(pos);

                if (app != null) {
                    boolean checked = mCheckedItems.contains(app.getPackageName());
                    handleToggle(pos, !checked);
                }
            }
        });

        recyclerViewHolder.toggle.setOnClickListener((v) -> {
            if(mRecyclerView != null) {
                int pos = recyclerViewHolder.getAbsoluteAdapterPosition();
                boolean checked = ((SwitchCompat)v).isChecked();
                handleToggle(pos, checked);
            }
        });

        return(recyclerViewHolder);
    }

    @Override
    public void onBindViewHolder(@NonNull AppViewHolder holder, int position) {
        AppDescriptor app = getItem(position);

        holder.appName.setText(app.getName());
        holder.packageName.setText(app.getPackageName());
        holder.toggle.setChecked(mCheckedItems.contains(app.getPackageName()));

        if(app.getIcon() != null)
            holder.icon.setImageDrawable(app.getIcon());
    }

    private boolean isFiltering() {
        return !mFilter.isEmpty() || !mShowSystemApps;
    }

    private List<AppDescriptor> getApps() {
        if(isFiltering())
            return mFilteredApps;
        else
            return mApps;
    }

    @Override
    public int getItemCount() {
        return getApps().size();
    }

    public AppDescriptor getItem(int pos) {
        if((pos < 0) || (pos > getItemCount()))
            return null;

        return getApps().get(pos);
    }

    private void handleToggle(int old_pos, boolean checked) {
        AppDescriptor app = getItem(old_pos);
        String packageName = app.getPackageName();

        if(checked == mCheckedItems.contains(packageName))
            return; // nothing changed

        if(checked)
            mCheckedItems.add(packageName);
        else
            mCheckedItems.remove(packageName);

        if(mListener != null)
            mListener.onAppToggled(app, checked);

        if(!checked && !mShowSystemApps && app.isSystem()) {
            getApps().remove(old_pos);
            notifyItemRemoved(old_pos);
            return;
        }

        List<AppDescriptor> apps = getApps();

        // determine the new item position
        int new_pos = old_pos;
        for(int i=0; i<apps.size(); i++) {
            AppDescriptor other = apps.get(i);

            if((i != old_pos) && compareCheckedFirst(app, other) <= 0) {
                new_pos = i;
                break;
            }
        }

        if(new_pos > old_pos)
            new_pos--;

        Log.d(TAG, "Item @" + old_pos + ": " + (checked ? "checked" : "unchecked") + " -> " + new_pos);
        notifyItemChanged(old_pos);

        if(new_pos != old_pos) {
            apps.remove(old_pos);
            apps.add(new_pos, app);
            notifyItemMoved(old_pos, new_pos);

            if(mRecyclerView != null) {
                if(checked)
                    mRecyclerView.scrollToPosition(new_pos);
                else
                    mRecyclerView.scrollToPosition(old_pos);
            }
        }
    }

    // sort apps so that checked items always appear first
    private int compareCheckedFirst(AppDescriptor a, AppDescriptor b) {
        boolean aChecked = mCheckedItems.contains(a.getPackageName());
        boolean bChecked = mCheckedItems.contains(b.getPackageName());

        if(aChecked && !bChecked)
            return -1;
        else if(!aChecked && bChecked)
            return 1;
        return a.compareTo(b);
    }

    @SuppressLint("NotifyDataSetChanged")
    private void refreshedFiteredApps() {
        mFilteredApps.clear();

        if(isFiltering()) {
            for(AppDescriptor app: mApps) {
                if(!mFilter.isEmpty() && !app.matches(mFilter, false))
                    continue;
                if(!mShowSystemApps && app.isSystem() && !mCheckedItems.contains(app.getPackageName()))
                    continue;
                mFilteredApps.add(app);
            }
        }

        Collections.sort(getApps(), this::compareCheckedFirst);
        notifyDataSetChanged();
    }

    public void setApps(List<AppDescriptor> apps) {
        mApps = apps;
        refreshedFiteredApps();
    }

    public void setFilter(String text) {
        mFilter = text;
        refreshedFiteredApps();
    }

    public void setShowSystemApps(boolean show) {
        mShowSystemApps = show;
        refreshedFiteredApps();
    }

    public void setAppToggleListener(final AppToggleListener listener) {
        mListener = listener;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/BlacklistsAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.BlacklistDescriptor;

import java.util.Iterator;

public class BlacklistsAdapter extends ArrayAdapter<BlacklistDescriptor> {
    private final LayoutInflater mLayoutInflater;

    public BlacklistsAdapter(@NonNull Context context, Iterator<BlacklistDescriptor> iterator) {
        super(context, R.layout.blacklist_item);
        mLayoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

        while(iterator.hasNext()) {
            BlacklistDescriptor item = iterator.next();
            add(item);
        }
    }

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        if(convertView == null)
            convertView = mLayoutInflater.inflate(R.layout.blacklist_item, parent, false);

        Context ctx = parent.getContext();
        BlacklistDescriptor bl = getItem(position);

        TextView label = convertView.findViewById(R.id.label);
        label.setText(bl.label);

        TextView status = convertView.findViewById(R.id.status);
        status.setText(bl.getStatusLabel(ctx));
        status.setTextColor(bl.getStatusColor(ctx));
        status.setVisibility(CaptureService.isServiceActive() ? View.VISIBLE : View.INVISIBLE);

        ((TextView)convertView.findViewById(R.id.type)).setText(String.format(ctx.getString(R.string.blacklist_type), bl.getTypeLabel(ctx)));
        ((TextView)convertView.findViewById(R.id.rules)).setText(String.format(ctx.getString(R.string.n_rules), Utils.formatIntShort(bl.num_rules)));
        ((TextView)convertView.findViewById(R.id.last_update)).setText(String.format(ctx.getString(R.string.last_update_val), Utils.formatEpochMin(ctx, bl.getLastUpdate() / 1000)));

        return convertView;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/ConnectionsAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.drawable.Drawable;
import android.util.SparseIntArray;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.collection.ArraySet;
import androidx.core.content.ContextCompat;
import androidx.preference.PreferenceManager;
import androidx.recyclerview.widget.RecyclerView;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.interfaces.ConnectionsListener;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.FilterDescriptor;
import com.emanuelef.remote_capture.model.MatchList;
import com.emanuelef.remote_capture.model.Prefs;

import java.util.ArrayList;
import java.util.Arrays;

public class ConnectionsAdapter extends RecyclerView.Adapter<ConnectionsAdapter.ViewHolder>
        implements ConnectionsListener {
    private static final String TAG = "ConnectionsAdapter";
    private final LayoutInflater mLayoutInflater;
    private final Drawable mUnknownIcon;
    private int mUnfilteredItemsCount;
    private View.OnClickListener mListener;
    private View.OnLongClickListener mSelectionLongClickListener;
    private final AppsResolver mAppsResolver;
    private final Context mContext;
    private ConnectionDescriptor mSelectedItem;
    private int mNumRemovedItems;
    private final ArraySet<Integer> mSelectedItems = new ArraySet<>();
    private final int mSelectedColor;
    private final int mSelectableBackground;

    // maps a connection ID to a position in mFilteredConn. Positions are shifted by mNumRemovedItems
    // to provide an always increasing position even when items are removed. The correct unshifted
    // position is returned by getFilteredItemPos. SparseIntArray is less efficient than an HashMap
    // on large collections, but takes much less memory.
    private final SparseIntArray mIdToFilteredPos;

    private ArrayList<ConnectionDescriptor> mFilteredConn;
    private String mSearch;
    public final MatchList mMask;
    public FilterDescriptor mFilter = new FilterDescriptor(); // must call refreshFilteredConnections to apply changes

    public static class ViewHolder extends RecyclerView.ViewHolder {
        ImageView icon;
        ImageView jsInjectorInd;
        ImageView blacklistedInd;
        ImageView blockedInd;
        ImageView redirectedInd;
        ImageView decryptionInd;
        TextView statusInd;
        TextView remote;
        TextView l7proto;
        TextView traffic;
        TextView appName;
        TextView lastSeen;
        //FlagImageView countryFlag;
        final String mProtoAndPort;

        ViewHolder(View itemView) {
            super(itemView);

            icon = itemView.findViewById(R.id.icon);
            remote = itemView.findViewById(R.id.remote);
            l7proto = itemView.findViewById(R.id.l7proto);
            traffic = itemView.findViewById(R.id.traffic);
            statusInd = itemView.findViewById(R.id.status_ind);
            decryptionInd = itemView.findViewById(R.id.decryption_status);
            appName = itemView.findViewById(R.id.app_name);
            lastSeen = itemView.findViewById(R.id.last_seen);
            jsInjectorInd = itemView.findViewById(R.id.js_injector);
            blacklistedInd = itemView.findViewById(R.id.blacklisted);
            blockedInd = itemView.findViewById(R.id.blocked);
            redirectedInd = itemView.findViewById(R.id.redirected);
            //countryFlag = itemView.findViewById(R.id.country_flag);

            Context context = itemView.getContext();
            mProtoAndPort = context.getString(R.string.proto_and_port);
        }

        @SuppressWarnings("deprecation")
        public void bindConn(Context context, ConnectionDescriptor conn, AppsResolver apps, Drawable unknownIcon) {
            AppDescriptor app = apps.getAppByUid(conn.uid, 0);
            Drawable appIcon;
            String l7Text;

            appIcon = ((app != null) && (app.getIcon() != null)) ? app.getIcon() : unknownIcon;
            icon.setImageDrawable(appIcon);

            if((conn.info != null) && (conn.info.length() > 0))
                remote.setText(conn.info);
            else
                remote.setText(conn.dst_ip);

            if(conn.dst_port != 0)
                l7Text = String.format(mProtoAndPort, conn.l7proto, conn.dst_port);
            else
                l7Text = conn.l7proto;

            if(conn.ipver == 6)
                l7Text = l7Text + ", IPv6";

            l7proto.setText(l7Text);

            String info_txt = (app != null) ? app.getName() : Integer.toString(conn.uid);
            appName.setText(info_txt);
            traffic.setText(Utils.formatBytes(conn.sent_bytes + conn.rcvd_bytes));
            lastSeen.setText(Utils.formatEpochShort(context, conn.last_seen / 1000));
            statusInd.setText(conn.getStatusLabel(context));

            int color;
            if(conn.status < ConnectionDescriptor.CONN_STATUS_CLOSED)
                color = R.color.statusOpen;
            else if((conn.status == ConnectionDescriptor.CONN_STATUS_CLOSED)
                    || (conn.status == ConnectionDescriptor.CONN_STATUS_RESET))
                color = R.color.statusClosed;
            else if ((conn.status == ConnectionDescriptor.CONN_STATUS_ERROR)
                    || ((conn.status == ConnectionDescriptor.CONN_STATUS_SOCKET_ERROR))
                    || (conn.status == ConnectionDescriptor.CONN_STATUS_UNREACHABLE))
                color = R.color.warning;
            else
                color = R.color.statusError;

            statusInd.setTextColor(ContextCompat.getColor(context, color));

            /*if(conn.country.isEmpty())
                countryFlag.setVisibility(View.GONE);
            else {
                countryFlag.setVisibility(View.VISIBLE);
                countryFlag.setCountryCode(conn.country);
            }*/

            jsInjectorInd.setVisibility(((conn.js_injected_scripts != null) && !conn.js_injected_scripts.isEmpty()) ? View.VISIBLE : View.GONE);
            blacklistedInd.setVisibility(conn.isBlacklisted() ? View.VISIBLE : View.GONE);
            blockedInd.setVisibility(conn.is_blocked ? View.VISIBLE : View.GONE);
            redirectedInd.setVisibility((conn.isPortMappingApplied() && !conn.is_blocked) ? View.VISIBLE : View.GONE);

            if(CaptureService.isDecryptingTLS() || PCAPdroid.getInstance().isDecryptingPcap()) {
                decryptionInd.setVisibility(View.VISIBLE);
                Utils.setDecryptionIcon(decryptionInd, conn);
            } else
                decryptionInd.setVisibility(View.GONE);
        }
    }

    public ConnectionsAdapter(Context context, AppsResolver resolver) {
        mContext = context;
        mAppsResolver = resolver;
        mLayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mUnknownIcon = ContextCompat.getDrawable(context, R.drawable.ic_image);
        mListener = null;
        mFilteredConn = null;
        mUnfilteredItemsCount = 0;
        mNumRemovedItems = 0;
        mIdToFilteredPos = new SparseIntArray();
        mMask = PCAPdroid.getInstance().getVisualizationMask();
        mSearch = null;
        TypedArray a = context.obtainStyledAttributes(new int[]{android.R.attr.colorControlHighlight});
        mSelectedColor = a.getColor(0, 0x40808080);
        a.recycle();
        TypedValue tv = new TypedValue();
        context.getTheme().resolveAttribute(android.R.attr.selectableItemBackground, tv, true);
        mSelectableBackground = tv.resourceId;
        setHasStableIds(true);
    }

    @Override
    public int getItemCount() {
        return((mFilteredConn != null) ? mFilteredConn.size() : mUnfilteredItemsCount);
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = mLayoutInflater.inflate(R.layout.connection_item, parent, false);

        // Enable the ability to show the context menu
        view.setLongClickable(true);

        if(mListener != null)
            view.setOnClickListener(mListener);

        ViewHolder holder = new ViewHolder(view);

        view.setOnLongClickListener(v -> {
            if((mSelectionLongClickListener != null) && mSelectionLongClickListener.onLongClick(v))
                return true;

            // see registerForContextMenu
            mSelectedItem = getItem(holder.getAbsoluteAdapterPosition());
            return false;
        });

        return holder;
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        ConnectionDescriptor conn = getItem(position);
        if(conn == null) {
            Log.w(TAG, "bad position: " + position);
            return;
        }

        holder.bindConn(mContext, conn, mAppsResolver, mUnknownIcon);

        if(mSelectedItems.contains(conn.incr_id))
            holder.itemView.setBackgroundColor(mSelectedColor);
        else
            holder.itemView.setBackgroundResource(mSelectableBackground);
    }

    @Override
    public long getItemId(int pos) {
        ConnectionDescriptor conn = getItem(pos);

        return ((conn != null) ? conn.incr_id : -1);
    }

    private boolean matches(ConnectionDescriptor conn) {
        return((conn != null)
                && mFilter.matches(conn)
                && ((mSearch == null) || conn.matches(mAppsResolver, mSearch)));
    }

    // Given an incrId, return the position of the connection into the mFilteredConn array
    private int getFilteredItemPos(int incrId) {
        int pos = mIdToFilteredPos.get(incrId, -1);
        if(pos == -1)
            return -1;

        return(pos - mNumRemovedItems);
    }

    private void removeFilteredItemAt(int pos) {
        // get the previous item which was now removed
        ConnectionDescriptor item = getItem(pos);
        if(item == null)
            return;

        mFilteredConn.remove(pos);
        mIdToFilteredPos.delete(item.incr_id);
        notifyItemRemoved(pos);
    }

    /* Fixes the mappings in mIdToFilteredPos, starting from the provided position */
    private void fixFilteredPositions(int startPos) {
        for(int i=startPos; i<mFilteredConn.size(); i++)
            mIdToFilteredPos.put(mFilteredConn.get(i).incr_id, i + mNumRemovedItems);
    }

    @Override
    public void connectionsChanges(int num_connetions) {
        //Log.d(TAG, "connectionsChanges: " + num_connetions + " connections");
        mUnfilteredItemsCount = num_connetions;
        refreshFilteredConnections();
    }

    @Override
    public void connectionsAdded(int start, ConnectionDescriptor []conns) {
        //Log.d(TAG, "connectionsAdded: at " + start + ", " + conns.length + " connections");
        mUnfilteredItemsCount += conns.length;

        if(mFilteredConn == null) {
            notifyItemRangeInserted(start, conns.length);
            return;
        }

        // Here dealing with filtered connections
        int numNew = 0;
        int pos = mNumRemovedItems + mFilteredConn.size();

        // Assume that connections are only added at the end of the dataset
        for(ConnectionDescriptor conn : conns) {
            if(matches(conn)) {
                mIdToFilteredPos.put(conn.incr_id, pos++);
                mFilteredConn.add(conn);
                numNew++;
            }
        }

        if(numNew > 0)
            notifyItemRangeInserted(mFilteredConn.size() - numNew, numNew);
    }

    @Override
    public void connectionsRemoved(int start, ConnectionDescriptor []conns) {
        //Log.d(TAG, "connectionsRemoved: at " + start + ", " + conns.length + " connections");
        mUnfilteredItemsCount -= conns.length;

        if(mFilteredConn == null) {
            notifyItemRangeRemoved(start, conns.length);
            return;
        }

        // Here dealing with filtered connections
        for(ConnectionDescriptor conn: conns) {
            if(conn == null)
                continue;

            mSelectedItems.remove(conn.incr_id);

            int pos = getFilteredItemPos(conn.incr_id);
            if(pos != -1) {
                // Assume that connections are only removed from the start of the dataset
                removeFilteredItemAt(0);

                // by incrementing mNumRemovedItems we can shift the position of subsequent items
                mNumRemovedItems++;
            }
        }
    }

    @Override
    public void connectionsUpdated(int[] positions) {
        //Log.d(TAG, "connectionsUpdated: " + positions.length + " connections");

        if(mFilteredConn == null) {
            for(int pos : positions)
                notifyItemChanged(pos);
            return;
        }

        // Here dealing with filtered connections
        ConnectionsRegister reg = CaptureService.requireConnsRegister();
        int first_removed_pos = -1;
        int num_just_removed = 0;

        // Sort order necessary to properly use num_just_removed
        Arrays.sort(positions);

        for(int reg_pos : positions) {
            ConnectionDescriptor conn = reg.getConn(reg_pos);
            if(conn != null) {
                // reg_pos is the position in the ConnectionsRegister, whereas pos is the position
                // in mFilteredConn
                int pos = getFilteredItemPos(conn.incr_id);
                if(pos != -1) {
                    // Need to shift by num_just_removed due to the removeFilteredItemAt below until
                    // fixFilteredPositions is called
                    pos -= num_just_removed;

                    if(matches(conn)) {
                        Log.d(TAG, "Changed item " + pos + ", dataset size: " + getItemCount());
                        notifyItemChanged(pos);
                    } else {
                        Log.d(TAG, "Unmatch item " + pos + ": " + conn.toString());

                        // A previously matching connection may not match anymore. This happens, for
                        // example, when its info or protocol is updated. In this case, the connection
                        // must be removed.
                        removeFilteredItemAt(pos);
                        num_just_removed++;

                        if(first_removed_pos == -1)
                            first_removed_pos = pos;
                    }
                }
            }
        }

        // Need to recalculate the mappings starting at the first removed item
        if(first_removed_pos != -1)
            fixFilteredPositions(first_removed_pos);
    }

    @SuppressLint("NotifyDataSetChanged")
    public void refreshFilteredConnections() {
        final ConnectionsRegister reg = CaptureService.getConnsRegister();
        if(reg == null)
            return;

        Log.d(TAG, "refreshFilteredConn (" + mUnfilteredItemsCount + ") unfiltered");
        mIdToFilteredPos.clear();
        mNumRemovedItems = 0;

        if(hasFilter()) {
            int pos = 0;
            mFilteredConn = new ArrayList<>();

            // Synchronize to improve performance of getConn
            synchronized(reg) {
                for(int i = 0; i < mUnfilteredItemsCount; i++) {
                    ConnectionDescriptor conn = reg.getConn(i);

                    if(matches(conn)) {
                        mFilteredConn.add(conn);
                        mIdToFilteredPos.put(conn.incr_id, pos++);
                    }
                }
            }

            Log.d(TAG, "refreshFilteredConn: " + mFilteredConn.size() + " connections matched");
        } else
            mFilteredConn = null;

        notifyDataSetChanged();
    }

    public ConnectionDescriptor getItem(int pos) {
        if(mFilteredConn != null) {
            if((pos < 0) || (pos >= mFilteredConn.size())) {
                Log.w(TAG, "getItem(filtered): bad position: " + pos);
                return null;
            }
            return mFilteredConn.get(pos);
        }

        ConnectionsRegister reg = CaptureService.getConnsRegister();
        if((pos < 0) || (pos >= mUnfilteredItemsCount) || (reg == null)) {
            Log.w(TAG, "getItem: bad position: " + pos);
            return null;
        }

        return reg.getConn(pos);
    }

    public void setSearch(String text) {
        mSearch = text;
        refreshFilteredConnections();
    }

    public void setClickListener(View.OnClickListener listener) {
        mListener = listener;
    }

    public ConnectionDescriptor getSelectedItem() {
        return mSelectedItem;
    }

    public boolean hasFilter() {
        return (mSearch != null) || mFilter.isSet();
    }

    public String dumpConnectionsCsv(boolean selectedOnly) {
        StringBuilder builder = new StringBuilder();
        AppsResolver resolver = new AppsResolver(mContext);
        boolean malwareDetection = Prefs.isMalwareDetectionEnabled(mContext, PreferenceManager.getDefaultSharedPreferences(mContext));

        String header = mContext.getString(R.string.connections_csv_fields);
        builder.append(header);
        if(malwareDetection)
            builder.append(",Malicious");
        builder.append("\n");

        for(int i = 0; i < getItemCount(); i++) {
            ConnectionDescriptor conn = getItem(i);

            if((conn != null) && (!selectedOnly || mSelectedItems.contains(conn.incr_id))) {
                AppDescriptor app = resolver.getAppByUid(conn.uid, 0);

                builder.append(conn.ipproto);                               builder.append(",");
                builder.append(conn.src_ip);                                builder.append(",");
                builder.append(conn.src_port);                              builder.append(",");
                builder.append(conn.dst_ip);                                builder.append(",");
                builder.append(conn.dst_port);                              builder.append(",");
                builder.append(conn.uid);                                   builder.append(",");
                builder.append((app != null) ? app.getName() : "");         builder.append(",");
                builder.append((app != null) ? app.getPackageName() : "");  builder.append(",");
                builder.append(conn.l7proto);                               builder.append(",");
                builder.append(conn.getStatusLabel(mContext));              builder.append(",");
                builder.append((conn.info != null) ? conn.info : "");       builder.append(",");
                builder.append(conn.sent_bytes);                            builder.append(",");
                builder.append(conn.rcvd_bytes);                            builder.append(",");
                builder.append(conn.sent_pkts);                             builder.append(",");
                builder.append(conn.rcvd_pkts);                             builder.append(",");
                builder.append(Utils.formatMillisIso8601(mContext, conn.first_seen));                            builder.append(",");
                builder.append(Utils.formatMillisIso8601(mContext, conn.last_seen));

                if(malwareDetection) {
                    builder.append(",");

                    if(conn.isBlacklisted())
                        builder.append("yes");
                }

                builder.append("\n");
            }
        }

        return builder.toString();
    }

    public void toggleSelection(int position) {
        ConnectionDescriptor conn = getItem(position);
        if(conn == null)
            return;

        if(!mSelectedItems.remove(conn.incr_id))
            mSelectedItems.add(conn.incr_id);
        notifyItemChanged(position);
    }

    public void selectItem(int position) {
        ConnectionDescriptor conn = getItem(position);
        if(conn == null)
            return;

        mSelectedItems.add(conn.incr_id);
        notifyItemChanged(position);
    }

    @SuppressLint("NotifyDataSetChanged")
    public void clearSelection() {
        mSelectedItems.clear();
        notifyDataSetChanged();
    }

    public int getSelectedCount() {
        return mSelectedItems.size();
    }

    @SuppressLint("NotifyDataSetChanged")
    public void selectAll() {
        for(int i = 0; i < getItemCount(); i++) {
            ConnectionDescriptor conn = getItem(i);
            if(conn != null)
                mSelectedItems.add(conn.incr_id);
        }
        notifyDataSetChanged();
    }

    public void setSelectionLongClickListener(View.OnLongClickListener listener) {
        mSelectionLongClickListener = listener;
    }

    public ArrayList<Integer> getFilteredConnectionIds() {
        if (mFilteredConn == null)
            return null;

        ArrayList<Integer> ids = new ArrayList<>(mFilteredConn.size());
        for (ConnectionDescriptor conn : mFilteredConn) {
            ids.add(conn.incr_id);
        }
        return ids;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/CtrlPermissionsAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.content.Context;
import android.content.pm.PackageManager;
import android.util.ArrayMap;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.interfaces.TextAdapter;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.CtrlPermissions;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

public class CtrlPermissionsAdapter extends ArrayAdapter<CtrlPermissions.Rule> implements TextAdapter {
    private final LayoutInflater mLayoutInflater;
    private final CtrlPermissions mPermissions;
    private final Context mContext;
    private final ArrayMap<String, AppDescriptor> mPkgToApp = new ArrayMap<>();

    public CtrlPermissionsAdapter(Context context, CtrlPermissions perms) {
        super(context, R.layout.rule_item);
        mLayoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mPermissions = perms;
        mContext = context;
        load();
    }

    private void load() {
        PackageManager pm = mContext.getPackageManager();
        Iterator<CtrlPermissions.Rule> it = mPermissions.iterRules();
        List<CtrlPermissions.Rule> sorted = new ArrayList<>();

        while(it.hasNext()) {
            CtrlPermissions.Rule rule = it.next();
            AppDescriptor app = AppsResolver.resolveInstalledApp(pm, rule.package_name, 0);
            if(app != null)
                mPkgToApp.put(rule.package_name, app);

            sorted.add(rule);
        }

        // sort by package name. It would be better to sort them via AppDescriptor.compareTo but
        // some apps may be null.
        Collections.sort(sorted, (o1, o2) -> {
            return o1.package_name.compareTo(o2.package_name);
        });
        addAll(sorted);
    }

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        if(convertView == null)
            convertView = mLayoutInflater.inflate(R.layout.rule_item, parent, false);

        CtrlPermissions.Rule rule = getItem(position);
        AppDescriptor app = mPkgToApp.get(rule.package_name); // may be null
        String text = String.format(mContext.getString(R.string.control_permissions_item),
                (app == null) ? rule.package_name : String.format("%s (%s)", app.getName(), app.getPackageName()),
                mContext.getString((rule.consent == CtrlPermissions.ConsentType.ALLOW) ? R.string.allow : R.string.deny));

        ((TextView)convertView.findViewById(R.id.item_label)).setText(text);

        return convertView;
    }

    @Override
    public String getItemText(int pos) {
        return getItem(pos).package_name;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/HttpLogAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.drawable.Drawable;
import android.util.SparseIntArray;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.collection.ArraySet;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.RecyclerView;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.HttpLog;
import com.emanuelef.remote_capture.HttpLog.HttpRequest;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.HttpLogFilterDescriptor;

import java.util.ArrayList;

public class HttpLogAdapter extends RecyclerView.Adapter<HttpLogAdapter.ViewHolder> implements HttpLog.Listener {
    private static final String TAG = "HttpLogAdapter";
    private final LayoutInflater mLayoutInflater;
    private final Drawable mUnknownIcon;
    private View.OnClickListener mListener;
    private View.OnLongClickListener mLongClickListener;
    private final AppsResolver mAppsResolver;
    private final Context mContext;
    private HttpRequest mSelectedItem;
    private final ArraySet<Integer> mSelectedItems = new ArraySet<>();
    private final int mSelectedColor;
    private final int mSelectableBackground;

    // maps a positions from HttpLog to mFilteredReqs.
    private final SparseIntArray mIdToFilteredPos;

    private ArrayList<HttpRequest> mFilteredReqs;
    private String mSearch;
    public HttpLogFilterDescriptor mFilter;

    public static class ViewHolder extends RecyclerView.ViewHolder {
        ImageView icon;
        TextView appName;
        TextView methodAndPath;
        TextView protoAndHost;
        TextView contentType;
        TextView reqTime;
        TextView httpStatus;
        TextView payloadSize;

        ViewHolder(View itemView) {
            super(itemView);

            icon = itemView.findViewById(R.id.icon);
            appName = itemView.findViewById(R.id.app_name);
            methodAndPath = itemView.findViewById(R.id.method_and_path);
            protoAndHost = itemView.findViewById(R.id.proto_and_host);
            contentType = itemView.findViewById(R.id.content_type);
            reqTime = itemView.findViewById(R.id.req_time);
            httpStatus = itemView.findViewById(R.id.http_status);
            payloadSize = itemView.findViewById(R.id.payload_size);
        }

        public void bindItem(HttpRequest req, Context ctx, AppsResolver apps, Drawable unknownIcon) {
            AppDescriptor app = apps.getAppByUid(req.conn.uid, 0);

            Drawable appIcon = ((app != null) && (app.getIcon() != null)) ? app.getIcon() : unknownIcon;
            icon.setImageDrawable(appIcon);

            String info_txt = (app != null) ? app.getName() : Integer.toString(req.conn.uid);
            appName.setText(info_txt);

            methodAndPath.setText(String.format("%s %s", req.method, req.path));
            protoAndHost.setText(req.getProtoAndHost());
            contentType.setText((req.reply != null) ? req.reply.contentType : "");
            reqTime.setText(Utils.formatEpochShort(ctx, req.timestamp / 1000));
            httpStatus.setText(req.decryptionError.isEmpty() ? getResponseCodeText(ctx, req) :
                    ctx.getString(R.string.decryption_error));

            int tot_length = (req.reply != null) ? (req.bodyLength + req.reply.bodyLength) : req.bodyLength;
            payloadSize.setText(Utils.formatBytes(tot_length));
            httpStatus.setTextColor(ContextCompat.getColor(ctx, req.decryptionError.isEmpty() ?
                    getResponseCodeColor(req) : R.color.statusError));
        }
    }

    private static String getResponseCodeText(Context ctx, HttpRequest req) {
        if ((req.reply != null) && (req.reply.responseCode > 0))
            return String.format(Utils.getPrimaryLocale(ctx), "%d %s", req.reply.responseCode, req.reply.responseStatus);
        else if (req.httpRst)
            return "RST_STREAM";
        else
            return "—";
    }

    private static int getResponseCodeColor(HttpRequest req) {
        int color = R.color.colorTabText;

        if (req.reply != null) {
            int code = req.reply.responseCode;

            if((code >= 200) && (code <= 299))
                color = R.color.statusOpen;
            else if((code >= 300) && (code <= 399))
                color = R.color.lightGray;
            else if((code >= 400) && (code <= 599))
                color = R.color.statusError;
        } else if (req.httpRst)
            color = R.color.statusError;

        return color;
    }

    public HttpLogAdapter(Context context, AppsResolver resolver) {
        mContext = context;
        mAppsResolver = resolver;
        mLayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mUnknownIcon = ContextCompat.getDrawable(context, R.drawable.ic_image);
        mIdToFilteredPos = new SparseIntArray();
        mListener = null;
        mFilteredReqs = null;
        mSearch = null;
        mFilter = new HttpLogFilterDescriptor();
        TypedArray a = context.obtainStyledAttributes(new int[]{android.R.attr.colorControlHighlight});
        mSelectedColor = a.getColor(0, 0x40808080);
        a.recycle();
        TypedValue tv = new TypedValue();
        context.getTheme().resolveAttribute(android.R.attr.selectableItemBackground, tv, true);
        mSelectableBackground = tv.resourceId;
        setHasStableIds(true);

        refreshFilteredItems();
    }

    @Override
    public int getItemCount() {
        if (mFilteredReqs != null)
            return mFilteredReqs.size();

        HttpLog httpLog = CaptureService.getHttpLog();
        return((httpLog != null) ? httpLog.getSize() : 0);
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = mLayoutInflater.inflate(R.layout.http_req_item, parent, false);
        view.setLongClickable(true);

        if(mListener != null)
            view.setOnClickListener(mListener);

        view.setOnLongClickListener(v -> {
            if(mLongClickListener != null)
                return mLongClickListener.onLongClick(v);
            return false;
        });

        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        HttpRequest item = getItem(position);
        if(item == null) {
            Log.w(TAG, "bad position: " + position);
            return;
        }

        holder.bindItem(item, mContext, mAppsResolver, mUnknownIcon);

        if(mSelectedItems.contains(item.getPosition()))
            holder.itemView.setBackgroundColor(mSelectedColor);
        else
            holder.itemView.setBackgroundResource(mSelectableBackground);
    }

    @Override
    public long getItemId(int pos) {
        HttpRequest item = getItem(pos);

        return ((item != null) ? item.getPosition() : -1);
    }

    public @Nullable HttpRequest getItem(int pos) {
        if(mFilteredReqs != null) {
            if((pos < 0) || (pos >= mFilteredReqs.size())) {
                Log.w(TAG, "getItem(filtered): bad position: " + pos);
                return null;
            }
            return mFilteredReqs.get(pos);
        }

        HttpLog httpLog = CaptureService.getHttpLog();
        if((httpLog == null) || (pos < 0) || (pos >= httpLog.getSize())) {
            Log.w(TAG, "getItem: bad position: " + pos);
            return null;
        }

        return httpLog.getRequest(pos);
    }

    @Override
    public void onHttpRequestAdded(int pos) {
        Log.d(TAG, "onHttpRequestAdded " + pos);
        HttpLog httpLog = CaptureService.getHttpLog();
        if (httpLog == null)
            return;

        HttpRequest req = httpLog.getRequest(pos);
        if (req == null)
            return;

        if (mFilteredReqs != null) {
            if (matches(req)) {
                int filtered_pos = mFilteredReqs.size();
                mIdToFilteredPos.put(pos, filtered_pos);
                mFilteredReqs.add(req);
                notifyItemInserted(filtered_pos);
            }
        } else
            notifyItemInserted(pos);
    }

    @Override
    public void onHttpRequestUpdated(int pos) {
        if (mFilteredReqs == null) {
            if ((pos >= 0) && (pos < getItemCount()))
                notifyItemChanged(pos);
            return;
        }

        int filtered_pos = mIdToFilteredPos.get(pos, -1);
        if (filtered_pos != -1) {
            notifyItemChanged(filtered_pos);
            return;
        }

        HttpLog httpLog = CaptureService.getHttpLog();
        if (httpLog == null)
            return;

        HttpRequest req = httpLog.getRequest(pos);
        if ((req != null) && matches(req)) {
            int new_pos = mFilteredReqs.size();
            mIdToFilteredPos.put(pos, new_pos);
            mFilteredReqs.add(req);
            notifyItemInserted(new_pos);
        }
    }

    @Override
    public void onHttpRequestsClear() {
        mSelectedItem = null;
        mSelectedItems.clear();
        refreshFilteredItems();
    }

    @SuppressLint("NotifyDataSetChanged")
    public void refreshFilteredItems() {
        mIdToFilteredPos.clear();
        mFilteredReqs = null;

        final HttpLog httpLog = CaptureService.getHttpLog();
        if(httpLog != null) {
            Log.d(TAG, "refreshFilteredConn (" + httpLog.getSize() + ") unfiltered");

            if (hasFilter()) {
                int pos = 0;
                mFilteredReqs = new ArrayList<>();

                // Synchronize to improve performance of getConn
                synchronized (httpLog) {
                    for (int i = 0; i < httpLog.getSize(); i++) {
                        HttpRequest req = httpLog.getRequest(i);

                        if ((req != null) && matches(req)) {
                            mFilteredReqs.add(req);
                            mIdToFilteredPos.put(i, pos++);
                        }
                    }
                }

                Log.d(TAG, "refreshFilteredItems: " + mFilteredReqs.size() + " items matched");
            }
        }

        notifyDataSetChanged();
    }

    private boolean matches(HttpRequest req) {
        boolean searchMatch = (mSearch == null) || req.matches(mSearch);
        boolean filterMatch = !mFilter.isSet() || mFilter.matches(req);
        return searchMatch && filterMatch;
    }

    public void setSearch(String text) {
        mSearch = text;
        refreshFilteredItems();
    }

    public void setClickListener(View.OnClickListener listener) {
        mListener = listener;
    }

    public HttpRequest getSelectedItem() {
        return mSelectedItem;
    }

    public boolean hasFilter() {
        return (mSearch != null) || mFilter.isSet();
    }

    public ArrayList<Integer> getFilteredPositions() {
        if (mFilteredReqs == null)
            return null;

        ArrayList<Integer> positions = new ArrayList<>(mFilteredReqs.size());
        for (HttpRequest req : mFilteredReqs) {
            positions.add(req.getPosition());
        }
        return positions;
    }

    public void setLongClickListener(View.OnLongClickListener listener) {
        mLongClickListener = listener;
    }

    public void toggleSelection(int position) {
        HttpRequest req = getItem(position);
        if(req == null)
            return;

        if(!mSelectedItems.remove(req.getPosition()))
            mSelectedItems.add(req.getPosition());
        notifyItemChanged(position);
    }

    public void selectItem(int position) {
        HttpRequest req = getItem(position);
        if(req == null)
            return;

        mSelectedItems.add(req.getPosition());
        notifyItemChanged(position);
    }

    @SuppressLint("NotifyDataSetChanged")
    public void clearSelection() {
        mSelectedItems.clear();
        notifyDataSetChanged();
    }

    public int getSelectedCount() {
        return mSelectedItems.size();
    }

    @SuppressLint("NotifyDataSetChanged")
    public void selectAll() {
        for(int i = 0; i < getItemCount(); i++) {
            HttpRequest req = getItem(i);
            if(req != null)
                mSelectedItems.add(req.getPosition());
        }
        notifyDataSetChanged();
    }

    public boolean isSelected(HttpRequest req) {
        return mSelectedItems.contains(req.getPosition());
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/ListEditAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;
import androidx.core.graphics.drawable.DrawableCompat;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.interfaces.TextAdapter;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.MatchList;
import com.haipq.android.flagkit.FlagImageView;

import java.util.Iterator;

public class ListEditAdapter extends ArrayAdapter<MatchList.Rule> implements TextAdapter {
    private final LayoutInflater mLayoutInflater;
    private final AppsResolver mApps;
    private final Drawable mDefaultIcon;
    private final Drawable mUnknownIcon;

    public ListEditAdapter(Context context) {
        super(context, R.layout.rule_item);
        mLayoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mApps = new AppsResolver(context);
        mUnknownIcon = ContextCompat.getDrawable(context, R.drawable.ic_image);
        mDefaultIcon = ContextCompat.getDrawable(context, R.drawable.ic_short_text);
        assert mDefaultIcon != null;
        DrawableCompat.setTint(mDefaultIcon, ContextCompat.getColor(context, R.color.colorTabText));
    }

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        if(convertView == null)
            convertView = mLayoutInflater.inflate(R.layout.rule_item, parent, false);

        MatchList.Rule rule = getItem(position);
        ((TextView)convertView.findViewById(R.id.item_label)).setText(rule.getLabel());

        ImageView icon = convertView.findViewById(R.id.icon);
        FlagImageView country_flag = convertView.findViewById(R.id.country_flag);
        boolean showFlag = false;

        if (rule.getType() == MatchList.RuleType.COUNTRY) {
            // try to load the country flag, fall back to default icon on failure
            country_flag.setCountryCode((String) rule.getValue());
            showFlag = (country_flag.getDrawable() != null);
        }

        icon.setVisibility(showFlag ? View.GONE : View.VISIBLE);
        country_flag.setVisibility(!showFlag ? View.GONE : View.VISIBLE);

        if (!showFlag) {
            if (rule.getType() == MatchList.RuleType.APP) {
                String package_name = (String) rule.getValue();
                AppDescriptor app = mApps.getAppByPackage(package_name, 0);
                Drawable drawable = ((app != null) && (app.getIcon() != null)) ? app.getIcon() : mUnknownIcon;
                icon.setImageDrawable(drawable);
            } else
                icon.setImageDrawable(mDefaultIcon);
        }

        return convertView;
    }

    @Override
    public String getItemText(int pos) {
        return getItem(pos).getLabel();
    }

    public void reload(Iterator<MatchList.Rule> items) {
        clear();

        while(items.hasNext()) {
            MatchList.Rule item = items.next();
            add(item);
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/PayloadAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.annotation.SuppressLint;
import android.app.AlertDialog;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.CheckResult;
import androidx.annotation.NonNull;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.RecyclerView;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.HTTPReassembly;
import com.emanuelef.remote_capture.HttpLog;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.PayloadChunk;
import com.emanuelef.remote_capture.model.PayloadChunk.ChunkType;
import com.emanuelef.remote_capture.model.Prefs;
import com.google.android.material.button.MaterialButton;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;

import java.nio.charset.StandardCharsets;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Locale;

/* An adapter to show PayloadChunk items.
 * Each item is wrapped into an AdapterChunk. An item can either be collapsed or expanded.
 * Since the text of a chunk can be very long (hundreds of KB) and rendering it would freeze the UI,
 * it is split into pages of VISUAL_PAGE_SIZE. */
public class PayloadAdapter extends RecyclerView.Adapter<PayloadAdapter.PayloadViewHolder> implements HTTPReassembly.ReassemblyListener {
    private static final String TAG = "PayloadAdapter";
    public static final int COLLAPSE_CHUNK_SIZE = 1500;
    public static final int VISUAL_PAGE_SIZE = 4020; // must be a multiple of 67 to avoid splitting the hexdump
    private final LayoutInflater mLayoutInflater;
    private final ConnectionDescriptor mConn;
    private final Context mContext;
    private final ChunkType mMode;
    private int mHandledChunks;
    private final ArrayList<AdapterChunk> mUnrepliedHttpReqs = new ArrayList<>();
    private final ArrayList<AdapterChunk> mChunks = new ArrayList<>();
    private final HTTPReassembly mHttpReq;
    private final HTTPReassembly mHttpRes;
    private final boolean mSupportsFileDialog;
    private final PayloadChunk mSingleChunk;
    private boolean mShowAsPrintable;
    private ExportPayloadHandler mExportHandler;

    public interface ExportPayloadHandler {
        void exportPayload(String payload);
        void exportPayload(byte[] payload, String contentType, String fname);
    }

    /* if singleChunk is set, this adapter will only show that chunk */
    private PayloadAdapter(Context context, ConnectionDescriptor conn, ChunkType mode,
                          boolean showAsPrintable, PayloadChunk singleChunk) {
        mLayoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mConn = conn;
        mContext = context;
        mMode = mode;
        mShowAsPrintable = showAsPrintable;
        mSupportsFileDialog = Utils.supportsFileDialog(context);
        mSingleChunk = singleChunk;

        if (mSingleChunk == null) {
            // Note: in minimal mode, only the first chunk is captured, so don't reassemble them
            boolean reassemble = (CaptureService.getCurPayloadMode() == Prefs.PayloadMode.FULL);

            // each direction must have its separate reassembly
            mHttpReq = new HTTPReassembly(reassemble, this);
            mHttpRes = new HTTPReassembly(reassemble, this);

            handleChunksAdded(mConn.getNumPayloadChunks());
        } else {
            mHttpReq = null;
            mHttpRes = null;

            if (mSingleChunk.payload.length > 0) {
                mChunks.add(new AdapterChunk(mSingleChunk, 0));
                notifyItemInserted(0);
            }
        }
    }

    public PayloadAdapter(Context context, ConnectionDescriptor conn, ChunkType mode,  boolean showAsPrintable) {
        this(context, conn, mode, showAsPrintable, null);
    }

    public PayloadAdapter(Context context, HttpLog.HttpRequest req, boolean show_reply) {
        this(context, req.conn, ChunkType.HTTP, true, getChunk(req, show_reply));
    }

    private static PayloadChunk getChunk(HttpLog.HttpRequest req, boolean show_reply) {
        if (show_reply) {
            if (req.reply != null)
                return req.conn.getHttpResponseChunk(req.reply.firstChunkPos);
        } else
            return req.conn.getHttpRequestChunk(req.firstChunkPos);

        // return an empty chunk instead of null to activate the single-chunk mode
        return new PayloadChunk(new byte[0], ChunkType.HTTP, true, 0, 0);
    }

    public void setExportPayloadHandler(ExportPayloadHandler handler) {
        mExportHandler = handler;
    }

    static final int MAX_JSON_FORMAT_SIZE = 1024 * 1024;

    private static final Gson prettyGson = new GsonBuilder().setPrettyPrinting().create();

    static String formatHttpPayload(String text, String contentType) {
        if ((contentType == null) || !contentType.equals("application/json"))
            return text;
        if (text.length() > MAX_JSON_FORMAT_SIZE)
            return text;

        int sep = text.indexOf("\r\n\r\n");
        if ((sep < 0) || (sep + 4 >= text.length()))
            return text;

        String headers = text.substring(0, sep + 4);
        String body = text.substring(sep + 4);

        try {
            String pretty = prettyGson.toJson(JsonParser.parseString(body));
            return headers + pretty;
        } catch (JsonSyntaxException e) {
            return text;
        }
    }

    private class AdapterChunk {
        private final PayloadChunk mChunk;
        private String mTheText;
        private boolean mIsExpanded;
        private int mNumPages = 1;
        public final int incrId;

        AdapterChunk(PayloadChunk _chunk, int incr_id) {
            mChunk = _chunk;
            incrId = incr_id;
        }

        boolean canBeExpanded() {
            return mChunk.payload.length > COLLAPSE_CHUNK_SIZE;
        }

        boolean isExpanded() {
            return mIsExpanded;
        }

        int getNumPages() {
            return mNumPages;
        }

        PayloadChunk getPayloadChunk() {
            return mChunk;
        }

        @CheckResult
        private String makeText(boolean as_printable, boolean expanded) {
            int dump_len = expanded ? mChunk.payload.length : Math.min(mChunk.payload.length, COLLAPSE_CHUNK_SIZE);

            if(!as_printable)
                return Utils.hexdump(mChunk.payload, 0, dump_len);
            else
                return new String(mChunk.payload, 0, dump_len, StandardCharsets.UTF_8);
        }

        @CheckResult
        private String makeText() {
            String text = makeText(mShowAsPrintable, mIsExpanded);
            if (mShowAsPrintable && (mMode == ChunkType.HTTP))
                text = formatHttpPayload(text, mChunk.httpContentType);
            return text;
        }

        void expand() {
            mIsExpanded = true;
            mTheText = makeText();

            // round up div
            mNumPages = (mTheText.length() + VISUAL_PAGE_SIZE - 1) / VISUAL_PAGE_SIZE;
        }

        // collapses the item and returns the old number of pages
        void collapse() {
            mIsExpanded = false;
            mTheText = null;

            mNumPages = 1;
        }

        String getText(int start, int end) {
            if(mTheText == null)
                mTheText = makeText();

            if((start == 0) && (end >= mTheText.length() - 1)) {
                return mTheText;
            }

            return mTheText.substring(start, end);
        }

        String getExpandedText(boolean as_printable) {
            return makeText(as_printable, true);
        }

        Page getPage(int pageIdx) {
            assert(pageIdx < mNumPages);

            if(mTheText == null)
                mTheText = makeText();

            if(!mIsExpanded)
                return new Page(this, 0, mTheText.length() - 1, true);
            else
                return new Page(this, pageIdx * VISUAL_PAGE_SIZE,
                        Math.min(((pageIdx + 1) * VISUAL_PAGE_SIZE) - 1, mTheText.length() - 1),
                        pageIdx == (mNumPages - 1));
        }
    }

    private static class Page {
        AdapterChunk adaptChunk;
        int textStart;
        int textEnd;
        boolean isLast;

        Page(AdapterChunk _adaptChunk, int _textStart, int _textEnd, boolean _isLast) {
            adaptChunk = _adaptChunk;
            textStart = _textStart;
            textEnd = _textEnd;
            isLast = _isLast;
        }

        boolean isFirst() {
            return (textStart == 0);
        }

        String getText() {
            return adaptChunk.getText(textStart, textEnd);
        }
    }

    protected static class PayloadViewHolder extends RecyclerView.ViewHolder {
        View headerLine;
        View dumpBox;
        TextView header;
        TextView dump;
        MaterialButton expandButton;
        MaterialButton copybutton;
        MaterialButton exportbutton;

        public PayloadViewHolder(View view) {
            super(view);

            headerLine = view.findViewById(R.id.header_line);
            header = view.findViewById(R.id.header);
            dump = view.findViewById(R.id.dump);
            dumpBox = view.findViewById(R.id.dump_box);
            expandButton = view.findViewById(R.id.expand_button);
            copybutton = view.findViewById(R.id.copy_button);
            exportbutton = view.findViewById(R.id.export_button);
        }
    }

    @NonNull
    @Override
    public PayloadViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = mLayoutInflater.inflate(R.layout.payload_item, parent, false);
        PayloadViewHolder holder = new PayloadViewHolder(view);

        holder.expandButton.setOnClickListener(v -> {
            int pos = holder.getAbsoluteAdapterPosition();
            Page page = getItem(pos);

            if(page.adaptChunk.isExpanded()) {
                int numPages = page.adaptChunk.getNumPages();
                int firstPagePos = pos - (numPages - 1);
                page.adaptChunk.collapse();
                notifyItemChanged(firstPagePos);
                notifyItemRangeRemoved(firstPagePos + 1, numPages - 1);
            } else {
                page.adaptChunk.expand();
                notifyItemChanged(pos);
                notifyItemRangeInserted(pos + 1, page.adaptChunk.getNumPages() - 1);
            }
        });

        holder.copybutton.setOnClickListener(v -> handleCopyExportButtons(holder, false));
        holder.exportbutton.setOnClickListener(v -> handleCopyExportButtons(holder, true));
        holder.exportbutton.setVisibility(mSupportsFileDialog ? View.VISIBLE : View.GONE);

        return holder;
    }

    private void handleCopyExportButtons(PayloadViewHolder holder, boolean is_export) {
        if(is_export && (mExportHandler == null))
            return;

        int payload_pos = holder.getAbsoluteAdapterPosition();
        int title = is_export ? R.string.export_ellipsis : R.string.copy_action;
        int positive_action = is_export ? R.string.export_action : R.string.copy_to_clipboard;

        AdapterChunk chunk = getItem(payload_pos).adaptChunk;
        if (chunk == null)
            return;

        if(mMode == ChunkType.HTTP) {
            String payload = chunk.getExpandedText(true);
            int crlf_pos = payload.indexOf("\r\n\r\n");
            String content_type = ((chunk.mChunk.httpContentType != null) && (!chunk.mChunk.httpContentType.isEmpty())) ?
                    chunk.mChunk.httpContentType : "text/plain";

            Log.d(TAG, "Export body content type: " + content_type);

            String fname = "";
            if (chunk.mChunk.is_sent && (chunk.mChunk.httpPath != null))
                fname = chunk.mChunk.httpPath;
            else if (payload_pos > 0) {
                // Try to match the HTTP request, to determine the file name
                AdapterChunk req_chunk = getItem(payload_pos - 1).adaptChunk;
                if (req_chunk.mChunk.is_sent && (req_chunk.mChunk.httpPath != null))
                    fname = req_chunk.mChunk.httpPath;
            }

            if (!fname.isEmpty()) {
                int last_slash = fname.lastIndexOf('/');
                if (last_slash >= 0)
                    fname = fname.substring(last_slash + 1);
            }

            if (fname.contains("."))
                Log.d(TAG, "File name: " + fname);
            else
                fname = "";

            String filename = fname;

            boolean has_body = (crlf_pos > 0) && (crlf_pos < (payload.length() - 4));
            if (!has_body) {
                // only HTTP headers
                if (is_export) {
                    if (mExportHandler != null)
                        mExportHandler.exportPayload(payload);
                } else
                    Utils.copyToClipboard(mContext, payload);
                return;
            }

            String[] choices = {
                    mContext.getString(R.string.headers),
                    mContext.getString(R.string.body),
                    mContext.getString(R.string.both),
            };

            AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
            builder.setTitle(title);
            builder.setSingleChoiceItems(choices, 1, (dialogInterface, i) -> {});
            builder.setNeutralButton(R.string.cancel_action, (dialogInterface, i) -> {});
            builder.setPositiveButton(positive_action, (dialogInterface, i) -> {
                int choice = ((AlertDialog)dialogInterface).getListView().getCheckedItemPosition();
                String to_copy = payload;

                if (choice != 2) {
                    if (choice == 0 /* Headers */)
                        to_copy = to_copy.substring(0, crlf_pos);
                    else /* body */
                        to_copy = to_copy.substring(crlf_pos + 4);
                }

                if (is_export) {
                    if (mExportHandler != null) {
                        boolean only_body = (choice == 1);

                        if (only_body) {
                            // export the raw body bytes
                            byte[] payload_bytes = chunk.mChunk.payload;

                            if (crlf_pos < (payload_bytes.length - 4))
                                payload_bytes = Arrays.copyOfRange(payload_bytes, crlf_pos + 4, payload_bytes.length);

                            mExportHandler.exportPayload(payload_bytes, content_type, filename);
                        } else
                            mExportHandler.exportPayload(to_copy);
                    }
                } else
                    Utils.copyToClipboard(mContext, to_copy);
            });
            builder.create().show();
        } else {
            List<String> choices = new ArrayList<>(Arrays.asList(
                    mContext.getString(R.string.text),
                    mContext.getString(R.string.hexdump)
            ));
            if (is_export)
                choices.add(mContext.getString(R.string.raw_bytes));

            AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
            builder.setTitle(title);
            builder.setSingleChoiceItems(choices.toArray(new String[]{}), mShowAsPrintable ? 0 : 1, (dialogInterface, i) -> {});

            builder.setNeutralButton(R.string.cancel_action, (dialogInterface, i) -> {});
            builder.setPositiveButton(positive_action, (dialogInterface, i) -> {
                int choice = ((AlertDialog)dialogInterface).getListView().getCheckedItemPosition();

                if (choice == 2 /* raw bytes */) {
                    assert (is_export);

                    if (mExportHandler != null)
                        mExportHandler.exportPayload(chunk.mChunk.payload, "application/octet-stream", "");
                } else {
                    String payload = getItem(payload_pos).adaptChunk.getExpandedText(choice == 0);

                    if (is_export) {
                        if (mExportHandler != null)
                            mExportHandler.exportPayload(payload);
                    } else
                        Utils.copyToClipboard(mContext, payload);
                }
            });
            builder.create().show();
        }
    }

    private String getHeaderTag(PayloadChunk chunk) {
        if(mMode == ChunkType.HTTP)
            return (chunk.is_sent) ? mContext.getString(R.string.request) : mContext.getString(R.string.response);
        else
            return chunk.is_sent ? mContext.getString(R.string.tx_direction) : mContext.getString(R.string.rx_direction);
    }

    @Override
    public void onBindViewHolder(@NonNull PayloadViewHolder holder, int position) {
        Page page = getItem(position);
        PayloadChunk chunk = page.adaptChunk.getPayloadChunk();

        if(page.isFirst()) {
            holder.headerLine.setVisibility(View.VISIBLE);

            Locale locale = Utils.getPrimaryLocale(mContext);
            String formattedTstamp = (new SimpleDateFormat("HH:mm:ss.SSS", locale)).format(new Date(chunk.timestamp));

            String formattedBytes;
            if (mMode == ChunkType.HTTP)
                formattedBytes = Utils.formatBytes(chunk.httpBodyLength);
            else
                formattedBytes = Utils.formatBytes(chunk.payload.length);

            if (mSingleChunk == null)
                holder.header.setText(String.format(locale,
                        "#%d [%s] %s — %s", page.adaptChunk.incrId + 1,
                        getHeaderTag(chunk),
                        formattedTstamp, formattedBytes));
            else
                holder.header.setText(String.format(locale,
                        "%s — %s",
                        formattedTstamp, formattedBytes));
        } else
            holder.headerLine.setVisibility(View.GONE);

        if(page.isLast && page.adaptChunk.canBeExpanded()) {
            holder.expandButton.setVisibility(View.VISIBLE);
            holder.expandButton.setRotation(page.adaptChunk.isExpanded() ? 180 : 0);
        } else
            holder.expandButton.setVisibility(View.GONE);

        holder.dump.setText(page.getText());

        if(chunk.is_sent) {
            holder.dumpBox.setBackgroundResource(R.color.sentPayloadBg);
            holder.dump.setTextColor(ContextCompat.getColor(mContext, R.color.sentPayloadFg));
        } else {
            holder.dumpBox.setBackgroundResource(R.color.rcvdPayloadBg);
            holder.dump.setTextColor(ContextCompat.getColor(mContext, R.color.rcvdPayloadFg));
        }
    }

    @Override
    public int getItemCount() {
        // TODO remove loop, as it can generate ANRs on high number of elements
        int count = 0;

        for(AdapterChunk aChunk: mChunks)
            count += aChunk.getNumPages();

        return count;
    }

    public Page getItem(int pos) {
        if(pos < 0)
            return null;

        int count = 0;
        int i;

        // Find the AdapterChunk for the given page pos
        for(i=0; i < mChunks.size(); i++) {
            AdapterChunk aChunk = mChunks.get(i);
            int new_count = count + aChunk.getNumPages();

            if((pos >= count) && (pos < new_count))
                break;

            count = new_count;
        }

        if(i >= mChunks.size())
            return null;

        int pageIdx = pos - count;
        return mChunks.get(i).getPage(pageIdx);
    }

    @SuppressLint("NotifyDataSetChanged")
    public void setDisplayAsPrintableText(boolean asText) {
        if(mShowAsPrintable != asText) {
            mShowAsPrintable = asText;

            // Chunk pagination depends on the displayed data length, collapsing everything is simpler
            // than handling individual changes
            for(AdapterChunk chunk: mChunks)
                chunk.collapse(); // resets the chunk text
            notifyDataSetChanged();
        }
    }

    private int getAdapterPosition(AdapterChunk chunk) {
        int i;
        int count = 0;

        for(i=0; i < mChunks.size(); i++) {
            AdapterChunk aChunk = mChunks.get(i);
            if(aChunk == chunk)
                break;

            count += aChunk.getNumPages();
        }

        return count;
    }

    public void handleChunksAdded(int tot_chunks) {
        int items_count = -1;
        boolean readingFromPcap = CaptureService.isReadingFromPcapFile();

        for(int i = mHandledChunks; i < tot_chunks; i++) {
            PayloadChunk chunk = mConn.getPayloadChunk(i);
            if(chunk == null)
                continue;

            // when reading from pcap, websocket data must be extracted from HTTP chunks
            boolean websocketFromHttp = readingFromPcap &&
                    (mMode == ChunkType.WEBSOCKET) &&
                    (chunk.type != ChunkType.RAW);

            // Exclude unrelated chunks
            if((mMode != ChunkType.RAW) && (mMode != chunk.type) && !websocketFromHttp)
                continue;

            if((mMode == ChunkType.HTTP) || websocketFromHttp) {
                // will call onChunkReassembled
                if(chunk.is_sent)
                    mHttpReq.handleChunk(chunk);
                else
                    mHttpRes.handleChunk(chunk);
            } else {
                // TODO remove temporary caching due to slow getItemCount
                if(items_count == -1)
                    items_count = getItemCount();
                mChunks.add(new AdapterChunk(chunk, mChunks.size()));
                notifyItemInserted(items_count);
                items_count += 1;
            }
        }

        mHandledChunks = tot_chunks;
    }

    private AdapterChunk findMatchingRequest(PayloadChunk chunk) {
        if (mUnrepliedHttpReqs.isEmpty())
            return null;

        if (chunk.stream_id == 0) {
            // HTTP/1: FIFO matching
            return mUnrepliedHttpReqs.get(0);
        } else {
            // HTTP/2: match by stream ID
            for (AdapterChunk req : mUnrepliedHttpReqs) {
                if (req.mChunk.stream_id == chunk.stream_id)
                    return req;
            }
        }

        return null;
    }

    @SuppressLint("DefaultLocale")
    @Override
    public void onChunkReassembled(PayloadChunk chunk) {
        if((mMode != ChunkType.RAW) && (mMode != chunk.type))
            // unrelated chunk (mainly for HTTP data before Websocket)
            return;

        AdapterChunk adapterChunk = new AdapterChunk(chunk, mChunks.size());
        int adapterPos = getItemCount();
        int insertPos = mChunks.size();
        boolean is_http2_rst = chunk.isHttp2Rst();

        // Need to determine where to add the chunk. If HTTP request, always add it to the bottom.
        // If HTTP reply/reset, it should be added right after the matching un-replied HTTP request
        if(!chunk.is_sent || is_http2_rst) {
            AdapterChunk matchedReq = findMatchingRequest(chunk);

            if (matchedReq != null) {
                int reqPos = mChunks.indexOf(matchedReq);
                assert(reqPos >= 0);

                if (!is_http2_rst) {
                    insertPos = reqPos + 1;
                    adapterPos = getAdapterPosition(matchedReq) + matchedReq.getNumPages();
                    Log.d(TAG, String.format("chunk #%d reply of #%d at %d", adapterChunk.incrId, matchedReq.incrId, insertPos));
                } else
                    Log.d(TAG, String.format("chunk #%d reset of #%d", adapterChunk.incrId, matchedReq.incrId));

                mUnrepliedHttpReqs.remove(matchedReq);
            }
        } else if(!is_http2_rst)
            mUnrepliedHttpReqs.add(adapterChunk);

        if (!is_http2_rst) {
            mChunks.add(insertPos, adapterChunk);
            notifyItemInserted(adapterPos);
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/PortMappingAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.annotation.SuppressLint;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.PortMapping;
import com.emanuelef.remote_capture.model.PortMapping.PortMap;

import java.util.Iterator;

public class PortMappingAdapter extends ArrayAdapter<PortMap> {
    private final LayoutInflater mLayoutInflater;
    private final PortMapping mMappings;

    public PortMappingAdapter(Context context, PortMapping mappings) {
        super(context, R.layout.port_mapping_item);
        mLayoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mMappings = mappings;
        reload();
    }

    @SuppressLint("SetTextI18n")
    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        if(convertView == null)
            convertView = mLayoutInflater.inflate(R.layout.port_mapping_item, parent, false);

        PortMap mapping = getItem(position);
        String redirect_to = getContext().getString(R.string.ip_and_port, mapping.redirect_host, mapping.redirect_port);

        ((TextView)convertView.findViewById(R.id.orig_port)).setText(Integer.toString(mapping.orig_port));
        ((TextView)convertView.findViewById(R.id.proto)).setText(Utils.proto2str(mapping.ipproto));
        ((TextView)convertView.findViewById(R.id.redirect_to)).setText(redirect_to);

        return convertView;
    }

    public void reload() {
        clear();

        Iterator<PortMap> iterator = mMappings.iter();

        while(iterator.hasNext()) {
            PortMap item = iterator.next();
            add(item);
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/adapters/PrefSpinnerAdapter.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.TextView;

import com.emanuelef.remote_capture.R;

public class PrefSpinnerAdapter extends BaseAdapter {
    private final LayoutInflater mInflater;
    private final ModeInfo[] mModes;

    public static class ModeInfo {
        public final String key;
        public final String label;
        public final String description;

        public ModeInfo(String _key, String _label, String _descr) {
            key = _key;
            label = _label;
            description = _descr;
        }
    }

    public PrefSpinnerAdapter(Context context, int keysRes, int labelsRes, int descrRes) {
        mInflater = LayoutInflater.from(context);

        String[] keys = context.getResources().getStringArray(keysRes);
        String[] labels = context.getResources().getStringArray(labelsRes);
        String[] descriptions = context.getResources().getStringArray(descrRes);

        assert ((keys.length == labels.length) && (keys.length == descriptions.length));
        mModes = new ModeInfo[keys.length];

        for(int i=0; i<keys.length; i++)
            mModes[i] = new ModeInfo(keys[i], labels[i], descriptions[i]);
    }

    public int getModePos(String key) {
        for(int i=0; i<mModes.length; i++) {
            if(key.equals(mModes[i].key))
                return i;
        }

        return 0;
    }

    @Override
    public int getCount() {
        return mModes.length;
    }

    @Override
    public Object getItem(int position) {
        return mModes[position];
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        if(convertView == null)
            convertView = mInflater.inflate(R.layout.quick_settings_item, parent, false);

        ModeInfo mode = (ModeInfo) getItem(position);

        TextView title = convertView.findViewById(R.id.title);
        title.setText(mode.label);

        TextView description = convertView.findViewById(R.id.description);
        description.setText(mode.description);

        return convertView;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/AppOverview.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.Settings;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.ScrollView;
import android.widget.TableLayout;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;
import androidx.core.graphics.Insets;
import androidx.core.view.MenuProvider;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.AppStats;

public class AppOverview extends Fragment implements MenuProvider {
    private static final String UID_ARG = "UID";
    private int mUid;
    private Handler mHandler;
    private View mBlockedConnsRow;
    private TextView mBytes;
    private TextView mConnections;
    private TextView mBlockedConnections;
    private TableLayout mTable;
    private TextView mPermissions;
    private PackageInfo mPinfo;
    private boolean mCreateError;

    public static AppOverview newInstance(int uid) {
        AppOverview fragment = new AppOverview();
        Bundle args = new Bundle();
        args.putInt(UID_ARG, uid);

        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.app_overview, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        assert getArguments() != null;
        mUid = getArguments().getInt(UID_ARG);
        Context ctx = requireContext();

        AppsResolver res = new AppsResolver(ctx);
        AppDescriptor dsc = res.getAppByUid(mUid, PackageManager.GET_PERMISSIONS);
        if(dsc == null) {
            mCreateError = true;
            Utils.showToast(ctx, R.string.app_not_found, mUid);
            requireActivity().finish();
            return;
        }

        mHandler = new Handler(Looper.getMainLooper());
        mBytes = view.findViewById(R.id.detail_bytes);
        mConnections = view.findViewById(R.id.connections);
        mBlockedConnections = view.findViewById(R.id.conns_blocked);
        mBlockedConnsRow = view.findViewById(R.id.conns_blocked_row);
        mPermissions = view.findViewById(R.id.permissions);

        if(Utils.isTv(ctx)) {
            // necessary to make scroll work on TV
            // but disables ability to select and copy permissions textview
            ViewGroup layout = view.findViewById(R.id.layout);
            layout.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
        }

        ((TextView)view.findViewById(R.id.uid)).setText(Utils.formatInteger(ctx, dsc.getUid()));
        ((TextView)view.findViewById(R.id.name)).setText(dsc.getName());
        Drawable icon = dsc.getIcon();
        if (icon == null)
            icon = ContextCompat.getDrawable(ctx, R.drawable.ic_image);
        ((ImageView)view.findViewById(R.id.app_icon)).setImageDrawable(icon);

        mPinfo = dsc.getPackageInfo();

        if(mPinfo != null) {
            ((TextView)view.findViewById(R.id.package_name)).setText(dsc.getPackageName());
            ((TextView)view.findViewById(R.id.version)).setText(mPinfo.versionName);
            ((TextView)view.findViewById(R.id.target_sdk)).setText(Utils.formatInteger(ctx, mPinfo.applicationInfo.targetSdkVersion));
            ((TextView)view.findViewById(R.id.install_date)).setText(Utils.formatEpochFull(ctx, mPinfo.firstInstallTime / 1000));
            ((TextView)view.findViewById(R.id.last_update)).setText(Utils.formatEpochFull(ctx, mPinfo.lastUpdateTime / 1000));

            if((mPinfo.requestedPermissions != null) && (mPinfo.requestedPermissions.length != 0)) {
                StringBuilder builder = new StringBuilder();
                boolean first = true;

                for(String perm: mPinfo.requestedPermissions) {
                    if(first)
                        first = false;
                    else
                        builder.append("\n");

                    builder.append(perm);
                }

                mPermissions.setText(builder.toString());

                if(Utils.isTv(ctx)) {
                    mPermissions.setOnClickListener(v -> Utils.shareText(ctx, getString(R.string.permissions), mPermissions.getText().toString()));
                }
            } else {
                view.findViewById(R.id.permissions_label).setVisibility(View.GONE);
                view.findViewById(R.id.permissions).setVisibility(View.GONE);
            }
        } else {
            // This is a virtual App
            if(!dsc.getDescription().isEmpty()) {
                ((TextView) view.findViewById(R.id.vapp_info)).setText(dsc.getDescription());
                view.findViewById(R.id.vapp_info).setVisibility(View.VISIBLE);
            }

            view.findViewById(R.id.package_name_row).setVisibility(View.GONE);
            view.findViewById(R.id.version_row).setVisibility(View.GONE);
            view.findViewById(R.id.target_sdk_row).setVisibility(View.GONE);
            view.findViewById(R.id.install_date_row).setVisibility(View.GONE);
            view.findViewById(R.id.last_update_row).setVisibility(View.GONE);
            view.findViewById(R.id.permissions_label).setVisibility(View.GONE);
            view.findViewById(R.id.permissions).setVisibility(View.GONE);
        }

        mTable = view.findViewById(R.id.table);

        ScrollView sv = view.findViewById(R.id.app_overview);
        ViewCompat.setOnApplyWindowInsetsListener(sv, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());
            v.setPadding(insets.left, 0, insets.right, insets.bottom);

            return windowInsets;
        });
        sv.setClipToPadding(false);
    }

    @Override
    public void onResume() {
        super.onResume();
        if(mCreateError)
            return;

        updateStatus();
    }

    @Override
    public void onPause() {
        super.onPause();
        if(mCreateError)
            return;

        mHandler.removeCallbacksAndMessages(null);
    }

    private String asString() {
        if(mPermissions.getVisibility() == View.GONE)
            return Utils.table2Text(mTable);

        return Utils.table2Text(mTable) +
                "\n" +
                getString(R.string.permissions) +
                ":\n" +
                mPermissions.getText();
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater menuInflater) {
        menuInflater.inflate(R.menu.app_overview_menu, menu);

        if(mPinfo == null)
            menu.findItem(R.id.app_info).setVisible(false);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.app_info) {
            Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
            intent.setData(Uri.fromParts("package", mPinfo.packageName, null));
            Utils.startActivity(requireContext(), intent);
            return true;
        } else if(id == R.id.copy_to_clipboard) {
            Utils.copyToClipboard(requireContext(), asString());
            return true;
        } else if(id == R.id.share) {
            Utils.shareText(requireContext(), getString(R.string.app_details), asString());
            return true;
        }

        return false;
    }

    private void updateStatus() {
        Context ctx = requireContext();
        ConnectionsRegister reg = CaptureService.getConnsRegister();
        if(reg == null)
            return;

        AppStats stats = reg.getAppStats(mUid);
        if(stats == null)
            stats = new AppStats(mUid);

        mBytes.setText(getString(R.string.rcvd_and_sent, Utils.formatBytes(stats.rcvdBytes), Utils.formatBytes(stats.sentBytes)));
        mConnections.setText(Utils.formatInteger(ctx, stats.numConnections));

        mBlockedConnsRow.setVisibility(stats.numBlockedConnections > 0 ? View.VISIBLE : View.GONE);
        mBlockedConnections.setText(Utils.formatInteger(ctx, stats.numBlockedConnections));
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/AppsFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.ContextMenu;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.activities.AppDetailsActivity;
import com.emanuelef.remote_capture.adapters.AppsStatsAdapter;
import com.emanuelef.remote_capture.adapters.AppsStatsAdapter.SortField;
import com.emanuelef.remote_capture.interfaces.ConnectionsListener;
import com.emanuelef.remote_capture.model.AppStats;
import com.emanuelef.remote_capture.model.Blocklist;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.MatchList;
import com.emanuelef.remote_capture.model.Prefs;
import com.emanuelef.remote_capture.views.EmptyRecyclerView;

public class AppsFragment extends Fragment implements ConnectionsListener, MenuProvider {
    private EmptyRecyclerView mRecyclerView;
    private AppsStatsAdapter mAdapter;
    private static final String TAG = "AppsFragment";
    private Handler mHandler;
    private boolean mRefreshApps;
    private boolean listenerSet;
    private Menu mMenu;

    @Override
    public void onPause() {
        super.onPause();

        unregisterConnsListener();
    }

    @Override
    public void onResume() {
        super.onResume();

        registerConnsListener();
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.apps_stats, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        mRecyclerView = view.findViewById(R.id.recycler_view);
        mRecyclerView.setLayoutManager(new EmptyRecyclerView.MyLinearLayoutManager(getContext()));
        registerForContextMenu(mRecyclerView);

        mAdapter = new AppsStatsAdapter(getContext());
        doRefreshApps();
        mRecyclerView.setAdapter(mAdapter);

        TextView emptyText = view.findViewById(R.id.no_apps);
        mRecyclerView.setEmptyView(emptyText);

        mHandler = new Handler(Looper.getMainLooper());
        mRefreshApps = false;

        mAdapter.setClickListener(v -> {
            int pos = mRecyclerView.getChildLayoutPosition(v);
            int uid = (int) mAdapter.getItemId(pos);

            Intent intent = new Intent(getActivity(), AppDetailsActivity.class);
            intent.putExtra(AppDetailsActivity.APP_UID_EXTRA, uid);
            startActivity(intent);
        });

        /* Register for service status */
        CaptureService.observeStatus(this, serviceStatus -> {
            if(serviceStatus == CaptureService.ServiceStatus.STARTED) {
                if(listenerSet) {
                    // register the new connection register
                    unregisterConnsListener();
                    registerConnsListener();
                }
            }
        });
    }

    private void refreshSortField() {
        if((mMenu == null) || (mAdapter == null))
            return;

        SortField sortField = mAdapter.getSortField();
        Log.d(TAG, "Sort field:" + sortField);

        MenuItem byName = mMenu.findItem(R.id.sort_by_name);
        MenuItem byTotalBytes = mMenu.findItem(R.id.sort_by_total_bytes);
        MenuItem byBytesSent = mMenu.findItem(R.id.sort_by_bytes_sent);
        MenuItem byBytesRcvd = mMenu.findItem(R.id.sort_by_bytes_rcvd);

        // important: the checked item must first be unchecked
        byName.setChecked(false);
        byTotalBytes.setChecked(false);
        byBytesSent.setChecked(false);
        byBytesRcvd.setChecked(false);

        if(sortField.equals(SortField.NAME))
            byName.setChecked(true);
        else if(sortField.equals(SortField.TOTAL_BYTES))
            byTotalBytes.setChecked(true);
        else if(sortField.equals(SortField.BYTES_SENT))
            byBytesSent.setChecked(true);
        else if(sortField.equals(SortField.BYTES_RCVD))
            byBytesRcvd.setChecked(true);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater menuInflater) {
        menuInflater.inflate(R.menu.apps_menu, menu);
        mMenu = menu;
        refreshSortField();
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem menuItem) {
        int id = menuItem.getItemId();

        if(id == R.id.reset) {
            new AlertDialog.Builder(requireContext())
                .setMessage(R.string.reset_stats_confirm)
                .setPositiveButton(R.string.yes, (dialog, whichButton) -> {
                    ConnectionsRegister reg = CaptureService.getConnsRegister();
                    if(reg != null) {
                        reg.resetAppsStats();
                        doRefreshApps();
                    }
                })
                .setNegativeButton(R.string.no, (dialog, whichButton) -> {})
                .show();

            return true;
        } else if(id == R.id.sort_by_name) {
            mAdapter.setSortField(SortField.NAME);
            refreshSortField();
            return true;
        } else if(id == R.id.sort_by_total_bytes) {
            mAdapter.setSortField(SortField.TOTAL_BYTES);
            refreshSortField();
            return true;
        } else if(id == R.id.sort_by_bytes_sent) {
            mAdapter.setSortField(SortField.BYTES_SENT);
            refreshSortField();
            return true;
        } else if(id == R.id.sort_by_bytes_rcvd) {
            mAdapter.setSortField(SortField.BYTES_RCVD);
            refreshSortField();
            return true;
        }

        return false;
    }

    @Override
    public void onCreateContextMenu(@NonNull ContextMenu menu, @NonNull View v,
                                    @Nullable ContextMenu.ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        Log.d(TAG, "onCreateContextMenu");

        MenuInflater inflater = requireActivity().getMenuInflater();
        inflater.inflate(R.menu.app_context_menu, menu);

        AppStats stats = mAdapter.getSelectedItem();
        if(stats == null)
            return;

        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
        boolean isBlocked = PCAPdroid.getInstance().getBlocklist().matchesApp(stats.getUid());
        menu.findItem(R.id.block_app).setVisible(!isBlocked);

        if(Prefs.isFirewallWhitelistMode(prefs)) {
            boolean isWhitelisted = PCAPdroid.getInstance().getFirewallWhitelist().matchesApp(stats.getUid());
            menu.findItem(R.id.add_to_fw_whitelist).setVisible(!isWhitelisted);
            menu.findItem(R.id.remove_from_fw_whitelist).setVisible(isWhitelisted);
        }

        menu.findItem(R.id.unblock_app_permanently).setVisible(isBlocked);
        menu.findItem(R.id.unblock_app_10m).setVisible(isBlocked)
                .setTitle(getString(R.string.unblock_for_n_minutes, 10));
        menu.findItem(R.id.unblock_app_1h).setVisible(isBlocked)
                .setTitle(getString(R.string.unblock_for_n_hours, 1));
        menu.findItem(R.id.unblock_app_8h).setVisible(isBlocked)
                .setTitle(getString(R.string.unblock_for_n_hours, 8));
    }

    @Override
    public boolean onContextItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();
        Blocklist blocklist = PCAPdroid.getInstance().getBlocklist();
        MatchList whitelist = PCAPdroid.getInstance().getFirewallWhitelist();
        boolean whitelistChanged = false;
        AppStats app = mAdapter.getSelectedItem();

        if(app == null)
            return super.onContextItemSelected(item);

        if(id == R.id.block_app)
            blocklist.addApp(app.getUid());
        else if(id == R.id.unblock_app_permanently)
            blocklist.removeApp(app.getUid());
        else if(id == R.id.unblock_app_10m)
            blocklist.unblockAppForMinutes(app.getUid(), 10);
        else if(id == R.id.unblock_app_1h)
            blocklist.unblockAppForMinutes(app.getUid(), 60);
        else if(id == R.id.unblock_app_8h)
            blocklist.unblockAppForMinutes(app.getUid(), 480);
        else if(id == R.id.add_to_fw_whitelist) {
            whitelist.addApp(app.getUid());
            whitelistChanged = true;
        } else if(id == R.id.remove_from_fw_whitelist) {
            whitelist.removeApp(app.getUid());
            whitelistChanged = true;
        } else
            return super.onContextItemSelected(item);

        if(whitelistChanged) {
            whitelist.save();
            if (CaptureService.isServiceActive())
                CaptureService.requireInstance().reloadFirewallWhitelist();
        } else
            blocklist.saveAndReload();

        // refresh the item
        mAdapter.notifyItemChanged(app);

        return true;
    }

    private void registerConnsListener() {
        if (!listenerSet) {
            ConnectionsRegister reg = CaptureService.getConnsRegister();

            if (reg != null) {
                reg.addListener(this);
                listenerSet = true;
            }
        }
    }

    private void unregisterConnsListener() {
        if(listenerSet) {
            ConnectionsRegister reg = CaptureService.getConnsRegister();
            if (reg != null)
                reg.removeListener(this);

            listenerSet = false;
        }
    }

    // NOTE: do not use synchronized as it could cause a deadlock with the ConnectionsRegister lock
    private void doRefreshApps() {
        mRefreshApps = false;

        ConnectionsRegister reg = CaptureService.getConnsRegister();
        if (reg == null)
            return;

        mAdapter.setStats(reg.getAppsStats());
    }

    private void refreshAppsAsync() {
        if(!mRefreshApps) {
            mRefreshApps = true;

            // schedule a delayed refresh to possibly catch multiple refreshes
            mHandler.postDelayed(this::doRefreshApps, 100);
        }
    }

    @Override
    public void connectionsChanges(int num_connections) {
        refreshAppsAsync();
    }

    @Override
    public void connectionsAdded(int start, ConnectionDescriptor []conns) {
        refreshAppsAsync();
    }

    @Override
    public void connectionsRemoved(int start, ConnectionDescriptor []conns) {
        refreshAppsAsync();
    }

    @Override
    public void connectionsUpdated(int[] positions) {
        refreshAppsAsync();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/AppsToggles.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.SearchView;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;

import com.emanuelef.remote_capture.AppsLoader;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.adapters.AppsTogglesAdapter;
import com.emanuelef.remote_capture.interfaces.AppsLoadListener;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.views.EmptyRecyclerView;

import java.util.List;
import java.util.Set;

import kotlin.NotImplementedError;

public abstract class AppsToggles extends Fragment implements AppsLoadListener,
        AppsTogglesAdapter.AppToggleListener, MenuProvider, SearchView.OnQueryTextListener {
    private static final String TAG = "AppsToggles";
    private static boolean sShowSystemApps;
    private AppsTogglesAdapter mAdapter;
    private SearchView mSearchView;
    private TextView mEmptyText;
    private String mQueryToApply;

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.apps_stats, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        EmptyRecyclerView recyclerView = view.findViewById(R.id.recycler_view);
        recyclerView.setLayoutManager(new EmptyRecyclerView.MyLinearLayoutManager(getContext()));

        mAdapter = new AppsTogglesAdapter(requireContext(), getCheckedApps());
        recyclerView.setAdapter(mAdapter);
        mAdapter.setAppToggleListener(this);

        mEmptyText = view.findViewById(R.id.no_apps);
        mEmptyText.setText(R.string.loading_apps);
        recyclerView.setEmptyView(mEmptyText);

        if(savedInstanceState != null) {
            String filter = savedInstanceState.getString("filter");
            if((filter != null) && !filter.isEmpty())
                mQueryToApply = filter;
        }

        mAdapter.setShowSystemApps(sShowSystemApps);

        Log.d(TAG, "mQueryToApply: " + mQueryToApply);

        (new AppsLoader((AppCompatActivity) requireActivity()))
                .setAppsLoadListener(this)
                .loadAllApps();
    }

    @Override
    public void onPause() {
        super.onPause();

        if(mSearchView != null)
            mQueryToApply = mSearchView.getQuery().toString();
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater menuInflater) {
        menuInflater.inflate(R.menu.search_menu, menu);
        MenuItem searchItem = menu.findItem(R.id.search);
        mSearchView = (SearchView) searchItem.getActionView();
        mSearchView.setOnQueryTextListener(this);

        if((mQueryToApply != null) && (!mQueryToApply.isEmpty())) {
            Log.d(TAG, "Initial filter: " + mQueryToApply);
            Utils.setSearchQuery(mSearchView, searchItem, mQueryToApply);
        }

        MenuItem systemAppsItem = menu.findItem(R.id.show_system_apps);
        if(systemAppsItem != null)
            systemAppsItem.setChecked(sShowSystemApps);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem menuItem) {
        if(menuItem.getItemId() == R.id.show_system_apps) {
            sShowSystemApps = !sShowSystemApps;
            menuItem.setChecked(sShowSystemApps);
            mAdapter.setShowSystemApps(sShowSystemApps);
            return true;
        }
        return false;
    }

    @Override
    public void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);

        // this is complemented by the activity onSaveInstanceState
        if(mSearchView != null) {
            String query = mSearchView.getQuery().toString();
            Log.d(TAG, "Saving filter: " + query);
            outState.putString("filter", query);
        }
    }

    // NOTE: must be called from the activity
    public boolean onBackPressed() {
        Log.d(TAG, "onBackPressed");
        return Utils.backHandleSearchview(mSearchView);
    }

    @Override
    public boolean onQueryTextSubmit(String query) { return true; }

    @Override
    public boolean onQueryTextChange(String newText) {
        mAdapter.setFilter(newText);
        return true;
    }

    @Override
    public void onAppsInfoLoaded(List<AppDescriptor> apps) {
        mAdapter.setApps(apps);
        mEmptyText.setText(R.string.no_matches_found);
    }

    // Must be implemented in sub-classes
    protected Set<String> getCheckedApps() {
        throw new NotImplementedError();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/BlacklistsFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ListView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.adapters.BlacklistsAdapter;
import com.emanuelef.remote_capture.interfaces.BlacklistsStateListener;
import com.emanuelef.remote_capture.Blacklists;
import com.emanuelef.remote_capture.model.BlacklistDescriptor;

public class BlacklistsFragment extends Fragment implements BlacklistsStateListener, MenuProvider {
    private static final String TAG = "BlacklistsFragment";
    private BlacklistsAdapter mAdapter;
    private Blacklists mBlacklists;
    private MenuItem mUpdateItem;
    private Handler mHandler;

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.malware_detection_blacklists, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        mBlacklists = PCAPdroid.getInstance().getBlacklists();
        mAdapter = new BlacklistsAdapter(view.getContext(), PCAPdroid.getInstance().getBlacklists().iter());
        ListView listView = view.findViewById(R.id.listview);
        listView.setAdapter(mAdapter);

        listView.setOnItemClickListener((parent, view1, position, id) -> {
            BlacklistDescriptor bl = mAdapter.getItem(position);
            if (bl != null)
                openUrl(view1.getContext(), bl.url);
        });

        mHandler = new Handler(Looper.getMainLooper());

        CaptureService.observeStatus(this, serviceStatus -> refreshStatus());
    }

    private void openUrl(Context ctx, String url) {
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
        Utils.startActivity(ctx, intent);
    }

    @Override
    public void onResume() {
        super.onResume();
        mBlacklists.addOnChangeListener(this);
    }

    @Override
    public void onPause() {
        super.onPause();
        mBlacklists.removeOnChangeListener(this);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.blacklists_menu, menu);
        mUpdateItem = menu.findItem(R.id.update);
        refreshStatus();
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.update) {
            CaptureService.requestBlacklistsUpdate();
            return true;
        }

        return false;
    }

    private void refreshStatus() {
        if(mAdapter != null)
            mAdapter.notifyDataSetChanged();

        if(mUpdateItem != null) {
            mUpdateItem.setVisible(CaptureService.isServiceActive());
            mUpdateItem.setEnabled(!mBlacklists.isUpdateInProgress());
        }
    }

    @Override
    public void onBlacklistsStateChanged() {
        Log.d(TAG, "onBlacklistsStateChanged");
        mHandler.post(this::refreshStatus);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/ConnectionOverview.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.util.Pair;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TableLayout;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;
import androidx.fragment.app.Fragment;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.ConnectionDetailsActivity;
import com.emanuelef.remote_capture.activities.MainActivity;
import com.emanuelef.remote_capture.activities.MenuActionHandler;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.haipq.android.flagkit.FlagImageView;

public class ConnectionOverview extends Fragment implements ConnectionDetailsActivity.ConnUpdateListener, MenuActionHandler {
    private static final String TAG = "ConnectionOverview";
    private ConnectionDetailsActivity mActivity;
    private ConnectionDescriptor mConn;
    private TableLayout mTable;
    private TextView mBytesView;
    private TextView mPayloadLen;
    private TextView mPacketsView;
    private TextView mDurationView;
    private TextView mBlockedPkts;
    private View mBlockedPktsRow;
    private TextView mStatus;
    private TextView mDecStatus;
    private ImageView mDecIcon;
    private TextView mFirstSeen;
    private TextView mLastSeen;
    //private TextView mTcpFlags;
    private TextView mError;
    private TextView mSocketErrno;
    private View mSocketErrnoRow;
    private View mSocketErrnoInfo;
    private ImageView mBlacklistedIp;
    private ImageView mBlacklistedHost;

    public static ConnectionOverview newInstance(int conn_id) {
        ConnectionOverview fragment = new ConnectionOverview();
        Bundle args = new Bundle();
        args.putInt("conn_id", conn_id);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);
        mActivity = (ConnectionDetailsActivity) context;
        mActivity.addConnUpdateListener(this);
    }

    @Override
    public void onDetach() {
        super.onDetach();
        mActivity.removeConnUpdateListener(this);
        mActivity = null;
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.connection_overview, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        TextView appLabel = view.findViewById(R.id.detail_app);
        TextView proto = view.findViewById(R.id.detail_protocol);
        TextView info_label = view.findViewById(R.id.detail_info_label);
        TextView info = view.findViewById(R.id.detail_info);
        TextView url = view.findViewById(R.id.detail_url);
        View url_row = view.findViewById(R.id.detail_url_row);
        View info_row = view.findViewById(R.id.detail_info_row);
        TextView source = view.findViewById(R.id.detail_source);
        TextView destination = view.findViewById(R.id.detail_destination);
        TextView country = view.findViewById(R.id.country_name);
        FlagImageView country_flag = view.findViewById(R.id.country_flag);
        TextView asn = view.findViewById(R.id.asn);
        mTable = view.findViewById(R.id.table);
        mPayloadLen = view.findViewById(R.id.detail_payload);
        mBytesView = view.findViewById(R.id.detail_bytes);
        mPacketsView = view.findViewById(R.id.detail_packets);
        mBlockedPkts = view.findViewById(R.id.blocked_pkts);
        mBlockedPktsRow = view.findViewById(R.id.blocked_row);
        mDurationView = view.findViewById(R.id.detail_duration);
        mStatus = view.findViewById(R.id.detail_status);
        mDecStatus = view.findViewById(R.id.detail_decryption_status);
        mDecIcon = view.findViewById(R.id.decryption_icon);
        mFirstSeen = view.findViewById(R.id.first_seen);
        mLastSeen = view.findViewById(R.id.last_seen);
        //mTcpFlags = view.findViewById(R.id.tcp_flags);
        mError = view.findViewById(R.id.error_msg);
        mSocketErrno = view.findViewById(R.id.detail_errno);
        mSocketErrnoRow = view.findViewById(R.id.error_row);
        mSocketErrnoInfo = view.findViewById(R.id.error_info);
        mBlacklistedIp = view.findViewById(R.id.blacklisted_ip);
        mBlacklistedHost = view.findViewById(R.id.blacklisted_host);

        Bundle args = getArguments();
        assert args != null;
        ConnectionsRegister reg = CaptureService.requireConnsRegister();

        mConn = reg.getConnById(args.getInt("conn_id"));
        if(mConn == null) {
            Utils.showToast(requireContext(), R.string.connection_not_found);
            mActivity.finish();
            return;
        }

        view.findViewById(R.id.whois_ip).setOnClickListener(v -> {
            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://search.arin.net/rdap/?query=" + mConn.dst_ip));
            Utils.startActivity(mActivity, intent);
        });

        if(mConn != null) {
            String l4proto = Utils.proto2str(mConn.ipproto);
            //if(l4proto.equals("TCP"))
            //    view.findViewById(R.id.tcp_flags_row).setVisibility(View.VISIBLE);

            if(!mConn.l7proto.equals(l4proto))
                proto.setText(String.format(getResources().getString(R.string.app_and_proto), mConn.l7proto, l4proto));
            else
                proto.setText(mConn.l7proto);

            CharSequence protoMsg = null;
            if (mConn.l7proto.equals("DNS"))
                protoMsg = getString(R.string.dns_conn_info);
            else if ((mConn.l7proto.equals("TLS")) || (mConn.l7proto.equals("HTTPS")))
                protoMsg = Utils.getText(view.getContext(), R.string.tls_conn_info, MainActivity.TLS_DECRYPTION_DOCS_URL);

            if (protoMsg != null) {
                final CharSequence msg = protoMsg;
                View protoInfo = view.findViewById(R.id.protocol_info);
                protoInfo.setVisibility(View.VISIBLE);

                protoInfo.setOnClickListener(view1 -> {
                    Context ctx = getContext();
                    if (ctx != null)
                        Utils.showHelpDialog(ctx, msg);
                });
            }

            if(l4proto.equals("ICMP")) {
                source.setText(mConn.src_ip);
                destination.setText(mConn.dst_ip);
            } else {
                if (mConn.ipver == 6) {
                    source.setText(String.format(getResources().getString(R.string.ipv6_and_port), mConn.src_ip, mConn.src_port));
                    destination.setText(String.format(getResources().getString(R.string.ipv6_and_port), mConn.dst_ip, mConn.dst_port));
                } else {
                    source.setText(String.format(getResources().getString(R.string.ip_and_port), mConn.src_ip, mConn.src_port));
                    destination.setText(String.format(getResources().getString(R.string.ip_and_port), mConn.dst_ip, mConn.dst_port));
                }
            }

            if((mConn.info != null) && (!mConn.info.isEmpty())) {
                if(mConn.l7proto.equals("DNS"))
                    info_label.setText(R.string.query);
                else if(mConn.l7proto.equals("HTTP"))
                    info_label.setText(R.string.host);
                info.setText(mConn.info);
            } else
                info_row.setVisibility(View.GONE);

            String uid_str = Integer.toString(mConn.uid);
            AppDescriptor app = (new AppsResolver(mActivity)).getAppByUid(mConn.uid, 0);
            if(app != null)
                appLabel.setText(String.format(getResources().getString(R.string.app_and_proto), app.getName(), uid_str));
            else
                appLabel.setText(uid_str);

            view.findViewById(R.id.decryption_status_row)
                    .setVisibility(CaptureService.isDecryptingTLS() ? View.VISIBLE : View.GONE);

            boolean has_scripts = (mConn.js_injected_scripts != null) && !mConn.js_injected_scripts.isEmpty();
            view.findViewById(R.id.injected_scripts_row)
                    .setVisibility(has_scripts ? View.VISIBLE : View.GONE);
            if(has_scripts)
                ((TextView)view.findViewById(R.id.injected_scripts)).setText(mConn.js_injected_scripts);

            if(!mConn.url.isEmpty())
                url.setText(mConn.url);
            else
                url_row.setVisibility(View.GONE);

            if(!mConn.country.isEmpty()) {
                country.setText(Utils.getCountryName(mActivity, mConn.country));
                country_flag.setCountryCode(mConn.country);
            } else
                view.findViewById(R.id.country_row).setVisibility(View.GONE);

            if(mConn.asn.isKnown())
                asn.setText(mConn.asn.toString());
            else
                view.findViewById(R.id.asn_row).setVisibility(View.GONE);

            if(mConn.ifidx > 0) {
                String ifname = CaptureService.getInterfaceName(mConn.ifidx);

                if(!ifname.isEmpty()) {
                    view.findViewById(R.id.interface_row).setVisibility(View.VISIBLE);
                    ((TextView) view.findViewById(R.id.capture_interface)).setText(ifname);
                }
            }

            connectionUpdated();
        }
    }

    @Override
    public boolean handleMenuAction(MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.copy_to_clipboard) {
            ClipboardManager clipboard = (ClipboardManager) mActivity.getSystemService(Context.CLIPBOARD_SERVICE);
            ClipData clip = ClipData.newPlainText(getString(R.string.connection_details), getContents());
            clipboard.setPrimaryClip(clip);

            Utils.showToast(mActivity, R.string.copied);
            return true;
        } else if(id == R.id.share) {
            Utils.shareText(mActivity, getString(R.string.connection_details), getContents());
            return true;
        }

        return false;
    }

    private String getContents() {
        if(mTable == null)
            return "";

        return Utils.table2Text(mTable);
    }

    @Override
    public void connectionUpdated() {
        Context context = mBytesView.getContext();

        mPayloadLen.setText(Utils.formatBytes(mConn.payload_length));
        mBytesView.setText(String.format(getResources().getString(R.string.rcvd_and_sent), Utils.formatBytes(mConn.rcvd_bytes), Utils.formatBytes(mConn.sent_bytes)));
        mPacketsView.setText(String.format(getResources().getString(R.string.rcvd_and_sent), Utils.formatIntShort(mConn.rcvd_pkts), Utils.formatIntShort(mConn.sent_pkts)));

        if(mConn.blocked_pkts > 0) {
            mBlockedPkts.setText(String.format(getResources().getString(R.string.n_pkts), Utils.formatIntShort(mConn.blocked_pkts)));
            mBlockedPktsRow.setVisibility(View.VISIBLE);
        }

        mDurationView.setText(Utils.formatDuration((mConn.last_seen - mConn.first_seen) / 1000));
        mFirstSeen.setText(Utils.formatEpochMillis(mActivity, mConn.first_seen));
        mLastSeen.setText(Utils.formatEpochMillis(mActivity, mConn.last_seen));
        mStatus.setText(mConn.getStatusLabel(mActivity));
        mDecStatus.setText(mConn.getDecryptionStatusLabel(mActivity));
        Utils.setDecryptionIcon(mDecIcon, mConn);
        //mTcpFlags.setText(Utils.tcpFlagsToStr(mConn.getRcvdTcpFlags()) + " <- " + Utils.tcpFlagsToStr(mConn.getSentTcpFlags()));
        mBlacklistedIp.setVisibility(mConn.isBlacklistedIp() ? View.VISIBLE : View.GONE);
        mBlacklistedHost.setVisibility(mConn.isBlacklistedHost() ? View.VISIBLE : View.GONE);

        if (mConn.error > 0) {
            mSocketErrnoRow.setVisibility(View.VISIBLE);

            Pair<Integer, Integer> errnoInfo = getSocketErrnoInfo(mConn.error);
            mSocketErrno.setText(context.getString(R.string.error_code_with_text,
                    context.getString((errnoInfo != null) ? errnoInfo.first : R.string.unknown_app),
                    mConn.error));

            if (errnoInfo != null) {
                final int msgId = errnoInfo.second;

                mSocketErrnoInfo.setOnClickListener(view -> {
                    Context ctx = getContext();
                    if (ctx != null)
                        Utils.showHelpDialog(ctx, msgId);
                });
            } else
                mSocketErrnoInfo.setVisibility(View.GONE);
        }

        if(mConn.decryption_error != null) {
            mError.setTextColor(ContextCompat.getColor(context, R.color.danger));
            mError.setText(mConn.decryption_error);
            mError.setVisibility(View.VISIBLE);
        } else if(mConn.is_blocked) {
            mError.setTextColor(ContextCompat.getColor(context, R.color.warning));
            mError.setText(context.getString(R.string.connection_blocked));
            mError.setVisibility(View.VISIBLE);
        } else if(!mConn.hasSeenStart()) {
            mError.setTextColor(ContextCompat.getColor(context, R.color.warning));
            mError.setText(context.getString(R.string.connection_start_not_seen));
            mError.setVisibility(View.VISIBLE);
        } else if(mConn.isPortMappingApplied()) {
            mError.setTextColor(ContextCompat.getColor(context, R.color.colorTabText));
            mError.setText(context.getString(R.string.connection_redirected_port_map));
            mError.setVisibility(View.VISIBLE);
        } else if(mConn.payload_length == 0) {
            mError.setTextColor(ContextCompat.getColor(context, R.color.warning));
            mError.setText(context.getString(R.string.warn_no_app_data));
            mError.setVisibility(View.VISIBLE);
        } else if(mConn.netd_block_missed) {
            mError.setTextColor(ContextCompat.getColor(context, R.color.warning));
            mError.setText(context.getString(R.string.netd_block_missed));
            mError.setVisibility(View.VISIBLE);
        } else if(mConn.getDecryptionStatus() == ConnectionDescriptor.DecryptionStatus.ENCRYPTED) {
            mError.setTextColor(ContextCompat.getColor(context, R.color.colorTabText));
            mError.setText(R.string.decryption_info_no_rule);
            mError.setVisibility(View.VISIBLE);
        } else if((mConn.getDecryptionStatus() == ConnectionDescriptor.DecryptionStatus.NOT_DECRYPTABLE)
                && mConn.l7proto.equals("QUIC") &&
                CaptureService.isDecryptingTLS()) {
            mError.setTextColor(ContextCompat.getColor(context, R.color.warning));
            mError.setText(R.string.decrypt_quic_notice);
            mError.setVisibility(View.VISIBLE);
        } else
            mError.setVisibility(View.GONE);
    }

    private Pair<Integer, Integer> getSocketErrnoInfo(int errno) {
        return switch (errno) {
            case 32 -> /* EPIPE */
                    new Pair<>(R.string.errno_epipe, R.string.errno_epipe_msg);
            case 100 -> /* ENETDOWN */
                    new Pair<>(R.string.errno_enetdown, R.string.errno_enetdown_msg);
            case 101 -> /* ENETUNREACH */
                    new Pair<>(R.string.errno_enetunreach, R.string.errno_enetunreach_msg);
            case 102 -> /* ENETRESET */
                    new Pair<>(R.string.errno_enetreset, R.string.errno_enetreset_msg);
            case 103 -> /* ECONNABORTED */
                    new Pair<>(R.string.errno_econnaborted, R.string.errno_econnaborted_msg);
            case 104 -> /* ECONNRESET */
                    new Pair<>(R.string.errno_econnreset, R.string.errno_econnreset_msg);
            case 110 -> /* ETIMEDOUT */
                    new Pair<>(R.string.errno_etimedout, R.string.errno_etimedout_msg);
            case 111 -> /* ECONNREFUSED */
                    new Pair<>(R.string.errno_econnrefused, R.string.errno_econnrefused_msg);
            case 113 -> /* EHOSTUNREACH */
                    new Pair<>(R.string.errno_ehostunreach, R.string.errno_ehostunreach_msg);
            default -> null;
        };
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/ConnectionPayload.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.adapters.PayloadAdapter;
import com.emanuelef.remote_capture.interfaces.PayloadHostActivity;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.PayloadChunk;
import com.emanuelef.remote_capture.model.Prefs;
import com.emanuelef.remote_capture.views.EmptyRecyclerView;

public class ConnectionPayload extends Fragment implements PayloadHostActivity.ConnUpdateListener {
    private static final String TAG = "ConnectionPayload";
    private PayloadHostActivity mActivity;
    private ConnectionDescriptor mConn;
    private PayloadAdapter mAdapter;
    private TextView mTruncatedWarning;
    private EmptyRecyclerView mRecyclerView;
    private int mCurChunks;
    private boolean mShowAsPrintable;
    private WindowInsetsCompat mInsets;

    public static ConnectionPayload newInstance(PayloadChunk.ChunkType mode, int conn_id) {
        ConnectionPayload fragment = new ConnectionPayload();
        Bundle args = new Bundle();
        args.putSerializable("mode", mode);
        args.putInt("conn_id", conn_id);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);
        mActivity = (PayloadHostActivity) context;
        mActivity.addConnUpdateListener(this);

        if (mAdapter != null)
            mAdapter.setExportPayloadHandler(mActivity);
    }

    @Override
    public void onDetach() {
        super.onDetach();
        mActivity.removeConnUpdateListener(this);
        mActivity = null;

        if (mAdapter != null)
            mAdapter.setExportPayloadHandler(null);
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.connection_payload, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        Bundle args = getArguments();
        PayloadChunk.ChunkType mode;
        assert args != null;
        ConnectionsRegister reg = CaptureService.requireConnsRegister();
        mode = Utils.getSerializable(args, "mode", PayloadChunk.ChunkType.class);
        assert(mode != null);

        mConn = reg.getConnById(args.getInt("conn_id"));
        if(mConn == null) {
            Utils.showToast(requireContext(), R.string.connection_not_found);
            requireActivity().finish();
            return;
        }

        mRecyclerView = view.findViewById(R.id.payload);
        EmptyRecyclerView.MyLinearLayoutManager layoutMan = new EmptyRecyclerView.MyLinearLayoutManager(requireContext());
        mRecyclerView.setLayoutManager(layoutMan);

        mTruncatedWarning = view.findViewById(R.id.truncated_warning);
        mTruncatedWarning.setText(String.format(getString(R.string.payload_truncated), getString(R.string.full_payload)));
        if(mConn.isPayloadTruncated()) {
            mTruncatedWarning.setVisibility(View.VISIBLE);
        }

        // Allow interactions with the last item
        ViewCompat.setOnApplyWindowInsetsListener(mRecyclerView, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());
            v.setPadding(0, 0, 0, insets.bottom);

            return WindowInsetsCompat.CONSUMED;
        });
        mRecyclerView.setClipToPadding(false);

        ViewCompat.setOnApplyWindowInsetsListener(mTruncatedWarning, (v, windowInsets) -> {
            if(mConn.isPayloadTruncated()) {
                applyTruncatedWarningInsets(windowInsets);
                return WindowInsetsCompat.CONSUMED;
            } else {
                mInsets = windowInsets;
                return windowInsets;
            }
        });

        mCurChunks = mConn.getNumPayloadChunks();
        mShowAsPrintable = true;
        mAdapter = new PayloadAdapter(requireContext(), mConn, mode, mShowAsPrintable);
        mAdapter.setExportPayloadHandler(mActivity);

        // only set adapter after acknowledged (see setMenuVisibility below)
        if(payloadNoticeAcknowledged(PreferenceManager.getDefaultSharedPreferences(requireContext())))
            mRecyclerView.setAdapter(mAdapter);
    }

    private void applyTruncatedWarningInsets(WindowInsetsCompat windowInsets) {
        Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                WindowInsetsCompat.Type.displayCutout());
        ViewGroup.MarginLayoutParams mlp = (ViewGroup.MarginLayoutParams) mTruncatedWarning.getLayoutParams();
        mlp.bottomMargin = insets.bottom;
        mTruncatedWarning.setLayoutParams(mlp);
    }

    @Override
    public void setMenuVisibility(boolean menuVisible) {
        super.setMenuVisibility(menuVisible);

        Context context = getContext();
        if(context == null)
            return;

        Log.d(TAG, "setMenuVisibility : " + menuVisible);
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);

        if(menuVisible && !payloadNoticeAcknowledged(prefs)) {
            AlertDialog dialog = new AlertDialog.Builder(context)
                    .setTitle(R.string.warning)
                    .setMessage(R.string.payload_scams_notice)
                    .setOnCancelListener((d) -> requireActivity().finish())
                    .setNegativeButton(R.string.cancel_action, (d, b) -> requireActivity().finish())
                    .setPositiveButton(R.string.show_data_action, (d, whichButton) -> {
                        mRecyclerView.setAdapter(mAdapter);
                        prefs.edit().putBoolean(Prefs.PREF_PAYLOAD_NOTICE_ACK, true).apply();
                    }).show();

            dialog.setCanceledOnTouchOutside(false);
        }

        if(menuVisible && (mActivity != null) && (mConn != null))
            mActivity.updateMenuVisibility();
    }

    private boolean payloadNoticeAcknowledged(SharedPreferences prefs) {
        return prefs.getBoolean(Prefs.PREF_PAYLOAD_NOTICE_ACK, false);
    }

    public void setDisplayMode(boolean showAsPrintable) {
        mShowAsPrintable = showAsPrintable;
        mAdapter.setDisplayAsPrintableText(showAsPrintable);
    }

    public boolean guessDisplayAsPrintable() {
        if (mConn == null)
            return false;

        // try to determine the best mode based on the current payload
        if(mConn.getNumPayloadChunks() == 0)
            return mConn.l7proto.equals("HTTPS");

        PayloadChunk firstChunk = mConn.getPayloadChunk(0);
        if((firstChunk == null) || (firstChunk.type == PayloadChunk.ChunkType.HTTP))
            return true;

        // guess based on the actual data
        int maxLen = Math.min(firstChunk.payload.length, 16);
        for(int i = 0; i < maxLen; i++) {
            if(!Utils.isPrintable(firstChunk.payload[i]))
                return false;
        }

        return true;
    }

    @Override
    public void connectionUpdated() {
        if((mCurChunks == 0) && (mActivity != null)) {
            mActivity.updateMenuVisibility();
        }

        if(mConn.getNumPayloadChunks() > mCurChunks) {
            mAdapter.handleChunksAdded(mConn.getNumPayloadChunks());
            mCurChunks = mConn.getNumPayloadChunks();
        }

        if(mConn.isPayloadTruncated() && (mTruncatedWarning != null))
            mTruncatedWarning.setVisibility(View.VISIBLE);

            if (mInsets != null)
                applyTruncatedWarningInsets(mInsets);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/ConnectionsFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.ContextMenu;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.view.ActionMode;
import androidx.appcompat.widget.SearchView;
import androidx.core.graphics.Insets;
import androidx.core.view.MenuProvider;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;
import androidx.preference.PreferenceManager;
import androidx.recyclerview.widget.DividerItemDecoration;
import androidx.recyclerview.widget.RecyclerView;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Cidr;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.AppDetailsActivity;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.Blocklist;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.activities.ConnectionDetailsActivity;
import com.emanuelef.remote_capture.adapters.ConnectionsAdapter;
import com.emanuelef.remote_capture.model.FilterDescriptor;
import com.emanuelef.remote_capture.model.MatchList;
import com.emanuelef.remote_capture.model.MatchList.RuleType;
import com.emanuelef.remote_capture.model.Prefs;
import com.emanuelef.remote_capture.views.EmptyRecyclerView;
import com.emanuelef.remote_capture.interfaces.ConnectionsListener;
import com.emanuelef.remote_capture.activities.EditFilterActivity;
import com.google.android.material.chip.ChipGroup;
import com.google.android.material.floatingactionbutton.FloatingActionButton;
import com.google.android.material.slider.LabelFormatter;
import com.google.android.material.slider.Slider;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ConnectionsFragment extends Fragment implements ConnectionsListener, MenuProvider, SearchView.OnQueryTextListener {
    private static final String TAG = "ConnectionsFragment";
    private static boolean maliciousWarningShown = false;
    public static final String FILTER_EXTRA = "filter";
    public static final String QUERY_EXTRA = "query";
    private Handler mHandler;
    private ConnectionsAdapter mAdapter;
    private FloatingActionButton mFabDown;
    private int mFabDownMargin = 0;
    private EmptyRecyclerView mRecyclerView;
    private TextView mEmptyText;
    private TextView mOldConnectionsText;
    private boolean autoScroll;
    private boolean listenerSet;
    private ChipGroup mActiveFilter;
    private Slider mSizeSlider;
    private boolean mSizeSliderActive = false;
    private MenuItem mMenuFilter;
    private MenuItem mMenuItemSearch;
    private MenuItem mSave;
    private Uri mCsvFname;
    private AppsResolver mApps;
    private SearchView mSearchView;
    private String mQueryToApply;
    private String mUnblockCidr;
    private String mDecRemoveCidr;
    private ActionMode mActionMode;
    private AlertDialog mAlertDialog;

    private final ActivityResultLauncher<Intent> csvFileLauncher =
            registerForActivityResult(new StartActivityForResult(), this::csvFileResult);
    private final ActivityResultLauncher<Intent> filterLauncher =
            registerForActivityResult(new StartActivityForResult(), this::filterResult);

    @Override
    public void onResume() {
        super.onResume();

        refreshEmptyText();

        registerConnsListener();
        mRecyclerView.setEmptyView(mEmptyText); // after registerConnsListener, when the adapter is populated

        refreshMenuIcons();

        if (mAdapter != null) {
            boolean visible = mAdapter.mFilter.minSize >= 1024;
            mSizeSlider.setVisibility(visible ? View.VISIBLE : View.GONE);
            mSizeSlider.setLabelBehavior(visible ? LabelFormatter.LABEL_VISIBLE : LabelFormatter.LABEL_GONE);
        }
    }

    @Override
    public void onPause() {
        super.onPause();

        unregisterConnsListener();
        mRecyclerView.setEmptyView(null);

        if(mSearchView != null)
            mQueryToApply = mSearchView.getQuery().toString();
    }

    @Override
    public void onDestroyView() {
        if(mAlertDialog != null)
            mAlertDialog.dismiss();

        super.onDestroyView();
    }

    @Override
    public void onHiddenChanged(boolean hidden) {
        super.onHiddenChanged(hidden);

        if (hidden) {
            if(mActionMode != null)
                mActionMode.finish();
            clearFilters();
        } else {
            if (mRecyclerView != null) {
                mRecyclerView.scrollToPosition(0);
            }
        }
    }

    @Override
    public void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);

        if(mSearchView != null)
            outState.putString("search", mSearchView.getQuery().toString());
        if(mAdapter != null)
            outState.putSerializable("filter_desc", mAdapter.mFilter);
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        if (!(getParentFragment() instanceof DataViewContainerFragment)) {
            requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        }
        return inflater.inflate(R.layout.connections, container, false);
    }

    private void refreshEmptyText() {
        if((CaptureService.getConnsRegister() != null) || CaptureService.isServiceActive())
            mEmptyText.setText(mAdapter.hasFilter() ? R.string.no_matches_found : R.string.no_connections);
        else
            mEmptyText.setText(R.string.capture_not_running_status);
    }

    private void registerConnsListener() {
        if (!listenerSet) {
            ConnectionsRegister reg = CaptureService.getConnsRegister();

            if (reg != null) {
                reg.addListener(this);
                listenerSet = true;
            }
        }
    }

    private void unregisterConnsListener() {
        if(listenerSet) {
            ConnectionsRegister reg = CaptureService.getConnsRegister();
            if (reg != null)
                reg.removeListener(this);

            listenerSet = false;
        }
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        mHandler = new Handler(Looper.getMainLooper());
        mFabDown = view.findViewById(R.id.fabDown);
        mRecyclerView = view.findViewById(R.id.connections_view);
        mOldConnectionsText = view.findViewById(R.id.old_connections_notice);
        EmptyRecyclerView.MyLinearLayoutManager layoutMan = new EmptyRecyclerView.MyLinearLayoutManager(requireContext());
        mRecyclerView.setLayoutManager(layoutMan);
        mApps = new AppsResolver(requireContext());

        mEmptyText = view.findViewById(R.id.no_connections);
        mSizeSlider = view.findViewById(R.id.size_slider);
        mSizeSlider.setLabelFormatter(value -> Utils.formatBytes(((long) value) * 1024));
        mSizeSlider.addOnChangeListener((slider, value, fromUser) -> {
            if (mAdapter != null) {
                mAdapter.mFilter.minSize = ((long) value) * 1024;
                refreshFilteredConnections();
            }
        });
        mSizeSlider.addOnSliderTouchListener(new Slider.OnSliderTouchListener() {
            @Override
            public void onStartTrackingTouch(@NonNull Slider slider) {
                mSizeSliderActive = true;
            }

            @Override
            public void onStopTrackingTouch(@NonNull Slider slider) {
                if (slider.getValue() == 0) {
                    // NOTE: setting LABEL_GONE is also necessary to
                    // prevent the label from being still visible in some cases
                    slider.setVisibility(View.GONE);
                    slider.setLabelBehavior(LabelFormatter.LABEL_GONE);
                }

                mSizeSliderActive = false;
                recheckMaxConnectionSize();
            }
        });

        mActiveFilter = view.findViewById(R.id.active_filter);
        mActiveFilter.setOnCheckedStateChangeListener((group, checkedIds) -> {
            if(mAdapter != null) {
                for(int checkedId: checkedIds)
                    mAdapter.mFilter.clear(checkedId);
                refreshFilteredConnections();
            }
        });

        mAdapter = new ConnectionsAdapter(requireContext(), mApps);
        mRecyclerView.setAdapter(mAdapter);
        listenerSet = false;
        registerForContextMenu(mRecyclerView);

        DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(mRecyclerView.getContext(),
                layoutMan.getOrientation());
        mRecyclerView.addItemDecoration(dividerItemDecoration);

        mAdapter.setClickListener(v -> {
            int pos = mRecyclerView.getChildLayoutPosition(v);

            if(mActionMode != null) {
                toggleSelection(pos);
                return;
            }

            ConnectionDescriptor item = mAdapter.getItem(pos);

            if(item != null) {
                Intent intent = new Intent(requireContext(), ConnectionDetailsActivity.class);
                intent.putExtra(ConnectionDetailsActivity.CONN_ID_KEY, item.incr_id);

                if(mAdapter.hasFilter()) {
                    ArrayList<Integer> filteredIds = mAdapter.getFilteredConnectionIds();
                    if(filteredIds != null)
                        intent.putIntegerArrayListExtra(ConnectionDetailsActivity.FILTERED_IDS_KEY, filteredIds);
                }

                startActivity(intent);
            }
        });

        mAdapter.setSelectionLongClickListener(v -> {
            if(mActionMode != null) {
                int pos = mRecyclerView.getChildLayoutPosition(v);
                toggleSelection(pos);
                return true;
            }
            return false;
        });

        autoScroll = true;
        showFabDown(false);

        ViewCompat.setOnApplyWindowInsetsListener(view.findViewById(R.id.linearlayout), (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());

            v.setPadding(insets.left, insets.top, insets.right, 0);

            // only consume the top inset
            return windowInsets.inset(insets.left, insets.top, insets.right, 0);
        });

        mFabDown.setOnClickListener(v -> scrollToBottom());
        ViewCompat.setOnApplyWindowInsetsListener(mFabDown, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout() | WindowInsetsCompat.Type.ime());

            ViewGroup.MarginLayoutParams mlp = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
            if (mFabDownMargin == 0)
                // save base margin from the layout
                mFabDownMargin = mlp.bottomMargin;

            mlp.bottomMargin = mFabDownMargin + insets.bottom;
            v.setLayoutParams(mlp);

            return WindowInsetsCompat.CONSUMED;
        });

        mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
                recheckScroll();
            }
        });

        refreshMenuIcons();

        String search = "";
        boolean fromIntent = false;
        Intent intent = requireActivity().getIntent();

        if(intent != null) {
            FilterDescriptor filter = Utils.getSerializableExtra(intent, FILTER_EXTRA, FilterDescriptor.class);
            if(filter != null) {
                mAdapter.mFilter = filter;
                fromIntent = true;

                if (filter.onlyBlacklisted && !maliciousWarningShown) {
                    new AlertDialog.Builder(requireContext())
                            .setTitle(R.string.malicious_connections)
                            .setMessage(R.string.malicious_connections_notice)
                            .setPositiveButton(R.string.ok, (dialogInterface, i) -> {})
                            .show();

                    maliciousWarningShown = true;
                }
            }

            search = intent.getStringExtra(QUERY_EXTRA);
            if((search != null) && !search.isEmpty()) {
                // Avoid hiding the interesting items
                mAdapter.mFilter.showMasked = true;
                fromIntent = true;
            }
        }

        if(savedInstanceState != null) {
            if((search == null) || search.isEmpty())
                search = savedInstanceState.getString("search");

            if(!fromIntent && savedInstanceState.containsKey("filter_desc"))
                mAdapter.mFilter = Utils.getSerializable(savedInstanceState, "filter_desc", FilterDescriptor.class);
        }
        refreshActiveFilter();

        if((search != null) && !search.isEmpty())
            mQueryToApply = search;

        // Register for service status
        CaptureService.observeStatus(this, serviceStatus -> {
            if(serviceStatus == CaptureService.ServiceStatus.STARTED) {
                // register the new connection register
                if(listenerSet) {
                    unregisterConnsListener();
                    registerConnsListener();
                }

                autoScroll = true;
                showFabDown(false);
                mOldConnectionsText.setVisibility(View.GONE);
                mEmptyText.setText(R.string.no_connections);
                mApps.clear();
            }

            refreshMenuIcons();
        });
    }

    @Override
    public void onCreateContextMenu(@NonNull ContextMenu menu, @NonNull View v,
                                    @Nullable ContextMenu.ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);

        MenuInflater inflater = requireActivity().getMenuInflater();
        inflater.inflate(R.menu.connection_context_menu, menu);
        int max_length = 32;

        ConnectionDescriptor conn = mAdapter.getSelectedItem();
        if(conn == null)
            return;

        AppDescriptor app = mApps.getAppByUid(conn.uid, 0);
        Context ctx = requireContext();
        MenuItem item;

        Billing billing = Billing.newInstance(ctx);
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);

        boolean firewallVisible = billing.isFirewallVisible();
        boolean whitelistMode = Prefs.isFirewallWhitelistMode(prefs);
        boolean showPurchaseFirewall = (!billing.isPurchased(Billing.FIREWALL_SKU) && billing.isAvailable(Billing.FIREWALL_SKU)) && !CaptureService.isCapturingAsRoot();
        boolean blockVisible = false;
        boolean unblockVisible = false;
        boolean decryptVisible = false;
        boolean dontDecryptVisible = false;
        Blocklist blocklist = PCAPdroid.getInstance().getBlocklist();
        MatchList fwWhitelist = PCAPdroid.getInstance().getFirewallWhitelist();
        MatchList decryptionList = PCAPdroid.getInstance().getDecryptionList();

        if(app != null) {
            boolean appBlocked = blocklist.matchesApp(app.getUid());
            blockVisible = !appBlocked;
            unblockVisible = appBlocked;

            boolean decryptApp = decryptionList.matchesApp(app.getUid());
            decryptVisible = !decryptApp;
            dontDecryptVisible = decryptApp;

            item = menu.findItem(R.id.hide_app);
            String label = Utils.shorten(MatchList.getRuleLabel(ctx, RuleType.APP, app.getPackageName()), max_length);
            item.setTitle(label);
            item.setVisible(true);

            item = menu.findItem(R.id.search_app);
            item.setTitle(label);
            item.setVisible(true);

            item = menu.findItem(R.id.block_app);
            item.setTitle(label);
            item.setVisible(!appBlocked);

            item = menu.findItem(R.id.unblock_app);
            item.setTitle(label);
            item.setVisible(appBlocked);

            item = menu.findItem(R.id.dec_add_app);
            item.setTitle(label);
            item.setVisible(!decryptApp);

            item = menu.findItem(R.id.dec_rem_app);
            item.setTitle(label);
            item.setVisible(decryptApp);

            menu.findItem(R.id.unblock_app_10m).setTitle(getString(R.string.unblock_for_n_minutes, 10));
            menu.findItem(R.id.unblock_app_1h).setTitle(getString(R.string.unblock_for_n_hours, 1));
            menu.findItem(R.id.unblock_app_8h).setTitle(getString(R.string.unblock_for_n_hours, 8));

            if(conn.isBlacklisted()) {
                item = menu.findItem(R.id.mw_whitelist_app);
                item.setTitle(label);
                item.setVisible(true);
            }

            if(firewallVisible && whitelistMode) {
                boolean whitelisted = fwWhitelist.matchesApp(app.getUid());
                menu.findItem(R.id.add_to_fw_whitelist).setVisible(!whitelisted);
                menu.findItem(R.id.remove_from_fw_whitelist).setVisible(whitelisted);
            }
        }

        if((conn.info != null) && (!conn.info.isEmpty())) {
            boolean hostBlocked = blocklist.matchesExactHost(conn.info);
            String label = Utils.shorten(MatchList.getRuleLabel(ctx, RuleType.HOST, conn.info), max_length);
            blockVisible |= !hostBlocked;
            unblockVisible |= hostBlocked;

            boolean decryptHost = decryptionList.matchesExactHost(conn.info);
            decryptVisible |= !decryptHost;
            dontDecryptVisible |= decryptHost;

            item = menu.findItem(R.id.hide_host);
            item.setTitle(label);
            item.setVisible(true);

            item = menu.findItem(R.id.block_host);
            item.setTitle(label);
            item.setVisible(!hostBlocked);

            item = menu.findItem(R.id.unblock_host);
            item.setTitle(label);
            item.setVisible(hostBlocked);

            item = menu.findItem(R.id.search_host);
            item.setTitle(label);
            item.setVisible(true);

            item = menu.findItem(R.id.copy_host);
            item.setTitle(label);
            item.setVisible(true);

            item = menu.findItem(R.id.dec_add_host);
            item.setTitle(label);
            item.setVisible(!decryptHost);

            item = menu.findItem(R.id.dec_rem_host);
            item.setTitle(label);
            item.setVisible(decryptHost);

            String dm_clean = Utils.cleanDomain(conn.info);
            String domain = Utils.getSecondLevelDomain(dm_clean);

            if(!domain.equals(dm_clean)) {
                boolean domainBlocked = blocklist.matchesExactHost(domain);
                label = Utils.shorten(MatchList.getRuleLabel(ctx, RuleType.HOST, domain), max_length);
                blockVisible |= !domainBlocked;
                unblockVisible |= domainBlocked;

                item = menu.findItem(R.id.hide_domain);
                item.setTitle(label);
                item.setVisible(true);

                item = menu.findItem(R.id.block_domain);
                item.setTitle(label);
                item.setVisible(!domainBlocked);

                item = menu.findItem(R.id.unblock_domain);
                item.setTitle(label);
                item.setVisible(domainBlocked);
            }

            if(conn.isBlacklistedHost()) {
                item = menu.findItem(R.id.mw_whitelist_host);
                item.setTitle(label);
                item.setVisible(true);
            }
        } // conn.info

        if((conn.url != null) && !(conn.url.isEmpty())) {
            item = menu.findItem(R.id.copy_url);
            item.setTitle(Utils.shorten(String.format(getString(R.string.url_val), conn.url), max_length));
            item.setVisible(true);
        }

        if(!conn.country.isEmpty()) {
            boolean countryBlocked = blocklist.matchesCountry(conn.country);
            String label = Utils.shorten(String.format(getString(R.string.country_val), Utils.getCountryName(ctx, conn.country)), max_length);
            blockVisible |= !countryBlocked;
            unblockVisible |= countryBlocked;

            item = menu.findItem(R.id.block_country);
            item.setTitle(label);
            item.setVisible(!countryBlocked);

            item = menu.findItem(R.id.unblock_country);
            item.setTitle(label);
            item.setVisible(countryBlocked);

            item = menu.findItem(R.id.hide_country);
            item.setTitle(label);
            item.setVisible(true);
        }

        String label = MatchList.getRuleLabel(ctx, RuleType.IP, conn.dst_ip);
        menu.findItem(R.id.hide_ip).setTitle(label);
        menu.findItem(R.id.copy_ip).setTitle(label);
        menu.findItem(R.id.search_ip).setTitle(label);
        String unblockIpLabel = label;
        String decRemoveIpLabel = label;
        mUnblockCidr = null;
        mDecRemoveCidr = null;

        boolean ipBlocked = blocklist.matchesExactIP(conn.dst_ip);
        if (!ipBlocked) {
            Cidr blockedCidr = blocklist.matchesCidr(conn.dst_ip);
            if (blockedCidr != null) {
                ipBlocked = true;
                mUnblockCidr = blockedCidr.toString();
                unblockIpLabel = MatchList.getCidrLabel(ctx, blockedCidr);
            }
        }
        blockVisible |= !ipBlocked;
        unblockVisible |= ipBlocked;

        boolean decryptIp = decryptionList.matchesExactIP(conn.dst_ip);
        if (!decryptIp) {
            Cidr decryptCidr = decryptionList.matchesCidr(conn.dst_ip);
            if (decryptCidr != null) {
                decryptIp = true;
                mDecRemoveCidr = decryptCidr.toString();
                decRemoveIpLabel = MatchList.getCidrLabel(ctx, decryptCidr);
            }
        }
        decryptVisible |= !decryptIp;
        dontDecryptVisible |= decryptIp;

        menu.findItem(R.id.block_ip)
                .setTitle(label)
                .setVisible(!ipBlocked);
        menu.findItem(R.id.unblock_ip)
                .setTitle(unblockIpLabel)
                .setVisible(ipBlocked);

        menu.findItem(R.id.dec_add_ip)
                .setTitle(label)
                .setVisible(!decryptIp);
        menu.findItem(R.id.dec_rem_ip)
                .setTitle(decRemoveIpLabel)
                .setVisible(decryptIp);

        if(conn.isBlacklistedIp())
            menu.findItem(R.id.mw_whitelist_ip).setTitle(label).setVisible(true);

        if(conn.hasHttpRequest())
            menu.findItem(R.id.copy_http_request).setVisible(true);
        if(conn.hasHttpResponse())
            menu.findItem(R.id.copy_http_response).setVisible(true);

        label = MatchList.getRuleLabel(ctx, RuleType.PROTOCOL, conn.l7proto);
        menu.findItem(R.id.hide_proto).setTitle(label);
        menu.findItem(R.id.search_proto).setTitle(label);

        menu.findItem(R.id.block_menu).setVisible((firewallVisible || showPurchaseFirewall) && blockVisible);
        menu.findItem(R.id.unblock_menu).setVisible(firewallVisible && unblockVisible);

        if(!conn.isBlacklisted())
            menu.findItem(R.id.mw_whitelist_menu).setVisible(false);

        boolean decryptionEnabled = CaptureService.isDecryptionListEnabled();
        boolean canDecryptConnection = !conn.isNotDecryptable() && !conn.isCleartext();
        menu.findItem(R.id.decrypt_menu).setVisible(decryptionEnabled && canDecryptConnection && decryptVisible);
        menu.findItem(R.id.dont_decrypt_menu).setVisible(decryptionEnabled && canDecryptConnection && dontDecryptVisible);
    }

    @Override
    public boolean onContextItemSelected(@NonNull MenuItem item) {
        Context ctx = requireContext();
        ConnectionDescriptor conn = mAdapter.getSelectedItem();
        MatchList whitelist = PCAPdroid.getInstance().getMalwareWhitelist();
        MatchList fwWhitelist = PCAPdroid.getInstance().getFirewallWhitelist();
        MatchList decryptionList = PCAPdroid.getInstance().getDecryptionList();
        Blocklist blocklist = PCAPdroid.getInstance().getBlocklist();
        boolean firewallPurchased = Billing.newInstance(ctx).isPurchased(Billing.FIREWALL_SKU);
        boolean mask_changed = false;
        boolean whitelist_changed = false;
        boolean blocklist_changed = false;
        boolean firewall_wl_changed = false;
        boolean decryption_list_changed = false;

        if(conn == null)
            return super.onContextItemSelected(item);

        int id = item.getItemId();

        if(id == R.id.select_connection) {
            startSelectionMode(conn);
            return true;
        } else if(id == R.id.hide_app) {
            mAdapter.mMask.addApp(conn.uid);
            mask_changed = true;
        } else if(id == R.id.hide_host) {
            mAdapter.mMask.addHost(conn.info);
            mask_changed = true;
        } else if(id == R.id.hide_ip) {
            mAdapter.mMask.addIp(conn.dst_ip);
            mask_changed = true;
        } else if(id == R.id.hide_proto) {
            mAdapter.mMask.addProto(conn.l7proto);
            mask_changed = true;
        } else if(id == R.id.hide_domain) {
            mAdapter.mMask.addHost(Utils.getSecondLevelDomain(conn.info));
            mask_changed = true;
        } else if(id == R.id.hide_country) {
            mAdapter.mMask.addCountry(conn.country);
            mask_changed = true;
        } else if(id == R.id.search_app) {
            AppDescriptor app = mApps.getAppByUid(conn.uid, 0);
            if(app != null)
                setQuery(app.getPackageName());
            else
                return super.onContextItemSelected(item);
        } else if(id == R.id.search_host)
            setQuery(conn.info);
        else if(id == R.id.search_ip)
            setQuery(conn.dst_ip);
        else if(id == R.id.search_proto)
            setQuery(conn.l7proto);
        else if(id == R.id.mw_whitelist_app)  {
            whitelist.addApp(conn.uid);
            whitelist_changed = true;
        } else if(id == R.id.mw_whitelist_ip)  {
            whitelist.addIp(conn.dst_ip);
            whitelist_changed = true;
        } else if(id == R.id.mw_whitelist_host) {
            whitelist.addHost(conn.info);
            whitelist_changed = true;
        } else if(id == R.id.dec_add_app)  {
            decryptionList.addApp(conn.uid);
            decryption_list_changed = true;
        } else if(id == R.id.dec_add_ip)  {
            decryptionList.addIp(conn.dst_ip);
            decryption_list_changed = true;
        } else if(id == R.id.dec_add_host)  {
            decryptionList.addHost(conn.info);
            decryption_list_changed = true;
        } else if(id == R.id.dec_rem_app)  {
            decryptionList.removeApp(conn.uid);
            decryption_list_changed = true;
        } else if(id == R.id.dec_rem_ip)  {
            decryptionList.removeIp((mDecRemoveCidr != null) ? mDecRemoveCidr : conn.dst_ip);
            decryption_list_changed = true;
        } else if(id == R.id.dec_rem_host)  {
            decryptionList.removeHost(conn.info);
            decryption_list_changed = true;
        } else if(id == R.id.block_app) {
            if(firewallPurchased) {
                blocklist.addApp(conn.uid);
                blocklist_changed = true;
            } else
                showFirewallPurchaseDialog();
        } else if(id == R.id.block_ip) {
            if(firewallPurchased) {
                blocklist.addIp(conn.dst_ip);
                blocklist_changed = true;
            } else
                showFirewallPurchaseDialog();
        } else if(id == R.id.block_host) {
            if(firewallPurchased) {
                blocklist.addHost(conn.info);
                blocklist_changed = true;
            } else
                showFirewallPurchaseDialog();
        } else if(id == R.id.block_domain) {
            if(firewallPurchased) {
                blocklist.addHost(Utils.getSecondLevelDomain(conn.info));
                blocklist_changed = true;
            } else
                showFirewallPurchaseDialog();
        } else if(id == R.id.block_country) {
            if(firewallPurchased) {
                blocklist.addCountry(conn.country);
                blocklist_changed = true;
            } else
                showFirewallPurchaseDialog();
        } else if(id == R.id.unblock_app_permanently) {
            blocklist.removeApp(conn.uid);
            blocklist_changed = true;
        } else if(id == R.id.unblock_app_10m) {
            blocklist_changed = blocklist.unblockAppForMinutes(conn.uid, 10);
        } else if(id == R.id.unblock_app_1h) {
            blocklist_changed = blocklist.unblockAppForMinutes(conn.uid, 60);
        } else if(id == R.id.unblock_app_8h) {
            blocklist_changed = blocklist.unblockAppForMinutes(conn.uid, 480);
        } else if(id == R.id.unblock_ip) {
            blocklist.removeIp((mUnblockCidr != null) ? mUnblockCidr : conn.dst_ip);
            blocklist_changed = true;
        } else if(id == R.id.unblock_host) {
            blocklist.removeHost(conn.info);
            blocklist_changed = true;
        } else if(id == R.id.unblock_domain) {
            blocklist.removeHost(Utils.getSecondLevelDomain(conn.info));
            blocklist_changed = true;
        } else if(id == R.id.unblock_country) {
            blocklist.removeCountry(conn.country);
            blocklist_changed = true;
        } else if(id == R.id.add_to_fw_whitelist) {
            fwWhitelist.addApp(conn.uid);
            firewall_wl_changed = true;
        } else if(id == R.id.remove_from_fw_whitelist) {
            fwWhitelist.removeApp(conn.uid);
            firewall_wl_changed = true;
        } else if(id == R.id.open_app_details) {
            Intent intent = new Intent(requireContext(), AppDetailsActivity.class);
            intent.putExtra(AppDetailsActivity.APP_UID_EXTRA, conn.uid);
            startActivity(intent);
        } else if(id == R.id.copy_ip)
            Utils.copyToClipboard(ctx, conn.dst_ip);
        else if(id == R.id.copy_host)
            Utils.copyToClipboard(ctx, conn.info);
        else if(id == R.id.copy_url)
            Utils.copyToClipboard(ctx, conn.url);
        else if(id == R.id.copy_http_request)
            Utils.copyToClipboard(ctx, conn.getHttpRequest());
        else if(id == R.id.copy_http_response)
            Utils.copyToClipboard(ctx, conn.getHttpResponse());
        else
            return super.onContextItemSelected(item);

        if(mask_changed) {
            mAdapter.mMask.save();
            mAdapter.mFilter.showMasked = false;
            refreshFilteredConnections();
        } else if(whitelist_changed) {
            whitelist.save();
            CaptureService.reloadMalwareWhitelist();
        } else if(firewall_wl_changed) {
            fwWhitelist.save();
            if(CaptureService.isServiceActive())
                CaptureService.requireInstance().reloadFirewallWhitelist();
        } else if(decryption_list_changed) {
            decryptionList.save();
            CaptureService.reloadDecryptionList();
        } else if(blocklist_changed)
            blocklist.saveAndReload();

        return true;
    }

    private void showFirewallPurchaseDialog() {
        new AlertDialog.Builder(requireContext())
                .setTitle(R.string.paid_feature)
                .setMessage(Utils.getText(requireContext(), R.string.firewall_purchase_msg, getString(R.string.no_root_firewall)))
                .setPositiveButton(R.string.show_me, (dialogInterface, i) -> {
                    // Billing code here
                })
                .setNegativeButton(R.string.cancel_action, (dialogInterface, i) -> {})
                .show();
    }

    private void setQuery(String query) {
        Utils.setSearchQuery(mSearchView, mMenuItemSearch, query);
    }

    private void recheckScroll() {
        final EmptyRecyclerView.MyLinearLayoutManager layoutMan = (EmptyRecyclerView.MyLinearLayoutManager) mRecyclerView.getLayoutManager();
        assert layoutMan != null;
        int first_visibile_pos = layoutMan.findFirstCompletelyVisibleItemPosition();
        int last_visible_pos = layoutMan.findLastCompletelyVisibleItemPosition();
        int last_pos = mAdapter.getItemCount() - 1;
        boolean reached_bottom = (last_visible_pos >= last_pos);
        boolean is_scrolling = (first_visibile_pos != 0) || (!reached_bottom);

        if(is_scrolling) {
            if(reached_bottom) {
                autoScroll = true;
                showFabDown(false);
            } else {
                autoScroll = false;
                showFabDown(true);
            }
        } else
            showFabDown(false);
    }

    private void showFabDown(boolean visible) {
        // compared to setVisibility, .show/.hide provide animations and also properly clear the AnchorId
        if(visible)
            mFabDown.show();
        else
            mFabDown.hide();
    }

    private void scrollToBottom() {
        int last_pos = mAdapter.getItemCount() - 1;
        mRecyclerView.scrollToPosition(last_pos);

        showFabDown(false);
    }

    private void refreshActiveFilter() {
        if(mAdapter == null)
            return;

        mActiveFilter.removeAllViews();
        mAdapter.mFilter.toChips(getLayoutInflater(), mActiveFilter);

        // minSize slider
        long minSizeKB = mAdapter.mFilter.minSize / 1024;
        boolean sliderVisible = false;
        ConnectionsRegister reg = CaptureService.getConnsRegister();

        if ((reg != null) && (minSizeKB > 0)) {
            long maxSizeKb = reg.getMaxBytes() / 1024;
            maxSizeKb = Math.max(maxSizeKb, minSizeKB);

            if (maxSizeKb >= 2) {
                // NOTE: visible -> hidden transition is performed in onStopTrackingTouch
                mSizeSlider.setValueTo(maxSizeKb);
                mSizeSlider.setValue(minSizeKB);
                sliderVisible = true;
            }
        }

        if (sliderVisible && (mSizeSlider.getVisibility() != View.VISIBLE)) {
            mSizeSlider.setVisibility(View.VISIBLE);
            mSizeSlider.setLabelBehavior(LabelFormatter.LABEL_VISIBLE);
        }
    }

    private void recheckMaxConnectionSize() {
        if ((mSizeSlider.getVisibility() == View.VISIBLE) && !mSizeSliderActive) {
            ConnectionsRegister reg = CaptureService.getConnsRegister();
            if (reg != null) {
                long maxSizeKB = reg.getMaxBytes() / 1024;

                if (maxSizeKB > mSizeSlider.getValueTo())
                    mSizeSlider.setValueTo(maxSizeKB);
            }
        }
    }

    // This performs an unoptimized adapter refresh
    private void refreshFilteredConnections() {
        mAdapter.refreshFilteredConnections();
        refreshMenuIcons();
        refreshActiveFilter();
        recheckScroll();
    }

    private void recheckUntrackedConnections() {
        ConnectionsRegister reg = CaptureService.requireConnsRegister();
        if(reg.getUntrackedConnCount() > 0) {
            String info = String.format(getString(R.string.older_connections_notice), reg.getUntrackedConnCount());
            mOldConnectionsText.setText(info);
            mOldConnectionsText.setVisibility(View.VISIBLE);
        } else
            mOldConnectionsText.setVisibility(View.GONE);
    }

    @Override
    public void connectionsChanges(int num_connections) {
        // Important: must use the provided num_connections rather than accessing the register
        // in order to avoid desyncs

        // using runOnUi to populate the adapter as soon as registerConnsListener is called
        Utils.runOnUi(() -> {
            Log.d(TAG, "New connections size: " + num_connections);

            mAdapter.connectionsChanges(num_connections);

            recheckScroll();
            if(autoScroll)
                scrollToBottom();
            recheckUntrackedConnections();
        }, mHandler);
    }

    @Override
    public void connectionsAdded(int start, ConnectionDescriptor []conns) {
        mHandler.post(() -> {
            Log.d(TAG, "Add " + conns.length + " connections at " + start);

            mAdapter.connectionsAdded(start, conns);

            if(autoScroll)
                scrollToBottom();
            recheckUntrackedConnections();
            recheckMaxConnectionSize();
        });
    }

    @Override
    public void connectionsRemoved(int start, ConnectionDescriptor []conns) {
        mHandler.post(() -> {
            Log.d(TAG, "Remove " + conns.length + " connections at " + start);
            mAdapter.connectionsRemoved(start, conns);
        });
    }

    @Override
    public void connectionsUpdated(int[] positions) {
        mHandler.post(() -> {
            mAdapter.connectionsUpdated(positions);
            recheckMaxConnectionSize();
        });
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater menuInflater) {
        menuInflater.inflate(R.menu.connections_menu, menu);

        mSave = menu.findItem(R.id.save);
        mMenuFilter = menu.findItem(R.id.edit_filter);
        mMenuItemSearch = menu.findItem(R.id.search);

        mSearchView = (SearchView) mMenuItemSearch.getActionView();
        mSearchView.setOnQueryTextListener(this);

        if((mQueryToApply != null) && (!mQueryToApply.isEmpty())) {
            String query = mQueryToApply;
            mQueryToApply = null;
            setQuery(query);
        }

        refreshMenuIcons();
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.save) {
            openFileSelector();
            return true;
        } else if(id == R.id.edit_filter) {
            Intent intent = new Intent(requireContext(), EditFilterActivity.class);
            intent.putExtra(EditFilterActivity.FILTER_DESCRIPTOR, mAdapter.mFilter);
            filterLauncher.launch(intent);
            return true;
        }

        return false;
    }

    private void refreshMenuIcons() {
        if(mSave == null)
            return;

        boolean is_enabled = (CaptureService.getConnsRegister() != null);

        mMenuItemSearch.setVisible(is_enabled); // NOTE: setEnabled does not work for this
        //mMenuFilter.setEnabled(is_enabled);
        mSave.setEnabled(is_enabled);
    }

    private void dumpCsv() {
        if(mCsvFname == null)
            return;

        Log.d(TAG, "Writing CSV file: " + mCsvFname);
        String dump = mAdapter.dumpConnectionsCsv(mActionMode != null);

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Handler handler = new Handler(Looper.getMainLooper());
        final boolean[] cancelled = {false};

        AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());
        builder.setTitle(R.string.exporting);
        builder.setMessage(R.string.export_in_progress);
        builder.setNegativeButton(android.R.string.cancel, (dialog, which) -> {
            Log.i(TAG, "Abort CSV export");
            cancelled[0] = true;
            executor.shutdownNow();
        });

        mAlertDialog = builder.create();
        mAlertDialog.setCanceledOnTouchOutside(false);
        mAlertDialog.show();

        mAlertDialog.setOnCancelListener(dialog -> {
            Log.i(TAG, "Abort CSV export (back button)");
            cancelled[0] = true;
            executor.shutdownNow();
        });
        mAlertDialog.setOnDismissListener(dialog -> mAlertDialog = null);

        final Uri csvFname = mCsvFname;
        mCsvFname = null;

        executor.execute(() -> {
            boolean success = false;

            try {
                OutputStream stream = requireActivity().getContentResolver().openOutputStream(csvFname, "rwt");

                if(stream != null) {
                    stream.write(dump.getBytes(StandardCharsets.UTF_8));
                    stream.close();
                    success = true;
                }
            } catch (IOException e) {
                if(!cancelled[0])
                    e.printStackTrace();
            }

            if(cancelled[0])
                return;

            final boolean result = success;
            final Utils.UriStat stat = result ? Utils.getUriStat(requireContext(), csvFname) : null;

            handler.post(() -> {
                if(mAlertDialog != null)
                    mAlertDialog.dismiss();

                if(result) {
                    if(stat != null) {
                        String msg = String.format(getString(R.string.file_saved_with_name), stat.name);
                        Toast.makeText(requireContext(), msg, Toast.LENGTH_SHORT).show();
                    } else
                        Utils.showToast(requireContext(), R.string.save_ok);
                } else
                    Utils.showToast(requireContext(), R.string.cannot_write_file);

                if(mActionMode != null)
                    mActionMode.finish();
            });
        });
    }

    public void openFileSelector() {
        boolean noFileDialog = false;
        String fname = Utils.getExportFileName(requireContext(), "csv");
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        intent.putExtra(Intent.EXTRA_TITLE, fname);

        if(Utils.supportsFileDialog(requireContext(), intent)) {
            try {
                csvFileLauncher.launch(intent);
            } catch (ActivityNotFoundException e) {
                noFileDialog = true;
            }
        } else
            noFileDialog = true;

        if(noFileDialog) {
            Log.w(TAG, "No app found to handle file selection");

            // Pick default path
            Uri uri = Utils.getDownloadsUri(requireContext(), fname);

            if(uri != null) {
                mCsvFname = uri;
                dumpCsv();
            } else
                Utils.showToastLong(requireContext(), R.string.no_activity_file_selection);
        }
    }

    private void csvFileResult(final ActivityResult result) {
        if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
            mCsvFname = result.getData().getData();
            dumpCsv();
        } else {
            mCsvFname = null;
        }
    }

    private void filterResult(final ActivityResult result) {
        if(result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
            FilterDescriptor descriptor = Utils.getSerializableExtra(result.getData(), EditFilterActivity.FILTER_DESCRIPTOR, FilterDescriptor.class);
            if(descriptor != null) {
                mAdapter.mFilter = descriptor;
                mAdapter.refreshFilteredConnections();
                refreshActiveFilter();
            }
        }
    }

    @Override
    public boolean onQueryTextSubmit(String query) { return true; }

    @Override
    public boolean onQueryTextChange(String newText) {
        mAdapter.setSearch(newText);
        recheckScroll();
        refreshEmptyText();
        return true;
    }

    // NOTE: dispatched from activity, returns true if handled
    public boolean onBackPressed() {
        if(mActionMode != null) {
            mActionMode.finish();
            return true;
        }
        return Utils.backHandleSearchview(mSearchView);
    }

    private void startSelectionMode(ConnectionDescriptor conn) {
        if(mActionMode != null)
            return;

        mActionMode = ((AppCompatActivity) requireActivity()).startSupportActionMode(mActionModeCallback);

        // find position of the connection and select it
        for(int i = 0; i < mAdapter.getItemCount(); i++) {
            ConnectionDescriptor c = mAdapter.getItem(i);
            if((c != null) && (c.incr_id == conn.incr_id)) {
                mAdapter.selectItem(i);
                break;
            }
        }

        updateActionModeTitle();
    }

    private void toggleSelection(int pos) {
        mAdapter.toggleSelection(pos);

        if(mAdapter.getSelectedCount() == 0) {
            if(mActionMode != null)
                mActionMode.finish();
        } else
            updateActionModeTitle();
    }

    private void updateActionModeTitle() {
        if(mActionMode != null)
            mActionMode.setTitle(getString(R.string.n_selected, mAdapter.getSelectedCount()));
    }

    private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
        @Override
        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            mode.getMenuInflater().inflate(R.menu.connections_cab, menu);
            return true;
        }

        @Override
        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            return false;
        }

        @Override
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            int id = item.getItemId();

            if(id == R.id.select_all) {
                if(mAdapter.getSelectedCount() == mAdapter.getItemCount())
                    mode.finish();
                else {
                    mAdapter.selectAll();
                    updateActionModeTitle();
                }
                return true;
            } else if(id == R.id.save) {
                openFileSelector();
                return true;
            }

            return false;
        }

        @Override
        public void onDestroyActionMode(ActionMode mode) {
            mAdapter.clearSelection();
            mActionMode = null;
        }
    };

    public void clearFilters() {
        if(mAdapter != null) {
            mAdapter.mFilter = new FilterDescriptor();
            mAdapter.refreshFilteredConnections();
            refreshActiveFilter();
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/DataViewContainerFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.Intent;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.TooltipCompat;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentActivity;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;
import androidx.lifecycle.Lifecycle;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.FilterDescriptor;
import com.google.android.material.tabs.TabLayout;

public class DataViewContainerFragment extends Fragment implements MenuProvider {
    private static final String TAG = "DataViewContainer";
    private static final String STATE_CURRENT_VIEW = "current_view";

    private static final int VIEW_CONNECTIONS = 0;
    private static final int VIEW_HTTP_LOG = 1;

    private static final int TAB_POSITION = 1;

    private int mCurrentView = VIEW_CONNECTIONS;
    private Fragment mConnectionsFragment;
    private Fragment mHttpLogFragment;

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            mCurrentView = savedInstanceState.getInt(STATE_CURRENT_VIEW, VIEW_CONNECTIONS);
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.data_view_container, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        FragmentManager childFragmentManager = getChildFragmentManager();

        mConnectionsFragment = childFragmentManager.findFragmentByTag("connections");
        mHttpLogFragment = childFragmentManager.findFragmentByTag("http_log");

        Intent intent = requireActivity().getIntent();
        Bundle connectionArgs = null;
        if (intent != null) {
            FilterDescriptor filter = Utils.getSerializableExtra(intent,
                ConnectionsFragment.FILTER_EXTRA, FilterDescriptor.class);
            String query = intent.getStringExtra(ConnectionsFragment.QUERY_EXTRA);

            if (filter != null || (query != null && !query.isEmpty())) {
                mCurrentView = VIEW_CONNECTIONS;

                connectionArgs = new Bundle();
                if (filter != null) {
                    connectionArgs.putSerializable(ConnectionsFragment.FILTER_EXTRA, filter);
                }
                if (query != null && !query.isEmpty()) {
                    connectionArgs.putString(ConnectionsFragment.QUERY_EXTRA, query);
                }

                intent.removeExtra(ConnectionsFragment.FILTER_EXTRA);
                intent.removeExtra(ConnectionsFragment.QUERY_EXTRA);
            }
        }

        FragmentTransaction transaction = childFragmentManager.beginTransaction();

        if (mConnectionsFragment == null) {
            mConnectionsFragment = new ConnectionsFragment();
            if (connectionArgs != null) {
                mConnectionsFragment.setArguments(connectionArgs);
            }
            transaction.add(R.id.child_fragment_container, mConnectionsFragment, "connections");
        }

        if (mHttpLogFragment == null) {
            mHttpLogFragment = new HttpLogFragment();
            transaction.add(R.id.child_fragment_container, mHttpLogFragment, "http_log");
        }

        if (mCurrentView == VIEW_CONNECTIONS) {
            transaction.show(mConnectionsFragment);
            transaction.hide(mHttpLogFragment);
        } else {
            transaction.show(mHttpLogFragment);
            transaction.hide(mConnectionsFragment);
        }

        transaction.commit();

        updateTabTitle();
    }

    @Override
    public void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(STATE_CURRENT_VIEW, mCurrentView);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, @NonNull MenuInflater menuInflater) {
        if ((mCurrentView == VIEW_CONNECTIONS) && (mConnectionsFragment != null)) {
            if (mConnectionsFragment instanceof ConnectionsFragment) {
                ((ConnectionsFragment) mConnectionsFragment).onCreateMenu(menu, menuInflater);
            }
        } else if ((mCurrentView == VIEW_HTTP_LOG) && (mHttpLogFragment != null)) {
            if (mHttpLogFragment instanceof HttpLogFragment) {
                ((HttpLogFragment) mHttpLogFragment).onCreateMenu(menu, menuInflater);
            }
        }

        updateTabTitle();
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        if ((mCurrentView == VIEW_CONNECTIONS) && (mConnectionsFragment != null)) {
            if (mConnectionsFragment instanceof ConnectionsFragment) {
                if (((ConnectionsFragment) mConnectionsFragment).onMenuItemSelected(item)) {
                    return true;
                }
            }
        } else if ((mCurrentView == VIEW_HTTP_LOG) && (mHttpLogFragment != null)) {
            if (mHttpLogFragment instanceof HttpLogFragment) {
                if (((HttpLogFragment) mHttpLogFragment).onMenuItemSelected(item)) {
                    return true;
                }
            }
        }

        return false;
    }

    public void toggleView() {
        int targetView = (mCurrentView == VIEW_CONNECTIONS) ?
            VIEW_HTTP_LOG : VIEW_CONNECTIONS;
        switchToView(targetView);
    }

    private void switchToView(int targetView) {
        if (mCurrentView == targetView) {
            return;
        }

        mCurrentView = targetView;

        FragmentTransaction transaction = getChildFragmentManager().beginTransaction();

        if (mCurrentView == VIEW_CONNECTIONS) {
            transaction.hide(mHttpLogFragment);
            transaction.show(mConnectionsFragment);
        } else {
            transaction.hide(mConnectionsFragment);
            transaction.show(mHttpLogFragment);
        }

        transaction.commit();

        updateTabTitle();

        requireActivity().invalidateMenu();
    }

    private void updateTabTitle() {
        FragmentActivity activity = requireActivity();
        TabLayout tabLayout = activity.findViewById(R.id.tablayout);

        if (tabLayout != null) {
            TabLayout.Tab tab = tabLayout.getTabAt(TAB_POSITION);
            if (tab != null) {
                int titleRes = (mCurrentView == VIEW_CONNECTIONS) ?
                    R.string.connections_view : R.string.http_requests;
                tab.setText(getString(titleRes));
            }
        }

        View switchButton = activity.findViewById(R.id.tab_switch_button);
        if (switchButton != null) {
            int contentDescRes = (mCurrentView == VIEW_CONNECTIONS) ?
                R.string.switch_to_http : R.string.switch_to_connections;
            String desc = getString(contentDescRes);
            switchButton.setContentDescription(desc);
            TooltipCompat.setTooltipText(switchButton, desc);
        }
    }

    public boolean onBackPressed() {
        if (mCurrentView == VIEW_CONNECTIONS && mConnectionsFragment != null) {
            if (mConnectionsFragment instanceof ConnectionsFragment) {
                return ((ConnectionsFragment) mConnectionsFragment).onBackPressed();
            }
        } else if (mCurrentView == VIEW_HTTP_LOG && mHttpLogFragment != null) {
            if (mHttpLogFragment instanceof HttpLogFragment) {
                return ((HttpLogFragment) mHttpLogFragment).onBackPressed();
            }
        }
        return false;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/EditListFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.view.ActionMode;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.adapters.ListEditAdapter;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.Blocklist;
import com.emanuelef.remote_capture.model.ListInfo;
import com.emanuelef.remote_capture.model.MatchList;
import com.emanuelef.remote_capture.model.MatchList.RuleType;
import com.emanuelef.remote_capture.views.AppSelectDialog;
import com.emanuelef.remote_capture.views.RuleAddDialog;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Locale;
import java.util.Scanner;
import java.util.Set;

public class EditListFragment extends Fragment implements MatchList.ListChangeListener, MenuProvider {
    private ListEditAdapter mAdapter;
    private TextView mEmptyText;
    private ArrayList<MatchList.Rule> mSelected = new ArrayList<>();
    private MatchList mList;
    private ListInfo mListInfo;
    private ListView mListView;
    private boolean mIsOwnUpdate;
    private ActionMode mActionMode;
    private AppSelectDialog mAppSelDialog;
    private static final int MAX_RULES_BEFORE_WARNING = 5000;
    private static final String TAG = "EditListFragment";
    private static final String LIST_TYPE_ARG = "list_type";

    private final ActivityResultLauncher<Intent> exportLauncher =
            registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), this::exportResult);
    private final ActivityResultLauncher<Intent> importLauncher =
            registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), this::importResult);

    public static EditListFragment newInstance(ListInfo.Type list) {
        EditListFragment fragment = new EditListFragment();
        Bundle args = new Bundle();
        args.putSerializable(LIST_TYPE_ARG, list);

        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.simple_list, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        mListView = view.findViewById(R.id.listview);
        mEmptyText = view.findViewById(R.id.list_empty);
        view.findViewById(R.id.simple_list).setFitsSystemWindows(true);

        assert getArguments() != null;
        mListInfo = new ListInfo(Utils.getSerializable(getArguments(), LIST_TYPE_ARG, ListInfo.Type.class));
        mList = mListInfo.getList();
        mList.addListChangeListener(this);

        mAdapter = new ListEditAdapter(requireContext());
        mListView.setAdapter(mAdapter);
        mListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
        mListView.setMultiChoiceModeListener(new AbsListView.MultiChoiceModeListener() {
            @Override
            public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) {
                MatchList.Rule item = mAdapter.getItem(position);

                if(checked)
                    mSelected.add(item);
                else
                    mSelected.remove(item);

                mode.setTitle(getString(R.string.n_selected, mSelected.size()));
            }

            @Override
            public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                MenuInflater inflater = requireActivity().getMenuInflater();
                inflater.inflate(R.menu.list_edit_cab, menu);
                mActionMode = mode;
                return true;
            }

            @Override
            public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                return false;
            }

            @Override
            public boolean onActionItemClicked(ActionMode mode, MenuItem menuItem) {
                int id = menuItem.getItemId();

                if(id == R.id.delete_entry) {
                    confirmDelete(mode);
                    return true;
                } else if(id == R.id.select_all) {
                    if(mSelected.size() >= mAdapter.getCount())
                        mode.finish();
                    else {
                        for(int i=0; i<mAdapter.getCount(); i++) {
                            if(!mListView.isItemChecked(i))
                                mListView.setItemChecked(i, true);
                        }
                    }

                    return true;
                } else
                    return false;
            }

            @Override
            public void onDestroyActionMode(ActionMode mode) {
                mSelected = new ArrayList<>();
                mActionMode = null;
            }
        });

        mAdapter.reload(mList.iterRules());
        recheckListSize();
    }

    @Override
    public void onDetach() {
        super.onDetach();
        abortAppSelection();
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        mList.removeListChangeListener(this);
    }

    private void confirmDelete(ActionMode mode) {
        AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());
        builder.setMessage(R.string.rules_delete_confirm);
        builder.setCancelable(true);
        builder.setPositiveButton(R.string.yes, (dialog, which) -> {
            if(mSelected.size() >= mAdapter.getCount()) {
                mAdapter.clear();
                mList.clear();
                mList.save();
            } else {
                for(MatchList.Rule item : mSelected)
                    mAdapter.remove(item);
                updateListFromAdapter();
            }

            mode.finish();
            mListInfo.reloadRules();
            recheckListSize();
        });
        builder.setNegativeButton(R.string.no, (dialog, whichButton) -> {});

        final AlertDialog alert = builder.create();
        alert.setCanceledOnTouchOutside(true);
        alert.show();
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.list_edit_menu, menu);

        if(!Utils.supportsFileDialog(requireContext())) {
            menu.findItem(R.id.action_import).setVisible(false);
            menu.findItem(R.id.action_export).setVisible(false);
        }

        Set<RuleType> supportedRules = mListInfo.getSupportedRules();
        if(supportedRules.contains(RuleType.APP))
            menu.findItem(R.id.add_app).setVisible(true);
        if(supportedRules.contains(RuleType.HOST))
            menu.findItem(R.id.add_host).setVisible(true);
        if(supportedRules.contains(RuleType.IP))
            menu.findItem(R.id.add_ip).setVisible(true);
        if(supportedRules.contains(RuleType.PROTOCOL))
            menu.findItem(R.id.add_proto).setVisible(true);
        if(supportedRules.contains(RuleType.COUNTRY))
            menu.findItem(R.id.add_country).setVisible(true);

        if(mListInfo.getHelpString() <= 0)
            menu.findItem(R.id.show_hint).setVisible(false);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();
        ListView lv = requireActivity().findViewById(R.id.listview);

        if(lv == null)
            return false;

        if(id == R.id.action_export) {
            if(mList.isEmpty())
                Utils.showToastLong(requireContext(), R.string.no_rules_to_export);
            else
                startExport();
            return true;
        } else if(id == R.id.action_import) {
            startImport();
            return true;
        } else if(id == R.id.copy_to_clipboard) {
            String contents = Utils.adapter2Text((ListEditAdapter)lv.getAdapter());
            Utils.copyToClipboard(requireContext(), contents);
            return true;
        } else if(id == R.id.share) {
            String contents = Utils.adapter2Text((ListEditAdapter)lv.getAdapter());
            Utils.shareText(requireContext(), getString(mListInfo.getTitle()), contents);
            return true;
        } else if(id == R.id.show_hint) {
            Utils.showHelpDialog(requireContext(), mListInfo.getHelpString());
            return true;
        } else if(id == R.id.add_ip) {
            showAddIpRule();
            return true;
        } else if(id == R.id.add_proto) {
            showAddProtoRule();
            return true;
        } else if(id == R.id.add_host) {
            showAddHostRule();
            return true;
        } else if(id == R.id.add_app) {
            showAddAppRule();
            return true;
        } else if(id == R.id.add_country) {
            showAddCountryRule();
            return true;
        }

        return false;
    }

    private void showAddIpRule() {
        RuleAddDialog.showText(requireContext(), R.string.ip_address_or_cidr, (value, field) -> {
            if(!Utils.validateCidr(value)) {
                field.setError(getString(R.string.invalid));
                return false;
            }

            if(!mList.addIp(value))
                Utils.showToastLong(requireContext(), R.string.rule_exists);
            else
                saveAndReload();
            return true;
        });
    }

    private void showAddProtoRule() {
        RuleAddDialog.showCombo(requireContext(), R.string.protocol, Utils.getL7Protocols(), (value, field) -> {
            if(!mList.addProto(value))
                Utils.showToastLong(requireContext(), R.string.rule_exists);
            else
                saveAndReload();
            return true;
        });
    }

    private void showAddCountryRule() {
        String[] countryCodes = Locale.getISOCountries();
        String[] countryNames = new String[countryCodes.length];
        Context ctx = requireContext();

        for(int i=0; i<countryCodes.length; i++)
            countryNames[i] = Utils.getCountryName(ctx, countryCodes[i]);

        RuleAddDialog.showCombo(requireContext(), R.string.country, countryNames, (value, field) -> {
            String code = null;

            for(int i=0; i<countryNames.length; i++) {
                if(countryNames[i].equals(value)) {
                    code = countryCodes[i];
                    break;
                }
            }

            if(code == null) {
                field.setError(getString(R.string.invalid));
                return false;
            }

            if(!mList.addCountry(code))
                Utils.showToastLong(ctx, R.string.rule_exists);
            else
                saveAndReload();

            Blocklist blocklist = PCAPdroid.getInstance().getBlocklist();
            blocklist.showNoticeIfGeoMissing(ctx);

            return true;
        });
    }

    private void showAddHostRule() {
        RuleAddDialog.showText(requireContext(), R.string.host, (value, field) -> {
            if(!Utils.validateHost(value)) {
                field.setError(getString(R.string.invalid));
                return false;
            }

            if(!mList.addHost(value))
                Utils.showToastLong(requireContext(), R.string.rule_exists);
            else
                saveAndReload();
            return true;
        });
    }

    private void showAddAppRule() {
        mAppSelDialog = new AppSelectDialog((AppCompatActivity) requireActivity(), R.string.app,
                new AppSelectDialog.AppSelectListener() {
            @Override
            public void onSelectedApp(AppDescriptor app) {
                abortAppSelection();

                if(!mList.addApp(app.getPackageName()))
                    Utils.showToastLong(requireContext(), R.string.rule_exists);
                else
                    saveAndReload();
            }

            @Override
            public void onAppSelectionAborted() {
                abortAppSelection();
            }
        });
    }

    private void abortAppSelection() {
        if(mAppSelDialog != null) {
            mAppSelDialog.abort();
            mAppSelDialog = null;
        }
    }

    private void recheckListSize() {
        mEmptyText.setVisibility((mAdapter.getCount() == 0) ? View.VISIBLE : View.GONE);
    }

    private void saveAndReload() {
        Log.d(TAG, "saveAndReload");
        mList.save();
        mListInfo.reloadRules();
    }

    private void updateListFromAdapter() {
        ArrayList<MatchList.Rule> toRemove = new ArrayList<>();
        Iterator<MatchList.Rule> iter = mList.iterRules();

        // Remove the mList rules which are not in the adapter dataset
        while(iter.hasNext()) {
            MatchList.Rule rule = iter.next();

            if (mAdapter.getPosition(rule) < 0)
                toRemove.add(rule);
        }

        if(toRemove.size() > 0) {
            mIsOwnUpdate = true;

            for(MatchList.Rule rule: toRemove)
                mList.removeRule(rule);
            mList.save();
        }
    }

    private String getExportName() {
        String fname = getString(mListInfo.getTitle()).toLowerCase().replaceAll(" ", "_");
        return "PCAPdroid_" + fname + ".json";
    }

    private void startExport() {
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        intent.putExtra(Intent.EXTRA_TITLE, getExportName());

        Utils.launchFileDialog(requireContext(), intent, exportLauncher);
    }

    private void exportResult(final ActivityResult result) {
        if(result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
            Context context = requireContext();
            String data = mList.toJson(true);

            try(OutputStream out = context.getContentResolver().openOutputStream(result.getData().getData(), "rwt")) {
                try(PrintWriter printer = new PrintWriter(out)) {
                    printer.print(data);
                    Utils.showToast(context, R.string.save_ok);
                }
            } catch (IOException e) {
                e.printStackTrace();
                Utils.showToastLong(context, R.string.export_failed);
            }
        }
    }

    private void startImport() {
        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        intent.putExtra(Intent.EXTRA_TITLE, getExportName());

        Utils.launchFileDialog(requireContext(), intent, importLauncher);
    }

    private void importResult(final ActivityResult result) {
        if(result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
            Context context = requireContext();

            try(InputStream in = context.getContentResolver().openInputStream(result.getData().getData())) {
                try(Scanner s = new Scanner(in).useDelimiter("\\A")) {
                    String data = s.hasNext() ? s.next() : "";
                    importRulesData(data, true);
                }
            } catch (IOException | RuntimeException e) {
                e.printStackTrace();
                Utils.showToastLong(context, R.string.import_failed);
            }
        }
    }

    private void importRulesData(String data, boolean limit_check) {
        Context context = requireContext();
        MatchList rules = new MatchList(context, "");

        int num_rules = rules.fromJson(data, limit_check ? MAX_RULES_BEFORE_WARNING : -1);
        if((num_rules <= 0) || rules.isEmpty()) {
            Utils.showToastLong(context, R.string.invalid_backup);
            return;
        }

        if(limit_check && (num_rules >= MAX_RULES_BEFORE_WARNING)) {
            confirmLoadManyRules(data);
            return;
        }

        // go on and import
        if(!mList.isEmpty())
            confirmImport(rules);
        else
            importRules(rules);
    }

    private void confirmLoadManyRules(String data) {
        Context context = requireContext();
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        builder.setTitle(R.string.warning);
        builder.setMessage(R.string.many_rules_warning);
        builder.setCancelable(true);
        builder.setPositiveButton(R.string.import_action, (dialog, which) -> {
            importRulesData(data, false);
        });
        builder.setNegativeButton(R.string.cancel_action, (dialog, which) -> {});

        final AlertDialog alert = builder.create();
        alert.setCanceledOnTouchOutside(false);
        alert.show();
    }

    private void confirmImport(MatchList rules) {
        Context context = requireContext();
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        builder.setTitle(R.string.import_action);
        builder.setMessage(R.string.rules_merge_msg);
        builder.setCancelable(true);
        builder.setPositiveButton(R.string.keep_action, (dialog, which) -> importRules(rules));
        builder.setNegativeButton(R.string.discard_action, (dialog, which) -> {
            mList.clear(false);
            importRules(rules);
        });

        final AlertDialog alert = builder.create();
        alert.setCanceledOnTouchOutside(false);
        alert.show();
    }

    private void importRules(MatchList to_add) {
        Context context = requireContext();
        int num_imported = mList.addRules(to_add);

        saveAndReload();

        String msg = String.format(context.getResources().getString(R.string.rules_import_success), num_imported);
        Toast.makeText(context, msg, Toast.LENGTH_SHORT).show();

        if (mList instanceof Blocklist) {
            Blocklist blocklist = PCAPdroid.getInstance().getBlocklist();
            if (blocklist.hasCountryRules())
                blocklist.showNoticeIfGeoMissing(context);
        }
    }

    @Override
    public void onListChanged() {
        if(mIsOwnUpdate) {
            Log.d(TAG, "onListChanged: own update");
            mIsOwnUpdate = false;
            return;
        }

        Log.d(TAG, "onListChanged");

        if(mActionMode != null) {
            mActionMode.finish();
            mActionMode = null;
        }

        // reload view
        mAdapter.reload(mList.iterRules());
        mListView.setAdapter(mAdapter);
        recheckListSize();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/FirewallStatus.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.widget.SwitchCompat;
import androidx.core.content.ContextCompat;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.ConnectionsActivity;
import com.emanuelef.remote_capture.activities.FirewallActivity;
import com.emanuelef.remote_capture.activities.MainActivity;
import com.emanuelef.remote_capture.model.Blocklist;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.FilterDescriptor;
import com.emanuelef.remote_capture.model.MatchList;
import com.emanuelef.remote_capture.model.Prefs;

public class FirewallStatus extends Fragment implements MenuProvider {
    private static final String TAG = "FirewallStatus";
    private static boolean whitelistWarningAck = false;
    private Handler mHandler;
    private SharedPreferences mPrefs;
    private Menu mMenu;
    private SwitchCompat mToggle;
    private ImageView mStatusIcon;
    private TextView mStatus;
    private TextView mNumBlocked;
    private TextView mNumChecked;
    private TextView mNumRules;
    private TextView mLastBlock;
    private Blocklist mBlocklist;
    private MatchList mWhitelist;
    private int mOkColor, mWarnColor, mGrayColor;

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.firewall_status, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        Context ctx = view.getContext();

        mPrefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        mBlocklist = PCAPdroid.getInstance().getBlocklist();
        mWhitelist = PCAPdroid.getInstance().getFirewallWhitelist();
        mStatus = view.findViewById(R.id.status);
        mHandler = new Handler(Looper.getMainLooper());
        mStatusIcon = view.findViewById(R.id.status_icon);
        mNumBlocked = view.findViewById(R.id.num_blocked);
        mNumChecked = view.findViewById(R.id.num_checked);
        mNumRules = view.findViewById(R.id.num_rules);
        mLastBlock = view.findViewById(R.id.last_block);

        mOkColor = ContextCompat.getColor(ctx, R.color.ok);
        mWarnColor = ContextCompat.getColor(ctx, R.color.warning);
        mGrayColor = ContextCompat.getColor(ctx, R.color.lightGray);

        view.findViewById(R.id.show_connections).setOnClickListener(v -> {
            FilterDescriptor filter = new FilterDescriptor();
            filter.filteringStatus = ConnectionDescriptor.FilteringStatus.BLOCKED;

            Intent intent = new Intent(requireContext(), ConnectionsActivity.class)
                    .putExtra(ConnectionsFragment.FILTER_EXTRA, filter);
            startActivity(intent);
        });
    }

    @Override
    public void onResume() {
        super.onResume();
        updateStatus();
    }

    @Override
    public void onPause() {
        super.onPause();
        mHandler.removeCallbacksAndMessages(null);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.firewall_menu, menu);
        mMenu = menu;

        mToggle = (SwitchCompat) menu.findItem(R.id.toggle_btn).getActionView();
        mToggle.setOnCheckedChangeListener((buttonView, isChecked) -> {
            if(isChecked == Prefs.isFirewallEnabled(requireContext(), mPrefs))
                return; // not changed

            Log.d(TAG, "Firwall is now " + (isChecked ? "enabled" : "disabled"));

            CaptureService.setFirewallEnabled(isChecked);
            mPrefs.edit().putBoolean(Prefs.PREF_FIREWALL, isChecked).apply();

            updateStatus();
        });

        menu.findItem(R.id.whitelist_mode).setChecked(Prefs.isFirewallWhitelistMode(mPrefs));
        menu.findItem(R.id.block_new_apps).setChecked(Prefs.blockNewApps(mPrefs));
        reloadMode(false);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.user_guide) {
            Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(MainActivity.FIREWALL_DOCS_URL));
            Utils.startActivity(requireContext(), browserIntent);
            return true;
        } else if(id == R.id.block_new_apps) {
            boolean checked = !item.isChecked();
            item.setChecked(checked);
            mPrefs.edit().putBoolean(Prefs.PREF_BLOCK_NEW_APPS, checked).apply();
            return true;
        } else if(id == R.id.whitelist_mode) {
            boolean checked = !item.isChecked();
            if(checked && !whitelistWarningAck) {
                AlertDialog dialog = new AlertDialog.Builder(requireContext())
                        .setTitle(R.string.whitelist_mode)
                        .setMessage(R.string.firewall_whitelist_notice)
                        .setPositiveButton(R.string.ok, (d, whichButton) -> {
                            whitelistWarningAck = true;
                            item.setChecked(true);
                            mPrefs.edit().putBoolean(Prefs.PREF_FIREWALL_WHITELIST_MODE, true).apply();
                            reloadMode(true);
                        })
                        .setNegativeButton(R.string.cancel_action, (d, whichButton) -> {})
                        .show();

                dialog.setCanceledOnTouchOutside(false);
            } else {
                item.setChecked(checked);
                mPrefs.edit().putBoolean(Prefs.PREF_FIREWALL_WHITELIST_MODE, checked).apply();
                reloadMode(true);
            }
            return true;
        }

        return false;
    }

    private void reloadMode(boolean changed) {
        if(changed && CaptureService.isServiceActive())
            CaptureService.requireInstance().reloadFirewallWhitelist();

        ((FirewallActivity)requireActivity()).recheckTabs();
        updateStatus();
    }

    private void updateStatus() {
        Context ctx = requireContext();
        ConnectionsRegister reg = CaptureService.getConnsRegister();
        boolean is_running = CaptureService.isServiceActive();
        boolean is_enabled = Prefs.isFirewallEnabled(ctx, mPrefs);
        boolean whitelist_mode = Prefs.isFirewallWhitelistMode(mPrefs);

        if(!is_running) {
            mStatusIcon.setImageResource(R.drawable.ic_shield);
            mStatusIcon.setColorFilter(mGrayColor);
            mStatus.setText(R.string.capture_not_running_status);
        } else if(CaptureService.isDNSEncrypted()) {
            mStatusIcon.setImageResource(R.drawable.ic_exclamation_triangle_solid);
            mStatusIcon.setColorFilter(mWarnColor);
            mStatus.setText(R.string.private_dns_hinders_detection);
        } else {
            mStatusIcon.setImageResource(R.drawable.ic_shield);

            if(is_enabled) {
                mStatusIcon.setColorFilter(mOkColor);
                mStatus.setText(R.string.firewall_is_enabled);
            } else {
                mStatusIcon.setColorFilter(mWarnColor);
                mStatus.setText(R.string.firewall_is_disabled);
            }
        }

        if(mToggle != null)
            mToggle.setChecked(is_enabled);

        mNumBlocked.setText(Utils.formatIntShort(((reg != null) ? reg.getNumBlockedConnections() : 0)));
        mNumChecked.setText(Utils.formatIntShort(CaptureService.getNumCheckedFirewallConnections()));
        mLastBlock.setText(Utils.formatEpochMin(ctx, ((reg != null) ? reg.getLastFirewallBlock() / 1000 : 0)));
        mNumRules.setText(Utils.formatIntShort(mBlocklist.getSize() + (whitelist_mode ? mWhitelist.getSize() : 0)));

        // Periodic update
        mHandler.postDelayed(this::updateStatus, 1000);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/HttpLogFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.view.ActionMode;
import androidx.appcompat.widget.SearchView;
import androidx.core.graphics.Insets;
import androidx.core.view.MenuProvider;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;
import androidx.recyclerview.widget.DividerItemDecoration;
import androidx.recyclerview.widget.RecyclerView;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.HarWriter;
import com.emanuelef.remote_capture.HttpLog;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.HttpDetailsActivity;
import com.emanuelef.remote_capture.activities.HttpLogFilterActivity;
import com.emanuelef.remote_capture.adapters.HttpLogAdapter;
import com.emanuelef.remote_capture.model.HttpLogFilterDescriptor;
import com.emanuelef.remote_capture.views.EmptyRecyclerView;
import com.google.android.material.chip.ChipGroup;
import com.google.android.material.floatingactionbutton.FloatingActionButton;
import com.google.android.material.slider.LabelFormatter;
import com.google.android.material.slider.Slider;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HttpLogFragment extends Fragment implements HttpLog.Listener, MenuProvider, SearchView.OnQueryTextListener {
    private static final String TAG = "HttpLogFragment";
    private TextView mEmptyText;
    private HttpLogAdapter mAdapter;
    private EmptyRecyclerView mRecyclerView;
    private FloatingActionButton mFabDown;
    private int mFabDownMargin = 0;
    private MenuItem mMenuItemSearch;
    private MenuItem mSave;
    private MenuItem mSaveAsHar;
    private SearchView mSearchView;
    private Handler mHandler;
    private ChipGroup mActiveFilter;
    private Slider mSizeSlider;
    private boolean mSizeSliderActive = false;
    private Uri mTxtFname;
    private Uri mHarFname;
    private AlertDialog mAlertDialog;

    private String mQueryToApply;
    private AppsResolver mApps;
    private boolean autoScroll;
    private boolean listenerSet;
    private ActionMode mActionMode;

    private final ActivityResultLauncher<Intent> filterLauncher =
            registerForActivityResult(new StartActivityForResult(), this::filterResult);
    private final ActivityResultLauncher<Intent> txtFileLauncher =
            registerForActivityResult(new StartActivityForResult(), this::txtFileResult);
    private final ActivityResultLauncher<Intent> harFileLauncher =
            registerForActivityResult(new StartActivityForResult(), this::harFileResult);

    @Override
    public void onResume() {
        super.onResume();

        refreshEmptyText();

        registerHttpListener();
        mRecyclerView.setEmptyView(mEmptyText); // after registerConnsListener, when the adapter is populated

        // Check scroll state after adapter is populated, to show FAB if needed.
        // Use post to ensure it executes after the RecyclerView has completed its layout
        mRecyclerView.post(this::recheckScroll);

        refreshMenuIcons();

        if (mAdapter != null) {
            boolean visible = mAdapter.mFilter.minPayloadSize >= 1024;
            mSizeSlider.setVisibility(visible ? View.VISIBLE : View.GONE);
            mSizeSlider.setLabelBehavior(visible ? LabelFormatter.LABEL_VISIBLE : LabelFormatter.LABEL_GONE);
        }
    }

    @Override
    public void onPause() {
        super.onPause();

        unregisterHttpListener();
        mRecyclerView.setEmptyView(null);

        if(mSearchView != null)
            mQueryToApply = mSearchView.getQuery().toString();
    }

    @Override
    public void onDestroyView() {
        if(mAlertDialog != null)
            mAlertDialog.dismiss();

        super.onDestroyView();
    }

    @Override
    public void onHiddenChanged(boolean hidden) {
        super.onHiddenChanged(hidden);

        if (hidden) {
            if(mActionMode != null)
                mActionMode.finish();
            clearFilters();
        } else {
            if (mRecyclerView != null) {
                mRecyclerView.scrollToPosition(0);
            }
        }
    }

    @Override
    public void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);

        if(mSearchView != null)
            outState.putString("search", mSearchView.getQuery().toString());
        if(mAdapter != null)
            outState.putSerializable("http_log_filter_desc", mAdapter.mFilter);
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        if (!(getParentFragment() instanceof DataViewContainerFragment)) {
            requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        }
        return inflater.inflate(R.layout.connections, container, false);
    }

    private void registerHttpListener() {
        if (!listenerSet) {
            HttpLog httpLog = CaptureService.getHttpLog();

            if (httpLog != null) {
                httpLog.setListener(this);
                listenerSet = true;

                // Sync adapter with data that arrived while listener was unregistered
                // (similar to ConnectionsRegister.addListener() which calls connectionsChanges)
                if (mAdapter != null) {
                    mAdapter.notifyDataSetChanged();
                }
            }
        }
    }

    private void unregisterHttpListener() {
        if(listenerSet) {
            HttpLog httpLog = CaptureService.getHttpLog();

            if (httpLog != null)
                httpLog.setListener(null);

            listenerSet = false;
        }
    }

    private void refreshEmptyText() {
        if((CaptureService.getHttpLog() != null) || CaptureService.isServiceActive())
            mEmptyText.setText(mAdapter.hasFilter() ? R.string.no_matches_found : R.string.no_requests);
        else
            mEmptyText.setText(R.string.capture_not_running_status);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        mHandler = new Handler(Looper.getMainLooper());
        mFabDown = view.findViewById(R.id.fabDown);
        mRecyclerView = view.findViewById(R.id.connections_view);
        EmptyRecyclerView.MyLinearLayoutManager layoutMan = new EmptyRecyclerView.MyLinearLayoutManager(requireContext());
        mRecyclerView.setLayoutManager(layoutMan);
        mApps = new AppsResolver(requireContext());

        mEmptyText = view.findViewById(R.id.no_connections);
        mSizeSlider = view.findViewById(R.id.size_slider);
        mSizeSlider.setLabelFormatter(value -> Utils.formatBytes(((long) value) * 1024));
        mSizeSlider.addOnChangeListener((slider, value, fromUser) -> {
            if (mAdapter != null) {
                mAdapter.mFilter.minPayloadSize = ((long) value) * 1024;
                refreshFilteredRequests();
            }
        });
        mSizeSlider.addOnSliderTouchListener(new Slider.OnSliderTouchListener() {
            @Override
            public void onStartTrackingTouch(@NonNull Slider slider) {
                mSizeSliderActive = true;
            }

            @Override
            public void onStopTrackingTouch(@NonNull Slider slider) {
                if (slider.getValue() == 0) {
                    slider.setVisibility(View.GONE);
                    slider.setLabelBehavior(LabelFormatter.LABEL_GONE);
                }

                mSizeSliderActive = false;
                recheckMaxPayloadSize();
            }
        });

        mActiveFilter = view.findViewById(R.id.active_filter);
        mActiveFilter.setOnCheckedStateChangeListener((group, checkedIds) -> {
            if(mAdapter != null) {
                for(int checkedId: checkedIds)
                    mAdapter.mFilter.clear(checkedId);
                refreshFilteredRequests();
            }
        });

        mAdapter = new HttpLogAdapter(requireContext(), mApps);
        mRecyclerView.setAdapter(mAdapter);

        DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(mRecyclerView.getContext(),
                layoutMan.getOrientation());
        mRecyclerView.addItemDecoration(dividerItemDecoration);

        mAdapter.setClickListener(v -> {
            int pos = mRecyclerView.getChildLayoutPosition(v);

            if(mActionMode != null) {
                toggleSelection(pos);
                return;
            }

            HttpLog.HttpRequest item = mAdapter.getItem(pos);

            if(item != null) {
                Intent intent = new Intent(requireContext(), HttpDetailsActivity.class);
                intent.putExtra(HttpDetailsActivity.HTTP_REQ_POS_KEY, item.getPosition());

                // Pass filtered positions for navigation
                if(mAdapter.hasFilter()) {
                    ArrayList<Integer> filteredPositions = mAdapter.getFilteredPositions();
                    if(filteredPositions != null)
                        intent.putIntegerArrayListExtra(HttpDetailsActivity.FILTERED_POSITIONS_KEY, filteredPositions);
                }

                startActivity(intent);
            }
        });

        mAdapter.setLongClickListener(v -> {
            int pos = mRecyclerView.getChildLayoutPosition(v);
            if(mActionMode != null) {
                toggleSelection(pos);
                return true;
            }
            startSelectionMode(pos);
            return true;
        });

        autoScroll = true;
        listenerSet = false;
        showFabDown(false);

        ViewCompat.setOnApplyWindowInsetsListener(view.findViewById(R.id.linearlayout), (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());

            v.setPadding(insets.left, insets.top, insets.right, 0);

            // only consume the top inset
            return windowInsets.inset(insets.left, insets.top, insets.right, 0);
        });

        mFabDown.setOnClickListener(v -> scrollToBottom());
        ViewCompat.setOnApplyWindowInsetsListener(mFabDown, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout() | WindowInsetsCompat.Type.ime());

            ViewGroup.MarginLayoutParams mlp = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
            if (mFabDownMargin == 0)
                // save base margin from the layout
                mFabDownMargin = mlp.bottomMargin;

            mlp.bottomMargin = mFabDownMargin + insets.bottom;
            v.setLayoutParams(mlp);

            return WindowInsetsCompat.CONSUMED;
        });

        mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
                recheckScroll();
            }
        });

        if(savedInstanceState != null) {
            String search = savedInstanceState.getString("search");

            if((search != null) && !search.isEmpty())
                mQueryToApply = search;

            if(savedInstanceState.containsKey("http_log_filter_desc"))
                mAdapter.mFilter = Utils.getSerializable(savedInstanceState, "http_log_filter_desc", HttpLogFilterDescriptor.class);
        }
        refreshActiveFilter();

        CaptureService.observeStatus(this, serviceStatus -> {
            if(serviceStatus == CaptureService.ServiceStatus.STARTED) {
                // register the new http log listener
                unregisterHttpListener();
                registerHttpListener();

                autoScroll = true;
                showFabDown(false);
                mEmptyText.setText(R.string.no_requests);
                mApps.clear();
            }

            refreshMenuIcons();
        });
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater menuInflater) {
        menuInflater.inflate(R.menu.http_log_menu, menu);

        mSave = menu.findItem(R.id.save);
        mSaveAsHar = menu.findItem(R.id.save_as_har);
        mMenuItemSearch = menu.findItem(R.id.search);

        mSearchView = (SearchView) mMenuItemSearch.getActionView();
        mSearchView.setOnQueryTextListener(this);

        if((mQueryToApply != null) && (!mQueryToApply.isEmpty())) {
            String query = mQueryToApply;
            mQueryToApply = null;
            setQuery(query);
        }

        refreshMenuIcons();
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.save) {
            openFileSelector();
            return true;
        } else if(id == R.id.save_as_har) {
            openHarFileSelector();
            return true;
        } else if(id == R.id.edit_filter) {
            Intent intent = new Intent(requireContext(), HttpLogFilterActivity.class);
            intent.putExtra(HttpLogFilterActivity.FILTER_DESCRIPTOR, mAdapter.mFilter);
            filterLauncher.launch(intent);
            return true;
        }

        return false;
    }

    private void setQuery(String query) {
        Utils.setSearchQuery(mSearchView, mMenuItemSearch, query);
    }

    @Override
    public boolean onQueryTextSubmit(String query) { return true; }

    @Override
    public boolean onQueryTextChange(String newText) {
        mAdapter.setSearch(newText);
        recheckScroll();
        refreshEmptyText();
        return true;
    }

    // NOTE: dispatched from activity, returns true if handled
    public boolean onBackPressed() {
        if(mActionMode != null) {
            mActionMode.finish();
            return true;
        }
        return Utils.backHandleSearchview(mSearchView);
    }

    @Override
    public void onHttpRequestAdded(int pos) {
        Utils.runOnUi(() -> {
            if (mAdapter != null) {
                mAdapter.onHttpRequestAdded(pos);

                if (autoScroll)
                    scrollToBottom();
            }
        }, mHandler);
    }

    @Override
    public void onHttpRequestUpdated(int pos) {
        Utils.runOnUi(() -> {
            if (mAdapter != null) {
                mAdapter.onHttpRequestUpdated(pos);

                if (autoScroll)
                    scrollToBottom();
            }
        }, mHandler);
    }

    @Override
    public void onHttpRequestsClear() {
        Utils.runOnUi(() -> {
            if (mAdapter != null)
                mAdapter.onHttpRequestsClear();
        }, mHandler);
    }

    private void recheckScroll() {
        final EmptyRecyclerView.MyLinearLayoutManager layoutMan = (EmptyRecyclerView.MyLinearLayoutManager) mRecyclerView.getLayoutManager();
        assert layoutMan != null;
        int first_visibile_pos = layoutMan.findFirstCompletelyVisibleItemPosition();
        int last_visible_pos = layoutMan.findLastCompletelyVisibleItemPosition();
        int last_pos = mAdapter.getItemCount() - 1;
        boolean reached_bottom = (last_visible_pos >= last_pos);
        boolean is_scrolling = (first_visibile_pos != 0) || (!reached_bottom);

        if(is_scrolling) {
            // Only update autoScroll flag if user is actively dragging (not programmatic scroll)
            boolean isUserScroll = mRecyclerView.getScrollState() == RecyclerView.SCROLL_STATE_DRAGGING;

            if(reached_bottom) {
                if (isUserScroll)
                    autoScroll = true;

                showFabDown(false);
            } else {
                if (isUserScroll)
                    autoScroll = false;

                showFabDown(true);
            }
        } else
            showFabDown(false);
    }

    private void showFabDown(boolean visible) {
        // compared to setVisibility, .show/.hide provide animations and also properly clear the AnchorId
        if(visible)
            mFabDown.show();
        else
            mFabDown.hide();
    }

    private void scrollToBottom() {
        int last_pos = mAdapter.getItemCount() - 1;
        mRecyclerView.scrollToPosition(last_pos);

        // Re-enable autoscroll when scrolling to bottom (user intent)
        autoScroll = true;
        showFabDown(false);
    }

    private void refreshActiveFilter() {
        if(mAdapter == null)
            return;

        mActiveFilter.removeAllViews();
        mAdapter.mFilter.toChips(getLayoutInflater(), mActiveFilter);

        // minPayloadSize slider
        long minSizeKB = mAdapter.mFilter.minPayloadSize / 1024;
        boolean sliderVisible = false;
        HttpLog httpLog = CaptureService.getHttpLog();

        if ((httpLog != null) && (minSizeKB > 0)) {
            long maxSizeKb = getMaxPayloadSize() / 1024;
            maxSizeKb = Math.max(maxSizeKb, minSizeKB);

            if (maxSizeKb >= 2) {
                mSizeSlider.setValueTo(maxSizeKb);
                mSizeSlider.setValue(minSizeKB);
                sliderVisible = true;
            }
        }

        if (sliderVisible && (mSizeSlider.getVisibility() != View.VISIBLE)) {
            mSizeSlider.setVisibility(View.VISIBLE);
            mSizeSlider.setLabelBehavior(LabelFormatter.LABEL_VISIBLE);
        }
    }

    private long getMaxPayloadSize() {
        HttpLog httpLog = CaptureService.getHttpLog();
        if (httpLog == null)
            return 0;

        long maxSize = 0;
        synchronized (httpLog) {
            for (int i = 0; i < httpLog.getSize(); i++) {
                HttpLog.HttpRequest req = httpLog.getRequest(i);
                if (req != null) {
                    int totalSize = (req.reply != null) ? (req.bodyLength + req.reply.bodyLength) : req.bodyLength;
                    if (totalSize > maxSize)
                        maxSize = totalSize;
                }
            }
        }
        return maxSize;
    }

    private void recheckMaxPayloadSize() {
        if ((mSizeSlider.getVisibility() == View.VISIBLE) && !mSizeSliderActive) {
            long maxSizeKB = getMaxPayloadSize() / 1024;

            if (maxSizeKB > mSizeSlider.getValueTo())
                mSizeSlider.setValueTo(maxSizeKB);
        }
    }

    private void refreshFilteredRequests() {
        mAdapter.refreshFilteredItems();
        refreshActiveFilter();
        recheckScroll();
    }

    private void filterResult(final ActivityResult result) {
        if(result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
            HttpLogFilterDescriptor descriptor = Utils.getSerializableExtra(result.getData(), HttpLogFilterActivity.FILTER_DESCRIPTOR, HttpLogFilterDescriptor.class);
            if(descriptor != null) {
                mAdapter.mFilter = descriptor;
                mAdapter.refreshFilteredItems();
                refreshActiveFilter();
            }
        }
    }

    private void refreshMenuIcons() {
        if(mSave == null)
            return;

        boolean is_enabled = (CaptureService.getHttpLog() != null);

        mMenuItemSearch.setVisible(is_enabled);
        mSave.setEnabled(is_enabled);
        if(mSaveAsHar != null)
            mSaveAsHar.setEnabled(is_enabled);
    }

    public void openFileSelector() {
        boolean noFileDialog = false;
        String fname = Utils.getExportFileName(requireContext(), "txt");
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        intent.putExtra(Intent.EXTRA_TITLE, fname);

        if(Utils.supportsFileDialog(requireContext(), intent)) {
            try {
                txtFileLauncher.launch(intent);
            } catch (ActivityNotFoundException e) {
                noFileDialog = true;
            }
        } else
            noFileDialog = true;

        if(noFileDialog) {
            Log.d(TAG, "No app found to handle file selection");

            Uri uri = Utils.getDownloadsUri(requireContext(), fname);

            if(uri != null) {
                mTxtFname = uri;
                dumpHttpLog();
            } else
                Utils.showToastLong(requireContext(), R.string.no_activity_file_selection);
        }
    }

    private void dumpHttpLog() {
        if(mTxtFname == null)
            return;

        boolean selectionActive = (mActionMode != null);
        Log.d(TAG, "Writing HTTP log file: " + mTxtFname);

        ArrayList<HttpLog.HttpRequest> requests = new ArrayList<>();
        for(int i = 0; i < mAdapter.getItemCount(); i++) {
            HttpLog.HttpRequest req = mAdapter.getItem(i);
            if((req != null) && (!selectionActive || mAdapter.isSelected(req)))
                requests.add(req);
        }

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Handler handler = new Handler(Looper.getMainLooper());
        final boolean[] cancelled = {false};

        AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());
        builder.setTitle(R.string.exporting);
        builder.setMessage(R.string.export_in_progress);
        builder.setNegativeButton(android.R.string.cancel, (dialog, which) -> {
            Log.i(TAG, "Abort TXT export");
            cancelled[0] = true;
            executor.shutdownNow();
        });

        mAlertDialog = builder.create();
        mAlertDialog.setCanceledOnTouchOutside(false);
        mAlertDialog.show();

        mAlertDialog.setOnCancelListener(dialog -> {
            Log.i(TAG, "Abort TXT export (back button)");
            cancelled[0] = true;
            executor.shutdownNow();
        });
        mAlertDialog.setOnDismissListener(dialog -> mAlertDialog = null);

        final Uri txtFname = mTxtFname;
        mTxtFname = null;

        executor.execute(() -> {
            boolean success = false;

            try {
                OutputStream stream = requireActivity().getContentResolver().openOutputStream(txtFname, "rwt");

                if(stream != null) {
                    for(HttpLog.HttpRequest req : requests) {
                        if(Thread.interrupted())
                            break;

                        StringBuilder sb = new StringBuilder();
                        var reqChunk = req.conn.getHttpRequestChunk(req.firstChunkPos);
                        String requestText = (reqChunk != null) ?
                                new String(reqChunk.payload, StandardCharsets.UTF_8) : "";

                        sb.append("[").append(req.timestamp).append("]\n");
                        if(!requestText.isEmpty()) {
                            sb.append(requestText);
                            if(!requestText.endsWith("\n"))
                                sb.append("\n");
                        }
                        sb.append("\n");

                        if(req.reply != null) {
                            var replyChunk = req.conn.getHttpResponseChunk(req.reply.firstChunkPos);
                            if(replyChunk != null) {
                                String replyText = new String(replyChunk.payload, StandardCharsets.UTF_8);
                                sb.append("[").append(replyChunk.timestamp).append("]\n");
                                sb.append(replyText);
                                if(!replyText.endsWith("\n"))
                                    sb.append("\n");
                                sb.append("\n");
                            }
                        }

                        stream.write(sb.toString().getBytes(StandardCharsets.UTF_8));
                    }

                    stream.close();
                    success = true;
                }
            } catch (IOException e) {
                if(!cancelled[0])
                    e.printStackTrace();
            }

            if(cancelled[0])
                return;

            final boolean result = success;
            final Utils.UriStat stat = result ? Utils.getUriStat(requireContext(), txtFname) : null;

            handler.post(() -> {
                if(mAlertDialog != null)
                    mAlertDialog.dismiss();

                if(result) {
                    if(stat != null) {
                        String msg = String.format(getString(R.string.file_saved_with_name), stat.name);
                        Toast.makeText(requireContext(), msg, Toast.LENGTH_SHORT).show();
                    } else
                        Utils.showToast(requireContext(), R.string.save_ok);
                } else
                    Utils.showToast(requireContext(), R.string.cannot_write_file);

                if(mActionMode != null)
                    mActionMode.finish();
            });
        });
    }

    private void txtFileResult(final ActivityResult result) {
        if((result.getResultCode() == Activity.RESULT_OK) && (result.getData() != null)) {
            mTxtFname = result.getData().getData();
            dumpHttpLog();
        } else {
            mTxtFname = null;
        }
    }

    public void openHarFileSelector() {
        boolean noFileDialog = false;
        String fname = Utils.getExportFileName(requireContext(), "har");
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("*/*");
        intent.putExtra(Intent.EXTRA_TITLE, fname);

        if(Utils.supportsFileDialog(requireContext(), intent)) {
            try {
                harFileLauncher.launch(intent);
            } catch (ActivityNotFoundException e) {
                noFileDialog = true;
            }
        } else
            noFileDialog = true;

        if(noFileDialog) {
            Log.d(TAG, "No app found to handle file selection");

            Uri uri = Utils.getDownloadsUri(requireContext(), fname);

            if(uri != null) {
                mHarFname = uri;
                exportHttpLogHar();
            } else
                Utils.showToastLong(requireContext(), R.string.no_activity_file_selection);
        }
    }

    private void exportHttpLogHar() {
        if(mHarFname == null)
            return;

        boolean selectionActive = (mActionMode != null);
        Log.d(TAG, "Writing HAR file: " + mHarFname);

        // Snapshot the visible (filtered) requests on the UI thread
        ArrayList<HttpLog.HttpRequest> requests = new ArrayList<>();
        for(int i = 0; i < mAdapter.getItemCount(); i++) {
            HttpLog.HttpRequest req = mAdapter.getItem(i);
            if((req != null) && (!selectionActive || mAdapter.isSelected(req)))
                requests.add(req);
        }

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Handler handler = new Handler(Looper.getMainLooper());
        final boolean[] cancelled = {false};

        AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());
        builder.setTitle(R.string.exporting);
        builder.setMessage(R.string.export_in_progress);
        builder.setNegativeButton(android.R.string.cancel, (dialog, which) -> {
            Log.i(TAG, "Abort HAR export");
            cancelled[0] = true;
            executor.shutdownNow();
        });

        mAlertDialog = builder.create();
        mAlertDialog.setCanceledOnTouchOutside(false);
        mAlertDialog.show();

        mAlertDialog.setOnCancelListener(dialog -> {
            Log.i(TAG, "Abort HAR export (back button)");
            cancelled[0] = true;
            executor.shutdownNow();
        });
        mAlertDialog.setOnDismissListener(dialog -> mAlertDialog = null);

        final Uri harFname = mHarFname;
        mHarFname = null;

        executor.execute(() -> {
            boolean success = false;

            try {
                OutputStream stream = requireActivity().getContentResolver().openOutputStream(harFname, "rwt");

                if(stream != null) {
                    HarWriter writer = new HarWriter(requireContext(), requests);
                    writer.write(stream);
                    stream.close();
                    success = true;
                }
            } catch (IOException e) {
                if(!cancelled[0])
                    e.printStackTrace();
            }

            if(cancelled[0])
                return;

            final boolean result = success;
            final Utils.UriStat stat = result ? Utils.getUriStat(requireContext(), harFname) : null;

            handler.post(() -> {
                if(mAlertDialog != null)
                    mAlertDialog.dismiss();

                if(result) {
                    if(stat != null) {
                        String msg = String.format(getString(R.string.file_saved_with_name), stat.name);
                        Toast.makeText(requireContext(), msg, Toast.LENGTH_SHORT).show();
                    } else
                        Utils.showToast(requireContext(), R.string.save_ok);
                } else
                    Utils.showToast(requireContext(), R.string.cannot_write_file);

                if(mActionMode != null)
                    mActionMode.finish();
            });
        });
    }

    private void harFileResult(final ActivityResult result) {
        if((result.getResultCode() == Activity.RESULT_OK) && (result.getData() != null)) {
            mHarFname = result.getData().getData();
            exportHttpLogHar();
        } else {
            mHarFname = null;
        }
    }

    private void startSelectionMode(int position) {
        if(mActionMode != null)
            return;

        mActionMode = ((AppCompatActivity) requireActivity()).startSupportActionMode(mActionModeCallback);
        mAdapter.selectItem(position);
        updateActionModeTitle();
    }

    private void toggleSelection(int pos) {
        mAdapter.toggleSelection(pos);

        if(mAdapter.getSelectedCount() == 0) {
            if(mActionMode != null)
                mActionMode.finish();
        } else
            updateActionModeTitle();
    }

    private void updateActionModeTitle() {
        if(mActionMode != null)
            mActionMode.setTitle(getString(R.string.n_selected, mAdapter.getSelectedCount()));
    }

    private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
        @Override
        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            mode.getMenuInflater().inflate(R.menu.http_log_cab, menu);
            return true;
        }

        @Override
        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            return false;
        }

        @Override
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            int id = item.getItemId();

            if(id == R.id.select_all) {
                if(mAdapter.getSelectedCount() == mAdapter.getItemCount())
                    mode.finish();
                else {
                    mAdapter.selectAll();
                    updateActionModeTitle();
                }
                return true;
            } else if(id == R.id.save) {
                openFileSelector();
                return true;
            } else if(id == R.id.save_as_har) {
                openHarFileSelector();
                return true;
            }

            return false;
        }

        @Override
        public void onDestroyActionMode(ActionMode mode) {
            mAdapter.clearSelection();
            mActionMode = null;
        }
    };

    public void clearFilters() {
        if(mAdapter != null) {
            mAdapter.mFilter = new HttpLogFilterDescriptor();
            mAdapter.refreshFilteredItems();
            refreshActiveFilter();
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/HttpPayloadFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.HttpLog;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.ConnectionDetailsActivity;
import com.emanuelef.remote_capture.activities.HttpDetailsActivity;
import com.emanuelef.remote_capture.adapters.PayloadAdapter;
import com.emanuelef.remote_capture.model.Prefs;
import com.emanuelef.remote_capture.views.EmptyRecyclerView;

public class HttpPayloadFragment extends Fragment {
    private static final String TAG = "ConnectionPayload";
    private HttpDetailsActivity mActivity;
    private HttpLog.HttpRequest mHttpReq;
    private PayloadAdapter mAdapter;
    private EmptyRecyclerView mRecyclerView;

    public static HttpPayloadFragment newInstance(int req_pos, boolean show_reply) {
        HttpPayloadFragment fragment = new HttpPayloadFragment();
        Bundle args = new Bundle();
        args.putSerializable("show_reply", show_reply);
        args.putInt("req_pos", req_pos);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);

        mActivity = (HttpDetailsActivity) context;

        if (mAdapter != null)
            mAdapter.setExportPayloadHandler(mActivity);
    }

    @Override
    public void onDetach() {
        super.onDetach();
        mActivity = null;

        if (mAdapter != null)
            mAdapter.setExportPayloadHandler(null);
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.connection_payload, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        Bundle args = getArguments();
        assert args != null;

        HttpLog httpLog = CaptureService.getHttpLog();
        if (httpLog == null) {
            mActivity.finish();
            return;
        }

        mHttpReq = httpLog.getRequest(args.getInt("req_pos"));
        if(mHttpReq == null) {
            Utils.showToast(requireContext(), R.string.item_not_found);
            mActivity.finish();
            return;
        }

        mRecyclerView = view.findViewById(R.id.payload);
        EmptyRecyclerView.MyLinearLayoutManager layoutMan = new EmptyRecyclerView.MyLinearLayoutManager(requireContext());
        mRecyclerView.setLayoutManager(layoutMan);

        // Add window insets handling to prevent unwanted padding from propagated insets
        ViewCompat.setOnApplyWindowInsetsListener(mRecyclerView, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());
            v.setPadding(0, 0, 0, insets.bottom);

            return WindowInsetsCompat.CONSUMED;
        });
        mRecyclerView.setClipToPadding(false);

        boolean show_reply = args.getBoolean("show_reply");
        mAdapter = new PayloadAdapter(requireContext(), mHttpReq, show_reply);
        mAdapter.setDisplayAsPrintableText(true);
        mAdapter.setExportPayloadHandler(mActivity);

        if (mHttpReq.decryptionError.isEmpty()) {
            // only set adapter after acknowledged (see setMenuVisibility below)
            if (payloadNoticeAcknowledged(PreferenceManager.getDefaultSharedPreferences(requireContext())))
                mRecyclerView.setAdapter(mAdapter);
        } else {
            LinearLayout errorContainer = view.findViewById(R.id.decryption_error_container);
            TextView urlView = view.findViewById(R.id.request_url);
            TextView errorView = view.findViewById(R.id.decryption_error);
            Button showConnectionBtn = view.findViewById(R.id.show_connection_btn);

            urlView.setText(mHttpReq.getProtoAndHost());
            errorView.setText(mHttpReq.decryptionError);
            mRecyclerView.setEmptyView(errorContainer);

            showConnectionBtn.setOnClickListener(v -> {
                Intent intent = new Intent(requireContext(), ConnectionDetailsActivity.class);
                intent.putExtra(ConnectionDetailsActivity.CONN_ID_KEY, mHttpReq.conn.incr_id);
                startActivity(intent);
            });
        }
    }

    @Override
    public void setMenuVisibility(boolean menuVisible) {
        super.setMenuVisibility(menuVisible);

        Context context = getContext();
        if(context == null)
            return;

        Log.d(TAG, "setMenuVisibility : " + menuVisible);
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);

        if(menuVisible && !payloadNoticeAcknowledged(prefs)) {
            AlertDialog dialog = new AlertDialog.Builder(context)
                    .setTitle(R.string.warning)
                    .setMessage(R.string.payload_scams_notice)
                    .setOnCancelListener((d) -> requireActivity().finish())
                    .setNegativeButton(R.string.cancel_action, (d, b) -> requireActivity().finish())
                    .setPositiveButton(R.string.show_data_action, (d, whichButton) -> {
                        mRecyclerView.setAdapter(mAdapter);
                        prefs.edit().putBoolean(Prefs.PREF_PAYLOAD_NOTICE_ACK, true).apply();
                    }).show();

            dialog.setCanceledOnTouchOutside(false);
        }

        if(menuVisible && mActivity != null)
            mActivity.updateMenuVisibility();
    }

    private boolean payloadNoticeAcknowledged(SharedPreferences prefs) {
        return prefs.getBoolean(Prefs.PREF_PAYLOAD_NOTICE_ACK, false);
    }

    public void setDisplayMode(boolean showAsPrintable) {
        mAdapter.setDisplayAsPrintableText(showAsPrintable);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/LogviewFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ScrollView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.ReversedLinesFileReader;
import com.emanuelef.remote_capture.Utils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

public class LogviewFragment extends Fragment {
    private static final String TAG = "LogviewFragment";
    public static final int MAX_LINES = 512;
    private String mLogPath;
    private String mLogText;
    private TextView mLogView;

    public static LogviewFragment newInstance(String path) {
        LogviewFragment fragment = new LogviewFragment();
        Bundle args = new Bundle();
        args.putSerializable("path", path);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.logview_fragment, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        Bundle args = getArguments();
        assert args != null;
        mLogPath = args.getString("path");
        assert(mLogPath != null);

        var scrollView = (ScrollView) view.findViewById(R.id.scrollView);
        ViewCompat.setOnApplyWindowInsetsListener(scrollView, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout());

            v.setPadding(0, 0, 0, insets.bottom);

            return WindowInsetsCompat.CONSUMED;
        });
        scrollView.setClipToPadding(false);

        if(Utils.isTv(view.getContext())) {
            // necessary to make scroll work on TV
            // but disables ability to select and copy the textview contents
            scrollView.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
        }

        mLogView = view.findViewById(R.id.log);
        reloadLog();
    }

    public void reloadLog() {
        try {
            ReversedLinesFileReader reader = new ReversedLinesFileReader(new File(mLogPath), StandardCharsets.US_ASCII);
            StringBuilder builder = new StringBuilder();
            String line;
            int count = 0;

            while(((line = reader.readLine()) != null) && (count < MAX_LINES)) {
                builder.insert(0, "\n");
                builder.insert(0, line);
                count += 1;
            }

            mLogText = builder.toString();
        } catch (IOException e) {
            e.printStackTrace();
            mLogText = "";
        }

        mLogView.setText(!mLogText.isEmpty() ? mLogText : getString(R.string.no_data));
    }

    public String getLog() {
        return mLogText;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/MalwareStatusFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.ConnectionsActivity;
import com.emanuelef.remote_capture.activities.MainActivity;
import com.emanuelef.remote_capture.Blacklists;
import com.emanuelef.remote_capture.model.FilterDescriptor;

public class MalwareStatusFragment extends Fragment implements MenuProvider {
    private static final String TAG = "MalwareStatus";
    private Blacklists mBlacklists;
    private Handler mHandler;
    private ImageView mStatusIcon;
    private TextView mStatus;
    private TextView mNumMalicious;
    private TextView mNumUpToDate;
    private TextView mNumChecked;
    private TextView mLastUpdate;
    private TextView mDomainRules;
    private TextView mIPRules;
    private int mOkColor, mWarnColor, mDangerColor, mTextColor, mGrayColor;

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.malware_detection_status, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        Context ctx = view.getContext();

        mStatus = view.findViewById(R.id.status);
        mHandler = new Handler(Looper.getMainLooper());
        mStatusIcon = view.findViewById(R.id.status_icon);
        View mConnectionsCard = view.findViewById(R.id.show_connections);
        mNumMalicious = view.findViewById(R.id.num_malicious);
        mNumUpToDate = view.findViewById(R.id.num_up_to_date);
        mNumChecked = view.findViewById(R.id.num_checked);
        mLastUpdate = view.findViewById(R.id.last_update);
        mDomainRules = view.findViewById(R.id.num_domain_rules);
        mIPRules = view.findViewById(R.id.num_ip_rules);
        mBlacklists = PCAPdroid.getInstance().getBlacklists();
        mOkColor = ContextCompat.getColor(ctx, R.color.ok);
        mWarnColor = ContextCompat.getColor(ctx, R.color.warning);
        mDangerColor = ContextCompat.getColor(ctx, R.color.danger);
        mGrayColor = ContextCompat.getColor(ctx, R.color.lightGray);
        mTextColor = ContextCompat.getColor(ctx, R.color.highContrast);

        mConnectionsCard.setOnClickListener(v -> {
            FilterDescriptor filter = new FilterDescriptor();
            filter.onlyBlacklisted = true;

            Intent intent = new Intent(requireContext(), ConnectionsActivity.class)
                    .putExtra(ConnectionsFragment.FILTER_EXTRA, filter);
            startActivity(intent);
        });
    }

    @Override
    public void onResume() {
        super.onResume();
        updateStatus();
    }

    @Override
    public void onPause() {
        super.onPause();
        mHandler.removeCallbacksAndMessages(null);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.docs_menu, menu);
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        int id = item.getItemId();

        if(id == R.id.user_guide) {
            Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(MainActivity.MALWARE_DETECTION_DOCS_URL));
            Utils.startActivity(requireContext(), browserIntent);
            return true;
        }

        return false;
    }

    private void updateStatus() {
        Context ctx = requireContext();
        ConnectionsRegister reg = CaptureService.getConnsRegister();
        boolean is_running = CaptureService.isServiceActive();

        int num_malicious = ((reg != null) ? reg.getNumMaliciousConnections() : 0);
        if(num_malicious > 0) {
            mStatusIcon.setImageResource(R.drawable.ic_exclamation_triangle_solid);
            mStatusIcon.setColorFilter(mDangerColor);
            mStatus.setText(R.string.malware_status_detected);
        } else {
            if(!is_running) {
                mStatusIcon.setImageResource(R.drawable.ic_bug);
                mStatusIcon.setColorFilter(mGrayColor);
                mStatus.setText(R.string.capture_not_running_status);
            } else if(mBlacklists.isUpdateInProgress()) {
                mStatusIcon.setImageResource(R.drawable.ic_exclamation_triangle_solid);
                mStatusIcon.setColorFilter(mGrayColor);
                mStatus.setText(R.string.status_updating);
            } else if(mBlacklists.getNumUpdatedBlacklists() < mBlacklists.getNumBlacklists()) {
                mStatusIcon.setImageResource(R.drawable.ic_exclamation_triangle_solid);
                mStatusIcon.setColorFilter(mWarnColor);
                mStatus.setText(R.string.malware_status_update_failed);
            } else if(CaptureService.isDNSEncrypted()) {
                mStatusIcon.setImageResource(R.drawable.ic_exclamation_triangle_solid);
                mStatusIcon.setColorFilter(mWarnColor);
                mStatus.setText(R.string.private_dns_hinders_detection);
            } else {
                mStatusIcon.setImageResource(R.drawable.ic_check_solid);
                mStatusIcon.setColorFilter(mOkColor);
                mStatus.setText(R.string.malware_status_ok);
            }
        }

        mNumMalicious.setText(Utils.formatIntShort(num_malicious));
        if(num_malicious > 0)
            mNumMalicious.setTextColor(mDangerColor);
        else
            mNumMalicious.setTextColor(mTextColor);

        mNumUpToDate.setText(String.format(Utils.getPrimaryLocale(ctx), "%d/%d",
                mBlacklists.getNumUpdatedBlacklists(), mBlacklists.getNumBlacklists()));
        if(is_running && (mBlacklists.getNumUpdatedBlacklists() < mBlacklists.getNumBlacklists()))
            mNumUpToDate.setTextColor(mWarnColor);
        else
            mNumUpToDate.setTextColor(mTextColor);

        mNumChecked.setText(Utils.formatIntShort(CaptureService.getNumCheckedMalwareConnections()));
        mLastUpdate.setText(Utils.formatEpochMin(ctx, mBlacklists.getLastUpdate() / 1000));
        mDomainRules.setText(Utils.formatIntShort(mBlacklists.getNumLoadedDomainRules()));
        mIPRules.setText(Utils.formatIntShort(mBlacklists.getNumLoadedIPRules()));

        // Periodic update
        mHandler.postDelayed(this::updateStatus, 1000);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/StatusFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-24 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.text.method.LinkMovementMethod;
import android.util.Pair;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.SwitchCompat;
import androidx.core.content.ContextCompat;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.MitmReceiver;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.activities.AppFilterActivity;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.AppState;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.MainActivity;
import com.emanuelef.remote_capture.interfaces.AppStateListener;
import com.emanuelef.remote_capture.model.Prefs;
import com.emanuelef.remote_capture.model.CaptureStats;
import com.emanuelef.remote_capture.views.PrefSpinner;

import java.util.ArrayList;
import java.util.Set;

public class StatusFragment extends Fragment implements AppStateListener, MenuProvider {
    private static final String TAG = "StatusFragment";
    private Menu mMenu;
    private MenuItem mStartBtn;
    private MenuItem mStopBtn;
    private MenuItem mOpenPcap;
    private MenuItem mDecryptPcap;
    private ImageView mFilterIcon;
    private MenuItem mMenuSettings;
    private TextView mInterfaceInfo;
    private View mCollectorInfoLayout;
    private TextView mCollectorInfoText;
    private ImageView mCollectorInfoIcon;
    private TextView mCaptureStatus;
    private View mQuickSettings;
    private MainActivity mActivity;
    private SharedPreferences mPrefs;
    private TextView mFilterDescription;
    private SwitchCompat mAppFilterSwitch;
    private Set<String> mAppFilter;
    private TextView mFilterRootDecryptionWarning;

    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);
        mActivity = (MainActivity) context;
    }

    @Override
    public void onDetach() {
        super.onDetach();
        mActivity.setAppStateListener(null);
        mActivity = null;
    }

    @Override
    public void onResume() {
        super.onResume();

        CaptureService.checkAlwaysOnVpnActivated();
        refreshStatus();
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.status, container, false);
    }

    @SuppressLint("ClickableViewAccessibility")
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        mInterfaceInfo = view.findViewById(R.id.interface_info);
        mCollectorInfoLayout = view.findViewById(R.id.collector_info_layout);
        mCollectorInfoText = mCollectorInfoLayout.findViewById(R.id.collector_info_text);
        mCollectorInfoIcon = mCollectorInfoLayout.findViewById(R.id.collector_info_icon);
        mCaptureStatus = view.findViewById(R.id.status_view);
        mQuickSettings = view.findViewById(R.id.quick_settings);
        mFilterRootDecryptionWarning = view.findViewById(R.id.app_filter_root_decryption_warning);
        mPrefs = PreferenceManager.getDefaultSharedPreferences(mActivity);
        mAppFilter = Prefs.getAppFilter(mPrefs);

        PrefSpinner.init(view.findViewById(R.id.dump_mode_spinner),
                R.array.pcap_dump_modes, R.array.pcap_dump_modes_labels, R.array.pcap_dump_modes_descriptions,
                Prefs.PREF_PCAP_DUMP_MODE, Prefs.DEFAULT_DUMP_MODE);

        mAppFilterSwitch = view.findViewById(R.id.app_filter_switch);
        View filterRow = view.findViewById(R.id.app_filter_text);
        TextView filterTitle = filterRow.findViewById(R.id.title);
        mFilterDescription = filterRow.findViewById(R.id.description);
        mFilterIcon = filterRow.findViewById(R.id.icon);

        filterTitle.setText(R.string.target_apps);

        mAppFilterSwitch.setOnClickListener((buttonView) -> {
            mAppFilterSwitch.setChecked(!mAppFilterSwitch.isChecked());
            openAppFilterSelector();
        });

        refreshFilterInfo();

        mCaptureStatus.setOnClickListener(v -> {
            if(mActivity.getState() == AppState.ready)
                mActivity.startCapture();
        });

        // Register for updates
        MitmReceiver.observeStatus(this, status -> refreshDecryptionStatus());
        CaptureService.observeStats(this, this::onStatsUpdate);

        // Make URLs clickable
        mCollectorInfoText.setMovementMethod(LinkMovementMethod.getInstance());

        /* Important: call this after all the fields have been initialized */
        mActivity.setAppStateListener(this);
        refreshStatus();
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater menuInflater) {
        menuInflater.inflate(R.menu.main_menu, menu);

        mMenu = menu;
        mStartBtn = mMenu.findItem(R.id.action_start);
        mStopBtn = mMenu.findItem(R.id.action_stop);
        mMenuSettings = mMenu.findItem(R.id.action_settings);
        mOpenPcap = mMenu.findItem(R.id.open_pcap);
        mDecryptPcap = mMenu.findItem(R.id.decrypt_pcap);
        mDecryptPcap.setVisible(PCAPdroid.getInstance().isUsharkAvailable());
        refreshStatus();
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem item) {
        return false;
    }

    private void recheckFilterWarning() {
        boolean hasFilter = ((mAppFilter != null) && (!mAppFilter.isEmpty()));

        mFilterRootDecryptionWarning.setVisibility((Prefs.getTlsDecryptionEnabled(mPrefs) &&
                Prefs.isRootCaptureEnabled(mPrefs)
                && !hasFilter) ? View.VISIBLE : View.GONE);
    }

    private void refreshDecryptionStatus() {
        MitmReceiver.Status proxy_status = CaptureService.getMitmProxyStatus();
        Context ctx = getContext();

        if((proxy_status == MitmReceiver.Status.START_ERROR) && (ctx != null))
            Utils.showToastLong(ctx, R.string.mitm_addon_error);

        mInterfaceInfo.setText((proxy_status == MitmReceiver.Status.RUNNING) ? R.string.mitm_addon_running : R.string.mitm_addon_starting);
    }

    private void refreshFilterInfo() {
        Context context = getContext();
        if(context == null)
            return;

        if((mAppFilter == null) || (mAppFilter.isEmpty())) {
            mFilterDescription.setText(R.string.capture_all_apps);
            mFilterIcon.setVisibility(View.GONE);
            mAppFilterSwitch.setChecked(false);
            return;
        }

        mAppFilterSwitch.setChecked(true);

        Pair<String, Drawable> pair = getAppFilterTextAndIcon(context);

        mFilterDescription.setText(pair.first);

        if (pair.second != null) {
            mFilterIcon.setImageDrawable(pair.second);
            mFilterIcon.setVisibility(View.VISIBLE);
        }
    }

    private void onStatsUpdate(CaptureStats stats) {
        Log.d("MainReceiver", "Got StatsUpdate: bytes_sent=" + stats.pkts_sent + ", bytes_rcvd=" +
                stats.bytes_rcvd + ", pkts_sent=" + stats.pkts_sent + ", pkts_rcvd=" + stats.pkts_rcvd);
        mCaptureStatus.setText(Utils.formatBytes(stats.bytes_sent + stats.bytes_rcvd));
    }

    private Pair<String, Drawable> getAppFilterTextAndIcon(@NonNull Context context) {
        Drawable icon = null;
        String text = "";

        if((mAppFilter != null) && (!mAppFilter.isEmpty())) {
            if (mAppFilter.size() == 1) {
                // only a single app is selected, show its image and text
                String package_name = mAppFilter.iterator().next();
                AppDescriptor app = AppsResolver.resolveInstalledApp(requireContext().getPackageManager(), package_name, 0);

                if((app != null) && (app.getIcon() != null)) {
                    icon = app.getIcon();
                    text = app.getName() + " (" + app.getPackageName() + ")";
                }
            } else {
                // multiple apps, show default icon and comprehensive text
                icon = ContextCompat.getDrawable(context, R.drawable.ic_image);
                ArrayList<String> parts = new ArrayList<>();

                for (String package_name: mAppFilter) {
                    AppDescriptor app = AppsResolver.resolveInstalledApp(requireContext().getPackageManager(), package_name, 0);
                    String tmp = package_name;

                    if (app != null)
                        tmp = app.getName();

                    parts.add(tmp);
                }

                text = Utils.shorten(String.join(", ", parts), 48);
            }
        }

        return new Pair<>(text, icon);
    }

    private void refreshPcapDumpInfo(Context context) {
        String info = "";

        Prefs.DumpMode mode = CaptureService.getDumpMode();

        switch (mode) {
        case NONE:
            info = getString(R.string.no_dump_info);
            break;
        case HTTP_SERVER:
            info = String.format(getResources().getString(R.string.http_server_status),
                    Utils.getLocalIPAddress(mActivity), CaptureService.getHTTPServerPort());
            break;
        case PCAP_FILE:
            info = getString(R.string.pcap_file_info);

            String pcapFname = CaptureService.getPcapFname();
            if(pcapFname != null)
                info = pcapFname;
            break;
        case UDP_EXPORTER:
            info = String.format(getResources().getString(R.string.collector_info),
                    CaptureService.getCollectorAddress(), CaptureService.getCollectorPort());
            break;
        case TCP_EXPORTER:
            info = String.format(getResources().getString(R.string.tcp_collector_info),
                    CaptureService.getCollectorAddress(), CaptureService.getCollectorPort());
            break;
        }

        mCollectorInfoText.setText(info);

        // Check if a filter is set
        Drawable drawable = null;
        if((mAppFilter != null) && (!mAppFilter.isEmpty())) {
            Pair<String, Drawable> pair = getAppFilterTextAndIcon(context);
            drawable = pair.second;
        }

        if (drawable != null) {
            mCollectorInfoIcon.setImageDrawable(drawable);
            mCollectorInfoIcon.setVisibility(View.VISIBLE);
        } else
            mCollectorInfoIcon.setVisibility(View.GONE);
    }

    @Override
    public void appStateChanged(AppState state) {
        Context context = getContext();
        if(context == null)
            return;

        if(mMenu != null) {
            if((state == AppState.running) || (state == AppState.stopping)) {
                mStartBtn.setVisible(false);
                mStopBtn.setEnabled(true);
                mStopBtn.setVisible(!CaptureService.isAlwaysOnVPN());
                mMenuSettings.setEnabled(false);
                mOpenPcap.setEnabled(false);
                mDecryptPcap.setEnabled(false);
            } else { // ready || starting
                mStopBtn.setVisible(false);
                mStartBtn.setEnabled(true);
                mStartBtn.setVisible(!CaptureService.isAlwaysOnVPN());
                mMenuSettings.setEnabled(true);
                mOpenPcap.setEnabled(true);
                mDecryptPcap.setEnabled(true);
            }
        }

        switch(state) {
            case ready:
                mCaptureStatus.setText(R.string.ready);
                mCollectorInfoLayout.setVisibility(View.GONE);
                mInterfaceInfo.setVisibility(View.GONE);
                mQuickSettings.setVisibility(View.VISIBLE);
                mAppFilter = Prefs.getAppFilter(mPrefs);
                refreshFilterInfo();
                break;
            case starting:
                if(mMenu != null)
                    mStartBtn.setEnabled(false);
                break;
            case stopping:
                if(mMenu != null)
                    mStopBtn.setEnabled(false);
                break;
            case running:
                mCaptureStatus.setText(Utils.formatBytes(CaptureService.getBytes()));
                mCollectorInfoLayout.setVisibility(View.VISIBLE);
                mQuickSettings.setVisibility(View.GONE);
                CaptureService service = CaptureService.requireInstance();

                if(CaptureService.isDecryptingTLS()) {
                    refreshDecryptionStatus();
                    mInterfaceInfo.setVisibility(View.VISIBLE);
                } else if(CaptureService.isCapturingAsRoot()) {
                    String capiface = service.getCaptureInterface();

                    if(capiface.equals("@inet"))
                        capiface = getString(R.string.internet);
                    else if(capiface.equals("any"))
                        capiface = getString(R.string.all_interfaces);

                    mInterfaceInfo.setText(String.format(getResources().getString(R.string.capturing_from), capiface));
                    mInterfaceInfo.setVisibility(View.VISIBLE);
                } else if(service.getSocks5Enabled() == 1) {
                    mInterfaceInfo.setText(String.format(getResources().getString(R.string.socks5_info),
                            service.getSocks5ProxyAddress(), service.getSocks5ProxyPort()));
                    mInterfaceInfo.setVisibility(View.VISIBLE);
                } else
                    mInterfaceInfo.setVisibility(View.GONE);

                mAppFilter = CaptureService.getAppFilter();
                refreshPcapDumpInfo(context);
                break;
            default:
                break;
        }
    }

    private void refreshStatus() {
        if(mActivity != null)
            appStateChanged(mActivity.getState());
        recheckFilterWarning();
    }

    private void openAppFilterSelector() {
        Intent intent = new Intent(requireContext(), AppFilterActivity.class);
        startActivity(intent);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/mitmwizard/Done.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.mitmwizard;

import android.os.Bundle;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.MitmAddon;
import com.emanuelef.remote_capture.R;

public class Done extends StepFragment {
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        mStepLabel.setText(R.string.mitm_setup_wizard_done);

        MitmAddon.setDecryptionSetupDone(requireContext(), true);
        nextStep(0);
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/fragments/mitmwizard/InstallAddon.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.mitmwizard;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import android.view.View;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.MitmAddon;
import com.emanuelef.remote_capture.Utils;

public class InstallAddon extends StepFragment {
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        Utils.setTextUrls(mStepLabel, R.string.install_the_mitm_addon, MitmAddon.REPOSITORY);

        String new_ver = MitmAddon.getNewVersionAvailable(requireContext());
        if(new_ver.isEmpty() && MitmAddon.isInstalled(requireContext()))
            addonOk();
        else
            installAddon(new_ver);
    }

    @Override
    public void onResume() {
        super.onResume();

        if(MitmAddon.getNewVersionAvailable(requireContext()).isEmpty() &&
                MitmAddon.isInstalled(requireContext()))
            addonOk();
    }

    private void addonOk() {
        nextStep(R.id.navto_install_cert);
    }

    private void installAddon(String new_ver) {
        String installed_ver = MitmAddon.getInstalledVersionName(requireContext());

        if(installed_ver.isEmpty()) {
            mStepLabel.setText(R.string.install_the_mitm_addon);
            mStepButton.setText(R.string.install_action);
        } else if(Utils.isSemanticVersionCompatible(installed_ver, new_ver)) {
            mStepLabel.setText(R.string.mitm_addon_update_available);
            mStepButton.setText(R.string.update_action);
            showSkipButton(view -> gotoStep(R.id.navto_install_cert));
        } else if(MitmAddon.getInstalledVersion(requireContext()) < MitmAddon.PACKAGE_VERSION_CODE) {
            mStepLabel.setText(R.string.mitm_addon_new_version);
            mStepButton.setText(R.string.update_action);
        } else {
            mStepLabel.setText(getString(R.string.mitm_addon_bad_version, MitmAddon.PACKAGE_VERSION_NAME));
            mStepIcon.setColorFilter(mDangerColor);
            mStepButton.setText(R.string.install_action);
            mStepButton.setEnabled(false);
            return;
        }

        mStepButton.setOnClickListener(v -> {
            String target_ver = new_ver.isEmpty() ? MitmAddon.PACKAGE_VERSION_NAME : new_ver;

            Intent browserIntent = new Intent(Intent.ACTION_VIEW,
                    Uri.parse(MitmAddon.getGithubReleaseUrl(target_ver)));
            Utils.startActivity(requireContext(), browserIntent);
        });
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/mitmwizard/InstallCertificate.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.mitmwizard;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.security.KeyChain;
import android.view.View;
import android.widget.Toast;

import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.interfaces.MitmListener;
import com.emanuelef.remote_capture.MitmAddon;
import com.pcapdroid.mitm.MitmAPI;

import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.security.cert.X509Certificate;

public class InstallCertificate extends StepFragment implements MitmListener {
    private static final String TAG = "InstallCertificate";
    private MitmAddon mAddon;
    private String mCaPem;
    private X509Certificate mCaCert;
    private boolean mFallbackExport;

    private final ActivityResultLauncher<Intent> certExportLauncher =
            registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), this::certExportResult);
    private final ActivityResultLauncher<Intent> certInstallLauncher =
            registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), this::certInstallResult);

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        mStepLabel.setText(R.string.checking_the_certificate);
        mStepButton.setText(canInstallCertViaIntent() ? R.string.install_action : R.string.export_action);
        mStepButton.setEnabled(false);

        showSkipButton(view1 -> new AlertDialog.Builder(view1.getContext())
                .setTitle(R.string.warning)
                .setMessage(R.string.mitm_skip_notice)
                .setNegativeButton(R.string.cancel_action, (dialogInterface, i) -> {})
                .setPositiveButton(R.string.app_intro_skip_button, (d, whichButton) -> {
                    MitmAddon.setCAInstallationSkipped(requireContext(), true);
                    gotoStep(R.id.navto_done);
                })
                .show());
        mAddon = new MitmAddon(requireContext(), this);
    }

    @Override
    public void onDestroyView() {
        mAddon.disconnect();
        super.onDestroyView();
    }

    @Override
    public void onResume() {
        if(!Utils.isCAInstalled(mCaCert)) {
            if(!mAddon.isConnected()) {
                if (!mAddon.connect(0)) {
                    new AlertDialog.Builder(requireContext())
                            .setTitle(R.string.error)
                            .setMessage(R.string.mitm_addon_autostart_workaround)
                            .setNegativeButton(R.string.no, (dialogInterface, i) -> {
                                Toast.makeText(requireContext(), "addon connect failed", Toast.LENGTH_LONG).show();
                                certFail();
                            })
                            .setPositiveButton(R.string.yes, (d, whichButton) -> {
                                Context ctx = requireContext();
                                Intent launchIntent = ctx.getPackageManager().getLaunchIntentForPackage(MitmAPI.PACKAGE_NAME);
                                if (launchIntent != null)
                                    Utils.startActivity(ctx, launchIntent);
                                else {
                                    Toast.makeText(requireContext(), "addon connect failed", Toast.LENGTH_LONG).show();
                                    certFail();
                                }
                            }).show();
                }
            }
        } else
            certOk();

        super.onResume();
    }

    private void certOk() {
        mStepLabel.setText(R.string.cert_installed_correctly);
        MitmAddon.setCAInstallationSkipped(requireContext(), false);
        nextStep(R.id.navto_done);
    }

    private void certFail() {
        mStepLabel.setText(R.string.ca_cert_export_failed);
        Utils.setTextUrls(mStepLabel, R.string.ca_cert_export_failed, "https://dontkillmyapp.com/xiaomi#app-battery-saver");
        mStepIcon.setColorFilter(mDangerColor);
        MitmAddon.setDecryptionSetupDone(requireContext(), false);
    }

    private boolean canInstallCertViaIntent() {
        // On Android < 11, an intent can be used for cert installation
        // On Android 11+, users must manually install the certificate from the settings
        return((Build.VERSION.SDK_INT < Build.VERSION_CODES.R) && !mFallbackExport);
    }

    private void fallbackToCertExport() {
        // If there are problems with the cert installation via Intent, fallback to export+install
        mFallbackExport = true;
        onMitmGetCaCertificateResult(mCaPem);
    }

    private void exportCaCertificate() {
        String fname = "PCAPdroid_CA.crt";
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("application/x-x509-ca-cert");
        intent.putExtra(Intent.EXTRA_TITLE, fname);

        if(!Utils.launchFileDialog(requireContext(), intent, certExportLauncher))
            certFail();
    }

    private void installCaCertificate() {
        Intent intent = KeyChain.createInstallIntent();
        intent.putExtra(KeyChain.EXTRA_NAME, "PCAPdroid CA");
        intent.putExtra(KeyChain.EXTRA_CERTIFICATE, mCaPem.getBytes(StandardCharsets.UTF_8));

        try {
            certInstallLauncher.launch(intent);
        } catch (ActivityNotFoundException e) {
            Utils.showToastLong(requireContext(), R.string.no_intent_handler_found);
            fallbackToCertExport();
        }
    }

    private void certExportResult(final ActivityResult result) {
        if((result.getResultCode() == Activity.RESULT_OK) && (result.getData() != null)) {
            Context ctx = requireContext();
            Uri cert_uri = result.getData().getData();
            boolean written = false;

            try(PrintWriter writer = new PrintWriter(ctx.getContentResolver().openOutputStream(cert_uri, "rwt"))) {
                writer.print(mCaPem);
                written = true;
            } catch (IOException e) {
                e.printStackTrace();
            }

            if(written)
                Utils.showToastLong(ctx, R.string.cert_exported_now_installed);
        }
    }

    private void certInstallResult(final ActivityResult result) {
        if((result.getResultCode() == Activity.RESULT_OK) && Utils.isCAInstalled(mCaCert))
            certOk();
        else
            fallbackToCertExport();
    }

    @Override
    public void onMitmGetCaCertificateResult(@Nullable String ca_pem) {
        mAddon.disconnect();

        // NOTE: this may be called when context is null
        Context context = getContext();
        if(context == null) {
            Log.d(TAG, "null context");
            return;
        }

        mCaPem = ca_pem;

        // NOTE: onMitmGetCaCertificateResult can be called by fallbackToCertExport
        mStepButton.setText(canInstallCertViaIntent() ? R.string.install_action : R.string.export_action);

        if(mCaPem != null) {
            Log.d(TAG, "Got certificate");
            //Log.d(TAG, "certificate: " + cert_str);
            mCaCert = Utils.x509FromPem(mCaPem);

            if(mCaCert != null) {
                if(Utils.isCAInstalled(mCaCert))
                    certOk();
                else {
                    // Cert not installed
                    MitmAddon.setDecryptionSetupDone(context, false);
                    mStepIcon.setColorFilter(mWarnColor);
                    mStepButton.setEnabled(true);

                    if(canInstallCertViaIntent())
                        mStepLabel.setText(R.string.install_ca_certificate);
                    else
                        mStepLabel.setText(R.string.export_ca_certificate);

                    mStepButton.setOnClickListener((v) -> {
                        if(canInstallCertViaIntent())
                            installCaCertificate();
                        else
                            exportCaCertificate();
                    });
                }
            } else {
                Toast.makeText(context, "addon did not return certificate", Toast.LENGTH_LONG).show();
                certFail();
            }
        }
    }

    @Override
    public void onMitmServiceConnect() {
        Context ctx = getContext();
        if(ctx == null)
            return;

        if(!mAddon.requestCaCertificate()) {
            Toast.makeText(ctx, "requestCaCertificate failed", Toast.LENGTH_LONG).show();
            certFail();
        }
    }

    @Override
    public void onMitmServiceDisconnect() {
        Context ctx = getContext();
        if(ctx == null)
            return;

        if(mCaPem == null) {
            Toast.makeText(ctx, "addon disconnected", Toast.LENGTH_LONG).show();
            certFail();
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/mitmwizard/Intro.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.mitmwizard;

import android.os.Bundle;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.activities.MainActivity;

public class Intro extends StepFragment {
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        mStepIcon.setVisibility(View.GONE);
        Utils.setTextUrls(mStepLabel, R.string.mitm_setup_wizard_intro, MainActivity.TLS_DECRYPTION_DOCS_URL);

        nextStep(R.id.navto_install_addon);
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/fragments/mitmwizard/StepFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.mitmwizard;

import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.content.res.AppCompatResources;
import androidx.core.content.ContextCompat;
import androidx.fragment.app.Fragment;
import androidx.navigation.NavController;
import androidx.navigation.Navigation;

import com.emanuelef.remote_capture.R;

public class StepFragment extends Fragment {
    protected TextView mStepLabel;
    protected ImageView mStepIcon;
    protected Button mStepButton;
    protected Button mSkipButton;
    protected NavController mNavController;
    protected int mOkColor;
    protected int mWarnColor;
    protected int mDangerColor;

    public StepFragment() {}

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_mitm_wizard, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        mNavController = Navigation.findNavController(view);

        mStepLabel = view.findViewById(R.id.step_label);
        mStepIcon = view.findViewById(R.id.step_status);
        mStepButton = view.findViewById(R.id.step_button);
        mSkipButton = view.findViewById(R.id.skip_button);

        Context ctx = requireContext();
        mOkColor = ContextCompat.getColor(ctx, R.color.ok);
        mWarnColor = ContextCompat.getColor(ctx, R.color.warning);
        mDangerColor = ContextCompat.getColor(ctx, R.color.danger);
    }

    protected void gotoStep(int action_or_dest) {
        boolean is_last_step = (action_or_dest <= 0);

        if(!is_last_step)
            mNavController.navigate(action_or_dest);
        else
            requireActivity().finish();
    }

    protected void nextStep(int action_or_dest) {
        Context ctx = requireContext();
        boolean is_last_step = (action_or_dest <= 0);
        mStepIcon.setImageDrawable(AppCompatResources.getDrawable(ctx, R.drawable.ic_check_solid));
        mStepIcon.setColorFilter(mOkColor);

        mSkipButton.setVisibility(View.GONE);
        mStepButton.setEnabled(true);
        mStepButton.setText(!is_last_step ? R.string.app_intro_next_button : R.string.app_intro_done_button);
        mStepButton.setOnClickListener((view) -> gotoStep(action_or_dest));
    }

    protected void showSkipButton(View.OnClickListener l) {
        mSkipButton.setVisibility(View.VISIBLE);
        mSkipButton.setOnClickListener(l);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/prefs/DnsSettings.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.prefs;
import android.os.Bundle;

import androidx.annotation.Nullable;
import androidx.preference.EditTextPreference;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.Prefs;

import java.util.Objects;

public class DnsSettings extends SettingsSubFragment {
    @Override
    public void onCreatePreferences(@Nullable Bundle savedInstanceState, @Nullable String rootKey) {
        setPreferencesFromResource(R.xml.dns_preferences, rootKey);

        EditTextPreference p1 = Objects.requireNonNull(findPreference(Prefs.PREF_DNS_SERVER_V4));
        p1.setOnPreferenceChangeListener((preference, newValue) -> Utils.validateIpv4Address(newValue.toString()));

        EditTextPreference p2 = Objects.requireNonNull(findPreference(Prefs.PREF_DNS_SERVER_V6));
        p2.setOnPreferenceChangeListener((preference, newValue) -> {
            String ip = newValue.toString();
            return !ip.equals("::") && Utils.validateIpv6Address(ip);
        });
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/prefs/GeoipSettings.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.prefs;
import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.preference.Preference;

import com.emanuelef.remote_capture.Geolocation;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;

import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class GeoipSettings extends SettingsSubFragment {
    private static final String TAG = "GeoipSettings";
    private Preference mStatus;
    private Preference mDelete;
    private AlertDialog mAlertDialog;

    @Override
    public void onCreatePreferences(@Nullable Bundle savedInstanceState, @Nullable String rootKey) {
        setPreferencesFromResource(R.xml.geoip_preferences, rootKey);
        Context context = requireContext();

        mStatus = requirePreference("status");
        mDelete = requirePreference("delete");
        refreshStatus(context);

        mDelete.setOnPreferenceClickListener(preference -> {
            Geolocation.deleteDb(context);
            refreshStatus(context);
            return true;
        });

        requirePreference("download")
                .setOnPreferenceClickListener(preference -> {
            downloadDatabases();
            return true;
        });
    }

    @Override
    public void onDestroyView() {
        // See https://stackoverflow.com/questions/22924825/view-not-attached-to-window-manager-crash
        if(mAlertDialog != null)
            mAlertDialog.dismiss();

        super.onDestroyView();
    }

    // NOTE: passing explicit context as this may be called when requireContext would return null
    private void refreshStatus(Context context) {
        Date builtDate = Geolocation.getDbDate(context);
        if(builtDate != null) {
            String dateStr = Utils.formatEpochFull(context, builtDate.getTime() / 1000);
            mStatus.setSummary("DB-IP Lite free\n" +
                    String.format(context.getString(R.string.built_on), dateStr) + "\n" +
                    String.format(context.getString(R.string.size_x), Utils.formatBytes(Geolocation.getDbSize(context))));
            mStatus.setEnabled(true);
        } else {
            mStatus.setSummary(R.string.geo_db_not_found);
            mStatus.setEnabled(false);
        }

        mDelete.setVisible((builtDate != null));
    }

    private void downloadDatabases() {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Handler handler = new Handler(Looper.getMainLooper());

        AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());
        builder.setTitle(R.string.downloading);
        builder.setMessage(R.string.download_in_progress);

        mAlertDialog = builder.create();
        mAlertDialog.setCanceledOnTouchOutside(false);
        mAlertDialog.show();

        mAlertDialog.setOnCancelListener(dialogInterface -> {
            Log.i(TAG, "Abort download");
            executor.shutdownNow();
        });
        mAlertDialog.setOnDismissListener(dialog -> mAlertDialog = null);

        // Hold reference to context to avoid garbage collection before the handler is called
        final Context context = requireContext();
        executor.execute(() -> {
            boolean result = Geolocation.downloadDb(context);

            handler.post(() -> {
                if(!result)
                    Utils.showToastLong(context, R.string.download_failed);

                if(mAlertDialog != null)
                    mAlertDialog.dismiss();
                refreshStatus(context);
            });
        });
    }

    private @NonNull
    <T extends Preference> T requirePreference(String key) {
        T pref = findPreference(key);
        if(pref == null)
            throw new IllegalStateException();
        return pref;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/prefs/PortMapFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.prefs;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.ActionMode;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.ListView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.widget.SwitchCompat;
import androidx.core.view.MenuProvider;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.Lifecycle;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.adapters.PortMappingAdapter;
import com.emanuelef.remote_capture.model.PortMapping;
import com.emanuelef.remote_capture.model.PortMapping.PortMap;
import com.emanuelef.remote_capture.model.Prefs;
import com.google.android.material.textfield.TextInputEditText;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Objects;


public class PortMapFragment extends Fragment implements MenuProvider {
    private static final String TAG = "PortMapFragment";
    private PortMappingAdapter mAdapter;
    private TextView mEmptyText;
    private ListView mListView;
    private PortMapping mPortMap;
    private ArrayList<PortMap> mSelected = new ArrayList<>();

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container, Bundle savedInstanceState) {
        requireActivity().addMenuProvider(this, getViewLifecycleOwner(), Lifecycle.State.RESUMED);
        return inflater.inflate(R.layout.simple_list, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        view.setFitsSystemWindows(true);
        mListView = view.findViewById(R.id.listview);
        mEmptyText = view.findViewById(R.id.list_empty);
        mPortMap = new PortMapping(requireContext());

        mAdapter = new PortMappingAdapter(requireContext(), mPortMap);
        mListView.setAdapter(mAdapter);
        mListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
        mListView.setMultiChoiceModeListener(new AbsListView.MultiChoiceModeListener() {
            @Override
            public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) {
                PortMap item = mAdapter.getItem(position);

                if(checked)
                    mSelected.add(item);
                else
                    mSelected.remove(item);

                mode.setTitle(getString(R.string.n_selected, mSelected.size()));
            }

            @Override
            public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                MenuInflater inflater = requireActivity().getMenuInflater();
                inflater.inflate(R.menu.list_edit_cab, menu);
                return true;
            }

            @Override
            public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                return false;
            }

            @Override
            public boolean onActionItemClicked(ActionMode mode, MenuItem menuItem) {
                int id = menuItem.getItemId();

                if(id == R.id.delete_entry) {
                    confirmDelete(mode);
                    return true;
                } else if(id == R.id.select_all) {
                    if(mSelected.size() >= mAdapter.getCount())
                        mode.finish();
                    else {
                        for(int i=0; i<mAdapter.getCount(); i++) {
                            if(!mListView.isItemChecked(i))
                                mListView.setItemChecked(i, true);
                        }
                    }

                    return true;
                } else
                    return false;
            }

            @Override
            public void onDestroyActionMode(ActionMode mode) {
                mSelected = new ArrayList<>();
            }
        });
        Utils.fixListviewInsetsBottom(mListView);

        recheckListSize();
    }

    private void recheckListSize() {
        mEmptyText.setVisibility((mAdapter.getCount() == 0) ? View.VISIBLE : View.GONE);
    }

    @Override
    public void onCreateMenu(@NonNull Menu menu, MenuInflater menuInflater) {
        menuInflater.inflate(R.menu.port_mapping_menu, menu);

        SwitchCompat toggle = (SwitchCompat) menu.findItem(R.id.toggle_btn).getActionView();
        toggle.setChecked(Prefs.isPortMappingEnabled(PreferenceManager.getDefaultSharedPreferences(requireContext())));
        toggle.setOnCheckedChangeListener((buttonView, isChecked) -> {
            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());

            if(isChecked == Prefs.isPortMappingEnabled(prefs))
                return; // not changed

            Log.d(TAG, "Port mapping is now " + (isChecked ? "enabled" : "disabled"));
            Prefs.setPortMappingEnabled(prefs, isChecked);
        });
    }

    @Override
    public boolean onMenuItemSelected(@NonNull MenuItem menuItem) {
        if(menuItem.getItemId() == R.id.add_mapping) {
            openAddDialog();
            return true;
        }

        return false;
    }

    private void openAddDialog() {
        Context ctx = requireContext();
        LayoutInflater inflater = LayoutInflater.from(ctx);

        View view = inflater.inflate(R.layout.add_port_mapping_dialog, null);

        final String[] protocols = {"TCP", "UDP"};
        ArrayAdapter<String> adapter = new ArrayAdapter<>(ctx, R.layout.dropdown_item, protocols);
        AutoCompleteTextView protoField = (AutoCompleteTextView) view.findViewById(R.id.proto);
        protoField.setText(protocols[0]);
        protoField.setAdapter(adapter);

        ((TextInputEditText) view.findViewById(R.id.redirect_host)).setText("127.0.0.1");

        AlertDialog dialog = new AlertDialog.Builder(ctx)
                .setView(view)
                .setTitle(R.string.port_mapping)
                .setPositiveButton(R.string.add_action, (dialogInterface, i) -> {})
                .setNegativeButton(R.string.cancel_action, (dialogInterface, i) -> {})
                .show();
        dialog.setCanceledOnTouchOutside(false);

        // custom dismiss logic
        dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            .setOnClickListener(v -> {
                PortMap mapping = validateAddDialog(view);
                if(mapping == null)
                    return;

                boolean exists = !mPortMap.add(mapping);
                if(exists)
                    Utils.showToastLong(requireContext(), R.string.port_mapping_exists);
                else {
                    mPortMap.save();
                    mAdapter.add(mapping);
                    recheckListSize();
                }

                dialog.dismiss();
            });
    }

    private PortMap validateAddDialog(View view) {
        TextInputEditText origPortField = (TextInputEditText) view.findViewById(R.id.orig_port);
        TextInputEditText redirectHostField = (TextInputEditText) view.findViewById(R.id.redirect_host);
        TextInputEditText redirectPortField = (TextInputEditText) view.findViewById(R.id.redirect_port);

        String origPort = Objects.requireNonNull(origPortField.getText()).toString();
        String redirectHost = Objects.requireNonNull(redirectHostField.getText()).toString();
        String redirectPort = Objects.requireNonNull(redirectPortField.getText()).toString();
        String proto = ((AutoCompleteTextView) view.findViewById(R.id.proto)).getText().toString();

        if(origPort.isEmpty()) {
            origPortField.setError(getString(R.string.required));
            return null;
        }
        if(!Utils.validatePort(origPort)) {
            origPortField.setError(getString(R.string.invalid));
            return null;
        }

        if(redirectHost.isEmpty()) {
            redirectHostField.setError(getString(R.string.required));
            return null;
        }
        if(!Utils.validateIpAddress(redirectHost) && !Utils.validateHost(redirectHost)) {
            redirectHostField.setError(getString(R.string.invalid));
            return null;
        }

        if(redirectPort.isEmpty()) {
            redirectPortField.setError(getString(R.string.required));
            return null;
        }
        if(!Utils.validatePort(redirectPort)) {
            redirectPortField.setError(getString(R.string.invalid));
            return null;
        }

        return new PortMap(
                proto.equals("TCP") ? 6 : 17, Integer.parseInt(origPort),
                Integer.parseInt(redirectPort), redirectHost);
    }

    private void confirmDelete(ActionMode mode) {
        AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());
        builder.setMessage(R.string.items_delete_confirm);
        builder.setCancelable(true);
        builder.setPositiveButton(R.string.yes, (dialog, which) -> {
            if(mSelected.size() >= mAdapter.getCount()) {
                mAdapter.clear();
                mPortMap.clear();
                mPortMap.save();
            } else {
                for(PortMap item : mSelected)
                    mAdapter.remove(item);
                updateMappingsFromAdapter();
            }

            mode.finish();
            recheckListSize();
        });
        builder.setNegativeButton(R.string.no, (dialog, whichButton) -> {});

        final AlertDialog alert = builder.create();
        alert.setCanceledOnTouchOutside(true);
        alert.show();
    }

    private void updateMappingsFromAdapter() {
        ArrayList<PortMap> toRemove = new ArrayList<>();
        Iterator<PortMap> iter = mPortMap.iter();

        // Remove the mList rules which are not in the adapter dataset
        while(iter.hasNext()) {
            PortMap mapping = iter.next();

            if (mAdapter.getPosition(mapping) < 0)
                toRemove.add(mapping);
        }

        if(toRemove.size() > 0) {
            for(PortMap mapping: toRemove)
                mPortMap.remove(mapping);
            mPortMap.save();
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/prefs/SettingsSubFragment.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-24 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.prefs;

import android.os.Bundle;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.preference.PreferenceFragmentCompat;

import com.emanuelef.remote_capture.interfaces.FragmentViewCreatedListener;

public abstract class SettingsSubFragment extends PreferenceFragmentCompat {
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        // insets handling logic
        view.setFitsSystemWindows(true);

        // fix for missing insets dispatching
        if (getActivity() instanceof FragmentViewCreatedListener)
            ((FragmentViewCreatedListener) requireActivity()).onFragmentViewCreated(view);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/fragments/prefs/Socks5Settings.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2023 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.fragments.prefs;
import android.os.Bundle;
import android.text.InputType;

import androidx.annotation.Nullable;
import androidx.preference.EditTextPreference;
import androidx.preference.SwitchPreference;

import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.model.Prefs;

import java.util.Objects;

public class Socks5Settings extends SettingsSubFragment {
    private EditTextPreference mProxyHost;
    private EditTextPreference mProxyPort;
    private EditTextPreference mUsername;
    private EditTextPreference mPassword;
    private SwitchPreference mSocks5AuthEnabled;

    @Override
    public void onCreatePreferences(@Nullable Bundle savedInstanceState, @Nullable String rootKey) {
        setPreferencesFromResource(R.xml.socks5_preferences, rootKey);

        /* SOCKS5 Proxy IP validation */
        mProxyHost = Objects.requireNonNull(findPreference(Prefs.PREF_SOCKS5_PROXY_IP_KEY));
        mProxyHost.setOnPreferenceChangeListener((preference, newValue) -> Utils.validateHost(newValue.toString()));
        mProxyHost.setOnBindEditTextListener(editText -> editText.setInputType(InputType.TYPE_TEXT_VARIATION_URI));

        /* SOCKS5 Proxy port validation */
        mProxyPort = Objects.requireNonNull(findPreference(Prefs.PREF_SOCKS5_PROXY_PORT_KEY));
        mProxyPort.setOnBindEditTextListener(editText -> editText.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_SIGNED));
        mProxyPort.setOnPreferenceChangeListener((preference, newValue) -> Utils.validatePort(newValue.toString()));

        mUsername = Objects.requireNonNull(findPreference(Prefs.PREF_SOCKS5_USERNAME_KEY));
        mPassword = Objects.requireNonNull(findPreference(Prefs.PREF_SOCKS5_PASSWORD_KEY));
        SwitchPreference socks5Enabled = Objects.requireNonNull(findPreference(Prefs.PREF_SOCKS5_ENABLED_KEY));
        mSocks5AuthEnabled = Objects.requireNonNull(findPreference(Prefs.PREF_SOCKS5_AUTH_ENABLED_KEY));

        socks5Enabled.setOnPreferenceChangeListener((preference, newValue) -> {
            toggleVisisiblity((boolean) newValue, mSocks5AuthEnabled.isChecked());
            return true;
        });
        mSocks5AuthEnabled.setOnPreferenceChangeListener((preference, newValue) -> {
            toggleVisisiblity(socks5Enabled.isChecked(), (boolean) newValue);
            return true;
        });

        toggleVisisiblity(socks5Enabled.isChecked(), mSocks5AuthEnabled.isChecked());
    }

    private void toggleVisisiblity(boolean socks5_enabled, boolean auth_enabled) {
        mProxyHost.setVisible(socks5_enabled);
        mProxyPort.setVisible(socks5_enabled);
        mSocks5AuthEnabled.setVisible(socks5_enabled);

        mUsername.setVisible(socks5_enabled && auth_enabled);
        mPassword.setVisible(socks5_enabled && auth_enabled);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/AppStateListener.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

import com.emanuelef.remote_capture.model.AppState;

public interface AppStateListener {
    void appStateChanged(AppState state);
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/AppsLoadListener.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

import com.emanuelef.remote_capture.model.AppDescriptor;

import java.util.List;

public interface AppsLoadListener {
    // uid -> AppDescriptor
    void onAppsInfoLoaded(List<AppDescriptor> apps);
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/BlacklistsStateListener.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

public interface BlacklistsStateListener {
    void onBlacklistsStateChanged();
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/CaptureStartListener.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

public interface CaptureStartListener {
    void onCaptureStartResult(boolean success);
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/ConnectionsListener.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

import com.emanuelef.remote_capture.model.ConnectionDescriptor;

public interface ConnectionsListener {
    void connectionsChanges(int num_connetions);
    void connectionsAdded(int start, ConnectionDescriptor []conns);
    void connectionsRemoved(int start, ConnectionDescriptor []conns);
    void connectionsUpdated(int[] positions);
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/DrawableLoader.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

import android.graphics.drawable.Drawable;

public interface DrawableLoader {
    Drawable getDrawable();
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/FragmentViewCreatedListener.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-24 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

import android.view.View;

import androidx.annotation.NonNull;

public interface FragmentViewCreatedListener {
    void onFragmentViewCreated(@NonNull View view);
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/MitmListener.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

import org.jetbrains.annotations.Nullable;

public interface MitmListener {
    // NOTE: for fragments, this may be called when their context is null
    void onMitmGetCaCertificateResult(@Nullable String ca_pem);

    void onMitmServiceConnect();
    void onMitmServiceDisconnect();
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/PayloadHostActivity.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.interfaces;

import com.emanuelef.remote_capture.adapters.PayloadAdapter;

/**
 * Interface for activities that host payload display fragments (like ConnectionPayload).
 * This allows the same fragment to be used in different activity contexts.
 */
public interface PayloadHostActivity extends PayloadAdapter.ExportPayloadHandler {
    /**
     * Called when the fragment needs to update menu visibility based on the current state.
     */
    void updateMenuVisibility();

    /**
     * Interface for receiving connection update notifications.
     */
    interface ConnUpdateListener {
        void connectionUpdated();
    }

    /**
     * Register for live connection updates. Override in activities that support live updates.
     * Default implementation does nothing.
     */
    default void addConnUpdateListener(ConnUpdateListener listener) {}

    /**
     * Unregister from live connection updates.
     * Default implementation does nothing.
     */
    default void removeConnUpdateListener(ConnUpdateListener listener) {}
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/PcapDumper.java`:

```java
package com.emanuelef.remote_capture.interfaces;

import java.io.IOException;

/** A dumper implements the ability to dump PCAP data.
 * It has the following lifecycle:
 *
 * startDumper -> ... dumpData ... -> stopDumper
 *
 * In order to avoid monitoring the dumper traffic (which would cause a loop), a dumper must implement
 * the following policy:
 *  - for root capture, the getBpf method must return a BPF filter to exclude the traffic. This will
 *    be set at the start of the catpure.
 *  - for non-root capture, the dumper must pass each socket it opens to the CaptureService.protect
 *    method.
 */
public interface PcapDumper {
    /**
     * Starts the dumper.
     * @throws IOException
     */
    void startDumper() throws IOException;

    /**
     * Terminates the dumper.
     * @throws IOException
     */
    void stopDumper() throws IOException;

    /** Get a BPF to use to ignore the connections made by the dumper.
     *
     * @return the BPF string
     */
    String getBpf();

    /**
     * Dump an unspecified number of PCAP records. The dumper must check if this is the first data
     * sent, in which case it should send the Utils.PCAP_HEADER bofore the PCAP records data.
     * @throws IOException
     */
    void dumpData(byte[] data) throws IOException;
}

```

`app/src/main/java/com/emanuelef/remote_capture/interfaces/TextAdapter.java`:

```java
package com.emanuelef.remote_capture.interfaces;

public interface TextAdapter {
    String getItemText(int pos);
    int getCount();
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/AppDescriptor.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.UserHandle;

import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.interfaces.DrawableLoader;

import java.io.Serializable;

public class AppDescriptor implements Comparable<AppDescriptor>, Serializable {
    private final String mName;
    private final String mPackageName;
    private final int mUid;
    private final boolean mIsSystem;
    private Drawable mIcon;
    private final DrawableLoader mIconLoader;
    private String mDescription;
    private static final String TAG = "AppDescriptor";
    private static boolean badgedIconFails = false;

    // NULL for virtual apps
    PackageManager mPm;
    PackageInfo mPackageInfo;

    public AppDescriptor(String name, DrawableLoader icon_loader, String package_name, int uid, boolean is_system) {
        this.mName = name;
        this.mIcon = null;
        this.mIconLoader = icon_loader;
        this.mPackageName = package_name;
        this.mUid = uid;
        this.mIsSystem = is_system;
        this.mDescription = "";
    }

    public AppDescriptor(PackageManager pm, PackageInfo pkgInfo) {
        this(pkgInfo.applicationInfo.loadLabel(pm).toString(), null,
                pkgInfo.applicationInfo.packageName, pkgInfo.applicationInfo.uid,
                (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);

        mPm = pm;
        mPackageInfo = pkgInfo;
    }

    public AppDescriptor setDescription(String dsc) {
        mDescription = dsc;
        return this;
    }

    public String getDescription() {
        return mDescription;
    }

    public String getName() {
        return mName;
    }

    public @Nullable Drawable getIcon() {
        if(mIcon != null)
            return mIcon;

        if(mIconLoader != null) {
            mIcon = mIconLoader.getDrawable();
            return mIcon;
        }

        if((mPackageInfo == null) || (mPm == null))
            return null;

        // NOTE: this call is expensive
        if ((Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) && CaptureService.isCapturingAsRoot()) {
            // Contrary to "loadIcon", this returns the correct icon for main-profile apps
            // when PCAPdroid is running into a work profile with root. For work-profile apps,
            // the badge is added below via getUserHandleForUid
            mIcon = mPackageInfo.applicationInfo.loadUnbadgedIcon(mPm);

            if (!badgedIconFails) {
                try {
                    UserHandle handle = UserHandle.getUserHandleForUid(mUid);

                    // On some systems may throw "java.lang.SecurityException: You need MANAGE_USERS permission to:
                    // check if specified user a managed profile outside your profile group"
                    mIcon = mPm.getUserBadgedIcon(mIcon, handle);
                } catch (SecurityException e) {
                    Log.w(TAG, "getUserBadgedIcon failed, using icons without badges: " + e.getMessage());
                    badgedIconFails = true;
                }
            }
        } else
            mIcon = mPackageInfo.applicationInfo.loadIcon(mPm);

        //Log.d("Icon size", mIcon.getIntrinsicWidth() + "x" + mIcon.getIntrinsicHeight());

        return mIcon;
    }

    public String getPackageName() {
        return mPackageName;
    }

    public int getUid() {
        return mUid;
    }

    public boolean isSystem() { return mIsSystem; }

    // the app does not have a package name (e.g. uid 0 is android system)
    public boolean isVirtual() { return (mPackageInfo == null); }

    public @Nullable PackageInfo getPackageInfo() { return mPackageInfo; }

    @Override
    public int compareTo(AppDescriptor o) {
        int rv = getName().toLowerCase().compareTo(o.getName().toLowerCase());

        if(rv == 0)
            rv = getPackageName().compareTo(o.getPackageName());

        return rv;
    }

    public boolean matches(String filter, boolean exactPackage) {
        String package_name = getPackageName().toLowerCase();

        return getName().toLowerCase().contains(filter) ||
                (exactPackage && package_name.equals(filter)) ||
                (!exactPackage && package_name.contains(filter));
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/AppState.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

/* App state handling: ready -> starting -> running -> stopping -> ready  */
public enum AppState {
    ready,
    starting,
    running,
    stopping
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/AppStats.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import androidx.annotation.NonNull;

public class AppStats implements Cloneable {
    private final int uid;
    public long sentBytes;
    public long rcvdBytes;
    public int numConnections;
    public int numBlockedConnections;

    public AppStats(int _uid) {
        uid = _uid;
    }

    public int getUid() {
        return uid;
    }

    @NonNull
    public AppStats clone() {
        AppStats rv = new AppStats(uid);
        rv.sentBytes = sentBytes;
        rv.rcvdBytes = rcvdBytes;
        rv.numConnections = numConnections;
        rv.numBlockedConnections = numBlockedConnections;

        return rv;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/BlacklistDescriptor.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import android.content.Context;

import androidx.core.content.ContextCompat;

import com.emanuelef.remote_capture.R;

public class BlacklistDescriptor {
    public final String label;
    public final Type type;    // NOTE: used via JNI
    public final String fname; // NOTE: used via JNI
    public final String url;
    long mLastUpdate = 0;
    boolean mUpToDate = false;
    boolean mUpdating = false;
    public boolean loaded = false;
    public int num_rules = 0;

    // NOTE: used via JNI
    public enum Type {
        IP_BLACKLIST,
        DOMAIN_BLACKLIST,
    }

    public enum Status {
        NOT_LOADED,
        OUTDATED,
        UPDATING,
        UP_TO_DATE
    }

    public BlacklistDescriptor(String label, Type type, String fname, String url) {
        this.label = label;
        this.type = type;
        this.fname = fname;
        this.url = url;
    }

    public void setUpdating() {
        mUpdating = true;
        mUpToDate = false;
    }

    public void setOutdated() {
        mUpdating = false;
        mUpToDate = false;
    }

    public void setUpdated(long now) {
        mUpdating = false;
        mLastUpdate = now;
        mUpToDate = (mLastUpdate != 0);
    }

    public long getLastUpdate() {
        return mLastUpdate;
    }

    public boolean isUpToDate() {
        return mUpToDate;
    }

    public Status getStatus() {
        if(mUpdating)
            return Status.UPDATING;
        if(!loaded)
            return Status.NOT_LOADED;
        if(!mUpToDate)
            return Status.OUTDATED;
        return Status.UP_TO_DATE;
    }

    public String getStatusLabel(Context ctx) {
        int id = -1;

        switch(getStatus()) {
            case NOT_LOADED:
                id = R.string.status_not_loaded;
                break;
            case OUTDATED:
                id = R.string.status_outdated;
                break;
            case UPDATING:
                id = R.string.status_updating;
                break;
            case UP_TO_DATE:
                id = R.string.status_uptodate;
                break;
        }

        return ctx.getString(id);
    }

    public int getStatusColor(Context ctx) {
        int id = -1;

        switch(getStatus()) {
            case NOT_LOADED:
                id = R.color.danger;
                break;
            case OUTDATED:
                id = R.color.warning;
                break;
            case UPDATING:
                id = R.color.in_progress;
                break;
            case UP_TO_DATE:
                id = R.color.ok;
                break;
        }

        return ContextCompat.getColor(ctx, id);
    }

    public String getTypeLabel(Context ctx) {
        int id = (type == Type.IP_BLACKLIST) ? R.string.blacklist_type_ip : R.string.blacklist_type_domain;
        return ctx.getString(id);
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/model/Blocklist.java`:

```java
package com.emanuelef.remote_capture.model;

import android.content.Context;
import android.os.SystemClock;
import android.util.ArrayMap;

import androidx.appcompat.app.AlertDialog;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Geolocation;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;

import java.util.Iterator;
import java.util.Map;

public class Blocklist extends MatchList {
    private static final String TAG = "Blocklist";
    private boolean mGeoWarningShown = false;

    // access to mUidToGrace must be synchronized as it can happen either from the UI thread or from
    // the CaptureService.connUpdateWork thread
    private final ArrayMap<Integer, Long> mUidToGrace = new ArrayMap<>();

    public Blocklist(Context ctx) {
        super(ctx, Prefs.PREF_BLOCKLIST);
    }

    public synchronized boolean unblockAppForMinutes(int uid, int minutes) {
        Long old_val = mUidToGrace.put(uid, SystemClock.elapsedRealtime() + (minutes * 60_000L));
        Log.i(TAG, "Grace app: " + uid + " for " + minutes + " minutes (old: " + old_val + ")");
        return (old_val == null);
    }

    public synchronized boolean checkGracePeriods() {
        long now = SystemClock.elapsedRealtime();
        boolean changed = false;
        Iterator<Map.Entry<Integer,Long>> iter = mUidToGrace.entrySet().iterator();

        while(iter.hasNext()) {
            Map.Entry<Integer, Long> entry = iter.next();

            if(now >= entry.getValue()) {
                Log.i(TAG, "Grace period ended for app: " + entry.getKey());
                iter.remove();
                changed = true;
            }
        }

        return changed;
    }

    @Override
    public synchronized boolean isExemptedApp(int uid) {
        return mUidToGrace.containsKey(uid);
    }

    @Override
    public boolean matchesApp(int uid) {
        if(!super.matchesApp(uid))
            return false;

        synchronized (this) {
            return !isExemptedApp(uid);
        }
    }

    @Override
    public synchronized void removeApp(int uid) {
        mUidToGrace.remove(uid);
        super.removeApp(uid);
    }

    @Override
    public synchronized boolean addApp(int uid) {
        mUidToGrace.remove(uid);
        return super.addApp(uid);
    }

    public void saveAndReload() {
        save();

        if(CaptureService.isServiceActive())
            CaptureService.requireInstance().reloadBlocklist();
    }

    public synchronized boolean hasCountryRules() {
        Iterator<MatchList.Rule> it = iterRules();
        while(it.hasNext()) {
            MatchList.Rule rule = it.next();

            if (rule.getType() == MatchList.RuleType.COUNTRY)
                return true;
        }

        return false;
    }

    public void showNoticeIfGeoMissing(Context ctx) {
        if (mGeoWarningShown)
            return;

        if (!Geolocation.isAvailable(ctx)) {
            new AlertDialog.Builder(ctx)
                    .setTitle(R.string.geo_db_missing)
                    .setMessage(R.string.country_rules_warning)
                    .setNeutralButton(R.string.ok, (dialog, whichButton) -> {})
                    .show();

            mGeoWarningShown = true;
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/CaptureSettings.java`:

```java
package com.emanuelef.remote_capture.model;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;

import com.emanuelef.remote_capture.Billing;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

public class CaptureSettings implements Serializable {
    public Prefs.DumpMode dump_mode;
    public HashSet<String> app_filter;
    public String decryption_rules_json = "";
    public String collector_address;
    public int collector_port;
    public int http_server_port;
    public boolean socks5_enabled;
    public boolean tls_decryption;
    public String socks5_proxy_address;
    public int socks5_proxy_port;
    public String socks5_username;
    public String socks5_password;
    public Prefs.IpMode ip_mode;
    public String input_pcap_path;
    public boolean root_capture;
    public boolean dump_extensions;
    public boolean full_payload;
    public Prefs.BlockQuicMode block_quic_mode;
    public boolean auto_block_private_dns;
    public boolean pcapng_format;
    public String capture_interface;
    public String pcap_uri = "";
    public String pcap_name = "";
    public String sslkeylog_name = "";
    public boolean api_capture;
    public int snaplen = 0;
    public int max_pkts_per_flow = 0;
    public int max_dump_size = 0;
    public String mitmproxy_opts;

    public CaptureSettings(Context ctx, SharedPreferences prefs) {
        dump_mode = Prefs.getDumpMode(prefs);
        app_filter = new HashSet<>(Prefs.getAppFilter(prefs));
        collector_address = Prefs.getCollectorIp(prefs);
        collector_port = Prefs.getCollectorPort(prefs);
        http_server_port = Prefs.getHttpServerPort(prefs);
        socks5_enabled = Prefs.getSocks5Enabled(prefs);
        socks5_proxy_address = Prefs.getSocks5ProxyHost(prefs);
        socks5_proxy_port = Prefs.getSocks5ProxyPort(prefs);
        socks5_username = Prefs.isSocks5AuthEnabled(prefs) ? Prefs.getSocks5Username(prefs) : "";
        socks5_password = Prefs.isSocks5AuthEnabled(prefs) ? Prefs.getSocks5Password(prefs) : "";
        ip_mode = Prefs.getIPMode(prefs);
        root_capture = Prefs.isRootCaptureEnabled(prefs);
        dump_extensions = Prefs.isPcapdroidMetadataEnabled(prefs);
        capture_interface = Prefs.getCaptureInterface(prefs);
        tls_decryption = Prefs.getTlsDecryptionEnabled(prefs);
        full_payload = Prefs.getFullPayloadMode(prefs);
        block_quic_mode = Prefs.getBlockQuicMode(prefs);
        auto_block_private_dns = Prefs.isPrivateDnsBlockingEnabled(prefs);
        mitmproxy_opts = Prefs.getMitmproxyOpts(prefs);
        pcapng_format = Prefs.isPcapngEnabled(ctx, prefs);
        api_capture = false;
    }

    public CaptureSettings(Context ctx, Intent intent) {
        dump_mode = Prefs.getDumpMode(getString(intent, "pcap_dump_mode", "none"));
        app_filter = new HashSet<>(getStringList(intent, Prefs.PREF_APP_FILTER));
        collector_address = getString(intent, Prefs.PREF_COLLECTOR_IP_KEY, "127.0.0.1");
        collector_port = getInt(intent, Prefs.PREF_COLLECTOR_PORT_KEY, 1234);
        http_server_port = getInt(intent, Prefs.PREF_HTTP_SERVER_PORT, 8080);
        socks5_enabled = getBool(intent, Prefs.PREF_SOCKS5_ENABLED_KEY, false);
        socks5_proxy_address = getString(intent, Prefs.PREF_SOCKS5_PROXY_HOST_KEY,
                getString(intent, Prefs.PREF_SOCKS5_PROXY_IP_KEY, "0.0.0.0"));
        socks5_proxy_port = getInt(intent, Prefs.PREF_SOCKS5_PROXY_PORT_KEY, 8080);
        socks5_username = getString(intent, Prefs.PREF_SOCKS5_USERNAME_KEY, "");
        socks5_password = getString(intent, Prefs.PREF_SOCKS5_PASSWORD_KEY, "");
        ip_mode = Prefs.getIPMode(getString(intent, Prefs.PREF_IP_MODE, Prefs.IP_MODE_DEFAULT));
        root_capture = getBool(intent, Prefs.PREF_ROOT_CAPTURE, false);
        dump_extensions = getBool(intent, Prefs.PREF_DUMP_EXTENSIONS, false) ||
                getBool(intent, "pcapdroid_trailer", false) /* deprecated */;
        capture_interface = getString(intent, Prefs.PREF_CAPTURE_INTERFACE, "@inet");
        pcap_uri = getString(intent, "pcap_uri", "");
        pcap_name = getString(intent, "pcap_name", "");
        snaplen = getInt(intent, Prefs.PREF_SNAPLEN, 0);
        max_pkts_per_flow = getInt(intent, Prefs.PREF_MAX_PKTS_PER_FLOW, 0);
        max_dump_size = getInt(intent, Prefs.PREF_MAX_DUMP_SIZE, 0);
        tls_decryption = getBool(intent, Prefs.PREF_TLS_DECRYPTION_KEY, false);
        full_payload = getBool(intent, Prefs.PREF_FULL_PAYLOAD, false);;
        block_quic_mode = Prefs.getBlockQuicMode(getString(intent, "block_quic", Prefs.BLOCK_QUIC_MODE_DEFAULT));
        auto_block_private_dns = getBool(intent, Prefs.PREF_AUTO_BLOCK_PRIVATE_DNS, true);
        mitmproxy_opts = getString(intent, Prefs.PREF_MITMPROXY_OPTS, "");
        pcapng_format = getBool(intent, Prefs.PREF_PCAPNG_ENABLED, false) && Billing.newInstance(ctx).isPurchased(Billing.PCAPNG_SKU);
        sslkeylog_name = getString(intent, "sslkeylog_name", "");
        decryption_rules_json = getDecryptionRulesFromIntent(intent);
        api_capture = true;
    }

    private String getDecryptionRulesFromIntent(Intent intent){
        String rules = getString(intent, "decryption_rules", "");
        if(rules.isBlank())
            return "";

        return "{\"rules\":" + rules + "}";
    }

    private static String getString(Intent intent, String key, String def_value) {
        String val = intent.getStringExtra(key);
        return (val != null) ? val : def_value;
    }

    // get a integer value from the bundle. The value may be represented as an int or as a string.
    private static int getInt(Intent intent, String key, int def_value) {
        Bundle bundle = intent.getExtras();

        String s = bundle.getString(key);
        if(s != null)
            return Integer.parseInt(s);
        return bundle.getInt(key, def_value);
    }

    // get a boolean value from the bundle. The value may be represented as a bool or as a string.
    private static boolean getBool(Intent intent, String key, boolean def_value) {
        Bundle bundle = intent.getExtras();

        String s = bundle.getString(key);
        if(s != null)
            return Boolean.parseBoolean(s);
        return bundle.getBoolean(key, def_value);
    }

    // get a list of comma-separated strings from the bundle
    private static List<String> getStringList(Intent intent, String key) {
        List<String> rv;

        String s = intent.getStringExtra(key);
        if(s != null) {
            if (s.indexOf(',') < 0) {
                rv = new ArrayList<>();
                rv.add(s);
            } else {
                String[] arr = s.split(",");
                rv = Arrays.asList(arr);
            }
        } else
            rv = new ArrayList<>();

        return rv;
    }

    public boolean readFromPcap() {
        return input_pcap_path != null;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/CaptureStats.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import java.io.Serializable;

public class CaptureStats implements Serializable {
    public String alloc_summary;
    public long bytes_sent;
    public long bytes_rcvd;
    public long ipv6_bytes_sent;
    public long ipv6_bytes_rcvd;
    public long pcap_dump_size;
    public int pkts_sent;
    public int pkts_rcvd;
    public int pkts_dropped;
    public int num_dropped_conns;
    public int num_open_sockets;
    public int max_fd;
    public int active_conns;
    public int tot_conns;
    public int num_dns_queries;

    /* Invoked by native code */
    public void setData(String _alloc_summary,
                        long _bytes_sent, long _bytes_rcvd,
                        long _ipv6_bytes_sent, long _ipv6_bytes_rcvd,
                        long _pcap_dump_size, int _pkts_sent, int _pkts_rcvd,
                        int _pkts_dropped, int _num_dropped_conns, int _num_open_sockets,
                        int _max_fd, int _active_conns, int _tot_conns, int _num_dns_queries) {
        alloc_summary = _alloc_summary;
        bytes_sent = _bytes_sent;
        bytes_rcvd = _bytes_rcvd;
        ipv6_bytes_sent = _ipv6_bytes_sent;
        ipv6_bytes_rcvd = _ipv6_bytes_rcvd;
        pcap_dump_size = _pcap_dump_size;
        pkts_sent = _pkts_sent;
        pkts_rcvd = _pkts_rcvd;
        pkts_dropped = _pkts_dropped;
        num_dropped_conns = _num_dropped_conns;
        num_open_sockets = _num_open_sockets;
        max_fd = _max_fd;
        active_conns = _active_conns;
        tot_conns = _tot_conns;
        num_dns_queries = _num_dns_queries;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/ConnectionDescriptor.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import android.content.Context;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.HTTPReassembly;
import com.emanuelef.remote_capture.HttpLog;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicReference;

/* Holds the information about a single connection.
 * Equivalent of zdtun_conn_t from zdtun and pd_conn_t from pcapdroid.c .
 *
 * Connections are normally stored into the ConnectionsRegister. Concurrent access to the connection
 * fields can happen when a connection is updated and, at the same time, it is retrieved by the UI
 * thread. However this does not create concurrency problems as the update only increments counters
 * or sets a previously null field to a non-null value.
 */
public class ConnectionDescriptor implements HTTPReassembly.ReassemblyListener {
    public static final String TAG = "ConnectionDescriptor";

    // sync with zdtun_conn_status_t
    public static final int CONN_STATUS_NEW = 0,
        CONN_STATUS_CONNECTING = 1,
        CONN_STATUS_CONNECTED = 2,
        CONN_STATUS_CLOSED = 3,
        CONN_STATUS_ERROR = 4,
        CONN_STATUS_SOCKET_ERROR = 5,
        CONN_STATUS_CLIENT_ERROR = 6,
        CONN_STATUS_RESET = 7,
        CONN_STATUS_UNREACHABLE = 8;

    // This is an high level status which abstracts the zdtun_conn_status_t
    public enum Status {
        STATUS_INVALID,
        STATUS_ACTIVE,
        STATUS_CLOSED,
        STATUS_UNREACHABLE,
        STATUS_ERROR,
    }

    public enum DecryptionStatus {
        INVALID,
        ENCRYPTED,
        CLEARTEXT,
        DECRYPTED,
        NOT_DECRYPTABLE,
        WAITING_DATA,
        ERROR,
    }

    public enum FilteringStatus {
        INVALID,
        ALLOWED,
        BLOCKED
    }

    /* Metadata */
    public final int ipver;
    public final int ipproto;
    public final String src_ip;
    public final String dst_ip;
    public final int src_port;
    public final int dst_port;
    public final int local_port; // in VPN mode, this is the local port of the Internet connection

    /* Data */
    public long first_seen;
    public long last_seen;
    public long payload_length;
    public long sent_bytes;
    public long rcvd_bytes;
    public int sent_pkts;
    public int rcvd_pkts;
    public int blocked_pkts;
    public String info;
    public String url;
    public String l7proto;
    private final ArrayList<PayloadChunk> payload_chunks; // must be synchronized
    public final int uid;
    public final int ifidx;
    public final int incr_id;
    private final boolean mitm_decrypt; // true if the connection is under mitm for TLS decryption
    private boolean internal_decrypt;
    public int status;
    public int error;
    private int tcp_flags;
    private boolean blacklisted_ip;
    private boolean blacklisted_host;
    public boolean is_blocked;
    private boolean port_mapping_applied;
    private boolean decryption_ignored;
    public boolean netd_block_missed;
    private boolean payload_truncated;
    private boolean encrypted_l7;     // application layer is encrypted (e.g. TLS)
    public boolean encrypted_payload; // actual payload is encrypted (e.g. telegram - see Utils.hasEncryptedPayload)
    private boolean has_websocket_data;
    public String decryption_error;
    public String js_injected_scripts;
    public String country;
    public Geomodel.ASN asn;

    /* Internal */
    public boolean alerted;
    public boolean block_accounted;
    private HTTPReassembly mHttpReqReassembly;
    private HTTPReassembly mHttpReplyReassembly;
    private int mFirstReqChunkPos = -1;
    private int mFirstReplyChunkPos = -1;
    private LinkedList<HttpLog.HttpRequest> mPendingRequests;

    // NOTE: invoked from JNI
    public ConnectionDescriptor(int _incr_id, int _ipver, int _ipproto, String _src_ip, String _dst_ip, String _country,
                                int _src_port, int _dst_port, int _local_port, int _uid, int _ifidx,
                                boolean _mitm_decrypt, long when) {
        incr_id = _incr_id;
        ipver = _ipver;
        ipproto = _ipproto;
        src_ip = _src_ip;
        dst_ip = _dst_ip;
        src_port = _src_port;
        dst_port = _dst_port;
        local_port = _local_port;
        uid = _uid;
        ifidx = _ifidx;
        first_seen = last_seen = when;
        l7proto = "";
        country = _country;
        asn = new Geomodel.ASN();
        payload_chunks = new ArrayList<>();
        mitm_decrypt = _mitm_decrypt;
        internal_decrypt = false;
    }

    // NOTE: invoked from either JNI (dumpNewConnection) or ConnectionsRegister
    public void processUpdate(ConnectionUpdate update) {
        // The "update_type" is used to limit the amount of data sent via the JNI
        if((update.update_type & ConnectionUpdate.UPDATE_STATS) != 0) {
            sent_bytes = update.sent_bytes;
            rcvd_bytes = update.rcvd_bytes;
            sent_pkts = update.sent_pkts;
            rcvd_pkts = update.rcvd_pkts;
            blocked_pkts = update.blocked_pkts;
            status = (update.status & 0x00FF);
            error = (update.status & 0xFF0000) >> 16;
            port_mapping_applied = (update.status & 0x2000) != 0;
            decryption_ignored = (update.status & 0x1000) != 0;
            netd_block_missed = (update.status & 0x0800) != 0;
            is_blocked = (update.status & 0x0400) != 0;
            blacklisted_host = (update.status & 0x0200) != 0;
            blacklisted_ip = (update.status & 0x0100) != 0;
            last_seen = update.last_seen;
            tcp_flags = update.tcp_flags; // NOTE: only for root capture

            // see MitmReceiver.handlePayload
            if((status == ConnectionDescriptor.CONN_STATUS_CLOSED) && (decryption_error != null))
                status = ConnectionDescriptor.CONN_STATUS_CLIENT_ERROR;

            // with mitm we account the TLS payload length instead
            if(!mitm_decrypt)
                payload_length = update.payload_length;
        }
        if((update.update_type & ConnectionUpdate.UPDATE_INFO) != 0) {
            info = update.info;
            url = update.url;
            l7proto = update.l7proto;
            encrypted_l7 = ((update.info_flags & ConnectionUpdate.UPDATE_INFO_FLAG_ENCRYPTED_L7) != 0);
        }
        if((update.update_type & ConnectionUpdate.UPDATE_PAYLOAD) != 0) {
            // Payload for decryptable connections should be received via the MitmReceiver
            assert(decryption_ignored || isNotDecryptable() || PCAPdroid.getInstance().isDecryptingPcap());

            synchronized (this) {
                // Some pending updates with payload may still be received after low memory has been
                // triggered and payload disabled
                if(!CaptureService.isLowMemory()) {
                    if (update.payload_chunks != null) {
                        boolean has_http_log = (CaptureService.getHttpLog() != null);
                        int chunk_pos = payload_chunks.size();

                        for (PayloadChunk chunk: update.payload_chunks) {
                            if (has_http_log && (chunk.type == PayloadChunk.ChunkType.HTTP))
                                logHttpChunk(chunk, chunk_pos);

                            // NOTE: logHttpChunk may change the chunk type
                            // from HTTP to WEBSOCKET after detecting a websocket upgrade
                            // so this condition should be checked separately
                            if (chunk.type == PayloadChunk.ChunkType.WEBSOCKET)
                                has_websocket_data = true;

                            chunk_pos++;
                        }

                        payload_chunks.addAll(update.payload_chunks);
                    }
                    payload_truncated = update.payload_truncated;
                    internal_decrypt = update.payload_decrypted;
                }
            }
        }
    }

    // See HttpLog
    private void logHttpChunk(PayloadChunk chunk, int chunk_pos) {
        assert (chunk.type == PayloadChunk.ChunkType.HTTP);

        if (CaptureService.getHttpLog() == null)
            return;

        if (mHttpReqReassembly == null) {
            // use a lightweight reassembly, without dumping the payload
            mHttpReqReassembly = new HTTPReassembly(true, this, false);
            mHttpReplyReassembly = new HTTPReassembly(true, this, false);
            mPendingRequests = new LinkedList<>();
        }

        // will call onChunkReassembled
        if (chunk.is_sent) {
            if ((mFirstReqChunkPos == -1) && !chunk.isHttp2Rst())
                mFirstReqChunkPos = chunk_pos;
            mHttpReqReassembly.handleChunk(chunk);
        } else {
            if ((mFirstReplyChunkPos == -1) && !chunk.isHttp2Rst())
                mFirstReplyChunkPos = chunk_pos;
            mHttpReplyReassembly.handleChunk(chunk);
        }
    }

    public InetAddress getDstAddr() {
        try {
            return InetAddress.getByName(dst_ip);
        } catch (UnknownHostException e) {
            e.printStackTrace();
            return null;
        }
    }

    public Status getStatus() {
        if(status >= CONN_STATUS_CLOSED) {
            switch(status) {
                case CONN_STATUS_CLOSED:
                case CONN_STATUS_RESET:
                    return Status.STATUS_CLOSED;
                case CONN_STATUS_UNREACHABLE:
                    return Status.STATUS_UNREACHABLE;
                default:
                    return Status.STATUS_ERROR;
            }
        }
        return Status.STATUS_ACTIVE;
    }

    public static String getStatusLabel(Status status, Context ctx) {
        int resid;

        switch(status) {
            case STATUS_ACTIVE: resid = R.string.conn_status_active; break;
            case STATUS_CLOSED: resid = R.string.conn_status_closed; break;
            case STATUS_UNREACHABLE: resid = R.string.conn_status_unreachable; break;
            default: resid = R.string.error;
        }

        return(ctx.getString(resid));
    }

    public String getStatusLabel(Context ctx) {
        return getStatusLabel(getStatus(), ctx);
    }

    public boolean matches(AppsResolver res, String filter) {
        filter = filter.toLowerCase();
        AppDescriptor app = res.getAppByUid(uid, 0);

        return(((info != null) && (info.contains(filter))) ||
                dst_ip.contains(filter) ||
                l7proto.toLowerCase().equals(filter) ||
                Integer.toString(uid).equals(filter) ||
                Integer.toString(dst_port).contains(filter) ||
                Integer.toString(src_port).equals(filter) ||
                ((app != null) && (app.matches(filter, true)))
        );
    }

    public DecryptionStatus getDecryptionStatus() {
        if(isCleartext())
            return DecryptionStatus.CLEARTEXT;
        else if(decryption_error != null)
            return DecryptionStatus.ERROR;
        else if(isNotDecryptable())
            return DecryptionStatus.NOT_DECRYPTABLE;
        else if(decryption_ignored || (PCAPdroid.getInstance().isDecryptingPcap() && !internal_decrypt))
            return DecryptionStatus.ENCRYPTED;
        else if(isDecrypted())
            return DecryptionStatus.DECRYPTED;
        else
            return DecryptionStatus.WAITING_DATA;
    }

    public static String getDecryptionStatusLabel(DecryptionStatus status, Context ctx) {
        int resid;

        switch (status) {
            case CLEARTEXT: resid = R.string.not_encrypted; break;
            case NOT_DECRYPTABLE: resid = R.string.not_decryptable; break;
            case DECRYPTED: resid = R.string.decrypted; break;
            case ENCRYPTED: resid = R.string.status_encrypted; break;
            case WAITING_DATA: resid = R.string.waiting_application_data; break;
            default: resid = R.string.error;
        }

        return(ctx.getString(resid));
    }

    public String getDecryptionStatusLabel(Context ctx) {
        return getDecryptionStatusLabel(getDecryptionStatus(), ctx);
    }

    public int getSentTcpFlags() {
        return (tcp_flags >> 8);
    }

    public int getRcvdTcpFlags() {
        return (tcp_flags & 0xFF);
    }

    public boolean isBlacklistedIp() { return blacklisted_ip; }
    public boolean isBlacklistedHost() { return blacklisted_host; }
    public boolean isBlacklisted() {
        return isBlacklistedIp() || isBlacklistedHost();
    }

    public void setPayloadTruncatedByAddon() {
        // only for the mitm addon
        assert(!isNotDecryptable());
        payload_truncated = true;
    }

    public boolean isPayloadTruncated() { return payload_truncated; }
    public boolean isPortMappingApplied() { return port_mapping_applied; }
    public boolean hasWebsocketData() { return has_websocket_data; }

    public boolean isNotDecryptable()   { return !decryption_ignored && (encrypted_payload || !mitm_decrypt) && !PCAPdroid.getInstance().isDecryptingPcap(); }
    public boolean isDecrypted()        { return !decryption_ignored && !isNotDecryptable() && (mitm_decrypt || internal_decrypt) && (getNumPayloadChunks() > 0); }
    public boolean isCleartext()        { return !encrypted_payload && !encrypted_l7; }

    public synchronized int getNumPayloadChunks() { return payload_chunks.size(); }

    public synchronized @Nullable PayloadChunk getPayloadChunk(int idx) {
        if(getNumPayloadChunks() <= idx)
            return null;
        return payload_chunks.get(idx);
    }

    public synchronized void addPayloadChunkMitm(PayloadChunk chunk) {
        if (chunk.type == PayloadChunk.ChunkType.HTTP)
            logHttpChunk(chunk, payload_chunks.size());
        else if (chunk.type == PayloadChunk.ChunkType.WEBSOCKET)
            has_websocket_data = true;

        payload_chunks.add(chunk);
        payload_length += chunk.payload.length;
    }

    public synchronized void dropPayload() {
        payload_chunks.clear();
    }

    private synchronized boolean hasHttp(boolean is_sent) {
        for(PayloadChunk chunk: payload_chunks) {
            if(chunk.is_sent == is_sent)
                return (chunk.type == PayloadChunk.ChunkType.HTTP);
        }

        return false;
    }
    public boolean hasHttpRequest() { return hasHttp(true); }
    public boolean hasHttpResponse() { return hasHttp(false); }

    private synchronized PayloadChunk getHttpChunks(boolean is_sent, int firstChunkPos) {
        if((getNumPayloadChunks() == 0) || (firstChunkPos < 0))
            return null;

        // Need to wrap the chunk to set it from the lambda
        final AtomicReference<PayloadChunk> rv = new AtomicReference<>();
        HTTPReassembly reassembly = new HTTPReassembly(
                CaptureService.getCurPayloadMode() == Prefs.PayloadMode.FULL,
                rv::set
        );

        // Possibly reassemble/decode the request
        for (int i = firstChunkPos; i < payload_chunks.size(); i++) {
            PayloadChunk chunk = payload_chunks.get(i);

            if(chunk.is_sent == is_sent)
                reassembly.handleChunk(chunk);

            // Stop at the first reassembly/chunk
            if(rv.get() != null)
                break;
        }

        return rv.get();
    }

    private String getHttpAsString(boolean is_sent) {
        PayloadChunk reassembled = getHttpChunks(is_sent, 0);
        if (reassembled == null)
            return "";

        return new String(reassembled.payload, StandardCharsets.UTF_8);
    }

    public String getHttpRequest() { return getHttpAsString(true); }
    public String getHttpResponse() { return getHttpAsString(false); }

    public PayloadChunk getHttpRequestChunk(int firstChunkPos) { return getHttpChunks(true, firstChunkPos); }
    public PayloadChunk getHttpResponseChunk(int firstChunkPos) { return getHttpChunks(false, firstChunkPos); }

    @Override
    public void onChunkReassembled(PayloadChunk chunk) {
        if (chunk.type != PayloadChunk.ChunkType.HTTP)
            return;

        HttpLog httplog = CaptureService.getHttpLog();
        if (httplog == null)
            return;

        if (chunk.is_sent && !chunk.isHttp2Rst()) {
            HttpLog.HttpRequest request = new HttpLog.HttpRequest(this, mFirstReqChunkPos);
            request.host = !chunk.httpHost.isEmpty() ? chunk.httpHost : info;
            request.method = chunk.httpMethod;
            request.path = chunk.httpPath;
            request.query = chunk.httpQuery;
            request.bodyLength = chunk.httpBodyLength;
            request.streamId = chunk.stream_id;
            request.timestamp = chunk.timestamp;
            httplog.addHttpRequest(request);

            mPendingRequests.add(request);
            mFirstReqChunkPos = -1;
        } else {
            // match the reply to the request
            HttpLog.HttpRequest request = null;

            if (chunk.stream_id == 0) {
                // if HTTP/1, then the request is the first in the list
                if (!mPendingRequests.isEmpty())
                    request = mPendingRequests.remove(0);
            } else {
                // if HTTP/2, use the stream ID for the matching
                int idx = 0;
                for (HttpLog.HttpRequest req: mPendingRequests) {
                    if (req.streamId == chunk.stream_id)
                        break;

                    idx++;
                }

                if (idx < mPendingRequests.size())
                    request = mPendingRequests.remove(idx);
            }

            if (request != null) {
                if (!chunk.isHttp2Rst()) {
                    HttpLog.HttpReply reply = new HttpLog.HttpReply(request, mFirstReplyChunkPos);
                    reply.responseCode = chunk.httpResponseCode;
                    reply.responseStatus = chunk.httpResponseStatus;
                    reply.contentType = chunk.httpContentType;
                    reply.bodyLength = chunk.httpBodyLength;
                    request.reply = reply;

                    httplog.addHttpReply(reply);
                    mFirstReplyChunkPos = -1;
                } else {
                    request.httpRst = true;
                    Log.d(TAG, "Got RST: " + request.getUrl());
                }
            } else if (!chunk.is_sent) { // ignore HTTP requests with RST
                if (chunk.isHttp2Rst())
                    Log.w(TAG, "Unmatched HTTP RST (sent=" + chunk.is_sent + ", stream=" + chunk.stream_id + ")");
                else
                    Log.w(TAG, "Unmatched HTTP reply (sent=" + chunk.is_sent + ", stream=" + chunk.stream_id + ")");
            }
        }
    }

    public boolean hasSeenStart() {
        if((ipproto != 6 /* TCP */) || !CaptureService.isCapturingAsRoot())
            return true;

        return (getSentTcpFlags() & 0x2) != 0; // SYN
    }

    @Override
    public @NonNull String toString() {
        return "[proto=" + ipproto + "/" + l7proto + "]: " + src_ip + ":" + src_port + " -> " +
                dst_ip + ":" + dst_port + " [" + uid + "] " + info;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/ConnectionUpdate.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import java.util.ArrayList;

public class ConnectionUpdate {
    public static final int UPDATE_STATS = 0x1;
    public static final int UPDATE_INFO = 0x2;
    public static final int UPDATE_PAYLOAD = 0x4;
    public static final int UPDATE_INFO_FLAG_ENCRYPTED_L7 = 0x1;
    public final int incr_id;
    public int update_type;

    /* set if update_type & UPDATE_STATS */
    public long last_seen;
    public long payload_length;
    public long sent_bytes;
    public long rcvd_bytes;
    public int sent_pkts;
    public int rcvd_pkts;
    public int blocked_pkts;
    public int tcp_flags;
    public int status;
    public int info_flags;

    /* set if update_type & UPDATE_INFO */
    public String info;
    public String url;
    public String l7proto;

    /* set if update_type & UPDATE_PAYLOAD */
    public ArrayList<PayloadChunk> payload_chunks;
    public boolean payload_truncated;
    public boolean payload_decrypted;

    public ConnectionUpdate(int _incr_id) {
        incr_id = _incr_id;
    }

    public void setStats(long _last_seen, long _payload_length, long _sent_bytes, long _rcvd_bytes,
                         int _sent_pkts, int _rcvd_pkts, int _blocked_pkts,
                         int _tcp_flags, int _status) {
        update_type |= UPDATE_STATS;

        last_seen = _last_seen;
        payload_length = _payload_length;
        sent_bytes = _sent_bytes;
        rcvd_bytes = _rcvd_bytes;
        sent_pkts = _sent_pkts;
        blocked_pkts = _blocked_pkts;
        rcvd_pkts = _rcvd_pkts;
        tcp_flags = _tcp_flags;
        status = _status;
    }

    public void setInfo(String _info, String _url, String _l7proto, int flags) {
        update_type |= UPDATE_INFO;

        info = _info;
        url = _url;
        l7proto = _l7proto;
        info_flags = flags;
    }

    public void setPayload(ArrayList<PayloadChunk> _chunks, int flags) {
        update_type |= UPDATE_PAYLOAD;

        payload_chunks = _chunks;
        payload_truncated = (flags & 0x1) != 0;
        payload_decrypted = (flags & 0x2) != 0;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/CtrlPermissions.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.ArrayMap;

import androidx.preference.PreferenceManager;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import java.lang.reflect.Type;
import java.util.Iterator;
import java.util.Map;

public class CtrlPermissions {
    private static final String PREF_NAME = "ctrl_perms";
    private final ArrayMap<String, Rule> mRules = new ArrayMap<>();
    private final SharedPreferences mPrefs;

    public enum ConsentType {
        UNSPECIFIED,
        ALLOW,
        DENY,
    }

    public static class Rule {
        public final String package_name;
        public final ConsentType consent;

        public Rule(String _package_name, ConsentType tp) {
            package_name = _package_name;
            consent = tp;
        }
    }

    public CtrlPermissions(Context ctx) {
        mPrefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        reload();
    }

    public void reload() {
        String serialized = mPrefs.getString(PREF_NAME, "");
        //Log.d(TAG, serialized);

        if(!serialized.isEmpty()) {
            JsonObject obj = JsonParser.parseString(serialized).getAsJsonObject();
            deserialize(obj);
        } else
            mRules.clear();
    }

    private void deserialize(JsonObject object) {
        mRules.clear();

        JsonObject rules = object.getAsJsonObject("rules");
        if(rules == null)
            return;

        for(Map.Entry<String, JsonElement> rule: rules.entrySet()) {
            if(rule.getValue().isJsonPrimitive() && rule.getValue().getAsJsonPrimitive().isString()) {
                String val = rule.getValue().getAsJsonPrimitive().getAsString();

                try {
                    ConsentType tp = ConsentType.valueOf(val);
                    mRules.put(rule.getKey(), new Rule(rule.getKey(), tp));
                } catch (IllegalArgumentException ignored) {}
            }
        }
    }

    private static class Serializer implements JsonSerializer<CtrlPermissions> {
        @Override
        public JsonElement serialize(CtrlPermissions src, Type typeOfSrc, JsonSerializationContext context) {
            JsonObject result = new JsonObject();
            JsonObject rulesObj = new JsonObject();

            for(Rule rule: src.mRules.values()) {
                rulesObj.add(rule.package_name, new JsonPrimitive(rule.consent.toString()));
            }

            result.add("rules", rulesObj);
            return result;
        }
    }

    private void save() {
        Gson gson = new GsonBuilder().registerTypeAdapter(getClass(), new Serializer())
                .create();

        String serialized = gson.toJson(this);
        //Log.d(TAG, "json: " + serialized);

        mPrefs.edit()
                .putString(PREF_NAME, serialized)
                .apply();
    }

    public void add(String package_name, ConsentType tp) {
        mRules.put(package_name, new Rule(package_name, tp));
        save();
    }

    public void remove(String package_name) {
        mRules.remove(package_name);
        save();
    }

    public void removeAll() {
        mRules.clear();
        save();
    }

    public Iterator<Rule> iterRules() {
        return mRules.values().iterator();
    }

    public boolean hasRules() {
        return !mRules.isEmpty();
    }

    public ConsentType getConsent(String package_name) {
        Rule rule = mRules.get(package_name);
        if(rule == null)
            return ConsentType.UNSPECIFIED;
        return rule.consent;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/FilterDescriptor.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.Status;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.DecryptionStatus;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.FilteringStatus;
import com.google.android.material.chip.Chip;
import com.google.android.material.chip.ChipGroup;

import java.io.Serializable;

public class FilterDescriptor implements Serializable {
    public Status status;
    public boolean showMasked;
    public boolean onlyBlacklisted;
    public boolean onlyCleartext;
    public FilteringStatus filteringStatus;
    public DecryptionStatus decStatus;
    public String iface;
    public int uid = -2; // this is persistent and used internally (AppDetailsActivity)
    public long minSize = 0;

    public FilterDescriptor() {
        clear();
        assert(!isSet());
    }

    public boolean isSet() {
        return (status != Status.STATUS_INVALID)
                || (decStatus != DecryptionStatus.INVALID)
                || (filteringStatus != FilteringStatus.INVALID)
                || (iface != null)
                || onlyBlacklisted
                || onlyCleartext
                || (uid != -2)
                || (minSize > 0)
                || (!showMasked && !PCAPdroid.getInstance().getVisualizationMask().isEmpty());
    }

    public boolean matches(ConnectionDescriptor conn) {
        return (showMasked || !PCAPdroid.getInstance().getVisualizationMask().matches(conn))
                && (!onlyBlacklisted || conn.isBlacklisted())
                && (!onlyCleartext || conn.isCleartext())
                && ((status == Status.STATUS_INVALID) || (conn.getStatus().equals(status)))
                && ((decStatus == DecryptionStatus.INVALID) || (conn.getDecryptionStatus() == decStatus))
                && ((filteringStatus == FilteringStatus.INVALID) || ((filteringStatus == FilteringStatus.BLOCKED) == conn.is_blocked))
                && ((iface == null) || (CaptureService.getInterfaceName(conn.ifidx).equals(iface)))
                && ((uid == -2) || (uid == conn.uid))
                && ((minSize == 0) || ((conn.sent_bytes + conn.rcvd_bytes) >= minSize));
    }

    private void addChip(LayoutInflater inflater, ChipGroup group, int id, String text) {
        Chip chip = (Chip) inflater.inflate(R.layout.active_filter_chip, group, false);
        chip.setId(id);
        chip.setText(text.toLowerCase());
        group.addView(chip);
    }

    public void toChips(LayoutInflater inflater, ChipGroup group) {
        Context ctx = inflater.getContext();

        if(!showMasked)
            addChip(inflater, group, R.id.not_hidden, ctx.getString(R.string.not_hidden_filter));
        if(onlyBlacklisted)
            addChip(inflater, group, R.id.blacklisted, ctx.getString(R.string.malicious_connection_filter));
        if(onlyCleartext)
            addChip(inflater, group, R.id.only_cleartext, ctx.getString(R.string.cleartext_connection));
        if(status != Status.STATUS_INVALID) {
            String label = String.format(ctx.getString(R.string.status_filter), ConnectionDescriptor.getStatusLabel(status, ctx));
            addChip(inflater, group, R.id.status_ind, label);
        }
        if(decStatus != DecryptionStatus.INVALID) {
            String label = String.format(ctx.getString(R.string.decryption_filter), ConnectionDescriptor.getDecryptionStatusLabel(decStatus, ctx));
            addChip(inflater, group, R.id.decryption_status, label);
        }
        if(filteringStatus != FilteringStatus.INVALID) {
            String label = ctx.getString(R.string.firewall_filter, ctx.getString((filteringStatus == FilteringStatus.BLOCKED) ?
                    R.string.blocked_connection_filter : R.string.allowed_connection_filter));
            addChip(inflater, group, R.id.firewall, label);
        }
        if(iface != null)
            addChip(inflater, group, R.id.capture_interface, String.format(ctx.getString(R.string.interface_filter), iface));

        group.setVisibility(group.getChildCount() > 0 ? View.VISIBLE : View.GONE);
    }

    // clear one of the filters of toChips
    public void clear(int filter_id) {
        if(filter_id == R.id.not_hidden)
            showMasked = true;
        else if(filter_id == R.id.blacklisted)
            onlyBlacklisted = false;
        else if(filter_id == R.id.only_cleartext)
            onlyCleartext = false;
        else if(filter_id == R.id.status_ind)
            status = Status.STATUS_INVALID;
        else if(filter_id == R.id.decryption_status)
            decStatus = DecryptionStatus.INVALID;
        else if(filter_id == R.id.firewall)
            filteringStatus = FilteringStatus.INVALID;
        else if(filter_id == R.id.capture_interface)
            iface = null;
    }

    public void clear() {
        showMasked = true;
        onlyBlacklisted = false;
        onlyCleartext = false;
        status = Status.STATUS_INVALID;
        decStatus = DecryptionStatus.INVALID;
        filteringStatus = FilteringStatus.INVALID;
        iface = null;
        minSize = 0;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/Geomodel.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import androidx.annotation.NonNull;

import com.maxmind.db.MaxMindDbConstructor;
import com.maxmind.db.MaxMindDbParameter;

import java.io.Serializable;

public class Geomodel {
    public static class CountryResult {
        public final Country country;

        @MaxMindDbConstructor
        public CountryResult (
                @MaxMindDbParameter(name="country") Country country
        ) {
            this.country = country;
        }
    }

    public static class Country implements Serializable {
        public final String isoCode;

        // https://db-ip.com/db/format/ip-to-country/mmdb.html
        @MaxMindDbConstructor
        public Country(
                @MaxMindDbParameter(name="iso_code") String isoCode) {
            this.isoCode = isoCode;
        }
    }

    public static class ASN implements Serializable {
        public final long number;
        public final String asname;

        public ASN() {
            number = 0;
            asname = "";
        }

        // https://dev.maxmind.com/geoip/docs/databases/asn?lang=en#blocks-files
        @MaxMindDbConstructor
        public ASN(
                @MaxMindDbParameter(name="autonomous_system_number") long number,
                @MaxMindDbParameter(name="autonomous_system_organization") String asname) {
            this.number = number;
            this.asname = asname;
        }

        public boolean isKnown() {
            return(number != 0);
        }

        @Override @NonNull
        public String toString() {
            if(number == 0)
                return "Unknown ASN";
            return "AS" + number + " - " + asname;
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/HttpLogFilterDescriptor.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;

import com.emanuelef.remote_capture.HttpLog;
import com.emanuelef.remote_capture.R;
import com.google.android.material.chip.Chip;
import com.google.android.material.chip.ChipGroup;

import java.io.Serializable;

public class HttpLogFilterDescriptor implements Serializable {
    public String method = null;
    public String contentType = null;
    public Integer httpStatus = null;
    public long minPayloadSize = 0;
    public Boolean decryptionError = null;

    public HttpLogFilterDescriptor() {
        clear();
        assert(!isSet());
    }

    public boolean isSet() {
        return (method != null)
                || (contentType != null)
                || (httpStatus != null)
                || (minPayloadSize > 0)
                || (decryptionError != null);
    }

    public boolean matches(HttpLog.HttpRequest req) {
        // Method filter
        if (method != null) {
            if (!req.method.equalsIgnoreCase(method))
                return false;
        }

        // Content-type filter
        if (contentType != null) {
            if (req.reply == null || req.reply.contentType == null || !req.reply.contentType.equals(contentType))
                return false;
        }

        // HTTP status filter
        if (httpStatus != null) {
            if (req.reply == null || req.reply.responseCode != httpStatus)
                return false;
        }

        // Payload size filter
        if (minPayloadSize > 0) {
            int totalSize = (req.reply != null) ? (req.bodyLength + req.reply.bodyLength) : req.bodyLength;
            if (totalSize < minPayloadSize)
                return false;
        }

        // Decryption error filter
        if (decryptionError != null) {
            boolean hasError = !req.decryptionError.isEmpty();
            if (decryptionError && !hasError)
                return false;
            if (!decryptionError && hasError)
                return false;
        }

        return true;
    }

    private void addChip(LayoutInflater inflater, ChipGroup group, int id, String text) {
        Chip chip = (Chip) inflater.inflate(R.layout.active_filter_chip, group, false);
        chip.setId(id);
        chip.setText(text.toLowerCase());
        group.addView(chip);
    }

    public void toChips(LayoutInflater inflater, ChipGroup group) {
        Context ctx = inflater.getContext();

        if (method != null) {
            String label = String.format(ctx.getString(R.string.method_filter), method);
            addChip(inflater, group, R.id.http_method_filter, label);
        }

        if (contentType != null) {
            String label = String.format(ctx.getString(R.string.content_type_filter), contentType);
            addChip(inflater, group, R.id.http_content_type_filter, label);
        }

        if (httpStatus != null) {
            String label = String.format(ctx.getString(R.string.status_filter), httpStatus.toString());
            addChip(inflater, group, R.id.http_status_filter, label);
        }

        if (decryptionError != null) {
            String err = ctx.getString(decryptionError ? R.string.decryption_error : R.string.ok);
            String label = String.format(ctx.getString(R.string.decryption_filter), err);
            addChip(inflater, group, R.id.decryption_status, label);
        }

        group.setVisibility(group.getChildCount() > 0 ? View.VISIBLE : View.GONE);
    }

    // clear one of the filters from toChips
    public void clear(int filter_id) {
        if (filter_id == R.id.http_method_filter)
            method = null;
        else if (filter_id == R.id.http_content_type_filter)
            contentType = null;
        else if (filter_id == R.id.http_status_filter)
            httpStatus = null;
        else if (filter_id == R.id.decryption_status)
            decryptionError = null;
    }

    public void clear() {
        method = null;
        contentType = null;
        httpStatus = null;
        minPayloadSize = 0;
        decryptionError = null;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/ListInfo.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import androidx.annotation.NonNull;
import androidx.collection.ArraySet;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.PCAPdroid;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.fragments.EditListFragment;
import com.emanuelef.remote_capture.model.MatchList.RuleType;

import java.util.Arrays;
import java.util.Collections;
import java.util.Set;


public class ListInfo {
    private final Type mType;

    public enum Type {
        VISUALIZATION_MASK,
        MALWARE_WHITELIST,
        BLOCKLIST,
        FIREWALL_WHITELIST,
        DECRYPTION_LIST,
    }

    public ListInfo(Type tp) {
        mType = tp;
    }

    public Type getType() {
        return mType;
    }

    public @NonNull MatchList getList() {
        switch(mType) {
            case VISUALIZATION_MASK:
                return PCAPdroid.getInstance().getVisualizationMask();
            case MALWARE_WHITELIST:
                return PCAPdroid.getInstance().getMalwareWhitelist();
            case BLOCKLIST:
                return PCAPdroid.getInstance().getBlocklist();
            case FIREWALL_WHITELIST:
                return PCAPdroid.getInstance().getFirewallWhitelist();
            case DECRYPTION_LIST:
                return PCAPdroid.getInstance().getDecryptionList();
        }

        assert false;
        return null;
    }

    public int getTitle() {
        switch(mType) {
            case VISUALIZATION_MASK:
                return R.string.hidden_connections_rules;
            case MALWARE_WHITELIST:
                return R.string.malware_whitelist_rules;
            case BLOCKLIST:
                return R.string.firewall_rules;
            case FIREWALL_WHITELIST:
                return R.string.whitelist;
            case DECRYPTION_LIST:
                return R.string.decryption_rules;
        }

        assert false;
        return 0;
    }

    public int getHelpString() {
        switch(mType) {
            case VISUALIZATION_MASK:
                return R.string.hidden_connections_help;
            case MALWARE_WHITELIST:
                return R.string.malware_whitelist_help;
            case BLOCKLIST:
                return 0;
            case FIREWALL_WHITELIST:
                return R.string.firewall_whitelist_help;
            case DECRYPTION_LIST:
                return R.string.decryption_rules_help;
        }

        assert false;
        return 0;
    }

    public Set<RuleType> getSupportedRules() {
        switch(mType) {
            case VISUALIZATION_MASK:
                return new ArraySet<>(Arrays.asList(RuleType.APP, RuleType.IP, RuleType.HOST, RuleType.COUNTRY, RuleType.PROTOCOL));
            case MALWARE_WHITELIST:
            case DECRYPTION_LIST:
            case BLOCKLIST:
                return new ArraySet<>(Arrays.asList(RuleType.APP, RuleType.IP, RuleType.HOST, RuleType.COUNTRY));
            case FIREWALL_WHITELIST:
                return new ArraySet<>(Collections.singletonList(RuleType.APP));
        }

        assert false;
        return null;
    }

    public void reloadRules() {
        switch(mType) {
            case MALWARE_WHITELIST:
                CaptureService.reloadMalwareWhitelist();
                break;
            case BLOCKLIST:
                if(CaptureService.isServiceActive())
                    CaptureService.requireInstance().reloadBlocklist();
                break;
            case FIREWALL_WHITELIST:
                if(CaptureService.isServiceActive())
                    CaptureService.requireInstance().reloadFirewallWhitelist();
                break;
            case DECRYPTION_LIST:
                CaptureService.reloadDecryptionList();
                break;
        }
    }

    public EditListFragment newFragment() {
        return EditListFragment.newInstance(mType);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/MatchList.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-25 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.Typeface;
import android.text.style.StyleSpan;
import android.util.ArrayMap;

import androidx.annotation.Nullable;
import androidx.collection.ArraySet;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.Cidr;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.Utils;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonSyntaxException;

import java.lang.reflect.Type;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/* Matches connections against the configured rules. */
public class MatchList {
    private static final String TAG = "MatchList";
    private static final StyleSpan italic = new StyleSpan(Typeface.ITALIC);
    private final Context mContext;
    private final SharedPreferences mPrefs;
    private final String mPrefName;
    private final ArrayList<ListChangeListener> mListeners = new ArrayList<>();
    private final ArrayList<Rule> mRules = new ArrayList<>();
    private final ArrayMap<String, Rule> mMatches = new ArrayMap<>();
    private final ArraySet<Integer> mUids = new ArraySet<>();
    private final ArrayList<Cidr> mCidrs = new ArrayList<>();
    private final ArrayMap<String, Integer> mPackageToUid = new ArrayMap<>();
    private final AppsResolver mResolver;
    private boolean mMigration = false;

    public enum RuleType {
        APP,
        IP,
        HOST,
        PROTOCOL,
        COUNTRY
    }

    public class Rule {
        private final String mLabel;
        private final RuleType mType;
        private final Object mValue;

        private Rule(RuleType tp, Object value) {
            mLabel = MatchList.getRuleLabel(mContext, tp, value.toString());
            mType = tp;
            mValue = value;
        }

        public String getLabel() {
            return mLabel;
        }

        public RuleType getType() {
            return mType;
        }

        public Object getValue() {
            return mValue;
        }

        @Override
        public boolean equals(@Nullable Object obj) {
            if(!(obj instanceof Rule))
                return super.equals(obj);

            Rule other = (Rule) obj;
            return((mType == other.mType) && (mValue.equals(other.mValue)));
        }
    }

    public interface ListChangeListener {
        void onListChanged();
    }

    // Accessed by JNI (see blacklist.c)
    public static class ListDescriptor {
        public final List<String> apps = new ArrayList<>();
        public final List<String> hosts = new ArrayList<>();
        public final List<String> ips = new ArrayList<>();
        public final List<String> countries = new ArrayList<>();
    }

    public MatchList(Context ctx, String pref_name) {
        mContext = ctx;
        mPrefName = pref_name; // The preference to bake the list rules
        mPrefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        mResolver = new AppsResolver(ctx);
        reload();
    }

    public void reload() {
        String serialized = mPrefs.getString(mPrefName, "");
        //Log.d(TAG, serialized);

        if(!serialized.isEmpty()) {
            fromJson(serialized);

            if(mMigration) {
                Log.i(TAG, "Migration completed");
                save();
                mMigration = false;
            }
        } else
            clear();
    }

    public void save() {
        mPrefs.edit()
                .putString(mPrefName, toJson(false))
                .apply();
    }

    public static String getRuleLabel(Context ctx, RuleType tp, String value) {
        int resid;

        switch(tp) {
            case APP:           resid = R.string.app_val; break;
            case IP:            resid = R.string.ip_address_val; break;
            case HOST:          resid = R.string.host_val; break;
            case PROTOCOL:      resid = R.string.protocol_val; break;
            case COUNTRY:       resid = R.string.country_val; break;
            default:
                return "";
        }

        if(tp == RuleType.APP) {
            // TODO handle cross-users/profiles?
            AppDescriptor app = AppsResolver.resolveInstalledApp(ctx.getPackageManager(), value, 0, false);
            if(app != null)
                value = app.getName();
        } else if(tp == RuleType.HOST)
            value = Utils.cleanDomain(value);
        else if(tp == RuleType.COUNTRY)
            value = Utils.getCountryName(ctx, value);

        return Utils.formatTextValue(ctx, null, italic, resid, value).toString();
    }

    public static String getCidrLabel(Context ctx, Cidr cidr) {
        return Utils.formatTextValue(ctx, null, italic, R.string.cidr_val, cidr.toString()).toString();
    }

    private static class Serializer implements JsonSerializer<MatchList> {
        @Override
        public JsonElement serialize(MatchList src, Type typeOfSrc, JsonSerializationContext context) {
            JsonObject result = new JsonObject();
            JsonArray rulesArr = new JsonArray();

            for(Rule rule : src.mRules) {
                JsonObject ruleObject = new JsonObject();

                ruleObject.add("type", new JsonPrimitive(rule.getType().name()));
                ruleObject.add("value", new JsonPrimitive(rule.getValue().toString()));

                rulesArr.add(ruleObject);
            }

            result.add("rules", rulesArr);
            return result;
        }
    }

    private int deserialize(JsonObject object, int max_rules) {
        int num_rules = 0;

        try {
            JsonArray ruleArray = object.getAsJsonArray("rules");
            if(ruleArray == null)
                return -1;

            clear(false);

            for(JsonElement el: ruleArray) {
                JsonObject ruleObj = el.getAsJsonObject();
                String typeStr = ruleObj.get("type").getAsString();
                String val = ruleObj.get("value").getAsString();
                RuleType type;

                try {
                    type = RuleType.valueOf(typeStr);
                } catch (IllegalArgumentException e) {
                    // can happen if format is changed
                    if(typeStr.equals("ROOT_DOMAIN")) {
                        Log.i(TAG, String.format("ROOT_DOMAIN %s migrated", val));
                        type = RuleType.HOST;
                        mMigration = true;
                    } else {
                        e.printStackTrace();
                        continue;
                    }
                }

                if(type == RuleType.APP) {
                    // Handle migration from the old uid-based format
                    try {
                        int uid = Integer.parseInt(val);

                        AppDescriptor app = mResolver.getAppByUid(uid, 0);
                        if(app != null) {
                            val = app.getPackageName();
                            Log.i(TAG, String.format("UID %d resolved to package %s", uid, val));
                            mMigration = true;
                        } else {
                            Log.w(TAG, "Ignoring unknown UID " + uid);
                            continue;
                        }
                    } catch (NumberFormatException ignored) {
                        // ok, package name
                    }

                    // Validate the uid->package_name mapping (see AppsResolver for more details).
                    // If the uid is mapped to a different package name, we must update the MatchList
                    // otherwise the user may not be able to remove the rule (see #257).
                    AppDescriptor app = mResolver.getAppByPackage(val, 0);
                    if((app != null) && !app.getPackageName().equals(val)) {
                        Log.i(TAG, "The UID " + app.getUid() + " mapping has changed from " + val + " to " + app.getPackageName());
                        val = app.getPackageName();
                        mMigration = true;
                    }
                }

                if(addRule(new Rule(type, val), false)) {
                    num_rules += 1;

                    if((max_rules > 0) && (num_rules >= max_rules))
                        break;
                }
            }

            notifyListeners();
        } catch (IllegalArgumentException | ClassCastException e) {
            e.printStackTrace();
            return -1;
        }

        return num_rules;
    }

    public boolean addIp(String ip)       { return addRule(new Rule(RuleType.IP, ip)); }
    public boolean addHost(String info)   { return addRule(new Rule(RuleType.HOST, Utils.cleanDomain(info))); }
    public boolean addProto(String proto) { return addRule(new Rule(RuleType.PROTOCOL, proto)); }
    public boolean addCountry(String country_code) { return addRule(new Rule(RuleType.COUNTRY, country_code)); }
    public boolean addApp(String pkg)     { return addRule(new Rule(RuleType.APP, pkg)); }
    public boolean addApp(int uid) {
        AppDescriptor app = mResolver.getAppByUid(uid, 0);
        if(app == null) {
            Log.e(TAG, "could not resolve UID " + uid);
            return false;
        }

        // apps must be identified by their package name to work across installations
        return addApp(app.getPackageName());
    }

    public void removeIp(String ip)       { removeRule(new Rule(RuleType.IP, ip)); }
    public void removeHost(String info)   { removeRule(new Rule(RuleType.HOST, Utils.cleanDomain(info))); }
    public void removeProto(String proto) { removeRule(new Rule(RuleType.PROTOCOL, proto)); }
    public void removeCountry(String country_code) { removeRule(new Rule(RuleType.COUNTRY, country_code)); }
    public void removeApp(String pkg)     { removeRule(new Rule(RuleType.APP, pkg)); }
    public void removeApp(int uid) {
        AppDescriptor app = mResolver.getAppByUid(uid, 0);
        if(app == null) {
            Log.e(TAG, "could not resolve UID " + uid);
            return;
        }

        removeApp(app.getPackageName());
    }

    static private String matchKey(RuleType tp, Object val) {
        return tp + "@" + val;
    }

    private boolean addCidr(String cidr_str) {
        Cidr cidr;
        try {
            cidr = new Cidr(cidr_str);
        } catch (UnknownHostException | IllegalArgumentException e) {
            return false;
        }

        // check if already exists
        for (Cidr test: mCidrs) {
            if (test.equals(cidr)) {
                return false;
            }
        }

        mCidrs.add(cidr);
        return true;
    }

    private boolean removeCidr(String cidr_str) {
        Cidr cidr;
        try {
            cidr = new Cidr(cidr_str);
        } catch (UnknownHostException | IllegalArgumentException e) {
            return false;
        }

        return mCidrs.remove(cidr);
    }

    private boolean addRule(Rule rule, boolean notify) {
        String value = rule.getValue().toString();
        String key = matchKey(rule.getType(), value);

        if(mMatches.containsKey(key))
            return false;

        if(rule.getType() == RuleType.APP) {
            // Need uid for match
            int uid = mResolver.getUid(value);
            if(uid == Utils.UID_NO_FILTER)
                return false;

            mPackageToUid.put(value, uid);
            mUids.add(uid);
        } else if (rule.getType() == RuleType.IP) {
            // Check if CIDR
            if (value.indexOf('/') >= 0) {
                if (!addCidr(value))
                    return false;
            }
        }

        mRules.add(rule);
        mMatches.put(key, rule);
        if(notify)
            notifyListeners();
        return true;
    }

    private boolean addRule(Rule rule) {
        return addRule(rule, true);
    }

    public int addRules(MatchList to_add) {
        int num_added = 0;

        for(Iterator<Rule> it = to_add.iterRules(); it.hasNext(); ) {
            Rule rule = it.next();

            if(addRule(rule, false))
                num_added++;
        }

        if(num_added > 0)
            notifyListeners();

        return num_added;
    }

    public void removeRule(Rule rule) {
        String val = rule.getValue().toString();
        String key = matchKey(rule.getType(), val);
        boolean removed = mRules.remove(rule);
        mMatches.remove(key);

        if(rule.getType() == RuleType.APP) {
            int uid = mResolver.getUid(val);
            if(uid != Utils.UID_NO_FILTER) {
                mPackageToUid.remove(val);
                mUids.remove(uid);
            } else
                Log.w(TAG, "removeRule: no uid found for package " + val);
        } else if (rule.getType() == RuleType.IP) {
            if ((val.indexOf('/') >= 0) && !removeCidr(val))
                Log.w(TAG, "removeRule: removing CIDR failed for " + val);
        }

        if(removed)
            notifyListeners();
    }

    public boolean matchesApp(int uid) {
        // match apps based on their uid (faster) rather than their package name
        return mUids.contains(uid);
    }

    public boolean matchesExactIP(String ip) {
        return mMatches.containsKey(matchKey(RuleType.IP, ip));
    }

    public Cidr matchesCidr(String ip) {
        if (!mCidrs.isEmpty()) {
            InetAddress address;

            try {
                address = InetAddress.getByName(ip);
            } catch (UnknownHostException ignored) {
                return null;
            }

            for (Cidr cidr : mCidrs) {
                if (cidr.isInRange(address))
                    return cidr;
            }
        }

        return null;
    }

    public boolean matchesProto(String l7proto) {
        return mMatches.containsKey(matchKey(RuleType.PROTOCOL, l7proto));
    }

    public boolean matchesExactHost(String host) {
        host = Utils.cleanDomain(host);
        return mMatches.containsKey(matchKey(RuleType.HOST, host));
    }

    public boolean matchesHost(String host) {
        // Keep in sync with the native blacklist_match_domain
        host = Utils.cleanDomain(host);

        // exact domain match
        if(matchesExactHost(host))
            return true;

        // 2nd-level domain match
        String domain = Utils.getSecondLevelDomain(host);
        return !domain.equals(host) && mMatches.containsKey(matchKey(RuleType.HOST, domain));
    }

    public boolean matchesCountry(String country_code) {
        return mMatches.containsKey(matchKey(RuleType.COUNTRY, country_code));
    }

    public boolean matches(ConnectionDescriptor conn) {
        if(mMatches.isEmpty())
            return false;

        boolean hasInfo = ((conn.info != null) && (!conn.info.isEmpty()));
        return(matchesApp(conn.uid) ||
                matchesExactIP(conn.dst_ip) ||
                (matchesCidr(conn.dst_ip) != null) ||
                matchesProto(conn.l7proto) ||
                matchesCountry(conn.country) ||
                (hasInfo && matchesHost(conn.info)));
    }

    public Iterator<Rule> iterRules() {
        return mRules.iterator();
    }

    public void clear(boolean notify) {
        boolean hasRules = mRules.size() > 0;
        mRules.clear();
        mMatches.clear();
        mPackageToUid.clear();
        mUids.clear();
        mCidrs.clear();

        if(notify && hasRules)
            notifyListeners();
    }

    public void clear() {
        clear(true);
    }

    public boolean isEmpty() {
        return(mRules.size() == 0);
    }

    public int getSize() {
        return mRules.size();
    }

    public String toJson(boolean pretty_print) {
        GsonBuilder builder = new GsonBuilder().registerTypeAdapter(getClass(), new Serializer());
        if(pretty_print)
            builder.setPrettyPrinting();
        Gson gson = builder.create();

        String serialized = gson.toJson(this);
        //Log.d(TAG, "toJson: " + serialized);

        return serialized;
    }

    public int fromJson(String json_str, int max_rules) {
        try {
            JsonElement el = JsonParser.parseString(json_str);
            if(!el.isJsonObject())
              return -1;

            return deserialize(el.getAsJsonObject(), max_rules);
        } catch (JsonSyntaxException e) {
            e.printStackTrace();
            return -1;
        }
    }

    public int fromJson(String json_str) {
        return fromJson(json_str, -1);
    }

    // can be used by a subclass to exempt specific app (e.g. Blocklist grace apps)
    protected boolean isExemptedApp(int uid) {
        return false;
    }

    /* Convert the MatchList into a ListDescriptor, which can be then loaded by JNI.
     * Only the following RuleTypes are supported: APP, IP, HOST, COUNTRY.
     */
    public ListDescriptor toListDescriptor() {
        final ListDescriptor rv = new ListDescriptor();

        Iterator<MatchList.Rule> it = iterRules();
        while(it.hasNext()) {
            MatchList.Rule rule = it.next();
            MatchList.RuleType tp = rule.getType();
            String val = rule.getValue().toString();

            if(tp.equals(MatchList.RuleType.HOST))
                rv.hosts.add(val);
            else if(tp.equals(MatchList.RuleType.IP))
                rv.ips.add(val);
            else if(tp.equals(MatchList.RuleType.COUNTRY))
                rv.countries.add(val);
            else if(!tp.equals(MatchList.RuleType.APP)) // apps handled below
                Log.w(TAG, "ListDescriptor does not support RuleType " + tp.name());
        }

        // Apps are matched via their UID
        for(int uid: mUids) {
            if(!isExemptedApp(uid))
                rv.apps.add(Integer.toString(uid));
        }

        return rv;
    }

    public void addListChangeListener(ListChangeListener listener) {
        mListeners.add(listener);
    }

    public void removeListChangeListener(ListChangeListener listener) {
        mListeners.remove(listener);
    }

    private void notifyListeners() {
        for(ListChangeListener listener: mListeners)
            listener.onListChanged();
    }

    /* Call this whenever a package name -> uid mapping may have changed.
     * True is returned when the mapping has been updated. In such a case,
     * the caller must reload any native rules based on this MatchList. */
    public boolean uidMappingChanged(String pkg) {
        if(!mMatches.containsKey(matchKey(RuleType.APP, pkg)))
            return false;

        boolean changed = false;
        Integer old_uid = mPackageToUid.get(pkg);
        AppDescriptor app = mResolver.getAppByPackage(pkg, 0);

        if((old_uid != null) && ((app == null) || (app.getUid() != old_uid))) {
            Log.i(TAG, "Remove old UID mapping of " + pkg + ": " + old_uid);

            mPackageToUid.remove(pkg);
            mUids.remove(old_uid);
            changed = true;

            old_uid = null; // possibly add the new UID mapping below
        }

        if((old_uid == null) && (app != null)) {
            int new_uid = app.getUid();
            Log.i(TAG, "Add UID mapping of " + pkg + ": " + new_uid);

            mPackageToUid.put(pkg, new_uid);
            mUids.add(new_uid);
            changed = true;
        }

        return changed;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/PayloadChunk.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import java.io.Serializable;

// A piece of payload. It may or may not correspond to a packet
public class PayloadChunk implements Serializable {
    public byte[] payload;
    public boolean is_sent;
    public long timestamp;
    public ChunkType type;
    public int stream_id;

    // HTTP
    public int httpResponseCode = 0;
    public String httpResponseStatus = "";
    public String httpMethod = "";
    public String httpHost = "";
    public String httpPath = "";
    public String httpQuery = "";
    public String httpContentType = "";
    public String httpVersion = "";
    public int httpBodyLength = 0;
    private boolean mHttpRst = false;

    // WebSocketDecoder data (when loading PCAP file)
    public int wsOpcode = -1;           // -1 = raw/undecoded, else opcode value
    public boolean wsIsFinal = true;    // FIN bit
    public boolean wsWasFragmented = false;  // True if reassembled from fragments

    // Serializable need in ConnectionPayload fragment
    public enum ChunkType implements Serializable {
        RAW,
        HTTP,
        WEBSOCKET
    }

    // the stream_id is the HTTP/2 stream ID; use 0 for HTTP/1
    public PayloadChunk(byte[] _payload, ChunkType _type, boolean _is_sent, long _timestamp, int _stream_id) {
        payload = _payload;
        type = _type;
        is_sent = _is_sent;
        timestamp = _timestamp;
        stream_id = _stream_id;
    }

    public PayloadChunk subchunk(int start, int size) {
        if (payload == null)
            return this;

        byte[] subarr = new byte[size];
        System.arraycopy(payload, start, subarr, 0, size);
        return new PayloadChunk(subarr, type, is_sent, timestamp, stream_id);
    }

    public PayloadChunk withPayload(byte[] the_payload) {
        return new PayloadChunk(the_payload, type, is_sent, timestamp, stream_id);
    }

    public void setHttpRst() {
        mHttpRst = true;
    }

    public boolean isHttp2Rst() {
        // http2.c uses a 0 length payload to indicate HTTP2 reset messages
        return mHttpRst || ((type == PayloadChunk.ChunkType.HTTP) &&
                (payload != null) && (payload.length == 0));
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/PortMapping.java`:

```java
package com.emanuelef.remote_capture.model;

import android.content.Context;
import android.content.SharedPreferences;

import androidx.preference.PreferenceManager;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Objects;

public class PortMapping {
    private static final String TAG = "PortMappings";
    private final SharedPreferences mPrefs;
    private ArrayList<PortMap> mMapping = new ArrayList<>();

    public static class PortMap {
        public final int ipproto;
        public final int orig_port;
        public final int redirect_port;
        @SerializedName("redirect_ip") // keep for backward compatibility
        public final String redirect_host;

        public PortMap(int proto, int port, int r_port, String r_host) {
            ipproto = proto;
            orig_port = port;
            redirect_port = r_port;
            redirect_host = r_host;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            PortMap portMap = (PortMap) o;
            return ipproto == portMap.ipproto && orig_port == portMap.orig_port &&
                    redirect_port == portMap.redirect_port && redirect_host.equals(portMap.redirect_host);
        }

        @Override
        public int hashCode() {
            return Objects.hash(ipproto, orig_port, redirect_port, redirect_host);
        }
    }

    public PortMapping(Context ctx) {
        mPrefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        reload();
    }

    public void clear() {
        mMapping.clear();
    }

    public void save() {
        mPrefs.edit()
                .putString(Prefs.PREF_PORT_MAPPING, toJson(false))
                .apply();
    }

    public void reload() {
        String serialized = mPrefs.getString(Prefs.PREF_PORT_MAPPING, "");
        if(!serialized.isEmpty())
            fromJson(serialized);
        else
            clear();
    }

    public boolean fromJson(String json_str) {
        try {
            Type listOfMyClassObject = new TypeToken<ArrayList<PortMap>>() {}.getType();
            Gson gson = new Gson();
            mMapping = gson.fromJson(json_str, listOfMyClassObject);
            return true;
        } catch (JsonParseException e) {
            e.printStackTrace();
            return false;
        }
    }

    public String toJson(boolean pretty_print) {
        GsonBuilder builder = new GsonBuilder();
        if(pretty_print)
            builder.setPrettyPrinting();
        Gson gson = builder.create();

        String serialized = gson.toJson(mMapping);
        //Log.d(TAG, "toJson: " + serialized);

        return serialized;
    }

    // returns false if the mapping already exists
    public boolean add(PortMap mapping) {
        if(mMapping.contains(mapping))
            return false;

        mMapping.add(mapping);
        return true;
    }

    public boolean remove(PortMap mapping) {
        return mMapping.remove(mapping);
    }

    public Iterator<PortMap> iter() {
        return mMapping.iterator();
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/model/Prefs.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.model;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.SharedPreferences;

import androidx.annotation.NonNull;
import androidx.collection.ArraySet;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.Billing;
import com.emanuelef.remote_capture.BuildConfig;
import com.emanuelef.remote_capture.MitmAddon;
import com.emanuelef.remote_capture.Utils;

import java.util.Set;

public class Prefs {
    public static final String DUMP_NONE = "none";
    public static final String DUMP_HTTP_SERVER = "http_server";
    public static final String DUMP_UDP_EXPORTER = "udp_exporter";
    public static final String DUMP_TCP_EXPORTER = "tcp_exporter";
    public static final String DUMP_PCAP_FILE = "pcap_file";
    public static final String DEFAULT_DUMP_MODE = DUMP_NONE;

    public static final String IP_MODE_IPV4_ONLY = "ipv4";
    public static final String IP_MODE_IPV6_ONLY = "ipv6";
    public static final String IP_MODE_BOTH = "both";
    public static final String IP_MODE_DEFAULT = IP_MODE_IPV4_ONLY;

    public static final String BLOCK_QUIC_MODE_NEVER = "never";
    public static final String BLOCK_QUIC_MODE_ALWAYS = "always";
    public static final String BLOCK_QUIC_MODE_TO_DECRYPT = "to_decrypt";
    public static final String BLOCK_QUIC_MODE_DEFAULT = BLOCK_QUIC_MODE_NEVER;

    public static final String PAYLOAD_MODE_NONE = "none";
    public static final String PAYLOAD_MODE_MINIMAL = "minimal";
    public static final String PAYLOAD_MODE_FULL = "full";
    public static final String DEFAULT_PAYLOAD_MODE = PAYLOAD_MODE_MINIMAL;

    // used to initialize the whitelist with some safe defaults
    public static final int FIREWALL_WHITELIST_INIT_VER = 1;

    public static final String PREF_COLLECTOR_IP_KEY = "collector_ip_address";
    public static final String PREF_COLLECTOR_PORT_KEY = "collector_port";
    public static final String PREF_SOCKS5_PROXY_IP_KEY = "socks5_proxy_ip_address";
    public static final String PREF_SOCKS5_PROXY_HOST_KEY = "socks5_proxy_host";
    public static final String PREF_SOCKS5_PROXY_PORT_KEY = "socks5_proxy_port";
    public static final String PREF_CAPTURE_INTERFACE = "capture_interface";
    public static final String PREF_MALWARE_DETECTION = "malware_detection";
    public static final String PREF_FIREWALL = "firewall";
    public static final String PREF_TLS_DECRYPTION_KEY = "tls_decryption";
    public static final String PREF_APP_FILTER = "app_filter";
    public static final String PREF_HTTP_SERVER_PORT = "http_server_port";
    public static final String PREF_PCAP_DUMP_MODE = "pcap_dump_mode_v2";
    public static final String PREF_IP_MODE = "ip_mode";
    public static final String PREF_APP_LANGUAGE = "app_language";
    public static final String PREF_ROOT_CAPTURE = "root_capture";
    public static final String PREF_VISUALIZATION_MASK = "vis_mask";
    public static final String PREF_MALWARE_WHITELIST = "malware_whitelist";
    public static final String PREF_DUMP_EXTENSIONS = "dump_extensions";
    public static final String PREF_BLOCKLIST = "bl";
    public static final String PREF_FIREWALL_WHITELIST_MODE = "firewall_wl_mode";
    public static final String PREF_FIREWALL_WHITELIST_INIT_VER = "firewall_wl_init";
    public static final String PREF_FIREWALL_WHITELIST = "firewall_whitelist";
    public static final String PREF_DECRYPTION_LIST = "decryption_list";
    public static final String PREF_START_AT_BOOT = "start_at_boot";
    public static final String PREF_SNAPLEN = "snaplen";
    public static final String PREF_MAX_PKTS_PER_FLOW = "max_pkts_per_flow";
    public static final String PREF_MAX_DUMP_SIZE = "max_dump_size";
    public static final String PREF_SOCKS5_ENABLED_KEY = "socks5_enabled";
    public static final String PREF_SOCKS5_AUTH_ENABLED_KEY = "socks5_auth_enabled";
    public static final String PREF_SOCKS5_USERNAME_KEY = "socks5_username";
    public static final String PREF_SOCKS5_PASSWORD_KEY = "socks5_password";
    public static final String PREF_TLS_DECRYPTION_SETUP_DONE = "tls_decryption_setup_ok";
    public static final String PREF_CA_INSTALLATION_SKIPPED = "ca_install_skipped";
    public static final String PREF_FULL_PAYLOAD = "full_payload";
    public static final String PREF_BLOCK_QUIC = "block_quic_mode";
    public static final String PREF_AUTO_BLOCK_PRIVATE_DNS = "auto_block_private_dns";
    public static final String PREF_APP_VERSION = "appver";
    public static final String PREF_LOCKDOWN_VPN_NOTICE_SHOWN = "vpn_lockdown_notice";
    public static final String PREF_VPN_EXCEPTIONS = "vpn_exceptions";
    public static final String PREF_PORT_MAPPING = "port_mapping";
    public static final String PREF_PORT_MAPPING_ENABLED = "port_mapping_enabled";
    public static final String PREF_BLOCK_NEW_APPS = "block_new_apps";
    public static final String PREF_PAYLOAD_NOTICE_ACK = "payload_notice";
    public static final String PREF_REMOTE_COLLECTOR_ACK = "remote_collector_notice";
    public static final String PREF_MITMPROXY_OPTS = "mitmproxy_opts";
    public static final String PREF_DNS_SERVER_V4 = "dns_v4";
    public static final String PREF_DNS_SERVER_V6 = "dns_v6";
    public static final String PREF_USE_SYSTEM_DNS = "system_dns";
    public static final String PREF_PCAPNG_ENABLED = "pcapng_format";
    public static final String PREF_RESTART_ON_DISCONNECT = "restart_on_disconnect";
    public static final String PREF_IGNORED_MITM_VERSION = "ignored_mitm_version";
    public static final String PREF_API_KEY = "api_key";
    public static final String PREF_FILENAME_PREFIX = "filename_prefix";

    public enum DumpMode {
        NONE,
        HTTP_SERVER,
        PCAP_FILE,
        UDP_EXPORTER,
        TCP_EXPORTER
    }

    public enum IpMode {
        IPV4_ONLY,
        IPV6_ONLY,
        BOTH,
    }

    public enum BlockQuicMode {
        NEVER,
        ALWAYS,
        TO_DECRYPT
    }

    public enum PayloadMode {
        NONE,
        MINIMAL,
        FULL
    }

    public static DumpMode getDumpMode(String pref) {
        switch (pref) {
            case DUMP_HTTP_SERVER:      return DumpMode.HTTP_SERVER;
            case DUMP_PCAP_FILE:        return DumpMode.PCAP_FILE;
            case DUMP_UDP_EXPORTER:     return DumpMode.UDP_EXPORTER;
            case DUMP_TCP_EXPORTER:     return DumpMode.TCP_EXPORTER;
            default:                    return DumpMode.NONE;
        }
    }

    public static IpMode getIPMode(String pref) {
        switch (pref) {
            case IP_MODE_IPV6_ONLY:     return IpMode.IPV6_ONLY;
            case IP_MODE_BOTH:          return IpMode.BOTH;
            default:                    return IpMode.IPV4_ONLY;
        }
    }

    public static BlockQuicMode getBlockQuicMode(String pref) {
        switch (pref) {
            case BLOCK_QUIC_MODE_ALWAYS:        return BlockQuicMode.ALWAYS;
            case BLOCK_QUIC_MODE_TO_DECRYPT:    return BlockQuicMode.TO_DECRYPT;
            default:                            return BlockQuicMode.NEVER;
        }
    }

    public static PayloadMode getPayloadMode(String pref) {
        switch (pref) {
            case PAYLOAD_MODE_MINIMAL:  return PayloadMode.MINIMAL;
            case PAYLOAD_MODE_FULL:     return PayloadMode.FULL;
            default:                    return PayloadMode.NONE;
        }
    }

    public static int getAppVersion(SharedPreferences p) {
        return p.getInt(PREF_APP_VERSION, 0);
    }

    public static void refreshAppVersion(SharedPreferences p) {
        p.edit().putInt(PREF_APP_VERSION, BuildConfig.VERSION_CODE).apply();
    }

    public static void setLockdownVpnNoticeShown(SharedPreferences p) {
        p.edit().putBoolean(PREF_LOCKDOWN_VPN_NOTICE_SHOWN, true).apply();
    }

    public static void setFirewallWhitelistInitialized(SharedPreferences p) {
        p.edit().putInt(PREF_FIREWALL_WHITELIST_INIT_VER, FIREWALL_WHITELIST_INIT_VER).apply();
    }

    public static void setPortMappingEnabled(SharedPreferences p, boolean enabled) {
        p.edit().putBoolean(PREF_PORT_MAPPING_ENABLED, enabled).apply();
    }

    /* Prefs with defaults */
    public static String getCollectorIp(SharedPreferences p) { return(p.getString(PREF_COLLECTOR_IP_KEY, "127.0.0.1")); }
    public static int getCollectorPort(SharedPreferences p)  { return(Integer.parseInt(p.getString(PREF_COLLECTOR_PORT_KEY, "1234"))); }
    public static DumpMode getDumpMode(SharedPreferences p)  { return(getDumpMode(p.getString(PREF_PCAP_DUMP_MODE, DEFAULT_DUMP_MODE))); }
    public static int getHttpServerPort(SharedPreferences p) { return(Integer.parseInt(p.getString(Prefs.PREF_HTTP_SERVER_PORT, "8080"))); }
    public static boolean getTlsDecryptionEnabled(SharedPreferences p) { return(p.getBoolean(PREF_TLS_DECRYPTION_KEY, false)); }
    public static boolean getSocks5Enabled(SharedPreferences p)     { return(p.getBoolean(PREF_SOCKS5_ENABLED_KEY, false)); }
    public static String getSocks5ProxyHost(SharedPreferences p)    { return(p.getString(PREF_SOCKS5_PROXY_IP_KEY, "0.0.0.0")); }
    public static int getSocks5ProxyPort(SharedPreferences p)       { return(Integer.parseInt(p.getString(Prefs.PREF_SOCKS5_PROXY_PORT_KEY, "8080"))); }
    public static boolean isSocks5AuthEnabled(SharedPreferences p)  { return(p.getBoolean(PREF_SOCKS5_AUTH_ENABLED_KEY, false)); }
    public static String getSocks5Username(SharedPreferences p)     { return(p.getString(PREF_SOCKS5_USERNAME_KEY, "")); }
    public static String getSocks5Password(SharedPreferences p)     { return(p.getString(PREF_SOCKS5_PASSWORD_KEY, "")); }
    public static Set<String> getAppFilter(SharedPreferences p)     { return(getStringSet(p, PREF_APP_FILTER)); }
    public static IpMode getIPMode(SharedPreferences p)          { return(getIPMode(p.getString(PREF_IP_MODE, IP_MODE_DEFAULT))); }
    public static BlockQuicMode getBlockQuicMode(SharedPreferences p) { return(getBlockQuicMode(p.getString(PREF_BLOCK_QUIC, BLOCK_QUIC_MODE_DEFAULT))); }
    public static String getAppLocale(SharedPreferences p) {
        String lang = p.getString(PREF_APP_LANGUAGE, "system");
        if ("system".equals(lang))
            return null;
        return lang;
    }
    public static boolean isRootCaptureEnabled(SharedPreferences p) { return(Utils.isRootAvailable() && p.getBoolean(PREF_ROOT_CAPTURE, false)); }
    public static boolean isPcapdroidMetadataEnabled(SharedPreferences p) { return(p.getBoolean(PREF_DUMP_EXTENSIONS, false)); }
    public static String getCaptureInterface(SharedPreferences p) { return(p.getString(PREF_CAPTURE_INTERFACE, "@inet")); }
    public static boolean isMalwareDetectionEnabled(Context ctx, SharedPreferences p) {
        return(Billing.newInstance(ctx).isPurchased(Billing.MALWARE_DETECTION_SKU)
                && p.getBoolean(PREF_MALWARE_DETECTION, true));
    }
    public static boolean isFirewallEnabled(Context ctx, SharedPreferences p) {
        // NOTE: firewall can be disabled at runtime
        return(Billing.newInstance(ctx).isFirewallVisible()
                && p.getBoolean(PREF_FIREWALL, true));
    }
    public static boolean isPcapngEnabled(Context ctx, SharedPreferences p)  {
        return(Billing.newInstance(ctx).isPurchased(Billing.PCAPNG_SKU)
                && p.getBoolean(PREF_PCAPNG_ENABLED, true));
    }
    public static boolean startAtBoot(SharedPreferences p)        { return(p.getBoolean(PREF_START_AT_BOOT, false)); }
    public static boolean restartOnDisconnect(SharedPreferences p)        { return(p.getBoolean(PREF_RESTART_ON_DISCONNECT, false)); }
    public static boolean isTLSDecryptionSetupDone(SharedPreferences p)     { return(p.getBoolean(PREF_TLS_DECRYPTION_SETUP_DONE, false)); }
    public static boolean getFullPayloadMode(SharedPreferences p) { return(p.getBoolean(PREF_FULL_PAYLOAD, false)); }
    public static boolean isPrivateDnsBlockingEnabled(SharedPreferences p) { return(p.getBoolean(PREF_AUTO_BLOCK_PRIVATE_DNS, true)); }
    public static boolean lockdownVpnNoticeShown(SharedPreferences p)      { return(p.getBoolean(PREF_LOCKDOWN_VPN_NOTICE_SHOWN, false)); }
    public static boolean blockNewApps(SharedPreferences p)       { return(p.getBoolean(PREF_BLOCK_NEW_APPS, false)); }
    public static boolean isFirewallWhitelistMode(SharedPreferences p)     { return(p.getBoolean(PREF_FIREWALL_WHITELIST_MODE, false)); }
    public static boolean isFirewallWhitelistInitialized(SharedPreferences p) { return(p.getInt(PREF_FIREWALL_WHITELIST_INIT_VER, 0) == FIREWALL_WHITELIST_INIT_VER); }
    public static String getMitmproxyOpts(SharedPreferences p)    { return(p.getString(PREF_MITMPROXY_OPTS, "")); }
    public static boolean isPortMappingEnabled(SharedPreferences p) { return(p.getBoolean(PREF_PORT_MAPPING_ENABLED, true)); }
    public static boolean useSystemDns(SharedPreferences p)     { return(p.getBoolean(PREF_USE_SYSTEM_DNS, true)); }
    public static String getDnsServerV4(SharedPreferences p)    { return(p.getString(PREF_DNS_SERVER_V4, "1.1.1.1")); }
    public static String getDnsServerV6(SharedPreferences p)    { return(p.getString(PREF_DNS_SERVER_V6, "2606:4700:4700::1111")); }
    public static boolean isIgnoredMitmVersion(SharedPreferences p, String v) { return p.getString(PREF_IGNORED_MITM_VERSION, "").equals(v); }
    public static String getApiKey(SharedPreferences p)         { return(p.getString(PREF_API_KEY, "")); }
    public static String getFilenamePrefix(SharedPreferences p)     { return(p.getString(PREF_FILENAME_PREFIX, "PCAPdroid_")); }

    // Gets a StringSet from the prefs
    // The preference should either be a StringSet or a String
    // An empty set is returned as the default value
    @SuppressLint("MutatingSharedPrefs")
    public static @NonNull Set<String> getStringSet(SharedPreferences p, String key) {
        Set<String> rv = null;

        try {
            rv = p.getStringSet(key, null);
        } catch (ClassCastException e) {
            // retry with string
            String s = p.getString(key, "");

            if (!s.isEmpty()) {
                rv = new ArraySet<>();
                rv.add(s);
            }
        }

        if (rv == null)
            rv = new ArraySet<>();

        return rv;
    }

    public static String asString(Context ctx) {
        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(ctx);

        // NOTE: possibly sensitive info like the collector IP address not shown
        return "DumpMode: " + getDumpMode(p) +
                "\nFullPayload: " + getFullPayloadMode(p) +
                "\nTLSDecryption: " + getTlsDecryptionEnabled(p) +
                "\nTLSSetupOk: " + isTLSDecryptionSetupDone(p) +
                "\nCAInstallSkipped: " + MitmAddon.isCAInstallationSkipped(ctx) +
                "\nBlockQuic: " + getBlockQuicMode(p) +
                "\nRootCapture: " + isRootCaptureEnabled(p) +
                "\nSocks5: " + getSocks5Enabled(p) +
                "\nBlockPrivateDns: " + isPrivateDnsBlockingEnabled(p) +
                "\nCaptureInterface: " + getCaptureInterface(p) +
                "\nMalwareDetection: " + isMalwareDetectionEnabled(ctx, p) +
                "\nFirewall: " + isFirewallEnabled(ctx, p) +
                "\nPCAPNG: " + isPcapngEnabled(ctx, p) +
                "\nBlockNewApps: " + blockNewApps(p) +
                "\nTargetApps: " + getAppFilter(p) +
                "\nIpMode: " + getIPMode(p) +
                "\nDumpExtensions: " + isPcapdroidMetadataEnabled(p) +
                "\nStartAtBoot: " + startAtBoot(p);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/pcap_dump/FileDumper.java`:

```java
package com.emanuelef.remote_capture.pcap_dump;

import android.content.Context;
import android.net.Uri;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.interfaces.PcapDumper;

import java.io.IOException;
import java.io.OutputStream;

public class FileDumper implements PcapDumper {
    public static final String TAG = "FileDumper";
    private final Context mContext;
    private final Uri mPcapUri;
    private boolean mSendHeader;
    private OutputStream mOutputStream;

    public FileDumper(Context ctx, Uri pcap_uri) {
        mContext = ctx;
        mPcapUri = pcap_uri;
        mSendHeader = true;
    }

    @Override
    public void startDumper() throws IOException {
        Log.d(TAG, "PCAP URI: " + mPcapUri);
        mOutputStream = mContext.getContentResolver().openOutputStream(mPcapUri, "rwt");
    }

    @Override
    public void stopDumper() throws IOException {
        mOutputStream.close();
    }

    @Override
    public String getBpf() {
        return "";
    }

    @Override
    public void dumpData(byte[] data) throws IOException {
        if(mSendHeader) {
            mSendHeader = false;
            mOutputStream.write(CaptureService.getPcapHeader());
        }

        mOutputStream.write(data);
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/pcap_dump/HTTPServer.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-22 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.pcap_dump;

import android.content.Context;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.interfaces.PcapDumper;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;

/*
 * A simple HTTP server which allows clients to download the PCAP dump over HTTP.
 */
public class HTTPServer implements PcapDumper, Runnable {
    private static final String TAG = "HTTPServer";
    private static final String PCAP_MIME = "application/vnd.tcpdump.pcap";
    private static final String PCAPNG_MIME = "application/x-pcapng";
    public static final int MAX_CLIENTS = 8;
    private ServerSocket mSocket;
    private boolean mRunning;
    private Thread mThread;
    private final int mPort;
    private final boolean mPcapngFormat;
    private final String mMimeType;
    private final Context mContext;

    // Shared state, must be synchronized
    private final ArrayList<ClientHandler> mClients = new ArrayList<>();

    public HTTPServer(Context context, int port, boolean pcapng_format) {
        mPort = port;
        mContext = context;
        mPcapngFormat = pcapng_format;
        mMimeType = pcapng_format ? PCAPNG_MIME : PCAP_MIME;
    }

    private static class ChunkedOutputStream extends FilterOutputStream {
        public ChunkedOutputStream(OutputStream out) throws IOException {
            super(out);
        }

        @Override
        public void write(byte[] data) throws IOException {
            // Chunked transfer coding
            // https://datatracker.ietf.org/doc/html/rfc2616#section-3.6.1
            out.write(String.format("%x\r\n", data.length).getBytes());
            out.write(data);
            out.write("\r\n".getBytes());
            out.flush();
        }

        public void finish() throws IOException {
            // Chunked transfer termination
            out.write("0\r\n\r\n".getBytes());
        }
    }

    /* Handles a single HTTP client. The normal workflow is:
     *  1. if isReadyForData then sendChunk
     *  2. if isClosed then remove this client
     *
     * No need for synchronization because sendChunk is only called when the runnable has terminated
     * (see isReadyForData).
     */
    private static class ClientHandler implements Runnable {
        static final int INPUT_BUFSIZE = 1024;
        Socket mSocket;
        final InputStream mInputStream;
        final OutputStream mOutputStream;
        final String mFname;
        final String mMimeType;
        ChunkedOutputStream mChunkedOutputStream;
        boolean mHasError;
        boolean mReadyForData;
        boolean mHeaderSent;
        boolean mIsClosed;

        public ClientHandler(Socket socket, String mimeType, String fname) throws IOException {
            mSocket = socket;
            mFname = fname;
            mInputStream = mSocket.getInputStream();
            mOutputStream = mSocket.getOutputStream();
            mMimeType = mimeType;
        }

        private void close(String error) {
            if(isClosed())
                return;

            if(error != null) {
                Log.i(TAG, "Client error: " + error);
                mHasError = true;
            } else if (mReadyForData) {
                try {
                    // Terminate the chunked stream
                    mChunkedOutputStream.finish();
                } catch (IOException ignored) {}
            }

            Utils.safeClose(mChunkedOutputStream);
            Utils.safeClose(mOutputStream);
            Utils.safeClose(mInputStream);
            Utils.safeClose(mSocket);
            mIsClosed = true;
        }

        public void stop() {
            // if running, will trigger a IOException
            Utils.safeClose(mSocket);
        }

        @Override
        public void run() {
            byte[] buf = new byte[INPUT_BUFSIZE];
            int sofar = 0;
            int req_size = 0;

            try {
                while(req_size <= 0) {
                    sofar += mInputStream.read(buf, sofar, buf.length - sofar);
                    req_size = Utils.getEndOfHTTPHeaders(buf);
                }

                Log.d(TAG, "Request headers end at " + req_size);
                //Log.d(TAG, "Req: " + new String(buf, 0, req_size, StandardCharsets.UTF_8));

                try(BufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(buf, 0, req_size)))) {
                    String line = reader.readLine();
                    if(line == null) {
                        close("Bad request");
                        return;
                    }

                    StringTokenizer tk = new StringTokenizer(line);
                    String method = tk.nextToken();
                    String url = tk.nextToken();

                    if(!method.equals("GET")) {
                        close("Bad request method");
                        return;
                    }

                    if(url.equals("/")) {
                        redirectToPcap();
                        close(null);
                    } else {
                        Log.d(TAG, "URL: " + url);

                        // NOTE: compressing with gzip is almost useless as most HTTP data is already
                        // gzip-compressed
                        mOutputStream.write(("HTTP/1.1 200 OK\r\n" +
                                "Content-Type: " + mMimeType + "\r\n" +
                                "Connection: close\r\n" +
                                "Transfer-Encoding: chunked\r\n" +
                                "\r\n"
                        ).getBytes());
                        mOutputStream.flush();

                        Log.d(TAG, "Ready for data");
                        mChunkedOutputStream = new ChunkedOutputStream(mOutputStream);
                        mReadyForData = true;
                    }
                }
            } catch (IOException | NoSuchElementException e) {
                close(e.getLocalizedMessage());
            }
        }

        /* Sends a 302 redirect to allow saving the PCAP file with a specific name */
        private void redirectToPcap() throws IOException {
            Log.d(TAG, "Redirecting to PCAP: " + mFname);

            mOutputStream.write(("HTTP/1.1 302 Found\r\n" +
                    "Location: /" + mFname + "\r\n" +
                    "\r\n"
            ).getBytes());
        }

        // Returns true if the client socket is closed
        public boolean isClosed() {
            return mIsClosed;
        }

        public boolean isReadyForData() {
            return mReadyForData;
        }

        // Send a chunk of data
        public void sendChunk(byte []data) {
            try {
                if(!mHeaderSent) {
                    mChunkedOutputStream.write(CaptureService.getPcapHeader());
                    mHeaderSent = true;
                }

                //Log.d(TAG, "+CHUNK [" + data.length + "]");
                mChunkedOutputStream.write(data);
            } catch (IOException e) {
                close(e.getLocalizedMessage());
            }
        }
    }

    @Override
    public void startDumper() throws IOException {
        mSocket = new ServerSocket();
        mSocket.setReuseAddress(true);
        mSocket.bind(new InetSocketAddress(mPort));

        mRunning = true;
        mThread = new Thread(this);
        mThread.start();
    }

    @Override
    public void run() {
        // NOTE: threads only handle the initial client communication.
        // After isReadyForData, clients are handled in dumpData.
        ExecutorService pool = Executors.newFixedThreadPool(MAX_CLIENTS);

        while(mRunning) {
            try {
                Socket client = mSocket.accept();

                synchronized(this) {
                    if(mClients.size() >= MAX_CLIENTS) {
                        Log.w(TAG, "Clients limit reached");
                        Utils.safeClose(client);
                        continue;
                    }
                }

                Log.i(TAG, "New client: " + client.getInetAddress().getHostAddress() + ":" + client.getPort());
                ClientHandler handler = new ClientHandler(client, mMimeType, Utils.getUniquePcapFileName(mContext, mPcapngFormat));

                try {
                    // will fail if pool is full
                    pool.submit(handler);

                    synchronized(this) {
                      mClients.add(handler);
                    }
                } catch (RejectedExecutionException e) {
                    Log.w(TAG, e.getLocalizedMessage());
                    Utils.safeClose(client);
                }
            } catch (IOException e) {
                if(!mRunning)
                    Log.d(TAG, "Got termination request");
                else
                    Log.d(TAG, e.getLocalizedMessage());
            }
        }

        Utils.safeClose(mSocket);

        // Terminate the running clients threads
        pool.shutdown();
        synchronized(this) {
            // Possibly wake clients blocked on read
            for(ClientHandler client: mClients) {
                if(!client.isReadyForData())
                    client.stop();
            }
        }
        while(true) {
            try {
                if(pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS))
                    break;
            } catch (InterruptedException ignored) {}
        }

        // Close the clients
        synchronized(this) {
            for(ClientHandler client: mClients) {
                if(!client.isClosed())
                    client.close(null);
            }

            mClients.clear();
        }
    }

    @Override
    public void stopDumper() throws IOException {
        mRunning = false;

        // Generate a socket exception
        mSocket.close();

        while((mThread != null) && (mThread.isAlive())) {
            try {
                Log.d(TAG, "Joining HTTP thread...");
                mThread.join();
            } catch (InterruptedException ignored) {}
        }
    }

    @Override
    public String getBpf() {
        return "not (host " + Utils.getLocalIPAddress(mContext) + " and tcp port " + mPort + ")";
    }

    @Override
    public void dumpData(byte[] data) throws IOException {
        synchronized(this) {
            Iterator<ClientHandler> it = mClients.iterator();

            while(it.hasNext()) {
                ClientHandler client = it.next();

                if(client.isReadyForData())
                    client.sendChunk(data);

                if(client.isClosed()) {
                    it.remove();
                    Log.d(TAG, "Client closed, active clients: " + mClients.size());
                }
            }
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/pcap_dump/TCPDumper.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-25 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.pcap_dump;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.interfaces.PcapDumper;

import java.io.DataOutputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.Iterator;

public class TCPDumper implements PcapDumper {
    private static final String TAG = "TCPDumper";
    private final InetSocketAddress mServer;
    private final boolean mPcapngFormat;
    private boolean mSendHeader;
    private Socket mSocket;
    private DataOutputStream mDataOut;

    public TCPDumper(InetSocketAddress server, boolean pcapngFormat) {
        mServer = server;
        mSendHeader = true;
        mPcapngFormat = pcapngFormat;
    }

    @Override
    public void startDumper() throws IOException {
        mSocket = new Socket();
        boolean ok = false;

        try {
            mSocket.connect(mServer, 1000);
            mDataOut = new DataOutputStream(mSocket.getOutputStream());
            ok = true;
        } finally {
            if (!ok)
                mSocket.close();
        }

        CaptureService.requireInstance().protect(mSocket);
    }

    @Override
    public void stopDumper() throws IOException {
        try {
            mDataOut.close();
        } finally {
            mSocket.close();
        }
    }

    @Override
    public String getBpf() {
        return "not (host " + mServer.getAddress().getHostAddress() + " and tcp port " + mServer.getPort() + ")";
    }

    @Override
    public void dumpData(byte[] data) throws IOException {
        if(mSendHeader) {
            mSendHeader = false;

            byte[] hdr = CaptureService.getPcapHeader();
            mDataOut.write(hdr);
        }

        Iterator<Integer> it = Utils.iterPcapRecords(data, mPcapngFormat);
        int pos = 0;

        while(it.hasNext()) {
            int rec_len = it.next();
            mDataOut.write(data, pos, rec_len);
            pos += rec_len;
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/pcap_dump/UDPDumper.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-25 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.pcap_dump;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Utils;
import com.emanuelef.remote_capture.interfaces.PcapDumper;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.util.Iterator;

public class UDPDumper implements PcapDumper {
    private static final String TAG = "UDPDumper";
    private final InetSocketAddress mServer;
    private final boolean mPcapngFormat;
    private boolean mSendHeader;
    private DatagramSocket mSocket;

    public UDPDumper(InetSocketAddress server, boolean pcapngFormat) {
        mServer = server;
        mSendHeader = true;
        mPcapngFormat = pcapngFormat;
    }

    @Override
    public void startDumper() throws IOException {
        mSocket = new DatagramSocket();
        CaptureService.requireInstance().protect(mSocket);
    }

    @Override
    public void stopDumper() throws IOException {
        mSocket.close();
    }

    @Override
    public String getBpf() {
        return "not (host " + mServer.getAddress().getHostAddress() + " and udp port " + mServer.getPort() + ")";
    }

    private void sendDatagram(byte[] data, int offset, int len) throws IOException {
        DatagramPacket request = new DatagramPacket(data, offset, len, mServer);
        mSocket.send(request);
    }

    @Override
    public void dumpData(byte[] data) throws IOException {
        if(mSendHeader) {
            mSendHeader = false;

            byte[] hdr = CaptureService.getPcapHeader();
            sendDatagram(hdr, 0, hdr.length);
        }

        Iterator<Integer> it = Utils.iterPcapRecords(data, mPcapngFormat);
        int pos = 0;

        while(it.hasNext()) {
            int rec_len = it.next();
            sendDatagram(data, pos, rec_len);
            pos += rec_len;
        }
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/views/AppSelectDialog.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.views;

import android.app.Dialog;
import android.content.SharedPreferences;
import android.view.View;
import android.widget.CheckBox;
import android.widget.TextView;

import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.SearchView;
import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.AppsLoader;
import com.emanuelef.remote_capture.Log;
import com.emanuelef.remote_capture.R;
import com.emanuelef.remote_capture.interfaces.AppsLoadListener;
import com.emanuelef.remote_capture.model.AppDescriptor;
import com.emanuelef.remote_capture.model.Prefs;
import com.pcapdroid.mitm.MitmAPI;

import java.util.ArrayList;
import java.util.List;

public class AppSelectDialog implements AppsLoadListener {
    private static final String TAG = "AppSelectDialog";
    private static boolean sShowSystemApps;
    private AppsListView mOpenAppsList;
    private TextView mEmptyAppsView;
    private Dialog mDialog;
    private AppsLoader mLoader;
    private AppCompatActivity mActivity;
    private AppSelectListener mListener;
    private final SharedPreferences mPrefs;
    private final int mTitleRes;

    public interface AppSelectListener {
        void onSelectedApp(AppDescriptor app);
        void onAppSelectionAborted();
    }

    public AppSelectDialog(AppCompatActivity activity, int title_res, AppSelectListener listener) {
        mActivity = activity;
        mPrefs = PreferenceManager.getDefaultSharedPreferences(mActivity);
        mListener = listener;
        mTitleRes = title_res;
        show();
    }

    @Override
    public void onAppsInfoLoaded(List<AppDescriptor> installedApps) {
        if(mOpenAppsList == null)
            return;

        mEmptyAppsView.setText(R.string.no_apps);

        if(Prefs.isTLSDecryptionSetupDone(mPrefs)) {
            // Remove the mitm addon from the list
            AppDescriptor mitmAddon = null;

            for(AppDescriptor cur: installedApps) {
                if(cur.getPackageName().equals(MitmAPI.PACKAGE_NAME)) {
                    mitmAddon = cur;
                    break;
                }
            }

            if(mitmAddon != null)
                installedApps.remove(mitmAddon);
        }

        Log.d(TAG, "loading " + installedApps.size() +" apps in dialog, icons=" + installedApps);
        mOpenAppsList.setApps(installedApps);
    }

    private void show() {
        mDialog = getDialog();
        mDialog.setOnCancelListener(dialog1 -> {
            if(mListener != null)
                mListener.onAppSelectionAborted();
        });
        mDialog.setOnDismissListener(dialog1 -> {
            mOpenAppsList = null;
        });

        mDialog.show();

        // NOTE: run this after dialog.show
        mOpenAppsList = mDialog.findViewById(R.id.apps_list);
        mEmptyAppsView = mDialog.findViewById(R.id.no_apps);
        mEmptyAppsView.setText(R.string.loading_apps);

        mLoader = (new AppsLoader(mActivity))
                .setAppsLoadListener(this)
                .loadAllApps();
    }

    private Dialog getDialog() {
        View dialogLayout = mActivity.getLayoutInflater().inflate(R.layout.apps_selector, null);
        SearchView searchView = dialogLayout.findViewById(R.id.apps_search);
        AppsListView apps = dialogLayout.findViewById(R.id.apps_list);
        TextView emptyText = dialogLayout.findViewById(R.id.no_apps);

        apps.setApps(new ArrayList<>());
        apps.setEmptyView(emptyText);
        searchView.setOnQueryTextListener(apps);

        CheckBox showSystemApps = dialogLayout.findViewById(R.id.show_system_apps);
        showSystemApps.setChecked(sShowSystemApps);
        apps.setShowSystemApps(sShowSystemApps);
        showSystemApps.setOnCheckedChangeListener((buttonView, isChecked) -> {
            sShowSystemApps = isChecked;
            apps.setShowSystemApps(isChecked);
        });

        AlertDialog.Builder builder = new androidx.appcompat.app.AlertDialog.Builder(mActivity);
        builder.setTitle(mTitleRes);
        builder.setView(dialogLayout);

        final AlertDialog alert = builder.create();
        alert.setCanceledOnTouchOutside(true);

        apps.setSelectedAppListener(app -> {
            if(mListener != null)
                mListener.onSelectedApp(app);

            // dismiss the dialog
            alert.dismiss();
        });

        return alert;
    }

    // call this to avoid context leaks
    public void abort() {
        mDialog.dismiss();
        mLoader.abort();
        mOpenAppsList = null;
        mActivity = null;
        mListener = null;
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/views/AppsListView.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.views;

import android.content.Context;
import android.util.AttributeSet;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.SearchView;

import com.emanuelef.remote_capture.adapters.AppsAdapter;
import com.emanuelef.remote_capture.model.AppDescriptor;

import java.util.ArrayList;
import java.util.List;

public class AppsListView extends EmptyRecyclerView implements SearchView.OnQueryTextListener {
    private List<AppDescriptor> mAllApps;
    private AppsAdapter mAdapter;
    private String mLastFilter;
    private boolean mShowSystemApps;

    public AppsListView(@NonNull Context context) {
        super(context);
        initialize(context);
    }

    public AppsListView(@NonNull Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        initialize(context);
    }

    public AppsListView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        initialize(context);
    }

    private void initialize(Context context) {
        mAllApps = null;
        setLayoutManager(new MyLinearLayoutManager(context));
        setHasFixedSize(true);
    }

    @Override
    public boolean onQueryTextSubmit(String query) {
        return true;
    }

    @Override
    public boolean onQueryTextChange(String newText) {
        mLastFilter = newText;
        if(mAllApps != null)
            mAdapter.setApps(getFilteredApps());
        return true;
    }

    interface OnSelectedAppListener {
        void onSelectedApp(AppDescriptor app);
    }

    private List<AppDescriptor> getFilteredApps() {
        String filter = (mLastFilter != null) ? mLastFilter.toLowerCase() : "";

        if(filter.isEmpty() && mShowSystemApps)
            return mAllApps;

        List<AppDescriptor> filtered = new ArrayList<>();
        for(AppDescriptor app : mAllApps) {
            if(!mShowSystemApps && app.isSystem())
                continue;
            if(!filter.isEmpty()
                    && !app.getPackageName().toLowerCase().contains(filter)
                    && !app.getName().toLowerCase().contains(filter))
                continue;
            filtered.add(app);
        }
        return filtered;
    }

    public void setApps(List<AppDescriptor> installedApps) {
        mAllApps = installedApps;
        List<AppDescriptor> apps = getFilteredApps();

        if(mAdapter == null) {
            mAdapter = new AppsAdapter(getContext(), apps);
            setAdapter(mAdapter);
        } else
            mAdapter.setApps(apps);
    }

    public void setShowSystemApps(boolean show) {
        mShowSystemApps = show;
        if(mAllApps != null)
            mAdapter.setApps(getFilteredApps());
    }

    public void setSelectedAppListener(final OnSelectedAppListener listener) {
        mAdapter.setOnClickListener(view -> {
            int itemPosition = getChildLayoutPosition(view);

            AppDescriptor app = mAdapter.getItem(itemPosition);

            if(app != null)
                listener.onSelectedApp(app);
        });
    }
}

```

`app/src/main/java/com/emanuelef/remote_capture/views/EmptyRecyclerView.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.views;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;

import androidx.annotation.Nullable;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.recyclerview.widget.SimpleItemAnimator;

// Adapter from https://gist.github.com/AlexZhukovich/537eaa1e3c82ef9f5d5cd22efdc80c54#file-emptyrecyclerview-java
public class EmptyRecyclerView extends RecyclerView {
    private View mEmptyView;

    /* Workaround for crash "java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid item position 0(offset:-1)".
     * See https://stackoverflow.com/questions/30220771/recyclerview-inconsistency-detected-invalid-item-position .
     * It can be reproduced by setting CaptureService.CONNECTIONS_LOG_SIZE = 4 and triggering a rollover right after inserting
     * item 3 in the register. It may take several tries to reproduce.
     * Possibly related issues:
     *  - https://issuetracker.google.com/issues?q=componentid:192731%2B%20IndexOutOfBoundsException%20Invalid%20item%20position
     * Another way to fix the issue is to disable the item animations via setItemAnimator(null).
     */
    public static class MyLinearLayoutManager extends LinearLayoutManager {
        public MyLinearLayoutManager(Context context) {
            super(context);
        }

        @Override
        public boolean supportsPredictiveItemAnimations() {
            return false;
        }
    }

    public EmptyRecyclerView(Context context) {
        super(context);
        init();
    }

    public EmptyRecyclerView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public EmptyRecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init();
    }

    private void init() {
        // Disable the item change animation since it cancels the touch event, making it impossible
        // to long click a continuously refreshed item.
        // https://stackoverflow.com/questions/58628885/handle-touch-events-for-recyclerview-with-frequently-changing-data
        ItemAnimator animator = getItemAnimator();
        if(animator instanceof SimpleItemAnimator)
            ((SimpleItemAnimator)animator).setSupportsChangeAnimations(false);

        ViewCompat.setOnApplyWindowInsetsListener(this, (v, windowInsets) -> {
            Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                    WindowInsetsCompat.Type.displayCutout() | WindowInsetsCompat.Type.ime());

            boolean isImeOpen = windowInsets.getInsets(WindowInsetsCompat.Type.ime()).bottom > 0;

            ViewGroup.MarginLayoutParams mlp = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
            mlp.topMargin = insets.top;
            mlp.bottomMargin = isImeOpen ? insets.bottom : 0;
            mlp.leftMargin = insets.left;
            mlp.rightMargin = insets.right;
            v.setLayoutParams(mlp);

            // when IME is open, apply as a margin for proper resizing
            // when not open, apply as a padding for an optimal edge-to-edge experience
            v.setPadding(0, 0, 0, !isImeOpen ? insets.bottom : 0);

            return windowInsets;
        });
        setClipToPadding(false);
    }

    private void initEmptyView() {
        if (mEmptyView != null) {
            mEmptyView.setVisibility(
                    getAdapter() == null || getAdapter().getItemCount() == 0 ? VISIBLE : GONE);
            EmptyRecyclerView.this.setVisibility(
                    getAdapter() == null || getAdapter().getItemCount() == 0 ? GONE : VISIBLE);
        }
    }

    final AdapterDataObserver observer = new AdapterDataObserver() {
        @Override
        public void onChanged() {
            super.onChanged();
            initEmptyView();
        }

        @Override
        public void onItemRangeInserted(int positionStart, int itemCount) {
            super.onItemRangeInserted(positionStart, itemCount);
            initEmptyView();
        }

        @Override
        public void onItemRangeRemoved(int positionStart, int itemCount) {
            super.onItemRangeRemoved(positionStart, itemCount);
            initEmptyView();
        }
    };

    @Override
    public void setAdapter(Adapter adapter) {
        var oldAdapter = getAdapter();
        super.setAdapter(adapter);

        if (oldAdapter != null) {
            oldAdapter.unregisterAdapterDataObserver(observer);
        }

        if (adapter != null) {
            adapter.registerAdapterDataObserver(observer);
        }

        initEmptyView();
    }

    public void setEmptyView(@Nullable View view) {
        if (mEmptyView != null)
            mEmptyView.setOnApplyWindowInsetsListener(null);

        mEmptyView = view;
        initEmptyView();

        if (view != null) {
            ViewCompat.setOnApplyWindowInsetsListener(view, (v, windowInsets) -> {
                Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars() |
                        WindowInsetsCompat.Type.displayCutout());
                v.setPadding(0, insets.top, 0, 0);

                return windowInsets;
            });
        }
    }
}
```

`app/src/main/java/com/emanuelef/remote_capture/views/PrefSpinner.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.views;

import android.content.Context;
import android.content.SharedPreferences;
import android.view.View;
import android.widget.AdapterView;
import android.widget.Spinner;

import androidx.preference.PreferenceManager;

import com.emanuelef.remote_capture.adapters.PrefSpinnerAdapter;

public class PrefSpinner implements AdapterView.OnItemSelectedListener {
    private final SharedPreferences mPrefs;
    private final PrefSpinnerAdapter mAdapter;
    private final String mPrefKey;

    private PrefSpinner(Spinner spinner, int keysRes, int labelsRes, int descrRes, String prefKey, String prefDefault) {
        Context context = spinner.getContext();
        mPrefs = PreferenceManager.getDefaultSharedPreferences(context);
        mPrefKey = prefKey;
        mAdapter = new PrefSpinnerAdapter(context, keysRes, labelsRes, descrRes);

        int curSel = mAdapter.getModePos(mPrefs.getString(prefKey, prefDefault));
        spinner.setAdapter(mAdapter);
        spinner.setSelection(curSel);
        spinner.setOnItemSelectedListener(this);
    }

    public static void init(Spinner spinner, int keysRes, int labelsRes, int descrRes, String prefKey, String prefDefault) {
        new PrefSpinner(spinner, keysRes, labelsRes, descrRes, prefKey, prefDefault);
    }

    @Override
    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
        PrefSpinnerAdapter.ModeInfo mode = (PrefSpinnerAdapter.ModeInfo) mAdapter.getItem(position);
        SharedPreferences.Editor editor = mPrefs.edit();

        editor.putString(mPrefKey, mode.key);
        editor.apply();
    }

    @Override
    public void onNothingSelected(AdapterView<?> parent) {}
}

```

`app/src/main/java/com/emanuelef/remote_capture/views/RuleAddDialog.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.views;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.TextView;

import androidx.appcompat.app.AlertDialog;

import com.emanuelef.remote_capture.R;
import com.google.android.material.textfield.TextInputEditText;
import com.google.android.material.textfield.TextInputLayout;

import java.util.Objects;

public class RuleAddDialog implements View.OnClickListener {
    private final Context mContext;
    private final AlertDialog mDialog;
    private final TextInputEditText mEditText;
    private final TextInputLayout mEditTextLayout;
    private final AutoCompleteTextView mComboText;
    private final TextInputLayout mComboLayout;
    private final ViewMode mViewMode;
    private final RuleAddListener mAdapter;
    private ArrayAdapter<String> mComboAdapter;

    private enum ViewMode {
        RULE_DIALOG_SIMPLE_TEXT,
        RULE_DIALOG_COMBO
    }

    public interface RuleAddListener {
        boolean addRule(String value, TextView field);
    }

    private RuleAddDialog(ViewMode viewMode, Context ctx, int title_res, RuleAddListener adapter) {
        mContext = ctx;
        mViewMode = viewMode;
        mAdapter = adapter;

        LayoutInflater inflater = LayoutInflater.from(ctx);
        View view = inflater.inflate(R.layout.add_rule_dialog, null);

        mComboLayout = view.findViewById(R.id.combo_field);
        mEditTextLayout = view.findViewById(R.id.text_field);
        mComboText = view.findViewById(R.id.combo_text);
        mEditText = view.findViewById(R.id.text_value);

        mDialog = new AlertDialog.Builder(ctx)
                .setView(view)
                .setTitle(title_res)
                .setPositiveButton(R.string.add_action, (dialogInterface, i) -> {})
                .setNegativeButton(R.string.cancel_action, (dialogInterface, i) -> {})
                .show();
        mDialog.setCanceledOnTouchOutside(false);
        mDialog.getButton(AlertDialog.BUTTON_POSITIVE)
                .setOnClickListener(this);
    }

    public static RuleAddDialog showText(Context ctx, int title_res, RuleAddListener adapter) {
        RuleAddDialog dialog = new RuleAddDialog(ViewMode.RULE_DIALOG_SIMPLE_TEXT, ctx, title_res, adapter);
        dialog.mEditTextLayout.setVisibility(View.VISIBLE);
        return dialog;
    }

    public static RuleAddDialog showCombo(Context ctx, int title_res, String[] values, RuleAddListener adapter) {
        RuleAddDialog dialog = new RuleAddDialog(ViewMode.RULE_DIALOG_COMBO, ctx, title_res, adapter);
        dialog.mComboLayout.setVisibility(View.VISIBLE);

        dialog.mComboAdapter = new ArrayAdapter<>(ctx, R.layout.dropdown_item, values);
        if(values.length > 0)
            dialog.mComboText.setText(values[0]);
        dialog.mComboText.setAdapter(dialog.mComboAdapter);

        return dialog;
    }

    @Override
    public void onClick(View v) {
        TextView field = getField();
        String text = Objects.requireNonNull(field.getText()).toString();

        if(text.isEmpty()) {
            field.setError(mContext.getString(R.string.required));
            return;
        }

        if(mComboAdapter != null) {
            // ensure that the value is in the selection list
            boolean found = false;

            for(int i=0; i<mComboAdapter.getCount(); i++) {
                String item = mComboAdapter.getItem(i);
                if(item.equals(text)) {
                    found = true;
                    break;
                }
            }

            if(!found) {
                field.setError(mContext.getString(R.string.invalid));
                return;
            }
        }

        if(!mAdapter.addRule(text, field))
            return;

        mDialog.dismiss();
    }

    public TextView getField() {
        if(mViewMode == ViewMode.RULE_DIALOG_SIMPLE_TEXT)
            return mEditText;
        else
            return mComboText;
    }
}

```

`app/src/main/java/com/pcapdroid/mitm/MitmAPI.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

package com.pcapdroid.mitm;

import java.io.Serializable;

/* API to integrate MitmAddon */
public class MitmAPI {
    public static final String PACKAGE_NAME = "com.pcapdroid.mitm";

    public static final String MITM_SERVICE = PACKAGE_NAME + ".MitmService";
    public static final int MSG_ERROR = -1;
    public static final int MSG_START_MITM = 1;
    public static final int MSG_GET_CA_CERTIFICATE = 2;
    public static final int MSG_STOP_MITM = 3;
    public static final int MSG_DISABLE_DOZE = 4;
    public static final String MITM_CONFIG = "mitm_config";
    public static final String CERTIFICATE_RESULT = "certificate";
    public static final String SSLKEYLOG_RESULT = "sslkeylog";

    public static final class MitmConfig implements Serializable {
        public int proxyPort;              // the SOCKS5 port to use to accept mitm-ed connections
        public boolean transparentMode;    // true to use transparent proxy mode, false to use SOCKS5 proxy mode
        public boolean sslInsecure;        // true to disable upstream certificate check
        public boolean dumpMasterSecrets;  // true to enable the TLS master secrets dump messages (similar to SSLKEYLOG)
        public boolean shortPayload;       // if true, only the initial portion of the payload will be sent
        public String proxyAuth;           // SOCKS5 proxy authentication, "user:pass"
        public String additionalOptions;   // provide additional options to mitmproxy
    }
}

```

`app/src/main/jni/CMakeLists.txt`:

```txt
project("PCAPdroid")
cmake_minimum_required(VERSION 3.18.1)

set(CMAKE_VERBOSE_MAKEFILE ON)
set(ROOTDIR ${CMAKE_CURRENT_SOURCE_DIR}/../../../..)

# Add debug symbols
# See packagingOptions.doNotStrip in build.gradle to avoid stripping
SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -fPIC")

# zdtun
set(ZDTUN_ROOT ${ROOTDIR}/submodules/zdtun)
include_directories(${ZDTUN_ROOT})
add_subdirectory(${ZDTUN_ROOT} zdtun_build)

# nDPI
set(NDPI_ROOT ${ROOTDIR}/submodules/nDPI)
include_directories(${NDPI_ROOT}/src/include ${NDPI_ROOT}/src/lib/third_party/include)

# base
include_directories(${CMAKE_CURRENT_SOURCE_DIR})

add_subdirectory(common)
add_subdirectory(pcapd)
add_subdirectory(core)
add_subdirectory(zstd)

```

`app/src/main/jni/common/CMakeLists.txt`:

```txt
project(common C)

ADD_LIBRARY(common STATIC uid_lru.c utils.c jni_utils.c uid_resolver.c
  ../third_party/libchash.c)

```

`app/src/main/jni/common/jni_utils.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#ifdef ANDROID

#include "jni_utils.h"
#include "common/utils.h"

/* ******************************************************* */

int jniCheckException(JNIEnv *env) {
    jthrowable ex = (*env)->ExceptionOccurred(env);
    if (ex) {
        (*env)->ExceptionDescribe(env);
        (*env)->ExceptionClear(env);
        (*env)->DeleteLocalRef(env, ex);
        return 1;
    }
    return 0;
}

/* ******************************************************* */

// Dumps JNI reference tables to logcat to detect possible reference leaks
void jniDumpReferences(JNIEnv *env) {
    jclass vm_class = jniFindClass(env, "dalvik/system/VMDebug");
    jmethodID dump_mid = jniGetStaticMethodID(env, vm_class, "dumpReferenceTables", "()V" );
    (*env)->CallStaticVoidMethod(env, vm_class, dump_mid);
    (*env)->DeleteLocalRef(env, vm_class);
}

/* ******************************************************* */

jclass jniFindClass(JNIEnv *env, const char *name) {
    jclass cls = (*env)->FindClass(env, name);
    if (cls == NULL)
        log_e("Class %s not found", name);
    else
        jniCheckException(env);
    return cls;
}

/* ******************************************************* */

jmethodID jniGetMethodID(JNIEnv *env, jclass cls, const char *name, const char *signature) {
    jmethodID method = (*env)->GetMethodID(env, cls, name, signature);
    if (method == NULL) {
        log_e("Method %s %s not found", name, signature);
        jniCheckException(env);
    }

    return method;
}

/* ******************************************************* */

jmethodID jniGetStaticMethodID(JNIEnv *env, jclass cls, const char *name, const char *signature) {
    jmethodID method = (*env)->GetStaticMethodID(env, cls, name, signature);
    if (method == NULL) {
        log_e("Static method %s %s not found", name, signature);
        jniCheckException(env);
    }

    return method;
}

/* ******************************************************* */

jfieldID jniFieldID(JNIEnv *env, jclass cls, const char *name, const char *type) {
    jfieldID field = (*env)->GetFieldID(env, cls, name, type);
    if(field == NULL) {
        log_e("Field %s(%s) not found", name, type);
        jniCheckException(env);
    }

    return field;
}

/* ******************************************************* */

jobject jniEnumVal(JNIEnv *env, const char *class_name, const char *enum_key) {
    char buf[512];

    jclass cls = jniFindClass(env, class_name);
    if(cls == NULL)
        return NULL;

    snprintf(buf, sizeof(buf), "L%s;", class_name);
    jfieldID field = (*env)->GetStaticFieldID(env, cls, enum_key, buf);
    if(field == NULL) {
        log_e("Static field %s(%s) not found", enum_key, buf);
        jniCheckException(env);
        return NULL;
    }

    jobject val = (*env)->GetStaticObjectField(env, cls, field);
    if(!val) {
        log_e("Enum value %s not found in \"%s\"", enum_key, class_name);
        jniCheckException(env);
    }

    (*env)->DeleteLocalRef(env, cls);
    return val;
}

#endif

```

`app/src/main/jni/common/jni_utils.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#ifndef __JNI_UTILS_H__
#define __JNI_UTILS_H__

#ifdef ANDROID

#include <jni.h>

jclass jniFindClass(JNIEnv *env, const char *name);
jmethodID jniGetMethodID(JNIEnv *env, jclass cls, const char *name, const char *signature);
jmethodID jniGetStaticMethodID(JNIEnv *env, jclass cls, const char *name, const char *signature);
jfieldID jniFieldID(JNIEnv *env, jclass cls, const char *name, const char *type);
jobject jniEnumVal(JNIEnv *env, const char *class_name, const char *enum_key);
int jniCheckException(JNIEnv *env);
void jniDumpReferences(JNIEnv *env);

#else // if ANDROID

#include <stdint.h>

// https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html
typedef uint8_t  jboolean;
typedef int8_t   jbyte;
typedef int32_t  jint;
typedef uint64_t jlong;

#endif // ANDROID

#endif // __JNI_UTILS_H__

```

`app/src/main/jni/common/memtrack.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

#ifndef PCAPDROID_MEMTRACK_H
#define PCAPDROID_MEMTRACK_H

#include <malloc.h>
#include <string.h>
#include <stdatomic.h>

// Uncomment to track allocations (with a performance impact)
//#define PCAPDROID_TRACK_ALLOCS

enum memtrack_scope {
    MEMTRACK_PCAPDROID = 0,
    MEMTRACK_NDPI = 1,
    MEMTRACK_BLACKLIST = 2,
    MEMTRACK_UTHASH = 3,
    //MEMTRACK_ZDTUN = 4, // TODO

    MEMTRACK_SCOPE_N
};

typedef struct {
    atomic_size_t scopes[MEMTRACK_SCOPE_N];
} memtrack_t;

extern memtrack_t memtrack;

#ifdef PCAPDROID_TRACK_ALLOCS

static void* _pcapdroid_malloc(size_t size, enum memtrack_scope scope) {
    void *ptr = malloc(size);
    if(ptr)
        memtrack.scopes[scope] += malloc_usable_size(ptr);
    return ptr;
}

static void* _pcapdroid_calloc(size_t nmemb, size_t size, enum memtrack_scope scope) {
    void *ptr = calloc(nmemb, size);
    if(ptr)
        memtrack.scopes[scope] += malloc_usable_size(ptr);
    return ptr;
}

static void _pcapdroid_free(void *ptr, enum memtrack_scope scope) {
    memtrack.scopes[scope] -= malloc_usable_size(ptr);
    free(ptr);
}

static void* _pcapdroid_realloc(void *ptr, size_t size, enum memtrack_scope scope) {
    memtrack.scopes[scope] -= malloc_usable_size(ptr);
    ptr = realloc(ptr, size);
    if(ptr)
        memtrack.scopes[scope] += malloc_usable_size(ptr);
    return ptr;
}

static char* _pcapdroid_strndup(const char *s, size_t n, enum memtrack_scope scope) {
    size_t l = strlen(s);
    if (l > n)
        l = n;

    char *c = (char*) _pcapdroid_malloc(l + 1, scope);
    if(!c)
        return NULL;
    memcpy(c, s, l);
    c[l] = 0;
    return c;
}

static inline char* _pcapdroid_strdup(const char *s, enum memtrack_scope scope) {
    return _pcapdroid_strndup(s, (size_t)-1, scope);
}

static inline void* pd_ndpi_malloc(size_t size) {
    return _pcapdroid_malloc(size, MEMTRACK_NDPI);
}

static inline void pd_ndpi_free(void *ptr) {
    return _pcapdroid_free(ptr, MEMTRACK_NDPI);
}

#define pd_malloc(size)         _pcapdroid_malloc(size, MEMTRACK_PCAPDROID)
#define pd_calloc(num, size)    _pcapdroid_calloc(num, size, MEMTRACK_PCAPDROID)
#define pd_free(ptr)            _pcapdroid_free(ptr, MEMTRACK_PCAPDROID)
#define pd_realloc(ptr, size)   _pcapdroid_realloc(ptr, size, MEMTRACK_PCAPDROID)
#define pd_strdup(str)          _pcapdroid_strdup(str, MEMTRACK_PCAPDROID)
#define pd_strndup(str, n)      _pcapdroid_strndup(str, n, MEMTRACK_PCAPDROID)
#define bl_malloc(str)          _pcapdroid_malloc(str, MEMTRACK_BLACKLIST)
#define bl_calloc(num, size)    _pcapdroid_calloc(num, size, MEMTRACK_BLACKLIST)
#define bl_free(ptr)            _pcapdroid_free(ptr, MEMTRACK_BLACKLIST)
#define bl_strdup(str)          _pcapdroid_strdup(str, MEMTRACK_BLACKLIST)

#include "third_party/uthash.h"
#undef uthash_malloc
#define uthash_malloc(sz)       _pcapdroid_malloc(sz, MEMTRACK_UTHASH)
#undef uthash_free
#define uthash_free(ptr, sz)    _pcapdroid_free(ptr, MEMTRACK_UTHASH)

#else // PCAPDROID_TRACK_ALLOCS

#define pd_malloc malloc
#define pd_calloc calloc
#define pd_free free
#define pd_realloc realloc
#define pd_strdup strdup
#define pd_strndup strndup

#define bl_malloc malloc
#define bl_calloc calloc
#define bl_free free
#define bl_strdup strdup

#endif // PCAPDROID_TRACK_ALLOCS

#endif

```

`app/src/main/jni/common/uid_lru.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

// A simple LRU implementation based on uthash
// Inspired by https://jehiah.cz/a/uthash

#include <stdlib.h>
#include "utils.h"
#include "uid_lru.h"
#include "third_party/uthash.h"

struct cache_entry {
    zdtun_5tuple_t key;
    int uid;
    UT_hash_handle hh;
};

struct uid_lru {
    int max_size;
    struct cache_entry *cache;
};

/* ******************************************************* */

uid_lru_t* uid_lru_init(int max_size) {
    uid_lru_t *lru = (uid_lru_t*) pd_malloc(sizeof(uid_lru_t));

    if(!lru)
        return NULL;

    lru->max_size = max_size;
    lru->cache = NULL;

    return lru;
}

/* ******************************************************* */

void uid_lru_destroy(uid_lru_t *lru) {
    struct cache_entry *entry, *tmp;

    HASH_ITER(hh, lru->cache, entry, tmp) {
        HASH_DELETE(hh, lru->cache, entry);
        pd_free(entry);
    }

    pd_free(lru);
}

/* ******************************************************* */

static struct cache_entry* uid_lru_find_entry(uid_lru_t *lru, const zdtun_5tuple_t *tuple) {
    struct cache_entry *entry;

    HASH_FIND(hh, lru->cache, tuple, sizeof(zdtun_5tuple_t), entry);

    if(entry) {
        // Bring the entry to the front of the list
        HASH_DELETE(hh, lru->cache, entry);
        HASH_ADD(hh, lru->cache, key, sizeof(zdtun_5tuple_t), entry);

        return(entry);
    }

    return NULL;
}

/* ******************************************************* */

void uid_lru_add(uid_lru_t *lru, const zdtun_5tuple_t *tuple, int uid) {
    struct cache_entry *entry, *tmp;

    entry = pd_malloc(sizeof(struct cache_entry));

    if(!entry)
        return;

    entry->key = *tuple;
    entry->uid = uid;

    HASH_ADD(hh, lru->cache, key, sizeof(zdtun_5tuple_t), entry);

    if(HASH_COUNT(lru->cache) > lru->max_size) {
        // uthash guarantees that iteration order is same as insertion order
        // see https://troydhanson.github.io/uthash/userguide.html#_sorting
        HASH_ITER(hh, lru->cache, entry, tmp) {
            // delete the oldest entry
            HASH_DELETE(hh, lru->cache, entry);
            pd_free(entry);
            break;
        }
    }
}

/* ******************************************************* */

int uid_lru_find(uid_lru_t *lru, const zdtun_5tuple_t *tuple) {
    struct cache_entry *entry = uid_lru_find_entry(lru, tuple);

    return(entry ? entry->uid : -2);
}

/* ******************************************************* */

int uid_lru_size(uid_lru_t *lru) {
    return HASH_COUNT(lru->cache);
}
```

`app/src/main/jni/common/uid_lru.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

#ifndef __UID_LRU_H__
#define __UID_LRU_H__

#include "zdtun.h"

typedef struct uid_lru uid_lru_t;

uid_lru_t* uid_lru_init(int max_size);
void uid_lru_destroy(uid_lru_t *lru);
void uid_lru_add(uid_lru_t *lru, const zdtun_5tuple_t *tuple, int uid);
int uid_lru_find(uid_lru_t *lru, const zdtun_5tuple_t *tuple);
int uid_lru_size(uid_lru_t *lru);

#endif // __UID_LRU_H__

```

`app/src/main/jni/common/uid_resolver.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <netinet/in.h>

#include "uid_resolver.h"
#include "utils.h"

/* ******************************************************* */

struct uid_resolver {
#ifdef ANDROID
    jint sdk;
    JNIEnv *env;
    jobject vpn_service;
    jmethodID getUidQ;
#endif
};

/* ******************************************************* */

// src_port and dst_port are in HBO.
static int get_uid_proc(int ipver, int ipproto, const char *conn_shex,
                         const char *conn_dhex, u_int16_t src_port, u_int16_t dst_port) {
    char *proc;

    // Get proc file name
    switch(ipproto) {
        case IPPROTO_TCP:
            proc = (ipver == 4) ? "/proc/net/tcp" : "/proc/net/tcp6";
            break;
        case IPPROTO_UDP:
            proc = (ipver == 4) ? "/proc/net/udp" : "/proc/net/udp6";
            break;
        case IPPROTO_ICMP:
        case IPPROTO_ICMPV6:
            proc = (ipver == 4) ? "/proc/net/icmp" : "/proc/net/icmp6";
            break;
        default:
            return UID_UNKNOWN;
    }

    FILE *fd = fopen(proc, "r");

    if (fd == NULL) {
        log_e("fopen(%s) failed[%d]: %s", proc, errno, strerror(errno));
        return UID_UNKNOWN;
    }

    // Parse proc file
    char line[256];
    int lines = 0;
    int rv = UID_UNKNOWN;
    int sport, dport, uid;
    char shex[33], dhex[33];
    const char *zero = (ipver == 4 ? "00000000" : "00000000000000000000000000000000");
    const char *fmt = (ipver == 4
                       ? "%*d: %8s:%X %8s:%X %*X %*X:%*X %*X:%*X %*X %d"
                       : "%*d: %32s:%X %32s:%X %*X %*X:%*X %*X:%*X %*X %d");

    while(fgets(line, sizeof(line), fd) != NULL) {
        // skip header
        if(!lines++)
            continue;

        //log_i("[try] %s", line);

        if(sscanf(line, fmt, shex, &sport, dhex, &dport, &uid) == 5) {
            //log_d("[try] %s:%d -> %s:%d [%d]", shex, sport, dhex, dport, uid);

            if((sport == src_port)
                    && ((dport == dst_port) || (dport == 0 /* ANY */))
                    && (!strcmp(conn_dhex, dhex) || !strcmp(dhex, zero /* ANY */))
                    && (!strcmp(conn_shex, shex) || !strcmp(shex, zero /* ANY */))) {
                // found
                rv = uid;
                break;
            }
        }
    }

    fclose(fd);

    return(rv);
}

/* ******************************************************* */

#if 0
static char* tohex(const uint8_t *src, int srcsize, char *dst, int dstsize) {
    static const char *hex = "0123456789ABCDEF";
    int j = 0;

    for(int i=0; (i < srcsize) && (j+2 < dstsize); i++) {
        dst[j++] = hex[(src[i] >> 4)];
        dst[j++] = hex[(src[i] & 0x0F)];
    }

    dst[j] = '\0';

    return dst;
}
#endif

/* ******************************************************* */

static int get_uid_slow(const zdtun_5tuple_t *conn_info) {
    char shex[33], dhex[33];
    int rv;

    //clock_t start = clock();

    u_int16_t sport = ntohs(conn_info->src_port);
    u_int16_t dport = ntohs(conn_info->dst_port);

    if(conn_info->ipver == 4) {
        sprintf(shex, "%08X", conn_info->src_ip.ip4);
        sprintf(dhex, "%08X", conn_info->dst_ip.ip4);

        rv = get_uid_proc(4, conn_info->ipproto, shex, dhex, sport, dport);

        if (rv == UID_UNKNOWN) {
            // Search for IPv4-mapped IPv6 addresses
            // https://tools.ietf.org/html/rfc3493#section-3.7
            sprintf(shex, "0000000000000000FFFF0000%08X", conn_info->src_ip.ip4);
            sprintf(dhex, "0000000000000000FFFF0000%08X", conn_info->dst_ip.ip4);

            rv = get_uid_proc(6, conn_info->ipproto, shex, dhex, sport, dport);
        }
    } else {
        struct in6_addr srcip6 = conn_info->src_ip.ip6;
        struct in6_addr dstip6 = conn_info->dst_ip.ip6;
        const uint32_t *src = srcip6.s6_addr32;
        const uint32_t *dst = dstip6.s6_addr32;

        sprintf(shex, "%08X%08X%08X%08X", src[0], src[1], src[2], src[3]);
        sprintf(dhex, "%08X%08X%08X%08X", dst[0], dst[1], dst[2], dst[3]);

        //log_i("HEX %s %s", shex, dhex);

        rv = get_uid_proc(6, conn_info->ipproto, shex, dhex, sport, dport);
    }

    //double cpu_time_used = ((double) (clock() - start)) / CLOCKS_PER_SEC;
    //log_d("cpu_time_used %f", cpu_time_used);

    return rv;
}

/* ******************************************************* */

#ifdef ANDROID

static int get_uid_q(uid_resolver_t *resolver,
                      const zdtun_5tuple_t *conn_info) {
    JNIEnv *env = resolver->env;
    int juid = UID_UNKNOWN;
    int version = conn_info->ipver;
    int family = (version == 4) ? AF_INET : AF_INET6;
    char srcip[INET6_ADDRSTRLEN];
    char dstip[INET6_ADDRSTRLEN];

    // getUidQ only works for TCP/UDP connections
    if((conn_info->ipproto != IPPROTO_TCP) && (conn_info->ipproto != IPPROTO_UDP))
        return UID_UNKNOWN;

    if(resolver->getUidQ == NULL) {
        // Resolve method
        jclass vpn_service_cls = (*env)->GetObjectClass(env, resolver->vpn_service);
        resolver->getUidQ = jniGetMethodID(env, vpn_service_cls, "getUidQ",
                "(ILjava/lang/String;ILjava/lang/String;I)I");

        if(!resolver->getUidQ)
            return UID_UNKNOWN;
    }

    u_int16_t sport = ntohs(conn_info->src_port);
    u_int16_t dport = ntohs(conn_info->dst_port);

    inet_ntop(family, &conn_info->src_ip, srcip, sizeof(srcip));
    inet_ntop(family, &conn_info->dst_ip, dstip, sizeof(dstip));

    jstring jsource = (*env)->NewStringUTF(env, srcip);
    jstring jdest = (*env)->NewStringUTF(env, dstip);

    if((jsource != NULL) && (jdest != NULL)) {
        juid = (*env)->CallIntMethod(
            env, resolver->vpn_service, resolver->getUidQ,
            conn_info->ipproto, jsource, sport, jdest, dport);
        jniCheckException(env);
    }

    (*env)->DeleteLocalRef(env, jsource);
    (*env)->DeleteLocalRef(env, jdest);

    return juid;
}

#endif

/* ******************************************************* */

#ifdef ANDROID

uid_resolver_t* init_uid_resolver(jint sdk_version, JNIEnv *env, jobject vpn) {
    uid_resolver_t *rv = pd_calloc(1, sizeof(uid_resolver_t));

    if(!rv) {
        log_e("calloc uid_resolver_t failed");
        return NULL;
    }

    rv->sdk = sdk_version;
    rv->env = env;
    rv->vpn_service = vpn;

    return rv;
}

#endif

uid_resolver_t* init_uid_resolver_from_proc() {
#ifdef ANDROID
    return(init_uid_resolver(0, NULL, 0));
#else
    return pd_calloc(1, sizeof(uid_resolver_t));
#endif
}

/* ******************************************************* */

void destroy_uid_resolver(uid_resolver_t *resolver) {
    pd_free(resolver);
}

/* ******************************************************* */

int get_uid(uid_resolver_t *resolver, const zdtun_5tuple_t *conn_info) {
#ifdef ANDROID
    if(resolver->sdk > 28) // Android 9 Pie
        return(get_uid_q(resolver, conn_info));
    else
#endif
        return(get_uid_slow(conn_info));
}

```

`app/src/main/jni/common/uid_resolver.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

#ifndef __UID_RESOLVER_H__
#define __UID_RESOLVER_H__

#include "jni_utils.h"
#include "zdtun.h"

#define UID_UNKNOWN -1
#define UID_ROOT 0
#define UID_PHONE 1001
#define UID_NETD 1051

typedef struct uid_resolver uid_resolver_t;

#ifdef ANDROID
uid_resolver_t* init_uid_resolver(jint sdk_version, JNIEnv *env, jobject vpn);
#endif

uid_resolver_t* init_uid_resolver_from_proc();
void destroy_uid_resolver(uid_resolver_t *resolver);
int get_uid(uid_resolver_t *resolver, const zdtun_5tuple_t *conn_info);

#endif // __UID_RESOLVER_H__

```

`app/src/main/jni/common/utils.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <stdarg.h>
#include <sys/wait.h>
#include <paths.h>
#include "utils.h"

memtrack_t memtrack = {0};
int loglevel = 0;
const char *logtag = "pcapdroid-native";
void (*logcallback)(int lvl, const char *msg) = NULL;

// Needed for local compilation, don't remove
extern char **environ;

/* ******************************************************* */

void set_log_level(int lvl) {
    loglevel = lvl;
}

/* ******************************************************* */

void log_android(int lvl, const char *fmt, ...) {
    if(lvl >= loglevel) {
        char line[1024];
        va_list argptr;

        va_start(argptr, fmt);
        vsnprintf(line, sizeof(line), fmt, argptr);
        va_end(argptr);

#ifdef ANDROID
        __android_log_print(lvl, logtag, "%s", line);
#else
        {
            char ch = '?';

            switch(lvl) {
                case ANDROID_LOG_DEBUG: ch = 'D'; break;
                case ANDROID_LOG_INFO:  ch = 'I'; break;
                case ANDROID_LOG_WARN:  ch = 'W'; break;
                case ANDROID_LOG_ERROR: ch = 'E'; break;
                case ANDROID_LOG_FATAL: ch = 'F'; break;
            }

            fprintf(lvl >= ANDROID_LOG_WARN ? stderr : stdout, "[%c] %s\n", ch, line);
        }
#endif

        if(logcallback != NULL)
            logcallback(lvl, line);
    }
}

/* ******************************************************* */

char loglvl2char(int lvl) {
    switch (lvl) {
        case ANDROID_LOG_DEBUG: return 'D';
        case ANDROID_LOG_INFO:  return 'I';
        case ANDROID_LOG_WARN:  return 'W';
        case ANDROID_LOG_ERROR: return 'E';
        case ANDROID_LOG_FATAL: return 'F';
        default:                return '?';
    }
}

/* ******************************************************* */

ssize_t xwrite(int fd, const void *buf, size_t count) {
    size_t sofar = 0;
    ssize_t ret;

    do {
        ret = write(fd, (u_char*)buf + sofar, count - sofar);

        if(ret < 0) {
            if(errno == EINTR)
                continue;

            return ret;
        }

        sofar += ret;
    } while((sofar != count) && (ret != 0));

    if(sofar != count)
        return -1;

    return 0;
}

/* ******************************************************* */

// returns < 0 on error, 0 if fd is closed
ssize_t xread(int fd, void *buf, size_t count) {
    size_t sofar = 0;
    ssize_t rv;

    do {
        rv = read(fd, (char*)buf + sofar, count - sofar);

        if(rv < 0) {
            if(errno == EINTR)
                continue;
            return rv;
        }

        sofar += rv;
    } while((sofar != count) && (rv != 0));

    if(sofar != count)
        return (rv == 0) ? 0 : -1;

    return count;
}

/* ******************************************************* */

void tupleSwapPeers(zdtun_5tuple_t *tuple) {
    uint16_t tmp = tuple->dst_port;
    tuple->dst_port = tuple->src_port;
    tuple->src_port = tmp;

    zdtun_ip_t tmp1 = tuple->dst_ip;
    tuple->dst_ip = tuple->src_ip;
    tuple->src_ip = tmp1;
}

/* ******************************************************* */

char* humanSize(char *buf, int bufsize, double bytes) {
    static char *suffix[] = {"B", "KB", "MB", "GB", "TB"};
    int num_suffix = sizeof(suffix) / sizeof(suffix[0]);
    int i;

    for(i = 0; (bytes >= 1024) && (i < num_suffix); i++)
        bytes /= 1024;

    snprintf(buf, bufsize, "%.02f %s", bytes, suffix[i]);
    return buf;
}

/* ******************************************************* */

/* Dumps packets in the hex format of "od -A x -t x1", which makes it compatible with
 * text2pcap. */
void hexdump(const char *buf, size_t bufsize) {
    size_t off = 0;
    char out[64];
    int idx = 0;
    static const char hex[] = "0123456789abcdef";

    while(off < bufsize) {
        if((off % 16) == 0) {
            if(off > 0) {
                out[idx] = '\0';
                log_d("%s", out);
            }
            idx = sprintf(out, "%06zx", off);
        }

        out[idx++] = ' ';
        out[idx++] = hex[(buf[off] & 0xF0) >> 4];
        out[idx++] = hex[buf[off] & 0x0F];
        off++;
    }

    if((off % 16) != 0) {
        out[idx] = '\0';
        log_d("%s", out);
        idx = sprintf(out, "%06zx", off);
    }

    out[idx] = '\0';
    log_d("%s", out);
}

/* ******************************************************* */

// Start a sub-process, running a command with some arguments, either as root or as the current user.
// If out_fd is not NULL, on success the out_fd parameter will receive an open file descriptor
// to read the command output.
// Returns the pid of the child process, or -1 on failure
// NOTE: the caller MUST call waitpid or equivalent to prevent process zombification and close the out_fd
int start_subprocess(const char *prog, const char *args, bool as_root, int* out_fd) {
    int in_p[2], out_p[2];
    pid_t pid;

    if((pipe(in_p) != 0) || (out_fd && (pipe(out_p) != 0))) {
        log_f("pipe failed[%d]: %s", errno, strerror(errno));
        return -1;
    }

    if((pid = fork()) == 0) {
        // child
        char *argp[] = {"sh", "-c", as_root ? "su" : "sh", NULL};

        close(in_p[1]);
        dup2(in_p[0], STDIN_FILENO);

        if(out_fd) {
            close(out_p[0]);

            dup2(out_p[1], STDOUT_FILENO);
            dup2(out_p[1], STDERR_FILENO);
        }

        execve(_PATH_BSHELL, argp, environ);
        fprintf(stderr, "execve failed[%d]: %s", errno, strerror(errno));
        exit(1);
    } else if(pid > 0) {
        // parent
        if(out_fd) {
            *out_fd = out_p[0];
            close(out_p[1]);
        }

        close(in_p[0]);

        // write "su"/"sh" command input
        if(as_root) {
            // Some su implementations (e.g. Android-x86) change the PWD when activated,
            // cd to the cache dir to ensure that the UNIX socket can be found by pcapd
            char* cwd = getcwd(NULL, 0);
            if (cwd) {
                log_d("start_subprocess[%d]: cd %s", pid, cwd);
                write(in_p[1], "cd \"",4);
                write(in_p[1], cwd, strlen(cwd));
                write(in_p[1], "\"\n", 2);
                free(cwd);
            } else
                log_w("start_subprocess[%d]: getcwd failed[%d]: %s - non-magisk 'su' may fail",
                      pid, errno, strerror(errno));
        }

        log_d("start_subprocess[%d]: %s %s", pid, prog, args);
        write(in_p[1], prog, strlen(prog));
        write(in_p[1], " ", 1);
        write(in_p[1], args, strlen(args));
        write(in_p[1], "\n", 1);
        close(in_p[1]);
    } else {
        log_f("fork() failed[%d]: %s", errno, strerror(errno));
        close(in_p[0]);
        close(in_p[1]);

        if(out_fd) {
            close(out_p[0]);
            close(out_p[1]);
        }
        return -1;
    }

    return pid;
}

/* ******************************************************* */

int run_shell_cmd(const char *prog, const char *args, bool as_root, bool check_error) {
    int out_fd;
    int pid = start_subprocess(prog, args, as_root, &out_fd);
    if(pid <= 0)
        return -1;

    int rv;
    if(waitpid(pid, &rv, 0) <= 0) {
        log_f("waitpid %d failed[%d]: %s", pid, errno, strerror(errno));
        return -1;
    }

    if(check_error && (rv != 0)) {
        char buf[128];
        struct timeval timeout = {0};
        fd_set fds;

        buf[0] = '\0';
        FD_ZERO(&fds);
        FD_SET(out_fd, &fds);

        select(out_fd + 1, &fds, NULL, NULL, &timeout);
        if (FD_ISSET(out_fd, &fds)) {
            int num = read(out_fd, buf, sizeof(buf) - 1);
            if (num > 0)
                buf[num] = '\0';
        }

        log_f("\"%s\" invocation failed: %s", prog, buf);
    }

    close(out_fd);
    return rv;
}

```

`app/src/main/jni/common/utils.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

#ifndef __LOG_UTILS_H__
#define __LOG_UTILS_H__

#include <sys/types.h>
#include <stdbool.h>
#include "zdtun.h"
#include "memtrack.h"

#ifdef ANDROID
#include <android/log.h>
#else

#define ANDROID_LOG_DEBUG 1
#define ANDROID_LOG_INFO  2
#define ANDROID_LOG_WARN  3
#define ANDROID_LOG_ERROR 4
#define ANDROID_LOG_FATAL 5

#endif

#ifndef __unused
#define __unused  __attribute__((unused))
#endif

#ifndef __packed
#define __packed  __attribute__((packed))
#endif

extern int loglevel;
extern const char* logtag;
extern void (*logcallback)(int lvl, const char *msg);

#define log_d(...) log_android(ANDROID_LOG_DEBUG, __VA_ARGS__)
#define log_i(...) log_android(ANDROID_LOG_INFO, __VA_ARGS__)
#define log_w(...) log_android(ANDROID_LOG_WARN, __VA_ARGS__)
#define log_e(...) log_android(ANDROID_LOG_ERROR, __VA_ARGS__)
#define log_f(...) log_android(ANDROID_LOG_FATAL, __VA_ARGS__)

void set_log_level(int lvl);
void log_android(int lvl, const char *fmt, ...);
ssize_t xwrite(int fd, const void *buf, size_t count);
ssize_t xread(int fd, void *buf, size_t count);
uint64_t timeval2ms(struct timeval *tv);
void tupleSwapPeers(zdtun_5tuple_t *tuple);
char loglvl2char(int lvl);
char* humanSize(char *buf, int bufsize, double bytes);
void hexdump(const char *buf, size_t bufsize);
int start_subprocess(const char *prog, const char *args, bool as_root, int* out_fd);
int run_shell_cmd(const char *prog, const char *args, bool as_root, bool check_error);

#endif // __LOG_UTILS_H__

```

`app/src/main/jni/core/CMakeLists.txt`:

```txt
project(core)

add_library(capture SHARED
        pcapdroid.c
        capture_vpn.c
        capture_pcap.c
        ip_lru.c
        ndpi_config.c
        crc32.c
        blacklist.c
        pcap_dump.c
        pcap_reader.c
        log_writer.c
        port_map.c
        ushark_dll.c
        jni_impl.c)

# nDPI
add_definitions(-DNDPI_LIB_COMPILATION)
add_definitions(-D__bswap_64=bswap_64)
AUX_SOURCE_DIRECTORY(${NDPI_ROOT}/src/lib ndpiSources)
AUX_SOURCE_DIRECTORY(${NDPI_ROOT}/src/lib/third_party/src ndpiSources)
AUX_SOURCE_DIRECTORY(${NDPI_ROOT}/src/lib/third_party/src/hll ndpiSources)
AUX_SOURCE_DIRECTORY(${NDPI_ROOT}/src/lib/protocols ndpiSources)

# slim build, see nDPI lib/Makefile.in
add_definitions(-DNDPI_SLIM)
list(REMOVE_ITEM ndpiSources
        ${NDPI_ROOT}/src/lib/third_party/src/libinjection_html5.c
        ${NDPI_ROOT}/src/lib/third_party/src/libinjection_xss.c
        ${NDPI_ROOT}/src/lib/third_party/src/libinjection_sqli.c
        ${NDPI_ROOT}/src/lib/third_party/src/roaring.c
        ${NDPI_ROOT}/src/lib/third_party/src/roaring_v2.c
        ${NDPI_ROOT}/src/lib/ndpi_bitmap.c
        ${NDPI_ROOT}/src/lib/ndpi_bitmap64_fuse.c
        ${NDPI_ROOT}/src/lib/ndpi_binary_bitmap.c
        ${NDPI_ROOT}/src/lib/ndpi_filter.c)

set(NDPI_GEN ${ROOTDIR}/generated/nDPI)
configure_file(${NDPI_GEN}/ndpi_api.h ${NDPI_ROOT}/src/include/ndpi_api.h)
configure_file(${NDPI_GEN}/ndpi_config.h ${NDPI_ROOT}/src/include/ndpi_config.h)
configure_file(${NDPI_GEN}/ndpi_define.h ${NDPI_ROOT}/src/include/ndpi_define.h)

ADD_LIBRARY(ndpi SHARED ${ndpiSources} ${NDPI_ROOT}/src/include/ndpi_api.h)

if(ANDROID)
        find_library(log-lib log)
        set(extra-libs ${log-lib})
else()
        set(extra-libs "pthread" "m")
endif()

target_link_libraries(capture
        zdtun
        ndpi
        common
        ${extra-libs})

```

`app/src/main/jni/core/blacklist.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-25 - Emanuele Faranda
 */

#define _GNU_SOURCE
#include <string.h>
#include "pcapdroid.h"
#include "common/utils.h"
#include "third_party/libchash.h"

typedef struct {
    char country_code[3];
    UT_hash_handle hh;
} country_entry_t;

typedef struct {
    int key;
    UT_hash_handle hh;
} int_entry_t;

struct blacklist {
    struct HashTable *domains;
    int_entry_t *uids;
    ndpi_ptree_t *ptree;
    country_entry_t* countries;
    blacklists_stats_t stats;
};

/* ******************************************************* */

blacklist_t* blacklist_init() {
    blacklist_t *bl = (blacklist_t*) bl_calloc(1, sizeof(blacklist_t));
    if(!bl)
        return NULL;

    bl->ptree = ndpi_ptree_create();
    if(!bl->ptree) {
        bl_free(bl);
        return NULL;
    }

    bl->domains = AllocateHashTable(0 /* keys are null terminated */, 1 /* copy keys */);
    if (!bl->domains) {
        ndpi_ptree_destroy(bl->ptree);
        bl_free(bl);
        return NULL;
    }

    return bl;
}

/* ******************************************************* */

int blacklist_add_domain(blacklist_t *bl, const char *domain) {
    if(strncmp(domain, "www.", 4) == 0)
        domain += 4;

    if(blacklist_match_domain(bl, domain))
        return -EADDRINUSE; // duplicate domain

    HTItem* entry = HashInsert(bl->domains, PTR_KEY(bl->domains, domain));
    if (!entry)
        return -ENOMEM;

    bl->stats.num_domains++;
    return 0;
}

/* ******************************************************* */

int blacklist_add_ip(blacklist_t *bl, const ndpi_ip_addr_t *addr, uint8_t bits) {
    int rv = ndpi_ptree_insert(bl->ptree, addr, bits, PCAPDROID_NDPI_CATEGORY_MALWARE);
    if(rv != 0)
        return (rv == -2) ? -EADDRINUSE : -EINVAL; // -2 means IP already in ptree

    bl->stats.num_ips++;
    return 0;
}

/* ******************************************************* */

int blacklist_add_ipstr(blacklist_t *bl, const char *ip) {
    char buf[INET6_ADDRSTRLEN];
    int bits = -1;

    // check for CIDR
    const char* slash = strchr(ip, '/');
    if (slash) {
        size_t to_copy = slash - ip;
        if ((to_copy == 0) || (to_copy >= sizeof(buf)))
            return -EINVAL;

        memcpy(buf, ip, to_copy);
        buf[to_copy] = '\0';
        ip = buf;
        bits = atoi(slash + 1);
    }

    ndpi_ip_addr_t addr;
    int ipver = ndpi_parse_ip_string(ip, &addr);

    if((ipver != 4) && (ipver != 6))
        return -EINVAL;

    if (bits < 0)
        bits = (ipver == 4) ? 32 : 128;
    else if (((ipver == 4) && (bits > 32)) ||
             ((ipver == 6) && (bits > 128)))
        return -EINVAL;

    return blacklist_add_ip(bl, &addr, bits);
}

/* ******************************************************* */

int blacklist_add_uid(blacklist_t *bl, int uid) {
    if(blacklist_match_uid(bl, uid))
        return -EADDRINUSE; // duplicate uid

    int_entry_t *entry = bl_malloc(sizeof(int_entry_t));
    if(!entry)
        return -ENOMEM;

    entry->key = uid;
    HASH_ADD_INT(bl->uids, key, entry);

    bl->stats.num_apps++;
    return 0;
}

/* ******************************************************* */

int blacklist_add_country(blacklist_t *bl, const char country_code[3]) {
    if(blacklist_match_country(bl, country_code))
        return -EADDRINUSE; // duplicate

    country_entry_t *entry = bl_malloc(sizeof(country_entry_t));
    if(!entry)
        return -ENOMEM;

    entry->country_code[0] = country_code[0];
    entry->country_code[1] = country_code[1];
    entry->country_code[2] = '\0';
    HASH_ADD_KEYPTR(hh, bl->countries, entry->country_code, 2, entry);

    bl->stats.num_countries++;
    return 0;
}

/* ******************************************************* */

int blacklist_load_file(blacklist_t *bl, const char *path, blacklist_type btype, blacklist_stats_t *bstats) {
    FILE *f;
    char buffer[256];
    int num_ok = 0, num_fail = 0, num_dup = 0;
    int max_file_rules = 15000000;

    f = fopen(path, "r");
    if(!f) {
        log_e("Could not open blacklist file \"%s\" [%d]: %s", path, errno, strerror(errno));
        return -1;
    }

    while(1) {
        char *item = fgets(buffer, sizeof(buffer), f);
        if(!item)
            break;

        if(!item[0] || (item[0] == '#') || (item[0] == '\n'))
            continue;

        item[strcspn(buffer, "\r\n")] = '\0';
        char *slash = strchr(buffer, '/');
        if(slash)
            *slash = 0;

        ndpi_ip_addr_t ip_addr;
        int ipver = ndpi_parse_ip_string(buffer, &ip_addr);
        bool is_ip_addr = (ipver == 4) || (ipver == 6);

        if(num_ok >= max_file_rules) {  // limit reached
            num_fail++;
            continue;
        }

        if(btype == IP_BLACKLIST) {
            if(!is_ip_addr) {
                log_w("Invalid IP/net \"%s\" in blacklist %s", buffer, path);
                num_fail++;
                continue;
            }

            int bits;
            if(slash)
                bits = atoi(slash + 1); // subnet
            else if(ipver == 4)
                bits = 32;
            else
                bits = 128;

            // Validate IPv4
            if(((ipver == 4) && (bits == 32)) &&
                    ((ip_addr.ipv4 == 0) || (ip_addr.ipv4 == 0xFFFFFFFF) || (ip_addr.ipv4 == 0x7F000001)))
                continue; // invalid

            // TODO validate IPv6

            int rv = blacklist_add_ip(bl, &ip_addr, bits);
            if(rv == 0)
                num_ok++;
            else if(rv == -EADDRINUSE)
                num_dup++;
            else
                num_fail++;
        } else if (btype == DOMAIN_BLACKLIST) {
            if(is_ip_addr) {
                log_w("IP/net \"%s\" found instead of domain in %s", buffer, path);
                num_fail++;
                continue;
            }

            int rv = blacklist_add_domain(bl, item);
            if(rv == 0)
                num_ok++;
            else if(rv == -EADDRINUSE)
                num_dup++;
            else
                num_fail++;
        } else {
            log_e("Loading unsupported blacklist of type %d", btype);
            break;
        }
    }

    fclose(f);
    log_d("Blacklist loaded[%s][%s]: %d ok, %d dups, %d failed",
          strrchr(path, '/') + 1, (btype == IP_BLACKLIST ? "IP" : "domain"), num_ok, num_dup, num_fail);

    // current list stats
    memset(bstats, 0, sizeof(*bstats));
    bstats->num_failed = num_fail;
    bstats->num_rules = num_ok;

    // cumulative stats
    bl->stats.num_lists++;
    bl->stats.num_failed += num_fail;

    return 0;
}

/* ******************************************************* */

void blacklist_destroy(blacklist_t *bl) {
    FreeHashTable(bl->domains);

    int_entry_t *entry_i, *tmp_i;
    HASH_ITER(hh, bl->uids, entry_i, tmp_i) {
        HASH_DELETE(hh, bl->uids, entry_i);
        bl_free(entry_i);
    }

    country_entry_t *entry_c, *tmp_c;
    HASH_ITER(hh, bl->countries, entry_c, tmp_c) {
        HASH_DELETE(hh, bl->countries, entry_c);
        bl_free(entry_c);
    }

    ndpi_ptree_destroy(bl->ptree);
    bl_free(bl);
}

/* ******************************************************* */

bool blacklist_match_ip(blacklist_t *bl, const zdtun_ip_t *ip, int ipver) {
    ndpi_ip_addr_t addr = {0};
    if(ipver == 4)
        addr.ipv4 = ip->ip4;
    else
        memcpy(&addr.ipv6, &ip->ip6, 16);

    u_int64_t res = 0;
    ndpi_ptree_match_addr(bl->ptree, &addr, &res);

    return(res == PCAPDROID_NDPI_CATEGORY_MALWARE);
}

/* ******************************************************* */

bool blacklist_match_ipstr(blacklist_t *bl, const char *ip_str) {
    zdtun_ip_t parsed;

    int ipver = zdtun_parse_ip(ip_str, &parsed);
    if(ipver < 0)
        return false;

    return blacklist_match_ip(bl, &parsed, ipver);
}

/* ******************************************************* */

bool blacklist_match_country(blacklist_t *bl, const char country_code[3]) {
    if (!country_code || (country_code[0] == '\0'))
        return false;

    country_entry_t *entry = NULL;

    HASH_FIND_STR(bl->countries, country_code, entry);
    return (entry != NULL);
}

/* ******************************************************* */

static char* get_second_level_domain(const char *domain) {
    char *dot = (char*) memrchr(domain, '.', strlen(domain));
    if(!dot || (dot == domain))
        return (char*)domain;

    dot = (char*) memrchr(domain, '.', dot - domain);
    if(!dot)
        return (char*)domain;

    return dot + 1;
}

/* ******************************************************* */

bool blacklist_match_domain(blacklist_t *bl, const char *domain) {
    // Keep in sync with MatchList.matchesHost
    HashTable* ht = bl->domains;
    HTItem *entry = NULL;

    if(strncmp(domain, "www.", 4) == 0)
        domain += 4;

    // exact domain match
    entry = HashFind(ht, PTR_KEY(ht, domain));
    if(entry != NULL)
        return true;

    // 2nd-level domain match
    char *domain2 = get_second_level_domain(domain);
    if(domain2 != domain) {
        entry = HashFind(ht, PTR_KEY(ht, domain2));
        if(entry != NULL)
            return true;
    }

    return false;
}

/* ******************************************************* */

bool blacklist_match_uid(blacklist_t *bl, int uid) {
    int_entry_t *entry = NULL;

    HASH_FIND_INT(bl->uids, &uid, entry);
    return(entry != NULL);
}

/* ******************************************************* */

void blacklist_get_stats(const blacklist_t *bl, blacklists_stats_t *stats) {
    *stats = bl->stats;
}

/* ******************************************************* */

#if ANDROID

static int bl_load_list_of_type(blacklist_t *bl, JNIEnv *env, jobject list, blacklist_type tp) {
    int num_items = (*env)->CallIntMethod(env, list, mids.listSize);
    int num_loaded = 0;

    for(int i=0; i<num_items; i++) {
        jstring *obj = (*env)->CallObjectMethod(env, list, mids.listGet, i);
        if(obj != NULL) {
            int rv;
            const char *val = (*env)->GetStringUTFChars(env, obj, NULL);

            switch (tp) {
                case IP_BLACKLIST:
                    rv = blacklist_add_ipstr(bl, val);
                    break;
                case DOMAIN_BLACKLIST:
                    rv = blacklist_add_domain(bl, val);
                    break;
                case UID_BLACKLIST:
                    rv = blacklist_add_uid(bl, atoi(val));
                    break;
                case COUNTRY_BLACKLIST:
                    rv = blacklist_add_country(bl, val);
                    break;
                default:
                    rv = -1;
            }
            (*env)->ReleaseStringUTFChars(env, obj, val);
            (*env)->DeleteLocalRef(env, obj);

            if(rv == 0) {
                num_loaded++;
            } else if(rv != -EADDRINUSE) {
                log_e("bl add %s failed: %d", val, rv);
                return -1;
            }
        }
    }

    return num_loaded;
}

/* ******************************************************* */

int blacklist_load_list_descriptor(blacklist_t *bl, JNIEnv *env, jobject ld) {
    jobject apps = (*env)->GetObjectField(env, ld, fields.ld_apps);
    jobject hosts = (*env)->GetObjectField(env, ld, fields.ld_hosts);
    jobject ips = (*env)->GetObjectField(env, ld, fields.ld_ips);
    jobject countries = (*env)->GetObjectField(env, ld, fields.ld_countries);

    int num_apps = bl_load_list_of_type(bl, env, apps, UID_BLACKLIST);
    int num_domains = bl_load_list_of_type(bl, env, hosts, DOMAIN_BLACKLIST);
    int num_ips = bl_load_list_of_type(bl, env, ips, IP_BLACKLIST);
    int num_countries = bl_load_list_of_type(bl, env, countries, COUNTRY_BLACKLIST);
    int rv = 0;

    if((num_apps == -1) || (num_ips == -1) || (num_domains == -1) || (num_countries == -1))
        rv = -1;

    (*env)->DeleteLocalRef(env, apps);
    (*env)->DeleteLocalRef(env, hosts);
    (*env)->DeleteLocalRef(env, ips);
    (*env)->DeleteLocalRef(env, countries);
    return rv;
}

#endif // ANDROID

```

`app/src/main/jni/core/blacklist.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

#ifndef PCAPDROID_BLACKLIST_H
#define PCAPDROID_BLACKLIST_H

#include "ndpi_api.h"

#ifdef ANDROID
#include <jni.h>
#endif

#define PCAPDROID_NDPI_CATEGORY_MALWARE NDPI_PROTOCOL_CATEGORY_CUSTOM_1

typedef struct blacklist blacklist_t;

typedef struct {
    int num_rules;
    int num_failed;
} blacklist_stats_t;

typedef struct {
    int num_lists;
    int num_domains;
    int num_ips;
    int num_apps;
    int num_countries;
    int num_failed;
} blacklists_stats_t;

typedef enum {
    DOMAIN_BLACKLIST,
    IP_BLACKLIST,
    UID_BLACKLIST,
    COUNTRY_BLACKLIST
} blacklist_type;

typedef struct {
    char *fname;
    blacklist_type type;
} bl_info_t;

typedef struct {
    char *fname;
    int num_rules;
} bl_status_t;

typedef struct {
    bl_status_t *items;
    int size;
    int cur_items;
} bl_status_arr_t;

blacklist_t* blacklist_init();
void blacklist_destroy(blacklist_t *bl);
int blacklist_add_domain(blacklist_t *bl, const char *domain);
int blacklist_add_ip(blacklist_t *bl, const ndpi_ip_addr_t *addr, uint8_t ipver);
int blacklist_add_ipstr(blacklist_t *bl, const char *ip);
int blacklist_add_uid(blacklist_t *bl, int uid);
int blacklist_add_country(blacklist_t *bl, const char country_code[3]);
int blacklist_load_file(blacklist_t *bl, const char *path, blacklist_type btype, blacklist_stats_t *bstats);
#ifdef ANDROID
int blacklist_load_list_descriptor(blacklist_t *bl, JNIEnv *env, jobject ld);
#endif
bool blacklist_match_ip(blacklist_t *bl, const zdtun_ip_t *ip, int ipver);
bool blacklist_match_ipstr(blacklist_t *bl, const char *ip);
bool blacklist_match_domain(blacklist_t *bl, const char *domain);
bool blacklist_match_uid(blacklist_t *bl, int uid);
bool blacklist_match_country(blacklist_t *bl, const char country_code[3]);
void blacklist_get_stats(const blacklist_t *bl, blacklists_stats_t *stats);

#endif //PCAPDROID_BLACKLIST_H

```

`app/src/main/jni/core/capture_pcap.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021-26 - Emanuele Faranda
 */

#include <sys/un.h>
#include <sys/wait.h>
#include <linux/limits.h>
#include <netinet/tcp.h>
#include "pcapdroid.h"
#include "errors.h"
#include "pcapd/pcapd.h"
#include "common/utils.h"
#include "third_party/uthash.h"
#include "pcap_reader.h"
#include "ushark_dll.h"

#define ICMP_TIMEOUT_SEC 5
#define UDP_TIMEOUT_SEC 30
#define TCP_CLOSED_TIMEOUT_SEC 60   // some servers keep sending FIN+ACK after close
#define TCP_TIMEOUT_SEC 300         // needs to be large as TCP connections may stay active for a long time

/* ******************************************************* */

typedef struct pcap_conn_t {
    zdtun_5tuple_t tuple;
    pd_conn_t *data;

    UT_hash_handle hh;
} pcap_conn_t;

/* ******************************************************* */

static int get_pcapd_pid() {
    char pid_s[8];
    FILE *f = fopen(PCAPD_PID, "r");

    if(f == NULL)
        return -1;

    fgets(pid_s, sizeof(pid_s), f);
    fclose(f);

    return atoi(pid_s);
}

/* ******************************************************* */

static void kill_process(int pid, bool as_root, int signum) {
    char args[16];

    snprintf(args, sizeof(args), "-%d %d", signum, pid);
    run_shell_cmd("kill", args, as_root, false);
}

/* ******************************************************* */

static bool valid_ifname(const char *name) {
    if(*name == '\0')
        return false;

    if(strlen(name) >= 16)
        return false;

    while(*name) {
        if((*name != '.') && (*name != '_') && (*name != '@') && !isalnum(*name))
            return false;
        name++;
    }

    return true;
}

/* ******************************************************* */

static bool valid_bpf(const char *bpf) {
    static const char disallowed_chars[] = "$'\"`\n\r";

    while(*bpf) {
        if(strchr(disallowed_chars, *bpf))
            return false;
        bpf++;
    }

    return true;
}

/* ******************************************************* */

static const char* get_uids_filter(pcapdroid_t *pd, char *buf, size_t buf_size) {
    if (pd->tls_decryption.enabled || (pd->pcap.app_filter_uids_size <= 0))
        return "-1";

    size_t off = 0;

    for (int i = 0; (i < pd->pcap.app_filter_uids_size) && (off < buf_size); i++) {
        const char * fmt = (i == 0) ? "%d" : ",%d";
        off += snprintf(buf + off, (buf_size - off), fmt, pd->pcap.app_filter_uids[i]);
    }

    if (off >= buf_size)
        log_e("The UID filter has been truncated");

    return buf;
}

/* ******************************************************* */

static int connectPcapd(pcapdroid_t *pd) {
    int sock;
    int client = -1;
    char pcapd[PATH_MAX];
    char *bpf = pd->pcap.bpf ? pd->pcap.bpf : "";

    log_d("Starting pcapd...");

    if(pd->cb.get_libprog_path)
        pd->cb.get_libprog_path(pd, "pcapd", pcapd, sizeof(pcapd));

    if(!pcapd[0])
        return(-1);

    if(chdir(get_cache_dir(pd)) < 0) {
        log_f("chdir to %s failed [%d]: %s", get_cache_dir(pd),
                    errno, strerror(errno));
        return (-1);
    }

    sock = socket(AF_UNIX, SOCK_STREAM, 0);

    if(sock < 0) {
        log_f("AF_UNIX socket creation failed [%d]: %s", errno,
                    strerror(errno));
        return (-1);
    }

    struct sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, PCAPD_SOCKET_PATH);

    int pid = get_pcapd_pid();
    if(pid > 0) {
        log_i("Killing old pcapd with pid %d", pid);
        kill_process(pid, pd->pcap.as_root, SIGTERM);
        pid = -1;
    }

    unlink(PCAPD_PID);
    unlink(PCAPD_SOCKET_PATH);

    if(bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
        log_f("AF_UNIX bind failed [%d]: %s", errno,
                    strerror(errno));
        goto cleanup;
    }

    listen(sock, 1);

    log_d("AF_UNIX socket listening at '%s'", addr.sun_path);

    // Validate parameters to prevent command injection
    if(bpf[0]) {
        if(!valid_bpf(bpf)) {
            log_f("BPF contains suspicious characters");
            goto cleanup;
        }
        log_d("BPF filter is in use");
    }

    if(pd->pcap_file_capture) {
        // must be a file path
        if(access(pd->pcap.capture_interface, F_OK)) {
            log_f(PD_ERR_PCAP_DOES_NOT_EXIST);
            goto cleanup;
        }
    } else {
        // must be a valid interface name
        if(!valid_ifname(pd->pcap.capture_interface)) {
            log_f("Invalid capture_interface");
            goto cleanup;
        }

        // this is needed to run with root under recent Magisk
        // the drawback is that it's not possible to get the pcapd exit status,
        // which is needed when reading a PCAP file
        pd->pcap.daemonize = true;
    }

    // Start the daemon
    char uids_filter_buf[128];
    char args[256];
    snprintf(args, sizeof(args), "-l pcapd.log -L %u -i '%s' -u %s -t -b '%s'%s",
             getuid(), pd->pcap.capture_interface,
             get_uids_filter(pd, uids_filter_buf, sizeof(uids_filter_buf)),
             bpf, pd->pcap.daemonize ? " -d" : "");

    pid = start_subprocess(pcapd, args, pd->pcap.as_root, NULL);
    if(pid <= 0) {
        log_e("start_subprocess failed");
        goto cleanup;
    }

    if(pd->pcap.daemonize) {
        // when running as a daemon, child exits early
        // note: this will block until user grants/denies root permission
        int rv;
        if((waitpid(pid, &rv, 0) == pid) && (rv != 0)) {
            log_w("pcapd exited with code %d", rv);

            log_f(PD_ERR_PCAPD_START);
            goto cleanup;
        }
    }

    // Wait for pcapd to connect to the socket
    const time_t start_timeout = time(NULL) + 5 /* 5 seconds */;
    bool pcapd_connected = false;

    while(time(NULL) < start_timeout) {
        struct timeval timeout = {.tv_sec = 0, .tv_usec = 500000 /* 500 ms */};
        fd_set selfds;

        FD_ZERO(&selfds);
        FD_SET(sock, &selfds);
        select(sock + 1, &selfds, NULL, NULL, &timeout);

        if(!running) {
            log_w("Connect to pcapd aborted");
            goto cleanup;
        }

        if(FD_ISSET(sock, &selfds)) {
            pcapd_connected = true;
            break;
        }

        // check if the child process terminated incorrectly
        int rv;
        if(!pd->pcap.daemonize && (waitpid(pid, &rv, WNOHANG) == pid)) {
            log_w("pcapd exited with code %d", rv);
            pid = -1;

            log_f(PD_ERR_PCAPD_START);
            goto cleanup;
        }
    }

    if(!pcapd_connected) {
        log_f(PD_ERR_PCAPD_NOT_SPAWNED);
        goto cleanup;
    }

    if((client = accept(sock, NULL, NULL)) < 0) {
        log_f("AF_UNIX accept failed [%d]: %s", errno,
                    strerror(errno));
        goto cleanup;
    }

    log_i("Connected to pcapd (pid=%d)", pid);
    pd->pcap.pcapd_pid = pid;

cleanup:
    if((client < 0) && (pid > 0)) {
        int rv;
        kill_process(pid, pd->pcap.as_root, SIGKILL);

        if(!pd->pcap.daemonize)
            waitpid(pid, &rv, 0);
    }
    unlink(PCAPD_SOCKET_PATH);
    close(sock);

    return client;
}

/* ******************************************************* */

static char* get_mitm_redirection_args(pcapdroid_t *pd, char *buf, int uid, bool add) {
    int off = sprintf(buf, "-t nat -%c OUTPUT -p tcp -m owner ", add ? 'I' : 'D');
    if(uid >= 0)
        off += sprintf(buf + off, "--uid-owner %d", uid);
    else
        off += sprintf(buf + off, "! --uid-owner %d", pd->mitm_addon_uid);
    sprintf(buf + off, " -j REDIRECT --to 7780");

    return buf;
}

/* ******************************************************* */

static void remove_connection(pcapdroid_t *pd, pcap_conn_t *conn) {
    switch (conn->tuple.ipproto) {
        case IPPROTO_TCP:
            pd->stats.num_tcp_conn--;
            break;
        case IPPROTO_UDP:
            pd->stats.num_udp_conn--;
            break;
        case IPPROTO_ICMP:
            pd->stats.num_icmp_conn--;
            break;
    }

    HASH_DEL(pd->pcap.connections, conn);
    pd_free(conn);
}

/* ******************************************************* */

// Determines when a connection gets closed
static void update_connection_status(pcapdroid_t *pd, pcap_conn_t *conn, zdtun_pkt_t *pkt, uint8_t dir) {
  // NOTE: pcap_conn_t needed below in remove_connection
  if((conn->data->status >= CONN_STATUS_CLOSED) || (pkt->flags & ZDTUN_PKT_IS_FRAGMENT))
      return;

  zdtun_5tuple_t *tuple = &conn->tuple;
  pd_conn_t *data = conn->data;

  if(tuple->ipproto == IPPROTO_TCP) {
      struct tcphdr *tcp = pkt->tcp;

      data->tcp_flags[dir] |= tcp->th_flags;
      uint8_t seen_flags = data->tcp_flags[0] & data->tcp_flags[1];

      if(tcp->th_flags & TH_RST)
          data->status = CONN_STATUS_RESET;
      else if(seen_flags & TH_FIN) {
          // closed when both the peers have sent FIN and the last FIN was acknowledged
          if(!data->last_ack)
              data->last_ack = true; // wait for the last ACK
          else if(tcp->th_flags & TH_ACK)
              data->status = CONN_STATUS_CLOSED;
      } else if(data->status < CONN_STATUS_CONNECTED) {
          const uint8_t syn_ack_flags = TH_SYN | TH_ACK;

          // the 3-way-handshake is complete when both the peers have sent the SYN+ACK flags
          if((pkt->l7_len > 0) ||
                ((seen_flags & syn_ack_flags) == syn_ack_flags))
              data->status = CONN_STATUS_CONNECTED;
          else
              data->status = CONN_STATUS_CONNECTING;
      }
  } else {
      if(data->status < CONN_STATUS_CONNECTED)
        data->status = CONN_STATUS_CONNECTED;

      if((tuple->ipproto == IPPROTO_UDP) &&
            pkt->l7_len >= sizeof(dns_packet_t) &&
            (tuple->dst_port == ntohs(53))) {
          const dns_packet_t *dns = (dns_packet_t *)pkt->l7;

          if((dns->flags & DNS_FLAGS_MASK) == DNS_TYPE_REQUEST)
              data->pending_dns_queries++;
          else if((dns->flags & DNS_FLAGS_MASK) == DNS_TYPE_RESPONSE) {
              data->pending_dns_queries--;

              // Close the connection as soon as all the responses arrive
              if(data->pending_dns_queries == 0) {
                  data->status = CONN_STATUS_CLOSED;

                  // Remove the connection from the hash table to ensure that if the DNS connection is
                  // reused for a new query, it will generated a new connection, to properly
                  // extract and handle the new DNS query. This also happens for AAAA + A queries.
                  data->to_purge = true;
                  remove_connection(pd, conn);
              }
          }
      }
  }

  // no need to call pd_notify_connection_update, it will be called as part of pd_account_stats
}

/* ******************************************************* */

static int get_ip_offset(int linktype) {
    switch(linktype) {
        case PCAPD_DLT_RAW:
            return 0;
        case PCAPD_DLT_ETHERNET:
            return 14;
        case PCAPD_DLT_LINUX_SLL:
            return 16;
        case PCAPD_DLT_LINUX_SLL2:
            return 20;
        default:
            return -1;
    }
}

/* ******************************************************* */

static plain_data_t g_plain_data = {};
static pkt_context_t *g_cur_ctx = NULL;

static void handle_http_data(bool is_tx, uint64_t ms, uint32_t stream_id, const unsigned char *plain_data, unsigned int data_len) {
    // NOTE: (plain_data == NULL) / (data_len == 0) signals HTTP/2 resets

    // allocate the data first, as a failure in this allocation is easier to handle now rather
    // than after a plain_data_item_t allocation
    unsigned char *new_item_data_buf = NULL;
    if (plain_data) {
        new_item_data_buf = pd_malloc(data_len);
        if (!new_item_data_buf) {
            log_e("alloc(http_data) failed[%d]: %s", errno, strerror(errno));
            return;
        }
    }

    plain_data_item_t* new_items = (plain_data_item_t*) pd_realloc(g_plain_data.items, (g_plain_data.n_items + 1) * sizeof(plain_data_item_t));
    if (!new_items) {
        log_e("realloc(tls_data) failed[%d]: %s", errno, strerror(errno));

        if (new_item_data_buf)
            pd_free(new_item_data_buf);
        return;
    }

    g_plain_data.items = new_items;
    plain_data_item_t *item = &g_plain_data.items[g_plain_data.n_items++];

    memset(item, 0, sizeof(plain_data_item_t));
    item->ms = ms;
    item->is_tx = is_tx;
    item->stream_id = stream_id;

    if (new_item_data_buf) {
        memcpy(new_item_data_buf, plain_data, data_len);

        item->data = new_item_data_buf;
        item->data_length = data_len;
    }
}

static void handle_ushark_http1_data(uint32_t conv_id, const unsigned char *plain_data, size_t data_len) {
    if (!g_cur_ctx)
        return;

    // HTTP/1 is sequential, use 0 as the stream ID
    handle_http_data(g_cur_ctx->is_tx, g_cur_ctx->ms, 0, plain_data, data_len);
}

static void handle_ushark_http2_request(uint32_t conv_id, uint32_t stream_id, const unsigned char *plain_data, size_t data_len) {
    if (!g_cur_ctx)
        return;

    handle_http_data(g_cur_ctx->is_tx, g_cur_ctx->ms, stream_id, plain_data, data_len);
}

static void handle_ushark_http2_response(uint32_t conv_id, uint32_t stream_id, const unsigned char *plain_data, size_t data_len) {
    if (!g_cur_ctx)
        return;

    handle_http_data(g_cur_ctx->is_tx, g_cur_ctx->ms, stream_id, plain_data, data_len);
}

static void handle_ushark_http2_reset(uint32_t conv_id, uint32_t stream_id) {
    if (!g_cur_ctx)
        return;

    handle_http_data(g_cur_ctx->is_tx, g_cur_ctx->ms, stream_id, NULL, 0);
}

/* ******************************************************* */

/* Returns true if packet is valid. If false is returned, the pkt must still be dumped, so a call to
 * pd_dump_packet is required. */
static bool handle_packet(pcapdroid_t *pd, pcapd_hdr_t *hdr, const char *buffer, int ipoffset) {
    zdtun_pkt_t pkt;
    pcap_conn_t *conn = NULL;
    uint8_t is_tx = (hdr->flags & PCAPD_FLAG_TX); // NOTE: the direction uses an heuristic so it may be wrong

    if(zdtun_parse_pkt(pd->zdt, buffer + ipoffset, hdr->len - ipoffset, &pkt) != 0) {
        log_d("zdtun_parse_pkt failed");
        return false;
    }

    if((pkt.flags & ZDTUN_PKT_IS_FRAGMENT) &&
            (pkt.tuple.src_port == 0) && (pkt.tuple.dst_port == 0)) {
        // This fragment cannot be mapped to the original src/dst ports. This may happen if the first
        // IP fragment is lost or was not captured (e.g. for packets matching the BPF of getPcapDumperBpf).
        // In such a case, we can only ignore the packet as we cannot determine the connection it belongs to.

        //log_d("unmatched IP fragment (ID = 0x%04x)", pkt.ip4->id);
        pd->num_discarded_fragments++;
        return false;
    }

    if(!is_tx) {
        // Packet from the internet, swap src and dst
        tupleSwapPeers(&pkt.tuple);
    }

    HASH_FIND(hh, pd->pcap.connections, &pkt.tuple, sizeof(zdtun_5tuple_t), conn);
    if(!conn) {
        // is_tx may be wrong, search in the other direction
        is_tx = !is_tx;
        tupleSwapPeers(&pkt.tuple);

        HASH_FIND(hh, pd->pcap.connections, &pkt.tuple, sizeof(zdtun_5tuple_t), conn);

        if(!conn) {
            if((pkt.flags & ZDTUN_PKT_IS_FRAGMENT) && !(pkt.flags & ZDTUN_PKT_IS_FIRST_FRAGMENT)) {
                log_d("ignoring fragment as it cannot start a connection");
                pd->num_discarded_fragments++;
                return false;
            }

            // assume is_tx was correct
            is_tx = !is_tx;
            tupleSwapPeers(&pkt.tuple);

            conn = pd_malloc(sizeof(pcap_conn_t));
            if(!conn) {
                log_f("malloc(pcap_conn_t) failed with code %d/%s",
                      errno, strerror(errno));
                return false;
            }

            pd_conn_t *data = pd_new_connection(pd, &pkt.tuple, hdr->uid);
            if(!data) {
                pd_free(conn);
                return false;
            }

            if (hdr->linktype == PCAPD_DLT_LINUX_SLL2)
                data->pcap.ifidx = ntohl(*(uint32_t*)(buffer + 4)); // sll2_header->sll2_if_index
            else if (pd->pcap_file_capture)
                data->pcap.ifidx = hdr->ifid;

            conn->tuple = pkt.tuple;
            conn->data = data;
            HASH_ADD(hh, pd->pcap.connections, tuple, sizeof(zdtun_5tuple_t), conn);

            switch (conn->tuple.ipproto) {
                case IPPROTO_TCP:
                    pd->stats.num_tcp_conn++;
                    pd->stats.num_tcp_opened++;
                    break;
                case IPPROTO_UDP:
                    pd->stats.num_udp_conn++;
                    pd->stats.num_udp_opened++;
                    break;
                case IPPROTO_ICMP:
                    pd->stats.num_icmp_conn++;
                    pd->stats.num_icmp_opened++;
                    break;
            }

            // assume connection proxy via iptables
            data->proxied = pd->tls_decryption.enabled && (conn->tuple.ipproto == IPPROTO_TCP);
        }
    }

    // like last_seen but monotonic
    conn->data->pcap.last_update_ms = pd->now_ms;

    // make a copy before passing it to pd_process_packet since conn may
    // be freed in update_connection_status, while the pkt_context_t is still
    // used in pd_account_stats
    zdtun_5tuple_t conn_tuple = conn->tuple;

    struct timeval tv = hdr->ts;
    pkt_context_t pinfo;
    pd_init_pkt_context(&pinfo, &pkt, is_tx, &conn_tuple, conn->data, &tv);
    g_cur_ctx = &pinfo;

    if (pd->pcap.usk && (pkt.len > 0)) {
        struct pcap_pkthdr pcap_hdr;
        pcap_hdr.len = pcap_hdr.caplen = pkt.len;
        pcap_hdr.ts = hdr->ts;

        ushark_dissect(pd->pcap.usk,
                           (const unsigned char*) pkt.l3,
                           &pcap_hdr);

        if (g_plain_data.n_items > 0)
            pinfo.plain_data = &g_plain_data;
    }

    pd_process_packet(pd, &pinfo);

    // NOTE: this may free the conn
    update_connection_status(pd, conn, &pkt, !is_tx);

    pd_account_stats(pd, &pinfo);

    if (g_plain_data.items) {
        for (size_t i = 0; i < g_plain_data.n_items; i++)
            pd_free(g_plain_data.items[i].data);

        pd_free(g_plain_data.items);
        memset(&g_plain_data, 0, sizeof(g_plain_data));
    }
    g_cur_ctx = NULL;

    return true;
}

/* ******************************************************* */

static void purge_expired_connections(pcapdroid_t *pd, uint8_t purge_all) {
    pcap_conn_t *conn, *tmp;

    HASH_ITER(hh, pd->pcap.connections, conn, tmp) {
        uint64_t timeout = 0;

        switch(conn->tuple.ipproto) {
            case IPPROTO_TCP:
                timeout = (conn->data->status >= CONN_STATUS_CLOSED) ? (TCP_CLOSED_TIMEOUT_SEC * 1000) : (TCP_TIMEOUT_SEC * 1000);
                break;
            case IPPROTO_UDP:
                timeout = UDP_TIMEOUT_SEC * 1000;
                break;
            case IPPROTO_ICMP:
                timeout = ICMP_TIMEOUT_SEC + 1000;
                break;
        }

        if(purge_all || (pd->now_ms >= (conn->data->pcap.last_update_ms + timeout))) {
            //log_d("IDLE (type=%d)", conn->tuple.ipproto);

            conn->data->to_purge = true;

            if(conn->data->status < CONN_STATUS_CLOSED) {
                conn->data->status = CONN_STATUS_CLOSED;
                conn->data->update_type |= CONN_UPDATE_STATS;
            }

            // If there is a pending notification, the connection data cannot be free now as it is enqueued in a conn_array_t
            if((conn->data->update_type == 0) || (pd_notify_connection_update(pd, &conn->tuple, conn->data) < 0)) {
                // no pending notification/pd_notify_connection_update failed, free now
                pd_purge_connection(pd, conn->data);
                conn->data = NULL;
            }

            remove_connection(pd, conn);
        }
    }
}

/* ******************************************************* */

void pcap_iter_connections(pcapdroid_t *pd, conn_cb cb) {
    pcap_conn_t *conn, *tmp;

    HASH_ITER(hh, pd->pcap.connections, conn, tmp) {
        if(cb(pd, &conn->tuple, conn->data) != 0)
            return;
    }
}

/* ******************************************************* */

static void process_pcapd_rv(pcapdroid_t *pd, int rv) {
    pcapd_rv rrv = (pcapd_rv) rv;
    log_i("pcapd exit code: %d", rv);

    switch (rrv) {
        case PCAPD_OK:
            break;
        case PCAPD_INTERFACE_OPEN_FAILED:
            if(pd->pcap_file_capture)
                log_f(PD_ERR_INVALID_PCAP_FILE);
            else
                log_f(PD_ERR_INTERFACE_OPEN_ERROR);
            break;
        case PCAPD_UNSUPPORTED_DATALINK:
            log_f(PD_ERR_UNSUPPORTED_DATALINK);
            break;
        case PCAPD_PCAP_READ_ERROR:
            log_f(PD_ERR_PCAP_READ);
            break;
        case PCAPD_SOCKET_WRITE_ERROR:
            // ignore, as it can be caused by PCAPdroid stopping the capture
            break;
        default:
            log_f("pcapd daemon exited with code %d", rv);
    }
}

/* ******************************************************* */

static reader_rv read_pcapd(pcapdroid_t *pd, int sock, pcapd_hdr_t* hdr, char *buffer) {
    fd_set fdset = {0};

    FD_SET(sock, &fdset);

    struct timeval timeout = {.tv_sec = 0, .tv_usec = SELECT_TIMEOUT_MS * 1000};

    if (select(sock + 1, &fdset, NULL, NULL, &timeout) < 0) {
        log_f("select failed[%d]: %s", errno, strerror(errno));
        return READER_ERROR;
    }

    pd_refresh_time(pd);

    if (!FD_ISSET(sock, &fdset))
        // used to indicate housekeeping
        return READER_CONTINUE;

    if(!running)
        return READER_EOF;

    ssize_t xrv = xread(sock, hdr, sizeof(*hdr));
    if (xrv != sizeof(*hdr)) {
        if (xrv < 0)
            log_f("read hdr from pcapd failed[%d]: %s", errno, strerror(errno));
        return READER_ERROR;
    }

    if (hdr->len > PCAPD_SNAPLEN) {
        log_f("packet too big (%d B)", hdr->len);
        return READER_ERROR;
    }

    if (xread(sock, buffer, hdr->len) != hdr->len) {
        log_f("read %d B packet from pcapd failed[%d]: %s", hdr->len, errno,
              strerror(errno));
        return READER_ERROR;
    }

    return READER_PACKET_OK;
}

static void on_dump_extensions_seen(void *_) {
    has_seen_dump_extensions = true;
}

static void on_uid_mapping(void *userdata, uid_t uid, const char *package_name, const char *app_name) {
    log_d("UID mapping: %u -> %s - %s", uid, package_name, app_name);

#ifdef ANDROID
    pcapdroid_t* pd = (pcapdroid_t*) userdata;
    loadUidMapping(pd, uid, package_name, app_name);
#endif
}

static reader_rv read_file(pcapdroid_t *pd, pd_reader_t *reader, pcapd_hdr_t* hdr, char *buffer) {
    pd_read_callbacks_t cbs = {
        .on_dump_extensions_seen = on_dump_extensions_seen,
        .on_uid_mapping = on_uid_mapping,
    };

    return pd_read_next(reader, hdr, buffer, &cbs, pd);
}

/* ******************************************************* */

int run_pcap(pcapdroid_t *pd) {
    int sock = -1;
    pd_reader_t *reader = NULL;

    int rv = -1;
    char buffer[PCAPD_SNAPLEN];
    bool iptables_cleanup = false;
    u_int64_t next_purge_ms;
    zdtun_callbacks_t callbacks = {.send_client = (void*)1};

    if (pd->pcap_file_capture) {
        // check if the SSL keylog exists
        // Use override path if provided (for tests), otherwise use default location
        const char *keylog_path = pd->keylog_path_override
                                   ? pd->keylog_path_override
                                   : get_cache_path(pd, "sslkeylog.txt");

        if (access(keylog_path, F_OK) == 0) {
            log_i("Use ushark for TLS decryption");

            if (ushark_init(pd)) {
                pd->pcap.usk = ushark_new(PCAPD_DLT_RAW, "");

                ushark_data_callbacks_t cbs = {
                        .on_http1_data = handle_ushark_http1_data,
                        .on_http2_request = handle_ushark_http2_request,
                        .on_http2_response = handle_ushark_http2_response,
                        .on_http2_reset = handle_ushark_http2_reset,
                };
                ushark_set_callbacks(pd->pcap.usk, &cbs);

                ushark_set_pref("tls.keylog_file", keylog_path);
            }
        }
    }

#if ANDROID
    char capture_interface[PATH_MAX] = "@inet";
    char bpf[256];
    bpf[0] = '\0';

    pd->pcap.app_filter_uids_size = getIntArrayPref(pd->env, pd->capture_service, "getAppFilterUids", &pd->pcap.app_filter_uids);
    pd->pcap.as_root = !pd->pcap_file_capture;
    pd->pcap.bpf = getStringPref(pd, "getPcapDumperBpf", bpf, sizeof(bpf));
    pd->pcap.capture_interface = getStringPref(pd, "getCaptureInterface", capture_interface, sizeof(capture_interface));
#endif

    if((pd->zdt = zdtun_init(&callbacks, NULL)) == NULL)
        return(-1);

    if (pd->pcap.as_root) {
        if ((sock = connectPcapd(pd)) < 0) {
            rv = -1;
            goto cleanup;
        }
    } else {
        // file capture
        char* error = NULL;
        reader = pd_new_reader(pd->pcap.capture_interface, &error);
        if (!reader) {
#ifndef FUZZING
            if (error)
                log_f(error);
#endif
            rv = -1;
            goto cleanup;
        }
    }

    if(pd->tls_decryption.enabled) {
        char args[128];

        if(pd->pcap.app_filter_uids_size > 0) {
            for (int i = 0; i < pd->pcap.app_filter_uids_size; i++) {
                int uid = pd->pcap.app_filter_uids[i];

                if (uid >= 0) {
                    if(run_shell_cmd("iptables", get_mitm_redirection_args(pd, args, uid, true), true, true) != 0)
                        goto cleanup;

                    iptables_cleanup = true;
                }
            }
        } else {
            if(run_shell_cmd("iptables", get_mitm_redirection_args(pd, args, -1, true), true, true) != 0)
                goto cleanup;

            iptables_cleanup = true;
        }
    }

    pd_refresh_time(pd);
    next_purge_ms = pd->now_ms + PERIODIC_PURGE_TIMEOUT_MS;

    log_i("Starting packet loop");
    if(pd->cb.notify_service_status && running)
        pd->cb.notify_service_status(pd, "started");

    bool eof = false;
    bool has_seen_packets = false;

    while(running && !eof) {
        pcapd_hdr_t hdr;

        reader_rv xrv = (reader != NULL) ?
                read_file(pd, reader, &hdr, buffer) :
                read_pcapd(pd, sock, &hdr, buffer);
        switch (xrv) {
            case READER_ERROR:
#ifndef FUZZING
                if (reader != NULL)
                    log_f(PD_ERR_PCAP_READ);
#endif
                goto cleanup;
            case READER_CONTINUE:
                goto housekeeping;
            case READER_EOF:
                eof = true;
                pd_refresh_time(pd);
                goto housekeeping; // last housekeeping
            case READER_PACKET_OK:
                has_seen_packets = true;
                break;
        }

        pd->num_dropped_pkts = hdr.pkt_drops;

        int ipoffset = get_ip_offset(hdr.linktype);
        if(ipoffset < 0) {
            log_e("invalid datalink: %d", hdr.linktype);
            continue;
        }
        if(hdr.len < ipoffset) {
            log_e("invalid length: %d, expected at least %d", hdr.len, ipoffset);
            continue;
        }

        if(!handle_packet(pd, &hdr, buffer, ipoffset)) {
            // packet was rejected (unsupported/corrupted), dump to PCAP file anyway
            struct timeval tv = hdr.ts;
            pd_dump_packet(pd, buffer + ipoffset, hdr.len - ipoffset, &tv, hdr.uid, hdr.ifid);
        }

    housekeeping:
        pd_housekeeping(pd);

        if(pd->now_ms >= next_purge_ms) {
            purge_expired_connections(pd, 0);
            next_purge_ms = pd->now_ms + PERIODIC_PURGE_TIMEOUT_MS;
        }
    }

    if (eof && (reader != NULL) && !has_seen_packets &&
            pd_has_unsupported_dlt_packets(reader) &&
            (pd_get_dump_format(reader) == PCAPNG_DUMP)
    ) {
        // For Pcapng, the unsupported datalink error can only be triggered after
        // processing the whole file
#ifndef FUZZING
        log_f(PD_ERR_UNSUPPORTED_DATALINK);
#endif
        rv = -1;
        goto cleanup;
    }

    rv = 0;

cleanup:
    purge_expired_connections(pd, 1 /* purge_all */);

    if(pd->zdt) zdtun_finalize(pd->zdt);
    if(sock >= 0) close(sock);
    if(reader != NULL) pd_destroy_reader(reader);

    if(iptables_cleanup) {
        char args[128];

        if(pd->pcap.app_filter_uids_size > 0) {
            for (int i = 0; i < pd->pcap.app_filter_uids_size; i++) {
                int uid = pd->pcap.app_filter_uids[i];

                if (uid >= 0)
                    run_shell_cmd("iptables", get_mitm_redirection_args(pd, args, uid, false), true, false);
            }
        } else
            run_shell_cmd("iptables", get_mitm_redirection_args(pd, args, -1, false), true, false);
    }

    if((pd->pcap.pcapd_pid > 0) && !pd->pcap.daemonize) {
        int status = PCAPD_ERROR;

        if(waitpid(pd->pcap.pcapd_pid, &status, 0) <= 0)
            log_e("waitpid %d failed[%d]: %s", pd->pcap.pcapd_pid, errno, strerror(errno));

        if(WIFEXITED(status))
            process_pcapd_rv(pd, WEXITSTATUS(status));
    }

#if ANDROID
    if (pd->pcap.app_filter_uids) {
        pd_free(pd->pcap.app_filter_uids);

        pd->pcap.app_filter_uids = NULL;
        pd->pcap.app_filter_uids_size = 0;
    }
#endif

    if (pd->pcap.usk) {
        ushark_destroy(pd->pcap.usk);
        pd->pcap.usk = NULL;

        ushark_cleanup();
    }

    return rv;
}

```

`app/src/main/jni/core/capture_vpn.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

#include <netinet/tcp.h>
#include <netinet/udp.h>

#include "pcapdroid.h"
#include "common/utils.h"
#include "port_map.h"

/* ******************************************************* */

static int resolve_uid(pcapdroid_t *pd, const zdtun_5tuple_t *conn_info) {
    char buf[256];
    jint uid;

    zdtun_5tuple2str(conn_info, buf, sizeof(buf));
    uid = get_uid(pd->vpn.resolver, conn_info);

    if(uid >= 0) {
        char appbuf[64];

        get_appname_by_uid(pd, uid, appbuf, sizeof(appbuf));
        log_d( "%s [%d/%s]", buf, uid, appbuf);
    } else {
        uid = UID_UNKNOWN;
        log_w("%s => UID not found!", buf);
    }

    return(uid);
}

static void protectSocketCallback(zdtun_t *zdt, socket_t sock) {
#if ANDROID
    pcapdroid_t *pd = ((pcapdroid_t*)zdtun_userdata(zdt));
    JNIEnv *env = pd->env;

    if(!pd->vpn_capture)
        return;

    /* Call VpnService protect */
    jboolean isProtected = (*env)->CallBooleanMethod(
            env, pd->capture_service, mids.protect, sock);
    jniCheckException(env);

    if(!isProtected)
        log_e("socket protect failed");
#endif
}

/* ******************************************************* */

static struct timeval* get_pkt_timestamp(pcapdroid_t *pd, struct timeval *tv) {
    struct timespec ts;

    if(!clock_gettime(CLOCK_REALTIME, &ts)) {
        tv->tv_sec = ts.tv_sec;
        tv->tv_usec = ts.tv_nsec / 1000;
        return tv;
    }

    log_w("clock_gettime failed[%d]: %s", errno, strerror(errno));
    return tv;
}

/* ******************************************************* */

static int remote2vpn(zdtun_t *zdt, zdtun_pkt_t *pkt, const zdtun_conn_t *conn_info) {
    if(!running)
        // e.g. during zdtun_finalize
        return 0;

    pcapdroid_t *pd = (pcapdroid_t*) zdtun_userdata(zdt);
    const zdtun_5tuple_t *tuple = zdtun_conn_get_5tuple(conn_info);
    pd_conn_t *data = zdtun_conn_get_userdata(conn_info);

    // if this is called inside zdtun_forward, account the egress packet before the subsequent ingress packet
    if(data->vpn.fw_pctx) {
        pd_account_stats(pd, data->vpn.fw_pctx);
        data->vpn.fw_pctx = NULL;
    }

    struct timeval tv;
    pkt_context_t pctx;
    pd_refresh_time(pd);

    pd_init_pkt_context(&pctx, pkt, false, tuple, data, get_pkt_timestamp(pd, &tv));
    pd_process_packet(pd, &pctx);
    if(data->to_block) {
        data->blocked_pkts++;
        data->update_type |= CONN_UPDATE_STATS;
        pd_notify_connection_update(pd, tuple, data);

        // Returning -1 will result into an error condition on the connection, forcing a connection
        // close. Closing the connection is mandatory as it's not possible to handle dropped packets
        // via zdtun, since data received via the zdtun TCP sockets must be delivered to the client.
        return -1;
    }

    int rv = write(pd->vpn.tunfd, pkt->buf, pkt->len);
    if(rv < 0) {
        if(errno == ENOBUFS) {
            char buf[256];

            // Do not abort, the connection will be terminated
            log_e("Got ENOBUFS %s", zdtun_5tuple2str(tuple, buf, sizeof(buf)));
        } else if(errno == EIO) {
            log_i("Got I/O error (terminating?)");
            running = false;
        } else {
            log_f("zdt write (%d) failed [%d]: %s", pkt->len, errno, strerror(errno));
            running = false;
        }
    } else if(rv != pkt->len) {
        log_f("partial zdt write (%d / %d)", rv, pkt->len);
        rv = -1;
    } else {
        // Success
        rv = 0;
        pd_account_stats(pd, &pctx);
    }

    return rv;
}

/* ******************************************************* */

/*
 * If the packet contains a DNS request directed to the IP address used internally by PCAPdroid,
 * then rewrite the server address with the actual DNS server.
 * Moreover, if a private DNS connection is detected in opportunistic mode (block_private_dns true),
 * then block this connection to force the fallback to non-private DNS mode.
 */
static bool check_dns_req_allowed(pcapdroid_t *pd, zdtun_conn_t *conn, pkt_context_t *pctx) {
    const zdtun_5tuple_t *tuple = pctx->tuple;

    if(new_dns_server != 0) {
        log_i("Using new DNS server");
        pd->vpn.ipv4.dns_server = new_dns_server;
        new_dns_server = 0;
    }

    if(pctx->tuple->ipproto == IPPROTO_ICMP)
        return true;

    bool is_internal_dns = pd->vpn.ipv4.enabled && (tuple->ipver == 4) && (tuple->dst_ip.ip4 == pd->vpn.ipv4.internal_dns);
    bool is_dns_server = is_internal_dns
                         || (pd->vpn.ipv6.enabled && (tuple->ipver == 6) && (memcmp(&tuple->dst_ip.ip6, &pd->vpn.ipv6.dns_server, 16) == 0));

    if(!is_dns_server) {
        // try with known DNS servers
        zdtun_ip_t dst_ip = tuple->dst_ip;

        if(blacklist_match_ip(pd->vpn.known_dns_servers, &dst_ip, tuple->ipver)) {
            char ip[INET6_ADDRSTRLEN];
            int family = (tuple->ipver == 4) ? AF_INET : AF_INET6;

            is_dns_server = true;
            ip[0] = '\0';
            inet_ntop(family, &dst_ip, (char *)&ip, sizeof(ip));

            log_d("Matched known DNS server: %s", ip);
        }
    }

    if(!is_dns_server)
        return(true);

    if((tuple->ipproto == IPPROTO_UDP) && (ntohs(tuple->dst_port) == 53)) {
        zdtun_pkt_t *pkt = pctx->pkt;
        int dns_length = pkt->l7_len;

        if(dns_length >= sizeof(dns_packet_t)) {
            dns_packet_t *dns_data = (dns_packet_t*) pkt->l7;

            if((dns_data->flags & DNS_FLAGS_MASK) != DNS_TYPE_REQUEST)
                return(true);

            pd->num_dns_requests++;

            if(is_internal_dns) {
                /*
                 * Direct the packet to the public DNS server. Checksum recalculation is not strictly necessary
                 * here as zdtun will pd the connection.
                 */
                zdtun_ip_t ip = {0};
                ip.ip4 = pd->vpn.ipv4.dns_server;
                zdtun_conn_dnat(conn, &ip, htons(53), 4);
            }

            return(true);
        }
    }

    if(block_private_dns) {
        log_d("blocking packet directed to the DNS server");
        return(false);
    }

    // allow
    return(true);
}

/* ******************************************************* */

static bool spoof_dns_reply(pcapdroid_t *pd, zdtun_conn_t *conn, pkt_context_t *pctx) {
    // Step 1: ensure that this is a valid query
    zdtun_pkt_t *pkt = pctx->pkt;
    if(pkt->l7_len < (sizeof(dns_packet_t) + 5))
        return false;

    dns_packet_t *req = (dns_packet_t*) pkt->l7;
    if(ntohs(req->questions) != 1)
        return false;

    int remaining = pkt->l7_len - sizeof(dns_packet_t);
    int qlen=0;
    while(remaining >= 5) {
        if(!req->queries[qlen])
            break;
        qlen++;
        remaining--;
    }

    if((req->queries[qlen] != 0) || (req->queries[qlen + 1] != 0) ||
       (req->queries[qlen + 3] != 0) || (req->queries[qlen + 4] != 1))
        return false; // invalid

    uint8_t qtype = req->queries[qlen + 2];
    if((qtype != 0x01) && (qtype != 0x1c))
        return false; // invalid query type

    // Step 2: spoof the reply
    log_d("Spoofing %s DNS reply", (qtype == 0x01) ? "A" : "AAAA");

    const zdtun_5tuple_t *tuple = pctx->tuple;
    uint8_t alen = (qtype == 0x01) ? 4 : 16;
    int iplen = zdtun_iphdr_len(pd->zdt, conn);
    unsigned int len = iplen + 8 /* UDP */ + sizeof(dns_packet_t) + qlen + 5 /* type, ... */ + 12 /* answer */ + alen;
    char buf[len];
    memset(buf, 0, len);

    zdtun_make_iphdr(pd->zdt, conn, buf, len - iplen);

    struct udphdr *udp = (struct udphdr*)(buf + iplen);
    udp->uh_sport = tuple->dst_port;
    udp->uh_dport = tuple->src_port;
    udp->len = htons(len - iplen);

    dns_packet_t *dns = (dns_packet_t*)(buf + iplen + 8);
    dns->transaction_id = req->transaction_id;
    dns->flags = htons(0x8180);
    dns->questions = req->questions;
    dns->answ_rrs = dns->questions;
    dns->auth_rrs = dns->additional_rrs = 0;

    // Queries
    memcpy(dns->queries, req->queries, qlen + 5);

    // Answers
    uint8_t *answ = dns->queries + qlen + 5;

    answ[0] = 0xc0, answ[1] = 0x0c;        // name ptr
    answ[2] = 0x00, answ[3] = qtype;       // type
    answ[4] = 0x00, answ[5] = 0x01;        // class IN
    *(uint32_t*)(answ + 6) = htonl(10); // TTL: 10s
    answ[10] = 0x00, answ[11] = alen;      // addr length
    memset(answ + 12, 0, alen);      // addr: 0.0.0.0/::

    // checksum
    udp->uh_sum = 0;
    udp->uh_sum = zdtun_l3_checksum(pd->zdt, conn, buf, (char*)udp, len - iplen);

    //hexdump(buf, len);
    write(pd->vpn.tunfd, buf, len);

    return true;
}

/* ******************************************************* */

static int handle_new_connection(zdtun_t *zdt, zdtun_conn_t *conn_info) {
    pcapdroid_t *pd = ((pcapdroid_t *) zdtun_userdata(zdt));
    const zdtun_5tuple_t *tuple = zdtun_conn_get_5tuple(conn_info);

    pd_conn_t *data = pd_new_connection(pd, tuple, resolve_uid(pd, tuple));
    if(!data) {
        /* reject connection */
        return (1);
    }

    zdtun_conn_set_userdata(conn_info, data);

    /* accept connection */
    return(0);
}

/* ******************************************************* */

static void connection_closed(zdtun_t *zdt, const zdtun_conn_t *conn_info) {
    pcapdroid_t *pd = (pcapdroid_t*) zdtun_userdata(zdt);
    pd_conn_t *data = zdtun_conn_get_userdata(conn_info);

    if(!data) {
        log_e("Missing data in connection");
        return;
    }

    const zdtun_5tuple_t *tuple = zdtun_conn_get_5tuple(conn_info);

    // Send last notification
    // Will free the data in sendConnectionsDump
    data->update_type |= CONN_UPDATE_STATS;
    if(pd_notify_connection_update(pd, tuple, data) < 0) {
        pd_purge_connection(pd, data);
        return;
    }

    pd_giveup_dpi(pd, data, tuple);
    data->status = zdtun_conn_get_status(conn_info);
    data->error = zdtun_conn_get_error(conn_info);
    data->to_purge = true;
}

/* ******************************************************* */

// This is called after remote2vpn or zdtun_forward
// No need to call pd_notify_connection_update, pd_account_stats is executed before
static void update_conn_status(zdtun_t *zdt, const zdtun_pkt_t *pkt, uint8_t from_tun, const zdtun_conn_t *conn_info) {
    pd_conn_t *data = zdtun_conn_get_userdata(conn_info);

    // Update the connection status
    data->status = zdtun_conn_get_status(conn_info);
    if(data->status >= CONN_STATUS_CLOSED) {
        data->to_purge = true;
        data->error = zdtun_conn_get_error(conn_info);
    }
}

/* ******************************************************* */

static bool matches_decryption_whitelist(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    zdtun_ip_t dst_ip = tuple->dst_ip;

    if(!pd->tls_decryption.list)
        return false;

    // NOTE: domain matching only works if a prior DNS reply is seen (see ip_lru_find in pd_new_connection)
    return blacklist_match_ip(pd->tls_decryption.list, &dst_ip, tuple->ipver) ||
        blacklist_match_uid(pd->tls_decryption.list, data->uid) ||
        (data->info && blacklist_match_domain(pd->tls_decryption.list, data->info));
}

/* ******************************************************* */

// NOTE: this handles both user-specified SOCKS5 and TLS decryption
static bool should_proxify(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    if(!pd->socks5.enabled)
        return false;

    if (pd->tls_decryption.list) {
        // TLS decryption
        if(!matches_decryption_whitelist(pd, tuple, data)) {
            data->decryption_ignored = true;
            return false;
        }

        // Since we cannot reliably determine TLS connections with 1 packet, and connections must be
        // proxified on the 1st packet, we proxify all the TCP connections
    }

    return (tuple->ipproto == IPPROTO_TCP);
}

/* ******************************************************* */

void vpn_process_ndpi(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    if(data->l7proto == NDPI_PROTOCOL_QUIC) {
        block_quic_mode_t block_mode = pd->vpn.block_quic_mode;

        if ((block_mode == BLOCK_QUIC_MODE_ALWAYS) ||
                ((block_mode == BLOCK_QUIC_MODE_TO_DECRYPT) && matches_decryption_whitelist(pd, tuple, data))) {
            data->blacklisted_internal = true;
            data->to_block = true;
        }
    }

    if(block_private_dns && !data->to_block &&
            (data->l7proto == NDPI_PROTOCOL_TLS) &&
            data->info && blacklist_match_domain(pd->vpn.known_dns_servers, data->info)) {
        log_d("blocking connection to private DNS server %s", data->info);
        data->blacklisted_internal = true;
        data->to_block = true;
    }
}

/* ******************************************************* */

static void load_dns_servers(pcapdroid_t *pd) {
    // IP addresses (both legacy and private DNS). These are used to count DNS queries and
    // redirect DNS queries to the public DNS server (see check_dns_req_allowed)
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "8.8.8.8");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "8.8.4.4");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "1.1.1.1");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "1.0.0.1");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "2001:4860:4860::8888");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "2001:4860:4860::8844");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "2606:4700:4700::64");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "2606:4700:4700::6400");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "2606:4700:4700::1111");
    blacklist_add_ipstr(pd->vpn.known_dns_servers, "2606:4700:4700::1001");

    // Domains (only private DNS)
    // https://help.firewalla.com/hc/en-us/articles/360060661873-Dealing-DNS-over-HTTPS-and-DNS-over-TLS-on-your-network
    blacklist_add_domain(pd->vpn.known_dns_servers, "dns.google");
    blacklist_add_domain(pd->vpn.known_dns_servers, "chrome.cloudflare-dns.com");
    blacklist_add_domain(pd->vpn.known_dns_servers, "mozilla.cloudflare-dns.com");
    blacklist_add_domain(pd->vpn.known_dns_servers, "doh.cleanbrowsing.org");
    blacklist_add_domain(pd->vpn.known_dns_servers, "chromium.dns.nextdns.io");
    blacklist_add_domain(pd->vpn.known_dns_servers, "firefox.dns.nextdns.io");
    blacklist_add_domain(pd->vpn.known_dns_servers, "dns.quad9.net");
    blacklist_add_domain(pd->vpn.known_dns_servers, "doh.opendns.com");
    blacklist_add_domain(pd->vpn.known_dns_servers, "dns.adguard.com");
    blacklist_add_domain(pd->vpn.known_dns_servers, "dot.libredns.gr");
    blacklist_add_domain(pd->vpn.known_dns_servers, "dns.dnslify.com");
    blacklist_add_domain(pd->vpn.known_dns_servers, "dns-tls.qis.io");
}

/* ******************************************************* */

int run_vpn(pcapdroid_t *pd) {
    zdtun_t *zdt;
    char buffer[VPN_BUFFER_SIZE];
    u_int64_t next_purge_ms;

    int flags = fcntl(pd->vpn.tunfd, F_GETFL, 0);
    if (flags < 0 || fcntl(pd->vpn.tunfd, F_SETFL, flags & ~O_NONBLOCK) < 0) {
        log_f("fcntl ~O_NONBLOCK error [%d]: %s", errno,
                    strerror(errno));
        return (-1);
    }

#if ANDROID
    pd->vpn.resolver = init_uid_resolver(pd->sdk_ver, pd->env, pd->capture_service);
    pd->vpn.known_dns_servers = blacklist_init();
    pd->vpn.block_quic_mode = getIntPref(pd->env, pd->capture_service, "getBlockQuickMode");

    pd->vpn.ipv4.enabled = (bool) getIntPref(pd->env, pd->capture_service, "getIPv4Enabled");
    pd->vpn.ipv4.dns_server = getIPv4Pref(pd->env, pd->capture_service, "getDnsServer");
    pd->vpn.ipv4.internal_dns = getIPv4Pref(pd->env, pd->capture_service, "getVpnDns");

    pd->vpn.ipv6.enabled = (bool) getIntPref(pd->env, pd->capture_service, "getIPv6Enabled");
    pd->vpn.ipv6.dns_server = getIPv6Pref(pd->env, pd->capture_service, "getIpv6DnsServer");
#endif

    zdtun_callbacks_t callbacks = {
        .send_client = remote2vpn,
        .account_packet = update_conn_status,
        .on_socket_open = protectSocketCallback,
        .on_connection_open = handle_new_connection,
        .on_connection_close = connection_closed,
    };

    load_dns_servers(pd);

    zdt = zdtun_init(&callbacks, pd);
    if(zdt == NULL) {
        log_f("zdtun_init failed");
        return(-2);
    }

#if ANDROID
    zdtun_set_mtu(zdt, getIntPref(pd->env, pd->capture_service, "getVpnMTU"));
#endif

    pd->zdt = zdt;
    new_dns_server = 0;

    if(pd->socks5.enabled) {
        zdtun_set_socks5_proxy(zdt, &pd->socks5.proxy_ip, pd->socks5.proxy_port, pd->socks5.proxy_ipver);

        if(pd->socks5.proxy_user[0] && pd->socks5.proxy_pass[0])
            zdtun_set_socks5_userpass(zdt, pd->socks5.proxy_user, pd->socks5.proxy_pass);
    }

    pd_refresh_time(pd);
    next_purge_ms = pd->now_ms + PERIODIC_PURGE_TIMEOUT_MS;

    log_i("Starting packet loop");
    if(pd->cb.notify_service_status && running)
        pd->cb.notify_service_status(pd, "started");

    while(running) {
        int max_fd;
        fd_set fdset;
        fd_set wrfds;
        int size;
        struct timeval timeout = {.tv_sec = 0, .tv_usec = SELECT_TIMEOUT_MS * 1000};

        zdtun_fds(zdt, &max_fd, &fdset, &wrfds);

        FD_SET(pd->vpn.tunfd, &fdset);
        max_fd = max(max_fd, pd->vpn.tunfd);

        if((select(max_fd + 1, &fdset, &wrfds, NULL, &timeout) < 0) && (errno != EINTR)) {
            log_e("select failed[%d]: %s", errno, strerror(errno));
            break;
        }

        if(!running)
            break;

        if(FD_ISSET(pd->vpn.tunfd, &fdset)) {
            /* Packet from VPN */
            size = read(pd->vpn.tunfd, buffer, sizeof(buffer));
            if(size > 0) {
                zdtun_pkt_t pkt;
                pd_refresh_time(pd);

                if(zdtun_parse_pkt(zdt, buffer, size, &pkt) != 0) {
                    log_d("zdtun_parse_pkt failed");
                    goto housekeeping;
                }

                if(pkt.flags & ZDTUN_PKT_IS_FRAGMENT) {
                    log_d("discarding IP fragment");
                    pd->num_discarded_fragments++;
                    goto housekeeping;
                }

                bool is_internal_dns = pd->vpn.ipv4.enabled && (pkt.tuple.ipver == 4) && (pkt.tuple.dst_ip.ip4 == pd->vpn.ipv4.internal_dns);
                if(is_internal_dns && ntohs(pkt.tuple.dst_port) == 853) {
                    // accepting this packet could result in multiple TCP connections being spammed
                    log_d("discarding private DNS packet directed to internal DNS");
                    goto housekeeping;
                }

                if(((pkt.tuple.ipver == 6) && !pd->vpn.ipv6.enabled) ||
                        ((pkt.tuple.ipver == 4) && !pd->vpn.ipv4.enabled)) {
                    char buf[512];

                    log_d("ignoring IPv%d packet: %s", pkt.tuple.ipver,
                                zdtun_5tuple2str(&pkt.tuple, buf, sizeof(buf)));
                    goto housekeeping;
                }

                // Skip established TCP connections
                uint8_t is_tcp_established = ((pkt.tuple.ipproto == IPPROTO_TCP) &&
                                              (!(pkt.tcp->th_flags & TH_SYN) || (pkt.tcp->th_flags & TH_ACK)));

                zdtun_conn_t *conn = zdtun_lookup(zdt, &pkt.tuple, !is_tcp_established);
                if (!conn) {
                    if(!is_tcp_established) {
                        char buf[512];

                        pd->num_dropped_connections++;
                        log_e("zdtun_lookup failed: %s",
                                    zdtun_5tuple2str(&pkt.tuple, buf, sizeof(buf)));
                    } else {
                        char buf[512];

                        log_d("skipping established TCP: %s",
                                    zdtun_5tuple2str(&pkt.tuple, buf, sizeof(buf)));
                    }
                    goto housekeeping;
                }

                // Process the packet
                struct timeval tv;
                const zdtun_5tuple_t *tuple = zdtun_conn_get_5tuple(conn);
                pkt_context_t pctx;
                pd_conn_t *data = zdtun_conn_get_userdata(conn);

                // To be run before pd_process_packet/process_payload
                if(data->sent_pkts == 0) {
                    if(pd_check_port_map(conn))
                        data->port_mapping_applied = true;
                    else if(should_proxify(pd, tuple, data)) {
                        zdtun_conn_proxy(conn);
                        data->proxied = true;
                    }
                }

                pd_init_pkt_context(&pctx, &pkt, true, tuple, data, get_pkt_timestamp(pd, &tv));
                pd_process_packet(pd, &pctx);
                if(data->sent_pkts == 0) {
                    // Newly created connections
                    if (!data->port_mapping_applied)
                        data->blacklisted_internal |= !check_dns_req_allowed(pd, conn, &pctx);
                    data->to_block |= data->blacklisted_internal;

                    if(data->to_block) {
                        // blocking a DNS query can cause multiple requests to be spammed. Better to
                        // spoof a reply with an invalid IP.
                        if((data->l7proto == NDPI_PROTOCOL_DNS) && (tuple->ipproto == IPPROTO_UDP)) {
                            spoof_dns_reply(pd, conn, &pctx);
                            zdtun_conn_close(zdt, conn, CONN_STATUS_CLOSED);
                        }
                    }
                }

                if(data->to_block) {
                    data->blocked_pkts++;
                    data->update_type |= CONN_UPDATE_STATS;
                    pd_notify_connection_update(pd, tuple, data);
                    goto housekeeping;
                }

                // NOTE: zdtun_forward will call remote2vpn
                data->vpn.fw_pctx = &pctx;
                if(zdtun_forward(zdt, &pkt, conn) != 0) {
                    char buf[512];
                    zdtun_conn_status_t status = zdtun_conn_get_status(conn);

                    if(status != CONN_STATUS_UNREACHABLE) {
                        log_e("zdtun_forward failed[%d]: %s", status,
                              zdtun_5tuple2str(&pkt.tuple, buf, sizeof(buf)));

                        pd->num_dropped_connections++;
                    } else
                        log_w("%s: net/host unreachable", zdtun_5tuple2str(&pkt.tuple, buf, sizeof(buf)));

                    zdtun_conn_close(zdt, conn, CONN_STATUS_ERROR);
                    goto housekeeping;
                } else {
                    // zdtun_forward was successful
                    if(data->vpn.fw_pctx) {
                        // it was not accounted in remote2vpn, account here
                        pd_account_stats(pd, data->vpn.fw_pctx);
                        data->vpn.fw_pctx = NULL;
                    }

                    // First forwarded packet
                    if(data->sent_pkts == 1) {
                        // The socket is open only after zdtun_forward is called
                        socket_t sock = zdtun_conn_get_socket(conn);

                        // In SOCKS5 with the MitmReceiver, we need the local port to the SOCKS5 proxy
                        if((sock != INVALID_SOCKET) && (tuple->ipver == 4)) {
                            // NOTE: the zdtun SOCKS5 implementation only supports IPv4 right now.
                            // If it also supported IPv6, than we would need to expose "sock_ipver"
                            struct sockaddr_in local_addr;
                            socklen_t addrlen = sizeof(local_addr);

                            if(getsockname(sock, (struct sockaddr*) &local_addr, &addrlen) == 0)
                                data->vpn.local_port = local_addr.sin_port;
                        }
                    }
                }
            } else {
                pd_refresh_time(pd);
                if(size < 0)
                    log_e("recv(tunfd) returned error [%d]: %s", errno,
                          strerror(errno));
            }
        } else {
            pd_refresh_time(pd);
            zdtun_handle_fd(zdt, &fdset, &wrfds);
        }

        housekeeping:
        pd_housekeeping(pd);

        if(pd->now_ms >= next_purge_ms) {
            zdtun_purge_expired(zdt);
            next_purge_ms = pd->now_ms + PERIODIC_PURGE_TIMEOUT_MS;
        }
    }

    pd_reset_port_map();
    zdtun_finalize(zdt);

#if ANDROID
    destroy_uid_resolver(pd->vpn.resolver);
    blacklist_destroy(pd->vpn.known_dns_servers);
#endif

    return(0);
}



```

`app/src/main/jni/core/crc32.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 *
 * Adapted from the slicing-by-4 implementation provided in
 * https://github.com/stbrumme/crc32/blob/master/Crc32.cpp .
 * Original Copyright (c) 2011-2019 Stephan Brumme.
 */

#include <endian.h>
#include <stdlib.h>
#include <stdint.h>

static inline uint32_t swap32(uint32_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return __builtin_bswap32(x);
#else
  return (x >> 24) |
  ((x >>  8) & 0x0000FF00) |
  ((x <<  8) & 0x00FF0000) |
  (x << 24);
#endif
}

static const uint32_t Crc32Lookup[4][256] = {
  {
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,
    0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,
    0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,
    0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,
    0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,
    0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,
    0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,
    0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,
    0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,
    0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,
    0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
    0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,
    0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,
    0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,
    0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,
    0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,
    0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
  },{
    0x00000000,0x191B3141,0x32366282,0x2B2D53C3,0x646CC504,0x7D77F445,0x565AA786,0x4F4196C7,
    0xC8D98A08,0xD1C2BB49,0xFAEFE88A,0xE3F4D9CB,0xACB54F0C,0xB5AE7E4D,0x9E832D8E,0x87981CCF,
    0x4AC21251,0x53D92310,0x78F470D3,0x61EF4192,0x2EAED755,0x37B5E614,0x1C98B5D7,0x05838496,
    0x821B9859,0x9B00A918,0xB02DFADB,0xA936CB9A,0xE6775D5D,0xFF6C6C1C,0xD4413FDF,0xCD5A0E9E,
    0x958424A2,0x8C9F15E3,0xA7B24620,0xBEA97761,0xF1E8E1A6,0xE8F3D0E7,0xC3DE8324,0xDAC5B265,
    0x5D5DAEAA,0x44469FEB,0x6F6BCC28,0x7670FD69,0x39316BAE,0x202A5AEF,0x0B07092C,0x121C386D,
    0xDF4636F3,0xC65D07B2,0xED705471,0xF46B6530,0xBB2AF3F7,0xA231C2B6,0x891C9175,0x9007A034,
    0x179FBCFB,0x0E848DBA,0x25A9DE79,0x3CB2EF38,0x73F379FF,0x6AE848BE,0x41C51B7D,0x58DE2A3C,
    0xF0794F05,0xE9627E44,0xC24F2D87,0xDB541CC6,0x94158A01,0x8D0EBB40,0xA623E883,0xBF38D9C2,
    0x38A0C50D,0x21BBF44C,0x0A96A78F,0x138D96CE,0x5CCC0009,0x45D73148,0x6EFA628B,0x77E153CA,
    0xBABB5D54,0xA3A06C15,0x888D3FD6,0x91960E97,0xDED79850,0xC7CCA911,0xECE1FAD2,0xF5FACB93,
    0x7262D75C,0x6B79E61D,0x4054B5DE,0x594F849F,0x160E1258,0x0F152319,0x243870DA,0x3D23419B,
    0x65FD6BA7,0x7CE65AE6,0x57CB0925,0x4ED03864,0x0191AEA3,0x188A9FE2,0x33A7CC21,0x2ABCFD60,
    0xAD24E1AF,0xB43FD0EE,0x9F12832D,0x8609B26C,0xC94824AB,0xD05315EA,0xFB7E4629,0xE2657768,
    0x2F3F79F6,0x362448B7,0x1D091B74,0x04122A35,0x4B53BCF2,0x52488DB3,0x7965DE70,0x607EEF31,
    0xE7E6F3FE,0xFEFDC2BF,0xD5D0917C,0xCCCBA03D,0x838A36FA,0x9A9107BB,0xB1BC5478,0xA8A76539,
    0x3B83984B,0x2298A90A,0x09B5FAC9,0x10AECB88,0x5FEF5D4F,0x46F46C0E,0x6DD93FCD,0x74C20E8C,
    0xF35A1243,0xEA412302,0xC16C70C1,0xD8774180,0x9736D747,0x8E2DE606,0xA500B5C5,0xBC1B8484,
    0x71418A1A,0x685ABB5B,0x4377E898,0x5A6CD9D9,0x152D4F1E,0x0C367E5F,0x271B2D9C,0x3E001CDD,
    0xB9980012,0xA0833153,0x8BAE6290,0x92B553D1,0xDDF4C516,0xC4EFF457,0xEFC2A794,0xF6D996D5,
    0xAE07BCE9,0xB71C8DA8,0x9C31DE6B,0x852AEF2A,0xCA6B79ED,0xD37048AC,0xF85D1B6F,0xE1462A2E,
    0x66DE36E1,0x7FC507A0,0x54E85463,0x4DF36522,0x02B2F3E5,0x1BA9C2A4,0x30849167,0x299FA026,
    0xE4C5AEB8,0xFDDE9FF9,0xD6F3CC3A,0xCFE8FD7B,0x80A96BBC,0x99B25AFD,0xB29F093E,0xAB84387F,
    0x2C1C24B0,0x350715F1,0x1E2A4632,0x07317773,0x4870E1B4,0x516BD0F5,0x7A468336,0x635DB277,
    0xCBFAD74E,0xD2E1E60F,0xF9CCB5CC,0xE0D7848D,0xAF96124A,0xB68D230B,0x9DA070C8,0x84BB4189,
    0x03235D46,0x1A386C07,0x31153FC4,0x280E0E85,0x674F9842,0x7E54A903,0x5579FAC0,0x4C62CB81,
    0x8138C51F,0x9823F45E,0xB30EA79D,0xAA1596DC,0xE554001B,0xFC4F315A,0xD7626299,0xCE7953D8,
    0x49E14F17,0x50FA7E56,0x7BD72D95,0x62CC1CD4,0x2D8D8A13,0x3496BB52,0x1FBBE891,0x06A0D9D0,
    0x5E7EF3EC,0x4765C2AD,0x6C48916E,0x7553A02F,0x3A1236E8,0x230907A9,0x0824546A,0x113F652B,
    0x96A779E4,0x8FBC48A5,0xA4911B66,0xBD8A2A27,0xF2CBBCE0,0xEBD08DA1,0xC0FDDE62,0xD9E6EF23,
    0x14BCE1BD,0x0DA7D0FC,0x268A833F,0x3F91B27E,0x70D024B9,0x69CB15F8,0x42E6463B,0x5BFD777A,
    0xDC656BB5,0xC57E5AF4,0xEE530937,0xF7483876,0xB809AEB1,0xA1129FF0,0x8A3FCC33,0x9324FD72,
  },{
    0x00000000,0x01C26A37,0x0384D46E,0x0246BE59,0x0709A8DC,0x06CBC2EB,0x048D7CB2,0x054F1685,
    0x0E1351B8,0x0FD13B8F,0x0D9785D6,0x0C55EFE1,0x091AF964,0x08D89353,0x0A9E2D0A,0x0B5C473D,
    0x1C26A370,0x1DE4C947,0x1FA2771E,0x1E601D29,0x1B2F0BAC,0x1AED619B,0x18ABDFC2,0x1969B5F5,
    0x1235F2C8,0x13F798FF,0x11B126A6,0x10734C91,0x153C5A14,0x14FE3023,0x16B88E7A,0x177AE44D,
    0x384D46E0,0x398F2CD7,0x3BC9928E,0x3A0BF8B9,0x3F44EE3C,0x3E86840B,0x3CC03A52,0x3D025065,
    0x365E1758,0x379C7D6F,0x35DAC336,0x3418A901,0x3157BF84,0x3095D5B3,0x32D36BEA,0x331101DD,
    0x246BE590,0x25A98FA7,0x27EF31FE,0x262D5BC9,0x23624D4C,0x22A0277B,0x20E69922,0x2124F315,
    0x2A78B428,0x2BBADE1F,0x29FC6046,0x283E0A71,0x2D711CF4,0x2CB376C3,0x2EF5C89A,0x2F37A2AD,
    0x709A8DC0,0x7158E7F7,0x731E59AE,0x72DC3399,0x7793251C,0x76514F2B,0x7417F172,0x75D59B45,
    0x7E89DC78,0x7F4BB64F,0x7D0D0816,0x7CCF6221,0x798074A4,0x78421E93,0x7A04A0CA,0x7BC6CAFD,
    0x6CBC2EB0,0x6D7E4487,0x6F38FADE,0x6EFA90E9,0x6BB5866C,0x6A77EC5B,0x68315202,0x69F33835,
    0x62AF7F08,0x636D153F,0x612BAB66,0x60E9C151,0x65A6D7D4,0x6464BDE3,0x662203BA,0x67E0698D,
    0x48D7CB20,0x4915A117,0x4B531F4E,0x4A917579,0x4FDE63FC,0x4E1C09CB,0x4C5AB792,0x4D98DDA5,
    0x46C49A98,0x4706F0AF,0x45404EF6,0x448224C1,0x41CD3244,0x400F5873,0x4249E62A,0x438B8C1D,
    0x54F16850,0x55330267,0x5775BC3E,0x56B7D609,0x53F8C08C,0x523AAABB,0x507C14E2,0x51BE7ED5,
    0x5AE239E8,0x5B2053DF,0x5966ED86,0x58A487B1,0x5DEB9134,0x5C29FB03,0x5E6F455A,0x5FAD2F6D,
    0xE1351B80,0xE0F771B7,0xE2B1CFEE,0xE373A5D9,0xE63CB35C,0xE7FED96B,0xE5B86732,0xE47A0D05,
    0xEF264A38,0xEEE4200F,0xECA29E56,0xED60F461,0xE82FE2E4,0xE9ED88D3,0xEBAB368A,0xEA695CBD,
    0xFD13B8F0,0xFCD1D2C7,0xFE976C9E,0xFF5506A9,0xFA1A102C,0xFBD87A1B,0xF99EC442,0xF85CAE75,
    0xF300E948,0xF2C2837F,0xF0843D26,0xF1465711,0xF4094194,0xF5CB2BA3,0xF78D95FA,0xF64FFFCD,
    0xD9785D60,0xD8BA3757,0xDAFC890E,0xDB3EE339,0xDE71F5BC,0xDFB39F8B,0xDDF521D2,0xDC374BE5,
    0xD76B0CD8,0xD6A966EF,0xD4EFD8B6,0xD52DB281,0xD062A404,0xD1A0CE33,0xD3E6706A,0xD2241A5D,
    0xC55EFE10,0xC49C9427,0xC6DA2A7E,0xC7184049,0xC25756CC,0xC3953CFB,0xC1D382A2,0xC011E895,
    0xCB4DAFA8,0xCA8FC59F,0xC8C97BC6,0xC90B11F1,0xCC440774,0xCD866D43,0xCFC0D31A,0xCE02B92D,
    0x91AF9640,0x906DFC77,0x922B422E,0x93E92819,0x96A63E9C,0x976454AB,0x9522EAF2,0x94E080C5,
    0x9FBCC7F8,0x9E7EADCF,0x9C381396,0x9DFA79A1,0x98B56F24,0x99770513,0x9B31BB4A,0x9AF3D17D,
    0x8D893530,0x8C4B5F07,0x8E0DE15E,0x8FCF8B69,0x8A809DEC,0x8B42F7DB,0x89044982,0x88C623B5,
    0x839A6488,0x82580EBF,0x801EB0E6,0x81DCDAD1,0x8493CC54,0x8551A663,0x8717183A,0x86D5720D,
    0xA9E2D0A0,0xA820BA97,0xAA6604CE,0xABA46EF9,0xAEEB787C,0xAF29124B,0xAD6FAC12,0xACADC625,
    0xA7F18118,0xA633EB2F,0xA4755576,0xA5B73F41,0xA0F829C4,0xA13A43F3,0xA37CFDAA,0xA2BE979D,
    0xB5C473D0,0xB40619E7,0xB640A7BE,0xB782CD89,0xB2CDDB0C,0xB30FB13B,0xB1490F62,0xB08B6555,
    0xBBD72268,0xBA15485F,0xB853F606,0xB9919C31,0xBCDE8AB4,0xBD1CE083,0xBF5A5EDA,0xBE9834ED,
  },{
    0x00000000,0xB8BC6765,0xAA09C88B,0x12B5AFEE,0x8F629757,0x37DEF032,0x256B5FDC,0x9DD738B9,
    0xC5B428EF,0x7D084F8A,0x6FBDE064,0xD7018701,0x4AD6BFB8,0xF26AD8DD,0xE0DF7733,0x58631056,
    0x5019579F,0xE8A530FA,0xFA109F14,0x42ACF871,0xDF7BC0C8,0x67C7A7AD,0x75720843,0xCDCE6F26,
    0x95AD7F70,0x2D111815,0x3FA4B7FB,0x8718D09E,0x1ACFE827,0xA2738F42,0xB0C620AC,0x087A47C9,
    0xA032AF3E,0x188EC85B,0x0A3B67B5,0xB28700D0,0x2F503869,0x97EC5F0C,0x8559F0E2,0x3DE59787,
    0x658687D1,0xDD3AE0B4,0xCF8F4F5A,0x7733283F,0xEAE41086,0x525877E3,0x40EDD80D,0xF851BF68,
    0xF02BF8A1,0x48979FC4,0x5A22302A,0xE29E574F,0x7F496FF6,0xC7F50893,0xD540A77D,0x6DFCC018,
    0x359FD04E,0x8D23B72B,0x9F9618C5,0x272A7FA0,0xBAFD4719,0x0241207C,0x10F48F92,0xA848E8F7,
    0x9B14583D,0x23A83F58,0x311D90B6,0x89A1F7D3,0x1476CF6A,0xACCAA80F,0xBE7F07E1,0x06C36084,
    0x5EA070D2,0xE61C17B7,0xF4A9B859,0x4C15DF3C,0xD1C2E785,0x697E80E0,0x7BCB2F0E,0xC377486B,
    0xCB0D0FA2,0x73B168C7,0x6104C729,0xD9B8A04C,0x446F98F5,0xFCD3FF90,0xEE66507E,0x56DA371B,
    0x0EB9274D,0xB6054028,0xA4B0EFC6,0x1C0C88A3,0x81DBB01A,0x3967D77F,0x2BD27891,0x936E1FF4,
    0x3B26F703,0x839A9066,0x912F3F88,0x299358ED,0xB4446054,0x0CF80731,0x1E4DA8DF,0xA6F1CFBA,
    0xFE92DFEC,0x462EB889,0x549B1767,0xEC277002,0x71F048BB,0xC94C2FDE,0xDBF98030,0x6345E755,
    0x6B3FA09C,0xD383C7F9,0xC1366817,0x798A0F72,0xE45D37CB,0x5CE150AE,0x4E54FF40,0xF6E89825,
    0xAE8B8873,0x1637EF16,0x048240F8,0xBC3E279D,0x21E91F24,0x99557841,0x8BE0D7AF,0x335CB0CA,
    0xED59B63B,0x55E5D15E,0x47507EB0,0xFFEC19D5,0x623B216C,0xDA874609,0xC832E9E7,0x708E8E82,
    0x28ED9ED4,0x9051F9B1,0x82E4565F,0x3A58313A,0xA78F0983,0x1F336EE6,0x0D86C108,0xB53AA66D,
    0xBD40E1A4,0x05FC86C1,0x1749292F,0xAFF54E4A,0x322276F3,0x8A9E1196,0x982BBE78,0x2097D91D,
    0x78F4C94B,0xC048AE2E,0xD2FD01C0,0x6A4166A5,0xF7965E1C,0x4F2A3979,0x5D9F9697,0xE523F1F2,
    0x4D6B1905,0xF5D77E60,0xE762D18E,0x5FDEB6EB,0xC2098E52,0x7AB5E937,0x680046D9,0xD0BC21BC,
    0x88DF31EA,0x3063568F,0x22D6F961,0x9A6A9E04,0x07BDA6BD,0xBF01C1D8,0xADB46E36,0x15080953,
    0x1D724E9A,0xA5CE29FF,0xB77B8611,0x0FC7E174,0x9210D9CD,0x2AACBEA8,0x38191146,0x80A57623,
    0xD8C66675,0x607A0110,0x72CFAEFE,0xCA73C99B,0x57A4F122,0xEF189647,0xFDAD39A9,0x45115ECC,
    0x764DEE06,0xCEF18963,0xDC44268D,0x64F841E8,0xF92F7951,0x41931E34,0x5326B1DA,0xEB9AD6BF,
    0xB3F9C6E9,0x0B45A18C,0x19F00E62,0xA14C6907,0x3C9B51BE,0x842736DB,0x96929935,0x2E2EFE50,
    0x2654B999,0x9EE8DEFC,0x8C5D7112,0x34E11677,0xA9362ECE,0x118A49AB,0x033FE645,0xBB838120,
    0xE3E09176,0x5B5CF613,0x49E959FD,0xF1553E98,0x6C820621,0xD43E6144,0xC68BCEAA,0x7E37A9CF,
    0xD67F4138,0x6EC3265D,0x7C7689B3,0xC4CAEED6,0x591DD66F,0xE1A1B10A,0xF3141EE4,0x4BA87981,
    0x13CB69D7,0xAB770EB2,0xB9C2A15C,0x017EC639,0x9CA9FE80,0x241599E5,0x36A0360B,0x8E1C516E,
    0x866616A7,0x3EDA71C2,0x2C6FDE2C,0x94D3B949,0x090481F0,0xB1B8E695,0xA30D497B,0x1BB12E1E,
    0x43D23E48,0xFB6E592D,0xE9DBF6C3,0x516791A6,0xCCB0A91F,0x740CCE7A,0x66B96194,0xDE0506F1,
  }
};

/* Calculates the CRC-32 of the provided data. The initial crc value is normally set to 0,
 * however it can be set to a previously calculated crc to extend it over new data. */
uint32_t crc32(const void* data, size_t length, uint32_t crc) {
  const uint32_t* current = (const uint32_t*) data;
  crc = ~crc;

  // process four bytes at once (Slicing-by-4)
  while (length >= 4) {
#if __BYTE_ORDER == __BIG_ENDIAN
    uint32_t one = *current++ ^ swap32(crc);
    crc = Crc32Lookup[0][ one      & 0xFF] ^
          Crc32Lookup[1][(one>> 8) & 0xFF] ^
          Crc32Lookup[2][(one>>16) & 0xFF] ^
          Crc32Lookup[3][(one>>24) & 0xFF];
#else
    uint32_t one = *current++ ^ crc;
    crc = Crc32Lookup[0][(one>>24) & 0xFF] ^
          Crc32Lookup[1][(one>>16) & 0xFF] ^
          Crc32Lookup[2][(one>> 8) & 0xFF] ^
          Crc32Lookup[3][ one      & 0xFF];
#endif

    length -= 4;
  }

  const uint8_t* currentChar = (const uint8_t*) current;
  // remaining 1 to 3 bytes (standard algorithm)
  while (length-- != 0)
    crc = (crc >> 8) ^ Crc32Lookup[0][(crc & 0xFF) ^ *currentChar++];

  return ~crc;
}

```

`app/src/main/jni/core/errors.h`:

```h
#ifndef __PCAPDROID_ERRORS_H__
#define __PCAPDROID_ERRORS_H__

// This file contains a set of error strings which may be returned from the native code.
// These should be translated in CaptureService.reportError

#define PD_ERR_UNSUPPORTED_PCAP_FILE    "Unsupported PCAP/Pcapng file"
#define PD_ERR_INVALID_PCAP_FILE        "Invalid PCAP/Pcapng file"
#define PD_ERR_INTERFACE_OPEN_ERROR     "Could not open the capture interface"
#define PD_ERR_UNSUPPORTED_DATALINK     "Unsupported datalink"
#define PD_ERR_PCAP_DOES_NOT_EXIST      "The specified PCAP/Pcapng file does not exist"
#define PD_ERR_PCAPD_START              "pcapd daemon start failure"
#define PD_ERR_PCAPD_NOT_SPAWNED        "pcapd daemon did not spawn"
#define PD_ERR_PCAP_READ                "PCAP/Pcapng read error"

#endif
```

`app/src/main/jni/core/ip_lru.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

// A simple LRU implementation based on uthash
// Inspired by https://jehiah.cz/a/uthash

#include <stdlib.h>
#include "common/utils.h"
#include "ip_lru.h"
#include "third_party/uthash.h"

struct cache_entry {
    zdtun_ip_t key;
    char *host;
    UT_hash_handle hh;
};

struct ip_lru {
    int max_size;
    struct cache_entry *cache;
};

/* ******************************************************* */

ip_lru_t* ip_lru_init(int max_size) {
    ip_lru_t *lru = (ip_lru_t*) pd_malloc(sizeof(ip_lru_t));

    if(!lru)
        return NULL;

    lru->max_size = max_size;
    lru->cache = NULL;

    return lru;
}

/* ******************************************************* */

void ip_lru_destroy(ip_lru_t *lru) {
    struct cache_entry *entry, *tmp;

    HASH_ITER(hh, lru->cache, entry, tmp) {
        HASH_DELETE(hh, lru->cache, entry);
        pd_free(entry->host);
        pd_free(entry);
    }

    pd_free(lru);
}

/* ******************************************************* */

static struct cache_entry* ip_lru_find_entry(ip_lru_t *lru, const zdtun_ip_t *ip) {
    struct cache_entry *entry;

    HASH_FIND(hh, lru->cache, ip, sizeof(zdtun_ip_t), entry);

    if(entry) {
        // Bring the entry to the front of the list
        HASH_DELETE(hh, lru->cache, entry);
        HASH_ADD(hh, lru->cache, key, sizeof(zdtun_ip_t), entry);

        return(entry);
    }

    return NULL;
}

/* ******************************************************* */

void ip_lru_add(ip_lru_t *lru, const zdtun_ip_t *ip, const char *hostname) {
    struct cache_entry *entry, *tmp;
    char *host = pd_strdup(hostname);

    if(!host)
        return;

    // guarantee key uniqueness
    entry = ip_lru_find_entry(lru, ip);

    if(entry != NULL) {
        // update existing
        pd_free(entry->host);
        entry->host = host;
        return;
    }

    entry = pd_malloc(sizeof(struct cache_entry));

    if(!entry) {
        pd_free(host);
        return;
    }

    entry->key = *ip;
    entry->host = host;

    HASH_ADD(hh, lru->cache, key, sizeof(zdtun_ip_t), entry);

    if(HASH_COUNT(lru->cache) > lru->max_size) {
        // uthash guarantees that iteration order is same as insertion order
        // see https://troydhanson.github.io/uthash/userguide.html#_sorting
        HASH_ITER(hh, lru->cache, entry, tmp) {
            // delete the oldest entry
            HASH_DELETE(hh, lru->cache, entry);
            pd_free(entry->host);
            pd_free(entry);
            break;
        }
    }
}

/* ******************************************************* */

char* ip_lru_find(ip_lru_t *lru, const zdtun_ip_t *ip) {
    struct cache_entry *entry = ip_lru_find_entry(lru, ip);

    return(entry ? pd_strdup(entry->host) : NULL);
}

/* ******************************************************* */

int ip_lru_size(ip_lru_t *lru) {
    return HASH_COUNT(lru->cache);
}
```

`app/src/main/jni/core/ip_lru.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

#ifndef __IP_LRU_H__
#define __IP_LRU_H__

#include "zdtun.h"

typedef struct ip_lru ip_lru_t;

ip_lru_t* ip_lru_init(int max_size);
void ip_lru_destroy(ip_lru_t *lru);
void ip_lru_add(ip_lru_t *lru, const zdtun_ip_t *ip, const char *hostname);
char* ip_lru_find(ip_lru_t *lru, const zdtun_ip_t *ip);
int ip_lru_size(ip_lru_t *lru);

#endif // __IP_LRU_H__

```

`app/src/main/jni/core/jni_impl.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022-24 - Emanuele Faranda
 */

#if ANDROID

#include <pthread.h>
#include "pcapdroid.h"
#include "common/utils.h"
#include "log_writer.h"
#include "port_map.h"
#include "pcap_reader.h"

// This files contains functions to make the capture core communicate
// with the Android system.
// Exported functions are defined in pcapdroid.h

static pcapdroid_t *global_pd = NULL;
static pthread_t jni_thread;

jni_classes_t cls;
jni_methods_t mids;
jni_fields_t fields;
jni_enum_t enums;

/* ******************************************************* */

static void log_callback(int lvl, const char *line) {
    pcapdroid_t *pd = global_pd;

    // quick path for debug logs
    if(lvl < PD_DEFAULT_LOGGER_LEVEL)
        return;

    pd_log_write(PD_DEFAULT_LOGGER, lvl, line);

    // ensure that we are invoking jni from the attached thread
    if(!pd || !(pthread_equal(jni_thread, pthread_self())))
        return;

    if(lvl >= ANDROID_LOG_FATAL) {
        // This is a fatal error, report it to the gui
        jobject info_string = (*pd->env)->NewStringUTF(pd->env, line);

        if((jniCheckException(pd->env) != 0) || (info_string == NULL))
            return;

        (*pd->env)->CallVoidMethod(pd->env, pd->capture_service, mids.reportError, info_string);
        jniCheckException(pd->env);

        (*pd->env)->DeleteLocalRef(pd->env, info_string);
    }
}

/* ******************************************************* */

static void sendStatsDump(pcapdroid_t *pd) {
    JNIEnv *env = pd->env;
    const capture_stats_t *capstats = &pd->capture_stats;
    const zdtun_statistics_t *stats = &pd->stats;
    jstring allocs_summary =
#ifdef PCAPDROID_TRACK_ALLOCS
    (*pd->env)->NewStringUTF(pd->env, get_allocs_summary());
#else
    NULL;
#endif

    int active_conns = (int)(stats->num_icmp_conn + stats->num_tcp_conn + stats->num_udp_conn);
    int tot_conns = (int)(stats->num_icmp_opened + stats->num_tcp_opened + stats->num_udp_opened);

    jobject stats_obj = (*env)->NewObject(env, cls.stats, mids.statsInit);

    if((stats_obj == NULL) || jniCheckException(env)) {
        log_e("NewObject(CaptureStats) failed");
        return;
    }

    (*env)->CallVoidMethod(env, stats_obj, mids.statsSetData,
                           allocs_summary,
                           capstats->sent_bytes, capstats->rcvd_bytes,
                           capstats->ipv6_sent_bytes, capstats->ipv6_rcvd_bytes,
                           (jlong)(pd->pcap_dump.dumper ? pcap_get_dump_size(pd->pcap_dump.dumper) : 0),
                           capstats->sent_pkts, capstats->rcvd_pkts,
                           min(pd->num_dropped_pkts, INT_MAX), pd->num_dropped_connections,
                           stats->num_open_sockets, stats->all_max_fd, active_conns, tot_conns,
                           pd->num_dns_requests);

    if(!jniCheckException(env)) {
        (*env)->CallVoidMethod(env, pd->capture_service, mids.sendStatsDump, stats_obj);
        jniCheckException(env);
    }

    (*env)->DeleteLocalRef(env, allocs_summary);
    (*env)->DeleteLocalRef(env, stats_obj);
}

/* ******************************************************* */

static void sendPcapDump(struct pcapdroid *pd, const int8_t *buf, int dump_size) {
    JNIEnv *env = pd->env;

    //log_d("Exporting a %d B PCAP buffer", pd->pcap_dump.buffer_idx);

    jbyteArray barray = (*env)->NewByteArray(env, dump_size);
    if(jniCheckException(env))
        return;

    (*env)->SetByteArrayRegion(env, barray, 0, dump_size, buf);
    (*env)->CallVoidMethod(env, pd->capture_service, mids.dumpPcapData, barray);
    jniCheckException(env);

    (*env)->DeleteLocalRef(env, barray);
}

/* ******************************************************* */

static void stopPcapDump(pcapdroid_t *pd) {
    JNIEnv *env = pd->env;

    (*env)->CallVoidMethod(env, pd->capture_service, mids.stopPcapDump);
    jniCheckException(env);
}

/* ******************************************************* */

static void notifyServiceStatus(pcapdroid_t *pd, const char *status) {
    JNIEnv *env = pd->env;
    jstring status_str;

    status_str = (*env)->NewStringUTF(env, status);

    (*env)->CallVoidMethod(env, pd->capture_service, mids.sendServiceStatus, status_str);
    jniCheckException(env);

    (*env)->DeleteLocalRef(env, status_str);
}

/* ******************************************************* */

static jobject getConnUpdate(pcapdroid_t *pd, const conn_and_tuple_t *conn) {
    JNIEnv *env = pd->env;
    pd_conn_t *data = conn->data;

    jobject update = (*env)->NewObject(env, cls.conn_update, mids.connUpdateInit, data->incr_id);

    if((update == NULL) || jniCheckException(env)) {
        log_e("NewObject(ConnectionDescriptor) failed");
        return NULL;
    }

    if(data->update_type & CONN_UPDATE_STATS) {
        bool blocked = data->to_block && pd->vpn_capture; // currently can only block connections in non-root mode

        (*env)->CallVoidMethod(env, update, mids.connUpdateSetStats, data->last_seen,
                               data->payload_length, data->sent_bytes, data->rcvd_bytes, data->sent_pkts, data->rcvd_pkts, data->blocked_pkts,
                               (data->tcp_flags[0] << 8) | data->tcp_flags[1],
                               (data->error << 16) /* 8 bits are enough for socket errno */ |
                                    (data->port_mapping_applied << 13) |
                                    (data->decryption_ignored << 12) |
                                    (data->netd_block_missed << 11) |
                                    (blocked << 10) |
                                    (data->blacklisted_domain << 9) |
                                    (data->blacklisted_ip << 8) |
                                    (data->status & 0xFF) /* 8 bits */);
    }
    if(data->update_type & CONN_UPDATE_INFO) {
        jobject info = (*env)->NewStringUTF(env, data->info ? data->info : "");
        jobject url = (*env)->NewStringUTF(env, data->url ? data->url : "");
        jobject l7proto = (*env)->NewStringUTF(env, pd_get_proto_name(pd, data->l7proto, data->alpn,
                                                                      conn->tuple.ipproto));
        int flags = data->encrypted_l7;

        (*env)->CallVoidMethod(env, update, mids.connUpdateSetInfo, info, url, l7proto, flags);

        (*env)->DeleteLocalRef(env, info);
        (*env)->DeleteLocalRef(env, url);
        (*env)->DeleteLocalRef(env, l7proto);
    }
    if(data->update_type & CONN_UPDATE_PAYLOAD) {
        (*env)->CallVoidMethod(env, update, mids.connUpdateSetPayload, data->payload_chunks,
                               data->payload_truncated |
                               (data->has_decrypted_data << 1));
        (*pd->env)->DeleteLocalRef(pd->env, data->payload_chunks);
        data->payload_chunks = NULL;
    }

    // reset the update flag
    data->update_type = 0;

    if(jniCheckException(env)) {
        log_e("getConnUpdate() failed");
        (*env)->DeleteLocalRef(env, update);
        return NULL;
    }

    return update;
}

/* ******************************************************* */

static int dumpNewConnection(pcapdroid_t *pd, const conn_and_tuple_t *conn, jobject arr, int idx) {
    char srcip[INET6_ADDRSTRLEN], dstip[INET6_ADDRSTRLEN];
    JNIEnv *env = pd->env;
    const zdtun_5tuple_t *conn_info = &conn->tuple;
    const pd_conn_t *data = conn->data;
    int rv = 0;
    int family = (conn->tuple.ipver == 4) ? AF_INET : AF_INET6;

    if((inet_ntop(family, &conn_info->src_ip, srcip, sizeof(srcip)) == NULL) ||
       (inet_ntop(family, &conn_info->dst_ip, dstip, sizeof(dstip)) == NULL)) {
        log_w("inet_ntop failed: ipver=%d, dstport=%d", conn->tuple.ipver, ntohs(conn_info->dst_port));
        return 0;
    }

#if 0
    log_i( "DUMP: [proto=%d]: %s:%u -> %s:%u [%d]",
                        conn_info->ipproto,
                        srcip, ntohs(conn_info->src_port),
                        dstip, ntohs(conn_info->dst_port),
                        data->uid);
#endif

    jobject src_string = (*env)->NewStringUTF(env, srcip);
    jobject dst_string = (*env)->NewStringUTF(env, dstip);
    jobject country_code = (*env)->NewStringUTF(env, data->country_code);
    u_int ifidx = (pd->vpn_capture ? 0 : data->pcap.ifidx);
    u_int local_port = (pd->vpn_capture ? data->vpn.local_port : conn_info->src_port);
    bool mitm_decrypt = (pd->tls_decryption.enabled && data->proxied);
    jobject conn_descriptor = (*env)->NewObject(env, cls.conn, mids.connInit, data->incr_id,
                                                conn_info->ipver, conn_info->ipproto,
                                                src_string, dst_string, country_code,
                                                ntohs(conn_info->src_port), ntohs(conn_info->dst_port),
                                                ntohs(local_port),
                                                data->uid, ifidx, mitm_decrypt, data->first_seen);

    if((conn_descriptor != NULL) && !jniCheckException(env)) {
        // This is the first update, send all the data
        conn->data->update_type |= CONN_UPDATE_STATS | CONN_UPDATE_INFO;
        jobject update = getConnUpdate(pd, conn);

        if(update != NULL) {
            (*env)->CallVoidMethod(env, conn_descriptor, mids.connProcessUpdate, update);
            (*env)->DeleteLocalRef(env, update);
        } else
            rv = -1;

        /* Add the connection to the array */
        (*env)->SetObjectArrayElement(env, arr, idx, conn_descriptor);

        if(jniCheckException(env))
            rv = -1;

        (*env)->DeleteLocalRef(env, conn_descriptor);
    } else {
        log_e("NewObject(ConnectionDescriptor) failed");
        rv = -1;
    }

    (*env)->DeleteLocalRef(env, src_string);
    (*env)->DeleteLocalRef(env, dst_string);
    (*env)->DeleteLocalRef(env, country_code);

    return rv;
}

/* ******************************************************* */

static int dumpConnectionUpdate(pcapdroid_t *pd, const conn_and_tuple_t *conn, jobject arr, int idx) {
    JNIEnv *env = pd->env;
    jobject update = getConnUpdate(pd, conn);

    if(update != NULL) {
        (*env)->SetObjectArrayElement(env, arr, idx, update);
        (*env)->DeleteLocalRef(env, update);
        return 0;
    }

    return -1;
}

/* ******************************************************* */

/* Perform a full dump of the active connections */
static void sendConnectionsDump(pcapdroid_t *pd) {
    JNIEnv *env = pd->env;
    //jniDumpReferences(env);

    jobject new_conns = (*env)->NewObjectArray(env, pd->new_conns.cur_items, cls.conn, NULL);
    jobject conns_updates = (*env)->NewObjectArray(env, pd->conns_updates.cur_items, cls.conn_update, NULL);

    if((new_conns == NULL) || (conns_updates == NULL) || jniCheckException(env)) {
        log_e("NewObjectArray() failed");
        goto cleanup;
    }

    // NOTE: updateConnections must be called after startConnectionsUpdate
    (*env)->CallVoidMethod(env, pd->capture_service, mids.startConnectionsUpdate);

    // New connections
    for(int i=0; i < pd->new_conns.cur_items; i++) {
        conn_and_tuple_t *conn = &pd->new_conns.items[i];
        conn->data->pending_notification = false;

        if(dumpNewConnection(pd, conn, new_conns, i) < 0)
            goto send_and_cleanup;
    }

    //clock_t start = clock();

    // Updated connections
    for(int i=0; i < pd->conns_updates.cur_items; i++) {
        conn_and_tuple_t *conn = &pd->conns_updates.items[i];
        conn->data->pending_notification = false;

        if(dumpConnectionUpdate(pd, conn, conns_updates, i) < 0)
            goto send_and_cleanup;
    }

    //double cpu_time_used = ((double) (clock() - start)) / CLOCKS_PER_SEC;
    //log_d("avg cpu_time_used per update: %f sec", cpu_time_used / pd->conns_updates.cur_items);

send_and_cleanup:
    /* Send the dump */
    (*env)->CallVoidMethod(env, pd->capture_service, mids.updateConnections, new_conns, conns_updates);
    jniCheckException(env);

cleanup:
    (*env)->DeleteLocalRef(env, new_conns);
    (*env)->DeleteLocalRef(env, conns_updates);
    //jniDumpReferences(env);
}

/* ******************************************************* */

// Load information about the blacklists to use (into pd->malware_detection.bls_info)
static int loadBlacklistsInfo(pcapdroid_t *pd) {
    int rv = 0;
    JNIEnv *env = pd->env;
    jobjectArray *arr = (*env)->CallObjectMethod(env, pd->capture_service, mids.getBlacklistsInfo);
    pd->malware_detection.bls_info = NULL;
    pd->malware_detection.num_bls = 0;

    if((jniCheckException(pd->env) != 0) || (arr == NULL))
        return -1;

    pd->malware_detection.num_bls = (*env)->GetArrayLength(env, arr);
    if(pd->malware_detection.num_bls == 0)
        goto cleanup;

    pd->malware_detection.bls_info = (bl_info_t*) pd_calloc(pd->malware_detection.num_bls, sizeof(bl_info_t));
    if(pd->malware_detection.bls_info == NULL) {
        pd->malware_detection.num_bls = 0;
        rv = -1;
        goto cleanup;
    }

    for(int i = 0; i < pd->malware_detection.num_bls; i++) {
        jobject *bl_descr = (*env)->GetObjectArrayElement(env, arr, i);
        if(bl_descr != NULL) {
            bl_info_t *blinfo = &pd->malware_detection.bls_info[i];

            jstring fname_obj = (*env)->GetObjectField(env, bl_descr, fields.bldescr_fname);
            const char *fname = (*env)->GetStringUTFChars(env, fname_obj, 0);
            blinfo->fname = pd_strdup(fname);
            (*env)->ReleaseStringUTFChars(env, fname_obj, fname);
            (*pd->env)->DeleteLocalRef(pd->env, fname_obj);

            jobject bl_type = (*env)->GetObjectField(env, bl_descr, fields.bldescr_type);
            blinfo->type = (*env)->IsSameObject(env, bl_type, enums.bltype_ip) ? IP_BLACKLIST : DOMAIN_BLACKLIST;
            (*pd->env)->DeleteLocalRef(pd->env, bl_type);

            //log_d("[+] Blacklist: %s (%s)", blinfo->fname, (blinfo->type == IP_BLACKLIST) ? "IP" : "domain");
            (*pd->env)->DeleteLocalRef(pd->env, bl_descr);
        }
    }

cleanup:
    (*pd->env)->DeleteLocalRef(pd->env, arr);
    return rv;
}

/* ******************************************************* */

static void notifyBlacklistsLoaded(pcapdroid_t *pd, bl_status_arr_t *status_arr) {
    JNIEnv *env = pd->env;
    jobject status_obj = (*env)->NewObjectArray(env, status_arr->cur_items, cls.blacklist_status, NULL);

    if((status_obj == NULL) || jniCheckException(env)) {
        log_e("NewObjectArray() failed");
        return;
    }

    for(int i=0; i<status_arr->cur_items; i++) {
        bl_status_t *st = &status_arr->items[i];
        jstring fname = (*env)->NewStringUTF(env, st->fname);
        if((fname == NULL) || jniCheckException(env))
            break;

        jobject stats = (*env)->NewObject(env, cls.blacklist_status, mids.blacklistStatusInit,
                                              fname, st->num_rules);
        (*env)->DeleteLocalRef(env, fname);

        if((stats == NULL) || jniCheckException(env))
            break;

        (*env)->SetObjectArrayElement(env, status_obj, i, stats);
        (*env)->DeleteLocalRef(env, stats);

        if(jniCheckException(env)) {
            break;
        }
    }

    (*env)->CallVoidMethod(env, pd->capture_service, mids.notifyBlacklistsLoaded, status_obj);
    (*env)->DeleteLocalRef(env, status_obj);
}

/* ******************************************************* */

static bool dumpPayloadChunk(struct pcapdroid *pd, pd_conn_t *conn, bool is_tx, uint64_t ms, uint32_t stream_id, const char *dump_data, int dump_size) {
    JNIEnv *env = pd->env;
    bool rv = false;

    if(conn->payload_chunks == NULL) {
        // Directly allocating an ArrayList<bytes> rather than creating it afterwards saves us from a data copy.
        // However, this creates a local reference, which is retained until sendConnectionsDump is called.
        // NOTE: Android only allows up to 512 local references.
        conn->payload_chunks = (*env)->NewObject(env, cls.arraylist, mids.arraylistNew);
        if((conn->payload_chunks == NULL) || jniCheckException(env))
            return false;
    }

    jbyteArray barray = (*env)->NewByteArray(env, dump_size);
    if(jniCheckException(env))
        return false;

    jobject chunk_type = (conn->l7proto == NDPI_PROTOCOL_HTTP) ? enums.chunktype_http : enums.chunktype_raw;

    jobject chunk = (*env)->NewObject(env, cls.payload_chunk, mids.payloadChunkInit, barray, chunk_type, is_tx, ms, stream_id);
    if(chunk && !jniCheckException(env)) {
        if (dump_data) // can be NULL for RST reporting in HTTP/2
            (*env)->SetByteArrayRegion(env, barray, 0, dump_size, (jbyte*) dump_data);
        rv = (*env)->CallBooleanMethod(env, conn->payload_chunks, mids.arraylistAdd, chunk);
    }

    //log_d("Dump chunk [size=%d]: %d", rv, dump_size);

    (*env)->DeleteLocalRef(env, barray);
    (*env)->DeleteLocalRef(env, chunk);
    return rv;
}

/* ******************************************************* */

static void clearPayloadChunks(struct pcapdroid *pd, const pkt_context_t *pctx) {
    JNIEnv *env = pd->env;

    if (pctx->data->payload_chunks) {
        (*env)->DeleteLocalRef(env, pctx->data->payload_chunks);
        pctx->data->payload_chunks = NULL;
    }
}

/* ******************************************************* */

// TODO rename
static void getLibprogPath(pcapdroid_t *pd, const char *prog_name, char *buf, int bufsize) {
    JNIEnv *env = pd->env;
    jobject prog_str = (*env)->NewStringUTF(env, prog_name);

    buf[0] = '\0';

    if((prog_str == NULL) || jniCheckException(env)) {
        log_e("could not allocate get_libprog_path string");
        return;
    }

    jstring obj = (*env)->CallObjectMethod(env, pd->capture_service, mids.getLibprogPath, prog_str);
    (*env)->DeleteLocalRef(env, prog_str);

    if(!jniCheckException(env)) {
        const char *value = (*env)->GetStringUTFChars(env, obj, 0);

        strncpy(buf, value, bufsize);
        buf[bufsize - 1] = '\0';

        (*env)->ReleaseStringUTFChars(env, obj, value);
    }

    (*env)->DeleteLocalRef(env, obj);
}

/* ******************************************************* */

static void getSocks5ProxyAuth(pcapdroid_t *pd) {
    char buf[64];
    buf[0] = '\0';

    getStringPref(pd, "getSocks5ProxyAuth", buf, sizeof(buf));
    char *sep = strchr(buf, ':');

    if(!sep)
        return;

    *sep = '\0';
    strncpy(pd->socks5.proxy_user, buf, sizeof(pd->socks5.proxy_user));
    strncpy(pd->socks5.proxy_pass, sep + 1, sizeof(pd->socks5.proxy_pass));

    //log_d("SOCKS5: user=%s pass=%s", pd->socks5.proxy_user, pd->socks5.proxy_pass);
}

static void init_jni(JNIEnv *env) {
    // NOTE: these are bound to this specific env

    /* Classes */
    cls.vpn_service = jniFindClass(env, "com/emanuelef/remote_capture/CaptureService");
    cls.conn = jniFindClass(env, "com/emanuelef/remote_capture/model/ConnectionDescriptor");
    cls.conn_update = jniFindClass(env, "com/emanuelef/remote_capture/model/ConnectionUpdate");
    cls.stats = jniFindClass(env, "com/emanuelef/remote_capture/model/CaptureStats");
    cls.blacklist_status = jniFindClass(env, "com/emanuelef/remote_capture/Blacklists$NativeBlacklistStatus");
    cls.blacklist_descriptor = jniFindClass(env, "com/emanuelef/remote_capture/model/BlacklistDescriptor");
    cls.matchlist_descriptor = jniFindClass(env, "com/emanuelef/remote_capture/model/MatchList$ListDescriptor");
    cls.list = jniFindClass(env, "java/util/List");
    cls.arraylist = jniFindClass(env, "java/util/ArrayList");
    cls.payload_chunk = jniFindClass(env, "com/emanuelef/remote_capture/model/PayloadChunk");

    /* Methods */
    mids.reportError = jniGetMethodID(env, cls.vpn_service, "reportError", "(Ljava/lang/String;)V");
    mids.getApplicationByUid = jniGetMethodID(env, cls.vpn_service, "getApplicationByUid", "(I)Ljava/lang/String;"),
    mids.getPackageNameByUid = jniGetMethodID(env, cls.vpn_service, "getPackageNameByUid", "(I)Ljava/lang/String;"),
    mids.loadUidMapping = jniGetMethodID(env, cls.vpn_service, "loadUidMapping", "(ILjava/lang/String;Ljava/lang/String;)V"),
    mids.getCountryCode = jniGetMethodID(env, cls.vpn_service, "getCountryCode", "(Ljava/lang/String;)Ljava/lang/String;"),
    mids.protect = jniGetMethodID(env, cls.vpn_service, "protect", "(I)Z");
    mids.dumpPcapData = jniGetMethodID(env, cls.vpn_service, "dumpPcapData", "([B)V");
    mids.stopPcapDump = jniGetMethodID(env, cls.vpn_service, "stopPcapDump", "()V");
    mids.startConnectionsUpdate = jniGetMethodID(env, cls.vpn_service, "startConnectionsUpdate", "()V");
    mids.updateConnections = jniGetMethodID(env, cls.vpn_service, "updateConnections", "([Lcom/emanuelef/remote_capture/model/ConnectionDescriptor;[Lcom/emanuelef/remote_capture/model/ConnectionUpdate;)V");
    mids.sendStatsDump = jniGetMethodID(env, cls.vpn_service, "sendStatsDump", "(Lcom/emanuelef/remote_capture/model/CaptureStats;)V");
    mids.sendServiceStatus = jniGetMethodID(env, cls.vpn_service, "sendServiceStatus", "(Ljava/lang/String;)V");
    mids.getLibprogPath = jniGetMethodID(env, cls.vpn_service, "getLibprogPath", "(Ljava/lang/String;)Ljava/lang/String;");
    mids.notifyBlacklistsLoaded = jniGetMethodID(env, cls.vpn_service, "notifyBlacklistsLoaded", "([Lcom/emanuelef/remote_capture/Blacklists$NativeBlacklistStatus;)V");
    mids.getBlacklistsInfo = jniGetMethodID(env, cls.vpn_service, "getBlacklistsInfo", "()[Lcom/emanuelef/remote_capture/model/BlacklistDescriptor;");
    mids.connInit = jniGetMethodID(env, cls.conn, "<init>", "(IIILjava/lang/String;Ljava/lang/String;Ljava/lang/String;IIIIIZJ)V");
    mids.connProcessUpdate = jniGetMethodID(env, cls.conn, "processUpdate", "(Lcom/emanuelef/remote_capture/model/ConnectionUpdate;)V");
    mids.connUpdateInit = jniGetMethodID(env, cls.conn_update, "<init>", "(I)V");
    mids.connUpdateSetStats = jniGetMethodID(env, cls.conn_update, "setStats", "(JJJJIIIII)V");
    mids.connUpdateSetInfo = jniGetMethodID(env, cls.conn_update, "setInfo", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V");
    mids.connUpdateSetPayload = jniGetMethodID(env, cls.conn_update, "setPayload", "(Ljava/util/ArrayList;I)V");
    mids.statsInit = jniGetMethodID(env, cls.stats, "<init>", "()V");
    mids.statsSetData = jniGetMethodID(env, cls.stats, "setData", "(Ljava/lang/String;JJJJJIIIIIIIII)V");
    mids.blacklistStatusInit = jniGetMethodID(env, cls.blacklist_status, "<init>", "(Ljava/lang/String;I)V");
    mids.listSize = jniGetMethodID(env, cls.list, "size", "()I");
    mids.listGet = jniGetMethodID(env, cls.list, "get", "(I)Ljava/lang/Object;");
    mids.arraylistNew = jniGetMethodID(env, cls.arraylist, "<init>", "()V");
    mids.arraylistAdd = jniGetMethodID(env, cls.arraylist, "add", "(Ljava/lang/Object;)Z");
    mids.payloadChunkInit = jniGetMethodID(env, cls.payload_chunk, "<init>", "([BLcom/emanuelef/remote_capture/model/PayloadChunk$ChunkType;ZJI)V");

    /* Fields */
    fields.bldescr_fname = jniFieldID(env, cls.blacklist_descriptor, "fname", "Ljava/lang/String;");
    fields.bldescr_type = jniFieldID(env, cls.blacklist_descriptor, "type", "Lcom/emanuelef/remote_capture/model/BlacklistDescriptor$Type;");
    fields.ld_apps = jniFieldID(env, cls.matchlist_descriptor, "apps", "Ljava/util/List;");
    fields.ld_hosts = jniFieldID(env, cls.matchlist_descriptor, "hosts", "Ljava/util/List;");
    fields.ld_ips = jniFieldID(env, cls.matchlist_descriptor, "ips", "Ljava/util/List;");
    fields.ld_countries = jniFieldID(env, cls.matchlist_descriptor, "countries", "Ljava/util/List;");

    /* Enums */
    enums.bltype_ip = jniEnumVal(env, "com/emanuelef/remote_capture/model/BlacklistDescriptor$Type", "IP_BLACKLIST");
    enums.chunktype_raw = jniEnumVal(env, "com/emanuelef/remote_capture/model/PayloadChunk$ChunkType", "RAW");
    enums.chunktype_http = jniEnumVal(env, "com/emanuelef/remote_capture/model/PayloadChunk$ChunkType", "HTTP");
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_runPacketLoop(JNIEnv *env, jclass type, jint tunfd,
                                                              jobject vpn, jint sdk) {

#ifdef PCAPDROID_TRACK_ALLOCS
    set_ndpi_malloc(pd_ndpi_malloc);
    set_ndpi_free(pd_ndpi_free);
#endif

    init_jni(env);

    pcapdroid_t pd = {
            .sdk_ver = sdk,
            .env = env,
            .capture_service = vpn,
            .cb = {
                    .get_libprog_path = getLibprogPath,
                    .load_blacklists_info = loadBlacklistsInfo,
                    .send_stats_dump = sendStatsDump,
                    .send_connections_dump = sendConnectionsDump,
                    .send_pcap_dump = sendPcapDump,
                    .stop_pcap_dump = stopPcapDump,
                    .notify_service_status = notifyServiceStatus,
                    .notify_blacklists_loaded = notifyBlacklistsLoaded,
                    .dump_payload_chunk = dumpPayloadChunk,
                    .clear_payload_chunks = clearPayloadChunks,
            },
            .mitm_addon_uid = getIntPref(env, vpn, "getMitmAddonUid"),
            .vpn_capture = (bool) getIntPref(env, vpn, "isVpnCapture"),
            .pcap_file_capture = (bool) getIntPref(env, vpn, "isPcapFileCapture"),
            .payload_mode = (payload_mode_t) getIntPref(env, vpn, "getPayloadMode"),
            .pcap_dump = {
                    .enabled = (bool) getIntPref(env, vpn, "pcapDumpEnabled"),
                    .dump_extensions = (bool)getIntPref(env, vpn, "dumpExtensionsEnabled"),
                    .pcapng_format = (bool)getIntPref(env, vpn, "isPcapngEnabled"),
                    .snaplen = getIntPref(env, vpn, "getSnaplen"),
                    .max_pkts_per_flow = getIntPref(env, vpn, "getMaxPktsPerFlow"),
                    .max_dump_size = getIntPref(env, vpn, "getMaxDumpSize"),
            },
            .socks5 = {
                    .enabled = (bool) getIntPref(env, vpn, "getSocks5Enabled"),
                    .proxy_ip = getIPPref(env, vpn, "getSocks5ProxyAddress", &pd.socks5.proxy_ipver),
                    .proxy_port = htons(getIntPref(env, vpn, "getSocks5ProxyPort")),
            },
            .malware_detection = {
                    .enabled = (bool) getIntPref(env, vpn, "malwareDetectionEnabled"),
            },
            .firewall = {
                    .enabled = (bool) getIntPref(env, vpn, "firewallEnabled"),
            },
            .tls_decryption = {
                    .enabled = (bool) getIntPref(env, vpn, "isTlsDecryptionEnabled"),
            }
    };

    if(pd.socks5.enabled)
        getSocks5ProxyAuth(&pd);

    if(pd.vpn_capture)
        pd.vpn.tunfd = tunfd;

    getStringPref(&pd, "getWorkingDir", pd.cachedir, sizeof(pd.cachedir));
    strcat(pd.cachedir, "/");
    pd.cachedir_len = strlen(pd.cachedir);

    getStringPref(&pd, "getPersistentDir", pd.filesdir, sizeof(pd.filesdir));
    strcat(pd.filesdir, "/");
    pd.filesdir_len = strlen(pd.filesdir);

    global_pd = &pd;
    jni_thread = pthread_self();
    logcallback = log_callback;
    signal(SIGPIPE, SIG_IGN);

    // Run the capture
    pd_run(&pd);

    global_pd = NULL;
    logcallback = NULL;

#if 0
    // free JNI local objects to ease references leak detection
    for(int i=0; i<sizeof(cls)/sizeof(jclass); i++) {
        jclass cur = ((jclass*)&cls)[i];
        (*env)->DeleteLocalRef(env, cur);
    }
    for(int i=0; i<sizeof(enums)/sizeof(jobject); i++) {
        jobject cur = ((jobject*)&enums)[i];
        (*env)->DeleteLocalRef(env, cur);
    }

    // at this point the local reference table should only contain 2 entries (VMDebug + Thread)
    jniDumpReferences(env);
#endif

#ifdef PCAPDROID_TRACK_ALLOCS
    log_i(get_allocs_summary());
#endif
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_stopPacketLoop(JNIEnv *env, jclass type) {
    /* NOTE: the select on the packets loop uses a timeout to wake up periodically */
    log_i("stopPacketLoop called");
    running = false;
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_initPlatformInfo(JNIEnv *env, jclass clazz,
                                                                   jstring appver, jstring device,
                                                                   jstring os) {
    const char *appver_s = (*env)->GetStringUTFChars(env, appver, 0);
    const char *device_s = (*env)->GetStringUTFChars(env, device, 0);
    const char *os_s = (*env)->GetStringUTFChars(env, os, 0);
    pd_appver = strdup(appver_s);
    pd_device = strdup(device_s);
    pd_os = strdup(os_s);
    (*env)->ReleaseStringUTFChars(env, appver, appver_s);
    (*env)->ReleaseStringUTFChars(env, device, device_s);
    (*env)->ReleaseStringUTFChars(env, os, os_s);
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_askStatsDump(JNIEnv *env, jclass clazz) {
    if(running)
        dump_capture_stats_now = true;
}

/* ******************************************************* */

JNIEXPORT jint JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_getFdSetSize(JNIEnv *env, jclass clazz) {
    return FD_SETSIZE;
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_setDnsServer(JNIEnv *env, jclass clazz,
                                                               jstring server) {
    struct in_addr addr = {0};
    const char *value = (*env)->GetStringUTFChars(env, server, 0);

    if(inet_aton(value, &addr) != 0)
        new_dns_server = addr.s_addr;

    (*env)->ReleaseStringUTFChars(env, server, value);
}

/* ******************************************************* */

JNIEXPORT jbyteArray JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_getPcapHeader(JNIEnv *env, jclass clazz) {
    pcapdroid_t *pd = global_pd;
    if(!pd || !pd->pcap_dump.dumper) {
        log_e("NULL pd/dumper instance");
        return false;
    }

    char *pcap_hdr = NULL;
    int hdr_size = pcap_get_preamble(pd->pcap_dump.dumper, &pcap_hdr);
    if((hdr_size < 0) || !pcap_hdr)
        return NULL;

    jbyteArray barray = (*env)->NewByteArray(env, hdr_size);
    if((barray == NULL) || jniCheckException(env)) {
        free(pcap_hdr);
        return NULL;
    }

    (*env)->SetByteArrayRegion(env, barray, 0, hdr_size, (jbyte*)pcap_hdr);
    pd_free(pcap_hdr);

    if(jniCheckException(env)) {
        (*env)->DeleteLocalRef(env, barray);
        return NULL;
    }

    return barray;
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_reloadBlacklists(JNIEnv *env, jclass clazz) {
    reload_blacklists_now = true;
}

/* ******************************************************* */

JNIEXPORT jint JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_getNumCheckedMalwareConnections(JNIEnv *env, jclass clazz) {
    return bl_num_checked_connections;
}

/* ******************************************************* */

JNIEXPORT jint JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_getNumCheckedFirewallConnections(JNIEnv *env, jclass clazz) {
    return fw_num_checked_connections;
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_setPrivateDnsBlocked(JNIEnv *env, jclass clazz, jboolean to_block) {
    block_private_dns = to_block;
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_addPortMapping(JNIEnv *env, jclass clazz, jint ipproto,
                                                                 jint orig_port, jint redirect_port, jstring redirect_ip) {
    zdtun_ip_t ip;

    const char *ip_s = (*env)->GetStringUTFChars(env, redirect_ip, 0);
    int ipver = zdtun_parse_ip(ip_s, &ip);
    (*env)->ReleaseStringUTFChars(env, redirect_ip, ip_s);

    if(ipver < 0) {
        log_e("addPortMapping invalid IP");
        return;
    }

    if(!pd_add_port_map(ipver, ipproto, orig_port, redirect_port, &ip)) {
        log_e("addPortMapping failed");
        return;
    }
}

/* ******************************************************* */

JNIEXPORT jboolean JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_reloadBlocklist(JNIEnv *env, jclass clazz,
        jobject ld) {
    pcapdroid_t *pd = global_pd;
    if(!pd) {
        log_e("NULL pd instance");
        return false;
    }

    if(!pd->vpn_capture) {
        log_e("firewall in root mode not implemented");
        return false;
    }

    if(pd->firewall.new_bl != NULL) {
        log_e("previous blocklist not loaded yet");
        return false;
    }

    blacklist_t *bl = blacklist_init();
    if(!bl) {
        log_e("blacklist_init failed");
        return false;
    }

    if(blacklist_load_list_descriptor(bl, env, ld) < 0) {
        log_f("Could not load firewall rules. Check the log for more details");
        blacklist_destroy(bl);
        return false;
    }

    blacklists_stats_t stats;
    blacklist_get_stats(bl, &stats);
    log_d("reloadBlocklist: %d apps, %d domains, %d IPs", stats.num_apps, stats.num_domains, stats.num_ips);

    pd->firewall.new_bl = bl;
    return true;
}

/* ******************************************************* */

JNIEXPORT jboolean JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_reloadFirewallWhitelist(JNIEnv *env, jclass clazz,
         jobject whitelist) {
    pcapdroid_t *pd = global_pd;
    if(!pd) {
        log_e("NULL pd instance");
        return false;
    }

    if(!pd->vpn_capture) {
        log_e("firewall in root mode not implemented");
        return false;
    }

    if(pd->firewall.new_wl != NULL) {
        log_e("previous firewall whitelist not loaded yet");
        return false;
    }

    if(whitelist == NULL) {
        pd->firewall.wl_enabled = false;
        log_d("firewall whitelist is disabled");
        return true;
    }

    blacklist_t *wl = blacklist_init();
    if(!wl) {
        log_e("blacklist_init failed");
        return false;
    }

    if(blacklist_load_list_descriptor(wl, env, whitelist) < 0) {
        log_f("Could not load firewall whitelist rules. Check the log for more details");
        blacklist_destroy(wl);
        return false;
    }

    blacklists_stats_t stats;
    blacklist_get_stats(wl, &stats);
    log_d("reloadFirewallWhitelist: %d apps, %d domains, %d IPs", stats.num_apps, stats.num_domains, stats.num_ips);

    pd->firewall.new_wl = wl;
    pd->firewall.wl_enabled = true;
    return true;
}

/* ******************************************************* */

JNIEXPORT jboolean JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_reloadMalwareWhitelist(JNIEnv *env, jclass clazz,
        jobject whitelist) {
    pcapdroid_t *pd = global_pd;
    if(!pd) {
        log_e("NULL pd instance");
        return false;
    }

    if(!pd->malware_detection.enabled) {
        log_e("malware detection not enabled");
        return false;
    }

    if(pd->malware_detection.new_wl != NULL) {
        log_e("previous malware whitelist not loaded yet");
        return false;
    }

    blacklist_t *wl = blacklist_init();
    if(!wl) {
        log_e("blacklist_init failed");
        return false;
    }

    if(blacklist_load_list_descriptor(wl, env, whitelist) < 0) {
        log_f("Could not load malware whitelist rules. Check the log for more details");
        blacklist_destroy(wl);
        return false;
    }

    blacklists_stats_t stats;
    blacklist_get_stats(wl, &stats);
    log_d("reloadMalwareWhitelist: %d apps, %d domains, %d IPs", stats.num_apps, stats.num_domains, stats.num_ips);

    pd->malware_detection.new_wl = wl;
    return true;
}

/* ******************************************************* */

JNIEXPORT jboolean JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_reloadDecryptionList(JNIEnv *env,
                                                                       jclass clazz, jobject listobj) {
    pcapdroid_t *pd = global_pd;
    if(!pd) {
        log_e("NULL pd instance");
        return false;
    }

    if(!pd->tls_decryption.enabled) {
        log_e("TLS decryption not enabled");
        return false;
    }

    if(pd->tls_decryption.new_list != NULL) {
        log_e("previous decryption list not loaded yet");
        return false;
    }

    blacklist_t *list = blacklist_init();
    if(!list) {
        log_e("blacklist_init failed");
        return false;
    }

    if(blacklist_load_list_descriptor(list, env, listobj) < 0) {
        log_f("Could not load decryption list. Check the log for more details");
        blacklist_destroy(list);
        return false;
    }

    blacklists_stats_t stats;
    blacklist_get_stats(list, &stats);
    log_d("reloadDecryptionList: %d apps, %d domains, %d IPs", stats.num_apps, stats.num_domains, stats.num_ips);

    pd->tls_decryption.new_list = list;
    return true;
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_nativeSetFirewallEnabled(JNIEnv *env, jclass clazz, jboolean enabled) {
    pcapdroid_t *pd = global_pd;
    if(!pd) {
        log_e("NULL pd instance");
        return;
    }

    pd->firewall.enabled = enabled;
}

/* ******************************************************* */

JNIEXPORT int JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_rootCmd(JNIEnv *env, jclass clazz, jstring prog,
                                                          jstring args) {
    const char *prog_s = (*env)->GetStringUTFChars(env, prog, 0);
    const char *args_s = (*env)->GetStringUTFChars(env, args, 0);
    int rv = run_shell_cmd(prog_s, args_s, true, true);

    (*env)->ReleaseStringUTFChars(env, prog, prog_s);
    (*env)->ReleaseStringUTFChars(env, args, args_s);

    return rv;
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_setPayloadMode(JNIEnv *env, jclass clazz, jint mode) {
    pcapdroid_t *pd = global_pd;
    if(!pd) {
        log_e("NULL pd instance");
        return;
    }

    pd->payload_mode = mode;
}

/* ******************************************************* */

JNIEXPORT jint JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_initLogger(JNIEnv *env, jclass clazz,
                                                             jstring path, jint level) {
    const char *path_s = (*env)->GetStringUTFChars(env, path, 0);
    int rv = pd_init_logger(path_s, level);
    (*env)->ReleaseStringUTFChars(env, path, path_s);
    return rv;
}

/* ******************************************************* */

JNIEXPORT jint JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_writeLog(JNIEnv *env, jclass clazz,
                                                      jint logger, jint lvl, jstring message) {
    const char *message_s = (*env)->GetStringUTFChars(env, message, 0);
    int rv = pd_log_write(logger, lvl, message_s);
    (*env)->ReleaseStringUTFChars(env, message, message_s);
    return rv;
}

/* ******************************************************* */

static bool arraylist_add_string(JNIEnv *env, jmethodID arrayListAdd, jobject arr, const char *s) {
    jobject s_obj = (*env)->NewStringUTF(env, s);
    if(!s_obj || jniCheckException(env))
        return false;

    bool rv = (*env)->CallBooleanMethod(env, arr, arrayListAdd, s_obj);
    (*env)->DeleteLocalRef(env, s_obj);
    return rv;
}

JNIEXPORT jobject JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_getL7Protocols(JNIEnv *env, jclass clazz) {
    jclass arrayListClass = jniFindClass(env, "java/util/ArrayList");
    jmethodID arrayListNew = jniGetMethodID(env, arrayListClass, "<init>", "()V");
    jmethodID arrayListAdd = jniGetMethodID(env, arrayListClass, "add", "(Ljava/lang/Object;)Z");

    struct ndpi_detection_module_struct *ndpi = ndpi_init_detection_module(NULL);
    if(!ndpi)
        return(NULL);

    NDPI_PROTOCOL_BITMASK protocols;
    NDPI_BITMASK_SET_ALL(protocols);
    ndpi_set_protocol_detection_bitmask2(ndpi, &protocols);

    jobject plist = (*env)->NewObject(env, arrayListClass, arrayListNew);
    if((plist == NULL) || jniCheckException(env))
        return NULL;

    bool success = true;
    int num_protos = (int) ndpi_get_ndpi_num_supported_protocols(ndpi);
    ndpi_proto_defaults_t* proto_defaults = ndpi_get_proto_defaults(ndpi);

    ndpi_protocol_bitmask_struct_t unique_protos;
    NDPI_BITMASK_RESET(unique_protos);

    // NOTE: this does not currently exist as a protocol (see pd_get_proto_name)
    if(!arraylist_add_string(env, arrayListAdd, plist, "HTTPS")) {
        success = false;
        goto out;
    }

    for(int i=0; i<num_protos; i++) {
        ndpi_protocol n_proto = {proto_defaults[i].protoId, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};
        uint16_t proto = pd_ndpi2proto(n_proto);
        //log_d("protos: %d -> %d -> %d", i, proto_defaults[i].protoId, proto);

        if(!NDPI_ISSET(&unique_protos, proto)) {
            NDPI_SET(&unique_protos, proto);
            const char *name = ndpi_get_proto_name(ndpi, proto);
            //log_d("proto: %d %s", proto, name);

            if(!arraylist_add_string(env, arrayListAdd, plist, name)) {
                success = false;
                goto out;
            }
        }
    }

out:
    if(!success) {
        (*env)->DeleteLocalRef(env, plist);
        plist = NULL;
    }
    ndpi_exit_detection_module(ndpi);

    return(plist);
}

/* ******************************************************* */

char* getStringPref(pcapdroid_t *pd, const char *key, char *buf, int bufsize) {
    JNIEnv *env = pd->env;

    jmethodID midMethod = jniGetMethodID(env, cls.vpn_service, key, "()Ljava/lang/String;");
    jstring obj = (*env)->CallObjectMethod(env, pd->capture_service, midMethod);
    char *rv = NULL;

    if(!jniCheckException(env)) {
        // Null string
        if(obj == NULL)
            return NULL;

        const char *value = (*env)->GetStringUTFChars(env, obj, 0);
        log_d("getStringPref(%s) = %s", key, value);

        strncpy(buf, value, bufsize);
        buf[bufsize - 1] = '\0';
        rv = buf;

        (*env)->ReleaseStringUTFChars(env, obj, value);
    }

    (*env)->DeleteLocalRef(env, obj);

    return(rv);
}

/* ******************************************************* */

u_int32_t getIPv4Pref(JNIEnv *env, jobject vpn_inst, const char *key) {
    struct in_addr addr = {0};

    jmethodID midMethod = jniGetMethodID(env, cls.vpn_service, key, "()Ljava/lang/String;");
    jstring obj = (*env)->CallObjectMethod(env, vpn_inst, midMethod);

    if(!jniCheckException(env)) {
        const char *value = (*env)->GetStringUTFChars(env, obj, 0);
        log_d("getIPv4Pref(%s) = %s", key, value);

        if(*value && (inet_aton(value, &addr) == 0))
            log_e("%s() returned invalid IPv4 address: %s", key, value);

        (*env)->ReleaseStringUTFChars(env, obj, value);
    }

    (*env)->DeleteLocalRef(env, obj);

    return(addr.s_addr);
}

/* ******************************************************* */

zdtun_ip_t getIPPref(JNIEnv *env, jobject vpn_inst, const char *key, int *ip_ver) {
    zdtun_ip_t rv = {};

    jmethodID midMethod = jniGetMethodID(env, cls.vpn_service, key, "()Ljava/lang/String;");
    jstring obj = (*env)->CallObjectMethod(env, vpn_inst, midMethod);

    if(!jniCheckException(env)) {
        const char *value = (*env)->GetStringUTFChars(env, obj, 0);
        log_d("getIPPref(%s) = %s", key, value);

        if(*value) {
            *ip_ver = zdtun_parse_ip(value, &rv);

            if(*ip_ver < 0)
                log_e("%s() returned invalid IP address: %s", key, value);
        }

        (*env)->ReleaseStringUTFChars(env, obj, value);
    }

    (*env)->DeleteLocalRef(env, obj);
    return(rv);
}

/* ******************************************************* */

struct in6_addr getIPv6Pref(JNIEnv *env, jobject vpn_inst, const char *key) {
    struct in6_addr addr = {0};

    jmethodID midMethod = jniGetMethodID(env, cls.vpn_service, key, "()Ljava/lang/String;");
    jstring obj = (*env)->CallObjectMethod(env, vpn_inst, midMethod);

    if(!jniCheckException(env)) {
        const char *value = (*env)->GetStringUTFChars(env, obj, 0);
        log_d("getIPv6Pref(%s) = %s", key, value);

        if(inet_pton(AF_INET6, value, &addr) != 1)
            log_e("%s() returned invalid IPv6 address", key);

        (*env)->ReleaseStringUTFChars(env, obj, value);
    }

    (*env)->DeleteLocalRef(env, obj);

    return(addr);
}

/* ******************************************************* */

int getIntPref(JNIEnv *env, jobject vpn_inst, const char *key) {
    jint value;
    jmethodID midMethod = jniGetMethodID(env, cls.vpn_service, key, "()I");

    value = (*env)->CallIntMethod(env, vpn_inst, midMethod);
    jniCheckException(env);

    log_d("getIntPref(%s) = %d", key, value);

    return(value);
}

/* ******************************************************* */

// Retrieve a int[] pref.
// If rv is >0, out points to the allocated array. It's up to the caller to free it with pd_free
int getIntArrayPref(JNIEnv *env, jobject vpn_inst, const char *key, int **out) {
    int rv = -1;
    jmethodID midMethod = jniGetMethodID(env, cls.vpn_service, key, "()[I");
    jintArray jarr = (jintArray) (*env)->CallObjectMethod(env, vpn_inst, midMethod);

    if (!jniCheckException(env)) {
        int size = (*env)->GetArrayLength(env, jarr);
        log_d("getIntArrayPref(%s) = #%d", key, size);

        if (size > 0) {
            jint *array = (*env)->GetIntArrayElements(env, jarr, NULL);
            if (array) {
                size_t arr_size = size * sizeof(int);

                *out = (int*) pd_malloc(arr_size);
                if (*out) {
                    // success
                    memcpy(*out, array, arr_size);
                    rv = size;
                }

                (*env)->ReleaseIntArrayElements(env, jarr, array, 0);
            }
        } else
            rv = size;
    }

    (*env)->DeleteLocalRef(env, jarr);
    return rv;
}

/* ******************************************************* */

void getApplicationByUid(pcapdroid_t *pd, jint uid, char *buf, int bufsize) {
    JNIEnv *env = pd->env;
    const char *value = NULL;

    jstring obj = (*env)->CallObjectMethod(env, pd->capture_service, mids.getApplicationByUid, uid);
    jniCheckException(env);

    if(obj)
        value = (*env)->GetStringUTFChars(env, obj, 0);

    if(value)
        snprintf(buf, bufsize, "%s", value);
    else
        snprintf(buf, bufsize, "???");

    if(value) (*env)->ReleaseStringUTFChars(env, obj, value);
    if(obj) (*env)->DeleteLocalRef(env, obj);
}

/* ******************************************************* */

void getPackageNameByUid(pcapdroid_t *pd, jint uid, char *buf, int bufsize) {
    JNIEnv *env = pd->env;
    const char *value = NULL;

    jstring obj = (*env)->CallObjectMethod(env, pd->capture_service, mids.getPackageNameByUid, uid);
    jniCheckException(env);

    if(obj)
        value = (*env)->GetStringUTFChars(env, obj, 0);

    if(value)
        snprintf(buf, bufsize, "%s", value);
    else
        buf[0] = '\0';

    if(value) (*env)->ReleaseStringUTFChars(env, obj, value);
    if(obj) (*env)->DeleteLocalRef(env, obj);
}

/* ******************************************************* */

void loadUidMapping(pcapdroid_t *pd, jint uid, const char *package_name, const char *app_name) {
    JNIEnv *env = pd->env;

    jstring package_str = (*env)->NewStringUTF(env, package_name);
    jstring app_str = (*env)->NewStringUTF(env, app_name);

    (*env)->CallVoidMethod(env, pd->capture_service, mids.loadUidMapping, uid, package_str, app_str);
    jniCheckException(env);

    (*env)->DeleteLocalRef(env, package_str);
    (*env)->DeleteLocalRef(env, app_str);
}

/* ******************************************************* */

bool getCountryCode(pcapdroid_t *pd, const char *host, char out[3]) {
    bool rv = false;
    JNIEnv *env = pd->env;
    jstring host_str = (*env)->NewStringUTF(env, host);

    jstring obj = (*env)->CallObjectMethod(env, pd->capture_service, mids.getCountryCode, host_str);
    jniCheckException(env);

    if (obj) {
        const char *value = (*env)->GetStringUTFChars(env, obj, 0);

        if (value && strlen(value) == 2) {
            out[0] = value[0];
            out[1] = value[1];
            out[2] = '\0';
            rv = true;
        }

        (*env)->ReleaseStringUTFChars(env, obj, value);
    }

    (*env)->DeleteLocalRef(env, host_str);
    return rv;
}

/* ******************************************************* */

JNIEXPORT void JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_dumpMasterSecret(JNIEnv *env, jclass clazz,
                                                                   jbyteArray secret) {
    jsize sec_len = (*env)->GetArrayLength(env, secret);
    jbyte* sec_data = (*env)->GetByteArrayElements(env, secret, 0);

    if(global_pd && global_pd->pcap_dump.dumper)
        pcap_dump_secret(global_pd->pcap_dump.dumper, sec_data, sec_len);

    (*env)->ReleaseByteArrayElements(env, secret, sec_data, 0);
}

/* ******************************************************* */

JNIEXPORT jboolean JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_hasSeenDumpExtensions(JNIEnv *env,
                                                                        jclass clazz) {
    return has_seen_dump_extensions;
}

/* ******************************************************* */

JNIEXPORT jboolean JNICALL
Java_com_emanuelef_remote_1capture_CaptureService_extractKeylogFromPcapng(JNIEnv *env, jclass clazz,
                    jstring pcapng_path, jstring out_path
) {
    const char *pcapng_s = (*env)->GetStringUTFChars(env, pcapng_path, 0);
    const char *out_s = (*env)->GetStringUTFChars(env, out_path, 0);

    bool rv = pcapng_to_keylog(pcapng_s, out_s);

    (*env)->ReleaseStringUTFChars(env, out_path, out_s);
    (*env)->ReleaseStringUTFChars(env, pcapng_path, pcapng_s);
    return rv;
}

#endif // ANDROID

```

`app/src/main/jni/core/log_writer.c`:

```c
#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include "log_writer.h"

struct log_writer;

static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
static struct log_writer **loggers = NULL;
static int num_loggers = 0;

struct log_writer {
    FILE *f;
    char *path;
    int id;
    int level;
    bool errored;
};

static void pd_destroy_logger(struct log_writer *logger) {
    if(logger->f)
        fclose(logger->f);
    pd_free(logger->path);
    pd_free(logger);
}

void pd_close_loggers() {
    pthread_mutex_lock(&mutex);

    for(int i=0; i<num_loggers; i++)
        pd_destroy_logger(loggers[i]);
    pd_free(loggers);
    loggers = NULL;
    num_loggers = 0;

    pthread_mutex_unlock(&mutex);
}

int pd_init_logger(const char *path, int min_lvl) {
    int rv;
    struct log_writer *logger = (struct log_writer*) pd_calloc(1, sizeof(struct log_writer));
    if(!logger)
        return -errno;

    logger->level = min_lvl;
    logger->path = pd_strdup(path);
    if(!logger->path) {
        pd_free(logger);
        return -errno;
    }

    pthread_mutex_lock(&mutex);
    loggers = pd_realloc(loggers, sizeof(void*) * (num_loggers + 1));
    if(!loggers) {
        pd_destroy_logger(logger);
        rv = -1;
    } else {
        loggers[num_loggers] = logger;
        logger->id = rv = num_loggers++;
    }
    pthread_mutex_unlock(&mutex);

    return rv;
}

int pd_log_write(int logger_id, int lvl, const char *msg) {
    int rv = 0;
    char dtbuf[64];
    struct tm tm;
    time_t tnow = time(NULL);
    strftime(dtbuf, sizeof(dtbuf), "%d/%b/%Y %H:%M:%S", localtime_r(&tnow, &tm));

    pthread_mutex_lock(&mutex);

    if((logger_id < 0) || (logger_id >= num_loggers)) {
        rv = -ENOENT;
        goto unlock;
    }

    struct log_writer *logger = loggers[logger_id];

    if(logger->level > lvl)
        goto unlock;

    if(!logger->f && !logger->errored) {
        // only overwrite the file when writing to it
        logger->f = fopen(logger->path, "w");

        if(!logger->f) {
#ifdef ANDROID
            __android_log_print(ANDROID_LOG_ERROR, logtag,
                                "pd_init_logger %s failed[%d]: %s", logger->path, errno, strerror(errno));
#endif
            rv = -errno;
            logger->errored = true;
            goto unlock;
        }
    }

    if(!logger->f || ferror(logger->f)) {
        rv = -EINVAL;
        goto unlock;
    }

    fprintf(logger->f, "[%c] %s - %s\n", loglvl2char(lvl), dtbuf, msg);
    if(ferror(logger->f)) {
#ifdef ANDROID
        __android_log_print(ANDROID_LOG_ERROR, logtag,
                            "pd_log %d failed[%d]: %s", logger_id, errno, strerror(errno));
#endif
        rv = -errno;
        goto unlock;
    }

    fflush(logger->f);

unlock:
    pthread_mutex_unlock(&mutex);
    return rv;
}
```

`app/src/main/jni/core/log_writer.h`:

```h
#ifndef PCAPDROID_LOG_WRITER_H
#define PCAPDROID_LOG_WRITER_H

#include "common/utils.h"

#define PD_DEFAULT_LOGGER 0
#define PD_DEFAULT_LOGGER_LEVEL ANDROID_LOG_INFO

int pd_init_logger(const char *path, int min_lvl);
int pd_log_write(int logger, int lvl, const char *msg);
void pd_close_loggers();

#endif //PCAPDROID_LOG_WRITER_H

```

`app/src/main/jni/core/ndpi_config.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-21 - Emanuele Faranda
 */

#include "ndpi_api.h"
#include "ndpi_protocol_ids.h"

/* ******************************************************* */

// protocols which are not application protocols
void init_ndpi_protocols_bitmask(ndpi_protocol_bitmask_struct_t *b) {
    NDPI_ZERO(b);

    // https://github.com/ntop/nDPI/blob/dev/src/include/ndpi_protocol_ids.h
    NDPI_SET(b, NDPI_PROTOCOL_FTP_CONTROL);
    NDPI_SET(b, NDPI_PROTOCOL_MAIL_POP);
    NDPI_SET(b, NDPI_PROTOCOL_MAIL_SMTP);
    NDPI_SET(b, NDPI_PROTOCOL_MAIL_IMAP);
    NDPI_SET(b, NDPI_PROTOCOL_DNS);
    NDPI_SET(b, NDPI_PROTOCOL_IPP);
    NDPI_SET(b, NDPI_PROTOCOL_HTTP);
    NDPI_SET(b, NDPI_PROTOCOL_MDNS);
    NDPI_SET(b, NDPI_PROTOCOL_NTP);
    NDPI_SET(b, NDPI_PROTOCOL_NETBIOS);
    NDPI_SET(b, NDPI_PROTOCOL_NFS);
    NDPI_SET(b, NDPI_PROTOCOL_SSDP);
    NDPI_SET(b, NDPI_PROTOCOL_SNMP);
    NDPI_SET(b, NDPI_PROTOCOL_XDMCP);
    NDPI_SET(b, NDPI_PROTOCOL_SMBV1);
    NDPI_SET(b, NDPI_PROTOCOL_SYSLOG);
    NDPI_SET(b, NDPI_PROTOCOL_DHCP);
    NDPI_SET(b, NDPI_PROTOCOL_POSTGRES);
    NDPI_SET(b, NDPI_PROTOCOL_MYSQL);
    NDPI_SET(b, NDPI_PROTOCOL_MAIL_POPS);
    NDPI_SET(b, NDPI_PROTOCOL_TAILSCALE);
    NDPI_SET(b, NDPI_PROTOCOL_COAP);
    NDPI_SET(b, NDPI_PROTOCOL_VMWARE);
    NDPI_SET(b, NDPI_PROTOCOL_MAIL_SMTPS);
    NDPI_SET(b, NDPI_PROTOCOL_DTLS);
    NDPI_SET(b, NDPI_PROTOCOL_UBNTAC2);
    NDPI_SET(b, NDPI_PROTOCOL_BITTORRENT);
    NDPI_SET(b, NDPI_PROTOCOL_SMBV23);
    NDPI_SET(b, NDPI_PROTOCOL_RTSP);
    NDPI_SET(b, NDPI_PROTOCOL_MAIL_IMAPS);
    NDPI_SET(b, NDPI_PROTOCOL_ICECAST);
    NDPI_SET(b, NDPI_PROTOCOL_IRC);
    NDPI_SET(b, NDPI_PROTOCOL_NATS);
    NDPI_SET(b, NDPI_PROTOCOL_TELNET);
    NDPI_SET(b, NDPI_PROTOCOL_STUN);
    NDPI_SET(b, NDPI_PROTOCOL_IPSEC);
    NDPI_SET(b, NDPI_PROTOCOL_IP_GRE);
    NDPI_SET(b, NDPI_PROTOCOL_RTP);
    NDPI_SET(b, NDPI_PROTOCOL_RDP);
    NDPI_SET(b, NDPI_PROTOCOL_VNC);
    NDPI_SET(b, NDPI_PROTOCOL_TLS);
    NDPI_SET(b, NDPI_PROTOCOL_SSH);
    NDPI_SET(b, NDPI_PROTOCOL_TFTP);
    NDPI_SET(b, NDPI_PROTOCOL_SIP);
    NDPI_SET(b, NDPI_PROTOCOL_DHCPV6);
    NDPI_SET(b, NDPI_PROTOCOL_KERBEROS);
    NDPI_SET(b, NDPI_PROTOCOL_PPTP);
    NDPI_SET(b, NDPI_PROTOCOL_NETFLOW);
    NDPI_SET(b, NDPI_PROTOCOL_SFLOW);
    NDPI_SET(b, NDPI_PROTOCOL_HTTP_CONNECT);
    NDPI_SET(b, NDPI_PROTOCOL_HTTP_PROXY);
    NDPI_SET(b, NDPI_PROTOCOL_RADIUS);
    NDPI_SET(b, NDPI_PROTOCOL_TEAMVIEWER);
    NDPI_SET(b, NDPI_PROTOCOL_OPENVPN);
    NDPI_SET(b, NDPI_PROTOCOL_CISCOVPN);
    NDPI_SET(b, NDPI_PROTOCOL_TOR);
    NDPI_SET(b, NDPI_PROTOCOL_RTCP);
    NDPI_SET(b, NDPI_PROTOCOL_SOCKS);
    NDPI_SET(b, NDPI_PROTOCOL_RTMP);
    NDPI_SET(b, NDPI_PROTOCOL_FTP_DATA);
    NDPI_SET(b, NDPI_PROTOCOL_ZMQ);
    NDPI_SET(b, NDPI_PROTOCOL_RESP);
    NDPI_SET(b, NDPI_PROTOCOL_QUIC);
    NDPI_SET(b, NDPI_PROTOCOL_WIREGUARD);
    NDPI_SET(b, NDPI_PROTOCOL_DNSCRYPT);
    NDPI_SET(b, NDPI_PROTOCOL_TINC);
    NDPI_SET(b, NDPI_PROTOCOL_DNSCRYPT);
    NDPI_SET(b, NDPI_PROTOCOL_MQTT);
    NDPI_SET(b, NDPI_PROTOCOL_RX);
    NDPI_SET(b, NDPI_PROTOCOL_GIT);
    NDPI_SET(b, NDPI_PROTOCOL_DRDA);
    NDPI_SET(b, NDPI_PROTOCOL_VALVE_SDR);
    NDPI_SET(b, NDPI_PROTOCOL_WEBSOCKET);
    NDPI_SET(b, NDPI_PROTOCOL_Z3950);
    NDPI_SET(b, NDPI_PROTOCOL_MPEGDASH);
    NDPI_SET(b, NDPI_PROTOCOL_FTPS);
    NDPI_SET(b, NDPI_PROTOCOL_NATPMP);
    NDPI_SET(b, NDPI_PROTOCOL_SRTP);
    NDPI_SET(b, NDPI_PROTOCOL_HTTP2);
    NDPI_SET(b, NDPI_PROTOCOL_PROTOBUF);
    NDPI_SET(b, NDPI_PROTOCOL_RTPS);
    NDPI_SET(b, NDPI_PROTOCOL_TRDP);
}
```

`app/src/main/jni/core/pcap_dump.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2023-25 - Emanuele Faranda
 */

#include <linux/if_ether.h>
#include <net/if.h>
#include <pthread.h>
#include "common/utils.h"
#include "pcapdroid.h"
#include "pcap_dump.h"
#include "third_party/uthash.h"

#define MAX_PCAP_DUMP_DELAY_MS 1000
#define PCAP_BUFFER_SIZE             (512*1024)         // 512K
#define PCAP_BUFFER_ALMOST_FULL_SIZE (450*1024)         // 450K
#define KEYLOG_BUFFER_HEADROOM       (sizeof(pcapng_decr_secrets_block_t))
#define KEYLOG_BUFFER_TAILROOM       8 /* block "total_size" field + max 3 bytes of padding + 1 */

typedef struct {
    int id;
    UT_hash_handle hh;
} mapped_uid_t;

typedef struct {
    u_int ifidx;
    u_int pcapng_ifid;
    UT_hash_handle hh;
} dumped_interface_t;

struct pcap_dumper {
    pcap_dump_format_t format;
    bool dump_extensions;
    pcap_dump_callback *dump_cb;
    pcapdroid_t *pd;
    int snaplen;
    uint64_t max_dump_size;
    bool max_dump_size_reached;
    uint64_t dump_size;
    uint64_t last_dump_ms;
    mapped_uid_t *mapped_uids;
    dumped_interface_t *dumped_interfaces;
    u_int num_dumped_interfaces;

    // the crc32 implementation requires 4-bytes aligned accesses.
    // frames are padded to honor the 4-bytes alignment.
    int8_t *buffer  __attribute__((aligned (4)));
    int buffer_idx;

    int8_t *keylog_buf;
    pthread_mutex_t keylog_mutex;
    int keylog_idx;
};

/* ******************************************************* */

pcap_dumper_t* pcap_new_dumper(pcap_dump_format_t format, bool dump_extensions,
                               int snaplen, uint64_t max_dump_size,
                               pcap_dump_callback dumpcb, pcapdroid_t *pd) {
    pcap_dumper_t *dumper = pd_calloc(1, sizeof(pcap_dumper_t));
    if(!dumper) {
        log_e("calloc(pcap_dumper_t) failed with code %d/%s",
              errno, strerror(errno));
        return NULL;
    }

    dumper->buffer = pd_malloc(PCAP_BUFFER_SIZE);
    if(!dumper->buffer) {
        log_e("malloc(pcap_dumper_t buffer) failed with code %d/%s",
              errno, strerror(errno));
        pd_free(dumper);
        return NULL;
    }

    if(pthread_mutex_init(&dumper->keylog_mutex, NULL) != 0) {
        log_e("pthread_mutex_init failed");
        pd_free(dumper->buffer);
        pd_free(dumper);
        return NULL;
    }

    dumper->snaplen = snaplen;
    dumper->format = format;
    dumper->dump_extensions = dump_extensions;
    dumper->max_dump_size = max_dump_size;
    dumper->dump_cb = dumpcb;
    dumper->pd = pd;

    return dumper;
}

/* ******************************************************* */

static void export_keylog_buffer(pcap_dumper_t *dumper) {
    if(dumper->keylog_idx == 0)
        return;

    // the keylog buffer is written by another thread, so it must be synchronized
    pthread_mutex_lock(&dumper->keylog_mutex);

    int sec_len = dumper->keylog_idx;
    uint8_t padding = (~sec_len + 1) & 0x3;
    int block_size = sizeof(pcapng_decr_secrets_block_t) + sec_len + padding + 4 /* total_length */;

    // refuse to dump if we would exceed the max_dump_size. NOTE: this could be improved to only
    // export what does not exceed the dump size
    if((dumper->max_dump_size > 0) && (dumper->dump_size + block_size >= dumper->max_dump_size)) {
        log_w("max dump size would be exceeded by the keylog dump, discarding keylog");
        dumper->keylog_idx = 0;
        goto unlock;
    }

    // prepare the block header
    pcapng_decr_secrets_block_t *dsb = (pcapng_decr_secrets_block_t*) dumper->keylog_buf;
    dsb->type = 0x0000000A;
    dsb->total_length = block_size;
    dsb->secrets_type = 0x544c534b /* TLS_KEYLOG */;
    dsb->secrets_length = sec_len;

    // padding
    char *ptr = (char*)dumper->keylog_buf + KEYLOG_BUFFER_HEADROOM + sec_len;
    for(uint8_t i=0; i<padding; i++)
        *(ptr++) = 0x00;
    *(uint32_t*)ptr = dsb->total_length;

    if(dumper->dump_cb)
        dumper->dump_cb(dumper->pd, dumper->keylog_buf, block_size);

    dumper->dump_size += block_size;
    dumper->keylog_idx = 0;

unlock:
    pthread_mutex_unlock(&dumper->keylog_mutex);
}

/* ******************************************************* */

static void export_dump_buffer(pcap_dumper_t *dumper) {
    // prevents exporting more than the max dump size
    if (dumper->max_dump_size_reached)
        return;

    export_keylog_buffer(dumper);

    if(dumper->buffer_idx == 0)
        return;

    if(dumper->dump_cb)
        dumper->dump_cb(dumper->pd, dumper->buffer, dumper->buffer_idx);

    dumper->buffer_idx = 0;
    dumper->last_dump_ms = dumper->pd->now_ms;
}

/* ******************************************************* */

// Allocates the given size in the PCAP export buffer and returns a pointer to it
// Note: the buffer may be flushed on subsequent invocations, so avoid interleaving calls to this
// Can return NULL, e.g. in case the max dump size was reached
static int8_t* alloc_dump_buffer(pcap_dumper_t *dumper, int size) {
    if (dumper->max_dump_size_reached)
        return NULL;

    if((PCAP_BUFFER_SIZE - dumper->buffer_idx) <= size)
        export_dump_buffer(dumper);

    if ((PCAP_BUFFER_SIZE - dumper->buffer_idx) <= size) {
        log_f("Invalid buffer size [size=%d, idx=%d, dump_size=%d]",
              PCAP_BUFFER_SIZE, dumper->buffer_idx, size);
        return NULL;
    } else if((dumper->max_dump_size > 0) &&
              ((dumper->dump_size + size) >= dumper->max_dump_size)) {
        dumper->max_dump_size_reached = true;
        log_i("Max dump size reached, stop the dump");
        return NULL;
    }

    int8_t* ptr = &dumper->buffer[dumper->buffer_idx];
    dumper->buffer_idx += size;
    dumper->dump_size += size;

    return ptr;
}

/* ******************************************************* */

void pcap_destroy_dumper(pcap_dumper_t *dumper) {
    export_dump_buffer(dumper);

    {
        mapped_uid_t *entry, *tmp;
        HASH_ITER(hh, dumper->mapped_uids, entry, tmp) {
            pd_free(entry);
        }
    }

    {
        dumped_interface_t *entry, *tmp;
        HASH_ITER(hh, dumper->dumped_interfaces, entry, tmp) {
            pd_free(entry);
        }
    }

    pthread_mutex_destroy(&dumper->keylog_mutex);
    if(dumper->keylog_buf)
        pd_free(dumper->keylog_buf);
    pd_free(dumper->buffer);
    pd_free(dumper);
}

/* ******************************************************* */

typedef struct {
    uint16_t type;
    uint16_t length;
    uint16_t padding;
    uint16_t tot_length;
    void *data;
} pcapng_opt_t;

static pcapng_opt_t pcapng_option(uint16_t type, void *data, uint16_t length) {
    pcapng_opt_t opt;

    opt.type = type;
    opt.length = length;
    opt.data = data;
    opt.padding = (~length + 1) & 0x3;
    opt.tot_length = 4 /* type, length */ + opt.length + opt.padding;
    return opt;
}

static int write_pcapng_opt(char *buf, pcapng_opt_t *opt) {
    *(uint16_t*) (buf+0) = opt->type;
    *(uint16_t*) (buf+2) = opt->length;
    buf += 4;

    memcpy(buf, opt->data, opt->length);
    buf += opt->length;

    for(uint8_t i=0; i < opt->padding; i++)
        *(buf++) = 0x00;

    return opt->tot_length;
}

/* ******************************************************* */

static int get_pcap_file_header(pcap_dumper_t *dumper, char **out) {
    struct pcap_hdr *pcap_hdr = pd_malloc(sizeof(struct pcap_hdr));
    if(!pcap_hdr)
        return -1;

    pcap_hdr->magic_number = 0xa1b2c3d4;
    pcap_hdr->version_major = 2;
    pcap_hdr->version_minor = 4;
    pcap_hdr->thiszone = 0;
    pcap_hdr->sigfigs = 0;
    pcap_hdr->snaplen = dumper->snaplen;
    pcap_hdr->network = dumper->dump_extensions ? LINKTYPE_ETHERNET : LINKTYPE_RAW;

    *out = (char*)pcap_hdr;
    return sizeof(struct pcap_hdr);
}

static int get_pcapng_preamble(pcap_dumper_t *dumper, char **out) {
    pcapng_opt_t shb_hw = pcapng_option(0x2, pd_device, strlen(pd_device));
    pcapng_opt_t shb_os = pcapng_option(0x3, pd_os, strlen(pd_os));
    pcapng_opt_t shb_app = pcapng_option(0x4, pd_appver, strlen(pd_appver));

    int shb_length = sizeof(pcapng_section_hdr_block_t) + shb_hw.tot_length +
            shb_os.tot_length + shb_app.tot_length + 4 /* total_length */;
    int idb_length = sizeof(pcapng_intf_descr_block_t) + 4 /* total_length */;
    int preamble_sz = shb_length + idb_length;
    char *preamble = (char*) pd_malloc(preamble_sz);
    if(!preamble)
        return -1;

    // Section Header Block
    pcapng_section_hdr_block_t *shb = (pcapng_section_hdr_block_t*) preamble;
    shb->type = 0x0A0D0D0A;
    shb->total_length = shb_length;
    shb->magic = 0x1a2b3c4d;
    shb->version_major = 1;
    shb->version_minor = 0;
    shb->section_length = -1;

    char *ptr = preamble + sizeof(pcapng_section_hdr_block_t);
    ptr += write_pcapng_opt(ptr, &shb_hw);
    ptr += write_pcapng_opt(ptr, &shb_os);
    ptr += write_pcapng_opt(ptr, &shb_app);
    *(uint32_t*)ptr = shb->total_length;
    ptr += 4;

    // Interface Description Block
    pcapng_intf_descr_block_t *idb = (pcapng_intf_descr_block_t*) ptr;
    idb->type = 0x00000001;
    idb->total_length = sizeof(pcapng_intf_descr_block_t) + 4;
    idb->reserved = 0;
    idb->linktype = LINKTYPE_RAW;
    idb->snaplen = dumper->snaplen;
    *(uint32_t*)(idb+1) = idb->total_length;

    *out = preamble;
    return preamble_sz;
}

/* Get a buffer (out) containing the PCAP header or the PCAPNG preamble (Section Header Block and
 * Interface Description Block).
 * Returns the buffer size on success, -1 on error. The out buffer must be free by the called with pd_free. */
int pcap_get_preamble(pcap_dumper_t *dumper, char **out) {
    if(dumper->format == PCAPNG_DUMP)
        return get_pcapng_preamble(dumper, out);
    else
        return get_pcap_file_header(dumper, out);
}

/* ******************************************************* */

// returns true if the buffer was exported
bool pcap_check_export(pcap_dumper_t *dumper) {
    if (dumper->max_dump_size_reached)
        return false;

    if(((dumper->buffer_idx > 0) && (dumper->pd->now_ms - dumper->last_dump_ms) >= MAX_PCAP_DUMP_DELAY_MS) ||
            (dumper->keylog_idx > PCAP_BUFFER_ALMOST_FULL_SIZE)) {
        export_dump_buffer(dumper);
        return true;
    }
    return false;
}

/* ******************************************************* */

uint64_t pcap_get_dump_size(pcap_dumper_t *dumper) {
    return dumper->dump_size;
}

/* ******************************************************* */

static bool dump_packet_pcap(pcap_dumper_t *dumper, const char *pkt, int pktlen,
                                    const struct timeval *tv, int uid) {
    int incl_len = min(pktlen, dumper->snaplen);
    int pre_trailer_padding = 0;
    bool with_trailer = false;
    int trailer_overhead = 0;

    if(dumper->dump_extensions) {
        // Pad the frame so that the buffer keeps its 4-bytes alignment
        pre_trailer_padding = (~(sizeof(struct ethhdr) + incl_len) + 1) & 0x3;
        trailer_overhead = (int)(sizeof(struct ethhdr) + pre_trailer_padding + sizeof(pcapdroid_trailer_t));

        if ((incl_len + trailer_overhead) > dumper->snaplen) {
            static bool warning_shown = false;
            if (!warning_shown) {
                log_w("PCAPdroid trailer would exceed snaplen, skipping. Consider increasing the snaplen");
                warning_shown = true;
            }
            pre_trailer_padding = 0;
            trailer_overhead = 0;
        } else {
            incl_len += trailer_overhead;
            with_trailer = true;
        }
    }

    int8_t *buffer = alloc_dump_buffer(dumper, sizeof(pcap_rec_t) + incl_len);
    if (!buffer)
        return false;

    pcap_rec_t *pcap_rec = (pcap_rec_t*) buffer;
    int offset = 0;

    pcap_rec->ts_sec = tv->tv_sec;
    pcap_rec->ts_usec = tv->tv_usec;
    pcap_rec->incl_len = incl_len;
    pcap_rec->orig_len = pktlen + trailer_overhead;
    buffer += sizeof(struct pcap_rec);

    if(with_trailer) {
        if((((uint64_t)buffer) & 0x3) != 0) {
            static bool warning_shown = false;
            if (!warning_shown) {
                log_w("Unaligned buffer!");
                warning_shown = true;
            }
        }

        // Insert the bogus header: both the MAC addresses are 0
        struct ethhdr *eth = (struct ethhdr*) buffer;
        memset(eth, 0, sizeof(struct ethhdr));
        eth->h_proto = htons((((*pkt) >> 4) == 4) ? ETH_P_IP : ETH_P_IPV6);

        offset += sizeof(struct ethhdr);
    }

    int payload_to_copy = min(pktlen, pcap_rec->incl_len - offset);
    memcpy(buffer + offset, pkt, payload_to_copy);
    offset += payload_to_copy;

    if(with_trailer) {
        // Pad the frame so that the buffer keeps its 4-bytes alignment
        // The padding is inserted before the PCAPdroid trailer so that accesses to pcapdroid_trailer_t
        // are also aligned.
        for(uint8_t i=0; i<pre_trailer_padding; i++)
            buffer[offset++] = 0x00;

        // Populate the trailer
        pcapdroid_trailer_t *trailer = (pcapdroid_trailer_t*)(buffer + offset);
        memset(trailer, 0, sizeof(*trailer));

        trailer->magic = htonl(PCAPDROID_TRAILER_MAGIC);
        trailer->uid = htonl(uid);
        get_appname_by_uid(dumper->pd, uid, trailer->appname, sizeof(trailer->appname));

        //clock_t start = clock();
        trailer->fcs = crc32((u_char*) buffer, pcap_rec->incl_len - 4, 0);
        //double cpu_time_used = ((double) (clock() - start)) / CLOCKS_PER_SEC;
        //log_d("crc cpu_time_used: %f sec", cpu_time_used);
    }

    return true;
}

static void make_custom_block(pcapng_pd_custom_block_t *block, uint8_t block_type, int total_length) {
    // https://datatracker.ietf.org/doc/draft-ietf-opsawg-pcapng - 4.8 Custom Block
    block->block_type = 0x00000bad;
    block->total_length = total_length;
    block->pen = PCAPDROID_PEN;

    block->version = PCAPDROID_PCAPNG_VERSION;
    block->type = block_type;
}

static bool dump_pcapng_uid_mapping(pcap_dumper_t *dumper, int uid) {
    char package_name[64];
    char app_name[64];

#ifdef ANDROID
    getPackageNameByUid(dumper->pd, uid, package_name, sizeof(package_name));
    getApplicationByUid(dumper->pd, uid, app_name, sizeof(app_name));
#else
    return true;
#endif

    int package_name_len = strlen(package_name);
    int app_name_len = strlen(app_name);

    int total_length = sizeof(pcapng_pd_uid_map_block_t) + package_name_len + app_name_len + 4 /* total length */;
    uint8_t padding = (~total_length + 1) & 0x3 /* padding */;
    total_length += padding;

    int8_t *buffer = alloc_dump_buffer(dumper, total_length);
    if (!buffer)
        return false;

    pcapng_pd_uid_map_block_t* block = (pcapng_pd_uid_map_block_t*) buffer;
    make_custom_block(&block->hdr, PCAPDROID_BLOCK_UID_MAP, total_length);
    block->uid = uid;
    block->package_name_len = package_name_len;
    block->app_name_len = app_name_len;

    buffer += sizeof(pcapng_pd_uid_map_block_t);
    memcpy(buffer, package_name, block->package_name_len);
    buffer += block->package_name_len;
    memcpy(buffer, app_name, block->app_name_len);
    buffer += block->app_name_len;

    for(uint8_t i=0; i<padding; i++)
        *(buffer++) = 0x00;

    *(uint32_t*)buffer = block->hdr.total_length;
    return true;
}

static bool dump_pcapng_interface(pcap_dumper_t *dumper, u_int ifidx) {
    int total_length = sizeof(pcapng_intf_descr_block_t) + 4 /* total length */;

    // try to get the interface name
    char ifname[IFNAMSIZ];
    uint8_t ifname_padding = 0;
    if (!if_indextoname(ifidx, ifname))
        ifname[0] = '\0';

    if (ifname[0]) {
        total_length += sizeof(pcapng_enh_option_t) + strlen(ifname);
        ifname_padding = (~total_length + 1) & 0x3;
        total_length += ifname_padding;
    }

    int8_t *buffer = alloc_dump_buffer(dumper, total_length);
    if (!buffer)
        return false;

    pcapng_intf_descr_block_t *idb = (pcapng_intf_descr_block_t*) buffer;
    idb->type = 0x00000001;
    idb->total_length = total_length;
    idb->reserved = 0;
    idb->linktype = LINKTYPE_RAW /* even with root, we always dump IP packets */;
    idb->snaplen = dumper->snaplen;
    buffer += sizeof(*idb);

    if (ifname[0]) {
        pcapng_enh_option_t *opt = (pcapng_enh_option_t*) buffer;
        opt->code = 2; // if_name
        opt->length = strlen(ifname);
        buffer += sizeof(*opt);

        memcpy(buffer, ifname, opt->length);
        buffer += opt->length;

        for(uint8_t i=0; i<ifname_padding; i++)
            *(buffer++) = 0x00;
    }

    *(uint32_t*)buffer = idb->total_length;
    return true;
}

static bool dump_packet_pcapng(pcap_dumper_t *dumper, const char *pkt, int pktlen,
                                      const struct timeval *tv, int uid, u_int ifidx) {
    u_int pcapng_ifid = 0;

    if(ifidx > 0) {
        dumped_interface_t *item;
        HASH_FIND_INT(dumper->dumped_interfaces, &ifidx, item);

        if (!item) {
            if (dump_pcapng_interface(dumper, ifidx)) {
                item = pd_calloc(sizeof(dumped_interface_t), 1);
                item->ifidx = ifidx;
                item->pcapng_ifid = pcapng_ifid = ++dumper->num_dumped_interfaces;
                HASH_ADD_INT(dumper->dumped_interfaces, ifidx, item);
            }
        } else
            pcapng_ifid = item->pcapng_ifid;
    }

    if(dumper->dump_extensions) {
        mapped_uid_t *item;
        HASH_FIND_INT(dumper->mapped_uids, &uid, item);

        if (!item) {
            if (!dump_pcapng_uid_mapping(dumper, uid))
                return false;

            item = pd_calloc(sizeof(mapped_uid_t), 1);
            item->id = uid;
            HASH_ADD_INT(dumper->mapped_uids, id, item);
        }
    }

    int incl_len = min(pktlen, dumper->snaplen);
    int epb_size = sizeof(pcapng_enh_packet_block_t) + 4 /* total length */;
    uint8_t padding = (~incl_len + 1) & 0x3; // packet data must be padded to 32 bits
    int total_length = epb_size + incl_len + padding;

    char comment[32];
    int comment_len = 0;
    uint8_t comment_padding = 0;
    bool has_comment = false;

    if(dumper->dump_extensions) {
        comment_len = snprintf(comment, sizeof(comment), "u-%d", uid);
        comment_padding = (~comment_len + 1) & 0x3;
        total_length += sizeof(pcapng_enh_option_t) + comment_len + comment_padding;
        has_comment = true;
    }

    uint64_t now_usec = (uint64_t)tv->tv_sec * 1000000 + tv->tv_usec;
    int8_t *buffer = alloc_dump_buffer(dumper, total_length);

    pcapng_enh_packet_block_t *epb = (pcapng_enh_packet_block_t*) buffer;
    epb->type = 0x00000006;
    epb->total_length = total_length;
    epb->interface_id = pcapng_ifid;
    epb->timestamp_high = now_usec >> 32;
    epb->timestamp_low = now_usec;
    epb->captured_len = incl_len;
    epb->original_len = pktlen;

    memcpy(buffer + sizeof(pcapng_enh_packet_block_t), pkt, epb->captured_len);
    buffer += sizeof(pcapng_enh_packet_block_t) + epb->captured_len;

    // packet data must be padded to 32 bits
    for(uint8_t i=0; i<padding; i++)
        *(buffer++) = 0x00;

    if (has_comment) {
        // specify the UID as a comment
        // this is necessary until custom options are supported by Wireshark
        // https://gitlab.com/wireshark/wireshark/-/issues/18614
        pcapng_enh_option_t *option = (pcapng_enh_option_t *) buffer;
        option->code = 0x0001;
        option->length = comment_len;
        buffer += sizeof(pcapng_enh_option_t);

        memcpy(buffer, comment, comment_len);
        buffer += comment_len;

        for(uint8_t i=0; i<comment_padding; i++)
            *(buffer++) = 0x00;
    }

    *(uint32_t*)buffer = epb->total_length;
    return true;
}

/* Dump a single packet into the buffer. Returns false if PCAP dump must be stopped (e.g. if max
 * dump size reached or an error occurred). */
bool pcap_dump_packet(pcap_dumper_t *dumper, const char *pkt, int pktlen,
                      const struct timeval *tv, int uid, u_int ifidx) {
    bool rv;
    if (dumper->format == PCAPNG_DUMP)
        rv = dump_packet_pcapng(dumper, pkt, pktlen, tv, uid, ifidx);
    else
        rv = dump_packet_pcap(dumper, pkt, pktlen, tv, uid);

    if (!rv)
        return false;

    pcap_check_export(dumper);
    return true;
}

/* ******************************************************* */

// Master secrets are received by the MitmReceiver thread and stored into the keylog_buf, which is
// later exporter in export_buffer by the capture thread.
// This allows to dump the secrets before the packets, and also to avoid locks in the data path.
//
// NOTE: there is still a small chance to dump the packets before the corresponding master secrets,
// which would result in the inability to decrypt such packets in some tools (e.g. Wireshark)
bool pcap_dump_secret(pcap_dumper_t *dumper, int8_t *sec_data, int sec_len) {
    if(!dumper->keylog_buf) {
        // [ DSB | KEYLOG[PCAP_BUFFER_SIZE] | PADDING[0-3] | total_length ]
        dumper->keylog_buf = pd_malloc(KEYLOG_BUFFER_HEADROOM + PCAP_BUFFER_SIZE + KEYLOG_BUFFER_TAILROOM);
        if(!dumper->keylog_buf) {
            log_e("malloc(keylog_buf) failed with code %d/%s",
                  errno, strerror(errno));
            return false;
        }
    }

    if((dumper->keylog_idx + (sec_len + 1 /* will add a \n */)) >= PCAP_BUFFER_SIZE) {
        log_w("the keylog is not being exported, discarding secret");
        return false;
    }

    pthread_mutex_lock(&dumper->keylog_mutex);

    memcpy(dumper->keylog_buf + KEYLOG_BUFFER_HEADROOM + dumper->keylog_idx, sec_data, sec_len);
    dumper->keylog_idx += sec_len;
    dumper->keylog_buf[KEYLOG_BUFFER_HEADROOM + dumper->keylog_idx++] = '\n';

    pthread_mutex_unlock(&dumper->keylog_mutex);
    return true;
}
```

`app/src/main/jni/core/pcap_dump.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2023-25 - Emanuele Faranda
 */

#ifndef __PCAPDROID_DUMP_H__
#define __PCAPDROID_DUMP_H__

#include <stdlib.h>
#include <stdint.h>
#include <sys/time.h>

#define PCAPDROID_TRAILER_MAGIC 0x01072021
#define PCAPDROID_PEN 62652
#define PCAPDROID_PCAPNG_VERSION 1

#define PCAPDROID_BLOCK_UID_MAP 1

#define LINKTYPE_ETHERNET   1
#define LINKTYPE_RAW        101
#define LINKTYPE_LINUX_SLL  113
#define LINKTYPE_LINUX_SLL2 276

/*
 * Packet dump module, dumping packet records in the PCAP/PCAPNG format.
 * Packets are first buffered and then exported periodically to the callback. pcap_check_export must
 * be called periodically to ensure that buffered packets are exported on time.
 *
 * The PCAP/PCAPNG preambles are *not* dumped, use pcap_get_preamble to get the preamble to be dumped. This
 * allows, for example, multiple HTTP clients to connect at different times, each one getting a valid
 * PCAP header.
 */
typedef struct pcap_dumper pcap_dumper_t;

#ifndef lib_pcap_pcap_h

// compatible with pcap.h
struct pcap_pkthdr {
    struct timeval ts;
    uint32_t caplen;
    uint32_t len;
};

#endif

/* ******************************************************* */

typedef struct pcap_hdr {
    uint32_t magic_number;
    uint16_t version_major;
    uint16_t version_minor;
    int32_t thiszone;
    uint32_t sigfigs;
    uint32_t snaplen;
    uint32_t network;
} __attribute__((packed)) pcap_hdr_t;

typedef struct pcap_rec {
    uint32_t ts_sec;
    uint32_t ts_usec;
    uint32_t incl_len;
    uint32_t orig_len;
} __attribute__((packed)) pcap_rec_t;

/* ******************************************************* */

// NOTE: all the PCAPNG block addresses are aligned to 32-bits
typedef struct pcapng_generic_block {
    uint32_t type;
    uint32_t total_length;

    /* ..options.. */
} __attribute__((packed)) pcapng_generic_block_t;

// NOTE: pd_new_reader assumes sizeof(pcapng_section_hdr_block_t) <= sizeof(pcap_hdr)
typedef struct pcapng_section_hdr_block {
    uint32_t type;
    uint32_t total_length;
    uint32_t magic;
    uint16_t version_major;
    uint16_t version_minor;
    uint64_t section_length;

    /* ..options.. */
} __attribute__((packed)) pcapng_section_hdr_block_t;

typedef struct pcapng_intf_descr_block {
    uint32_t type;
    uint32_t total_length;
    uint16_t linktype;
    uint16_t reserved;
    uint32_t snaplen;
    /* ..options.. */
} __attribute__((packed)) pcapng_intf_descr_block_t;

typedef struct pcapng_decr_secrets_block {
    uint32_t type;
    uint32_t total_length;
    uint32_t secrets_type;
    uint32_t secrets_length;
    /* ..secrets data.. */
    /* ..options.. */
} __attribute__((packed)) pcapng_decr_secrets_block_t;

typedef struct pcapng_enh_packet_block {
    uint32_t type;
    uint32_t total_length;
    uint32_t interface_id;
    uint32_t timestamp_high;
    uint32_t timestamp_low;
    uint32_t captured_len;
    uint32_t original_len;
    /* ..packet data.. */
    /* ..padding.. */
    /* ..options.. */
} __attribute__((packed)) pcapng_enh_packet_block_t;

typedef struct pcapng_enh_option {
    uint16_t code;
    uint16_t length;
} pcapng_enh_option_t;

/* ******************************************************* */

typedef struct pcapng_pd_custom_block {
    int32_t block_type;
    uint32_t total_length;
    uint32_t pen;

    uint16_t version;
    uint8_t type;
    uint8_t padding;
} __attribute__((packed)) pcapng_pd_custom_block_t;

typedef struct pcapng_pd_uid_map_block {
    pcapng_pd_custom_block_t hdr;

    int32_t uid;
    uint8_t package_name_len;
    uint8_t app_name_len;
    /* ..package_name, app_name.. */
} __attribute__((packed)) pcapng_pd_uid_map_block_t;

/* ******************************************************* */

typedef enum {
    PCAP_DUMP,                // PCAP file
    PCAPNG_DUMP,              // PcapNg file
} pcap_dump_format_t;

/* A trailer to the packet which contains PCAPdroid-specific information.
 * When pcapdroid_trailer is set, the raw packet will be prepended with a bogus ethernet header,
 * whose size spans the raw packet data. The pcapdroid_trailer_t will be appended after the L3 data
 * so that PCAP parsers which are not aware of this data will just ignore it.
 *
 *  original: [IP | Payload]
 * pcapdroid: [ETH | IP | Payload | CustomData]
 */
typedef struct pcapdroid_trailer {
    uint32_t magic;
    int32_t uid;
    char appname[20];
    uint32_t fcs;
} __attribute__((packed)) pcapdroid_trailer_t;

struct pcapdroid;
typedef void pcap_dump_callback(struct pcapdroid *pd, const int8_t *buf, int dump_size);

pcap_dumper_t* pcap_new_dumper(pcap_dump_format_t format, bool dump_extensions, int snaplen, uint64_t max_dump_size,
                               pcap_dump_callback dumpcb, struct pcapdroid *pd);
void pcap_destroy_dumper(pcap_dumper_t *dumper);
bool pcap_dump_packet(pcap_dumper_t *dumper, const char *pkt, int pktlen, const struct timeval *tv, int uid, u_int ifidx);
bool pcap_dump_secret(pcap_dumper_t *dumper, int8_t *sec_data, int seclen);
int pcap_get_preamble(pcap_dumper_t *dumper, char **out);
uint64_t pcap_get_dump_size(pcap_dumper_t *dumper);
bool pcap_check_export(pcap_dumper_t *dumper);

#endif // __PCAPDROID_DUMP_H__

```

`app/src/main/jni/core/pcap_reader.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021-25 - Emanuele Faranda
 */

#include <stdio.h>
#include <errno.h>
#include <assert.h>
#include <net/if.h>

#include "pcap_reader.h"
#include "errors.h"
#include "common/memtrack.h"
#include "common/utils.h"
#include "third_party/uthash.h"

typedef struct {
    char name[IFNAMSIZ];
    int dlt;
    int ifidx;
} pcapng_intf_t;

typedef struct {
    int uid;
    UT_hash_handle hh;
} mapped_uid_t;

struct pd_reader {
    FILE* fp;
    pcap_dump_format_t dump_format;
    bool has_error;
    bool has_seen_dump_extensions;
    bool has_unsupported_dlt_packets;
    int dlt;
    pcapng_intf_t *interfaces;
    int num_interfaces;
    u_char *buffer;
    size_t buffer_size;
    mapped_uid_t *mapped_uids;
    long cur_block_pos;
    size_t cur_block_size;
};

static int linktype_to_dlt(int linktype) {
    // this should support all the DLTs of get_ip_offset
    switch (linktype) {
        case LINKTYPE_RAW:
            // NOTE: different from linktype
            return PCAPD_DLT_RAW;
        case LINKTYPE_ETHERNET:
        case LINKTYPE_LINUX_SLL:
        case LINKTYPE_LINUX_SLL2:
            return linktype;
        default:
            return 0;
    }
}

pd_reader_t* pd_new_reader(const char *fpath, char **error) {
    *error = NULL;

    pd_reader_t *reader = pd_calloc(1, sizeof(pd_reader_t));
    if(!reader) {
        log_e("calloc(pd_reader_t) failed with code %d/%s",
              errno, strerror(errno));
        goto fail;
    }

    reader->fp = fopen(fpath, "rb");
    if (!reader->fp) {
        log_e("Open capture %s failed[%d]: %s", fpath, errno, strerror(errno));
        if (errno == ENOENT)
            *error = PD_ERR_PCAP_DOES_NOT_EXIST;
        goto fail;
    }

    // determine the format
    pcap_hdr_t pcap_hdr;
    if (!fread(&pcap_hdr, sizeof(pcap_hdr), 1, reader->fp)) {
        log_e("Error reading the capture header[%d]: %s", errno, strerror(errno));
        *error = PD_ERR_INVALID_PCAP_FILE;
        goto fail;
    }

    if (pcap_hdr.magic_number == 0xa1b2c3d4) {
        // PCAP file
        reader->dlt = linktype_to_dlt(pcap_hdr.network);

        if ((pcap_hdr.version_major != 2) || (reader->dlt == 0)) {
            log_e("Unsupported PCAP file: version=%u.%u, linktype=%u",
                  pcap_hdr.version_major, pcap_hdr.version_minor, pcap_hdr.network);
            *error = PD_ERR_UNSUPPORTED_PCAP_FILE;
            goto fail;
        }

        reader->dump_format = PCAP_DUMP;
    } else {
        // this precondition allows for simpler logic
        assert(sizeof(pcap_hdr_t) >= sizeof(pcapng_section_hdr_block_t));
        if (!(sizeof(pcap_hdr_t) >= sizeof(pcapng_section_hdr_block_t))) {
            *error = PD_ERR_INVALID_PCAP_FILE;
            goto fail;
        }

        pcapng_section_hdr_block_t* pcapng_hdr = (pcapng_section_hdr_block_t*) &pcap_hdr;
        if ((pcapng_hdr->type != 0x0A0D0D0A) ||
            (pcapng_hdr->magic != 0x1a2b3c4d) &&
            (pcapng_hdr->magic != 0x4d32b1a)
        ) {
            log_e("Not a PCAP/Pcapng file");
            *error = PD_ERR_INVALID_PCAP_FILE;
            goto fail;
        }

        // Pcapng file
        if ((pcapng_hdr->magic != 0x1a2b3c4d) ||
            (pcapng_hdr->version_major != 1) ||
            (pcapng_hdr->section_length != -1)
        ) {
            log_e("Unsupported Pcapng file: version=%u.%u, magic=%u",
                  pcapng_hdr->version_major, pcapng_hdr->version_minor, pcapng_hdr->magic);
            *error = PD_ERR_UNSUPPORTED_PCAP_FILE;
            goto fail;
        }

        reader->cur_block_pos = 0;
        reader->cur_block_size = pcapng_hdr->total_length;
        reader->dump_format = PCAPNG_DUMP;
    }

    // success
    return reader;

fail:
    pd_destroy_reader(reader);
    return NULL;
}

void pd_destroy_reader(pd_reader_t *reader) {
    if (!reader)
        return;

    mapped_uid_t *entry, *tmp;
    HASH_ITER(hh, reader->mapped_uids, entry, tmp) {
        pd_free(entry);
    }

    if (reader->buffer)
        pd_free(reader->buffer);

    if (reader->interfaces)
        pd_free(reader->interfaces);

    if (reader->fp)
        fclose(reader->fp);

    pd_free(reader);
}

pcap_dump_format_t pd_get_dump_format(pd_reader_t *reader) {
    return reader->dump_format;
}

bool pd_has_seen_dump_extensions(pd_reader_t *reader) {
    return reader->has_seen_dump_extensions;
}

bool pd_has_unsupported_dlt_packets(pd_reader_t *reader) {
    return reader->has_unsupported_dlt_packets;
}

static bool reserve_buffer(pd_reader_t *reader, size_t size) {
    if (reader->buffer_size < size) {
        reader->buffer = pd_realloc(reader->buffer, size);

        if (!reader->buffer) {
            log_e("Cannot allocate Pcapng buffer of size %u", size);
            reader->has_error = true;
            return false;
        }

        reader->buffer_size = size;
    }

    return true;
}

static reader_rv pd_pcap_read_next(pd_reader_t *reader, pcapd_hdr_t *hdr, char* buffer, pd_read_callbacks_t *cb, void *userdata) {
    pcap_rec_t rec;

    if (fread(&rec, sizeof(rec), 1, reader->fp) != 1) {
        if (ferror(reader->fp)) {
            log_e("Error reading the next PCAP record [%d]: %s", errno, strerror(errno));
            reader->has_error = true;
            return READER_ERROR;
        } else
            return READER_EOF;
    }

    if (rec.incl_len > rec.orig_len) {
        log_e("PCAP record bad length: included=%u, orig=%u", rec.incl_len, rec.orig_len);
        errno = EINVAL;
        reader->has_error = true;
        return READER_ERROR;
    }

    int size = min(rec.incl_len, PCAPD_SNAPLEN);

    if (fread(buffer, size, 1, reader->fp) != 1) {
        if (ferror(reader->fp)) {
            log_e("Error reading the PCAP packed data[%d]: %s", errno, strerror(errno));
            reader->has_error = true;
            return READER_ERROR;
        } else {
            log_w("Capture stopped in the middle of a packet");
            return READER_EOF;
        }
    }

    // successfully read packet data
    memset(hdr, 0, sizeof(*hdr));
    hdr->ts.tv_sec = rec.ts_sec;
    hdr->ts.tv_usec = rec.ts_usec;
    hdr->len = size;
    hdr->uid = -1;
    hdr->linktype = reader->dlt;
    hdr->flags = PCAPD_FLAG_TX;

    // possibly retrieve the UID from the PCAPdroid trailer
    if ((reader->dlt == PCAPD_DLT_ETHERNET) && (size > (14 + sizeof(pcapdroid_trailer_t)))) {
        const struct pcapdroid_trailer* trailer =
                (const struct pcapdroid_trailer*) (buffer + size - sizeof(pcapdroid_trailer_t));

        if(ntohl(trailer->magic) == PCAPDROID_TRAILER_MAGIC) {
            hdr->uid = ntohl(trailer->uid);

            if (!reader->has_seen_dump_extensions) {
                reader->has_seen_dump_extensions = true;

                if (cb->on_dump_extensions_seen)
                    cb->on_dump_extensions_seen(userdata);
            }
        }
    }

    return READER_PACKET_OK;
}

static reader_rv read_enhanced_packet_block(pd_reader_t *reader, pcapd_hdr_t *hdr, char* buffer, pd_read_callbacks_t *cb, void *userdata) {
    pcapng_enh_packet_block_t enh;

    if (fread(&enh, sizeof(enh), 1, reader->fp) != 1) {
        log_e("Error reading the EPB block[%u]: %s", errno, strerror(errno));
        reader->has_error = true;
        return READER_ERROR;
    }

    if ((enh.total_length < sizeof(pcapng_enh_packet_block_t)) ||
        (enh.captured_len > enh.original_len) ||
        (enh.captured_len > (enh.total_length - sizeof(pcapng_enh_packet_block_t)))
    ) {
        log_e("Packet EPB block bad length: total=%u, captured=%u, orig=%u",
              enh.total_length, enh.captured_len, enh.original_len);
        errno = EINVAL;
        reader->has_error = true;
        return READER_ERROR;
    }

    // get capture interface
    uint32_t ifid = enh.interface_id;
    if (ifid >= reader->num_interfaces) {
        log_e("Unknown Pcapng interface: %u", ifid);
        reader->has_error = true;
        return READER_ERROR;
    }

    pcapng_intf_t* intf = &reader->interfaces[ifid];
    if (intf->dlt == 0) {
        // ignore packet from interface with unsupported linktype
        reader->has_unsupported_dlt_packets = true;
        return READER_CONTINUE;
    }

    int size = min(enh.captured_len, PCAPD_SNAPLEN);

    if (fread(buffer, size, 1, reader->fp) != 1) {
        if (ferror(reader->fp)) {
            log_e("Error reading the PCAP packed data[%d]: %s", errno, strerror(errno));
            reader->has_error = true;
            return READER_ERROR;
        } else {
            log_w("Capture stopped in the middle of a packet");
            return READER_EOF;
        }
    }

    // successfully read packet data
    uint64_t usec = ((uint64_t) enh.timestamp_high << 32) | enh.timestamp_low;

    memset(hdr, 0, sizeof(*hdr));
    hdr->ts.tv_sec = usec / 1000000;
    hdr->ts.tv_usec = usec % 1000000;
    hdr->len = size;
    hdr->uid = -1;
    hdr->linktype = intf->dlt;
    hdr->flags = PCAPD_FLAG_TX;
    hdr->ifid = intf->ifidx;

    // Possibly parse the UID
    uint8_t packet_padding = (~enh.captured_len + 1) & 0x3;
    int opts_offset = sizeof(enh) + enh.captured_len + packet_padding;
    int max_read = enh.total_length - opts_offset - 4 /* total size */;

    if (fseek(reader->fp, reader->cur_block_pos + opts_offset, SEEK_SET) == 0) {
        pcapng_enh_option_t opt;

        while ((max_read >= sizeof(opt)) &&
               fread(&opt, sizeof(opt), 1, reader->fp) == 1
        ) {
            if ((opt.code == 1) && (opt.length > 0)) { // comment
                char comment[16];

                size_t read_size = min(opt.length, sizeof(comment) - 1);
                if (fread(comment, read_size, 1, reader->fp) == 1) {
                    int parsed_length;
                    unsigned int uid;
                    comment[read_size] = '\0';

                    if ((sscanf(comment, "u-%u%n", &uid, &parsed_length) == 1) &&
                        (comment[parsed_length] == '\0')
                    ) {
                        // a previous UID mapping must be present
                        mapped_uid_t *item;
                        HASH_FIND_INT(reader->mapped_uids, &uid, item);

                        if (item) {
                            hdr->uid = uid;

                            if (!reader->has_seen_dump_extensions) {
                                reader->has_seen_dump_extensions = true;

                                if (cb->on_dump_extensions_seen)
                                    cb->on_dump_extensions_seen(userdata);
                            }
                        } else
                            log_w("Ignore UID without mapping: %u", uid);

                        break;
                    }
                }
            }

            int length_padded = opt.length + (uint8_t)((~opt.length + 1) & 0x3);
            max_read -= length_padded + sizeof(opt);
            fseek(reader->fp, length_padded, SEEK_CUR);
        }
    }

    return READER_PACKET_OK;
}

static reader_rv read_interface_description_block(pd_reader_t *reader) {
    pcapng_intf_descr_block_t idb;

    if (fread(&idb, sizeof(idb), 1, reader->fp) != 1) {
        log_e("Error reading the IDB block[%u]: %s", errno, strerror(errno));
        reader->has_error = true;
        return READER_ERROR;
    }

    int idx = reader->num_interfaces++;
    reader->interfaces = pd_realloc(reader->interfaces, reader->num_interfaces * sizeof(pcapng_intf_t));
    if (!reader->interfaces) {
        log_e("Allocating Pcapng interface failed");
        reader->has_error = true;
        return READER_ERROR;
    }

    pcapng_intf_t* intf = &reader->interfaces[idx];
    memset(intf, 0, sizeof(*intf));

    intf->dlt = linktype_to_dlt(idb.linktype);
    if (intf->dlt == 0)
        log_w("Pcapng interface #%d has unsupported linktype %d. Its packets will be ignored", idx, idb.linktype);

    // check if interface name is specified
    int max_read = idb.total_length - sizeof(idb) - 4 /* total size */;
    pcapng_enh_option_t opt;

    while ((max_read >= sizeof(opt)) &&
        fread(&opt, sizeof(opt), 1, reader->fp) == 1
    ) {
        if (opt.code == 2) { // if_name
            size_t read_size = min(opt.length, sizeof(intf->name) - 1);
            fread(intf->name, read_size, 1, reader->fp);
            intf->name[read_size] = '\0';
            break;
        }

        int length_padded = opt.length + (uint8_t)((~opt.length + 1) & 0x3);
        max_read -= length_padded + sizeof(opt);
        fseek(reader->fp, length_padded, SEEK_CUR);
    }

    if (intf->name[0] != '\0')
        // try to get the ifidx as well
        intf->ifidx = if_nametoindex(intf->name);
    else
        // fallback
        snprintf(intf->name, sizeof(intf->name), "if_%d", idx);

    log_d("Pcapng interface #%d: name=%s, linktype=%u\n", idx, intf->name, idb.linktype);
    return READER_CONTINUE;
}

static reader_rv read_uid_map_block(pd_reader_t *reader, pd_read_callbacks_t *cb, void *userdata) {
    pcapng_pd_uid_map_block_t umb;

    if (fread(&umb, sizeof(umb), 1, reader->fp) != 1) {
        log_e("Error reading UID mapping block[%u]: %s", errno, strerror(errno));
        reader->has_error = true;
        return READER_ERROR;
    }

    mapped_uid_t *item;
    HASH_FIND_INT(reader->mapped_uids, &umb.uid, item);
    if (item) {
        log_w("Ignoring already mapped UID: %u", umb.uid);
        return READER_CONTINUE;
    }

    item = pd_calloc(sizeof(mapped_uid_t), 1);
    item->uid = umb.uid;
    HASH_ADD_INT(reader->mapped_uids, uid, item);

    size_t needed_size = umb.package_name_len + umb.app_name_len + 2 /* NULL terminators */;
    if (!reserve_buffer(reader, needed_size))
        return READER_ERROR;

    char *package_name = (char *) reader->buffer;
    char *app_name = (char *) reader->buffer + umb.package_name_len + 1;

    if (fread(package_name, umb.package_name_len, 1, reader->fp) != 1) {
        log_e("Error reading package name[%u]: %s", errno, strerror(errno));
        reader->has_error = true;
        return READER_ERROR;
    }

    if (fread(app_name, umb.app_name_len, 1, reader->fp) != 1) {
        log_e("Error reading app name[%u]: %s", errno, strerror(errno));
        reader->has_error = true;
        return READER_ERROR;
    }

    package_name[umb.package_name_len] = '\0';
    app_name[umb.app_name_len] = '\0';

    if (cb->on_uid_mapping)
        cb->on_uid_mapping(userdata, umb.uid, package_name, app_name);

    return READER_CONTINUE;
}

static reader_rv read_dsb_block(pd_reader_t *reader, pd_read_callbacks_t *cb, void *userdata) {
    pcapng_decr_secrets_block_t dsb;

    if (fread(&dsb, sizeof(dsb), 1, reader->fp) != 1) {
        log_e("Error reading DSB block[%u]: %s", errno, strerror(errno));
        reader->has_error = true;
        return READER_ERROR;
    }

    if ((dsb.total_length < sizeof(pcapng_decr_secrets_block_t)) ||
        (dsb.secrets_length > (dsb.total_length - sizeof(pcapng_decr_secrets_block_t)))
    ) {
        log_e("DSB bad length: total=%u, secrets_length=%u",
              dsb.total_length, dsb.secrets_length);
        errno = EINVAL;
        reader->has_error = true;
        return READER_ERROR;
    }

    if ((dsb.secrets_type == 0x544c534b /* TLS_KEYLOG */) &&
        (dsb.secrets_length > 0) &&
        (cb->on_dsb_secrets != NULL)
    ) {
        uint32_t secrets_len = dsb.secrets_length;

        if (secrets_len <= MAX_DSB_SECRETS_LENGTH) {
            if (!reserve_buffer(reader, secrets_len))
                return READER_ERROR;

            if (fread(reader->buffer, secrets_len, 1, reader->fp) != 1) {
                log_e("Error reading the DSB secrets");
                return READER_ERROR;
            }

            cb->on_dsb_secrets(userdata, (const char *) reader->buffer, secrets_len);
        } else
            log_w("Invalid secrets length (%u), ignored", secrets_len);
    }

    return READER_CONTINUE;
}

static reader_rv read_pd_custom_block(pd_reader_t *reader, pd_read_callbacks_t *cb, void *userdata) {
    pcapng_pd_custom_block_t block;

    if (fread(&block, sizeof(block), 1, reader->fp) != 1) {
        log_e("Error reading custom block[%u]: %s", errno, strerror(errno));
        reader->has_error = true;
        return READER_ERROR;
    }

    if ((block.pen != PCAPDROID_PEN) || (block.version > PCAPDROID_PCAPNG_VERSION))
        // ignore unsupported
        return READER_CONTINUE;

    uint8_t block_type = block.type;

    if (fseek(reader->fp, reader->cur_block_pos, SEEK_SET))
        return READER_CONTINUE;

    if (block_type == PCAPDROID_BLOCK_UID_MAP)
        return read_uid_map_block(reader, cb, userdata);
    else
        log_w("Unsupported PCAPdroid extension block: type=%u, length=%u",
              block_type, block.total_length);

    return READER_CONTINUE;
}

static reader_rv pd_pcapng_read_next(pd_reader_t *reader, pcapd_hdr_t *hdr, char* buffer, pd_read_callbacks_t *cb, void *userdata) {
    while (!ferror(reader->fp)) {
        // position to the start of the next block
        long offset = reader->cur_block_pos + reader->cur_block_size;
        if (fseek(reader->fp, offset, SEEK_SET)) {
            log_e("Seek to %u failed[%d]: %s", offset, errno, strerror(errno));
            reader->has_error = true;
            return READER_ERROR;
        }

        reader->cur_block_pos += reader->cur_block_size;

        pcapng_generic_block_t block;
        if (fread(&block, sizeof(block), 1, reader->fp) != 1) {
            if (ferror(reader->fp)) {
                log_e("Error reading the next Pcapng block");
                reader->has_error = true;
                return READER_ERROR;
            } else
                return READER_EOF;
        }

        if (block.total_length < (sizeof(block) + 4 /* total length */)) {
            log_e("Invalid Block length: %u", block.total_length);
            errno = EINVAL;
            reader->has_error = true;
            return READER_ERROR;
        }

        //log_d("Block: %08x - %u B", block.type, block.total_length);
        uint32_t block_length = block.total_length;
        reader->cur_block_size = block_length;

        // seek back to the start of the block
        if (fseek(reader->fp, offset, SEEK_SET))
            continue;

        reader_rv rv;

        if (block.type == 0x00000006)
            rv = read_enhanced_packet_block(reader, hdr, buffer, cb, userdata);
        else if (block.type == 0x00000001)
            rv = read_interface_description_block(reader);
        else if (block.type == 0x0000000a)
            rv = read_dsb_block(reader, cb, userdata);
        else if (block.type == 0x00000bad)
            rv = read_pd_custom_block(reader, cb, userdata);
        else
            rv = READER_CONTINUE;

        if (rv != READER_CONTINUE)
            return rv;
    }

    reader->has_error = true;
    return READER_ERROR;
}

reader_rv pd_read_next(pd_reader_t *reader, pcapd_hdr_t *hdr, char* buffer, pd_read_callbacks_t *cb, void *userdata) {
    if (feof(reader->fp))
        return READER_EOF;

    if (reader->has_error || ferror(reader->fp))
        return READER_ERROR;

    if (reader->dump_format == PCAPNG_DUMP)
        return pd_pcapng_read_next(reader, hdr, buffer, cb, userdata);
    else
        return pd_pcap_read_next(reader, hdr, buffer, cb, userdata);
}

static void dump_dsb_secrets(void *userdata, const char *secrets, size_t length) {
    FILE *fout = (FILE*) userdata;

    if (fwrite(secrets, length, 1, fout) != 1)
        log_e("Error writing the KEYLOG file[%d]: %s", errno, strerror(errno));
}

bool pcapng_to_keylog(const char *pcapng_path, const char *out_path) {
    char* error = NULL;
    pd_reader_t* reader = pd_new_reader(pcapng_path, &error);

    if (!reader)
        return false;

    if (reader->dump_format != PCAPNG_DUMP) {
        log_e("Input file is not a Pcapng");
        pd_destroy_reader(reader);
        return false;
    }

    FILE *fout = fopen(out_path, "w");
    if (!fout) {
        pd_destroy_reader(reader);
        log_e("Open keylog failed[%d]: %s", errno, strerror(errno));
        return false;
    }

    pcapd_hdr_t hdr;
    char buffer[PCAPD_SNAPLEN];
    pd_read_callbacks_t cb = { .on_dsb_secrets = dump_dsb_secrets };
    reader_rv rv;

    // process all the blocks, DSB will be handled via the callbacks
    while (((rv = pd_read_next(reader, &hdr, buffer, &cb, fout)) == READER_PACKET_OK) &&
           (!ferror(fout)))
        ;

    fclose(fout);
    pd_destroy_reader(reader);
    return (rv == READER_EOF);
}

```

`app/src/main/jni/core/pcap_reader.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021-25 - Emanuele Faranda
 */

#ifndef __PCAPDROID_PCAP_READER_H__
#define __PCAPDROID_PCAP_READER_H__

/*
 * Module to read PCAP/Pcapng files.
 * It only supports captures created by the pcap_dump module on the same endianness.
 */

#include <stdint.h>
#include <stdbool.h>
#include <sys/types.h>

#include "pcapd/pcapd.h"
#include "pcap_dump.h"

typedef struct pd_reader pd_reader_t;

#define MAX_DSB_SECRETS_LENGTH       (1024*1024)        // 1 MB

typedef enum {
    READER_PACKET_OK,       // a packet was read successfully into the buffer
    READER_CONTINUE,        // continue reading next packet (internal use)
    READER_EOF,
    READER_ERROR
} reader_rv;

typedef struct pd_read_callbacks {
    void (*on_uid_mapping)(void *userdata, uid_t uid, const char *package_name, const char *app_name);
    void (*on_dump_extensions_seen)(void *userdata);
    void (*on_dsb_secrets)(void *userdata, const char *secrets, size_t length);
} pd_read_callbacks_t;

pd_reader_t* pd_new_reader(const char *fpath, char **error);
void pd_destroy_reader(pd_reader_t *reader);
pcap_dump_format_t pd_get_dump_format(pd_reader_t *reader);
bool pd_has_unsupported_dlt_packets(pd_reader_t *reader);
bool pd_has_seen_dump_extensions(pd_reader_t *reader);

/**
 * Read the next packet
 * @param hdr will be filled with header information on successful read
 * @param buffer must be of PCAPD_SNAPLEN size, will contain the packet data
 * @param cb a structure defining the possibly null callbacks
 * @param userdata opaque data passed to the callbacks
 */
reader_rv pd_read_next(pd_reader_t *reader, pcapd_hdr_t *hdr, char* buffer, pd_read_callbacks_t *cb, void *userdata);

/**
 * Read a Pcapng file and extract the SSL keylog into a file
 * @param pcapng_path the Pcapng to read
 * @param out_path the output keylog path
 */
bool pcapng_to_keylog(const char *pcapng_path, const char *out_path);

#endif

```

`app/src/main/jni/core/pcapdroid.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it wsetStatsill be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-25 - Emanuele Faranda
 */

#include <inttypes.h>
#include <assert.h> // NOTE: look for "assertion" in logcat
#include <pthread.h>
#include "pcapdroid.h"
#include "pcap_dump.h"
#include "common/utils.h"
#include "pcapd/pcapd.h"
#include "ndpi_protocol_ids.h"

extern int run_vpn(pcapdroid_t *pd);
extern int run_pcap(pcapdroid_t *pd);
extern void pcap_iter_connections(pcapdroid_t *pd, conn_cb cb);
extern void vpn_process_ndpi(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data);

/* ******************************************************* */

bool running = false;
uint32_t new_dns_server = 0;
bool block_private_dns = false;
bool has_seen_dump_extensions = false;

bool dump_capture_stats_now = false;
bool reload_blacklists_now = false;
int bl_num_checked_connections = 0;
int fw_num_checked_connections = 0;

char *pd_appver = (char*) "";
char *pd_device = (char*) "";
char *pd_os = (char*) "";

static ndpi_protocol_bitmask_struct_t masterProtos;
static bool masterProtosInit = false;

/* ******************************************************* */

/* NOTE: these must be reset during each run, as android may reuse the service */
static int netd_resolve_waiting;
static u_int64_t last_connections_dump;
static u_int64_t next_connections_dump;

/* ******************************************************* */

static void conn_free_ndpi(pd_conn_t *data) {
    if(data->ndpi_flow) {
        ndpi_free_flow(data->ndpi_flow);
        data->ndpi_flow = NULL;
    }
}

/* ******************************************************* */

uint16_t pd_ndpi2proto(ndpi_protocol nproto) {
    // The nDPI master/app protocol logic is not clear (e.g. the first packet of a DNS flow has
    // master_protocol unknown whereas the second has master_protocol set to DNS). We are not interested
    // in the app protocols, so just take the one that's not unknown.
    uint16_t l7proto = ((nproto.proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ?
            nproto.proto.master_protocol : nproto.proto.app_protocol);

    if((l7proto == NDPI_PROTOCOL_HTTP_CONNECT) || (l7proto == NDPI_PROTOCOL_HTTP_PROXY))
        l7proto = NDPI_PROTOCOL_HTTP;

    if(!masterProtosInit) {
        init_ndpi_protocols_bitmask(&masterProtos);
        masterProtosInit = true;
    }

    // nDPI will still return a disabled protocol (via the bitmask) if it matches some
    // metadata for it (e.g. the SNI)
    if(!NDPI_ISSET(&masterProtos, l7proto))
        l7proto = NDPI_PROTOCOL_UNKNOWN;

    //log_d("PROTO: %d/%d -> %d", proto.master_protocol, proto.app_protocol, l7proto);

    return l7proto;
}

/* ******************************************************* */

static bool is_encrypted_l7(struct ndpi_detection_module_struct *ndpi_str, uint16_t l7proto) {
    // The ndpi_is_encrypted_proto API does not work reliably as it mixes master protocols with apps
    if(l7proto >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))
        return false;

    ndpi_proto_defaults_t *proto_defaults = ndpi_get_proto_defaults(ndpi_str);
    return (proto_defaults && (proto_defaults[l7proto].isClearTextProto == 0));
}

/* ******************************************************* */

void pd_purge_connection(pcapdroid_t *pd, pd_conn_t *data) {
    if(!data)
        return;

    conn_free_ndpi(data);

    if(data->info)
        pd_free(data->info);
    if(data->url)
        pd_free(data->url);

#ifdef ANDROID
    if(data->payload_chunks)
        (*pd->env)->DeleteLocalRef(pd->env, data->payload_chunks);
#endif

    pd_free(data);
}

/* ******************************************************* */

static int notif_connection(pcapdroid_t *pd, conn_array_t *arr, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    // End the detection when the connection is closed
    // Always check this, even pending_notification are present
    if(data->status >= CONN_STATUS_CLOSED)
        pd_giveup_dpi(pd, data, tuple);

    if(data->pending_notification)
        return 0;

    if(arr->cur_items >= arr->size) {
        /* Extend array */
        arr->size = (arr->size == 0) ? 8 : (arr->size * 2);
        arr->items = pd_realloc(arr->items, arr->size * sizeof(conn_and_tuple_t));

        if(arr->items == NULL) {
            log_e("realloc(conn_array_t) (%d items) failed", arr->size);
            return -1;
        }
    }

    conn_and_tuple_t *slot = &arr->items[arr->cur_items++];
    slot->tuple = *tuple;
    slot->data = data;
    data->pending_notification = true;
    return 0;
}

/* Call this when the connection data has changed. The connection data will be sent to JAVA during the
 * next sendConnectionsDump. The type of change is determined by the data->update_type.
 * A negative value is returned if the connection update could not be enqueued. */
int pd_notify_connection_update(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    return notif_connection(pd, &pd->conns_updates, tuple, data);
}

/* ******************************************************* */

static void conns_clear(pcapdroid_t *pd, conn_array_t *arr, bool free_all) {
    if(arr->items) {
        for(int i=0; i < arr->cur_items; i++) {
            conn_and_tuple_t *slot = &arr->items[i];

            if(slot->data && (slot->data->to_purge || free_all))
                pd_purge_connection(pd, slot->data);
        }

        pd_free(arr->items);
        arr->items = NULL;
    }

    arr->size = 0;
    arr->cur_items = 0;
}

/* ******************************************************* */

char* get_appname_by_uid(pcapdroid_t *pd, int uid, char *buf, int bufsize) {
#ifdef ANDROID
    uid_to_app_t *app_entry;

    HASH_FIND_INT(pd->uid2app, &uid, app_entry);
    if(app_entry == NULL) {
        app_entry = (uid_to_app_t*) pd_malloc(sizeof(uid_to_app_t));

        if(app_entry) {
            // Resolve the app name
            getApplicationByUid(pd, uid, app_entry->appname, sizeof(app_entry->appname));

            log_d("uid %d resolved to \"%s\"", uid, app_entry->appname);

            app_entry->uid = uid;
            HASH_ADD_INT(pd->uid2app, uid, app_entry);
        }
    }
#else
    uid_to_app_t *app_entry = NULL;
#endif

    if(app_entry) {
        strncpy(buf, app_entry->appname, bufsize-1);
        buf[bufsize-1] = '\0';
    } else
        buf[0] = '\0';

    return buf;
}

/* ******************************************************* */

struct ndpi_detection_module_struct* init_ndpi() {
#ifdef FUZZING
    // nDPI initialization is very expensive, cache it
    // see also ndpi_exit_detection_module
    static struct ndpi_detection_module_struct *ndpi_cache = NULL;

    if(ndpi_cache != NULL)
      return ndpi_cache;
#endif

    struct ndpi_detection_module_struct *ndpi = ndpi_init_detection_module(NULL);
    NDPI_PROTOCOL_BITMASK protocols;

    if(!ndpi)
        return(NULL);

    // needed by pd_get_proto_name
    if(!masterProtosInit) {
        init_ndpi_protocols_bitmask(&masterProtos);
        masterProtosInit = true;
    }

#ifndef FUZZING
    // enable all the protocols
    NDPI_BITMASK_SET_ALL(protocols);
#else
    // nDPI has a big performance impact on fuzzing.
    // Only enable some protocols to extract the metadata for use in
    // PCAPdroid, we are not fuzzing nDPI!
    NDPI_BITMASK_RESET(protocols);
    NDPI_BITMASK_ADD(protocols, NDPI_PROTOCOL_DNS);
    NDPI_BITMASK_ADD(protocols, NDPI_PROTOCOL_HTTP);
    //NDPI_BITMASK_ADD(protocols, NDPI_PROTOCOL_TLS);
#endif

    ndpi_set_protocol_detection_bitmask2(ndpi, &protocols);

    ndpi_finalize_initialization(ndpi);

#ifdef FUZZING
    ndpi_cache = ndpi;
#endif

    return(ndpi);
}

/* ******************************************************* */

const char* pd_get_proto_name(pcapdroid_t *pd, uint16_t proto, uint16_t alpn, int ipproto) {
    if(proto == NDPI_PROTOCOL_UNKNOWN) {
        // Return the L3 protocol
        return zdtun_proto2str(ipproto);
    }

    if(proto == NDPI_PROTOCOL_TLS) {
        switch (alpn) {
            case NDPI_PROTOCOL_HTTP:
                return "HTTPS";
            case NDPI_PROTOCOL_MAIL_IMAP:
                return "IMAPS";
            case NDPI_PROTOCOL_MAIL_SMTP:
                return "SMTPS";
            default:
                // go on
                break;
        }
    }

    return ndpi_get_proto_name(pd->ndpi, proto);
}

/* ******************************************************* */

static void check_blacklisted_domain(pcapdroid_t *pd, pd_conn_t *data, const zdtun_5tuple_t *tuple) {
    if(data->info && data->info[0]) {
        if(pd->malware_detection.bl && !data->blacklisted_domain && !data->whitelisted_app) {
            bool blacklisted = blacklist_match_domain(pd->malware_detection.bl, data->info);
            if(blacklisted) {
                char appbuf[64];
                char buf[512];
                get_appname_by_uid(pd, data->uid, appbuf, sizeof(appbuf));

                // Check if whitelisted
                if(pd->malware_detection.whitelist && blacklist_match_domain(pd->malware_detection.whitelist, data->info))
                    log_d("Whitelisted domain [%s]: %s [%s]", data->info,
                          zdtun_5tuple2str(tuple, buf, sizeof(buf)), appbuf);
                else {
                    log_w("Blacklisted domain [%s]: %s [%s]", data->info,
                          zdtun_5tuple2str(tuple, buf, sizeof(buf)), appbuf);
                    data->blacklisted_domain = true;
                    data->to_block = true;
                }
            }
        }

        if(pd->firewall.enabled && pd->firewall.bl && !data->to_block) {
            // Check if the domain is explicitly blocked by the firewall
            data->to_block |= blacklist_match_domain(pd->firewall.bl, data->info);
            if(data->to_block) {
                char appbuf[64];
                char buf[512];

                get_appname_by_uid(pd, data->uid, appbuf, sizeof(appbuf));
                log_d("Blocked domain [%s]: %s [%s]", data->info, zdtun_5tuple2str(tuple, buf, sizeof(buf)), appbuf);
            }
        }
    }
}

/* ******************************************************* */

static void check_whitelist_mode_block(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    // whitelist mode: block any app unless it's explicitly whitelisted.
    // The blocklist still has priority to determine if a connection should be blocked.

    // NOTE: data->l7proto is not computed yet
    bool is_dns = (tuple->ipproto == IPPROTO_UDP) && (ntohs(tuple->dst_port) == 53);

    if(pd->firewall.enabled && pd->firewall.wl_enabled && pd->firewall.wl && !data->to_block &&
            // always allow DNS traffic from unspecified apps
            (!is_dns || ((data->uid != UID_NETD) && (data->uid != UID_PHONE) && (data->uid != UID_UNKNOWN))))
        data->to_block = !blacklist_match_uid(pd->firewall.wl, data->uid);
}

/* ******************************************************* */

pd_conn_t* pd_new_connection(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, int uid) {
    pd_conn_t *data = pd_calloc(1, sizeof(pd_conn_t));
    if(!data) {
        log_e("calloc(pd_conn_t) failed with code %d/%s",
                    errno, strerror(errno));
        return(NULL);
    }

    /* nDPI */
    if((data->ndpi_flow = ndpi_calloc(1, SIZEOF_FLOW_STRUCT)) == NULL) {
        log_e("ndpi_flow_malloc failed");
        pd_purge_connection(pd, data);
        return(NULL);
    }

    if(notif_connection(pd, &pd->new_conns, tuple, data) < 0) {
        pd_purge_connection(pd, data);
        return(NULL);
    }

    data->uid = uid;
    data->incr_id = pd->new_conn_id++;

    if(pd->malware_detection.whitelist) {
        // NOTE: if app is whitelisted, no need to check for blacklisted IP/domains
        data->whitelisted_app = blacklist_match_uid(pd->malware_detection.whitelist, uid);

        if(data->whitelisted_app) {
            char appbuf[64];
            char buf[256];
            get_appname_by_uid(pd, data->uid, appbuf, sizeof(appbuf));

            log_d("Whitelisted app: %s [%s]", zdtun_5tuple2str(tuple, buf, sizeof(buf)), appbuf);
        }
    }

    // Query country info
    const zdtun_ip_t dst_ip = tuple->dst_ip;
    char remote_ip[INET6_ADDRSTRLEN];
    int family = (tuple->ipver == 4) ? AF_INET : AF_INET6;

    remote_ip[0] = '\0';
    inet_ntop(family, &dst_ip, remote_ip, sizeof(remote_ip));

#ifdef ANDROID
    getCountryCode(pd, remote_ip, data->country_code);
#endif

    // Try to resolve host name via the LRU cache
    data->info = ip_lru_find(pd->ip_to_host, &dst_ip);

    if(data->info) {
        log_d("Host LRU cache HIT: %s -> %s", remote_ip, data->info);
        data->info_from_lru = true;

        if(data->uid != UID_UNKNOWN) {
            // When a DNS request is followed by a TLS connection or similar, mark the DNS request
            // with the uid of this connection. This allows us to match netd requests to actual apps.
            // Only change the uid of new connections (pd->new_conns) to avoid possible side effects
            for(int i=0; i < pd->new_conns.cur_items; i++) {
                conn_and_tuple_t *conn = &pd->new_conns.items[i];

                if((conn->data->uid == UID_NETD)
                        && (conn->data->info != NULL)
                        && (strcmp(conn->data->info, data->info) == 0)) {
                    char buf[256];

                    conn->data->uid = data->uid;

                    if(!conn->data->to_block && pd->firewall.enabled && pd->firewall.bl && (
                            blacklist_match_uid(pd->firewall.bl, conn->data->uid) ||
                            (pd->firewall.wl_enabled && pd->firewall.wl && !blacklist_match_uid(pd->firewall.wl, conn->data->uid))))
                        conn->data->netd_block_missed = true;

                    zdtun_5tuple2str(&conn->tuple, buf, sizeof(buf));
                    log_d("Resolved netd uid: %s : %d", buf, data->uid);

                    if(netd_resolve_waiting > 0) {
                        // If all the netd connections have been resolved, remove the dump delay
                        if((--netd_resolve_waiting) == 0) {
                            log_d("Removing netd resolution delay");
                            next_connections_dump -= NETD_RESOLVE_DELAY_MS;
                        }
                    }
                }
            }
        }

        check_blacklisted_domain(pd, data, tuple);
    }

    if(pd->malware_detection.bl) {
        if(!data->whitelisted_app) {
            bool blacklisted = blacklist_match_ip(pd->malware_detection.bl, &dst_ip, tuple->ipver);
            if (blacklisted) {
                char appbuf[64];
                char buf[256];
                get_appname_by_uid(pd, data->uid, appbuf, sizeof(appbuf));

                if(pd->malware_detection.whitelist && blacklist_match_ip(pd->malware_detection.whitelist, &dst_ip, tuple->ipver))
                    log_d("Whitelisted dst ip: %s [%s]", zdtun_5tuple2str(tuple, buf, sizeof(buf)),
                          appbuf);
                else {
                    log_w("Blacklisted dst ip: %s [%s]", zdtun_5tuple2str(tuple, buf, sizeof(buf)), appbuf);
                    data->blacklisted_ip = true;
                    data->to_block = true;
                }
            }
        }

        bl_num_checked_connections++;
    }

    if(pd->firewall.enabled && pd->firewall.bl && !data->to_block) {
        char appbuf[64];
        char buf[256];

        data->to_block |= blacklist_match_ip(pd->firewall.bl, &dst_ip, tuple->ipver);
        if(data->to_block) {
            get_appname_by_uid(pd, data->uid, appbuf, sizeof(appbuf));
            log_d("Blocked ip: %s [%s]", zdtun_5tuple2str(tuple, buf, sizeof(buf)), appbuf);
        }

        if(!data->to_block) {
            data->to_block = blacklist_match_uid(pd->firewall.bl, data->uid);
            if(data->to_block) {
                get_appname_by_uid(pd, data->uid, appbuf, sizeof(appbuf));
                log_d("Blocked app: %s [%s]", zdtun_5tuple2str(tuple, buf, sizeof(buf)), appbuf);
            }
        }

        if(!data->to_block) {
            data->to_block = blacklist_match_country(pd->firewall.bl, data->country_code);
            if(data->to_block) {
                get_appname_by_uid(pd, data->uid, appbuf, sizeof(appbuf));
                log_d("Blocked country \"%s\": %s [%s]", data->country_code,
                      zdtun_5tuple2str(tuple, buf, sizeof(buf)), appbuf);
            }
        }

        fw_num_checked_connections++;
    }

    check_whitelist_mode_block(pd, tuple, data);

    return(data);
}

/* ******************************************************* */

static bool is_numeric_host(const char *host) {
    if(isdigit(*host))
        return true;

    for(; *host; host++) {
        char ch = *host;

        if(ch == ':') // IPv6
            return true;
        if(ch == '.')
            break;
    }

    return false;
}

/* ******************************************************* */

static void process_ndpi_data(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    char *found_info = NULL;

    switch(data->l7proto) {
        case NDPI_PROTOCOL_TLS:
            // ALPN extension in client hello (https://datatracker.ietf.org/doc/html/rfc7301)
            if(!data->alpn && data->ndpi_flow->protos.tls_quic.negotiated_alpn) {
                if(strstr(data->ndpi_flow->protos.tls_quic.negotiated_alpn, "http/")) {
                    data->alpn = NDPI_PROTOCOL_HTTP;
                    data->update_type |= CONN_UPDATE_INFO;
                } else if(strstr(data->ndpi_flow->protos.tls_quic.negotiated_alpn, "imap")) {
                    data->alpn = NDPI_PROTOCOL_MAIL_IMAP;
                    data->update_type |= CONN_UPDATE_INFO;
                } else if(strstr(data->ndpi_flow->protos.tls_quic.negotiated_alpn, "smtp")) {
                    data->alpn = NDPI_PROTOCOL_MAIL_SMTP;
                    data->update_type |= CONN_UPDATE_INFO;
                } else {
                    log_d("Unknown ALPN: %s", data->ndpi_flow->protos.tls_quic.negotiated_alpn);
                    data->alpn = NDPI_PROTOCOL_TLS; // mark to avoid port-based guessing
                }
            }
            /* fallthrough */
        case NDPI_PROTOCOL_DNS:
            if(data->ndpi_flow->host_server_name[0])
                found_info = (char*)data->ndpi_flow->host_server_name;
            break;
        case NDPI_PROTOCOL_HTTP:
            if(data->ndpi_flow->host_server_name[0] &&
               !is_numeric_host((char*)data->ndpi_flow->host_server_name))
                found_info = (char*)data->ndpi_flow->host_server_name;

            if(!data->url && data->ndpi_flow->http.url) {
                data->url = pd_strndup(data->ndpi_flow->http.url, 256);
                data->update_type |= CONN_UPDATE_INFO;
            }

            break;
    }

    if(found_info && (!data->info || data->info_from_lru)) {
        if(data->info)
            pd_free(data->info);
        data->info = pd_strndup(found_info, 256);
        data->info_from_lru = false;

        check_blacklisted_domain(pd, data, tuple);
        data->update_type |= CONN_UPDATE_INFO;
    }

    if(pd->vpn_capture)
        vpn_process_ndpi(pd, tuple, data);
}

/* ******************************************************* */

/* Stop the DPI detection and determine the l7proto of the connection. */
void pd_giveup_dpi(pcapdroid_t *pd, pd_conn_t *data, const zdtun_5tuple_t *tuple) {
    if(!data->ndpi_flow)
        return;

    if(data->l7proto == NDPI_PROTOCOL_UNKNOWN) {
        uint8_t proto_guessed;
        struct ndpi_proto n_proto = ndpi_detection_giveup(pd->ndpi, data->ndpi_flow,
                              &proto_guessed);
        data->l7proto = pd_ndpi2proto(n_proto);
        data->encrypted_l7 = is_encrypted_l7(pd->ndpi, data->l7proto);
    }

    log_d("nDPI completed[pkts=%d, ipver=%d, proto=%d] -> l7proto: %d",
                data->sent_pkts + data->rcvd_pkts,
                tuple->ipver, tuple->ipproto, data->l7proto);

    process_ndpi_data(pd, tuple, data);
    conn_free_ndpi(data);
}

/* ******************************************************* */

// dumps the payload and returns true if fully dumped, false if failed or truncated
static bool dump_payload(pcapdroid_t *pd, pd_conn_t *conn, bool is_tx, uint64_t ms, uint32_t stream_id,
                         const char *to_dump, int dump_size)
{
    bool truncated = false;

    if((pd->payload_mode == PAYLOAD_MODE_MINIMAL) && (dump_size > MINIMAL_PAYLOAD_MAX_DIRECTION_SIZE)) {
        dump_size = MINIMAL_PAYLOAD_MAX_DIRECTION_SIZE;
        truncated = true;
    }

    if(pd->cb.dump_payload_chunk(pd, conn, is_tx, ms, stream_id, to_dump, dump_size))
        conn->has_payload[is_tx] = true;
    else
        truncated = true;

    return !truncated;
}

/* ******************************************************* */

static void process_payload(pcapdroid_t *pd, pkt_context_t *pctx) {
    const zdtun_pkt_t *pkt = pctx->pkt;
    pd_conn_t *data = pctx->data;
    bool truncated = data->payload_truncated;
    bool updated = false;

    if((pd->payload_mode == PAYLOAD_MODE_NONE) ||
       (pd->cb.dump_payload_chunk == NULL) ||
       (pkt->l7_len <= 0) ||
       (data->has_decrypted_data && !pctx->plain_data) ||
       (pd->tls_decryption.enabled && data->proxied)) // NOTE: when performing TLS decryption, TCP connections data is handled by the MitmReceiver
        return;

    if((pd->payload_mode != PAYLOAD_MODE_MINIMAL) || !data->has_payload[pctx->is_tx]) {
        if (pctx->plain_data) {
            // if there is plaintext (decrypted) data, dump it instead of the encrypted data
            if (!data->has_decrypted_data) {
                // existing chunks are encrypted, so drop them
                if (pd->cb.clear_payload_chunks)
                    pd->cb.clear_payload_chunks(pd, pctx);
                data->has_decrypted_data = true;
            }

            truncated = false;

            for (unsigned int i = 0; i < pctx->plain_data->n_items; i++) {
                const plain_data_item_t *item =  &pctx->plain_data->items[i];

                // use the item is_tx and ms timestamp data, rather than the ones from pctx because
                // http2.c may buffer http responses/resets so they may be processed with a different pctx
                truncated |= !dump_payload(pd, pctx->data, item->is_tx, item->ms, item->stream_id,
                                           (const char*) item->data, (int) item->data_length);
            }
        } else
            truncated = !dump_payload(pd, pctx->data, pctx->is_tx, pctx->ms, 0, pkt->l7, pkt->l7_len);

        updated = true;
    } else
        truncated = true;

    if((updated && data->payload_chunks) || (truncated != data->payload_truncated)) {
        data->payload_truncated |= truncated;
        data->update_type |= CONN_UPDATE_PAYLOAD;
        pd_notify_connection_update(pd, pctx->tuple, data);
    }
}

/* ******************************************************* */

static void process_dns_reply(pd_conn_t *data, pcapdroid_t *pd, const struct zdtun_pkt *pkt) {
    const char *query = (const char*) data->ndpi_flow->host_server_name;

    if((!query[0]) || !strchr(query, '.') || (pkt->l7_len < sizeof(dns_packet_t)))
        return;

    dns_packet_t *dns = (dns_packet_t*)pkt->l7;

    if(((ntohs(dns->flags) & 0x8000) == 0x8000) && (dns->questions != 0) && (dns->answ_rrs != 0)) {
        u_char *reply = dns->queries;
        int len = pkt->l7_len - sizeof(dns_packet_t);
        int num_queries = ntohs(dns->questions);
        int num_replies = min(ntohs(dns->answ_rrs), 32);

        // Skip queries
        for(int i=0; (i<num_queries) && (len > 0); i++) {
            while((len > 0) && (*reply != '\0')) {
                reply++;
                len--;
            }

            reply += 5; len -= 5;
        }

        for(int i=0; (i<num_replies) && (len > 0); i++) {
            int ipver = 0;
            zdtun_ip_t rsp_addr = {0};

            // Skip name
            while(len > 0) {
                if(*reply == 0x00) {
                    reply++; len--;
                    break;
                } else if(*reply == 0xc0) {
                    reply+=2; len-=2;
                    break;
                }

                reply++; len--;
            }

            if(len < 10)
                return;

            uint16_t rec_type = ntohs((*(uint16_t*)reply));
            uint16_t addr_len = ntohs((*(uint16_t*)(reply + 8)));
            reply += 10; len -= 10;

            if (len < addr_len)
                return;

            if((rec_type == 0x1) && (addr_len == 4)) { // A record
                ipver = 4;
                rsp_addr.ip4 = *((u_int32_t*)reply);
            } else if((rec_type == 0x1c) && (addr_len == 16)) { // AAAA record
                ipver = 6;
                memcpy(&rsp_addr.ip6, reply, 16);
            }

            if(ipver != 0) {
                char rspip[INET6_ADDRSTRLEN];
                int family = (ipver == 4) ? AF_INET : AF_INET6;

                rspip[0] = '\0';
                inet_ntop(family, &rsp_addr, rspip, sizeof(rspip));

                log_d("Host LRU cache ADD [v%d]: %s -> %s", ipver, rspip, query);
                ip_lru_add(pd->ip_to_host, &rsp_addr, query);
            }

            reply += addr_len; len -= addr_len;
        }
    }
}

/* ******************************************************* */

static void perform_dpi(pcapdroid_t *pd, pkt_context_t *pctx) {
    pd_conn_t *data = pctx->data;
    bool giveup = ((data->sent_pkts + data->rcvd_pkts + 1) >= MAX_DPI_PACKETS);
    zdtun_pkt_t *pkt = pctx->pkt;
    bool is_tx = pctx->is_tx;

    uint16_t old_proto = data->l7proto;
    struct ndpi_proto n_proto = ndpi_detection_process_packet(pd->ndpi, data->ndpi_flow, (const u_char *)pkt->buf,
                                  pkt->len, data->last_seen, NULL);
    data->l7proto = pd_ndpi2proto(n_proto);

    if(old_proto != data->l7proto) {
        data->update_type |= CONN_UPDATE_INFO;
        data->encrypted_l7 = is_encrypted_l7(pd->ndpi, data->l7proto);
    }

    if(!is_tx && (data->l7proto == NDPI_PROTOCOL_DNS))
        process_dns_reply(data, pd, pkt);

    if(giveup || ((data->l7proto != NDPI_PROTOCOL_UNKNOWN) &&
            !ndpi_extra_dissection_possible(pd->ndpi, data->ndpi_flow)))
        pd_giveup_dpi(pd, data, &pkt->tuple); // calls process_ndpi_data
    else
        process_ndpi_data(pd, &pkt->tuple, data);

    if((data->l7proto == NDPI_PROTOCOL_DNS)
       && (data->uid == UID_NETD)
       && (data->sent_pkts + data->rcvd_pkts == 0)
       && ((netd_resolve_waiting > 0) || ((next_connections_dump - NETD_RESOLVE_DELAY_MS) < pd->now_ms))) {
        if(netd_resolve_waiting == 0) {
            // Wait before sending the dump to possibly resolve netd DNS connections uid.
            // Only delay for the first DNS request, to avoid excessive delay.
            log_d("Adding netd resolution delay");
            next_connections_dump += NETD_RESOLVE_DELAY_MS;
        }
        netd_resolve_waiting++;
    }

    if(!data->ndpi_flow) {
        // nDPI detection complete
        if((data->l7proto == NDPI_PROTOCOL_TLS) && (!data->alpn)) {
            if(ntohs(pctx->tuple->dst_port) == 443)
                data->alpn = NDPI_PROTOCOL_HTTP; // assume HTTPS
            else if(data->info && !strncmp(data->info, "imap.", 5))
                data->alpn = NDPI_PROTOCOL_MAIL_IMAP; // assume IMAPS
            else if(data->info && !strncmp(data->info, "smtp.", 5))
                data->alpn = NDPI_PROTOCOL_MAIL_SMTP; // assume SMTPS

            if(data->alpn) {
                data->update_type |= CONN_UPDATE_INFO;
                pd_notify_connection_update(pd, pctx->tuple, data);
            }
        }
    }
}

/* ******************************************************* */

#ifdef PCAPDROID_TRACK_ALLOCS

static char allocs_buf[1024];

char* get_allocs_summary() {
    char b1[16], b2[16], b3[16], b4[16];

    snprintf(allocs_buf, sizeof(allocs_buf),
             "*** Allocs Summary ***\n"
             "  PCAPdroid: %s\n"
             "  nDPI: %s\n"
             "  Blacklist (domains): %s\n"
             "  UTHash: %s\n",
             humanSize(b1, 32, memtrack.scopes[MEMTRACK_PCAPDROID]),
             humanSize(b2, 32, memtrack.scopes[MEMTRACK_NDPI]),
             humanSize(b3, 32, memtrack.scopes[MEMTRACK_BLACKLIST]),
             humanSize(b4, 32, memtrack.scopes[MEMTRACK_UTHASH]));
    return allocs_buf;
}

#endif

/* ******************************************************* */

const char* get_cache_path(pcapdroid_t *pd, const char *subpath) {
    strncpy(pd->cachedir + pd->cachedir_len, subpath,
            sizeof(pd->cachedir) - pd->cachedir_len - 1);
    pd->cachedir[sizeof(pd->cachedir) - 1] = 0;
    return pd->cachedir;
}

/* ******************************************************* */

const char* get_file_path(pcapdroid_t *pd, const char *subpath) {
    strncpy(pd->filesdir + pd->filesdir_len, subpath,
            sizeof(pd->filesdir) - pd->filesdir_len - 1);
    pd->filesdir[sizeof(pd->filesdir) - 1] = 0;
    return pd->filesdir;
}

/* ******************************************************* */

// called after load_new_blacklists
static void use_new_blacklists(pcapdroid_t *pd) {
    if(!pd->malware_detection.new_bl)
        return;

    if(pd->malware_detection.bl)
        blacklist_destroy(pd->malware_detection.bl);
    pd->malware_detection.bl = pd->malware_detection.new_bl;
    pd->malware_detection.new_bl = NULL;

    bl_status_arr_t *status_arr = pd->malware_detection.status_arr;
    pd->malware_detection.status_arr = NULL;

    if(status_arr == NULL) {
        // NOTE: must notify even if status_arr is NULL
        status_arr = pd_calloc(0, sizeof(bl_status_arr_t));

        if(!status_arr) // this should never happen
            return;
    }

    if(pd->cb.notify_blacklists_loaded)
        pd->cb.notify_blacklists_loaded(pd, status_arr);

    for(int i = 0; i < status_arr->cur_items; i++) {
        bl_status_t *st = &status_arr->items[i];
        pd_free(st->fname);
    }
    pd_free(status_arr->items);
    pd_free(status_arr);
}

/* ******************************************************* */

// Loads the blacklists data into new_bl and sets reload_done.
// use_new_blacklists needs to be called to use it.
static void* load_new_blacklists(void *data) {
    pcapdroid_t *pd = (pcapdroid_t*) data;
    bl_status_arr_t *status_arr = pd_calloc(1, sizeof(bl_status_arr_t));
    if(!status_arr) {
        pd->malware_detection.reload_done = true;
        return NULL;
    }

    blacklist_t *bl = blacklist_init();
    if(!bl) {
        pd_free(status_arr);
        pd->malware_detection.reload_done = true;
        return NULL;
    }

    clock_t start = clock();

    // load files in the malware_bl directory
    for(int i = 0; i < pd->malware_detection.num_bls; i++) {
        bl_info_t *blinfo = &pd->malware_detection.bls_info[i];
        char subpath[256];
        blacklist_stats_t stats;

        snprintf(subpath, sizeof(subpath), "malware_bl/%s", blinfo->fname);

        if(blacklist_load_file(bl, get_file_path(pd, subpath), blinfo->type, &stats) == 0) {
            // NOTE: cannot invoke JNI from this thread, must use an intermediate storage
            if(status_arr->size >= status_arr->cur_items) {
                /* Extend array */
                status_arr->size = (status_arr->size == 0) ? 8 : (status_arr->size * 2);
                status_arr->items = pd_realloc(status_arr->items, status_arr->size * sizeof(bl_status_t));
                if(!status_arr->items) {
                    log_e("realloc(bl_status_arr_t) (%d items) failed", status_arr->size);
                    status_arr->size = 0;
                    continue;
                }
            }

            char *fname = pd_strdup(blinfo->fname);
            if(!fname)
                continue;

            bl_status_t *status = &status_arr->items[status_arr->cur_items++];
            status->fname = fname;
            status->num_rules = stats.num_rules;
        }
    }

    // Test domain/IP to test blacklist match
    blacklist_add_domain(bl, "internetbadguys.com");
    blacklist_add_ipstr(bl, "0.0.0.1");

    log_d("Blacklists loaded in %.3f sec", ((double) (clock() - start)) / CLOCKS_PER_SEC);

    pd->malware_detection.new_bl = bl;
    pd->malware_detection.status_arr = status_arr;
    pd->malware_detection.reload_done = true;
    return NULL;
}

/* ******************************************************* */

struct iter_conn_data {
    pcapdroid_t *pd;
    conn_cb cb;
};

static int zdtun_iter_adapter(zdtun_t *zdt, const zdtun_conn_t *conn_info, void *data) {
    struct iter_conn_data *idata = (struct iter_conn_data*) data;
    const zdtun_5tuple_t *tuple = zdtun_conn_get_5tuple(conn_info);
    pd_conn_t *conn = zdtun_conn_get_userdata(conn_info);

    return idata->cb(idata->pd, tuple, conn);
}

static void iter_active_connections(pcapdroid_t *pd, conn_cb cb) {
    if(!pd->vpn_capture)
        pcap_iter_connections(pd, cb);
    else {
        struct iter_conn_data idata = {
                .pd = pd,
                .cb = cb,
        };
        zdtun_iter_connections(pd->zdt, zdtun_iter_adapter, &idata);
    }
}

/* ******************************************************* */

static int check_blocked_conn_cb(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    zdtun_ip_t dst_ip = tuple->dst_ip;
    blacklist_t *fw_bl = pd->firewall.bl;
    bool old_block = data->to_block;

    data->to_block = (data->blacklisted_internal || data->blacklisted_ip || data->blacklisted_domain);
    if(!data->to_block && pd->firewall.enabled && fw_bl) {
        data->to_block = blacklist_match_uid(fw_bl, data->uid) ||
                         blacklist_match_ip(fw_bl, &dst_ip, tuple->ipver) ||
                         (data->info && data->info[0] && blacklist_match_domain(fw_bl, data->info));
    }

    check_whitelist_mode_block(pd, tuple, data);

    if(old_block != data->to_block) {
        data->update_type |= CONN_UPDATE_STATS;
        pd_notify_connection_update(pd, tuple, data);
    }

    // continue
    return 0;
}

/* ******************************************************* */

// Check if a previously blacklisted connection is now whitelisted
static int check_blacklisted_conn_cb(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data) {
    blacklist_t *whitelist = pd->malware_detection.whitelist;
    bool changed = false;

    data->whitelisted_app = blacklist_match_uid(whitelist, data->uid);

    if(data->blacklisted_ip) {
        const zdtun_ip_t dst_ip = tuple->dst_ip;
        if(data->whitelisted_app || blacklist_match_ip(whitelist, &dst_ip, tuple->ipver)) {
            data->blacklisted_ip = false;
            changed = true;
        }
    }

    if(data->blacklisted_domain &&
            (data->whitelisted_app || blacklist_match_domain(whitelist, data->info))) {
        data->blacklisted_domain = false;
        changed = true;
    }

    if(changed) {
        // Possibly unblock the connection
        if(pd->firewall.bl)
            check_blocked_conn_cb(pd, tuple, data);

        data->update_type |= CONN_UPDATE_STATS;
        pd_notify_connection_update(pd, tuple, data);
    }

    // continue
    return 0;
}

/* ******************************************************* */

static void stop_pcap_dump(pcapdroid_t *pd) {
    pcap_destroy_dumper(pd->pcap_dump.dumper);
    pd->pcap_dump.dumper = NULL;

    if(pd->cb.stop_pcap_dump)
        pd->cb.stop_pcap_dump(pd);
}

/* ******************************************************* */

/* Perfom periodic tasks. This should be called after processing a packet or after some time has
 * passed (e.g. after a select with no packet). */
void pd_housekeeping(pcapdroid_t *pd) {
    if(dump_capture_stats_now ||
            (pd->capture_stats.new_stats && ((pd->now_ms - pd->capture_stats.last_update_ms) >= CAPTURE_STATS_UPDATE_FREQUENCY_MS))) {
        dump_capture_stats_now = false;
        //log_d("Send stats");

        if(pd->vpn_capture)
            zdtun_get_stats(pd->zdt, &pd->stats);

        if(pd->cb.send_stats_dump)
            pd->cb.send_stats_dump(pd);

        pd->capture_stats.new_stats = false;
        pd->capture_stats.last_update_ms = pd->now_ms;
    } else if (pd->now_ms >= next_connections_dump) {
        /*log_d("sendConnectionsDump [after %" PRIu64 " ms]: new=%d, updates=%d",
              pd->now_ms - last_connections_dump,
              pd->new_conns.cur_items, pd->conns_updates.cur_items);*/

        if ((pd->new_conns.cur_items != 0) || (pd->conns_updates.cur_items != 0)) {
            if (pd->cb.send_connections_dump)
                pd->cb.send_connections_dump(pd);
            conns_clear(pd, &pd->new_conns, false);
            conns_clear(pd, &pd->conns_updates, false);
        }

        last_connections_dump = pd->now_ms;
        next_connections_dump = pd->now_ms + CONNECTION_DUMP_UPDATE_FREQUENCY_MS;
        netd_resolve_waiting = 0;
    } else if(pd->pcap_dump.dumper && pcap_check_export(pd->pcap_dump.dumper))
        ;
    else if(pd->malware_detection.enabled) {
        // Malware detection
        if(pd->malware_detection.reload_in_progress) {
            if(pd->malware_detection.reload_done) {
                pthread_join(pd->malware_detection.reload_worker, NULL);
                pd->malware_detection.reload_in_progress = false;
                use_new_blacklists(pd);
            }
        } else if(reload_blacklists_now) {
            reload_blacklists_now = false;
            pd->malware_detection.reload_done = false;
            pd->malware_detection.new_bl = NULL;
            pd->malware_detection.status_arr = NULL;
            pthread_create(&pd->malware_detection.reload_worker, NULL, load_new_blacklists,
                           pd);
            pd->malware_detection.reload_in_progress = true;
        }
    }

    if(pd->malware_detection.new_wl) {
        // Load new whitelist
        if(pd->malware_detection.whitelist)
            blacklist_destroy(pd->malware_detection.whitelist);
        pd->malware_detection.whitelist = pd->malware_detection.new_wl;
        pd->malware_detection.new_wl = NULL;

        // Check the active (blacklisted) connections to possibly whitelist (and unblock) them
        iter_active_connections(pd, check_blacklisted_conn_cb);
    }

    if(pd->firewall.new_bl) {
        // Load new blocklist
        if(pd->firewall.bl)
            blacklist_destroy(pd->firewall.bl);
        pd->firewall.bl = pd->firewall.new_bl;
        pd->firewall.new_bl = NULL;
        iter_active_connections(pd, check_blocked_conn_cb);
    } else if(pd->firewall.new_wl) {
        // Load new whitelist
        if(pd->firewall.wl)
            blacklist_destroy(pd->firewall.wl);
        pd->firewall.wl = pd->firewall.new_wl;
        pd->firewall.new_wl = NULL;
        iter_active_connections(pd, check_blocked_conn_cb);
    }

    if(pd->tls_decryption.new_list) {
        // Load new whitelist
        if(pd->tls_decryption.list)
            blacklist_destroy(pd->tls_decryption.list);
        pd->tls_decryption.list = pd->tls_decryption.new_list;
        pd->tls_decryption.new_list = NULL;
    }
}

/* ******************************************************* */

/* Refresh the monotonic time. This must be called before any call to pd_housekeeping. */
void pd_refresh_time(pcapdroid_t *pd) {
    struct timespec ts;

    if(clock_gettime(CLOCK_MONOTONIC_COARSE, &ts)) {
        log_d("clock_gettime failed[%d]: %s", errno, strerror(errno));
        return;
    }

    pd->now_ms = (uint64_t)ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
}

/* ******************************************************* */

void pd_init_pkt_context(pkt_context_t *pctx,
                         zdtun_pkt_t *pkt, bool is_tx, const zdtun_5tuple_t *tuple,
                         pd_conn_t *data, struct timeval *tv
) {
    pctx->pkt = pkt;
    pctx->tv = *tv;
    pctx->ms = (uint64_t)tv->tv_sec * 1000 + tv->tv_usec / 1000;
    pctx->is_tx = is_tx;
    pctx->tuple = tuple;
    pctx->data = data;
    pctx->plain_data = NULL; // managed by capture_libpcap
}

/* ******************************************************* */

/* Process the packet (e.g. perform DPI) and fill the packet context. */
void pd_process_packet(pcapdroid_t *pd, pkt_context_t *pctx) {
    pd_conn_t *data = pctx->data;
    zdtun_pkt_t *pkt = pctx->pkt;

    // NOTE: pd_account_stats will not be called for blocked connections
    data->last_seen = pctx->ms;
    if(!data->first_seen)
        data->first_seen = pctx->ms;

    if(data->ndpi_flow &&
       (!(pkt->flags & ZDTUN_PKT_IS_FRAGMENT) || (pkt->flags & ZDTUN_PKT_IS_FIRST_FRAGMENT))) {
        // nDPI cannot handle fragments, since they miss the L4 layer (see ndpi_iph_is_valid_and_not_fragmented)
        perform_dpi(pd, pctx);
    }

    if (pctx->plain_data && (data->alpn != NDPI_PROTOCOL_UNKNOWN) && (data->alpn != pctx->data->l7proto)) {
        // we have the L7 decrypted data
        pd_giveup_dpi(pd, data, pctx->tuple);
        pctx->data->l7proto = data->alpn;

        data->update_type |= CONN_UPDATE_INFO;
        pd_notify_connection_update(pd, pctx->tuple, data);
    }

    process_payload(pd, pctx);
}

/* ******************************************************* */

void pd_dump_packet(pcapdroid_t *pd, const char *pktbuf, int pktlen, const struct timeval *tv, int uid, u_int ifidx) {
    if(!pd->pcap_dump.dumper)
        return;

    if(!pcap_dump_packet(pd->pcap_dump.dumper, pktbuf, pktlen, tv, uid, ifidx))
        stop_pcap_dump(pd);
}

/* ******************************************************* */

/* Update the stats for the current packet and dump it if requested. */
void pd_account_stats(pcapdroid_t *pd, pkt_context_t *pctx) {
    zdtun_pkt_t *pkt = pctx->pkt;
    pd_conn_t *data = pctx->data;

    data->payload_length += pkt->l7_len;

    if(pctx->is_tx) {
        data->sent_pkts++;
        data->sent_bytes += pkt->len;
        pd->capture_stats.sent_pkts++;
        pd->capture_stats.sent_bytes += pkt->len;
        if(pkt->tuple.ipver == 6) {
            pd->capture_stats.ipv6_sent_bytes += pkt->len;
        }
    } else {
        data->rcvd_pkts++;
        data->rcvd_bytes += pkt->len;
        pd->capture_stats.rcvd_pkts++;
        pd->capture_stats.rcvd_bytes += pkt->len;
        if(pkt->tuple.ipver == 6) {
            pd->capture_stats.ipv6_rcvd_bytes += pkt->len;
        }
    }

    /* New stats to notify */
    pd->capture_stats.new_stats = true;
    data->update_type |= CONN_UPDATE_STATS;
    pd_notify_connection_update(pd, pctx->tuple, pctx->data);

    if((pd->pcap_dump.dumper) &&
            ((pd->pcap_dump.max_pkts_per_flow <= 0) ||
                ((data->sent_pkts + data->rcvd_pkts) <= pd->pcap_dump.max_pkts_per_flow))) {
        u_int ifidx = !pd->vpn_capture ? pctx->data->pcap.ifidx : 0;
        pd_dump_packet(pd, pkt->buf, pkt->len, &pctx->tv, pctx->data->uid, ifidx);
    }
}

/* ******************************************************* */

int pd_run(pcapdroid_t *pd) {
    /* Important: init global state every time. Android may reuse the service. */
    running = true;
    has_seen_dump_extensions = false;
    netd_resolve_waiting = 0;

    /* nDPI */
    pd->ndpi = init_ndpi();
    if(pd->ndpi == NULL) {
        log_f("nDPI initialization failed");
        return(-1);
    }

    pd->ip_to_host = ip_lru_init(MAX_HOST_LRU_SIZE);

    if(pd->malware_detection.enabled && pd->cb.load_blacklists_info)
        pd->cb.load_blacklists_info(pd);

    // Load the blacklist before starting
    if(pd->malware_detection.enabled && reload_blacklists_now) {
        reload_blacklists_now = false;
        load_new_blacklists(pd);
        use_new_blacklists(pd);
    }

    if(pd->pcap_dump.enabled) {
        int max_snaplen = !pd->vpn_capture ? PCAPD_SNAPLEN : VPN_BUFFER_SIZE;

        // use the snaplen provided by the API
        if((pd->pcap_dump.snaplen <= 0) || (pd->pcap_dump.snaplen > max_snaplen))
            pd->pcap_dump.snaplen = max_snaplen;

        pcap_dump_format_t dump_fmt = pd->pcap_dump.pcapng_format ? PCAPNG_DUMP : PCAP_DUMP;
        bool dump_extensions = pd->pcap_dump.dump_extensions;

        log_d("dump_mode: %d - extensions: %u", dump_fmt, dump_extensions);
        pd->pcap_dump.dumper = pcap_new_dumper(dump_fmt, dump_extensions,
                                               pd->pcap_dump.snaplen,
                                               pd->pcap_dump.max_dump_size,
                                               pd->cb.send_pcap_dump, pd);
        if(!pd->pcap_dump.dumper) {
            log_f("Could not initialize the PCAP dumper");
            running = false;
        }
    }

    memset(&pd->stats, 0, sizeof(pd->stats));

    pd_refresh_time(pd);
    last_connections_dump = pd->now_ms;
    next_connections_dump = last_connections_dump + 500 /* first update after 500 ms */;
    bl_num_checked_connections = 0;
    fw_num_checked_connections = 0;

    // Run the capture
    int rv = pd->vpn_capture ? run_vpn(pd) : run_pcap(pd);

    log_i("Stopped packet loop");

    // send last dump
    if(pd->cb.send_stats_dump)
        pd->cb.send_stats_dump(pd);
    if(pd->cb.send_connections_dump)
        pd->cb.send_connections_dump(pd);

    conns_clear(pd, &pd->new_conns, true);
    conns_clear(pd, &pd->conns_updates, true);

    if(pd->firewall.bl)
        blacklist_destroy(pd->firewall.bl);
    if(pd->firewall.new_bl)
        blacklist_destroy(pd->firewall.new_bl);
    if(pd->firewall.wl)
        blacklist_destroy(pd->firewall.wl);
    if(pd->firewall.new_wl)
        blacklist_destroy(pd->firewall.new_wl);
    if(pd->tls_decryption.list)
        blacklist_destroy(pd->tls_decryption.list);
    if(pd->tls_decryption.new_list)
        blacklist_destroy(pd->tls_decryption.new_list);

    if(pd->malware_detection.enabled) {
        if(pd->malware_detection.reload_in_progress) {
            log_i("Joining blacklists reload_worker");
            pthread_join(pd->malware_detection.reload_worker, NULL);
        }
        if(pd->malware_detection.bl)
            blacklist_destroy(pd->malware_detection.bl);
        if(pd->malware_detection.whitelist)
            blacklist_destroy(pd->malware_detection.whitelist);
        if(pd->malware_detection.new_wl)
            blacklist_destroy(pd->malware_detection.new_wl);
        if(pd->malware_detection.bls_info) {
            for(int i=0; i < pd->malware_detection.num_bls; i++)
                pd_free(pd->malware_detection.bls_info[i].fname);
            pd_free(pd->malware_detection.bls_info);
        }
    }

#ifndef FUZZING
    ndpi_exit_detection_module(pd->ndpi);
#endif

    if(pd->pcap_dump.dumper)
        stop_pcap_dump(pd);

    uid_to_app_t *e, *tmp;
    HASH_ITER(hh, pd->uid2app, e, tmp) {
        HASH_DEL(pd->uid2app, e);
        pd_free(e);
    }

    log_i("Host LRU cache size: %d", ip_lru_size(pd->ip_to_host));
    log_i("Discarded fragments: %ld", pd->num_discarded_fragments);
    ip_lru_destroy(pd->ip_to_host);

    return(rv);
}

```

`app/src/main/jni/core/pcapdroid.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-24 - Emanuele Faranda
 */

#ifndef __PCAPDROID_H__
#define __PCAPDROID_H__

#include <stdbool.h>
#include "zdtun.h"
#include "ip_lru.h"
#include "blacklist.h"
#include "pcap_dump.h"
#include "ndpi_api.h"
#include "common/jni_utils.h"
#include "common/uid_resolver.h"
#include "third_party/uthash.h"

#define CAPTURE_STATS_UPDATE_FREQUENCY_MS 300
#define CONNECTION_DUMP_UPDATE_FREQUENCY_MS 1000
#define NETD_RESOLVE_DELAY_MS 1000
#define SELECT_TIMEOUT_MS 250
#define MAX_DPI_PACKETS 12
#define VPN_BUFFER_SIZE 32768
#define MAX_HOST_LRU_SIZE 256
#define PERIODIC_PURGE_TIMEOUT_MS 5000
#define MINIMAL_PAYLOAD_MAX_DIRECTION_SIZE 512

#define DNS_FLAGS_MASK 0x8000
#define DNS_TYPE_REQUEST 0x0000
#define DNS_TYPE_RESPONSE 0x8000

#define CONN_UPDATE_STATS   0x1
#define CONN_UPDATE_INFO    0x2
#define CONN_UPDATE_PAYLOAD 0x4

typedef struct {
    jlong sent_bytes;
    jlong rcvd_bytes;
    jlong ipv6_sent_bytes;
    jlong ipv6_rcvd_bytes;
    jint sent_pkts;
    jint rcvd_pkts;

    bool new_stats;
    u_int64_t last_update_ms;
} capture_stats_t;

// NOTE: sync with Prefs.PayloadMode
typedef enum {
    PAYLOAD_MODE_NONE = 0,
    PAYLOAD_MODE_MINIMAL,
    PAYLOAD_MODE_FULL
} payload_mode_t;

// NOTE: sync with Prefs.BlockQuicMode
typedef enum {
    BLOCK_QUIC_MODE_NEVER = 0,
    BLOCK_QUIC_MODE_ALWAYS,
    BLOCK_QUIC_MODE_TO_DECRYPT
} block_quic_mode_t;

typedef struct {
    jint incr_id; // an incremental number which identifies a specific connection

    /* nDPI */
    struct ndpi_flow_struct *ndpi_flow;
    struct ndpi_id_struct *src_id, *dst_id;
    uint16_t l7proto;
    uint16_t alpn;

    union {
        struct {
            uint64_t last_update_ms; // like last_seen but monotonic
            u_int ifidx;             // the 1-based interface index
        } pcap;
        struct {
            struct pkt_context *fw_pctx; // context for the forwarded packet
            uint16_t local_port;         // local port, from zdtun to the Internet
        } vpn;
    };

    void* payload_chunks;

    jlong first_seen;
    jlong last_seen;
    jlong payload_length;
    jlong sent_bytes;
    jlong rcvd_bytes;
    jint sent_pkts;
    jint rcvd_pkts;
    jint blocked_pkts;
    zdtun_conn_status_t status;
    int error;
    char *info;
    jint uid;
    char country_code[3];
    uint8_t tcp_flags[2]; // cli2srv, srv2cli
    union {
        uint8_t last_ack;
        uint8_t pending_dns_queries;
    };
    bool pending_notification;
    bool to_purge; // if true, free this pd_conn_t during the next sendConnectionsDump
    bool info_from_lru;
    bool blacklisted_internal;
    bool blacklisted_ip;
    bool blacklisted_domain;
    bool whitelisted_app;
    bool to_block;
    bool netd_block_missed;
    bool proxied;
    bool decryption_ignored;
    bool port_mapping_applied;
    bool encrypted_l7;
    bool payload_truncated;
    bool has_payload[2]; // [0]: rx, [1] tx
    bool has_decrypted_data;
    char *url;
    uint8_t update_type;
} pd_conn_t;

typedef struct {
    zdtun_5tuple_t tuple;
    pd_conn_t *data;
} conn_and_tuple_t;

typedef struct {
    conn_and_tuple_t *items;
    int size;
    int cur_items;
} conn_array_t;

typedef struct {
    int uid;
    char appname[64];
    UT_hash_handle hh;
} uid_to_app_t;

typedef struct {
    unsigned char *data;
    unsigned int data_length;
    uint64_t ms;
    uint32_t stream_id;
    bool is_tx;
} plain_data_item_t;

typedef struct {
    plain_data_item_t *items;
    unsigned int n_items;
} plain_data_t;

typedef struct pkt_context {
    zdtun_pkt_t *pkt;
    struct timeval tv; // Packet timestamp, need by pcap_dump_rec
    uint64_t ms;       // Packet timestamp in ms
    bool is_tx;
    const zdtun_5tuple_t *tuple;
    pd_conn_t *data;
    plain_data_t *plain_data;
} pkt_context_t;

struct ushark;

/* ******************************************************* */

struct pcapdroid;

// Used to decouple pcapdroid.c from the JNI calls
typedef struct {
    void (*get_libprog_path)(struct pcapdroid *pd, const char *prog_name, char *buf, int bufsize);
     int (*load_blacklists_info)(struct pcapdroid *pd);
    void (*send_stats_dump)(struct pcapdroid *pd);
    void (*send_connections_dump)(struct pcapdroid *pd);
    void (*send_pcap_dump)(struct pcapdroid *pd, const int8_t *buf, int dump_size);
    void (*stop_pcap_dump)(struct pcapdroid *pd);
    void (*notify_service_status)(struct pcapdroid *pd, const char *status);
    void (*notify_blacklists_loaded)(struct pcapdroid *pd, bl_status_arr_t *status_arr);
    bool (*dump_payload_chunk)(struct pcapdroid *pd, pd_conn_t *conn, bool is_tx, uint64_t ms, uint32_t stream_id, const char *dump_data, int dump_size);
    void (*clear_payload_chunks)(struct pcapdroid *pd, const pkt_context_t *pctx);
} pd_callbacks_t;

/* ******************************************************* */

typedef struct pcapdroid {
#ifdef ANDROID
    JNIEnv *env;
    jobject capture_service;
    jint sdk_ver;
#endif
    int new_conn_id;
    uint64_t now_ms;            // Monotonic timestamp, see pd_refresh_time
    struct ndpi_detection_module_struct *ndpi;
    zdtun_t *zdt;
    ip_lru_t *ip_to_host;
    conn_array_t new_conns;
    conn_array_t conns_updates;
    pd_callbacks_t cb;
    uid_to_app_t *uid2app;
    char cachedir[PATH_MAX];
    char filesdir[PATH_MAX];
    int cachedir_len;
    int filesdir_len;

    // config
    jint mitm_addon_uid;
    bool vpn_capture;
    bool pcap_file_capture;
    const char *keylog_path_override;  // For tests: override sslkeylog.txt location
    payload_mode_t payload_mode;

    // stats
    u_int num_dropped_pkts;
    long num_discarded_fragments;
    uint32_t num_dropped_connections;
    uint32_t num_dns_requests;
    zdtun_statistics_t stats;
    capture_stats_t capture_stats;

    union {
        struct {
            int tunfd;
            block_quic_mode_t block_quic_mode;
            blacklist_t *known_dns_servers;
            uid_resolver_t *resolver;

            struct {
                bool enabled;
                uint32_t dns_server;
                uint32_t internal_dns;
            } ipv4;
            struct {
                bool enabled;
                struct in6_addr dns_server;
            } ipv6;
        } vpn;
        struct {
            struct pcap_conn_t *connections;
            bool as_root;
            bool daemonize;
            char *bpf;
            char *capture_interface;
            int pcapd_pid;
            struct ushark *usk;

            int *app_filter_uids;
            int app_filter_uids_size;
        } pcap;
    };

    struct {
        bool enabled;
        bool dump_extensions;
        bool pcapng_format;
        int snaplen;
        int max_pkts_per_flow;
        int max_dump_size;
        pcap_dumper_t *dumper;
    } pcap_dump;

    struct {
        bool enabled;
        zdtun_ip_t proxy_ip;
        u_int32_t proxy_port;
        int proxy_ipver;
        char proxy_user[32];
        char proxy_pass[32];
    } socks5;

    struct {
        bool enabled;
        blacklist_t *bl; // blacklist
        blacklist_t *whitelist;
        pthread_t reload_worker;
        bool reload_in_progress;
        volatile bool reload_done;
        blacklist_t *new_bl;
        blacklist_t *new_wl;
        bl_status_arr_t *status_arr;
        bl_info_t *bls_info;
        int num_bls;
    } malware_detection;

    struct {
        bool enabled;
        blacklist_t *bl;     // blocklist
        blacklist_t *new_bl;
        bool wl_enabled;
        blacklist_t *wl;     // whitelist
        blacklist_t *new_wl;
    } firewall;

    struct {
        bool enabled;
        blacklist_t *list;
        blacklist_t *new_list;
    } tls_decryption;
} pcapdroid_t;

// return 0 to continue, anything else to break
typedef int (*conn_cb)(pcapdroid_t*, const zdtun_5tuple_t*, pd_conn_t*);

/* ******************************************************* */

typedef struct {
    uint16_t transaction_id;
    uint16_t flags;
    uint16_t questions;
    uint16_t answ_rrs;
    uint16_t auth_rrs;
    uint16_t additional_rrs;
    uint8_t queries[];
} __attribute__((packed)) dns_packet_t;

/* ******************************************************* */

#ifdef ANDROID

typedef struct {
    jmethodID reportError;
    jmethodID getApplicationByUid;
    jmethodID getPackageNameByUid;
    jmethodID loadUidMapping;
    jmethodID getCountryCode;
    jmethodID protect;
    jmethodID dumpPcapData;
    jmethodID stopPcapDump;
    jmethodID startConnectionsUpdate;
    jmethodID updateConnections;
    jmethodID connInit;
    jmethodID connProcessUpdate;
    jmethodID connUpdateInit;
    jmethodID connUpdateSetStats;
    jmethodID connUpdateSetInfo;
    jmethodID connUpdateSetPayload;
    jmethodID sendServiceStatus;
    jmethodID sendStatsDump;
    jmethodID statsInit;
    jmethodID statsSetData;
    jmethodID getLibprogPath;
    jmethodID notifyBlacklistsLoaded;
    jmethodID blacklistStatusInit;
    jmethodID getBlacklistsInfo;
    jmethodID listSize;
    jmethodID listGet;
    jmethodID arraylistNew;
    jmethodID arraylistAdd;
    jmethodID payloadChunkInit;
} jni_methods_t;

typedef struct {
    jclass vpn_service;
    jclass conn;
    jclass conn_update;
    jclass stats;
    jclass blacklist_status;
    jclass blacklist_descriptor;
    jclass matchlist_descriptor;
    jclass list;
    jclass arraylist;
    jclass payload_chunk;
} jni_classes_t;

typedef struct {
    jfieldID bldescr_fname;
    jfieldID bldescr_type;
    jfieldID ld_apps;
    jfieldID ld_hosts;
    jfieldID ld_ips;
    jfieldID ld_countries;
} jni_fields_t;

typedef struct {
    jobject bltype_ip;
    jobject chunktype_raw;
    jobject chunktype_http;
} jni_enum_t;

extern jni_methods_t mids;
extern jni_classes_t cls;
extern jni_fields_t fields;
extern jni_enum_t enums;

#endif // ANDROID

/* ******************************************************* */

extern bool running;
extern uint32_t new_dns_server;
extern bool block_private_dns;
extern bool dump_capture_stats_now;
extern bool reload_blacklists_now;
extern bool has_seen_dump_extensions;
extern int bl_num_checked_connections;
extern int fw_num_checked_connections;
extern char *pd_appver;
extern char *pd_device;
extern char *pd_os;

// capture API
int pd_run(pcapdroid_t *pd);
void pd_refresh_time(pcapdroid_t *pd);
void pd_init_pkt_context(pkt_context_t *pctx,
                         zdtun_pkt_t *pkt, bool is_tx, const zdtun_5tuple_t *tuple,
                         pd_conn_t *data, struct timeval *tv);
void pd_process_packet(pcapdroid_t *pd, pkt_context_t *pctx);
void pd_account_stats(pcapdroid_t *pd, pkt_context_t *pctx);
void pd_dump_packet(pcapdroid_t *pd, const char *pktbuf, int pktlen, const struct timeval *tv,
                       int uid, u_int ifidx);
void pd_housekeeping(pcapdroid_t *pd);
pd_conn_t* pd_new_connection(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, int uid);
void pd_purge_connection(pcapdroid_t *pd, pd_conn_t *data);
int pd_notify_connection_update(pcapdroid_t *pd, const zdtun_5tuple_t *tuple, pd_conn_t *data);
void pd_giveup_dpi(pcapdroid_t *pd, pd_conn_t *data, const zdtun_5tuple_t *tuple);
const char* pd_get_proto_name(pcapdroid_t *pd, uint16_t proto, uint16_t alpn, int ipproto);

// Utility
const char* get_cache_path(pcapdroid_t *pd, const char *subpath);
const char* get_file_path(pcapdroid_t *pd, const char *subpath);
static inline const char* get_cache_dir(pcapdroid_t *pd) { return get_cache_path(pd, ""); }
static inline const char* get_files_dir(pcapdroid_t *pd) { return get_file_path(pd, ""); }
char* get_appname_by_uid(pcapdroid_t *pd, int uid, char *buf, int bufsize);
uint16_t pd_ndpi2proto(ndpi_protocol proto);

#ifdef ANDROID

char* getStringPref(pcapdroid_t *pd, const char *key, char *buf, int bufsize);
int getIntPref(JNIEnv *env, jobject vpn_inst, const char *key);
int getIntArrayPref(JNIEnv *env, jobject vpn_inst, const char *key, int **out);
zdtun_ip_t getIPPref(JNIEnv *env, jobject vpn_inst, const char *key, int *ip_ver);
uint32_t getIPv4Pref(JNIEnv *env, jobject vpn_inst, const char *key);
struct in6_addr getIPv6Pref(JNIEnv *env, jobject vpn_inst, const char *key);
void getApplicationByUid(pcapdroid_t *pd, jint uid, char *buf, int bufsize);
void getPackageNameByUid(pcapdroid_t *pd, jint uid, char *buf, int bufsize);
void loadUidMapping(pcapdroid_t *pd, jint uid, const char *package_name, const char *app_name);
bool getCountryCode(pcapdroid_t *pd, const char *host, char out[3]);

#endif // ANDROID

// Internals
void init_ndpi_protocols_bitmask(ndpi_protocol_bitmask_struct_t *b);
void load_ndpi_hosts(struct ndpi_detection_module_struct *ndpi);
uint32_t crc32(u_char *buf, size_t len, uint32_t crc);
char* get_allocs_summary();

#endif //__PCAPDROID_H__

```

`app/src/main/jni/core/port_map.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#include "common/memtrack.h"
#include "log_writer.h"
#include "port_map.h"

typedef struct {
    zdtun_ip_t redirect_ip;
    int ipver;
    int orig_port;
    int redirect_port;
} port_map_t;

typedef struct {
    port_map_t *items;
    int num_items;
} port_map_list_t;

static struct {
    port_map_list_t tcp;
    port_map_list_t udp;
} mappings;

/* ******************************************************* */

static inline port_map_list_t* get_map_list(int ipproto) {
    if(ipproto == IPPROTO_TCP)
        return &mappings.tcp;
    else if(ipproto == IPPROTO_UDP)
        return &mappings.udp;
    else
        return NULL;
}

/* ******************************************************* */

bool pd_add_port_map(int ipver, int ipproto, int orig_port, int redirect_port, const zdtun_ip_t *redirect_ip) {
    port_map_list_t *mlist = get_map_list(ipproto);
    if(!mlist)
        return false;

    mlist->items = (port_map_t*) pd_realloc(mlist->items, (++mlist->num_items) * sizeof(port_map_t));
    if(!mlist->items) {
        mlist->num_items = 0;
        return false;
    }

    port_map_t *mapping = &mlist->items[mlist->num_items - 1];
    mapping->orig_port = htons(orig_port);
    mapping->ipver = ipver;
    mapping->redirect_ip = *redirect_ip;
    mapping->redirect_port = htons(redirect_port);

    return true;
}

/* ******************************************************* */

bool pd_check_port_map(zdtun_conn_t *conn) {
    const zdtun_5tuple_t *tuple = zdtun_conn_get_5tuple(conn);
    port_map_list_t *mlist = get_map_list(tuple->ipproto);
    if(!mlist)
        return false;

    for(int i=0; i<mlist->num_items; i++) {
        port_map_t *mapping = &mlist->items[i];

        if(mapping->orig_port == tuple->dst_port) {
            log_d("Port mapping found: %d -> %d", ntohs(tuple->dst_port), ntohs(mapping->redirect_port));
            zdtun_conn_dnat(conn, &mapping->redirect_ip, mapping->redirect_port, mapping->ipver);
            return true;
        }
    }

    return false;
}

/* ******************************************************* */

static void clear_map_list(port_map_list_t *mlist) {
    pd_free(mlist->items);
    mlist->items = NULL;
    mlist->num_items = 0;
}

void pd_reset_port_map() {
    clear_map_list(&mappings.tcp);
    clear_map_list(&mappings.udp);
}
```

`app/src/main/jni/core/port_map.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#ifndef PCAPDROID_PORTMAP_H
#define PCAPDROID_PORTMAP_H

#include <stdbool.h>
#include "zdtun.h"

bool pd_add_port_map(int ipver, int ipproto, int orig_port, int redirect_port, const zdtun_ip_t *redirect_ip);
bool pd_check_port_map(zdtun_conn_t *conn);
void pd_reset_port_map();

#endif //PCAPDROID_PORTMAP_H

```

`app/src/main/jni/core/ushark_dll.c`:

```c
#include <dlfcn.h>
#include <unistd.h>
#include <stdbool.h>
#include <assert.h>

#include "ushark_dll.h"
#include "../common/utils.h"

static void *sk_dll;
static void (*sk_init)();
static void (*sk_cleanup)();
static ushark_t* (*sk_new)(int, const char *);
static void (*sk_set_pref)(const char *, const char *);
static void (*sk_set_callbacks)(ushark_t *, const ushark_data_callbacks_t *);
static void (*sk_destroy)(ushark_t*);
static const char* (*sk_dissect)(ushark_t*, const unsigned char *, const struct pcap_pkthdr *);

bool ushark_init(pcapdroid_t *pd) {
    assert(!sk_dll);

    if (!pd->cb.get_libprog_path) {
        log_e("get_libprog_path not defined");
        return false;
    }

    char ushark_lib[PATH_MAX];
    ushark_lib[0] = '\0';
    pd->cb.get_libprog_path(pd, "ushark", ushark_lib, sizeof(ushark_lib));

    if (!ushark_lib[0]) {
        log_e("cannot find libushark.so");
        return false;
    }

    log_d("libushark found: %s", ushark_lib);

    sk_dll = dlopen(ushark_lib, RTLD_NOW | RTLD_LOCAL);
    if (!sk_dll) {
        log_d("loading libushark.so failed: %s", dlerror());
        return false;
    }

    sk_init = dlsym(sk_dll, "ushark_init");
    sk_cleanup = dlsym(sk_dll, "ushark_cleanup");
    sk_new = dlsym(sk_dll, "ushark_new");
    sk_set_pref = dlsym(sk_dll, "ushark_set_pref");
    sk_set_callbacks = dlsym(sk_dll, "ushark_set_callbacks");
    sk_destroy = dlsym(sk_dll, "ushark_destroy");
    sk_dissect = dlsym(sk_dll, "ushark_dissect");

    if (!sk_init || !sk_cleanup || !sk_new || !sk_set_pref || !sk_set_callbacks || !sk_destroy || !sk_dissect) {
        dlclose(sk_dll);
        sk_dll = NULL;
        log_e("libushark.so misses some required symbols");
        return false;
    }

    sk_init();
    return true;
}

void ushark_cleanup() {
    assert(sk_dll);

    sk_cleanup();

    sk_init = NULL;
    sk_cleanup = NULL;
    sk_new = NULL;
    sk_set_pref = NULL;
    sk_set_callbacks = NULL;
    sk_destroy = NULL;
    sk_dissect = NULL;

    // deallocates the static variables in wireshark, necessary to run cleanly again
    dlclose(sk_dll);
    sk_dll = NULL;
}

ushark_t* ushark_new(int pcap_encap, const char *dfilter) {
    assert(sk_new);

    return sk_new(pcap_encap, dfilter);
}

void ushark_destroy(ushark_t *sk) {
    assert(sk_destroy);

    sk_destroy(sk);
}

void ushark_set_pref(const char *name, const char *val) {
    assert(sk_set_pref);

    sk_set_pref(name, val);
}

void ushark_set_callbacks(ushark_t *sk, const ushark_data_callbacks_t *cbs) {
    assert(sk_set_callbacks);

    sk_set_callbacks(sk, cbs);
}

const char* ushark_dissect(ushark_t *sk, const unsigned char *buf, const struct pcap_pkthdr *hdr) {
    assert(sk_dissect);

    return sk_dissect(sk, buf, hdr);
}

```

`app/src/main/jni/core/ushark_dll.h`:

```h
#ifndef _USHARK_H_
#define _USHARK_H_

#include "pcapdroid.h"

typedef struct ushark ushark_t;
struct pcap_pkthdr;

bool ushark_init(pcapdroid_t *pd);
void ushark_cleanup();

ushark_t* ushark_new(int pcap_encap, const char *dfilter);
void ushark_destroy(ushark_t *sk);
void ushark_set_pref(const char *name, const char *val);

typedef struct {
    void (*on_http1_data)(uint32_t conversation_id, const unsigned char *plain_data, size_t data_len);
    void (*on_http2_request)(uint32_t conversation_id, uint32_t stream_id, const unsigned char *plain_data, size_t data_len);
    void (*on_http2_response)(uint32_t conversation_id, uint32_t stream_id, const unsigned char *plain_data, size_t data_len);
    void (*on_http2_reset)(uint32_t conversation_id, uint32_t stream_id);
} ushark_data_callbacks_t;
void ushark_set_callbacks(ushark_t *sk, const ushark_data_callbacks_t *cbs);

const char* ushark_dissect(ushark_t *sk, const unsigned char *buf, const struct pcap_pkthdr *hdr);

#endif

```

`app/src/main/jni/pcapd/CMakeLists.txt`:

```txt
project(pcapd C)

# libpcap
set(LIBPCAP_ROOT ${ROOTDIR}/submodules/libpcap)
include_directories(${LIBPCAP_ROOT})

set(LIBPCAP_GEN ${ROOTDIR}/generated/libpcap)
configure_file(${LIBPCAP_GEN}/config.h ${LIBPCAP_ROOT}/config.h)
configure_file(${LIBPCAP_GEN}/grammar.c ${LIBPCAP_ROOT}/grammar.c)
configure_file(${LIBPCAP_GEN}/grammar.h ${LIBPCAP_ROOT}/grammar.h)
configure_file(${LIBPCAP_GEN}/scanner.c ${LIBPCAP_ROOT}/scanner.c)
configure_file(${LIBPCAP_GEN}/scanner.h ${LIBPCAP_ROOT}/scanner.h)

ADD_LIBRARY(pcap STATIC
        ${LIBPCAP_ROOT}/pcap.c
        ${LIBPCAP_ROOT}/pcap-common.c
        ${LIBPCAP_ROOT}/pcap-util.c
        ${LIBPCAP_ROOT}/sf-pcap.c
        ${LIBPCAP_ROOT}/sf-pcapng.c
        ${LIBPCAP_ROOT}/pcap-linux.c
        ${LIBPCAP_ROOT}/fad-gifc.c
        ${LIBPCAP_ROOT}/nametoaddr.c
        ${LIBPCAP_ROOT}/etherent.c
        ${LIBPCAP_ROOT}/savefile.c
        ${LIBPCAP_ROOT}/fmtutils.c
        ${LIBPCAP_ROOT}/gencode.c
        ${LIBPCAP_ROOT}/grammar.c
        ${LIBPCAP_ROOT}/scanner.c
        ${LIBPCAP_ROOT}/bpf_filter.c
        ${LIBPCAP_ROOT}/optimize.c
        ${LIBPCAP_ROOT}/missing/strlcpy.c)

if(FUZZING)
  add_library(libpcapd.so SHARED pcapd.c nl_utils.c)
else()
  # Executables must be names as libraries to be stored into corresponding native folder
  # NOTE: only works if extractNativeLibs is true
  add_executable(libpcapd.so pcapd.c nl_utils.c)
endif()

# Better to link static libs to avoid changing the library path
target_link_libraries(libpcapd.so pcap zdtun common)

```

`app/src/main/jni/pcapd/README.md`:

```md
What's pcapd
------------

pcapd is an executable, run with root privileges, which can be used to capture network packets and process them into an Android app.

Its hot features include:

- Capture from the internet-facing interface and automatically roam when it changes
- Filter traffic by app (via the app UID)
- Capture from multiple interfaces and detect the packet direction
- The executable lives within the normal app directories and does not alter the Android root file system
- All the dumped packets start with the IP headers, which relieves your app from doing datalink processing

The following datalinks are currently supported: `DLT_RAW`, `DLT_EN10MB` and `DLT_LINUX_SLL`.

Usage
-----

You can find pre-compiled binaries to integrate pcapd in other apps in the [pcapd-bin](https://github.com/emanuele-f/pcapd-bin) repository.

The pcapd executable can be run with the `-h` option to print its cli usage:

```
pcapd - root capture tool of PCAPdroid
Copyright 2021 Emanuele Faranda <black.silver@hotmail.it>

Usage: pcapd [OPTIONS]
 -i [ifname]    capture packets on the specified interface. Can be specified
                multiple times. The '@inet' keyword can be used to capture from
                the internet interface
 -d             daemonize the process
 -t             dump the interface datalink header. Default: don't dump
 -u [uid]       filter packets by uid
 -b [bpf]       filter packets by BPF filter
 -l [file]      log output to the specified file
 -n             do not connect to the UNIX socket, log to stdout instead
```

If no option is provided, pcapd will start capturing on the internet interface.

The daemon logs messages to logcat, identified by the `pcapd` tag.

App integration
---------------

pcapd uses a UNIX socket to send the captured packets to the client app, so native code must be used to interface with it.

pcapd is compiled into the binary executable `libpcapd.so`, which is named as a shared library to force grandle to package it into the apk.
The app must set `android:extractNativeLibs="true"` in the `AndroidManifest.xml` in order to unpack the `libpcapd.so` to the Android filesystem once the app is installed.
The `libpcapd.so` is located into the app library path, which can be obtained in java via `Context.getApplicationInfo().nativeLibraryDir`.

Here are the steps to make it communicate with your app:

1. The app chdirs to a writable directory, which will be the working directory for the pcapd daemon.
2. The app should check if a `PCAPD_PID` file is present. If so, it can read it and kill the running deamon.
3. The app creates the `PCAPD_SOCKET_PATH` UNIX socket in listen mode.
4. The app spawns pcapd in deamon mode (with the `-d` option) and waits for its connection on the UNIX socket.
5. The app can now receive the packets on the UNIX socket.
6. When the app closes the UNIX socket, the pcapd daemon is automatically stopped.

Check out the [capture_pcap.c source](https://github.com/emanuele-f/PCAPdroid/blob/master/app/src/main/jni/core/capture_pcap.c) to see an example of integration.

Packets Data
------------

pcapd captures packets on the specified interfaces and writes them to the `PCAPD_SOCKET_PATH` UNIX socket.

Each packet is prepended with the fixed size `pcapd_hdr_t` header, which contains the packet metadata such as the packet length and the interface it was captured on.
The `ifid` field corresponds to the positional index of the interface in the pcapd command line. For example, when running pcapd with `-i wlan0 -i rmnet0`, `wlan0` will have index `0` and `rmnet0` will have index `1`.

For a description of all the header fields check out [pcapd.h](https://github.com/emanuele-f/PCAPdroid/blob/master/app/src/main/jni/pcapd/pcapd.h).

```

`app/src/main/jni/pcapd/nl_utils.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/sock_diag.h>
#include <linux/inet_diag.h>
#include <netinet/in.h>
#include <net/if.h>
#include "nl_utils.h"
#include "common/uid_resolver.h"
#include "common/utils.h"

int nl_route_socket(uint32_t groups) {
  struct sockaddr_nl snl;
  int sock;

  sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);

  if(sock < 0)
    return -1;

  memset(&snl, 0, sizeof(snl));
  snl.nl_family = AF_NETLINK;
  snl.nl_pid = 0; // managed by the kernel, see man 7 netlink
  snl.nl_groups = groups;

  if(bind(sock, (struct sockaddr *)&snl, sizeof(snl)) < 0) {
    close(sock);
    return -1;
  }

  return sock;
}

/* ******************************************************* */

// adapted from libdnet/route-linux.c
int nl_get_route(int af, const addr_t *addr, route_info_t *out) {
  static int seq = 0;
  struct nlmsghdr *nmsg;
  struct rtmsg *rmsg;
  struct rtattr *rta;
  struct sockaddr_nl snl;
  struct iovec iov;
  struct msghdr msg;
  u_char buf[512];
  int i, alen, nlsock, rv = -1;

  nlsock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);

  if(nlsock < 0)
    return(-1);

  alen = (af == AF_INET) ? 4 : 16;
  memset(buf, 0, sizeof(buf));

  nmsg = (struct nlmsghdr *)buf;
  nmsg->nlmsg_len = NLMSG_LENGTH(sizeof(*nmsg)) + RTA_LENGTH(alen);
  nmsg->nlmsg_flags = NLM_F_REQUEST;
  nmsg->nlmsg_type = RTM_GETROUTE;
  nmsg->nlmsg_seq = ++seq;

  rmsg = (struct rtmsg *)(nmsg + 1);
  rmsg->rtm_family = af;
  rmsg->rtm_dst_len = alen * 8;

  rta = RTM_RTA(rmsg);
  rta->rta_type = RTA_DST;
  rta->rta_len = RTA_LENGTH(alen);

  /* XXX - gross hack for default route */
  if (af == AF_INET && (addr->v4 == INADDR_ANY)) {
    i = htonl(0x60060606);
    memcpy(RTA_DATA(rta), &i, alen);
  } else
    memcpy(RTA_DATA(rta), addr, alen);

  memset(&snl, 0, sizeof(snl));
  snl.nl_family = AF_NETLINK;

  iov.iov_base = nmsg;
  iov.iov_len = nmsg->nlmsg_len;

  memset(&msg, 0, sizeof(msg));
  msg.msg_name = &snl;
  msg.msg_namelen = sizeof(snl);
  msg.msg_iov = &iov;
  msg.msg_iovlen = 1;

  if(sendmsg(nlsock, &msg, 0) < 0)
    goto out;

  iov.iov_base = buf;
  iov.iov_len = sizeof(buf);

  if ((i = recvmsg(nlsock, &msg, 0)) <= 0)
    goto out;

  if(nmsg->nlmsg_len < (int)sizeof(*nmsg) || nmsg->nlmsg_len > i ||
      nmsg->nlmsg_seq != seq) {
    errno = EINVAL;
    goto out;
  }

  if(nmsg->nlmsg_type == NLMSG_ERROR)
    goto out;

  i -= NLMSG_LENGTH(sizeof(*nmsg));
  out->gw_len = 0;

  for(rta = RTM_RTA(rmsg); RTA_OK(rta, i); rta = RTA_NEXT(rta, i)) {
    if(rta->rta_type == RTA_GATEWAY) {
      // may noy be present
      memcpy(&out->gateway, RTA_DATA(rta), alen);
      out->gw_len = alen;
    } else if (rta->rta_type == RTA_OIF) {
      rv = 0;
      out->ifidx = *(int *) RTA_DATA(rta);
    }
  }

  if(rv != 0) {
    errno = ESRCH;
    goto out;
  }

out:
  close(nlsock);

  return(rv);
}

/* ******************************************************* */

// Returns:
//      >= 0 on success
//      UID_UNKNOWN if the UID could not be resolved
//      other on error, errno is set accordingly
static int diag_uid_lookup(int nlsock, int family, int ipproto,
          const pd_sockaddr_t *local, const pd_sockaddr_t *remote,
          int flags) {
  struct sockaddr_nl snl = {0};
  struct msghdr msg = {0};
  struct iovec iov;
  u_char buf[512];
  static int seq = 0;
  ssize_t rv;
  uint8_t do_retry = 1;

  struct nlmsghdr *nmsg = (struct nlmsghdr*) buf;
  struct inet_diag_req_v2 *req = (struct inet_diag_req_v2*) (nmsg + 1);

  memset(req, 0, sizeof(*req));
  req->sdiag_family = family;
  req->sdiag_protocol = ipproto;
  req->idiag_states = -1 /* ANY state */;
  req->id.idiag_sport = local->port;
  req->id.idiag_dport = remote->port;
  req->id.idiag_cookie[0] = -1, req->id.idiag_cookie[1] = -1; /* no cookie */

  if(family == AF_INET) {
    memcpy(req->id.idiag_src, &local->addr.ip4, 4);
    memcpy(req->id.idiag_dst, &remote->addr.ip4, 4);
  } else {
    memcpy(req->id.idiag_src, &local->addr.ip6, 16);
    memcpy(req->id.idiag_dst, &remote->addr.ip6, 16);
  }

  memset(nmsg, 0, sizeof(*nmsg));
  nmsg->nlmsg_len = sizeof(*nmsg) + sizeof(*req);
  nmsg->nlmsg_type = SOCK_DIAG_BY_FAMILY;
  nmsg->nlmsg_flags = flags;
  nmsg->nlmsg_seq = ++seq;

  iov.iov_base = (void*) nmsg;
  iov.iov_len = nmsg->nlmsg_len;

  snl.nl_family = AF_NETLINK;

  msg.msg_name = (void*) &snl;
  msg.msg_namelen = sizeof(snl);
  msg.msg_iov = &iov;
  msg.msg_iovlen = 1;

  // Send request
  if(sendmsg(nlsock, &msg, 0) < 0)
    return -2;

  iov.iov_base = buf;
  iov.iov_len = sizeof(buf);

retry:
  // Recv reply
  if((rv = recvmsg(nlsock, &msg, 0)) <= 0)
    return -3;

  // NOTE: nmsg points to buf
  if(nmsg->nlmsg_len < (int)sizeof(*nmsg) || nmsg->nlmsg_len > rv) {
    errno = EINVAL;
    return -4;
  }

  if(nmsg->nlmsg_seq != seq) {
    if(do_retry && (nmsg->nlmsg_seq == (seq - 1))) {
      do_retry = 0;
      goto retry; // this issue is recoverable, retry once
    }

    log_e("out of sequence: %d/%d", nmsg->nlmsg_seq, seq);
    errno = EINVAL;
    return -5;
  }

  if(nmsg->nlmsg_type == NLMSG_ERROR) {
    const struct nlmsgerr *err = NLMSG_DATA(nmsg);

    if(nmsg->nlmsg_len >= NLMSG_LENGTH(sizeof(*err))) {
        errno = -err->error;
        if(errno == ENOENT)
            return UID_UNKNOWN;
    } else
        errno = EINVAL;

    return -6;
  }

  if(nmsg->nlmsg_type == NLMSG_DONE)
    return UID_UNKNOWN;

  if(nmsg->nlmsg_len < NLMSG_LENGTH(sizeof(struct inet_diag_msg))) {
      errno = EINVAL;
      return -7;
  }

  struct inet_diag_msg *diag_msg = (struct inet_diag_msg*) NLMSG_DATA(nmsg);
  return diag_msg->idiag_uid;
}

/* ******************************************************* */

// On some Android versions (e.g. emulator API 21) the DIAG socket always returns ENOENT
// Perform a wildcard dump query to verify this
int nl_is_diag_working() {
  int working;
  pd_sockaddr_t wildcard = {0};

  // NOTE: don't use an existing socket, as the NLM_F_DUMP query may span multiple datagrams
  int nlsock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_INET_DIAG);
  if(nlsock < 0)
    return 0;

  // Assume at least 1 open UDP AF_INET open socket exists
  int rv = diag_uid_lookup(nlsock, AF_INET, IPPROTO_UDP, &wildcard, &wildcard, NLM_F_REQUEST | NLM_F_DUMP);
  working = (rv >= 0);

  close(nlsock);
  return working;
}

/* ******************************************************* */

int nl_get_uid(int nlsock, const zdtun_5tuple_t *tuple) {
  int uid;

  int family = (tuple->ipver == 4) ? AF_INET : AF_INET6;
  int ipproto = tuple->ipproto;
  pd_sockaddr_t src = {.addr = tuple->src_ip, .port = tuple->src_port};
  pd_sockaddr_t dst = {.addr = tuple->dst_ip, .port = tuple->dst_port};

  // fix to known bug with UDP: https://www.mail-archive.com/netdev@vger.kernel.org/msg248638.html
  const pd_sockaddr_t *local = (ipproto == IPPROTO_UDP) ? &dst : &src;
  const pd_sockaddr_t *remote = (ipproto == IPPROTO_UDP) ? &src : &dst;

  uid = diag_uid_lookup(nlsock, family, ipproto, local, remote, NLM_F_REQUEST);
  if((uid >= 0) || (uid != UID_UNKNOWN))
    return uid;

  // Search for IPv4-mapped IPv6 addresses
  if(family == AF_INET) {
    uid = diag_uid_lookup(nlsock, AF_INET6, ipproto, local, remote, NLM_F_REQUEST);
    if((uid >= 0) || (uid != UID_UNKNOWN))
      return uid;
  }

  // For UDP it's possible for a socket to send packets to arbitrary destinations
  // See InetDiagMessage.java in Android
  if(ipproto == IPPROTO_UDP) {
    pd_sockaddr_t wildcard = {0};

    uid = diag_uid_lookup(nlsock, family, ipproto, &src, &wildcard, NLM_F_REQUEST | NLM_F_DUMP);
    if((uid >= 0) || (uid != UID_UNKNOWN))
      return uid;

    // Search for IPv4-mapped IPv6 addresses
    if(family == AF_INET) {
      uid = diag_uid_lookup(nlsock, AF_INET6, ipproto, &src, &wildcard, NLM_F_REQUEST | NLM_F_DUMP);
      if((uid >= 0) || (uid != UID_UNKNOWN))
        return uid;
    }
  }

  return UID_UNKNOWN;
}

```

`app/src/main/jni/pcapd/nl_utils.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

#ifndef __NL_UTILS_H__
#define __NL_UTILS_H__

#include <stdint.h>
#include <zdtun.h>

/* >= 8192 to avoid truncation, see "man 7 netlink" */
#define NL_BUFFER_SIZE 8192

typedef struct {
  union {
    uint32_t v4;
    uint8_t v6[8];
  };
} __attribute__((packed)) addr_t;

typedef struct {
  zdtun_ip_t addr;
  uint16_t port;
} pd_sockaddr_t;

typedef struct {
  addr_t gateway;
  int ifidx;
  int gw_len;
} route_info_t;

int nl_get_route(int af, const addr_t *addr, route_info_t *out);
int nl_route_socket(uint32_t groups);
int nl_is_diag_working();
int nl_get_uid(int nlsock, const zdtun_5tuple_t *tuple);

#endif

```

`app/src/main/jni/pcapd/pcapd.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021-24 - Emanuele Faranda
 */

/*
 * A daemon to capture network packets and send them to a UNIX socket.
 * When running as daemon, the PCAPD_PID file is created, storing the the daemon pid. It is
 * automatically deleted when the daemon exits. The daemon captures the packets from the internet
 * interface (the interface of the default gateway) and detects its changes.
 * The daemon expects the PCAPD_SOCKET_PATH UNIX socket to be present. It will connect and
 * start dumping the packets to it. When the socket is closed, the daemon exits.
 */

#include <linux/netlink.h>
#include <linux/rtnetlink.h>

#include "pcapd_priv.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <signal.h>
#include <linux/if_ether.h>
#include <time.h>
#include <pcap/sll.h>
#include "pcapd.h"
#include "nl_utils.h"

//#define READ_FROM_PCAP "/sdcard/test.pcap"

/* ******************************************************* */

static void init_interface(pcapd_iface_t *iface);
static void close_interface(pcapd_runtime_t *rt, pcapd_iface_t *iface);

/* ******************************************************* */

static char errbuf[PCAP_ERRBUF_SIZE];
static FILE *logf = NULL;
static sig_atomic_t running;

/* ******************************************************* */

static uint64_t bytes2mac(const uint8_t *buf) {
  uint64_t m = 0;

  memcpy(&m, buf, 6);

  return m;
}

/* ******************************************************* */

static int str2mac(const char *buf, uint64_t *mac) {
  uint8_t mac_bytes[6];
  int m[6] = {0};

  if(sscanf(buf, "%02X:%02X:%02X:%02X:%02X:%02X", m+0, m+1, m+2, m+3, m+4, m+5) != 6)
      return -1;

  for(int i = 0; i < 6; i++)
      mac_bytes[i] = m[i];

  *mac = bytes2mac(mac_bytes);
  return 0;
}

/* ******************************************************* */

static int* parse_uid_filter(char *s) {
  int num_uids = 1;

  for(int i=0; s[i]; i++) {
    if(s[i] == ',')
      num_uids++;
  }

  int* rv = malloc((num_uids + 1 /* terminator */) * sizeof(int));
  if(rv == NULL) {
    fprintf(stderr, "parse_uid_filter: malloc failed[%d]: %s",
        errno, strerror(errno));
    exit(PCAPD_ERROR);
  }

  int i = 0;
  char *token;
  char *tmp;
  token = strtok_r(s, ",", &tmp);

  while(token && (i < num_uids)) {
    int uid = atoi(token);
    if(uid < -1) {
      fprintf(stderr, "Invalid UID: %s\n", token);
      exit(PCAPD_ERROR);
    }

    if(uid != -1)
      rv[i++] = uid;

    token = strtok_r(NULL, ",", &tmp);
  }

  // terminator
  rv[i++] = -1;

  return rv;
}

/* ******************************************************* */

static int matches_uid_filter(const int *filter, int uid) {
  if (!filter || (*filter == -1))
    return 1;

  while (*filter != -1) {
    if (*filter == uid)
      return 1;

    filter++;
  }

  // no match
  return 0;
}

/* ******************************************************* */

static void logcb(int lvl, const char *msg) {
  char datetime[64];
  struct tm res;
  time_t now;

  now = time(NULL);
  strftime(datetime, sizeof(datetime), "%d/%b/%Y %H:%M:%S", localtime_r(&now, &res));

  fprintf(stderr, "[%c] %s - %s\n", loglvl2char(lvl), datetime, msg);

  if(!logf)
    return;

  fprintf(logf, "[%c] %s - %s\n", loglvl2char(lvl), datetime, msg);
  fflush(logf);
}

/* ******************************************************* */

static int get_iface_mac(const char *iface, uint64_t *mac) {
  char fpath[128];
  char buf[24];

  // avoid using ioctl as it sometimes triggers SELINUX errors
  snprintf(fpath, sizeof(fpath), "/sys/class/net/%s/address", iface);

  FILE *f = fopen(fpath, "r");

  if(f == NULL)
    return -1;

  buf[0] = '\0';
  fgets(buf, sizeof(buf), f);
  fclose(f);

  if(str2mac(buf, mac) != 0)
      return -1;

  return(0);
}

/* ******************************************************* */

static int get_iface_ip(const char *iface, uint32_t *ip, uint32_t *netmask) {
  struct ifreq ifr;
  int fd;
  int rv;

  fd = socket(AF_INET, SOCK_DGRAM, 0);

  ifr.ifr_addr.sa_family = AF_INET;
  strncpy((char *)ifr.ifr_name, iface, IFNAMSIZ-1);

  if((rv = ioctl(fd, SIOCGIFADDR, &ifr)) != -1) {
    *ip = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;

    if((rv = ioctl(fd, SIOCGIFNETMASK, &ifr)) != -1)
      *netmask = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;
  }

  close(fd);
  return(rv);
}

/* ******************************************************* */

static int get_iface_ip6(const char *iface, struct in6_addr *ip) {
  FILE *f = fopen("/proc/net/if_inet6", "r");
  char line[128];
  int found = 0;

  if(f == NULL)
    return -1;

  __be32 *ip6 = ip->s6_addr32;

  while(fgets(line, sizeof(line), f)) {
    if((strstr(line, iface) != NULL) &&
            (sscanf(line, "%08x%08x%08x%08x", &ip6[0], &ip6[1], &ip6[2], &ip6[3]) == 4)) {
      for(int i=0; i<4; i++)
        ip6[i] = htonl(ip6[i]);

      if((ip->s6_addr[0] == 0xfe) &&
         ((ip->s6_addr[1] & 0xC0) == 0x80)) // link local address
        continue;

      char addr[INET6_ADDRSTRLEN];
      inet_ntop(AF_INET6, ip, addr, INET6_ADDRSTRLEN);

      log_d("IPv6 address[%s]: %s", iface, addr);
      found = 1;
      break;
    }
  }

  fclose(f);
  return(found ? 0 : -1);
}

/* ******************************************************* */

static void sum_stats(struct pcap_stat *out, const struct pcap_stat *to_sum) {
  out->ps_drop += to_sum->ps_drop;
  out->ps_ifdrop += to_sum->ps_ifdrop;
  out->ps_recv += to_sum->ps_recv;
}

/* ******************************************************* */

static void sighandler(__unused int signo) {
  if(running) {
    log_i("Signal received, terminating");
    running = 0;
  } else {
    log_w("Exit now");
    unlink(PCAPD_PID);
    exit(PCAPD_ERROR);
  }
}

/* ******************************************************* */

static int create_pid_file() {
  FILE *f = fopen(PCAPD_PID, "w");

  if(!f)
    return -1;

  fprintf(f, "%d\n", getpid());
  fclose(f);

  return 0;
}

/* ******************************************************* */

static void finish_pcapd_capture(pcapd_runtime_t *rt) {
  if(rt->client > 0)
    close(rt->client);
  if(rt->nlroute_sock > 0)
    close(rt->nlroute_sock);
  if(rt->nldiag_sock > 0)
    close(rt->nldiag_sock);
  if(rt->lru)
    uid_lru_destroy(rt->lru);
  if(rt->resolver)
    destroy_uid_resolver(rt->resolver);

  for(int i=0; i<rt->conf->num_interfaces; i++)
    close_interface(rt, &rt->ifaces[i]);

  unlink(PCAPD_PID);
}

/* ******************************************************* */

static int init_pcapd_capture(pcapd_runtime_t *rt, pcapd_conf_t *conf) {
  if(conf->daemonize) {
    pid_t pid = fork();

    if(pid < 0) {
      fprintf(stderr, "fork failed[%d]: %s\n", errno, strerror(errno));
      return -1;
    } else if(pid != 0) {
      // parent
      exit(0);
    }
  }

  // SIGPIPE will be generated as in su_cmd PCAPdroid performs a dup2 stdout/stderr to a pipe
  // which is then closed
  signal(SIGPIPE, SIG_IGN);

  rt->nlroute_sock = -1;
  rt->nldiag_sock = -1;
  rt->client = -1;
  rt->conf = conf;

  if(!(rt->lru = uid_lru_init(64)))
    goto err;

  if(!(rt->resolver = init_uid_resolver_from_proc()))
    goto err;

  for(int i=0; i<conf->num_interfaces; i++)
    init_interface(&rt->ifaces[i]);

  if(conf->inet_ifid != -1)
    rt->inet_iface = &rt->ifaces[conf->inet_ifid];

  if(conf->daemonize && (create_pid_file() < 0)) {
    log_e("pid file creation failed[%d]: %s", errno, strerror(errno));
    goto err;
  }

  if(rt->inet_iface) {
    rt->nlroute_sock = nl_route_socket(RTMGRP_IPV4_ROUTE | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_RULE |
                                   RTMGRP_IPV6_ROUTE | RTMGRP_IPV6_IFADDR | RTMGRP_LINK);
    if(rt->nlroute_sock < 0) {
      log_e("could not create netlink socket[%d]: %s", errno, strerror(errno));
      goto err;
    }
    rt->maxfd = max(rt->maxfd, rt->nlroute_sock);
  }

  if(getuid() == 0) {
    if(nl_is_diag_working()) {
      rt->nldiag_sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_INET_DIAG);
      if(rt->nldiag_sock < 0)
        log_w("could not open NETLINK_INET_DIAG[%d]: %s", errno, strerror(errno));
    } else
      log_w("NETLINK_INET_DIAG not working, using slow UID resolution method");
  }

  signal(SIGINT, &sighandler);
  signal(SIGTERM, &sighandler);
  signal(SIGHUP, &sighandler);

  if(!rt->conf->no_client) {
    rt->client = socket(AF_UNIX, SOCK_STREAM, 0);
    if(rt->client < 0) {
      log_e("socket creation failed[%d]: %s", errno, strerror(errno));
      goto err;
    }
    rt->maxfd = max(rt->maxfd, rt->client);

    struct sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, PCAPD_SOCKET_PATH);

    log_i("Connecting to client...");

    if(connect(rt->client, (struct sockaddr*) &addr, sizeof(addr)) != 0) {
      log_e("client connection failed[%d]: %s", errno, strerror(errno));
      goto err;
    }

    log_i("Connected to client");
    unlink(PCAPD_SOCKET_PATH);
  }

  return 0;

err:
  return -1;
}

/* ******************************************************* */

static void init_interface(pcapd_iface_t *iface) {
  memset(iface, 0, sizeof(pcapd_iface_t));
  iface->pf = -1;
  iface->ifidx = -1;
}

/* ******************************************************* */

static pcapd_rv open_interface(pcapd_iface_t *iface, pcapd_runtime_t *rt, const char *ifname, int ifid) {
#ifndef READ_FROM_PCAP
  int is_file = 0;
  pcap_t *pd;

  pd = pcap_create(ifname, errbuf);
  if(pd) {
    // NOTE: setting immediate mode greatly increases the chance to resolve UIDs of short-lived
    // connections. But it has a big performance impact due to the increased context switches.
    // The performance cost is not acceptable.
    if((pcap_set_timeout(pd, 1) != 0) ||
       (pcap_set_snaplen(pd, PCAPD_SNAPLEN) != 0) ||
       (pcap_set_immediate_mode(pd, 0) != 0) ||
       (pcap_activate(pd) != 0)) {
      pcap_close(pd);
      pd = NULL;
    }
  }

  if(!pd) {
    // try to open as file
    pd = pcap_open_offline(ifname, errbuf);

    if(!pd) {
      log_e("pcap_open(%s) failed: %s", ifname, errbuf);
      return PCAPD_INTERFACE_OPEN_FAILED;
    }

    is_file = 1;
  }

  // Fixes pcap_next_ex sometimes hanging on interface down
  // https://github.com/the-tcpdump-group/libpcap/issues/899
  pcap_setnonblock(pd, 1, errbuf);
#else
  int is_file = 1;
  pcap_t *pd = pcap_open_offline(READ_FROM_PCAP, errbuf);

  if(!pd) {
    log_i("pcap_open_offline(%s) failed: %s", READ_FROM_PCAP, errbuf);
    return PCAPD_INTERFACE_OPEN_FAILED;
  }

  strcpy(ifname, "pcap");
#endif

  int dlink = pcap_datalink(pd);
  int ipoffset;
  const char *dlink_s;

  if(dlink == DLT_LINUX_SLL) {
    // try to upgrade to DLT_LINUX_SLL2
    pcap_set_datalink(pd, DLT_LINUX_SLL2);
    dlink = pcap_datalink(pd);
  }

  switch(dlink) {
    case DLT_RAW:
      ipoffset = 0;
      dlink_s = "raw";
      break;
    case DLT_EN10MB:
      ipoffset = 14;
      dlink_s = "ethernet";
      break;
    case DLT_LINUX_SLL:
      ipoffset = SLL_HDR_LEN;
      dlink_s = "SLL";
      break;
    case DLT_LINUX_SLL2:
      ipoffset = SLL2_HDR_LEN;
      dlink_s = "SLL2";
      break;
    default:
      log_i("[%s] unsupported datalink: %d", ifname, dlink);
      pcap_close(pd);
      return PCAPD_UNSUPPORTED_DATALINK;
  }

  struct bpf_program fcode;

  // Only IP traffic
  if(pcap_compile(pd, &fcode, rt->bpf, 1, PCAP_NETMASK_UNKNOWN) < 0) {
    log_i("[%s] could not set capture filter: %s", ifname, pcap_geterr(pd));
    pcap_close(pd);
    return PCAPD_INTERFACE_OPEN_FAILED;
  }

  if(pcap_setfilter(pd, &fcode) < 0) {
    log_e("[%s] pcap_setfilter failed: %s", ifname, pcap_geterr(pd));
    pcap_freecode(&fcode);
    pcap_close(pd);
    return PCAPD_INTERFACE_OPEN_FAILED;
  }
  pcap_freecode(&fcode);

  // Success
  iface->pd = pd;
  iface->is_file = is_file;
  iface->mac = 0;
  iface->ifid = ifid;
  iface->ifidx = if_nametoindex(ifname);

  errno = 0;
  if(!is_file && (dlink == DLT_EN10MB) && (get_iface_mac(ifname, &iface->mac) < 0))
    log_i("Could not get interface \"%s\" MAC[%d]: %s", ifname, errno, strerror(errno));

  uint32_t netmask;
  iface->ip = 0;
  if(!is_file && get_iface_ip(ifname, &iface->ip, &netmask) < 0)
    log_i("Could not get interface \"%s\" IP[%d]: %s", ifname, errno, strerror(errno));

  if(!is_file && get_iface_ip6(ifname, &iface->ip6) < 0) {
    log_i("Could not get interface \"%s\" IPv6[%d]: %s", ifname, errno, strerror(errno));
    memset(&iface->ip6, 0, sizeof(iface->ip6));
  }

  iface->dlink = dlink;
  iface->ipoffset = ipoffset;
  iface->pf = pcap_get_selectable_fd(pd);
  rt->maxfd = max(rt->maxfd, iface->pf);

  if(is_file) {
    char *last_slash = strrchr(ifname, '/');
    if(last_slash)
      ifname = last_slash + 1;
  }

  strncpy(iface->name, ifname, sizeof(iface->name));
  iface->name[sizeof(iface->name) - 1] = '\0';

  log_d("%s(%d): datalink=%s(%d)", iface->name, iface->ifidx, dlink_s, dlink);

  return PCAPD_OK;
}

/* ******************************************************* */

static void close_interface(pcapd_runtime_t *rt, pcapd_iface_t *iface) {
  if(!iface->pd)
    return;

  // Account the stats
  pcap_stats(iface->pd, &iface->stats);
  sum_stats(&rt->stats, &iface->stats);

  FD_CLR(iface->pf, &rt->sel_fds);
  pcap_close(iface->pd);
  iface->pd = NULL;
  iface->pf = -1;
  iface->ifidx = -1;
  iface->name[0] = '\0';
}

/* ******************************************************* */

static void check_inet_interface(pcapd_runtime_t *rt) {
  addr_t pubaddr = {.v4 = 0x60060606}; // arbitrary IPv4 public address
  route_info_t ri = {.ifidx = -1};
  char ifname[IFNAMSIZ];

  if(!rt->inet_iface)
    return;

  if((nl_get_route(AF_INET, &pubaddr, &ri) < 0) || (ri.ifidx == rt->inet_iface->ifidx)) {
    //log_i("check_inet_interface: nope [%s] - %d", rt->ifname, ri.ifidx);
    return;
  }

  if(if_indextoname(ri.ifidx, ifname) == NULL) {
    log_i("could not get ifidx %d ifname", ri.ifidx);
    return;
  }

  log_i("Internet interface changed [%d -> %d], (re)starting capture", rt->inet_iface->ifidx, ri.ifidx);

  pcap_t *old_pd = rt->inet_iface->pd;

  if(open_interface(rt->inet_iface, rt, ifname, rt->conf->inet_ifid) != PCAPD_OK)
    return;

  // Success
  if(old_pd) {
    // Account the stats before closing the interface
    pcap_stats(old_pd, &rt->inet_iface->stats);
    sum_stats(&rt->stats, &rt->inet_iface->stats);
    pcap_close(old_pd);
  }

  log_i("\"%s\" is the new internet interface", ifname);
}

/* ******************************************************* */

static pcapd_iface_t* iface_by_ifidx(pcapd_runtime_t *rt, int ifidx) {
  for(int i=0; i<rt->conf->num_interfaces; i++) {
    if(rt->ifaces[i].ifidx == ifidx)
      return &rt->ifaces[i];
  }

  return NULL;
}

/* ******************************************************* */

static int handle_nl_message(pcapd_runtime_t *rt) {
  pcapd_iface_t *iface;

  struct iovec iov = {
    .iov_base = rt->nlbuf,
    .iov_len = sizeof(rt->nlbuf)
  };

  struct sockaddr_nl snl;
  struct msghdr msg = {
    .msg_name = (void *)&snl,
    .msg_namelen = sizeof(snl),
    .msg_iov = &iov,
    .msg_iovlen = 1
  };

  ssize_t len = recvmsg(rt->nlroute_sock, &msg, 0);
  uint8_t recheck_inet = 0;

#ifdef READ_FROM_PCAP
  return 0;
#endif

  if(len <= 0) {
    log_e("netlink recvmsg failed [%d]: %s\n", errno, strerror(errno));
    return -1;
  }

  for(struct nlmsghdr *nh = (struct nlmsghdr *)rt->nlbuf; NLMSG_OK(nh, len); nh = NLMSG_NEXT(nh, len)) {
    uint8_t do_break = 0;

    switch(nh->nlmsg_type) {
      case NLMSG_DONE:
        do_break = 1;
        break;
      case RTM_NEWROUTE:
      case RTM_NEWRULE:
        recheck_inet = 1;
        break;
      case RTM_NEWADDR:
        if((iface = iface_by_ifidx(rt, ((struct ifaddrmsg *) NLMSG_DATA(nh))->ifa_index)) != NULL) {
          log_i("Detected possible IP address change");

          uint32_t netmask;
          if(get_iface_ip(iface->name, &iface->ip, &netmask) < 0)
            log_i("Could not get interface \"%s\" IP[%d]: %s", iface->name, errno, strerror(errno));

          if(get_iface_ip6(iface->name, &iface->ip6) < 0) {
            log_i("Could not get interface \"%s\" IPv6[%d]: %s", iface->name, errno, strerror(errno));
            memset(&iface->ip6, 0, sizeof(iface->ip6));
          }
        }
        break;
      case RTM_DELLINK:
        if((iface = iface_by_ifidx(rt, ((struct ifaddrmsg *) NLMSG_DATA(nh))->ifa_index)) != NULL) {
          // libpcap sometimes does not detect that an interface was removed. Making it necessary
          // to subscribe to RTMGRP_LINK
          log_i("RTM_DELLINK: interface %s deleted", iface->name);

          if(rt->inet_iface && (iface->ifidx == rt->inet_iface->ifidx))
            recheck_inet = 1;

          close_interface(rt, iface);
        }
        break;
    }

    if(do_break)
      break;
  }

  if(recheck_inet)
    check_inet_interface(rt);

  return 0;
}

/* ******************************************************* */

// try to determine the packet direction as it is only available in SLL / SLL2 ("any" interface)
static int is_tx_packet(pcapd_iface_t *iface, const u_char *pkt, u_int16_t len) {
  // TODO check for broadcast / multicast
  if((iface->dlink == DLT_EN10MB) && (len >= 14)) {
    // Ethernet header present
    struct ethhdr *eth = (struct ethhdr *) pkt;
    uint64_t smac = bytes2mac(eth->h_source);
    uint64_t dmac = bytes2mac(eth->h_dest);

    if(smac != dmac) {
      if(smac == iface->mac)
        return 1; // TX
      else if(dmac == iface->mac)
        return 0; // RX
    }

    len -= 14;
    pkt += 14;
  } else if((iface->dlink == DLT_LINUX_SLL) && (len >= SLL_HDR_LEN)) {
    struct sll_header *sll = (struct sll_header*) pkt;
    uint16_t pkttype = ntohs(sll->sll_pkttype);

    if(pkttype == LINUX_SLL_HOST)
      return 0; // RX
    else if(pkttype == LINUX_SLL_OUTGOING)
      return 1; // TX

    len -= SLL_HDR_LEN;
    pkt += SLL_HDR_LEN;
  } else if((iface->dlink == DLT_LINUX_SLL2) && (len >= SLL2_HDR_LEN)) {
    struct sll2_header *sll2 = (struct sll2_header*) pkt;
    uint16_t pkttype = ntohs(sll2->sll2_pkttype);

    if(pkttype == LINUX_SLL_HOST)
      return 0; // RX
    else if(pkttype == LINUX_SLL_OUTGOING)
      return 1; // TX

    len -= SLL2_HDR_LEN;
    pkt += SLL2_HDR_LEN;
  }

  // NOTE: this must be IPv4/IPv6 traffic due to the PCAP filter
  if(len < 20)
    return 0;

  struct iphdr *ip = (struct iphdr *) pkt;

  if(ip->version == 4) {
    if(ip->daddr == iface->ip)
      return 0; // RX
  } else if((ip->version == 6) && (len >= sizeof(struct ipv6hdr))) {
    struct ipv6hdr *hdr = (struct ipv6hdr *) pkt;

    if(memcmp(&hdr->daddr, &iface->ip6, sizeof(iface->ip6)) == 0)
      return 0; // RX
  }

  return 1; // by default assume TX
}

/* ******************************************************* */

static void get_selectable_fds(pcapd_runtime_t *rt, fd_set *fds) {
  FD_ZERO(fds);

  if(rt->client > 0)
    FD_SET(rt->client, fds);

  if(rt->nlroute_sock > 0)
    FD_SET(rt->nlroute_sock, fds);

  for(int i=0; i<rt->conf->num_interfaces; i++) {
    if(rt->ifaces[i].pf != -1)
      FD_SET(rt->ifaces[i].pf, fds);
  }
}

/* ******************************************************* */

static pcapd_rv read_pkt(pcapd_runtime_t *rt, pcapd_iface_t *iface, time_t now) {
  struct pcap_pkthdr *hdr;
  const u_char *pkt;
  int to_skip = iface->ipoffset;
  int rv = pcap_next_ex(iface->pd, &hdr, &pkt);

  if(rv != 1) {
    if(rv == PCAP_ERROR) {
      log_i("pcap_next_ex failed: %s", pcap_geterr(iface->pd));
      close_interface(rt, iface);

      if(iface == rt->inet_iface)
        // Do not abort, just wait for route/interface changes
        return PCAPD_OK;

      // abort, resuming other interfaces is not supported yet
      return PCAPD_PCAP_READ_ERROR;
    } else if(rv == PCAP_ERROR_BREAK)
      return PCAPD_EOF;

    // can be reached when the packet buffer timeout expires
    return PCAPD_OK;
  }

  if(hdr->caplen >= to_skip) {
    pcapd_hdr_t phdr;
    zdtun_pkt_t zpkt;
    int len = hdr->caplen;
    int uid = UID_UNKNOWN;
    uint8_t is_tx = is_tx_packet(iface, pkt, len);

    if(hdr->caplen < hdr->len)
      log_w("Packet truncated: %d/%d", hdr->caplen, hdr->len);

    pkt += to_skip;
    len -= to_skip;

    if(zdtun_parse_pkt(rt->tun, (const char*)pkt, len, &zpkt) == 0) {
      if(!is_tx) {
        // Packet from the internet, swap src and dst
        tupleSwapPeers(&zpkt.tuple);
      }

      if(!iface->is_file) {
        uid = uid_lru_find(rt->lru, &zpkt.tuple);

        if(uid == -2) {
          if((rt->nldiag_sock > 0) && (zpkt.tuple.ipproto != IPPROTO_ICMP)) {
            // retrieve via netlink
            uid = nl_get_uid(rt->nldiag_sock, &zpkt.tuple);

            if((uid < 0) && (uid != UID_UNKNOWN)) {
              log_e("nl_get_uid failed with error %d [%d]: %s", uid, errno, strerror(errno));
              close(rt->nldiag_sock);
              rt->nldiag_sock = -1;

              // fallback to slow method
              uid = get_uid(rt->resolver, &zpkt.tuple);
            }
          } else
            // slow method
            uid = get_uid(rt->resolver, &zpkt.tuple);

          uid_lru_add(rt->lru, &zpkt.tuple, uid);
        }
      }
    }

    // export packet even if zdtun_parse_pkt failed
    if(!rt->conf->uid_filter || matches_uid_filter(rt->conf->uid_filter, uid)) {
      if(rt->conf->dump_datalink) {
        // Include the datalink header
        pkt -= to_skip;
        len += to_skip;
        phdr.linktype = iface->dlink;
      } else
        phdr.linktype = DLT_RAW;

      phdr.ts = hdr->ts;
      phdr.len = len;
      phdr.pkt_drops = iface->stats.ps_drop;
      phdr.uid = uid;
      phdr.flags = is_tx ? PCAPD_FLAG_TX : 0;
      phdr.ifid = iface->ifid;

      if(!rt->conf->no_client) {
        // Send the pcapd_hdr_t first, then the packet data. The packet data always starts with
        // the IP header.
        if((xwrite(rt->client, &phdr, sizeof(phdr)) < 0) ||
           (xwrite(rt->client, pkt, phdr.len) < 0)) {
          log_e("write failed[%d]: %s", errno, strerror(errno));
          return PCAPD_SOCKET_WRITE_ERROR;
        }
      } else if(!rt->conf->quiet) {
        char buf[512];
        zdtun_5tuple2str(&zpkt.tuple, buf, sizeof(buf));

        printf("[%s:%d] %s (%u B) [%cX] (%d)\n", iface->name,
            iface->ifid, buf, phdr.len, is_tx ? 'T' : 'R',
            uid);
      }

      if(iface->is_file) {
        // libpcap does not provide stats for savefiles
        // https://www.tcpdump.org/manpages/pcap_stats.3pcap.html
        iface->stats.ps_recv++;
      }
    }
  }

  if(now >= iface->next_stats_update) {
    // TODO stats for all the interfaces
    pcap_stats(iface->pd, &iface->stats);
    iface->next_stats_update = now + 3;
  }

  return PCAPD_OK;
}

/* ******************************************************* */

pcapd_rv run_pcap_dump(pcapd_conf_t *conf) {
  pcapd_rv rv = PCAPD_ERROR;
  struct timespec ts = {0};
  pcapd_runtime_t rt = {0};
  time_t next_interface_recheck = 0;
  zdtun_callbacks_t callbacks = {.send_client = (void*)1};

  if(conf->quiet && (loglevel < ANDROID_LOG_ERROR))
    loglevel = ANDROID_LOG_ERROR;

  if(!(rt.tun = zdtun_init(&callbacks, NULL)))
    goto cleanup;

  if(init_pcapd_capture(&rt, conf) < 0)
    goto cleanup;

  int l = snprintf(rt.bpf, sizeof(rt.bpf), "ip or ip6");

  if(conf->bpf && conf->bpf[0])
    snprintf(rt.bpf + l, sizeof(rt.bpf) - l, " and (%s)", conf->bpf);

  log_d("Using BPF: %s", rt.bpf);

  check_inet_interface(&rt);

  for(int i=0; i<conf->num_interfaces; i++) {
    if((strcmp(conf->ifnames[i], "@inet") != 0)
          && (rv = open_interface(&rt.ifaces[i], &rt, conf->ifnames[i], i)) != PCAPD_OK)
      goto cleanup;
  }

  rv = PCAPD_OK;
  running = 1;
  get_selectable_fds(&rt, &rt.sel_fds);

  while(running) {
    struct timeval timeout = {.tv_sec = 1, .tv_usec = 0};
    fd_set fds = rt.sel_fds;

    if(select(rt.maxfd + 1, &fds, NULL, NULL, &timeout) < 0) {
      if(errno != EINTR) {
        log_e("select failed[%d]: %s", errno, strerror(errno));
        rv = PCAPD_ERROR;
      }
      break;
    }

    clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);
    time_t now = ts.tv_sec;

    if((rt.client > 0) && FD_ISSET(rt.client, &fds)) {
      log_i("Client closed");
      break;
    } else if((rt.nlroute_sock > 0) && FD_ISSET(rt.nlroute_sock, &fds)) {
      if(handle_nl_message(&rt) < 0) {
        rv = PCAPD_NETLINK_ERROR;
        break;
      }

      // Interfaces may have changed, refresh fds
      get_selectable_fds(&rt, &rt.sel_fds);
    } else {
      for(int i=0; i<rt.conf->num_interfaces; i++) {
        if((rt.ifaces[i].pf != -1) && FD_ISSET(rt.ifaces[i].pf, &fds)) {
          if((rv = read_pkt(&rt, &rt.ifaces[i], now)) != PCAPD_OK) {
            if(rv == PCAPD_EOF)
              rv = PCAPD_OK;
            running = 0;
            break;
          }
        }
      }
    }

    if(rt.inet_iface && (rt.inet_iface->pd == NULL) && (now >= next_interface_recheck)) {
      check_inet_interface(&rt);
      next_interface_recheck = now + 2;
    }
  }

  log_i("Terminating...");

cleanup:
  finish_pcapd_capture(&rt);

  if(rt.tun)
    zdtun_finalize(rt.tun);

  log_i("Pkts: %u rcvd, %u drops (%.1f%%), %u iface_drops", rt.stats.ps_recv, rt.stats.ps_drop,
        rt.stats.ps_drop * 100.f / (rt.stats.ps_recv + rt.stats.ps_drop + 1),
        rt.stats.ps_ifdrop);

  unlink(PCAPD_PID);

  for(int i=0; i<conf->num_interfaces; i++)
    free(conf->ifnames[i]);

  free(conf->uid_filter);
  free(conf->bpf);
  free(conf->log_file);

  if(logf)
    fclose(logf);

  return rv;
}

/* ******************************************************* */

static void usage() {
  fprintf(stderr, "pcapd - root capture tool of PCAPdroid\n"
    "Copyright 2021-23 Emanuele Faranda <black.silver@hotmail.it>\n\n"
    "Usage: pcapd [OPTIONS]\n"
    " -i [ifname]    capture packets on the specified interface. Can be specified\n"
    "                multiple times. The '@inet' keyword can be used to capture from\n"
    "                the internet interface\n"
    " -d             daemonize the process\n"
    " -t             dump the interface datalink header. Default: don't dump\n"
    " -u [uid, ...]  filter packets by the specified UIDs\n"
    " -b [bpf]       filter packets by BPF filter\n"
    " -l [file]      log output to the specified file\n"
    " -L uid         specify the UID to use to create the log file\n"
    " -n             do not connect to the UNIX socket, log to stdout instead\n"
    " -q             suppress non-error output\n"
  );

  exit(PCAPD_ERROR);
}

/* ******************************************************* */

void init_conf(pcapd_conf_t *conf) {
  memset(conf, 0, sizeof(pcapd_conf_t));
  conf->inet_ifid = -1;
}

/* ******************************************************* */

static void parse_args(pcapd_conf_t *conf, int argc, char **argv) {
  int c;

  init_conf(conf);
  opterr = 0;

  while ((c = getopt (argc, argv, "hdtnqi:u:b:l:L:")) != -1) {
    switch(c) {
      case 'i':
        if(conf->num_interfaces >= PCAPD_MAX_INTERFACES) {
          fprintf(stderr, "Maximum number of interfaces reached (%d)\n", PCAPD_MAX_INTERFACES);
          exit(PCAPD_ERROR);
        }
        if(strcmp(optarg, "@inet") == 0) {
          if(conf->inet_ifid != -1) {
            fprintf(stderr, "@inet interface already specified\n");
            exit(PCAPD_ERROR);
          }
          conf->inet_ifid = conf->num_interfaces;
        }
        conf->ifnames[conf->num_interfaces++] = strdup(optarg);
        break;
      case 'd':
        conf->daemonize = 1;
        break;
      case 't':
        conf->dump_datalink = 1;
        break;
      case 'n':
        conf->no_client = 1;
        break;
      case 'u':
        if (conf->uid_filter)
          free(conf->uid_filter);

        conf->uid_filter = parse_uid_filter(optarg);
        break;
      case 'b':
        if(conf->bpf) free(conf->bpf);
        conf->bpf = strdup(optarg);
        break;
      case 'l':
        if(conf->log_file) free(conf->log_file);
        conf->log_file = strdup(optarg);
        break;
      case 'L':
        conf->log_uid = atol(optarg);
        break;
      case 'q':
        conf->quiet = 1;
        break;
      default:
        usage();
    }
  }

  // No positional args
  if(optind < argc)
    usage();

  if(conf->log_file) {
    uid_t saved_uid = geteuid();

    if(conf->log_uid > 0) {
      unlink(conf->log_file);
      seteuid(conf->log_uid);
    }

    logf = fopen(conf->log_file, "w");

    if(conf->log_uid > 0)
      seteuid(saved_uid);

    if(logf == NULL)
      log_e("Could not open log file[%d]: %s", errno, strerror(errno));
  }

  if(conf->num_interfaces == 0) {
    conf->inet_ifid = 0;
    conf->ifnames[conf->num_interfaces++] = strdup("@inet");
  }
}

/* ******************************************************* */

#ifndef FUZZING

int main(int argc, char *argv[]) {
  pcapd_conf_t conf;

  logtag = "pcapd";
  logcallback = logcb;
  parse_args(&conf, argc, argv);

  return run_pcap_dump(&conf);
}

#endif

```

`app/src/main/jni/pcapd/pcapd.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * You are allowed to distribute this file with your proprietary app
 * as long as you provide proper attribution to the PCAPdroid project.
 *
 * Copyright 2021 - Emanuele Faranda
 */

#ifndef __PCAPD_H__
#define __PCAPD_H__

#define PCAPD_SOCKET_PATH  "pcapsock"
#define PCAPD_PID          "pcapd.pid"

#define PCAPD_FLAG_TX      (1 << 0)

#include <time.h>
#include <stdint.h>

// Using a snaplen large enough to avoid truncating packets even with TSO/GRO. Size is currently
// limited to 16 bits by pcapd_hdr_t.len
#define PCAPD_SNAPLEN 65535

// pcap/dlt.h
#define PCAPD_DLT_ETHERNET    1
#define PCAPD_DLT_RAW         12
#define PCAPD_DLT_LINUX_SLL   113
#define PCAPD_DLT_LINUX_SLL2  276

typedef struct {
  struct timeval ts;        // the packet timestamp
  u_int pkt_drops;          // number of dropped packets on this interface
  uid_t uid;                // the UID of the process which sent/received the packet
  uint16_t len;             // the packet length
  uint16_t linktype;        // the link type, see PCAPD_DLT_*
  uint8_t flags;            // packet flags, see PCAPD_FLAG_*
  uint8_t ifid;             // the interface id, which is the interface position in the -i args
  uint8_t pad[2];           // padding for 64bit alignment of the payload
} __attribute__((packed)) pcapd_hdr_t;

typedef enum {
    PCAPD_OK = 0,
    PCAPD_ERROR,
    PCAPD_INTERFACE_OPEN_FAILED,
    PCAPD_NETLINK_ERROR,
    PCAPD_PCAP_READ_ERROR,
    PCAPD_SOCKET_WRITE_ERROR,
    PCAPD_UNSUPPORTED_DATALINK,
    PCAPD_EOF
} pcapd_rv;

#endif

```

`app/src/main/jni/pcapd/pcapd_priv.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#ifndef __PCAPD_PRIV_H__
#define __PCAPD_PRIV_H__

#include <stdint.h>
#include <net/if.h>
#include <pcap.h>
#include <linux/limits.h>

#include "nl_utils.h"
#include "common/uid_lru.h"
#include "common/uid_resolver.h"
#include "common/utils.h"
#include "pcapd.h"
#include "zdtun.h"

#define PCAPD_MAX_INTERFACES 16

typedef struct {
  char *ifnames[PCAPD_MAX_INTERFACES];
  char *bpf;
  char *log_file;
  int* uid_filter;
  int num_interfaces;
  int inet_ifid;
  uint8_t dump_datalink;
  uint8_t daemonize;
  uint8_t no_client;
  uint8_t quiet;
  uid_t log_uid;
} pcapd_conf_t;

typedef struct {
  char name[PATH_MAX];
  int ifidx;
  uint8_t ifid;       // positional interface index
  uint8_t is_file;
  pcap_t *pd;
  int pf;
  int dlink;
  int ipoffset;
  uint64_t mac;
  uint32_t ip;
  struct in6_addr ip6;
  time_t next_stats_update;
  struct pcap_stat stats;
} pcapd_iface_t;

typedef struct {
  char bpf[512];
  char nlbuf[NL_BUFFER_SIZE];

  int nlroute_sock;
  int nldiag_sock;
  int client;

  zdtun_t *tun;
  uid_lru_t *lru;
  uid_resolver_t *resolver;
  pcapd_iface_t *inet_iface;
  pcapd_iface_t ifaces[PCAPD_MAX_INTERFACES];
  struct pcap_stat stats;
  fd_set sel_fds;
  int maxfd;
  pcapd_conf_t *conf;
} pcapd_runtime_t;

void init_conf(pcapd_conf_t *conf);
pcapd_rv run_pcap_dump(pcapd_conf_t *conf);

#endif

```

`app/src/main/jni/tests/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18.1)
project(tests)

option(FUZZING "Build for Fuzz Testing" OFF)

if(FUZZING)
  if(NOT DEFINED "LIB_FUZZING_ENGINE")
    set(LIB_FUZZING_ENGINE "-fsanitize=fuzzer")
  endif()

  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DFUZZING -g -O1 ${LIB_FUZZING_ENGINE} -fsanitize=address,undefined,leak -fno-sanitize=alignment")
endif()

#set(CMAKE_VERBOSE_MAKEFILE ON)
set(ROOTDIR ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)

add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/.. ${CMAKE_CURRENT_BINARY_DIR}/main)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/..)
include_directories(${ROOTDIR}/submodules/zdtun)
include_directories(${ROOTDIR}/submodules/nDPI/src/include)
include_directories(.)

if(FUZZING)
  add_subdirectory(fuzz)
else()
  add_subdirectory(test)
endif()

```

`app/src/main/jni/tests/Makefile`:

```
.PHONY: clean run_tests fuzz fuzz_pcapd fuzz_capture

clean:
	rm -rf build /tmp/pcapdroid_test*

run_tests:
	mkdir -p build/test
	cd build/test && \
		cmake -DCMAKE_C_COMPILER=clang -DCMAKE_C_FLAGS="-fsanitize=address,leak -DHAVE_GNU_STRERROR_R -fno-omit-frame-pointer -g -O0" ../.. && \
		$(MAKE) run_tests

fuzz:
	# Note: corpus should be specific of a single target
	mkdir -p build/${FUZZ_TARGET}
	cd build/${FUZZ_TARGET} && \
		cmake -DFUZZING=1 -DCMAKE_C_COMPILER=clang -DCMAKE_C_FLAGS="-DHAVE_GNU_STRERROR_R" ../.. && \
		$(MAKE) ${FUZZ_TARGET}
	cd build/${FUZZ_TARGET}/fuzz && \
		mkdir -p CORPUS && \
		./${FUZZ_TARGET} CORPUS ../../../../../../../../submodules/nDPI/tests/pcap ../../../pcap ${FUZZ_OPTS}

fuzz_pcapd:
	$(MAKE) FUZZ_TARGET=fuzz_pcapd fuzz

fuzz_capture:
	$(MAKE) FUZZ_TARGET=fuzz_capture fuzz

```

`app/src/main/jni/tests/README.md`:

```md
Tests and fuzzers for the native code of PCAPdroid.

The tests are built with the [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html) to detect memory issues and leaks. They are run as part of the Github workflow.

The fuzzers use [LibFuzzer](https://llvm.org/docs/LibFuzzer.html).

The targets can be run with the provided `Makefile` as follows:

```bash
# Install dependencies
apt install make clang libpcap-dev cmake

# Run the tests
# pcapd log at build/test/test/pcapd.log
make run_tests

# Fuzz the pcapd daemon
FUZZ_OPTS="-jobs=8" make fuzz_pcapd

# Fuzz the pcapdroid capture
FUZZ_OPTS="-jobs=8" make fuzz_capture
```

Cmake `3.18.1` or newer is required. If that's not available for your distribution, you can install it as follows:

```
apt purge cmake

cd /usr
wget https://github.com/Kitware/CMake/releases/download/v3.23.2/cmake-3.23.2-linux-x86_64.sh
chmod +x cmake-3.23.2-linux-x86_64.sh

# answer "n" when prompted to extract in subdir
./cmake-3.23.2-linux-x86_64.sh

# version should now be 3.23.2
cmake --version
```

The following sections describe the PCAP files contained in the `pcap` directory.

## metadata.pcap

Contains HTTP, TLS and DNS connections for both IPv4 and IPv6, suitable to test DPI.

Connections:

```
[UDP4] 192.168.1.10:48037 -> 8.8.8.8:53 [example.org]
[UDP4] 192.168.1.10:38793 -> 8.8.8.8:53 [www.google.com]
[TCP4] 192.168.1.10:36922 -> 216.58.208.164:80 [www.google.com]
[UDP4] 192.168.1.10:48772 -> 8.8.8.8:53 [www.google.com]
[TCP6] 2001:db8:1234::1:49936 -> 385d:1ee:e3c9:9c5f::2004:80 [www.google.com]
[UDP4] 192.168.1.10:51080 -> 8.8.8.8:53 [google.it]
[TCP6] 2001:db8:1234::1:44904 -> 2c9b:a9b9:83dd:d9d1::2003:443 []
[TCP4] 192.168.1.10:51588 -> 142.250.180.131:443 [google.it]
[UDP4] 192.168.1.10:42218 -> 8.8.8.8:53 [www.google.it]
[TCP6] 2001:db8:1234::1:59424 -> 3a5d:15fe:e3cb:9c5f::2003:443 [www.google.it]
[ICMP4] 192.168.1.10:4 -> 1.1.1.1:0 []
[UDP4] 192.168.1.10:47987 -> 8.8.8.8:53 [www.internetbadguys.com]
[TCP4] 192.168.1.10:46312 -> 146.112.255.155:80 [www.internetbadguys.com]
[UDP4] 192.168.1.10:51165 -> 8.8.8.8:53 [www.internetbadguys.com]
[UDP4] 192.168.1.10:52176 -> 8.8.8.8:53 [example.org]
[TCP6] 2001:db8:1234::1:45226 -> 2ed5:9050:81e9:4b68:248:1893:25c8:1946:443 [example.org]
[TCP4] 192.168.1.10:43453 -> 8.8.8.8:53 [f-droid.org]
[UDP4] 192.168.1.10:41011 -> 8.8.8.8:53 [f-droid.org]
[TCP4] 192.168.1.10:52782 -> 149.202.95.241:80 [f-droid.org]
```

## two_flows.pcap

Contains two flows. The first 20 packets of the PCAP are part of the first flow, whereas
the last 29 packets are from the second flow.

```
[TCP4] 192.168.1.10:36922 -> 216.58.208.164:80 [www.google.com]
[TCP4] 192.168.1.10:51588 -> 142.250.180.131:443 [google.it]
```

## invalid_or_unsupported.pcap

Contains packets with invalid or unsupported IP/transport headers.

- Packets with invalid length
- Packet smaller than IP header size
- UDP packet smaller than header size
- Packet with invalid IP version (0)
- Packet with non TCP/UDP/ICMP protocol (CHAOS)
- Packets with IPv6 extensions (OSPF IGP, ESP)
- IP subsequent fragment with first fragment not seen

## crash-*

These files, generated by the fuzzer, caused a crash. They are part of
the seed used by the fuzzer, which ensures no regression occurs.

```

`app/src/main/jni/tests/fuzz/CMakeLists.txt`:

```txt
add_executable(fuzz_pcapd fuzz_pcapd.c)
target_link_libraries(fuzz_pcapd libpcapd.so)

add_executable(fuzz_capture ../test_utils.c fuzz_capture.c)
target_link_libraries(fuzz_capture capture pcap)

```

`app/src/main/jni/tests/fuzz/fuzz_capture.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021-22 - Emanuele Faranda
 */

#include <pcap.h>
#include "core/pcapdroid.h"
#include "common/utils.h"
#include "pcapd/pcapd.h"
#include "test_utils.h"

/* ******************************************************* */

#include "fuzz_utils.c"

int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  char *pcap_path;

  if(!(pcap_path = buffer_to_tmpfile(Data, Size)))
    return -1;

  pcapdroid_t *pd = pd_init_test(pcap_path);

  loglevel = ANDROID_LOG_FATAL;
  pd_run(pd);

  pd_free_test(pd);
  unlink(pcap_path);
  free(pcap_path);

  return 0;
}

```

`app/src/main/jni/tests/fuzz/fuzz_pcapd.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021-22 - Emanuele Faranda
 */

#include "pcapd/pcapd_priv.h"

/* ******************************************************* */

#include "fuzz_utils.c"

int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  pcapd_conf_t conf;
  char *pcap_path;

  if(!(pcap_path = buffer_to_tmpfile(Data, Size)))
    return -1;

  init_conf(&conf);
  conf.ifnames[0] = strdup(pcap_path);
  conf.num_interfaces = 1;
  conf.no_client = 1;
  conf.quiet = 1;

  run_pcap_dump(&conf);

  unlink(pcap_path);
  free(pcap_path);

  return 0;
}

```

`app/src/main/jni/tests/fuzz_utils.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>

/* ******************************************************* */

/* Creates a temporary file to hold the specified buffer data.
 * Returns the file name string. The string must be freed. */
char* buffer_to_tmpfile(const uint8_t *buf, size_t size) {
  char fname[] = "/tmp/pcapdroid_testXXXXXX";

  int filedes = mkstemp(fname);
  if(filedes < 0) {
    perror("mkstemp failed");
    return NULL;
  }

  FILE *fd = fdopen(filedes, "wb");
  if(!fd) {
    perror("fdopen failed");
    return NULL;
  }

  int success = (fwrite(buf, 1, size, fd) == size);

  fclose(fd);
  close(filedes);

  if(!success)
    return NULL;

  return strdup(fname);
}

```

`app/src/main/jni/tests/test/CMakeLists.txt`:

```txt
include(CTest)

# Target to run tests and build them if necessary
add_custom_target(build_tests)
add_custom_target(run_tests COMMAND CTEST_OUTPUT_ON_FAILURE=1 ${CMAKE_CTEST_COMMAND})
add_dependencies(run_tests build_tests)

# test_source(target)
macro(test_source)
  add_executable(${ARGV0} ${ARGV0}.c ../test_utils.c)
  add_dependencies(${ARGV0} libpcapd.so)
  add_dependencies(build_tests ${ARGV0})

  target_link_libraries(${ARGV0} capture)
endmacro()

# Tests
test_source(pcap_reader)

test_source(dpi)
add_test(NAME dpi_extract COMMAND ./dpi extract)
add_test(NAME dpi_extract_proxy COMMAND ./dpi extract_proxy)

test_source(blacklist)
add_test(NAME blacklist_match COMMAND ./blacklist match)
add_test(NAME blacklist_detection COMMAND ./blacklist detection)

test_source(dump_api)
add_test(NAME dump_api_snaplen COMMAND ./dump_api snaplen)
add_test(NAME dump_api_max_pkts_flow COMMAND ./dump_api max_pkts_per_flow)
add_test(NAME dump_api_max_size COMMAND ./dump_api max_dump_size)

test_source(root_capture)
add_test(NAME root_capture COMMAND ./root_capture invalid_pkts)

```

`app/src/main/jni/tests/test/blacklist.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#include "test_utils.h"

/* ******************************************************* */

static void test_match() {
  blacklist_t *bl = blacklist_init();
  assert(bl != NULL);

  // Load blacklist
  assert0(blacklist_add_domain(bl, "example.org"));
  assert0(blacklist_add_ipstr(bl, "1.2.3.4"));
  assert0(blacklist_add_ipstr(bl, "::2"));
  assert0(blacklist_add_uid(bl, 777));
  assert0(blacklist_add_uid(bl, 888));

  // Use blacklist
  assert1(blacklist_match_domain(bl, "www.example.org"));
  assert1(blacklist_match_domain(bl, "some.example.org"));
  assert1(blacklist_match_domain(bl, "evil.some.example.org"));

  assert0(blacklist_match_ipstr(bl, "1.2.3.0"));
  assert1(blacklist_match_ipstr(bl, "1.2.3.4"));

  assert0(blacklist_match_ipstr(bl, "::1"));
  assert1(blacklist_match_ipstr(bl, "::2"));

  assert0(blacklist_match_uid(bl, 0));
  assert0(blacklist_match_uid(bl, 999));
  assert1(blacklist_match_uid(bl, 777));

  blacklist_destroy(bl);
}

/* ******************************************************* */

static void detection_cb(pcapdroid_t *pd) {
  conn_and_tuple_t *conn;

  // IP blacklist
  conn = assert_conn(pd, IPPROTO_ICMP, "1.1.1.1", 0, NULL);
  assert1(conn->data->blacklisted_ip);
  conn = assert_conn(pd, IPPROTO_TCP, "216.58.208.164", 80, NULL);
  assert1(conn->data->blacklisted_ip);
  conn = assert_conn(pd, IPPROTO_TCP, "2c9b:a9b9:83dd:d9d1::2003", 443, NULL);
  assert1(conn->data->blacklisted_ip);

  // Host blacklist
  conn = assert_conn(pd, IPPROTO_UDP, "8.8.8.8", 53, "www.google.it");
  assert0(conn->data->blacklisted_ip);
  assert1(conn->data->blacklisted_domain);
  conn = assert_conn(pd, IPPROTO_TCP, "146.112.255.155", 80, "www.internetbadguys.com");
  assert1(conn->data->blacklisted_domain);
  conn = assert_conn(pd, IPPROTO_TCP, "3a5d:15fe:e3cb:9c5f::2003", 443, "www.google.it");
  assert0(conn->data->blacklisted_ip);
  assert1(conn->data->blacklisted_domain);

  // Whitelist
  conn = assert_conn(pd, IPPROTO_TCP, "149.202.95.241", 80, "f-droid.org");
  assert0(conn->data->blacklisted_domain);
  assert0(conn->data->blacklisted_ip);
  conn = assert_conn(pd, IPPROTO_TCP, "2ed5:9050:81e9:4b68:248:1893:25c8:1946", 443, "example.org");
  assert0(conn->data->blacklisted_domain);
  assert0(conn->data->blacklisted_ip);
}

static void test_detection() {
  pcapdroid_t *pd = pd_init_test(PCAP_PATH "/metadata.pcap");

  blacklist_t *bl = blacklist_init();
  assert(bl != NULL);
  blacklist_t *wl = blacklist_init();
  assert(wl != NULL);
  pd->malware_detection.enabled = true;
  pd->malware_detection.bl = bl;
  pd->malware_detection.whitelist = wl;

  // Load blacklist
  blacklist_add_ipstr(bl, "1.1.1.1");
  blacklist_add_ipstr(bl, "216.58.208.164");
  blacklist_add_ipstr(bl, "2c9b:a9b9:83dd:d9d1::2003");
  blacklist_add_ipstr(bl, "149.202.95.241");
  blacklist_add_domain(bl, "google.it");
  blacklist_add_domain(bl, "www.internetbadguys.com");
  blacklist_add_domain(bl, "example.org");

  // Load whitelist
  blacklist_add_ipstr(wl, "149.202.95.241");
  blacklist_add_domain(wl, "example.org");

  // Run
  pd->cb.send_connections_dump = detection_cb;
  pd_run(pd);

  pd_free_test(pd);
}

/* ******************************************************* */

int main(int argc, char **argv) {
  add_test("match", test_match);
  add_test("detection", test_detection);

  run_test(argc, argv);
  return 0;
}

```

`app/src/main/jni/tests/test/dpi.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#define _GNU_SOURCE // for memmem
#include "test_utils.h"

/* ******************************************************* */

// Called on send_connections_dump. pd->new_conns contains the dumped
// connections. Ensures that metadata is correctly extracted from
// network traffic.
static void extract_metadata_cb(pcapdroid_t *pd) {
  conn_and_tuple_t *conn;

  // DNS request without reply
  conn = assert_conn(pd, IPPROTO_UDP, "8.8.8.8", 53, "example.org");
  assert(conn->tuple.src_port == htons(48037));

  // DNS (TCP)
  assert_conn(pd, IPPROTO_TCP, "8.8.8.8", 53, "f-droid.org");

  // Guess host name from previous DNS request
  assert_conn(pd, IPPROTO_TCP, "149.202.95.241", 80, "f-droid.org");

  // HTTP
  conn = assert_conn(pd, IPPROTO_TCP, "216.58.208.164", 80, "www.google.com");
  assert(!strcmp(conn->data->url, "www.google.com/imghp?test=1&v2=2"));
  conn = assert_conn(pd, IPPROTO_TCP, "385d:1ee:e3c9:9c5f::2004", 80, "www.google.com");
  assert(!strcmp(conn->data->url, "www.google.com/imghp?test=1&v2=2"));

  // TLS
  conn = assert_conn(pd, IPPROTO_TCP, "142.250.180.131", 443, "google.it");
  assert(conn->data->l7proto == NDPI_PROTOCOL_TLS);
  conn = assert_conn(pd, IPPROTO_TCP, "2ed5:9050:81e9:4b68:248:1893:25c8:1946", 443, "example.org");
  assert(conn->data->l7proto == NDPI_PROTOCOL_TLS);
}

static void test_metadata_extraction() {
  pcapdroid_t *pd = pd_init_test(PCAP_PATH "/metadata.pcap");

  pd->cb.send_connections_dump = extract_metadata_cb;
  pd_run(pd);

  pd_free_test(pd);
}

/* ******************************************************* */

static void extract_proxy_cb(pcapdroid_t *pd) {
    // HTTP proxy
    conn_and_tuple_t * conn = assert_conn(pd, IPPROTO_TCP, "85.25.246.38", 8080, "weberblog.net");
    assert(conn->data->l7proto == NDPI_PROTOCOL_HTTP);
    assert(!strcmp(conn->data->url, "15.35.226.136:443"));

    // payload extraction
    payload_chunk_t *chunk = (payload_chunk_t*) conn->data->payload_chunks;
    assert(chunk != NULL);
    assert(memmem(chunk->payload, chunk->size, "CONNECT 15.35.226.136:443", 25) != 0);
}

static void test_proxy_extraction() {
    pcapdroid_t *pd = pd_init_test(PCAP_PATH "/http_proxy.pcap");

    pd->cb.dump_payload_chunk = dump_cb_payload_chunk;
    pd->cb.send_connections_dump = extract_proxy_cb;
    pd_run(pd);

    pd_free_test(pd);
}

/* ******************************************************* */

int main(int argc, char **argv) {
  add_test("extract", test_metadata_extraction);
  add_test("extract_proxy", test_proxy_extraction);

  run_test(argc, argv);
  return 0;
}

```

`app/src/main/jni/tests/test/dump_api.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#include "test_utils.h"

#define TEST_SNAPLEN 256
#define TEST_MAX_PKTS 8
#define TEST_MAX_SIZE 10240

/* ******************************************************* */

/* Tests that packets are correctly truncated to honor the "snaplen"
 * dump parameter. */
static void test_snaplen() {
  pcap_hdr_t hdr;
  pcap_rec_t rec;
  pcapdroid_t *pd = pd_init_test(PCAP_PATH "/metadata.pcap");
  bool at_least_one_pkt_truncated = false;

  // Run
  pd->pcap_dump.snaplen = TEST_SNAPLEN;
  pd_dump_to_file(pd);
  pd_run(pd);
  pd_done_dump();

  // Verify
  assert_pcap_header(&hdr);
  assert(hdr.snaplen == TEST_SNAPLEN);

  // The size of all the packets must be <= of the snaplen
  while(next_pcap_record(&rec)) {
    assert(rec.incl_len <= TEST_SNAPLEN);
    at_least_one_pkt_truncated |= (rec.incl_len != rec.orig_len);
  }

  // For this test to be effective, at least one packet must be trucated
  // due to the snaplen
  assert(at_least_one_pkt_truncated);

  pd_free_test(pd);
}

/* ******************************************************* */

/* Tests that at most "max_pkts_per_flow" packets are dumped for each
 * flow. */
static void max_pkts_per_flow() {
  pcap_hdr_t hdr;
  pcap_rec_t rec;
  u_char *buf;
  int num_pkts = 0;
  pcapdroid_t *pd = pd_init_test(PCAP_PATH "/two_flows.pcap");
  zdtun_ip_t local_ip, ip1, ip2;

  assert(zdtun_parse_ip("192.168.1.10", &local_ip) == 4);
  assert(zdtun_parse_ip("216.58.208.164", &ip1) == 4);
  assert(zdtun_parse_ip("142.250.180.131", &ip2) == 4);

  // Run
  pd->pcap_dump.max_pkts_per_flow = TEST_MAX_PKTS;
  pd_dump_to_file(pd);
  pd_run(pd);
  pd_done_dump();

  // Verify
  assert_pcap_header(&hdr);

  while((buf = next_pcap_record(&rec))) {
    zdtun_pkt_t pkt;
    zdtun_ip_t *expected_ip;
    zdtun_ip_t *remote_ip;
    zdtun_ip_t src_ip, dst_ip;

    assert0(zdtun_parse_pkt(pd->zdt, (char*)buf, rec.incl_len, &pkt));
    src_ip = pkt.tuple.src_ip;
    dst_ip = pkt.tuple.dst_ip;

    remote_ip = (zdtun_cmp_ip(4, &src_ip, &local_ip) == 0) ?
        &dst_ip : &src_ip;

#if 0
    char ip[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, remote_ip, ip, sizeof(ip));
    log_i("IP: %s", ip);
#endif

    // The pcap files contains two consecutive flows. PCAPdroid must
    // only dump the first TEST_MAX_PKTS of each flow.
    expected_ip = (num_pkts < TEST_MAX_PKTS) ? &ip1 : &ip2;
    assert_ip_equal(4, remote_ip, expected_ip);

    num_pkts++;
  }

  assert(num_pkts == 2 * TEST_MAX_PKTS);

  pd_free_test(pd);
}

/* ******************************************************* */

/* Tests that at most "max_dump_size" bytes are dumped. */
static void max_dump_size() {
  pcap_hdr_t hdr;
  pcap_rec_t rec;
  pcapdroid_t *pd = pd_init_test(PCAP_PATH "/metadata.pcap");
  u_int dump_size;

  // Run
  pd->pcap_dump.max_dump_size = TEST_MAX_SIZE;
  pd_dump_to_file(pd);
  pd_run(pd);
  pd_done_dump();

  // Verify
  assert_pcap_header(&hdr);
  dump_size = sizeof(hdr);

  while(next_pcap_record(&rec))
    dump_size += sizeof(rec) + rec.incl_len;

  assert(dump_size <= TEST_MAX_SIZE);

  pd_free_test(pd);
}

/* ******************************************************* */

int main(int argc, char **argv) {
  add_test("snaplen", test_snaplen);
  add_test("max_pkts_per_flow", max_pkts_per_flow);
  add_test("max_dump_size", max_dump_size);

  run_test(argc, argv);
  return 0;
}

```

`app/src/main/jni/tests/test/pcap_reader.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#include <stdio.h>
#include <signal.h>
#include "test_utils.h"
#include "common/utils.h"

/* ******************************************************* */

static void usage() {
  fprintf(stderr, "pcap_reader - test for PCAPdroid\n"
    "Copyright 2022 Emanuele Faranda <black.silver@hotmail.it>\n\n"
    "Usage: pcap_reader -i ifname\n"
    " -i [ifname]    capture packets on the specified interface or PCAP file.\n"
    "                The '@inet' keyword can be used to capture from the internet\n"
    "                interface\n"
  );

  exit(1);
}

/* ******************************************************* */

static void sig_handler(int signo) {
  if(running) {
    running = false;
    return;
  }

  fprintf(stderr, "exit now");
  exit(1);
}

/* ******************************************************* */

static void dump_connections(pcapdroid_t *pd) {
  char buf[256];

  for(int i=0; i < pd->new_conns.cur_items; i++) {
    conn_and_tuple_t *conn = &pd->new_conns.items[i];

    zdtun_5tuple2str(&conn->tuple, buf, sizeof(buf));
    printf("%s [%s]\n", buf,
      //pd_get_proto_name(pd, conn->data->l7proto, conn->tuple.ipproto),
      conn->data->info ? conn->data->info : "");
  }
}

/* ******************************************************* */

int main(int argc, char *argv[]) {
  int c;
  char *ifname = NULL;
  uint8_t verbose = 0;

  while((c = getopt(argc, argv, "hi:v")) != -1) {
    switch(c) {
      case 'i':
        ifname = strdup(optarg);
        break;
      case 'v':
        verbose = 1;
        break;
      default:
        usage();
    }
  }

  if(ifname == NULL)
    usage();

  loglevel = verbose ? ANDROID_LOG_DEBUG : ANDROID_LOG_INFO;

  pcapdroid_t *pd = pd_init_test(ifname);
  pd->cb.send_connections_dump = dump_connections;

  signal(SIGINT, sig_handler);
  signal(SIGTERM, sig_handler);
  signal(SIGHUP, sig_handler);

  log_i("Capturing packets from %s", ifname);
  pd_run(pd);

  log_i("Cleanup...");
  pd_free_test(pd);
  free(ifname);
}

```

`app/src/main/jni/tests/test/root_capture.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022 - Emanuele Faranda
 */

#include "test_utils.h"

#define NUM_PKTS 15

/* ******************************************************* */

/* Tests that invalid/unsupported IP packets are still dumped by PCAPdroid */
static void invalid_pkts() {
  pcap_hdr_t hdr;
  pcap_rec_t rec;
  pcapdroid_t *pd = pd_init_test(PCAP_PATH "/invalid_or_unsupported.pcap");
  int num_pkts = 0;

  // Run
  pd_dump_to_file(pd);
  pd_run(pd);
  pd_done_dump();

  // Verify
  assert_pcap_header(&hdr);

  while(next_pcap_record(&rec))
    num_pkts++;

  assert(num_pkts == NUM_PKTS);
  pd_free_test(pd);
}

/* ******************************************************* */

int main(int argc, char **argv) {
  add_test("invalid_pkts", invalid_pkts);

  run_test(argc, argv);
  return 0;
}

```

`app/src/main/jni/tests/test_utils.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022-26 - Emanuele Faranda
 */

#include "test_utils.h"

#define TEST_NAME_MAX_LENGTH 32
#define MAX_TESTS 32

typedef struct {
  char name[TEST_NAME_MAX_LENGTH];
  void (*cb)();
} test_spec;

static test_spec all_tests[MAX_TESTS] = {0};
static FILE *out_fp = NULL;
static u_char pcap_read_buf[65535];

static payload_chunk_t **chunks_lists_heads = NULL;
static int num_chunks_lists = 0;
static void free_payload_chunks(pcapdroid_t *pd);

/* ******************************************************* */

static void getNativeLibPath(struct pcapdroid *pd, const char *prog_name, char *buf, int bufsize) {
    if (strcmp(prog_name, "pcapd") == 0)
        snprintf(buf, bufsize, "../main/pcapd/libpcapd.so");
    else {
        fprintf(stderr, "Unknown native library: %s", prog_name);

        if (bufsize > 0)
            buf[0] = '\0';
    }
}

/* ******************************************************* */

void add_test(const char *name, void (*test_cb)()) {
  int len = strlen(name);
  assert(len < TEST_NAME_MAX_LENGTH);

  for(int i=0; i<MAX_TESTS; i++) {
    if(all_tests[i].cb == NULL) {
      memcpy(all_tests[i].name, name, len); // \0 is already there
      all_tests[i].cb = test_cb;
      return;
    }
  }

  // MAX_TESTS exceeded
  assert(0);
}

/* ******************************************************* */

void run_test(int argc, char **argv) {
  assert(argc == 2);
  const char *test_name = argv[1];
  test_spec *test = NULL;

  for(int i=0; ((i < MAX_TESTS) && (all_tests[i].cb != NULL)); i++) {
    if(!strcmp(all_tests[i].name, test_name)) {
      test = &all_tests[i];
      break;
    }
  }

  assert(test != NULL);

  // run the test
  test->cb();
}

/* ******************************************************* */

pcapdroid_t* pd_init_test(const char *ifname) {
  pcapdroid_t *pd = calloc(1, sizeof(pcapdroid_t));
  assert(pd != NULL);

  pd->vpn_capture = false;
  pd->pcap_file_capture = true;
  pd->pcap.capture_interface = (char*) ifname;
  pd->pcap.as_root = false;   // don't run as root
  pd->cb.get_libprog_path = getNativeLibPath;
  pd->payload_mode = PAYLOAD_MODE_FULL;

  strcpy(pd->cachedir, ".");
  pd->cachedir_len = 1;

  return pd;
}

/* ******************************************************* */

void pd_free_test(pcapdroid_t *pd) {
  free(pd);

  if(out_fp)
    fclose(out_fp);
  free_payload_chunks(pd);
}

/* ******************************************************* */

/* To be called during send_connections_dump. Looks up a connection
 * matching the specified protocol, IP port and info (if not NULL).
 * If no connection is found, abort is called. Only the first match is
 * returned.
 */
conn_and_tuple_t* assert_conn(pcapdroid_t *pd, int ipproto, const char *dst_ip,
          uint16_t dst_port, const char *info) {
  conn_and_tuple_t *found = NULL;
  zdtun_ip_t ip;
  dst_port = htons(dst_port);

  int ipver = zdtun_parse_ip(dst_ip, &ip);
  assert((ipver == 4) || (ipver == 6));

  for(int i=0; i < pd->new_conns.cur_items; i++) {
    conn_and_tuple_t *conn = &pd->new_conns.items[i];
    zdtun_ip_t dst_ip = conn->tuple.dst_ip;

    if((conn->tuple.ipproto == ipproto) &&
       (conn->tuple.dst_port == dst_port) &&
       (conn->tuple.ipver == ipver) &&
       (!zdtun_cmp_ip(ipver, &dst_ip, &ip)) &&
       ((info == NULL) || ((conn->data->info != NULL) && !strcmp(info, conn->data->info)))) {
      found = conn;
      break;
    }
  }

  assert(found);
  return found;
}

/* ******************************************************* */

static void dump_to_file_cb(struct pcapdroid *pd, const int8_t *buf, int len) {
  if(out_fp == NULL) {
    out_fp = fopen(PCAP_OUT_PATH, "wb+");

    if(!out_fp) {
      perror("Could not create PCAP file");
      exit(1);
    }

    // write the PCAP header
    pcap_hdr_t *hdr;
    assert(pcap_get_preamble(pd->pcap_dump.dumper, (char **)&hdr) == sizeof(*hdr));
    assert(fwrite(hdr, sizeof(*hdr), 1, out_fp) == 1);
    pd_free(hdr);
  }

  assert(fwrite(buf, len, 1, out_fp) == 1);
  fflush(out_fp);
}

/* Dump the packets to PCAP_OUT_PATH */
void pd_dump_to_file(pcapdroid_t *pd) {
  pd->cb.send_pcap_dump = dump_to_file_cb;
  pd->pcap_dump.enabled = 1;
}

/* ******************************************************* */

/* To be called with pd_dump_to_file after finishing dumping the file,
 * before any assert_pcap_*. */
void pd_done_dump() {
  assert(out_fp != NULL);

  fseek(out_fp, 0, SEEK_SET);
}

/* ******************************************************* */

/* Reads the PCAP header from the dump file and verify that is valid. */
void assert_pcap_header(pcap_hdr_t *hdr) {
  assert(out_fp != NULL);

  assert(fread(hdr, sizeof(pcap_hdr_t), 1, out_fp) == 1);

  assert(hdr->magic_number == 0xa1b2c3d4);
  assert(hdr->version_major == 2);
  assert(hdr->version_minor == 4);
}

/* ******************************************************* */

/* Reads a PCAP record and returns a buffer pointing to its data.
 * The data length available in the buffer is rec->incl_len.
 * Returns NULL on EOF. */
u_char* next_pcap_record(pcap_rec_t *rec) {
  int rv = fread(rec, sizeof(pcap_rec_t), 1, out_fp);

  if((rv != 1) && feof(out_fp))
    return NULL;

  assert(rv == 1);
  assert(rec->incl_len <= rec->orig_len);
  assert(rec->incl_len <= sizeof(pcap_read_buf));

  assert(fread(pcap_read_buf, rec->incl_len, 1, out_fp) == 1);
  return pcap_read_buf;
}

/* ******************************************************* */

/* Dumps all the payload chunks into a linked list. The linked list is accessible via
 * (payload_chunk_t*)conn->payload_chunks */
bool dump_cb_payload_chunk(pcapdroid_t *pd, pd_conn_t *conn, bool is_tx, uint64_t ms, uint32_t stream_id, const char *dump_data, int dump_size) {
  payload_chunk_t *chunk = calloc(1, sizeof(payload_chunk_t));
  assert(chunk != NULL);
  chunk->payload = (u_char*)malloc(dump_size);
  assert(chunk->payload != NULL);

  memcpy(chunk->payload, dump_data, dump_size);
  chunk->size = dump_size;
  chunk->is_tx = is_tx;

  // append to the linked list
  payload_chunk_t *last = (payload_chunk_t*) conn->payload_chunks;
  if(last) {
    while(last->next)
      last = last->next;
    last->next = chunk;
  } else {
    // First chunk
    num_chunks_lists++;
    chunks_lists_heads = realloc(chunks_lists_heads, num_chunks_lists * sizeof(void*));
    chunks_lists_heads[num_chunks_lists - 1] = chunk;
    conn->payload_chunks = chunk;
  }

  return true;
}

/* ******************************************************* */

static void free_payload_chunks(pcapdroid_t *pd) {
  for(int i=0; i<num_chunks_lists; i++) {
    payload_chunk_t *cur = chunks_lists_heads[i];

    while(cur) {
      payload_chunk_t *next = cur->next;
      free(cur->payload);
      free(cur);
      cur = next;
    }
  }

  free(chunks_lists_heads);
}

```

`app/src/main/jni/tests/test_utils.h`:

```h
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022-26 - Emanuele Faranda
 */

#ifndef __TEST_UTILS_H__
#define __TEST_UTILS_H__

#include "core/pcapdroid.h"
#include "core/pcap_dump.h"
#include "common/memtrack.h"
#include <assert.h>

#define assert0(x) assert((x) == 0)
#define assert1(x) assert((x) == 1)
#define assert_ip_equal(ipver, a, b) assert(zdtun_cmp_ip((ipver), (a), (b)) == 0)

#define PCAP_PATH "../../../pcap"
#define PCAP_OUT_PATH "/tmp/pcapdroid_test_out.pcap"

void add_test(const char *name, void (*test_cb)());
void run_test(int argc, char **argv);

typedef struct payload_chunk {
  u_char *payload;
  int size;
  bool is_tx;
  struct payload_chunk *next;
} payload_chunk_t;

pcapdroid_t* pd_init_test(const char *ifname);
void pd_free_test(pcapdroid_t *pd);

// PCAP dump
void pd_dump_to_file(pcapdroid_t *pd);
void pd_done_dump();
void assert_pcap_header(pcap_hdr_t *hdr);
u_char* next_pcap_record(pcap_rec_t *rec);

// Callbacks
bool dump_cb_payload_chunk(pcapdroid_t *pd, pd_conn_t *conn, bool is_tx, uint64_t ms, uint32_t stream_id, const char *dump_data, int dump_size);

conn_and_tuple_t* assert_conn(pcapdroid_t *pd, int ipproto, const char *dst_ip, uint16_t dst_port, const char *info);

#endif

```

`app/src/main/jni/third_party/libchash.c`:

```c
/* Copyright (c) 1998 - 2005, Google Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ---
 * Author: Craig Silverstein
 *
 *  This library is intended to be used for in-memory hash tables,
 *  though it provides rudimentary permanent-storage capabilities.
 *  It attempts to be fast, portable, and small.  The best algorithm
 *  to fulfill these goals is an internal probing hashing algorithm,
 *  as in Knuth, _Art of Computer Programming_, vol III.  Unlike
 *  chained (open) hashing, it doesn't require a pointer for every
 *  item, yet it is still constant time lookup in practice.
 *
 *  Also to save space, we let the contents (both data and key) that
 *  you insert be a union: if the key/data is small, we store it
 *  directly in the hashtable, otherwise we store a pointer to it.
 *  To keep you from having to figure out which, use KEY_PTR and
 *  PTR_KEY to convert between the arguments to these functions and
 *  a pointer to the real data.  For instance:
 *     char key[] = "ab", *key2;
 *     HTItem *bck; HashTable *ht;
 *     HashInsert(ht, PTR_KEY(ht, key), 0);
 *     bck = HashFind(ht, PTR_KEY(ht, "ab"));
 *     key2 = KEY_PTR(ht, bck->key);
 *
 *  There are a rich set of operations supported:
 *     AllocateHashTable() -- Allocates a hashtable structure and
 *                            returns it.
 *        cchKey: if it's a positive number, then each key is a
 *                fixed-length record of that length.  If it's 0,
 *                the key is assumed to be a \0-terminated string.
 *        fSaveKey: normally, you are responsible for allocating
 *                  space for the key.  If this is 1, we make a
 *                  copy of the key for you.
 *     ClearHashTable() -- Removes everything from a hashtable
 *     FreeHashTable() -- Frees memory used by a hashtable
 *
 *     HashFind() -- takes a key (use PTR_KEY) and returns the
 *                   HTItem containing that key, or NULL if the
 *                   key is not in the hashtable.
 *     HashFindLast() -- returns the item found by last HashFind()
 *     HashFindOrInsert() -- inserts the key/data pair if the key
 *                           is not already in the hashtable, or
 *                           returns the appropraite HTItem if it is.
 *     HashFindOrInsertItem() -- takes key/data as an HTItem.
 *     HashInsert() -- adds a key/data pair to the hashtable.  What
 *                     it does if the key is already in the table
 *                     depends on the value of SAMEKEY_OVERWRITE.
 *     HashInsertItem() -- takes key/data as an HTItem.
 *     HashDelete() -- removes a key/data pair from the hashtable,
 *                     if it's there.  RETURNS 1 if it was there,
 *                     0 else.
 *        If you use sparse tables and never delete, the full data
 *        space is available.  Otherwise we steal -2 (maybe -3),
 *        so you can't have data fields with those values.
 *     HashDeleteLast() -- deletes the item returned by the last Find().
 *
 *     HashFirstBucket() -- used to iterate over the buckets in a 
 *                          hashtable.  DON'T INSERT OR DELETE WHILE
 *                          ITERATING!  You can't nest iterations.
 *     HashNextBucket() -- RETURNS NULL at the end of iterating.
 *
 *     HashSetDeltaGoalSize() -- if you're going to insert 1000 items
 *                               at once, call this fn with arg 1000.
 *                               It grows the table more intelligently.
 *
 *     HashSave() -- saves the hashtable to a file.  It saves keys ok,
 *                   but it doesn't know how to interpret the data field,
 *                   so if the data field is a pointer to some complex
 *                   structure, you must send a function that takes a
 *                   file pointer and a pointer to the structure, and
 *                   write whatever you want to write.  It should return
 *                   the number of bytes written.  If the file is NULL,
 *                   it should just return the number of bytes it would
 *                   write, without writing anything.
 *                      If your data field is just an integer, not a
 *                   pointer, just send NULL for the function.
 *     HashLoad() -- loads a hashtable.  It needs a function that takes
 *                   a file and the size of the structure, and expects
 *                   you to read in the structure and return a pointer
 *                   to it.  You must do memory allocation, etc.  If
 *                   the data is just a number, send NULL.
 *     HashLoadKeys() -- unlike HashLoad(), doesn't load the data off disk
 *                       until needed.  This saves memory, but if you look
 *                       up the same key a lot, it does a disk access each
 *                       time.
 *        You can't do Insert() or Delete() on hashtables that were loaded
 *        from disk.
 *
 *  See libchash.h for parameters you can modify.  Make sure LOG_WORD_SIZE
 *  is defined correctly for your machine!  (5 for 32 bit words, 6 for 64).
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>       /* for strcmp, memcmp, etc */
#include <sys/types.h>    /* ULTRIX needs this for in.h */
#include <netinet/in.h>   /* for reading/writing hashtables */
#include <assert.h>
#include "libchash.h"     /* all the types */

   /* if keys are stored directly but cchKey is less than sizeof(ulong), */
   /* this cuts off the bits at the end */
char grgKeyTruncMask[sizeof(ulong)][sizeof(ulong)];
#define KEY_TRUNC(ht, key)                                                    \
   ( STORES_PTR(ht) || (ht)->cchKey == sizeof(ulong)                          \
       ? (key) : ((key) & *(ulong *)&(grgKeyTruncMask[(ht)->cchKey][0])) )

   /* round num up to a multiple of wordsize.  (LOG_WORD_SIZE-3 is in bytes) */
#define WORD_ROUND(num)         ( ((num-1) | ((1<<(LOG_WORD_SIZE-3))-1)) + 1 )
#define NULL_TERMINATED  0    /* val of cchKey if keys are null-term strings */

   /* Useful operations we do to keys: compare them, copy them, free them */

#define KEY_CMP(ht, key1, key2)      ( !STORES_PTR(ht)  ? (key1) - (key2) :   \
                                       (key1) == (key2) ? 0 :                 \
                                       HashKeySize(ht) == NULL_TERMINATED ?   \
                                          strcmp((char *)key1, (char *)key2) :\
                                          memcmp((void *)key1, (void *)key2,  \
						 HashKeySize(ht)) )

#define COPY_KEY(ht, keyTo, keyFrom) do                                       \
   if ( !STORES_PTR(ht) || !(ht)->fSaveKeys )                                 \
      (keyTo) = (keyFrom);                     /* just copy pointer or info */\
   else if ( (ht)->cchKey == NULL_TERMINATED )        /* copy 0-term.ed str */\
   {                                                                          \
      (keyTo) = (ulong)HTsmalloc( WORD_ROUND(strlen((char *)(keyFrom))+1) );  \
      strcpy((char *)(keyTo), (char *)(keyFrom));                             \
   }                                                                          \
   else                                                                       \
   {                                                                          \
      (keyTo) = (ulong) HTsmalloc( WORD_ROUND((ht)->cchKey) );                \
      memcpy( (char *)(keyTo), (char *)(keyFrom), (ht)->cchKey);              \
   }                                                                          \
   while ( 0 )

#define FREE_KEY(ht, key) do {                                                \
   if ( STORES_PTR(ht) && (ht)->fSaveKeys ) {                                 \
     if ( (ht)->cchKey == NULL_TERMINATED )                                   \
        HTfree((char *)(key), WORD_ROUND(strlen((char *)(key))+1));           \
     else                                                                     \
        HTfree((char *)(key), WORD_ROUND((ht)->cchKey));                      \
   }                                                                          \
   } while ( 0 )

   /* the following are useful for bitmaps */
   /* Format is like this (if 1 word = 4 bits):  3210 7654 ba98 fedc ... */
typedef ulong          HTBitmapPart;  /* this has to be unsigned, for >> */
typedef HTBitmapPart   HTBitmap[1<<LOG_BM_WORDS];
typedef ulong          HTOffset; /* something big enough to hold offsets */

#define BM_BYTES(cBuckets)   /* we must ensure it's a multiple of word size */\
   ( (((cBuckets) + 8*sizeof(ulong)-1) >> LOG_WORD_SIZE) << (LOG_WORD_SIZE-3) )
#define MOD2(i, logmod)      ( (i) & ((1<<(logmod))-1) )
#define DIV_NUM_ENTRIES(i)   ( (i) >> LOG_WORD_SIZE )
#define MOD_NUM_ENTRIES(i)   ( MOD2(i, LOG_WORD_SIZE) )
#define MODBIT(i)            ( ((ulong)1) << MOD_NUM_ENTRIES(i) )

#define TEST_BITMAP(bm, i)   ( (bm)[DIV_NUM_ENTRIES(i)] & MODBIT(i) ? 1 : 0 )
#define SET_BITMAP(bm, i)    (bm)[DIV_NUM_ENTRIES(i)] |= MODBIT(i)
#define CLEAR_BITMAP(bm, i)  (bm)[DIV_NUM_ENTRIES(i)] &= ~MODBIT(i)

   /* the following are useful for reading and writing hashtables */
#define READ_UL(fp, data)                  \
   do {                                    \
      long _ul;                            \
      fread(&_ul, sizeof(_ul), 1, (fp));   \
      data = ntohl(_ul);                   \
   } while (0)

#define WRITE_UL(fp, data)                 \
   do {                                    \
      long _ul = htonl((long)(data));      \
      fwrite(&_ul, sizeof(_ul), 1, (fp));  \
   } while (0)

   /* Moves data from disk to memory if necessary.  Note dataRead cannot be  *
    * NULL, because then we might as well (and do) load the data into memory */
#define LOAD_AND_RETURN(ht, loadCommand)     /* lC returns an HTItem * */     \
   return (loadCommand);


/* ======================================================================== */
/*                          UTILITY ROUTINES                                */
/*                       ----------------------                             */

/* HTsmalloc() -- safe malloc
 *    allocates memory, or crashes if the allocation fails.
 */
static void *HTsmalloc(unsigned long size)
{
   void *retval;

   if ( size == 0 )
      return NULL;
   retval = (void *)malloc(size);
   if ( !retval )
   {
      fprintf(stderr, "HTsmalloc: Unable to allocate %lu bytes of memory\n",
	      size);
      exit(1);
   }
   return retval;
}

/* HTscalloc() -- safe calloc
 *    allocates memory and initializes it to 0, or crashes if
 *    the allocation fails.
 */
static void *HTscalloc(unsigned long size)
{
   void *retval;

   retval = (void *)calloc(size, 1);
   if ( !retval && size > 0 )
   {
      fprintf(stderr, "HTscalloc: Unable to allocate %lu bytes of memory\n",
	      size);
      exit(1);
   }
   return retval;
}

/* HTsrealloc() -- safe calloc
 *    grows the amount of memory from a source, or crashes if
 *    the allocation fails.
 */
static void *HTsrealloc(void *ptr, unsigned long new_size, long delta)
{
   if ( ptr == NULL )
      return HTsmalloc(new_size);
   ptr = realloc(ptr, new_size);
   if ( !ptr && new_size > 0 )
   {
      fprintf(stderr, "HTsrealloc: Unable to reallocate %lu bytes of memory\n",
	      new_size);
      exit(1);
   }
   return ptr;
}

/* HTfree() -- keep track of memory use
 *    frees memory using free, but updates count of how much memory
 *    is being used.
 */
static void HTfree(void *ptr, unsigned long size)
{
   if ( size > 0 )         /* some systems seem to not like freeing NULL */
      free(ptr);
}

/*************************************************************************\
| HTcopy()                                                                |
|     Sometimes we interpret data as a ulong.  But ulongs must be         |
|     aligned on some machines, so instead of casting we copy.            |
\*************************************************************************/

unsigned long HTcopy(char *ul)
{
   unsigned long retval;

   memcpy(&retval, ul, sizeof(retval));
   return retval;
}

/*************************************************************************\
| HTSetupKeyTrunc()                                                       |
|     If keys are stored directly but cchKey is less than                 |
|     sizeof(ulong), this cuts off the bits at the end.                   |
\*************************************************************************/
   
static void HTSetupKeyTrunc(void)
{
   int i, j;

   for ( i = 0; i < sizeof(unsigned long); i++ )
      for ( j = 0; j < sizeof(unsigned long); j++ )
	 grgKeyTruncMask[i][j] = j < i ? ((char)255) : 0;   /* chars have 8 bits */
}


/* ======================================================================== */
/*                            TABLE ROUTINES                                */
/*                         --------------------                             */

/*  The idea is that a hashtable with (logically) t buckets is divided
 *  into t/M groups of M buckets each.  (M is a constant set in
 *  LOG_BM_WORDS for efficiency.)  Each group is stored sparsely.
 *  Thus, inserting into the table causes some array to grow, which is
 *  slow but still constant time.  Lookup involves doing a
 *  logical-position-to-sparse-position lookup, which is also slow but
 *  constant time.  The larger M is, the slower these operations are
 *  but the less overhead (slightly).
 *
 *  To store the sparse array, we store a bitmap B, where B[i] = 1 iff
 *  bucket i is non-empty.  Then to look up bucket i we really look up
 *  array[# of 1s before i in B].  This is constant time for fixed M.
 *
 *  Terminology: the position of an item in the overall table (from
 *  1 .. t) is called its "location."  The logical position in a group
 *  (from 1 .. M ) is called its "position."  The actual location in
 *  the array (from 1 .. # of non-empty buckets in the group) is
 *  called its "offset."
 *
 *  The following operations are supported:
 *     o Allocate an array with t buckets, all empty
 *     o Free a array (but not whatever was stored in the buckets)
 *     o Tell whether or not a bucket is empty
 *     o Return a bucket with a given location
 *     o Set the value of a bucket at a given location
 *     o Iterate through all the buckets in the array
 *     o Read and write an occupancy bitmap to disk
 *     o Return how much memory is being allocated by the array structure
 */

#ifndef SparseBucket            /* by default, each bucket holds an HTItem */
#define SparseBucket            HTItem
#endif

typedef struct SparseBin {
   SparseBucket *binSparse;
   HTBitmap bmOccupied;      /* bmOccupied[i] is 1 if bucket i has an item */
   short cOccupied;          /* size of binSparse; useful for iterators, eg */
} SparseBin;

typedef struct SparseIterator {
   long posGroup;
   long posOffset;
   SparseBin *binSparse;     /* state info, to avoid args for NextBucket() */
   ulong cBuckets;
} SparseIterator;

#define LOG_LOW_BIN_SIZE        ( LOG_BM_WORDS+LOG_WORD_SIZE )
#define SPARSE_GROUPS(cBuckets) ( (((cBuckets)-1) >> LOG_LOW_BIN_SIZE) + 1 )

   /* we need a small function to figure out # of items set in the bm */
static HTOffset EntriesUpto(HTBitmapPart *bm, int i)
{                                       /* returns # of set bits in 0..i-1 */
   HTOffset retval = 0; 
   static HTOffset rgcBits[256] =             /* # of bits set in one char */
      {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
       1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
       1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
       2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
       1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
       2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
       2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
       3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
       1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
       2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
       2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
       3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
       2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
       3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
       3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
       4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};

   if ( i == 0 ) return 0;
   for ( ; i > sizeof(*bm)*8; i -= sizeof(*bm)*8, bm++ )
   {                                       /* think of it as loop unrolling */
#if LOG_WORD_SIZE >= 3                     /* 1 byte per word, or more */
      retval += rgcBits[*bm & 255];        /* get the low byte */
#if LOG_WORD_SIZE >= 4                     /* at least 2 bytes */
      retval += rgcBits[(*bm >> 8) & 255];
#if LOG_WORD_SIZE >= 5                     /* at least 4 bytes */
      retval += rgcBits[(*bm >> 16) & 255];
      retval += rgcBits[(*bm >> 24) & 255];
#if LOG_WORD_SIZE >= 6                     /* 8 bytes! */
      retval += rgcBits[(*bm >> 32) & 255];
      retval += rgcBits[(*bm >> 40) & 255];
      retval += rgcBits[(*bm >> 48) & 255];
      retval += rgcBits[(*bm >> 56) & 255];
#if LOG_WORD_SIZE >= 7                     /* not a concern for a while... */
#error Need to rewrite EntriesUpto to support such big words
#endif   /* >8 bytes */
#endif   /* 8 bytes */
#endif   /* 4 bytes */
#endif   /* 2 bytes */
#endif   /* 1 byte */
   }
   switch ( i ) {                         /* from 0 to 63 */
      case 0:
	 return retval;
#if LOG_WORD_SIZE >= 3                     /* 1 byte per word, or more */
      case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8:
	 return (retval + rgcBits[*bm & ((1 << i)-1)]);
#if LOG_WORD_SIZE >= 4                     /* at least 2 bytes */
      case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16:
	 return (retval + rgcBits[*bm & 255] + 
		 rgcBits[(*bm >> 8) & ((1 << (i-8))-1)]);
#if LOG_WORD_SIZE >= 5                     /* at least 4 bytes */
      case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24:
	 return (retval + rgcBits[*bm & 255] + rgcBits[(*bm >> 8) & 255] +
		 rgcBits[(*bm >> 16) & ((1 << (i-16))-1)]);
      case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32:
	 return (retval + rgcBits[*bm & 255] + rgcBits[(*bm >> 8) & 255] +
		 rgcBits[(*bm >> 16) & 255] + 
		 rgcBits[(*bm >> 24) & ((1 << (i-24))-1)]);
#if LOG_WORD_SIZE >= 6                     /* 8 bytes! */
      case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40:
	 return (retval + rgcBits[*bm & 255] + rgcBits[(*bm >> 8) & 255] +
		 rgcBits[(*bm >> 16) & 255] + rgcBits[(*bm >> 24) & 255] + 
		 rgcBits[(*bm >> 32) & ((1 << (i-32))-1)]);
      case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48:
	 return (retval + rgcBits[*bm & 255] + rgcBits[(*bm >> 8) & 255] +
		 rgcBits[(*bm >> 16) & 255] + rgcBits[(*bm >> 24) & 255] + 
		 rgcBits[(*bm >> 32) & 255] +
		 rgcBits[(*bm >> 40) & ((1 << (i-40))-1)]);
      case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56:
	 return (retval + rgcBits[*bm & 255] + rgcBits[(*bm >> 8) & 255] +
		 rgcBits[(*bm >> 16) & 255] + rgcBits[(*bm >> 24) & 255] + 
		 rgcBits[(*bm >> 32) & 255] + rgcBits[(*bm >> 40) & 255] +
		 rgcBits[(*bm >> 48) & ((1 << (i-48))-1)]);
      case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64:
	 return (retval + rgcBits[*bm & 255] + rgcBits[(*bm >> 8) & 255] +
		 rgcBits[(*bm >> 16) & 255] + rgcBits[(*bm >> 24) & 255] + 
		 rgcBits[(*bm >> 32) & 255] + rgcBits[(*bm >> 40) & 255] +
		 rgcBits[(*bm >> 48) & 255] + 
		 rgcBits[(*bm >> 56) & ((1 << (i-56))-1)]);
#endif   /* 8 bytes */
#endif   /* 4 bytes */
#endif   /* 2 bytes */
#endif   /* 1 byte */
   }
   //assert("" == "word size is too big in EntriesUpto()");
   return -1;
}
#define SPARSE_POS_TO_OFFSET(bm, i)   ( EntriesUpto(&((bm)[0]), i) )
#define SPARSE_BUCKET(bin, location)  \
   ( (bin)[(location) >> LOG_LOW_BIN_SIZE].binSparse +                     \
      SPARSE_POS_TO_OFFSET((bin)[(location)>>LOG_LOW_BIN_SIZE].bmOccupied, \
		           MOD2(location, LOG_LOW_BIN_SIZE)) )


/*************************************************************************\
| SparseAllocate()                                                        |
| SparseFree()                                                            |
|     Allocates, sets-to-empty, and frees a sparse array.  All you need   |
|     to tell me is how many buckets you want.  I return the number of    |
|     buckets I actually allocated, setting the array as a parameter.     |
|     Note that you have to set auxilliary parameters, like cOccupied.    |
\*************************************************************************/

static ulong SparseAllocate(SparseBin **pbinSparse, ulong cBuckets)
{
   int cGroups = SPARSE_GROUPS(cBuckets);

   *pbinSparse = (SparseBin *) HTscalloc(sizeof(**pbinSparse) * cGroups);
   return cGroups << LOG_LOW_BIN_SIZE;
}

static SparseBin *SparseFree(SparseBin *binSparse, ulong cBuckets)
{
   ulong iGroup, cGroups = SPARSE_GROUPS(cBuckets);

   for ( iGroup = 0; iGroup < cGroups; iGroup++ )
      HTfree(binSparse[iGroup].binSparse, (sizeof(*binSparse[iGroup].binSparse)
					   * binSparse[iGroup].cOccupied));
   HTfree(binSparse, sizeof(*binSparse) * cGroups);
   return NULL;
}

/*************************************************************************\
| SparseIsEmpty()                                                         |
| SparseFind()                                                            |
|     You give me a location (ie a number between 1 and t), and I         |
|     return the bucket at that location, or NULL if the bucket is        |
|     empty.  It's OK to call Find() on an empty table.                   |
\*************************************************************************/

static int SparseIsEmpty(SparseBin *binSparse, ulong location)
{
   return !TEST_BITMAP(binSparse[location>>LOG_LOW_BIN_SIZE].bmOccupied,
		       MOD2(location, LOG_LOW_BIN_SIZE));
}

static SparseBucket *SparseFind(SparseBin *binSparse, ulong location)
{
   if ( SparseIsEmpty(binSparse, location) )
      return NULL;
   return SPARSE_BUCKET(binSparse, location);
}

/*************************************************************************\
| SparseInsert()                                                          |
|     You give me a location, and contents to put there, and I insert     |
|     into that location and RETURN a pointer to the location.  If        |
|     bucket was already occupied, I write over the contents only if      |
|     *pfOverwrite is 1.  We set *pfOverwrite to 1 if there was someone   |
|     there (whether or not we overwrote) and 0 else.                     |
\*************************************************************************/

static SparseBucket *SparseInsert(SparseBin *binSparse, SparseBucket *bckInsert,
				  ulong location, int *pfOverwrite)
{
   SparseBucket *bckPlace;
   HTOffset offset;

   bckPlace = SparseFind(binSparse, location);
   if ( bckPlace )                /* means we replace old contents */
   {
      if ( *pfOverwrite )
	 *bckPlace = *bckInsert;
      *pfOverwrite = 1;
      return bckPlace;
   }

   binSparse += (location >> LOG_LOW_BIN_SIZE);
   offset = SPARSE_POS_TO_OFFSET(binSparse->bmOccupied,
				 MOD2(location, LOG_LOW_BIN_SIZE));
   binSparse->binSparse = (SparseBucket *) 
      HTsrealloc(binSparse->binSparse,
		 sizeof(*binSparse->binSparse) * ++binSparse->cOccupied,
		 sizeof(*binSparse->binSparse));
   memmove(binSparse->binSparse + offset+1,
	   binSparse->binSparse + offset,
	   (binSparse->cOccupied-1 - offset) * sizeof(*binSparse->binSparse));
   binSparse->binSparse[offset] = *bckInsert;
   SET_BITMAP(binSparse->bmOccupied, MOD2(location, LOG_LOW_BIN_SIZE));
   *pfOverwrite = 0;
   return binSparse->binSparse + offset;
}

/*************************************************************************\
| SparseFirstBucket()                                                     |
| SparseNextBucket()                                                      |
| SparseCurrentBit()                                                      |
|     Iterate through the occupied buckets of a dense hashtable.  You     |
|     must, of course, have allocated space yourself for the iterator.    |
\*************************************************************************/

static SparseBucket *SparseNextBucket(SparseIterator *iter)
{
   if ( iter->posOffset != -1 &&      /* not called from FirstBucket()? */
        (++iter->posOffset < iter->binSparse[iter->posGroup].cOccupied) )
      return iter->binSparse[iter->posGroup].binSparse + iter->posOffset;

   iter->posOffset = 0;                         /* start the next group */
   for ( iter->posGroup++;  iter->posGroup < SPARSE_GROUPS(iter->cBuckets);
	 iter->posGroup++ )
      if ( iter->binSparse[iter->posGroup].cOccupied > 0 )
	 return iter->binSparse[iter->posGroup].binSparse; /* + 0 */
   return NULL;                      /* all remaining groups were empty */
}

static SparseBucket *SparseFirstBucket(SparseIterator *iter,
				       SparseBin *binSparse, ulong cBuckets)
{
   iter->binSparse = binSparse;        /* set it up for NextBucket() */
   iter->cBuckets = cBuckets;
   iter->posOffset = -1;               /* when we advance, we're at 0 */
   iter->posGroup = -1;
   return SparseNextBucket(iter);
}

/*************************************************************************\
| SparseWrite()                                                           |
| SparseRead()                                                            |
|     These are routines for storing a sparse hashtable onto disk.  We    |
|     store the number of buckets and a bitmap indicating which buckets   |
|     are allocated (occupied).  The actual contents of the buckets       |
|     must be stored separately.                                          |
\*************************************************************************/

static void SparseWrite(FILE *fp, SparseBin *binSparse, ulong cBuckets)
{
   ulong i, j;

   WRITE_UL(fp, cBuckets);
   for ( i = 0; i < SPARSE_GROUPS(cBuckets); i++ )
      for ( j = 0; j < (1<<LOG_BM_WORDS); j++ )
	 WRITE_UL(fp, binSparse[i].bmOccupied[j]);
}

static ulong SparseRead(FILE *fp, SparseBin **pbinSparse)
{
   ulong i, j, cBuckets;

   READ_UL(fp, cBuckets);                /* actually, cBuckets is stored */
   cBuckets = SparseAllocate(pbinSparse, cBuckets);
   for ( i = 0; i < SPARSE_GROUPS(cBuckets); i++ )
   {
      for ( j = 0; j < (1<<LOG_BM_WORDS); j++ )
	 READ_UL(fp, (*pbinSparse)[i].bmOccupied[j]);
      (*pbinSparse)[i].cOccupied =
	 SPARSE_POS_TO_OFFSET((*pbinSparse)[i].bmOccupied,1<<LOG_LOW_BIN_SIZE);
      (*pbinSparse)[i].binSparse =
	 (SparseBucket *) HTsmalloc(sizeof(*((*pbinSparse)[i].binSparse)) *
				    (*pbinSparse)[i].cOccupied);
   }
   return cBuckets;
}

/*************************************************************************\
| SparseMemory()                                                          |
|     SparseMemory() tells us how much memory is being allocated for      |
|     the dense table.  You need to tell me not only how many buckets     |
|     there are, but how many are occupied.                               |
\*************************************************************************/

static ulong SparseMemory(ulong cBuckets, ulong cOccupied)
{
   return ( cOccupied * sizeof(SparseBucket) +
	    SPARSE_GROUPS(cBuckets) * sizeof(SparseBin) );
}

/* ======================================================================== */
/*                          HASHING ROUTINES                                */
/*                       ----------------------                             */

/*  Implements a simple quadratic hashing scheme.  We have a single hash
 *  table of size t and a single hash function h(x).  When inserting an
 *  item, first we try h(x) % t.  If it's occupied, we try h(x) + 
 *  i*(i-1)/2 % t for increasing values of i until we hit a not-occupied
 *  space.  To make this dynamic, we double the size of the hash table as
 *  soon as more than half the cells are occupied.  When deleting, we can
 *  choose to shrink the hashtable when less than a quarter of the
 *  cells are occupied, or we can choose never to shrink the hashtable.
 *  For lookup, we check h(x) + i*(i-1)/2 % t (starting with i=0) until
 *  we get a match or we hit an empty space.  Note that as a result,
 *  we can't make a cell empty on deletion, or lookups may end prematurely.
 *  Instead we mark the cell as "deleted."  We thus steal the value
 *  DELETED as a possible "data" value.  As long as data are pointers,
 *  that's ok.
 *     The hash increment we use, i(i-1)/2, is not the standard quadratic
 *  hash increment, which is i^2.  i(i-1)/2 covers the entire bucket space
 *  when the hashtable size is a power of two, as it is for us.  In fact,
 *  the first n probes cover n distinct buckets; then it repeats.  This
 *  guarantees insertion will always succeed.
 *     If you linear hashing, set JUMP in chash.h.  You can also change
 *  various other parameters there.
 */

/*************************************************************************\
| Hash()                                                                  |
|     The hash function I use is due to Bob Jenkins (see                  |
|     http://burtleburtle.net/bob/hash/evahash.html                       |
|     According to http://burtleburtle.net/bob/c/lookup2.c,               |
|     his implementation is public domain.)                               |
|     It takes 36 instructions, in 18 cycles if you're lucky.             |
|        hashing depends on the fact the hashtable size is always a       |
|     power of 2.  cBuckets is probably ht->cBuckets.                     |
\*************************************************************************/

#if LOG_WORD_SIZE == 5                      /* 32 bit words */

#define mix(a,b,c) \
{ \
  a -= b; a -= c; a ^= (c>>13); \
  b -= c; b -= a; b ^= (a<<8); \
  c -= a; c -= b; c ^= (b>>13); \
  a -= b; a -= c; a ^= (c>>12);  \
  b -= c; b -= a; b ^= (a<<16); \
  c -= a; c -= b; c ^= (b>>5); \
  a -= b; a -= c; a ^= (c>>3);  \
  b -= c; b -= a; b ^= (a<<10); \
  c -= a; c -= b; c ^= (b>>15); \
}
#ifdef WORD_HASH                 /* play with this on little-endian machines */
#define WORD_AT(ptr)    ( *(ulong *)(ptr) )
#else
#define WORD_AT(ptr)    ( (ptr)[0] + ((ulong)(ptr)[1]<<8) + \
			  ((ulong)(ptr)[2]<<16) + ((ulong)(ptr)[3]<<24) )
#endif

#elif LOG_WORD_SIZE == 6        /* 64 bit words */

#define mix(a,b,c) \
{ \
  a -= b; a -= c; a ^= (c>>43); \
  b -= c; b -= a; b ^= (a<<9); \
  c -= a; c -= b; c ^= (b>>8); \
  a -= b; a -= c; a ^= (c>>38); \
  b -= c; b -= a; b ^= (a<<23); \
  c -= a; c -= b; c ^= (b>>5); \
  a -= b; a -= c; a ^= (c>>35); \
  b -= c; b -= a; b ^= (a<<49); \
  c -= a; c -= b; c ^= (b>>11); \
  a -= b; a -= c; a ^= (c>>12); \
  b -= c; b -= a; b ^= (a<<18); \
  c -= a; c -= b; c ^= (b>>22); \
}
#ifdef WORD_HASH                 /* alpha is little-endian, btw */
#define WORD_AT(ptr)    ( *(ulong *)(ptr) )
#else
#define WORD_AT(ptr)    ( (ptr)[0] + ((ulong)(ptr)[1]<<8) + \
			  ((ulong)(ptr)[2]<<16) + ((ulong)(ptr)[3]<<24) + \
			  ((ulong)(ptr)[4]<<32) + ((ulong)(ptr)[5]<<40) + \
			  ((ulong)(ptr)[6]<<48) + ((ulong)(ptr)[7]<<56) )
#endif

#else                            /* neither 32 or 64 bit words */
#error This hash function can only hash 32 or 64 bit words.  Sorry.
#endif

static ulong Hash(HashTable *ht, char *key, ulong cBuckets)
{
   ulong a, b, c, cchKey, cchKeyOrig;

   cchKeyOrig = ht->cchKey == NULL_TERMINATED ? strlen(key) : ht->cchKey;
   a = b = c = 0x9e3779b9;       /* the golden ratio; an arbitrary value */

   for ( cchKey = cchKeyOrig;  cchKey >= 3 * sizeof(ulong);
	 cchKey -= 3 * sizeof(ulong),  key += 3 * sizeof(ulong) )
   {
      a += WORD_AT(key);
      b += WORD_AT(key + sizeof(ulong));
      c += WORD_AT(key + sizeof(ulong)*2);
      mix(a,b,c);
   }

   c += cchKeyOrig;
   switch ( cchKey ) {           /* deal with rest.  Cases fall through */
#if LOG_WORD_SIZE == 5
      case 11: c += (ulong)key[10]<<24;
      case 10: c += (ulong)key[9]<<16;
      case 9 : c += (ulong)key[8]<<8;
               /* the first byte of c is reserved for the length */
      case 8 : b += WORD_AT(key+4);  a+= WORD_AT(key);  break;
      case 7 : b += (ulong)key[6]<<16;
      case 6 : b += (ulong)key[5]<<8;
      case 5 : b += key[4];
      case 4 : a += WORD_AT(key);  break;
      case 3 : a += (ulong)key[2]<<16;
      case 2 : a += (ulong)key[1]<<8;
      case 1 : a += key[0];
   /* case 0 : nothing left to add */
#elif LOG_WORD_SIZE == 6
      case 23: c += (ulong)key[22]<<56;
      case 22: c += (ulong)key[21]<<48;
      case 21: c += (ulong)key[20]<<40;
      case 20: c += (ulong)key[19]<<32;
      case 19: c += (ulong)key[18]<<24;
      case 18: c += (ulong)key[17]<<16;
      case 17: c += (ulong)key[16]<<8;
               /* the first byte of c is reserved for the length */
      case 16: b += WORD_AT(key+8);  a+= WORD_AT(key);  break;
      case 15: b += (ulong)key[14]<<48;
      case 14: b += (ulong)key[13]<<40;
      case 13: b += (ulong)key[12]<<32;
      case 12: b += (ulong)key[11]<<24;
      case 11: b += (ulong)key[10]<<16;
      case 10: b += (ulong)key[ 9]<<8;
      case  9: b += (ulong)key[ 8];
      case  8: a += WORD_AT(key);  break;
      case  7: a += (ulong)key[ 6]<<48;
      case  6: a += (ulong)key[ 5]<<40;
      case  5: a += (ulong)key[ 4]<<32;
      case  4: a += (ulong)key[ 3]<<24;
      case  3: a += (ulong)key[ 2]<<16;
      case  2: a += (ulong)key[ 1]<<8;
      case  1: a += (ulong)key[ 0];
   /* case 0: nothing left to add */
#endif
   }
   mix(a,b,c);
   return c & (cBuckets-1);
}


/*************************************************************************\
| Rehash()                                                                |
|     You give me a hashtable, a new size, and a bucket to follow, and    |
|     I resize the hashtable's bin to be the new size, rehashing          |
|     everything in it.  I keep particular track of the bucket you pass   |
|     in, and RETURN a pointer to where the item in the bucket got to.    |
|     (If you pass in NULL, I return an arbitrary pointer.)               |
\*************************************************************************/

static HTItem *Rehash(HashTable *ht, ulong cNewBuckets, HTItem *bckWatch)
{
   Table *tableNew;
   ulong iBucketFirst;
   HTItem *bck, *bckNew = NULL;
   ulong offset;                         /* the i in h(x) + i*(i-1)/2 */
   int fOverwrite = 0;    /* not an issue: there can be no collisions */

   assert( ht->table );
   cNewBuckets = Table(Allocate)(&tableNew, cNewBuckets);
      /* Since we RETURN the new position of bckWatch, we want  *
       * to make sure it doesn't get moved due to some table    *
       * rehashing that comes after it's inserted.  Thus, we    *
       * have to put it in last.  This makes the loop weird.    */
   for ( bck = HashFirstBucket(ht); ; bck = HashNextBucket(ht) )
   {
      if ( bck == NULL )      /* we're done iterating, so look at bckWatch */
      {
	 bck = bckWatch;
	 if ( bck == NULL )           /* I guess bckWatch wasn't specified */
	    break;
      }
      else if ( bck == bckWatch )
	 continue;             /* ignore if we see it during the iteration */

      offset = 0;                              /* a new i for a new bucket */
      for ( iBucketFirst = Hash(ht, KEY_PTR(ht, bck->key), cNewBuckets);
	    !Table(IsEmpty)(tableNew, iBucketFirst);
	    iBucketFirst = (iBucketFirst + JUMP(KEY_PTR(ht,bck->key), offset))
	                   & (cNewBuckets-1) )
	 ;
      bckNew = Table(Insert)(tableNew, bck, iBucketFirst, &fOverwrite);
      if ( bck == bckWatch )       /* we're done with the last thing to do */
	 break;
   }
   Table(Free)(ht->table, ht->cBuckets);
   ht->table = tableNew;
   ht->cBuckets = cNewBuckets;
   ht->cDeletedItems = 0;
   return bckNew;     /* new position of bckWatch, which was inserted last */
}

/*************************************************************************\
| Find()                                                                  |
|     Does the quadratic searching stuff.  RETURNS NULL if we don't       |
|     find an object with the given key, and a pointer to the Item        |
|     holding the key, if we do.  Also sets posLastFind.  If piEmpty is   |
|     non-NULL, we set it to the first open bucket we pass; helpful for   |
|     doing a later insert if the search fails, for instance.             |
\*************************************************************************/

static HTItem *Find(HashTable *ht, ulong key, ulong *piEmpty)
{
   ulong iBucketFirst;
   HTItem *item;
   ulong offset = 0;              /* the i in h(x) + i*(i-1)/2 */
   int fFoundEmpty = 0;           /* set when we pass over an empty bucket */

   ht->posLastFind = NULL;        /* set up for failure: a new find starts */
   if ( ht->table == NULL )       /* empty hash table: find is bound to fail */
      return NULL;

   iBucketFirst = Hash(ht, KEY_PTR(ht, key), ht->cBuckets);
   while ( 1 )                    /* now try all i > 0 */
   {
      item = Table(Find)(ht->table, iBucketFirst);
      if ( item == NULL )         /* it's not in the table */
      {
	 if ( piEmpty && !fFoundEmpty ) *piEmpty = iBucketFirst;
	 return NULL;
      }
      else
      {
	 if ( IS_BCK_DELETED(item) )      /* always 0 ifdef INSERT_ONLY */
	 {
	    if ( piEmpty && !fFoundEmpty )
	    {
	       *piEmpty = iBucketFirst;
	       fFoundEmpty = 1;
	    }
	 } else
	    if ( !KEY_CMP(ht, key, item->key) )     /* must be occupied */
	    {
	       ht->posLastFind = item;
	       return item;               /* we found it! */
	    }
      }
      iBucketFirst = ((iBucketFirst + JUMP(KEY_PTR(ht, key), offset))
		      & (ht->cBuckets-1));
   }
}

/*************************************************************************\
| Insert()                                                                |
|     If an item with the key already exists in the hashtable, RETURNS    |
|     a pointer to the item (replacing its data if fOverwrite is 1).      |
|     If not, we find the first place-to-insert (which Find() is nice     |
|     enough to set for us) and insert the item there, RETURNing a        |
|     pointer to the item.  We might grow the hashtable if it's getting   |
|     full.  Note we include buckets holding DELETED when determining     |
|     fullness, because they slow down searching.                         |
\*************************************************************************/

static ulong NextPow2(ulong x)    /* returns next power of 2 > x, or 2^31 */
{
   if ( ((x << 1) >> 1) != x )    /* next power of 2 overflows */
      x >>= 1;                    /* so we return highest power of 2 we can */
   while ( (x & (x-1)) != 0 )     /* blacks out all but the top bit */
      x &= (x-1);
   return x << 1;                 /* makes it the *next* power of 2 */
}

static HTItem *Insert(HashTable *ht, ulong key, int fOverwrite)
{
   HTItem *item, bckInsert;
   ulong iEmpty;                  /* first empty bucket key probes */

   if ( ht->table == NULL )       /* empty hash table: find is bound to fail */
      return NULL;
   item = Find(ht, key, &iEmpty);
   ht->posLastFind = NULL;        /* last operation is insert, not find */
   if ( item )
   {
      return item;
   }

   COPY_KEY(ht, bckInsert.key, key);    /* make our own copy of the key */
   item = Table(Insert)(ht->table, &bckInsert, iEmpty, &fOverwrite);
   if ( fOverwrite )                    /* we overwrote a deleted bucket */
      ht->cDeletedItems--;
   ht->cItems++;                        /* insert couldn't have overwritten */
   if ( ht->cDeltaGoalSize > 0 )  /* closer to our goal size */
      ht->cDeltaGoalSize--;
   if ( ht->cItems + ht->cDeletedItems >= ht->cBuckets * OCCUPANCY_PCT
        || ht->cDeltaGoalSize < 0 ) /* we must've overestimated # of deletes */
      item = Rehash(ht, 
		    NextPow2((ulong)(((ht->cDeltaGoalSize > 0 ?
				       ht->cDeltaGoalSize : 0)
				      + ht->cItems) / OCCUPANCY_PCT)),
		    item);
   return item;
}

/*************************************************************************\
| Delete()                                                                |
|     Removes the item from the hashtable, and if fShrink is 1, will      |
|     shrink the hashtable if it's too small (ie even after halving,      |
|     the ht would be less than half full, though in order to avoid       |
|     oscillating table size, we insist that after halving the ht would   |
|     be less than 40% full).  RETURNS 1 if the item was found, 0 else.   |
|        If fLastFindSet is true, then this function is basically         |
|     DeleteLastFind.                                                     |
\*************************************************************************/

#ifndef INSERT_ONLY

static int Delete(HashTable *ht, ulong key, int fShrink, int fLastFindSet)
{
   if ( !fLastFindSet && !Find(ht, key, NULL) )
      return 0;
   SET_BCK_DELETED(ht, ht->posLastFind);       /* find set this, how nice */
   ht->cItems--; 
   ht->cDeletedItems++;
   if ( ht->cDeltaGoalSize < 0 )  /* heading towards our goal of deletion */
      ht->cDeltaGoalSize++;

   if ( fShrink && ht->cItems < ht->cBuckets * OCCUPANCY_PCT*0.4 
        && ht->cDeltaGoalSize >= 0       /* wait until we're done deleting */
        && (ht->cBuckets >> 1) >= MIN_HASH_SIZE )                /* shrink */
      Rehash(ht,
	     NextPow2((ulong)((ht->cItems+ht->cDeltaGoalSize)/OCCUPANCY_PCT)),
	     NULL);
   ht->posLastFind = NULL;           /* last operation is delete, not find */
   return 1;
}

#endif


/* ======================================================================== */
/*                          USER-VISIBLE API                                */
/*                       ----------------------                             */

/*************************************************************************\
| AllocateHashTable()                                                     |
| ClearHashTable()                                                        |
| FreeHashTable()                                                         |
|     Allocate() allocates a hash table and sets up size parameters.      |
|     Free() frees it.  Clear() deletes all the items from the hash       |
|     table, but frees not.                                               |
|        cchKey is < 0 if the keys you send me are meant to be pointers   |
|     to \0-terminated strings.  Then -cchKey is the maximum key size.    |
|     If cchKey < one word (ulong), the keys you send me are the keys     |
|     themselves; else the keys you send me are pointers to the data.     |
|        If fSaveKeys is 1, we copy any keys given to us to insert.  We   |
|     also free these keys when freeing the hash table.  If it's 0, the   |
|     user is responsible for key space management.                       |
|        AllocateHashTable() RETURNS a hash table; the others TAKE one.   |
\*************************************************************************/

HashTable *AllocateHashTable(int cchKey, int fSaveKeys)
{
   HashTable *ht;

   ht = (HashTable *) HTsmalloc(sizeof(*ht));   /* set everything to 0 */
   ht->cBuckets = Table(Allocate)(&ht->table, MIN_HASH_SIZE);
   ht->cchKey = cchKey <= 0 ? NULL_TERMINATED : cchKey;
   ht->cItems = 0;
   ht->cDeletedItems = 0;
   ht->fSaveKeys = fSaveKeys;
   ht->cDeltaGoalSize = 0;
   ht->iter = HTsmalloc( sizeof(TableIterator) );

   HTSetupKeyTrunc();                           /* in util.c */
   return ht;
}

void ClearHashTable(HashTable *ht)
{
   HTItem *bck;

   if ( STORES_PTR(ht) && ht->fSaveKeys )       /* need to free keys */
      for ( bck = HashFirstBucket(ht); bck; bck = HashNextBucket(ht) )
      {
	 FREE_KEY(ht, bck->key);
	 if ( ht->fSaveKeys == 2 )  /* this means key stored in one block */
	    break;                  /* ...so only free once */
      }
   Table(Free)(ht->table, ht->cBuckets);
   ht->cBuckets = Table(Allocate)(&ht->table, MIN_HASH_SIZE);

   ht->cItems = 0;
   ht->cDeletedItems = 0;
   ht->cDeltaGoalSize = 0;
   ht->posLastFind = NULL;
}

void FreeHashTable(HashTable *ht)
{
   ClearHashTable(ht);
   if ( ht->iter )    HTfree(ht->iter, sizeof(TableIterator));
   if ( ht->table )   Table(Free)(ht->table, ht->cBuckets);
   free(ht);
}

/*************************************************************************\
| HashFind()                                                              |
| HashFindLast()                                                          |
|     HashFind(): looks in h(x) + i(i-1)/2 % t as i goes up from 0        |
|     until we either find the key or hit an empty bucket.  RETURNS a     |
|     pointer to the item in the hit bucket, if we find it, else          |
|     RETURNS NULL.                                                       |
|        HashFindLast() returns the item returned by the last             |
|     HashFind(), which may be NULL if the last HashFind() failed.        |
|        LOAD_AND_RETURN reads the data from off disk, if necessary.      |
\*************************************************************************/

HTItem *HashFind(HashTable *ht, ulong key)
{
   LOAD_AND_RETURN(ht, Find(ht, KEY_TRUNC(ht, key), NULL));
}

HTItem *HashFindLast(HashTable *ht)
{
   LOAD_AND_RETURN(ht, ht->posLastFind);
}

/*************************************************************************\
| HashFindOrInsert()                                                      |
| HashFindOrInsertItem()                                                  |
| HashInsert()                                                            |
| HashInsertItem()                                                        |
| HashDelete()                                                            |
| HashDeleteLast()                                                        |
|     Pretty obvious what these guys do.  Some take buckets (items),      |
|     some take keys and data separately.  All things RETURN the bucket   |
|     (a pointer into the hashtable) if appropriate.                      |
\*************************************************************************/

HTItem *HashFindOrInsert(HashTable *ht, ulong key)
{
      /* This is equivalent to Insert without samekey-overwrite */
   return Insert(ht, KEY_TRUNC(ht, key), 0);
}

HTItem *HashFindOrInsertItem(HashTable *ht, HTItem *pItem)
{
   return HashFindOrInsert(ht, pItem->key);
}

HTItem *HashInsert(HashTable *ht, ulong key)
{
   return Insert(ht, KEY_TRUNC(ht, key), SAMEKEY_OVERWRITE);
}

HTItem *HashInsertItem(HashTable *ht, HTItem *pItem)
{
   return HashInsert(ht, pItem->key);
}

#ifndef INSERT_ONLY

int HashDelete(HashTable *ht, ulong key)
{
   return Delete(ht, KEY_TRUNC(ht, key), !FAST_DELETE, 0);
}

int HashDeleteLast(HashTable *ht)
{
   if ( !ht->posLastFind  )                /* last find failed */
      return 0;
   return Delete(ht, 0, !FAST_DELETE, 1);  /* no need to specify a key */
}

#endif

/*************************************************************************\
| HashFirstBucket()                                                       |
| HashNextBucket()                                                        |
|     Iterates through the items in the hashtable by iterating through    |
|     the table.  Since we know about deleted buckets and loading data    |
|     off disk, and the table doesn't, our job is to take care of these   |
|     things.  RETURNS a bucket, or NULL after the last bucket.           |
\*************************************************************************/

HTItem *HashFirstBucket(HashTable *ht)
{
   HTItem *retval;

   for ( retval = Table(FirstBucket)(ht->iter, ht->table, ht->cBuckets);
	 retval;  retval = Table(NextBucket)(ht->iter) )
      if ( !IS_BCK_DELETED(retval) )
	 LOAD_AND_RETURN(ht, retval);
   return NULL;
}

HTItem *HashNextBucket(HashTable *ht)
{
   HTItem *retval;

   while ( (retval=Table(NextBucket)(ht->iter)) )
      if ( !IS_BCK_DELETED(retval) )
	 LOAD_AND_RETURN(ht, retval);
   return NULL;
}

/*************************************************************************\
| HashSetDeltaGoalSize()                                                  |
|     If we're going to insert 100 items, set the delta goal size to      |
|     100 and we take that into account when inserting.  Likewise, if     |
|     we're going to delete 10 items, set it to -100 and we won't         |
|     rehash until all 100 have been done.  It's ok to be wrong, but      |
|     it's efficient to be right.  Returns the delta value.               |
\*************************************************************************/

int HashSetDeltaGoalSize(HashTable *ht, int delta)
{
   ht->cDeltaGoalSize = delta;
#if FAST_DELETE == 1 || defined INSERT_ONLY
   if ( ht->cDeltaGoalSize < 0 )   /* for fast delete, we never */
      ht->cDeltaGoalSize = 0;      /* ...rehash after deletion  */
#endif
   return ht->cDeltaGoalSize;
}

/*************************************************************************\
| PrintHashTable()                                                        |
|     A debugging tool.  Prints the entire contents of the hash table,    |
|     like so: <bin #>: key of the contents.  Returns number of bytes     |
|     allocated.  If time is not -1, we print it as the time required     |
|     for the hash.  If iForm is 0, we just print the stats.  If it's     |
|     1, we print the keys and data too, but the keys are printed as      |
|     ulongs.  If it's 2, we print the keys correctly (as long numbers    |
|     or as strings).                                                     |
\*************************************************************************/

ulong PrintHashTable(HashTable *ht, double time, int iForm)
{
   ulong cbData = 0, cbBin = 0, cItems = 0, cOccupied = 0;
   HTItem *item;

   printf("HASH TABLE.\n");
   if ( time > -1.0 )
   {
      printf("----------\n");
      printf("Time: %27.2f\n", time);
   }

   for ( item = Table(FirstBucket)(ht->iter, ht->table, ht->cBuckets);
	 item;  item = Table(NextBucket)(ht->iter) )
   {
      cOccupied++;                    /* this includes deleted buckets */
      if ( IS_BCK_DELETED(item) )     /* we don't need you for anything else */
	 continue;
      cItems++;                       /* this is for a sanity check */
      if ( STORES_PTR(ht) )
	 cbData += ht->cchKey == NULL_TERMINATED ? 
	    WORD_ROUND(strlen((char *)item->key)+1) : ht->cchKey;
      else
	 cbBin -= sizeof(item->key), cbData += sizeof(item->key);
      if ( iForm != 0 )      /* we want the actual contents */
      {
	 if ( iForm == 2 && ht->cchKey == NULL_TERMINATED ) 
	    printf("%s\n", (char *)item->key);
	 else if ( iForm == 2 && STORES_PTR(ht) )
	    printf("%.*s\n",
		   (int)ht->cchKey, (char *)item->key);
	 else     /* either key actually is a ulong, or iForm == 1 */
	    printf("%lu\n", item->key);
      }
   }
   assert( cItems == ht->cItems );                   /* sanity check */
   cbBin = Table(Memory)(ht->cBuckets, cOccupied);

   printf("----------\n");   
   printf("%lu buckets (%lu bytes).  %lu empty.  %lu hold deleted items.\n"
	  "%lu items (%lu bytes).\n"
	  "%lu bytes total.  %lu bytes (%2.1f%%) of this is ht overhead.\n",
	  ht->cBuckets, cbBin, ht->cBuckets - cOccupied, cOccupied - ht->cItems,
	  ht->cItems, cbData,
	  cbData + cbBin, cbBin, cbBin*100.0/(cbBin+cbData));

   return cbData + cbBin;
}

```

`app/src/main/jni/third_party/libchash.h`:

```h
/* Copyright (c) 1998 - 2005, Google Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ---
 * Author: Craig Silverstein
 *
 *  This library is intended to be used for in-memory hash tables,
 *  though it provides rudimentary permanent-storage capabilities.
 *  It attempts to be fast, portable, and small.  The best algorithm
 *  to fulfill these goals is an internal probing hashing algorithm,
 *  as in Knuth, _Art of Computer Programming_, vol III.  Unlike
 *  chained (open) hashing, it doesn't require a pointer for every
 *  item, yet it is still constant time lookup in practice.
 *
 *  Also to save space, we let the contents (both data and key) that
 *  you insert be a union: if the key/data is small, we store it
 *  directly in the hashtable, otherwise we store a pointer to it.
 *  To keep you from having to figure out which, use KEY_PTR and
 *  PTR_KEY to convert between the arguments to these functions and
 *  a pointer to the real data.  For instance:
 *     char key[] = "ab", *key2;
 *     HTItem *bck; HashTable *ht;
 *     HashInsert(ht, PTR_KEY(ht, key), 0);
 *     bck = HashFind(ht, PTR_KEY(ht, "ab"));
 *     key2 = KEY_PTR(ht, bck->key);
 *
 *  There are a rich set of operations supported:
 *     AllocateHashTable() -- Allocates a hashtable structure and
 *                            returns it.
 *        cchKey: if it's a positive number, then each key is a
 *                fixed-length record of that length.  If it's 0,
 *                the key is assumed to be a \0-terminated string.
 *        fSaveKey: normally, you are responsible for allocating
 *                  space for the key.  If this is 1, we make a
 *                  copy of the key for you.
 *     ClearHashTable() -- Removes everything from a hashtable
 *     FreeHashTable() -- Frees memory used by a hashtable
 *
 *     HashFind() -- takes a key (use PTR_KEY) and returns the
 *                   HTItem containing that key, or NULL if the
 *                   key is not in the hashtable.
 *     HashFindLast() -- returns the item found by last HashFind()
 *     HashFindOrInsert() -- inserts the key/data pair if the key
 *                           is not already in the hashtable, or
 *                           returns the appropraite HTItem if it is.
 *     HashFindOrInsertItem() -- takes key/data as an HTItem.
 *     HashInsert() -- adds a key/data pair to the hashtable.  What
 *                     it does if the key is already in the table
 *                     depends on the value of SAMEKEY_OVERWRITE.
 *     HashInsertItem() -- takes key/data as an HTItem.
 *     HashDelete() -- removes a key/data pair from the hashtable,
 *                     if it's there.  RETURNS 1 if it was there,
 *                     0 else.
 *        If you use sparse tables and never delete, the full data
 *        space is available.  Otherwise we steal -2 (maybe -3),
 *        so you can't have data fields with those values.
 *     HashDeleteLast() -- deletes the item returned by the last Find().
 *
 *     HashFirstBucket() -- used to iterate over the buckets in a 
 *                          hashtable.  DON'T INSERT OR DELETE WHILE
 *                          ITERATING!  You can't nest iterations.
 *     HashNextBucket() -- RETURNS NULL at the end of iterating.
 *
 *     HashSetDeltaGoalSize() -- if you're going to insert 1000 items
 *                               at once, call this fn with arg 1000.
 *                               It grows the table more intelligently.
 *
 *     HashSave() -- saves the hashtable to a file.  It saves keys ok,
 *                   but it doesn't know how to interpret the data field,
 *                   so if the data field is a pointer to some complex
 *                   structure, you must send a function that takes a
 *                   file pointer and a pointer to the structure, and
 *                   write whatever you want to write.  It should return
 *                   the number of bytes written.  If the file is NULL,
 *                   it should just return the number of bytes it would
 *                   write, without writing anything.
 *                      If your data field is just an integer, not a
 *                   pointer, just send NULL for the function.
 *     HashLoad() -- loads a hashtable.  It needs a function that takes
 *                   a file and the size of the structure, and expects
 *                   you to read in the structure and return a pointer
 *                   to it.  You must do memory allocation, etc.  If
 *                   the data is just a number, send NULL.
 *     HashLoadKeys() -- unlike HashLoad(), doesn't load the data off disk
 *                       until needed.  This saves memory, but if you look
 *                       up the same key a lot, it does a disk access each
 *                       time.
 *        You can't do Insert() or Delete() on hashtables that were loaded
 *        from disk.
 */

/* Make insert-only to remove the need to track deleted buckets */
#define INSERT_ONLY

#include <sys/types.h>         /* includes definition of "ulong", we hope */
#define ulong u_long

#define MAGIC_KEY             "CHsh"   /* when we save the file */

#ifndef LOG_WORD_SIZE                  /* 5 for 32 bit words, 6 for 64 */
#if defined (__LP64__) || defined (_LP64)
#define LOG_WORD_SIZE          6       /* log_2(sizeof(ulong)) [in bits] */
#else
#define LOG_WORD_SIZE          5       /* log_2(sizeof(ulong)) [in bits] */
#endif
#endif

   /* The following gives a speed/time tradeoff: how many buckets are  *
    * in each bin.  0 gives 32 buckets/bin, which is a good number.    */
#ifndef LOG_BM_WORDS
#define LOG_BM_WORDS        0      /* each group has 2^L_B_W * 32 buckets */
#endif

   /* The following are all parameters that affect performance. */
#ifndef JUMP
#define JUMP(key, offset)   ( ++(offset) )  /* ( 1 ) for linear hashing */
#endif
#ifndef Table
#define Table(x)            Sparse##x       /* Dense##x for dense tables */
#endif
#ifndef FAST_DELETE
#define FAST_DELETE         0      /* if it's 1, we never shrink the ht */
#endif
#ifndef SAMEKEY_OVERWRITE
#define SAMEKEY_OVERWRITE   1      /* overwrite item with our key on insert? */
#endif
#ifndef OCCUPANCY_PCT
#define OCCUPANCY_PCT       0.5    /* large PCT means smaller and slower */
#endif
#ifndef MIN_HASH_SIZE
#define MIN_HASH_SIZE       512    /* ht size when first created */
#endif
   /* When deleting a bucket, we can't just empty it (future hashes  *
    * may fail); instead we set the data field to DELETED.  Thus you *
    * should set DELETED to a data value you never use.  Better yet, *
    * if you don't need to delete, define INSERT_ONLY.               */
#ifndef INSERT_ONLY
#define DELETED                   -2UL
#define IS_BCK_DELETED(bck)       ( (bck) && (bck)->data == DELETED )
#define SET_BCK_DELETED(ht, bck)  do { (bck)->data = DELETED;                \
                                       FREE_KEY(ht, (bck)->key); } while ( 0 )
#else
#define IS_BCK_DELETED(bck)       0
#define SET_BCK_DELETED(ht, bck)  \
   do { fprintf(stderr, "Deletion not supported for insert-only hashtable\n");\
        exit(2); } while ( 0 )
#endif

   /* This is what an item is.  Either can be cast to a pointer. */
typedef struct {
   ulong key;         /* 4/8 bytes for the key: either a pointer or an int */
} HTItem;

struct Table(Bin);                            /* defined in chash.c, I hope */
struct Table(Iterator);
typedef struct Table(Bin)       Table;        /* Expands to SparseBin, etc */
typedef struct Table(Iterator)  TableIterator;

   /* for STORES_PTR to work ok, cchKey MUST BE DEFINED 1st, cItems 2nd! */
typedef struct HashTable {
   ulong cchKey;        /* the length of the key, or if it's \0 terminated */
   ulong cItems;        /* number of items currently in the hashtable */
   ulong cDeletedItems; /* # of buckets holding DELETE in the hashtable */
   ulong cBuckets;      /* size of the table */
   Table *table;        /* The actual contents of the hashtable */
   int fSaveKeys;       /* 1 if we copy keys locally; 2 if keys in one block */
   int cDeltaGoalSize;  /* # of coming inserts (or deletes, if <0) we expect */
   HTItem *posLastFind; /* position of last Find() command */
   TableIterator *iter; /* used in First/NextBucket */
} HashTable;

   /* Small keys are stored and passed directly, but large keys are
    * stored and passed as pointers.  To make it easier to remember
    * what to pass, we provide two functions:
    *   PTR_KEY: give it a pointer to your data, and it returns
    *            something appropriate to send to Hash() functions or
    *            be stored in a data field.
    *   KEY_PTR: give it something returned by a Hash() routine, and
    *            it returns a (char *) pointer to the actual data.
    */
#define HashKeySize(ht)   ( ((ulong *)(ht))[0] )  /* this is how we inline */
#define HashSize(ht)      ( ((ulong *)(ht))[1] )  /* ...a la C++ :-) */

#define STORES_PTR(ht)    ( HashKeySize(ht) == 0 || \
			    HashKeySize(ht) > sizeof(ulong) )
#define KEY_PTR(ht, key)  ( STORES_PTR(ht) ? (char *)(key) : (char *)&(key) )
#ifdef DONT_HAVE_TO_WORRY_ABOUT_BUS_ERRORS
#define PTR_KEY(ht, ptr)  ( STORES_PTR(ht) ? (ulong)(ptr) : *(ulong *)(ptr) )
#else
#define PTR_KEY(ht, ptr)  ( STORES_PTR(ht) ? (ulong)(ptr) : HTcopy((char *)ptr))
#endif


   /* Function prototypes */
unsigned long HTcopy(char *pul);         /* for PTR_KEY, not for users */

struct HashTable *AllocateHashTable(int cchKey, int fSaveKeys);
void ClearHashTable(struct HashTable *ht);
void FreeHashTable(struct HashTable *ht);

HTItem *HashFind(struct HashTable *ht, ulong key);
HTItem *HashFindLast(struct HashTable *ht);
HTItem *HashFindOrInsert(struct HashTable *ht, ulong key);
HTItem *HashFindOrInsertItem(struct HashTable *ht, HTItem *pItem);

HTItem *HashInsert(struct HashTable *ht, ulong key);
HTItem *HashInsertItem(struct HashTable *ht, HTItem *pItem);

#ifndef INSERT_ONLY
int HashDelete(struct HashTable *ht, ulong key);
int HashDeleteLast(struct HashTable *ht);
#endif

HTItem *HashFirstBucket(struct HashTable *ht);
HTItem *HashNextBucket(struct HashTable *ht);

int HashSetDeltaGoalSize(struct HashTable *ht, int delta);

```

`app/src/main/jni/zstd/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18.1)
project(zstd_jni C)

if(NOT DEFINED ROOTDIR)
    set(ROOTDIR ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)
endif()

set(ZSTD_ROOT ${ROOTDIR}/submodules/zstd/lib)

# Decoder-only: common + decompress sources
set(ZSTD_SOURCES
        ${ZSTD_ROOT}/common/debug.c
        ${ZSTD_ROOT}/common/entropy_common.c
        ${ZSTD_ROOT}/common/error_private.c
        ${ZSTD_ROOT}/common/fse_decompress.c
        ${ZSTD_ROOT}/common/xxhash.c
        ${ZSTD_ROOT}/common/zstd_common.c
        ${ZSTD_ROOT}/decompress/huf_decompress.c
        ${ZSTD_ROOT}/decompress/zstd_ddict.c
        ${ZSTD_ROOT}/decompress/zstd_decompress.c
        ${ZSTD_ROOT}/decompress/zstd_decompress_block.c)

add_library(zstd_dec SHARED
        zstd_jni.c
        ${ZSTD_SOURCES})

# Build decoder only
target_compile_definitions(zstd_dec PRIVATE
        ZSTD_DISABLE_COMPRESS=1
        ZSTD_DISABLE_ASM=1)

target_include_directories(zstd_dec PRIVATE
        ${ZSTD_ROOT}
        ${ZSTD_ROOT}/common
        ${CMAKE_CURRENT_SOURCE_DIR}/..)

if(ANDROID)
    find_library(log-lib log)
    target_link_libraries(zstd_dec ${log-lib})
else()
    find_package(JNI REQUIRED)
    target_include_directories(zstd_dec PRIVATE ${JNI_INCLUDE_DIRS})
endif()

```

`app/src/main/jni/zstd/zstd_jni.c`:

```c
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

#include <jni.h>
#include <stdlib.h>

#define ZSTD_STATIC_LINKING_ONLY
#include "common/memtrack.h"
#include "zstd.h"

static const size_t MAX_DECOMPRESSED_SIZE = 64 * 1024 * 1024;

static jbyteArray decompress_streaming(JNIEnv *env, jclass io_exc,
                                       const jbyte *src_buf, jsize src_len) {
    const char *exception_msg = NULL;
    ZSTD_DStream *dstream = NULL;
    unsigned char *out_buf = NULL;
    jbyteArray result = NULL;

    dstream = ZSTD_createDStream();
    if (!dstream) {
        exception_msg = "Failed to create ZSTD_DStream";
        goto cleanup;
    }

    ZSTD_initDStream(dstream);

    size_t out_capacity = ZSTD_DStreamOutSize();
    if (out_capacity < (size_t)src_len * 4)
        out_capacity = (size_t)src_len * 4;
    if (out_capacity > MAX_DECOMPRESSED_SIZE)
        out_capacity = MAX_DECOMPRESSED_SIZE;

    size_t out_size = 0;
    out_buf = pd_malloc(out_capacity);
    if (!out_buf) {
        exception_msg = "Out of memory";
        goto cleanup;
    }

    ZSTD_inBuffer input = { src_buf, (size_t)src_len, 0 };
    size_t ret = 1;

    while ((ret > 0) && (input.pos < input.size)) {
        ZSTD_outBuffer output = { out_buf + out_size, out_capacity - out_size, 0 };
        ret = ZSTD_decompressStream(dstream, &output, &input);

        if (ZSTD_isError(ret)) {
            exception_msg = ZSTD_getErrorName(ret);
            goto cleanup;
        }

        out_size += output.pos;

        if ((out_size == out_capacity) && (ret > 0)) {
            size_t new_capacity = out_capacity * 2;
            if (new_capacity > MAX_DECOMPRESSED_SIZE)
                new_capacity = MAX_DECOMPRESSED_SIZE;
            if (new_capacity == out_capacity) {
                exception_msg = "Decompressed size too large";
                goto cleanup;
            }

            unsigned char *new_buf = pd_realloc(out_buf, new_capacity);
            if (!new_buf) {
                exception_msg = "Out of memory";
                goto cleanup;
            }
            out_buf = new_buf;
            out_capacity = new_capacity;
        }
    }

    result = (*env)->NewByteArray(env, (jsize)out_size);
    if (result)
        (*env)->SetByteArrayRegion(env, result, 0, (jsize)out_size, (jbyte *)out_buf);

cleanup:
    pd_free(out_buf);

    if (dstream)
        ZSTD_freeDStream(dstream);

    if (exception_msg)
        (*env)->ThrowNew(env, io_exc, exception_msg);

    return result;
}

static jbyteArray decompress_single_shot(JNIEnv *env, jclass io_exc,
                                         const jbyte *src_buf, jsize src_len,
                                         unsigned long long decompressed_size) {
    if (decompressed_size > MAX_DECOMPRESSED_SIZE) {
        (*env)->ThrowNew(env, io_exc, "Decompressed size too large");
        return NULL;
    }

    jbyteArray result = (*env)->NewByteArray(env, (jsize)decompressed_size);
    if (!result)
        return NULL;

    jbyte *dst_buf = (*env)->GetByteArrayElements(env, result, NULL);
    if (!dst_buf)
        return NULL;

    size_t actual = ZSTD_decompress(dst_buf, (size_t)decompressed_size,
                                    src_buf, (size_t)src_len);

    (*env)->ReleaseByteArrayElements(env, result, dst_buf, 0);

    if (ZSTD_isError(actual)) {
        (*env)->ThrowNew(env, io_exc, ZSTD_getErrorName(actual));
        return NULL;
    }

    return result;
}

/*
 * Decompress a zstd-compressed byte array.
 * Returns the decompressed data or null on error (possibly with an IOException thrown).
 */
JNIEXPORT jbyteArray JNICALL
Java_com_emanuelef_remote_1capture_ZstdDecoder_decompress(JNIEnv *env, jclass cls, jbyteArray src) {
    jsize src_len = (*env)->GetArrayLength(env, src);
    jbyte *src_buf = (*env)->GetByteArrayElements(env, src, NULL);
    if (!src_buf)
        return NULL;

    const jclass io_exc = (*env)->FindClass(env, "java/io/IOException");
    unsigned long long decompressed_size = ZSTD_getFrameContentSize(src_buf, src_len);
    jbyteArray result;

    if ((decompressed_size == ZSTD_CONTENTSIZE_ERROR) ||
        (decompressed_size == ZSTD_CONTENTSIZE_UNKNOWN))
        result = decompress_streaming(env, io_exc, src_buf, src_len);
    else
        result = decompress_single_shot(env, io_exc, src_buf, src_len, decompressed_size);

    (*env)->ReleaseByteArrayElements(env, src, src_buf, JNI_ABORT);

    return result;
}

```

`app/src/main/res/anim/slide_in_left.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android" >
    <translate
        android:duration="300"
        android:fromXDelta="100%"
        android:toXDelta="0%" >
    </translate>
</set>

```

`app/src/main/res/anim/slide_in_right.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:shareInterpolator="false">
    <translate
        android:duration="300"
        android:fromXDelta="-100%"
        android:toXDelta="0%" />
</set>
```

`app/src/main/res/anim/slide_out_left.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android" >
    <translate
        android:duration="300"
        android:fromXDelta="0%"
        android:toXDelta="-100%" >
    </translate>
</set>

```

`app/src/main/res/anim/slide_out_right.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android" >
    <translate
        android:duration="300"
        android:fromXDelta="0%"
        android:toXDelta="100%" >
    </translate>
</set>

```

`app/src/main/res/drawable-v23/splash_screen.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:opacity="opaque">

  <item android:drawable="@color/colorPrimaryDark" />

  <item
      android:drawable="@drawable/ic_logo"
      android:width="128dp"
      android:height="128dp"
      android:gravity="center"
      tools:targetApi="m" />
</layer-list>
```

`app/src/main/res/drawable/banner.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="320dp"
    android:height="180dp"
    android:viewportWidth="320"
    android:viewportHeight="180">
  <path
      android:pathData="M0.243,-0.054h320.106v180.055h-320.106z"
      android:strokeWidth="0.376099"
      android:fillColor="#512da8"
      android:strokeColor="#000000"/>
  <path
      android:pathData="m32.281,78.35c-0.329,0.292 -0.711,0.542 -1.151,0.75v0.757c0.244,-0.09 0.52,-0.224 0.827,-0.406 0.307,-0.18 0.555,-0.36 0.741,-0.539v4.999L33.482,83.911v-6.414h-0.505c-0.134,0.276 -0.368,0.559 -0.695,0.853zM39.115,78.297c-0.169,-0.261 -0.382,-0.458 -0.64,-0.596 -0.261,-0.138 -0.561,-0.206 -0.901,-0.206 -0.465,0 -0.853,0.123 -1.16,0.375 -0.305,0.25 -0.535,0.605 -0.691,1.064 -0.152,0.459 -0.23,1.07 -0.23,1.824 0,1.199 0.21,2.066 0.629,2.598 0.353,0.439 0.836,0.662 1.454,0.662 0.465,0 0.853,-0.123 1.158,-0.379 0.307,-0.252 0.537,-0.607 0.689,-1.066 0.155,-0.459 0.233,-1.066 0.233,-1.814 0,-0.634 -0.048,-1.136 -0.145,-1.509 -0.094,-0.373 -0.226,-0.689 -0.397,-0.952zM38.482,82.851c-0.247,0.349 -0.548,0.524 -0.906,0.524 -0.362,0 -0.664,-0.175 -0.912,-0.522 -0.247,-0.345 -0.366,-1.044 -0.366,-2.094 0,-1.046 0.134,-1.767 0.403,-2.155 0.217,-0.307 0.504,-0.458 0.864,-0.458 0.366,0 0.671,0.171 0.917,0.514 0.247,0.345 0.37,1.044 0.37,2.098 -0.004,1.046 -0.123,1.743 -0.37,2.092zM44.08,78.297c-0.169,-0.261 -0.384,-0.458 -0.642,-0.596 -0.261,-0.138 -0.561,-0.206 -0.903,-0.206 -0.465,0 -0.851,0.123 -1.156,0.375 -0.307,0.25 -0.537,0.605 -0.693,1.064 -0.155,0.459 -0.233,1.07 -0.233,1.824 0,1.199 0.211,2.066 0.632,2.598 0.351,0.439 0.833,0.662 1.452,0.662 0.465,0 0.851,-0.123 1.158,-0.379 0.307,-0.252 0.537,-0.607 0.691,-1.066 0.155,-0.459 0.23,-1.066 0.23,-1.814 0,-0.634 -0.048,-1.136 -0.143,-1.509 -0.094,-0.373 -0.226,-0.689 -0.394,-0.952zM43.442,82.851c-0.247,0.349 -0.548,0.524 -0.908,0.524 -0.36,0 -0.662,-0.175 -0.91,-0.522 -0.247,-0.345 -0.366,-1.044 -0.366,-2.094 0,-1.046 0.132,-1.767 0.403,-2.155 0.215,-0.307 0.504,-0.458 0.864,-0.458 0.366,0 0.671,0.171 0.917,0.514 0.247,0.345 0.37,1.044 0.37,2.098 0.002,1.046 -0.119,1.743 -0.37,2.092zM49.044,78.297c-0.173,-0.261 -0.384,-0.458 -0.642,-0.596 -0.259,-0.138 -0.561,-0.206 -0.903,-0.206 -0.465,0 -0.849,0.123 -1.156,0.375 -0.307,0.25 -0.537,0.605 -0.693,1.064 -0.155,0.459 -0.232,1.07 -0.232,1.824 0,1.199 0.21,2.066 0.631,2.598 0.351,0.439 0.836,0.662 1.452,0.662 0.467,0 0.853,-0.123 1.16,-0.379 0.307,-0.252 0.537,-0.607 0.691,-1.066 0.155,-0.459 0.232,-1.066 0.232,-1.814 0,-0.634 -0.048,-1.136 -0.143,-1.509 -0.099,-0.373 -0.232,-0.689 -0.397,-0.952zM48.407,82.851c-0.247,0.349 -0.55,0.524 -0.91,0.524 -0.362,0 -0.664,-0.175 -0.91,-0.522 -0.244,-0.345 -0.366,-1.044 -0.366,-2.094 0,-1.046 0.134,-1.767 0.404,-2.155 0.215,-0.307 0.504,-0.458 0.862,-0.458 0.368,0 0.673,0.171 0.919,0.514 0.244,0.345 0.367,1.044 0.367,2.098 0.002,1.046 -0.123,1.743 -0.367,2.092zM52.551,78.911v4.998h0.785L53.336,77.495L52.831,77.495c-0.138,0.276 -0.37,0.561 -0.697,0.855 -0.327,0.292 -0.713,0.542 -1.151,0.75v0.757c0.244,-0.09 0.52,-0.224 0.827,-0.406 0.303,-0.18 0.552,-0.36 0.741,-0.54zM56.434,78.35c-0.331,0.292 -0.713,0.542 -1.151,0.75v0.757c0.244,-0.09 0.518,-0.224 0.825,-0.406 0.307,-0.18 0.555,-0.36 0.741,-0.539v4.999h0.787v-6.414h-0.505c-0.138,0.276 -0.37,0.559 -0.697,0.853zM63.267,78.297c-0.173,-0.261 -0.384,-0.458 -0.643,-0.596 -0.259,-0.138 -0.559,-0.206 -0.901,-0.206 -0.463,0 -0.853,0.123 -1.156,0.375 -0.309,0.25 -0.54,0.605 -0.695,1.064 -0.152,0.459 -0.232,1.07 -0.232,1.824 0,1.199 0.211,2.066 0.631,2.598 0.351,0.439 0.836,0.662 1.454,0.662 0.467,0 0.851,-0.123 1.156,-0.379 0.309,-0.252 0.539,-0.607 0.693,-1.066 0.155,-0.459 0.234,-1.066 0.234,-1.814 0,-0.634 -0.048,-1.136 -0.143,-1.509 -0.092,-0.373 -0.232,-0.689 -0.397,-0.952zM62.635,82.85c-0.248,0.349 -0.55,0.524 -0.908,0.524 -0.358,0 -0.662,-0.175 -0.908,-0.522 -0.244,-0.345 -0.37,-1.044 -0.37,-2.094 0,-1.046 0.136,-1.767 0.408,-2.155 0.215,-0.307 0.504,-0.458 0.864,-0.458 0.366,0 0.669,0.171 0.916,0.514 0.244,0.345 0.37,1.044 0.37,2.098 -0.002,1.046 -0.123,1.743 -0.371,2.092zM32.281,89.059c-0.329,0.293 -0.711,0.542 -1.151,0.75v0.757c0.244,-0.09 0.52,-0.224 0.827,-0.406 0.307,-0.18 0.555,-0.358 0.741,-0.539L32.699,94.619L33.482,94.619v-6.414h-0.505c-0.134,0.272 -0.368,0.559 -0.695,0.853zM39.115,89.005c-0.169,-0.261 -0.382,-0.459 -0.64,-0.596 -0.261,-0.136 -0.561,-0.206 -0.901,-0.206 -0.465,0 -0.853,0.125 -1.16,0.375 -0.307,0.25 -0.537,0.607 -0.693,1.066 -0.152,0.459 -0.23,1.068 -0.23,1.82 0,1.202 0.21,2.066 0.629,2.598 0.353,0.441 0.836,0.664 1.454,0.664 0.465,0 0.853,-0.125 1.158,-0.379 0.307,-0.252 0.537,-0.607 0.689,-1.066 0.155,-0.459 0.234,-1.068 0.234,-1.816 0,-0.632 -0.048,-1.134 -0.145,-1.506 -0.092,-0.377 -0.224,-0.693 -0.395,-0.954zM38.482,93.557c-0.247,0.345 -0.548,0.522 -0.906,0.522 -0.362,0 -0.664,-0.175 -0.912,-0.522 -0.247,-0.345 -0.366,-1.044 -0.366,-2.096 0,-1.046 0.134,-1.765 0.403,-2.156 0.217,-0.305 0.504,-0.458 0.864,-0.458 0.366,0 0.671,0.175 0.917,0.517 0.247,0.345 0.37,1.044 0.37,2.096 -0.004,1.052 -0.123,1.748 -0.37,2.098zM43.409,94.616v-6.414h-0.505c-0.136,0.274 -0.37,0.561 -0.699,0.855 -0.327,0.293 -0.711,0.542 -1.149,0.75v0.757c0.244,-0.09 0.518,-0.224 0.824,-0.406 0.307,-0.18 0.555,-0.358 0.743,-0.539v4.998zM46.924,89.619v4.998h0.783v-6.414h-0.505c-0.134,0.274 -0.37,0.561 -0.697,0.855 -0.327,0.293 -0.711,0.542 -1.149,0.75v0.757c0.244,-0.09 0.518,-0.224 0.825,-0.406 0.307,-0.18 0.555,-0.362 0.743,-0.54zM53.343,89.005c-0.169,-0.261 -0.381,-0.459 -0.638,-0.596 -0.261,-0.136 -0.561,-0.206 -0.901,-0.206 -0.465,0 -0.851,0.125 -1.156,0.375 -0.307,0.25 -0.539,0.607 -0.695,1.066 -0.155,0.459 -0.232,1.068 -0.232,1.82 0,1.202 0.21,2.066 0.631,2.598 0.351,0.441 0.835,0.664 1.454,0.664 0.463,0 0.851,-0.125 1.158,-0.379 0.307,-0.252 0.535,-0.607 0.689,-1.066 0.155,-0.459 0.232,-1.068 0.232,-1.816 0,-0.632 -0.048,-1.134 -0.145,-1.506 -0.094,-0.377 -0.228,-0.693 -0.397,-0.954zM52.709,93.557c-0.244,0.345 -0.548,0.522 -0.906,0.522 -0.362,0 -0.665,-0.175 -0.912,-0.522 -0.247,-0.345 -0.366,-1.044 -0.366,-2.096 0,-1.046 0.134,-1.765 0.404,-2.156 0.215,-0.305 0.504,-0.458 0.862,-0.458 0.366,0 0.673,0.175 0.917,0.517 0.247,0.345 0.367,1.044 0.367,2.096 0,1.052 -0.121,1.748 -0.367,2.098zM56.434,89.057c-0.331,0.293 -0.713,0.542 -1.151,0.75v0.757c0.244,-0.09 0.518,-0.224 0.825,-0.406 0.307,-0.18 0.555,-0.358 0.741,-0.539v4.998h0.787v-6.414h-0.505c-0.138,0.272 -0.37,0.559 -0.697,0.853zM63.267,89.003c-0.173,-0.261 -0.384,-0.459 -0.643,-0.596 -0.259,-0.136 -0.559,-0.206 -0.901,-0.206 -0.463,0 -0.853,0.125 -1.156,0.375 -0.305,0.25 -0.54,0.607 -0.697,1.066 -0.152,0.459 -0.232,1.068 -0.232,1.82 0,1.202 0.211,2.066 0.631,2.598 0.351,0.441 0.836,0.664 1.454,0.664 0.467,0 0.851,-0.125 1.156,-0.379 0.309,-0.252 0.539,-0.607 0.693,-1.066 0.155,-0.459 0.233,-1.068 0.233,-1.816 0,-0.632 -0.048,-1.134 -0.143,-1.506C63.572,89.58 63.432,89.264 63.267,89.003ZM62.635,93.555c-0.248,0.345 -0.55,0.522 -0.908,0.522 -0.358,0 -0.662,-0.175 -0.908,-0.522 -0.244,-0.345 -0.37,-1.044 -0.37,-2.096 0,-1.046 0.136,-1.765 0.408,-2.156 0.215,-0.305 0.504,-0.458 0.864,-0.458 0.366,0 0.669,0.175 0.916,0.517 0.244,0.345 0.37,1.044 0.37,2.096 -0.002,1.052 -0.123,1.748 -0.371,2.098zM66.357,89.054c-0.329,0.293 -0.717,0.542 -1.151,0.75v0.757c0.244,-0.09 0.517,-0.224 0.825,-0.406 0.305,-0.18 0.553,-0.358 0.739,-0.539v4.998h0.783v-6.414h-0.502c-0.134,0.272 -0.366,0.559 -0.695,0.853zM32.281,99.763c-0.329,0.29 -0.711,0.542 -1.151,0.75v0.757c0.244,-0.092 0.52,-0.226 0.827,-0.408 0.307,-0.182 0.555,-0.36 0.741,-0.539v4.997L33.482,105.32v-6.412h-0.505c-0.134,0.276 -0.368,0.561 -0.695,0.855zM39.115,99.715c-0.169,-0.263 -0.382,-0.459 -0.64,-0.597 -0.261,-0.134 -0.561,-0.204 -0.901,-0.204 -0.465,0 -0.853,0.123 -1.16,0.375 -0.307,0.248 -0.537,0.603 -0.693,1.063 -0.152,0.463 -0.23,1.068 -0.23,1.824 0,1.202 0.21,2.064 0.629,2.599 0.353,0.441 0.836,0.66 1.454,0.66 0.465,0 0.853,-0.125 1.158,-0.377 0.307,-0.252 0.537,-0.607 0.689,-1.066 0.155,-0.459 0.234,-1.066 0.234,-1.816 0,-0.634 -0.048,-1.138 -0.145,-1.507 -0.092,-0.379 -0.224,-0.695 -0.395,-0.952zM38.482,104.263c-0.247,0.348 -0.548,0.524 -0.906,0.524 -0.362,0 -0.664,-0.173 -0.912,-0.52 -0.247,-0.345 -0.366,-1.04 -0.366,-2.094 0,-1.048 0.134,-1.767 0.403,-2.156 0.217,-0.305 0.504,-0.458 0.864,-0.458 0.366,0 0.671,0.173 0.917,0.517 0.247,0.345 0.37,1.048 0.37,2.098 -0.004,1.05 -0.123,1.746 -0.37,2.09zM44.08,99.715c-0.169,-0.263 -0.384,-0.459 -0.642,-0.597 -0.261,-0.134 -0.561,-0.204 -0.903,-0.204 -0.465,0 -0.851,0.123 -1.156,0.375 -0.307,0.248 -0.537,0.603 -0.693,1.063 -0.155,0.463 -0.233,1.068 -0.233,1.824 0,1.202 0.211,2.064 0.632,2.599 0.351,0.441 0.833,0.66 1.452,0.66 0.465,0 0.851,-0.125 1.158,-0.377 0.307,-0.252 0.537,-0.607 0.691,-1.066 0.155,-0.463 0.23,-1.066 0.23,-1.816 0,-0.634 -0.048,-1.138 -0.143,-1.507 -0.094,-0.379 -0.226,-0.695 -0.394,-0.952zM43.442,104.263c-0.247,0.348 -0.548,0.524 -0.908,0.524 -0.36,0 -0.662,-0.173 -0.91,-0.52 -0.247,-0.345 -0.366,-1.04 -0.366,-2.094 0,-1.048 0.132,-1.767 0.403,-2.156 0.215,-0.305 0.504,-0.458 0.864,-0.458 0.366,0 0.671,0.173 0.917,0.517 0.247,0.345 0.37,1.048 0.37,2.098 0,1.05 -0.119,1.746 -0.37,2.09zM49.044,99.715c-0.173,-0.263 -0.384,-0.459 -0.642,-0.597 -0.259,-0.134 -0.561,-0.204 -0.903,-0.204 -0.465,0 -0.849,0.123 -1.156,0.375 -0.307,0.248 -0.537,0.603 -0.693,1.063 -0.155,0.463 -0.232,1.068 -0.232,1.824 0,1.202 0.21,2.064 0.631,2.599 0.351,0.441 0.836,0.66 1.452,0.66 0.467,0 0.853,-0.125 1.16,-0.377 0.307,-0.252 0.537,-0.607 0.691,-1.066 0.155,-0.463 0.232,-1.066 0.232,-1.816 0,-0.634 -0.048,-1.138 -0.143,-1.507 -0.099,-0.379 -0.232,-0.695 -0.397,-0.952zM48.407,104.263c-0.247,0.348 -0.55,0.524 -0.91,0.524 -0.362,0 -0.664,-0.173 -0.91,-0.52 -0.244,-0.345 -0.366,-1.04 -0.366,-2.094 0,-1.048 0.134,-1.767 0.404,-2.156 0.215,-0.305 0.504,-0.458 0.862,-0.458 0.368,0 0.673,0.173 0.919,0.517 0.244,0.345 0.367,1.048 0.367,2.098 0.002,1.05 -0.123,1.746 -0.367,2.09zM52.132,99.764c-0.327,0.29 -0.713,0.542 -1.151,0.75v0.757c0.244,-0.092 0.52,-0.226 0.827,-0.408 0.305,-0.182 0.553,-0.36 0.743,-0.539v4.997h0.785L53.336,98.91L52.831,98.91c-0.138,0.276 -0.37,0.561 -0.699,0.855zM56.434,99.764c-0.331,0.29 -0.713,0.542 -1.151,0.75v0.757c0.244,-0.092 0.518,-0.226 0.825,-0.408 0.307,-0.182 0.555,-0.36 0.741,-0.539v4.997h0.787v-6.412h-0.505c-0.138,0.276 -0.37,0.561 -0.697,0.855zM63.267,99.716c-0.173,-0.263 -0.384,-0.459 -0.643,-0.597 -0.259,-0.134 -0.559,-0.204 -0.901,-0.204 -0.463,0 -0.853,0.123 -1.156,0.375 -0.309,0.248 -0.54,0.603 -0.697,1.063 -0.152,0.463 -0.232,1.068 -0.232,1.824 0,1.202 0.211,2.064 0.631,2.599 0.351,0.441 0.836,0.66 1.454,0.66 0.467,0 0.851,-0.125 1.156,-0.377 0.309,-0.252 0.539,-0.607 0.693,-1.066 0.155,-0.463 0.233,-1.066 0.233,-1.816 0,-0.634 -0.048,-1.138 -0.143,-1.507 -0.09,-0.379 -0.23,-0.695 -0.395,-0.952zM62.635,104.264c-0.248,0.348 -0.55,0.524 -0.908,0.524 -0.358,0 -0.662,-0.173 -0.908,-0.52 -0.244,-0.345 -0.37,-1.041 -0.37,-2.094 0,-1.048 0.136,-1.767 0.408,-2.156 0.215,-0.305 0.504,-0.458 0.864,-0.458 0.366,0 0.669,0.173 0.916,0.517 0.244,0.345 0.37,1.048 0.37,2.098 -0.002,1.05 -0.123,1.746 -0.371,2.09zM77.209,89.684c0,-16.146 -13.135,-29.281 -29.278,-29.281 -16.145,0 -29.283,13.135 -29.283,29.281 0,16.146 13.137,29.281 29.281,29.281 16.144,-0.002 29.28,-13.135 29.28,-29.281zM28.566,79.417c0.239,0.351 0.358,1.04 0.358,2.074 0,1.046 -0.121,1.743 -0.37,2.094 -0.248,0.348 -0.548,0.522 -0.908,0.522 -0.311,0 -0.568,-0.156 -0.794,-0.413 0.427,-1.496 0.996,-2.93 1.713,-4.276zM67.054,99.645c-0.136,0.276 -0.367,0.561 -0.697,0.855 -0.329,0.293 -0.717,0.542 -1.151,0.75v0.757c0.244,-0.09 0.517,-0.226 0.825,-0.406 0.208,-0.121 0.348,-0.244 0.502,-0.366 -3.873,6.219 -10.756,10.379 -18.608,10.379 -7.629,0 -14.356,-3.925 -18.284,-9.852 -0.021,-0.121 -0.032,-0.259 -0.06,-0.362 -0.096,-0.375 -0.23,-0.691 -0.395,-0.952 -0.169,-0.261 -0.384,-0.459 -0.642,-0.596 -0.011,-0.006 -0.027,-0.006 -0.037,-0.016 -0.904,-1.724 -1.59,-3.579 -2.011,-5.533 0.314,0.254 0.682,0.421 1.147,0.421 0.467,0 0.853,-0.125 1.158,-0.379 0.309,-0.252 0.539,-0.607 0.693,-1.066 0.155,-0.459 0.23,-1.068 0.23,-1.816 0,-0.632 -0.048,-1.134 -0.143,-1.506 -0.096,-0.375 -0.23,-0.689 -0.395,-0.952 -0.169,-0.261 -0.384,-0.459 -0.642,-0.596 -0.259,-0.136 -0.559,-0.206 -0.903,-0.206 -0.463,0 -0.851,0.125 -1.156,0.375 -0.186,0.151 -0.333,0.351 -0.462,0.579 0.037,-1.62 0.257,-3.19 0.631,-4.706 0.283,0.176 0.601,0.298 0.989,0.298 0.467,0 0.853,-0.125 1.158,-0.379 0.309,-0.252 0.539,-0.607 0.693,-1.066 0.155,-0.459 0.23,-1.066 0.23,-1.816 0,-0.632 -0.048,-1.136 -0.143,-1.507 -0.096,-0.373 -0.23,-0.689 -0.395,-0.954 -0.068,-0.105 -0.178,-0.156 -0.261,-0.241 3.789,-6.581 10.879,-11.032 19.003,-11.032 7.859,0 14.745,4.169 18.617,10.398 -0.064,0.066 -0.114,0.129 -0.191,0.195 -0.327,0.292 -0.715,0.542 -1.151,0.75v0.757c0.244,-0.09 0.518,-0.224 0.827,-0.406 0.305,-0.18 0.552,-0.36 0.737,-0.539v4.998h0.785v-3.945c1.462,2.936 2.302,6.228 2.302,9.721 0,0.215 -0.027,0.425 -0.037,0.642 -0.006,0.021 -0.016,0.032 -0.027,0.053 -0.151,0.459 -0.234,1.068 -0.234,1.822 0,0.241 0.016,0.459 0.037,0.675 -0.349,2.406 -1.088,4.684 -2.158,6.773h-0.384v-0.004h0.006zM26.371,91.464c0,-1.046 0.132,-1.765 0.403,-2.156 0.213,-0.305 0.504,-0.458 0.864,-0.458 0.367,0 0.671,0.175 0.917,0.517 0.247,0.345 0.37,1.044 0.37,2.096 0,1.046 -0.121,1.745 -0.37,2.096 -0.247,0.345 -0.548,0.522 -0.908,0.522 -0.36,0 -0.662,-0.175 -0.908,-0.522 -0.247,-0.345 -0.367,-1.042 -0.367,-2.094zM67.653,117.151 L74.126,110.678 96.62,133.173 90.147,139.646z"
      android:strokeWidth="1.83837"
      android:fillColor="#ffffff"/>
  <path
      android:pathData="m102.376,93.532l0,11.962l-4.029,0L98.347,74.939l11.269,0q5.016,0 7.849,2.56 2.854,2.56 2.854,6.778 0,4.449 -2.791,6.862 -2.77,2.392 -7.954,2.392zM102.376,90.237l7.24,0q3.232,0 4.953,-1.511 1.721,-1.532 1.721,-4.407 0,-2.728 -1.721,-4.365 -1.721,-1.637 -4.722,-1.7l-7.471,0z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
  <path
      android:pathData="m147.936,95.799q-0.567,4.848 -3.589,7.492 -3.001,2.623 -7.996,2.623 -5.414,0 -8.688,-3.882 -3.253,-3.882 -3.253,-10.388l0,-2.938q0,-4.26 1.511,-7.492 1.532,-3.232 4.323,-4.953 2.791,-1.742 6.464,-1.742 4.869,0 7.807,2.728 2.938,2.707 3.421,7.513l-4.05,0q-0.525,-3.652 -2.287,-5.288 -1.742,-1.637 -4.89,-1.637 -3.861,0 -6.065,2.854 -2.183,2.854 -2.183,8.121l0,2.959q0,4.974 2.078,7.912 2.078,2.938 5.813,2.938 3.358,0 5.142,-1.511 1.805,-1.532 2.392,-5.309z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
  <path
      android:pathData="m170.307,97.519l-12.801,0l-2.875,7.975l-4.155,0l11.668,-30.555l3.526,0l11.689,30.555l-4.134,0zM158.723,94.204l10.388,0l-5.204,-14.291z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
  <path
      android:pathData="m185.5,93.532l0,11.962l-4.029,0L181.471,74.939l11.269,0q5.016,0 7.849,2.56 2.854,2.56 2.854,6.778 0,4.449 -2.791,6.862 -2.77,2.392 -7.954,2.392zM185.5,90.237l7.24,0q3.232,0 4.953,-1.511 1.721,-1.532 1.721,-4.407 0,-2.728 -1.721,-4.365 -1.721,-1.637 -4.722,-1.7l-7.471,0z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
  <path
      android:pathData="m207.032,93.952q0,-5.225 2.476,-8.394 2.476,-3.19 6.485,-3.19 3.987,0 6.317,2.728L222.31,73.26l3.882,0l0,32.234l-3.568,0l-0.189,-2.434q-2.329,2.854 -6.485,2.854 -3.945,0 -6.443,-3.232 -2.476,-3.232 -2.476,-8.436zM210.914,94.393q0,3.861 1.595,6.044 1.595,2.183 4.407,2.183 3.694,0 5.393,-3.316l0,-10.43q-1.742,-3.211 -5.351,-3.211 -2.854,0 -4.449,2.204 -1.595,2.204 -1.595,6.527z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
  <path
      android:pathData="m243.19,86.271q-0.881,-0.147 -1.91,-0.147 -3.819,0 -5.183,3.253l0,16.117L232.215,105.494L232.215,82.787l3.777,0l0.063,2.623q1.91,-3.043 5.414,-3.043 1.133,0 1.721,0.294z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
  <path
      android:pathData="m245.31,93.931q0,-3.337 1.301,-6.002 1.322,-2.665 3.652,-4.113 2.35,-1.448 5.351,-1.448 4.638,0 7.492,3.211 2.875,3.211 2.875,8.541l0,0.273q0,3.316 -1.28,5.96 -1.259,2.623 -3.631,4.092 -2.35,1.469 -5.414,1.469 -4.617,0 -7.492,-3.211 -2.854,-3.211 -2.854,-8.499zM249.213,94.393q0,3.777 1.742,6.065 1.763,2.287 4.701,2.287 2.959,0 4.701,-2.308 1.742,-2.329 1.742,-6.506 0,-3.735 -1.784,-6.044 -1.763,-2.329 -4.701,-2.329 -2.875,0 -4.638,2.287 -1.763,2.287 -1.763,6.548z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
  <path
      android:pathData="m275.068,105.494l-3.882,0L271.185,82.787l3.882,0zM270.871,76.764q0,-0.944 0.567,-1.595 0.588,-0.651 1.721,-0.651 1.133,0 1.721,0.651 0.588,0.651 0.588,1.595 0,0.944 -0.588,1.574 -0.588,0.63 -1.721,0.63 -1.133,0 -1.721,-0.63 -0.567,-0.63 -0.567,-1.574z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
  <path
      android:pathData="m280.335,93.952q0,-5.225 2.476,-8.394 2.476,-3.19 6.485,-3.19 3.987,0 6.317,2.728L295.613,73.26l3.882,0l0,32.234l-3.568,0l-0.189,-2.434q-2.329,2.854 -6.485,2.854 -3.945,0 -6.443,-3.232 -2.476,-3.232 -2.476,-8.436zM284.218,94.393q0,3.861 1.595,6.044 1.595,2.183 4.407,2.183 3.694,0 5.393,-3.316l0,-10.43q-1.742,-3.211 -5.351,-3.211 -2.854,0 -4.449,2.204 -1.595,2.204 -1.595,6.527z"
      android:strokeLineJoin="miter"
      android:strokeWidth="0.264583"
      android:fillColor="#ffffff"
      android:strokeColor="#00000000"
      android:strokeLineCap="butt"/>
</vector>

```

`app/src/main/res/drawable/ic_add.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
</vector>

```

`app/src/main/res/drawable/ic_app_crash.xml`:

```xml
<vector android:height="128dp" android:viewportHeight="256"
    android:viewportWidth="256" android:width="128dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#B6D152" android:pathData="M184.333,171.899l16.053,-22.233c1.205,-1.672 0.828,-4.007 -0.845,-5.214c-1.674,-1.205 -4.006,-0.83 -5.215,0.842l-16.081,22.276c-0.208,0.291 -0.354,0.604 -0.472,0.927c-14.801,-7.064 -31.591,-11.072 -49.402,-11.072c-17.498,0 -34.004,3.873 -48.614,10.706c-0.092,-0.191 -0.195,-0.383 -0.326,-0.562l-16.081,-22.275c-1.206,-1.672 -3.537,-2.047 -5.213,-0.844c-1.673,1.207 -2.049,3.543 -0.843,5.213l15.777,21.854c-30.482,16.862 -51.208,47.232 -52.487,82.168h215.575C234.888,219.007 214.45,188.834 184.333,171.899z"/>
    <path android:fillColor="#594A42" android:pathData="M95.93,199.207l-5.94,5.941l-5.942,-5.941c-1.943,-1.944 -5.096,-1.942 -7.041,0.003c-1.943,1.943 -1.943,5.096 0,7.039l5.94,5.941l-5.94,5.941c-1.943,1.945 -1.943,5.098 0,7.043c1.943,1.944 5.097,1.944 7.041,-0.002l5.942,-5.94l5.941,5.942c1.942,1.944 5.097,1.944 7.041,0c1.946,-1.945 1.946,-5.098 0,-7.043l-5.941,-5.941l5.941,-5.941c1.946,-1.943 1.946,-5.098 0,-7.042C101.027,197.263 97.873,197.263 95.93,199.207z"/>
    <path android:fillColor="#F1F2F2" android:pathData="M76.237,182.55c-0.536,0 -1.054,-0.279 -1.339,-0.775c-0.423,-0.739 -0.168,-1.683 0.57,-2.105c2.107,-1.21 4.302,-2.363 6.518,-3.431c0.767,-0.364 1.689,-0.046 2.06,0.722c0.369,0.768 0.047,1.689 -0.722,2.059c-2.151,1.035 -4.277,2.154 -6.321,3.326C76.761,182.483 76.496,182.55 76.237,182.55z"/>
    <path android:fillColor="#F1F2F2" android:pathData="M40.77,218.337c-0.249,0 -0.501,-0.061 -0.736,-0.188c-0.75,-0.407 -1.026,-1.344 -0.618,-2.092c6.966,-12.795 17.292,-24.043 29.861,-32.531c0.706,-0.478 1.667,-0.291 2.142,0.416c0.477,0.705 0.291,1.664 -0.415,2.141c-12.162,8.213 -22.148,19.088 -28.878,31.449C41.846,218.046 41.316,218.337 40.77,218.337z"/>
    <path android:fillColor="#9FB543" android:pathData="M162.919,205.372c0,20.409 -10.769,38.297 -26.925,48.313h100.165c-1.271,-34.679 -21.709,-64.852 -51.826,-81.786l16.053,-22.233c1.205,-1.672 0.828,-4.007 -0.845,-5.214c-1.674,-1.205 -4.006,-0.83 -5.215,0.842l-16.081,22.276c-0.208,0.291 -0.354,0.604 -0.472,0.927c-12.364,-5.9 -26.113,-9.658 -40.687,-10.738C152.634,167.896 162.919,185.427 162.919,205.372z"/>
    <path android:fillColor="#594A42" android:pathData="M174.603,199.207l-5.938,5.941l-5.941,-5.941c-1.946,-1.944 -5.1,-1.942 -7.042,0.003c-1.945,1.943 -1.945,5.096 0,7.039l5.938,5.941l-5.938,5.941c-1.945,1.945 -1.945,5.098 0,7.043c1.942,1.944 5.096,1.944 7.042,-0.002l5.941,-5.94l5.939,5.942c1.943,1.944 5.099,1.944 7.041,0c1.946,-1.945 1.946,-5.098 0,-7.043l-5.941,-5.941l5.941,-5.941c1.946,-1.943 1.946,-5.098 0,-7.042C179.703,197.263 176.548,197.263 174.603,199.207z"/>
    <path android:fillColor="#594A42" android:pathData="M236.159,256H20.584c-0.628,0 -1.23,-0.255 -1.666,-0.708c-0.437,-0.453 -0.671,-1.063 -0.646,-1.691c1.245,-33.957 20.406,-64.734 51.414,-82.82l-14.268,-19.762c-0.945,-1.311 -1.325,-2.91 -1.066,-4.504c0.259,-1.596 1.122,-2.994 2.433,-3.94c1.042,-0.748 2.263,-1.143 3.536,-1.143c1.94,0 3.774,0.938 4.907,2.508l15.355,21.271c14.987,-6.703 31.052,-10.1 47.789,-10.1c17.023,0 33.328,3.502 48.499,10.411l15.58,-21.582c1.136,-1.57 2.969,-2.508 4.908,-2.508c1.274,0 2.497,0.396 3.535,1.143c2.706,1.952 3.318,5.74 1.369,8.444l-14.554,20.158c30.609,18.139 49.529,48.77 50.763,82.424c0.022,0.628 -0.212,1.238 -0.647,1.691S236.788,256 236.159,256zM23.016,251.372h210.712c-2.016,-31.896 -20.765,-60.719 -50.527,-77.456c-0.575,-0.323 -0.984,-0.876 -1.127,-1.52c-0.142,-0.644 -0.001,-1.317 0.385,-1.852l16.053,-22.233c0.456,-0.635 0.313,-1.525 -0.323,-1.983c-0.308,-0.222 -0.622,-0.269 -0.829,-0.269c-0.465,0 -0.885,0.215 -1.157,0.59l-16.08,22.275c-0.052,0.072 -0.11,0.195 -0.172,0.364c-0.223,0.612 -0.694,1.103 -1.3,1.35c-0.604,0.246 -1.284,0.228 -1.872,-0.054c-15.078,-7.197 -31.364,-10.847 -48.406,-10.847c-16.727,0 -32.752,3.529 -47.633,10.488c-1.154,0.536 -2.521,0.048 -3.068,-1.097c-0.033,-0.069 -0.067,-0.141 -0.115,-0.206l-16.083,-22.276c-0.269,-0.375 -0.688,-0.588 -1.152,-0.588c-0.207,0 -0.521,0.047 -0.831,0.271c-0.305,0.219 -0.508,0.548 -0.568,0.922c-0.062,0.375 0.028,0.75 0.25,1.058l15.778,21.854c0.386,0.536 0.526,1.213 0.381,1.859c-0.145,0.646 -0.559,1.199 -1.139,1.52C44.033,190.226 25.044,219.187 23.016,251.372z"/>
</vector>

```

`app/src/main/res/drawable/ic_apps.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M4,8h4L8,4L4,4v4zM10,20h4v-4h-4v4zM4,20h4v-4L4,16v4zM4,14h4v-4L4,10v4zM10,14h4v-4h-4v4zM16,4v4h4L20,4h-4zM10,8h4L14,4h-4v4zM16,14h4v-4h-4v4zM16,20h4v-4h-4v4z"/>
</vector>

```

`app/src/main/res/drawable/ic_arrow_drop_down.xml`:

```xml
<vector android:height="24dp"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@color/backgroundColor" android:pathData="M7,10l5,5 5,-5z"/>
</vector>

```

`app/src/main/res/drawable/ic_baseline_javascript.xml`:

```xml
<vector android:height="24dp" android:tint="#000000"
    android:viewportHeight="12" android:viewportWidth="12"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M 6 8 v -1 h 1.5 v 0.5 h 2 v -1 H 7 c -0.55 0 -1 -0.45 -1 -1 V 4 c 0 -0.55 0.45 -1 1 -1 h 3 c 0.55 0 1 0.45 1 1 v 1 h -1.5 v -0.5 h -2 v 1 H 10 c 0.55 0 1 0.45 1 1 V 8 c 0 0.55 -0.45 1 -1 1 h -3 C 6.45 9 6 8.55 6 8 z M 3 3 v 4.5 H 1.5 v -1 H 0 v 1 C 0 8.33 0.67 9 1.5 9 H 3 c 0.83 0 1.5 -0.67 1.5 -1.5 V 3 C 4.5 3 3.83 3 3 3 z"/>
</vector>

```

`app/src/main/res/drawable/ic_block.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
    Android drawable generated by fa5ad-free project:
    https://github.com/diwanoczko/fa5ad-free
    Resource generated base on Font Awesome 5 Free icons set:
    https://fontawesome.com/
-->
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="512"
    android:viewportHeight="512">
    <path
        android:fillColor="#FFF"
        android:pathData="M256 8C119.034 8 8 119.033 8 256s111.034 248 248 248 248-111.034 248-248S392.967 8 256 8zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676zM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676z"
        />
</vector>
```

`app/src/main/res/drawable/ic_book.xml`:

```xml
<!--
Source https://github.com/encharm/Font-Awesome-SVG-PNG/blob/master/black/svg/book.svg
All brand icons are trademarks of their respective owners.
-->
<vector android:height="24dp" android:viewportHeight="1792"
    android:viewportWidth="1792" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M1703,478q40,57 18,129l-275,906q-19,64 -76.5,107.5t-122.5,43.5h-923q-77,0 -148.5,-53.5t-99.5,-131.5q-24,-67 -2,-127 0,-4 3,-27t4,-37q1,-8 -3,-21.5t-3,-19.5q2,-11 8,-21t16.5,-23.5 16.5,-23.5q23,-38 45,-91.5t30,-91.5q3,-10 0.5,-30t-0.5,-28q3,-11 17,-28t17,-23q21,-36 42,-92t25,-90q1,-9 -2.5,-32t0.5,-28q4,-13 22,-30.5t22,-22.5q19,-26 42.5,-84.5t27.5,-96.5q1,-8 -3,-25.5t-2,-26.5q2,-8 9,-18t18,-23 17,-21q8,-12 16.5,-30.5t15,-35 16,-36 19.5,-32 26.5,-23.5 36,-11.5 47.5,5.5l-1,3q38,-9 51,-9h761q74,0 114,56t18,130l-274,906q-36,119 -71.5,153.5t-128.5,34.5h-869q-27,0 -38,15 -11,16 -1,43 24,70 144,70h923q29,0 56,-15.5t35,-41.5l300,-987q7,-22 5,-57 38,15 59,43zM639,480q-4,13 2,22.5t20,9.5h608q13,0 25.5,-9.5t16.5,-22.5l21,-64q4,-13 -2,-22.5t-20,-9.5h-608q-13,0 -25.5,9.5t-16.5,22.5zM556,736q-4,13 2,22.5t20,9.5h608q13,0 25.5,-9.5t16.5,-22.5l21,-64q4,-13 -2,-22.5t-20,-9.5h-608q-13,0 -25.5,9.5t-16.5,22.5z"/>
</vector>

```

`app/src/main/res/drawable/ic_bug.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M20,8h-2.81c-0.45,-0.78 -1.07,-1.45 -1.82,-1.96L17,4.41 15.59,3l-2.17,2.17C12.96,5.06 12.49,5 12,5c-0.49,0 -0.96,0.06 -1.41,0.17L8.41,3 7,4.41l1.62,1.63C7.88,6.55 7.26,7.22 6.81,8L4,8v2h2.09c-0.05,0.33 -0.09,0.66 -0.09,1v1L4,12v2h2v1c0,0.34 0.04,0.67 0.09,1L4,16v2h2.81c1.04,1.79 2.97,3 5.19,3s4.15,-1.21 5.19,-3L20,18v-2h-2.09c0.05,-0.33 0.09,-0.66 0.09,-1v-1h2v-2h-2v-1c0,-0.34 -0.04,-0.67 -0.09,-1L20,10L20,8zM14,16h-4v-2h4v2zM14,12h-4v-2h4v2z"/>
</vector>

```

`app/src/main/res/drawable/ic_check_solid.xml`:

```xml
<vector android:height="24dp" android:viewportHeight="512"
    android:viewportWidth="512" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@color/ok" android:pathData="M480,128c0,8.188 -3.125,16.38 -9.375,22.62l-256,256C208.4,412.9 200.2,416 192,416s-16.38,-3.125 -22.62,-9.375l-128,-128C35.13,272.4 32,264.2 32,256c0,-18.28 14.95,-32 32,-32c8.188,0 16.38,3.125 22.62,9.375L192,338.8l233.4,-233.4C431.6,99.13 439.8,96 448,96C465.1,96 480,109.7 480,128z"/>
</vector>

```

`app/src/main/res/drawable/ic_close.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M19,6.41L17.59,5 12,10.59 6.41,5 5,6.41 10.59,12 5,17.59 6.41,19 12,13.41 17.59,19 19,17.59 13.41,12z"/>
</vector>

```

`app/src/main/res/drawable/ic_content_copy.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M16,1L4,1c-1.1,0 -2,0.9 -2,2v14h2L4,3h12L16,1zM19,5L8,5c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h11c1.1,0 2,-0.9 2,-2L21,7c0,-1.1 -0.9,-2 -2,-2zM19,21L8,21L8,7h11v14z"/>
</vector>

```

`app/src/main/res/drawable/ic_content_copy_small.xml`:

```xml
<vector android:height="18dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="18dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M16,1L4,1c-1.1,0 -2,0.9 -2,2v14h2L4,3h12L16,1zM19,5L8,5c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h11c1.1,0 2,-0.9 2,-2L21,7c0,-1.1 -0.9,-2 -2,-2zM19,21L8,21L8,7h11v14z"/>
</vector>

```

`app/src/main/res/drawable/ic_copyright.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M11.88,9.14c1.28,0.06 1.61,1.15 1.63,1.66h1.79c-0.08,-1.98 -1.49,-3.19 -3.45,-3.19C9.64,7.61 8,9 8,12.14c0,1.94 0.93,4.24 3.84,4.24c2.22,0 3.41,-1.65 3.44,-2.95h-1.79c-0.03,0.59 -0.45,1.38 -1.63,1.44C10.55,14.83 10,13.81 10,12.14C10,9.25 11.28,9.16 11.88,9.14zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10s10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8s8,3.59 8,8S16.41,20 12,20z"/>
</vector>

```

`app/src/main/res/drawable/ic_exclamation_triangle_solid.xml`:

```xml
<vector android:height="24dp" android:viewportHeight="512"
    android:viewportWidth="576" android:width="27dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@color/danger" android:pathData="M569.517,440.013C587.975,472.007 564.806,512 527.94,512L48.054,512c-36.937,0 -59.999,-40.055 -41.577,-71.987L246.423,23.985c18.467,-32.009 64.72,-31.951 83.154,0l239.94,416.028zM288,354c-25.405,0 -46,20.595 -46,46s20.595,46 46,46 46,-20.595 46,-46 -20.595,-46 -46,-46zM244.327,188.654l7.418,136c0.347,6.364 5.609,11.346 11.982,11.346h48.546c6.373,0 11.635,-4.982 11.982,-11.346l7.418,-136c0.375,-6.874 -5.098,-12.654 -11.982,-12.654h-63.383c-6.884,0 -12.356,5.78 -11.981,12.654z"/>
</vector>

```

`app/src/main/res/drawable/ic_expand_more.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M16.59,8.59L12,13.17 7.41,8.59 6,10l6,6 6,-6z"/>
</vector>

```

`app/src/main/res/drawable/ic_external.xml`:

```xml
<vector android:autoMirrored="true" android:height="16dp"
    android:tint="?attr/colorControlNormal" android:viewportHeight="24"
    android:viewportWidth="24" android:width="16dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M19,19H5V5h7V3H5c-1.11,0 -2,0.9 -2,2v14c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2v-7h-2v7zM14,3v2h3.59l-9.83,9.83 1.41,1.41L19,6.41V10h2V3h-7z"/>
</vector>

```

`app/src/main/res/drawable/ic_file_export.xml`:

```xml
<vector android:height="24dp" android:viewportHeight="512"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="576" android:width="27dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#FF000000" android:pathData="M192,312C192,298.8 202.8,288 216,288H384V160H256c-17.67,0 -32,-14.33 -32,-32L224,0H48C21.49,0 0,21.49 0,48v416C0,490.5 21.49,512 48,512h288c26.51,0 48,-21.49 48,-48v-128H216C202.8,336 192,325.3 192,312zM256,0v128h128L256,0zM568.1,295l-80,-80c-9.38,-9.38 -24.56,-9.38 -33.94,0s-9.38,24.56 0,33.94L494.1,288H384v48h110.1l-39.03,39.03C450.3,379.7 448,385.8 448,392s2.34,12.28 7.03,16.97c9.38,9.38 24.56,9.38 33.94,0l80,-80C578.3,319.6 578.3,304.4 568.1,295z"/>
</vector>

```

`app/src/main/res/drawable/ic_file_import.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
All brand icons are trademarks of their respective owners.
-->
<vector android:height="24dp" android:viewportHeight="512"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="512" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#FF000000" android:pathData="M384,0v128h128L384,0zM352,128L352,0H176C149.5,0 128,21.49 128,48V288h174.1l-39.03,-39.03c-9.38,-9.38 -9.38,-24.56 0,-33.94s24.56,-9.38 33.94,0l80,80c9.38,9.38 9.38,24.56 0,33.94l-80,80c-9.38,9.38 -24.56,9.38 -33.94,0C258.3,404.3 256,398.2 256,392s2.34,-12.28 7.03,-16.97L302.1,336H128v128C128,490.5 149.5,512 176,512h288c26.51,0 48,-21.49 48,-48V160h-127.1C366.3,160 352,145.7 352,128zM24,288C10.75,288 0,298.7 0,312c0,13.25 10.75,24 24,24H128V288H24z"/>
</vector>

```

`app/src/main/res/drawable/ic_filter.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M4.25,5.61C6.27,8.2 10,13 10,13v6c0,0.55 0.45,1 1,1h2c0.55,0 1,-0.45 1,-1v-6c0,0 3.72,-4.8 5.74,-7.39C20.25,4.95 19.78,4 18.95,4H5.04C4.21,4 3.74,4.95 4.25,5.61z"/>
</vector>

```

`app/src/main/res/drawable/ic_help.xml`:

```xml
<vector android:autoMirrored="true" android:height="24dp"
    android:tint="?attr/colorControlNormal" android:viewportHeight="24"
    android:viewportWidth="24" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM13,19h-2v-2h2v2zM15.07,11.25l-0.9,0.92C13.45,12.9 13,13.5 13,15h-2v-0.5c0,-1.1 0.45,-2.1 1.17,-2.83l1.24,-1.26c0.37,-0.36 0.59,-0.86 0.59,-1.41 0,-1.1 -0.9,-2 -2,-2s-2,0.9 -2,2L8,9c0,-2.21 1.79,-4 4,-4s4,1.79 4,4c0,0.88 -0.36,1.68 -0.93,2.25z"/>
</vector>

```

`app/src/main/res/drawable/ic_hourglass_top.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M6,2l0.01,6L10,12l-3.99,4.01L6,22h12v-6l-4,-4l4,-3.99V2H6zM16,16.5V20H8v-3.5l4,-4L16,16.5z"/>
</vector>

```

`app/src/main/res/drawable/ic_image.xml`:

```xml
<vector android:height="24dp" android:tint="@android:color/darker_gray"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M21,19V5c0,-1.1 -0.9,-2 -2,-2H5c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2zM8.5,13.5l2.5,3.01L14.5,12l4.5,6H5l3.5,-4.5z"/>
</vector>

```

`app/src/main/res/drawable/ic_info.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM13,17h-2v-6h2v6zM13,9h-2L11,7h2v2z"/>
</vector>

```

`app/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
  <group android:scaleX="2.5425"
      android:scaleY="2.5425"
      android:translateX="-7.02"
      android:translateY="-7.02">
    <path
        android:pathData="M0.125,-0.25h48.375v48.375h-48.375z"
        android:strokeLineJoin="miter"
        android:strokeWidth="0"
        android:fillColor="#512da8"
        android:fillType="nonZero"
        android:strokeColor="#00000000"
        android:strokeLineCap="butt"/>
  </group>
</vector>

```

`app/src/main/res/drawable/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
  <group android:scaleX="1.6875"
      android:scaleY="1.6875"
      android:translateX="13.5"
      android:translateY="13.5">
    <path
        android:pathData="m14.3868,15.1546h0.1985v2.5184h-0.3075v-1.9626c-0.0729,0.07 -0.1704,0.1408 -0.2909,0.2115 -0.1205,0.0715 -0.2288,0.1242 -0.3248,0.1595v-0.2974c0.1725,-0.0816 0.3226,-0.1797 0.4518,-0.2945 0.1285,-0.1155 0.2201,-0.2266 0.2728,-0.3349zM16.9528,15.8425c0.0375,0.1465 0.057,0.3436 0.057,0.5926 0,0.2938 -0.031,0.532 -0.0917,0.7124 -0.0599,0.1805 -0.1501,0.3198 -0.2707,0.4187 -0.1198,0.1003 -0.2721,0.1487 -0.4547,0.1487 -0.2425,0 -0.4324,-0.0873 -0.5709,-0.2598 -0.1646,-0.2086 -0.2469,-0.5493 -0.2469,-1.0199 0,-0.2959 0.0303,-0.5356 0.0902,-0.716 0.0613,-0.1805 0.1516,-0.3198 0.2714,-0.4179 0.1205,-0.0989 0.2728,-0.1472 0.4555,-0.1472 0.1335,0 0.2512,0.0267 0.3537,0.0808 0.101,0.0541 0.1848,0.1314 0.2512,0.2339 0.0671,0.1032 0.1191,0.2274 0.1559,0.3739zM16.6937,16.4351c0,-0.4136 -0.0484,-0.6879 -0.1451,-0.8236 -0.0967,-0.135 -0.2165,-0.2021 -0.3602,-0.2021 -0.1415,0 -0.2541,0.0592 -0.3392,0.1797 -0.1054,0.1523 -0.1581,0.4353 -0.1581,0.846 0,0.4121 0.0469,0.6864 0.1436,0.8221 0.0974,0.1364 0.2158,0.205 0.358,0.205 0.1408,0 0.2591,-0.0686 0.3559,-0.2057 0.0967,-0.1371 0.1436,-0.4107 0.1451,-0.8214zM18.9009,15.8425c0.0383,0.1465 0.0563,0.3436 0.0563,0.5926 0,0.2938 -0.0296,0.532 -0.0902,0.7124 -0.0606,0.1805 -0.1509,0.3198 -0.2714,0.4187 -0.1205,0.1003 -0.2721,0.1487 -0.4547,0.1487 -0.2432,0 -0.4324,-0.0873 -0.5702,-0.2598 -0.1653,-0.2086 -0.2483,-0.5493 -0.2483,-1.0199 0,-0.2959 0.031,-0.5356 0.0917,-0.716 0.0613,-0.1805 0.1516,-0.3198 0.2721,-0.4179 0.1198,-0.0989 0.2714,-0.1472 0.454,-0.1472 0.1343,0 0.2519,0.0267 0.3544,0.0808 0.101,0.0541 0.1855,0.1314 0.2519,0.2339 0.0657,0.1032 0.1177,0.2274 0.1545,0.3739zM18.6411,16.4351c0,-0.4136 -0.0484,-0.6879 -0.1451,-0.8236 -0.0967,-0.135 -0.2165,-0.2021 -0.3602,-0.2021 -0.1415,0 -0.2548,0.0592 -0.3392,0.1797 -0.1061,0.1523 -0.1581,0.4353 -0.1581,0.846 0,0.4121 0.0469,0.6864 0.1436,0.8221 0.0974,0.1364 0.2158,0.205 0.3573,0.205 0.1415,0 0.2598,-0.0686 0.3566,-0.2057 0.0982,-0.1371 0.1458,-0.4107 0.1451,-0.8214zM20.8513,15.8425c0.0368,0.1465 0.0563,0.3436 0.0563,0.5926 0,0.2938 -0.0303,0.532 -0.0909,0.7124 -0.0606,0.1805 -0.1509,0.3198 -0.2714,0.4187 -0.1205,0.1003 -0.2721,0.1487 -0.4555,0.1487 -0.2418,0 -0.4324,-0.0873 -0.5702,-0.2598 -0.1653,-0.2086 -0.2476,-0.5493 -0.2476,-1.0199 0,-0.2959 0.0303,-0.5356 0.0909,-0.716 0.0613,-0.1805 0.1516,-0.3198 0.2721,-0.4179 0.1205,-0.0989 0.2714,-0.1472 0.454,-0.1472 0.1343,0 0.2526,0.0267 0.3544,0.0808 0.101,0.0541 0.1841,0.1314 0.2519,0.2339 0.065,0.1032 0.1169,0.2274 0.1559,0.3739zM20.59,16.4351c0,-0.4136 -0.0484,-0.6879 -0.1444,-0.8236 -0.0967,-0.135 -0.2165,-0.2021 -0.3609,-0.2021 -0.1408,0 -0.2541,0.0592 -0.3385,0.1797 -0.1061,0.1523 -0.1588,0.4353 -0.1588,0.846 0,0.4121 0.0476,0.6864 0.1436,0.8221 0.0967,0.1364 0.2151,0.205 0.3573,0.205 0.1415,0 0.2606,-0.0686 0.3573,-0.2057 0.096,-0.1371 0.1451,-0.4107 0.1444,-0.8214zM21.7817,15.9219c-0.1205,0.0715 -0.2288,0.1242 -0.3248,0.1595v-0.2974c0.1718,-0.0816 0.3234,-0.1797 0.4518,-0.2945 0.1285,-0.1155 0.2194,-0.2274 0.2736,-0.3356h0.1985v2.5184h-0.3082v-1.9626C21.9982,15.7804 21.9008,15.8511 21.7817,15.9219ZM23.8706,15.1546h0.1985v2.5184h-0.3089v-1.9626c-0.0729,0.07 -0.1704,0.1408 -0.2909,0.2115 -0.1205,0.0715 -0.2281,0.1242 -0.3241,0.1595v-0.2974c0.1718,-0.0816 0.3219,-0.1797 0.4518,-0.2945 0.1285,-0.1155 0.2194,-0.2266 0.2736,-0.3349zM26.4359,15.8425c0.0375,0.1465 0.0563,0.3436 0.0563,0.5926 0,0.2938 -0.031,0.532 -0.0917,0.7124 -0.0606,0.1805 -0.1509,0.3198 -0.2721,0.4187 -0.1198,0.1003 -0.2707,0.1487 -0.454,0.1487 -0.2425,0 -0.4331,-0.0873 -0.5709,-0.2598 -0.1646,-0.2086 -0.2476,-0.5493 -0.2476,-1.0199 0,-0.2959 0.031,-0.5356 0.0909,-0.716 0.0606,-0.1805 0.1516,-0.3198 0.2728,-0.4179 0.1191,-0.0989 0.2721,-0.1472 0.454,-0.1472 0.1343,0 0.2519,0.0267 0.3537,0.0808 0.1018,0.0541 0.1848,0.1314 0.2526,0.2339 0.065,0.1032 0.1198,0.2274 0.1559,0.3739zM26.1775,16.4351c0,-0.4136 -0.0491,-0.6879 -0.1451,-0.8236 -0.0967,-0.135 -0.2158,-0.2021 -0.3595,-0.2021 -0.1415,0 -0.2548,0.0592 -0.3392,0.1797 -0.1068,0.1523 -0.1602,0.4353 -0.1602,0.846 0,0.4121 0.0491,0.6864 0.1451,0.8221 0.0967,0.1364 0.2158,0.205 0.3566,0.205 0.1408,0 0.2591,-0.0686 0.3566,-0.2057 0.0974,-0.1371 0.1451,-0.4107 0.1458,-0.8214zM14.3868,19.3591h0.1985v2.5184h-0.3075v-1.9626c-0.0729,0.0707 -0.1704,0.1408 -0.2909,0.2115 -0.1205,0.0715 -0.2288,0.1242 -0.3248,0.1595v-0.2974c0.1725,-0.0816 0.3226,-0.1797 0.4518,-0.2945 0.1285,-0.1155 0.2201,-0.2281 0.2728,-0.3349zM16.9521,20.0485c0.0375,0.1458 0.057,0.3429 0.057,0.5912 0,0.2938 -0.031,0.5327 -0.0917,0.7132 -0.0599,0.1805 -0.1501,0.3198 -0.2707,0.4187 -0.1198,0.0996 -0.2721,0.1487 -0.4547,0.1487 -0.2425,0 -0.4324,-0.0873 -0.5709,-0.2606 -0.1646,-0.2086 -0.2469,-0.5479 -0.2469,-1.0199 0,-0.2952 0.0303,-0.5341 0.0902,-0.7146 0.0613,-0.1805 0.1516,-0.3205 0.2721,-0.4187 0.1205,-0.0982 0.2728,-0.1472 0.4555,-0.1472 0.1335,0 0.2512,0.0274 0.3537,0.0808 0.101,0.0534 0.1848,0.1314 0.2512,0.2339 0.0671,0.1025 0.1191,0.2266 0.1552,0.3746zM16.6937,20.6374c0,-0.4129 -0.0484,-0.6872 -0.1451,-0.8229 -0.0967,-0.1343 -0.2165,-0.2028 -0.3602,-0.2028 -0.1415,0 -0.2541,0.0599 -0.3392,0.1797 -0.1054,0.1538 -0.1581,0.436 -0.1581,0.8467 0,0.4129 0.0469,0.6872 0.1436,0.8229 0.0974,0.1364 0.2158,0.205 0.358,0.205 0.1408,0 0.2591,-0.0693 0.3559,-0.205 0.0967,-0.1371 0.1436,-0.4107 0.1451,-0.8236zM18.483,21.8768 L18.1741,21.8775v-1.9626c-0.0736,0.0707 -0.1711,0.1408 -0.2916,0.2115 -0.1198,0.0715 -0.2274,0.1242 -0.3234,0.1595v-0.2974c0.1718,-0.0816 0.3226,-0.1797 0.4511,-0.2945 0.1292,-0.1155 0.2209,-0.2281 0.2743,-0.3356h0.1985zM19.5715,20.1271c-0.1205,0.0715 -0.2281,0.1242 -0.3241,0.1595v-0.2974c0.1718,-0.0816 0.3226,-0.1797 0.4511,-0.2945 0.1285,-0.1155 0.2209,-0.2281 0.2736,-0.3356h0.1985v2.5184h-0.3075v-1.9626c-0.0736,0.07 -0.1711,0.1415 -0.2916,0.2122zM22.5396,20.0485c0.0383,0.1458 0.057,0.3429 0.057,0.5912 0,0.2938 -0.0303,0.5327 -0.0909,0.7132 -0.0606,0.1805 -0.1501,0.3198 -0.2707,0.4187 -0.1205,0.0996 -0.2728,0.1487 -0.4547,0.1487 -0.2432,0 -0.4331,-0.0873 -0.5709,-0.2606 -0.1653,-0.2086 -0.2476,-0.5479 -0.2476,-1.0199 0,-0.2952 0.0303,-0.5341 0.0909,-0.7146 0.0613,-0.1805 0.1523,-0.3205 0.2728,-0.4187 0.1198,-0.0982 0.2714,-0.1472 0.454,-0.1472 0.1335,0 0.2512,0.0274 0.3537,0.0808 0.101,0.0534 0.1841,0.1314 0.2505,0.2339 0.0664,0.1025 0.1191,0.2266 0.1559,0.3746zM22.279,20.6374c0,-0.4129 -0.0476,-0.6872 -0.1444,-0.8229 -0.096,-0.1343 -0.2165,-0.2028 -0.3602,-0.2028 -0.1408,0 -0.2541,0.0599 -0.3385,0.1797 -0.1061,0.1538 -0.1588,0.436 -0.1588,0.8467 0,0.4129 0.0469,0.6872 0.1436,0.8229 0.0967,0.1364 0.2158,0.205 0.358,0.205 0.1408,0 0.2598,-0.0693 0.3559,-0.205 0.0967,-0.1371 0.1444,-0.4107 0.1444,-0.8236zM23.8706,19.3591h0.1985v2.5184h-0.3089v-1.9626c-0.0729,0.0707 -0.1704,0.1408 -0.2909,0.2115 -0.1205,0.0715 -0.2281,0.1242 -0.3241,0.1595v-0.2974c0.1718,-0.0816 0.3219,-0.1797 0.4518,-0.2945 0.1285,-0.1155 0.2194,-0.2281 0.2736,-0.3349zM26.4352,20.0485c0.0375,0.1458 0.0563,0.3429 0.0563,0.5912 0,0.2938 -0.031,0.5327 -0.0917,0.7132 -0.0606,0.1805 -0.1509,0.3198 -0.2721,0.4187 -0.1198,0.0996 -0.2707,0.1487 -0.454,0.1487 -0.2425,0 -0.4331,-0.0873 -0.5709,-0.2606 -0.1646,-0.2086 -0.2476,-0.5479 -0.2476,-1.0199 0,-0.2952 0.031,-0.5341 0.0909,-0.7146 0.0613,-0.1805 0.1538,-0.3205 0.2736,-0.4187 0.1191,-0.0982 0.2721,-0.1472 0.454,-0.1472 0.1343,0 0.2519,0.0274 0.3537,0.0808 0.1018,0.0534 0.1848,0.1314 0.2526,0.2339 0.065,0.1025 0.1198,0.2266 0.1552,0.3746zM26.1775,20.6374c0,-0.4129 -0.0491,-0.6872 -0.1451,-0.8229 -0.0967,-0.1343 -0.2158,-0.2028 -0.3595,-0.2028 -0.1415,0 -0.2548,0.0599 -0.3392,0.1797 -0.1068,0.1538 -0.1602,0.436 -0.1602,0.8467 0,0.4129 0.0491,0.6872 0.1451,0.8229 0.0967,0.1364 0.2158,0.205 0.3566,0.205 0.1408,0 0.2591,-0.0693 0.3566,-0.205 0.0974,-0.1371 0.1451,-0.4107 0.1458,-0.8236zM27.7662,19.3591h0.1971v2.5184h-0.3075v-1.9626c-0.0729,0.0707 -0.1704,0.1408 -0.2902,0.2115 -0.1213,0.0715 -0.2281,0.1242 -0.3241,0.1595v-0.2974c0.1704,-0.0816 0.3226,-0.1797 0.4518,-0.2945 0.1292,-0.1155 0.2201,-0.2281 0.2728,-0.3349zM14.3868,23.5629h0.1985v2.5177h-0.3075v-1.9619c-0.0729,0.07 -0.1704,0.14 -0.2909,0.2115 -0.1205,0.0715 -0.2288,0.1242 -0.3248,0.1602v-0.2974c0.1725,-0.0816 0.3226,-0.1805 0.4518,-0.2945 0.1285,-0.1155 0.2201,-0.2274 0.2728,-0.3356zM16.9521,24.253c0.0375,0.1451 0.057,0.3429 0.057,0.5919 0,0.2945 -0.031,0.5327 -0.0917,0.7132 -0.0599,0.1805 -0.1501,0.3198 -0.2707,0.4187 -0.1198,0.0989 -0.2721,0.148 -0.4547,0.148 -0.2425,0 -0.4324,-0.0859 -0.5709,-0.2591 -0.1646,-0.2101 -0.2469,-0.5486 -0.2469,-1.0206 0,-0.2967 0.0303,-0.5341 0.0902,-0.716 0.0613,-0.1805 0.1516,-0.3198 0.2721,-0.4172 0.1205,-0.0989 0.2728,-0.1472 0.4555,-0.1472 0.1335,0 0.2512,0.0274 0.3537,0.0801 0.101,0.0541 0.1848,0.1314 0.2512,0.2346 0.0671,0.101 0.1191,0.2252 0.1552,0.3739zM16.6937,24.8442c0,-0.4121 -0.0484,-0.6879 -0.1451,-0.8236 -0.0967,-0.135 -0.2165,-0.2028 -0.3602,-0.2028 -0.1415,0 -0.2541,0.0599 -0.3392,0.1797 -0.1054,0.153 -0.1581,0.4353 -0.1581,0.8467 0,0.4136 0.0469,0.6864 0.1436,0.8221 0.0974,0.1364 0.2158,0.2043 0.358,0.2043 0.1408,0 0.2591,-0.0693 0.3559,-0.2057 0.0967,-0.135 0.1436,-0.4085 0.1451,-0.8207zM18.901,24.253c0.0383,0.1451 0.0563,0.3429 0.0563,0.5919 0,0.2945 -0.0296,0.5313 -0.0902,0.7132 -0.0606,0.1805 -0.1509,0.3198 -0.2714,0.4187 -0.1205,0.0989 -0.2721,0.148 -0.4547,0.148 -0.2432,0 -0.4324,-0.0859 -0.5702,-0.2591 -0.1653,-0.2101 -0.2483,-0.5486 -0.2483,-1.0206 0,-0.2967 0.031,-0.5341 0.0917,-0.716 0.0613,-0.1805 0.1516,-0.3198 0.2721,-0.4172 0.1198,-0.0989 0.2714,-0.1472 0.454,-0.1472 0.1343,0 0.2519,0.0274 0.3544,0.0801 0.101,0.0541 0.1855,0.1314 0.2519,0.2346 0.0657,0.101 0.1177,0.2252 0.1545,0.3739zM18.6411,24.8442c0,-0.4121 -0.0484,-0.6879 -0.1451,-0.8236 -0.0967,-0.135 -0.2165,-0.2028 -0.3602,-0.2028 -0.1415,0 -0.2548,0.0599 -0.3392,0.1797 -0.1061,0.153 -0.1581,0.4353 -0.1581,0.8467 0,0.4136 0.0469,0.6864 0.1436,0.8221 0.0974,0.1364 0.2158,0.2043 0.3573,0.2043 0.1415,0 0.2598,-0.0693 0.3566,-0.2057 0.0982,-0.135 0.1451,-0.4085 0.1451,-0.8207zM20.8513,24.253c0.0368,0.1451 0.0563,0.3429 0.0563,0.5919 0,0.2945 -0.0303,0.5313 -0.0909,0.7132 -0.0606,0.1805 -0.1509,0.3198 -0.2714,0.4187 -0.1205,0.0989 -0.2721,0.148 -0.4555,0.148 -0.2418,0 -0.4324,-0.0859 -0.5702,-0.2591 -0.1653,-0.2101 -0.2476,-0.5486 -0.2476,-1.0206 0,-0.2967 0.0303,-0.5341 0.0909,-0.716 0.0613,-0.1805 0.1516,-0.3198 0.2721,-0.4172 0.1205,-0.0989 0.2714,-0.1472 0.454,-0.1472 0.1343,0 0.2526,0.0274 0.3544,0.0801 0.101,0.0541 0.1841,0.1314 0.2519,0.2346 0.065,0.101 0.1169,0.2252 0.1559,0.3739zM20.59,24.8442c0,-0.4121 -0.0484,-0.6879 -0.1444,-0.8236 -0.0967,-0.135 -0.2165,-0.2028 -0.3609,-0.2028 -0.1408,0 -0.2541,0.0599 -0.3385,0.1797 -0.1061,0.153 -0.1588,0.4353 -0.1588,0.8467 0,0.4136 0.0476,0.6864 0.1436,0.8221 0.0967,0.1364 0.2151,0.2043 0.3573,0.2043 0.1415,0 0.2606,-0.0693 0.3573,-0.2057 0.096,-0.135 0.1451,-0.4085 0.1444,-0.8207zM22.1823,23.5629h0.1985v2.5177h-0.3082v-1.9619c-0.0743,0.07 -0.1718,0.14 -0.2916,0.2115 -0.1205,0.0715 -0.2288,0.1242 -0.3248,0.1602v-0.2974c0.1718,-0.0816 0.3234,-0.1805 0.4518,-0.2945 0.1292,-0.1155 0.2201,-0.2274 0.2743,-0.3356zM23.8706,23.5629h0.1985v2.5177h-0.3089v-1.9619c-0.0729,0.07 -0.1704,0.14 -0.2909,0.2115 -0.1205,0.0715 -0.2281,0.1242 -0.3241,0.1602v-0.2974c0.1718,-0.0816 0.3219,-0.1805 0.4518,-0.2945 0.1285,-0.1155 0.2194,-0.2274 0.2736,-0.3356zM26.4352,24.253c0.0375,0.1451 0.0563,0.3429 0.0563,0.5919 0,0.2945 -0.031,0.5313 -0.0917,0.7132 -0.0606,0.1805 -0.1509,0.3198 -0.2721,0.4187 -0.1198,0.0989 -0.2707,0.148 -0.454,0.148 -0.2425,0 -0.4331,-0.0859 -0.5709,-0.2591 -0.1646,-0.2101 -0.2476,-0.5486 -0.2476,-1.0206 0,-0.2967 0.031,-0.5341 0.0909,-0.716 0.0613,-0.1805 0.1523,-0.3198 0.2736,-0.4172 0.1191,-0.0989 0.2721,-0.1472 0.454,-0.1472 0.1343,0 0.2519,0.0274 0.3537,0.0801 0.1018,0.0541 0.1848,0.1314 0.2526,0.2346 0.065,0.101 0.1198,0.2252 0.1552,0.3739zM26.1775,24.8442c0,-0.4121 -0.0491,-0.6879 -0.1451,-0.8236 -0.0967,-0.135 -0.2158,-0.2028 -0.3595,-0.2028 -0.1415,0 -0.2548,0.0599 -0.3392,0.1797 -0.1068,0.153 -0.1602,0.4353 -0.1602,0.8467 0,0.4136 0.0491,0.6864 0.1451,0.8221 0.0967,0.1364 0.2158,0.2043 0.3566,0.2043 0.1408,0 0.2591,-0.0693 0.3566,-0.2057 0.0974,-0.135 0.1451,-0.4085 0.1458,-0.8207zM20.258,31.4372c-6.3389,0 -11.497,-5.1573 -11.497,-11.497 0,-6.3397 5.1588,-11.497 11.4977,-11.497 6.3382,0 11.4955,5.1573 11.4955,11.497 0,6.3397 -5.1573,11.4963 -11.4963,11.497zM11.9824,17.5878c0.0888,0.101 0.1898,0.1624 0.3118,0.1624 0.1415,0 0.2591,-0.0686 0.3566,-0.205 0.0974,-0.1379 0.1451,-0.4114 0.1451,-0.8221 0,-0.4057 -0.0469,-0.6763 -0.1408,-0.8142 -0.2815,0.5284 -0.5053,1.0914 -0.6727,1.6789zM27.7669,23.851 L27.7666,23.8517h-0.0018v-0.0014h0.0022zM27.7666,23.8517h0.149c0.4201,-0.82 0.7103,-1.7143 0.8474,-2.6591 -0.0072,-0.0844 -0.0137,-0.1704 -0.0137,-0.2649 0,-0.2959 0.0325,-0.5349 0.0917,-0.7153 0.0036,-0.0072 0.0079,-0.0123 0.0108,-0.0202 0.0029,-0.0852 0.0137,-0.1675 0.0137,-0.2519 0,-1.3714 -0.3299,-2.6642 -0.9037,-3.8169v1.549h-0.3082v-1.9626c-0.0729,0.07 -0.1696,0.1408 -0.2894,0.2115 -0.1213,0.0715 -0.2288,0.1242 -0.3248,0.1595L27.0393,15.7833c0.1711,-0.0816 0.3234,-0.1797 0.4518,-0.2945 0.0303,-0.026 0.0498,-0.0505 0.0751,-0.0765 -1.5201,-2.4455 -4.224,-4.0826 -7.3098,-4.0826 -3.1897,0 -5.9737,1.7475 -7.4613,4.3316 0.0325,0.0332 0.0758,0.0534 0.1025,0.0946 0.065,0.1039 0.1177,0.2281 0.1552,0.3746 0.0383,0.1458 0.0563,0.3436 0.0563,0.5919 0,0.2945 -0.0296,0.5327 -0.0902,0.7132 -0.0606,0.1805 -0.1509,0.3198 -0.2721,0.4187 -0.1198,0.0996 -0.2714,0.1487 -0.4547,0.1487 -0.1523,0 -0.2772,-0.0476 -0.3883,-0.1169 -0.1465,0.5955 -0.2324,1.2119 -0.2476,1.8478 0.0505,-0.0895 0.1083,-0.1682 0.1812,-0.2274 0.1198,-0.0982 0.2721,-0.1472 0.454,-0.1472 0.135,0 0.2526,0.0274 0.3544,0.0808 0.101,0.0534 0.1855,0.1314 0.2519,0.2339 0.065,0.1032 0.1177,0.2266 0.1552,0.3739 0.0383,0.1458 0.0563,0.3429 0.0563,0.5912 0,0.2938 -0.0296,0.5327 -0.0902,0.7132 -0.0606,0.1805 -0.1509,0.3198 -0.2721,0.4187 -0.1198,0.0996 -0.2714,0.1487 -0.4547,0.1487 -0.1826,0 -0.327,-0.0657 -0.4504,-0.1653 0.1653,0.7673 0.4345,1.4956 0.7897,2.1726 0.005,0.0029 0.0108,0.0029 0.0152,0.0058 0.101,0.0534 0.1855,0.1314 0.2519,0.2339 0.065,0.1025 0.1177,0.2266 0.1552,0.3739 0.0108,0.0404 0.0159,0.0946 0.0238,0.1422 1.5425,2.3271 4.1836,3.8682 7.1791,3.8682 3.0828,0 5.7853,-1.6335 7.3061,-4.0753 -0.0606,0.0476 -0.1155,0.096 -0.1971,0.1436 -0.1213,0.0707 -0.2281,0.1242 -0.3241,0.1595L27.0415,24.4811c0.1704,-0.0816 0.3226,-0.1797 0.4518,-0.2945 0.1289,-0.1152 0.2198,-0.2269 0.2732,-0.3349zM11.9377,21.461c0.0967,0.1364 0.2151,0.205 0.3566,0.205 0.1415,0 0.2598,-0.0693 0.3566,-0.205 0.0974,-0.1379 0.1451,-0.4121 0.1451,-0.8229 0,-0.4129 -0.0484,-0.6872 -0.1451,-0.8229 -0.0967,-0.1343 -0.2158,-0.2028 -0.3602,-0.2028 -0.1415,0 -0.2555,0.0599 -0.3392,0.1797 -0.1061,0.1538 -0.1581,0.436 -0.1581,0.8467 0,0.4129 0.0476,0.6864 0.1444,0.8221zM27.7146,30.4371 L30.2561,27.8956 39.0881,36.7277 36.5466,39.2691z"
        android:strokeLineJoin="miter"
        android:strokeWidth="0"
        android:fillColor="#ffffff"
        android:fillType="nonZero"
        android:strokeLineCap="butt"/>
  </group>
</vector>

```

`app/src/main/res/drawable/ic_location_dot.xml`:

```xml
<vector android:height="48dp" android:viewportHeight="512"
    android:tint="#FFFFFF"
    android:viewportWidth="384" android:width="36dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M168.3,499.2C116.1,435 0,279.4 0,192C0,85.96 85.96,0 192,0C298,0 384,85.96 384,192C384,279.4 267,435 215.7,499.2C203.4,514.5 180.6,514.5 168.3,499.2H168.3zM192,256C227.3,256 256,227.3 256,192C256,156.7 227.3,128 192,128C156.7,128 128,156.7 128,192C128,227.3 156.7,256 192,256z"/>
</vector>

```

`app/src/main/res/drawable/ic_lock.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:tint="#FFFFFF"
    android:width="24dp"
    android:height="27dp"
    android:viewportWidth="448"
    android:viewportHeight="512">
  <!--
  All brand icons are trademarks of their respective owners.
  -->
  <path
      android:fillColor="@android:color/white"
      android:pathData="M80,192V144C80,64.47 144.5,0 224,0C303.5,0 368,64.47 368,144V192H384C419.3,192 448,220.7 448,256V448C448,483.3 419.3,512 384,512H64C28.65,512 0,483.3 0,448V256C0,220.7 28.65,192 64,192H80zM144,192H304V144C304,99.82 268.2,64 224,64C179.8,64 144,99.82 144,144V192z"/>
</vector>

```

`app/src/main/res/drawable/ic_lock_open.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:tint="#FFFFFF"
    android:width="24dp"
    android:height="21dp"
    android:viewportWidth="576"
    android:viewportHeight="512">
  <!--
  All brand icons are trademarks of their respective owners.
  -->
  <path
      android:fillColor="@android:color/white"
      android:pathData="M352,192H384C419.3,192 448,220.7 448,256V448C448,483.3 419.3,512 384,512H64C28.65,512 0,483.3 0,448V256C0,220.7 28.65,192 64,192H288V144C288,64.47 352.5,0 432,0C511.5,0 576,64.47 576,144V192C576,209.7 561.7,224 544,224C526.3,224 512,209.7 512,192V144C512,99.82 476.2,64 432,64C387.8,64 352,99.82 352,144V192z"/>
</vector>

```

`app/src/main/res/drawable/ic_lock_open_alt.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M12,17c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2zM18,8h-1L17,6c0,-2.76 -2.24,-5 -5,-5S7,3.24 7,6h1.9c0,-1.71 1.39,-3.1 3.1,-3.1 1.71,0 3.1,1.39 3.1,3.1v2L6,8c-1.1,0 -2,0.9 -2,2v10c0,1.1 0.9,2 2,2h12c1.1,0 2,-0.9 2,-2L20,10c0,-1.1 -0.9,-2 -2,-2zM18,20L6,20L6,10h12v10z"/>
</vector>

```

`app/src/main/res/drawable/ic_logo.xml`:

```xml
<vector android:height="56dp" android:viewportHeight="43.105"
    android:viewportWidth="43.105" android:width="56dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/primary_text_dark" android:pathData="M7.762,9.762c-0.179,0.159 -0.387,0.295 -0.626,0.408v0.412c0.133,-0.049 0.283,-0.122 0.45,-0.221c0.167,-0.098 0.302,-0.196 0.403,-0.293v2.719h0.426V9.298H8.14C8.067,9.448 7.94,9.602 7.762,9.762zM11.479,9.733c-0.092,-0.142 -0.208,-0.249 -0.348,-0.324c-0.142,-0.075 -0.305,-0.112 -0.49,-0.112c-0.253,0 -0.464,0.067 -0.631,0.204C9.844,9.637 9.719,9.83 9.634,10.08c-0.083,0.25 -0.125,0.582 -0.125,0.992c0,0.652 0.114,1.124 0.342,1.413c0.192,0.239 0.455,0.36 0.791,0.36c0.253,0 0.464,-0.067 0.63,-0.206c0.167,-0.137 0.292,-0.33 0.375,-0.58c0.084,-0.25 0.127,-0.58 0.127,-0.987c0,-0.345 -0.027,-0.618 -0.079,-0.821C11.644,10.048 11.572,9.876 11.479,9.733zM11.135,12.21c-0.134,0.19 -0.298,0.285 -0.493,0.285c-0.197,0 -0.361,-0.095 -0.496,-0.284c-0.134,-0.188 -0.199,-0.568 -0.199,-1.139c0,-0.569 0.073,-0.961 0.219,-1.172c0.118,-0.167 0.274,-0.249 0.47,-0.249c0.199,0 0.365,0.093 0.499,0.28c0.134,0.188 0.201,0.568 0.201,1.141C11.334,11.641 11.269,12.02 11.135,12.21zM14.18,9.733c-0.092,-0.142 -0.209,-0.249 -0.349,-0.324c-0.142,-0.075 -0.305,-0.112 -0.491,-0.112c-0.253,0 -0.463,0.067 -0.629,0.204c-0.167,0.136 -0.292,0.329 -0.377,0.579c-0.084,0.25 -0.127,0.582 -0.127,0.992c0,0.652 0.115,1.124 0.344,1.413c0.191,0.239 0.453,0.36 0.79,0.36c0.253,0 0.463,-0.067 0.63,-0.206c0.167,-0.137 0.292,-0.33 0.376,-0.58s0.125,-0.58 0.125,-0.987c0,-0.345 -0.025,-0.618 -0.078,-0.821C14.343,10.048 14.271,9.876 14.18,9.733zM13.833,12.21c-0.134,0.19 -0.298,0.285 -0.494,0.285c-0.196,0 -0.36,-0.095 -0.495,-0.284c-0.134,-0.188 -0.199,-0.568 -0.199,-1.139c0,-0.569 0.072,-0.961 0.219,-1.172c0.117,-0.167 0.274,-0.249 0.47,-0.249c0.199,0 0.365,0.093 0.499,0.28c0.134,0.188 0.201,0.568 0.201,1.141C14.035,11.641 13.969,12.02 13.833,12.21zM16.88,9.733c-0.094,-0.142 -0.209,-0.249 -0.349,-0.324c-0.141,-0.075 -0.305,-0.112 -0.491,-0.112c-0.253,0 -0.462,0.067 -0.629,0.204c-0.167,0.136 -0.292,0.329 -0.377,0.579c-0.084,0.25 -0.126,0.582 -0.126,0.992c0,0.652 0.114,1.124 0.343,1.413c0.191,0.239 0.455,0.36 0.79,0.36c0.254,0 0.464,-0.067 0.631,-0.206c0.167,-0.137 0.292,-0.33 0.376,-0.58s0.126,-0.58 0.126,-0.987c0,-0.345 -0.027,-0.618 -0.078,-0.821C17.042,10.048 16.97,9.876 16.88,9.733zM16.534,12.21c-0.134,0.19 -0.299,0.285 -0.495,0.285c-0.197,0 -0.361,-0.095 -0.495,-0.284c-0.133,-0.188 -0.199,-0.568 -0.199,-1.139c0,-0.569 0.073,-0.961 0.22,-1.172c0.117,-0.167 0.274,-0.249 0.469,-0.249c0.2,0 0.366,0.093 0.5,0.28c0.133,0.188 0.2,0.568 0.2,1.141C16.735,11.641 16.667,12.02 16.534,12.21zM18.788,10.067v2.719h0.427V9.297H18.94c-0.075,0.15 -0.201,0.305 -0.379,0.465c-0.178,0.159 -0.388,0.295 -0.626,0.408v0.412c0.133,-0.049 0.283,-0.122 0.45,-0.221C18.55,10.263 18.685,10.165 18.788,10.067zM20.9,9.762c-0.18,0.159 -0.388,0.295 -0.626,0.408v0.412c0.133,-0.049 0.282,-0.122 0.449,-0.221c0.167,-0.098 0.302,-0.196 0.403,-0.293v2.719h0.428V9.298h-0.275C21.204,9.448 21.078,9.602 20.9,9.762zM24.617,9.733c-0.094,-0.142 -0.209,-0.249 -0.35,-0.324s-0.304,-0.112 -0.49,-0.112c-0.252,0 -0.464,0.067 -0.629,0.204C22.98,9.637 22.854,9.83 22.77,10.08c-0.083,0.25 -0.126,0.582 -0.126,0.992c0,0.652 0.115,1.124 0.343,1.413c0.191,0.239 0.455,0.36 0.791,0.36c0.254,0 0.463,-0.067 0.629,-0.206c0.168,-0.137 0.293,-0.33 0.377,-0.58s0.127,-0.58 0.127,-0.987c0,-0.345 -0.026,-0.618 -0.078,-0.821C24.783,10.048 24.707,9.876 24.617,9.733zM24.273,12.21c-0.135,0.19 -0.299,0.285 -0.494,0.285s-0.36,-0.095 -0.494,-0.284c-0.133,-0.188 -0.201,-0.568 -0.201,-1.139c0,-0.569 0.074,-0.961 0.222,-1.172c0.117,-0.167 0.274,-0.249 0.47,-0.249c0.199,0 0.364,0.093 0.498,0.28c0.133,0.188 0.201,0.568 0.201,1.141C24.474,11.641 24.408,12.02 24.273,12.21zM7.762,15.587c-0.179,0.159 -0.387,0.295 -0.626,0.408v0.412c0.133,-0.049 0.283,-0.122 0.45,-0.221c0.167,-0.098 0.302,-0.195 0.403,-0.293v2.719h0.426v-3.489H8.14C8.067,15.271 7.94,15.427 7.762,15.587zM11.479,15.559c-0.092,-0.142 -0.208,-0.25 -0.348,-0.324c-0.142,-0.074 -0.305,-0.112 -0.49,-0.112c-0.253,0 -0.464,0.068 -0.631,0.204s-0.292,0.33 -0.377,0.58c-0.083,0.25 -0.125,0.581 -0.125,0.99c0,0.654 0.114,1.124 0.342,1.413c0.192,0.24 0.455,0.361 0.791,0.361c0.253,0 0.464,-0.068 0.63,-0.206c0.167,-0.137 0.292,-0.33 0.375,-0.58c0.084,-0.25 0.127,-0.581 0.127,-0.988c0,-0.344 -0.027,-0.617 -0.079,-0.819C11.644,15.873 11.572,15.701 11.479,15.559zM11.135,18.035c-0.134,0.188 -0.298,0.284 -0.493,0.284c-0.197,0 -0.361,-0.095 -0.496,-0.284c-0.134,-0.188 -0.199,-0.568 -0.199,-1.14c0,-0.569 0.073,-0.96 0.219,-1.173c0.118,-0.166 0.274,-0.249 0.47,-0.249c0.199,0 0.365,0.095 0.499,0.281c0.134,0.188 0.201,0.568 0.201,1.14C11.334,17.466 11.269,17.845 11.135,18.035zM13.815,18.611v-3.489H13.54c-0.074,0.149 -0.201,0.305 -0.38,0.465c-0.178,0.159 -0.387,0.295 -0.625,0.408v0.412c0.133,-0.049 0.282,-0.122 0.448,-0.221c0.167,-0.098 0.302,-0.195 0.404,-0.293v2.719L13.815,18.611L13.815,18.611zM15.727,15.893v2.719h0.426v-3.489h-0.275c-0.073,0.149 -0.201,0.305 -0.379,0.465c-0.178,0.159 -0.387,0.295 -0.625,0.408v0.412c0.133,-0.049 0.282,-0.122 0.449,-0.221C15.49,16.089 15.625,15.99 15.727,15.893zM19.219,15.559c-0.092,-0.142 -0.207,-0.25 -0.347,-0.324c-0.142,-0.074 -0.305,-0.112 -0.49,-0.112c-0.253,0 -0.463,0.068 -0.629,0.204c-0.167,0.136 -0.293,0.33 -0.378,0.58c-0.084,0.25 -0.126,0.581 -0.126,0.99c0,0.654 0.114,1.124 0.343,1.413c0.191,0.24 0.454,0.361 0.791,0.361c0.252,0 0.463,-0.068 0.63,-0.206c0.167,-0.137 0.291,-0.33 0.375,-0.58s0.126,-0.581 0.126,-0.988c0,-0.344 -0.026,-0.617 -0.079,-0.819C19.384,15.873 19.311,15.701 19.219,15.559zM18.874,18.035c-0.133,0.188 -0.298,0.284 -0.493,0.284c-0.197,0 -0.362,-0.095 -0.496,-0.284c-0.134,-0.188 -0.199,-0.568 -0.199,-1.14c0,-0.569 0.073,-0.96 0.22,-1.173c0.117,-0.166 0.274,-0.249 0.469,-0.249c0.199,0 0.366,0.095 0.499,0.281c0.134,0.188 0.2,0.568 0.2,1.14S19.008,17.845 18.874,18.035zM20.9,15.587c-0.18,0.159 -0.388,0.295 -0.626,0.408v0.412c0.133,-0.049 0.282,-0.122 0.449,-0.221c0.167,-0.098 0.302,-0.195 0.403,-0.293v2.719h0.428v-3.489h-0.275C21.204,15.271 21.078,15.427 20.9,15.587zM24.617,15.559c-0.094,-0.142 -0.209,-0.25 -0.35,-0.324s-0.304,-0.112 -0.49,-0.112c-0.252,0 -0.464,0.068 -0.629,0.204c-0.166,0.136 -0.294,0.33 -0.379,0.58c-0.083,0.25 -0.126,0.581 -0.126,0.99c0,0.654 0.115,1.124 0.343,1.413c0.191,0.24 0.455,0.361 0.791,0.361c0.254,0 0.463,-0.068 0.629,-0.206c0.168,-0.137 0.293,-0.33 0.377,-0.58s0.127,-0.581 0.127,-0.988c0,-0.344 -0.026,-0.617 -0.078,-0.819C24.783,15.873 24.707,15.701 24.617,15.559zM24.273,18.035c-0.135,0.188 -0.299,0.284 -0.494,0.284s-0.36,-0.095 -0.494,-0.284c-0.133,-0.188 -0.201,-0.568 -0.201,-1.14c0,-0.569 0.074,-0.96 0.222,-1.173c0.117,-0.166 0.274,-0.249 0.47,-0.249c0.199,0 0.364,0.095 0.498,0.281c0.133,0.188 0.201,0.568 0.201,1.14C24.474,17.466 24.408,17.845 24.273,18.035zM26.298,15.587c-0.179,0.159 -0.39,0.295 -0.626,0.408v0.412c0.133,-0.049 0.281,-0.122 0.449,-0.221c0.166,-0.098 0.301,-0.195 0.402,-0.293v2.719h0.426v-3.489h-0.273C26.603,15.271 26.477,15.427 26.298,15.587zM7.762,21.412c-0.179,0.158 -0.387,0.295 -0.626,0.408v0.412c0.133,-0.05 0.283,-0.123 0.45,-0.222s0.302,-0.196 0.403,-0.293v2.718h0.426v-3.488H8.14C8.067,21.097 7.94,21.252 7.762,21.412zM11.479,21.385c-0.092,-0.143 -0.208,-0.25 -0.348,-0.325c-0.142,-0.073 -0.305,-0.111 -0.49,-0.111c-0.253,0 -0.464,0.067 -0.631,0.204c-0.167,0.135 -0.292,0.328 -0.377,0.578c-0.083,0.252 -0.125,0.581 -0.125,0.992c0,0.654 0.114,1.123 0.342,1.414c0.192,0.24 0.455,0.359 0.791,0.359c0.253,0 0.464,-0.068 0.63,-0.205c0.167,-0.137 0.292,-0.33 0.375,-0.58c0.084,-0.25 0.127,-0.58 0.127,-0.988c0,-0.345 -0.027,-0.619 -0.079,-0.82C11.644,21.697 11.572,21.525 11.479,21.385zM11.135,23.859c-0.134,0.189 -0.298,0.285 -0.493,0.285c-0.197,0 -0.361,-0.094 -0.496,-0.283c-0.134,-0.188 -0.199,-0.566 -0.199,-1.139c0,-0.57 0.073,-0.961 0.219,-1.173c0.118,-0.166 0.274,-0.249 0.47,-0.249c0.199,0 0.365,0.094 0.499,0.281c0.134,0.188 0.201,0.57 0.201,1.141C11.334,23.293 11.269,23.672 11.135,23.859zM14.18,21.385c-0.092,-0.143 -0.209,-0.25 -0.349,-0.325c-0.142,-0.073 -0.305,-0.111 -0.491,-0.111c-0.253,0 -0.463,0.067 -0.629,0.204c-0.167,0.135 -0.292,0.328 -0.377,0.578c-0.084,0.252 -0.127,0.581 -0.127,0.992c0,0.654 0.115,1.123 0.344,1.414c0.191,0.24 0.453,0.359 0.79,0.359c0.253,0 0.463,-0.068 0.63,-0.205s0.292,-0.33 0.376,-0.58c0.084,-0.252 0.125,-0.58 0.125,-0.988c0,-0.345 -0.025,-0.619 -0.078,-0.82C14.343,21.697 14.271,21.525 14.18,21.385zM13.833,23.859c-0.134,0.189 -0.298,0.285 -0.494,0.285c-0.196,0 -0.36,-0.094 -0.495,-0.283c-0.134,-0.188 -0.199,-0.566 -0.199,-1.139c0,-0.57 0.072,-0.961 0.219,-1.173c0.117,-0.166 0.274,-0.249 0.47,-0.249c0.199,0 0.365,0.094 0.499,0.281c0.134,0.188 0.201,0.57 0.201,1.141S13.969,23.672 13.833,23.859zM16.88,21.385c-0.094,-0.143 -0.209,-0.25 -0.349,-0.325c-0.141,-0.073 -0.305,-0.111 -0.491,-0.111c-0.253,0 -0.462,0.067 -0.629,0.204c-0.167,0.135 -0.292,0.328 -0.377,0.578c-0.084,0.252 -0.126,0.581 -0.126,0.992c0,0.654 0.114,1.123 0.343,1.414c0.191,0.24 0.455,0.359 0.79,0.359c0.254,0 0.464,-0.068 0.631,-0.205s0.292,-0.33 0.376,-0.58c0.084,-0.252 0.126,-0.58 0.126,-0.988c0,-0.345 -0.027,-0.619 -0.078,-0.82C17.042,21.697 16.97,21.525 16.88,21.385zM16.534,23.859c-0.134,0.189 -0.299,0.285 -0.495,0.285c-0.197,0 -0.361,-0.094 -0.495,-0.283c-0.133,-0.188 -0.199,-0.566 -0.199,-1.139c0,-0.57 0.073,-0.961 0.22,-1.173c0.117,-0.166 0.274,-0.249 0.469,-0.249c0.2,0 0.366,0.094 0.5,0.281c0.133,0.188 0.2,0.57 0.2,1.141C16.735,23.293 16.667,23.672 16.534,23.859zM18.56,21.412c-0.178,0.158 -0.388,0.295 -0.626,0.408v0.412c0.133,-0.05 0.283,-0.123 0.45,-0.222c0.166,-0.099 0.301,-0.196 0.404,-0.293v2.718h0.427v-3.488H18.94C18.865,21.097 18.739,21.252 18.56,21.412zM20.9,21.412c-0.18,0.158 -0.388,0.295 -0.626,0.408v0.412c0.133,-0.05 0.282,-0.123 0.449,-0.222s0.302,-0.196 0.403,-0.293v2.718h0.428v-3.488h-0.275C21.204,21.097 21.078,21.252 20.9,21.412zM24.617,21.385c-0.094,-0.143 -0.209,-0.25 -0.35,-0.325c-0.141,-0.073 -0.304,-0.111 -0.49,-0.111c-0.252,0 -0.464,0.067 -0.629,0.204c-0.168,0.135 -0.294,0.328 -0.379,0.578c-0.083,0.252 -0.126,0.581 -0.126,0.992c0,0.654 0.115,1.123 0.343,1.414c0.191,0.24 0.455,0.359 0.791,0.359c0.254,0 0.463,-0.068 0.629,-0.205c0.168,-0.137 0.293,-0.33 0.377,-0.58c0.084,-0.252 0.127,-0.58 0.127,-0.988c0,-0.345 -0.026,-0.619 -0.078,-0.82C24.783,21.697 24.707,21.525 24.617,21.385zM24.273,23.859c-0.135,0.189 -0.299,0.285 -0.494,0.285s-0.36,-0.094 -0.494,-0.283c-0.133,-0.188 -0.201,-0.566 -0.201,-1.139c0,-0.57 0.074,-0.961 0.222,-1.173c0.117,-0.166 0.274,-0.249 0.47,-0.249c0.199,0 0.364,0.094 0.498,0.281c0.133,0.188 0.201,0.57 0.201,1.141C24.474,23.293 24.408,23.672 24.273,23.859zM32.201,15.928C32.201,7.145 25.056,0 16.275,0C7.493,0 0.346,7.145 0.346,15.928s7.146,15.928 15.928,15.928C25.056,31.855 32.201,24.711 32.201,15.928zM5.741,10.343c0.13,0.191 0.195,0.566 0.195,1.128c0,0.569 -0.066,0.948 -0.201,1.139c-0.135,0.189 -0.298,0.284 -0.494,0.284c-0.169,0 -0.309,-0.085 -0.432,-0.225C5.041,11.855 5.351,11.075 5.741,10.343zM26.677,21.346c-0.074,0.15 -0.2,0.305 -0.379,0.465c-0.179,0.159 -0.39,0.295 -0.626,0.408v0.412c0.133,-0.049 0.281,-0.123 0.449,-0.221c0.113,-0.066 0.189,-0.133 0.273,-0.199c-2.107,3.383 -5.851,5.646 -10.122,5.646c-4.15,0 -7.809,-2.135 -9.946,-5.359c-0.011,-0.066 -0.018,-0.141 -0.033,-0.197c-0.052,-0.204 -0.125,-0.376 -0.215,-0.518c-0.092,-0.142 -0.209,-0.25 -0.349,-0.324c-0.006,-0.004 -0.014,-0.004 -0.021,-0.008c-0.492,-0.938 -0.865,-1.947 -1.094,-3.01c0.171,0.138 0.371,0.229 0.624,0.229c0.254,0 0.464,-0.068 0.63,-0.206c0.168,-0.137 0.293,-0.33 0.377,-0.58s0.125,-0.581 0.125,-0.988c0,-0.344 -0.025,-0.617 -0.078,-0.819c-0.052,-0.204 -0.125,-0.375 -0.215,-0.518c-0.092,-0.142 -0.209,-0.25 -0.349,-0.324c-0.141,-0.074 -0.304,-0.112 -0.491,-0.112c-0.252,0 -0.463,0.068 -0.629,0.204c-0.101,0.082 -0.181,0.191 -0.251,0.315c0.021,-0.881 0.14,-1.735 0.343,-2.56c0.154,0.096 0.327,0.162 0.538,0.162c0.254,0 0.464,-0.068 0.63,-0.206c0.168,-0.137 0.293,-0.33 0.377,-0.58s0.125,-0.58 0.125,-0.988c0,-0.344 -0.025,-0.618 -0.078,-0.82c-0.052,-0.203 -0.125,-0.375 -0.215,-0.519C6.04,10.074 5.98,10.046 5.935,10c2.061,-3.58 5.918,-6.001 10.337,-6.001c4.275,0 8.021,2.268 10.127,5.656c-0.035,0.036 -0.062,0.07 -0.104,0.106c-0.178,0.159 -0.389,0.295 -0.626,0.408v0.412c0.133,-0.049 0.282,-0.122 0.45,-0.221c0.166,-0.098 0.3,-0.196 0.401,-0.293v2.719h0.427v-2.146c0.795,1.597 1.252,3.388 1.252,5.288c0,0.117 -0.015,0.231 -0.019,0.349c-0.004,0.011 -0.01,0.018 -0.015,0.028c-0.082,0.25 -0.127,0.581 -0.127,0.991c0,0.131 0.009,0.25 0.019,0.367c-0.19,1.309 -0.592,2.548 -1.174,3.684h-0.209v-0.002H26.677zM4.547,16.896c0,-0.569 0.072,-0.96 0.219,-1.173c0.116,-0.166 0.274,-0.249 0.47,-0.249c0.2,0 0.365,0.095 0.499,0.281c0.134,0.188 0.201,0.568 0.201,1.14c0,0.569 -0.066,0.949 -0.201,1.14c-0.134,0.188 -0.298,0.284 -0.494,0.284s-0.36,-0.095 -0.494,-0.284C4.613,17.847 4.547,17.468 4.547,16.896zM27.003,30.869l3.521,-3.521L42.76,39.584l-3.521,3.521L27.003,30.869z"/>
</vector>

```

`app/src/main/res/drawable/ic_media_stop.xml`:

```xml
<vector android:height="32dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="32dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M6,6h12v12H6z"/>
</vector>

```

`app/src/main/res/drawable/ic_money.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M11.8,10.9c-2.27,-0.59 -3,-1.2 -3,-2.15 0,-1.09 1.01,-1.85 2.7,-1.85 1.78,0 2.44,0.85 2.5,2.1h2.21c-0.07,-1.72 -1.12,-3.3 -3.21,-3.81V3h-3v2.16c-1.94,0.42 -3.5,1.68 -3.5,3.61 0,2.31 1.91,3.46 4.7,4.13 2.5,0.6 3,1.48 3,2.41 0,0.69 -0.49,1.79 -2.7,1.79 -2.06,0 -2.87,-0.92 -2.98,-2.1h-2.2c0.12,2.19 1.76,3.42 3.68,3.83V21h3v-2.15c1.95,-0.37 3.5,-1.5 3.5,-3.55 0,-2.84 -2.43,-3.81 -4.7,-4.4z"/>
</vector>

```

`app/src/main/res/drawable/ic_navigate_before.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M15.41,7.41L14,6l-6,6 6,6 1.41,-1.41L10.83,12z"/>
</vector>

```

`app/src/main/res/drawable/ic_navigate_next.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M10,6L8.59,7.41 13.17,12l-4.58,4.59L10,18l6,-6z"/>
</vector>

```

`app/src/main/res/drawable/ic_play_arrow.xml`:

```xml
<vector android:height="32dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="32dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M8,5v14l11,-7z"/>
</vector>

```

`app/src/main/res/drawable/ic_refresh.xml`:

```xml
<vector android:height="24dp"
    android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M17.65,6.35C16.2,4.9 14.21,4 12,4c-4.42,0 -7.99,3.58 -7.99,8s3.57,8 7.99,8c3.73,0 6.84,-2.55 7.73,-6h-2.08c-0.82,2.33 -3.04,4 -5.65,4 -3.31,0 -6,-2.69 -6,-6s2.69,-6 6,-6c1.66,0 3.14,0.69 4.22,1.78L13,11h7V4l-2.35,2.35z"/>
</vector>

```

`app/src/main/res/drawable/ic_reset.xml`:

```xml
<vector android:autoMirrored="true" android:height="24dp"
    android:tint="?attr/colorControlNormal" android:viewportHeight="24"
    android:viewportWidth="24" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M12.5,8c-2.65,0 -5.05,0.99 -6.9,2.6L2,7v9h9l-3.62,-3.62c1.39,-1.16 3.16,-1.88 5.12,-1.88 3.54,0 6.55,2.31 7.6,5.5l2.37,-0.78C21.08,11.03 17.15,8 12.5,8z"/>
</vector>

```

`app/src/main/res/drawable/ic_save.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M17,3L5,3c-1.11,0 -2,0.9 -2,2v14c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2L21,7l-4,-4zM12,19c-1.66,0 -3,-1.34 -3,-3s1.34,-3 3,-3 3,1.34 3,3 -1.34,3 -3,3zM15,9L5,9L5,5h10v4z"/>
</vector>

```

`app/src/main/res/drawable/ic_save_alt_small.xml`:

```xml
<vector android:height="18dp" android:tint="#000000"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="18dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M19,12v7L5,19v-7L3,12v7c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2v-7h-2zM13,12.67l2.59,-2.58L17,11.5l-5,5 -5,-5 1.41,-1.41L11,12.67L11,3h2z"/>
</vector>

```

`app/src/main/res/drawable/ic_search.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M15.5,14h-0.79l-0.28,-0.27C15.41,12.59 16,11.11 16,9.5 16,5.91 13.09,3 9.5,3S3,5.91 3,9.5 5.91,16 9.5,16c1.61,0 3.09,-0.59 4.23,-1.57l0.27,0.28v0.79l5,4.99L20.49,19l-4.99,-5zM9.5,14C7.01,14 5,11.99 5,9.5S7.01,5 9.5,5 14,7.01 14,9.5 11.99,14 9.5,14z"/>
</vector>

```

`app/src/main/res/drawable/ic_select_all.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M3,5h2L5,3c-1.1,0 -2,0.9 -2,2zM3,13h2v-2L3,11v2zM7,21h2v-2L7,19v2zM3,9h2L5,7L3,7v2zM13,3h-2v2h2L13,3zM19,3v2h2c0,-1.1 -0.9,-2 -2,-2zM5,21v-2L3,19c0,1.1 0.9,2 2,2zM3,17h2v-2L3,15v2zM9,3L7,3v2h2L9,3zM11,21h2v-2h-2v2zM19,13h2v-2h-2v2zM19,21c1.1,0 2,-0.9 2,-2h-2v2zM19,9h2L21,7h-2v2zM19,17h2v-2h-2v2zM15,21h2v-2h-2v2zM15,5h2L17,3h-2v2zM7,17h10L17,7L7,7v10zM9,9h6v6L9,15L9,9z"/>
</vector>

```

`app/src/main/res/drawable/ic_settings.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M19.14,12.94c0.04,-0.3 0.06,-0.61 0.06,-0.94c0,-0.32 -0.02,-0.64 -0.07,-0.94l2.03,-1.58c0.18,-0.14 0.23,-0.41 0.12,-0.61l-1.92,-3.32c-0.12,-0.22 -0.37,-0.29 -0.59,-0.22l-2.39,0.96c-0.5,-0.38 -1.03,-0.7 -1.62,-0.94L14.4,2.81c-0.04,-0.24 -0.24,-0.41 -0.48,-0.41h-3.84c-0.24,0 -0.43,0.17 -0.47,0.41L9.25,5.35C8.66,5.59 8.12,5.92 7.63,6.29L5.24,5.33c-0.22,-0.08 -0.47,0 -0.59,0.22L2.74,8.87C2.62,9.08 2.66,9.34 2.86,9.48l2.03,1.58C4.84,11.36 4.8,11.69 4.8,12s0.02,0.64 0.07,0.94l-2.03,1.58c-0.18,0.14 -0.23,0.41 -0.12,0.61l1.92,3.32c0.12,0.22 0.37,0.29 0.59,0.22l2.39,-0.96c0.5,0.38 1.03,0.7 1.62,0.94l0.36,2.54c0.05,0.24 0.24,0.41 0.48,0.41h3.84c0.24,0 0.44,-0.17 0.47,-0.41l0.36,-2.54c0.59,-0.24 1.13,-0.56 1.62,-0.94l2.39,0.96c0.22,0.08 0.47,0 0.59,-0.22l1.92,-3.32c0.12,-0.22 0.07,-0.47 -0.12,-0.61L19.14,12.94zM12,15.6c-1.98,0 -3.6,-1.62 -3.6,-3.6s1.62,-3.6 3.6,-3.6s3.6,1.62 3.6,3.6S13.98,15.6 12,15.6z" />
</vector>

```

`app/src/main/res/drawable/ic_share.xml`:

```xml
<vector android:height="24dp" android:tint="?attr/colorControlNormal"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M18,16.08c-0.76,0 -1.44,0.3 -1.96,0.77L8.91,12.7c0.05,-0.23 0.09,-0.46 0.09,-0.7s-0.04,-0.47 -0.09,-0.7l7.05,-4.11c0.54,0.5 1.25,0.81 2.04,0.81 1.66,0 3,-1.34 3,-3s-1.34,-3 -3,-3 -3,1.34 -3,3c0,0.24 0.04,0.47 0.09,0.7L8.04,9.81C7.5,9.31 6.79,9 6,9c-1.66,0 -3,1.34 -3,3s1.34,3 3,3c0.79,0 1.5,-0.31 2.04,-0.81l7.12,4.16c-0.05,0.21 -0.08,0.43 -0.08,0.65 0,1.61 1.31,2.92 2.92,2.92 1.61,0 2.92,-1.31 2.92,-2.92s-1.31,-2.92 -2.92,-2.92z"/>
</vector>

```

`app/src/main/res/drawable/ic_shield.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
    Android drawable generated by fa5ad-free project:
    https://github.com/diwanoczko/fa5ad-free
    Resource generated base on Font Awesome 5 Free icons set:
    https://fontawesome.com/
-->
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorControlNormal"
    android:viewportWidth="512"
    android:viewportHeight="512">
    <path
        android:fillColor="#FFFFFFFF"
        android:pathData="M496 128c0 221.282-135.934 344.645-221.539 380.308a48 48 0 0 1-36.923 0C130.495 463.713 16 326.487 16 128a48 48 0 0 1 29.539-44.308l192-80a48 48 0 0 1 36.923 0l192 80A48 48 0 0 1 496 128zM256 446.313l0.066 0.034c93.735-46.689 172.497-156.308 175.817-307.729L256 65.333v380.98z"
        />
</vector>
```

`app/src/main/res/drawable/ic_shopping_cart.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M7,18c-1.1,0 -1.99,0.9 -1.99,2S5.9,22 7,22s2,-0.9 2,-2 -0.9,-2 -2,-2zM1,2v2h2l3.6,7.59 -1.35,2.45c-0.16,0.28 -0.25,0.61 -0.25,0.96 0,1.1 0.9,2 2,2h12v-2L7.42,15c-0.14,0 -0.25,-0.11 -0.25,-0.25l0.03,-0.12 0.9,-1.63h7.45c0.75,0 1.41,-0.41 1.75,-1.03l3.58,-6.49c0.08,-0.14 0.12,-0.31 0.12,-0.48 0,-0.55 -0.45,-1 -1,-1L5.21,4l-0.94,-2L1,2zM17,18c-1.1,0 -1.99,0.9 -1.99,2s0.89,2 1.99,2 2,-0.9 2,-2 -0.9,-2 -2,-2z"/>
</vector>

```

`app/src/main/res/drawable/ic_short_text.xml`:

```xml
<vector android:autoMirrored="true" android:height="24dp"
    android:tint="?attr/colorControlNormal" android:viewportHeight="24"
    android:viewportWidth="24" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M4,9h16v2H4V9zM4,13h10v2H4V13z"/>
</vector>

```

`app/src/main/res/drawable/ic_skull.xml`:

```xml
<vector android:height="20dp" android:tint="#FFFFFF"
    android:viewportHeight="512" android:viewportWidth="512"
    android:width="20dp" xmlns:android="http://schemas.android.com/apk/res/android">
<!--
All brand icons are trademarks of their respective owners.
-->
    <path android:fillColor="@android:color/white" android:pathData="M256,0C114.6,0 0,100.3 0,224c0,70.1 36.9,132.6 94.5,173.7 9.6,6.9 15.2,18.1 13.5,29.9l-9.4,66.2c-1.4,9.6 6,18.2 15.7,18.2L192,512v-56c0,-4.4 3.6,-8 8,-8h16c4.4,0 8,3.6 8,8v56h64v-56c0,-4.4 3.6,-8 8,-8h16c4.4,0 8,3.6 8,8v56h77.7c9.7,0 17.1,-8.6 15.7,-18.2l-9.4,-66.2c-1.7,-11.7 3.8,-23 13.5,-29.9C475.1,356.6 512,294.1 512,224 512,100.3 397.4,0 256,0zM160,320c-35.3,0 -64,-28.7 -64,-64s28.7,-64 64,-64 64,28.7 64,64 -28.7,64 -64,64zM352,320c-35.3,0 -64,-28.7 -64,-64s28.7,-64 64,-64 64,28.7 64,64 -28.7,64 -64,64z"/>
</vector>

```

`app/src/main/res/drawable/ic_sort.xml`:

```xml
<vector android:autoMirrored="true" android:height="24dp"
    android:tint="?attr/colorControlNormal" android:viewportHeight="24"
    android:viewportWidth="24" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M3,18h6v-2L3,16v2zM3,6v2h18L21,6L3,6zM3,13h12v-2L3,11v2z"/>
</vector>

```

`app/src/main/res/drawable/ic_stacked_bar_chart.xml`:

```xml
<vector android:height="24dp" android:tint="#FFFFFF"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M6,10h3v10L6,20zM6,5h3v4L6,9zM16,16h3v4h-3zM16,13h3v2h-3zM11,13h3v7h-3zM11,9h3v3h-3z"/>
</vector>

```

`app/src/main/res/drawable/ic_swap_horiz.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="28dp" android:width="28dp"
    android:viewportHeight="24" android:viewportWidth="24">
    <path android:fillColor="#FFFFFF" android:pathData="M6.99,10L3,14l3.99,4v-3H14v-2H6.99v-3zM21,8l-3.99,-4v3H10v2h7.01v3L21,8z"/>
</vector>

```

`app/src/main/res/drawable/ic_telegram.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
All brand icons are trademarks of their respective owners.
-->
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="512"
    android:viewportHeight="512">

    <path
        android:fillColor="@android:color/white"
        android:pathData="M429 90L76 227c-25 9-24 23-5 28l88 28 34 104c4 11 2 15 13 15 9 0 13-4 19-9l44-43
91 68c18 10 29 4 34-16l60-284c6-24-9-35-25-28zM173 277l198-126c11-6 20-3 12
4L212 308l-6 72z" />
</vector>

```

`app/src/main/res/drawable/ic_text_snippet.xml`:

```xml
<vector android:autoMirrored="true" android:height="24dp"
    android:tint="#FFFFFF" android:viewportHeight="24"
    android:viewportWidth="24" android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M20.41,8.41l-4.83,-4.83C15.21,3.21 14.7,3 14.17,3H5C3.9,3 3,3.9 3,5v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2V9.83C21,9.3 20.79,8.79 20.41,8.41zM7,7h7v2H7V7zM17,17H7v-2h10V17zM17,13H7v-2h10V13z"/>
</vector>

```

`app/src/main/res/drawable/reply.xml`:

```xml
<vector android:autoMirrored="true" android:height="20dp"
    android:tint="#000000" android:viewportHeight="20"
    android:viewportWidth="20" android:width="20dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M10,9V5l-7,7 7,7v-4.1c5,0 8.5,1.6 11,5.1 -1,-5 -4,-10 -11,-11z"/>
</vector>

```

`app/src/main/res/drawable/rounded_bg.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="ring"
    android:innerRadiusRatio="2.1"
    android:thickness="2dp"
    android:useLevel="false" >

    <gradient
        android:angle="360"
        android:startColor="#7E4382"
        android:endColor="#f800f0"
        android:type="linear" />
</shape>
```

`app/src/main/res/drawable/splash_screen.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:opacity="opaque">

  <item android:drawable="@color/colorPrimaryDark" />

  <item
      android:drawable="@drawable/ic_logo"
      android:gravity="center"
      tools:targetApi="m" />
</layer-list>
```

`app/src/main/res/drawable/tab_switch_button_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ripple xmlns:android="http://schemas.android.com/apk/res/android"
    android:color="?attr/colorControlHighlight">
    <item android:id="@android:id/mask">
        <shape android:shape="oval">
            <solid android:color="@android:color/white" />
        </shape>
    </item>
</ripple>

```

`app/src/main/res/layout/about_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <ScrollView
        android:id="@+id/scrollView"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="15dp">

            <ImageView
                android:id="@+id/logo"
                android:layout_width="90dp"
                android:layout_height="wrap_content"
                android:layout_alignParentTop="true"
                android:layout_centerHorizontal="true"
                android:layout_marginTop="30dp"
                android:src="@mipmap/ic_launcher"
                android:adjustViewBounds="true" />

            <TextView
                android:id="@+id/app_version"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_below="@id/logo"
                android:layout_centerHorizontal="true"
                android:layout_marginTop="20dp"
                android:textSize="20sp"
                android:textStyle="bold"
                tools:text="PCAPdroid vx.y.z"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:layout_below="@id/app_version"
                android:layout_alignParentStart="true">

                <TextView
                    android:id="@+id/app_description"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="50dp"
                    android:text="@string/about_text" />

                <TextView
                    android:id="@+id/app_copyright"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:autoLink="email"
                    android:text="Copyright (C) 2020-26 - Emanuele Faranda black.silver@hotmail.it" />

                <TextView
                    android:id="@+id/app_license"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:text="@string/app_license"/>

                <TextView
                    android:id="@+id/app_source_link"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:text="@string/source_code"/>

                <TextView
                    android:id="@+id/opensource_licenses"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:text="@string/opensource_licenses"/>

                <TextView
                    android:id="@+id/wireshark_licenses"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/wireshark_licenses"/>
            </LinearLayout>
        </RelativeLayout>
    </ScrollView>
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/active_filter_chip.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.chip.Chip xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    style="@style/Widget.MaterialComponents.Chip.Entry"
    android:textSize="12sp"
    app:chipMinTouchTargetSize="24dp"
    android:checkable="true"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    tools:text="a filter" />
```

`app/src/main/res/layout/activity_stats.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <ScrollView
        android:fitsSystemWindows="true"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:padding="8dp"
        android:layout_height="wrap_content">
    <TableLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/table">

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/bytes_sent" />
            <TextView
                android:id="@+id/bytes_sent"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/bytes_rcvd" />
            <TextView
                android:id="@+id/bytes_rcvd"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:id="@+id/ipv6_bytes_sent_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/ipv6_bytes_sent" />
            <TextView
                android:id="@+id/ipv6_bytes_sent"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:id="@+id/ipv6_bytes_rcvd_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/ipv6_bytes_rcvd" />
            <TextView
                android:id="@+id/ipv6_bytes_rcvd"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:id="@+id/ipv6_bytes_percentage_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/ipv6_bytes_percentage" />
            <TextView
                android:id="@+id/ipv6_bytes_percentage"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/packets_sent" />
            <TextView
                android:id="@+id/packets_sent"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/packets_rcvd" />
            <TextView
                android:id="@+id/packets_rcvd"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:id="@+id/row_pkts_dropped"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/packets_dropped" />
            <TextView
                android:id="@+id/pkts_dropped"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp"
            android:layout_marginTop="20dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/active_connections" />
            <TextView
                android:id="@+id/active_connections"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:id="@+id/row_dropped_connections"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/dropped_connections" />
            <TextView
                android:id="@+id/dropped_connections"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/tot_connections" />
            <TextView
                android:id="@+id/tot_connections"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp"
            android:id="@+id/dns_server_row">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/dns_server" />
            <TextView
                android:id="@+id/dns_server"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp"
            android:id="@+id/dns_queries_row">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/dns_queries" />
            <TextView
                android:id="@+id/dns_queries"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginTop="20dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/heap_usage" />
            <TextView
                android:id="@+id/heap_usage"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/memory_usage" />
            <TextView
                android:id="@+id/mem_usage"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/low_memory" />
            <TextView
                android:id="@+id/low_mem_detected"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp"
            android:id="@+id/open_sockets_row">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textStyle="bold"
                android:text="@string/open_sockets" />
            <TextView
                android:id="@+id/open_sockets"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.50"
                android:textIsSelectable="true" />
        </TableRow>
    </TableLayout>

    <TextView
        android:id="@+id/alloc_stats"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="20dp"
        android:visibility="gone"
        tools:visibility="visible"
        tools:text="Alloc Stats..."/>
    </LinearLayout>

    </ScrollView>
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/add_port_mapping_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:padding="8dp"
    android:paddingTop="12dp"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/Theme.TextInputLayoutOutlined"
            style="@style/TextInputLayoutOutlinedDropdown">

            <AutoCompleteTextView
                android:id="@+id/proto"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="none"
                android:text="@string/protocol" />
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/original_port"
            android:theme="@style/Theme.TextInputLayoutOutlined"
            style="@style/TextInputLayoutOutlined" >

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/orig_port"
                android:inputType="numberDecimal"
                android:imeOptions="actionNext"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="30dp"
            android:hint="@string/destination_host"
            android:theme="@style/Theme.TextInputLayoutOutlined"
            style="@style/TextInputLayoutOutlined" >

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/redirect_host"
                android:inputType="text"
                android:imeOptions="actionNext"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/destination_port"
            android:theme="@style/Theme.TextInputLayoutOutlined"
            style="@style/TextInputLayoutOutlined" >

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/redirect_port"
                android:inputType="numberDecimal"
                android:imeOptions="actionNext"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
        </com.google.android.material.textfield.TextInputLayout>
    </LinearLayout>
</ScrollView>
```

`app/src/main/res/layout/add_rule_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:padding="8dp"
    android:paddingTop="12dp"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/combo_field"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:visibility="gone"
            tools:visibility="visible"
            android:theme="@style/Theme.TextInputLayoutOutlined"
            style="@style/TextInputLayoutOutlinedDropdown">

            <androidx.appcompat.widget.AppCompatAutoCompleteTextView
                android:id="@+id/combo_text"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="text"
                android:imeOptions="actionNext"
                tools:text="Combo" />
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/text_field"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:visibility="gone"
            tools:visibility="visible"
            tools:hint="Text"
            android:theme="@style/Theme.TextInputLayoutOutlined"
            style="@style/TextInputLayoutOutlined" >

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/text_value"
                android:imeOptions="actionNext"
                android:inputType="text"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
        </com.google.android.material.textfield.TextInputLayout>
    </LinearLayout>
</ScrollView>

```

`app/src/main/res/layout/app_installed_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:background="?attr/selectableItemBackground"
    android:padding="3dp">
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="5dp">
        <ImageView
            android:id="@+id/app_icon"
            android:layout_gravity="center"
            android:layout_width="36dp"
            android:layout_height="36dp"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_marginStart="10dp">
            <TextView
                android:id="@+id/app_name"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:textSize="14sp"
                tools:text="App Name"/>
            <TextView
                android:id="@+id/app_package"
                tools:text="App Package Name"
                android:textSize="12sp"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />
        </LinearLayout>
    </LinearLayout>
</LinearLayout>
```

`app/src/main/res/layout/app_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:background="?attr/selectableItemBackground"
    android:orientation="horizontal"
    android:paddingHorizontal="4dp"
    android:paddingVertical="2dp"
    android:gravity="center_vertical"
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/icon"
        tools:src="@drawable/ic_apps"
        tools:tint="?attr/colorAccent"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_margin="4dp" />

    <LinearLayout
        android:orientation="vertical"
        android:layout_marginStart="4dp"
        android:layout_width="0dp"
        android:layout_weight="0.5"
        android:layout_height="wrap_content">

        <TextView
            android:id="@+id/app_info"
            android:textStyle="bold"
            android:textSize="14sp"
            android:ellipsize="end"
            android:singleLine="true"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            tools:text="Example app" />

        <TextView
            android:id="@+id/sent_rcvd"
            tools:text="@string/rcvd_and_sent"
            android:textSize="12sp"
            android:layout_marginTop="2dp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />
    </LinearLayout>

    <ImageView
        android:id="@+id/blocked"
        android:src="@drawable/ic_block"
        android:layout_marginHorizontal="4dp"
        android:layout_width="wrap_content"
        android:layout_height="12sp" />

    <ImageView
        android:id="@+id/whitelisted"
        android:src="@drawable/ic_check_solid"
        app:tint="?attr/colorControlNormal"
        android:layout_marginHorizontal="4dp"
        android:layout_width="wrap_content"
        android:layout_height="16sp" />

    <ImageView
        android:id="@+id/temp_unblocked"
        android:src="@drawable/ic_hourglass_top"
        android:layout_marginHorizontal="4dp"
        android:layout_width="wrap_content"
        android:layout_height="14sp" />

    <TextView
        android:layout_width="8sp"
        android:layout_height="fill_parent"
        android:layout_weight="0.2"
        tools:text="1.05 MB"
        android:gravity="center_vertical|end"
        android:id="@+id/traffic"/>
</LinearLayout>

```

`app/src/main/res/layout/app_overview.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/app_overview"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:fillViewport="true"
    android:padding="8dp">

<androidx.constraintlayout.widget.ConstraintLayout
    android:id="@+id/layout"
    android:padding="8dp"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/app_icon"
        tools:src="@drawable/ic_apps"
        tools:tint="@color/colorAccent"
        android:layout_marginTop="10dp"
        android:layout_width="wrap_content"
        android:layout_height="80dp"
        android:adjustViewBounds="true"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <TableLayout
        android:id="@+id/table"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/app_icon"
        android:layout_marginTop="20dp">

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/app_name" />
            <TextView
                android:id="@+id/name"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="PCAPdroid" />
        </TableRow>

        <TableRow
            android:id="@+id/package_name_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/package_name" />
            <TextView
                android:id="@+id/package_name"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="com.emanuelef.remote_capture" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/uid" />
            <TextView
                android:id="@+id/uid"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="12345" />
        </TableRow>

        <TableRow
            android:id="@+id/version_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/version" />
            <TextView
                android:id="@+id/version"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="1.3.9" />
        </TableRow>

        <TableRow
            android:id="@+id/target_sdk_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/target_sdk" />
            <TextView
                android:id="@+id/target_sdk"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="23" />
        </TableRow>

        <TableRow
            android:id="@+id/install_date_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/installed_on" />
            <TextView
                android:id="@+id/install_date"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="01/02/20 00:45:01" />
        </TableRow>

        <TableRow
            android:id="@+id/last_update_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/last_update" />
            <TextView
                android:id="@+id/last_update"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="01/02/20 00:45:01" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/network_traffic" />
            <TextView
                android:id="@+id/detail_bytes"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="410 B received — 590 B sent" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/connections_view" />
            <TextView
                android:id="@+id/connections"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="2" />
        </TableRow>

        <TableRow
            android:id="@+id/conns_blocked_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.35"
                android:textStyle="bold"
                android:text="@string/connections_blocked" />
            <TextView
                android:id="@+id/conns_blocked"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.65"
                android:textIsSelectable="true"
                tools:text="5" />
        </TableRow>
    </TableLayout>

    <TextView
        android:id="@+id/vapp_info"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="20dp"
        android:textStyle="italic"
        android:visibility="gone"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/table" />

    <TextView
        android:id="@+id/permissions_label"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:textStyle="bold"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/table"
        android:text="@string/permissions"/>

    <HorizontalScrollView
        android:id="@+id/permissionsSv"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/permissions_label"
        android:background="@color/colorBackgroundGray"
        android:layout_marginTop="8dp">

        <TextView
            android:id="@+id/permissions"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:padding="0sp"
            android:textIsSelectable="true"
            android:focusable="true"
            android:nextFocusUp="@id/show_connections"
            android:fontFamily="monospace"
            android:textSize="12sp"
            android:scrollHorizontally="true"
            tools:text="android.permission.INTERNET\nandroid.permission.FOREGROUND_SERVICE"/>
    </HorizontalScrollView>

</androidx.constraintlayout.widget.ConstraintLayout>
</ScrollView>
```

`app/src/main/res/layout/app_selection_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:background="?attr/selectableItemBackground"
    android:orientation="horizontal"
    android:paddingHorizontal="4dp"
    android:paddingVertical="8dp"
    android:gravity="center_vertical"
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/icon"
        android:layout_width="40dp"
        android:layout_height="40dp"
        tools:src="@drawable/ic_apps"
        tools:tint="@color/danger"
        android:layout_margin="4dp" />

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical"
        android:layout_marginStart="10dp">
        <TextView
            android:id="@+id/app_name"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textStyle="bold"
            android:textSize="14sp"
            tools:text="App Name"/>
        <TextView
            android:id="@+id/app_package"
            tools:text="App Package Name"
            android:textSize="12sp"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />
    </LinearLayout>

    <androidx.appcompat.widget.SwitchCompat
        android:id="@+id/toggle_btn"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:gravity="center_vertical|end"/>
</LinearLayout>

```

`app/src/main/res/layout/apps_selector.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <androidx.appcompat.widget.SearchView
        android:id="@+id/apps_search"
        android:layout_marginTop="5dp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:iconifiedByDefault="false"
        app:queryHint="@string/search_apps"/>

    <CheckBox
        android:id="@+id/show_system_apps"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginStart="12dp"
        android:layout_marginEnd="12dp"
        android:text="@string/show_system_apps" />

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <com.emanuelef.remote_capture.views.AppsListView
            android:id="@+id/apps_list"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />

        <TextView
            android:id="@+id/no_apps"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:gravity="center_horizontal"
            android:layout_marginTop="20dp"
            android:layout_marginBottom="40dp"
            android:textStyle="italic"
            android:textSize="15sp"
            android:text="@string/no_apps">
        </TextView>
    </RelativeLayout>

</LinearLayout>
```

`app/src/main/res/layout/apps_stats.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.emanuelef.remote_capture.views.EmptyRecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scrollbars="vertical"
        android:scrollbarStyle="outsideOverlay"
        android:fillViewport="true" />

    <TextView
        android:id="@+id/no_apps"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center_horizontal"
        android:layout_marginTop="40dp"
        android:textStyle="italic"
        android:textSize="15sp"
        android:text="@string/no_apps">
    </TextView>
</RelativeLayout>

```

`app/src/main/res/layout/blacklist_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:descendantFocusability="blocksDescendants"
    android:paddingHorizontal="5dp"
    android:paddingVertical="5dp">

    <TextView
        android:id="@+id/label"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constrainedWidth="true"
        app:layout_constraintEnd_toStartOf="@id/status"
        android:ellipsize="end"
        android:singleLine="true"
        app:layout_constraintHorizontal_bias="0"
        android:textStyle="bold"
        android:textSize="17sp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:drawableEndCompat="@drawable/ic_external"
        android:drawablePadding="5dp"
        tools:text="Blacklist Name" />

    <TextView
        android:id="@+id/status"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        tools:text="Up to date"
        tools:textColor="@color/ok" />

    <TextView
        android:id="@+id/type"
        app:layout_constraintStart_toStartOf="@id/label"
        app:layout_constraintTop_toBottomOf="@id/label"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="13sp"
        tools:text="Type: IP blacklist" />

    <TextView
        android:id="@+id/rules"
        app:layout_constraintStart_toStartOf="@id/type"
        app:layout_constraintTop_toBottomOf="@id/type"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="13sp"
        tools:text="150k rules" />

    <TextView
        android:id="@+id/last_update"
        app:layout_constraintStart_toStartOf="@id/rules"
        app:layout_constraintTop_toBottomOf="@id/rules"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="13sp"
        tools:text="Last update: 12:02:11" />
</androidx.constraintlayout.widget.ConstraintLayout>

```

`app/src/main/res/layout/choice_chip.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.chip.Chip
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    style="@style/Widget.MaterialComponents.Chip.Choice"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    tools:text="a choice" />
```

`app/src/main/res/layout/connection_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:layout_height="60dp"
    android:background="?attr/selectableItemBackground"
    android:orientation="horizontal"
    android:paddingHorizontal="4dp"
    android:paddingTop="3dp"
    android:paddingBottom="3dp">

    <ImageView
        android:id="@+id/icon"
        android:adjustViewBounds="false"
        android:gravity="center"
        android:layout_width="40dp"
        android:layout_height="match_parent"
        android:layout_margin="2dp"
        tools:src="@drawable/ic_apps"
        tools:tint="?attr/colorAccent" />

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="0dp"
        android:orientation="vertical"
        android:paddingHorizontal="4dp"
        android:layout_marginStart="5dp"
        android:layout_weight="1"
        android:layout_height="wrap_content">

        <LinearLayout
            android:id="@+id/app_name_layout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintEnd_toStartOf="@+id/status_placeholder"
            app:layout_constrainedWidth="true"
            app:layout_constraintHorizontal_bias="0"
            android:layout_marginEnd="5dp"
            android:orientation="horizontal">

            <TextView
                android:id="@+id/app_name"
                android:textStyle="bold"
                android:textSize="14sp"
                android:ellipsize="end"
                android:singleLine="true"
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                tools:text="Android" />

            <LinearLayout
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:gravity="center_vertical"
                android:orientation="horizontal">

                <ImageView
                    android:id="@+id/js_injector"
                    android:layout_width="wrap_content"
                    android:layout_height="12sp"
                    android:layout_marginEnd="5dp"
                    app:tint="@color/colorTabText"
                    android:contentDescription="@string/injected"
                    android:src="@drawable/ic_baseline_javascript" />

                <ImageView
                    android:id="@+id/redirected"
                    android:layout_width="wrap_content"
                    android:layout_height="12sp"
                    android:layout_marginEnd="5dp"
                    app:tint="@color/colorTabText"
                    android:contentDescription="@string/redirected"
                    android:src="@drawable/reply" />

                <ImageView
                    android:id="@+id/blacklisted"
                    android:layout_width="wrap_content"
                    android:layout_height="12sp"
                    android:layout_marginEnd="5dp"
                    app:tint="@color/colorTabText"
                    android:contentDescription="@string/malicious_connection_filter"
                    android:src="@drawable/ic_skull" />

                <ImageView
                    android:id="@+id/blocked"
                    android:layout_width="wrap_content"
                    android:layout_height="12sp"
                    app:tint="@color/colorTabText"
                    android:src="@drawable/ic_block" />

                <!--<com.haipq.android.flagkit.FlagImageView
                    android:id="@+id/country_flag"
                    android:layout_width="wrap_content"
                    android:layout_height="12sp"
                    android:layout_marginEnd="5dp"
                    tools:src="@drawable/flag_it" />-->
            </LinearLayout>
        </LinearLayout>

        <TextView
            android:id="@+id/status_placeholder"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            android:visibility="invisible"
            android:text="@string/conn_status_unreachable"/>

        <TextView
            android:id="@+id/status_ind"
            android:textSize="12sp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textAlignment="textEnd"
            app:layout_constraintTop_toTopOf="@id/app_name_layout"
            app:layout_constraintBottom_toBottomOf="@id/app_name_layout"
            app:layout_constraintEnd_toEndOf="parent"
            tools:textColor="#FF28BC36"
            tools:text="@string/conn_status_active" />

        <TextView
            android:id="@+id/last_seen"
            android:textSize="12sp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constraintTop_toBottomOf="@id/app_name_layout"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="17:15:00"/>

        <ImageView
            android:id="@+id/decryption_status"
            android:layout_width="wrap_content"
            android:adjustViewBounds="true"
            android:layout_height="0dp"
            android:paddingVertical="3dp"
            app:layout_constraintTop_toBottomOf="@id/app_name_layout"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintBottom_toBottomOf="@id/l7proto"
            tools:tint="@color/ok"
            tools:src="@drawable/ic_lock_open" />

        <TextView
            android:id="@+id/l7proto"
            android:textSize="13sp"
            android:layout_marginStart="4dp"
            app:layout_goneMarginStart="0dp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constraintTop_toBottomOf="@id/app_name_layout"
            app:layout_constraintStart_toEndOf="@id/decryption_status"
            tools:text="HTTP, 80" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            app:layout_constrainedWidth="true"
            app:layout_constraintHorizontal_bias="0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toStartOf="@+id/traffic"
            app:layout_constraintTop_toBottomOf="@id/l7proto"
            android:gravity="center_vertical">

            <TextView
                android:id="@+id/remote"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:ellipsize="end"
                android:singleLine="true"
                tools:text="example.org"
                android:textSize="12sp" />
        </LinearLayout>

        <TextView
            android:id="@+id/traffic"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            tools:text="105.4 MB"
            android:textSize="14sp"
            android:gravity="end"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintBottom_toBottomOf="parent" />
    </androidx.constraintlayout.widget.ConstraintLayout>
</LinearLayout>

```

`app/src/main/res/layout/connection_overview.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/connection_overview"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:fillViewport="true"
    android:padding="8dp">

<androidx.constraintlayout.widget.ConstraintLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <TableLayout
        android:id="@+id/table"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent">

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/app" />
            <TextView
                android:id="@+id/detail_app"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="com.emanuelef.remote_capture (14503)" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/protocol" />

            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="0.75"
                android:orientation="horizontal">

                <TextView
                    android:id="@+id/detail_protocol"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textIsSelectable="true"
                    tools:text="TLS (TCP)" />

                <ImageView
                    android:id="@+id/protocol_info"
                    android:layout_gravity="center"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:visibility="gone"
                    tools:visibility="visible"
                    android:paddingTop="1sp"
                    android:src="@drawable/ic_info" />
            </LinearLayout>
        </TableRow>

        <TableRow
            android:id="@+id/detail_info_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:id="@+id/detail_info_label"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/sni" />
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:orientation="horizontal">
                <ImageView
                    android:id="@+id/blacklisted_host"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:paddingVertical="3sp"
                    android:src="@drawable/ic_skull"
                    app:tint="@color/colorTabText"/>
                <TextView
                    android:id="@+id/detail_info"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textIsSelectable="true"
                    tools:text="ssl.example.com" />
            </LinearLayout>
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="@string/source" />
            <TextView
                android:id="@+id/detail_source"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="1.2.3.4:14631" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/destination" />
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:orientation="horizontal">
                <ImageView
                    android:id="@+id/blacklisted_ip"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:paddingVertical="3sp"
                    android:src="@drawable/ic_skull"
                    app:tint="@color/colorTabText"
                    android:contentDescription="@string/malicious_connection_filter" />
                <TextView
                    android:id="@+id/detail_destination"
                    android:layout_gravity="center_vertical"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textIsSelectable="true"
                    tools:text="5.6.7.8:443" />
                <com.google.android.material.button.MaterialButton
                    android:id="@+id/whois_ip"
                    android:insetTop="0dp"
                    android:insetBottom="0dp"
                    android:minWidth="0dp"
                    android:layout_marginStart="10dp"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:paddingVertical="0dp"
                    android:paddingHorizontal="5dp"
                    android:drawableEnd="@drawable/ic_external"
                    app:drawableTint="@color/colorPrimary"
                    style="@style/Widget.MaterialComponents.Button.TextButton"
                    android:textSize="12sp"
                    android:text="@string/whois_lookup"/>
            </LinearLayout>
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/status" />
            <TextView
                android:id="@+id/detail_status"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="Open" />
        </TableRow>

        <TableRow
            android:id="@+id/error_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp"
            android:visibility="gone"
            tools:visibility="visible">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/error" />
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="0.75"
                android:orientation="horizontal">

                <TextView
                    android:id="@+id/detail_errno"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textIsSelectable="true"
                    android:textColor="@color/warning"
                    tools:text="No route to host (error 113)" />

                <ImageView
                    android:id="@+id/error_info"
                    android:layout_gravity="center"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:paddingTop="1sp"
                    android:src="@drawable/ic_info" />
            </LinearLayout>
        </TableRow>

        <TableRow
            android:id="@+id/interface_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp"
            android:visibility="gone"
            tools:visibility="visible">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/network_interface" />
            <TextView
                android:id="@+id/capture_interface"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="wlan0" />
        </TableRow>

        <TableRow
            android:id="@+id/detail_url_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/url" />
            <TextView
                android:id="@+id/detail_url"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="example.com/test" />
        </TableRow>

        <TableRow
            android:id="@+id/country_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/country" />
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:gravity="center_vertical">

                <com.haipq.android.flagkit.FlagImageView
                    android:id="@+id/country_flag"
                    android:layout_width="wrap_content"
                    android:layout_height="14sp"
                    android:layout_marginEnd="5dp"
                    tools:src="@drawable/flag_it" />

                <TextView
                    android:id="@+id/country_name"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textIsSelectable="true"
                    tools:text="Italy" />
            </LinearLayout>
        </TableRow>

        <TableRow
            android:id="@+id/asn_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/asn" />
            <TextView
                android:id="@+id/asn"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="ASN_1 - Public" />
        </TableRow>
        <TableRow
            android:id="@+id/decryption_status_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/decryption" />
            <LinearLayout
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:gravity="center_vertical">

                <ImageView
                    android:id="@+id/decryption_icon"
                    tools:tint="@color/ok"
                    tools:src="@drawable/ic_lock_open"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:layout_marginStart="-2dp"
                    android:layout_marginEnd="2dp"
                    android:adjustViewBounds="true"
                    android:paddingVertical="2dp" />
                <TextView
                    android:id="@+id/detail_decryption_status"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="0.75"
                    android:textIsSelectable="true"
                    tools:text="Decrypted" />
            </LinearLayout>
        </TableRow>
        <TableRow
            android:id="@+id/injected_scripts_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/injected" />
            <TextView
                android:id="@+id/injected_scripts"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="some script" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp"
            android:layout_marginTop="16dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/network_traffic" />
            <TextView
                android:id="@+id/detail_bytes"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="1.5 MB received - 0.1 sent" />
        </TableRow>

        <TableRow
            android:id="@+id/tcp_flags_row"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:visibility="gone"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="TCP Flags" />
            <TextView
                android:id="@+id/tcp_flags"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="1.1 K down - 98 down" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/packets" />
            <TextView
                android:id="@+id/detail_packets"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="1.1 K received - 98 sent" />
        </TableRow>

        <TableRow
            android:id="@+id/blocked_row"
            android:visibility="gone"
            tools:visibility="visible"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/blocked_pkts" />
            <TextView
                android:id="@+id/blocked_pkts"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="11 pkts" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/payload" />
            <TextView
                android:id="@+id/detail_payload"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="0.6 MB" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/duration" />
            <TextView
                android:id="@+id/detail_duration"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="2 min" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/first_seen" />
            <TextView
                android:id="@+id/first_seen"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="01/02/20 00:45:01" />
        </TableRow>

        <TableRow
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginBottom="4dp">
            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.25"
                android:textStyle="bold"
                android:text="@string/last_seen" />
            <TextView
                android:id="@+id/last_seen"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="0.75"
                android:textIsSelectable="true"
                tools:text="01/02/20 00:47:01" />
        </TableRow>
    </TableLayout>

    <TextView
        android:id="@+id/error_msg"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/table"
        android:textColor="@color/danger"
        android:textIsSelectable="true"
        android:layout_marginTop="8dp"
        android:visibility="gone"
        tools:visibility="visible"
        tools:text="The client may not trust certificate" />

</androidx.constraintlayout.widget.ConstraintLayout>
</ScrollView>
```

`app/src/main/res/layout/connection_payload.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    android:id="@+id/cord_layout"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <com.emanuelef.remote_capture.views.EmptyRecyclerView
        android:id="@+id/payload"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:scrollbars="vertical"
        android:scrollbarStyle="outsideOverlay"
        android:fillViewport="true" />

    <LinearLayout
        android:id="@+id/decryption_error_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp"
        android:visibility="gone">

        <TextView
            android:id="@+id/request_url"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:paddingVertical="8dp" />

        <TextView
            android:id="@+id/decryption_error"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="@color/danger"
            android:paddingBottom="8dp" />

        <Button
            android:id="@+id/show_connection_btn"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/show_connection" />
    </LinearLayout>

    <TextView
        android:id="@+id/truncated_warning"
        android:text="@string/payload_truncated"
        android:layout_width="match_parent"
        tools:visibility="visible"
        android:visibility="gone"
        android:padding="6dp"
        android:textStyle="italic"
        android:layout_height="wrap_content"/>
</LinearLayout>
```

`app/src/main/res/layout/connections.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/connections"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <LinearLayout
        android:id="@+id/linearlayout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <TextView
            android:id="@+id/old_connections_notice"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_margin="8dp"
            android:textSize="15sp"
            android:textStyle="italic"
            android:visibility="gone"
            tools:visibility="visible"
            tools:text="74 older connections not shown" />

        <com.google.android.material.chip.ChipGroup
            android:id="@+id/active_filter"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginVertical="4dp"
            android:layout_marginHorizontal="2dp"
            android:visibility="gone"
            app:singleSelection="true">
        </com.google.android.material.chip.ChipGroup>

        <com.google.android.material.slider.Slider
            android:id="@+id/size_slider"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginHorizontal="10dp"
            app:thumbColor="@color/colorAccent"
            app:trackColorActive="@color/colorAccent"
            app:trackColorInactive="@color/colorAccentLight"
            app:labelBehavior="visible"
            android:valueFrom="0"
            android:valueTo="1024"
            android:stepSize="1"
            android:visibility="gone"
            tools:value="100"
            tools:valueTo="1024"/>

        <TextView
            android:id="@+id/no_connections"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:gravity="center_horizontal"
            android:layout_marginTop="40dp"
            android:textStyle="italic"
            android:textSize="15sp"
            tools:text="@string/start_capture_first">
        </TextView>

        <com.emanuelef.remote_capture.views.EmptyRecyclerView
            android:id="@+id/connections_view"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:scrollbars="vertical"
            android:scrollbarStyle="outsideOverlay"
            android:fillViewport="true" />
    </LinearLayout>

    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fabDown"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentEnd="true"
        android:layout_alignParentBottom="true"
        android:layout_margin="16dp"
        app:backgroundTint="@color/colorAccent"
        app:tint="@null"
        app:maxImageSize="48dp"
        android:src="@drawable/ic_arrow_drop_down" />
</RelativeLayout>

```

`app/src/main/res/layout/ctrl_consent.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:background="@color/navViewBackground"
    android:filterTouchesWhenObscured="true"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginHorizontal="10dp"
    android:paddingVertical="15dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textStyle="bold"
        android:layout_gravity="center_horizontal"
        android:layout_marginBottom="20dp"
        android:textSize="18sp"
        android:text="@string/ctrl_consent_title" />

    <LinearLayout
        android:id="@+id/caller_app"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_horizontal"
        android:orientation="vertical">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical">

            <ImageView
                android:id="@+id/app_icon"
                android:layout_width="50dp"
                android:layout_height="wrap_content"
                android:layout_marginStart="20dp"
                android:layout_marginEnd="15dp"
                android:adjustViewBounds="false"
                tools:src="@drawable/ic_apps"
                tools:tint="@color/colorAccent" />

            <LinearLayout
                android:orientation="vertical"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center_vertical">

                <TextView
                    android:id="@+id/app_name"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textStyle="bold"
                    tools:text="App Name" />

                <TextView
                    android:id="@+id/app_package"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    tools:text="my.app.package" />
            </LinearLayout>
        </LinearLayout>

        <RadioGroup
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <RadioButton
                android:id="@+id/choice_once"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginEnd="15dp"
                android:text="@string/once"
                android:checked="true" />
            <RadioButton
                android:id="@+id/choice_forever"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/forever" />
        </RadioGroup>
    </LinearLayout>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textColor="#FF6565"
        android:textStyle="bold"
        android:layout_gravity="center_horizontal"
        android:textAlignment="center"
        android:layout_marginTop="20dp"
        android:text="@string/ctrl_consent" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_gravity="center_horizontal"
        android:layout_marginHorizontal="20dp"
        android:layout_marginTop="20dp">

        <Button
            android:id="@+id/deny_btn"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_weight="1"
            android:text="@string/deny"
            android:background="?android:attr/selectableItemBackground"
            android:textColor="@android:color/darker_gray" />

        <Button
            android:id="@+id/allow_btn"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:layout_weight="1"
            android:text="@string/allow"
            android:enabled="false"
            android:background="?android:attr/selectableItemBackground"
            android:textColor="@android:color/darker_gray" />
    </LinearLayout>
</LinearLayout>
```

`app/src/main/res/layout/data_view_container.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/child_fragment_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />

```

`app/src/main/res/layout/dropdown_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="16dp"
    android:ellipsize="end"
    android:maxLines="1"
    android:textAppearance="?attr/textAppearanceSubtitle1"
    />
```

`app/src/main/res/layout/edit_filter_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fitsSystemWindows="true">

        <LinearLayout
            android:orientation="vertical"
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            android:layout_margin="15dp">

            <RelativeLayout
                android:id="@+id/connections_mask"
                android:layout_height="wrap_content"
                android:layout_width="match_parent"
                android:layout_marginBottom="10dp">

                <CheckBox
                    android:id="@+id/not_hidden"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_alignParentStart="true"
                    android:layout_toStartOf="@id/edit_mask"
                    android:text="@string/not_hidden_filter" />

                <Button
                    android:id="@+id/edit_mask"
                    style="?attr/materialButtonOutlinedStyle"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_alignParentEnd="true"
                    android:text="@string/edit_list"
                    android:textColor="@color/colorTabText" />
            </RelativeLayout>

            <CheckBox
                android:id="@+id/only_blacklisted"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:text="@string/show_only_malicious" />

            <CheckBox
                android:id="@+id/only_cleartext"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:text="@string/show_only_cleartext" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/status"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@id/status_group"
                android:layout_marginBottom="5dp"/>
            <com.google.android.material.chip.ChipGroup
                android:id="@+id/status_group"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                app:singleSelection="true">

                <com.google.android.material.chip.Chip
                    android:id="@+id/status_active"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/conn_status_active"/>

                <com.google.android.material.chip.Chip
                    android:id="@+id/status_closed"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/conn_status_closed"/>

                <com.google.android.material.chip.Chip
                    android:id="@+id/status_unreachable"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/conn_status_unreachable"/>

                <com.google.android.material.chip.Chip
                    android:id="@+id/status_error"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/error"/>
            </com.google.android.material.chip.ChipGroup>

            <TextView
                android:id="@+id/decryption_status_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/decryption"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@id/decryption_status_group"
                android:visibility="gone"
                tools:visibility="visible"
                android:layout_marginBottom="5dp"/>
            <com.google.android.material.chip.ChipGroup
                android:id="@+id/decryption_status_group"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:visibility="gone"
                tools:visibility="visible"
                app:singleSelection="true">

                <com.google.android.material.chip.Chip
                    android:id="@+id/dec_status_decrypted"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/decrypted"/>

                <com.google.android.material.chip.Chip
                    android:id="@+id/dec_status_not_decryptable"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/not_decryptable"/>

                <com.google.android.material.chip.Chip
                    android:id="@+id/dec_status_error"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/error"/>
            </com.google.android.material.chip.ChipGroup>

            <TextView
                android:id="@+id/firewall_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/firewall"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@+id/firewall_group"
                android:visibility="gone"
                tools:visibility="visible"
                android:layout_marginBottom="5dp"/>
            <com.google.android.material.chip.ChipGroup
                android:id="@+id/firewall_group"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:visibility="gone"
                tools:visibility="visible"
                app:singleSelection="true">

                <com.google.android.material.chip.Chip
                    android:id="@+id/status_blocked"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/blocked_connection_filter"/>

                <com.google.android.material.chip.Chip
                    android:id="@+id/status_allowed"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/allowed_connection_filter"/>
            </com.google.android.material.chip.ChipGroup>

            <TextView
                android:id="@+id/interfaces_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/network_interface"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:visibility="gone"
                tools:visibility="visible"
                android:labelFor="@id/interfaces"
                android:layout_marginBottom="5dp"/>

            <com.google.android.material.chip.ChipGroup
                android:id="@+id/interfaces"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:visibility="gone"
                tools:visibility="visible"
                app:singleSelection="true">
            </com.google.android.material.chip.ChipGroup>

            <TextView
                android:id="@+id/size_slider_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/bytes_threshold"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@id/size_slider"
                android:visibility="gone"
                tools:visibility="visible"
                android:layout_marginBottom="5dp"/>

            <com.google.android.material.slider.Slider
                android:id="@+id/size_slider"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:thumbColor="@color/colorAccent"
                app:trackColorActive="@color/colorAccent"
                app:trackColorInactive="@color/colorAccentLight"
                app:labelBehavior="visible"
                android:valueFrom="0"
                android:valueTo="1024"
                android:stepSize="1"
                android:visibility="gone"
                tools:visibility="visible"
                tools:value="100"
                tools:valueTo="1024"/>
        </LinearLayout>
    </ScrollView>
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/error_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:background="@android:color/transparent"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center">

        <ScrollView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            tools:ignore="UselessParent">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:orientation="vertical"
                android:paddingBottom="@dimen/customactivityoncrash_activity_vertical_margin"
                android:paddingLeft="@dimen/customactivityoncrash_activity_horizontal_margin"
                android:paddingRight="@dimen/customactivityoncrash_activity_horizontal_margin"
                android:paddingTop="@dimen/customactivityoncrash_activity_vertical_margin">

                <ImageView
                    android:id="@+id/customactivityoncrash_error_activity_image"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:contentDescription="@null"
                    android:src="@drawable/customactivityoncrash_error_image" />

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/customactivityoncrash_activity_vertical_margin"
                    android:gravity="center"
                    android:text="@string/customactivityoncrash_error_activity_error_occurred_explanation"
                    android:textSize="18sp"
                    android:textStyle="bold" />

                <Button
                    android:id="@+id/report_button"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/customactivityoncrash_activity_vertical_margin"
                    android:text="@string/send_report" />

                <Button
                    android:id="@+id/customactivityoncrash_error_activity_more_info_button"
                    style="?borderlessButtonStyle"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/customactivityoncrash_error_activity_error_details"
                    android:textColor="?colorPrimary" />

                <Button
                    android:id="@+id/customactivityoncrash_error_activity_restart_button"
                    style="?materialButtonOutlinedStyle"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="@dimen/customactivityoncrash_activity_vertical_margin"
                    android:text="@string/customactivityoncrash_error_activity_close_app" />
            </LinearLayout>
        </ScrollView>
    </RelativeLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/firewall_status.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/scrollView"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:layout_marginTop="30dp"
    android:layout_marginBottom="10dp"
    android:fillViewport="true">

    <LinearLayout
        android:id="@+id/firewall_status"
        android:layout_width="match_parent"
        android:orientation="vertical"
        android:layout_height="wrap_content"
        android:gravity="center_horizontal"
        android:layout_margin="10dp">

        <ImageView
            android:id="@+id/status_icon"
            android:layout_width="100dp"
            android:layout_height="100dp"
            android:layout_marginTop="50dp"
            app:tint="@color/ok"
            tools:src="@drawable/ic_shield" />
        <TextView
            android:id="@+id/status"
            android:layout_marginTop="10dp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="30dp"
            android:textSize="20sp"
            android:textStyle="bold"
            tools:text="@string/firewall_is_enabled" />

        <GridLayout
            android:columnCount="2"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:descendantFocusability="blocksDescendants"
            android:useDefaultMargins="true">

            <com.google.android.material.card.MaterialCardView
                android:clickable="false"
                android:focusable="false"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/connections_checked"/>
                    <TextView
                        android:id="@+id/num_checked"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="1.2 k"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:id="@+id/show_connections"
                android:clickable="true"
                android:focusable="true"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/connections_blocked"/>
                    <TextView
                        android:id="@+id/num_blocked"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="48"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>


            <com.google.android.material.card.MaterialCardView
                android:clickable="false"
                android:focusable="false"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/num_configured_rules"/>
                    <TextView
                        android:id="@+id/num_rules"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="21"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:clickable="false"
                android:focusable="false"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/last_firewall_block"/>
                    <TextView
                        android:id="@+id/last_block"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="13:04"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>
        </GridLayout>
    </LinearLayout>
</ScrollView>
```

`app/src/main/res/layout/fragment_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <androidx.fragment.app.FragmentContainerView
            android:id="@+id/fragment"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1" />
    </LinearLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/fragment_mitm_wizard.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    tools:context=".fragments.mitmwizard.InstallAddon">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/step_status"
            android:layout_width="80dp"
            android:layout_height="80dp"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            app:layout_constraintBottom_toTopOf="@id/step_label"
            android:layout_marginBottom="20dp"
            android:src="@drawable/ic_exclamation_triangle_solid"
            app:tint="@color/warning" />

        <TextView
            android:id="@+id/step_label"
            tools:text="Perform this and that"
            android:textAlignment="center"
            android:textSize="16sp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"/>

        <Button
            android:id="@+id/skip_button"
            style="?materialButtonOutlinedStyle"
            android:text="@string/app_intro_skip_button"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:visibility="gone"
            tools:visibility="visible"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            app:layout_constraintBottom_toTopOf="@id/step_button"/>

        <Button
            android:id="@+id/step_button"
            tools:text="Action"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"/>
    </androidx.constraintlayout.widget.ConstraintLayout>
</FrameLayout>
```

`app/src/main/res/layout/http_log_filter_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fitsSystemWindows="true">

        <LinearLayout
            android:orientation="vertical"
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            android:layout_margin="15dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/status"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@id/decryption_error_group"
                tools:visibility="visible"
                android:layout_marginBottom="5dp"/>
            <com.google.android.material.chip.ChipGroup
                android:id="@+id/decryption_error_group"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                tools:visibility="visible"
                app:singleSelection="true">

                <com.google.android.material.chip.Chip
                    android:id="@+id/decryption_no_error_chip"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/ok"/>

                <com.google.android.material.chip.Chip
                    android:id="@+id/decryption_error_chip"
                    style="@style/Widget.MaterialComponents.Chip.Choice"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/decryption_error"/>
            </com.google.android.material.chip.ChipGroup>

            <TextView
                android:id="@+id/method_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/request_method"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@id/method_group"
                android:visibility="gone"
                tools:visibility="visible"
                android:layout_marginBottom="5dp"/>
            <com.google.android.material.chip.ChipGroup
                android:id="@+id/method_group"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:visibility="gone"
                tools:visibility="visible"
                app:singleSelection="true">
            </com.google.android.material.chip.ChipGroup>
            <View
                android:id="@+id/http_method_filter"
                android:layout_width="0dp"
                android:layout_height="0dp"
                android:visibility="gone" />

            <TextView
                android:id="@+id/content_type_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/content_type"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@id/content_type_group"
                android:visibility="gone"
                tools:visibility="visible"
                android:layout_marginBottom="5dp"/>

            <com.google.android.material.chip.ChipGroup
                android:id="@+id/content_type_group"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:visibility="gone"
                tools:visibility="visible"
                app:singleSelection="true">
            </com.google.android.material.chip.ChipGroup>
            <View
                android:id="@+id/http_content_type_filter"
                android:layout_width="0dp"
                android:layout_height="0dp"
                android:visibility="gone" />

            <TextView
                android:id="@+id/http_status_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/http_status"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@id/http_status_group"
                android:visibility="gone"
                tools:visibility="visible"
                android:layout_marginBottom="5dp"/>

            <com.google.android.material.chip.ChipGroup
                android:id="@+id/http_status_group"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:visibility="gone"
                tools:visibility="visible"
                app:singleSelection="true">
            </com.google.android.material.chip.ChipGroup>
            <View
                android:id="@+id/http_status_filter"
                android:layout_width="0dp"
                android:layout_height="0dp"
                android:visibility="gone" />

            <TextView
                android:id="@+id/payload_size_label"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/payload_size_threshold"
                android:textStyle="bold"
                android:textColor="@color/colorAccent"
                android:textSize="18sp"
                android:labelFor="@id/payload_size_slider"
                android:visibility="gone"
                tools:visibility="visible"
                android:layout_marginBottom="5dp"/>

            <com.google.android.material.slider.Slider
                android:id="@+id/payload_size_slider"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:thumbColor="@color/colorAccent"
                app:trackColorActive="@color/colorAccent"
                app:trackColorInactive="@color/colorAccentLight"
                app:labelBehavior="visible"
                android:valueFrom="0"
                android:valueTo="1024"
                android:stepSize="1"
                android:visibility="gone"
                tools:visibility="visible"
                tools:value="100"
                tools:valueTo="1024"/>
        </LinearLayout>
    </ScrollView>
</androidx.coordinatorlayout.widget.CoordinatorLayout>

```

`app/src/main/res/layout/http_req_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:layout_height="80dp"
    android:background="?attr/selectableItemBackground"
    android:orientation="horizontal"
    android:paddingHorizontal="4dp"
    android:paddingTop="3dp"
    android:paddingBottom="3dp">

    <ImageView
        android:id="@+id/icon"
        android:adjustViewBounds="false"
        android:gravity="center"
        android:layout_width="40dp"
        android:layout_height="match_parent"
        android:layout_margin="2dp"
        tools:src="@drawable/ic_apps"
        tools:tint="?attr/colorAccent" />

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="0dp"
        android:orientation="vertical"
        android:paddingHorizontal="4dp"
        android:layout_marginStart="5dp"
        android:layout_weight="1"
        android:layout_height="wrap_content">

        <LinearLayout
            android:id="@+id/app_name_layout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constrainedWidth="true"
            app:layout_constraintHorizontal_bias="0"
            android:orientation="horizontal">

            <TextView
                android:id="@+id/app_name"
                android:textStyle="bold"
                android:textSize="14sp"
                android:ellipsize="end"
                android:singleLine="true"
                android:layout_width="0dp"
                android:layout_weight="3"
                android:layout_marginEnd="10dp"
                android:layout_height="wrap_content"
                tools:text="Android" />

            <TextView
                android:id="@+id/content_type"
                android:textSize="12sp"
                android:layout_width="0dp"
                android:layout_weight="2"
                android:layout_height="wrap_content"
                android:textAlignment="textEnd"
                android:textColor="@color/in_progress"
                app:layout_constraintTop_toTopOf="@id/app_name_layout"
                app:layout_constraintBottom_toBottomOf="@id/app_name_layout"
                app:layout_constraintEnd_toEndOf="parent"
                android:ellipsize="start"
                android:singleLine="true"
                tools:text="application/x-www-form-urlencoded" />
        </LinearLayout>

        <TextView
            android:id="@+id/proto_and_host"
            android:textSize="13sp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constrainedWidth="true"
            app:layout_constraintHorizontal_bias="0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@id/app_name_layout"
            app:layout_constraintEnd_toStartOf="@id/req_time"
            android:paddingEnd="5dp"
            android:ellipsize="middle"
            android:singleLine="true"
            tools:text="http://example.org"
            tools:ignore="RtlSymmetry" />

        <TextView
            android:id="@+id/method_and_path"
            android:textSize="13sp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constrainedWidth="true"
            app:layout_constraintHorizontal_bias="0"
            app:layout_constraintTop_toBottomOf="@id/proto_and_host"
            app:layout_constraintEnd_toStartOf="@id/req_time"
            app:layout_constraintStart_toStartOf="parent"
            android:singleLine="true"
            android:ellipsize="middle"
            tools:text="GET /images/24x24/some_image.png" />

        <TextView
            android:id="@+id/req_time"
            android:textSize="12sp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constraintTop_toBottomOf="@id/app_name_layout"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="17:15:00"/>

        <TextView
            android:id="@+id/http_status"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constrainedWidth="true"
            app:layout_constraintHorizontal_bias="0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toStartOf="@+id/payload_size"
            app:layout_constraintTop_toBottomOf="@id/method_and_path"
            android:ellipsize="end"
            android:singleLine="true"
            tools:text="304 Not Modified"
            android:textSize="12sp" />

        <TextView
            android:id="@+id/payload_size"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            tools:text="105.4 MB"
            android:textSize="12sp"
            android:gravity="end"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintBottom_toBottomOf="parent" />
    </androidx.constraintlayout.widget.ConstraintLayout>
</LinearLayout>

```

`app/src/main/res/layout/license_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="10dp">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:textStyle="bold"
            android:text="@string/installation_id" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center">

            <TextView
                android:id="@+id/installation_id"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textIsSelectable="true"
                android:focusable="true"
                tools:text="A127ADC1245" />

            <ImageView
                android:id="@+id/copy_id"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="8dp"
                android:src="@drawable/ic_content_copy" />
        </LinearLayout>

        <com.google.android.material.button.MaterialButton
            android:id="@+id/show_qr_code"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/activate_via_qr_code"
            android:layout_gravity="center"
            style="?attr/materialButtonOutlinedStyle" />

        <TextView
            android:id="@+id/qr_code_loading"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:visibility="gone"
            android:text="@string/loading" />

        <TextView
            android:id="@+id/qr_info_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:textAlignment="center"
            android:visibility="gone"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            android:layout_marginHorizontal="40dp"
            android:layout_marginTop="10dp"
            android:text="@string/qr_info_text" />

        <LinearLayout
            android:id="@+id/qr_box"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:visibility="gone"
            tools:visibility="visible"
            android:layout_gravity="center"
            android:orientation="vertical">

            <ImageView
                android:id="@+id/qr_code"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginVertical="20dp"
                tools:layout_width="200dp"
                tools:layout_height="200dp"/>

            <ProgressBar
                android:id="@+id/qr_remaining_time"
                style="@android:style/Widget.Material.ProgressBar.Horizontal"
                tools:progress="25"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"/>
        </LinearLayout>

        <TextView
            android:id="@+id/paid_features_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginVertical="10dp"
            android:text="@string/access_paid_features_msg" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textStyle="bold"
            android:text="@string/license_code" />

        <EditText
            android:id="@+id/license_code"
            android:fontFamily="monospace"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="textMultiLine"
            android:gravity="top"
            android:lines="4" />

        <TextView
            android:id="@+id/validation_rc"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@color/ok"
            android:textAllCaps="true"
            android:textSize="13sp"
            tools:text="@string/valid" />
    </LinearLayout>
</ScrollView>
```

`app/src/main/res/layout/logview_fragment.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    android:id="@+id/scrollView"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/log"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:textSize="13sp"
        tools:text="[i] log..."
        android:textIsSelectable="true" />
</ScrollView>
```

`app/src/main/res/layout/main_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<androidx.drawerlayout.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:openDrawer="start">

    <include
        layout="@layout/tabs_activity"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

    <com.google.android.material.navigation.NavigationView
        android:id="@+id/nav_view"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:background="@color/navViewBackground"
        app:headerLayout="@layout/nav_header"
        app:itemIconPadding="18dp"
        app:itemTextColor="@color/drawerItemColor"
        app:itemIconTint="@color/drawerItemColor"
        app:menu="@menu/nav_items" />

</androidx.drawerlayout.widget.DrawerLayout>

```

`app/src/main/res/layout/malware_detection_blacklists.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ListView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/listview"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scrollbarStyle="outsideOverlay" />
```

`app/src/main/res/layout/malware_detection_status.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:layout_marginTop="30dp"
    android:layout_marginBottom="10dp"
    android:fillViewport="true">

    <LinearLayout
        android:id="@+id/mw_detection_status"
        android:layout_width="match_parent"
        android:orientation="vertical"
        android:layout_height="wrap_content"
        android:gravity="center_horizontal"
        android:layout_margin="10dp">

        <ImageView
            android:id="@+id/status_icon"
            android:layout_width="100dp"
            android:layout_height="100dp"
            android:layout_marginTop="50dp"
            tools:src="@drawable/ic_exclamation_triangle_solid" />
        <TextView
            android:id="@+id/status"
            android:layout_marginTop="10dp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="30dp"
            android:textSize="20sp"
            android:textStyle="bold"
            tools:text="@string/malware_status_detected" />

        <GridLayout
            android:columnCount="2"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:descendantFocusability="blocksDescendants"
            android:useDefaultMargins="true">

            <com.google.android.material.card.MaterialCardView
                android:clickable="false"
                android:focusable="false"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/connections_checked"/>
                    <TextView
                        android:id="@+id/num_checked"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="1.2 k"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:id="@+id/show_connections"
                android:clickable="true"
                android:focusable="true"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/malicious_connections"/>
                    <TextView
                        android:id="@+id/num_malicious"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textColor="@color/danger"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="3"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:clickable="false"
                android:focusable="false"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/updated_blacklists"/>
                    <TextView
                        android:id="@+id/num_up_to_date"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="5/5"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:clickable="false"
                android:focusable="false"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/last_blacklists_update"/>
                    <TextView
                        android:id="@+id/last_update"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="13:04"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:clickable="false"
                android:focusable="false"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/domain_rules"/>
                    <TextView
                        android:id="@+id/num_domain_rules"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="150 k"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <com.google.android.material.card.MaterialCardView
                android:clickable="false"
                android:focusable="false"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_columnWeight="1">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="start"
                    android:layout_margin="15dp"
                    android:orientation="vertical">
                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="13sp"
                        android:layout_marginBottom="5dp"
                        android:text="@string/ip_rules"/>
                    <TextView
                        android:id="@+id/num_ip_rules"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:textSize="30sp"
                        android:textAppearance="?attr/textAppearanceSubtitle1"
                        tools:text="4.8 k"/>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>
        </GridLayout>
    </LinearLayout>
</ScrollView>
```

`app/src/main/res/layout/mitm_wizard_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

<androidx.constraintlayout.widget.ConstraintLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true"
    tools:context=".activities.MitmSetupWizard">

    <androidx.fragment.app.FragmentContainerView
        android:id="@+id/nav_host_fragment"
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_margin="10dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"

        app:defaultNavHost="true"
        app:navGraph="@navigation/mitm_wizard_graph" />

    </androidx.constraintlayout.widget.ConstraintLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/nav_header.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ImageView
        android:layout_width="match_parent"
        android:layout_height="@dimen/drawer_header_height"
        android:src="@drawable/drawer_background"
        android:scaleType="centerCrop"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"/>

    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:src="@drawable/ic_logo"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintHorizontal_bias="0.5"
        app:layout_constraintVertical_bias="0.5"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <TextView
        android:id="@+id/app_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginBottom="8dp"
        android:layout_marginStart="8dp"
        android:text="PCAPdroid"
        android:textSize="12sp"
        android:textColor="@android:color/primary_text_dark"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent" />

    <TextView
        android:id="@+id/app_version"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginBottom="8dp"
        android:layout_marginEnd="8dp"
        tools:text="vx.y.z"
        android:focusable="false"
        android:textSize="12sp"
        android:textColor="@android:color/primary_text_dark"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintRight_toRightOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
```

`app/src/main/res/layout/payload_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:focusableInTouchMode="true"
    android:nextFocusDown="@id/expand_button"
    android:paddingHorizontal="3sp">

    <LinearLayout
        android:id="@+id/header_line"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_vertical"
        android:layout_marginVertical="8dp"
        android:orientation="horizontal">

        <TextView
            android:id="@+id/header"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:fontFamily="monospace"
            android:textSize="11sp"
            android:textStyle="bold"
            tools:text="#1 [TX] 11:02:03.154 — 120 B" />

        <View
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_weight="1" />

        <com.google.android.material.button.MaterialButton
            android:id="@+id/copy_button"
            android:insetTop="0dp"
            android:insetBottom="0dp"
            android:insetLeft="0dp"
            android:insetRight="0dp"
            android:minWidth="0dp"
            android:minHeight="0dp"
            android:paddingVertical="2dp"
            android:paddingHorizontal="2dp"
            android:layout_marginHorizontal="2dp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:icon="@drawable/ic_content_copy_small"
            app:iconGravity="textStart"
            app:iconPadding="0dp"
            app:iconTint="@color/colorTabText"
            style="@style/Widget.MaterialComponents.Button.TextButton" />

        <com.google.android.material.button.MaterialButton
            android:id="@+id/export_button"
            android:insetTop="0dp"
            android:insetBottom="0dp"
            android:insetLeft="0dp"
            android:insetRight="0dp"
            android:minWidth="0dp"
            android:minHeight="0dp"
            android:paddingVertical="2dp"
            android:paddingHorizontal="2dp"
            android:layout_marginHorizontal="2dp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:icon="@drawable/ic_save_alt_small"
            app:iconGravity="textStart"
            app:iconPadding="0dp"
            app:iconTint="@color/colorTabText"
            style="@style/Widget.MaterialComponents.Button.TextButton" />
    </LinearLayout>

    <RelativeLayout
        android:id="@+id/dump_box"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        tools:background="@color/sentPayloadBg">

        <!-- Keep layout_width to "wrap_content" or text selection will fail in some cases (Android bug?) -->
        <!-- Use dp to get a consistent size across devices: prevents splitting hexdump lines -->
        <TextView
            android:id="@+id/dump"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            tools:textColor="@color/sentPayloadFg"
            android:textIsSelectable="true"
            android:fontFamily="@font/sourcecodepro_regular"
            android:textDirection="ltr"
            android:textSize="9dp"
            android:textStyle="bold"
            android:focusable="true"
            tools:text="GET / HTTP/1.1\nHost: example.org\nAccept: */*"/>
    </RelativeLayout>

    <com.google.android.material.button.MaterialButton
        android:id="@+id/expand_button"
        android:insetTop="0dp"
        android:insetBottom="0dp"
        android:insetLeft="0dp"
        android:insetRight="0dp"
        android:minWidth="0dp"
        android:minHeight="0dp"
        android:paddingVertical="0dp"
        android:paddingHorizontal="0dp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginEnd="2dp"
        android:layout_gravity="end"
        app:icon="@drawable/ic_expand_more"
        app:iconGravity="textStart"
        app:iconPadding="0dp"
        app:iconTint="@color/colorTabText"
        style="@style/Widget.MaterialComponents.Button.TextButton" />
</LinearLayout>

```

`app/src/main/res/layout/port_mapping_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:background="?android:attr/activatedBackgroundIndicator"
    android:orientation="vertical"
    android:gravity="center_vertical"
    android:padding="10dp">

    <TextView
        android:id="@+id/proto"
        android:layout_height="wrap_content"
        android:layout_width="wrap_content"
        android:textStyle="bold"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="TCP" />

    <TextView
        android:id="@+id/orig_port"
        android:layout_height="wrap_content"
        android:layout_width="wrap_content"
        android:textStyle="bold"
        android:layout_marginStart="5sp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toEndOf="@id/proto"
        tools:text="53" />

    <TextView
        android:id="@+id/redirect_to_lbl"
        android:text="@string/redirect_to"
        android:layout_height="wrap_content"
        android:layout_width="wrap_content"
        app:layout_constraintTop_toBottomOf="@id/proto"
        app:layout_constraintStart_toStartOf="parent" />

    <TextView
        android:id="@+id/redirect_to"
        android:layout_height="wrap_content"
        android:layout_width="wrap_content"
        android:layout_marginStart="5sp"
        app:layout_constraintTop_toBottomOf="@id/proto"
        app:layout_constraintStart_toEndOf="@id/redirect_to_lbl"
        tools:text="127.0.0.1:5353" />
</androidx.constraintlayout.widget.ConstraintLayout>

```

`app/src/main/res/layout/quick_settings_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginBottom="4dp"
    android:layout_marginTop="4dp"
    android:padding="10dp"
    android:orientation="vertical">

    <TextView
        android:id="@+id/title"
        android:theme="@style/QuickSettings.Title"
        tools:text="Title"
        android:layout_width="wrap_content"
        android:layout_marginBottom="2dp"
        android:layout_height="wrap_content"/>

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_vertical">

        <ImageView
            android:id="@+id/icon"
            android:visibility="gone"
            android:adjustViewBounds="false"
            android:layout_width="24dp"
            android:layout_height="match_parent"
            android:layout_marginVertical="1dp"
            android:layout_marginEnd="2dp"
            tools:src="@drawable/ic_apps"
            tools:tint="?attr/colorAccent" />

        <TextView
            android:id="@+id/description"
            tools:text="Description"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="wrap_content"/>
    </LinearLayout>
</LinearLayout>
```

`app/src/main/res/layout/rule_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="?android:attr/activatedBackgroundIndicator"
    android:orientation="horizontal"
    android:gravity="center_vertical"
    android:padding="10dp">

    <ImageView
        android:id="@+id/icon"
        android:layout_width="30dp"
        android:layout_height="wrap_content"
        android:layout_marginEnd="10dp"
        android:adjustViewBounds="true"
        tools:tint="@color/colorTabText"
        tools:src="@drawable/ic_short_text" />

    <com.haipq.android.flagkit.FlagImageView
        android:id="@+id/country_flag"
        android:visibility="gone"
        android:layout_width="30dp"
        android:layout_height="wrap_content"
        android:layout_marginEnd="10dp"
        android:padding="4dp"
        tools:src="@drawable/flag_it" />

    <TextView
        android:id="@+id/item_label"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        tools:text="App: example app"
        android:gravity="center_vertical" />
</LinearLayout>

```

`app/src/main/res/layout/scrollable_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:padding="8dp"
    android:paddingTop="12dp"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:focusable="false"
        android:textIsSelectable="true" />
</ScrollView>
```

`app/src/main/res/layout/simple_list.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!-- Note: don't set fitsSystemWindows on this root element, set via code where necessary -->
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/simple_list"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ListView
        android:id="@+id/listview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:descendantFocusability="afterDescendants"
        android:scrollbarStyle="outsideOverlay" />

    <TextView
        android:id="@+id/list_empty"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center_horizontal"
        android:layout_marginTop="40dp"
        android:textStyle="italic"
        android:textSize="15sp"
        android:text="@string/list_is_empty">
    </TextView>
</RelativeLayout>

```

`app/src/main/res/layout/simple_list_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <include
        layout="@layout/simple_list" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/status.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"

    android:layout_height="wrap_content"
    android:layout_width="match_parent"
    android:orientation="vertical">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/main_screen"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingBottom="10dp"
        tools:context="com.emanuelef.remote_capture.activities.MainActivity">

        <LinearLayout
            android:id="@+id/collector_info_layout"
            android:orientation="horizontal"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="50dp"
            android:gravity="center"
            android:visibility="gone"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@id/status_view">

            <TextView
                android:id="@+id/collector_info_text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:autoLink="web"
                tools:text="Collector Info" />

            <ImageView
                android:id="@+id/collector_info_icon"
                android:adjustViewBounds="false"
                android:layout_width="24dp"
                android:layout_height="match_parent"
                android:layout_marginVertical="1dp"
                android:layout_marginHorizontal="2dp"
                tools:src="@drawable/ic_apps"
                tools:tint="?attr/colorAccent" />
        </LinearLayout>

        <TextView
            android:id="@+id/interface_info"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="20dp"
            android:gravity="center"
            tools:text="Capturing from eth0..."
            tools:visibility="gone"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@id/collector_info_layout" />

        <TextView
            android:id="@+id/status_view"
            android:layout_width="210dp"
            android:layout_height="210dp"
            android:layout_marginTop="50dp"
            android:background="@drawable/rounded_bg"
            android:gravity="center"
            android:text="@string/ready"
            android:textSize="30sp"
            android:focusable="false"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.5"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

        <LinearLayout
            android:id="@+id/quick_settings"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_marginTop="35dp"
            android:padding="10dp"
            app:layout_constraintTop_toBottomOf="@id/status_view"
            app:layout_constraintStart_toStartOf="parent">

            <androidx.appcompat.widget.AppCompatSpinner
                android:id="@+id/dump_mode_spinner"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:spinnerMode="dialog"
                tools:listitem="@layout/quick_settings_item"
                android:prompt="@string/traffic_dump"/>

            <RelativeLayout
                android:layout_width="match_parent"
                android:layout_height="match_parent">

                <include
                    android:id="@+id/app_filter_text"
                    layout="@layout/quick_settings_item"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_marginEnd="50dp" />

                <androidx.appcompat.widget.SwitchCompat
                    android:id="@+id/app_filter_switch"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_centerInParent="true" />

                <TextView
                    android:id="@+id/app_filter_root_decryption_warning"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_below="@id/app_filter_text"
                    android:paddingHorizontal="10dp"
                    android:layout_marginTop="5dp"
                    android:text="@string/decryption_no_filter_warn"
                    android:textColor="@color/warning"
                    android:textSize="14sp" />
            </RelativeLayout>
        </LinearLayout>
    </androidx.constraintlayout.widget.ConstraintLayout>
</ScrollView>
```

`app/src/main/res/layout/tabs_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <LinearLayout
        app:layout_behavior="com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <com.google.android.material.tabs.TabLayout
                android:id="@+id/tablayout"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                app:tabTextColor="@color/colorTabText"
                app:tabSelectedTextColor="@color/colorTabTextSelected"
                app:tabIndicatorColor="@color/colorTab"
                app:tabMaxWidth="0dp"
                app:tabGravity="fill" />

            <ImageButton
                android:id="@+id/tab_switch_button"
                android:layout_width="42dp"
                android:layout_height="42dp"
                android:layout_gravity="center_vertical"
                android:padding="8dp"
                android:src="@drawable/ic_swap_horiz"
                android:tint="@color/colorTabTextSelected"
                android:background="@drawable/tab_switch_button_background"
                android:contentDescription="@string/switch_to_http"
                android:visibility="gone"
                android:focusable="true"
                android:clickable="true" />
        </LinearLayout>

        <androidx.viewpager2.widget.ViewPager2
            android:id="@+id/pager"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1" />
    </LinearLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/layout/tabs_activity_fixed.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/app_bar_layout">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:background="@color/colorActionBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:theme="@style/AppBarOverlay"
            app:popupTheme="@style/PopupOverlay" />
    </com.google.android.material.appbar.AppBarLayout>

    <LinearLayout
        app:layout_behavior="com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <com.google.android.material.tabs.TabLayout
            android:id="@+id/tablayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:tabTextColor="@color/colorTabText"
            app:tabSelectedTextColor="@color/colorTabTextSelected"
            app:tabIndicatorColor="@color/colorTab"
            app:tabMode="scrollable"
            app:tabGravity="start" />

        <androidx.viewpager2.widget.ViewPager2
            android:id="@+id/pager"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1" />
    </LinearLayout>
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

`app/src/main/res/menu/about_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/build_info"
        android:title="@string/build_info"
        android:orderInCategory="5"
        android:icon="@drawable/ic_info"
        app:showAsAction="ifRoom" />
    <item
        android:id="@+id/on_boarding"
        android:title="@string/welcome_to_pcapdroid"
        android:orderInCategory="10"
        app:showAsAction="never" />
    <item
        android:id="@+id/paid_features"
        android:title="@string/paid_features"
        android:orderInCategory="20"
        app:showAsAction="never" />
</menu>

```

`app/src/main/res/menu/app_context_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <item
        android:id="@+id/block_app"
        android:title="@string/action_block" />
    <item
        android:id="@+id/add_to_fw_whitelist"
        android:title="@string/add_to_fw_whitelist"
        tools:visible="true"
        android:visible="false" />
    <item
        android:id="@+id/remove_from_fw_whitelist"
        android:title="@string/remove_from_fw_whitelist"
        android:visible="false" />

    <item
        android:id="@+id/unblock_app_permanently"
        android:title="@string/unblock_permanently" />
    <item
        android:id="@+id/unblock_app_10m"
        android:title="" />
    <item
        android:id="@+id/unblock_app_1h"
        android:title="" />
    <item
        android:id="@+id/unblock_app_8h"
        android:title="" />
</menu>
```

`app/src/main/res/menu/app_overview_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/app_info"
        android:title="@string/app_info"
        android:orderInCategory="5"
        android:icon="@drawable/ic_settings"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/copy_to_clipboard"
        android:title="@string/copy_to_clipboard"
        android:orderInCategory="10"
        android:icon="@drawable/ic_content_copy"
        app:showAsAction="never" />

    <item
        android:id="@+id/share"
        android:title="@string/share"
        android:orderInCategory="20"
        android:icon="@drawable/ic_share"
        app:showAsAction="never" />
</menu>
```

`app/src/main/res/menu/apps_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:title="@string/sort_by"
        android:icon="@drawable/ic_sort"
        app:showAsAction="ifRoom">
        <menu>
            <group android:id="@+id/sort_by" android:checkableBehavior="single">
                <item android:id="@+id/sort_by_name"
                    android:title="@string/app_name"/>
                <item android:id="@+id/sort_by_total_bytes"
                    android:title="@string/total_bytes"/>
                <item android:id="@+id/sort_by_bytes_sent"
                    android:title="@string/bytes_sent"/>
                <item android:id="@+id/sort_by_bytes_rcvd"
                    android:title="@string/bytes_rcvd"/>
            </group>
        </menu>
    </item>

    <item
        android:id="@+id/reset"
        android:title="@string/reset"
        android:icon="@drawable/ic_reset"
        app:showAsAction="ifRoom"/>
</menu>
```

`app/src/main/res/menu/blacklists_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/update"
        android:title="@string/update_now"
        android:orderInCategory="10"
        android:icon="@drawable/ic_refresh"
        app:showAsAction="ifRoom" />
</menu>
```

`app/src/main/res/menu/connection_context_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <item
        android:id="@+id/select_connection"
        android:title="@string/select"
        android:orderInCategory="0" />

    <item
        android:title="@string/hide">
        <menu>
            <item
                android:id="@+id/hide_app"
                android:title=""
                tools:title="@string/app_val"
                android:visible="false" />

            <item
                android:id="@+id/hide_ip"
                android:title=""
                tools:title="@string/ip_address_val" />

            <item
                android:id="@+id/hide_host"
                android:title=""
                tools:title="@string/host_val"
                android:visible="false" />

            <item
                android:id="@+id/hide_domain"
                android:title=""
                tools:title="@string/host_val"
                android:visible="false" />

            <item
                android:id="@+id/hide_proto"
                android:title=""
                tools:title="@string/protocol_val" />

            <item
                android:id="@+id/hide_country"
                android:title=""
                tools:title="@string/country_val"
                android:visible="false" />
        </menu>
    </item>

    <item android:id="@+id/block_menu" android:title="@string/block">
        <menu>
            <item
                android:id="@+id/block_app"
                android:title=""
                tools:title="@string/app_val"
                android:visible="false" />

            <item
                android:id="@+id/block_ip"
                android:title=""
                tools:title="@string/ip_address_val" />

            <item
                android:id="@+id/block_host"
                android:title=""
                tools:title="@string/host_val"
                android:visible="false" />

            <item
                android:id="@+id/block_domain"
                android:title=""
                tools:title="@string/host_val"
                android:visible="false" />

            <item
                android:id="@+id/block_country"
                android:title=""
                tools:title="@string/country_val"
                android:visible="false" />
        </menu>
    </item>

    <item android:id="@+id/unblock_menu" android:title="@string/unblock">
        <menu>
            <item
                android:id="@+id/unblock_app"
                android:title=""
                tools:title="@string/app_val"
                android:visible="false">

                <menu>
                    <item
                        android:id="@+id/unblock_app_permanently"
                        android:title="@string/unblock_permanently" />
                    <item
                        android:id="@+id/unblock_app_10m"
                        android:title="" />
                    <item
                        android:id="@+id/unblock_app_1h"
                        android:title="" />
                    <item
                        android:id="@+id/unblock_app_8h"
                        android:title="" />
                </menu>
            </item>

            <item
                android:id="@+id/unblock_ip"
                android:title=""
                tools:title="@string/ip_address_val" />

            <item
                android:id="@+id/unblock_host"
                android:title=""
                tools:title="@string/host_val"
                android:visible="false" />

            <item
                android:id="@+id/unblock_domain"
                android:title=""
                tools:title="@string/host_val"
                android:visible="false" />

            <item
                android:id="@+id/unblock_country"
                android:title=""
                tools:title="@string/country_val"
                android:visible="false" />
        </menu>
    </item>

    <item
        android:id="@+id/add_to_fw_whitelist"
        android:title="@string/add_to_fw_whitelist"
        tools:visible="true"
        android:visible="false" />
    <item
        android:id="@+id/remove_from_fw_whitelist"
        android:title="@string/remove_from_fw_whitelist"
        android:visible="false" />

    <item android:title="@string/search">
        <menu>
            <item
                android:id="@+id/search_app"
                android:title=""
                tools:title="@string/app_val" />

            <item
                android:id="@+id/search_ip"
                android:title=""
                tools:title="@string/ip_address_val" />

            <item
                android:id="@+id/search_host"
                android:title=""
                tools:title="@string/host_val"
                android:visible="false" />

            <item
                android:id="@+id/search_proto"
                android:title=""
                tools:title="@string/protocol_val" />
        </menu>
    </item>

    <item android:title="@string/copy_action">
        <menu>
            <item
                android:id="@+id/copy_ip"
                android:title=""
                tools:title="@string/ip_address_val" />

            <item
                android:id="@+id/copy_host"
                android:title=""
                tools:title="@string/host_val"
                android:visible="false" />

            <item
                android:id="@+id/copy_url"
                android:title=""
                android:visible="false" />

            <item
                android:id="@+id/copy_http_request"
                android:title="@string/string_http_request"
                android:visible="false" />

            <item
                android:id="@+id/copy_http_response"
                android:title="@string/string_http_response"
                android:visible="false" />
        </menu>
    </item>

    <item android:id="@+id/decrypt_menu" android:title="@string/decrypt_action">
        <menu>
            <item
                android:id="@+id/dec_add_app"
                android:title=""
                android:visible="false"
                tools:title="@string/app_val" />

            <item
                android:id="@+id/dec_add_ip"
                android:title=""
                android:visible="false"
                tools:title="@string/ip_address_val" />

            <item
                android:id="@+id/dec_add_host"
                android:title=""
                android:visible="false"
                tools:title="@string/host_val" />
        </menu>
    </item>

    <item android:id="@+id/dont_decrypt_menu" android:title="@string/dont_decrypt_action">
        <menu>
            <item
                android:id="@+id/dec_rem_app"
                android:title=""
                android:visible="false"
                tools:title="@string/app_val" />

            <item
                android:id="@+id/dec_rem_ip"
                android:title=""
                android:visible="false"
                tools:title="@string/ip_address_val" />

            <item
                android:id="@+id/dec_rem_host"
                android:title=""
                android:visible="false"
                tools:title="@string/host_val" />
        </menu>
    </item>

    <item android:id="@+id/mw_whitelist_menu" android:title="@string/malware_whitelist_action">
        <menu>
            <item
                android:id="@+id/mw_whitelist_app"
                android:title=""
                android:visible="false"
                tools:title="@string/app_val" />

            <item
                android:id="@+id/mw_whitelist_ip"
                android:title=""
                android:visible="false"
                tools:title="@string/ip_address_val" />

            <item
                android:id="@+id/mw_whitelist_host"
                android:title=""
                android:visible="false"
                tools:title="@string/host_val" />
        </menu>
    </item>

    <item
        android:id="@+id/open_app_details"
        android:title="@string/app_details" />
</menu>
```

`app/src/main/res/menu/connection_details_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/navigate_before"
        android:title="@string/previous"
        android:orderInCategory="10"
        android:icon="@drawable/ic_navigate_before"
        app:showAsAction="always" />

    <item
        android:id="@+id/navigate_next"
        android:title="@string/next"
        android:orderInCategory="20"
        android:icon="@drawable/ic_navigate_next"
        app:showAsAction="always" />

    <!-- Menu items for ConnectionOverview fragment -->
    <item
        android:id="@+id/copy_to_clipboard"
        android:title="@string/copy_to_clipboard"
        android:orderInCategory="30"
        android:icon="@drawable/ic_content_copy"
        app:showAsAction="ifRoom"
        android:visible="false" />

    <item
        android:id="@+id/share"
        android:title="@string/share"
        android:orderInCategory="40"
        android:icon="@drawable/ic_share"
        app:showAsAction="ifRoom"
        android:visible="false" />

    <!-- Menu items for ConnectionPayload fragment -->
    <item
        android:id="@+id/display_as"
        android:title="@string/display_as_text"
        android:orderInCategory="50"
        android:icon="@drawable/ic_short_text"
        app:showAsAction="never"
        android:visible="false" />
</menu>

```

`app/src/main/res/menu/connections_cab.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item android:id="@+id/select_all"
        android:title="@string/select_all"
        android:orderInCategory="10"
        android:icon="@drawable/ic_select_all"
        app:showAsAction="ifRoom" />
    <item android:id="@+id/save"
        android:title="@string/save_to_file"
        android:orderInCategory="20"
        android:icon="@drawable/ic_save"
        app:showAsAction="ifRoom" />
</menu>

```

`app/src/main/res/menu/connections_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:tools="http://schemas.android.com/tools"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <!-- NOTE: "always|collapseActionView" must be set to prevent the search button from
         disappearing and to avoid hiding the other elements. -->
    <item
        android:id="@+id/search"
        android:title="@string/search"
        android:icon="@drawable/ic_search"
        android:orderInCategory="15"
        app:actionViewClass="androidx.appcompat.widget.SearchView"
        app:showAsAction="always|collapseActionView"
        tools:ignore="AlwaysShowAction" />

    <item
        android:id="@+id/edit_filter"
        android:title="@string/edit_filter"
        android:icon="@drawable/ic_filter"
        android:orderInCategory="20"
        app:showAsAction="always">
    </item>

    <item
        android:id="@+id/save"
        android:title="@string/save_to_file"
        android:orderInCategory="30"
        android:icon="@drawable/ic_save"
        app:showAsAction="never" />

    <item
        android:id="@+id/switch_to_http_log"
        android:visible="false" />
</menu>
```

`app/src/main/res/menu/copy_share_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/copy_to_clipboard"
        android:title="@string/copy_to_clipboard"
        android:orderInCategory="10"
        android:icon="@drawable/ic_content_copy"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/share"
        android:title="@string/share"
        android:orderInCategory="20"
        android:icon="@drawable/ic_share"
        app:showAsAction="ifRoom" />
</menu>
```

`app/src/main/res/menu/ctrl_permissions_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/user_guide"
        android:title="@string/user_guide"
        android:orderInCategory="10"
        android:icon="@drawable/ic_book"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/show_api_key"
        android:title="@string/show_api_key"
        android:orderInCategory="20"
        app:showAsAction="never" />

    <item
        android:id="@+id/generate_api_key"
        android:title="@string/generate_api_key"
        android:orderInCategory="20"
        app:showAsAction="never" />
</menu>
```

`app/src/main/res/menu/docs_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/user_guide"
        android:title="@string/user_guide"
        android:orderInCategory="10"
        android:icon="@drawable/ic_book"
        app:showAsAction="ifRoom" />
</menu>
```

`app/src/main/res/menu/edit_filter_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/reset_changes"
        android:title="@string/reset"
        android:icon="@drawable/ic_reset"
        app:showAsAction="ifRoom" />
</menu>
```

`app/src/main/res/menu/firewall_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/toggle_btn"
        android:title=""
        android:orderInCategory="10"
        app:showAsAction="always"
        app:actionViewClass="androidx.appcompat.widget.SwitchCompat" />

    <item
        android:id="@+id/user_guide"
        android:title="@string/user_guide"
        android:orderInCategory="20"
        android:icon="@drawable/ic_book"
        app:showAsAction="never" />

    <item
        android:id="@+id/whitelist_mode"
        android:title="@string/whitelist_mode"
        android:orderInCategory="25"
        android:checkable="true"
        app:showAsAction="never" />

    <item
        android:id="@+id/block_new_apps"
        android:title="@string/block_new_apps"
        android:orderInCategory="30"
        android:checkable="true"
        app:showAsAction="never" />
</menu>
```

`app/src/main/res/menu/hint_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/show_hint"
        android:title="@string/hint"
        android:orderInCategory="5"
        android:icon="@drawable/ic_info"
        app:showAsAction="ifRoom" />
</menu>

```

`app/src/main/res/menu/http_details_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/navigate_before"
        android:title="@string/previous"
        android:orderInCategory="10"
        android:icon="@drawable/ic_navigate_before"
        app:showAsAction="always" />

    <item
        android:id="@+id/navigate_next"
        android:title="@string/next"
        android:orderInCategory="20"
        android:icon="@drawable/ic_navigate_next"
        app:showAsAction="always" />

    <item
        android:id="@+id/display_as"
        android:title="@string/display_as_text"
        android:orderInCategory="30"
        android:icon="@drawable/ic_short_text"
        app:showAsAction="never"
        android:visible="false" />

    <item
        android:id="@+id/save_as_har"
        android:title="@string/save_as_har"
        android:orderInCategory="40"
        app:showAsAction="never" />
</menu>

```

`app/src/main/res/menu/http_log_cab.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item android:id="@+id/select_all"
        android:title="@string/select_all"
        android:orderInCategory="10"
        android:icon="@drawable/ic_select_all"
        app:showAsAction="ifRoom" />
    <item android:id="@+id/save"
        android:title="@string/save_as_text"
        android:orderInCategory="20"
        android:icon="@drawable/ic_save"
        app:showAsAction="ifRoom" />
    <item android:id="@+id/save_as_har"
        android:title="@string/save_as_har"
        android:orderInCategory="30"
        app:showAsAction="never" />
</menu>

```

`app/src/main/res/menu/http_log_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:tools="http://schemas.android.com/tools"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <!-- NOTE: "always|collapseActionView" must be set to prevent the search button from
         disappearing and to avoid hiding the other elements. -->
    <item
        android:id="@+id/search"
        android:title="@string/search"
        android:icon="@drawable/ic_search"
        android:orderInCategory="15"
        app:actionViewClass="androidx.appcompat.widget.SearchView"
        app:showAsAction="always|collapseActionView"
        tools:ignore="AlwaysShowAction" />

    <item
        android:id="@+id/edit_filter"
        android:title="@string/edit_filter"
        android:icon="@drawable/ic_filter"
        android:orderInCategory="20"
        app:showAsAction="always">
    </item>

    <item
        android:id="@+id/save"
        android:title="@string/save_as_text"
        android:orderInCategory="30"
        android:icon="@drawable/ic_save"
        app:showAsAction="never" />

    <item
        android:id="@+id/save_as_har"
        android:title="@string/save_as_har"
        android:orderInCategory="31"
        app:showAsAction="never" />

    <item
        android:id="@+id/switch_to_connections"
        android:visible="false" />
</menu>
```

`app/src/main/res/menu/list_edit_cab.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/select_all"
        android:title="@string/select_all"
        android:orderInCategory="10"
        android:icon="@drawable/ic_select_all"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/delete_entry"
        android:title="@string/delete"
        android:orderInCategory="20"
        android:icon="@android:drawable/ic_menu_delete"
        app:showAsAction="ifRoom" />
</menu>
```

`app/src/main/res/menu/list_edit_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/show_hint"
        android:title="@string/hint"
        android:orderInCategory="10"
        android:icon="@drawable/ic_help"
        app:showAsAction="ifRoom" />

    <item
        android:title="@string/add_action"
        android:orderInCategory="15"
        android:icon="@drawable/ic_add"
        app:showAsAction="ifRoom">
        <menu>
            <item
                android:id="@+id/add_app"
                android:title="@string/app"
                android:visible="false" />
            <item
                android:id="@+id/add_host"
                android:title="@string/host"
                android:visible="false" />
            <item
                android:id="@+id/add_ip"
                android:title="@string/ip_address_or_cidr"
                android:visible="false" />
            <item
                android:id="@+id/add_proto"
                android:title="@string/protocol"
                android:visible="false" />
            <item
                android:id="@+id/add_country"
                android:title="@string/country"
                android:visible="false" />
        </menu>
    </item>

    <item
        android:id="@+id/action_export"
        android:title="@string/export_action"
        android:orderInCategory="18"
        android:icon="@drawable/ic_file_export"
        app:showAsAction="never" />

    <item
        android:id="@+id/action_import"
        android:title="@string/import_action"
        android:orderInCategory="19"
        android:icon="@drawable/ic_file_import"
        app:showAsAction="never" />

    <item
        android:id="@+id/copy_to_clipboard"
        android:title="@string/copy_to_clipboard"
        android:orderInCategory="20"
        android:icon="@drawable/ic_content_copy"
        app:showAsAction="never" />

    <item
        android:id="@+id/share"
        android:title="@string/share"
        android:orderInCategory="30"
        android:icon="@drawable/ic_share"
        app:showAsAction="never" />
</menu>
```

`app/src/main/res/menu/log_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/reload"
        android:title="@string/update_now"
        android:orderInCategory="5"
        android:icon="@drawable/ic_refresh"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/copy_to_clipboard"
        android:title="@string/copy_to_clipboard"
        android:orderInCategory="10"
        android:icon="@drawable/ic_content_copy"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/share"
        android:title="@string/share"
        android:orderInCategory="20"
        android:icon="@drawable/ic_share"
        app:showAsAction="ifRoom" />
</menu>
```

`app/src/main/res/menu/main_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/action_start"
        android:title="@string/start_button"
        android:orderInCategory="10"
        android:icon="@drawable/ic_play_arrow"
        app:showAsAction="always" />

    <item
        android:id="@+id/action_stop"
        android:title="@string/stop_button"
        android:orderInCategory="20"
        android:icon="@drawable/ic_media_stop"
        android:visible="false"
        app:showAsAction="always" />

    <item
        android:id="@+id/action_settings"
        android:title="@string/title_activity_settings"
        android:orderInCategory="30"
        android:icon="@drawable/ic_settings"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/open_pcap"
        android:title="@string/open_pcap_file"
        android:enabled="true"
        app:showAsAction="never" />

    <item
        android:id="@+id/decrypt_pcap"
        android:title="@string/decrypt_pcap_file"
        android:enabled="true"
        app:showAsAction="never" />
</menu>

```

`app/src/main/res/menu/nav_items.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <group android:id="@+id/group_app">
        <item
            android:id="@+id/item_apps"
            android:title="@string/apps"
            android:icon="@drawable/ic_apps" />
        <item
            android:id="@+id/action_stats"
            android:title="@string/stats"
            android:icon="@drawable/ic_stacked_bar_chart" />
        <item
            android:id="@+id/tls_decryption"
            android:title="@string/decryption_rules"
            android:icon="@drawable/ic_lock_open_alt" />
        <item
            android:id="@+id/firewall"
            android:title="@string/firewall"
            android:icon="@drawable/ic_shield" />
        <item
            android:id="@+id/malware_detection"
            android:title="@string/malware_detection"
            android:icon="@drawable/ic_bug" />
        <item
            android:id="@+id/open_log"
            android:title="@string/app_log"
            android:icon="@drawable/ic_text_snippet" />
        <item
            android:id="@+id/paid_features"
            android:visible="false"
            android:title="@string/paid_features"
            android:icon="@drawable/ic_money" />
    </group>
    <group android:id="@+id/group_social">
        <item
            android:id="@+id/action_open_user_guide"
            android:title="@string/user_guide"
            android:icon="@drawable/ic_book" />
        <item
            android:id="@+id/action_donate"
            android:title="@string/donate"
            android:icon="@drawable/ic_money" />
        <item
            android:id="@+id/action_share_app"
            android:title="@string/share"
            android:icon="@drawable/ic_share" />
        <item
            android:id="@+id/action_open_telegram"
            android:title="@string/open_telegram_group"
            android:icon="@drawable/ic_telegram" />
        <item
            android:id="@+id/action_about"
            android:title="@string/about"
            android:icon="@drawable/ic_copyright" />
    </group>
</menu>
```

`app/src/main/res/menu/port_mapping_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/toggle_btn"
        android:title=""
        android:orderInCategory="10"
        app:showAsAction="always"
        app:actionViewClass="androidx.appcompat.widget.SwitchCompat" />

    <item
        android:id="@+id/add_mapping"
        android:title="@string/add_action"
        android:orderInCategory="20"
        android:icon="@drawable/ic_add"
        app:showAsAction="ifRoom" />
</menu>

```

`app/src/main/res/menu/search_menu.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:tools="http://schemas.android.com/tools"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/search"
        android:title="@string/search"
        android:icon="@drawable/ic_search"
        app:actionViewClass="androidx.appcompat.widget.SearchView"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/show_system_apps"
        android:title="@string/show_system_apps"
        android:checkable="true"
        app:showAsAction="never" />
</menu>
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
    <monochrome android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
    <monochrome android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon>
```

`app/src/main/res/navigation/mitm_wizard_graph.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/mitm_wizard_graph"
    app:startDestination="@id/intro">

    <fragment
        android:id="@+id/intro"
        android:name="com.emanuelef.remote_capture.fragments.mitmwizard.Intro"
        tools:layout="@layout/fragment_mitm_wizard" >
        <action
            android:id="@+id/navto_install_addon"
            app:enterAnim="@anim/slide_in_left"
            app:exitAnim="@anim/slide_out_left"
            app:popEnterAnim="@anim/slide_in_right"
            app:popExitAnim="@anim/slide_out_right"
            app:destination="@id/installMitmApp" />
    </fragment>

    <fragment
        android:id="@+id/installMitmApp"
        android:name="com.emanuelef.remote_capture.fragments.mitmwizard.InstallAddon"
        tools:layout="@layout/fragment_mitm_wizard" >
        <action
            android:id="@+id/navto_install_cert"
            app:enterAnim="@anim/slide_in_left"
            app:exitAnim="@anim/slide_out_left"
            app:popEnterAnim="@anim/slide_in_right"
            app:popExitAnim="@anim/slide_out_right"
            app:destination="@id/InstallCertificate" />
    </fragment>

    <fragment
        android:id="@+id/InstallCertificate"
        android:name="com.emanuelef.remote_capture.fragments.mitmwizard.InstallCertificate"
        tools:layout="@layout/fragment_mitm_wizard">
        <action
            android:id="@+id/navto_done"
            app:enterAnim="@anim/slide_in_left"
            app:exitAnim="@anim/slide_out_left"
            app:popEnterAnim="@anim/slide_in_right"
            app:popExitAnim="@anim/slide_out_right"
            app:destination="@id/Done" />
    </fragment>

    <fragment
        android:id="@+id/Done"
        android:name="com.emanuelef.remote_capture.fragments.mitmwizard.Done"
        tools:layout="@layout/fragment_mitm_wizard" />
</navigation>
```

`app/src/main/res/resources.properties`:

```properties
unqualifiedResLocale=en-US

```

`app/src/main/res/values-ar/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">بدأ</string>
    <string name="title_activity_settings">الإعدادات</string>
    <string name="source">مصدر</string>
    <string name="no_dump_info">لن يتم تفريغ حركة المرور</string>
    <string name="dns_server">خادم DNS</string>
    <string name="traffic_dump">تفريغ حركة المرور</string>
    <string name="stats">احصائيات</string>
    <string name="open_telegram_group">مجموعة تيليغرام</string>
    <string name="active_connections">اتصالات النشطة</string>
    <string name="dns_queries">الاستعلامات DNS</string>
    <string name="stop_button">إقاف</string>
    <string name="collector_info">جامع UDP: %1$s:%2$d</string>
    <string name="http_server_status">خادم HTTP: http://%1$s:%2$d</string>
    <string name="query">استعلام</string>
    <string name="host">استضافة</string>
    <string name="ready">مستعد</string>
    <string name="status">الحالة</string>
    <string name="about">حول</string>
    <string name="connections_view">الاتصالات</string>
    <string name="no_connections">لا اتصالات</string>
    <string name="connection_details">تفاصيل الاتصال</string>
    <string name="app">تطبيق</string>
    <string name="protocol">بروتوكول</string>
    <string name="destination">الوجهة</string>
    <string name="packets">الحِزم</string>
    <string name="duration">مدة</string>
    <string name="http_server">خادم HTTP</string>
    <string name="udp_exporter">مُصدر UDP</string>
    <string name="no_dump">لا تفريغ</string>
    <string name="http_server_info">ابدأ خادم HTTP لتنزيل PCAP</string>
    <string name="udp_exporter_info">أرسل PCAP إلى جهاز استقبال UDP بعيد</string>
    <string name="http_server_port">منفذ خادم HTTP</string>
    <string name="receiver_ip_address">عنوان IP للمجمع</string>
    <string name="receiver_port">منفذ جامع</string>
    <string name="user_guide">دليل المستخدم</string>
    <string name="source_code">الشيفرة المصدرية</string>
    <string name="yes">نعم</string>
    <string name="no">لا</string>
    <string name="vpn_setup_failed">تعذر إعداد VPN. تأكد من تعطيل Always-on VPN</string>
    <string name="app_not_found">تعذر العثور على تطبيق %1$s</string>
    <string name="dropped_connections">اتصالات مقطوعة</string>
    <string name="tot_connections">إجمالي الاتصالات</string>
    <string name="open_sockets">مآخذ مفتوحة</string>
    <string name="bytes_sent">البايت المرسلة</string>
    <string name="bytes_rcvd">البايتات المستقبَلة</string>
    <string name="packets_sent">الحزم المرسلة</string>
    <string name="packets_rcvd">الحزم المستقبَلة</string>
    <string name="search_apps">ابحث في التطبيقات</string>
    <string name="no_apps">ليس هناك تطبيقات</string>
    <string name="apps">التطبيقات</string>
    <string name="pcap_file">ملف PCAP</string>
    <string name="rcvd_and_sent">استقبلت %1$s - ارسلت %2$s</string>
    <string name="notification_msg">%1$s ملتقط و %2$s اتصالات</string>
    <string name="get_app">أحصل عليه:</string>
    <string name="pcap_file_info">أنشئ ملف Pcapng/PCAP في مساحة تخزين الجهاز</string>
    <string name="cannot_write_file">لا يمكن كتابة الملف</string>
    <string name="ok">حسناً</string>
    <string name="share">مشاركة</string>
    <string name="pcap_file_action">حُفظت حركة المرور في ملف %1$s (%2$s)</string>
    <string name="delete">حذف</string>
    <string name="copy_error">تعذر كتابة الملف</string>
    <string name="capture_running">الالتقاط يعمل</string>
    <string name="conn_status_active">مفعّل</string>
    <string name="first_seen">أول ظهور</string>
    <string name="conn_status_closed">مغلق</string>
    <string name="last_seen">آخر ظهور</string>
    <string name="copy_to_clipboard">نسخ</string>
    <string name="save_to_file">حفظ إلى الملف</string>
    <string name="older_connections_notice">%1$d اتصالات قديمة غير معروضة</string>
    <string name="about_text">PCAPdroid هي أداة التقاط ومراقبة للشبكة مفتوحة المصدر تعمل بدون امتيازات الجذر</string>
    <string name="delete_error">لا يمكن حذف الملف</string>
    <string name="socks5_auth">مصادقة SOCKS5</string>
    <string name="socks5_auth_summary">قم بالمصادقة على الوكيل عبر اسم المستخدم وكلمة المرور</string>
    <string name="proxy_port">منفذ الوكيل</string>
    <string name="select_all">اختيار الكل</string>
    <string name="target_sdk">SDK المستهدفة</string>
    <string name="installed_on">مثبت على</string>
    <string name="last_update">آخر تحديث</string>
    <string name="permissions">الأذونات</string>
    <string name="android_app_info">نظام الاندرويد</string>
    <string name="capture_prefs">إلتقاط</string>
    <string name="capturing_from">التقاط الحزم من \"%1$s\"</string>
    <string name="malicious_connection_filter">ضارة</string>
    <string name="status_outdated">غير مُحدّث</string>
    <string name="status_not_loaded">غير محمل</string>
    <string name="connections_checked">تم فحص الإتصالات</string>
    <string name="update_now">تحديث الان</string>
    <string name="valid">صالح</string>
    <string name="copied">تم نسخّه</string>
    <string name="install_the_mitm_addon">ثبّت PCAPdroid <a href="%1$s">mitm إضافة</a></string>
    <string name="size_x">الحجم: %1$s</string>
    <string name="block_quick">حظر QUIC</string>
    <string name="welcome_to_pcapdroid">مرحبًا بك في PCAPdroid</string>
    <string name="app_intro_skip_button">تخطي</string>
    <string name="capture_stopped_low_memory">تم إيقاف الالتقاط</string>
    <string name="memory_usage">إستهلاك الذاكرة</string>
    <string name="ip_mode">عناوين VPN IP</string>
    <string name="notifications_notice">يستخدم التطبيق الإشعارات لإرسال تنبيهات في حالة وقوع أحداث شاذة. امنحه الإذن بإرسال الإشعارات في الشاشة التالية</string>
    <string name="cancel_action">إلغاء</string>
    <string name="warning">تحذير</string>
    <string name="show_action">عرض</string>
    <string name="port_mapping">تعيين منفذ</string>
    <string name="add_action">أضف</string>
    <string name="use_system_dns">استخدم نظام DNS</string>
    <string name="total_bytes">إجمالي البيتات</string>
    <string name="password">كلمة المرور</string>
    <string name="socks5_info">وكيل SOCKS5 : %1$s:%2$d</string>
    <string name="app_language">لغة التطبيق</string>
    <string name="phone_app">تطبيق الهاتف</string>
    <string name="unknown_app">غير معروف</string>
    <string name="other_prefs">آخر</string>
    <string name="system_default">النظام الافتراضي</string>
    <string name="conn_status_unreachable">لا يمكن الوصول إليه</string>
    <string name="no_activity_file_selection">لم يتم العثور على تطبيق للتعامل مع الملف المُختار</string>
    <string name="file_saved_with_name">تم حفظ الملف باسم \"%1$s\"</string>
    <string name="socks5_redirection">إعادة توجيه SOCKS5</string>
    <string name="socks5_summary">قم بتكوين إعادة التوجيه إلى وكيل SOCKS5</string>
    <string name="enable_socks5_proxy_summary">إعادة توجيه كافة اتصالات TCP إلى وكيل SOCKS5</string>
    <string name="search">البحث…</string>
    <string name="ip_address_val">عنوان IP: %1$s</string>
    <string name="proxy_host">مضيف الوكيل</string>
    <string name="app_val">التطبيق: %1$s</string>
    <string name="root_capture">الالتقاط باستخدام الجذر</string>
    <string name="root_capture_summary">يسمح لـ PCAPdroid بالعمل مع تطبيقات VPN الأخرى</string>
    <string name="donate">تبرّع</string>
    <string name="app_log">السجل</string>
    <string name="no_data">لا بيانات</string>
    <string name="host_val">المضيف : %1$s</string>
    <string name="protocol_val">بروتوكول : %1$s</string>
    <string name="malware_whitelist_action">القائمة البيضاء (البرامج الضارة)…</string>
    <string name="hide">إخفاء…</string>
    <string name="n_selected">%1$d المحدد</string>
    <string name="app_details">تفاصيل التطبيق</string>
    <string name="package_name">اسم الحزمة</string>
    <string name="uid">المُعرف</string>
    <string name="app_name">اسم</string>
    <string name="version">الإصدار</string>
    <string name="root_app_info">daemons النظام تعمل بأقصى قدر من الامتيازات</string>
    <string name="netd_app_info">يقوم daemons النظام بتنفيذ قرارات DNS</string>
    <string name="phone_app_info">الخدمات الهاتفية</string>
    <string name="unknown_app_info">يشير \"غير معروف\" إلى الاتصالات التي لا يمكن تحديد تطبيقها</string>
    <string name="packets_dropped">إسقاط الحزم</string>
    <string name="ctrl_consent_denied">pcapdroid: تم رفض طلب التحكم</string>
    <string name="allow">السماح</string>
    <string name="pending_transaction">يرجى إكمال معاملتك لاسترداد هذه الميزة</string>
    <string name="ctrl_consent">يريد أحد التطبيقات التقاط حركة مرور جهازك.
\nارفض ذلك إذا لم تكن متأكد</string>
    <string name="ctrl_consent_title">طلب التحكم في PCAPdroid</string>
    <string name="deny">رفض</string>
    <string name="ctrl_consent_allowed">pcapdroid: تم السماح بطلب التحكم</string>
    <string name="capture_interface">‌واجهة الالتقاط</string>
    <string name="internet">الإنترنت</string>
    <string name="all_interfaces">‌جميع الواجهات</string>
    <string name="edit_filter">تعديل التصفية</string>
    <string name="edit_list">تعديل القائمة</string>
    <string name="hidden_connections_rules">قواعد الاتصالات المخفية</string>
    <string name="list_is_empty">القائمة فارغة</string>
    <string name="show_only_cleartext">اتصالات النص الواضح</string>
    <string name="malware_detection">الكشف عن البرامج الضارة</string>
    <string name="malware_detection_summary">اكتشف الاتصالات بالمضيفين الضارين المعروفين عبر القوائم السوداء التابعة لجهات خارجية</string>
    <string name="show_only_malicious">اتصالات ضارة</string>
    <string name="security">الأمان</string>
    <string name="feature_not_available">هذه الميزة غير متاحة حاليًا لجهازك</string>
    <string name="reset">إعادة تعيين</string>
    <string name="malware_whitelist_rules">قواعد القائمة البيضاء للبرامج الضارة</string>
    <string name="billing_connecting">الاتصال بـ Google Play قيد التقدم، يرجى إعادة المحاولة بعد قليل</string>
    <string name="malware_whitelist_help">القائمة البيضاء المعرفة من قبل المستخدم لمنع اكتشاف البرامج الضارة. اضغط لفترة طويلة على الاتصالات الضارة لإنشاء قواعد لإلغاء تحديدها كبرامج ضارة</string>
    <string name="hidden_connections_help">قائمة القواعد لإخفاء إدخالات قائمة الاتصال حتى تتمكن من التركيز على الإدخالات ذات الصلة</string>
    <string name="not_hidden_filter">غير مخفي</string>
    <string name="status_filter">حالة HTTP: %1$s</string>
    <string name="show_me">أرِني</string>
    <string name="control_permissions">تحكم في الأذونات</string>
    <string name="country_val">البلد: %1$s</string>
    <string name="copy_action">نسخ…</string>
    <string name="country">الدولة</string>
    <string name="url_val">الرابط: %1$s</string>
    <string name="hint">تَلمِيح</string>
    <string name="start_at_boot">ابدأ عند التمهيد</string>
    <string name="start_at_boot_summary">يبدأ الالتقاط تلقائيًا بعد التمهيد</string>
    <string name="once">مرة واحِدة</string>
    <string name="forever">‎للأبد</string>
    <string name="control_permissions_summary">تحقق من التطبيقات المسموح لها بالتحكم في التقاط PCAPdroid</string>
    <string name="send_report">أرسل تقريراً</string>
    <string name="malware_status_ok">لم يتم اكتشاف أي حركة مرور ضارة</string>
    <string name="malware_status_detected">تم اكتشاف اتصالات ضارة</string>
    <string name="blacklists">القائمة السوداء</string>
    <string name="whitelist">القائمة البيضاء</string>
    <string name="status_uptodate">مُحدث</string>
    <string name="blacklist_type">النوع: %1$s</string>
    <string name="blacklist_type_ip">القائمة السوداء لعنوان IP</string>
    <string name="last_update_val">التحديث الأخير: %1$s</string>
    <string name="malicious_connections">اتصالات ضارة</string>
    <string name="updated_blacklists">القوائم السوداء المحدثة</string>
    <string name="last_blacklists_update">آخر تحديث</string>
    <string name="domain_rules">قواعد المجال</string>
    <string name="blacklist_type_domain">القائمة السوداء للمجال</string>
    <string name="n_rules">قواعد %1$s</string>
    <string name="malware_status_update_failed">بعض القوائم السوداء قديمة</string>
    <string name="ip_rules">قواعد عناوين IP</string>
    <string name="status_updating">جارٍ التحديث…</string>
    <string name="malware_detection_learn_more">تعرف المزيد حول ميزة الكشف عن البرامج الضارة</string>
    <string name="private_dns_message_notice">يمنع DNS الخاص PCAPdroid من فحص حركة مرور DNS. يمكنك إيقاف تشغيله من إعدادات شبكة Android</string>
    <string name="private_dns_hinders_detection">DNS الخاص يعيق الكشف</string>
    <string name="decryption_no_filter_warn">حدد تطبيقًا مستهدفًا عند فك تعمية TLS لتجنب فقدان اتصالك بالإنترنت</string>
    <string name="block">حظر…</string>
    <string name="blocked_pkts">محظور</string>
    <string name="validate">التحقق من صحة</string>
    <string name="unblock">رفع الحظر…</string>
    <string name="firewall">جدار الحِماية</string>
    <string name="firewall_rules">قواعد جدار الحِماية</string>
    <string name="blocked_connection_filter">محظور</string>
    <string name="allowed_connection_filter">مسمّوح</string>
    <string name="paid_features">الميزات المدفوعة</string>
    <string name="firewall_filter">جدار الحماية: %1$s</string>
    <string name="invalid">غير صالح</string>
    <string name="no_intent_handler_found">لم يتم العثور على تطبيق لتنفيذ هذا الإجراء</string>
    <string name="buy_action">شِراء</string>
    <string name="tls_decryption_summary">فك تعمية حركة مرور SSL/TLS عن طريق إجراء mitm. قد يعمل هذا الآن مع بعض التطبيقات، راجع دليل المستخدم</string>
    <string name="no_items_for_purchase">لا توجد عناصر متاحة للشراء</string>
    <string name="interface_filter">الواجهة: %1$s</string>
    <string name="network_interface">واجهة الشبكة</string>
    <string name="loading">تحميل…</string>
    <string name="purchased">تّم شِراؤها</string>
    <string name="billing_failure">تعذر الاتصال بـ Google Play. يرجى إعادة المحاولة بعد فترة</string>
    <string name="learn_more">تعلم المزيد</string>
    <string name="start_capture_first">ابدأ الإلتقاط أولاً</string>
    <string name="capture_not_running_status">الإلتقاط لا يعمل</string>
    <string name="can_use_purchased_feature">يُمكنك الآن إستخدام الميزة التي تم شراؤها</string>
    <string name="disconnect_vpn_confirm">سَيؤدي الإستمرار إلى قطع اتصال VPN النشط</string>
    <string name="close_nav_drawer">إغلاق الدرج</string>
    <string name="loading_apps">جارٍ تحميل التطبيقات…</string>
    <string name="capture_all_apps">إلتقاط حركة المرور لجميع التطبيقات</string>
    <string name="tls_decryption">فك تعمية TLS</string>
    <string name="open_nav_drawer">فتح الدرج</string>
    <string name="save_ok">حٌفظت</string>
    <string name="mitm_start_failed">لا يمكن بدء خدمة mitm. حاول فتح تطبيق إضافة mitm يدويًا ثم أعد المحاولة</string>
    <string name="mitm_setup_wizard">إعداد Mitm</string>
    <string name="install_action">ثَبَّتَ</string>
    <string name="export_action">تصدير</string>
    <string name="sort_by">الترتيب حسب</string>
    <string name="username">أسم المستخدم</string>
    <string name="write_ext_storage_failed">فشلت الكتابة إلى وحدة التخزين الخارجية. تحقق من سجل التطبيق للحصول على التفاصيل</string>
    <string name="mitm_addon_autostart_workaround">فشل الاتصال بالملحق mitm. كحل بديل، يمكنك محاولة فتح تطبيق mitm addon ثم العودة إلى PCAPdroid دون إغلاقه. هل تريد فتحه الآن؟</string>
    <string name="qr_license_confirm">هل تريد إنشاء ترخيص لجهاز \"%1$s\" باستخدام رمز إلغاء القفل التالي؟</string>
    <string name="invalid_license">ترخيص غير صالح</string>
    <string name="connection_error">خطأ في الاتصال: %1$s</string>
    <string name="activate_via_qr_code">تنشيط عبر رمز QR</string>
    <string name="qr_code_expired">انتهت صلاحية رمز QR. قم بإنشاء رمز QR جديد ثم أعِد المحاولة</string>
    <string name="qr_info_text">قم بتثبيت PCAPdroid من Google Play وقم بمسح رمز QR هذا ضوئيًا</string>
    <string name="qr_purchase_required">قم بشراء رمز إلغاء القفل لمتابعة تنشيط رمز QR</string>
    <string name="decryption_rules_help">تحدد هذه القواعد الاتصالات التي سيتم فك تعميتها. تعمل القواعد المستندة إلى المضيف فقط في حالة رؤية رد DNS سابق</string>
    <string name="pcap_read_error">خطأ في قراءة ملف الالتقاط. تحقق من السجل للحصول على التفاصيل</string>
    <string name="license_error">خطأ في إنشاء الترخيص [%1$d]: %2$s</string>
    <string name="license_limit_reached">لقد وصلت إلى الحد الأقصى للتراخيص لرمز إلغاء القفل هذا. قم بشراء رمز مميز جديد لإنشاء المزيد من التراخيص</string>
    <string name="mitm_addon_starting">يبدأ الملحق Mitm…</string>
    <string name="requesting_license">جارٍ طلب رمز الترخيص، يُرجى الأنتظار</string>
    <string name="license_activation_ok">إكتمل تفعيل الترخيص</string>
    <string name="mitm_addon_running">المُلحق Mitm قيد التشغيل</string>
    <string name="decrypt_action">فك تعمية…</string>
    <string name="dont_decrypt_action">لا تفك التعمية…</string>
    <string name="decryption_rules">قواعد فك التعمية</string>
    <string name="status_encrypted">مُعمّى</string>
    <string name="injected">حقن</string>
    <string name="open_pcap_file">افتح ملف Pcapng/PCAP…</string>
    <string name="pcap_load_success">ملف التقاط محمّل</string>
    <string name="invalid_pcap_file">تنسيق ملف الالتقاط غير صالح</string>
    <string name="root_capture_start_failed">التقاط فشل البداية. تأكد من أن الجهاز متجذر باستخدام Magisk</string>
    <string name="capture_interface_open_error">لا يمكن فتح واجهة الالتقاط</string>
    <string name="unsupported_pcap_datalink">يحتوي الملف على datalink غير مدعوم</string>
    <string name="pcap_file_not_exists">الملف المحدد غير موجود</string>
    <string name="pcap_file_load_aborted">تم إحباط تحميل الملف</string>
    <string name="host_resolution_failed">تعذر حل المضيف %1$s</string>
    <string name="pcapdroid_trailer_notice">لإظهار التطبيقات الفعلية بدلاً من \"%1$s\"، تأكد من تمكين الخيار \"%2$s\" قبل توليد التفريغ</string>
    <string name="decryption_info_no_rule">لفك تعمية هذا الاتصال، أنشئ قاعدة فك التعمية من الدرج الأيسر أو من القائمة السياقية في قائمة الاتصالات</string>
    <string name="error">خطأ</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="asn">ASN</string>
    <string name="export_ca_certificate">صدّر شهادة PCAPdroid CA، افتح إعدادات \"التشفير وبيانات الاعتماد\" لنظام Android واختر تثبيتها كـ \"شهادة CA\"</string>
    <string name="install_ca_certificate">قم بتثبيت شهادة PCAPdroid CA، واختيار \"VPN والتطبيقات\". سيطلب Android شاشة القفل أو كلمة مرورك</string>
    <string name="checking_the_certificate">جارِ التحقق من الشهادة…</string>
    <string name="ca_cert_export_failed">حدث خطأ أثناء تصدير شهادة CA
\n
\nإذا كان جهازك يستخدم برنامج التشغيل التلقائي أو برنامجًا مشابهًا للحد من تنفيذ خدمات الخلفية، فتأكد من <a href="%1$s">إضافة PCAPdroid إلى القائمة البيضاء</a></string>
    <string name="cert_exported_now_installed">تم تصدير الشهادة، قم بتثبيتها الآن من إعدادات Android</string>
    <string name="cert_installed_correctly">تم تثبيت شهادة CA</string>
    <string name="cert_reinstall_required">لم يتم تثبيت شهادة CA، قم بتشغيل معالج إعداد mitm</string>
    <string name="mitm_addon_bad_version">نُسخة إضافة PCAPdroid mitm سيئة. الرجاء تثبيت إصدار %1$s وإعادة المحاولة</string>
    <string name="mitm_addon_new_version">يجب ترقية إضافة PCAPdroid mitm</string>
    <string name="mitm_addon">المُلحق mitm</string>
    <string name="export_failed">فشل التصدير</string>
    <string name="overview">نظرة عامة</string>
    <string name="not_encrypted">غير مُعمّى</string>
    <string name="request">طلب</string>
    <string name="not_decryptable">غير قابل لفك التعمية</string>
    <string name="response">إستجابة</string>
    <string name="string_http_request">طلب HTTP</string>
    <string name="string_http_response">إستجابة HTTP</string>
    <string name="payload_truncated">يتم اقتطاع الحمولة. لإظهاره بالكامل، قم بإيقاف الالتقاط وتمكين \"%1$s\" من إعدادات PCAPdroid</string>
    <string name="websocket">ويب سوكت</string>
    <string name="http">HTTP</string>
    <string name="payload">الحمولة</string>
    <string name="full_payload">حمولة كاملة</string>
    <string name="full_payload_summary">إظهار حمولة الاتصالات الكاملة (على سبيل المثال، طلب HTTP الكامل والاستجابة له). وهذا يتطلب الكثير من الذاكرة، لا تستخدمها على المدى الطويل</string>
    <string name="decrypted">تم فك تعميتها</string>
    <string name="network_traffic">حركة المرور</string>
    <string name="decryption">فك التعمية</string>
    <string name="connection_start_not_seen">لم يشاهد PCAPdroid بداية هذا الاتصال. قد تكون بعض المعلومات مفقودة</string>
    <string name="warn_no_app_data">لم يتم تبادل أي بيانات التطبيق</string>
    <string name="decryption_filter">الحالة: %1$s</string>
    <string name="waiting_application_data">في انتظار البيانات</string>
    <string name="hexdump">تفريغ سداسي (Hexdump)</string>
    <string name="geolocation">تحديد الموقع الجغرافي</string>
    <string name="geolocation_summary">قم بعرض معلومات البلد ورقم ASN من خلال إجراء عمليات بحث في وضع عدم الاتصال</string>
    <string name="downloading">جارى التحميل…</string>
    <string name="download_in_progress">التنزيل قيد التقدم، يُرجى الأنتظار</string>
    <string name="download_failed">فشل التحميل</string>
    <string name="pcap_load_in_progress">التقاط الملف التحميل قيد التقدم، يُرجى الانتظار</string>
    <string name="geo_db_not_found">لم يتم العثور على قاعدة البيانات. تم تعطيل تحديد الموقع الجغرافي</string>
    <string name="database">قاعدة البيانات</string>
    <string name="built_on">مبني على: %1$s</string>
    <string name="geo_db_download">انقر لتنزيل أحدث قاعدة بيانات. قواعد بيانات جديدة متاحة شهريا</string>
    <string name="geo_db_delete">انقر لحذف قاعدة البيانات وتوفير المساحة</string>
    <string name="download">تحميل</string>
    <string name="connection_blocked">تم حظر هذا الاتصال بواسطة PCAPdroid</string>
    <string name="import_action">إستيراد</string>
    <string name="import_failed">فشل الأستيراد</string>
    <string name="invalid_backup">تنسيق النسخة الاحتياطية غير صالح</string>
    <string name="no_rules_to_export">لا توجد قواعد للتصدير</string>
    <string name="rules_import_success">تم استيراد %1$d من القواعد</string>
    <string name="rules_merge_msg">أبقِ القواعد الحالية؟</string>
    <string name="keep_action">أبقِها</string>
    <string name="rules_delete_confirm">حذف القواعد المُحددة؟</string>
    <string name="discard_action">أهمِل</string>
    <string name="blocklist">قائمة الحظر</string>
    <string name="num_configured_rules">القواعد التي تم تكوينها</string>
    <string name="connections_blocked">تم حظر الإتصالات</string>
    <string name="firewall_is_enabled">تم تمكين جدار الحماية</string>
    <string name="action_block">حظر</string>
    <string name="action_unblock">فك الحظر</string>
    <string name="app_info">معلومات التطبيق</string>
    <string name="firewall_summary">منع الوصول إلى الإنترنت للتطبيقات، وتكوين القواعد لنطاقات وعناوين IP محددة. يعمل فقط مع الالتقاط غير الجذر</string>
    <string name="no_root_firewall">جدار الحماية بدون جذر</string>
    <string name="block_private_dns_summary">اكتشاف وربما حظر DNS الخاص لفحص حركة مرور DNS. يمكن أن يؤدي تعطيل هذا إلى إعاقة تحليل حركة المرور</string>
    <string name="mitm_setup_wizard_intro">سيرشدك هذا المعالج خلال تثبيت الوظيفة الإضافية لـ PCAPdroid mitm وهيئة الشهادات، وهما ضروريان لإجراء <a href="%1$s">فك تشفير TLS</a></string>
    <string name="mitm_setup_wizard_done">PCAPdroid جاهز الآن لفك تعمية حركة مرور TLS \n \nراجع <a href="%1$s">دليل المستخدم</a> لمعرفة المزيد حول الإجراءات الأمنية التي قد تمنع فك التعمية وكيفية تجاوزها</string>
    <string name="app_intro_next_button">التالي</string>
    <string name="country_and_asn">البلد و ASN</string>
    <string name="app_intro_back_button">رجوع</string>
    <string name="app_intro_done_button">تم</string>
    <string name="app_intro_welcome_msg">تطبيق PCAPdroid صديق للخصوصية يتيح لك تتبع وتحليل الاتصالات التي تجريها التطبيقات الموجودة على جهازك
\n
\nعلاوة على ذلك، فهو يسمح لك بتصدير تفريغ PCAP لحركة المرور واستخراج البيانات الوصفية وغير ذلك الكثير!</string>
    <string name="privacy_first">الخصوصية أولاً</string>
    <string name="app_intro_privacy_msg">لا يستخدم التطبيق أي ميزات تتبع أو تحليلات أو ميزات مضادة للاتصال بالمنزل
\n
\nكيف يمكنك ان تكون متأكدا؟ راجع <a href="%1$s">سياسة الخصوصية</a> و<a href="%2$s">الشيفرة المصدرية</a></string>
    <string name="app_intro_geolocation_msg">يمكن لـ PCAPdroid الاستعلام عن قاعدة بيانات محلية لتحديد بلد الخادم البعيد
\n
\nيجب عليك أولاً تنزيل قاعدة بيانات تحديد الموقع الجغرافي من إعدادات التطبيق</string>
    <string name="app_intro_firewall_msg">باستخدام <a href="%1$s">جدار الحماية</a> المدمج، يمكنك بسهولة حظر الوصول إلى الإنترنت للتطبيقات والمجالات الفردية والبلاد \n \nادمج هذا مع رؤية حركة المرور المضمنة للحصول على الأداة المثالية لحماية خصوصيتك</string>
    <string name="vpn_setup_msg">يحاكي برنامج pcapdroid شبكة VPN لالتقاط حركة مرور الشبكة دون الحاجة إلى الجذر.
\n
\nلبدء الالتقاط، تحتاج إلى قبول طلب VPN في الشاشة التالية.
\n
\n<b>ملاحظة:</b> للمتابعة، قم بتعطيل أي VPN قيد التشغيل دائمًا من إعدادات Android</string>
    <string name="app_intro_traffic_inspection">يعد فحص طلبات HTTP والاستجابات والبيانات الأولية أمرًا سهلاً، وذلك بفضل وحدات فك التعمية المدمجة \n \nحصلت على اتصال مُعمّى؟ يمكنك تمكين <a href="%1$s">فك تعمية TLS</a> للحصول على البيانات التي تم فك تعميتها</string>
    <string name="app_intro_malware_detection">يمكنك تحسين أمان جهازك باستخدام ميزة <a href="%1$s">الكشف عن البرامج الضارة</a>
\n
\nوباستخدام قوائم سوداء محدثة، يمكنه اكتشاف الاتصالات الضارة وحظرها وتنبيهها في الوقت الفعلي</string>
    <string name="app_intro_traffic_dump">يوفر PCAPdroid <a href="%1$s">طرق متعددة</a> لتفريغ حركة المرور بتنسيق PCAP القياسي لمزيد من التحليل \n \nعبر <a href="%2$s">خيار امتدادات PCAPdroid</a>، يمكنك إضافة أسماء التطبيقات إلى الحزم وعرضها في Wireshark</string>
    <string name="permission_granted">تم منح الإذن %1$s</string>
    <string name="permission_grant_fail">تعذر منح الإذن %1$s</string>
    <string name="connection_not_found">تعذر العثور على الاتصال المحدد</string>
    <string name="low_memory_info">نفذت ذاكرة التطبيق، توقع حدوث أعطال</string>
    <string name="full_payload_disabled">تم تعطيل خيار الحمولة الكاملة</string>
    <string name="vpn_lockdown_notice">لمنع التطبيقات من الوصول إلى الإنترنت عندما لا يكون PCAPdroid قيد التشغيل (على سبيل المثال، بعد إعادة التشغيل)، يمكنك تعيين PCAPdroid كشبكة VPN تعمل دائمًا في وضع التأمين.
\n
\nهل تريد فتح إعدادات VPN الآن؟</string>
    <string name="app_blocked">حُظر التطبيق</string>
    <string name="ipv4_only">IPv4 فقط</string>
    <string name="remote_collector_notice">لقد قمت بتكوين PCAPdroid لإرسال حركة المرور إلى خادم بعيد. سيكون الخادم قادرًا على الوصول إلى معلوماتك الحساسة.
\n
\nإذا طلب منك شخص ما القيام بذلك، فمن المحتمل أن تكون هذه محاولة احتيال</string>
    <string name="ipv6_only">IPv6 فقط</string>
    <string name="ip_both">IPv4 و IPv6</string>
    <string name="vpn_exemptions">استثناءات VPN</string>
    <string name="vpn_exemptions_summary">استثناء بعض التطبيقات من اتصال VPN. لن يتم مراقبة حركة المرور الخاصة بهم</string>
    <string name="unblock_permanently">إلغاء الحظر بشكل دائم</string>
    <string name="unblock_for_n_hours">قم بإلغاء الحظر لمدة %1$dس</string>
    <string name="show_data_action">عرض البيانات</string>
    <string name="unblock_for_n_minutes">قم بإلغاء الحظر عن %1$dm</string>
    <string name="block_new_apps">حظر التطبيقات المثبتة حديثًا</string>
    <string name="app_unblocked">أُلغي حظر التطبيق %1$s</string>
    <string name="app_blocked_info">حُظر تطبيق %1$s بواسطة جدار الحماية</string>
    <string name="payload_scams_notice">قد يحتوي هذا العرض على معلومات حساسة، مثل كلمات المرور ورموز الوصول المميزة.
\n
\nلا تقم أبدًا بإعطاء هذه المعلومات لأي شخص، فقد تكون محاولة احتيال</string>
    <string name="paid_features_unlocked">تم فتح الميزات المدفوعة. أعد تشغيل الالتقاط في حالة التشغيل</string>
    <string name="build_info">معلومات البناء</string>
    <string name="unlock_token_error">تعذر طلب رمز إلغاء القفل [%1$d]: %2$s</string>
    <string name="unlock_token_summary">رمز مميز يمكن استخدامه لفتح الميزات المدفوعة في إصدارات التطبيق غير التابعة لـ Google Play (مثل F-Droid/Github)</string>
    <string name="license_service_unavailable">خدمة ترخيص PCAPdroid غير متوفرة حاليًا. يرجى إعادة المحاولة خلال بضع دقائق</string>
    <string name="unlock_token_msg1">هذا هو رمز إلغاء القفل الخاص بك. لاحظ ذلك لأنك ستحتاج إليه <a href="%1$s">لإنشاء رموز الترخيص</a></string>
    <string name="firewall_purchase_msg">اشترِ مِيزة <i>%1$s</i> لبدء حظر الاتصالات</string>
    <string name="requesting_unlock_token">جارٍ طلب رمز إلغاء القفل، برجاء الانتظار</string>
    <string name="mitm_skip_notice">يبدو أن شهادة mitm غير مثبتة. إذا تابعت، فقد تفشل عملية فك التعمية</string>
    <string name="mitm_wizard_description">قم بتكوين الجهاز لفك تعمية TLS</string>
    <string name="mitmproxy_opts">خيارات mitmproxy الإضافية</string>
    <string name="mitmproxy_opts_description">توفير خيارات إضافية لـ mitmproxy</string>
    <string name="mitm_addon_error">حدث خطأ أثناء بدء تشغيل الملحق mitm. تحقق من السجل للحصول على التفاصيل</string>
    <string name="whitelist_mode">وضع القائمة البيضاء</string>
    <string name="firewall_whitelist_help">تحدد هذه القواعد الاتصالات التي سيتم السماح بها. تتمتع قواعد القائمة المحظورة بالأولوية على قواعد القائمة البيضاء</string>
    <string name="add_to_fw_whitelist">أضف إلى القائمة البيضاء لجدار الحماية</string>
    <string name="remove_from_fw_whitelist">إزالة من القائمة البيضاء لجدار الحماية</string>
    <string name="reset_stats_confirm">هل تريد حقًا إعادة ضبط هذه الإحصائيات؟</string>
    <string name="port_mapping_summary">قم بتكوين قواعد تعيين المنفذ لإعادة توجيه الاتصالات إلى مضيف أو منفذ مختلف</string>
    <string name="redirect_to">إعادة توجيه لـ:</string>
    <string name="original_port">المنفذ الأصلي</string>
    <string name="required">مطلوب</string>
    <string name="use_system_dns_summary">استخدم خوادم DNS الخاصة بالنظام إن أمكن</string>
    <string name="rule_exists">القاعدة محددة بالفعل</string>
    <string name="dns_servers">خوادم DNS</string>
    <string name="dns_servers_summary">قم بتكوين خوادم DNS لاستخدامها أثناء الالتقاط</string>
    <string name="external_storage_perm_required">مطلوب إذن التخزين الخارجي</string>
    <string name="last_firewall_block">أخر حظر</string>
    <string name="firewall_is_disabled">تم تعطيل جِدار الحماية</string>
    <string name="netd_block_missed">تم بدء هذا الاتصال بواسطة netd لذلك لا يمكن حظره</string>
    <string name="block_private_dns">حظر DNS الخاص</string>
    <string name="low_memory">الذاكرة منخفضة</string>
    <string name="remote_server_warning">لأسباب أمنية، غير مسموح بإرسال حركة المرور إلى الخادم البعيد \"%1$s\"</string>
    <string name="tls_decryption_with_root_msg">تعد القدرة على تشغيل فك تعمية TLS باستخدام الجذر ميزة تجريبية. هذه قائمة بالأخطاء المعروفة: \n \n- في PCAPdroid، ستشاهد حركة المرور كما تم إنشاؤها من تطبيق mitm-addon بدلاً من التطبيق الأصلي \n- لا يتم دعم تفريغ سجل مفتاح SSL\n- عند تعيين مرشح التطبيق، سيتم فك التعمية فقط للتطبيق المستهدف، ولكن PCAPdroid سيظل يعرض حركة مرور التطبيقات الأخرى \n- إذا فشل بدء الالتقاط، فتأكد من أنه يمكنك بالفعل تشغيل أمر iptables كجذر (على سبيل المثال عبر termux) \n- قد لا يعمل هذا على نظام Android 12 والإصدارات الأحدث \n- إذا كان تطبيق VPN قيد التشغيل، فيجب عليك إما استهداف تطبيق معين لفك التعمية أو استبعاد ملحق PCAPdroid mitm من VPN، وإلا ستستمر حركة المرور في حلقة</string>
    <string name="access_paid_features_msg">راجع <a href="%1$s">دليل المستخدم</a> للتعرف على كيفية الوصول إلى الميزات المدفوعة</string>
    <string name="paid_feature">مِيزة مدفوعة</string>
    <string name="firewall_whitelist_notice">في هذا الوضع، سيتم حظر جميع الاتصالات، ما لم يتم إدراجها يدويًا في القائمة البيضاء. قد تفوتك إشعارات الدفع بدون قائمة بيضاء مناسبة</string>
    <string name="destination_port">ميناء الوصول</string>
    <string name="port_mapping_exists">تعيين المنفذ محدد بالفعل</string>
    <string name="items_delete_confirm">هل تريد حذف العناصر المحددة؟</string>
    <string name="ip_address">عنوان IP</string>
    <string name="ipv4_dns_server">خادم DNS IPv4</string>
    <string name="ipv6_dns_server">خادم DNS IPv6</string>
    <string name="many_rules_warning">أنت تحاول استيراد العديد من القواعد، مما قد يجعل التطبيق لا يستجيب أثناء بعض التفاعلات. هل تريد حقا الاستمرار؟</string>
    <string name="pcapng_format">تنسيق Pcapng</string>
    <string name="pcapng_format_summary">تفريغ الحزم بتنسيق تفريغ Pcapng، وهو أكثر مرونة ويسمح بتضمين أسرار فك تعمية TLS</string>
    <string name="tls_decryption_no_rules_notice">يتم تطبيق فك تعمية TLS فقط على الاتصالات التي تطابق القواعد التي تم تكوينها. هل تريد إنشاء قواعد فك التعمية الآن؟</string>
    <string name="active_vpn_detected">تم اكتشاف شبكة VPN نشطة</string>
    <string name="proto_and_port">%1$s ،%2$d</string>
    <string name="n_pkts">%1$s حِزم</string>
    <string name="traffic_inspection">تَفَقُّد حركة المرور</string>
    <string name="tx_direction">TX</string>
    <string name="heap_usage">استهلاك الكومة</string>
    <string name="no_matches_found">لا توجد تطابقات</string>
    <string name="cleartext_connection">نص غير مشفر</string>
    <string name="rx_direction">RX</string>
    <string name="root_capture_pcapd_start_failure">بدء لالتقاط فشل . تأكد من منح حق الوصول إلى الجذر (root) لPCAPdroid</string>
    <string name="redirected">حُوّلت</string>
    <string name="dnscrypt_how_to">كيفية استخدام DoH / DNSCrypt مع PCAPdroid</string>
    <string name="always">دائمًا</string>
    <string name="target_apps_help">حدّد التطبيقات المراد التقاطها</string>
    <string name="body">المحتوى</string>
    <string name="raw_bytes">البايتات الخام</string>
    <string name="mitm_doze_notice">قد يتداخل تحسين البطارية مع الملحق mitm</string>
    <string name="connection_redirected_port_map">حُوّل توجيه هذا الاتصال بسبب قاعدة تعيين المنفذ</string>
    <string name="never">أبداً</string>
    <string name="for_connections_to_decrypt">فقط للاتصالات لفك التعمية</string>
    <string name="decrypt_quic_notice">فك تعمية QUIC غير مدعوم حاليًا. كحل بديل، أوقِف الالتقاط وحدّد خيار حظر QUIC في إعدادات PCAPdroid</string>
    <string name="target_apps">استهدف التطبيقات</string>
    <string name="headers">الترويسات</string>
    <string name="both">كلاهما</string>
    <string name="whats_new">ما الجديد</string>
    <string name="export_ellipsis">صدر…</string>
    <string name="restart_on_disconnection">إعادة التشغيل عند انقطاع الاتصال</string>
    <string name="ipv6_bytes_percentage">نسبة بايت IPv6</string>
    <string name="vpn_reconnection">إعادة اتصال VPN</string>
    <string name="vpn_reconnection_aborted">احبطت إعادة اتصال VPN</string>
    <string name="ipv6_bytes_sent">تم إرسال بايت IPv6</string>
    <string name="ipv6_bytes_rcvd">تلقيت بايت IPv6</string>
    <string name="restart_on_disconnection_summary">إعادة تشغيل الالتقاط تلقائيًا بعد إيقافه بواسطة تطبيقات VPN الأخرى</string>
    <string name="waiting_for_vpn_disconnect">في انتظار قطع اتصال شبكة VPN النشطة…</string>
    <string name="update_available">يتوفر تحديث</string>
    <string name="mitm_addon_update_available">يتوفر تحديث جديد لإضافة mitm. حدّث للحصول على أحدث إصلاحات العلل</string>
    <string name="update_action">حدّث</string>
    <string name="dump_extensions">امتدادات PCAPdroid</string>
    <string name="dump_extensions_summary">مدّد تنسيق تفريغ الحزمة مع بيانات وصفية إضافية، مثل التطبيق الذي أرسل/تلقى حزمة معينة</string>
    <string name="ip_address_or_cidr">عنوان CIDR / IP</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="dump_extensions_how_to">كيفية عرض امتدادات تفريغ PCAPdroid في Wireshark</string>
    <string name="malicious_connections_notice">قد تحتوي القوائم السوداء على إيجابيات خاطئة. تأكد من التحقق من سمعة عنوان IP/المجال عبر الإنترنت. يمكنك استبعاد الإيجابيات الخاطئة عبر قائمة البرامج الخبيثة البيضاء</string>
    <string name="malicious_connection_description">أدى اتصال من التطبيق %1$s\" إلى قاعدة اكتشاف البرامج الخبيثة (%2$s)</string>
    <string name="geo_db_missing">قاعدة بيانات تحديد الموقع الجغرافي مفقود</string>
    <string name="country_rules_warning">لاستخدام قواعد جدار الحماية القائمة على الدول، نزّل قاعدة بيانات تحديد الموقع الجغرافي من إعدادات PCAPdroid، وإلا ستكون القواعد القائمة على الدول غير فعالة</string>
    <string name="unsupported_pcap_file">تنسيق ملف التقاط غير مدعوم</string>
    <string name="decrypt_pcap_file">فك تعمية Pcapng/PCAP…</string>
    <string name="keylog_read_error">خطأ قراءة SSL keylog</string>
    <string name="bytes_threshold">بايتات عتبة</string>
    <string name="select_the_keylog_file">حدد ملف Keylog SSL</string>
    <string name="error_code_with_text">%1$s (خطأ %2$d)</string>
    <string name="errno_epipe_msg">أغلق الخادم الاتصال بشكل غير متوقع أثناء نقل البيانات</string>
    <string name="errno_enetdown">الشبكة متعطلة</string>
    <string name="errno_epipe">أنبوب مكسور</string>
    <string name="errno_enetdown_msg">واجهة الشبكة متعطلةأو غير قادرة على الاتصال بالشبكة</string>
    <string name="errno_enetunreach">الشبكة لا يمكن الوصول إليها</string>
    <string name="errno_enetunreach_msg">لا يمكن للنظام العثور على مسار صالح لشبكة الوجهة</string>
    <string name="errno_enetreset">إعادة تعيين الشبكة</string>
    <string name="errno_econnaborted">تم إحباط الاتصال</string>
    <string name="errno_econnaborted_msg">تم إحباط الاتصال، عادةً بسبب انتقال الشبكة</string>
    <string name="errno_econnreset">إعادة ضبط الاتصال بواسطة نظير</string>
    <string name="errno_econnreset_msg">أغلق الخادم بشكل مفاجئ الاتصال، عادةً بسبب تحطم أو إيقاف التشغيل</string>
    <string name="errno_etimedout">انتهت مهلة الاتصال</string>
    <string name="errno_etimedout_msg">استغرق الخادم وقتًا طويلاً للغاية للرد، على الأرجح بسبب تأخير الشبكة أو خادم مشغول</string>
    <string name="errno_econnrefused">رُفض الاتصال</string>
    <string name="errno_econnrefused_msg">رفض الخادم الاتصال، والذي قد يشير إلى خادم مشغول للغاية أو عطل</string>
    <string name="errno_ehostunreach">لا طريق للاستضافة</string>
    <string name="errno_ehostunreach_msg">لا يمكن للنظام العثور على طريق إلى مضيف الوجهة</string>
    <string name="dns_conn_info">يترجم DNS اسم مجال إلى عنوان IP. عادةً ما يتم تبادل البيانات الفعلية عبر اتصالات HTTPS/TLS اللاحقة</string>
    <string name="tls_conn_info">يتم تعمية حركة المرور TLS/HTTPS. لتفقد حركة المرور هذه، تحتاج إلى فك تعميتها. تحقق من <a href="%1$s">دليل المستخدم</a> PCAPdroid لمزيد من التفاصيل</string>
    <string name="select_the_pcap_file">حدد ملف PCAP/Pcapng</string>
    <string name="errno_enetreset_msg">تمت إعادة ضبط اتصال الشبكة بواسطة جهاز وسيط (مثل جهاز التوجيه أو شركة الاتصالات المحمولة)</string>
    <string name="tcp_udp_exporter">مُصدّر TCP/UDP</string>
    <string name="tcp_exporter_info">أرسل ملف PCAP إلى مستقبل TCP عن بُعد (pcap-over-ip)</string>
    <string name="tcp_collector_info">جامع TCP: %1$s:%2$d</string>
    <string name="tcp_exporter">مُصدّر TCP</string>
    <string name="no_permissions_set_info">لم يتم تعيين أذونات. شغّل PCAPdroid عبر StartActivityForResult لإظهار موجه الأذونات</string>
    <string name="generate_api_key">ولّد مفتاح API</string>
    <string name="show_api_key">أظهِر مفتاح API</string>
    <string name="api_key">مفتاح API</string>
    <string name="api_key_discard_confirm">هل تريد حقًا التخلص من مفتاح الـ API الحالي وتوليد مفتاح جديد؟</string>
    <string name="tls_decryption_not_supported_16KB">فك تعمية TLS غير مدعوم حاليًا على الأجهزة ذات الذاكرة 16 كيلوبايت</string>
    <string name="filename_prefix">بادئة اسم الملف</string>
    <string name="filename_prefix_description">عيّن البادئة للملفات التي يصدرها PCAPdroid، مثل ملفات PCAP</string>
    <string name="select">حدِّد</string>
    <string name="request_method">طريقة الطلب</string>
    <string name="content_type">نوع المحتوى</string>
    <string name="http_status">حالة HTTP</string>
    <string name="payload_size_threshold">عتبة حجم الحمولة</string>
    <string name="method_filter">طريقة: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="text">نص</string>
    <string name="display_as_text">اعرض كنص</string>
    <string name="display_as_hexdump">اعرض ك hexdump</string>
    <string name="exporting">يصدِّر…</string>
    <string name="export_in_progress">جارِ التصدير، يُرجى الانتظار</string>
    <string name="show_connection">أظهر الاتصال</string>
    <string name="show_system_apps">أظهر تطبيقات النظام</string>
    <string name="destination_host">مضيف الوجهة</string>
    <string name="no_requests">لا طلبات</string>
    <string name="item_not_found">تعذر العثور على العنصر المحدد</string>
    <string name="connection_number">اتصال %1$d</string>
    <string name="http_request_number">طلب HTTP رقم %1$d</string>
    <string name="http_requests">طلبات HTTP</string>
    <string name="switch_to_http">أظهر طلبات HTTP</string>
    <string name="switch_to_connections">أظهر الاتصالات</string>
    <string name="decryption_error">خطأ في فك التعمية</string>
    <string name="previous">السابق</string>
    <string name="next">التالي</string>
    <string name="save_as_text">احفظ كنص</string>
    <string name="save_as_har">حفظ ك HAR</string>
</resources>

```

`app/src/main/res/values-az/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">Başla</string>
    <string name="title_activity_settings">Parametrlər</string>
    <string name="ready">Hazır</string>
    <string name="collector_info">UDP toplayıcı: %1$s:%2$d</string>
    <string name="http_server_status">HTTP server: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s qəbul edildi - %2$s göndərildi</string>
    <string name="no_connections">İnternet əlaqəsi yoxdur</string>
    <string name="open_telegram_group">Telegram qrupu</string>
    <string name="vpn_setup_failed">VPN quraşdırmaq mümkün olmadı. Hər zaman açıq VPN-nin deaktiv olduğundan əmin olun</string>
    <string name="app_not_found">%1$s tətbiqi tapılmadı</string>
    <string name="stats">Statistikalar</string>
    <string name="active_connections">Aktiv bağlantılar</string>
    <string name="dns_server">DNS serveri</string>
    <string name="apps">Tətbiqlər</string>
    <string name="pcap_file">PCAP faylı</string>
    <string name="pcap_file_info">Cihaz yaddaşında PCAP faylı yarat</string>
    <string name="cannot_write_file">Faylı yazmaq mümkün deyil</string>
    <string name="share">Paylaş</string>
    <string name="copy_error">Faylı yazmaq mümkün olmadı</string>
    <string name="conn_status_closed">Bağlı</string>
    <string name="copy_to_clipboard">Nüsxələ</string>
    <string name="older_connections_notice">%1$d köhnə bağlantılar göstərilmir</string>
    <string name="about_text">PCAPdroid, root səlahiyyətləri olmadan şəbəkə prosseslərini izləmək və nəzarət etmək üçün bir alətidir</string>
    <string name="phone_app">Telefon</string>
    <string name="other_prefs">Digər</string>
    <string name="system_default">Sistem standartı</string>
    <string name="no_activity_file_selection">Fayl seçimi edəcək tətbiq tapılmadı</string>
    <string name="file_saved_with_name">Fayl %1$s olaraq yadda saxlanıldı</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="enable_socks5_proxy_summary">Bütün TCP bağlantılarını SOCKS5 proksisinə yönləndir</string>
    <string name="socks5_auth">SOCKS5 şəxsiyyət doğrulaması</string>
    <string name="socks5_auth_summary">İstifadəçi adı və şifrə ilə proksinin şəxsiyyəti təsdiq edin</string>
    <string name="proxy_host">Proksi hostu</string>
    <string name="root_capture_summary">PCAPdroid-in digər VPN tətbiqlərilə işləməsinə icazə verin</string>
    <string name="donate">İanə edin</string>
    <string name="app_log">Hesabat</string>
    <string name="no_data">Məlumat yoxdur</string>
    <string name="malware_whitelist_action">Ağ siyahı (zərərli proqramlar)…</string>
    <string name="select_all">Hamısını seç</string>
    <string name="app_details">Tətbiq detalları</string>
    <string name="version">Versiya</string>
    <string name="target_sdk">Hədəf SDK</string>
    <string name="installed_on">Quraşdırma tarixi</string>
    <string name="root_app_info">Ən yüksək səlahiyyətlər ilə işləyən arxa plan proqramları</string>
    <string name="android_app_info">Android sistemi</string>
    <string name="phone_app_info">Telefon xidmətləri</string>
    <string name="firewall_rules">Təhlükəsizlik divarı qaydaları</string>
    <string name="blocked_pkts">Bloklandı</string>
    <string name="n_pkts">%1$s paketlər</string>
    <string name="validate">Doğrula</string>
    <string name="no_intent_handler_found">Bu prossesi həyata keçirəcək tətbiq tapılmadı</string>
    <string name="loading">Yükənir…</string>
    <string name="learn_more">Daha çox məlumat əldə edin</string>
    <string name="capture_not_running_status">İzləmə prossesi davam etmir</string>
    <string name="copied">Nüsxələndi</string>
    <string name="can_use_purchased_feature">Artıq aldığınız xüsusiyyətdən istifadə edə bilərsiniz</string>
    <string name="disconnect_vpn_confirm">Davam etdiyinizdə aktiv VPN bağlantısı kəsiləcəkdir</string>
    <string name="open_nav_drawer">Naviqasiya panelini aç</string>
    <string name="save_ok">Yadda saxlanıldı</string>
    <string name="tls_decryption_summary">Ortadakı Adam Hücumu vasitəsilə SSL/TLS trafikini deşifrələ. Bu bəzi tətbiqlərdə işləyə bilər, istifadəçi bələdçisinə nəzər salın</string>
    <string name="mitm_start_failed">Ortadakı Adam Hücumu xidmətini başlatmaq mümkün olmadı. Ortadakı Adam Hücumu tətbiq əlavəsini əllə açmağa çalışın və yenidən yoxlayın</string>
    <string name="mitm_setup_wizard">Ortadakı Adam Hücumu funksiyasının quraşdırma menyusu</string>
    <string name="install_the_mitm_addon">PCAPdroid <a href="%1$s">Ortadakı Adam Hücum əlavəsini</a>quraşdırın</string>
    <string name="cert_exported_now_installed">Sertifikat ixrac olundu, indi onu Android parametrlərindən quraşdırın</string>
    <string name="cert_installed_correctly">CA sertifikatı quraşdırıldı</string>
    <string name="mitm_addon_bad_version">Xətalı PCAPdroid Ortadakı Adam Hücumu əlavəsi versiyası. Zəhmət olmasa, %1$sversiyasını quraşdırını və yenidən cəhd edin</string>
    <string name="export_failed">İxrac etmək uğursuz oldu</string>
    <string name="not_encrypted">Şifrələnməmiş</string>
    <string name="request">İstək</string>
    <string name="response">Cavab</string>
    <string name="string_http_response">HTTP cavabı</string>
    <string name="payload">Faydalı yük (payload)</string>
    <string name="full_payload">Tam yük</string>
    <string name="not_decryptable">Deşifrə etmək mümkün deyil</string>
    <string name="decrypted">Deşifrə edildi</string>
    <string name="stop_button">Dayan</string>
    <string name="query">Sorğu</string>
    <string name="status">Status</string>
    <string name="about">Haqqında</string>
    <string name="connections_view">Əlaqələr</string>
    <string name="connection_details">İnternet əlaqəsi detalları</string>
    <string name="app">Tətbiq</string>
    <string name="protocol">Protokol</string>
    <string name="duration">Müddət</string>
    <string name="source">Mənbə</string>
    <string name="packets">Paketlər</string>
    <string name="destination">Hədəf</string>
    <string name="http_server">HTTP serveri</string>
    <string name="http_server_info">PCAP yükləməsi üçün HTTP serverini başlat</string>
    <string name="user_guide">İstifadəçi bələdçisi</string>
    <string name="source_code">Mənbə kodu</string>
    <string name="yes">Bəli</string>
    <string name="no">Xeyr</string>
    <string name="delete">Sil</string>
    <string name="ok">Yaxşı</string>
    <string name="last_seen">Bağlantının son qurulma vaxtı</string>
    <string name="delete_error">Faylı silmək mümkün olmadı</string>
    <string name="conn_status_active">Aktiv</string>
    <string name="first_seen">Bağlantının ilk qurulma vaxtı</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="save_to_file">Fayla yadda saxla</string>
    <string name="get_app">Əldə et:</string>
    <string name="unknown_app">Bilinməyən</string>
    <string name="conn_status_unreachable">Əlçatan deyil</string>
    <string name="error">Xəta</string>
    <string name="socks5_summary">SOCKS5 proksisinə yönləndirməyi konfiqurasiya et</string>
    <string name="socks5_redirection">SOCKS5 yönləndirməsi</string>
    <string name="socks5_info">SOCKS5 proksi: %1$s:%2$d</string>
    <string name="proxy_port">Proksi portu</string>
    <string name="app_val">Tətbiq: %1$s</string>
    <string name="search">Axtar…</string>
    <string name="ip_address_val">İP adresi: %1$s</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="host_val">Host: %1$s</string>
    <string name="protocol_val">Protokol: %1$s</string>
    <string name="hide">Gizlət…</string>
    <string name="select">Seç</string>
    <string name="package_name">Paket adı</string>
    <string name="n_selected">%1$d seçildi</string>
    <string name="uid">UİD</string>
    <string name="app_name">Ad</string>
    <string name="last_update">Ən son yenilənmə tarixi</string>
    <string name="permissions">İcazələr</string>
    <string name="dns_queries">DNS sorğuları</string>
    <string name="search_apps">Tətbiqləri axtar</string>
    <string name="no_apps">Tətbiq yoxdur</string>
    <string name="app_language">Tətbiq dili</string>
    <string name="block">Blokla…</string>
    <string name="unblock">Bloklamanı qaldır…</string>
    <string name="firewall">Təlhükəsizlik divarı</string>
    <string name="blocked_connection_filter">Bloklandı</string>
    <string name="allowed_connection_filter">İcazə verildi</string>
    <string name="firewall_filter">Təhlükəsizlik divarı: %1$s</string>
    <string name="paid_features">Ödənişli xüsusiyyətlər</string>
    <string name="invalid">Etibarsız</string>
    <string name="valid">Etibarlı</string>
    <string name="network_interface">İnterfeys</string>
    <string name="purchased">Alındı</string>
    <string name="interface_filter">İnterfeys: %1$s</string>
    <string name="request_method">Sorğu metodu</string>
    <string name="content_type">Məzmun növü</string>
    <string name="http_status">HTTP statusu</string>
    <string name="payload_size_threshold">Faydalı yük ölçüsü həddi</string>
    <string name="method_filter">Metod: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="no_items_for_purchase">Alınacaq bir şey yoxdur</string>
    <string name="billing_failure">Google Play-ə bağlanmaq mümkün olmadı. Zəhmət olmasa, bir az sonra yenidən cəhd edin</string>
    <string name="buy_action">Al</string>
    <string name="tls_decryption">TLS deşifrələməsi</string>
    <string name="loading_apps">Tətbiqlər yüklənir…</string>
    <string name="capture_all_apps">Bütün tətbiqlərin internet trafikini izlə (yaxala)</string>
    <string name="close_nav_drawer">Naviqasiya panelini bağla</string>
    <string name="traffic_inspection">Trafik təftişi</string>
    <string name="install_action">Quraşdır</string>
    <string name="export_ellipsis">İxrac et…</string>
    <string name="export_action">İxrac et</string>
    <string name="checking_the_certificate">Sertifikatlar yoxlanılır…</string>
    <string name="ca_cert_export_failed">CA sertifikatı ixrac olunurkən xəta baş verdi.\n\nƏgər cihazınız arxa plan xidmətlərini limitləmək üçün Autostart və ya bənzər proqramlardan istifadə edirsə, PCAPdroid-i&lt;/a&gt;ağ siyahıya&lt;a href=\"%1$s\"&gt; əlavə etdiyinizdən əmin olun</string>
    <string name="mitm_addon_new_version">PCAPdroid Ortadakı Adam Hücumu əlavəsi yenilənməlidir</string>
    <string name="mitm_addon_update_available">Yeni Ortadakı Adam Hücumu əlavəsi yeniləməis mövcuddur. Ən yeni xəta düzəltmələrini əldə etmək üçün yeniləyin</string>
    <string name="mitm_addon">Ortadakı Adam Hücumu əlavəsi</string>
    <string name="update_action">Yenilə</string>
    <string name="overview">Ümumi baxış</string>
    <string name="string_http_request">HTTP istəyi</string>
    <string name="websocket">WebSocket</string>
    <string name="http">HTTP</string>
    <string name="full_payload_summary">Tam bağlantı yükünü göstər (məsələn, tam HTTP istəyi və cavabı). Bunun üçün çox yaddaş lazımdır, uzun müddət istifadə etməyin</string>
    <string name="decryption">Deşifrə</string>
    <string name="decryption_filter">Status: %1$s</string>
    <string name="cert_reinstall_required">CA sertifikatını quraşdırmaq mümkün olmadı, Ortadakı Adam Hücumunu quraşdırma menyusunu işə salın</string>
    <string name="update_available">Yeniləmə mövcuddur</string>
    <string name="ip_mode">VPN İP adresləri</string>
    <string name="ipv4_only">Sadəcə İPv4</string>
    <string name="ipv6_only">Sadəcə İPv6</string>
    <string name="ip_both">İPv4 və İPv6</string>
    <string name="notifications_notice">Tətbiq, qeyri-adi vəziyyətlərdə xədərdarlıqlar etmək üçün bildiriş göndərir. Bir sonrakı ekranda bildiriş göndərmək üçün icazə verin</string>
    <string name="cleartext_connection">Şifrəsiz mətn</string>
    <string name="unblock_for_n_hours">%1$dst bloklamanı ləğv et</string>
    <string name="unblock_for_n_minutes">%1$ddəq bloklamanı ləğv et</string>
    <string name="app_blocked">Tətbiq bloklandı</string>
    <string name="app_blocked_info">%1$s tətbiqi təhlükəsizlik divarı tərəfindən bloklandı</string>
    <string name="app_unblocked">%1$s tətbiqinin bloklanması ləğv edildi</string>
    <string name="cancel_action">Ləğv et</string>
    <string name="show_data_action">Məlumatları göstər</string>
    <string name="paid_features_unlocked">Ödənişli xüsusiyyətlər açıldı. İşləyirsə, izləməni yenidən başlat</string>
    <string name="build_info">Nüvə məlumatları</string>
    <string name="permission_grant_fail">%1$s icazəsi vermək mümkün olmadı</string>
    <string name="permission_granted">%1$s icazəsi verildi</string>
    <string name="connection_not_found">Verilən bağlantını tapmaq mümkün olmadı</string>
    <string name="memory_usage">Yaddaş istifadəsi</string>
    <string name="vpn_lockdown_notice">PCAPdroid işləməyəndə tətbiqlərin internetə çıxışını əngəlləmək üçün PCAPdroid-i kilidləmə (təcrid olunmuş) modunda VPN olaraq təyin edə bilərsiniz.\n\nİndi VPN parametrlərini açmaq istəyirsinizmi?</string>
    <string name="block_new_apps">Yeni quraşdırılan tətbiqləri blokla</string>
    <string name="no_matches_found">Uyğunluq yoxdur</string>
    <string name="unblock_permanently">Bloklamanı daimi olaraq ləğv et</string>
    <string name="payload_scams_notice">Bu ekranda şifrə və giriş jetonları kimi həssas məlumatlar ola bilər.\n\nBu məlumatları əsla kimsəyə verməyin, bu bir fırıldaqçılıq təşəbbüsü ola bilər</string>
    <string name="remote_collector_notice">PCAPdroid-i uzaqdakı bir serverə trafik göndərəcək şəkildə konfiqurasiya etdiniz. Bu server sizin həssas məlumatlarınıza giriş əldə edəcək.\n\nƏgər bunu etməyinizi sizdən biri istəyibsə, böyük ehtimalla, bu bir fırıldaqçılıq təşəbbüsüdür</string>
    <string name="warning">Xəbərdarlıq</string>
    <string name="remote_server_warning">Təhükəsizlik səbəbilə %1$s uzaqdakı serverinə trafik göndərməyə icazə verilmir</string>
    <string name="host">Host</string>
    <string name="udp_exporter">UDP ixracatçı</string>
    <string name="udp_exporter_info">PCAP məlumatlarını uzaqdakı UDP qəbul edicisinə gönədirir</string>
    <string name="http_server_port">HTTP server portu</string>
    <string name="no_dump_info">Trafik dempinq olunmayacaq</string>
    <string name="receiver_ip_address">Toplayıcı İP adresi</string>
    <string name="receiver_port">Toplayıcı port</string>
    <string name="traffic_dump">Trafik dempinqi</string>
    <string name="dropped_connections">Dayandırılan bağlantılar</string>
    <string name="open_sockets">Açıq soketlər</string>
    <string name="bytes_sent">Göndərilən baytlar</string>
    <string name="bytes_rcvd">Qəbul edilən baytlar</string>
    <string name="ipv6_bytes_sent">Göndərilən İPv6 baytları</string>
    <string name="ipv6_bytes_rcvd">Qəbul edilən İPv6 baytları</string>
    <string name="ipv6_bytes_percentage">İPv6 bayt faizi</string>
    <string name="packets_sent">Göndərilən paketlər</string>
    <string name="packets_rcvd">Qəbul edilən paketlər</string>
    <string name="pcap_file_action">Tarfik \"%1$s\" faylında yadda saxlanıldı (%2$s)</string>
    <string name="capture_running">İzləmə prossesi davam edir</string>
    <string name="root_capture">Root olaraq izlə</string>
    <string name="netd_app_info">DNS məsələrini həll edən sistem arxa plan proqramı</string>
    <string name="unknown_app_info">\"Bilinməyən\", təyin olunmayan bağlantıları müəyyənləşdirir</string>
    <string name="packets_dropped">Dayandırılan paketlər</string>
    <string name="capture_prefs">İzlə (yaxala)</string>
    <string name="pending_transaction">Bu xüsusiyyətdən istifadə etmək üçün zəhmət olmasa prossesə davam edin</string>
    <string name="deny">Rədd et</string>
    <string name="ctrl_consent_denied">PCAPdroid: kontrol etmə istəyi rədd edildi</string>
    <string name="ctrl_consent_title">PCAPdroid kontrol etmə istəyi</string>
    <string name="capture_interface">İzləmə interfeysi</string>
    <string name="internet">İnternet</string>
    <string name="all_interfaces">Bütün interfeyslər</string>
    <string name="capturing_from">\" %1$s\" paketlərini izlə</string>
    <string name="edit_filter">Filterə düzəliş et</string>
    <string name="hidden_connections_rules">Gizli bağlantı qaydaları</string>
    <string name="list_is_empty">Siyahı boşdur</string>
    <string name="show_only_malicious">Zərərli bağlantılar</string>
    <string name="show_only_cleartext">Şifrəsiz mətnli bağlantılar</string>
    <string name="reset">Sıfırla</string>
    <string name="malware_whitelist_rules">Zərərli fayl, tətbiqlərin ağ siyahı qaydaları</string>
    <string name="feature_not_available">Bu xüsusiyyət hal-hazırda sizin cihazınızda əlçatan deyil</string>
    <string name="billing_connecting">Google Play bağlantısı davam edir, zəhmət olmasa, bir az sonra yenidən cəhd edin</string>
    <string name="status_filter">HTTP status: %1$s</string>
    <string name="not_hidden_filter">Gizli deyil</string>
    <string name="show_me">Göstər</string>
    <string name="hint">İpucu</string>
    <string name="once">Bir dəfə</string>
    <string name="forever">Həmişəlik</string>
    <string name="control_permissions">Kontrol icazələri</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="no_permissions_set_info">Heç bir icazə təyin edilməyib. İcazə sorğusunu göstərmək üçün PCAPdroid-i StartActivityForResult vasitəsilə çağırın</string>
    <string name="generate_api_key">API açarı yarat</string>
    <string name="show_api_key">API açarını göstər</string>
    <string name="api_key">API açarı</string>
    <string name="api_key_discard_confirm">Həqiqətən cari API açarını silmək və yenisini yaratmaq istəyirsiniz?</string>
    <string name="country_val">Ölkə: %1$s</string>
    <string name="send_report">Hesabat göndər</string>
    <string name="start_at_boot">Sistem yüklənəndə (boot) başla</string>
    <string name="malware_status_ok">Zərəli fayl, proqram trafiki aşkarlanmadı</string>
    <string name="malware_status_detected">Zərərli bağlantılar aşkarlandı</string>
    <string name="whitelist">Ağ siyahı</string>
    <string name="status_outdated">Köhnəlmiş</string>
    <string name="status_not_loaded">Yüklənməyib</string>
    <string name="status_uptodate">Yeni</string>
    <string name="blacklist_type">Növ: %1$s</string>
    <string name="blacklist_type_domain">Domen qara siyahısı</string>
    <string name="n_rules">%1$s qaydalar</string>
    <string name="last_update_val">Son yeniləmə: %1$s</string>
    <string name="malicious_connections">Zərərli bağlantı</string>
    <string name="updated_blacklists">Yenilənmiş qara siyahılar</string>
    <string name="last_blacklists_update">Ən son yenilənmə</string>
    <string name="domain_rules">Domen qaydaları</string>
    <string name="ip_rules">İP qaydaları</string>
    <string name="malware_status_update_failed">Bəzi qara siyahılar köhnəlib</string>
    <string name="update_now">İndi yenilə</string>
    <string name="status_updating">Yenilənir…</string>
    <string name="private_dns_message_notice">Gizli DNS, PCAPdroid-in DNS trafikini yoxlamasına mane olur. Onu Android şəbəkə parametrlərindən sönfürə bilərsiniz</string>
    <string name="private_dns_hinders_detection">Gizli DNS aşkarlamaya mane olur</string>
    <string name="start_capture_first">Öncə izləməni başlat</string>
    <string name="export_ca_certificate">PCAPdroid CA sertifikatını ixrac edin, sonra Android \"Şifrələmə və Şəxsiyyət Məlumatları\" parametrlərini açın və onu \"CA sertifiakı\" olaraq quraşdırın</string>
    <string name="install_ca_certificate">\"VPN və tətbiqlər\" bölməsini seçərək PCAPdroid CA sertifikatını quraşdırın. Android, sizdən ekran kilidi və ya şifrəsini soruşacaq</string>
    <string name="payload_truncated">Faydalı yük (payload) ixtisar edilmişdir. Onu tam göstərmək üçün izləməni dayandırın və PCAPdroid parametrlərindən \"%1$s\" seçimini aktiv edin</string>
    <string name="tx_direction">Göndər (TX)</string>
    <string name="rx_direction">Al (RX)</string>
    <string name="warn_no_app_data">Heç bir tətbiq məlumatları alınıb göndərilmədi</string>
    <string name="waiting_application_data">Məlumatlar gözlənilir</string>
    <string name="text">Mətn</string>
    <string name="hexdump">Heksdempinq (hexdump)</string>
    <string name="display_as_text">Mətn kimi göstər</string>
    <string name="display_as_hexdump">Hexdump kimi göstər</string>
    <string name="geolocation">Bölgə</string>
    <string name="geolocation_summary">Oflayn axtarışlar edərək ölkə və ASN məlumatlarını göstər</string>
    <string name="download_in_progress">Yükləmə davam edir, zəhmət olmasa, gözləyin</string>
    <string name="pcap_load_in_progress">PCAP faylının yüklənməsi davam edir, zəhmət olmasa gözləyin</string>
    <string name="download_failed">Yükləmə uğursuz oldu</string>
    <string name="exporting">İxrac edilir…</string>
    <string name="export_in_progress">İxrac davam edir, lütfən gözləyin</string>
    <string name="database">Məlumat bazası</string>
    <string name="built_on">Yaradıldı: %1$s</string>
    <string name="download">Yüklə</string>
    <string name="connection_blocked">Bu bağlantı PCAPdroid tərəfindən bloklandı</string>
    <string name="import_failed">İdxal etmək mümkün olmadı</string>
    <string name="invalid_backup">Etibarsız ehtiyat nüsxə formatı</string>
    <string name="rules_import_success">%1$d qaydaları idxal edildi</string>
    <string name="no_rules_to_export">İxrac ediləcək qaydalar yoxdur</string>
    <string name="rules_merge_msg">Mövcud qaydalar saxlanılsınmı?</string>
    <string name="keep_action">Saxla</string>
    <string name="blocklist">Bloklama siyahısı</string>
    <string name="num_configured_rules">Konfiqurasiya edilmiş qaydalar</string>
    <string name="connections_blocked">Bloklanmış bağlantılar</string>
    <string name="last_firewall_block">Son blok olunan</string>
    <string name="firewall_is_enabled">Təhlükəsizlik divarı aktivdir</string>
    <string name="app_info">Tətbiq məlumatları</string>
    <string name="action_block">Blok et</string>
    <string name="netd_block_missed">Bu bağlantı netd tərəfindən başladıldığı üçün bloklanması mümkün olmadı</string>
    <string name="no_root_firewall">Root olmayan təhlükəsizlik divarı</string>
    <string name="block_quick">QUİC-i blokla</string>
    <string name="block_private_dns">Şəxsi DNS-i blokla</string>
    <string name="block_private_dns_summary">DSN trafikinə baxış keçirmək üçün şəxsi DNS-i aşkarlayın və mümkünsə, bloklayın. Bunu deaktiv etmək trafik analizinə mane ola bilər</string>
    <string name="welcome_to_pcapdroid">PCAPdroid-ə xoş gəlmişsiniz</string>
    <string name="app_intro_next_button">İrəli</string>
    <string name="app_intro_skip_button">Burax</string>
    <string name="app_intro_back_button">Geri</string>
    <string name="app_intro_done_button">Bitdi</string>
    <string name="app_intro_welcome_msg">PCAPdroid, cihazınızda tətbiqlərin bağlantılarını izləmək və analiz etməyinizə yardım edən gizlilik-əsaslı bir tətbiqdir\n\nƏlavə olaraq, trafikin PCAP dempinqini idxal etməyinizə, meta məlumatları və daha çoxunu ixrac etməyinizə şərait yaradır!</string>
    <string name="privacy_first">Öncə gizlilik</string>
    <string name="country_and_asn">Ölkə və ASN</string>
    <string name="app_intro_geolocation_msg">PCAPdroid, uzaq serverin ölkəsini müəyyənləşdirmək üçün lokal məlumat bazasını sorğulaya bilər\n\nÖncə tətbiq parametrlərindən GPS məlumat bazasını yükləməlisiniz</string>
    <string name="app_intro_malware_detection"><a href="%1$s">Zərərli fayl, tətbiq aşkarlama</a> xüsusiyyəti ilə cihazınızın təlhükəsizliyini daha da artırın\n\nO, yenilənmiş qara siyahılardan istifadə edərək gerçək zamanlı zərərli bağlantıları aşkarlaya, bloklama və onlar barədə xəbərdarlıq edə bilər</string>
    <string name="low_memory">Aşağı yaddaş</string>
    <string name="low_memory_info">Tətbiqin yaddaşı azalır, çökmələr gözlənilir</string>
    <string name="full_payload_disabled">Tam faydalı yük seçimi deaktiv edildi</string>
    <string name="capture_stopped_low_memory">İzləmə prossesi dayandırıldı</string>
    <string name="heap_usage">Heap istifadəsi</string>
    <string name="vpn_exemptions">VPN istisnaları</string>
    <string name="unlock_token_error">kilidli jeton istəyi mümkün olmadı [%1$d]: %2$s</string>
    <string name="license_service_unavailable">PCAPdroid lisenziya xidməti hal-hazırda əlçatan deyil. Zəhmət olmasa, bir neçə dəqiqə sonra yenidən cəhd edin</string>
    <string name="requesting_unlock_token">Kilidaçma jetonu istənilir, zəhmət olmasa, gözləyin</string>
    <string name="show_action">Göstər</string>
    <string name="show_connection">Əlaqəni göstər</string>
    <string name="show_system_apps">Sistem tətbiqlərini göstər</string>
    <string name="paid_feature">Ödənişli xüsusiyyət</string>
    <string name="firewall_purchase_msg">Bağlantıları bloklamağa başlamaq üçün <i>%1$s</i> xüsusiyyətini alın</string>
    <string name="mitm_wizard_description">TLS deşifrələməsi üçün cihazınızı konfiqurasiya edin</string>
    <string name="mitmproxy_opts">Əlavə ortadakı adam hücumu proksi (mitmproxy) seçimləri</string>
    <string name="mitmproxy_opts_description">Ortadakı adam hücumu proksisi (mitmproxy) üçün əlavə seçimlər təmin edin</string>
    <string name="whitelist_mode">Ağ siyahı modu</string>
    <string name="firewall_whitelist_notice">Bu modda, əllə ağ siyahıya salınmadığı müddətcə bütün bağlantılar bloklanacaq. Uyğun bir ağ siyahı olmadan bildirişləri görməyə bilərsiniz</string>
    <string name="original_port">Orijinal (əsas) port</string>
    <string name="required">gərəkli</string>
    <string name="destination_host">Hədəf host</string>
    <string name="destination_port">Hədəf port</string>
    <string name="port_mapping_exists">Port yönləndirmə artıq təyin edilib</string>
    <string name="add_to_fw_whitelist">Təhlükəsizlik divarı ağ siyahısına əlavə et</string>
    <string name="remove_from_fw_whitelist">Təhlükəsizlik divarı ağ siyahısından sil</string>
    <string name="reset_stats_confirm">Bu statistikaları həqiqətən sıfırlamaq istəyirsinizmi?</string>
    <string name="port_mapping">Port yönləndirmə</string>
    <string name="dns_servers">DNS serverləri</string>
    <string name="ipv6_dns_server">İPv6 DNS serveri</string>
    <string name="use_system_dns">Sistem DNS-dən istifadə et</string>
    <string name="use_system_dns_summary">Mümkünsə, sistem DNS serverlərindən istifadə et</string>
    <string name="rule_exists">Qayda artıq müəyyən edilib</string>
    <string name="dns_servers_summary">İzləmə zamanı istifadə ediləcək DNS serverləri konfiqurasiya edin</string>
    <string name="pcapng_format">Pcapng formatı</string>
    <string name="sort_by">Sırala</string>
    <string name="total_bytes">Ümumi baytlar</string>
    <string name="password">Şifrə</string>
    <string name="invalid_license">Etibarsız lisenziya</string>
    <string name="connection_error">Bağlantı xətası: %1$s</string>
    <string name="write_ext_storage_failed">Xarici yaddaşa yazma uğursuz oldu. Detallar üçün tətbiqin loqlarına baxın</string>
    <string name="qr_info_text">PCAPdroid-i Google Play-dən quraşdırın və bu QR kodu skan edin</string>
    <string name="qr_purchase_required">QR kod ilə aktivləşdirməyə davam etmək üçün kilid açma jetonu alın</string>
    <string name="license_activation_ok">Lisenziya kativləşdirmə tamamlandı</string>
    <string name="mitm_addon_starting">Ortadakı adam hücumu əlavəsi başladılır…</string>
    <string name="mitm_addon_running">Ortadakı adam hücumu əlavəsi işləyir</string>
    <string name="decryption_rules">Deşifrələmə qaydaları</string>
    <string name="decrypt_action">Deşifrələ…</string>
    <string name="dont_decrypt_action">Deşifrələmə…</string>
    <string name="status_encrypted">Şifrəli</string>
    <string name="injected">İnyeksiya edildi</string>
    <string name="open_pcap_file">PCAP faylını aç…</string>
    <string name="pcap_load_success">PCAP faylı yükləndi</string>
    <string name="invalid_pcap_file">Etibarsız PCAP faylı</string>
    <string name="capture_interface_open_error">İzləmə interfeysini açmaq mümkün olmadı</string>
    <string name="pcap_file_not_exists">Təyin edilən PCAP faylı mövcud deyil</string>
    <string name="root_capture_start_failed">İzləməni başlatmaq mümkün olmadı. Cihazın Magisk ilə root edildiyindən əmin olun</string>
    <string name="pcap_read_error">Yaxalanan fayl oxunarkən xəta.Ətraflı məlumat üçün günlüyü yoxla</string>
    <string name="pcap_file_load_aborted">PCAP faylının yüklənməsi ləğv edildi</string>
    <string name="host_resolution_failed">%1$s host ünvanı problemini həll etmək mümkün olmadı</string>
    <string name="active_vpn_detected">Aktiv VPN aşkarlandı</string>
    <string name="redirected">yenidən yönləndirmək</string>
    <string name="connection_redirected_port_map">Bu bağlantı port yönləndirməsinə görə yenidən yönləndirilmişdir</string>
    <string name="dnscrypt_how_to">PCAPdroid ilə DoH / DNSCrypt-dən necə istifadə edilir</string>
    <string name="for_connections_to_decrypt">Sadəcə deşifrələnəcək bağlantılar üçün</string>
    <string name="target_apps">Hədəf tətbiqlər</string>
    <string name="target_apps_help">İzlənəcək tətbiqləri seçin</string>
    <string name="headers">Başlıqlar</string>
    <string name="body">Əsas hissə</string>
    <string name="both">Hər ikisi</string>
    <string name="whats_new">Yeniliklər</string>
    <string name="raw_bytes">Xam baytlar</string>
    <string name="restart_on_disconnection">Bağlantı kəsildiyində yenidən başlat</string>
    <string name="vpn_reconnection_aborted">VPN-nin yenidən bağlanması ləğv edildi</string>
    <string name="vpn_reconnection">VPN-nin yenidən bağlanması</string>
    <string name="decrypt_quic_notice">QUİC deşifrələməsi hal-hazırda dəstəklənmir. Müvəqqəti həll üçün izləmə funksiyasını dayandırın və PCAPdroid parametrlərində QUİC bloklama seçimini seçin</string>
    <string name="restart_on_disconnection_summary">Digər VPN tətbiqləri tərəfindən dayandırıldıqdan sonra izləməni avtomatik olaraq yenidən başlat</string>
    <string name="waiting_for_vpn_disconnect">Aktiv VPN bağlantısının kəsilməsi gözlənilir…</string>
    <string name="no_dump">Dempinq yoxdur</string>
    <string name="tot_connections">Toplam bağlantılar</string>
    <string name="notification_msg">%1$s izlənildi, %2$s bağlantılar</string>
    <string name="ctrl_consent">Bir tətbiq sizin cihazınızın trafikini izləmək (yaxalamaq) istəyir\nƏmin deyilsinizsə, rədd edin</string>
    <string name="allow">İcazə ver</string>
    <string name="ctrl_consent_allowed">PCAPdroid: kontrol etmə istəyinə icazə verildi</string>
    <string name="edit_list">Siyahıya düzəliş et</string>
    <string name="blacklists">Qara siyahı</string>
    <string name="malware_detection">Zərərli fayl, proqram aşkarlama</string>
    <string name="security">Təhlükəsizlik</string>
    <string name="malware_detection_summary">Üçüncü tərəf qara siyahılar vasitəsilə bilinən zərərli hostlara bağlantıları aşkarla</string>
    <string name="malicious_connection_filter">Zərərli fayl, proqram</string>
    <string name="url_val">URL: %1$s</string>
    <string name="copy_action">Nüsxələ…</string>
    <string name="start_at_boot_summary">Sistem yüklənəndən (boot) sonra izləməni avtomatik başlat</string>
    <string name="control_permissions_summary">Hansı tətbiqlərin PCAPdrod-in izləməsini kontrol etməyə icazəsi olduğunu yoxlayın</string>
    <string name="country">Ölkə</string>
    <string name="blacklist_type_ip">İP qara siyahı</string>
    <string name="asn">ASN</string>
    <string name="connections_checked">Yoxlanılan bağlantılar</string>
    <string name="decryption_no_filter_warn">İnternetə çıxışı itirməmək üçün TLS deşifrələməsi zamanı bir hədəf tətbiq seçin</string>
    <string name="malware_detection_learn_more">Zərərli fayl, tətbiq aşkarlama funksiyası haqqında daha çox məlumat əldə edin</string>
    <string name="connection_start_not_seen">PCAPdroid bu bağlantının başlanğıcını təsbit etmədi. Bəzi məlumatlar əskik ola bilər</string>
    <string name="network_traffic">Trafik</string>
    <string name="downloading">Yüklənir…</string>
    <string name="geo_db_delete">Məlumat bazasını silmək və boş yer açmaq üçün toxunun</string>
    <string name="geo_db_not_found">Məlumat bazası tapılmadı. GPS aktiv deyil</string>
    <string name="geo_db_download">Ən son məlumat bazasını yükləmək üçün toxunun. Yeni məlumat bazaları aylıq olaraq yayımlanır</string>
    <string name="size_x">Ölçü: %1$s</string>
    <string name="import_action">İdxal et</string>
    <string name="firewall_is_disabled">Təhlükəsizlik divarı aktiv deyil</string>
    <string name="discard_action">Saxlama</string>
    <string name="rules_delete_confirm">Seçilən qaydalar silinsinmi?</string>
    <string name="action_unblock">Bloklamanı aç</string>
    <string name="firewall_summary">Tətbiqlərin internetə girişini bloklayın, xüsusi domenlər və İP ünvanları üçün qaydaları konfiqurasiya edin. Sadəcə root olmayan izləmədə işə yarayır</string>
    <string name="add_action">Əlavə et</string>
    <string name="redirect_to">Buraya yönləndir:</string>
    <string name="ipv4_dns_server">İPv4 DNS serveri</string>
    <string name="items_delete_confirm">Seçilmişlər silinsinmi?</string>
    <string name="ip_address">İP adresi</string>
    <string name="ip_address_or_cidr">İP adresi / CIDR</string>
    <string name="external_storage_perm_required">Xarici yaddaş qurğusuna giriş icazəsi lazımdır</string>
    <string name="many_rules_warning">Çox sayda qaydaları idxal etməyə çalışırsınız, nəticədə bəzi prosseslər zamanı tətbiqin fəaliyyətində problemlər yarana bilər. Həqiqətən davam etmək istəyirsinizmi?</string>
    <string name="username">İstifadəçi adı</string>
    <string name="qr_license_confirm">Aşağıdakı kilid açma jetonundan istifadə edərək %1$s cihazı üçün lisenziya yaratmaq istəyirsinizmi?</string>
    <string name="activate_via_qr_code">QR kod ilə aktivləşdir</string>
    <string name="qr_code_expired">QR kod istifadə müddəti bitib. Yeni bir QR kod yaradın və yenidən cəhd edin</string>
    <string name="mitm_doze_notice">Batareya optimallaşdırması ortadakl adam hücumunun fəaliyyətinə mane ola bilər</string>
    <string name="tls_decryption_no_rules_notice">TLS deşifrələmə sadəcə konfiqurasiya edilmiş qaydalarla uyğunlaşan bağlantılara tətbiq edilir. İndi deşifrələmə qaydaları yaratmaq istəyirsinizmi?</string>
    <string name="never">Heç vaxt</string>
    <string name="always">Həmişə</string>
    <string name="malware_whitelist_help">Zərərli fayl, tətbiq aşkarlanmasına mane olmaq üçün istifadəçi tərəfindən təyin olunan ağ siyahı. Zərərli fayl, tətbiq kimi işarələnmələrini aradan qaldıran qaydalar yaratmaq üçün zərərli bağlantılara uzun basın</string>
    <string name="hidden_connections_help">Münasib olanlara diqqət etməyiniz üçün bağlantı siyahılarını gizlədən qaydalar siyahısı</string>
    <string name="mitm_setup_wizard_intro">Bu menyu, <a href="%1$s">TLS deşifrələmə</a> prossesini həyata keçirmək üçün lazım olan PCAPdroid ortadakı adam hücumu əlavəsi və sertifikasiya səlahiyyətini quraşdırılmasından sizə bələdçilik edəcəkdir</string>
    <string name="mitm_setup_wizard_done">PCAPdroid artıq TLS trafikini deşifrələmək üçün hazırdır\n\nDeşifrələməyə mane olacaq təhlükəsizlik tədbirlərini və onların öhdəsindən necə gələ biləcəyiniz haqqında daha çox məlumat əldə etmək üçün <a href="%1$s"> istifadəçi bələdçisinə </a> nəzər yetirin</string>
    <string name="app_intro_privacy_msg">Tətbiqdə hər hansısa izləmə, analiz və məlumat ötürmə kimi mənfi xüsusiyyətlər yoxdur\n\nNecə əmin olar bilərsiniz? <a href="%1$s">Gizlilik siyasətinə</a> və <a href="%2$s">mənbə koduna</a> nəzər yetirin</string>
    <string name="vpn_exemptions_summary">Bəzi tətbiqləri VPN bağlantısından azad edin. Onların trafikinə nəzarət olunmayacaq</string>
    <string name="unlock_token_summary">Tətbiqin Google Play xarici versiyalarında (məsələn, F-Droid/Github) ödənişli xüsusiyyətləri açmaq üçün istifadə edilən jeton</string>
    <string name="firewall_whitelist_help">Bu qaydalar hansı bağlantılara icazə veriləcəyini müəyyən edir. Bloklama siyahısı qaydalarının ağ siyahı qaydalarından daha üstündür</string>
    <string name="port_mapping_summary">Bağlantıları fərqli host və ya porta yenidən yönləndirmək üçün port yönləndirmə qaydalarını konfiqurasiya edin</string>
    <string name="pcapng_format_summary">Paketləri TLS deşifrələmə gizliliklərinə yeridilməsinə imkan verən \"pcapng dump\" formatına yığ</string>
    <string name="license_error">Lisenziya yaratma xətası[%1$d]: %2$s</string>
    <string name="mitm_addon_autostart_workaround">Ortadakı adam hücumu əlavəsinə bağlanma uğursuz oldu. Müvəqqəti həll üçün ortadakı adam hücumu əlavəsi tətbiqini açmağı və onu bağlamadan PCAPdroid tətbiqinə geri qayıtmağı yoxlaya bilərsiniz. Onu indi açmaq istəyirsinizmi?</string>
    <string name="requesting_license">Yeni lisenziya istənilir, zəhmət olmasa, gözləyin</string>
    <string name="license_limit_reached">Bu kilid açma jetonu üçün lisenziya limitinə çatmısınız. Daha çox lisenziya yaratmaq üçün yeni jeton alın</string>
    <string name="access_paid_features_msg">Ödənişli xüsusiyyətlərdən necə istifadə edəcəyinizi öyrənmək üçün <a href="%1$s">istifadəçi bələdçisinə</a> nəzər yetirin</string>
    <string name="unlock_token_msg1">Bu sizin kilid açma jetonunuzdur. <a href="%1$s">Lisenziya kodlarınızı hazırlamaq üçün</a> ona ehtiyacınız olacağından onu qeyd edin</string>
    <string name="mitm_skip_notice">Ortadakı adam hücumu sertifikatı yüklənmiş görünmür. Əgər davam etsəniz, deşifrələmə uğursuz ola bilər</string>
    <string name="mitm_addon_error">Ortadakı adam hücumu əlavəsi başladılarkən xəta baş verdi. Detallar üçün loqlara baxın</string>
    <string name="decryption_rules_help">Bu qaydalar hansı bağlantıların deşifrələnəcəyini müəyyən edir. Host əsaslı qaydalar sadəcə əvvəlcədən bir DNS cavabı olduqda işləyir</string>
    <string name="unsupported_pcap_datalink">PCAP faylında dəstəklənməyən məlumat linki var</string>
    <string name="root_capture_pcapd_start_failure">İzləməni başlatamq mümkün olmadı. PCAPdroid-ə root icazəsi verdiyinizdən əmin olun</string>
    <string name="pcapdroid_trailer_notice">\"%1$s\" yerinə gerçək tətbiqləri göstərmək üçün PCAP faylının idxal olunmasından əvvəl \"%2$s\" seçiminin aktiv olduğundan əmin olun</string>
    <string name="decryption_info_no_rule">Bu bağlantını deşifrələməkçün, sol çəkməcədə ya da bağlantı siyahısındakı mətn əsaslı menyudan deşifrələmə qaydası yaradın.</string>
    <string name="vpn_setup_msg">PCAPdroid, şəbəkə trafikini root olmadan izləmək üçün VPN kimi davranır.\n\nİzləməni başlatmaq üçün bir sonrakı ekranda VPN istəyini qebul etməlisiniz.\n\n<b>QEYD:</b> Davam etmək üçün Andoid parametrlərindən konfiqurasiya edilmiş hər zaman açıq VPN-ləri dekativ edin</string>
    <string name="app_intro_traffic_inspection">Daxili dekoderlər sayəsində HTTP istəkərini, cavabları və xam məlumatları yoxlamaq asandır\n\nŞifrəli bağlantınız varmı? Deşifrələnmiş məlumatları əldə etmək üçün <a href="%1$s">TLS deşifrələməsini</a> aktiv edə bilərsiniz</string>
    <string name="app_intro_firewall_msg">Daxili <a href="%1$s">təhlükəsizlik divarı</a> ilə fərdi tətbiqlərə, domenlərə və ölkələrə internet çıxışını asanlıqla bloklaya bilərsiniz\n\nBunu daxili trafik monitorinqi funksiyası ilə birləşdirərək gizliliyinizi qorumaq üçün çox yaxşı bir alət əldə edin</string>
    <string name="app_intro_traffic_dump">PCAPdroid, daha çox analiz üçün trafiki standart PCAP formatında yığmaq üçün <a href="%1$s">müxtəlif seçimlər, üsullar</a> təqdim edir\n\n<a href="%2$s">treyler seçimi</a> ilə siz paketlərə tətbiq adlarını əlavə edə və onları Wirshark-da göstərə bilərsiniz</string>
    <string name="tls_decryption_with_root_msg">TLS deşifrələməsini root-la işlətmə funksiyası eksperimental xüsusiyyətdir. Məlum olan xətaların siyahısı:\n\n- PCAPdroid-də trafiki orijinal tətbiq yerinə ortadakı adam hücumu əlavəsi tətbiqindən hazırlanmış şəkildə görəcəksiniz\n- SSL açar günlüyünün dempinqi dəstəklənmir\n- tətbiq filteri təyin olunduğunda deşifrələmə sadəcə hədəf tətbiq üçün keçərli olacaqdır, lakin PCAPdroid hələ də digər tətbiqlərin trafikini göstərəcəkdir\n- əgər izləməni başlatmaq uğursuz olduqda iptables əmrini həqiqətən root olaraq işə saldığınızdan əmin olun (məs. termux ilə)\n- bu, android 12 və sonrakı versiyalarda işləməyə bilər\n- əgər VPN tətbiqi işləmirsə, deşifrələmə üçün xüsusi bir tətbiq seçməlisiniz və ya VPN-dən PCAPdroid ortadakı adam hücumu əlavəsini istisna etməlisiniz, əks halda trafik sonsuz döngəyə girəcəkdir.</string>
    <string name="malicious_connections_notice">Qara siyahılarda müsbət yalnışlar olabilir.İki dəfə basmaqla İP adres/yer adı bilinirliyindən əmin olun. Zərərli tətbiq ağ siyahısı ilə,müsbət yalnışları kənar tutabilərsiz.</string>
    <string name="dump_extensions">PCAPdroid əlavələri</string>
    <string name="dump_extensions_how_to">PCAPdroid məlumat yığını uzantılarını Wiresharkda necə görüntülənir</string>
    <string name="malicious_connection_description">"\"%1$s\" Programından gələn qoşulma,  zərərli tətbiq təspit qaydasını tətiklədi  (%2$s)"</string>
    <string name="geo_db_missing">Coğrafi məlumat bazası çatışmır</string>
    <string name="country_rules_warning">Ölkə üzrə qorunma qaydalarını istifadə etmək üçün,PCAPdroid coğrafi məlumat bazasından ayarları yükləyin,əks halda ölkə üzrə qaydalar təsirsiz olacaq</string>
    <string name="unsupported_pcap_file">Dəstəklənməyən yaxalama qovluq formatı</string>
    <string name="decrypt_pcap_file">Şifrəsizləşdir PCAP/Pcaping faylı…</string>
    <string name="keylog_read_error">SSL açar günlüyü oxu xətası</string>
    <string name="bytes_threshold">Bit limiti</string>
    <string name="select_the_pcap_file">PCAP/Pcapng fayl seç</string>
    <string name="select_the_keylog_file">SSL açar günlüyü faylını seç</string>
    <string name="error_code_with_text">%1$s (xəta %2$d)</string>
    <string name="errno_epipe">Sınıq boru</string>
    <string name="errno_epipe_msg">Məlumat ötürülməsi zamanı,server gözlənilmədən qapandı</string>
    <string name="errno_enetdown">Şəbəkə çöküb</string>
    <string name="errno_enetdown_msg">Şəbəkə görünürü çöküb ya da şəbəkəyə qoşulabilmir</string>
    <string name="errno_enetunreach">Şəbəkə əlçatmazdır</string>
    <string name="errno_enetunreach_msg">Sistem hədəfə çatmaq üçün, rəsmi yol tapmadı</string>
    <string name="errno_enetreset">Şəbəkə sıfırla</string>
    <string name="errno_econnreset_msg">Server,çökmə və istənməyən söndürülmə səbəb ilə qoşulmanı bağladı</string>
    <string name="errno_econnrefused_msg">Server qoşulmanı rəddetdi,bu da çox məşğulluğ ya da nasazlığ göstəricisidir</string>
    <string name="dns_conn_info">DNS çevirir sahə adları ip adresə çevirir.Əsas məlumat sonra HTTPS/TLS qoşulma üzərindən alışverişlənir</string>
    <string name="dump_extensions_summary">Paket yığını formatını əlavə metadata ilə genişləndir,hansı ki verilən göndər/götür paketini</string>
    <string name="errno_enetreset_msg">Şəbəkə aradakı ötürücü cihaz tərəfindən sıfırlandı (misal:yönləndirici ya da sim operator )</string>
    <string name="errno_econnaborted">Qoşulma dayandı</string>
    <string name="errno_econnaborted_msg">Şəbəkə keçişinə görə qoşulma dayandı</string>
    <string name="errno_econnreset">Şəbəkə digər ucda sıfırlandı</string>
    <string name="errno_etimedout">Qoşulma vaxtı bitdi</string>
    <string name="errno_etimedout_msg">Server cavabı uzun çəkdi, şəbəkə gecikməsi ya da server məşğulluğu səbəbi ilə</string>
    <string name="errno_econnrefused">Qoşulma rədd edildi</string>
    <string name="errno_ehostunreach">Barındırıcıya marşrut yoxdur</string>
    <string name="errno_ehostunreach_msg">Sistem hədəf barındırıcıya marşrutu tapmadı</string>
    <string name="tls_conn_info">TLS/HTTPS trafiki şifrəlidir.Bu trafiki incələmək üçün,deşifrləməyə ehtiyacın var.Yoxla PCAPdroid <a href="%1$s">istifadəçi təlimatını</a> ətraflı üçün</string>
    <string name="tls_decryption_not_supported_16KB">TLS deşifrələməsi hazırda 16 KB cihazlarda dəstəklənmir</string>
    <string name="filename_prefix">Fayl adı prefiksi</string>
    <string name="filename_prefix_description">PCAPdroid tərəfindən ixrac edilən fayllar üçün prefiks təyin edin, məs. PCAP faylları</string>
    <string name="no_requests">Sorğu yoxdur</string>
    <string name="item_not_found">Göstərilən element tapılmadı</string>
    <string name="connection_number">Əlaqə #%1$d</string>
    <string name="http_request_number">HTTP sorğu #%1$d</string>
    <string name="http_requests">HTTP sorğuları</string>
    <string name="switch_to_http">HTTP sorğularını göstər</string>
    <string name="switch_to_connections">Əlaqələri göstər</string>
    <string name="decryption_error">Deşifrə xətası</string>
    <string name="previous">Əvvəlki</string>
    <string name="next">Növbəti</string>
    <string name="save_as_text">Mətn olaraq saxla</string>
    <string name="save_as_har">HAR olaraq saxla</string>
    <string name="tcp_collector_info">TCP toplayıcısı: %1$s%2$d</string>
    <string name="tcp_exporter">TCP ixracatçısı</string>
    <string name="tcp_udp_exporter">TCP/UDP ixracatçısı</string>
    <string name="tcp_exporter_info">PCAP məlumatını uzaq TCP qəbuledicisinə göndər (pcap-over-ip vasitəsilə)</string>
</resources>

```

`app/src/main/res/values-de/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="title_activity_settings">Einstellungen</string>
    <string name="ready">Bereit</string>
    <string name="connections_view">Verbindungen</string>
    <string name="no_connections">Keine Verbindungen</string>
    <string name="connection_details">Verbindungsdetails</string>
    <string name="protocol">Protokoll</string>
    <string name="source">Quelle</string>
    <string name="packets">Pakete</string>
    <string name="duration">Dauer</string>
    <string name="stop_button">Stoppen</string>
    <string name="start_button">Starten</string>
    <string name="destination">Ziel</string>
    <string name="http_server_status">HTTP-Server: http://%1$s:%2$d</string>
    <string name="query">Abfrage</string>
    <string name="host">Host</string>
    <string name="about">Über</string>
    <string name="status">Status</string>
    <string name="app">App</string>
    <string name="http_server">HTTP-Server</string>
    <string name="no_dump">Kein Mitschnitt</string>
    <string name="http_server_info">Starte einen HTTP-Server für den PCAP download</string>
    <string name="user_guide">Benutzerhandbuch</string>
    <string name="open_telegram_group">Telegram-Gruppe</string>
    <string name="source_code">Quellcode</string>
    <string name="yes">Ja</string>
    <string name="no">Nein</string>
    <string name="vpn_setup_failed">VPN konnte nicht eingerichtet werden. Stelle sicher, dass Always-on VPN deaktiviert ist</string>
    <string name="app_not_found">App %1$s konnte nicht gefunden werden</string>
    <string name="stats">Statistiken</string>
    <string name="active_connections">Aktive Verbindungen</string>
    <string name="udp_exporter">UDP-Exporter</string>
    <string name="udp_exporter_info">Sendet das PCAP zu einen remote UDP-Server</string>
    <string name="http_server_port">HTTP-Server-Port</string>
    <string name="no_dump_info">Verkehr wird nicht gedumpt</string>
    <string name="receiver_port">Empfänger-Port</string>
    <string name="dropped_connections">Abgebrochene Verbindungen</string>
    <string name="tot_connections">Verbindungen insgesamt</string>
    <string name="open_sockets">Offene Sockets</string>
    <string name="bytes_sent">Bytes gesendet</string>
    <string name="bytes_rcvd">Bytes empfangen</string>
    <string name="packets_sent">Pakete gesendet</string>
    <string name="packets_rcvd">Pakete empfangen</string>
    <string name="dns_queries">DNS-Abfragen</string>
    <string name="search_apps">Suche Apps</string>
    <string name="no_apps">Keine Apps</string>
    <string name="dns_server">DNS-Server</string>
    <string name="apps">Apps</string>
    <string name="pcap_file">PCAP-Datei</string>
    <string name="pcap_file_info">Erstelle eine PCAP/Pcapng-Datei im Gerätespeicher</string>
    <string name="cannot_write_file">Datei kann nicht geschrieben werden</string>
    <string name="share">Teilen</string>
    <string name="pcap_file_action">In der Datei \"%1$s\" gespeicherter Netzwerktraffic (%2$s)</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="conn_status_closed">Geschlossen</string>
    <string name="copy_to_clipboard">Kopieren</string>
    <string name="first_seen">Start der Verbindung</string>
    <string name="last_seen">Letztes Verbindungspaket erhalten</string>
    <string name="capture_running">Aufnahme läuft</string>
    <string name="notification_msg">%1$s aufgenommen, %2$s Verbindungen</string>
    <string name="paid_features">Kostenpflichtige Funktionen</string>
    <string name="malware_whitelist_help">Benutzerdefinierte Positivliste zur Verhinderung der Malware-Erkennung. Langes drücken auf bösartige Verbindungen kann zum Erstellen von Regeln genutzt werden, um die Malware-Markierung aufzuheben</string>
    <string name="whitelist">Positivliste</string>
    <string name="malware_detection_summary">Erkennung von Verbindungen zu bekannten bösartigen Hosts über Sperrlisten von Drittanbietern</string>
    <string name="billing_connecting">Verbinde mit Google Play… Versuche es später noch einmal</string>
    <string name="hidden_connections_help">Liste der Regeln zum Ausblenden von Verbindungslisteneinträgen, um sich auf relevante fokussieren zu können</string>
    <string name="control_permissions">Berechtigungssteuerung</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="no_permissions_set_info">Keine Berechtigungen festgelegt. Rufen Sie PCAPdroid über StartActivityForResult auf, um die Berechtigungsabfrage anzuzeigen</string>
    <string name="status_outdated">Veraltet</string>
    <string name="status_not_loaded">Nicht geladen</string>
    <string name="connections_checked">Geprüfte Verbindungen</string>
    <string name="ok">OK</string>
    <string name="delete_error">Datei kann nicht gelöscht werden</string>
    <string name="delete">Löschen</string>
    <string name="ctrl_consent_denied">PCAPdroid: Die Steuerungsanfrage wurde abgelehnt</string>
    <string name="private_dns_message_notice">Ein privates DNS verhindert, dass PCAPdroid den DNS-Datenverkehr untersucht. Diese Einstellung kann in den Android-Netzwerkeinstellungen deaktiviert werden</string>
    <string name="last_blacklists_update">Letzte Aktualisierung</string>
    <string name="select_all">Alles auswählen</string>
    <string name="enable_socks5_proxy_summary">Umleiten aller TCP-Verbindungen an einen SOCKS5 Proxy</string>
    <string name="receiver_ip_address">Empfänger-IP-Adresse</string>
    <string name="malware_detection_learn_more">Erfahre mehr über die Malware-Erkennungsfunktion</string>
    <string name="save_ok">Gespeichert</string>
    <string name="internet">Internet</string>
    <string name="uid">UID</string>
    <string name="netd_app_info">Der System-Daemon, der die DNS-Auflösungen durchführt</string>
    <string name="rcvd_and_sent">%1$s empfangen — %2$s gesendet</string>
    <string name="collector_info">UDP-Kollektor: %1$s:%2$d</string>
    <string name="save_to_file">Speichern unter</string>
    <string name="older_connections_notice">%1$d ältere Verbindungen werden nicht angezeigt</string>
    <string name="unknown_app">Unbekannt</string>
    <string name="error">Fehler</string>
    <string name="conn_status_unreachable">Unerreichbar</string>
    <string name="other_prefs">Andere</string>
    <string name="app_language">App-Sprache</string>
    <string name="system_default">Systemvorgabe</string>
    <string name="file_saved_with_name">Datei als \"%1$s\" gespeichert</string>
    <string name="get_app">Herunterladen:</string>
    <string name="no_activity_file_selection">Keine App für die Dateiauswahl gefunden</string>
    <string name="about_text">PCAPdroid ist ein Open-Source-Netzwerkaufnahme- und Überwachungswerkzeug, das ohne Root-Rechte funktioniert</string>
    <string name="proxy_port">Proxy-Port</string>
    <string name="root_capture_summary">Erlaubt PCAPdroid die Ausführung mit anderen VPN-Apps</string>
    <string name="donate">Spenden</string>
    <string name="search">Suche…</string>
    <string name="app_val">App: %1$s</string>
    <string name="ip_address_val">IP-Adresse: %1$s</string>
    <string name="host_val">Host: %1$s</string>
    <string name="protocol_val">Protokoll: %1$s</string>
    <string name="hide">Verstecken…</string>
    <string name="n_selected">%1$d ausgewählt</string>
    <string name="app_details">App-Details</string>
    <string name="package_name">Paketname</string>
    <string name="app_name">Name</string>
    <string name="version">Version</string>
    <string name="target_sdk">Ziel-SDK</string>
    <string name="installed_on">Installiert am</string>
    <string name="last_update">Letztes Update</string>
    <string name="permissions">Berechtigungen</string>
    <string name="root_app_info">System-Daemon, der mit maximalen Berechtigungen ausgeführt werden</string>
    <string name="android_app_info">Das Android-System</string>
    <string name="unknown_app_info">„Unbekannt“ markiert Verbindungen, deren App nicht ermittelt werden konnte</string>
    <string name="packets_dropped">Entfallene Pakete</string>
    <string name="root_capture">Als Root aufnehmen</string>
    <string name="pending_transaction">Bitte schließe deine Transaktion ab, um diese Funktion einzulösen</string>
    <string name="allow">Erlauben</string>
    <string name="ctrl_consent_title">PCAPdroid-Steuerungsanforderung</string>
    <string name="deny">Ablehnen</string>
    <string name="ctrl_consent_allowed">PCAPdroid: Die Steueranfrage wurde zugelassen</string>
    <string name="all_interfaces">Alle Schnittstellen</string>
    <string name="capturing_from">Erfasse Pakete von \"%1$s\"</string>
    <string name="edit_filter">Filter bearbeiten</string>
    <string name="edit_list">Liste bearbeiten</string>
    <string name="hidden_connections_rules">Versteckte Verbindungsregeln</string>
    <string name="list_is_empty">Die Liste ist leer</string>
    <string name="show_only_malicious">Bösartige Verbindungen</string>
    <string name="security">Sicherheit</string>
    <string name="malware_detection">Malware-Erkennung</string>
    <string name="reset">Zurücksetzen</string>
    <string name="feature_not_available">Diese Funktion ist derzeit für dein Gerät nicht verfügbar</string>
    <string name="capture_prefs">Aufnehmen</string>
    <string name="ctrl_consent">Eine App möchte den Datenverkehr Ihres Geräts aufnehmen. 
\nLehne ab, wenn du dir nicht sicher bist</string>
    <string name="capture_interface">Aufnahmeschnittstelle</string>
    <string name="malware_whitelist_rules">Regeln für Malware-Positivliste</string>
    <string name="malicious_connection_filter">Bösartig</string>
    <string name="status_filter">HTTP-Status: %1$s</string>
    <string name="not_hidden_filter">Nicht versteckt</string>
    <string name="copy_action">Kopieren…</string>
    <string name="url_val">URL: %1$s</string>
    <string name="show_me">Anzeigen</string>
    <string name="hint">Hinweis</string>
    <string name="once">Einmal</string>
    <string name="forever">Für immer</string>
    <string name="country">Land</string>
    <string name="asn">ASN</string>
    <string name="country_val">Land: %1$s</string>
    <string name="send_report">Bericht senden</string>
    <string name="start_at_boot">Beim Booten starten</string>
    <string name="malware_status_ok">Kein schädlicher Datenverkehr erkannt</string>
    <string name="malware_status_detected">Schädliche Verbindungen erkannt</string>
    <string name="status_uptodate">Auf dem neusten Stand</string>
    <string name="blacklist_type">Typ: %1$s</string>
    <string name="n_rules">%1$s Regeln</string>
    <string name="malicious_connections">Bösartige Verbindungen</string>
    <string name="last_update_val">Letzte Aktualisierung: %1$s</string>
    <string name="control_permissions_summary">Überprüfe, welche Apps die PCAPdroid-Aufnahme steuern dürfen</string>
    <string name="start_at_boot_summary">Aufnahme nach dem Booten automatisch starten</string>
    <string name="blacklists">Sperrlisten</string>
    <string name="blacklist_type_ip">IP-Sperrliste</string>
    <string name="blacklist_type_domain">Domain-Sperrliste</string>
    <string name="updated_blacklists">Aktualisierte Sperrlisten</string>
    <string name="domain_rules">Domain-Regeln</string>
    <string name="ip_rules">IP-Regeln</string>
    <string name="update_now">Jetzt aktualisieren</string>
    <string name="status_updating">Aktualisierung…</string>
    <string name="private_dns_hinders_detection">Privates DNS verhindert die Erkennung</string>
    <string name="decryption_no_filter_warn">Wähle beim Entschlüsseln von TLS eine Ziel-App aus, um die Internetverbindung nicht zu verlieren</string>
    <string name="block">Sperren…</string>
    <string name="firewall">Firewall</string>
    <string name="firewall_rules">Firewall-Regeln</string>
    <string name="blocked_pkts">Gesperrt</string>
    <string name="n_pkts">%1$s Pkt</string>
    <string name="blocked_connection_filter">Gesperrt</string>
    <string name="validate">Bestätigen</string>
    <string name="valid">Gültig</string>
    <string name="invalid">Ungültig</string>
    <string name="no_intent_handler_found">Keine App zum Ausführen dieser Aktion gefunden</string>
    <string name="network_interface">Schnittstelle</string>
    <string name="interface_filter">Schnittstelle: %1$s</string>
    <string name="request_method">Anfragemethode</string>
    <string name="loading">Wird geladen…</string>
    <string name="purchased">Gekauft</string>
    <string name="no_items_for_purchase">Keine Artikel zum Kauf verfügbar</string>
    <string name="billing_failure">Es konnte keine Verbindung zu Google Play hergestellt werden. Bitte versuche es später erneut</string>
    <string name="learn_more">Mehr erfahren</string>
    <string name="buy_action">Kaufen</string>
    <string name="malware_status_update_failed">Einige Sperrlisten sind veraltet</string>
    <string name="copied">Kopiert</string>
    <string name="can_use_purchased_feature">Gekaufte Funktion jetzt verwenden werden</string>
    <string name="disconnect_vpn_confirm">Wenn Sie fortfahren wird die aktive VPN Verbindung unterbrochen</string>
    <string name="loading_apps">Lade Apps…</string>
    <string name="open_nav_drawer">Menü öffnen</string>
    <string name="close_nav_drawer">Menü schließen</string>
    <string name="capture_not_running_status">Die Aufnahme läuft nicht</string>
    <string name="start_capture_first">Starte zuerst die Aufnahme</string>
    <string name="capture_all_apps">Datenverkehr aller Apps aufnehmen</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="socks5_info">SOCKS5-Proxy: %1$s:%2$d</string>
    <string name="phone_app_info">Telefoniedienste</string>
    <string name="action_block">Sperren</string>
    <string name="connection_blocked">Diese Verbindung wurde von PCAPdroid gesperrt</string>
    <string name="netd_block_missed">Diese Verbindung wurde von netd initiiert und konnte daher nicht gesperrt werden</string>
    <string name="action_unblock">Entsperren</string>
    <string name="conn_status_active">Aktiv</string>
    <string name="blocklist">Sperrliste</string>
    <string name="connections_blocked">Gesperrte Verbindungen</string>
    <string name="block_private_dns">Privates DNS sperren</string>
    <string name="firewall_summary">Sperre den Internetzugang für Apps, konfiguriere Regeln für bestimmte Domänen und IP-Adressen. Funktioniert nur mit der Nicht-Root-Erfassung</string>
    <string name="app_intro_firewall_msg">Mit der integrierten <a href="%1$s">Firewall</a> kannst du ganz einfach den Internetzugang zu einzelnen Apps, Domains und Ländern sperren\n \nKombiniere dies mit der integrierten Sichtbarkeit des Datenverkehrs, um das ultimative Tool zum Schutz deiner Privatsphäre zu erhalten</string>
    <string name="app_intro_malware_detection">Verbessere die Sicherheit deines Geräts mit der Funktion <a href="%1$s">Malware-Erkennung</a>
\n
\nDurch die Verwendung aktueller Blacklists kann es bösartige Verbindungen in Echtzeit erkennen, blockieren und warnen</string>
    <string name="block_new_apps">Neu installierte Apps sperren</string>
    <string name="app_blocked">App gesperrt</string>
    <string name="allowed_connection_filter">Erlaubt</string>
    <string name="unblock">Entsperren…</string>
    <string name="tls_decryption">TLS-Entschlüsselung</string>
    <string name="last_firewall_block">Letzte Sperre</string>
    <string name="firewall_purchase_msg">Kaufe die Funktion <i>%1$s</i>, um Verbindungen zu sperren</string>
    <string name="show_only_cleartext">Klartext-Verbindungen</string>
    <string name="block_quick">QUIC sperren</string>
    <string name="block_private_dns_summary">Private DNS erkennen und möglicherweise sperren, um DNS-Verkehr zu untersuchen. Die Deaktivierung dieser Funktion kann die Analyse des Datenverkehrs behindern</string>
    <string name="firewall_filter">Firewall: %1$s</string>
    <string name="unblock_permanently">Dauerhaft entsperren</string>
    <string name="unblock_for_n_hours">Entsperren für %1$dh</string>
    <string name="unblock_for_n_minutes">Entsperren für %1$dm</string>
    <string name="app_blocked_info">Die %1$s App wurde von der Firewall gesperrt</string>
    <string name="app_unblocked">Die App %1$s wurde entsperrt</string>
    <string name="phone_app">Telefon</string>
    <string name="install_action">Installieren</string>
    <string name="export_action">Exportieren</string>
    <string name="checking_the_certificate">Zertifikat wird überprüft…</string>
    <string name="app_log">Protokoll</string>
    <string name="no_data">Keine Daten</string>
    <string name="malware_whitelist_action">Whitelist (Malware)…</string>
    <string name="ca_cert_export_failed">Beim Exportieren des CA-Zertifikats ist ein Fehler aufgetreten
\n
\nWenn Ihr Gerät Autostart oder ähnliche Software implementiert, um die Ausführung von Hintergrunddiensten einzuschränken, stellen Sie sicher, dass Sie <a href="%1$s">PCAPdroid</a> auf die weiße Liste setzen</string>
    <string name="mitm_addon">mitm Addon</string>
    <string name="export_failed">Export fehlgeschlagen</string>
    <string name="not_encrypted">Nicht verschlüsselt</string>
    <string name="request">Anfrage</string>
    <string name="websocket">WebSocket</string>
    <string name="http">HTTP</string>
    <string name="not_decryptable">Nicht entschlüsselbar</string>
    <string name="decrypted">Entschlüsselt</string>
    <string name="decryption">Entschlüsselung</string>
    <string name="decryption_filter">Status: %1$s</string>
    <string name="connection_start_not_seen">PCAPdroid hat den Beginn dieser Verbindung nicht gesehen. Einige Informationen fehlen möglicherweise</string>
    <string name="warn_no_app_data">Es wurden keine Anwendungsdaten ausgetauscht</string>
    <string name="waiting_application_data">Wartende Daten</string>
    <string name="downloading">Wird heruntergeladen…</string>
    <string name="download_in_progress">Download läuft, bitte warten</string>
    <string name="download_failed">Download fehlgeschlagen</string>
    <string name="geo_db_download">Tippen Sie hier, um die neueste Datenbank herunterzuladen. Neue Datenbanken sind monatlich verfügbar</string>
    <string name="geo_db_delete">Tippen Sie, um die Datenbank zu löschen und Speicherplatz zu sparen</string>
    <string name="size_x">Größe: %1$s</string>
    <string name="download">Download</string>
    <string name="import_action">Importieren</string>
    <string name="import_failed">Import fehlgeschlagen</string>
    <string name="invalid_backup">Ungültiges Sicherungsformat</string>
    <string name="rules_import_success">Importierte Regeln %1$d</string>
    <string name="rules_delete_confirm">Ausgewählte Regeln löschen\?</string>
    <string name="num_configured_rules">Konfigurierte Regeln</string>
    <string name="firewall_is_disabled">Firewall ist deaktiviert</string>
    <string name="firewall_is_enabled">Firewall ist aktiviert</string>
    <string name="no_root_firewall">No-Root-Firewall</string>
    <string name="mitm_setup_wizard_intro">Dieser Assistent führt Sie durch die Installation des PCAPdroid mitm-Addons und des Zertifikates, die zur Durchführung der <a href="%1$s">TLS-Entschlüsselung benötigt werden</a></string>
    <string name="mitm_setup_wizard_done">PCAPdroid ist nun bereit, den TLS-Datenverkehr zu entschlüsseln
\n
\nSchauen Sie sich das Benutzerhandbuch <a href="%1$s"/> an, um mehr über die Sicherheitsmaßnahmen zu erfahren, die eine Entschlüsselung verhindern können und wie diese umgangen werden können</string>
    <string name="welcome_to_pcapdroid">Willkommen bei PCAPdroid</string>
    <string name="app_intro_privacy_msg">Die App beinhaltet keine Tracking-, Analyse- oder Datensammel-Funktionen.\n \nWie können Sie sich sicher sein? Überprüfen Sie die Datenschutzrichtlinie <a href="%1$s"/> und den <a href="%2$s">Quellcode</a>.</string>
    <string name="app_intro_geolocation_msg">PCAPdroid kann eine lokale Datenbank abfragen, um das Land eines entfernten Servers zu bestimmen
\n
\nSie müssen zuerst die Geolokalisierungsdatenbank aus den App-Einstellungen herunterladen</string>
    <string name="app_intro_traffic_inspection">Die Überprüfung von HTTP-Anfragen, Antworten und Rohdaten ist dank der eingebauten Decoder einfach.
\n
\nHaben Sie eine verschlüsselte Verbindung\? Sie können die <a href="%1$s">TLS-Entschlüsselung</a> aktivieren, um die entschlüsselten Daten zu erhalten</string>
    <string name="low_memory">Wenig Speicher</string>
    <string name="low_memory_info">Der App geht der Arbeitsspeicher aus, Abstürze sind zu erwarten</string>
    <string name="full_payload_disabled">Die Option \"Volle Nutzlast\" wurde deaktiviert</string>
    <string name="capture_stopped_low_memory">Die Aufzeichnung wurde gestoppt</string>
    <string name="memory_usage">Speichernutzung</string>
    <string name="ip_mode">VPN IP-Adressen</string>
    <string name="ipv4_only">Nur IPv4</string>
    <string name="ipv6_only">Nur IPv6</string>
    <string name="ip_both">IPv4 und IPv6</string>
    <string name="no_matches_found">Kein Treffer</string>
    <string name="notifications_notice">Die App verwendet Benachrichtigungen, um bei anormalen Ereignissen Alarme zu senden. Erteilen Sie ihr im nächsten Bildschirm die Erlaubnis, Benachrichtigungen zu senden</string>
    <string name="cleartext_connection">Klartext</string>
    <string name="payload_scams_notice">Diese Ansicht kann vertrauliche Informationen wie Ihre Kennwörter und Zugriffstoken enthalten.
\n
\nGeben Sie diese Informationen niemals an jemanden weiter, es könnte daraus eine Betrugsversuch entstehen</string>
    <string name="vpn_exemptions">VPN-Ausnahmen</string>
    <string name="vpn_exemptions_summary">Nehmen Sie einige Anwendungen von der VPN-Verbindung aus. Deren Datenverkehr wird nicht überwacht</string>
    <string name="cancel_action">Abbrechen</string>
    <string name="show_data_action">Daten anzeigen</string>
    <string name="remote_server_warning">Aus Sicherheitsgründen ist das Senden von Daten an den Remote-Server \"%1$s\" nicht erlaubt\"</string>
    <string name="paid_features_unlocked">Kostenpflichtige Funktionen freigeschaltet. Starten Sie die Aufzeichnung neu, wenn sie ausgeführt wird</string>
    <string name="build_info">Build-Informationen</string>
    <string name="mitmproxy_opts">Zusätzliche mitmproxy-Optionen</string>
    <string name="mitmproxy_opts_description">Zusätzliche Optionen für mitmproxy bereitstellen</string>
    <string name="mitm_addon_error">Fehler beim Starten des mitm-Addons. Prüfen Sie das Protokoll für Details</string>
    <string name="whitelist_mode">Whitelist-Modus</string>
    <string name="firewall_whitelist_notice">In diesem Modus werden alle Verbindungen blockiert, es sei denn, sie werden manuell auf die Whitelist gesetzt. Ohne eine geeignete Whitelist verpassen Sie möglicherweise Push-Benachrichtigungen</string>
    <string name="firewall_whitelist_help">Diese Regeln legen fest, welche Verbindungen zugelassen werden sollen. Blocklist-Regeln haben Vorrang vor Whitelist-Regeln</string>
    <string name="add_to_fw_whitelist">Zur Firewall-Whitelist hinzufügen</string>
    <string name="remove_from_fw_whitelist">Von der Firewall-Whitelist entfernen</string>
    <string name="reset_stats_confirm">Möchten Sie diese Statistiken wirklich zurücksetzen\?</string>
    <string name="port_mapping">Port-Mapping</string>
    <string name="port_mapping_summary">Konfigurieren Sie Port-Zuordnungsregeln, um Verbindungen an einen anderen Host oder Port umzuleiten</string>
    <string name="add_action">Hinzufügen</string>
    <string name="redirect_to">Weiterleiten zu:</string>
    <string name="original_port">Ursprünglicher Port</string>
    <string name="required">Erforderlich</string>
    <string name="destination_port">Ziel-Port</string>
    <string name="port_mapping_exists">Port-Zuordnung bereits definiert</string>
    <string name="items_delete_confirm">Ausgewählte Elemente löschen\?</string>
    <string name="ip_address">IP-Adresse</string>
    <string name="rule_exists">Regel bereits definiert</string>
    <string name="dns_servers">DNS-Server</string>
    <string name="dns_servers_summary">Konfigurieren Sie die DNS-Server, die während der Erfassung verwendet werden sollen</string>
    <string name="ipv4_dns_server">IPv4 DNS-Server</string>
    <string name="ipv6_dns_server">IPv6 DNS-Server</string>
    <string name="use_system_dns">System DNS verwenden</string>
    <string name="use_system_dns_summary">Wenn möglich den System DNS-Server verwenden</string>
    <string name="external_storage_perm_required">Die Berechtigung für den externen Speicher ist erforderlich</string>
    <string name="many_rules_warning">Sie versuchen, viele Regeln zu importieren, was dazu führen kann, dass die App bei einigen Interaktionen nicht mehr reagiert. Wollen Sie wirklich fortfahren\?</string>
    <string name="pcapng_format">Pcapng Format</string>
    <string name="pcapng_format_summary">Dump-Pakete im Pcapng-Dump-Format, das flexibler ist und die Einbettung von TLS-Entschlüsselungsgeheimnissen ermöglicht</string>
    <string name="warning">Warnung</string>
    <string name="remote_collector_notice">Sie haben PCAPdroid so konfiguriert, dass es Datenverkehr an einen entfernten Server sendet. Der Server kann auf Ihre sensiblen Daten zugreifen.
\n
\nWenn Sie jemand dazu aufgefordert hat, handelt es sich wahrscheinlich um einen Betrugsversuch</string>
    <string name="connection_not_found">Konnte die angegebene Verbindung nicht finden</string>
    <string name="heap_usage">Heap-Nutzung</string>
    <string name="mitm_skip_notice">Das mitm-Zertifikat scheint nicht installiert zu sein. Wenn Sie fortfahren, schlägt die Entschlüsselung möglicherweise fehl</string>
    <string name="mitm_wizard_description">Konfigurieren des Geräts für die TLS-Entschlüsselung</string>
    <string name="traffic_dump">Traffic-Dump</string>
    <string name="traffic_inspection">Datenverkehrskontrolle</string>
    <string name="tls_decryption_summary">Entschlüssel den SSL/TLS-Datenverkehr, durch ausführen von mitm. Dies kann jetzt mit einigen Apps funktionieren, siehe im Benutzerhandbuch nach</string>
    <string name="mitm_setup_wizard">Mitm-Einrichtungsassistent</string>
    <string name="mitm_start_failed">Der mitm-Dienst konnte nicht gestartet werden. Versuchen Sie, die mitm Addon-App manuell zu öffnen, und versuchen Sie es erneut</string>
    <string name="install_ca_certificate">Installieren Sie das PCAPdroid-CA-Zertifikat und wählen Sie „VPN und Apps“. Android wird nach Ihrem Sperrbildschirm oder Passwort fragen</string>
    <string name="cert_installed_correctly">Das CA-Zertifikat ist installiert</string>
    <string name="cert_reinstall_required">Das CA-Zertifikat ist nicht installiert, führen Sie den mitm-Einrichtungsassistenten aus</string>
    <string name="cert_exported_now_installed">Zertifikat exportiert, installieren Sie es nun über die Android-Einstellungen</string>
    <string name="mitm_addon_bad_version">Schlechte PCAPdroid Mitm Addon-Version. Bitte installieren Sie Version %1$s und versuchen Sie es erneut</string>
    <string name="mitm_addon_new_version">Das PCAPdroid mitm Addon muss aktualisiert werden</string>
    <string name="overview">Übersicht</string>
    <string name="response">Antwort</string>
    <string name="string_http_request">HTTP-Anfrage</string>
    <string name="string_http_response">HTTP-Antwort</string>
    <string name="payload_truncated">Der Payload ist gekürzt. Aktivieren Sie \"%1$s\", um den Payload vollständig anzuzeigen</string>
    <string name="full_payload_summary">Zeigen Sie die volle Verbindung Payload (z.B. die volle HTTP-Anfrage und Antwort). Dies erfordert viel Speicher, nicht auf lange Sicht verwenden</string>
    <string name="payload">Nutzlast</string>
    <string name="tx_direction">Senden</string>
    <string name="rx_direction">Empfang</string>
    <string name="full_payload">Volle Nutzlast</string>
    <string name="geolocation">Standort</string>
    <string name="geolocation_summary">Zeigen Sie Länder- und ASN-Informationen an, indem Sie Offline-Suchen durchführen</string>
    <string name="hexdump">Hexdump</string>
    <string name="geo_db_not_found">Datenbank nicht gefunden. Geolokalisierung ist deaktiviert</string>
    <string name="database">Datenbank</string>
    <string name="built_on">Aufgebaut am: %1$s</string>
    <string name="discard_action">Verwerfen</string>
    <string name="no_rules_to_export">Keine Regeln zum Exportieren</string>
    <string name="rules_merge_msg">Bestehende Regeln beibehalten\?</string>
    <string name="keep_action">Behalten</string>
    <string name="app_info">App-Info</string>
    <string name="app_intro_skip_button">Überspringen</string>
    <string name="app_intro_next_button">Weiter</string>
    <string name="app_intro_back_button">Zurück</string>
    <string name="privacy_first">Datenschutz an erster Stelle</string>
    <string name="country_and_asn">Land und ASN</string>
    <string name="install_the_mitm_addon">Installieren Sie das PCAPdroid <a href="%1$s">mitm Addon</a></string>
    <string name="export_ca_certificate">Exportieren Sie das PCAPdroid-CA-Zertifikat, öffnen Sie dann die Android-Einstellungen für \"Verschlüsselung und Anmeldeinformationen\" und wählen Sie \"CA-Zertifikat installieren\"</string>
    <string name="app_intro_done_button">Fertig</string>
    <string name="app_intro_welcome_msg">PCAPdroid ist eine datenschutzfreundliche App, mit der Sie die von den Apps auf Ihrem Gerät hergestellten Verbindungen verfolgen und analysieren können
\n
\nDarüber hinaus können Sie einen PCAP-Dump des Datenverkehrs exportieren, Metadaten extrahieren und vieles mehr!</string>
    <string name="vpn_setup_msg">PCAPdroid simuliert einen VPN, um den Netzwerkverkehr ohne Root zu erfassen.
\n
\nUm die Aufzeichnung zu starten, müssen Sie die VPN-Anfrage auf dem nächsten Bildschirm akzeptieren.
\n
\n<b>ANMERKUNG:</b> um fortzufahren deaktivieren Sie bitte alle Always-on VPNs in den Android Einstellungen</string>
    <string name="app_intro_traffic_dump">PCAPdroid bietet <a href="%1$s">mehrere Möglichkeiten</a>, den Datenverkehr zur weiteren Analyse in das Standard-PCAP-Format zu übertragen\n\nMit der <a href="%2$s">PCAPdroid-Erweiterungen Option</a> können Sie den Paketen App-Namen hinzufügen und sie in Wireshark anzeigen lassen</string>
    <string name="tls_decryption_with_root_msg">Die Möglichkeit, die TLS-Entschlüsselung mit root auszuführen, ist eine experimentelle Funktion. Dies ist eine Liste von bekannten Fehlern: \n \n - in PCAPdroid wird der Datenverkehr so angezeigt, wie er von der mitm-addon-App anstelle der ursprünglichen App generiert wurde \n - der Dump des SSL-Keylogs wird nicht unterstützt \n - wenn ein App-Filter gesetzt ist, wird nur die Ziel-App entschlüsselt, aber PCAPdroid zeigt weiterhin den Datenverkehr der anderen Apps an \n - wenn die Erfassung nicht startet, stellen Sie sicher, dass Sie den iptables-Befehl als root ausführen können (z. B. über termux). \n - dies funktioniert möglicherweise nicht unter Android 12 und später \n - wenn eine VPN-App läuft, sollten Sie entweder eine bestimmte App für die Entschlüsselung auswählen oder das PCAPdroid mitm Addon vom VPN ausschließen, da der Datenverkehr sonst in einer Schleife läuft</string>
    <string name="vpn_lockdown_notice">Um zu verhindern, dass Apps auf das Internet zugreifen, wenn PCAPdroid nicht läuft (z.B. nach einem Neustart), können Sie PCAPdroid als Always-On-VPN im Lockdown-Modus einstellen.
\n
\nMöchten Sie jetzt die VPN-Einstellungen öffnen\?</string>
    <string name="write_ext_storage_failed">Schreiben auf externen Speicher fehlgeschlagen. Prüfen Sie das App-Protokoll für Details</string>
    <string name="paid_feature">Kostenpflichtige Funktion</string>
    <string name="network_traffic">Verkehr</string>
    <string name="permission_granted">%1$s Berechtigung wurde erteilt</string>
    <string name="permission_grant_fail">%1$s Berechtigung konnte nicht erteilt werden</string>
    <string name="sort_by">Sortieren nach</string>
    <string name="total_bytes">Bytes insgesamt</string>
    <string name="access_paid_features_msg">Unter <a href="%1$s">finden Sie das Benutzerhandbuch</a>, um zu erfahren, wie Sie auf die kostenpflichtigen Funktionen zugreifen können</string>
    <string name="license_service_unavailable">Der PCAPdroid-Lizenzdienst ist derzeit nicht verfügbar. Bitte versuchen Sie es in einigen Minuten erneut</string>
    <string name="requesting_unlock_token">Anforderung eines Freigabetokens, bitte warten</string>
    <string name="unlock_token_summary">Ein Token, das verwendet werden kann, um die kostenpflichtigen Funktionen in Nicht-Google-Play-Builds der App (z. B. F-Droid/Github) freizuschalten</string>
    <string name="unlock_token_error">Konnte kein Entsperrungs-Token anfordern [%1$d]: %2$s</string>
    <string name="show_action">Zeigen</string>
    <string name="unlock_token_msg1">Dies ist Ihr Freischalt-Token. Notieren Sie ihn, da Sie ihn unter <a href="%1$s">benötigen, um Ihre Lizenzcodes zu generieren.</a></string>
    <string name="socks5_redirection">SOCKS5 Umleitung</string>
    <string name="socks5_summary">Konfigurieren Sie die Umleitung zu einem SOCKS5-Proxy</string>
    <string name="socks5_auth">SOCKS5 Authentifizierung</string>
    <string name="username">Benutzername</string>
    <string name="password">Passwort</string>
    <string name="socks5_auth_summary">Authentifizieren Sie sich beim Proxy über Benutzername und Passwort</string>
    <string name="mitm_addon_autostart_workaround">Die Verbindung mit dem mitm-Addon ist fehlgeschlagen. Als Workaround können Sie versuchen, die mitm addon-App zu öffnen und dann zu PCAPdroid zurückzukehren, ohne sie zu schließen. Möchten Sie die App jetzt öffnen\?</string>
    <string name="qr_info_text">Installiere PCAPdroid aus dem Google Play Store und scanne diesen QR-Code</string>
    <string name="qr_purchase_required">Kaufe einen Entsperr-Token, um mit QR-Code zu aktivieren</string>
    <string name="license_limit_reached">Du hast die Lizenzgrenze für diesen Freischalt-Token erreicht. Kaufe ein neuen Token, um mehr Lizenzen zu generieren</string>
    <string name="license_error">Fehler der Lizenzerzeugung [%1$d: %2$s</string>
    <string name="requesting_license">Frage einen Lizenzcode an, bitte warten</string>
    <string name="mitm_addon_starting">Mitm addon startet…</string>
    <string name="decryption_rules">Entschlüsselung Regeln</string>
    <string name="decrypt_action">Entschlüsseln…</string>
    <string name="dont_decrypt_action">Nicht entschlüsseln…</string>
    <string name="status_encrypted">Verschlüsselt</string>
    <string name="injected">Injiziert</string>
    <string name="qr_license_confirm">Möchten Sie eine Lizenz für das \"%1$s\"-Gerät mit dem folgenden Entsperr-Token generieren\?</string>
    <string name="invalid_license">ungültige Lizenz</string>
    <string name="connection_error">Verbindungsfehler: %1$s</string>
    <string name="qr_code_expired">QR-Code verfallen. Generiere einen neuen QR-Code und versuche es erneut</string>
    <string name="license_activation_ok">Lizenzierung abgeschlossen</string>
    <string name="mitm_addon_running">Mitm addon läuft</string>
    <string name="decryption_rules_help">Diese Regeln geben an, welche Verbindungen zu entschlüsseln sind. Host-basierte Regeln funktionieren nur, wenn eine vorherige DNS-Antwort angezeigt wird</string>
    <string name="activate_via_qr_code">Aktivier mit QR-Code</string>
    <string name="copy_error">Datei kann nicht geschrieben werden</string>
    <string name="proxy_host">Proxy Host</string>
    <string name="pcap_load_success">Capture-Datei geladen</string>
    <string name="decryption_info_no_rule">Um diese Verbindung zu entschlüsseln, erstellen Sie eine Entschlüsselungsregel aus der linken Menü oder aus dem Kontextmenü in der Verbindungsliste</string>
    <string name="pcap_read_error">Fehler beim Lesen der Erfassungsdatei. Überprüfen Sie das Protokoll für Details</string>
    <string name="pcap_load_in_progress">Capture-Datei wird gerade geladen, bitte warten</string>
    <string name="open_pcap_file">PCAP/Pcapng Datei öffnen…</string>
    <string name="invalid_pcap_file">Ungültiges Erfassungsdateiformat</string>
    <string name="unsupported_pcap_datalink">Die Datei hat einen nicht unterstützten Datenlink</string>
    <string name="pcap_file_not_exists">Die angegebene Datei existiert nicht</string>
    <string name="root_capture_pcapd_start_failure">Fehler beim starten der Aufzeichnung. Stelle sicher dass PCAPdroid root Berechtigungen erhalten hat</string>
    <string name="pcapdroid_trailer_notice">Um die tatsächlichen Anwendungen anstelle von „%1$s“ anzuzeigen, müssen Sie die Option „%2$s“ aktivieren, bevor Sie den Dump erstellen</string>
    <string name="tls_decryption_no_rules_notice">Nur Verbindungen die mit den vorkonfigurierten Regeln übereinstimmen werden entschlüsselt. Möchtest du jetzt eine Entschlüsselungsregel erstellen?</string>
    <string name="active_vpn_detected">Aktiver VPN festgestellt</string>
    <string name="pcap_file_load_aborted">Laden der Aufzeichnungsdatei abgebrochen</string>
    <string name="host_resolution_failed">Der Host %1$s konnte nicht gefunden werden</string>
    <string name="capture_interface_open_error">Die Aufnahmeschnittstelle konnte nicht geöffnet werden</string>
    <string name="root_capture_start_failed">Fehler beim starten der Aufzeichnung. Stelle sicher, dass das Gerät mit Magisk gerootet ist</string>
    <string name="mitm_doze_notice">Batterieoptimierung kann das Mitm-Addon stören</string>
    <string name="redirected">umgeleitet</string>
    <string name="ipv6_bytes_sent">IPv6 Bytes gesendet</string>
    <string name="connection_redirected_port_map">Diese Verbindung wurde durch eine Port-Mapping-Regel umgeleitet</string>
    <string name="dnscrypt_how_to">Wie man DoH / DNSCrypt mit PCAPdroid verwendet</string>
    <string name="decrypt_quic_notice">Das Entschlüsseln von QUIC wird derzeit nicht unterstützt. Als Workaround stoppen Sie die Erfassung und wählen Sie die Option, um QUIC in den PCAPdroid-Einstellungen zu blockieren</string>
    <string name="target_apps">Ziel-Apps</string>
    <string name="export_ellipsis">Export…</string>
    <string name="ipv6_bytes_rcvd">IPv6 Bytes empfangen</string>
    <string name="ipv6_bytes_percentage">IPv6 bys prozentual</string>
    <string name="never">Nie</string>
    <string name="always">Immer</string>
    <string name="for_connections_to_decrypt">Nur für Verbindungen zur Entschlüsselung</string>
    <string name="target_apps_help">Wählen Sie die zu erfassenden Anwendungen aus</string>
    <string name="headers">HTTP-Headers</string>
    <string name="body">HTTP-Body</string>
    <string name="both">beides</string>
    <string name="whats_new">Was ist neu</string>
    <string name="waiting_for_vpn_disconnect">Warten darauf, dass die aktive VPN-Verbindung getrennt wird …</string>
    <string name="raw_bytes">Raw -Bytes</string>
    <string name="restart_on_disconnection">Neustart bei Trennung</string>
    <string name="restart_on_disconnection_summary">Startet die Aufnahme automatisch neu, nachdem sie von anderen VPN-Apps gestoppt wurde</string>
    <string name="vpn_reconnection">VPN-Wiederverbindung</string>
    <string name="vpn_reconnection_aborted">VPN-Wiederverbindung abgebrochen</string>
    <string name="update_available">Aktualisierung verfügbar</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="dump_extensions">PCAPdroid-Erweiterungen</string>
    <string name="errno_econnaborted">Verbindung abgebrochen</string>
    <string name="dump_extensions_how_to">Wie man die PCAPdroid Dump-Erweiterungen in Wireshark anzeigt</string>
    <string name="malicious_connection_description">Eine Verbindung von App \"%1$s\" löste eine Malware-Erkennungsregel (%2$s) aus</string>
    <string name="malicious_connections_notice">Blacklisten können falsche Positive enthalten. Achten Sie darauf, die IP-Adresse/Domain-Reputation online zu überprüfen. Sie können falsche Positive über die Malware Whitelist ausschließen</string>
    <string name="geo_db_missing">Geolocation Datenbank fehlt</string>
    <string name="country_rules_warning">Um landesbasierte Firewall-Regeln zu verwenden, laden Sie die Geolocation-Datenbank aus den PCAPdroid-Einstellungen herunter, andernfalls werden landesbasierte Regeln ineffektiv sein</string>
    <string name="keylog_read_error">SSL keylog Lesefehler</string>
    <string name="bytes_threshold">Bytes Schwelle</string>
    <string name="select_the_pcap_file">Wählen Sie die PCAP/Pcapng-Datei</string>
    <string name="select_the_keylog_file">Wählen Sie die SSL-Keylogdatei</string>
    <string name="error_code_with_text">%1$s (Fehler %2$d)</string>
    <string name="errno_epipe">Broken pipe</string>
    <string name="errno_epipe_msg">Der Server hat die Verbindung während der Datenübertragung unerwartet geschlossen</string>
    <string name="errno_enetdown">Netzwerk ist ausgefallen</string>
    <string name="errno_enetdown_msg">Die Netzwerkschnittstelle ist ausgefallen oder es kann keine Verbindung zum Netzwerk hergestellt werden</string>
    <string name="errno_enetunreach">Netzwerk ist nicht erreichbar</string>
    <string name="errno_enetunreach_msg">Das System kann keine gültige Route zum Zielnetzwerk finden</string>
    <string name="errno_enetreset">Netzwerk-Reset</string>
    <string name="errno_enetreset_msg">Die Netzwerkverbindung wurde von einem Zwischengerät (z. B. Router oder Mobilfunkanbieter) zurückgesetzt</string>
    <string name="errno_econnaborted_msg">Die Verbindung wurde abgebrochen, normalerweise aufgrund eines Netzwerkübergangs</string>
    <string name="errno_econnreset">Verbindungsreset durch Peer</string>
    <string name="errno_econnreset_msg">Der Server hat die Verbindung schlagartig geschlossen, in der Regel aufgrund eines Absturzes oder plötzlicher Abschaltung</string>
    <string name="errno_etimedout">Zeitüberschreitung der Verbindung</string>
    <string name="errno_etimedout_msg">Der Server hat zu lange gebraucht, um zu antworten, wahrscheinlich aufgrund von Netzwerkverzögerungen oder einem ausgelasteten Server</string>
    <string name="errno_econnrefused">Verbindung wurde abgelehnt</string>
    <string name="errno_econnrefused_msg">Der Server hat die Verbindung abgelehnt, was auf einen überlasteten oder nicht funktionierenden Server hinweisen kann</string>
    <string name="errno_ehostunreach">Keine Route zum Host</string>
    <string name="errno_ehostunreach_msg">Das System kann keine Route zum Ziel-Host finden</string>
    <string name="dns_conn_info">DNS übersetzt einen Domainnamen in eine IP-Adresse. Die tatsächlichen Daten werden typischerweise über nachfolgende HTTPS/TLS-Verbindungen ausgetauscht</string>
    <string name="tls_conn_info">TLS/HTTPS-Verkehr ist verschlüsselt. Um diesen Traffic zu überprüfen, müssen Sie ihn entschlüsseln. Überprüfen Sie die PCAPdroid <a href="%1$s">Benutzeranleitung</a> für Details</string>
    <string name="tls_decryption_not_supported_16KB">TLS-Entschlüsselung wird auf 16-KB-Geräten derzeit nicht unterstützt</string>
    <string name="dump_extensions_summary">Erweitern Sie das Paket-Dump-Format mit zusätzlichen Metadaten, wie die App, die ein bestimmtes Paket gesendet / empfangen</string>
    <string name="unsupported_pcap_file">Ununterstütztes Erfassungsdateiformat</string>
    <string name="decrypt_pcap_file">PCAP/Pcapng Datei entschlüsseln…</string>
    <string name="mitm_addon_update_available">Ein neues Update für das mitm AddOn ist verfügbar. Aktualisiere, um die aktuellsten Fehlerbehebungen zu installieren</string>
    <string name="update_action">Aktualisierung</string>
    <string name="ip_address_or_cidr">IP-Adresse / CIDR</string>
    <string name="tcp_exporter">TCP-Exporter</string>
    <string name="tcp_udp_exporter">TCP/UDP-Exporter</string>
    <string name="tcp_exporter_info">Sendet das PCAP an einen remote TCP-Empfänger (pcap-über-ip)</string>
    <string name="generate_api_key">API-Schlüssel generieren</string>
    <string name="show_api_key">API-Schlüssel anzeigen</string>
    <string name="api_key">API-Schlüssel</string>
    <string name="api_key_discard_confirm">Möchten Sie den aktuellen API-Schlüssel wirklich verwerfen und einen neuen generieren?</string>
    <string name="save_as_text">Als Text speichern</string>
    <string name="save_as_har">Als HAR speichern</string>
    <string name="tcp_collector_info">TCP-Kollektor: %1$s:%2$d</string>
    <string name="select">Auswählen</string>
    <string name="content_type">Inhaltstyp</string>
    <string name="http_status">HTTP-Status</string>
    <string name="payload_size_threshold">Schwellenwert für Nutzlastgröße</string>
    <string name="method_filter">Methode: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="text">Text</string>
    <string name="display_as_text">Als Text anzeigen</string>
    <string name="display_as_hexdump">Als Hexdump anzeigen</string>
    <string name="exporting">Wird exportiert…</string>
    <string name="export_in_progress">Export wird durchgeführt, bitte warten</string>
    <string name="show_connection">Verbindung anzeigen</string>
    <string name="show_system_apps">System-Apps anzeigen</string>
    <string name="destination_host">Ziel-Host</string>
    <string name="filename_prefix">Dateinamenpräfix</string>
    <string name="filename_prefix_description">Legt das Präfix für die von PCAPdroid exportierten Dateien fest, z.B. PCAP-Dateien</string>
    <string name="no_requests">Keine Anfragen</string>
    <string name="item_not_found">Das angegebene Element wurde nicht gefunden</string>
    <string name="connection_number">Verbindung #%1$d</string>
    <string name="http_request_number">HTTP-Anfrage #%1$d</string>
    <string name="http_requests">HTTP-Anfragen</string>
    <string name="switch_to_http">HTTP-Anfragen anzeigen</string>
    <string name="switch_to_connections">Verbindungen anzeigen</string>
    <string name="decryption_error">Entschlüsselungsfehler</string>
    <string name="previous">Zurück</string>
    <string name="next">Weiter</string>
</resources>

```

`app/src/main/res/values-es/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">Iniciar</string>
    <string name="stop_button">Detener</string>
    <string name="title_activity_settings">Ajustes</string>
    <string name="collector_info">Colector UDP: %1$s:%2$d</string>
    <string name="http_server_status">Servidor HTTP: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s recibidos — %2$s enviados</string>
    <string name="query">Query</string>
    <string name="host">Host</string>
    <string name="ready">Preparado</string>
    <string name="about">Acerca de</string>
    <string name="status">Estado</string>
    <string name="connections_view">Conexiones</string>
    <string name="no_connections">Sin conexiones</string>
    <string name="connection_details">Detalles de conexión</string>
    <string name="app">App</string>
    <string name="protocol">Protocolo</string>
    <string name="source">Fuente</string>
    <string name="destination">Destino</string>
    <string name="packets">Paquetes</string>
    <string name="duration">Duración</string>
    <string name="http_server">Servidor HTTP</string>
    <string name="udp_exporter">Exportador UDP</string>
    <string name="no_dump">Sin volcado</string>
    <string name="no_dump_info">El tráfico no será volcado</string>
    <string name="http_server_info">Inicia el servidor HTTP para la descarga de PCAP</string>
    <string name="udp_exporter_info">Envía el PCAP al colector remoto UDP</string>
    <string name="http_server_port">Puerto del servidor HTTP</string>
    <string name="receiver_ip_address">Dirección IP del colector</string>
    <string name="receiver_port">Puerto del colector</string>
    <string name="user_guide">Guía de usuario</string>
    <string name="open_telegram_group">Grupo de Telegram</string>
    <string name="source_code">Código fuente</string>
    <string name="yes">Sí</string>
    <string name="no">No</string>
    <string name="vpn_setup_failed">No se ha podido configurar la VPN. Asegúrate de que la VPN siempre activa está desactivada</string>
    <string name="app_not_found">No se pudo encontrar la aplicación %1$s</string>
    <string name="stats">Estadísticas</string>
    <string name="active_connections">Conexiones activas</string>
    <string name="dropped_connections">Conexiones interrumpidas</string>
    <string name="tot_connections">Total de conexiones</string>
    <string name="open_sockets">Sockets abiertos</string>
    <string name="bytes_sent">Bytes enviados</string>
    <string name="bytes_rcvd">Bytes recibidos</string>
    <string name="packets_sent">Paquetes enviados</string>
    <string name="packets_rcvd">Paquetes recibidos</string>
    <string name="dns_queries">Consultas DNS</string>
    <string name="search_apps">Buscar apps</string>
    <string name="no_apps">No hay apps</string>
    <string name="dns_server">Servidor DNS</string>
    <string name="apps">Apps</string>
    <string name="pcap_file">Archivo PCAP</string>
    <string name="pcap_file_info">Crea un archivo PCAP/Pcapng en el almacenamiento del dispositivo</string>
    <string name="cannot_write_file">No se puede escribir el archivo</string>
    <string name="share">Compartir</string>
    <string name="delete">Borrar</string>
    <string name="ok">Aceptar</string>
    <string name="pcap_file_action">Tráfico guardado en el archivo \"%1$s\" (%2$s)</string>
    <string name="delete_error">No se pudo eliminar el archivo</string>
    <string name="capture_running">Ejecutando captura</string>
    <string name="notification_msg">%1$s capturado, %2$s conexiones</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">Primera vez</string>
    <string name="last_seen">Última vez</string>
    <string name="conn_status_closed">Cerrado</string>
    <string name="copy_to_clipboard">Copiar</string>
    <string name="save_to_file">Guardar al archivo</string>
    <string name="older_connections_notice">%1$d conexiones antiguas no mostradas</string>
    <string name="about_text">PCAPdroid es una herramienta de captura y monitorización de red de código abierto que funciona sin privilegios root</string>
    <string name="get_app">Obténgalo:</string>
    <string name="unknown_app">Desconocido</string>
    <string name="error">Error</string>
    <string name="conn_status_unreachable">Inalcanzable</string>
    <string name="other_prefs">Otros</string>
    <string name="app_language">Idioma de la app</string>
    <string name="system_default">Predeterminado del sistema</string>
    <string name="no_activity_file_selection">No se encontró una app como administrador de archivos</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="proxy_port">Puerto proxy</string>
    <string name="root_capture">Capturar como root</string>
    <string name="donate">Donar</string>
    <string name="search">Buscar…</string>
    <string name="app_val">App: %1$s</string>
    <string name="ip_address_val">Dirección IP: %1$s</string>
    <string name="host_val">Host: %1$s</string>
    <string name="protocol_val">Protocolo: %1$s</string>
    <string name="hide">Ocultar…</string>
    <string name="select">Seleccionar</string>
    <string name="n_selected">%1$d seleccionados</string>
    <string name="select_all">Seleccionar todo</string>
    <string name="app_details">Detalles de la app</string>
    <string name="package_name">Nombre del paquete</string>
    <string name="uid">UID</string>
    <string name="app_name">Nombre</string>
    <string name="version">Versión</string>
    <string name="target_sdk">SDK objetivo</string>
    <string name="installed_on">Instalado en</string>
    <string name="last_update">Último actualización</string>
    <string name="permissions">Permisos</string>
    <string name="root_app_info">Servicios del sistema que se ejecutan con los máximos privilegios</string>
    <string name="netd_app_info">El servicio del sistema que realiza las resoluciones DNS</string>
    <string name="android_app_info">El sistema Android</string>
    <string name="unknown_app_info">\"Desconocido\" marca las conexiones cuya aplicación no se pudo determinar</string>
    <string name="packets_dropped">Paquetes perdidos</string>
    <string name="capture_prefs">Captura</string>
    <string name="dump_extensions_summary">Extiende el formato de volcado de paquetes con metadatos adicionales, como la aplicación que envió/recibió un paquete determinado</string>
    <string name="pending_transaction">Por favor, completa tu transacción para canjear esta función</string>
    <string name="ctrl_consent">Una aplicación quiere capturar el tráfico de tu dispositivo.
\nRecházala si no estás seguro</string>
    <string name="deny">Denegar</string>
    <string name="allow">Permitir</string>
    <string name="ctrl_consent_title">Solicitud de control por PCAPdroid</string>
    <string name="ctrl_consent_denied">PCAPdroid: la solicitud de control fue denegada</string>
    <string name="ctrl_consent_allowed">PCAPdroid: la solicitud de control fue permitida</string>
    <string name="capture_interface">Interfaz de captura</string>
    <string name="internet">Internet</string>
    <string name="all_interfaces">Todas las interfaces</string>
    <string name="capturing_from">Capturando paquetes desde \"%1$s\"</string>
    <string name="edit_filter">Editar filtro</string>
    <string name="edit_list">Editar lista</string>
    <string name="hidden_connections_rules">Reglas de conexiones ocultas</string>
    <string name="list_is_empty">La lista está vacía</string>
    <string name="show_only_malicious">Conexiones maliciosas</string>
    <string name="security">Securidad</string>
    <string name="malware_detection">Detección de malware</string>
    <string name="malware_detection_summary">Detecta conexiones conocidas por host malévolos desde listas de bloqueos de terceros</string>
    <string name="reset">Reiniciar</string>
    <string name="malware_whitelist_rules">Reglas de lista blanca de malware</string>
    <string name="feature_not_available">Esta función no está disponible actualmente para tu dispositivo</string>
    <string name="billing_connecting">La conexión con Google Play está en curso, por favor reintenta más tarde</string>
    <string name="malicious_connection_filter">Malicioso</string>
    <string name="status_filter">Estado HTTP: %1$s</string>
    <string name="not_hidden_filter">No oculto</string>
    <string name="copy_action">Copiar…</string>
    <string name="url_val">"URL: %1$s"</string>
    <string name="show_me">Muéstrame</string>
    <string name="hint">Pista</string>
    <string name="once">Una vez</string>
    <string name="forever">Para siempre</string>
    <string name="control_permissions">Permisos de control</string>
    <string name="control_permissions_summary">Comprueba qué aplicaciones pueden controlar la captura de PCAPdroid</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="no_permissions_set_info">No se han establecido permisos. Invoque PCAPdroid mediante StartActivityForResult para mostrar el diálogo de permisos</string>
    <string name="country">País</string>
    <string name="asn">ASN</string>
    <string name="country_val">País: %1$s</string>
    <string name="send_report">Enviar reporte</string>
    <string name="start_at_boot">Iniciar al arrancar</string>
    <string name="malware_status_ok">No se ha detectado tráfico malicioso</string>
    <string name="malware_status_detected">Conexiones maliciosas detectadas</string>
    <string name="whitelist">Lista blanca</string>
    <string name="blacklists">Lista negra</string>
    <string name="status_outdated">Desactualizado</string>
    <string name="status_not_loaded">No cargado</string>
    <string name="status_uptodate">Actualizado</string>
    <string name="blacklist_type">"Tipo: %1$s"</string>
    <string name="blacklist_type_ip">Lista negra de IP</string>
    <string name="blacklist_type_domain">Lista negra de dominios</string>
    <string name="n_rules">Reglas %1$s</string>
    <string name="last_update_val">Última actualización: %1$s</string>
    <string name="malicious_connections">Conexiones maliciosas</string>
    <string name="malicious_connection_description">Una conexión de la aplicación "%1$s" activó una regla de detección de malware (%2$s)</string>
    <string name="malicious_connections_notice">Las listas negras pueden contener falsos positivos. Asegúrese de verificar la reputación de la dirección IP/dominio en línea. Puede excluir los falsos positivos a través de la lista blanca de malware</string>
    <string name="updated_blacklists">Lista negra actualizada</string>
    <string name="connections_checked">Conexiones revisadas</string>
    <string name="last_blacklists_update">Última actualización</string>
    <string name="domain_rules">Reglas de dominio</string>
    <string name="ip_rules">Reglas IP</string>
    <string name="malware_status_update_failed">Algunas listas negras están desactualizadas</string>
    <string name="update_now">Actualizar ahora</string>
    <string name="status_updating">Actualizando…</string>
    <string name="malware_detection_learn_more">Más información sobre la función de detección de malware</string>
    <string name="private_dns_message_notice">El DNS privado evita que PCAPdroid inspeccione el tráfico DNS. Puedes deshabilitarlo desde los ajustes de red de Android</string>
    <string name="private_dns_hinders_detection">Los DNS privados dificultan la detección</string>
    <string name="validate">Validar</string>
    <string name="valid">Válido</string>
    <string name="invalid">No válido</string>
    <string name="block">Bloquear…</string>
    <string name="blocked_connection_filter">Bloqueado</string>
    <string name="firewall">Cortafuegos</string>
    <string name="firewall_rules">Reglas del cortafuegos</string>
    <string name="paid_features">Funciones de pago</string>
    <string name="copied">Copiado</string>
    <string name="network_interface">Interfaz</string>
    <string name="interface_filter">Interfaz: %1$s</string>
    <string name="request_method">Método de solicitud</string>
    <string name="content_type">Tipo de contenido</string>
    <string name="http_status">Estado HTTP</string>
    <string name="payload_size_threshold">Umbral de tamaño de contenido</string>
    <string name="method_filter">Método: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="buy_action">Comprar</string>
    <string name="can_use_purchased_feature">Ahora puedes utilizar la función comprada</string>
    <string name="save_ok">Guardado</string>
    <string name="loading_apps">Cargando apps…</string>
    <string name="decryption_no_filter_warn">Seleccione una aplicación de destino al descifrar TLS para evitar perder la conexión a Internet</string>
    <string name="file_saved_with_name">Archivo guardado como \"%1$s\"</string>
    <string name="loading">Cargando…</string>
    <string name="capture_not_running_status">La captura no se está ejecutando</string>
    <string name="capture_all_apps">Capturar tráfico de todas las aplicaciones</string>
    <string name="disconnect_vpn_confirm">Continuar desconectará la VPN activa</string>
    <string name="enable_socks5_proxy_summary">Redirigir todas las conexiones TCP a un proxy SOCKS5</string>
    <string name="root_capture_summary">Permite que PCAPdroid funcione con otras aplicaciones VPN</string>
    <string name="hidden_connections_help">Lista de reglas para ocultar las entradas de la lista de conexiones y así poder centrarse en las relevantes</string>
    <string name="blocked_pkts">Bloqueado</string>
    <string name="n_pkts">%1$s paquetes</string>
    <string name="no_items_for_purchase">No hay elementos disponibles para comprar</string>
    <string name="purchased">Comprado</string>
    <string name="learn_more">Más información</string>
    <string name="malware_whitelist_help">Lista blanca definida por el usuario para inhibir la detección de malware. Mantener presionadas las conexiones maliciosas para crear reglas que las desmarquen como malware</string>
    <string name="start_at_boot_summary">Iniciar captura automáticamente después de arrancar</string>
    <string name="start_capture_first">Iniciar la captura primero</string>
    <string name="open_nav_drawer">Abrir cajón de navegación</string>
    <string name="close_nav_drawer">Cerrar cajón de navegación</string>
    <string name="no_intent_handler_found">No se encontró ninguna aplicación para realizar esta acción</string>
    <string name="billing_failure">No se pudo conectar con Google Play. Por favor reintenta más tarde</string>
    <string name="show_only_cleartext">Conexiones de texto sin formato</string>
    <string name="allowed_connection_filter">Permitido</string>
    <string name="firewall_filter">Cortafuegos: %1$s</string>
    <string name="phone_app">Teléfono</string>
    <string name="socks5_info">Proxy SOCKS5: %1$s:%2$d</string>
    <string name="unblock">Desbloquear…</string>
    <string name="tls_decryption">Descifrado TLS</string>
    <string name="tls_decryption_summary">Descifra el tráfico SSL/TLS por medio de un ataque de intermediario (mitm). Esto podría funcionar con algunas aplicaciones, verifica la guía de usuario</string>
    <string name="traffic_inspection">Inspección de trafico</string>
    <string name="mitm_start_failed">No se ha podido iniciar el servicio mitm. Intenta abrir la aplicación mitm manualmente y vuelve a intentarlo</string>
    <string name="mitm_setup_wizard">Asistente de configuración mitm</string>
    <string name="install_action">Instalar</string>
    <string name="export_action">Exportar</string>
    <string name="checking_the_certificate">Verificando el certificado…</string>
    <string name="cert_exported_now_installed">Certificado exportado, ahora instálalo en los ajustes de Android</string>
    <string name="ca_cert_export_failed">Un error ha ocurrido mientras se exportaba el certificado CA
\n
\nAsegúrese de poner a <a href="%1$s">PCAPdroid en la lista blanca</a>, si su dispositivo implementa software que limita los servicios de fondo o de arranque automático</string>
    <string name="cert_installed_correctly">El certificado CA esta instalado</string>
    <string name="cert_reinstall_required">El certificado CA no esta instalado, corra el asistente de configuración de mitm</string>
    <string name="conn_status_active">Activo</string>
    <string name="phone_app_info">Servicios Telefónicos</string>
    <string name="remote_server_warning">Por razones de seguridad, enviar el tráfico al servidor remoto %1$s no está permitido</string>
    <string name="cancel_action">Cancelar</string>
    <string name="welcome_to_pcapdroid">Bienvenido a PCAPdroid</string>
    <string name="app_intro_skip_button">Saltar</string>
    <string name="app_intro_back_button">Atrás</string>
    <string name="app_intro_welcome_msg">PCAPdroid es una aplicación para la privacidad que te deja seguir y analizar las conexiones hechas por las apps en tu dispositivo
\n
\n¡Además, te permite exportar un volcado PCAP del tráfico, extraer metadatos y ¡mucho más!</string>
    <string name="low_memory_info">La aplicación se está quedando sin memoria, espera posibles bloqueos</string>
    <string name="capture_stopped_low_memory">La captura se ha detenido</string>
    <string name="cleartext_connection">Texto plano</string>
    <string name="app_blocked">Aplicación bloqueada</string>
    <string name="app_unblocked">La aplicación %1$s ha sido desbloqueada</string>
    <string name="show_data_action">Mostrar datos</string>
    <string name="payload_scams_notice">Esto puede contener información sensible, como contraseñas y tokens de acceso
\n
\nNunca le des esta información a nadie, puede ser un intento de estafa</string>
    <string name="remote_collector_notice">Has configurado PCAPdroid para que envie el tráfico a un servidor remoto. El servidor podrá procesar información sensible
\n
\nSi alguien te ha pedido que hagas esto, probablemente sea un intento de estafa</string>
    <string name="warning">Advertencia</string>
    <string name="paid_features_unlocked">Funciones de pago desbloqueadas. Reinicia la captura si se está ejecutando</string>
    <string name="payload_truncated">La carga útil está truncada. Para mostrarla completa, detén la captura y activa \"%1$s\" desde los ajustes de PCAPdroid</string>
    <string name="privacy_first">La privacidad es lo primero</string>
    <string name="permission_granted">El permiso %1$s fue concedido</string>
    <string name="rx_direction">RX</string>
    <string name="connection_not_found">No se pudo encontrar la conexión</string>
    <string name="low_memory">Poca memoria RAM restante</string>
    <string name="full_payload_disabled">La opción \"payload completo\" ha sido deshabilitada</string>
    <string name="memory_usage">Uso de memoria</string>
    <string name="ip_mode">Direcciones IP VPN</string>
    <string name="ipv4_only">Solo IPv4</string>
    <string name="ipv6_only">Solo IPv6</string>
    <string name="ip_both">IPv4 y IPv6</string>
    <string name="mitm_skip_notice">Parece que el certificado mitm no está instalado. Si continuas, el descifrado podría fallar</string>
    <string name="mitm_wizard_description">Configura el dispositivo para el descifrado TLS</string>
    <string name="export_ca_certificate">Exporta el certificado PCAPDROID CA, abre \"Cifrado y Credenciales\" en Ajustes y selecciona \"Instalar certificado CA\"</string>
    <string name="install_ca_certificate">Instala el certificado PCAPDROID CA, selecciona \"VPN y aplicaciones\". Android te pedirá la contraseña</string>
    <string name="mitm_addon_new_version">El complemento mitm de PCAPdroid debe actualizarse</string>
    <string name="export_failed">Exportación fallida</string>
    <string name="not_encrypted">No cifrado</string>
    <string name="request">Petición</string>
    <string name="response">Respuesta</string>
    <string name="not_decryptable">No descifrable</string>
    <string name="connection_start_not_seen">PCAPdroid no ha visto el inicio de esta conexión. Puede ser que falte información</string>
    <string name="network_traffic">Tráfico</string>
    <string name="warn_no_app_data">No se han intercambiado datos</string>
    <string name="waiting_application_data">Esperando datos</string>
    <string name="text">Texto</string>
    <string name="hexdump">Hexadécimal</string>
    <string name="display_as_text">Mostrar como texto</string>
    <string name="display_as_hexdump">Mostrar como volcado hexadecimal</string>
    <string name="geolocation">Geolocalización</string>
    <string name="downloading">Descargando…</string>
    <string name="built_on">Montada en: %1$s</string>
    <string name="geo_db_download">Toca para descargar la última base de datos. Nuevas bases de datos están disponibles cada mes</string>
    <string name="size_x">Tamaño: %1$s</string>
    <string name="download">Descargar</string>
    <string name="geo_db_delete">Toca para borrar la base de datos y ahorrar espacio</string>
    <string name="connection_blocked">Esta conexión ha sido bloqueada por PCAPdroid</string>
    <string name="import_action">Importar</string>
    <string name="import_failed">Importación fallida</string>
    <string name="rules_import_success">%1$d reglas importadas</string>
    <string name="invalid_backup">Formato no válido</string>
    <string name="no_rules_to_export">No hay reglas que exportar</string>
    <string name="rules_merge_msg">¿Mantener las reglas existentes\?</string>
    <string name="keep_action">Mantener</string>
    <string name="discard_action">Descartar</string>
    <string name="rules_delete_confirm">¿Borrar las reglas seleccionadas\?</string>
    <string name="blocklist">Lista de bloqueos</string>
    <string name="num_configured_rules">Reglas configuradas</string>
    <string name="connections_blocked">Conexiones bloqueadas</string>
    <string name="last_firewall_block">Último bloqueo</string>
    <string name="firewall_is_disabled">El cortafuegos está deshabilitado</string>
    <string name="firewall_is_enabled">El cortafuegos está habilitado</string>
    <string name="action_unblock">Desbloquear</string>
    <string name="websocket">WebSocket</string>
    <string name="netd_block_missed">La conexión fue comenzada por netd, por tanto no se pudo bloquear</string>
    <string name="mitm_addon_bad_version">Versión del complemento mitm incorrecta. Instale la versión %1$s y reinténtalo</string>
    <string name="overview">Resumen</string>
    <string name="string_http_request">Petición HTTP</string>
    <string name="http">HTTP</string>
    <string name="full_payload_summary">Muestra el payload de conexiones completo (por ejemplo, la petición HTTP y respuesta completa). Requiere mucha memoria, no lo uses por mucho tiempo</string>
    <string name="decrypted">Descifrado</string>
    <string name="decryption">Descifrado</string>
    <string name="decryption_filter">Estado: %1$s</string>
    <string name="download_in_progress">Descarga en progreso, por favor espera</string>
    <string name="download_failed">Descarga fallida</string>
    <string name="exporting">Exportando…</string>
    <string name="export_in_progress">Exportación en curso, por favor espere</string>
    <string name="geo_db_not_found">Base de datos no encontrada. La geolocalización está deshabilitada</string>
    <string name="geo_db_missing">Base de datos de geolocalización no encontrada</string>
    <string name="country_rules_warning">Para usar reglas de cortafuegos basadas en países, descargue la base de datos de geolocalización desde los ajustes de PCAPdroid, de lo contrario las reglas basadas en países no tendrán efecto</string>
    <string name="database">Base de datos</string>
    <string name="no_root_firewall">Cortafuegos sin root</string>
    <string name="app_info">Información de la aplicación</string>
    <string name="action_block">Bloquear</string>
    <string name="firewall_summary">Bloquea el acceso a internet de aplicaciones, configura reglas específicas para dominios y direcciones IP. Solo funciona con la captura sin root</string>
    <string name="block_quick">Bloquear QUIC</string>
    <string name="app_intro_next_button">Siguiente</string>
    <string name="install_the_mitm_addon">Instala la extensión <a href="%1$s">complemento mitm</a></string>
    <string name="paid_feature">Funciones de pago</string>
    <string name="firewall_purchase_msg">Compra la función <i>%1$s</i> para comenzar a bloquear conexiones</string>
    <string name="string_http_response">Respuesta HTTP</string>
    <string name="payload">Contenido</string>
    <string name="tx_direction">TX</string>
    <string name="full_payload">Payload completo</string>
    <string name="geolocation_summary">Mostrar información sobre el país y el ASN realizando búsquedas sin conexión</string>
    <string name="block_private_dns">Bloquear DNS privado</string>
    <string name="block_private_dns_summary">Detectar y posiblemente bloquear DNS privado para inspeccionar el tráfico DNS. Deshabilitar esto puede obstaculizar el análisis del tráfico</string>
    <string name="mitm_setup_wizard_intro">Este asistente te guiará por la instalación del complemento mitm y la certificación, los cuales son necesarios para realizar el <a href="%1$s">descifrado TLS</a></string>
    <string name="mitm_setup_wizard_done">PCAPdroid está listo para descifrar el tráfico TLS
\n
\nComprueba la <a href="%1$s">guía del usuario</a> para conocer más sobre las medidas de seguridad que puedan prevenir la desencriptación y como evitarlas</string>
    <string name="app_intro_done_button">Listo</string>
    <string name="country_and_asn">País y ASN</string>
    <string name="app_intro_geolocation_msg">PCAPdroid puede consultar una base de datos local para determinar el país de un servidor remoto
\n
\nPrimero deberás descargar la base de datos de geolocalización desde los ajustes de la aplicación</string>
    <string name="vpn_setup_msg">PCAPdroid simula una VPN para capturar el tráfico de la red sin root.
\n
\nPara iniciar la captura, debes aceptar la solicitud de la VPN en la pantalla siguiente.
\n
\n<b>NOTA:</b>para continuar, deshabilita cualquier VPN siempre activa configurada desde los ajustes de Android</string>
    <string name="permission_grant_fail">El permiso %1$s no pudo ser concedido</string>
    <string name="notifications_notice">La aplicación usa notificaciones para enviar alertas en caso de eventos anómalos. Concédele el permiso para enviarte notificaciones en la siguiente pantalla</string>
    <string name="vpn_exemptions">Excepciones VPN</string>
    <string name="vpn_exemptions_summary">Exime algunas aplicaciones de la conexión VPN. Su tráfico no será monitorizado</string>
    <string name="no_matches_found">Sin coincidencias</string>
    <string name="unblock_permanently">Desbloquear permanentemente</string>
    <string name="unblock_for_n_hours">Desbloquear por %1$dh</string>
    <string name="unblock_for_n_minutes">Desbloquear por %1$dm</string>
    <string name="block_new_apps">Bloquear aplicaciones recién instaladas</string>
    <string name="app_blocked_info">La aplicación %1$s ha sido bloqueada por el cortafuegos</string>
    <string name="build_info">Información de la app</string>
    <string name="traffic_dump">Volcar tráfico</string>
    <string name="unlock_token_error">No se pudo solicitar el token de desbloqueo [%1$d]: %2$s</string>
    <string name="unlock_token_summary">Un token que puede ser usado para desbloquear las funciones de pago en versiones de la aplicación que no sean de Google Play (por ejemplo, F-Droid/GitHub)</string>
    <string name="license_service_unavailable">El servicio de licencias de PCAPdroid no está disponible ahora mismo. Vuelve a intentarlo en unos minutos</string>
    <string name="requesting_unlock_token">Solicitando token de desbloqueo, por favor espera</string>
    <string name="show_action">Mostrar</string>
    <string name="show_connection">Mostrar conexión</string>
    <string name="show_system_apps">Mostrar aplicaciones del sistema</string>
    <string name="unlock_token_msg1">Este es tu token de desbloqueo. Guárdalo, lo necesitarás para generar tus códigos de licencia <a href="%1$s"/></string>
    <string name="heap_usage">Uso del montón</string>
    <string name="vpn_lockdown_notice">Para evitar que las aplicaciones accedan a Internet cuando PCAPdroid no se está ejecutando (por ejemplo, después de reiniciar), puede configurar PCAPdroid como una VPN siempre activa en modo de bloqueo.
\n
\n¿Quieres abrir ahora los ajustes de la VPN\?</string>
    <string name="app_intro_traffic_inspection">La inspección de peticiones HTTP, respuestas y datos sin procesar es muy sencilla gracias a los decodificadores integrados
\n
\n¿Tienes una conexión cifrada\? Puedes habilitar el <a href="%1$s">descifrado TLS</a> para ver los datos descifrados</string>
    <string name="app_intro_traffic_dump">PCAPdroid tiene <a href="%1$s">varios métodos</a> para volcar el tráfico en formato PCAP y realizar análisis posteriores \n \nCon la <a href="%2$s">opción de extensiones de PCAPdroid</a>, puedes añadir nombres de aplicaciones a los paquetes y verlos en Wireshark</string>
    <string name="access_paid_features_msg">Consulta la <a href="%1$s">guía de usuario</a> para saber cómo acceder a las funciones de pago</string>
    <string name="tls_decryption_with_root_msg">Ejecutar el descifrado TLS con privilegios de root es una función experimental. Aquí hay una lista de errores conocidos: \n \n - en PCAPdroid, parece que el tráfico se genera desde la aplicación mitm-addon en lugar de la aplicación original \n - el volcado del registro de claves SSL no es compatible \n - después de configurar un filtro de aplicaciones, solo se descifrará la aplicación de destino, pero PCAPdroid aún mostrará el tráfico de otras aplicaciones \n - si la captura de tráfico no se inicia, asegúrese de que puede ejecutar los comandos de iptables como root (por ejemplo, a través de termux) \n - es posible que esta función no funcione en Android 12 y superior \n - si la aplicación VPN se está ejecutando, debe descifrar la aplicación específica o excluir el complemento PCAPdroid mitm de la VPN; de lo contrario, el tráfico entrará en bucle</string>
    <string name="app_intro_privacy_msg">La aplicación no emplea ninguna función de rastreo, analítica o de llamada a casa.
\n
\n¿Como puedo estar seguro\? Consulta la <a href="%1$s">política de privacidad</a> y el <a href="%2$s">código fuente</a></string>
    <string name="app_intro_firewall_msg">Con el <a href="%1$s">Cortafuegos</a> integrado, puedes bloquear fácilmente el acceso a Internet para aplicaciones, dominios y países específicos. \n \nCombina esto con la vista de tráfico incorporada y tendrás la herramienta perfecta para proteger tu privacidad</string>
    <string name="app_intro_malware_detection">Aumenta la seguridad de tu dispositivo con la característica de <a href="%1$s">detección de malware</a>
\n
\nUsando la última lista negra, puedes detectar, bloquear y advertir de conexiones peligrosas en tiempo real</string>
    <string name="malware_whitelist_action">Lista blanca (software malicioso)…</string>
    <string name="mitm_addon">complemento mitm</string>
    <string name="mitmproxy_opts">Opciones adicionales para mitmproxy</string>
    <string name="mitmproxy_opts_description">Opciones adicionales para mitmproxy</string>
    <string name="mitm_addon_error">Error al iniciar el complemento mitm. Comprueba el registro para más detalles</string>
    <string name="whitelist_mode">Modo permisivo (lista blanca)</string>
    <string name="firewall_whitelist_help">Estas reglas especifican qué conexiones permitir. Las reglas de la lista de bloqueo tienen prioridad sobre las de la lista blanca</string>
    <string name="reset_stats_confirm">¿De verdad quieres restablecer estas estadísticas\?</string>
    <string name="add_to_fw_whitelist">Añadir a lista blanca del cortafuegos</string>
    <string name="remove_from_fw_whitelist">Quitar de la lista blanca del cortafuegos</string>
    <string name="port_mapping">Asignación de puertos</string>
    <string name="port_mapping_summary">Configurar las reglas para la asignación de puertos para redirigir las conexiones a un host o puerto diferente</string>
    <string name="add_action">Añadir</string>
    <string name="redirect_to">Redirigir a:</string>
    <string name="original_port">Puerto de origen</string>
    <string name="required">obligatorio</string>
    <string name="destination_host">Host de destino</string>
    <string name="destination_port">Puerto de destino</string>
    <string name="port_mapping_exists">Mapeo de puertos ya definido</string>
    <string name="items_delete_confirm">¿Borrar los elementos seleccionados\?</string>
    <string name="ip_address">Dirección IP</string>
    <string name="rule_exists">Norma ya definida</string>
    <string name="dns_servers">Servidores DNS</string>
    <string name="dns_servers_summary">Configurar los servidores DNS a utilizar durante la captura</string>
    <string name="ipv4_dns_server">Servidor DNS IPv4</string>
    <string name="ipv6_dns_server">Servidor DNS IPv6</string>
    <string name="use_system_dns">Utilizar la DNS del sistema</string>
    <string name="use_system_dns_summary">Si es posible, utilice los servidores DNS del sistema</string>
    <string name="external_storage_perm_required">El permiso al almacenamiento externo es necesario</string>
    <string name="many_rules_warning">Estás intentando importar muchas reglas, lo que podría hacer que la aplicación no respondiera durante algunas interacciones. ¿De verdad quieres continuar\?</string>
    <string name="pcapng_format">Formato Pcapng</string>
    <string name="pcapng_format_summary">Volcar paquetes en formato Ocapng, que es más flexible y permite incrustar secretos de descifrado TLS</string>
    <string name="no_data">Sin datos</string>
    <string name="app_log">Registro</string>
    <string name="firewall_whitelist_notice">En este modo se bloquearán todas las conexiones, a menos que se incluyan manualmente en una lista blanca. Puedes perder notificaciones push sin una lista blanca adecuada</string>
    <string name="sort_by">Ordenar por</string>
    <string name="total_bytes">bytes totales</string>
    <string name="write_ext_storage_failed">No se pudo escribir en el almacenamiento externo. Consulte el registro de la aplicación para obtener más información</string>
    <string name="socks5_redirection">Redireccionamiento SOCKS5</string>
    <string name="socks5_summary">Configurar la redirección a un proxy SOCKS5</string>
    <string name="socks5_auth">Autenticación SOCKS5</string>
    <string name="socks5_auth_summary">Autenticarse en el proxy a través de nombre de usuario y contraseña</string>
    <string name="username">Nombre de usuario</string>
    <string name="password">Contraseña</string>
    <string name="mitm_addon_autostart_workaround">Falló la conexión con el complemento mitm. Como solución alternativa, puede intentar abrir la aplicación del complemento mitm y luego volver a PCAPdroid sin cerrarla. ¿Quieres abrirlo ahora\?</string>
    <string name="qr_license_confirm">¿Deseas generar una licencia para el dispositivo \"%1$s\" utilizando el siguiente token de desbloqueo\?</string>
    <string name="invalid_license">Licencia no válida</string>
    <string name="connection_error">Error en la conexión: %1$s</string>
    <string name="activate_via_qr_code">Activar mediante un código QR</string>
    <string name="qr_code_expired">Código QR caducado. Genera un nuevo código QR y vuelve a intentarlo</string>
    <string name="qr_info_text">Instala PCAPdroid desde la Google Play y escanea este código QR</string>
    <string name="qr_purchase_required">Compra un token de desbloqueo para proceder a la activación del código QR</string>
    <string name="license_limit_reached">Has alcanzado el límite de licencias para este token de desbloqueo. Compra un nuevo token para generar más licencias</string>
    <string name="license_error">Error en la generación de licencia [%1$d]: %2$s</string>
    <string name="requesting_license">Solicitando un código de licencia, por favor espera</string>
    <string name="license_activation_ok">Completada la activación de la licencia</string>
    <string name="mitm_addon_starting">El complemento Mitm está iniciándose…</string>
    <string name="mitm_addon_running">El complemento Mitm se está ejecutando</string>
    <string name="decryption_rules">Reglas de descifrado</string>
    <string name="decryption_rules_help">Estas reglas especifican qué conexiones descifrar. Las reglas basadas en el host solo funcionan si se ve una respuesta de una DNS anterior</string>
    <string name="status_encrypted">Encriptado</string>
    <string name="injected">Inyectado</string>
    <string name="decrypt_action">Descifrar…</string>
    <string name="dont_decrypt_action">No descifrar…</string>
    <string name="proxy_host">Host del proxy</string>
    <string name="copy_error">No se ha podido escribir el archivo</string>
    <string name="capture_interface_open_error">No se ha podido abrir la interfaz de captura</string>
    <string name="pcap_file_not_exists">El archivo especificado no existe</string>
    <string name="open_pcap_file">Abrir archivo PCAP/Pcapng…</string>
    <string name="pcap_load_success">Archivo de captura cargado</string>
    <string name="unsupported_pcap_file">Formato de archivo de captura no compatible</string>
    <string name="decrypt_pcap_file">Descifrar archivo PCAP/Pcapng…</string>
    <string name="invalid_pcap_file">Formato de archivo de captura no válido</string>
    <string name="root_capture_start_failed">Fallo del inicio de captura. Asegúrate de que el dispositivo está rooteado con Magisk</string>
    <string name="pcap_read_error">Error al leer el archivo de captura. Comprueba el registro para más detalles</string>
    <string name="unsupported_pcap_datalink">El archivo tiene un enlace de datos no compatible</string>
    <string name="pcap_file_load_aborted">Carga del archivo de captura cancelada</string>
    <string name="host_resolution_failed">No se pudo resolver host %1$s</string>
    <string name="pcapdroid_trailer_notice">Para mostrar las aplicaciones reales en lugar de \"%1$s\", asegúrate de habilitar la opción \"%2$s\" antes de generar el volcado</string>
    <string name="decryption_info_no_rule">Para descifrar esta conexión, crea una regla de descifrado desde el panel lateral izquierdo o desde el menú contextual en la lista de Conexiones</string>
    <string name="tls_decryption_no_rules_notice">El descifrado TLS sólo se aplica a las conexiones que coinciden con las reglas configuradas. ¿Deseas crear las reglas de descifrado ahora\?</string>
    <string name="active_vpn_detected">Se ha detectado una VPN activa</string>
    <string name="pcap_load_in_progress">Carga del archivo de captura en proceso, por favor espera</string>
    <string name="root_capture_pcapd_start_failure">Fallo al realizar la captura. Asegúrate de conceder acceso root a PCAPdroid</string>
    <string name="mitm_doze_notice">La optimización de la batería puede interferir con el addon mitm</string>
    <string name="redirected">redirigido</string>
    <string name="connection_redirected_port_map">Esta conexión ha sido redirigida debido a una regla de asignación de puertos</string>
    <string name="dnscrypt_how_to">¿Cómo utilizar DoH / DNSCrypt con PCAPdroid?</string>
    <string name="never">Nunca</string>
    <string name="always">Siempre</string>
    <string name="for_connections_to_decrypt">Solo para conexiones a descifrar</string>
    <string name="target_apps">Aplicaciones de destino</string>
    <string name="target_apps_help">Seleccione las aplicaciones que desea capturar</string>
    <string name="headers">Encabezados</string>
    <string name="body">Cuerpo</string>
    <string name="both">Ambos</string>
    <string name="whats_new">Novedades</string>
    <string name="raw_bytes">Bytes sin formato</string>
    <string name="decrypt_quic_notice">Actualmente no es posible descifrar QUIC. Como solución, detenga la captura y seleccione la opción de bloquear QUIC en los ajustes de PCAPdroid</string>
    <string name="export_ellipsis">Exportar…</string>
    <string name="vpn_reconnection">Reconectar a la VPN</string>
    <string name="vpn_reconnection_aborted">Reconexión a la VPN abortada</string>
    <string name="waiting_for_vpn_disconnect">Esperando a que la VPN activa se desconecte…</string>
    <string name="bytes_threshold">Umbral de bytes</string>
    <string name="select_the_pcap_file">Seleccione el archivo PCAP/Pcapng</string>
    <string name="select_the_keylog_file">Seleccione el archivo de registro de claves SSL</string>
    <string name="errno_epipe">Tubería rota</string>
    <string name="errno_epipe_msg">El servidor cerró la conexión inesperadamente durante la transferencia de datos</string>
    <string name="errno_enetdown">Red caída</string>
    <string name="errno_enetdown_msg">La interfaz de red está caída o no puede conectarse a la red</string>
    <string name="errno_enetunreach">Red inaccesible</string>
    <string name="errno_enetunreach_msg">El sistema no puede encontrar una ruta válida hacia la red de destino</string>
    <string name="errno_enetreset_msg">La conexión de red fue reiniciada por un dispositivo intermediario (p. ej. enrutador u operador móvil)</string>
    <string name="errno_econnaborted">Conexión cancelada</string>
    <string name="errno_econnaborted_msg">La conexión fue cancelada, normalmente debido a un cambio de red</string>
    <string name="errno_econnreset">Conexión reiniciada por el servidor</string>
    <string name="errno_econnreset_msg">El servidor cerró la conexión abruptamente, normalmente debido a un fallo o un cierre no controlado</string>
    <string name="errno_etimedout">Tiempo de conexión agotado</string>
    <string name="errno_etimedout_msg">El servidor tardó demasiado en responder, probablemente debido a retrasos en la red o un servidor ocupado</string>
    <string name="errno_econnrefused_msg">El servidor rechazó la conexión, lo que puede indicar un servidor demasiado ocupado o con fallos</string>
    <string name="errno_ehostunreach">Sin ruta al host</string>
    <string name="errno_ehostunreach_msg">El sistema no puede encontrar una ruta hacia el host de destino</string>
    <string name="dns_conn_info">DNS traduce un nombre de dominio a una dirección IP. Los datos reales se intercambian normalmente a través de conexiones HTTPS/TLS posteriores</string>
    <string name="tls_conn_info">El tráfico TLS/HTTPS está cifrado. Para inspeccionar este tráfico, necesita descifrarlo. Consulte la <a href="%1$s">guía de usuario</a> de PCAPdroid para más detalles</string>
    <string name="tls_decryption_not_supported_16KB">El descifrado TLS no es compatible actualmente en dispositivos de 16 KB</string>
    <string name="filename_prefix">Prefijo de nombre de archivo</string>
    <string name="filename_prefix_description">Establece el prefijo para los archivos exportados por PCAPdroid, p. ej. archivos PCAP</string>
    <string name="no_requests">Sin solicitudes</string>
    <string name="item_not_found">No se pudo encontrar el elemento especificado</string>
    <string name="connection_number">Conexión #%1$d</string>
    <string name="http_request_number">Solicitud HTTP #%1$d</string>
    <string name="http_requests">Solicitudes HTTP</string>
    <string name="switch_to_http">Mostrar solicitudes HTTP</string>
    <string name="switch_to_connections">Mostrar conexiones</string>
    <string name="decryption_error">Error de descifrado</string>
    <string name="previous">Anterior</string>
    <string name="next">Siguiente</string>
    <string name="save_as_text">Guardar como texto</string>
    <string name="save_as_har">Guardar como HAR</string>
    <string name="restart_on_disconnection">Reiniciar al desconectarse</string>
    <string name="restart_on_disconnection_summary">Reiniciar automáticamente la captura después de ser detenido por otras aplicaciones VPN</string>
    <string name="ipv6_bytes_rcvd">Bytes IPv6 recibidos</string>
    <string name="ipv6_bytes_percentage">Porcentaje de bytes IPv6</string>
    <string name="ipv6_bytes_sent">Bytes IPv6 enviados</string>
    <string name="update_available">Actualización disponible</string>
    <string name="mitm_addon_update_available">Hay una nueva actualización del complemento MITM disponible. Actualiza para obtener las últimas correcciones de errores</string>
    <string name="update_action">Actualizar</string>
    <string name="tcp_collector_info">Colector TCP: %1$s:%2$d</string>
    <string name="tcp_exporter">Exportador TCP</string>
    <string name="tcp_udp_exporter">Exportador TCP/UDP</string>
    <string name="tcp_exporter_info">Envía el PCAP a un receptor TCP remoto (pcap-sobre-ip)</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="dump_extensions">Extensiones de PCAPdroid</string>
    <string name="dump_extensions_how_to">Cómo mostrar las extensiones de volcado PCAPdroid en Wireshark</string>
    <string name="generate_api_key">Generar clave API</string>
    <string name="show_api_key">Mostrar clave API</string>
    <string name="api_key">Clave API</string>
    <string name="ip_address_or_cidr">Dirección IP / CIDR</string>
    <string name="errno_enetreset">Restablecer red</string>
    <string name="errno_econnrefused">Conexión rechazada</string>
    <string name="error_code_with_text">%1$s (error %2$d)</string>
    <string name="api_key_discard_confirm">¿Realmente desea descartar la clave API actual y generar una nueva?</string>
    <string name="keylog_read_error">Error de lectura del registro de claves SSL</string>
</resources>

```

`app/src/main/res/values-fr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="protocol">Protocole</string>
    <string name="connections_view">Connexions</string>
    <string name="start_button">Démarrer</string>
    <string name="status">État</string>
    <string name="dns_server">Serveur DNS</string>
    <string name="notification_msg">%1$s capturés, %2$s connexions</string>
    <string name="title_activity_settings">Paramètres</string>
    <string name="collector_info">Collecteur UDP : %1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s reçus – %2$s envoyés</string>
    <string name="query">Requête</string>
    <string name="host">Hôte</string>
    <string name="ready">Prêt</string>
    <string name="about">À propos</string>
    <string name="no_connections">Aucune connexion</string>
    <string name="source">Source</string>
    <string name="destination">Destination</string>
    <string name="packets">Paquets</string>
    <string name="duration">Durée</string>
    <string name="http_server">Serveur HTTP</string>
    <string name="udp_exporter">Exporteur UDP</string>
    <string name="no_dump">Aucune extraction</string>
    <string name="user_guide">Guide d\'utilisation</string>
    <string name="open_telegram_group">Groupe Telegram</string>
    <string name="source_code">Code source</string>
    <string name="yes">Oui</string>
    <string name="vpn_setup_failed">Impossible de configurer le RPV</string>
    <string name="app_not_found">Impossible de trouver l\'application %1$s</string>
    <string name="stats">Statistiques</string>
    <string name="tot_connections">Total des connexions</string>
    <string name="bytes_sent">Octets envoyés</string>
    <string name="bytes_rcvd">Octets reçus</string>
    <string name="packets_sent">Paquets envoyés</string>
    <string name="packets_rcvd">Paquets reçus</string>
    <string name="dns_queries">Requêtes DNS</string>
    <string name="no_apps">Aucune appli</string>
    <string name="apps">Applis</string>
    <string name="cannot_write_file">Impossible d\'écrire le fichier</string>
    <string name="share">Partager</string>
    <string name="pcap_file_action">Trafic enregistré dans le fichier « %1$s » (%2$s)</string>
    <string name="delete_error">Impossible de supprimer le fichier</string>
    <string name="capture_running">Capture en cours</string>
    <string name="first_seen">Début</string>
    <string name="last_seen">Fin</string>
    <string name="conn_status_closed">Terminée</string>
    <string name="copy_to_clipboard">Copier</string>
    <string name="save_to_file">Enregistrer dans un fichier</string>
    <string name="older_connections_notice">%1$d anciennes connexions non affichées</string>
    <string name="error">Erreur</string>
    <string name="conn_status_unreachable">Injoignable</string>
    <string name="other_prefs">Autre</string>
    <string name="app_language">Langue</string>
    <string name="system_default">Paramètre par défaut du système</string>
    <string name="no_activity_file_selection">Aucune application trouvée pour gérer la sélection des fichiers</string>
    <string name="file_saved_with_name">Fichier enregistré sous le nom de « %1$s »</string>
    <string name="donate">Faire un don</string>
    <string name="search">Recherche…</string>
    <string name="app_val">Appli : %1$s</string>
    <string name="ip_address_val">Adresse IP : %1$s</string>
    <string name="host_val">Hôte : %1$s</string>
    <string name="protocol_val">Protocole : %1$s</string>
    <string name="hide">Masquer…</string>
    <string name="n_selected">%1$d sélectionnés</string>
    <string name="select_all">Tout sélectionner</string>
    <string name="app_details">Détails de l\'appli</string>
    <string name="package_name">Nom du paquet</string>
    <string name="uid">UID</string>
    <string name="app_name">Nom</string>
    <string name="installed_on">Installé le</string>
    <string name="last_update">Dernière mise à jour</string>
    <string name="permissions">Autorisations</string>
    <string name="root_app_info">Démons système fonctionnant avec des privilèges maximaux</string>
    <string name="deny">Refuser</string>
    <string name="allow">Autoriser</string>
    <string name="http_server_status">Serveur HTTP: http://%1$s:%2$d</string>
    <string name="open_nav_drawer">Ouvrir le menu</string>
    <string name="save_ok">Enregistré</string>
    <string name="stop_button">Arrêter</string>
    <string name="connection_details">Détails de la connexion</string>
    <string name="delete">Supprimer</string>
    <string name="app">Appli</string>
    <string name="no">Non</string>
    <string name="active_connections">Connexions actives</string>
    <string name="dropped_connections">Connexions interrompues</string>
    <string name="ok">OK</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="unknown_app">Inconnue</string>
    <string name="search_apps">Chercher des applis</string>
    <string name="pcap_file">Fichier PCAP</string>
    <string name="disconnect_vpn_confirm">Déconnecter l\'application RPV active et continuer \?</string>
    <string name="version">Version</string>
    <string name="loading_apps">Chargement des applis…</string>
    <string name="close_nav_drawer">Fermer le menu</string>
    <string name="capture_all_apps">Capturer le trafic de toutes les applications</string>
    <string name="no_dump_info">Le trafic ne sera pas extrait</string>
    <string name="http_server_info">Démarrer un serveur HTTP pour le téléchargement du PCAP</string>
    <string name="udp_exporter_info">Envoie le PCAP à un receveur UCP distant</string>
    <string name="open_sockets">Ouvrir les sockets</string>
    <string name="http_server_port">Port du serveur HTTP</string>
    <string name="receiver_ip_address">Adresse IP du collecteur</string>
    <string name="receiver_port">Port du collecteur</string>
    <string name="pcap_file_info">Créer un fichier PCAP/Pcapng dans l\'espace de stockage de l\'appareil</string>
    <string name="get_app">L\'obtenir :</string>
    <string name="about_text">PCAPdroid est un outil open-source de capture et de suivi de réseau qui fonctionne sans un compte administrateur</string>
    <string name="proxy_port">Port de proxy</string>
    <string name="root_capture">Capturer comme administrateur</string>
    <string name="enable_socks5_proxy_summary">Rediriger toutes les connexions TCP vers un proxy SOCKS5</string>
    <string name="root_capture_summary">Autorise le lancement de PCAPdroid avec d\'autres applications de VPN</string>
    <string name="socks5_proxy">Activer le proxy SOCKS5</string>
    <string name="capture_prefs">Capture</string>
    <string name="packets_dropped">Paquets ignorés</string>
    <string name="android_app_info">Le système Android</string>
    <string name="unknown_app_info">\"Inconnu\" signale les connexions où l\'application n\'a pu être déterminée</string>
    <string name="netd_app_info">Le démon système qui gère de la résolution DNS</string>
    <string name="target_sdk">SDK cible</string>
    <string name="ctrl_consent">Une application voudrait capturer le trafic de l\'appareil.
\nRefusez si vous n\'est pas sûr(e)</string>
    <string name="pending_transaction">Veuillez terminer votre transaction pour débloquer cette fonctionnalité</string>
    <string name="ctrl_consent_title">Requête de contrôle cd PCAPdroid</string>
    <string name="security">Sécurité</string>
    <string name="internet">Internet</string>
    <string name="reset">Rétablir</string>
    <string name="capture_interface">Capturer l\'interface</string>
    <string name="all_interfaces">Tous les interfaces</string>
    <string name="edit_filter">Modifier le filtre</string>
    <string name="edit_list">Modifier la liste</string>
    <string name="ctrl_consent_denied">PCAPdroid : la requête de contrôle à été refusée</string>
    <string name="ctrl_consent_allowed">PCAPdroid : la requête de contrôle à été accepté</string>
    <string name="capturing_from">Capture des paquets depuis « %1$s »</string>
    <string name="hidden_connections_rules">Règles de connexions masquées</string>
    <string name="list_is_empty">La liste est vide</string>
    <string name="malware_detection">Détection de virus</string>
    <string name="malware_detection_summary">Détecte les connexions connues des listes de bannissements pour héberger des virus</string>
    <string name="show_only_malicious">Connexions malveillantes</string>
    <string name="copy_action">Copier…</string>
    <string name="status_filter">Status : %1$s</string>
    <string name="not_hidden_filter">Non masqué</string>
    <string name="url_val">URL : %1$s</string>
    <string name="billing_connecting">Connexion au Google Player en cours, veuillez réessayer plus tard</string>
    <string name="feature_not_available">Cette fonctionnalité n\'est actuellement pas disponible sur votre appareil</string>
    <string name="malware_whitelist_rules">Règles d\'autorisation des virus</string>
    <string name="hidden_connections_help">La liste des règles pour masquer les connexions de la liste et ainsi se concentrer sur les plus pertinentes</string>
    <string name="malicious_connection_filter">Malveillant</string>
    <string name="hint">Astuce</string>
    <string name="once">Une fois</string>
    <string name="forever">Toujours</string>
    <string name="country">Pays</string>
    <string name="asn">ASN</string>
    <string name="whitelist">Autorisés</string>
    <string name="show_me">M\'afficher</string>
    <string name="control_permissions_item">%1$s : %2$s</string>
    <string name="country_val">Pays : %1$s</string>
    <string name="send_report">Envoyer le rapport</string>
    <string name="control_permissions_summary">Vérifier quelles applications peuvent contrôler la capture de PCAPdroid</string>
    <string name="control_permissions">Contrôle des autorisations</string>
    <string name="start_at_boot">Lancer au démarrage</string>
    <string name="start_at_boot_summary">Capturer dès le lancement</string>
    <string name="malware_status_ok">Aucun trafic douteux détecté</string>
    <string name="malware_status_detected">Connexions malveillantes détectées</string>
    <string name="blacklists">Bannis</string>
    <string name="status_outdated">Obsolète</string>
    <string name="status_uptodate">À jour</string>
    <string name="status_not_loaded">Non chargé</string>
    <string name="blacklist_type">Type : %1$s</string>
    <string name="n_rules">%1$s règles</string>
    <string name="connections_checked">Connexions vérifiées</string>
    <string name="blacklist_type_ip">IP bannies</string>
    <string name="blacklist_type_domain">Domaines bannis</string>
    <string name="last_update_val">Dernière mise à jour : %1$s</string>
    <string name="malicious_connections">Connexions malveillantes</string>
    <string name="updated_blacklists">Bannissements mis à jour</string>
    <string name="status_updating">Mise à jour…</string>
    <string name="last_blacklists_update">Dernière mise à jour</string>
    <string name="domain_rules">Règles de domaine</string>
    <string name="ip_rules">Règles IP</string>
    <string name="update_now">Mettre à jour maintenant</string>
    <string name="malware_status_update_failed">Certaines listes sont obsolètes</string>
    <string name="malware_detection_learn_more">En apprendre plus sur la fonctionnalité de détection de virus</string>
    <string name="private_dns_hinders_detection">Les DNS privés empêchent la détection</string>
    <string name="private_dns_message_notice">Un DNS privé empêche PCAPdroid d\'inspecter le trafic DNS. Vous pouvez le désactiver dans les préférences réseau du système Android</string>
    <string name="block">Bloquer…</string>
    <string name="firewall">Par-feu</string>
    <string name="blocked_pkts">Bloqué</string>
    <string name="blocked_connection_filter">Bloqué</string>
    <string name="validate">Valider</string>
    <string name="valid">Valide</string>
    <string name="invalid">Invalide</string>
    <string name="firewall_rules">Règles du par-feu</string>
    <string name="paid_features">Fonctionnalités payantes</string>
    <string name="no_intent_handler_found">Aucune application pour cette action</string>
    <string name="decryption_no_filter_warn">Sélectionnez une application cible lors du décryptage TLS pour éviter de perdre votre connexion internet</string>
    <string name="n_pkts">%1$s paq.</string>
    <string name="purchased">Acheté</string>
    <string name="network_interface">Interface</string>
    <string name="loading">Chargement…</string>
    <string name="buy_action">Acheter</string>
    <string name="interface_filter">Interface : %1$s</string>
    <string name="learn_more">Plus d\'info</string>
    <string name="no_items_for_purchase">Aucun élément à acheter</string>
    <string name="billing_failure">Échec de connexion au Google Play. Veuillez réessayer plus tard</string>
    <string name="capture_not_running_status">La capture n\'a pas été lancée</string>
    <string name="copied">Copié</string>
    <string name="can_use_purchased_feature">Vous pouvez maintenant la fonctionnalité d\'achat</string>
    <string name="start_capture_first">Lancez d\'abord la capture</string>
    <string name="malware_whitelist_help">Les listes utilisateur pour la détection des virus. Pressez longuement une connexion virale pour créer une nouvelle règle qui ne la détectera plus comme un virus</string>
    <string name="conn_status_active">Actif</string>
    <string name="phone_app">Téléphone</string>
    <string name="phone_app_info">Services téléphoniques</string>
    <string name="unblock">Débloquer…</string>
    <string name="tls_decryption">Décryptage TLS</string>
    <string name="traffic_inspection">Inspection du trafic</string>
    <string name="install_action">Installer</string>
    <string name="export_action">Exporter</string>
    <string name="cert_installed_correctly">Le certificat CA est installé</string>
    <string name="checking_the_certificate">Vérification du certificat…</string>
    <string name="export_failed">Échec de l\'export</string>
    <string name="not_encrypted">Non crypté</string>
    <string name="response">Réponse</string>
    <string name="request">Requête</string>
    <string name="overview">Aperçu</string>
    <string name="websocket">WebSocket</string>
    <string name="http">HTTP</string>
    <string name="tx_direction">TX</string>
    <string name="string_http_request">Requête HTTP</string>
    <string name="string_http_response">Réponse HTTP</string>
    <string name="rx_direction">RX</string>
    <string name="decrypted">Décrypté</string>
    <string name="decryption">Décryption</string>
    <string name="not_decryptable">Ne peut pas être décrypté</string>
    <string name="decryption_filter">Décryptage : %1$s</string>
    <string name="network_traffic">Trafic</string>
    <string name="warn_no_app_data">Aucune donnée de l\'app n\'a été echangée</string>
    <string name="hexdump">En hexadécimal</string>
    <string name="geolocation">Géolocalisation</string>
    <string name="downloading">Téléchargement…</string>
    <string name="database">Base de données</string>
    <string name="download_in_progress">Téléchargement en cours, veuillez patienter</string>
    <string name="geo_db_not_found">Aucune base de données trouvée. La géolocalisation est désactivée</string>
    <string name="download_failed">Échec du téléchargement</string>
    <string name="download">Télécharger</string>
    <string name="import_action">Importer</string>
    <string name="import_failed">Échec de l\'importation</string>
    <string name="geo_db_delete">Tapez pour supprimer la base de données et récupérer de l\'espace disque</string>
    <string name="geo_db_download">Tapez pour télécharger la dernière base de données. De nouvelles bases sont disponibles chaque mois</string>
    <string name="size_x">Taille : %1$s</string>
    <string name="built_on">Construit avec : %1$s</string>
    <string name="connection_blocked">Cette connexion a été bloquée par PCAPdroit</string>
    <string name="invalid_backup">Format de sauvegarde invalide</string>
    <string name="rules_import_success">%1$d règles importées</string>
    <string name="keep_action">Garder</string>
    <string name="discard_action">Ignorer</string>
    <string name="blocklist">Liste des blocages</string>
    <string name="no_rules_to_export">Aucune règle à exporter</string>
    <string name="rules_merge_msg">Garder les règles existantes \?</string>
    <string name="rules_delete_confirm">Supprimer les règles sélectionnées \?</string>
    <string name="action_block">Bloquer</string>
    <string name="app_info">Infos de l\'App</string>
    <string name="connections_blocked">Connexions bloquées</string>
    <string name="last_firewall_block">Dernier blocage</string>
    <string name="firewall_is_disabled">Le pare-feu est inactif</string>
    <string name="firewall_is_enabled">Le pare-feu est actif</string>
    <string name="num_configured_rules">Règles configurées</string>
    <string name="action_unblock">Débloquer</string>
    <string name="show_only_cleartext">Connections en clair</string>
    <string name="firewall_filter">Pare-feu : %1$s</string>
    <string name="ip_both">IPv4 et IPv6</string>
    <string name="unblock_for_n_hours">Débloquer pour %1$dh</string>
    <string name="cleartext_connection">En clair</string>
    <string name="no_matches_found">Aucune correspondance</string>
    <string name="unblock_permanently">Débloqué en permanence</string>
    <string name="app_blocked">Application bloquée</string>
    <string name="show_data_action">Afficher les données</string>
    <string name="allowed_connection_filter">Autorisé</string>
    <string name="country_and_asn">Pays et ASN</string>
    <string name="low_memory">Mémoire basse</string>
    <string name="memory_usage">Utilisation de la mémoire</string>
    <string name="ipv4_only">IPv4 uniquement</string>
    <string name="traffic_dump">Extraction du trafic</string>
    <string name="payload">Charge utile</string>
    <string name="block_private_dns">Bloquer les DNS privés</string>
    <string name="app_intro_next_button">Suivant</string>
    <string name="app_intro_skip_button">Passer</string>
    <string name="app_intro_back_button">Retour</string>
    <string name="app_intro_done_button">Terminé</string>
    <string name="welcome_to_pcapdroid">Bienvenue sur PCAPdroid</string>
    <string name="socks5_info">Proxy SOCKS5 : %1$s:%2$d</string>
    <string name="cancel_action">Annuler</string>
    <string name="warning">Attention</string>
    <string name="ipv6_only">IPv6 uniquement</string>
    <string name="build_info">Informations de la version</string>
    <string name="unblock_for_n_minutes">Débloquer pour %1$dm</string>
    <string name="permission_grant_fail">La permission %1$s n\'a pu être obtenue</string>
    <string name="app_unblocked">L\'application %1$s a été débloquée</string>
    <string name="privacy_first">La confidentialité avant tout</string>
    <string name="permission_granted">Permission %1$s acceptée</string>
    <string name="low_memory_info">Cette application n\'a plus de mémoire, il est possible qu\'elle plante</string>
    <string name="capture_stopped_low_memory">La capture a été arrêtée</string>
    <string name="heap_usage">Utilisation du tas</string>
    <string name="connection_not_found">Cette connexion n\'a pu être trouvée</string>
    <string name="ip_mode">Adresses IP VPN</string>
    <string name="mitm_setup_wizard">Assistance de configuration Mitm</string>
    <string name="mitm_start_failed">"Le service mitm n\'a pu être lancé. Veuillez ouvrir  ce greffon manuellement et réessayez"</string>
    <string name="mitm_addon_new_version">Le greffon mitm de PCAPdroid doit être mis à jour</string>
    <string name="full_payload">Charge utile complète</string>
    <string name="waiting_application_data">En attente des données</string>
    <string name="no_root_firewall">Pare-feu non-root</string>
    <string name="block_quick">Bloquer QUIC</string>
    <string name="paid_feature">Fonctionnalité payante</string>
    <string name="firewall_purchase_msg">Achetez la fonctionnalité <i>%1$s</i> pour commencer à bloquer des connexions</string>
    <string name="app_intro_geolocation_msg">PCAPdroid peut demander à une base de données locale le pays du serveur distant
\n
\nVous devez d\'abord télécharger cette base de géolocalisation depuis les préférences de l\'application</string>
    <string name="install_the_mitm_addon">Installer <a href="%1$s">le greffon mitm</a> de PCAPdroid</string>
    <string name="app_blocked_info">L\'application %1$s a été bloquée par le pare-feu</string>
    <string name="paid_features_unlocked">Les fonctionnalités payantes ont été débloquées. Relancez la capture si déjà lancée</string>
    <string name="access_paid_features_msg">Consultez <a href="%1$s">le guide utilisateur</a> pour savoir comment accéder au fonctionnalités payantes</string>
    <string name="unlock_token_error">Le \"unlock token\" [%1$d] n\'a pu être demandé : %2$s</string>
    <string name="show_action">Afficher</string>
    <string name="license_service_unavailable">Le service de licences PCAPdroid n\'a actuellement pas disponible. Veuillez réessayer dans quelques instants</string>
    <string name="requesting_unlock_token">Demande d\'un \"unlock token\", veuillez patienter</string>
    <string name="vpn_exemptions">Exemptions VPN</string>
    <string name="remote_server_warning">Pour des raisons de sécurité, envoyer du trafic au serveur distant \"%1$s\" n\'est pas autorisé\"</string>
    <string name="vpn_setup_msg">PCAPdroid simule un VPN pour pouvoir capturer le trafic réseau sans être root. \n \nPour lancer la capture, vous devez accepter la requête VPN de la page suivante.\n\n<b>NOTE:</b> pour continuer, désactivez tout \"VPN permanent\" que vous auriez configuré depuis les paramètres Android</string>
    <string name="vpn_exemptions_summary">Exclure certaines applications de la connexion VPN. Leur trafic ne pourra pas être suivi</string>
    <string name="payload_scams_notice">Cette vue peut contenir des informations sensibles, comme des mots de passe ou des jetons d\'accès.
\n
\nNe montrer jamais cette vue à qui que ce soit, cela peut être une tentative d\'arnaque</string>
    <string name="app_log">Log</string>
    <string name="no_data">Pas de données</string>
    <string name="malware_whitelist_action">Liste blanche (malware) …</string>
    <string name="full_payload_disabled">L\'option charge utile complète a été désactivée</string>
    <string name="tls_decryption_summary">Déchiffrer le trafic SSL/TLS en opérant en MitM. Cela fonctionne maintenant avec certaines applications, vérifiez le guide de l\'utilisateur</string>
    <string name="cert_reinstall_required">Le certificat de l\'Autorité de Certification (AC) n\'est pas installé, lancez l\'assistant de paramétrage du MitM</string>
    <string name="socks5_redirection">Redirection SOCKS5</string>
    <string name="socks5_summary">Configurer la redirection vers un proxy SOCKS5</string>
    <string name="socks5_auth">Authentification SOCKS5</string>
    <string name="socks5_auth_summary">S\'authentifier sur le proxy par nom d\'utilisateur et mot de passe</string>
    <string name="copy_error">Impossible d\'écrire dans le fichier</string>
    <string name="proxy_host">Nom d\'hôte du proxy</string>
    <string name="pcap_load_in_progress">Chargement du fichier de capture en cours, merci de patienter</string>
    <string name="geo_db_missing">Base de données de géolocalisation manquante</string>
    <string name="netd_block_missed">Cette connexion a été initiée par netd et n\'a donc pas pu être bloquée</string>
    <string name="ipv6_bytes_sent">Octets IPv6 envoyés</string>
    <string name="ipv6_bytes_rcvd">Octets IPv6 reçus</string>
    <string name="ipv6_bytes_percentage">Pourcentage d\'octets IPv6</string>
    <string name="export_ellipsis">Exporter…</string>
    <string name="update_available">Mise à jour disponible</string>
    <string name="update_action">Mettre à jour</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="dump_extensions_summary">Enrichir le format de capture de paquet avec des métadonnées additionnelles, telles que l\'application qui a envoyé/reçu nun paquet donné</string>
    <string name="malicious_connection_description">Une connexion de l\'application \"%1$s\" a déclenché une règle de détection de malware (%2$s)</string>
    <string name="cert_exported_now_installed">Certificat exporté, installez-le maintenant à partir des paramètres Android</string>
    <string name="payload_truncated">La charge utile est tronquée. Pour le voir intégralement, arrêtez la capture et activez \"%1$s\" à partir des réglages de PCAPdroid</string>
    <string name="dump_extensions">Extensions PCAPdroid</string>
    <string name="add_action">Ajouter</string>
    <string name="required">obligatoire</string>
    <string name="rule_exists">Règle déjà définie</string>
    <string name="pcapng_format">Format Pcapng</string>
    <string name="ip_address">Adresse IP</string>
    <string name="reset_stats_confirm">Voulez-vous réellement remettre les statistiques à zéro ?</string>
    <string name="pcapng_format_summary">Exporter les paquets au format Pcapng, qui est plus flexible et permet d\'intégrer des secrets de déchiffrement TLS</string>
    <string name="connection_error">Erreur de connexion: %1$s</string>
    <string name="qr_purchase_required">Achetez un jeton de déverrouillage pour poursuivre l’activation via le QR code</string>
    <string name="sort_by">Trier par</string>
    <string name="qr_license_confirm">Voulez-vous générer une licence pour l\'appareil \"%1$s\" en utilisant le jeton de déverrouillage suivant ?</string>
    <string name="invalid_license">Licence invalide</string>
    <string name="activate_via_qr_code">Activer par QR code</string>
    <string name="qr_info_text">Installez PCAPdroid depuis Google Play et scannez ce QR code</string>
    <string name="remove_from_fw_whitelist">Supprimer de la liste autorisée du pare-feu</string>
    <string name="destination_port">Port de destination</string>
    <string name="items_delete_confirm">Supprimer les éléments sélectionnés ?</string>
    <string name="ip_address_or_cidr">Adresse IP / CIDR</string>
    <string name="dns_servers">Serveurs DNS</string>
    <string name="ipv4_dns_server">Serveur DNS IPv4</string>
    <string name="ipv6_dns_server">Serveur DNS IPv6</string>
    <string name="use_system_dns_summary">Utiliser les serveurs DNS du système si possible</string>
    <string name="total_bytes">Nombre total d\'octets</string>
    <string name="many_rules_warning">Vous essayez d\'importer de nombreuses règles, ce qui pourrait rendre l\'application non réactive lors de certaines interactions. Voulez-vous vraiment continuer ?</string>
    <string name="write_ext_storage_failed">Échec de l\'écriture sur le stockage externe. Consultez le journal de l\'application pour plus de détails</string>
    <string name="username">Nom d\'utilisateur</string>
    <string name="password">Mot de passe</string>
    <string name="qr_code_expired">Le QR code a expiré. Générez un nouveau code QR et réessayez</string>
</resources>

```

`app/src/main/res/values-in/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="private_dns_hinders_detection">DNS Pribadi menghalangi deteksi</string>
    <string name="hide">Sembunyikan…</string>
    <string name="select">Pilih</string>
    <string name="app_details">Detail aplikasi</string>
    <string name="n_selected">%1$d dipilih</string>
    <string name="package_name">Nama paket</string>
    <string name="app_name">Nama</string>
    <string name="version">Versi</string>
    <string name="target_sdk">SDK Target</string>
    <string name="unknown_app_info">\"Tidak diketahui\" menandai koneksi yang aplikasinya tidak dapat ditentukan</string>
    <string name="android_app_info">Sistem Android</string>
    <string name="pending_transaction">Silakan selesaikan transaksi Anda untuk menukarkan fitur ini</string>
    <string name="ctrl_consent">Sebuah aplikasi ingin menangkap lalu lintas perangkat Anda.
\nTolak jika Anda tidak yakin</string>
    <string name="ctrl_consent_title">Permintaan kontrol PCAPdroid</string>
    <string name="ctrl_consent_denied">PCAPdroid: permintaan kontrol ditolak</string>
    <string name="deny">Tolak</string>
    <string name="all_interfaces">Semua interface</string>
    <string name="list_is_empty">Daftar kosong</string>
    <string name="malicious_connection_filter">Berbahaya</string>
    <string name="reset">Atur ulang</string>
    <string name="country_val">Negara: %1$s</string>
    <string name="status_updating">Memperbarui…</string>
    <string name="malware_whitelist_help">Daftar putih yang ditentukan pengguna untuk menghambat deteksi malware. Tekan lama koneksi berbahaya untuk membuat aturan yang tidak menandainya sebagai malware</string>
    <string name="hidden_connections_help">Daftar aturan untuk menyembunyikan entri daftar koneksi sehingga Anda dapat fokus pada yang relevan</string>
    <string name="copy_action">Salin…</string>
    <string name="url_val">URL: %1$s</string>
    <string name="forever">Selamanya</string>
    <string name="not_hidden_filter">Tidak tersembunyi</string>
    <string name="once">Sekali</string>
    <string name="control_permissions_summary">Periksa aplikasi mana yang diizinkan untuk mengontrol penangkapan PCAPdroid</string>
    <string name="country">Negara</string>
    <string name="asn">ASN</string>
    <string name="status_outdated">Usang</string>
    <string name="last_update_val">Pembaruan terakhir: %1$s</string>
    <string name="malware_status_ok">Tidak ada lalu lintas berbahaya yang terdeteksi</string>
    <string name="last_blacklists_update">Pembaharuan Terakhir</string>
    <string name="paid_features">Fitur berbayar</string>
    <string name="malicious_connections">Koneksi berbahaya</string>
    <string name="malware_status_update_failed">Beberapa daftar hitam sudah usang</string>
    <string name="billing_failure">Tidak dapat terhubung ke Google Play. Silakan coba beberapa saat lagi</string>
    <string name="buy_action">Beli</string>
    <string name="capture_not_running_status">Tangkapan tidak berjalan</string>
    <string name="connections_checked">Koneksi diperiksa</string>
    <string name="update_now">Perbarui sekarang</string>
    <string name="malware_detection_learn_more">Pelajari lebih lanjut tentang fitur deteksi malware</string>
    <string name="block">Blokir…</string>
    <string name="firewall">Firewall</string>
    <string name="blocked_connection_filter">Diblokir</string>
    <string name="invalid">Tidak sah</string>
    <string name="no_intent_handler_found">Tidak ada aplikasi yang ditemukan untuk melakukan tindakan ini</string>
    <string name="start_capture_first">Mulai penangkapan terlebih dahulu</string>
    <string name="copied">Disalin</string>
    <string name="loading_apps">Memuat aplikasi…</string>
    <string name="capture_all_apps">Tangkap lalu lintas semua aplikasi</string>
    <string name="collector_info">Kolektor UDP: %1$s:%2$d</string>
    <string name="host">Host</string>
    <string name="ready">Siap</string>
    <string name="about">Tentang</string>
    <string name="connection_details">Detail koneksi</string>
    <string name="protocol">Protokol</string>
    <string name="source">Sumber</string>
    <string name="destination">Tujuan</string>
    <string name="http_server">Server HTTP</string>
    <string name="udp_exporter">Eksportir UDP</string>
    <string name="no_dump">Tidak ada dump</string>
    <string name="http_server_info">Mulai server HTTP untuk unduhan PCAP</string>
    <string name="app">Apl</string>
    <string name="no_dump_info">Lalu lintas tidak akan dibuang</string>
    <string name="receiver_port">Port kolektor</string>
    <string name="user_guide">Panduan pengguna</string>
    <string name="open_telegram_group">Grup telegram</string>
    <string name="source_code">Kode sumber</string>
    <string name="yes">Ya</string>
    <string name="stats">Statistik</string>
    <string name="tot_connections">Jumlah koneksi</string>
    <string name="open_sockets">Buka soket</string>
    <string name="bytes_sent">Byte terkirim</string>
    <string name="packets_rcvd">Paket diterima</string>
    <string name="dropped_connections">Koneksi disingkirkan</string>
    <string name="packets_sent">Paket dikirim</string>
    <string name="dns_server">Server DNS</string>
    <string name="pcap_file_info">Buat file PCAP/Pcapng di dalam penyimpanan perangkat</string>
    <string name="cannot_write_file">Tidak dapat menulis file</string>
    <string name="apps">Apl</string>
    <string name="ok">OK</string>
    <string name="notification_msg">%1$s ditangkap, %2$s koneksi</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">Terlihat</string>
    <string name="last_seen">Terakhir terlihat</string>
    <string name="conn_status_closed">Tertutup</string>
    <string name="about_text">PCAPdroid adalah alat penangkapan dan pemantauan jaringan sumber terbuka yang bekerja tanpa hak akses root</string>
    <string name="get_app">Dapatkan:</string>
    <string name="error">Kesalahan</string>
    <string name="app_language">Bahasa</string>
    <string name="no_activity_file_selection">Tidak ada aplikasi yang ditemukan untuk menangani pemilihan file</string>
    <string name="file_saved_with_name">File disimpan sebagai \"%1$s\"</string>
    <string name="enable_socks5_proxy_summary">Arahkan ulang semua koneksi TCP ke proxy SOCKS5</string>
    <string name="proxy_port">Port proksi</string>
    <string name="root_capture">Capture dengan akses root</string>
    <string name="donate">Donasi</string>
    <string name="search">Cari…</string>
    <string name="ip_address_val">Alamat IP: %1$s</string>
    <string name="host_val">Host: %1$s</string>
    <string name="protocol_val">Protokol: %1$s</string>
    <string name="app_val">Apl: %1$s</string>
    <string name="select_all">Pilih semua</string>
    <string name="uid">UID</string>
    <string name="installed_on">Terinstal pada</string>
    <string name="last_update">Pembaharuan Terakhir</string>
    <string name="permissions">Perizinan</string>
    <string name="netd_app_info">Daemon sistem melakukan resolusi DNS</string>
    <string name="root_app_info">Daemon sistem berjalan dengan hak istimewa maksimum</string>
    <string name="packets_dropped">Paket dikecualikan</string>
    <string name="capture_prefs">Tangkap</string>
    <string name="allow">Izinkan</string>
    <string name="ctrl_consent_allowed">PCAPdroid: permintaan kontrol diizinkan</string>
    <string name="capture_interface">Tangkap interface</string>
    <string name="internet">Internet</string>
    <string name="capturing_from">Menangkap paket dari \"%1$s\"</string>
    <string name="edit_filter">Ubah filter</string>
    <string name="edit_list">Ubah daftar</string>
    <string name="hidden_connections_rules">Aturan koneksi tersembunyi</string>
    <string name="show_only_malicious">Koneksi berbahaya</string>
    <string name="security">Keamanan</string>
    <string name="malware_detection">Pendeteksi malware</string>
    <string name="malware_detection_summary">Deteksi koneksi ke host jahat yang diketahui melalui daftar hitam pihak ketiga</string>
    <string name="malware_whitelist_rules">Aturan daftar putih malware</string>
    <string name="feature_not_available">Saat ini fitur tidak tersedia untuk perangkat Anda</string>
    <string name="billing_connecting">Koneksi ke Google Play sedang berlangsung, silakan coba beberapa saat lagi</string>
    <string name="status_filter">HTTP Status: %1$s</string>
    <string name="show_me">Tunjukkan</string>
    <string name="hint">Petunjuk</string>
    <string name="control_permissions">Izin kontrol</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="send_report">Kirim laporan</string>
    <string name="start_at_boot">Mulai saat boot</string>
    <string name="start_at_boot_summary">Mulai penangkapan otomatis setelah boot</string>
    <string name="malware_status_detected">Koneksi berbahaya terdeteksi</string>
    <string name="whitelist">Daftar putih</string>
    <string name="blacklists">Daftar hitam</string>
    <string name="status_not_loaded">Tidak dimuat</string>
    <string name="status_uptodate">Terbaru</string>
    <string name="blacklist_type">Jenis: %1$s</string>
    <string name="blacklist_type_ip">daftar hitam IP</string>
    <string name="blacklist_type_domain">Daftar hitam domain</string>
    <string name="n_rules">%1$s aturan</string>
    <string name="updated_blacklists">Daftar hitam yang diperbarui</string>
    <string name="domain_rules">Aturan domain</string>
    <string name="ip_rules">Aturan IP</string>
    <string name="private_dns_message_notice">DNS Pribadi mencegah PCAPdroid memeriksa lalu lintas DNS. Anda dapat menonaktifkan dari pengaturan jaringan Android</string>
    <string name="decryption_no_filter_warn">Pilih aplikasi tujuan saat mendekripsi TLS untuk menghindari kehilangan koneksi ke Internet</string>
    <string name="firewall_rules">Aturan firewall</string>
    <string name="blocked_pkts">Diblokir</string>
    <string name="n_pkts">%1$s pkt</string>
    <string name="validate">Validasi</string>
    <string name="valid">Sah</string>
    <string name="network_interface">Interface</string>
    <string name="interface_filter">Interface: %1$s</string>
    <string name="request_method">Metode permintaan</string>
    <string name="content_type">Tipe konten</string>
    <string name="http_status">Status HTTP</string>
    <string name="payload_size_threshold">Ambang batas ukuran muatan</string>
    <string name="method_filter">Metode: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="loading">Memuat…</string>
    <string name="purchased">Dibeli</string>
    <string name="no_items_for_purchase">Tidak ada item yang tersedia untuk dibeli</string>
    <string name="learn_more">Pelajari lebih lanjut</string>
    <string name="can_use_purchased_feature">Sekarang Anda dapat menggunakan fitur yang telah dibeli</string>
    <string name="disconnect_vpn_confirm">Melanjutkan akan memutuskan sambungan VPN yang aktif</string>
    <string name="open_nav_drawer">Buka drawer</string>
    <string name="close_nav_drawer">Tutup drawer</string>
    <string name="save_ok">Disimpan</string>
    <string name="http_server_status">Server HTTP: http://%1$s:%2$d</string>
    <string name="no_connections">Tidak ada koneksi</string>
    <string name="start_button">Mulai</string>
    <string name="stop_button">Berhenti</string>
    <string name="title_activity_settings">Pengaturan</string>
    <string name="rcvd_and_sent">%1$s diterima — %2$s terkirim</string>
    <string name="query">Pertanyaan</string>
    <string name="status">Status</string>
    <string name="connections_view">Koneksi</string>
    <string name="packets">Paket</string>
    <string name="duration">Durasi</string>
    <string name="udp_exporter_info">Kirim PCAP ke penerima UDP jarak jauh</string>
    <string name="vpn_setup_failed">Tidak dapat mengatur VPN. Pastikan VPN Selalu Aktif dinonaktifkan</string>
    <string name="older_connections_notice">%1$d koneksi lama tidak ditampilkan</string>
    <string name="http_server_port">Port server HTTP</string>
    <string name="receiver_ip_address">Alamat IP kolektor</string>
    <string name="no">Tidak</string>
    <string name="app_not_found">Tidak dapat menemukan aplikasi %1$s</string>
    <string name="active_connections">Koneksi aktif</string>
    <string name="bytes_rcvd">Byte diterima</string>
    <string name="search_apps">Cari aplikasi</string>
    <string name="no_apps">Tidak ada aplikasi</string>
    <string name="dns_queries">DNS Kueri</string>
    <string name="pcap_file">File PCAP</string>
    <string name="share">Bagikan</string>
    <string name="pcap_file_action">Trafik disimpan ke file \"%1$s\" (%2$s)</string>
    <string name="delete_error">Tidak dapat menghapus file</string>
    <string name="other_prefs">Lainnya</string>
    <string name="delete">Hapus</string>
    <string name="capture_running">Capture berjalan</string>
    <string name="copy_to_clipboard">Salin ke papan klip</string>
    <string name="save_to_file">Simpan ke file</string>
    <string name="unknown_app">Tidak diketahui</string>
    <string name="system_default">Bawaan sistem</string>
    <string name="conn_status_unreachable">Tidak terjangkau</string>
    <string name="root_capture_summary">Mengizinkan PCAPdroid menangkap koneksi VPN aplikasi lain yang sedang berjalan</string>
    <string name="network_traffic">Lalu lintas</string>
    <string name="warn_no_app_data">Tidak ada data aplikasi yang dipertukarkan</string>
    <string name="hexdump">Timbunan kode heksadesimal</string>
    <string name="display_as_text">Tampilkan sebagai teks</string>
    <string name="display_as_hexdump">Tampilkan sebagai hexdump</string>
    <string name="geolocation">Geolokasi</string>
    <string name="geolocation_summary">Tampilkan info negara dan ASN dengan melakukan pencarian offline</string>
    <string name="download_failed">Gagal mengunduh</string>
    <string name="exporting">Mengekspor…</string>
    <string name="export_in_progress">Ekspor sedang berlangsung, harap tunggu</string>
    <string name="database">Basis data</string>
    <string name="size_x">Ukuran: %1$s</string>
    <string name="geo_db_delete">Ketuk untuk menghapus basis data dan menghemat ruang</string>
    <string name="no_rules_to_export">Tidak ada aturan untuk mengekspor</string>
    <string name="rules_merge_msg">Mempertahankan aturan yang ada\?</string>
    <string name="keep_action">Simpan</string>
    <string name="discard_action">Buang</string>
    <string name="blocklist">Daftar Blokir</string>
    <string name="num_configured_rules">Aturan yang dikonfigurasi</string>
    <string name="connections_blocked">Koneksi diblokir</string>
    <string name="app_info">Info aplikasi</string>
    <string name="decryption">Dekripsi</string>
    <string name="geo_db_not_found">Basis data tidak ditemukan. Geolokasi dinonaktifkan</string>
    <string name="built_on">Dibuat pada: %1$s</string>
    <string name="connection_blocked">Koneksi ini telah diblokir oleh PCAPdroid</string>
    <string name="import_action">Impor</string>
    <string name="action_unblock">Buka blokir</string>
    <string name="decryption_filter">Status: %1$s</string>
    <string name="connection_start_not_seen">PCAPdroid belum melihat awal dari koneksi ini. Beberapa informasi mungkin hilang</string>
    <string name="decrypted">Didekripsi</string>
    <string name="waiting_application_data">Menunggu data</string>
    <string name="text">Teks</string>
    <string name="downloading">Mengunduh…</string>
    <string name="download_in_progress">Unduhan sedang berlangsung, harap tunggu</string>
    <string name="geo_db_download">Ketuk untuk mengunduh database terbaru. Database baru tersedia setiap bulan</string>
    <string name="download">Unduh</string>
    <string name="import_failed">Impor gagal</string>
    <string name="invalid_backup">Format cadangan tidak valid</string>
    <string name="rules_import_success">Aturan yang diimpor %1$d</string>
    <string name="rules_delete_confirm">Hapus aturan yang dipilih\?</string>
    <string name="last_firewall_block">Blok terakhir</string>
    <string name="firewall_is_disabled">Firewall dinonaktifkan</string>
    <string name="firewall_is_enabled">Firewall diaktifkan</string>
    <string name="traffic_dump">Pembuangan lalu lintas</string>
    <string name="conn_status_active">Aktif</string>
    <string name="phone_app">Telepon</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="socks5_info">Proksi SOCKS5: %1$s:%2$d</string>
    <string name="phone_app_info">Layanan telepon</string>
    <string name="unblock">Buka blokir…</string>
    <string name="tls_decryption">Dekripsi TLS</string>
    <string name="tls_decryption_summary">Dekripsi lalu lintas SSL/TLS dengan melakukan mitm. Saat ini dapat bekerja dengan beberapa aplikasi, lihat panduan pengguna</string>
    <string name="traffic_inspection">Inspeksi lalu lintas</string>
    <string name="mitm_start_failed">Tidak dapat memulai layanan mitm. Coba buka aplikasi addon mitm secara manual dan coba lagi</string>
    <string name="mitm_setup_wizard">Petunjuk instalasi Mitm</string>
    <string name="install_action">Instal</string>
    <string name="export_action">Ekspor</string>
    <string name="export_ca_certificate">Ekspor sertifikat CA PCAPdroid, lalu buka pengaturan \"Enkripsi &amp; Kredensial\" Android dan pilih instal sebagai \"sertifikat CA\"</string>
    <string name="export_failed">Ekspor gagal</string>
    <string name="not_encrypted">Tidak dienkripsi</string>
    <string name="request">Permintaan</string>
    <string name="response">Tanggapan</string>
    <string name="overview">Ringkasan</string>
    <string name="string_http_request">Permintaan HTTP</string>
    <string name="string_http_response">Respon HTTP</string>
    <string name="payload_truncated">Payload terpotong. Aktifkan \"%1$s\" untuk menampilkannya secara penuh</string>
    <string name="mitm_addon_bad_version">Versi addon PCAPdroid mitm buruk. Instal versi %1$s dan coba lagi</string>
    <string name="mitm_addon_new_version">Addon mitm PCAPdroid harus di perbarui</string>
    <string name="websocket">WebSocket</string>
    <string name="http">HTTP</string>
    <string name="payload">Muatan</string>
    <string name="tx_direction">TX</string>
    <string name="rx_direction">RX</string>
    <string name="full_payload">Payload penuh</string>
    <string name="full_payload_summary">Tampilkan payload koneksi penuh (mis. permintaan dan respons HTTP lengkap). Ini membutuhkan banyak memori, jangan gunakan dalam jangka panjang</string>
    <string name="not_decryptable">Tidak dapat didekripsi</string>
    <string name="action_block">Blokir</string>
    <string name="cert_installed_correctly">Sertifikat CA diinstal</string>
    <string name="cert_reinstall_required">Sertifikat CA tidak diinstal, jalankan wizard penginstalan mitm</string>
    <string name="block_private_dns">Blokir DNS pribadi</string>
    <string name="country_and_asn">Negara dan ASN</string>
    <string name="cert_exported_now_installed">Sertifikat diekspor, sekarang instal dari pengaturan Android</string>
    <string name="ca_cert_export_failed">Terjadi kesalahan saat mengekspor sertifikat CA
\n
\nJika perangkat Anda mengimplementasikan Autostart atau perangkat lunak serupa untuk membatasi eksekusi layanan latar belakang, pastikan untuk <a href="%1$s">PCAPdroid masuk daftar putih</a></string>
    <string name="install_ca_certificate">Instal sertifikat CA PCAPdroid, pilih \"VPN dan aplikasi\". Android akan meminta kunci layar atau kata sandi Anda</string>
    <string name="checking_the_certificate">Memeriksa sertifikat…</string>
    <string name="app_intro_skip_button">Lewati</string>
    <string name="firewall_summary">Blokir akses internet ke aplikasi, konfigurasikan aturan untuk domain dan alamat IP tertentu. Hanya berfungsi dengan tangkapan non-root</string>
    <string name="no_root_firewall">Firewall tanpa root</string>
    <string name="netd_block_missed">Koneksi ini dimulai oleh netd sehingga tidak dapat diblokir</string>
    <string name="app_intro_next_button">Lanjut</string>
    <string name="block_quick">Blokir QUIC</string>
    <string name="block_private_dns_summary">Mendeteksi dan mungkin memblokir DNS pribadi untuk memeriksa lalu lintas DNS. Menonaktifkan ini dapat menghambat analisis lalu lintas</string>
    <string name="app_intro_back_button">Kembali</string>
    <string name="mitm_setup_wizard_intro">Wizard ini akan memandu Anda melalui penginstalan PCAPdroid mitm addon dan otoritas sertifikasi, yang diperlukan untuk melakukan <a href="%1$s">dekripsi TLS</a></string>
    <string name="mitm_setup_wizard_done">PCAPdroid sekarang siap untuk mendekripsi lalu lintas TLS
\n
\nLihat <a href="%1$s">panduan pengguna</a> untuk mengetahui lebih lanjut tentang langkah-langkah keamanan yang dapat mencegah dekripsi dan cara mengabaikannya</string>
    <string name="welcome_to_pcapdroid">Selamat datang di PCAPdroid</string>
    <string name="app_intro_done_button">Selesai</string>
    <string name="app_intro_geolocation_msg">PCAPdroid dapat meminta database lokal untuk menentukan negara dari server jarak jauh
\n
\nAnda harus terlebih dahulu mengunduh basis data geolokasi dari pengaturan aplikasi</string>
    <string name="app_intro_welcome_msg">PCAPdroid adalah aplikasi ramah privasi yang memungkinkan Anda melacak dan menganalisis koneksi yang dibuat oleh aplikasi di perangkat Anda
\n
\nSelain itu, ini memungkinkan Anda untuk mengekspor dump PCAP dari lalu lintas, mengekstrak metadata, dan banyak lagi!</string>
    <string name="app_intro_privacy_msg">Aplikasi ini tidak menggunakan pelacakan, analitik, atau anti-fitur telepon rumah
\n
\nBagaimana Anda bisa yakin\? Lihat <a href="%1$s">kebijakan privasi</a> dan <a href="%2$s">kode sumber</a>-nya</string>
    <string name="privacy_first">Utamakan privasi</string>
    <string name="vpn_setup_msg">PCAPdroid mensimulasikan VPN untuk menangkap lalu lintas jaringan tanpa root.
\n
\nUntuk memulai pengambilan, Anda harus menerima permintaan VPN di layar berikutnya
\n
\n<b>CATATAN:</b> untuk melanjutkan, nonaktifkan VPN Selalu Aktif yang dikonfigurasi dari pengaturan Android</string>
    <string name="app_intro_traffic_inspection">Memeriksa permintaan HTTP, respons, dan data mentah menjadi mudah, berkat dekoder bawaan
\n
\nPunya koneksi terenkripsi\? Anda dapat mengaktifkan <a href="%1$s">dekripsi TLS</a> untuk mendapatkan data yang didekripsi</string>
    <string name="app_intro_firewall_msg">Dengan <a href="%1$s">Firewall</a> terintegrasi, Anda dapat dengan mudah memblokir akses Internet ke masing-masing aplikasi, domain dan negara.\n\nGabungkan ini dengan visibilitas lalu lintas bawaan untuk mendapatkan alat utama untuk melindungi privasi Anda</string>
    <string name="app_intro_malware_detection">Tingkatkan keamanan perangkat Anda dengan fitur <a href="%1$s">deteksi malware</a>
\n
\nDengan menggunakan daftar hitam terbaru, ini dapat mendeteksi, memblokir, dan memperingatkan koneksi berbahaya secara waktu nyata</string>
    <string name="app_intro_traffic_dump">PCAPdroid menyediakan <a href="%1$s">berbagai cara</a> untuk membuang lalu lintas dalam format PCAP standar untuk analisis lebih lanjut \n \nMelalui <a href="%2$s">opsi ekstensi PCAPdroid</a>, Anda dapat menambahkan nama aplikasi ke paket dan menampilkannya di Wireshark</string>
    <string name="low_memory">Kekurangan Memori</string>
    <string name="heap_usage">memori menumpuk</string>
    <string name="no_matches_found">Tidak ada yang cocok</string>
    <string name="cleartext_connection">Teks bersih</string>
    <string name="unblock_permanently">Buka blokir secara permanen</string>
    <string name="block_new_apps">Blokir aplikasi yang baru diinstal</string>
    <string name="cancel_action">Membatalkan</string>
    <string name="payload_scams_notice">Tampilan ini mungkin berisi informasi sensitif, seperti kata sandi dan token akses Anda.
\n
\nJangan pernah memberikan informasi ini kepada siapa pun, ini mungkin upaya penipuan</string>
    <string name="show_data_action">Lihat data</string>
    <string name="unblock_for_n_minutes">Buka blokir untuk %1$dmenit</string>
    <string name="remote_collector_notice">Anda telah mengonfigurasi PCAPdroid untuk mengirim lalu lintas ke server jauh. Server akan dapat mengakses informasi sensitif Anda.
\n
\nJika seseorang meminta Anda untuk melakukan ini, itu mungkin upaya penipuan</string>
    <string name="memory_usage">Memori digunakan</string>
    <string name="ip_mode">Alamat IP VPN</string>
    <string name="mitm_skip_notice">Sertifikat mitm tampaknya tidak diinstal. Jika Anda melanjutkan, dekripsi mungkin gagal</string>
    <string name="mitm_wizard_description">Konfigurasikan perangkat untuk dekripsi TLS</string>
    <string name="install_the_mitm_addon">Instal PCAPdroid <a href="%1$s">addon mitm</a></string>
    <string name="permission_grant_fail">%1$s izin tidak dapat diberikan</string>
    <string name="low_memory_info">Aplikasi kehabisan memori, perkirakan macet</string>
    <string name="full_payload_disabled">Opsi muatan penuh telah dinonaktifkan</string>
    <string name="ipv4_only">Hanya IPv4</string>
    <string name="ipv6_only">Hanya IPv6</string>
    <string name="ip_both">IPv4 dan IPv6</string>
    <string name="notifications_notice">Aplikasi ini menggunakan pemberitahuan untuk mengirim peringatan jika terjadi peristiwa anomali. Berikan izin untuk mengirim notifikasi di layar berikutnya</string>
    <string name="vpn_exemptions">Pengecualian VPN</string>
    <string name="app_blocked">App terblokir</string>
    <string name="app_blocked_info">Aplikasi %1$s telah diblokir oleh firewall</string>
    <string name="app_unblocked">Aplikasi %1$s telah dibuka blokirnya</string>
    <string name="unlock_token_summary">Token yang dapat digunakan untuk membuka kunci fitur berbayar di versi aplikasi non-Google-Play (mis. F-Droid/Github)</string>
    <string name="unlock_token_error">Tidak dapat meminta unlock token [%1$d]: %2$s</string>
    <string name="access_paid_features_msg">Lihat <a href="%1$s">panduan pengguna</a> untuk mempelajari cara mengakses fitur berbayar</string>
    <string name="license_service_unavailable">Layanan lisensi PCAPdroid saat ini tidak tersedia. Silakan coba lagi dalam beberapa menit</string>
    <string name="requesting_unlock_token">Meminta sebuah unlock token, tunggu sebentar</string>
    <string name="show_action">Lihat</string>
    <string name="show_connection">Lihat koneksi</string>
    <string name="show_system_apps">Lihat aplikasi sistem</string>
    <string name="unlock_token_msg1">Ini adalah token pembuka kunci Anda. Catat karena Anda akan memerlukannya <a href="%1$s">untuk membuat kode lisensi</a></string>
    <string name="show_only_cleartext">Bersihkan koneksi teks</string>
    <string name="allowed_connection_filter">Di Izinkan</string>
    <string name="permission_granted">%1$s izin diberikan</string>
    <string name="firewall_filter">Firewall : %1$s</string>
    <string name="connection_not_found">Tidak dapat menemukan koneksi yang diberikan</string>
    <string name="capture_stopped_low_memory">Penangkapan telah berhenti</string>
    <string name="vpn_lockdown_notice">Untuk mencegah aplikasi mengakses Internet saat PCAPdroid tidak berjalan (misalnya setelah reboot), Anda dapat mengatur PCAPdroid sebagai VPN yang selalu aktif dalam mode penguncian.
\n
\nApakah Anda ingin membuka pengaturan VPN sekarang\?</string>
    <string name="vpn_exemptions_summary">Mengecualikan beberapa aplikasi dari koneksi VPN. Lalu lintas mereka tidak akan dipantau</string>
    <string name="unblock_for_n_hours">Buka blokir untuk %1$djam</string>
    <string name="remote_server_warning">Untuk alasan keamanan, pengiriman lalu lintas ke server jarak jauh \"%1$s\" tidak diperbolehkan</string>
    <string name="warning">Peringatan</string>
    <string name="firewall_purchase_msg">Beli fitur <i>%1$s</i> untuk mulai memblokir koneksi</string>
    <string name="paid_features_unlocked">Fitur berbayar tidak terkunci. Mulai ulang penangkapan jika berjalan</string>
    <string name="build_info">Info build</string>
    <string name="paid_feature">Fitur berbayar</string>
    <string name="socks5_summary">Konfigurasikan pengarahan ulang ke proxy SOCKS5</string>
    <string name="copy_error">Tidak dapat menulis berkas</string>
    <string name="socks5_redirection">Pengarahan ulang SOCKS5</string>
    <string name="firewall_whitelist_notice">Dalam mode ini semua koneksi akan diblokir, kecuali jika dimasukkan ke dalam daftar putih secara manual. Anda mungkin melewatkan notifikasi push tanpa daftar putih yang tepat</string>
    <string name="host_resolution_failed">Tidak dapat menyelesaikan host %1$s</string>
    <string name="dns_servers_summary">Mengonfigurasi server DNS yang akan digunakan selama pencatatan</string>
    <string name="pcap_file_load_aborted">Pemuatan file penangkapan dibatalkan</string>
    <string name="password">Sandi</string>
    <string name="many_rules_warning">Anda mencoba mengimpor banyak aturan, yang bisa membuat aplikasi tidak responsif selama berinteraksi. Apakah Anda benar-benar ingin melanjutkan\?</string>
    <string name="mitm_addon">addon mitm</string>
    <string name="decryption_rules">Aturan dekripsi</string>
    <string name="tls_decryption_no_rules_notice">Dekripsi TLS hanya diterapkan pada koneksi yang sesuai dengan aturan yang dikonfigurasi. Apakah Anda ingin membuat aturan dekripsi sekarang\?</string>
    <string name="pcap_load_success">File penangkapan dimuat</string>
    <string name="ipv4_dns_server">Server DNS IPv4</string>
    <string name="firewall_whitelist_help">Aturan-aturan ini menentukan koneksi mana yang diizinkan. Aturan daftar blokir memiliki prioritas di atas aturan daftar putih</string>
    <string name="status_encrypted">Terenkripsi</string>
    <string name="ip_address">Alamat IP</string>
    <string name="remove_from_fw_whitelist">Hapus dari daftar putih firewall</string>
    <string name="unsupported_pcap_datalink">File tersebut memiliki datalink yang tidak didukung</string>
    <string name="rule_exists">Aturan telah ditetapkan</string>
    <string name="use_system_dns_summary">Gunakan server DNS sistem jika memungkinkan</string>
    <string name="license_error">Kesalahan pembuatan lisensi [%1$d]: %2$s</string>
    <string name="activate_via_qr_code">Aktivasi melalui kode QR</string>
    <string name="qr_code_expired">Kode QR kedaluwarsa. Buat kode QR baru dan coba lagi</string>
    <string name="license_limit_reached">Anda telah mencapai batas lisensi untuk token buka kunci ini. Beli token baru untuk membuat lebih banyak lisensi</string>
    <string name="socks5_auth_summary">Autentikasi ke proxy melalui nama pengguna dan kata sandi</string>
    <string name="mitm_addon_error">Kesalahan saat memulai addon mitm. Periksa log untuk detailnya</string>
    <string name="username">Nama pengguna (username)</string>
    <string name="total_bytes">Total bytes</string>
    <string name="reset_stats_confirm">Apakah Anda benar-benar ingin mengatur ulang statistik ini\?</string>
    <string name="pcap_file_not_exists">File yang ditentukan tidak ada</string>
    <string name="dns_servers">Server DNS</string>
    <string name="license_activation_ok">Aktivasi lisensi selesai</string>
    <string name="sort_by">Urutkan berdasarkan</string>
    <string name="root_capture_start_failed">Pencatatan gagal dijalankan. Pastikan perangkat telah di-root dengan Magisk</string>
    <string name="add_to_fw_whitelist">Tambahkan ke daftar putih firewall</string>
    <string name="external_storage_perm_required">Izin penyimpanan eksternal diperlukan</string>
    <string name="port_mapping_summary">Mengkonfigurasi aturan pemetaan port untuk mengalihkan koneksi ke host atau port yang berbeda</string>
    <string name="write_ext_storage_failed">Gagal menyimpan ke penyimpanan eksternal. Periksa riwayat log aplikasi untuk detailnya</string>
    <string name="mitmproxy_opts_description">Menyediakan opsi tambahan untuk mitmproxy</string>
    <string name="socks5_auth">Autentikasi SOCKS5</string>
    <string name="decryption_info_no_rule">Untuk mendekripsi koneksi ini, buat aturan dekripsi dari menu kiri atau dari menu kontekstual di daftar Sambungan</string>
    <string name="pcapng_format_summary">Buang paket dalam format dump Pcapng, yang lebih fleksibel dan memungkinkan penyisipan rahasia dekripsi TLS</string>
    <string name="dont_decrypt_action">Jangan mendekripsi…</string>
    <string name="pcap_read_error">Kesalahan membaca file tangkapan. Periksa log untuk detailnya</string>
    <string name="add_action">Tambahkan</string>
    <string name="active_vpn_detected">VPN aktif terdeteksi</string>
    <string name="pcap_load_in_progress">Pemuatan file PCAP sedang berlangsung, harap tunggu</string>
    <string name="app_log">Riwayat</string>
    <string name="required">dibutuhkan</string>
    <string name="destination_host">Host tujuan</string>
    <string name="pcapng_format">format Pcapng</string>
    <string name="ipv6_dns_server">Server DNS IPv6</string>
    <string name="port_mapping">Pemetaan port</string>
    <string name="redirect_to">Arahkan ke:</string>
    <string name="mitm_addon_autostart_workaround">Koneksi ke addon mitm gagal. Sebagai solusi, Anda dapat mencoba membuka aplikasi addon mitm dan kembali ke PCAPdroid tanpa menutupnya. Apakah Anda ingin membukanya sekarang\?</string>
    <string name="items_delete_confirm">Hapus item yang dipilih\?</string>
    <string name="no_data">Tidak ada data</string>
    <string name="qr_license_confirm">Apakah Anda ingin membuat lisensi untuk perangkat \"%1$s\" menggunakan token pembuka kunci berikut ini\?</string>
    <string name="qr_info_text">Instal PCAPdroid dari Google Play dan pindai kode QR ini</string>
    <string name="injected">Disuntikkan</string>
    <string name="tls_decryption_with_root_msg">Kemampuan untuk menjalankan dekripsi TLS dengan root adalah fitur eksperimental. Ini adalah daftar bug yang diketahui: \n \n - di PCAPdroid Anda akan melihat lalu lintas yang dihasilkan dari aplikasi mitm-addon sebagai pengganti aplikasi asli \n - ump keylog SSL tidak didukung\n - ketika filter aplikasi ditetapkan, dekripsi hanya akan terjadi untuk aplikasi target, tetapi PCAPdroid masih akan menampilkan lalu lintas aplikasi lain \n - jika penangkapan gagal dimulai, pastikan bahwa Anda benar-benar dapat menjalankan perintah iptables sebagai root (mis. melalui termux) \n - ini mungkin tidak bekerja pada Android 12 dan yang lebih baru \n - jika aplikasi VPN sedang berjalan, Anda harus menargetkan aplikasi tertentu untuk dekripsi atau mengecualikan addon mitm PCAPdroid dari VPN, jika tidak, lalu lintas akan berputar-putar</string>
    <string name="requesting_license">Meminta kode lisensi, harap tunggu</string>
    <string name="mitm_addon_running">Addon mitm sedang berjalan</string>
    <string name="malware_whitelist_action">Daftar putih (malware)…</string>
    <string name="pcapdroid_trailer_notice">Untuk menampilkan aplikasi yang sebenarnya selain \"%1$s\", pastikan untuk mengaktifkan opsi \"%2$s\" sebelum membuat dump</string>
    <string name="mitm_addon_starting">Addon Mitm sudah dijalankan…</string>
    <string name="original_port">Porta asli</string>
    <string name="open_pcap_file">Buka file PCAP/Pcapng…</string>
    <string name="use_system_dns">Gunakan DNS sistem</string>
    <string name="decrypt_action">Dekripsi…</string>
    <string name="root_capture_pcapd_start_failure">Pencatatan gagal dijalankan. Pastikan Anda memberikan akses root ke PCAPdroid</string>
    <string name="qr_purchase_required">Beli token pembuka kunci untuk melanjutkan aktivasi melalui kode QR</string>
    <string name="connection_error">Kesalahan koneksi: %1$s</string>
    <string name="invalid_pcap_file">Format file penangkapan tidak valid</string>
    <string name="invalid_license">Lisensi tidak valid</string>
    <string name="decryption_rules_help">Aturan-aturan ini menentukan koneksi mana yang akan didekripsi. Aturan berbasis host hanya berfungsi jika balasan DNS sebelumnya terlihat</string>
    <string name="proxy_host">Proxy host</string>
    <string name="port_mapping_exists">Pemetaan porta telah ditentukan</string>
    <string name="whitelist_mode">Mode daftar putih</string>
    <string name="mitmproxy_opts">Opsi mitmproxy tambahan</string>
    <string name="destination_port">Porta tujuan</string>
    <string name="capture_interface_open_error">Tidak dapat membuka antarmuka pencatatan</string>
    <string name="raw_bytes">Byte mentah</string>
    <string name="dnscrypt_how_to">Cara penggunaan DoH / DNSCrypt dengan PCAPdroid</string>
    <string name="export_ellipsis">Ekspor…</string>
    <string name="never">Jangan pernah</string>
    <string name="always">Selalu</string>
    <string name="ipv6_bytes_sent">Byte IPv6 terkirim</string>
    <string name="ipv6_bytes_rcvd">Byte IPv6 diterima</string>
    <string name="connection_redirected_port_map">Koneksi ini telah dialihkan karena aturan pemetaan port</string>
    <string name="decrypt_quic_notice">Mendekripsi QUIC saat ini tidak didukung. Sebagai solusi sementara, hentikan penangkapan dan pilih opsi untuk memblokir QUIC di pengaturan PCAPdroid</string>
    <string name="restart_on_disconnection">Mulai ulang saat putus koneksi</string>
    <string name="restart_on_disconnection_summary">Jalankan ulang tangkapan karena penggunaan apl VPN lain</string>
    <string name="vpn_reconnection">Menghubungkan kembali VPN</string>
    <string name="vpn_reconnection_aborted">Penghubungan ulang VPN dihentikan</string>
    <string name="waiting_for_vpn_disconnect">VPN yang sedang berjalan akan diberhentikan…</string>
    <string name="ipv6_bytes_percentage">Persentase byte IPv6</string>
    <string name="target_apps">Aplikasi target</string>
    <string name="target_apps_help">Pilih apl yang ingin ditangkap</string>
    <string name="whats_new">Apa yang baru</string>
    <string name="mitm_doze_notice">Optimasi baterai mungkin mengintervensi add-on mitm</string>
    <string name="redirected">dialihkan</string>
    <string name="for_connections_to_decrypt">Hanya untuk koneksi yang akan didekripsi</string>
    <string name="headers">Header</string>
    <string name="body">Tubuh</string>
    <string name="both">Keduanya</string>
    <string name="malicious_connection_description">Suatu koneksi dari aplikasi “%1$s” memicu sebuah aturan deteksi malware (%2$s)</string>
    <string name="dump_extensions_summary">Memperluas format pembuangan paket dengan metadata tambahan, seperti aplikasi yang mengirim/menerima paket yang sudah diberi</string>
    <string name="malicious_connections_notice">Blacklist mungkin berisi positif palsu. Pastikan untuk memeriksa ulang alamat IP/reputasi domain secara online. Anda dapat mengecualikan positif palsu melalui whitelist malware</string>
    <string name="dns_conn_info">DNS menerjemahkan nama domain menjadi alamat IP. Data sebenarnya biasanya dipertukarkan melalui koneksi HTTPS/TLS berikutnya</string>
    <string name="errno_econnrefused_msg">Server menolak koneksi, yang mungkin mengindikasikan server yang terlalu sibuk atau tidak berfungsi</string>
    <string name="errno_econnrefused">Koneksi ditolak</string>
    <string name="errno_ehostunreach">Tidak ada rute ke host</string>
    <string name="errno_ehostunreach_msg">Sistem tidak dapat menemukan rute ke host tujuan</string>
    <string name="tls_conn_info">lalu lintas TLS/HTTPS dienkripsi. Untuk memeriksa lalu lintas ini, Anda perlu mendekripsinya. Cek <a href="%1$s">panduan pengguna</a> PCAPdroid untuk detailnya</string>
    <string name="tls_decryption_not_supported_16KB">Dekripsi TLS saat ini tidak didukung pada perangkat 16 KB</string>
    <string name="filename_prefix">Awalan nama file</string>
    <string name="filename_prefix_description">Atur awalan untuk file yang diekspor oleh PCAPdroid, mis. file PCAP</string>
    <string name="no_requests">Tidak ada permintaan</string>
    <string name="item_not_found">Item yang ditentukan tidak ditemukan</string>
    <string name="connection_number">Koneksi #%1$d</string>
    <string name="http_request_number">Permintaan HTTP #%1$d</string>
    <string name="http_requests">Permintaan HTTP</string>
    <string name="switch_to_http">Lihat permintaan HTTP</string>
    <string name="switch_to_connections">Lihat koneksi</string>
    <string name="decryption_error">Kesalahan dekripsi</string>
    <string name="previous">Sebelumnya</string>
    <string name="next">Berikutnya</string>
    <string name="save_as_text">Simpan sebagai teks</string>
    <string name="save_as_har">Simpan sebagai HAR</string>
    <string name="dump_extensions_how_to">Cara menampilkan ekstensi pembuangan PCAPdroid di Wireshark</string>
    <string name="dump_extensions">Ekstensi PCAPdroid</string>
    <string name="errno_enetdown">Jaringan mati</string>
    <string name="update_available">Pembaruan Tersedia</string>
    <string name="country_rules_warning">Untuk menggunakan aturan firewall berbasis negara, unduh database geolokasi dari pengaturan PCAPdroid, jika tidak, aturan berbasis negara akan menjadi tidak efektif</string>
    <string name="ip_address_or_cidr">Alamat IP / CIDR</string>
    <string name="errno_enetdown_msg">Antarmuka jaringan mati atau tidak dapat tersambung ke jaringan</string>
    <string name="errno_econnaborted_msg">Sambungan terputus, biasanya karena peralihan jaringan</string>
    <string name="errno_enetunreach">Jaringan tidak tercapai</string>
    <string name="errno_enetunreach_msg">Sistem tidak dapat menemukan rute yang valid ke jaringan tujuan</string>
    <string name="errno_enetreset">Reset jaringan</string>
    <string name="errno_econnreset">Reset koneksi oleh rekan(peer)</string>
    <string name="errno_econnreset_msg">Server tiba-tiba menutup koneksi, biasanya karena kerusakan atau pematian yang tidak pantas</string>
    <string name="errno_etimedout">Waktu koneksi habis</string>
    <string name="errno_etimedout_msg">Server terlalu lama merespons, kemungkinan karena penundaan jaringan atau server yang sibuk</string>
    <string name="errno_epipe">Broken Pipe</string>
    <string name="geo_db_missing">Database geolokasi tidak ada</string>
    <string name="decrypt_pcap_file">Dekripsi file PCAP/Pcapng…</string>
    <string name="keylog_read_error">Kesalahan pembacaan keylog SSL</string>
    <string name="unsupported_pcap_file">Format file penangkapan tidak didukung</string>
    <string name="bytes_threshold">Batas byte</string>
    <string name="select_the_pcap_file">Pilih file PCAP/Pcapng</string>
    <string name="select_the_keylog_file">Pilih file SSL keylog</string>
    <string name="error_code_with_text">%1$s (kesalahan %2$d)</string>
    <string name="errno_epipe_msg">Server tiba-tiba menutup koneksi saat transfer data</string>
    <string name="errno_enetreset_msg">Sambungan jaringan direset oleh perangkat perantara (mis. router atau operator seluler)</string>
    <string name="errno_econnaborted">Koneksi dibatalkan</string>
    <string name="mitm_addon_update_available">Pembaruan addon mitm baru telah tersedia. Perbarui untuk mendapatkan perbaikan bug terbaru</string>
    <string name="update_action">Perbarui</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="tcp_collector_info">Kolektor TCP: %1$s:%2$d</string>
    <string name="tcp_exporter">Eksportir TCP</string>
    <string name="tcp_udp_exporter">Eksportir TCP/UDP</string>
    <string name="tcp_exporter_info">Kirim PCAP ke penerima TCP jarak jauh (pcap-over-ip)</string>
    <string name="generate_api_key">Hasilkan kunci API</string>
    <string name="show_api_key">Tampilkan kunci API</string>
    <string name="api_key">Kunci API</string>
    <string name="api_key_discard_confirm">Apakah Anda benar-benar ingin membuang kunci API saat ini dan membuat yang baru?</string>
    <string name="no_permissions_set_info">Tidak ada izin yang ditetapkan. Panggil PCAPdroid melalui StartActivityForResult untuk menampilkan permintaan izin</string>
</resources>

```

`app/src/main/res/values-it/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">Avvia</string>
    <string name="stop_button">Ferma</string>
    <string name="title_activity_settings">Impostazioni</string>
    <string name="collector_info">Collettore UDP: %1$s:%2$d</string>
    <string name="http_server_status">Server HTTP: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s ricevuti — %2$s inviati</string>
    <string name="query">Query</string>
    <string name="host">Host</string>
    <string name="ready">Pronto</string>
    <string name="about">Informazioni</string>
    <string name="status">Stato</string>
    <string name="connections_view">Connessioni</string>
    <string name="no_connections">Nessuna connessione</string>
    <string name="connection_details">Dettagli connessione</string>
    <string name="app">App</string>
    <string name="protocol">Protocollo</string>
    <string name="source">Sorgente</string>
    <string name="destination">Destinazione</string>
    <string name="packets">Pacchetti</string>
    <string name="duration">Durata</string>
    <string name="http_server">Server HTTP</string>
    <string name="udp_exporter">Esportatore UDP</string>
    <string name="no_dump">Salvataggio disattivato</string>
    <string name="no_dump_info">Il traffico di rete non sarà salvato</string>
    <string name="http_server_info">Avvia un server HTTP per il download del PCAP</string>
    <string name="udp_exporter_info">Invia il PCAP a un collettore UDP remoto</string>
    <string name="http_server_port">Porta del server HTTP</string>
    <string name="receiver_ip_address">IP del collettore</string>
    <string name="receiver_port">Porta del collettore</string>
    <string name="user_guide">Guida utente</string>
    <string name="open_telegram_group">Gruppo Telegram</string>
    <string name="source_code">Codice sorgente</string>
    <string name="yes">Sì</string>
    <string name="no">No</string>
    <string name="vpn_setup_failed">Setup della VPN fallito. Assicurarsi di aver disabilitato la \"VPN sempre attiva\"</string>
    <string name="app_not_found">L\'app %1$s non è stata trovata</string>
    <string name="stats">Statistiche</string>
    <string name="active_connections">Connessioni attive</string>
    <string name="dropped_connections">Connessioni interrotte</string>
    <string name="tot_connections">Connessioni totali</string>
    <string name="open_sockets">Socket aperti</string>
    <string name="bytes_sent">Bytes inviati</string>
    <string name="bytes_rcvd">Bytes ricevuti</string>
    <string name="packets_sent">Pacchetti inviati</string>
    <string name="packets_rcvd">Pacchetti ricevuti</string>
    <string name="dns_queries">Query DNS</string>
    <string name="search_apps">Cerca app</string>
    <string name="no_apps">Nessuna app</string>
    <string name="dns_server">Server DNS</string>
    <string name="apps">App</string>
    <string name="pcap_file">File PCAP</string>
    <string name="pcap_file_info">Crea un file PCAP/Pcapng nella memoria del dispositivo</string>
    <string name="cannot_write_file">Impossibile scrivere il file</string>
    <string name="share">Condividi</string>
    <string name="delete">Elimina</string>
    <string name="ok">OK</string>
    <string name="pcap_file_action">Traffico salvato nel file %1$s (%2$s)</string>
    <string name="delete_error">Impossibile eliminare il file</string>
    <string name="capture_running">Cattura in esecuzione</string>
    <string name="notification_msg">%1$s catturati, %2$s connessioni</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">Inizio</string>
    <string name="last_seen">Fine</string>
    <string name="conn_status_closed">Terminata</string>
    <string name="copy_to_clipboard">Copia</string>
    <string name="save_to_file">Esporta in un file</string>
    <string name="older_connections_notice">%1$d connessioni precedenti nascoste</string>
    <string name="about_text">PCAPdroid è un software libero per la cattura e il monitoraggio di rete che funziona senza privilegi di root</string>
    <string name="get_app">Scaricala:</string>
    <string name="unknown_app">Sconosciuta</string>
    <string name="error">Errore</string>
    <string name="conn_status_unreachable">Non raggiungibile</string>
    <string name="other_prefs">Altro</string>
    <string name="app_language">Lingua</string>
    <string name="system_default">Predefinita del sistema</string>
    <string name="no_activity_file_selection">App di selezione file mancante</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="proxy_port">Porta del proxy</string>
    <string name="root_capture">Cattura come root</string>
    <string name="root_capture_summary">Permette a PCAPdroid di funzionare assieme ad altre app VPN</string>
    <string name="donate">Donazioni</string>
    <string name="search">Cerca…</string>
    <string name="app_val">App: %1$s</string>
    <string name="ip_address_val">Indirizzo IP: %1$s</string>
    <string name="host_val">Host: %1$s</string>
    <string name="protocol_val">Protocollo: %1$s</string>
    <string name="hide">Nascondi…</string>
    <string name="n_selected">%1$d selezionati</string>
    <string name="select_all">Seleziona tutto</string>
    <string name="app_details">Dettaglio app</string>
    <string name="package_name">Nome pacchetto</string>
    <string name="uid">UID</string>
    <string name="app_name">Nome</string>
    <string name="version">Versione</string>
    <string name="target_sdk">Target SDK</string>
    <string name="installed_on">Installata il</string>
    <string name="last_update">Ultimo aggiornamento</string>
    <string name="permissions">Permessi</string>
    <string name="root_app_info">Servizi di sistema eseguiti con i massimi privilegi</string>
    <string name="netd_app_info">Il servizio di sistema che effettua la risoluzione DNS</string>
    <string name="android_app_info">Il sistema android</string>
    <string name="unknown_app_info">\"Sconosciuta\" indica connessioni la cui app non può essere determinata</string>
    <string name="packets_dropped">Pacchetti persi</string>
    <string name="capture_prefs">Cattura</string>
    <string name="pending_transaction">Completa la transazione per ottenere l\'accesso a questa funzionalità</string>
    <string name="ctrl_consent">Un\'altra app vuole catturare il traffico di questo dispositivo.\nNegare l\'accesso se non si è sicuri</string>
    <string name="deny">Nega</string>
    <string name="allow">Permetti</string>
    <string name="ctrl_consent_title">Richiesta di controllo PCAPdroid</string>
    <string name="ctrl_consent_denied">PCAPdroid: la richiesta di controllo è stata rifiutata</string>
    <string name="ctrl_consent_allowed">PCAPdroid: la richiesta di controllo è stata accettata</string>
    <string name="capture_interface">Interfaccia di cattura</string>
    <string name="internet">Internet</string>
    <string name="all_interfaces">Tutte le interfacce</string>
    <string name="capturing_from">Cattura in corso da \"%1$s\"</string>
    <string name="edit_filter">Modifica filtro</string>
    <string name="edit_list">Modifica lista</string>
    <string name="hidden_connections_rules">Regole connessioni nascoste</string>
    <string name="list_is_empty">La lista è vuota</string>
    <string name="show_only_malicious">Connessioni malevole</string>
    <string name="security">Sicurezza</string>
    <string name="malware_detection">Rilevamento malware</string>
    <string name="malware_detection_summary">Rileva le connessioni a host malevoli tramite blacklist di terze parti</string>
    <string name="reset">Reimposta</string>
    <string name="malware_whitelist_rules">Regole della whitelist malware</string>
    <string name="feature_not_available">Questa funzione non è attualmente disponibile per il tuo dispositivo</string>
    <string name="billing_connecting">La connessione a Google Play è in corso, riprovare tra poco</string>
    <string name="malicious_connection_filter">Malevola</string>
    <string name="status_filter">Stato HTTP: %1$s</string>
    <string name="not_hidden_filter">Non nascosta</string>
    <string name="copy_action">Copia…</string>
    <string name="url_val">"URL: %1$s"</string>
    <string name="show_me">Mostrami</string>
    <string name="hint">Suggerimento</string>
    <string name="once">Una volta</string>
    <string name="forever">Per sempre</string>
    <string name="control_permissions">Permessi di controllo</string>
    <string name="control_permissions_summary">Controlla a quali app è permesso controllare la cattura di PCAPdroid</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">Nazione</string>
    <string name="asn">ASN</string>
    <string name="country_val">Nazione: %1$s</string>
    <string name="send_report">Invia report</string>
    <string name="start_at_boot">Cattura all\'avvio</string>
    <string name="malware_status_ok">Nessun traffico malevolo rilevato</string>
    <string name="malware_status_detected">Connessioni malevole rilevate</string>
    <string name="whitelist">Whitelist</string>
    <string name="blacklists">Blacklist</string>
    <string name="status_outdated">Non aggiornato</string>
    <string name="status_not_loaded">Non caricato</string>
    <string name="status_uptodate">Aggiornato</string>
    <string name="blacklist_type">"Tipo: %1$s"</string>
    <string name="blacklist_type_ip">Blacklist di IP</string>
    <string name="blacklist_type_domain">Blacklist di domini</string>
    <string name="n_rules">%1$s regole</string>
    <string name="last_update_val">Ultimo aggiornamento: %1$s</string>
    <string name="malicious_connections">Connessioni malevole</string>
    <string name="updated_blacklists">Blacklist aggiornate</string>
    <string name="connections_checked">Connessioni controllate</string>
    <string name="last_blacklists_update">Ultimo aggiornamento</string>
    <string name="domain_rules">Regole di domini</string>
    <string name="ip_rules">Regole IP</string>
    <string name="malware_status_update_failed">Alcune blacklist non sono aggiornate</string>
    <string name="update_now">Aggiorna ora</string>
    <string name="status_updating">In aggiornamento…</string>
    <string name="malware_detection_learn_more">Scopri di più sulla funzione di rilevamento malware</string>
    <string name="private_dns_message_notice">IL DNS privato impedisce a PCAPdroid di ispezionare il traffico DNS. Puoi disattivarlo dalle impostazioni di rete di Android</string>
    <string name="private_dns_hinders_detection">Il DNS privato ostacola il rilevamento</string>
    <string name="block">Blocca…</string>
    <string name="firewall">Firewall</string>
    <string name="firewall_rules">Regole del firewall</string>
    <string name="blocked_pkts">Bloccata</string>
    <string name="n_pkts">%1$s pacchetti</string>
    <string name="blocked_connection_filter">Bloccata</string>
    <string name="paid_features">Funzioni a pagamento</string>
    <string name="validate">Convalida</string>
    <string name="valid">Valido</string>
    <string name="invalid">Invalido</string>
    <string name="no_intent_handler_found">Nessuna app è in grado di eseguire questa azione</string>
    <string name="network_interface">Interfaccia</string>
    <string name="interface_filter">Interfaccia: %1$s</string>
    <string name="loading">Caricamento…</string>
    <string name="purchased">Acquistato</string>
    <string name="no_items_for_purchase">Non ci sono elementi disponibili per l\'acquisto</string>
    <string name="billing_failure">La connessione a Google Play è fallita, attendere e riprovare</string>
    <string name="learn_more">Scopri di più</string>
    <string name="buy_action">Acquista</string>
    <string name="capture_not_running_status">La cattura non è in esecuzione</string>
    <string name="start_capture_first">Prima avvia la cattura</string>
    <string name="copied">Copiato</string>
    <string name="can_use_purchased_feature">La funzione acquistata è pronta all\'uso</string>
    <string name="disconnect_vpn_confirm">Proseguendo verrà disconnessa l\'attuale VPN attiva</string>
    <string name="loading_apps">Caricamento app…</string>
    <string name="open_nav_drawer">Apri menù</string>
    <string name="close_nav_drawer">Chiudi menù</string>
    <string name="capture_all_apps">Cattura il traffico di tutte le app</string>
    <string name="save_ok">Salvato</string>
    <string name="hidden_connections_help">Lista di regole per nascondere elementi dalla lista connessioni, mettendo in risalto solo connessioni rilevanti</string>
    <string name="file_saved_with_name">File salvato come \"%1$s\"</string>
    <string name="start_at_boot_summary">Avvia la cattura in automatico all\'avvio del dispositivo</string>
    <string name="malware_whitelist_help">Whitelist definita dall\'utente per inibire il rilevamento di malware. Tieni premuto su una connessione malevola per creare una regola</string>
    <string name="enable_socks5_proxy_summary">Redirigi tutte le connessioni TCP verso un proxy SOCKS5</string>
    <string name="decryption_no_filter_warn">Quando la decrittazione TLS è abilitata, è necessario selezionare un filtro app per evitare di perdere la connessione a Internet</string>
    <string name="traffic_dump">Salvataggio del traffico</string>
    <string name="conn_status_active">Attiva</string>
    <string name="phone_app">Telefono</string>
    <string name="socks5_info">Proxy SOCKS5: %1$s:%2$d</string>
    <string name="phone_app_info">Servizi di telefonia</string>
    <string name="tls_decryption">Decrittazione TLS</string>
    <string name="checking_the_certificate">Controllo del certificato…</string>
    <string name="install_ca_certificate">Installa il certificato CA di PCAPdroid, scegliendo \"App e VPN\". Android ti chiederà di inserire segno di sblocco o password</string>
    <string name="cert_exported_now_installed">Il certificato è stato esportato, adesso è necessario installarlo dalle impostazioni di Android</string>
    <string name="cert_installed_correctly">Il certificato CA è stato installato</string>
    <string name="cert_reinstall_required">Il certificato CA non è installato, eseguire nuovamente la configurazione</string>
    <string name="mitm_addon_bad_version">Versione dell\'addon mitm non supportata. Installa la versione %1$s e riprovare</string>
    <string name="mitm_addon_new_version">L\'addon mitm deve essere aggiornato</string>
    <string name="export_failed">Esport fallito</string>
    <string name="not_encrypted">Non cifrata</string>
    <string name="string_http_response">Risposta HTTP</string>
    <string name="payload">Contenuto</string>
    <string name="tx_direction">TX</string>
    <string name="not_decryptable">Non decrittabile</string>
    <string name="full_payload">Contenuto intero</string>
    <string name="full_payload_summary">Mostra il contenuto delle connessioni per intero (e.s. l\'intera richiesta e risposta HTTP). Questa funzione richiede molta memoria, non usare per lunghe catture</string>
    <string name="connection_start_not_seen">PCAPdroid non ha visto l\'inizio della connessione. Alcune informazioni potrebbero essere mancanti</string>
    <string name="network_traffic">Traffico</string>
    <string name="warn_no_app_data">Non è stato scambiato alcun dato applicativo</string>
    <string name="waiting_application_data">In attesa di dati</string>
    <string name="hexdump">In esadecimale</string>
    <string name="geolocation">Geolocalizzazione</string>
    <string name="geolocation_summary">Mostra informazioni quali nazione e ASN tramite ricerche in un database locale</string>
    <string name="downloading">In scaricamento…</string>
    <string name="connection_blocked">Questa connessione è stata bloccata da PCAPdroid</string>
    <string name="import_action">Importa</string>
    <string name="import_failed">Importazione fallita</string>
    <string name="invalid_backup">Formato del backup non valido</string>
    <string name="rules_import_success">Importate %1$d regole</string>
    <string name="no_rules_to_export">Non ci sono regole da esportare</string>
    <string name="rules_merge_msg">Mantenere le regole esistenti\?</string>
    <string name="keep_action">Mantieni</string>
    <string name="discard_action">Scarta</string>
    <string name="rules_delete_confirm">Eliminare le regole selezionate\?</string>
    <string name="blocklist">Lista di blocco</string>
    <string name="num_configured_rules">Regole configurate</string>
    <string name="unblock">Sblocca…</string>
    <string name="mitm_start_failed">Impossibile avviare il servizio di mitm. Prova ad aprire manualmente l\'app dell\'addon di mitm e riprova</string>
    <string name="mitm_setup_wizard">Configurazione mitm</string>
    <string name="overview">Panoramica</string>
    <string name="payload_truncated">Il contenuto visualizzato è limitato. Per mostrarlo per esteso, ferma la cattura e abilita \"%1$s\" dalle impostazioni PCAPdroid</string>
    <string name="websocket">WebSocket</string>
    <string name="rx_direction">RX</string>
    <string name="decrypted">Decifrata</string>
    <string name="decryption_filter">Stato: %1$s</string>
    <string name="download">Scarica</string>
    <string name="app_info">Informazioni app</string>
    <string name="action_block">Blocca</string>
    <string name="welcome_to_pcapdroid">Benvenuto in PCAPdroid</string>
    <string name="app_intro_welcome_msg">PCAPdroid è un\'app privacy-friendly che ti permette di tracciare ed analizzare le connessioni effettuate dalle app del dispositivo
\n
\nTi permette inoltre di salvare il traffico nel formato PCAP, estrarre metadati e molto altro!</string>
    <string name="country_and_asn">Nazione e ASN</string>
    <string name="vpn_setup_msg">Per poter catturare il traffico senza root, PCAPdroid simula una connessione VPN.
\n
\nPer avviare la cattura, è necessario accettare la richiesta di VPN nella prossima schermata.
\n
\n<b>NOTA:</b> per procedere, disabilita ogni eventuale \"VPN sempre attiva\" dalle impostazioni Android</string>
    <string name="tls_decryption_summary">Decritta il traffico SSL/TLS tramite mitm. Potrebbe non funzionare con alcune app, far riferimento alla guida utente</string>
    <string name="traffic_inspection">Ispezione del traffico</string>
    <string name="install_action">Installa</string>
    <string name="export_action">Esporta</string>
    <string name="export_ca_certificate">Esporta il certificato CA di PCAPdroid, poi importalo dalle impostazioni Android di \"Crittografia e Credenziali\", installandolo come \"Certificato CA\"</string>
    <string name="ca_cert_export_failed">Errore durante l\'esportazione del certificato CA
\n
\nSe il tuo dispositivo utilizza Autostart o software simile per limitare l\'esecuzione di processi in background, assicurati di <a href="%1$s">escludere PCAPdroid</a></string>
    <string name="request">Richiesta</string>
    <string name="response">Risposta</string>
    <string name="string_http_request">Richiesta HTTP</string>
    <string name="size_x">Dimensione: %1$s</string>
    <string name="firewall_is_disabled">Il firewall è disabilitato</string>
    <string name="action_unblock">Sblocca</string>
    <string name="app_intro_skip_button">Salta</string>
    <string name="http">HTTP</string>
    <string name="decryption">Decrittazione</string>
    <string name="download_in_progress">Il download è in corso, attendere</string>
    <string name="geo_db_not_found">Database non trovato. Geolocalizzazione disabilitata</string>
    <string name="database">Database</string>
    <string name="download_failed">Download fallito</string>
    <string name="firewall_is_enabled">Il firewall è abilitato</string>
    <string name="built_on">Build del: %1$s</string>
    <string name="geo_db_download">Premere per scaricare l\'ultima versione del database. Nuove versioni sono disponibili mensilmente</string>
    <string name="geo_db_delete">Premere per eliminare il database e far spazio</string>
    <string name="last_firewall_block">Ultimo blocco</string>
    <string name="connections_blocked">Connessioni bloccate</string>
    <string name="netd_block_missed">Questa connessione è stata iniziata da netd, quindi non è stato possibile bloccarla</string>
    <string name="block_quick">Blocca QUIC</string>
    <string name="firewall_summary">Blocca l\'accesso Internet alle app, configura regole per domini e indirizzi IP specifici. Funziona solamente con la cattura non-root</string>
    <string name="no_root_firewall">Firewall senza root</string>
    <string name="mitm_setup_wizard_done">PCAPdroid è pronto a decrittare il traffico TLS
\n
\nPer saperne di più sulle misure di sicurezza adottate dalle app, che potrebbero interferire con la decrittazione, e su come bypassarle, far riferimento alla <a href="%1$s">guida utente</a></string>
    <string name="app_intro_firewall_msg">Grazie al <a href="%1$s">Firewall</a> integrato puoi facilmente bloccare l\'accesso Internet a specifiche app, domini o nazioni \n \nCombina questa funzione con la visibilità sul traffico e otterrai lo strumento definitivo per proteggere la tua privacy</string>
    <string name="block_private_dns">Blocca il DNS privato</string>
    <string name="privacy_first">Prima la privacy</string>
    <string name="block_private_dns_summary">Rileva e, se possibile, blocca il DNS privato per ispezionare il traffico DNS. Disabilitare l\'opzione potrebbe compromettere l\'analisi del traffico</string>
    <string name="mitm_setup_wizard_intro">Questo configuratore ti guiderà attraverso l\'installazione dell\'addon di mitm di PCAPdroid e della sua autorità di certificato, necessari per poter effetuare la <a href="%1$s">decrittazione TLS</a></string>
    <string name="app_intro_next_button">Prossimo</string>
    <string name="app_intro_back_button">Indietro</string>
    <string name="app_intro_done_button">Fatto</string>
    <string name="app_intro_privacy_msg">L\'app non effettua tracking, raccolta di analitiche o phoning-home
\n
\nCome puoi esserne certo\? Dai un\'occhiata alla sua <a href="%1$s">politica sulla privacy</a> e al suo <a href="%2$s">codice sorgente</a></string>
    <string name="app_intro_geolocation_msg">PCAPdroid può usare un database locale per determinare la nazione dei server remoti
\n
\nPer far questo è necessario prima scaricare il database di geolocalizzazione dalle impostazioni dell\'app</string>
    <string name="app_intro_traffic_inspection">Ispezionare richieste e risposte HTTP o dati grezzi è facile grazie ai decoder integrati
\n
\nLa connessione è cifrata\? Puoi abilitare la <a href="%1$s">decrittazione TLS</a> per ottenere i dati decifrati</string>
    <string name="app_intro_malware_detection">Migliora la sicurezza del dispositivo tramite la funzione di <a href="%1$s">rilevamento malware</a>
\n
\nUtilizzando blacklist in continuo aggiornamento, è in grado di rilevare, bloccare e allertare in tempo reale connessioni malevole</string>
    <string name="app_intro_traffic_dump">PCAPdroid dispone di <a href="%1$s">diversi metodi</a> per salvare il traffico in formato PCAP ed effettuare analisi successive \n \nTramite <a href="%2$s">l\'opzione estensioni PCAPdroid</a>, puoi aggiungere i nomi delle app ai pacchetti e visualizzarli in Wireshark</string>
    <string name="permission_granted">Il permesso %1$s è stato concesso</string>
    <string name="permission_grant_fail">Non è stato possibile concedere il permesso %1$s</string>
    <string name="low_memory_info">L\'app sta esaurendo la memoria disponibile, attenzione a possibili crash</string>
    <string name="firewall_filter">Firewall: %1$s</string>
    <string name="allowed_connection_filter">Permessa</string>
    <string name="heap_usage">Utilizzo heap</string>
    <string name="memory_usage">Utilizzo della memoria</string>
    <string name="connection_not_found">Impossibile individuare questa connessione</string>
    <string name="low_memory">Poca memoria</string>
    <string name="capture_stopped_low_memory">La cattura è stata arrestata</string>
    <string name="full_payload_disabled">L\'opzione di contenuto intero è stata disattivata</string>
    <string name="vpn_lockdown_notice">Per evitare che le app accedano a Internet quando PCAPdroid non è attivo (e.s. al riavvio) è possibile abilitare la modalità di VPN sempre attiva con blocco.
\n
\nVuoi aprire le impostazioni delle VPN\?</string>
    <string name="vpn_exemptions">Esenzioni VPN</string>
    <string name="unblock_permanently">Sblocca permanentemente</string>
    <string name="unblock_for_n_hours">Sblocca per %1$dh</string>
    <string name="app_blocked_info">L\'app %1$s è stata bloccata dal firewall</string>
    <string name="ipv4_only">Solo IPv4</string>
    <string name="ip_both">IPv4 e IPv6</string>
    <string name="show_only_cleartext">Connessioni in chiaro</string>
    <string name="ipv6_only">Solo IPv6</string>
    <string name="vpn_exemptions_summary">Esimi app dalla connessione VPN. Il traffico di tali app non sarà monitorato</string>
    <string name="notifications_notice">L\'app invia notifiche per allertare in caso di eventi anomali. Si prega di acconsentire all\'invio di notifiche nella prossima schermata</string>
    <string name="no_matches_found">Nessuna corrispondenza</string>
    <string name="cleartext_connection">In chiaro</string>
    <string name="app_blocked">App bloccata</string>
    <string name="block_new_apps">Blocca le nuove app installate</string>
    <string name="ip_mode">Indirizzi della VPN</string>
    <string name="payload_scams_notice">Questa vista potrebbe contenere dati sensibili, quali le tue password o token di accesso.
\n
\nNon comunicare mai a nessuno questi dati, potrebbe essere un tentativo di truffa</string>
    <string name="cancel_action">Annulla</string>
    <string name="show_data_action">Mostra i dati</string>
    <string name="remote_collector_notice">Hai configurato PCAPdroid per inviare il traffic a un server remoto. Il server potrà accedere ai tuoi dati sensibili.
\n
\nSe qualcuno ti ha chiesto di farlo, questo è probabilmente un tentativo di truffa</string>
    <string name="remote_server_warning">Per ragioni di sicurezza, l\'invio del traffico al server remoto \"%1$s\" non è permesso</string>
    <string name="app_unblocked">L\'app %1$s è stata sbloccata</string>
    <string name="warning">Attenzione</string>
    <string name="install_the_mitm_addon">Installa l\'<a href="%1$s">addon di mitm</a> di PCAPdroid</string>
    <string name="unblock_for_n_minutes">Sblocca per %1$dm</string>
    <string name="paid_features_unlocked">Le funzioni a pagamento sono state sbloccate. Riavvia la cattura</string>
    <string name="build_info">Informazioni build</string>
    <string name="tls_decryption_with_root_msg">La possibilità di eseguire la decrittazione TLS in modalità root è una funzione sperimentale. Ecco una lista di bug noti: \n \n- in PCAPdroid vedrai il traffico come se fosse generato dall\'addon di mitm invece che dall\'app originale \n- la generazione dell\'SSL keylog non è supportata\n- quando un filtro app è impostato, la decrittazione avverrà solo per tale app, tuttavia PCAPdroid mostrarà anche il traffico delle altre app \n- se la cattura non si avvia, controllare se sia possibile eseguire il comando iptables come root (es. tramite termux) \n- questa funzione potrebbe non funzionare in Android 12 e successivi \n- se un\'app di VPN è in esecuzione, assicurati di impostare un filtro app oppure di escludere l\'addon di mitm di PCAPdroid dalla VPN, altrimenti il traffico del dispostivio andrà in loop</string>
    <string name="paid_feature">Funzione a pagamento</string>
    <string name="firewall_purchase_msg">Acquista la funzione di <i>%1$s</i> e inizia a bloccare le connessioni</string>
    <string name="unlock_token_summary">Un token che può essere usato per sbloccare le funzioni a pagamento in build diverse da Google-Play (e.s. F-Droid/Github)</string>
    <string name="unlock_token_error">Impossibile richiedere l\'unlock token [%1$d]: %2$s</string>
    <string name="access_paid_features_msg">Fai riferimento <a href="%1$s">alla guida utente</a> per conoscere come accedere alle funzioni a pagamento</string>
    <string name="license_service_unavailable">Il servizio di licenza di PCAPdroid non è attualmente disponibile. Riprovare tra qualche minuto</string>
    <string name="requesting_unlock_token">In attesa di un unlock token, attendere</string>
    <string name="show_action">Mostra</string>
    <string name="unlock_token_msg1">Questo è il tuo unlock token. Prendine nota in quanto ti servità <a href="%1$s">per generare i codici di licenza</a></string>
    <string name="mitm_skip_notice">Il certificato di mitm non sembra essere installato. Se procedi, la decrittazione potrebbe fallire</string>
    <string name="mitm_wizard_description">Configura il dispositivo per la decrittazione TLS</string>
    <string name="app_log">Log</string>
    <string name="no_data">Dati non disponibili</string>
    <string name="malware_whitelist_action">Aggiungi a whitelist (malware)…</string>
    <string name="mitm_addon">addon di mitm</string>
    <string name="mitmproxy_opts">Opzioni aggiuntive mitmproxy</string>
    <string name="mitmproxy_opts_description">Fornisci opzioni aggiuntive per mitmproxy</string>
    <string name="mitm_addon_error">Errore durante l\'avvio dell\'addon di mitm. Per maggiori dettagli controllare il log</string>
    <string name="whitelist_mode">Modalità whitelist</string>
    <string name="firewall_whitelist_notice">In questa modalità tutte le connessioni sono bloccate, a parte quelle manualmente whitelistate. Se non crei una whitelist appropriata, potresti inibire le notifiche push del sistema</string>
    <string name="firewall_whitelist_help">Queste regole specificano quali conessioni sono consentite. Le regole della lista di blocco hanno preferenza sulle regole della whitelist</string>
    <string name="add_to_fw_whitelist">Aggiungi alla whitelist del firewall</string>
    <string name="remove_from_fw_whitelist">Rimuovi dalla whitelist del firewall</string>
    <string name="reset_stats_confirm">Vuoi veramente resettare queste statistiche\?</string>
    <string name="port_mapping">Port mapping</string>
    <string name="port_mapping_summary">Configura del regole di port mapping per redirigere le connessioni a host o porte differenti</string>
    <string name="add_action">Aggiungi</string>
    <string name="redirect_to">Redireziona a:</string>
    <string name="original_port">Porta originale</string>
    <string name="required">richiesto</string>
    <string name="destination_port">Porta di destinazione</string>
    <string name="port_mapping_exists">Regola di port mapping già definita</string>
    <string name="items_delete_confirm">Eliminare gli elementi selezionati\?</string>
    <string name="ip_address">Indirizzo IP</string>
    <string name="rule_exists">Regola già definita</string>
    <string name="dns_servers">Server DNS</string>
    <string name="dns_servers_summary">Configura i server DNS da usare durante la cattura</string>
    <string name="ipv4_dns_server">Server DNS per IPv4</string>
    <string name="ipv6_dns_server">Server DNS per IPv6</string>
    <string name="use_system_dns">Usa il DNS di sistema</string>
    <string name="use_system_dns_summary">Se possibile utilizza i server DNS di sistema</string>
    <string name="external_storage_perm_required">Il permesso di accesso ai file esterni è richiesto</string>
    <string name="many_rules_warning">Si sta cercando d\'importare molte regole, che potrebbero causare il rallentamento dell\'app durante alcune interazioni con la stessa. Procedere\?</string>
    <string name="pcapng_format">Formato pcapng</string>
    <string name="pcapng_format_summary">Salva i pacchetti di rete nel formato Pcapng, che è più flessibile e consente di incorporare segreti di decrittazione TLS</string>
    <string name="sort_by">Ordina per</string>
    <string name="total_bytes">Bytes totali</string>
    <string name="write_ext_storage_failed">Errore nella scrittura sull\'archivio esterno. Per maggiori dettagli controllare il log dell\'applicazione</string>
    <string name="socks5_auth">Autenticazione SOCKS5</string>
    <string name="socks5_auth_summary">Autenticati al proxy tramite nome utente e password</string>
    <string name="username">Nome utente</string>
    <string name="password">Password</string>
    <string name="socks5_redirection">Redirezione SOCKS5</string>
    <string name="socks5_summary">Configura la redirezione ad un proxy SOCKS5</string>
    <string name="mitm_addon_autostart_workaround">Connessione all\'addon di mitm fallita. Come soluzione, prova ad aprire l\'app dell\'addon e, lasciando quest\'app aperta, tornare a PCAPdroid. Vuoi aprirla adesso\?</string>
    <string name="qr_license_confirm">Vuoi generare una licenza per il dispositivo \"%1$s\" utilizzando il seguente unlock token\?</string>
    <string name="invalid_license">Licenza non valida</string>
    <string name="connection_error">Errore di connessione: %1$s</string>
    <string name="activate_via_qr_code">Attiva tramite QR code</string>
    <string name="qr_code_expired">QR code scaduto. Genera un nuovo QR code e riprova</string>
    <string name="qr_info_text">Installa PCAPdroid da Google Play e scansiona questo QR code</string>
    <string name="license_limit_reached">Hai raggiunto il limite di licenze generabili per questo unlock token. Acquista un nuovo token per generarne di nuove</string>
    <string name="license_error">Errore nella generazione della licenza [%1$d]: %2$s</string>
    <string name="requesting_license">Richiedendo un codice di licenza, attendere</string>
    <string name="license_activation_ok">Licenza attivata con successo</string>
    <string name="qr_purchase_required">Acquista un unlock token per procedere con l\'attivazione tramite QR code</string>
    <string name="decrypt_action">Decritta…</string>
    <string name="status_encrypted">Crittata</string>
    <string name="injected">Iniettati</string>
    <string name="mitm_addon_starting">Avviando l\'addon di mitm…</string>
    <string name="mitm_addon_running">Addon di mitm in esecuzione</string>
    <string name="decryption_rules">Regole di decrittazione</string>
    <string name="decryption_rules_help">Queste regole specificano quali connessioni decrittare. Regole basate su host funzionano solo in presenza di una risposta DNS vista in precedenza</string>
    <string name="dont_decrypt_action">Non decrittare…</string>
    <string name="copy_error">Impossibile scrivere il file</string>
    <string name="proxy_host">Host del proxy</string>
    <string name="pcap_load_in_progress">Caricamento del file di acquisizione in corso, attendere</string>
    <string name="open_pcap_file">Apri file PCAP/Pcapng…</string>
    <string name="pcap_load_success">File di cattura caricato</string>
    <string name="invalid_pcap_file">Formato file di cattura non valido</string>
    <string name="capture_interface_open_error">Impossibile aprire l\'interfaccia di cattura</string>
    <string name="active_vpn_detected">Rilevata una VPN attiva</string>
    <string name="unsupported_pcap_datalink">Il file ha un datalink non supportato</string>
    <string name="pcap_file_not_exists">Il file specificato non esiste</string>
    <string name="root_capture_start_failed">Avvio della cattura fallito. Assicurarsi che il root del dispositivo sia effettuato con Magisk</string>
    <string name="pcap_read_error">Errore durante la lettura del file di cattura. Controlla il registro per i dettagli</string>
    <string name="pcap_file_load_aborted">Caricamento file di cattura annullato</string>
    <string name="host_resolution_failed">Impossibile risolvere l\'host %1$s</string>
    <string name="pcapdroid_trailer_notice">Per visualizzare le app effettive invece di \"%1$s\", abilitare l\'opzione \"%2$s\" prima di generare il dump</string>
    <string name="decryption_info_no_rule">Per decrittare questa connessione, crea una regola di decrittazione dal menù a sinistra o dal menu contestuale nell\'elenco Connessioni</string>
    <string name="tls_decryption_no_rules_notice">La decrittazione TLS è applicata soltanto alle connessioni che matchano le regole configurate. Vuoi creare ora delle regole di decrittazione\?</string>
    <string name="root_capture_pcapd_start_failure">Avvio della cattura fallito. Assicurati di concedere l\'accesso root a PCAPdroid</string>
    <string name="export_ellipsis">Esporta…</string>
    <string name="redirected">redirezionata</string>
    <string name="always">Sempre</string>
    <string name="target_apps">Filtri app</string>
    <string name="whats_new">Novità</string>
    <string name="mitm_doze_notice">L\'ottimizzazione della batteria potrebbe interferire con l\'addon mitm</string>
    <string name="never">Mai</string>
    <string name="for_connections_to_decrypt">Solo per connessioni da decrittare</string>
    <string name="decrypt_quic_notice">La decrittazione di QUIC non è attualmente supportata. Come soluzione temporanea, ferma la cattura e seleziona l\'opzione di blocco QUIC dalle opzioni PCAPdroid</string>
    <string name="target_apps_help">Seleziona le applicazione da catturare</string>
    <string name="headers">Header</string>
    <string name="connection_redirected_port_map">Questa connessione è stata redirezionata per via di una regola di port mapping</string>
    <string name="dnscrypt_how_to">Come usare DoH / DNSCrypt con PCAPdroid</string>
    <string name="body">Corpo</string>
    <string name="both">Entrambi</string>
    <string name="raw_bytes">Byte grezzi</string>
    <string name="restart_on_disconnection">Riavvia su disconnessione</string>
    <string name="restart_on_disconnection_summary">Riavvia in automatico la cattura dopo che questa è stata interrotta da altre app di VPN</string>
    <string name="ipv6_bytes_rcvd">Bytes IPv6 ricevuti</string>
    <string name="ipv6_bytes_percentage">Percentuale bytes IPv6</string>
    <string name="waiting_for_vpn_disconnect">In attesa che la VPN attiva termini…</string>
    <string name="ipv6_bytes_sent">Bytes IPv6 inviati</string>
    <string name="vpn_reconnection">Riconnessione VPN</string>
    <string name="vpn_reconnection_aborted">Riconnessione VPN annullata</string>
    <string name="update_available">Aggiornamento disponibile</string>
    <string name="update_action">Aggiorna</string>
    <string name="mitm_addon_update_available">Una nuova versione dell\'addon mitm è disponibile. Aggiorna per ottenere gli ultimi miglioramenti</string>
    <string name="dump_extensions_summary">Estendi il dump dei pacchetti con metadati aggiuntivi, come l\'app che ha inviato/ricevuto un determinato pacchetto</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="dump_extensions">Estensioni PCAPdroid</string>
    <string name="unsupported_pcap_file">Formato file di cattura non supportato</string>
    <string name="errno_etimedout_msg">Il server ha impiegato troppo tempo per rispondere, probabilmente a causa di ritardi di rete o di un server occupato</string>
    <string name="dns_conn_info">Il DNS traduce un nome di dominio in un indirizzo IP. I dati effettivi vengono generalmente scambiati tramite connessioni HTTPS/TLS successive</string>
    <string name="tls_conn_info">Il traffico TLS/HTTPS è criptato. Per ispezionare questo traffico, è necessario decriptarlo. Dai un\'occhiata alla <a href="%1$s">guida utente di PCAPdroid</a> per i dettagli</string>
    <string name="malicious_connection_description">Una connessione dall\'app \"%1$s\" ha attivato una regola di rilevamento malware (%2$s)</string>
    <string name="malicious_connections_notice">Le Blacklist possono contenere falsi positivi. Assicurati di ricontrollare online l\'indirizzo IP/reputazione del dominio. Puoi escludere i falsi positivi tramite la whitelist malware</string>
    <string name="geo_db_missing">Database geolocalizzazione non presente</string>
    <string name="country_rules_warning">Per utilizzare le regole del firewall basate sul paese, scarica il database di geolocalizzazione dalle impostazioni di PCAPdroid, altrimenti le regole basate sul paese saranno inefficaci</string>
    <string name="keylog_read_error">Errore di lettura del keylog SSL</string>
    <string name="bytes_threshold">Soglia di byte</string>
    <string name="select_the_pcap_file">Seleziona il file PCAP/Pcapng</string>
    <string name="select_the_keylog_file">Seleziona il file keylog SSL</string>
    <string name="error_code_with_text">%1$s (errore %2$d)</string>
    <string name="errno_epipe_msg">Il server ha chiuso inaspettatamente la connessione durante il trasferimento dei dati</string>
    <string name="errno_enetdown">La rete non funziona</string>
    <string name="errno_enetdown_msg">L\'interfaccia di rete è inattiva o non è in grado di connettersi alla rete</string>
    <string name="errno_epipe">Broken pipe</string>
    <string name="errno_enetunreach">La rete è irraggiungibile</string>
    <string name="errno_enetunreach_msg">Il sistema non riesce a trovare una rotta valida verso la rete di destinazione</string>
    <string name="errno_enetreset">Ripristino della rete</string>
    <string name="errno_enetreset_msg">La connessione di rete è stata ripristinata da un dispositivo intermediario (ad esempio router o operatore di telefonia mobile)</string>
    <string name="errno_econnaborted">Connessione interrotta</string>
    <string name="errno_econnaborted_msg">La connessione è stata interrotta, solitamente a causa di una transizione di rete</string>
    <string name="errno_econnreset">Connessione ripristinata dal peer</string>
    <string name="errno_econnreset_msg">Il server ha chiuso improvvisamente la connessione, solitamente a causa di un crash o di un arresto anomalo o uno spegnimento forzato</string>
    <string name="errno_etimedout">Timeout connessione</string>
    <string name="errno_econnrefused">Connessione rifiutata</string>
    <string name="errno_econnrefused_msg">Il server ha rifiutato la connessione, potrebbe indicare un sovraccarico o un malfunzionamento</string>
    <string name="errno_ehostunreach">Nessuna rotta per l\'host</string>
    <string name="errno_ehostunreach_msg">Il sistema non riesce a trovare una rotta verso l\'host di destinazione</string>
    <string name="decrypt_pcap_file">Decritta il file PCAP/Pcapng…</string>
    <string name="dump_extensions_how_to">Come visualizzare le estensioni dump PCAPdroid in Wireshark</string>
    <string name="ip_address_or_cidr">Indirizzo IP / CIDR</string>
    <string name="tcp_collector_info">Collettore TCP: %1$s:%2$d</string>
    <string name="tcp_exporter">Esportatore TCP</string>
    <string name="tcp_udp_exporter">Esportatore TCP/UDP</string>
    <string name="tcp_exporter_info">Invia il PCAP a un collettore TCP remoto (pcap-over-ip)</string>
    <string name="generate_api_key">Genera chiave API</string>
    <string name="no_permissions_set_info">Nessun permesso impostato. Avvia PCAPdroid tramite StartActivityForResult per mostrare la richiesta di permesso</string>
    <string name="show_api_key">Mostra chiave API</string>
    <string name="api_key">Chiave API</string>
    <string name="api_key_discard_confirm">Vuoi veramente scartare l\'attuale chiave API e generarne una nuova?</string>
    <string name="tls_decryption_not_supported_16KB">La decrittazione TLS non è attualmente supportata su dispositivi a 16 KB</string>
    <string name="filename_prefix">Prefisso nomi dei file</string>
    <string name="filename_prefix_description">Imposta il prefisso usato per i file esportati da PCAPdroid, e.s. file PCAP</string>
    <string name="select">Seleziona</string>
    <string name="request_method">Metodo della richiesta</string>
    <string name="content_type">Content type</string>
    <string name="http_status">Status HTTP</string>
    <string name="method_filter">Metodo: %1$s</string>
    <string name="text">Testo</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="display_as_text">Mostra come testo</string>
    <string name="payload_size_threshold">Soglia dimensione payload</string>
    <string name="display_as_hexdump">Mostra come hexdump</string>
    <string name="export_in_progress">Esportazione in corso, attendere</string>
    <string name="exporting">Esportando…</string>
    <string name="show_connection">Mostra la connessione</string>
    <string name="show_system_apps">Mostra app di sistema</string>
    <string name="item_not_found">Impossibile trovare l\'elemento specificato</string>
    <string name="no_requests">Nessuna richiesta</string>
    <string name="destination_host">Host di destinazione</string>
    <string name="connection_number">Connessione #%1$d</string>
    <string name="switch_to_connections">Mostra le connessioni</string>
    <string name="decryption_error">Errore di decrittazione</string>
    <string name="http_request_number">Richiesta HTTP #%1$d</string>
    <string name="http_requests">Richieste HTTP</string>
    <string name="switch_to_http">Mostra le richieste HTTP</string>
    <string name="save_as_har">Salva come HAR</string>
    <string name="previous">Precedente</string>
    <string name="next">Successivo</string>
    <string name="save_as_text">Salva come testo</string>
</resources>

```

`app/src/main/res/values-ja/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">開始</string>
    <string name="stop_button">終了</string>
    <string name="title_activity_settings">設定</string>
    <string name="collector_info">UDP コントローラー: %1$s:%2$d</string>
    <string name="http_server_status">HTTP サーバー: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s 受信 — %2$s 送信</string>
    <string name="query">クエリ</string>
    <string name="host">ホスト</string>
    <string name="ready">準備完了</string>
    <string name="about">詳細</string>
    <string name="status">状態</string>
    <string name="connections_view">接続</string>
    <string name="no_connections">接続がありません</string>
    <string name="connection_details">接続の詳細</string>
    <string name="app">アプリ</string>
    <string name="protocol">プロトコル</string>
    <string name="source">ソース</string>
    <string name="destination">宛先</string>
    <string name="packets">パケット</string>
    <string name="duration">期限</string>
    <string name="http_server">HTTP サーバー</string>
    <string name="udp_exporter">UDP エクスポーター</string>
    <string name="no_dump">なし</string>
    <string name="no_dump_info">PCAP はダンプしません</string>
    <string name="http_server_info">PCAP をダウンロードするために HTTP サーバーを開始します</string>
    <string name="udp_exporter_info">PCAP をリモート UDP レシーバーに送信します</string>
    <string name="http_server_port">HTTP サーバー ポート</string>
    <string name="receiver_ip_address">コントローラー IP アドレス</string>
    <string name="receiver_port">コントローラー ポート</string>
    <string name="user_guide">ユーザー ガイド</string>
    <string name="open_telegram_group">Telegram グループ</string>
    <string name="source_code">ソース コード</string>
    <string name="yes">はい</string>
    <string name="no">いいえ</string>
    <string name="vpn_setup_failed">VPN セットアップに失敗しました</string>
    <string name="app_not_found">アプリ「%1$s」は見つかりません</string>
    <string name="stats">統計</string>
    <string name="active_connections">アクティブな接続</string>
    <string name="dropped_connections">ドロップされた接続</string>
    <string name="tot_connections">接続の合計</string>
    <string name="open_sockets">オープン ソケット</string>
    <string name="bytes_sent">バイト送信</string>
    <string name="bytes_rcvd">バイト受信</string>
    <string name="packets_sent">パケット送信</string>
    <string name="packets_rcvd">パケット受信</string>
    <string name="dns_queries">DNS クエリ</string>
    <string name="search_apps">アプリを検索</string>
    <string name="no_apps">アプリはありません</string>
    <string name="dns_server">DNS サーバー</string>
    <string name="apps">アプリ</string>
    <string name="pcap_file">PCAP ファイル</string>
    <string name="pcap_file_info">デバイスのストレージに PCAP ファイルを作成します</string>
    <string name="cannot_write_file">ファイルに書き込むことができません</string>
    <string name="share">共有</string>
    <string name="delete">削除</string>
    <string name="ok">OK</string>
    <string name="pcap_file_action">トラフィックをファイルに保存しました %1$s (%2$s)</string>
    <string name="delete_error">ファイルを削除できませんでした</string>
    <string name="capture_running">キャプチャは実行されています</string>
    <string name="notification_msg">%1$s キャプチャ済み、%2$s 接続</string>
    <string name="proto_and_port">%1$s、%2$d</string>
    <string name="first_seen">最初の確認</string>
    <string name="last_seen">最新の確認</string>
    <string name="conn_status_closed">クローズド</string>
    <string name="copy_to_clipboard">クリップボードにコピー</string>
    <string name="save_to_file">ファイルに保存</string>
    <string name="older_connections_notice">%1$d より古い接続は表示されません</string>
    <string name="about_text">PCAPdroid はルート権限なしで動作するオープン ソースのネットワーク キャプチャ、モニタリング ツールです</string>
    <string name="get_app">入手:</string>
    <string name="unknown_app">不明</string>
    <string name="error">エラー</string>
    <string name="conn_status_unreachable">到達不能</string>
    <string name="other_prefs">その他</string>
    <string name="app_language">アプリの言語</string>
    <string name="system_default">システム標準</string>
    <string name="no_activity_file_selection">ファイル選択を処理するアプリが見つかりません</string>
    <string name="file_saved_with_name">「%1$s」としてファイルを保存しました</string>
    <string name="socks5_proxy">SOCKS5 プロキシを有効にする</string>
    <string name="enable_socks5_proxy_summary">すべての TCP 接続を指定した SOCKS5 プロキシにリダイレクトします</string>
    <string name="proxy_port">プロキシ ポート</string>
    <string name="root_capture">ルートとしてキャプチャ</string>
    <string name="root_capture_summary">PCAPdroid とほかの VPN アプリとの併用を許可します</string>
    <string name="donate">寄付</string>
    <string name="search">検索…</string>
    <string name="app_val">アプリ: %1$s</string>
    <string name="ip_address_val">IP アドレス: %1$s</string>
    <string name="host_val">ホスト: %1$s</string>
    <string name="protocol_val">プロトコル: %1$s</string>
    <string name="hide">隠す…</string>
    <string name="n_selected">%1$d 選択済み</string>
    <string name="select_all">すべて選択</string>
    <string name="app_details">アプリの詳細</string>
    <string name="package_name">パッケージ名</string>
    <string name="uid">UID</string>
    <string name="app_name">名前</string>
    <string name="version">バージョン</string>
    <string name="target_sdk">ターゲット SDK</string>
    <string name="installed_on">インストール日時</string>
    <string name="last_update">最終更新日</string>
    <string name="permissions">権限</string>
    <string name="root_app_info">システム デーモンは最大の権限で動作しています</string>
    <string name="netd_app_info">DNS 解決をするシステム デーモン</string>
    <string name="android_app_info">Android システム</string>
    <string name="unknown_app_info">どのアプリの接続かわからない場合に「不明」と表示されます</string>
    <string name="packets_dropped">ドロップ済みパケット</string>
    <string name="capture_prefs">キャプチャ</string>
    <string name="pending_transaction">決済を完了させて機能を回復させてください</string>
    <string name="ctrl_consent">アプリはデバイスのトラフィックをキャプチャしようとしています。よくわからない場合は拒否してください</string>
    <string name="deny">拒否</string>
    <string name="allow">許可</string>
    <string name="ctrl_consent_title">PCAPdroid コントロール要求</string>
    <string name="ctrl_consent_denied">PCAPdroid: コントロール要求は拒否されました</string>
    <string name="ctrl_consent_allowed">PCAPdroid: コントロール要求は許可されました</string>
    <string name="capture_interface">キャプチャ インターフェイス</string>
    <string name="internet">インターネット</string>
    <string name="all_interfaces">すべてのインターフェイス</string>
    <string name="capturing_from">「%1$s」からパケットをキャプチャしています</string>
    <string name="edit_filter">フィルターを編集</string>
    <string name="edit_list">リストを編集</string>
    <string name="hidden_connections_rules">隠された接続ルール</string>
    <string name="list_is_empty">リストは空です</string>
    <string name="show_only_malicious">悪意ある接続</string>
    <string name="security">セキュリティ</string>
    <string name="malware_detection">マルウェアの検出</string>
    <string name="malware_detection_summary">第三者のブラックリストを使って悪意ある既知のホストへの接続を検出します</string>
    <string name="reset">リセット</string>
    <string name="malware_whitelist_rules">マルウェア ホワイトリスト ルール</string>
    <string name="feature_not_available">このデバイスでこの機能は現在利用できません</string>
    <string name="billing_connecting">Google Play に接続しています。しばらくしてから再試行してください</string>
    <string name="malware_whitelist_help">ユーザー定義のホワイトリストによってマルウェアの検出を回避することができます。悪意ある接続を長押ししてマルウェアから除外するルールを作ることができます</string>
    <string name="malicious_connection_filter">悪意</string>
    <string name="status_filter">状態: %1$s</string>
    <string name="not_hidden_filter">隠されていません</string>
    <string name="copy_action">コピー…</string>
    <string name="url_val">URL: %1$s</string>
    <string name="show_me">表示</string>
    <string name="hint">ヒント</string>
    <string name="once">1 度のみ</string>
    <string name="forever">表示しない</string>
    <string name="control_permissions">権限を管理</string>
    <string name="control_permissions_summary">PCAPdroid キャプチャー制御を許可するアプリを確認します</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">国</string>
    <string name="asn">AS 番号</string>
    <string name="country_val">国: %1$s</string>
    <string name="send_report">レポートを送信</string>
    <string name="start_at_boot">ブート時に開始</string>
    <string name="start_at_boot_summary">ブート後に自動的にキャプチャを開始します</string>
    <string name="malware_status_ok">悪意あるトラフィックは検出されませんでした</string>
    <string name="malware_status_detected">悪意ある接続が検出されました</string>
    <string name="whitelist">ホワイトリスト</string>
    <string name="blacklists">ブラックリスト</string>
    <string name="status_outdated">古い状態</string>
    <string name="status_not_loaded">未読み込み</string>
    <string name="status_uptodate">最新</string>
    <string name="blacklist_type">種類: %1$s</string>
    <string name="blacklist_type_ip">IP ブラックリスト</string>
    <string name="blacklist_type_domain">ドメイン ブラックリスト</string>
    <string name="n_rules">%1$s ルール</string>
    <string name="last_update_val">最終更新: %1$s</string>
    <string name="malicious_connections">悪意ある接続</string>
    <string name="updated_blacklists">ブラックリストが更新されました</string>
    <string name="connections_checked">チェック済みの接続</string>
    <string name="last_blacklists_update">最終更新</string>
    <string name="domain_rules">ドメイン ルール</string>
    <string name="ip_rules">IP ルール</string>
    <string name="malware_status_update_failed">いくつかのブラックリストが最新ではありません</string>
    <string name="update_now">いますく更新</string>
    <string name="status_updating">アップデートしています…</string>
    <string name="malware_detection_learn_more">マルウェア検出機能の詳細</string>
    <string name="private_dns_message_notice">プライベート DNS は PCAPdroid が DNS トラフィックを検出するのを妨害します。Android のネットワーク設定からオフにすることができます</string>
    <string name="private_dns_hinders_detection">プライベート DNS は検出を妨害します</string>
    <string name="block">ブロック…</string>
    <string name="firewall">ファイアウォール</string>
    <string name="firewall_rules">ファイアウォール ルール</string>
    <string name="blocked_pkts">ブロック済み</string>
    <string name="n_pkts">%1$s パケット</string>
    <string name="blocked_connection_filter">ブロック済み</string>
    <string name="paid_features">有料機能</string>
    <string name="validate">検証</string>
    <string name="valid">有効</string>
    <string name="invalid">無効</string>
    <string name="no_intent_handler_found">このアクションを実行するアプリが見つかりません</string>
    <string name="network_interface">インターフェイス</string>
    <string name="interface_filter">インターフェイス: %1$s</string>
    <string name="loading">読み込んでいます…</string>
    <string name="purchased">購入済み</string>
    <string name="no_items_for_purchase">購入できるアイテムはありません</string>
    <string name="billing_failure">Google Play に接続できませんでした。しばらくしてから再試行してください</string>
    <string name="learn_more">詳細</string>
    <string name="buy_action">購入</string>
    <string name="capture_not_running_status">キャプチャは実行されていません</string>
    <string name="start_capture_first">最初にキャプチャを開始してください</string>
    <string name="copied">コピーしました</string>
    <string name="can_use_purchased_feature">有料の機能が利用できるようになりました</string>
    <string name="disconnect_vpn_confirm">アクティブな VPN を切断して続行しますか?</string>
    <string name="loading_apps">アプリを読み込んでいます…</string>
    <string name="open_nav_drawer">ドロワーを開く</string>
    <string name="close_nav_drawer">ドロワーを閉じる</string>
    <string name="capture_all_apps">すべてのアプリのトラフィックをキャプチャ</string>
    <string name="save_ok">保存しました</string>
</resources>

```

`app/src/main/res/values-ko/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hide">숨김…</string>
    <string name="n_selected">%1$d 선택됨</string>
    <string name="select_all">모두 선택</string>
    <string name="app_details">앱 상세정보</string>
    <string name="package_name">패키지명</string>
    <string name="uid">UID</string>
    <string name="app_name">이름</string>
    <string name="version">버전</string>
    <string name="target_sdk">타겟 SDK</string>
    <string name="last_update">마지막 업데이트</string>
    <string name="permissions">권한</string>
    <string name="installed_on">설치된 날짜</string>
    <string name="asn">ASN</string>
    <string name="rcvd_and_sent">%1$s 받음 — %2$s 보냄</string>
    <string name="host">호스트</string>
    <string name="ready">준비</string>
    <string name="status">상태</string>
    <string name="no_connections">커넥션 없음</string>
    <string name="connection_details">커넥션 자세히</string>
    <string name="packets">패킷</string>
    <string name="udp_exporter">UDP 추출기</string>
    <string name="no_dump">덤프 없음</string>
    <string name="app">앱</string>
    <string name="http_server_port">HTTP 서버 포트</string>
    <string name="source_code">소스코드</string>
    <string name="source">출발지</string>
    <string name="no_dump_info">트래픽이 덤프되지 않음</string>
    <string name="udp_exporter_info">PCAP을 원격 UDP 리시버로 보냅니다</string>
    <string name="http_server_info">PCAP을 다운로드 하기위한 HTTP 서버를 시작합니다</string>
    <string name="traffic_dump">트래픽 덤프</string>
    <string name="receiver_ip_address">콜렉터 IP 주소</string>
    <string name="user_guide">사용자 가이드</string>
    <string name="open_telegram_group">텔레그램 그룹</string>
    <string name="app_not_found">앱 %1$s을 찾을 수 없습니다</string>
    <string name="yes">네</string>
    <string name="no">아니요</string>
    <string name="vpn_setup_failed">VPN을 설정할 수 없습니다</string>
    <string name="active_connections">활성화된 커넥션</string>
    <string name="receiver_port">콜렉터 포트</string>
    <string name="dropped_connections">버려진 커넥션</string>
    <string name="tot_connections">전체 커넥션</string>
    <string name="bytes_sent">보낸 바이트</string>
    <string name="bytes_rcvd">받은 바이트</string>
    <string name="dns_queries">DNS 쿼리</string>
    <string name="search_apps">앱 검색</string>
    <string name="cannot_write_file">파일을 쓸 수 없습니다</string>
    <string name="delete">삭제</string>
    <string name="no_apps">앱 없음</string>
    <string name="share">공유</string>
    <string name="collector_info">UDP 컬렉터: %1$s:%2$d</string>
    <string name="conn_status_active">활성화</string>
    <string name="open_sockets">소켓 열기</string>
    <string name="packets_sent">보낸 패킷</string>
    <string name="packets_rcvd">받은 패킷</string>
    <string name="dns_server">DNS 서버</string>
    <string name="apps">앱</string>
    <string name="pcap_file_info">기기의 저장공간에 PCAP 파일을 생성합니다</string>
    <string name="pcap_file">PCAP 파일</string>
    <string name="ok">확인</string>
    <string name="capture_running">캡처 하는중</string>
    <string name="copy_to_clipboard">복사</string>
    <string name="pcap_file_action">트래픽이 %1$s에 저장되었습니다(%2$s)</string>
    <string name="delete_error">파일을 삭제할 수 없습니다</string>
    <string name="notification_msg">%1$s 캡처됨, %2$s 커넥션</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">커넥션 시작</string>
    <string name="last_seen">커넥션 종료</string>
    <string name="conn_status_closed">닫힘</string>
    <string name="save_to_file">파일로 저장</string>
    <string name="other_prefs">나머지</string>
    <string name="about_text">PCAPdroid는 루트 권한 없이 작동하는 오픈소스 네트워크 캡처 및 모니터링 도구입니다</string>
    <string name="unknown_app">알수없음</string>
    <string name="error">에러</string>
    <string name="conn_status_unreachable">도달할 수 없음</string>
    <string name="app_language">앱 언어</string>
    <string name="no_activity_file_selection">선택한 파일을 처리할 수 있는 앱을 찾을 수 없습니다</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="system_default">시스템</string>
    <string name="file_saved_with_name">파일이 \"%1$s\"로 저장되었습니다</string>
    <string name="enable_socks5_proxy_summary">모든 TCP 커넥션을 지정된 SOCKS5 프록시로 리다이렉트합니다</string>
    <string name="root_capture">루트로 캡처하기</string>
    <string name="socks5_info">SOCKS5 프록시: %1$s:%2$d</string>
    <string name="search">검색…</string>
    <string name="packets_dropped">버려진 패킷</string>
    <string name="proxy_port">프록시 포트</string>
    <string name="donate">후원</string>
    <string name="root_capture_summary">PCAPdroid가 다른 VPN 앱과 같이 동작하도록 허용하기</string>
    <string name="host_val">호스트: %1$s</string>
    <string name="app_val">앱: %1$s</string>
    <string name="ip_address_val">IP 주소: %1$s</string>
    <string name="protocol_val">프로토콜: %1$s</string>
    <string name="root_app_info">최대 권한으로 동작 중인 시스템 데몬</string>
    <string name="android_app_info">안드로이드 시스템</string>
    <string name="netd_app_info">DNS 이름 확인을 수행 중인 시스템 데몬</string>
    <string name="phone_app_info">텔레포니 서비스</string>
    <string name="capture_prefs">캡처</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="ip_rules">IP 규칙</string>
    <string name="show_only_malicious">악성 커넥션</string>
    <string name="malicious_connection_filter">악성 연결</string>
    <string name="once">한번만</string>
    <string name="n_rules">%1$s 규칙</string>
    <string name="pending_transaction">이 기능을 사용하려면 거래를 완료하세요</string>
    <string name="ctrl_consent">앱인 기기의 트래픽을 캡처하려합니다.
\n확실하지 않으면 거절하세요</string>
    <string name="allow">허용</string>
    <string name="ctrl_consent_title">PCAPdroid 컨트롤 요청</string>
    <string name="internet">인터넷</string>
    <string name="all_interfaces">모든 인터페이스</string>
    <string name="capturing_from">\"%1$s\"에서 패킷을 캡처합니다</string>
    <string name="edit_filter">필터 수정</string>
    <string name="edit_list">리스트 수정</string>
    <string name="deny">거절</string>
    <string name="hidden_connections_rules">커넥션 숨김 규칙</string>
    <string name="show_only_cleartext">Cleartext 커넥션</string>
    <string name="security">보안</string>
    <string name="ctrl_consent_denied">PCAPdroid: 컨트롤 요청이 거부되었습니다</string>
    <string name="ctrl_consent_allowed">PCAPdroid: 컨트롤 요청이 허용되었습니다</string>
    <string name="capture_interface">캡처할 인터페이스</string>
    <string name="list_is_empty">이 리스트는 비어있습니다</string>
    <string name="billing_connecting">Google Play로의 커넥션이 진행중이니, 잠시후 다시 시도해주세요</string>
    <string name="malware_detection">멀웨어 감지</string>
    <string name="reset">초기화</string>
    <string name="feature_not_available">이 기능은 현재 당신의 기기에서 사용할 수 없습니다</string>
    <string name="malware_detection_summary">써드파티 블랙리스트를 통해 알려진 악성 호스트로의 커넥션을 감지합니다</string>
    <string name="malware_whitelist_rules">멀웨어 화이트리스트 규칙</string>
    <string name="malware_whitelist_help">멀웨어 탐지를 제외하는 사용자 지정 화이트리스트입니다. 악성 연결을 길게 눌러 악성 연결로 표시하는 것을 해제하는 규칙을 만듭니다</string>
    <string name="start_at_boot_summary">부팅후 자동으로 캡처를 시작합니다</string>
    <string name="status_filter">상태: %1$s</string>
    <string name="not_hidden_filter">숨기지 않음</string>
    <string name="show_me">표시하기</string>
    <string name="copy_action">복사…</string>
    <string name="hint">힌트</string>
    <string name="forever">계속</string>
    <string name="url_val">URL: %1$s</string>
    <string name="control_permissions">컨트롤 퍼미션</string>
    <string name="country_val">국가: %1$s</string>
    <string name="whitelist">화이트리스트</string>
    <string name="blacklist_type_ip">IP 블랙리스트</string>
    <string name="updated_blacklists">업데이트된 블랙리스트</string>
    <string name="status_updating">업데이트 중…</string>
    <string name="firewall_rules">방화벽 규칙</string>
    <string name="country">국가</string>
    <string name="send_report">보고서 전송</string>
    <string name="start_at_boot">부팅시 시작하기</string>
    <string name="blacklists">블랙리스트</string>
    <string name="blacklist_type_domain">도메인 블랙리스트</string>
    <string name="connections_checked">커넥션 확인됨</string>
    <string name="malware_status_ok">감지된 악성 트래픽 없음</string>
    <string name="malware_status_detected">악성 커넥션 탐지됨</string>
    <string name="last_update_val">마지막 업데이트: %1$s</string>
    <string name="status_not_loaded">로드되지 않음</string>
    <string name="blacklist_type">유형: %1$s</string>
    <string name="malicious_connections">악성 커넥션</string>
    <string name="last_blacklists_update">마지막 업데이트</string>
    <string name="domain_rules">도메인 규칙</string>
    <string name="update_now">지금 업데이트</string>
    <string name="malware_detection_learn_more">멀웨어 탐지 기능에 대하여 더 자세히 알아보기</string>
    <string name="n_pkts">%1$s 패킷</string>
    <string name="paid_features">유료 기능</string>
    <string name="firewall">방화벽</string>
    <string name="firewall_filter">방화벽: %1$s</string>
    <string name="destination">도착지</string>
    <string name="stop_button">중지</string>
    <string name="start_button">시작</string>
    <string name="query">쿼리</string>
    <string name="title_activity_settings">설정</string>
    <string name="protocol">프로토콜</string>
    <string name="http_server">HTTP 서버</string>
    <string name="http_server_status">HTTP 서버: http://%1$s:%2$d</string>
    <string name="connections_view">커넥션</string>
</resources>

```

`app/src/main/res/values-nb-rNO/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="status_outdated">Utdatert</string>
    <string name="status_uptodate">Oppdatert</string>
    <string name="blacklist_type_ip">IP-svarteliste</string>
    <string name="blacklist_type">Type: %1$s</string>
    <string name="n_rules">%1$s regler</string>
    <string name="firewall">Brannmur</string>
    <string name="last_update_val">Siste oppdatering: %1$s</string>
    <string name="firewall_rules">Brannmursregler</string>
    <string name="blocked_pkts">Blokkert</string>
    <string name="not_hidden_filter">Ikke skjult</string>
    <string name="copy_action">Kopier …</string>
    <string name="yes">Ja</string>
    <string name="http_server">HTTP-tjener</string>
    <string name="source_code">Kildekode</string>
    <string name="start_button">Start</string>
    <string name="stop_button">Stopp</string>
    <string name="title_activity_settings">Innstillinger</string>
    <string name="query">Spørring</string>
    <string name="host">Vert</string>
    <string name="ready">Klar</string>
    <string name="about">Om</string>
    <string name="status">Status</string>
    <string name="connections_view">Tilkoblinger</string>
    <string name="connection_details">Tilkoblingsdetaljer</string>
    <string name="rcvd_and_sent">%1$s mottatt — %2$s sendt</string>
    <string name="app">Program</string>
    <string name="protocol">Protokoll</string>
    <string name="source">Kilde</string>
    <string name="destination">Mål</string>
    <string name="packets">Pakker</string>
    <string name="no_dump">Ingen</string>
    <string name="udp_exporter">UDP-eksportør</string>
    <string name="http_server_port">HTTP-tjenerport</string>
    <string name="user_guide">Brukerveiledning</string>
    <string name="open_telegram_group">Telegram-gruppe</string>
    <string name="no">Nei</string>
    <string name="vpn_setup_failed">Klarte ikke å sette opp VPN</string>
    <string name="stats">Statistikk</string>
    <string name="active_connections">Aktive tilkoblinger</string>
    <string name="bytes_sent">Byte sendt</string>
    <string name="packets_sent">Pakker sendt</string>
    <string name="packets_rcvd">Pakker mottatt</string>
    <string name="dns_queries">DNS-spørringer</string>
    <string name="dns_server">DNS-tjener</string>
    <string name="apps">Programmer</string>
    <string name="pcap_file">PCAP-fil</string>
    <string name="cannot_write_file">Kan ikke skrive til fil</string>
    <string name="share">Del</string>
    <string name="delete">Slett</string>
    <string name="ok">OK</string>
    <string name="delete_error">Kunne ikke slette filen</string>
    <string name="first_seen">Først sett</string>
    <string name="last_seen">Sist sett</string>
    <string name="conn_status_closed">Lukket</string>
    <string name="copy_to_clipboard">Kopier til utklippstavle</string>
    <string name="save_to_file">Lagre som fil</string>
    <string name="unknown_app">Ukjent</string>
    <string name="error">Feil</string>
    <string name="older_connections_notice">%1$d eldre tilkoblinger vises ikke</string>
    <string name="about_text">PCAPdroid er et fritt verktøy for nettverksovervåkning og lagring, som fungerer uten rot-tilgang</string>
    <string name="get_app">Hent det:</string>
    <string name="conn_status_unreachable">Kan ikke nåes</string>
    <string name="donate">Doner</string>
    <string name="search">Søk …</string>
    <string name="ip_address_val">IP-adresse: %1$s</string>
    <string name="host_val">Vert: %1$s</string>
    <string name="protocol_val">Protokoll: %1$s</string>
    <string name="hide">Skjul …</string>
    <string name="n_selected">%1$d valgt</string>
    <string name="select_all">Velg alle</string>
    <string name="app_details">Programdetaljer</string>
    <string name="package_name">Pakkenavn</string>
    <string name="uid">UID</string>
    <string name="app_name">Navn</string>
    <string name="version">Versjon</string>
    <string name="permissions">Tilganger</string>
    <string name="android_app_info">Android-systemet</string>
    <string name="proxy_port">Mellomtjenerport</string>
    <string name="app_val">Program: %1$s</string>
    <string name="target_sdk">Mål-SDK</string>
    <string name="reset">Tilbakestill</string>
    <string name="feature_not_available">Funksjonen er utilgjengelig for enheten din</string>
    <string name="malicious_connection_filter">Skadelig</string>
    <string name="status_filter">Status: %1$s</string>
    <string name="url_val">Nettadresse: %1$s</string>
    <string name="show_me">Vis meg</string>
    <string name="hint">Hint</string>
    <string name="once">Én gang</string>
    <string name="forever">Alltid</string>
    <string name="country_val">Land: %1$s</string>
    <string name="send_report">Send rapport</string>
    <string name="start_at_boot">Start sammen med enheten</string>
    <string name="whitelist">Hvitliste</string>
    <string name="blacklist_type_domain">Domene-svarteliste</string>
    <string name="domain_rules">Domeneregler</string>
    <string name="ip_rules">IP-regler</string>
    <string name="block">Blokker …</string>
    <string name="paid_features">Betalte funksjoner</string>
    <string name="duration">Varighet</string>
    <string name="validate">Bekreft</string>
    <string name="invalid">Ugyldig</string>
    <string name="network_interface">Grensesnitt</string>
    <string name="interface_filter">Grensesnitt: %1$s</string>
    <string name="loading">Laster inn …</string>
    <string name="learn_more">Lær mer</string>
    <string name="buy_action">Kjøp</string>
    <string name="no_connections">Ingen tilkoblinger</string>
    <string name="http_server_info">Start en HTTP-tjener for PCAP-nedlasting</string>
    <string name="bytes_rcvd">Byte mottatt</string>
    <string name="open_sockets">Åpne socket-er</string>
    <string name="app_language">Programspråk</string>
    <string name="search_apps">Søk i programmer</string>
    <string name="no_apps">Ingen programmer</string>
    <string name="deny">Nekt</string>
    <string name="country">Land</string>
    <string name="other_prefs">Annet</string>
    <string name="system_default">System</string>
    <string name="socks5_proxy">Skru på SOCKS5-mellomtjener</string>
    <string name="blacklists">Svartelister</string>
    <string name="status_not_loaded">Ikke innlastet</string>
    <string name="allow">Tillat</string>
    <string name="blocked_connection_filter">blokkert</string>
    <string name="http_server_status">HTTP-tjener: http://%1$s:%2$d</string>
    <string name="app_not_found">Fant ikke programmet «%1$s»</string>
    <string name="no_activity_file_selection">Fant ikke noe program til å håndtere valg av filer</string>
    <string name="file_saved_with_name">Filen «%1$s» ble lagret</string>
    <string name="ctrl_consent_denied">PCAPdroid: Kontrollforespørsel ble avslått</string>
    <string name="all_interfaces">Alle grensesnitt</string>
    <string name="edit_filter">Rediger filter</string>
    <string name="edit_list">Rediger liste</string>
    <string name="hidden_connections_rules">Skjul tilkolbingsregler</string>
    <string name="list_is_empty">Listen er tom</string>
    <string name="ctrl_consent_allowed">PCAPdroid: Kontrollforespørsel ble innvilget</string>
    <string name="security">Sikkerhet</string>
    <string name="show_only_malicious">Ondsinnede tilkoblinger</string>
    <string name="control_permissions">Kontrolltilganger</string>
    <string name="control_permissions_summary">Sjekk hvilke programmer som tillates å kontrollere PCAPdroid-fangst</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="asn">ASN</string>
    <string name="malware_status_ok">Ingen ondsinnet trafikk oppdaget</string>
    <string name="malware_status_detected">Ondsinnet trafikk oppdaget</string>
    <string name="status_updating">Oppdaterer …</string>
    <string name="malware_detection_learn_more">Lær mer om skadevareoppdagelsesfunksjonen</string>
    <string name="private_dns_message_notice">Privat DNS forhindrer PCAPdroid fra å inspisere DNS-trafikk. Du kan skru det av fra Android-nettverksinnstillingene.</string>
    <string name="n_pkts">%1$s pakker</string>
    <string name="private_dns_hinders_detection">Privat DNS forhindrer oppdagelse</string>
    <string name="decryption_no_filter_warn">Velg et målprogram når du dekrypterer TLS for å unngå å miste tilkoblingen din til Internett</string>
    <string name="billing_failure">Kunne ikke koble til Google Play. Prøv igjen om en stund</string>
    <string name="start_capture_first">Start fangst først</string>
    <string name="close_nav_drawer">Lukk skuff</string>
    <string name="save_ok">Lagret</string>
    <string name="copied">Kopiert</string>
    <string name="can_use_purchased_feature">Du kan nå bruke den betalte funksjonen</string>
    <string name="disconnect_vpn_confirm">Koble fra aktivt VPN-program og fortsett\?</string>
    <string name="loading_apps">Laster inn programmer …</string>
    <string name="open_nav_drawer">Åpne skuff</string>
    <string name="capture_all_apps">Fang trafikk for alle programmene</string>
    <string name="collector_info">UDP-innsamler: %1$s:%2$d</string>
    <string name="receiver_ip_address">Innsamler-IP-adresse</string>
    <string name="receiver_port">Innsamler-port</string>
    <string name="udp_exporter_info">Sender PCAP til en UDP-mottager annensteds hen</string>
    <string name="dropped_connections">Droppede tilkoblinger</string>
    <string name="pcap_file_info">Opprett en PCAP-fil i enhetslagring</string>
    <string name="tot_connections">Alle tilkoblinger</string>
    <string name="capture_running">Fangst kjører</string>
    <string name="packets_dropped">Pakker som ikke kom fram</string>
    <string name="installed_on">Installert</string>
    <string name="capture_prefs">Trafikkfangst</string>
    <string name="root_capture_summary">Lar PCAPdroid kjøre med andre VPN-programmer</string>
    <string name="netd_app_info">Systemnissen som utfører DNS-oppslag</string>
    <string name="enable_socks5_proxy_summary">Videresend alle TCP-tilkoblinger til angitt SOCKS5-mellomtjener</string>
    <string name="unknown_app_info">«Ukjent» tilkjennegir tilkoblinger hvis program ikke kunne fastsettes.</string>
    <string name="root_capture">Fangst med rot-tilgang</string>
    <string name="ctrl_consent">Et program vil fane din enhetstrafikk.
\nNekt det hvis du ikke er sikker</string>
    <string name="malware_whitelist_rules">Skadevare-hvitlisteregler</string>
    <string name="malware_detection_summary">Oppdag tilkoblinger til kjente ondsinnede verter via tredjeparts-svartelister</string>
    <string name="billing_connecting">Kobler til Google Play …Prøv igjen om en stund.</string>
    <string name="hidden_connections_help">Lister over regler for skjuling av tilkoblingslisteoppføringer, slik at du kan fokusere på de som er relevante</string>
    <string name="updated_blacklists">Oppdaterte svartelister</string>
    <string name="last_blacklists_update">Siste oppdatering</string>
    <string name="purchased">Kjøpt</string>
    <string name="no_items_for_purchase">Ingenting for salg</string>
    <string name="no_intent_handler_found">Fant ikke noe program til å utføre handlingen</string>
    <string name="valid">Gyldig</string>
    <string name="pcap_file_action">Trafikk lagret til «%1$s»-filen (%2$s)</string>
    <string name="internet">Internett</string>
    <string name="malware_status_update_failed">Noen svartelister er utdatert</string>
    <string name="update_now">Oppdater nå</string>
    <string name="malware_detection">Skadevare-oppdagelse</string>
    <string name="connections_checked">Tilkoblinger sjekket</string>
    <string name="root_app_info">Systemnisser kjører med alle privilegier</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="last_update">Siste oppdatering</string>
    <string name="malicious_connections">Skadelige tilkoblinger</string>
    <string name="notification_msg">%1$s fanget, %2$s tilkoblinger</string>
    <string name="capture_not_running_status">Fangst kjører ikke</string>
    <string name="pending_transaction">Fullfør kjøpet for å bruke denne funksjonen</string>
    <string name="ctrl_consent_title">PCAPdroid-kontrollforespørsel</string>
    <string name="capturing_from">Fanger pakker fra «%1$s»</string>
    <string name="capture_interface">Fangstgrensesnitt</string>
    <string name="no_dump_info">PCAP vil ikke bli registrert</string>
    <string name="malware_whitelist_help">Brukerdefinert hvitliste for å unngå skadevareoppdatelse. Lang-trykk på ondsinnede tilkoblinger for å opprette regler som avmarkerer dem som skadevare</string>
    <string name="start_at_boot_summary">Starter fangst sammen med enheten</string>
    <string name="app_intro_back_button">Tilbake</string>
    <string name="firewall_filter">Brannmur: %1$s</string>
    <string name="connection_not_found">Fant ikke angitt tilkobling</string>
    <string name="allowed_connection_filter">Tillatt</string>
    <string name="connection_blocked">Denne tilkoblingen har blitt blokkert av PCAPdroid</string>
    <string name="low_memory">Lite minne igjen</string>
    <string name="full_payload_disabled">Alternativet for full nyttelast har blitt avskrudd</string>
    <string name="block_private_dns_summary">Oppdag og potensielt blokker privat DNS for å inspisere DNS-trafikk. Å skru av dette kan forhindre trafikk-analyse.</string>
    <string name="app_intro_firewall_msg">Med den integrerte <a href="%1$s">brannmuren</a> kan du blokkere tilgang til Internett for individuelle programmer og domener. \n \nKombiner dette med den innebygde trafikk-synligheten for å få det ultimate verktøyet for å beskytte ditt personvern.</string>
    <string name="heap_usage">Haugbruk</string>
    <string name="app_intro_done_button">Ferdig</string>
    <string name="download">Last ned</string>
    <string name="capture_stopped_low_memory">Fangst stoppet</string>
    <string name="permission_granted">%1$s-tilgang ble innvilget</string>
    <string name="memory_usage">Minnebruk</string>
    <string name="permission_grant_fail">%1$s-tilgang kunne ikke innvilges</string>
    <string name="vpn_lockdown_notice">For å forhindre programmer fra å bruke Internett når PCAPdroid ikke kjører (f.eks. etter en omstart) kan du sette PCAPdroid til VPN i nedlåst modus som alltid er påslått.
\n
\nÅpne VPN-innstillingene nå\?</string>
    <string name="low_memory_info">Programmet er i ferd med å slippe opp for minne. Forvent krasj.</string>
    <string name="app_intro_geolocation_msg">PCAPdroid kan utføre spørring av en lokal database for å fastsette landsopprinnelse for en fjerntjener.
\n
\nDu må laste ned geoposisjoneringsdatabasen først fra programinnstillingene.</string>
    <string name="install_ca_certificate">Installer sertifikatmyndighetssertifikatet tilhørende PCAPdroid ved å velge «VPN og programmer». Android vil spørre deg om din låseskjerm og passord.</string>
    <string name="ca_cert_export_failed">En feil oppstod under eksport av sertifikatmyndighetssertifikatet.
\n
\nHvis enheten din implementerer automatisk start eller lignende programvare for å forhindre kjøring av bakgrunnstjenester må du <a href="%1$s">hvitliste PCAPdroid</a></string>
    <string name="payload_truncated">Nyttelasten er forkortet. Skru på «%1$s» for å vise den i sin helhet.</string>
    <string name="firewall_summary">Blokker Internett-tilgang for programmer, sett opp roller for spesifikke domener og IP-adresser. Fungerer kun med fangst uten rot-tilgang.</string>
    <string name="mitm_setup_wizard_intro">Denne veiledningen tar deg gjennom installasjon av sertifikatmyndighets-sertifikat og MITM-tillegget for PCAPdroid, som trengs for å utføre <a href="%1$s">TLS-dekryptering</a>.</string>
    <string name="mitm_setup_wizard_done">PCAPdroid er nå klar til å dekryptere TLS-trafikk.
\n
\nSjekk ut <a href="%1$s">brukerveiledningen</a> for å finne ut mer om sikkerhetsfunksjoner som kan forhindre dekryptering og hvordan du omgår dem.</string>
    <string name="app_intro_welcome_msg">PCAPdroid er et personvernsvennlig program som lar deg spore og analysere tilkoblinger gjort av programmer på enheten din.
\n
\nDet lar deg også eksporter en PCAP-dump av trafikken, pakke ut matadata, med mer.</string>
    <string name="app_intro_privacy_msg">Programmet utfører ingen sporing, analyse, og ringer heller ikke hjem.
\n
\nDu kan forsikre deg om dette i <a href="%1$s">personvernspraksisen</a> og <a href="%2$s">kildekoden</a>.</string>
    <string name="app_intro_traffic_inspection">Inspeksjon av HTTP-forespørsler, svar, og rådata er enkelt, takket være de innebygde dekoderne.
\n
\nFikk du en kryptert tilkobling\? Du kan skru på <a href="%1$s">TLS-dekryptering</a> for å hente den dekrypterte dataen.</string>
    <string name="app_intro_malware_detection">Forbedre sikkerheten din på enheten din med funksjonen for <a href="%1$s">skadevareoppdagelse</a>.
\n
\nVe då bruke oppdaterte svartelister kan det oppdage, blokkere, og varsle om skadelige tilkoblinger i sanntid.</string>
    <string name="traffic_dump">Trafikk-dump</string>
    <string name="conn_status_active">Aktiv</string>
    <string name="phone_app">Telefonprogram</string>
    <string name="socks5_info">SOCKS5-mellomtjener: %1$s:%2$d</string>
    <string name="phone_app_info">Telefonitjenester</string>
    <string name="unblock">Avblokker …</string>
    <string name="traffic_inspection">Trafikk-inspeksjon</string>
    <string name="mitm_start_failed">Kunne ikke starte MITM-tjenesten. Reinstaller MITM-tillegget og prøv igjen.</string>
    <string name="install_action">Installer</string>
    <string name="mitm_setup_wizard">Oppsettsveileder for MITM</string>
    <string name="overview">Oversikt</string>
    <string name="string_http_request">HTTP-forespørsel</string>
    <string name="string_http_response">HTTP-svar</string>
    <string name="websocket">WebSocket</string>
    <string name="full_payload">Full nyttelast</string>
    <string name="full_payload_summary">Vis nyttelasten for tilkoblinger i sin helhet (altså hele HTTP-forespørselen og svaret). Dette krever mye minne, så ikke bruk det på sikt.</string>
    <string name="decrypted">Dekryptert</string>
    <string name="decryption">Dekryptering</string>
    <string name="decryption_filter">Dekryptering: %1$s</string>
    <string name="network_traffic">Trafikk</string>
    <string name="connection_start_not_seen">PCAPdroid har ikke sett starten på denne tilkoblingen. Noe av infoen kan mangle.</string>
    <string name="waiting_application_data">Venter på data …</string>
    <string name="downloading">Laster ned …</string>
    <string name="download_in_progress">Laster ned …</string>
    <string name="download_failed">Nedlasting mislyktes</string>
    <string name="geo_db_not_found">Fant ikke databasen. Geoposisjonering er avskrudd.</string>
    <string name="built_on">Bygd %1$s</string>
    <string name="database">Database</string>
    <string name="size_x">Størrelse: %1$s</string>
    <string name="import_action">Importer</string>
    <string name="discard_action">Forkast</string>
    <string name="rules_delete_confirm">Slett valgte regler\?</string>
    <string name="firewall_is_disabled">Brannmur av</string>
    <string name="action_unblock">Avblokker</string>
    <string name="export_action">Eksporter</string>
    <string name="tls_decryption">TLS-dekryptering</string>
    <string name="tls_decryption_summary">Dekrypter SSL/TLS-trafikk ved å utføre MITM. Dette kan fungere med noen programmer nå. Sjekk brukerveiledningen.</string>
    <string name="export_ca_certificate">Eksporter sertifikatmyndighetssertifikatet tilhørende PCAPdroid, åpne så «Kryptering og identitetsdetaljer» i Android og veld å installere det som et «CA-sertifikat».</string>
    <string name="checking_the_certificate">Sjekker sertifikatet …</string>
    <string name="cert_exported_now_installed">Sertifikat eksporter. Installer det nå fra Android-innstillingene.</string>
    <string name="cert_installed_correctly">Sertifikatmyndighetssertifikatet er installert</string>
    <string name="cert_reinstall_required">Sertifikatmyndighetssertifikatet er ikke installert. Kjør MITM-oppsettsveilederen.</string>
    <string name="mitm_addon_bad_version">Feilaktig versjon for MITM-tillegget i PCAPdroid. Installer versjon %1$s og prøv igjen.</string>
    <string name="export_failed">Eksport mislyktes</string>
    <string name="not_encrypted">Ikke kryptert</string>
    <string name="request">Forespørsel</string>
    <string name="response">Svar</string>
    <string name="payload">Nyttelast</string>
    <string name="tx_direction">TX</string>
    <string name="warn_no_app_data">Ingen programdata har blitt utvekslet</string>
    <string name="http">HTTP</string>
    <string name="not_decryptable">Ikke dekrypterbar</string>
    <string name="rx_direction">RX</string>
    <string name="hexdump">Heksadesimal dump</string>
    <string name="geolocation">Geoposisjon</string>
    <string name="geolocation_summary">Vis land og ASN-info ved å utføre frakoblet oppslag</string>
    <string name="geo_db_download">Trykk for å laste ned siste database. De slippes månedlig.</string>
    <string name="geo_db_delete">Trykk for å slette databasen og spare plass.</string>
    <string name="import_failed">Import mislyktes</string>
    <string name="invalid_backup">Ugyldig sikkerhetskopieringsformat</string>
    <string name="rules_import_success">Importerte %1$d regler</string>
    <string name="no_rules_to_export">Ingen regler å eksportere</string>
    <string name="keep_action">Behold</string>
    <string name="blocklist">Svarteliste</string>
    <string name="rules_merge_msg">Behold eksisterende regler\?</string>
    <string name="firewall_is_enabled">Brannmur på</string>
    <string name="connections_blocked">Tilkoblinger blokkert</string>
    <string name="last_firewall_block">Siste blokkering</string>
    <string name="num_configured_rules">Oppsatte regler</string>
    <string name="app_info">Programinfo</string>
    <string name="action_block">Blokker</string>
    <string name="netd_block_missed">Denne tilkoblingen ble igangsatt av netd så den kan ikke blokkeres</string>
    <string name="no_root_firewall">Brannmur uten rot-tilgang</string>
    <string name="block_quick">Blokker QUIC</string>
    <string name="block_private_dns">Blokker privat DNS</string>
    <string name="welcome_to_pcapdroid">Velkommen til PCAPdroid</string>
    <string name="app_intro_next_button">Neste</string>
    <string name="app_intro_skip_button">Hopp over</string>
    <string name="privacy_first">Personvern først</string>
    <string name="country_and_asn">Land og ASN</string>
    <string name="vpn_setup_msg">PCAPdroid simulerer VPN for å fange nettverkstrafikk uten rot-tilgang.
\n
\nFor å starte fangst må du godta VPN-forespørselen i neste steg.</string>
    <string name="app_intro_traffic_dump">PCAPdroid tillater dumping av data på <a href="%1$s">flere vis</a> for dumping av data i forvalgt PCAP-format for videre analyse.
\n
\nVia <a href="%2$s">trailer-alternativet</a>, kan du legge til programnavn i pakkene og vise dem i Wireshark.</string>
    <string name="mitm_addon_new_version">MITM-tillegget for PCAPdroid må oppgraderes.</string>
</resources>

```

`app/src/main/res/values-night-v8/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorTab">#5A458D</color>
    <color name="colorTabText">@android:color/secondary_text_dark</color>
    <color name="colorTabTextSelected">@android:color/primary_text_dark</color>
    <color name="colorPrimary">#6C52AB</color>
    <color name="colorPrimaryDark">#24144D</color>
    <color name="colorActionBar">#121212</color>
    <color name="colorAccent">#03DAC6</color>
    <color name="colorAccentLight">#BCEBE7</color>
    <color name="colorBackgroundGray">#1CFFFFFF</color>
    <color name="navViewBackground">#FF202020</color>
    <color name="backgroundColor">@color/background_material_dark</color>
    <color name="drawerItemColor">@android:color/primary_text_dark</color>
    <color name="highContrast">#FFFFFF</color>
</resources>
```

`app/src/main/res/values-night-v8/styles.xml`:

```xml
<resources xmlns:android="http://schemas.android.com/apk/res/android">
    <style name="AppTheme" parent="Base.AppTheme">
        <!--
        <item name="android:colorBackground">#ff000000</item>
        <item name="materialThemeOverlay">@style/ButtonStyleTextColor</item>
        -->
    </style>

    <!--
    <style name="ButtonStyleTextColor">
        <item name="colorOnPrimary">@color/colorTabText</item>
        <item name="colorOnSecondary">@color/colorTabText</item>
    </style>
    -->
</resources>
```

`app/src/main/res/values-pl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">Start</string>
    <string name="stop_button">Stop</string>
    <string name="title_activity_settings">Ustawienia</string>
    <string name="collector_info">Kolektor UDP: %1$s:%2$d</string>
    <string name="tcp_collector_info">Kolektor TCP: %1$s:%2$d</string>
    <string name="http_server_status">HTTP serwer: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s otrzymane — %2$s wysłane</string>
    <string name="query">Zapytanie</string>
    <string name="host">Host</string>
    <string name="ready">Gotowe</string>
    <string name="about">Informacje</string>
    <string name="status">Status</string>
    <string name="connections_view">Połączenia</string>
    <string name="no_connections">Brak połączeń</string>
    <string name="connection_details">Szczegóły połączenia</string>
    <string name="app">App</string>
    <string name="protocol">Protokół</string>
    <string name="source">Źródło</string>
    <string name="destination">Cel</string>
    <string name="packets">Pakiety</string>
    <string name="duration">Czas trwania</string>
    <string name="http_server">HTTP serwer</string>
    <string name="udp_exporter">Eksport UDP</string>
    <string name="tcp_exporter">Eksport TCP</string>
    <string name="no_dump">Bez zrzutu</string>
    <string name="no_dump_info">Ruch nie będzie zrzucany</string>
    <string name="http_server_info">Uruchom serwer HTTP do pobierania PCAP</string>
    <string name="udp_exporter_info">Wyślij PCAP do zdalnego odbiornika UDP</string>
    <string name="http_server_port">Port serwera HTTP</string>
    <string name="receiver_ip_address">Adres IP kolektora</string>
    <string name="receiver_port">Port kolektora</string>
    <string name="traffic_dump">Zrzut ruchu sieciowego</string>
    <string name="user_guide">Podręcznik użytkownika</string>
    <string name="open_telegram_group">Grupa na Telegramie</string>
    <string name="source_code">Kod źródłowy</string>
    <string name="yes">Tak</string>
    <string name="no">Nie</string>
    <string name="vpn_setup_failed">Nie można skonfigurować VPN. Sprawdź czy ustawienie Zawsze włączony VPN jest wyłączone</string>
    <string name="app_not_found">Nie można znaleźć aplikacji „%1$s”</string>
    <string name="stats">Statystyki</string>
    <string name="active_connections">Aktywne połączenia</string>
    <string name="dropped_connections">Zerwane połączenia</string>
    <string name="tot_connections">Wszystkie połączenia</string>
    <string name="open_sockets">Otwarte sockets</string>
    <string name="bytes_sent">Wysłane bajty</string>
    <string name="bytes_rcvd">Bajty odebrane</string>
    <string name="ipv6_bytes_percentage">Procent bajtów IPv6</string>
    <string name="packets_sent">Wysłane pakiety</string>
    <string name="packets_rcvd">Odebrane pakiety</string>
    <string name="dns_queries">Zapytania DNS</string>
    <string name="search_apps">Wyszukiwanie aplikacji</string>
    <string name="no_apps">Brak aplikacji</string>
    <string name="dns_server">DNS serwer</string>
    <string name="apps">Aplikacje</string>
    <string name="pcap_file">Plik PCAP</string>
    <string name="pcap_file_info">Utwórz plik PCAP/Pcapng w pamięci urządzenia</string>
    <string name="cannot_write_file">Nie można zapisać pliku</string>
    <string name="share">Udostępnij</string>
    <string name="delete">Usuń</string>
    <string name="ok">OK</string>
    <string name="pcap_file_action">Ruch zapisany w pliku \"%1$s\".(%2$s)</string>
    <string name="delete_error">Nie udało się usunąć pliku</string>
    <string name="capture_running">Przechwytywanie działa</string>
    <string name="notification_msg">Przechwycono %1$s, połączenie %2$s</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="conn_status_active">Aktywny</string>
    <string name="first_seen">Pierwszy widziany</string>
    <string name="last_seen">Ostatnio widziany</string>
    <string name="conn_status_closed">Zamknij</string>
    <string name="copy_to_clipboard">Kopiuj</string>
    <string name="save_to_file">Zapisz do pliku</string>
    <string name="older_connections_notice">Nie pokazano %1$d starszych połączeń</string>
    <string name="about_text">PCAPdroid to narzędzie opensource do przechwytywania i monitorowania sieci, które działa bez uprawnień administratora</string>
    <string name="get_app">Pobierz:</string>
    <string name="unknown_app">Nieznany</string>
    <string name="phone_app">Telefon</string>
    <string name="error">Błąd</string>
    <string name="conn_status_unreachable">Nieosiągalny</string>
    <string name="other_prefs">Inne</string>
    <string name="app_language">Język aplikacji</string>
    <string name="system_default">domyślne systemu</string>
    <string name="no_activity_file_selection">Nie znaleziono aplikacji obsługującej wybór plików</string>
    <string name="file_saved_with_name">Plik zapisany jako \"%1$s\"</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="socks5_redirection">Przekierowanie SOCKS5</string>
    <string name="socks5_summary">Skonfiguruj przekierowanie do serwera proxy SOCKS5</string>
    <string name="enable_socks5_proxy_summary">Przekieruj wszystkie połączenia TCP do serwera proxy SOCKS5</string>
    <string name="socks5_info">Proxy SOCKS5: %1$s:%2$d</string>
    <string name="socks5_auth">Uwierzytelnianie SOCKS5n</string>
    <string name="socks5_auth_summary">Uwierzytelnij serwer proxy za pomocą nazwy użytkownika i hasła</string>
    <string name="proxy_port">Port proxy</string>
    <string name="root_capture">Przechwyć jako root</string>
    <string name="root_capture_summary">Pozwala PCAPdroid działać z innymi aplikacjami VPN</string>
    <string name="donate">Dotacja</string>
    <string name="app_log">Log</string>
    <string name="no_data">Brak danych</string>
    <string name="search">Szukanie…</string>
    <string name="app_val">Apka: %1$s</string>
    <string name="ip_address_val">Adres IP: %1$s</string>
    <string name="host_val">Host: %1$s</string>
    <string name="protocol_val">Protokół: %1$s</string>
    <string name="malware_whitelist_action">Biała lista (złośliwe oprogramowanie)…</string>
    <string name="hide">Ukrywanie…</string>
    <string name="select">Wybierz</string>
    <string name="n_selected">Wybrano %1$d</string>
    <string name="select_all">Zaznacz wszystko</string>
    <string name="app_details">Szczegóły aplikacji</string>
    <string name="package_name">Nazwa pakietu</string>
    <string name="uid">UID</string>
    <string name="app_name">Nazwa</string>
    <string name="version">Wersja</string>
    <string name="target_sdk">Target SDK</string>
    <string name="installed_on">Zainstalowany na</string>
    <string name="last_update">Ostatnia aktualizacja</string>
    <string name="permissions">Pozwolenia</string>
    <string name="root_app_info">Demony systemowe działające z maksymalnymi uprawnieniami</string>
    <string name="netd_app_info">Demon systemowy wykonujący rozpoznawanie nazw DNS</string>
    <string name="android_app_info">System Android</string>
    <string name="phone_app_info">Usługi telefoniczne</string>
    <string name="unknown_app_info">\„Nieznane\” oznacza połączenia, których aplikacji nie można określić</string>
    <string name="packets_dropped">Pakiety upuszczone</string>
    <string name="capture_prefs">Przechytywanie</string>
    <string name="dump_extensions_how_to">Jak wyświetlić rozszerzenia zrzutu PCAPdroid w Wireshark</string>
    <string name="pending_transaction">Dokończ transakcję, aby skorzystać z tej funkcji</string>
    <string name="ctrl_consent">Aplikacja chce przechwytywać ruch na Twoim urządzeniu.\nOdrzuć, jeśli nie masz pewności</string>
    <string name="deny">Odmowa</string>
    <string name="allow">Zgoda</string>
    <string name="ctrl_consent_title">Żądanie kontroli PCAPdroid</string>
    <string name="ctrl_consent_denied">PCAPdroid: żądanie kontroli zostało odrzucone</string>
    <string name="ctrl_consent_allowed">PCAPdroid: żądanie kontroli było dozwolone</string>
    <string name="capture_interface">Interfejs przechwytywania</string>
    <string name="internet">Internet</string>
    <string name="all_interfaces">Wszystkie interfejsy</string>
    <string name="capturing_from">Przechwytywanie pakietów z \"%1$s\"</string>
    <string name="edit_filter">Edytuj filtry</string>
    <string name="edit_list">Edytuj listę</string>
    <string name="hidden_connections_rules">Zasady połączeń ukrytych</string>
    <string name="list_is_empty">Lista jest pusta</string>
    <string name="show_only_malicious">Złośliwe połączenia</string>
    <string name="show_only_cleartext">Wyczyść połączenia tekstowe</string>
    <string name="security">Ochrona</string>
    <string name="malware_detection">Wykrywanie złośliwego oprogramowania</string>
    <string name="malware_detection_summary">Wykrywaj połączenia ze znanymi złośliwymi hostami za pośrednictwem czarnych list innych firm</string>
    <string name="reset">Reset</string>
    <string name="malware_whitelist_rules">Zasady białej listy złośliwego oprogramowania</string>
    <string name="feature_not_available">Ta funkcja jest obecnie niedostępna na Twoim urządzeniu</string>
    <string name="billing_connecting">Trwa łączenie z Google Play, spróbuj ponownie za chwilę</string>
    <string name="malware_whitelist_help">Biała lista zdefiniowana przez użytkownika w celu zablokowania wykrywania złośliwego oprogramowania. Długo naciskaj złośliwe połączenia, aby utworzyć reguły usuwające ich oznaczenie jako złośliwego oprogramowania</string>
    <string name="hidden_connections_help">Lista reguł ukrywania wpisów na liście połączeń, dzięki czemu możesz skupić się na odpowiednich</string>
    <string name="malicious_connection_filter">Złośliwe połączenia</string>
    <string name="status_filter">HTTP Status: %1$s</string>
    <string name="not_hidden_filter">Nieukryte</string>
    <string name="copy_action">Kopiowanie…</string>
    <string name="url_val">"URL: %1$s"</string>
    <string name="show_me">Pokaż</string>
    <string name="hint">Wskazówka</string>
    <string name="once">Raz</string>
    <string name="forever">Na zawsze</string>
    <string name="control_permissions">Kontroluj uprawnienia</string>
    <string name="control_permissions_summary">Sprawdź, które aplikacje mogą kontrolować przechwytywanie PCAPdroid</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">Kraj</string>
    <string name="asn">ASN</string>
    <string name="country_val">Kraj: %1$s</string>
    <string name="send_report">Wyślij raport</string>
    <string name="start_at_boot">Uruchom przy rozruchu</string>
    <string name="start_at_boot_summary">Automatyczne uruchamianie przechwytywania po uruchomieniu</string>
    <string name="malware_status_ok">Nie wykryto złośliwego ruchu</string>
    <string name="malware_status_detected">Wykryto złośliwe połączenia</string>
    <string name="whitelist">Biała lista</string>
    <string name="blacklists">Czarne listy</string>
    <string name="status_outdated">Przestarzały</string>
    <string name="status_not_loaded">Nie załadowano</string>
    <string name="status_uptodate">Aktualne</string>
    <string name="blacklist_type">"Typ: %1$s"</string>
    <string name="blacklist_type_ip">Czarna lista adresów IP</string>
    <string name="blacklist_type_domain">Czarna lista domen</string>
    <string name="n_rules">%1$s reguły</string>
    <string name="last_update_val">Ostatnia aktualizacja: %1$s</string>
    <string name="malicious_connections">Złośliwe połączenia</string>
    <string name="updated_blacklists">Zaktualizowane czarne listy</string>
    <string name="connections_checked">Połączenia sprawdzone</string>
    <string name="last_blacklists_update">Ostatnia aktualizacja</string>
    <string name="domain_rules">Reguły domeny</string>
    <string name="ip_rules">Zasady IP</string>
    <string name="malware_status_update_failed">Niektóre czarne listy są nieaktualne</string>
    <string name="update_now">Aktualizuj teraz</string>
    <string name="status_updating">Aktualizacja…</string>
    <string name="malware_detection_learn_more">Dowiedz się więcej o funkcji wykrywania złośliwego oprogramowania</string>
    <string name="private_dns_message_notice">Prywatny DNS uniemożliwia PCAPdroid sprawdzanie ruchu DNS. Możesz go wyłączyć w ustawieniach sieci Android</string>
    <string name="private_dns_hinders_detection">Prywatny DNS utrudnia wykrywanie</string>
    <string name="decryption_no_filter_warn">Wybierz aplikację docelową podczas odszyfrowywania TLS, aby uniknąć utraty połączenia z Internetem</string>
    <string name="block">Blokowanie…</string>
    <string name="unblock">Odblokowywanie…</string>
    <string name="firewall">Zapora</string>
    <string name="firewall_rules">Reguły zapory</string>
    <string name="blocked_pkts">Zablokowany</string>
    <string name="n_pkts">%1$s pak</string>
    <string name="blocked_connection_filter">Zablokowany</string>
    <string name="allowed_connection_filter">Dozwolony</string>
    <string name="firewall_filter">Zapora: %1$s</string>
    <string name="paid_features">Płatne funkcje</string>
    <string name="validate">Potwierdzić</string>
    <string name="valid">Poprawny</string>
    <string name="invalid">Niepoprawny</string>
    <string name="no_intent_handler_found">Nie znaleziono aplikacji do wykonania tej czynności</string>
    <string name="network_interface">Interfejs</string>
    <string name="interface_filter">Interfejs: %1$s</string>
    <string name="request_method">Metoda żądania</string>
    <string name="content_type">Typ zawartości</string>
    <string name="http_status">Status HTTP</string>
    <string name="payload_size_threshold">Próg rozmiaru payloadu</string>
    <string name="method_filter">Metoda: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="loading">Ładowanie…</string>
    <string name="purchased">Zakupione</string>
    <string name="no_items_for_purchase">Brak przedmiotów do kupienia</string>
    <string name="billing_failure">Nie można połączyć się z Google Play. Spróbuj ponownie za chwilę</string>
    <string name="learn_more">Doczytaj</string>
    <string name="buy_action">Kup</string>
    <string name="capture_not_running_status">Przechwytywanie nie jest uruchomione</string>
    <string name="start_capture_first">Najpierw rozpocznij przechwytywanie</string>
    <string name="copied">Skopiowane</string>
    <string name="can_use_purchased_feature">Możesz teraz korzystać z zakupionej funkcji</string>
    <string name="disconnect_vpn_confirm">Potwierdzenie odłączy aktywną aplikację VPN</string>
    <string name="loading_apps">Ładowanie aplikacji…</string>
    <string name="open_nav_drawer">Otwórz szufladę</string>
    <string name="close_nav_drawer">Zamknij szufladę</string>
    <string name="capture_all_apps">Przechwytuj ruch ze wszystkich aplikacji</string>
    <string name="save_ok">Zapisane</string>
    <string name="tls_decryption">Deszyfrowanie TLS</string>
    <string name="tls_decryption_summary">Odszyfruj ruch SSL/TLS, wykonując mitm. Może to teraz działać z niektórymi aplikacjami, zapoznaj się z instrukcją obsługi</string>
    <string name="traffic_inspection">Inspekcja ruchu</string>
    <string name="mitm_start_failed">Nie można uruchomić usługi mitm. Spróbuj ręcznie otworzyć aplikację mitm addon i spróbuj ponownie</string>
    <string name="mitm_setup_wizard">Mitm kreator konfiguracji</string>
    <string name="install_action">Instalacja</string>
    <string name="export_action">Eksport</string>
    <string name="install_the_mitm_addon">Zainstaluj PCAPdroid <a href="%1$s">dodatek mitm</a></string>
    <string name="export_ca_certificate">Wyeksportuj certyfikat PCAPdroid CA, a następnie otwórz ustawienia Androida \"Szyfrowanie i poświadczenia\" i wybierz zainstaluj go jako \"Certyfikat CA\""</string>
    <string name="install_ca_certificate">Zainstaluj certyfikat PCAPdroid CA, wybierając \"VPN i aplikacje\". Android poprosi o ekran blokady lub hasło</string>
    <string name="checking_the_certificate">Sprawdzanie certyfikatu…</string>
    <string name="ca_cert_export_failed">Wystąpił błąd podczas eksportowania certyfikatu \n\nJeśli Twoje urządzenie obsługuje funkcję Autostart lub podobne oprogramowanie ograniczające wykonywanie usług w tle, pamiętaj o umieszczeniu <a href="%1$s"> na białej liście PCAPdroid</a></string>
    <string name="cert_exported_now_installed">Certyfikat wyeksportowany, teraz zainstaluj go z poziomu ustawień Androida</string>
    <string name="cert_installed_correctly">Certyfikat CA jest zainstalowany</string>
    <string name="cert_reinstall_required">Certyfikat CA nie jest zainstalowany, uruchom kreatora instalacji mitm</string>
    <string name="mitm_addon_bad_version">Zła wersja dodatku PCAPdroid mitm. Zainstaluj wersję %1$s i spróbuj ponownie</string>
    <string name="mitm_addon_new_version">Dodatek PCAPdroid mitm musi zostać zaktualizowany</string>
    <string name="mitm_addon">Dodatek mitm</string>
    <string name="export_failed">Eksport nie powiódł się</string>
    <string name="not_encrypted">Nie zaszyfrowane</string>
    <string name="request">Żądanie</string>
    <string name="response">Odpowiedź</string>
    <string name="overview">Przegląd</string>
    <string name="string_http_request">Żądanie HTTP</string>
    <string name="string_http_response">Odpowiedź HTTP</string>
    <string name="payload_truncated">Payload jest obcięty. Włącz opcję \"%1$s\", aby wyświetlić w całości</string>
    <string name="websocket">WebSocket</string>
    <string name="http">HTTP</string>
    <string name="payload">Treść</string>
    <string name="tx_direction">TX</string>
    <string name="rx_direction">RX</string>
    <string name="full_payload">Pełna treść</string>
    <string name="full_payload_summary">Pokaż pełny payload połączeń (np. pełne żądanie i odpowiedź HTTP). To wymaga dużo pamięci, nie używaj na dłuższą metę</string>
    <string name="not_decryptable">Nie do odszyfrowania</string>
    <string name="decrypted">Odszyfrowane</string>
    <string name="decryption">Deszyfrowanie</string>
    <string name="decryption_filter">Status: %1$s</string>
    <string name="connection_start_not_seen">PCAPdroid nie widział początku tego połączenia. Może brakować niektórych informacji</string>
    <string name="network_traffic">Ruch</string>
    <string name="warn_no_app_data">Żadne dane aplikacji nie zostały wymienione</string>
    <string name="waiting_application_data">Oczekiwanie na dane</string>
    <string name="text">Tekst</string>
    <string name="hexdump">Zrzut szesnastkowy</string>
    <string name="display_as_text">Wyświetl jako tekst</string>
    <string name="display_as_hexdump">Wyświetl jako zrzut szesnastkowy</string>
    <string name="geolocation">Geolokalizacja</string>
    <string name="geolocation_summary">Pokaż informacje o kraju i ASN, przeprowadzając wyszukiwanie offline</string>
    <string name="downloading">Pobieranie…</string>
    <string name="download_in_progress">Trwa pobieranie, proszę czekać</string>
    <string name="download_failed">Pobieranie nie udane</string>
    <string name="exporting">Eksportowanie…</string>
    <string name="export_in_progress">Eksport w toku, proszę czekać</string>
    <string name="geo_db_not_found">Nie znaleziono bazy danych. Geolokalizacja jest wyłączona</string>
    <string name="country_rules_warning">Aby korzystać z reguł zapory opartych na krajach, pobierz bazę danych geolokalizacji z ustawień PCAPdroid, w przeciwnym razie reguły oparte na krajach będą nieskuteczne</string>
    <string name="database">Bazy danych</string>
    <string name="built_on">Zbudowany na: %1$s</string>
    <string name="geo_db_download">Stuknij, aby pobrać najnowszą bazę danych. Nowe bazy danych są dostępne co miesiąc</string>
    <string name="size_x">Rozmiar: %1$s</string>
    <string name="geo_db_delete">Stuknij, aby usunąć bazę danych i zaoszczędzić miejsce</string>
    <string name="download">Pobierz</string>
    <string name="connection_blocked">To połączenie zostało zablokowane przez PCAPdroid</string>
    <string name="import_action">Import</string>
    <string name="import_failed">Importowanie nie powiodło się</string>
    <string name="invalid_backup">Nieprawidłowy format kopii zapasowej</string>
    <string name="rules_import_success">Zaimportowana reguła %1$ds</string>
    <string name="no_rules_to_export">Brak reguł eksportu</string>
    <string name="rules_merge_msg">Zachować dotychczasowe zasady?</string>
    <string name="keep_action">Zachowaj</string>
    <string name="discard_action">Porzuć</string>
    <string name="rules_delete_confirm">Usunąć wybrane reguły??</string>
    <string name="blocklist">Lista zablokowanych</string>
    <string name="num_configured_rules">Skonfigurowane reguły</string>
    <string name="connections_blocked">Połączenia zablokowane</string>
    <string name="last_firewall_block">Ostatni blok</string>
    <string name="firewall_is_disabled">Zapora sieciowa jest wyłączona</string>
    <string name="firewall_is_enabled">Zapora sieciowa jest włączona</string>
    <string name="app_info">Informacje o aplikacji</string>
    <string name="action_block">Blokuj</string>
    <string name="action_unblock">Odblokujk</string>
    <string name="netd_block_missed">To połączenie zostało zainicjowane przez netd, więc nie mogło zostać zablokowane</string>
    <string name="firewall_summary">Blokuj dostęp aplikacji do Internetu, konfiguruj reguły dla określonych domen i adresów IP. Działa tylko z przechwytywaniem innym niż root</string>
    <string name="no_root_firewall">Zapora bez roota</string>
    <string name="block_quick">Zablokuj QUIC</string>
    <string name="block_private_dns">Zablokuj prywatny DNS</string>
    <string name="block_private_dns_summary">Wykryj i prawdopodobnie zablokuj prywatny DNS, aby sprawdzić ruch DNS. Wyłączenie tej opcji może utrudnić analizę ruchu</string>
    <string name="mitm_setup_wizard_intro">Ten kreator przeprowadzi Cię przez proces instalacji dodatku PCAPdroid mitm i certyfikacji, które są potrzebne do wykonania <a href="%1$s">odszyfrowania TLS</a></string>
    <string name="mitm_setup_wizard_done">PCAPdroid jest teraz gotowy do odszyfrowania ruchu TLS\n\nSprawdź <a href="%1$s">podręcznik użytkownika</a>, aby dowiedzieć się więcej o środkach bezpieczeństwa, które mogą uniemożliwić odszyfrowanie i jak je ominąć</string>
    <string name="welcome_to_pcapdroid">Witamy w PCAPdroid</string>
    <string name="app_intro_next_button">Następny</string>
    <string name="app_intro_skip_button">Przeskocz</string>
    <string name="app_intro_back_button">Wstecz</string>
    <string name="app_intro_done_button">Zrobione</string>
    <string name="app_intro_welcome_msg">PCAPdroid to przyjazna dla prywatności aplikacja, która pozwala śledzić i analizować połączenia nawiązywane przez aplikacje na Twoim urządzeniu\n\nPonadto pozwala eksportować zrzut ruchu PCAP, wyodrębniać metadane i wiele więcej!</string>
    <string name="privacy_first">Prywatność na pierwszym miejscu</string>
    <string name="app_intro_privacy_msg">Aplikacja nie wykorzystuje żadnych funkcji śledzenia i analityki \n\nSkąd możesz mieć pewność? Sprawdź  <a href="%1$s">politykę prywatności</a> i <a href="%2$s">kod źródłowy</a></string>
    <string name="country_and_asn">Kraj i ASN</string>
    <string name="app_intro_geolocation_msg">PCAPdroid może wysłać zapytanie do lokalnej bazy danych, aby określić kraj zdalnego serwera\n\nNajpierw musisz pobrać bazę danych geolokalizacji z ustawień aplikacji</string>
    <string name="vpn_setup_msg">PCAPdroid symuluje VPN w celu przechwytywania ruchu sieciowego bez rootowania.\n\nAby rozpocząć przechwytywanie, musisz zaakceptować żądanie VPN na następnym ekranie\n\n<b>UWAGA:</b> aby kontynuować, wyłącz każdą skonfigurowaną funkcję Always-on VPN w ustawieniach Androida</string>
    <string name="app_intro_traffic_inspection">Sprawdzanie żądań HTTP, odpowiedzi i nieprzetworzonych danych jest łatwe dzięki wbudowanym dekoderom\n\nMasz szyfrowane połączenie? Możesz włączyć <a href="%1$s">odszyfrowywanie TLS</a>, aby uzyskać odszyfrowane dane</string>
    <string name="app_intro_firewall_msg">Dzięki zintegrowanej <a href="%1$s">zaporze sieciowej</a> możesz łatwo blokować dostęp do Internetu dla poszczególnym aplikacji, domen i państw\n\nPołącz to z wbudowaną widocznością ruchu, aby uzyskać najlepsze narzędzie do ochrony prywatności</string>
    <string name="app_intro_malware_detection">Zwiększ bezpieczeństwo swojego urządzenia dzięki funkcji <a href="%1$s">wykrywania złośliwego oprogramowania</a>\n\nKorzystając z aktualnych czarnych list, może wykrywać, blokować i ostrzegać o złośliwych połączeniach w czasie rzeczywistym</string>
    <string name="app_intro_traffic_dump">PCAPdroid zapewnia <a href="%1$s">wiele sposobów</a> zrzucania ruchu w standardowym formacie PCAP do dalszej analizy\n\nDzięki <a href="%2$s">opcji rozszerzeń PCAPdriod</a>, możesz dodawać nazwy aplikacji do pakietów i wyświetlać je w Wireshark</string>
    <string name="permission_granted">Uprawnienie %1$s zostało przyznane</string>
    <string name="permission_grant_fail">Nie można przyznać uprawnienia %1$s</string>
    <string name="connection_not_found">Nie można znaleźć podanego połączenia</string>
    <string name="low_memory">Mało pamięci</string>
    <string name="low_memory_info">Aplikacji brakuje pamięci, spodziewaj się awarii</string>
    <string name="full_payload_disabled">Opcja payload została wyłączona</string>
    <string name="capture_stopped_low_memory">Przechwytywanie zostało zatrzymane</string>
    <string name="heap_usage">Wykorzystanie sterty</string>
    <string name="memory_usage">Zużycie pamięci</string>
    <string name="vpn_lockdown_notice">Aby uniemożliwić aplikacjom dostęp do Internetu, gdy PCAPdroid nie jest uruchomiony (np. po ponownym uruchomieniu), możesz ustawić PCAPdroid jako stałą sieć VPN w trybie blokady.\n\nCzy chcesz teraz otworzyć ustawienia VPN?</string>
    <string name="ip_mode">Adresy IP sieci VPN</string>
    <string name="ipv4_only">Tylko IPv4</string>
    <string name="ipv6_only">Tylko IPv6</string>
    <string name="ip_both">IPv4 i IPv6</string>
    <string name="notifications_notice">Aplikacja wykorzystuje powiadomienia do wysyłania alertów w przypadku nietypowych zdarzeń. Nadaj jej uprawnienia do wysyłania powiadomień na następnym ekranie</string>
    <string name="vpn_exemptions">Wyjątki VPN</string>
    <string name="vpn_exemptions_summary">Zwolnij niektóre aplikacje z połączenia VPN. Ich ruch nie będzie monitorowany</string>
    <string name="no_matches_found">Brak wyników</string>
    <string name="cleartext_connection">Połączenia nieszyfrowane</string>
    <string name="unblock_permanently">Odblokuj na stałe</string>
    <string name="unblock_for_n_hours">Odblokuj dla %1$dh</string>
    <string name="unblock_for_n_minutes">Odblokuj dla %1$dm</string>
    <string name="block_new_apps">Blokuj nowo zainstalowane aplikacje</string>
    <string name="app_blocked">Aplikacja zablokowana</string>
    <string name="app_blocked_info">Aplikacja %1$s została zablokowana przez zaporę sieciową</string>
    <string name="app_unblocked">Aplikacja %1$s została odblokowana</string>
    <string name="payload_scams_notice">Ten widok może zawierać poufne informacje, takie jak hasła i tokeny dostępu.\n\nNigdy nie podawaj nikomu tych informacji, może to być próba oszustwa</string>
    <string name="cancel_action">Anuluj</string>
    <string name="show_data_action">Pokaż dane</string>
    <string name="remote_collector_notice">Skonfigurowałeś PCAPdroid do wysyłania ruchu do zdalnego serwera. Serwer będzie mógł uzyskać dostęp do Twoich poufnych informacji.\n\nJeśli ktoś Cię o to poprosi, prawdopodobnie jest to próba oszustwa</string>
    <string name="remote_server_warning">Ze względów bezpieczeństwa wysyłanie ruchu do zdalnego serwera \"%1$s\" jest niedozwolone"</string>
    <string name="warning">Ostrzeżenie</string>
    <string name="paid_features_unlocked">Płatne funkcje odblokowane. Uruchom ponownie przechwytywanie, jeśli jest uruchomione</string>
    <string name="build_info">Informacje o kompilacji</string>
    <string name="tls_decryption_with_root_msg">Możliwość uruchomienia deszyfrowania TLS z uprawnieniami administratora jest funkcją eksperymentalną. Oto lista znanych błędów:\n\n - w PCAPdroid zobaczysz ruch wygenerowany z aplikacji mitm-addon zamiast oryginalnej aplikacji\n - zrzut SSL keylog nie jest obsługiwany \n - gdy ustawiony jest filtr aplikacji, odszyfrowanie nastąpi tylko dla aplikacji docelowej, ale PCAPdroid nadal będzie wyświetlał ruch innych aplikacji\n - jeśli przechwytywanie się nie rozpocznie, upewnij się, że faktycznie możesz uruchomić polecenie iptables jako root (np. przez termux)\n – to może nie działać na Androidzie 12 i nowszych\n - jeśli aplikacja VPN jest uruchomiona, należy wybrać konkretną aplikację do odszyfrowania lub wykluczyć dodatek PCAPdroid mitm z VPN, w przeciwnym razie ruch będzie się zapętlał</string>
    <string name="unlock_token_summary">Token, którego można użyć do odblokowania płatnych funkcji w kompilacjach aplikacji spoza Google Play (np. F-Droid/Github)</string>
    <string name="unlock_token_error">Nie można zażądać tokena odblokowującego [%1$d]: %2$s</string>
    <string name="access_paid_features_msg">Zapoznaj się z <a href="%1$s">przewodnikiem użytkownika</a>, aby dowiedzieć się, jak uzyskać dostęp do płatnych funkcji</string>
    <string name="license_service_unavailable">Usługa licencji PCAPdroid jest obecnie niedostępna. Spróbuj ponownie za kilka minut</string>
    <string name="requesting_unlock_token">Prośba o token odblokowania, proszę czekać</string>
    <string name="show_action">Pokaż</string>
    <string name="show_connection">Pokaż połączenie</string>
    <string name="show_system_apps">Pokaż aplikacje systemowe</string>
    <string name="unlock_token_msg1">To jest twój token odblokowania. Zanotuj go, ponieważ będzie potrzebny <a href="%1$s">do wygenerowania kodów licencyjnych</a></string>
    <string name="paid_feature">Płatna funkcja</string>
    <string name="firewall_purchase_msg">Kup funkcję <i>%1$s</i>, aby zacząć blokować połączenia</string>
    <string name="mitm_skip_notice">Wydaje się, że certyfikat mitm nie jest zainstalowany. Jeśli będziesz kontynuować, odszyfrowywanie może się nie powieść</string>
    <string name="mitm_wizard_description">Skonfiguruj urządzenie do deszyfrowania TLS</string>
    <string name="mitmproxy_opts">Dodatkowe opcje mitmproxy</string>
    <string name="mitmproxy_opts_description">Podaj dodatkowe opcje dla mitmproxy</string>
    <string name="mitm_addon_error">Błąd podczas uruchamiania dodatku mitm. Sprawdź dziennik, aby uzyskać szczegółowe informacje</string>
    <string name="whitelist_mode">Tryb białej listy</string>
    <string name="firewall_whitelist_notice">W tym trybie wszystkie połączenia będą blokowane, chyba że zostaną ręcznie dodane do białej listy. Możesz przegapić powiadomienia push bez odpowiedniej białej listy</string>
    <string name="firewall_whitelist_help">Reguły te określają, które połączenia mają być dozwolone. Reguły listy zablokowanych mają pierwszeństwo przed regułami białej listy</string>
    <string name="add_to_fw_whitelist">Dodaj do białej listy zapory</string>
    <string name="remove_from_fw_whitelist">Usuń z białej listy zapory</string>
    <string name="reset_stats_confirm">Czy na pewno chcesz zresetować te statystyki?</string>
    <string name="port_mapping">Mapowanie portów</string>
    <string name="port_mapping_summary">Skonfiguruj reguły mapowania portów, aby przekierowywać połączenia do innego hosta lub portu</string>
    <string name="add_action">Dodaj</string>
    <string name="redirect_to">Przekieruj do:</string>
    <string name="original_port">Oryginalny port</string>
    <string name="required">wymagany</string>
    <string name="destination_host">Host docelowy</string>
    <string name="destination_port">Port docelowy</string>
    <string name="port_mapping_exists">Mapowanie portów jest już zdefiniowane</string>
    <string name="items_delete_confirm">Usunąć wybrane elementy?</string>
    <string name="ip_address">Adres IP</string>
    <string name="rule_exists">Reguła już zdefiniowana</string>
    <string name="dns_servers">Serwery DNS</string>
    <string name="dns_servers_summary">Skonfiguruj serwery DNS, które mają być używane podczas przechwytywania</string>
    <string name="ipv4_dns_server">Serwer DNS IPv4</string>
    <string name="ipv6_dns_server">Serwer DNS IPv6</string>
    <string name="use_system_dns">Użyj systemowego DNS</string>
    <string name="use_system_dns_summary">Jeśli to możliwe, korzystaj z systemowych serwerów DNS</string>
    <string name="external_storage_perm_required">Dostęp do pamięci zewnętrznej jest wymagany</string>
    <string name="many_rules_warning">Próbujesz zaimportować wiele reguł, co może spowodować, że aplikacja przestanie odpowiadać podczas niektórych interakcji. Czy naprawdę chcesz kontynuować?</string>
    <string name="pcapng_format">Format Pcapng</string>
    <string name="pcapng_format_summary">Zrzucaj pakiety w formacie zrzutu pcapng, który jest bardziej zaawansowany i umożliwia osadzenie sekretów deszyfrowania TLS</string>
    <string name="sort_by">Sortuj</string>
    <string name="total_bytes">Całkowita liczba bajtów</string>
    <string name="write_ext_storage_failed">Zapis w pamięci zewnętrznej nie powiódł się. Sprawdź dziennik aplikacji, aby uzyskać szczegółowe informacje</string>
    <string name="username">Nazwa</string>
    <string name="password">Hasło</string>
    <string name="mitm_addon_autostart_workaround">Połączenie z dodatkiem mitm nie powiodło się. Aby obejść ten problem, możesz spróbować otworzyć aplikację dodatku mitm, a następnie wrócić do PCAPdroid bez jej zamykania. Czy chcesz go teraz otworzyć?</string>
    <string name="qr_license_confirm">Czy chcesz wygenerować licencję na urządzenie \"%1$s\" za pomocą następującego tokena odblokowującego?</string>
    <string name="invalid_license">Niepoprawna licencja</string>
    <string name="connection_error">Błąd połączenia: %1$s</string>
    <string name="activate_via_qr_code">Aktywuj za pomocą kodu QR</string>
    <string name="qr_code_expired">Kod QR wygasł. Wygeneruj nowy kod QR i spróbuj ponownie</string>
    <string name="qr_info_text">Zainstaluj PCAPdroid z Google Play i zeskanuj ten kod QR</string>
    <string name="qr_purchase_required">Kup token odblokowujący, aby kontynuować aktywację kodu QR</string>
    <string name="license_limit_reached">Osiągnąłeś limit licencji dla tego tokena odblokowującego. Kup nowy token, aby wygenerować więcej licencji</string>
    <string name="license_error">Błąd generowania licencji [%1$d]: %2$s</string>
    <string name="requesting_license">Żądanie kodu licencji, proszę czekać</string>
    <string name="license_activation_ok">Aktywacja licencji zakończona</string>
    <string name="mitm_addon_running">Dodatek Mitm jest uruchomiony</string>
    <string name="decryption_rules_help">Te reguły określają, które połączenia mają być odszyfrowane. Reguły oparte na hostach działają tylko wtedy, gdy wcześniej otrzymano odpowiedź DNS</string>
    <string name="keylog_read_error">Błąd odczytu SSL keylog</string>
    <string name="pcap_file_load_aborted">Ładowanie pliku przechwytywania przerwane</string>
    <string name="decryption_info_no_rule">Aby odszyfrować to połączenie, utwórz regułę deszyfrowania z panelu bocznego lub z menu kontekstowego na liście połączeń</string>
    <string name="active_vpn_detected">Wykryto aktywny VPN</string>
    <string name="mitm_doze_notice">Optymalizacja baterii może zakłócać działanie dodatku mitm</string>
    <string name="redirected">przekierowano</string>
    <string name="connection_redirected_port_map">To połączenie zostało przekierowane z powodu reguły mapowania portów</string>
    <string name="dnscrypt_how_to">Jak używać DoH / DNSCrypt z PCAPdroid</string>
    <string name="never">Nigdy</string>
    <string name="for_connections_to_decrypt">Tylko dla połączeń do odszyfrowania</string>
    <string name="decrypt_quic_notice">Odszyfrowywanie QUIC nie jest obecnie obsługiwane. Jako obejście, zatrzymaj przechwytywanie i wybierz opcję blokowania QUIC w ustawieniach PCAPdroid</string>
    <string name="target_apps">Aplikacje docelowe</string>
    <string name="target_apps_help">Wybierz aplikacje do przechwytywania</string>
    <string name="restart_on_disconnection">Restart po rozłączeniu</string>
    <string name="vpn_reconnection">Ponowne połączenie VPN</string>
    <string name="vpn_reconnection_aborted">Ponowne połączenie VPN przerwane</string>
    <string name="bytes_threshold">Próg bajtów</string>
    <string name="select_the_keylog_file">Wybierz plik SSL keylog</string>
    <string name="error_code_with_text">%1$s (błąd %2$d)</string>
    <string name="errno_epipe">Przerwany potok</string>
    <string name="errno_epipe_msg">Serwer niespodziewanie zamknął połączenie podczas przesyłania danych</string>
    <string name="errno_enetdown">Sieć jest wyłączona</string>
    <string name="errno_enetdown_msg">Interfejs sieciowy jest wyłączony lub nie może połączyć się z siecią</string>
    <string name="errno_enetunreach">Sieć jest nieosiągalna</string>
    <string name="errno_enetunreach_msg">System nie może znaleźć prawidłowej trasy do sieci docelowej</string>
    <string name="errno_enetreset">Reset sieci</string>
    <string name="errno_enetreset_msg">Połączenie sieciowe zostało zresetowane przez urządzenie pośredniczące (np. router lub operator komórkowy)</string>
    <string name="errno_econnaborted">Połączenie przerwane</string>
    <string name="errno_econnaborted_msg">Połączenie zostało przerwane, zwykle z powodu zmiany sieci</string>
    <string name="errno_econnreset">Połączenie zresetowane przez drugą stronę</string>
    <string name="errno_econnreset_msg">Serwer nagle zamknął połączenie, zwykle z powodu awarii lub nieprawidłowego zamknięcia</string>
    <string name="errno_etimedout">Przekroczono limit czasu połączenia</string>
    <string name="errno_etimedout_msg">Serwer zbyt długo nie odpowiadał, prawdopodobnie z powodu opóźnień sieci lub obciążonego serwera</string>
    <string name="errno_econnrefused">Połączenie odrzucone</string>
    <string name="errno_econnrefused_msg">Serwer odrzucił połączenie, co może oznaczać zbyt obciążony lub wadliwy serwer</string>
    <string name="errno_ehostunreach">Brak trasy do hosta</string>
    <string name="errno_ehostunreach_msg">System nie może znaleźć trasy do hosta docelowego</string>
    <string name="dns_conn_info">DNS tłumaczy nazwę domeny na adres IP. Właściwe dane są zazwyczaj wymieniane przez kolejne połączenia HTTPS/TLS</string>
    <string name="tls_conn_info">Ruch TLS/HTTPS jest zaszyfrowany. Aby zbadać ten ruch, musisz go odszyfrować. Sprawdź <a href="%1$s">podręcznik użytkownika</a> PCAPdroid, aby uzyskać szczegóły</string>
    <string name="tls_decryption_not_supported_16KB">Deszyfrowanie TLS nie jest obecnie obsługiwane na urządzeniach 16 KB</string>
    <string name="filename_prefix">Prefiks nazwy pliku</string>
    <string name="filename_prefix_description">Ustaw prefiks plików eksportowanych przez PCAPdroid, np. plików PCAP</string>
    <string name="no_requests">Brak żądań</string>
    <string name="item_not_found">Nie można znaleźć określonego elementu</string>
    <string name="connection_number">Połączenie #%1$d</string>
    <string name="http_request_number">Żądanie HTTP #%1$d</string>
    <string name="http_requests">Żądania HTTP</string>
    <string name="switch_to_http">Pokaż żądania HTTP</string>
    <string name="switch_to_connections">Pokaż połączenia</string>
    <string name="decryption_error">Błąd deszyfrowania</string>
    <string name="previous">Wstecz</string>
    <string name="next">Dalej</string>
    <string name="save_as_text">Zapisz jako tekst</string>
    <string name="save_as_har">Zapisz jako HAR</string>
    <string name="mitm_addon_starting">Dodatek Mitm jest uruchamiany…</string>
    <string name="tcp_udp_exporter">Eksport TCP/UDP</string>
    <string name="tcp_exporter_info">Wyślij PCAP do zdalnego odbiornika TCP (pcap-over-ip)</string>
    <string name="ipv6_bytes_sent">Wysłane bajty IPv6</string>
    <string name="ipv6_bytes_rcvd">Odebrane bajty IPv6</string>
    <string name="copy_error">Nie można zapisać pliku</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="dump_extensions">Rozszerzenie PCAPdroid</string>
    <string name="dump_extensions_summary">Rozszerz format zrzutu pakietów o dodatkowe metadane, takie jak aplikacja, która wysłała/odebrała dany pakiet</string>
    <string name="no_permissions_set_info">Brak przyznanych uprawnień. Wywołaj PCAPdroid przez StartActivityForResult, aby wyświetlić monit przyznania uprawnień</string>
    <string name="generate_api_key">Wygeneruj klucz API</string>
    <string name="show_api_key">Pokaż klucz API</string>
    <string name="api_key">klucz API</string>
    <string name="api_key_discard_confirm">Czy na pewno zastąpić obecny klucz API nowym?</string>
    <string name="malicious_connection_description">Połączenie z aplikacji \"%1$s\" aktywowało zasady wykrywania złośliwego oprogramowania (%2$s)</string>
    <string name="malicious_connections_notice">Czarne listy mogą zawierać fałszywe trafienia. Upewnij się, że sprawdziłeś reputację adresu IP/domeny online. Fałszywe trafienia możesz wykluczyć przez białą listę</string>
    <string name="export_ellipsis">Eksportuj…</string>
    <string name="update_available">Dostępna jest aktualizacja</string>
    <string name="mitm_addon_update_available">Dostępna jest aktualizacja dodatku mitm. Pobierz, by otrzymać najnowsze poprawki</string>
    <string name="update_action">Aktualizuj</string>
    <string name="pcap_load_in_progress">Trwa ładowanie pliku przechwytywania, proszę czekać</string>
    <string name="geo_db_missing">Brak bazy danych geolokalizacji</string>
    <string name="ip_address_or_cidr">adres IP / CIDR</string>
    <string name="decryption_rules">Reguły rozszyfrowywania</string>
    <string name="decrypt_action">Rozszyfruj…</string>
    <string name="dont_decrypt_action">Nie deszyfruj…</string>
    <string name="status_encrypted">Zaszyfrowane</string>
    <string name="injected">Wstrzyknięte</string>
    <string name="open_pcap_file">Otwórz plik PCAP/Pcapng…</string>
    <string name="pcap_load_success">Załadowano plik przechwytywania</string>
    <string name="unsupported_pcap_file">Nieobsługiwany format pliku przechwytywania</string>
    <string name="decrypt_pcap_file">Rozszyfruj plik PCAP/Pcapng…</string>
    <string name="invalid_pcap_file">Błędny format pliku przechwytywania</string>
    <string name="capture_interface_open_error">Nie można otworzyć interfejsu przechwytywania</string>
    <string name="unsupported_pcap_datalink">Plik zawiera nieobsługiwany typ łącza danych</string>
    <string name="pcap_file_not_exists">Wskazany plik nie istnieje</string>
    <string name="root_capture_start_failed">Przechwytywanie nie powiodło się. Upewnij się, że urządzenie jest zrootowane za pomocą Magiska</string>
    <string name="root_capture_pcapd_start_failure">Przechwytywanie nie powiodło się. Upewnij się, że PCAPdriod ma uprawnienia roota</string>
    <string name="pcap_read_error">Błąd podczas odczytu pliku przechwytywania. Sprawdź log, aby uzyskać szczegóły</string>
    <string name="host_resolution_failed">Nie można rozwiązać hosta %1$s</string>
    <string name="pcapdroid_trailer_notice">Aby wyświetlić prawdziwe aplikacje zamiast \"%1$s\", włącz opcję \"%2$s\" przed generowaniem zrzutu</string>
    <string name="tls_decryption_no_rules_notice">Deszyfrowanie TLS jest stosowane tylko do połączeń pasujących do skonfigurowanych reguł. Czy chcesz teraz utworzyć reguły deszyfrowania?</string>
    <string name="always">Zawsze</string>
    <string name="headers">Nagłówki</string>
    <string name="body">Ciało</string>
    <string name="both">Oba</string>
    <string name="whats_new">Co nowego</string>
    <string name="raw_bytes">Surowe dane</string>
    <string name="restart_on_disconnection_summary">Automatycznie wznów przechwytywanie po zatrzymaniu przez inne aplikacje VPN</string>
    <string name="waiting_for_vpn_disconnect">Oczekiwanie na zakończenie aktywnego połączenia VPN…</string>
    <string name="select_the_pcap_file">Wybierz plik PCAP/Pcapng</string>
    <string name="proxy_host">Host usługi Proxy</string>
</resources>

```

`app/src/main/res/values-pt-rBR/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">Iniciar</string>
    <string name="stop_button">Parar</string>
    <string name="title_activity_settings">Configurações</string>
    <string name="collector_info">Coletor UDP: %1$s:%2$d</string>
    <string name="http_server_status">Servidor HTTP: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s recebidos — %2$s enviados</string>
    <string name="query">Consulta</string>
    <string name="host">Host</string>
    <string name="ready">Pronto</string>
    <string name="about">Sobre</string>
    <string name="status">Status</string>
    <string name="connections_view">Conexões</string>
    <string name="no_connections">Nenhuma conexão</string>
    <string name="connection_details">Detalhes da conexão</string>
    <string name="app">App</string>
    <string name="protocol">Protocolo</string>
    <string name="source">Fonte</string>
    <string name="destination">Destino</string>
    <string name="packets">Pacotes</string>
    <string name="duration">Duração</string>
    <string name="http_server">Servidor HTTP</string>
    <string name="udp_exporter">Exportador UDP</string>
    <string name="no_dump">Sem dump</string>
    <string name="no_dump_info">O tráfego não será despejado</string>
    <string name="http_server_info">Inicia um servidor HTTP para o download do PCAP</string>
    <string name="udp_exporter_info">Envia o PCAP para um receptor UDP remoto</string>
    <string name="http_server_port">Porta do servidor HTTP</string>
    <string name="receiver_ip_address">Endereço IP do coletor</string>
    <string name="receiver_port">Porta do coletor</string>
    <string name="user_guide">Guia de usuario</string>
    <string name="open_telegram_group">Grupo no Telegram</string>
    <string name="source_code">Código-fonte</string>
    <string name="yes">Sim</string>
    <string name="no">Não</string>
    <string name="vpn_setup_failed">A Configuração da VPN falhou. Certifique-se de que a VPN Always-on esteja desabilitada</string>
    <string name="app_not_found">O app %1$s não foi encontrado</string>
    <string name="stats">Estatísticas</string>
    <string name="active_connections">Conexões ativas</string>
    <string name="dropped_connections">Conexões interrompidas</string>
    <string name="tot_connections">Total de conexões</string>
    <string name="open_sockets">Sockets abertos</string>
    <string name="bytes_sent">Bytes enviados</string>
    <string name="bytes_rcvd">Bytes recebidos</string>
    <string name="packets_sent">Pacotes enviados</string>
    <string name="packets_rcvd">Pacotes recebidos</string>
    <string name="dns_queries">Consultas do DNS</string>
    <string name="search_apps">Buscar apps</string>
    <string name="no_apps">Nenhum app</string>
    <string name="dns_server">Servidor do DNS</string>
    <string name="apps">Apps</string>
    <string name="pcap_file">Arquivo PCAP</string>
    <string name="pcap_file_info">Crie um arquivo PCAP/Pcapng no armazenamento do dispositivo</string>
    <string name="cannot_write_file">Não foi possível salvar no arquivo</string>
    <string name="share">Compartilhar</string>
    <string name="delete">Excluir</string>
    <string name="ok">OK</string>
    <string name="pcap_file_action">Tráfego salvo no arquivo \"%1$s\" (%2$s)</string>
    <string name="delete_error">Não foi possível apagar o arquivo</string>
    <string name="capture_running">Captura em execução</string>
    <string name="notification_msg">%1$s capturados, %2$s conexões</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">Começou</string>
    <string name="last_seen">Última atividade</string>
    <string name="conn_status_closed">Fechado</string>
    <string name="copy_to_clipboard">Copiar</string>
    <string name="save_to_file">Salvar em arquivo</string>
    <string name="older_connections_notice">%1$d conexões antigas não exibidas</string>
    <string name="about_text">PCAPdroid é uma ferramenta de captura e monitoramento de rede de software livre que funciona sem privilégios root</string>
    <string name="get_app">Baixe:</string>
    <string name="unknown_app">Desconhecido</string>
    <string name="error">Erro</string>
    <string name="conn_status_unreachable">Inacessível</string>
    <string name="other_prefs">Outro</string>
    <string name="app_language">Idioma do app</string>
    <string name="system_default">Padrão do Sistema</string>
    <string name="no_activity_file_selection">Não foi encontrado nenhum app de seleção de arquivos</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="proxy_port">Porta do proxy</string>
    <string name="root_capture">Capturar como root</string>
    <string name="donate">Doar</string>
    <string name="search">Buscar…</string>
    <string name="app_val">App: %1$s</string>
    <string name="ip_address_val">Endereço IP: %1$s</string>
    <string name="host_val">Host: %1$s</string>
    <string name="protocol_val">Protocolo: %1$s</string>
    <string name="n_selected">%1$d selecionado</string>
    <string name="select_all">Selecionar tudo</string>
    <string name="app_details">Detalhes do app</string>
    <string name="package_name">Nome do pacote</string>
    <string name="uid">UID</string>
    <string name="app_name">Nome</string>
    <string name="version">Versão</string>
    <string name="target_sdk">SDK alvo</string>
    <string name="installed_on">Instalado em</string>
    <string name="last_update">Última atualização</string>
    <string name="permissions">Permissões</string>
    <string name="root_app_info">Daemons do sistema funcionando com privilégios máximos</string>
    <string name="netd_app_info">Daemon de sistema que realiza as resoluções do DNS</string>
    <string name="android_app_info">Sistema do Android</string>
    <string name="unknown_app_info">\"Desconhecido\" indica as conexões do app que não podiam ser determinadas</string>
    <string name="packets_dropped">Pacotes desconsiderados</string>
    <string name="capture_prefs">Capturar</string>
    <string name="pending_transaction">Por favor, finalize a transação para liberar esta funcionalidade</string>
    <string name="ctrl_consent">Um app quer capturar o tráfego no seu dispositivo.
\nSe não tiver certeza, melhor recusar</string>
    <string name="deny">Recusar</string>
    <string name="allow">Permitir</string>
    <string name="ctrl_consent_title">Solicitação de controle por PCAPdroid</string>
    <string name="ctrl_consent_denied">PCAPdroid: a solicitação de controle foi negada</string>
    <string name="ctrl_consent_allowed">PCAPdroid: a solicitação de controle foi concedida</string>
    <string name="capture_interface">Interface de captura</string>
    <string name="internet">Internet</string>
    <string name="all_interfaces">Todas interfaces</string>
    <string name="capturing_from">Capturando pacotes de \"%1$s\"</string>
    <string name="root_capture_summary">Permite que o PCAPdroid funcione com outros apps da VPN</string>
    <string name="hide">Esconder…</string>
    <string name="edit_filter">Editar filtro</string>
    <string name="edit_list">Editar lista</string>
    <string name="hidden_connections_rules">Regras de conexões ocultas</string>
    <string name="list_is_empty">A lista está vazia</string>
    <string name="show_only_malicious">Conexão maliciosa</string>
    <string name="security">Segurança</string>
    <string name="malware_detection">Detecção de malware</string>
    <string name="reset">Redefinir</string>
    <string name="malware_whitelist_rules">Regras da lista de permitidos de malware</string>
    <string name="feature_not_available">Esta funcionalidade está atualmente indisponível para seu dispositivo</string>
    <string name="billing_connecting">A conexão com Google Play está em andamento, por favor, tente novamente daqui a pouco</string>
    <string name="malware_whitelist_help">Lista de permitidos definida pelo usuário para impedir a detecção de malware. Faça clique longo em conexões maliciosas para criar regras que marcam as como não nocivas</string>
    <string name="hidden_connections_help">Lista de regras que escondem entradas da lista de conexões a fim de mostrar apenas relevantes</string>
    <string name="not_hidden_filter">Não oculto</string>
    <string name="copy_action">Copiar…</string>
    <string name="url_val">URL: %1$s</string>
    <string name="show_me">Mostrar</string>
    <string name="hint">Dica</string>
    <string name="once">Uma vez</string>
    <string name="forever">Sempre</string>
    <string name="control_permissions">Permissões de controle</string>
    <string name="control_permissions_summary">Verifique quais apps são permitidos para controlar a captura do PCAPdroid</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">País</string>
    <string name="asn">ASN</string>
    <string name="country_val">País: %1$s</string>
    <string name="malware_status_detected">Conexões maliciosas detectadas</string>
    <string name="blacklists">Lista de proibidos</string>
    <string name="status_outdated">Desatualizado</string>
    <string name="status_not_loaded">Não carregado</string>
    <string name="status_uptodate">Atualizado</string>
    <string name="blacklist_type">Tipo: %1$s</string>
    <string name="blacklist_type_domain">Lista de domínios proibidos</string>
    <string name="last_update_val">Última atualização: %1$s</string>
    <string name="malicious_connections">Conexões maliciosas</string>
    <string name="updated_blacklists">Lista de proibidos atualizada</string>
    <string name="connections_checked">Conexões verificadas</string>
    <string name="last_blacklists_update">Última atualização</string>
    <string name="domain_rules">Regras de domínio</string>
    <string name="ip_rules">Regras de IPs</string>
    <string name="malware_status_update_failed">Algumas listas de proibidos estão desatualizadas</string>
    <string name="update_now">Atualizar agora</string>
    <string name="status_updating">Atualizando…</string>
    <string name="malware_detection_learn_more">Saiba mais sobre a funcionalidade da detecção de malware</string>
    <string name="firewall">Firewall</string>
    <string name="firewall_rules">Regras do firewall</string>
    <string name="blocked_pkts">Bloqueado</string>
    <string name="n_pkts">%1$s pcts</string>
    <string name="blocked_connection_filter">Bloqueado</string>
    <string name="paid_features">Funcionalidades não gratuitas</string>
    <string name="validate">Validar</string>
    <string name="interface_filter">Interface: %1$s</string>
    <string name="loading">Carregando…</string>
    <string name="capture_not_running_status">A captura não está executada</string>
    <string name="start_capture_first">Primeiro execute a captura</string>
    <string name="copied">Copiado</string>
    <string name="can_use_purchased_feature">Agora você pode usar a funcionalidade adquirida</string>
    <string name="disconnect_vpn_confirm">Continuar desconectará a VPN ativa</string>
    <string name="loading_apps">Carregando apps…</string>
    <string name="open_nav_drawer">Abrir menu</string>
    <string name="close_nav_drawer">Fechar menu</string>
    <string name="capture_all_apps">Capturar tráfego de todos os apps</string>
    <string name="save_ok">Salvo</string>
    <string name="malicious_connection_filter">Malicioso</string>
    <string name="status_filter">HTTP Status: %1$s</string>
    <string name="file_saved_with_name">Arquivo salvo como \"%1$s\"</string>
    <string name="enable_socks5_proxy_summary">Redirecionar todas as conexões TCP para o proxy SOCKS5 especificado</string>
    <string name="malware_detection_summary">Detectar as conexões com hosts maliciosos conhecidos via lista de proibidos de terceiros</string>
    <string name="send_report">Enviar relatório</string>
    <string name="start_at_boot">Executar ao iniciar</string>
    <string name="start_at_boot_summary">Captura automática após iniciar</string>
    <string name="malware_status_ok">Nenhum tráfego malicioso detectado</string>
    <string name="whitelist">Lista de permitidos</string>
    <string name="blacklist_type_ip">Lista de IPs proibidos</string>
    <string name="n_rules">%1$s regras</string>
    <string name="private_dns_message_notice">DNS privado impede o PCAPdroid de analisar o tráfego do DNS. Você pode desligá-lo em configurações da rede no Android</string>
    <string name="private_dns_hinders_detection">DNS privado impede a detecção</string>
    <string name="decryption_no_filter_warn">Selecione um app alvo ao descriptografar o TLS para evitar a perda da sua conexão com a internet</string>
    <string name="block">Bloquear…</string>
    <string name="valid">Válido</string>
    <string name="invalid">Inválido</string>
    <string name="no_intent_handler_found">Nenhum app encontrado para realizar esta ação</string>
    <string name="network_interface">Interface</string>
    <string name="billing_failure">Não foi possível conectar-se ao Google Play. Por favor, tente novamente daqui a pouco</string>
    <string name="learn_more">Saiba mais</string>
    <string name="purchased">Adquirido</string>
    <string name="no_items_for_purchase">Nenhum item disponível para comprar</string>
    <string name="buy_action">Comprar</string>
    <string name="allowed_connection_filter">Permitido</string>
    <string name="vpn_lockdown_notice">Para evitar que apps acessem a internet quando o PCAPdroid não estiver funcionando (p.ex., após uma reinicialização) você pode configurar o PCAPdroid como uma VPN sempre ligada no modo de bloqueio.
\n
\nVocê quer abrir as configurações da VPN agora\?</string>
    <string name="low_memory">Baixa memória</string>
    <string name="low_memory_info">O app está ficando sem memória, espere travamentos</string>
    <string name="full_payload_disabled">A opção do payload total foi desativada</string>
    <string name="ip_both">IPv4 e IPv6</string>
    <string name="capture_stopped_low_memory">A captura foi interrompida</string>
    <string name="memory_usage">Uso da memória</string>
    <string name="heap_usage">Uso do heap</string>
    <string name="ipv6_only">Somente IPv6</string>
    <string name="firewall_filter">Firewall: %1$s</string>
    <string name="mitm_addon_new_version">O complemento PCAPdroid mitm deve ser atualizado</string>
    <string name="app_intro_traffic_dump">O PCAPdroid oferece <a href="%1$s">várias maneiras</a> de despejar o tráfego no formato PCAP padrão para análise posterior.\n\nAtravés da <a href="%2$s">opção de extensões do PCAPdroid</a>, você pode adicionar nomes de aplicativos aos pacotes e exibi-los no Wireshark.</string>
    <string name="permission_granted">%1$s permissão foi concedida</string>
    <string name="permission_grant_fail">%1$s a permissão não pôde ser concedida</string>
    <string name="connection_not_found">Não foi possível encontrar a conexão referida</string>
    <string name="ca_cert_export_failed">Ocorreu um erro durante a exportação do certificado CA
\n
\nSe seu dispositivo implementa a iniciação automática ou solução similar para limitar a execução de serviços em segundo plano, certifique-se de incluir <a href="%1$s">PCAPdroid na lista de permitidos</a></string>
    <string name="geolocation_summary">Mostrar informações sobre o país e o ASN realizando pesquisas offline</string>
    <string name="geo_db_delete">Toque para excluir a base de dados e preservar o espaço</string>
    <string name="action_block">Bloquear</string>
    <string name="action_unblock">Desbloquear</string>
    <string name="app_intro_geolocation_msg">PCAPdroid pode consultar uma base de dados local para determinar o país de um servidor remoto
\n
\nPrimeiro você deve baixar a base de dados com geolocalização em configurações do aplicativo</string>
    <string name="app_intro_malware_detection">Aumente a segurança do seu dispositivo com a funcionalidade da <a href="%1$s">detecção do malware</a>
\n
\nAo usar listas atualizadas de não permitidos, você pode detectar, bloquear e receber alertas sobre as conexões maliciosas em tempo real</string>
    <string name="ip_mode">Endereços IP da VPN</string>
    <string name="ipv4_only">Somente IPv4</string>
    <string name="traffic_dump">Dump do tráfego</string>
    <string name="conn_status_active">Ativo</string>
    <string name="phone_app">Telefone</string>
    <string name="socks5_info">Proxy de SOCKS5: %1$s:%2$d</string>
    <string name="phone_app_info">Serviço de telefonia</string>
    <string name="unblock">Desbloquear…</string>
    <string name="tls_decryption">Decriptação do TLS</string>
    <string name="tls_decryption_summary">Decripte o tráfego SSL/TLS via mitm. Isto agora pode funcionar com alguns apps, confira o guia de usuario</string>
    <string name="traffic_inspection">Inspeção de tráfego</string>
    <string name="mitm_start_failed">Não foi possível iniciar o serviço mitm. Tente abrir o aplicativo complementar mitm manualmente e tente novamente.</string>
    <string name="mitm_setup_wizard">Assistente de configuração do mitm</string>
    <string name="checking_the_certificate">Verificando o certificado…</string>
    <string name="cert_exported_now_installed">Certificado exportado, agora instale-o em configurações do Android</string>
    <string name="cert_installed_correctly">O certificado CA está instalado</string>
    <string name="cert_reinstall_required">O certificado CA não está instalado, execute o assistente de configuração do mitm</string>
    <string name="export_failed">Exportação falhou</string>
    <string name="string_http_request">Solicitação HTTP</string>
    <string name="websocket">WebSocket</string>
    <string name="welcome_to_pcapdroid">Bem-vindo ao PCAPdroid</string>
    <string name="app_intro_welcome_msg">PCAPdroid é um aplicativo que respeita sua privacidade e permite rastrear e analisar as conexões feitas pelos apps no seu dispositivo
\n
\nAlém disso, permite que você exporte PCAP dump do tráfego, extraia metadados e muito mais!</string>
    <string name="privacy_first">Privacidade em primeiro lugar</string>
    <string name="country_and_asn">País e ASN</string>
    <string name="install_action">Instalar</string>
    <string name="export_action">Exportar</string>
    <string name="export_ca_certificate">Exporte o certificado PCAPdroid CA, logo abra em configurações do Android \"Criptografia e Credenciais\" e escolha instalar como um \"certificado CA\"</string>
    <string name="install_ca_certificate">Instale o certificado PCAPdroid CA, escolhendo \"VPN e aplicativos\". O Android solicitará desbloqueio da tela ou a senha</string>
    <string name="mitm_addon_bad_version">A versão da extensão de mitm do PCAPdroid é incorreta. Instale a versão %1$s e tente novamente</string>
    <string name="not_encrypted">Não criptografado</string>
    <string name="request">Solicitação</string>
    <string name="response">Resposta</string>
    <string name="overview">Visão geral</string>
    <string name="string_http_response">Resposta HTTP</string>
    <string name="tx_direction">TX</string>
    <string name="rx_direction">RX</string>
    <string name="payload_truncated">A carga útil está truncada. Para exibi-la na íntegra, interrompa a captura e ative \"%1$s\" nas configurações do PCAPdroid.</string>
    <string name="http">HTTP</string>
    <string name="payload">Payload</string>
    <string name="full_payload_summary">Mostrar o payload total de conexões (p.ex. a solicitação e resposta de HTTP completa). Isto requer muita memória, não use a longo prazo</string>
    <string name="full_payload">Payload total</string>
    <string name="not_decryptable">Não decodificável</string>
    <string name="decrypted">Descriptografado</string>
    <string name="decryption">Decriptação</string>
    <string name="decryption_filter">Status: %1$s</string>
    <string name="connection_start_not_seen">O PCAPdroid ainda não examinou o início desta conexão. Algumas informações podem estar faltando</string>
    <string name="network_traffic">Tráfego</string>
    <string name="warn_no_app_data">Nenhum dado do app foi intercambiado</string>
    <string name="waiting_application_data">Aguardando dados</string>
    <string name="hexdump">Hexdump</string>
    <string name="geolocation">Geolocalização</string>
    <string name="downloading">Baixando…</string>
    <string name="download_in_progress">Download em execução, por favor aguarde</string>
    <string name="download_failed">Download falhou</string>
    <string name="geo_db_not_found">Base de dados não encontrada. A geolocalização está desativada</string>
    <string name="geo_db_download">Toque para baixar a base de dados mais recente. Novas versões estão disponíveis mensalmente</string>
    <string name="size_x">Tamanho: %1$s</string>
    <string name="download">Download</string>
    <string name="database">Base de dados</string>
    <string name="built_on">Compilado em: %1$s</string>
    <string name="connection_blocked">Esta conexão foi bloqueada pelo PCAPdroid</string>
    <string name="import_action">Importar</string>
    <string name="import_failed">Importação falhou</string>
    <string name="invalid_backup">Formato do backup inválido</string>
    <string name="rules_import_success">Importadas %1$d regras</string>
    <string name="no_rules_to_export">Nenhuma regra para exportar</string>
    <string name="rules_merge_msg">Manter as regras existentes\?</string>
    <string name="keep_action">Manter</string>
    <string name="discard_action">Descartar</string>
    <string name="rules_delete_confirm">Apagar as regras selecionadas\?</string>
    <string name="blocklist">Lista de não permitidos</string>
    <string name="num_configured_rules">Regras configuradas</string>
    <string name="connections_blocked">Conexões bloqueadas</string>
    <string name="last_firewall_block">Último bloco</string>
    <string name="firewall_is_disabled">Firewall está desativado</string>
    <string name="firewall_is_enabled">Firewall está ativado</string>
    <string name="app_info">Sobre o app</string>
    <string name="firewall_summary">Bloquear o acesso à internet para apps, configurar regras para domínios específicos e endereços IP. Funciona somente com a captura não-root</string>
    <string name="netd_block_missed">Esta conexão foi iniciada pela netd por isso não pôde ser bloqueada</string>
    <string name="no_root_firewall">Firewall não-root</string>
    <string name="block_quick">Bloquear QUIC</string>
    <string name="block_private_dns">Bloquear DNS privado</string>
    <string name="mitm_setup_wizard_intro">Este assistente mostrará você como instalar a extensão de mitm do PCAPdroid e autoridade de certificação, que são necessários para realizar a <a href="%1$s">Decriptação do TLS</a></string>
    <string name="app_intro_skip_button">Pular</string>
    <string name="mitm_setup_wizard_done">O PCAPdroid está pronto para decodificar o tráfego do TLS
\n
\nConfira o <a href="%1$s">guia de usuário</a> para saber mais sobre as medidas de segurança que podem impedir a decriptação e como contorná-la</string>
    <string name="app_intro_next_button">Próximo</string>
    <string name="app_intro_back_button">Voltar</string>
    <string name="app_intro_done_button">Concluído</string>
    <string name="vpn_setup_msg">PCAPdroid simula uma VPN a fim de capturar o tráfego da rede sem privilégios root.
\n
\nPara iniciar a captura, você precisa aceitar o pedido da VPN na próxima tela</string>
    <string name="app_intro_traffic_inspection">A inspeção de solicitações HTTP, respostas e dados brutos (raw) é muito fácil, graças aos decodificadores integrados
\n
\nTem uma conexão criptografada\? Você pode ativar a <a href="%1$s">decriptação do TLS</a> para ver os dados descriptografados</string>
    <string name="app_intro_firewall_msg">Com o <a href="%1$s">Firewall</a> integrado, você pode bloquear facilmente o acesso à internet para aplicativos, domínios e países individuais.\n\nCombine isso com a visibilidade de tráfego integrada para obter a ferramenta definitiva para proteger sua privacidade.</string>
    <string name="app_intro_privacy_msg">O app não implementa nenhuma funcionalidade de rastreamento, análise ou conexão com serviços externos
\n
\nComo posso ter certeza\? Confira a <a href="%1$s">política de privacidade</a> e o <a href="%2$s">código-fonte</a></string>
    <string name="block_private_dns_summary">Detectar e possivelmente bloquear o DNS privado para inspecionar o tráfego do DNS. Ao desabilitar isso você pode dificultar a análise do tráfego</string>
    <string name="vpn_exemptions">Exceções da VPN</string>
    <string name="vpn_exemptions_summary">Excluir alguns apps da conexão VPN. O tráfego deles não será monitorado</string>
    <string name="no_matches_found">Nada corresponde</string>
    <string name="cleartext_connection">Legível</string>
    <string name="app_blocked">App bloqueado</string>
    <string name="app_blocked_info">O app %1$s foi bloqueado pelo firewall</string>
    <string name="show_only_cleartext">Conexões em texto puro</string>
    <string name="notifications_notice">O app usa notificações para mostrar alertas em caso de eventos anormais. Conceda a permissão na próxima tela para receber notificações</string>
    <string name="unblock_permanently">Desbloquear permanentemente</string>
    <string name="unblock_for_n_hours">Desbloquear por %1$dh</string>
    <string name="block_new_apps">Bloquear apps recém instalados</string>
    <string name="cancel_action">Cancelar</string>
    <string name="remote_collector_notice">Você configurou o PCAPdroid permitindo o envio de tráfego a um servidor remoto. Aquele servidor será capaz de acessar suas informações confidenciais.
\n
\nSe alguém te pediu para fazer isso, provavelmente é uma tentativa de fraude</string>
    <string name="remote_server_warning">Por razões de segurança, não é permitido enviar o tráfego ao servidor remoto \"%1$s\"</string>
    <string name="show_data_action">Mostrar dados</string>
    <string name="payload_scams_notice">Esta visualização pode conter informações sensíveis, como suas senhas e tokens de acesso.
\n
\nNunca forneça estas informações a ninguém, pode ser uma tentativa de fraude</string>
    <string name="unblock_for_n_minutes">Desbloquear por %1$dm</string>
    <string name="app_unblocked">O %1$s app foi desbloqueado</string>
    <string name="paid_features_unlocked">Funcionalidades pagas desbloqueadas. Reinicie a captura se estiver funcionando</string>
    <string name="build_info">Detalhes da compilação</string>
    <string name="install_the_mitm_addon">Instalar a <a href="%1$s">extensão de mitm</a> do PCAPdroid</string>
    <string name="warning">Aviso</string>
    <string name="tls_decryption_with_root_msg">A capacidade de executar a descriptografia TLS com root é um recurso experimental. Esta é uma lista de bugs conhecidos:\n\n- no PCAPdroid, você verá o tráfego conforme gerado pelo aplicativo mitm-addon no lugar do aplicativo original\n\n- o dump do keylog SSL não é suportado\n\n- quando um filtro de aplicativo estiver definido, a descriptografia ocorrerá apenas para o aplicativo de destino, mas o PCAPdroid ainda mostrará o tráfego dos outros aplicativos\n\n- se a captura falhar ao iniciar, certifique-se de que você pode executar o comando iptables como root (por exemplo, via termux)\n\n- isso pode não funcionar no Android 12 e versões posteriores\n\n- se um aplicativo VPN estiver em execução, você deve direcionar um aplicativo específico para descriptografia ou excluir o complemento mitm do PCAPdroid da VPN, caso contrário, o tráfego entrará em loop</string>
    <string name="mitm_skip_notice">O certificado de mitm não parece estar instalado. Se continuar, o processo de decriptação pode falhar</string>
    <string name="mitm_wizard_description">Configurar o dispositivo para a decriptação do TLS</string>
    <string name="paid_feature">Funcionalidades não gratuitas</string>
    <string name="firewall_purchase_msg">Adquira a funcionalidade <i>%1$s</i> para começar a bloquear conexões</string>
    <string name="unlock_token_summary">Um token que pode ser usado para desbloquear as funcionalidades pagas em versões do app que não são da loja do Google Play (p.ex. de fontes como F-Droid/Github)</string>
    <string name="unlock_token_error">Não foi possível solicitar um token de desbloqueio [%1$d]: %2$s</string>
    <string name="access_paid_features_msg">Confira <a href="%1$s">o guia do usuário</a> para ver como acessar as funcionalidades pagas</string>
    <string name="license_service_unavailable">O serviço de licença do PCAPdroid não está disponível no momento. Tente novamente em alguns minutos</string>
    <string name="requesting_unlock_token">Solicitando um token de desbloqueio, aguarde</string>
    <string name="show_action">Mostrar</string>
    <string name="unlock_token_msg1">Este é seu token de desbloqueio. Anote-o, porque será preciso <a href="%1$s">para gerar seus códigos de licença</a></string>
    <string name="app_log">Log</string>
    <string name="no_data">Sem dados</string>
    <string name="socks5_auth_summary">Faça a autenticação para o proxy via nome de usuário e senha</string>
    <string name="socks5_auth">Autenticação SOCKS5</string>
    <string name="ipv6_bytes_percentage">Porcentagem de bytes IPv6</string>
    <string name="socks5_summary">Configurar o redirecionamento para um proxy SOCKS5</string>
    <string name="socks5_redirection">Redirecionamento de SOCKS5</string>
    <string name="copy_error">Não foi possível salvar o arquivo</string>
    <string name="proxy_host">Endereço da Proxy</string>
    <string name="ipv6_bytes_sent">Bytes IPv6 enviados</string>
    <string name="ipv6_bytes_rcvd">Bytes IPv6 recebidos</string>
    <string name="tcp_collector_info">Coletor TCP: %1$s:%2$d</string>
    <string name="tcp_exporter">Exportador TCP</string>
    <string name="tcp_udp_exporter">Exportador TCP/UDP</string>
    <string name="tcp_exporter_info">Enviar o PCAP para um receptor TCP remoto (pcap-over-ip)</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="malware_whitelist_action">Lista de permissões (malware)…</string>
    <string name="dump_extensions">Extensões do PCAPdroid</string>
    <string name="dump_extensions_summary">Estenda o formato de despejo de pacotes com metadados adicionais, como o aplicativo que enviou/recebeu um determinado pacote</string>
    <string name="dump_extensions_how_to">Como exibir as extensões de despejo do PCAPdroid no Wireshark</string>
    <string name="no_permissions_set_info">Nenhuma permissão definida. Invoque o PCAPdroid via StartActivityForResult para exibir o prompt de permissões</string>
    <string name="generate_api_key">Gerar chave da API</string>
    <string name="show_api_key">Mostrar chave da API</string>
    <string name="api_key">Chave da API</string>
    <string name="api_key_discard_confirm">Você quer realmente descartar a chave da API atual e gerar uma nova?</string>
    <string name="malicious_connection_description">Uma conexão do aplicativo \"%1$s\" acionou uma regra de detecção de malware (%2$s)</string>
    <string name="malicious_connections_notice">As listas negras podem conter falsos positivos. Certifique-se de verificar a reputação do endereço IP/domínio online. Você pode excluir falsos positivos por meio da lista branca de malware</string>
    <string name="export_ellipsis">Exportar…</string>
    <string name="update_available">Atualização disponível</string>
    <string name="mitm_addon_update_available">Uma nova atualização do mitm está dísponivel. Atualize para obter as correções mais recentes</string>
    <string name="mitm_addon">Complemeto mitm</string>
    <string name="update_action">Atualizar</string>
    <string name="pcap_load_in_progress">O carregamento do arquivo de captura está em andamento, aguarde</string>
    <string name="geo_db_missing">Banco de dados de geolocalização ausente</string>
    <string name="country_rules_warning">Para usar regras de firewall baseadas em país, baixe o banco de dados de geolocalização nas configurações do PCAPdroid, caso contrário, as regras baseadas em país serão ineficazes</string>
    <string name="mitmproxy_opts">Configurações adicionais do proxy mitm</string>
    <string name="mitmproxy_opts_description">Fornecer opções adicionais para mitmproxy</string>
    <string name="mitm_addon_error">Erro ao iniciar o addon do mitm. Cheque o log para detalhes</string>
    <string name="whitelist_mode">Modo de lista de permissões</string>
    <string name="firewall_whitelist_notice">Neste modo, todas as conexões serão bloqueadas, a menos que sejam adicionadas manualmente à lista de permissões. Você pode perder notificações push sem uma lista de permissões adequada</string>
    <string name="firewall_whitelist_help">Estas regras especificam quais conexões permitir. As regras da lista de bloqueio têm prioridade sobre as regras da lista de permissão</string>
    <string name="add_to_fw_whitelist">Adicionar à lista de permissões do firewall</string>
    <string name="remove_from_fw_whitelist">Remover da lista de permissões do firewall</string>
    <string name="reset_stats_confirm">Você realmente quer zerar essas estatísticas?</string>
    <string name="port_mapping">Mapeamento de portas</string>
    <string name="port_mapping_summary">Configurar regras de mapeamento de porta para redirecionar conexões para um host ou porta diferente</string>
    <string name="add_action">Adicionar</string>
    <string name="redirect_to">Redirecionar para:</string>
    <string name="original_port">Porta original</string>
    <string name="required">Requerido</string>
    <string name="destination_port">Porta de destino</string>
    <string name="port_mapping_exists">Mapeamento de portas já definido</string>
    <string name="items_delete_confirm">Deletar os itens selecionados?</string>
    <string name="ip_address">Endereço IP</string>
    <string name="ip_address_or_cidr">Endereço IP / CIDR</string>
    <string name="rule_exists">Regra já definida</string>
    <string name="dns_servers">Servidores DNS</string>
    <string name="dns_servers_summary">Configure os servidores DNS a serem usados durante a captura</string>
    <string name="ipv4_dns_server">Servidor DNS IPv4</string>
    <string name="ipv6_dns_server">Servidor DNS IPv6</string>
    <string name="use_system_dns">Usar DNS do sistema</string>
    <string name="use_system_dns_summary">Usar o servidor DNS do sistema se possivel</string>
    <string name="external_storage_perm_required">A permissão de armazenamento externo é necessária</string>
    <string name="many_rules_warning">Você está tentando importar muitas regras, o que pode fazer com que o aplicativo pare de responder durante algumas interações. Deseja mesmo continuar?</string>
    <string name="pcapng_format">Formato Pcapng</string>
    <string name="pcapng_format_summary">Pacotes de despejo no formato de despejo Pcapng, que é mais flexível e permite incorporar segredos de descriptografia TLS</string>
    <string name="sort_by">Ordenar por</string>
    <string name="total_bytes">Bytes totais</string>
    <string name="write_ext_storage_failed">Ocorreu um erro ao escrever no armazenamento externo. Cheque o log do app para detalhes</string>
    <string name="username">Nome de usuario</string>
    <string name="password">Senha</string>
    <string name="mitm_addon_autostart_workaround">A conexão com o complemento mitm falhou. Como solução alternativa, você pode tentar abrir o aplicativo do complemento mitm e depois voltar para o PCAPdroid sem fechá-lo. Deseja abri-lo agora?</string>
    <string name="qr_license_confirm">Deseja gerar uma licença para o dispositivo \"%1$s\" usando o seguinte token de desbloqueio?</string>
    <string name="invalid_license">Licença inválida</string>
    <string name="connection_error">Erro de conexão:%1$s</string>
    <string name="activate_via_qr_code">Ativar via QR Code</string>
    <string name="qr_code_expired">O código QR expirou. Gere um novo código QR e tente novamente</string>
    <string name="qr_info_text">Instale o PCAPdroid do Google Play e escaneie este código QR</string>
    <string name="qr_purchase_required">Compre um token de desbloqueio para prosseguir com a ativação do código QR</string>
    <string name="license_limit_reached">Você atingiu o limite de licenças para este token de desbloqueio. Compre um novo token para gerar mais licenças</string>
    <string name="license_error">Erro de geração de licença [%1$d]: %2$s</string>
    <string name="requesting_license">Solicitando um código de licença, aguarde</string>
    <string name="license_activation_ok">Ativação da licença concluída</string>
    <string name="mitm_addon_starting">O complemento Mitm está iniciando…</string>
    <string name="mitm_addon_running">O complemento Mitm está em execução</string>
    <string name="decryption_rules">Regras de descriptografia</string>
    <string name="decryption_rules_help">Essas regras especificam quais conexões devem ser descriptografadas. As regras baseadas em host só funcionam se uma resposta DNS anterior for vista</string>
    <string name="decrypt_action">Descriptografar…</string>
    <string name="dont_decrypt_action">Não descriptografar…</string>
    <string name="status_encrypted">Criptografado</string>
    <string name="injected">Injetado</string>
    <string name="open_pcap_file">Abrir arquivo PCAP/Pcapng…</string>
    <string name="pcap_load_success">Arquivo de captura carregado</string>
    <string name="unsupported_pcap_file">Formato de arquivo de captura não suportado</string>
    <string name="decrypt_pcap_file">Descriptografar arquivo PCAP/Pcapng…</string>
    <string name="invalid_pcap_file">Formato de arquivo de captura inválido</string>
    <string name="capture_interface_open_error">Não foi possível abrir a interface de captura</string>
    <string name="unsupported_pcap_datalink">O arquivo tem um datalink não suportado</string>
    <string name="pcap_file_not_exists">O arquivo especificado não existe</string>
    <string name="root_capture_start_failed">Falha na inicialização da captura. Certifique-se de que o dispositivo esteja enraizado com Magisk</string>
    <string name="root_capture_pcapd_start_failure">Falha na inicialização da captura. Certifique-se de conceder acesso root ao PCAPdroid</string>
    <string name="pcap_read_error">Erro ao ler o arquivo de captura. Verifique o log para mais detalhes.</string>
    <string name="keylog_read_error">Erro de leitura do keylog SSL</string>
    <string name="pcap_file_load_aborted">Carregamento do arquivo de captura abortado</string>
    <string name="host_resolution_failed">Não foi possível resolver o host %1$s</string>
    <string name="pcapdroid_trailer_notice">Para mostrar os aplicativos reais em vez de \"%1$s\", certifique-se de habilitar a opção \"%2$s\" antes de gerar o dump</string>
    <string name="decryption_info_no_rule">Para descriptografar esta conexão, crie uma regra de descriptografia na gaveta esquerda ou no menu contextual na lista Conexões</string>
    <string name="tls_decryption_no_rules_notice">A descriptografia TLS só é aplicada a conexões que correspondem às regras configuradas. Deseja criar regras de descriptografia agora?</string>
    <string name="active_vpn_detected">VPN ativa detectada</string>
    <string name="mitm_doze_notice">A otimização da bateria pode interferir no complemento mitm</string>
    <string name="redirected">redirecionado</string>
    <string name="connection_redirected_port_map">Esta conexão foi redirecionada devido a uma regra de mapeamento de porta</string>
    <string name="dnscrypt_how_to">Como usar DoH / DNSCrypt com PCAPdroid</string>
    <string name="never">Nunca</string>
    <string name="always">Sempre</string>
    <string name="for_connections_to_decrypt">Somente para conexões para descriptografar</string>
    <string name="decrypt_quic_notice">A descriptografia do QUIC não é suportada atualmente. Como solução alternativa, interrompa a captura e selecione a opção para bloquear o QUIC nas configurações do PCAPdroid</string>
    <string name="target_apps">Aplicativos de destino</string>
    <string name="target_apps_help">Selecione os aplicativos para capturar</string>
    <string name="headers">Cabeçalhos</string>
    <string name="body">Corpo</string>
    <string name="both">Ambos</string>
    <string name="whats_new">O que há de novo</string>
    <string name="raw_bytes">Bytes brutos</string>
    <string name="restart_on_disconnection">Reiniciar na desconexão</string>
    <string name="restart_on_disconnection_summary">Reiniciar automaticamente a captura após ser interrompida por outros aplicativos VPN</string>
    <string name="vpn_reconnection">Reconexão VPN</string>
    <string name="vpn_reconnection_aborted">Reconexão VPN abortada</string>
    <string name="waiting_for_vpn_disconnect">Aguardando a desconexão da VPN ativa…</string>
    <string name="bytes_threshold">Limite de bytes</string>
    <string name="select_the_pcap_file">Selecione o arquivo PCAP/Pcapng</string>
    <string name="select_the_keylog_file">Selecione o arquivo keylog SSL</string>
    <string name="error_code_with_text">%1$s (erro %2$d)</string>
    <string name="errno_epipe">Cano quebrado</string>
    <string name="errno_epipe_msg">O servidor fechou inesperadamente a conexão durante a transferência de dados</string>
    <string name="errno_enetdown">A rede está inativa</string>
    <string name="errno_enetdown_msg">A interface de rede está inativa ou não consegue se conectar à rede</string>
    <string name="errno_enetunreach">A rede está inacessível</string>
    <string name="errno_enetunreach_msg">O sistema não consegue encontrar uma rota válida para a rede de destino</string>
    <string name="errno_enetreset">Reinicialização da rede</string>
    <string name="errno_enetreset_msg">A conexão de rede foi redefinida por um dispositivo intermediário (por exemplo, roteador ou operadora de celular)</string>
    <string name="errno_econnaborted">Conexão abortada</string>
    <string name="errno_econnaborted_msg">A conexão foi abortada, geralmente devido a uma transição de rede</string>
    <string name="errno_econnreset">Conexão redefinida pelo peer</string>
    <string name="errno_econnreset_msg">O servidor fechou a conexão abruptamente, geralmente devido a uma falha ou desligamento inadequado</string>
    <string name="errno_etimedout">Tempo de conexão esgotado</string>
    <string name="errno_etimedout_msg">O servidor demorou muito para responder, provavelmente devido a atrasos na rede ou a um servidor ocupado</string>
    <string name="errno_econnrefused">Ligação recusada</string>
    <string name="errno_econnrefused_msg">O servidor rejeitou a conexão, o que pode indicar um servidor muito ocupado ou com defeito</string>
    <string name="errno_ehostunreach">Nenhuma rota para o host</string>
    <string name="errno_ehostunreach_msg">O sistema não consegue encontrar uma rota para o host de destino</string>
    <string name="dns_conn_info">O DNS traduz um nome de domínio em um endereço IP. Os dados reais são normalmente trocados por meio de conexões HTTPS/TLS subsequentes</string>
    <string name="tls_conn_info">O tráfego TLS/HTTPS é criptografado. Para inspecionar esse tráfego, você precisa descriptografá-lo. Consulte o <a href="%1$s">guia do usuário</a> do PCAPdroid para obter mais detalhes</string>
    <string name="tls_decryption_not_supported_16KB">A descriptografia TLS não é suportada atualmente em dispositivos de 16 KB</string>
    <string name="filename_prefix">Prefixo do nome do arquivo</string>
    <string name="filename_prefix_description">Defina o prefixo para os arquivos exportados pelo PCAPdroid, por exemplo, arquivos PCAP</string>
    <string name="select">Selecionar</string>
    <string name="request_method">Método da solicitação</string>
    <string name="content_type">Tipo de conteúdo</string>
    <string name="http_status">Status HTTP</string>
    <string name="payload_size_threshold">Limite de tamanho do payload</string>
    <string name="method_filter">Método: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="text">Texto</string>
    <string name="display_as_text">Mostrar como texto</string>
    <string name="display_as_hexdump">Mostrar como hexdump</string>
    <string name="exporting">Exportando…</string>
    <string name="export_in_progress">Exportação em execução, por favor aguarde</string>
    <string name="show_connection">Mostrar conexão</string>
    <string name="show_system_apps">Mostrar apps do sistema</string>
    <string name="destination_host">Host de destino</string>
    <string name="no_requests">Nenhuma solicitação</string>
    <string name="item_not_found">Não foi possível encontrar o item especificado</string>
    <string name="connection_number">Conexão #%1$d</string>
    <string name="http_request_number">Solicitação HTTP #%1$d</string>
    <string name="http_requests">Solicitações HTTP</string>
    <string name="switch_to_http">Mostrar solicitações HTTP</string>
    <string name="switch_to_connections">Mostrar conexões</string>
    <string name="decryption_error">Erro de descriptografia</string>
    <string name="previous">Anterior</string>
    <string name="next">Próximo</string>
    <string name="save_as_text">Salvar como texto</string>
    <string name="save_as_har">Salvar como HAR</string>
</resources>

```

`app/src/main/res/values-ru/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">Запустить</string>
    <string name="stop_button">Остановить</string>
    <string name="title_activity_settings">Настройки</string>
    <string name="collector_info">UDP сборщик: %1$s:%2$d</string>
    <string name="http_server_status">HTTP сервер: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s получено — %2$s отправлено</string>
    <string name="query">Запрос</string>
    <string name="host">Хост</string>
    <string name="ready">Готов</string>
    <string name="about">О приложении</string>
    <string name="status">Состояние</string>
    <string name="connections_view">Соединения</string>
    <string name="no_connections">Нет соединений</string>
    <string name="connection_details">Детали соединения</string>
    <string name="app">Приложение</string>
    <string name="protocol">Протокол</string>
    <string name="source">Источник</string>
    <string name="destination">Назначение</string>
    <string name="packets">Пакеты</string>
    <string name="duration">Продолжительность</string>
    <string name="http_server">HTTP сервер</string>
    <string name="udp_exporter">UDP экспортёр</string>
    <string name="no_dump">Без дампа</string>
    <string name="no_dump_info">Поток данных не будет записан</string>
    <string name="http_server_info">Запустить HTTP сервер для скачивания PCAP</string>
    <string name="udp_exporter_info">Отправить PCAP на удалённый UDP приёмник</string>
    <string name="http_server_port">Порт HTTP сервера</string>
    <string name="receiver_ip_address">IP адрес сборщика</string>
    <string name="receiver_port">Порт сборщика</string>
    <string name="user_guide">Руководство пользователя</string>
    <string name="open_telegram_group">Telegram сообщество</string>
    <string name="source_code">Исходный код</string>
    <string name="yes">Да</string>
    <string name="no">Нет</string>
    <string name="vpn_setup_failed">Не удалось настроить VPN. Убедитесь, что опция Постоянный VPN отключена</string>
    <string name="app_not_found">Не удалось найти приложение %1$s</string>
    <string name="stats">Показатели</string>
    <string name="active_connections">Активные соединения</string>
    <string name="dropped_connections">Прерванные соединения</string>
    <string name="tot_connections">Всего соединений</string>
    <string name="open_sockets">Открытые сокеты</string>
    <string name="bytes_sent">Байтов отправлено</string>
    <string name="bytes_rcvd">Байтов получено</string>
    <string name="packets_sent">Пакетов отправлено</string>
    <string name="packets_rcvd">Пакетов получено</string>
    <string name="dns_queries">DNS запросы</string>
    <string name="search_apps">Поиск приложений</string>
    <string name="no_apps">Нет приложений</string>
    <string name="dns_server">DNS сервер</string>
    <string name="apps">Приложения</string>
    <string name="pcap_file">PCAP файл</string>
    <string name="pcap_file_info">Создать PCAP/Pcapng файл в памяти устройства</string>
    <string name="cannot_write_file">Невозможно записать файл</string>
    <string name="share">Поделиться</string>
    <string name="delete">Удалить</string>
    <string name="ok">Хорошо</string>
    <string name="pcap_file_action">Трафик сохранён в файл %1$s (%2$s)</string>
    <string name="delete_error">Не удалось удалить файл</string>
    <string name="capture_running">Захват проводится</string>
    <string name="notification_msg">%1$s захвачено, %2$s соединения</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">Впервые обнаружено</string>
    <string name="last_seen">В последний раз обнаружено</string>
    <string name="conn_status_closed">Закрыто</string>
    <string name="copy_to_clipboard">Копировать</string>
    <string name="save_to_file">Сохранить в файл</string>
    <string name="older_connections_notice">%1$d старых соединений не показано</string>
    <string name="about_text">PCAPdroid это свободный инструмент захвата и отслеживания сетевого трафика, который работает без привилегий суперпользователя</string>
    <string name="get_app">Получить его:</string>
    <string name="unknown_app">Неизвестное</string>
    <string name="error">Ошибка</string>
    <string name="conn_status_unreachable">Недоступен</string>
    <string name="other_prefs">Другое</string>
    <string name="app_language">Язык приложения</string>
    <string name="system_default">Как в системе</string>
    <string name="no_activity_file_selection">Программа для взаимодействия с данным файлом не обнаружена</string>
    <string name="socks5_proxy">Включить SOCKS5 прокси</string>
    <string name="proxy_port">Порт прокси</string>
    <string name="root_capture">Захват в root режиме</string>
    <string name="donate">Пожертвовать</string>
    <string name="search">Поиск…</string>
    <string name="app_val">Приложение: %1$s</string>
    <string name="ip_address_val">IP адрес: %1$s</string>
    <string name="host_val">Хост: %1$s</string>
    <string name="protocol_val">Протокол: %1$s</string>
    <string name="hide">Скрыть…</string>
    <string name="n_selected">%1$d выбран(о)</string>
    <string name="select_all">Выбрать все</string>
    <string name="app_details">Информация о приложении</string>
    <string name="package_name">Имя пакета</string>
    <string name="uid">Идентификатор (UID)</string>
    <string name="app_name">Название</string>
    <string name="version">Версия</string>
    <string name="target_sdk">Целевой уровень SDK</string>
    <string name="installed_on">Установлено</string>
    <string name="last_update">Последнее обновление</string>
    <string name="permissions">Разрешения</string>
    <string name="root_app_info">Системные сервисы запущенные с максимальными привелегиями</string>
    <string name="netd_app_info">Системный сервис выполняющий DNS резолвинг</string>
    <string name="android_app_info">ОС Android</string>
    <string name="unknown_app_info">Пометка \"Неизвестное\" присваивается соединениям, у которых не удалось определить приложение-источник</string>
    <string name="packets_dropped">Отброшенные пакеты</string>
    <string name="capture_prefs">Захват трафика</string>
    <string name="pending_transaction">Пожалуйста, завершите транзакцию для получения этой возможности</string>
    <string name="ctrl_consent">Внешнее приложение хочет начать захват трафика посредством PCAPdroid.\nЕсли вы не уверены (или это не вы), то отклоните запрос</string>
    <string name="deny">Отклонить</string>
    <string name="allow">Разрешить</string>
    <string name="ctrl_consent_title">PCAPdroid Контрольный запрос</string>
    <string name="ctrl_consent_denied">PCAPdroid: Запрос был отклонен</string>
    <string name="ctrl_consent_allowed">PCAPdroid: Запрос был разрешен</string>
    <string name="capture_interface">Интерфейс для захвата</string>
    <string name="internet">Интернет</string>
    <string name="all_interfaces">Все интерфейсы</string>
    <string name="capturing_from">Перехватываются пакеты с \"%1$s\"</string>
    <string name="edit_filter">Изменить фильтр</string>
    <string name="edit_list">Изменить список</string>
    <string name="hidden_connections_rules">Правила скрытия соединений</string>
    <string name="list_is_empty">Список пуст</string>
    <string name="show_only_malicious">Вредоносные соединения</string>
    <string name="security">Безопасность</string>
    <string name="malware_detection">Обнаружение вредоносов</string>
    <string name="malware_detection_summary">Обнаружение соединений с известными вредоносными хостами с помощью сторонних черных списков</string>
    <string name="reset">Сбросить</string>
    <string name="malware_whitelist_rules">Правила игнорирования вредоносов</string>
    <string name="feature_not_available">Эта возможность на текущий момент недоступна для вашего устройства</string>
    <string name="billing_connecting">Подключение к Google Play в процессе, пожалуйста попробуйте еще раз позже</string>
    <string name="malicious_connection_filter">Вредоносные</string>
    <string name="status_filter">HTTP статус: %1$s</string>
    <string name="not_hidden_filter">Не скрыты</string>
    <string name="copy_action">Копировать…</string>
    <string name="url_val">"URL: %1$s"</string>
    <string name="show_me">Покажите мне</string>
    <string name="hint">Подсказка</string>
    <string name="once">Единожды</string>
    <string name="forever">Навсегда</string>
    <string name="control_permissions">Контроль разрешений</string>
    <string name="control_permissions_summary">Проверьте каким приложениям разрешено контролировать захват трафика через PCAPdroid</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">Страна</string>
    <string name="asn">ASN</string>
    <string name="country_val">Страна: %1$s</string>
    <string name="send_report">Отправить отчет</string>
    <string name="start_at_boot">Захват после загрузки устройства</string>
    <string name="malware_status_ok">Вредоносного трафика не обнаружено</string>
    <string name="malware_status_detected">Обнаружен вредоносный поток данных</string>
    <string name="whitelist">Белый список</string>
    <string name="blacklists">Черный список</string>
    <string name="status_outdated">Устарел</string>
    <string name="status_not_loaded">Не загружен</string>
    <string name="status_uptodate">Актуален</string>
    <string name="blacklist_type">"Тип: %1$s"</string>
    <string name="blacklist_type_ip">Черный список IP</string>
    <string name="blacklist_type_domain">Черный список доменов</string>
    <string name="n_rules">%1$s правил</string>
    <string name="last_update_val">Последнее обновление: %1$s</string>
    <string name="malicious_connections">Вредоносные соединения</string>
    <string name="updated_blacklists">Обновлено черных списков</string>
    <string name="connections_checked">Проверено соединений</string>
    <string name="last_blacklists_update">Последнее обновление</string>
    <string name="domain_rules">Правил по доменам</string>
    <string name="ip_rules">Правил по IP</string>
    <string name="malware_status_update_failed">Часть черных списков устарела</string>
    <string name="update_now">Обновить сейчас</string>
    <string name="status_updating">Обновление…</string>
    <string name="malware_detection_learn_more">Узнайте больше про возможность обнаружения вредоносных соединений</string>
    <string name="private_dns_message_notice">Частный DNS препятствует наблюдению PCAPdroid за DNS трафиком. Вы можете выключить его в сетевый настройках ОС Android</string>
    <string name="private_dns_hinders_detection">Частный DNS препятствует обнаружению</string>
    <string name="firewall">Файрвол</string>
    <string name="paid_features">Платные возможности</string>
    <string name="blocked_pkts">Заблокировано</string>
    <string name="n_pkts">%1$s пакетов</string>
    <string name="valid">Подтвержден</string>
    <string name="network_interface">Интерфейс</string>
    <string name="interface_filter">Интерфейс: %1$s</string>
    <string name="invalid">Недействителен</string>
    <string name="purchased">Приобретено</string>
    <string name="learn_more">Узнать больше</string>
    <string name="no_items_for_purchase">Отсутствуют опции доступные для покупки</string>
    <string name="buy_action">Купить</string>
    <string name="blocked_connection_filter">Заблокировано</string>
    <string name="block">Заблокировать…</string>
    <string name="firewall_rules">Правила для файрвола</string>
    <string name="validate">Подтвердить</string>
    <string name="billing_failure">Не удалось подключиться к Google Play, пожалуйста повторите позже</string>
    <string name="loading">Загрузка…</string>
    <string name="no_intent_handler_found">Не найдено приложения для выполнения этого действия</string>
    <string name="save_ok">Сохранено</string>
    <string name="loading_apps">Загрузка приложений…</string>
    <string name="file_saved_with_name">Файл сохранен как \"%1$s\"</string>
    <string name="disconnect_vpn_confirm">Продолжение приведёт к отключению от активного VPN</string>
    <string name="copied">Скопировано</string>
    <string name="capture_not_running_status">Захват не производится</string>
    <string name="start_capture_first">Сначала запустите захват потока данных</string>
    <string name="open_nav_drawer">Открыть боковое меню</string>
    <string name="close_nav_drawer">Закрыть боковое меню</string>
    <string name="root_capture_summary">Позволяет PCAPdroid работать вместе с другими VPN приложениями</string>
    <string name="start_at_boot_summary">Автозапуск захвата после загрузки</string>
    <string name="can_use_purchased_feature">Теперь вы можете пользоваться приобретенными возможностями</string>
    <string name="capture_all_apps">Захватывать поток данных всех приложений</string>
    <string name="hidden_connections_help">Список правил для скрытия элементов из списка соединений, чтобы сфокусироваться только на нужном</string>
    <string name="enable_socks5_proxy_summary">Перенаправляет все TCP соединения на SOCKS5 прокси</string>
    <string name="malware_whitelist_help">Определенный пользователем белый список для подавления обнаружения вредоносов. Удерживайте вредоносное соединение, чтобы создать правило согласно которому данное соединение не будет считаться вредоносным</string>
    <string name="decryption_no_filter_warn">При дешифровании TLS выберите целевое приложение, чтобы избежать потери соединения с интернетом</string>
    <string name="traffic_dump">Запись потока данных</string>
    <string name="phone_app">Телефон</string>
    <string name="phone_app_info">Службы телефонии</string>
    <string name="unblock">Разблокировать…</string>
    <string name="tls_decryption">Дешифрование TLS</string>
    <string name="tls_decryption_summary">Расшифровка SSL/TLS потока данных посредством MITM (Man-in-the-middle, \"человек по середине\"). Это может работать с некоторыми приложениями, ознакомьтесь с руководством пользователя</string>
    <string name="traffic_inspection">Просмотр потока данных</string>
    <string name="mitm_setup_wizard">Мастер настройки mitm</string>
    <string name="install_action">Установить</string>
    <string name="export_action">Экспорт</string>
    <string name="cert_exported_now_installed">Сертификат экспортирован, теперь установите его из настроек Android</string>
    <string name="cert_reinstall_required">Корневой сертификат не установлен, запустите мастер настройки mitm</string>
    <string name="mitm_addon_new_version">PCAPdroid mitm-дополнение необходимо обновить</string>
    <string name="string_http_request">HTTP запрос</string>
    <string name="string_http_response">HTTP ответ</string>
    <string name="request">Запрос</string>
    <string name="response">Ответ</string>
    <string name="overview">Обзор</string>
    <string name="websocket">Веб-сокет</string>
    <string name="http">HTTP</string>
    <string name="payload">Содержимое</string>
    <string name="decryption_filter">Статус: %1$s</string>
    <string name="connection_start_not_seen">PCAPdroid не обнаружил начало этого соединения. Некоторая информация может быть потеряна</string>
    <string name="full_payload_summary">Отображать полное содержимое соединений (например полные HTTP запросы и ответы). Это требует много памяти, не используйте при продолжительных захватах</string>
    <string name="tx_direction">TX</string>
    <string name="rx_direction">RX</string>
    <string name="not_decryptable">Не дешифруемо</string>
    <string name="full_payload">Показывать полное содержимое</string>
    <string name="network_traffic">Трафик</string>
    <string name="warn_no_app_data">Обмена прикладными данными не было</string>
    <string name="geolocation">Геолокация</string>
    <string name="download_in_progress">Скачивание еще продолжается, пожалуйста подождите</string>
    <string name="hexdump">HEX формат</string>
    <string name="download_failed">Скачивание не удалось</string>
    <string name="size_x">Размер: %1$s</string>
    <string name="database">База данных</string>
    <string name="geo_db_not_found">База данных не найдена. Геолокация выключена</string>
    <string name="built_on">Дата сборки: %1$s</string>
    <string name="geo_db_delete">Нажмите чтобы удалить базу данных и освободить место</string>
    <string name="rules_import_success">Импортировано %1$d правил</string>
    <string name="connection_blocked">Это соединение было заблокировано PCAPdroid</string>
    <string name="download">Скачать</string>
    <string name="no_rules_to_export">Нет правил для экспорта</string>
    <string name="rules_delete_confirm">Удалить выбранные правила\?</string>
    <string name="blocklist">Список для блокировки</string>
    <string name="keep_action">Оставить</string>
    <string name="discard_action">Отмена</string>
    <string name="rules_merge_msg">Оставить существующие правила\?</string>
    <string name="last_firewall_block">Последняя блокировка</string>
    <string name="connections_blocked">Соединение заблокировано</string>
    <string name="num_configured_rules">Установленные правила</string>
    <string name="action_unblock">Разблокировать</string>
    <string name="action_block">Заблокировать</string>
    <string name="app_info">Информация о приложении</string>
    <string name="export_ca_certificate">Экспортируйте корневой сертификат PCAPdroid, откройте в Android настройки \"Шифрование и учетные данные\" и выберите установку в качестве \"Сертификат ЦС\"</string>
    <string name="socks5_info">SOCKS5 прокси: %1$s:%2$d</string>
    <string name="mitm_start_failed">Не удалось запустить mitm сервис. Попробуйте открыть вручную mitm дополнение и повторите попытку</string>
    <string name="install_ca_certificate">Установите корневой сертификат PCAPdroid, выбрав \"VPN и приложения\". Android запросит ваш код или пароль блокировки экрана</string>
    <string name="checking_the_certificate">Проверяем сертификат…</string>
    <string name="cert_installed_correctly">Корневой сертификат установлен</string>
    <string name="mitm_addon_bad_version">Неподходящая версия PCAPdroid mitm дополнения. Пожалуйста, установите версию %1$s и попробуйте снова</string>
    <string name="conn_status_active">Активно</string>
    <string name="export_failed">Экспорт не удался</string>
    <string name="not_encrypted">Не зашифровано</string>
    <string name="payload_truncated">Содержимое сокращено. Чтобы отобразить его полностью, остановите захват и включите %1$s в настройках PCAPdroid</string>
    <string name="decrypted">Дешифровано</string>
    <string name="decryption">Дешифрование</string>
    <string name="waiting_application_data">Ожидаем данные</string>
    <string name="downloading">Скачивание…</string>
    <string name="import_action">Импорт</string>
    <string name="firewall_is_enabled">Файрвол включен</string>
    <string name="import_failed">Импорт не удался</string>
    <string name="invalid_backup">Неверный формат резервной копии</string>
    <string name="geo_db_download">Нажмите для загрузки новейшей базы данных. Новые базы данных доступны ежемесячно</string>
    <string name="firewall_is_disabled">Файрвол выключен</string>
    <string name="geolocation_summary">Отображать информацию о стране и ASN посредством локальных проверок</string>
    <string name="no_root_firewall">Файрвол не требующий root</string>
    <string name="block_quick">Блокировка QUIC</string>
    <string name="block_private_dns">Блокировка приватных DNS</string>
    <string name="welcome_to_pcapdroid">Добро пожаловать в PCAPdroid</string>
    <string name="privacy_first">Конфиденциальность превыше всего</string>
    <string name="country_and_asn">Страна и ASN</string>
    <string name="app_intro_traffic_dump">PCAPdroid предоставляет <a href="%1$s">несколько способов</a> получить запись потока данных в формате PCAP для дальнейшего анализа\n\nС помощью <a href="%2$s">опции расширений PCAPdroid</a>, вы можете добавить в дамп названия приложений, чтобы отобразить их в Wireshark</string>
    <string name="app_intro_privacy_msg">Это приложение не содержит трекеры и аналитику, не собирает данные без вашего согласия.
\n
\nКак в этом убедиться\? Ознакомьтесь с <a href="%1$s">политикой конфиденциальности</a> и <a href="%2$s">исходным кодом</a></string>
    <string name="ca_cert_export_failed">При экспорте корневого сертификата возникла ошибка
\n
\nЕсли на вашем устройстве есть Autostart или похожие программы, ограничивающие активность фоновых процессов, убедитесь в том, что <a href="%1$s">разрешили все для PCAPdroid</a></string>
    <string name="netd_block_missed">Это соединение инициировано сервисом netd, поэтому оно не может быть заблокировано</string>
    <string name="firewall_summary">Блокируйте доступ в интернет для приложений, настраивайте правила для доменов и IP адресов. Работает только при захвате без root</string>
    <string name="app_intro_back_button">Назад</string>
    <string name="app_intro_done_button">Готово</string>
    <string name="mitm_setup_wizard_intro">Этот мастер настройки проведет вас через установку дополнения PCAPdroid mitm и корневого сертификата, которые необходимы для проведения <a href="%1$s">дешифрования TLS</a></string>
    <string name="app_intro_next_button">Далее</string>
    <string name="app_intro_skip_button">Пропустить</string>
    <string name="block_private_dns_summary">Обнаруживать и по возможности блокировать использование приватных DNS, чтобы инспектировать поток данных DNS. Отключение этой опции может затруднить анализ потока данных</string>
    <string name="mitm_setup_wizard_done">PCAPdroid теперь готов к расшифровыванию TLS потока данных\n\nОзнакомьтесь с <a href="%1$s">руководством пользователя</a> чтобы узнать больше о мерах безопасности, которые могут предотвратить расшифровыванию и как преодолеть их</string>
    <string name="app_intro_welcome_msg">PCAPdroid это ориентированное на конфиденциальность приложение, которое позволяет вам отслеживать и анализировать соединения, производимые приложениями с вашего устройства\n \nБолее того, приложение позволяет вам экспортировать запись потока данных в виде PCAP, извлекать метаданные и многое другое!</string>
    <string name="vpn_setup_msg">PCAPdroid симулирует VPN чтобы захватывать весь потока данных устройства без необходимости в суперпользователя root.\n\nЧтобы начать захват, вам необходимо принять запрос на включение VPN на следующем экране\n\n<b>ПРИМЕЧАНИЕ:</b> чтобы продолжить, отключите любой настроенный Постоянный VPN из настроек Android</string>
    <string name="app_intro_firewall_msg">Со встроенным <a href="%1$s">файрволом</a> вы можете легко заблокировать доступ в интернет отдельным приложениям, доменам, странам\n\nСкомбинируйте это со встроенной возможностью просматривать поток данных и получите идеальный инструмент для защиты своей конфиденциальности</string>
    <string name="app_intro_malware_detection">Повысьте безопасность своего устройства с функцией <a href="%1$s">обнаружения вредоносных соединений</a>
\n
\nИспользуя актуальные черные списки, эта функция может обнаруживать, блокировать и уведомлять о вредоносных соединениях в реальном времени</string>
    <string name="app_intro_geolocation_msg">PCAPdroid может использовать локальную базу данных для определения страны, в которой находится удаленный сервер
\n
\nВам необходимо сперва скачать базу данных геолокации из настроек приложения</string>
    <string name="app_intro_traffic_inspection">Просматривать HTTP запросы, ответы и необработанные данные легко, благодаря встроенным декодерам
\n
\nПопалось зашифрованное соединение\? Вы можете включить <a href="%1$s">дешифрование TLS</a> чтобы получить дешифрованные данные</string>
    <string name="allowed_connection_filter">Разрешенные</string>
    <string name="unblock_for_n_hours">Разблокировать на %1$dч</string>
    <string name="unblock_permanently">Разблокировать навсегда</string>
    <string name="app_blocked_info">Приложение %1$s было заблокировано файрволом</string>
    <string name="permission_granted">Разрешение %1$s было получено</string>
    <string name="app_blocked">Приложение заблокировано</string>
    <string name="block_new_apps">Блокировать недавно установленные приложения</string>
    <string name="no_matches_found">Нет совпадений</string>
    <string name="full_payload_disabled">Опция отображения полного содержимого была отключена</string>
    <string name="capture_stopped_low_memory">Захват был остановлен</string>
    <string name="firewall_filter">Файрвол: %1$s</string>
    <string name="low_memory_info">Приложению не хватает памяти, ожидаются сбои в работе</string>
    <string name="permission_grant_fail">Разрешение %1$s не может быть получено</string>
    <string name="connection_not_found">Не удалось найти заданное соединение</string>
    <string name="low_memory">Мало памяти</string>
    <string name="show_only_cleartext">Соединения c открытым текстом</string>
    <string name="ip_both">IPv4 и IPv6</string>
    <string name="memory_usage">Использование памяти</string>
    <string name="cleartext_connection">Незашифрованно</string>
    <string name="vpn_exemptions_summary">Исключение некоторых приложений из VPN соединения. Их поток данных не будет просматриваться</string>
    <string name="vpn_exemptions">VPN исключения</string>
    <string name="notifications_notice">Приложение использует уведомления для оповещения в случае аномальных событий. Предоставьте ему разрешение на отправку уведомлений на следующем экране</string>
    <string name="cancel_action">Отмена</string>
    <string name="show_data_action">Показать данные</string>
    <string name="remote_collector_notice">Вы настроили PCAPdroid отправлять трафик на удаленный сервер. Сервер будет иметь доступ к вашей конфиденциальной информации.
\n
\nЕсли кто-то попросил вас сделать это, возможно это попытка мошенничества</string>
    <string name="payload_scams_notice">Это окно может содержать конфиденциальную информацию, например пароли или токены доступа.
\n
\nНикогда не передавайте эту информацию никому, это может быть попыткой мошенничества</string>
    <string name="remote_server_warning">Из соображений безопасности, отправка трафика на удаленный сервер \"%1$s\" не разрешена</string>
    <string name="heap_usage">Использование кучи</string>
    <string name="vpn_lockdown_notice">Чтобы предотвратить доступ к интернету для приложений когда PCAPdroid не запущен (например после перезагрузки), вы можете настроить PCAPdroid для работы в качестве всегда активного VPN в режиме блокировки.
\n
\nВы хотите открыть настройки VPN сейчас\?</string>
    <string name="ip_mode">IP адреса для VPN</string>
    <string name="ipv4_only">Только IPv4</string>
    <string name="ipv6_only">Только IPv6</string>
    <string name="warning">Предупреждение</string>
    <string name="build_info">Информация о сборке</string>
    <string name="install_the_mitm_addon">Установить <a href="%1$s">mitm дополнение</a> PCAPdroid</string>
    <string name="app_unblocked">Приложение %1$s было разблокировано</string>
    <string name="unblock_for_n_minutes">Разблокировать на %1$d мин</string>
    <string name="paid_features_unlocked">Платные функции разблокированы. Перезапустите захват пакетов, если он запущен</string>
    <string name="tls_decryption_with_root_msg">Возможность запускать TLS дешифрование с использованием root является экспериментальной функцией. Cписок известных ошибок: \n \n - в PCAPdroid вы можете видеть трафик так, будто он был сгенерирован в приложении mitm-дополнением вместо оригинального приложения \n - дамп SSL keylog не поддерживается\n - когда в приложении установлен фильтр, дешифрование будет происходить только для целевого приложения, но PCAPdroid всё равно будет показывать трафик других приложений \n - если захват пакетов не может начаться, убедитесь, что вы можете запускать команду iptables от имени суперпользователя (например через termux) \n - функция может не работать на Android 12 и выше \n - если VPN приложение запущено, вы должны, либо указать целевое приложение для дешифрования, либо исключить PCAPdroid mitm-дополнение из VPN, иначе трафик будет закольцован</string>
    <string name="paid_feature">Платная функция</string>
    <string name="unlock_token_summary">Токен, который может использоваться для разблокировки платных возможностей в версиях приложения не из Google Play (Github/F-Droid)</string>
    <string name="access_paid_features_msg">Ознакомьтесь <a href="%1$s">с инструкцией</a>, чтобы узнать, как получить доступ к платным функциям</string>
    <string name="requesting_unlock_token">Запрашиваю unlock token, пожалуйста подождите</string>
    <string name="show_action">Показать</string>
    <string name="mitm_wizard_description">Настройте устройство для дешифрования TLS</string>
    <string name="mitm_skip_notice">Похоже, что mitm сертификат не установлен. Если Вы продолжите, дешифрование может завершиться неудачей</string>
    <string name="firewall_purchase_msg">Приобретите функцию <i>%1$s</i>, чтобы начать блокировать соединения</string>
    <string name="unlock_token_error">Ошибка запроса unlock token [%1$d]: %2$s</string>
    <string name="unlock_token_msg1">Это ваш unlock token. Не потеряйте его, так как он используется для <a href="%1$s">генерации ваших лицензионных ключей</a></string>
    <string name="license_service_unavailable">Сервис лицензирования PCAPdroid временно недоступен. Пожалуйста, повторите попытку позже</string>
    <string name="app_log">Журнал</string>
    <string name="no_data">Нет данных</string>
    <string name="malware_whitelist_action">Белый список (вредонос)…</string>
    <string name="mitm_addon">mitm дополнение</string>
    <string name="mitmproxy_opts_description">Укажите дополнительные опции для mitmproxy</string>
    <string name="mitm_addon_error">Ошибка запуска mitm дополнения. Проверьте журнал для деталей</string>
    <string name="whitelist_mode">Режим белого списка</string>
    <string name="firewall_whitelist_notice">В этом режиме все соединения будут заблокированы, до ручного добавления в белый список. Вы можете лишиться push-уведомлений без корректного белого списка</string>
    <string name="add_to_fw_whitelist">Добавить в белый список файрвола</string>
    <string name="firewall_whitelist_help">Эти правила определяют какие соединения разрешить. Правила блокировки имеют приоритет над белым списком</string>
    <string name="reset_stats_confirm">Вы действительно хотите сбросить статистику\?</string>
    <string name="remove_from_fw_whitelist">Убрать из белого списка файрвола</string>
    <string name="port_mapping">Сопоставление портов</string>
    <string name="redirect_to">Перенаправлять на:</string>
    <string name="add_action">Добавить</string>
    <string name="items_delete_confirm">Удалить выбранные элементы\?</string>
    <string name="destination_port">Порт назначения</string>
    <string name="port_mapping_summary">Настройте правила сопоставления портов для перенаправления соединений на другие хосты или порты</string>
    <string name="original_port">Изначальный порт</string>
    <string name="required">необходимо</string>
    <string name="port_mapping_exists">Сопоставление портов уже определено</string>
    <string name="dns_servers_summary">Настройте DNS сервера для использования в процессе захвата</string>
    <string name="ipv4_dns_server">IPv4 DNS сервер</string>
    <string name="ipv6_dns_server">IPv6 DNS сервер</string>
    <string name="dns_servers">DNS сервера</string>
    <string name="ip_address">IP адрес</string>
    <string name="rule_exists">Правило уже определено</string>
    <string name="use_system_dns">Использовать системный DNS</string>
    <string name="pcapng_format">Формат Pcapng</string>
    <string name="external_storage_perm_required">Требуется разрешение на доступ к внешнему накопителю</string>
    <string name="mitmproxy_opts">Дополнительные опции mitmproxy</string>
    <string name="pcapng_format_summary">Делать дамп пакетов в формат Pcapng, который является более гибким и позволяет встраивать секреты дешифрования TLS</string>
    <string name="many_rules_warning">Вы пытаетесь импортировать множество правил, что может сделать приложение неотзывчивым в течение некоторых действий. Вы действительно хотите продолжить\?</string>
    <string name="use_system_dns_summary">Использовать системные DNS сервера, если это возможно</string>
    <string name="total_bytes">Всего байт</string>
    <string name="sort_by">Сортировать по</string>
    <string name="write_ext_storage_failed">Запись на внешнее устройство хранения не удалась. Подробности в журнале приложения</string>
    <string name="socks5_auth_summary">Аутентификация в прокси через имя пользователя и пароль</string>
    <string name="socks5_summary">Настроить перенаправление на SOCKS5 прокси</string>
    <string name="socks5_redirection">SOCKS5 перенаправление</string>
    <string name="username">Имя пользователя</string>
    <string name="password">Пароль</string>
    <string name="mitm_addon_autostart_workaround">Соединение с mitm дополнением не удалось. Вы можете попробовать открыть приложение mitm дополнения и затем, не закрывая его, вернуться в PCAPdroid. Вы хотите открыть его сейчас\?</string>
    <string name="qr_info_text">Установите PCAPdroid из Google Play и отсканируйте этот QR код</string>
    <string name="invalid_license">Некорректная лицензия</string>
    <string name="connection_error">Ошибка соединения: %1$s</string>
    <string name="qr_purchase_required">Приобретите unlock token, чтобы продолжить активацию QR кода</string>
    <string name="requesting_license">Запрашивается лицензионный код, пожалуйста подождите</string>
    <string name="license_activation_ok">Активация лицензии завершена</string>
    <string name="license_error">Ошибка генерации лицензии [%1$d]: %2$s</string>
    <string name="qr_license_confirm">Вы хотите сгененировать лицензию для устройства \"%1$s\" используя следующий unlock token\?</string>
    <string name="activate_via_qr_code">Активировать с помощью QR кода</string>
    <string name="license_limit_reached">Достигнут лимит лицензий для данного unlock token. Приобретите новый token, чтобы сгенерировать больше лицензий</string>
    <string name="qr_code_expired">Срок действия QR кода истек. Сгенерируйте новый QR код и повторите попытку</string>
    <string name="socks5_auth">Аутентификация SOCKS5</string>
    <string name="mitm_addon_starting">MITM-аддон запускается…</string>
    <string name="mitm_addon_running">MITM-аддон запущен</string>
    <string name="decryption_rules">Правила дешифрования</string>
    <string name="decrypt_action">Дешифровать…</string>
    <string name="decryption_rules_help">Эти правила указывают на те соединения, которые необходимо дешифровать. Правила на основе хостов работают только если найден соответствующий отклик от DNS сервера</string>
    <string name="dont_decrypt_action">Не дешифровать…</string>
    <string name="status_encrypted">Зашифровано</string>
    <string name="injected">Инжектировано</string>
    <string name="tls_decryption_no_rules_notice">Дешифрование TLS применяется только к соединениям, которые соответствуют настроенным правилам. Вы хотите создать правила дешифрования\?</string>
    <string name="root_capture_pcapd_start_failure">Не удалось начать захват. Убедитесь, что вы разрешили root-доступ для PCAPdroid</string>
    <string name="active_vpn_detected">Обнаружен активный VPN</string>
    <string name="copy_error">Не удаётся записать файл</string>
    <string name="proxy_host">Прокси хост</string>
    <string name="pcap_load_in_progress">Файл дампа загружается, пожалуйста подождите</string>
    <string name="open_pcap_file">Открыть PCAP/Pcapng файл…</string>
    <string name="decryption_info_no_rule">Для дешифрования этого соединения создайте соответствующее правило через боковое меню, либо через контекстное меню в списке соединений</string>
    <string name="host_resolution_failed">Не удалось разрешить хост %1$s</string>
    <string name="capture_interface_open_error">Не удалось открыть интерфейс захвата</string>
    <string name="pcap_load_success">Файл захвата загружен</string>
    <string name="invalid_pcap_file">Недопустимый формат файла захвата</string>
    <string name="pcap_file_not_exists">Указанного файла не существует</string>
    <string name="pcap_read_error">Ошибка чтения файла захвата. См. подробности в логах</string>
    <string name="pcap_file_load_aborted">Загрузка файла захвата прервана</string>
    <string name="root_capture_start_failed">Не удалось начать захват. Убедитесь, что устройство рутовано с помощью Magisk</string>
    <string name="pcapdroid_trailer_notice">Чтобы отображать фактические приложения вместо \"%1$s\", убедитесь, что вы включили опцию \"%2$s\" перед генерацией дампа</string>
    <string name="never">Никогда</string>
    <string name="target_apps">Целевые приложения</string>
    <string name="target_apps_help">Выберите приложения для захвата</string>
    <string name="connection_redirected_port_map">Это соединение было перенаправлено по правилу сопоставления портов</string>
    <string name="for_connections_to_decrypt">Только для дешифруемых соединений</string>
    <string name="whats_new">Что нового</string>
    <string name="both">Обе части</string>
    <string name="redirected">перенаправлено</string>
    <string name="dnscrypt_how_to">Как использовать DoH / DNSCrypt с PCAPdroid</string>
    <string name="always">Всегда</string>
    <string name="raw_bytes">Raw байты</string>
    <string name="mitm_doze_notice">Оптимизации батареи могут помешать работе mitm дополнения</string>
    <string name="decrypt_quic_notice">Дешифрование QUIC в данный момент не поддерживается. В качестве временной меры, остановите захват и в настройках PCAPdroid включите опцию блокировки QUIC</string>
    <string name="headers">Заголовки</string>
    <string name="body">Тело</string>
    <string name="unsupported_pcap_datalink">Файл содержит неподдерживаемый datalink</string>
    <string name="export_ellipsis">Экспорт…</string>
    <string name="ipv6_bytes_rcvd">IPv6 байт получено</string>
    <string name="restart_on_disconnection_summary">Автоматически перезапускать захват после остановки другими VPN приложениями</string>
    <string name="ipv6_bytes_sent">IPv6 байт отправлено</string>
    <string name="ipv6_bytes_percentage">Процент IPv6 байт</string>
    <string name="waiting_for_vpn_disconnect">Ожидается отключение активного VPN…</string>
    <string name="vpn_reconnection">Переподключение VPN</string>
    <string name="vpn_reconnection_aborted">Переподключение VPN прервано</string>
    <string name="restart_on_disconnection">Перезапуск при отключении</string>
    <string name="update_available">Доступно обновление</string>
    <string name="mitm_addon_update_available">Доступно свежее обновление для mitm-дополнения. Обновитесь для получения последних исправлений</string>
    <string name="update_action">Обновить</string>
    <string name="dump_extensions_summary">Расширяет формат дампа пакетов дополнительными метаданными, такими как название приложения, которое отправило/получило данный пакет</string>
    <string name="dump_extensions_how_to">Как отобразить расширения дампа PCAPdroid в Wireshark</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="malicious_connection_description">Соединение из приложения \"%1$s\" вызвало срабатывание правила обнаружения вредоносов (%2$s)</string>
    <string name="malicious_connections_notice">Черные списки могут содержать ошибки. Дважды убедитель в репутации адреса/домена в сети. Вы можете исключить ложные срабатывания через белый список</string>
    <string name="ip_address_or_cidr">IP адрес / CIDR</string>
    <string name="errno_econnaborted_msg">Соединение прервано, как правило, из-за переключения сети</string>
    <string name="errno_enetreset_msg">Соединение сброшено промежуточным устройством (например роутером или мобильным оператором)</string>
    <string name="errno_econnrefused_msg">Сервер отклонил соединение, что может означать высокую загруженность или неисправность сервера</string>
    <string name="errno_etimedout_msg">Сервер отвечал слишком долго, вероятно из-за сетевых задержек или загруженности сервера</string>
    <string name="geo_db_missing">Отсутствует база данных геолокации</string>
    <string name="country_rules_warning">Чтобы использовать правила по странам, необходимо загрузить базу данных геолокации из настроек PCAPdroid, иначе правила по странам будут неэффективны</string>
    <string name="unsupported_pcap_file">Неподдерживаемый формат файла захвата</string>
    <string name="decrypt_pcap_file">Дешифровать PCAP/Pcapng файл…</string>
    <string name="keylog_read_error">Ошибка чтения SSL keylog</string>
    <string name="select_the_pcap_file">Выберите PCAP/Pcapng файл</string>
    <string name="error_code_with_text">%1$s (ошибка %2$d)</string>
    <string name="bytes_threshold">Пороговое значение в байтах</string>
    <string name="select_the_keylog_file">Выберите файл SSL keylog</string>
    <string name="errno_epipe">Соединение разорвано</string>
    <string name="errno_econnaborted">Соединение прервано</string>
    <string name="errno_enetunreach">Сеть недостижима</string>
    <string name="errno_enetunreach_msg">Система не может найти корректый маршрут в сеть назначения</string>
    <string name="errno_etimedout">Таймаут соединения</string>
    <string name="errno_enetdown">Сеть отключена</string>
    <string name="errno_enetdown_msg">Сетевой интерфейс отключен или не может подключиться к сети</string>
    <string name="errno_enetreset">Соединение сброшено</string>
    <string name="errno_econnreset">Соединение сброшено пиром</string>
    <string name="errno_econnreset_msg">Сервер внезапно закрыл соединение, как правило, из-за сбоя или некорректного отключения</string>
    <string name="errno_epipe_msg">Сервер внезапно закрыл соединение во время передачи данных</string>
    <string name="errno_ehostunreach">Нет маршрута до хоста</string>
    <string name="errno_ehostunreach_msg">Система не может найти маршрут до хоста назначения</string>
    <string name="errno_econnrefused">Соединение отклонено</string>
    <string name="tls_conn_info">TLS/HTTPS трафик зашифрован. Чтобы изучать этот трафик, вам необходимо его дешифровать. Загляните в <a href="%1$s">Руководство пользователя</a> PCAPdroid за деталями</string>
    <string name="dns_conn_info">DNS преобразовывает доменное имя в IP адрес. Фактический обмен данными, как правило, идет через последующие HTTPS/TLS соединения</string>
    <string name="dump_extensions">Расширения PCAPdroid</string>
    <string name="tcp_exporter_info">Отправить этот PCAP на удалённый TCP приёмник (pcap-over-ip)</string>
    <string name="no_permissions_set_info">Никаких разрешений не установлено. Вызовите PCAPdroid через StartActivityForResult чтобы увидеть запрос разрешений</string>
    <string name="api_key_discard_confirm">Вы действительно хотите сбросить текущий ключ API и создать новый?</string>
    <string name="tcp_collector_info">TCP сборщик: %1$s:%2$d</string>
    <string name="tcp_exporter">TCP экспортер</string>
    <string name="tcp_udp_exporter">TCP/UDP экспортёр</string>
    <string name="generate_api_key">Сгенерировать ключ API</string>
    <string name="show_api_key">Показать ключ API</string>
    <string name="api_key">Ключ API</string>
    <string name="select">Выбрать</string>
    <string name="request_method">Метод запроса</string>
    <string name="http_status">HTTP статус</string>
    <string name="method_filter">Метод: %1$s</string>
    <string name="text">Текст</string>
    <string name="display_as_text">Отобразить как текст</string>
    <string name="display_as_hexdump">Отобразить как hex-дамп</string>
    <string name="switch_to_http">Показать HTTP запросы</string>
    <string name="switch_to_connections">Показать соединения</string>
    <string name="no_requests">Нет запросов</string>
    <string name="save_as_text">Сохранить как текст</string>
    <string name="save_as_har">Сохранить как HAR</string>
    <string name="show_system_apps">Показывать системные приложения</string>
    <string name="filename_prefix">Префикс имени файла</string>
    <string name="filename_prefix_description">Настройка префикса для файлов, экспортируемых PCAPdroid, например PCAP файлы</string>
    <string name="connection_number">Соединение #%1$d</string>
    <string name="http_request_number">HTTP запрос #%1$d</string>
    <string name="decryption_error">Ошибка дешифрования</string>
    <string name="http_requests">HTTP запросы</string>
    <string name="show_connection">Показать соединение</string>
    <string name="exporting">Экспортируется…</string>
    <string name="export_in_progress">Выполняется экспорт, пожалуйста подождите</string>
    <string name="destination_host">Хост назначения</string>
    <string name="payload_size_threshold">Пороговый размер содержимого</string>
    <string name="previous">Предыдущий</string>
    <string name="next">Следующий</string>
    <string name="content_type">Content type</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="tls_decryption_not_supported_16KB">Дешифрование TLS на текущий момент не поддерживается на устройствах со страницей памяти 16КБ</string>
    <string name="item_not_found">Не удалось найти указанный элемент</string>
</resources>

```

`app/src/main/res/values-sw600dp/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="drawer_header_height">225dp</dimen>
</resources>

```

`app/src/main/res/values-ta/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">தொடங்கு</string>
    <string name="stop_button">நிறுத்து</string>
    <string name="title_activity_settings">அமைப்புகள்</string>
    <string name="collector_info">யுடிபி கலெக்டர்: %1$s: %2$d</string>
    <string name="http_server_status">Http சேவையகம்: http: //%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s பெறப்பட்டன - %2$s அனுப்பப்பட்டது</string>
    <string name="query">வினவல்</string>
    <string name="host">விருந்தோம்பி</string>
    <string name="ready">ஆயத்தம்</string>
    <string name="about">பற்றி</string>
    <string name="status">நிலை</string>
    <string name="connections_view">இணைப்புகள்</string>
    <string name="no_connections">இணைப்புகள் இல்லை</string>
    <string name="connection_details">இணைப்பு விவரங்கள்</string>
    <string name="app">பயன்பாடு</string>
    <string name="protocol">நெறிமுறை</string>
    <string name="source">மூலம்</string>
    <string name="destination">இலக்கு</string>
    <string name="packets">பாக்கெட்டுகள்</string>
    <string name="duration">காலம்</string>
    <string name="http_server">HTTP சேவையகம்</string>
    <string name="udp_exporter">யுடிபி ஏற்றுமதியாளர்கள்</string>
    <string name="no_dump">டம்ப் இல்லை</string>
    <string name="no_dump_info">போக்குவரத்து கொட்டப்படாது</string>
    <string name="http_server_info">PCAP பதிவிறக்கத்திற்கு HTTP சேவையகத்தைத் தொடங்கவும்</string>
    <string name="udp_exporter_info">தொலைநிலை UDP ரிசீவருக்கு PCAP ஐ அனுப்பவும்</string>
    <string name="http_server_port">HTTP சேவையக போர்ட்</string>
    <string name="receiver_ip_address">கலெக்டர் ஐபி முகவரி</string>
    <string name="receiver_port">கலெக்டர் போர்ட்</string>
    <string name="traffic_dump">போக்குவரத்து டம்ப்</string>
    <string name="user_guide">பயனர் வழிகாட்டி</string>
    <string name="open_telegram_group">தந்தி குழு</string>
    <string name="source_code">மூலக் குறியீடு</string>
    <string name="yes">ஆம்</string>
    <string name="no">இல்லை</string>
    <string name="vpn_setup_failed">VPN ஐ அமைக்க முடியவில்லை. எப்போதும் VPN முடக்கப்பட்டுள்ளது என்பதை உறுதிப்படுத்தவும்</string>
    <string name="app_not_found">%1$s பயன்பாட்டைக் கண்டுபிடிக்க முடியவில்லை</string>
    <string name="stats">புள்ளிவிவரங்கள்</string>
    <string name="active_connections">செயலில் உள்ள இணைப்புகள்</string>
    <string name="dropped_connections">கைவிடப்பட்ட இணைப்புகள்</string>
    <string name="conn_status_active">செயலில்</string>
    <string name="security">பாதுகாப்பு</string>
    <string name="app_unblocked">%1$s பயன்பாடு தடை நீக்கப்பட்டது</string>
    <string name="sort_by">வரிசைப்படுத்தவும்</string>
    <string name="invalid_license">தவறான உரிமம்</string>
    <string name="mitm_doze_notice">பேட்டரி உகப்பாக்கம் MITM துணை நிரலில் தலையிடக்கூடும்</string>
    <string name="whats_new">புதியது என்ன</string>
    <string name="tot_connections">மொத்த இணைப்புகள்</string>
    <string name="open_sockets">திறந்த சாக்கெட்டுகள்</string>
    <string name="bytes_sent">பைட்டுகள் அனுப்பப்பட்டன</string>
    <string name="bytes_rcvd">பைட்டுகள் பெறப்பட்டன</string>
    <string name="ipv6_bytes_sent">ஐபிவி 6 பைட்டுகள் அனுப்பப்பட்டன</string>
    <string name="ipv6_bytes_rcvd">ஐபிவி 6 பைட்டுகள் பெறப்பட்டன</string>
    <string name="ipv6_bytes_percentage">ஐபிவி 6 பைட்டுகள் விழுக்காடு</string>
    <string name="packets_sent">பாக்கெட்டுகள் அனுப்பப்பட்டன</string>
    <string name="packets_rcvd">பாக்கெட்டுகள் பெறப்பட்டன</string>
    <string name="dns_queries">டி.என்.எச் வினவல்கள்</string>
    <string name="search_apps">பயன்பாடுகளைத் தேடுங்கள்</string>
    <string name="no_apps">பயன்பாடுகள் இல்லை</string>
    <string name="dns_server">டிஎன்எச் சேவையகம்</string>
    <string name="apps">பயன்பாடுகள்</string>
    <string name="pcap_file">PCAP கோப்பு</string>
    <string name="pcap_file_info">சாதன சேமிப்பகத்தில் PCAP/PCAPNG கோப்பை உருவாக்கவும்</string>
    <string name="cannot_write_file">கோப்பை எழுத முடியாது</string>
    <string name="share">பங்கு</string>
    <string name="delete">நீக்கு</string>
    <string name="ok">சரி</string>
    <string name="pcap_file_action">போக்குவரத்து \"%1$s\" கோப்பில் சேமிக்கப்பட்டது (%2$s)</string>
    <string name="delete_error">கோப்பை நீக்க முடியவில்லை</string>
    <string name="copy_error">கோப்பை எழுத முடியவில்லை</string>
    <string name="capture_running">இயங்கும் பிடிப்பு</string>
    <string name="notification_msg">%1$s கைப்பற்றப்பட்டன, %2$s இணைப்புகள்</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">முதலில் பார்த்தேன்</string>
    <string name="last_seen">கடைசியாக பார்த்தேன்</string>
    <string name="conn_status_closed">மூடப்பட்டது</string>
    <string name="copy_to_clipboard">நகலெடு</string>
    <string name="save_to_file">கோப்பில் சேமிக்கவும்</string>
    <string name="older_connections_notice">%1$d பழைய இணைப்புகள் காட்டப்படவில்லை</string>
    <string name="about_text">பி.சி.ஏ.பி டிராய்டு என்பது ஒரு திறந்த மூல பிணையம் பிடிப்பு மற்றும் கண்காணிப்பு கருவியாகும், இது ரூட் சலுகைகள் இல்லாமல் செயல்படுகிறது</string>
    <string name="get_app">அதைப் பெறுங்கள்:</string>
    <string name="unknown_app">தெரியவில்லை</string>
    <string name="phone_app">தொலைபேசி</string>
    <string name="error">பிழை</string>
    <string name="conn_status_unreachable">அணுக முடியாதது</string>
    <string name="other_prefs">மற்றொன்று</string>
    <string name="app_language">பயன்பாட்டு மொழி</string>
    <string name="system_default">கணினி இயல்புநிலை</string>
    <string name="no_activity_file_selection">கோப்பு தேர்வைக் கையாள எந்த பயன்பாடும் கிடைக்கவில்லை</string>
    <string name="file_saved_with_name">கோப்பு \"%1$s\" என சேமிக்கப்பட்டது</string>
    <string name="socks5_proxy">சாக்ச் 5</string>
    <string name="socks5_redirection">SOCKS5 திருப்பிவிடுதல்</string>
    <string name="socks5_summary">ஒரு சாக்ச் 5 ப்ராக்சிக்கு திருப்பிவிடுவதை உள்ளமைக்கவும்</string>
    <string name="enable_socks5_proxy_summary">அனைத்து TCP இணைப்புகளையும் ஒரு SOCKS5 ப்ராக்சிக்கு திருப்பி விடுங்கள்</string>
    <string name="socks5_info">SOCKS5 ப்ராக்சி: %1$s: %2$d</string>
    <string name="socks5_auth">SOCKS5 ஏற்பு</string>
    <string name="socks5_auth_summary">பயனர்பெயர் மற்றும் கடவுச்சொல் வழியாக ப்ராக்சிக்கு அங்கீகரிக்கவும்</string>
    <string name="proxy_host">பதிலாள் புரவலன்</string>
    <string name="proxy_port">பதிலாள் போர்ட்</string>
    <string name="root_capture">வேராகப் பிடிக்கவும்</string>
    <string name="root_capture_summary">பிற VPN பயன்பாடுகளுடன் இயங்க PCAPDroid ஐ அனுமதிக்கிறது</string>
    <string name="donate">நன்கொடை</string>
    <string name="app_log">பதிவு</string>
    <string name="no_data">தரவு இல்லை</string>
    <string name="search">தேடுங்கள்…</string>
    <string name="app_val">பயன்பாடு: %1$s</string>
    <string name="ip_address_val">ஐபி முகவரி: %1$s</string>
    <string name="host_val">ஓச்ட்: %1$s</string>
    <string name="protocol_val">நெறிமுறை: %1$s</string>
    <string name="malware_whitelist_action">அனுமதிப்பட்டியல் (தீம்பொருள்)…</string>
    <string name="hide">மறை…</string>
    <string name="select">தேர்வு</string>
    <string name="n_selected">%1$d தேர்ந்தெடுக்கப்பட்டது</string>
    <string name="select_all">அனைத்தையும் தெரிவுசெய்</string>
    <string name="app_details">பயன்பாட்டு விவரங்கள்</string>
    <string name="package_name">தொகுப்பு பெயர்</string>
    <string name="uid">Uid</string>
    <string name="app_name">பெயர்</string>
    <string name="version">பதிப்பு</string>
    <string name="target_sdk">இலக்கு SDK</string>
    <string name="installed_on">நிறுவப்பட்டுள்ளது</string>
    <string name="last_update">கடைசி புதுப்பிப்பு</string>
    <string name="permissions">அனுமதிகள்</string>
    <string name="root_app_info">சிச்டம் டீமன்கள் அதிகபட்ச சலுகைகளுடன் இயங்குகின்றன</string>
    <string name="netd_app_info">டிஎன்எச் தீர்மானங்களைச் செய்யும் கணினி டீமான்</string>
    <string name="android_app_info">ஆண்ட்ராய்டு அமைப்பு</string>
    <string name="phone_app_info">தொலைபேசி சேவைகள்</string>
    <string name="unknown_app_info">\"தெரியாதது\" பயன்பாட்டை தீர்மானிக்க முடியாத இணைப்புகளைக் குறிக்கிறது</string>
    <string name="packets_dropped">பாக்கெட்டுகள் கைவிடப்பட்டன</string>
    <string name="capture_prefs">பிடிப்பு</string>
    <string name="pending_transaction">இந்த அம்சத்தை மீட்டெடுக்க உங்கள் பரிவர்த்தனையை முடிக்கவும்</string>
    <string name="ctrl_consent">ஒரு பயன்பாடு உங்கள் சாதன போக்குவரத்தை கைப்பற்ற விரும்புகிறது.\n உங்களுக்கு உறுதியாக தெரியவில்லை என்றால் அதை மறுக்கவும்</string>
    <string name="deny">மறுக்கவும்</string>
    <string name="allow">இசைவு</string>
    <string name="ctrl_consent_title">Pcapdroid கட்டுப்பாட்டு கோரிக்கை</string>
    <string name="ctrl_consent_denied">Pcapdroid: கட்டுப்பாட்டு கோரிக்கை மறுக்கப்பட்டது</string>
    <string name="ctrl_consent_allowed">Pcapdroid: கட்டுப்பாட்டு கோரிக்கை அனுமதிக்கப்பட்டது</string>
    <string name="capture_interface">இடைமுகத்தைப் பிடிக்கவும்</string>
    <string name="internet">இணையம்</string>
    <string name="all_interfaces">அனைத்து இடைமுகங்களும்</string>
    <string name="capturing_from">\"%1$s\" இலிருந்து பாக்கெட்டுகளை கைப்பற்றுதல்</string>
    <string name="edit_filter">வடிகட்டியைத் திருத்து</string>
    <string name="edit_list">பட்டியலைத் திருத்து</string>
    <string name="hidden_connections_rules">மறைக்கப்பட்ட இணைப்புகள் விதிகள்</string>
    <string name="list_is_empty">பட்டியல் காலியாக உள்ளது</string>
    <string name="show_only_malicious">தீங்கிழைக்கும் இணைப்புகள்</string>
    <string name="show_only_cleartext">ClearText இணைப்புகள்</string>
    <string name="malware_detection">தீம்பொருள் கண்டறிதல்</string>
    <string name="malware_detection_summary">மூன்றாம் தரப்பு தடுப்புப்பட்டியல் வழியாக அறியப்பட்ட தீங்கிழைக்கும் புரவலர்களுக்கான இணைப்பைக் கண்டறியவும்</string>
    <string name="reset">மீட்டமை</string>
    <string name="malware_whitelist_rules">தீம்பொருள் அனுமதிப்பட்டியல் விதிகள்</string>
    <string name="feature_not_available">இந்த நற்பொருத்தம் தற்போது உங்கள் சாதனத்திற்கு கிடைக்கவில்லை</string>
    <string name="billing_connecting">Google Play க்கான இணைப்பு நடந்து வருகிறது, தயவுசெய்து சிறிது நேரத்தில் மீண்டும் முயற்சிக்கவும்</string>
    <string name="malware_whitelist_help">கருப்பொருள் கண்டறிதலைத் தடுக்க பயனர் வரையறுக்கப்பட்ட அனுமதிப்பட்டியலாளர். தீங்கிழைக்கும் இணைப்புகளைக் கருப்பொருள் எனக் குறைக்கும் விதிகளை உருவாக்க நீண்ட அழுத்தமாக இருக்கும்</string>
    <string name="hidden_connections_help">இணைப்பு-பட்டியல் உள்ளீடுகளை மறைக்க விதிகளின் பட்டியல், எனவே நீங்கள் தொடர்புடையவற்றில் கவனம் செலுத்தலாம்</string>
    <string name="malicious_connection_filter">தீங்கிழைக்கும்</string>
    <string name="status_filter">HTTP நிலை: %1$s</string>
    <string name="not_hidden_filter">மறைக்கப்படவில்லை</string>
    <string name="copy_action">நகலெடு…</string>
    <string name="url_val">URL: %1$s</string>
    <string name="show_me">என்னைக் காட்டு</string>
    <string name="hint">குறிப்பு</string>
    <string name="once">ஒருமுறை</string>
    <string name="forever">என்றென்றும்</string>
    <string name="control_permissions">கட்டுப்பாட்டு அனுமதிகள்</string>
    <string name="control_permissions_summary">பி.சி.ஏ.பி டிராய்டு பிடிப்பைக் கட்டுப்படுத்த எந்த பயன்பாடுகள் அனுமதிக்கப்படுகின்றன என்பதைச் சரிபார்க்கவும்</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">நாடு</string>
    <string name="asn">ASN</string>
    <string name="country_val">நாடு: %1$s</string>
    <string name="send_report">அறிக்கை அனுப்பவும்</string>
    <string name="start_at_boot">துவக்கத்தில் தொடங்கவும்</string>
    <string name="start_at_boot_summary">துவக்கத்திற்குப் பிறகு ஆட்டோ-ச்டார்ட்ச் பிடிப்பு</string>
    <string name="malware_status_ok">தீங்கிழைக்கும் போக்குவரத்து எதுவும் கண்டறியப்படவில்லை</string>
    <string name="malware_status_detected">தீங்கிழைக்கும் இணைப்புகள் கண்டறியப்பட்டன</string>
    <string name="whitelist">அனுமதிப்பட்டியலாளர்</string>
    <string name="blacklists">தடுப்புப்பட்டியல்</string>
    <string name="status_outdated">காலாவதியான</string>
    <string name="status_not_loaded">ஏற்றப்படவில்லை</string>
    <string name="status_uptodate">புதுப்பித்த</string>
    <string name="blacklist_type">வகை: %1$s</string>
    <string name="blacklist_type_ip">ஐபி பிளாக்லிச்ட்</string>
    <string name="blacklist_type_domain">டொமைன் பிளாக்லிச்ட்</string>
    <string name="n_rules">%1$s விதிகள்</string>
    <string name="last_update_val">கடைசி புதுப்பிப்பு: %1$s</string>
    <string name="malicious_connections">தீங்கிழைக்கும் இணைப்புகள்</string>
    <string name="updated_blacklists">புதுப்பிக்கப்பட்ட தடுப்புப்பட்டிகள்</string>
    <string name="connections_checked">இணைப்புகள் சரிபார்க்கப்பட்டன</string>
    <string name="last_blacklists_update">கடைசி புதுப்பிப்பு</string>
    <string name="domain_rules">டொமைன் விதிகள்</string>
    <string name="ip_rules">ஐபி விதிகள்</string>
    <string name="malware_status_update_failed">சில தடுப்புப்பட்டியல்கள் காலாவதியானவை</string>
    <string name="update_now">இப்போது புதுப்பிக்கவும்</string>
    <string name="status_updating">புதுப்பித்தல்…</string>
    <string name="malware_detection_learn_more">தீம்பொருள் கண்டறிதல் அம்சத்தைப் பற்றி மேலும் அறிக</string>
    <string name="private_dns_message_notice">தனியார் டிஎன்எச் போக்குவரத்தை ஆய்வு செய்வதிலிருந்து பி.சி.ஏ.பி டிராய்டைத் தடுக்கிறது. நீங்கள் அதை ஆண்ட்ராய்டு பிணையம் அமைப்புகளிலிருந்து அணைக்கலாம்</string>
    <string name="private_dns_hinders_detection">தனியார் டி.என்.எச் கண்டறிதலைத் தடுக்கிறது</string>
    <string name="decryption_no_filter_warn">இணையத்துடனான உங்கள் தொடர்பை இழப்பதைத் தவிர்க்க TLS ஐ மறைகுறியாக்கும்போது இலக்கு பயன்பாட்டைத் தேர்ந்தெடுக்கவும்</string>
    <string name="block">தொகுதி…</string>
    <string name="unblock">தடை நீக்கு…</string>
    <string name="firewall">ஃபயர்வால்</string>
    <string name="firewall_rules">ஃபயர்வால் விதிகள்</string>
    <string name="blocked_pkts">தடுக்கப்பட்டது</string>
    <string name="n_pkts">%1$s PKTS</string>
    <string name="blocked_connection_filter">தடுக்கப்பட்டது</string>
    <string name="allowed_connection_filter">அனுமதிக்கப்படுகிறது</string>
    <string name="firewall_filter">ஃபயர்வால்: %1$s</string>
    <string name="paid_features">கட்டண நற்பொருத்தங்கள்</string>
    <string name="validate">சரிபார்க்கவும்</string>
    <string name="valid">செல்லுபடியாகும்</string>
    <string name="invalid">செல்லுபடியாகாத</string>
    <string name="no_intent_handler_found">இந்த செயலைச் செய்ய எந்த பயன்பாடும் கிடைக்கவில்லை</string>
    <string name="network_interface">இடைமுகம்</string>
    <string name="interface_filter">இடைமுகம்: %1$s</string>
    <string name="request_method">கோரிக்கை முறை</string>
    <string name="content_type">உள்ளடக்க வகை</string>
    <string name="http_status">HTTP நிலை</string>
    <string name="payload_size_threshold">பேலோட் அளவு வரம்பு</string>
    <string name="method_filter">முறை: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="loading">ஏற்றுகிறது…</string>
    <string name="purchased">வாங்கப்பட்டது</string>
    <string name="no_items_for_purchase">வாங்குவதற்கு எந்த பொருட்களும் கிடைக்கவில்லை</string>
    <string name="billing_failure">Google Play உடன் இணைக்க முடியவில்லை. சிறிது நேரத்தில் மீண்டும் முயற்சிக்கவும்</string>
    <string name="learn_more">மேலும் அறிக</string>
    <string name="buy_action">வாங்க</string>
    <string name="capture_not_running_status">பிடிப்பு இயங்கவில்லை</string>
    <string name="start_capture_first">முதலில் பிடிப்பைத் தொடங்குங்கள்</string>
    <string name="copied">நகலெடுக்கப்பட்டது</string>
    <string name="can_use_purchased_feature">நீங்கள் இப்போது வாங்கிய அம்சத்தைப் பயன்படுத்தலாம்</string>
    <string name="disconnect_vpn_confirm">தொடர்வது செயலில் உள்ள VPN ஐ துண்டிக்கும்</string>
    <string name="loading_apps">பயன்பாடுகளை ஏற்றுகிறது…</string>
    <string name="open_nav_drawer">திறந்த அலமாரியை</string>
    <string name="close_nav_drawer">மூடு அலமாரியை மூடு</string>
    <string name="capture_all_apps">அனைத்து பயன்பாடுகளின் போக்குவரத்தையும் கைப்பற்றவும்</string>
    <string name="save_ok">சேமிக்கப்பட்டது</string>
    <string name="tls_decryption">டி.எல்.எச் மறைகுறியாக்கம்</string>
    <string name="tls_decryption_summary">எம்ஐடிஎம் செய்வதன் மூலம் எச்எச்எல்/டிஎல்எச் போக்குவரத்தை டிக்ரிப்ட் செய்யுங்கள். இது இப்போது சில பயன்பாடுகளுடன் வேலை செய்யலாம், பயனர் வழிகாட்டியைப் பாருங்கள்</string>
    <string name="traffic_inspection">போக்குவரத்து ஆய்வு</string>
    <string name="mitm_start_failed">MITM சேவையைத் தொடங்க முடியவில்லை. MITM ADDON பயன்பாட்டை கைமுறையாக திறந்து மீண்டும் முயற்சிக்கவும்</string>
    <string name="mitm_setup_wizard">எம்ஐடிஎம் அமைவு வழிகாட்டி</string>
    <string name="install_action">நிறுவவும்</string>
    <string name="export_action">ஏற்றுமதி</string>
    <string name="export_ellipsis">ஏற்றுமதி…</string>
    <string name="install_the_mitm_addon">PCAPDroid <a href="%1$s"> MITM addon </a> ஐ நிறுவவும்</string>
    <string name="export_ca_certificate">PCAPDroid CA சான்றிதழை ஏற்றுமதி செய்து, பின்னர் ஆண்ட்ராய்டு \"குறியாக்க மற்றும் நற்சான்றிதழ்கள்\" அமைப்புகளைத் திறந்து அதை \"CA சான்றிதழ்\" ஆக நிறுவவும் என்பதைத் தேர்வுசெய்க</string>
    <string name="install_ca_certificate">\"VPN மற்றும் APPS\" ஐத் தேர்ந்தெடுத்து PCAPDroid CA சான்றிதழை நிறுவவும். ஆண்ட்ராய்டு உங்கள் பூட்டு திரை அல்லது கடவுச்சொல்லைக் கேட்கும்</string>
    <string name="checking_the_certificate">சான்றிதழை சரிபார்க்கிறது…</string>
    <string name="ca_cert_export_failed">CA சான்றிதழை ஏற்றுமதி செய்யும் போது பிழை ஏற்பட்டது\n\n பின்னணி சேவைகள் செயல்படுத்தலைக் கட்டுப்படுத்த உங்கள் சாதனம் ஆட்டோச்டார்ட் அல்லது ஒத்த மென்பொருளை செயல்படுத்தினால், <a href="%1$s"> வைட்லிச்ட் pcapdroid </a> ஐ உறுதிப்படுத்திக் கொள்ளுங்கள்</string>
    <string name="cert_exported_now_installed">சான்றிதழ் ஏற்றுமதி செய்யப்பட்டது, இப்போது அதை ஆண்ட்ராய்டு அமைப்புகளிலிருந்து நிறுவவும்</string>
    <string name="cert_installed_correctly">CA சான்றிதழ் நிறுவப்பட்டுள்ளது</string>
    <string name="cert_reinstall_required">CA சான்றிதழ் நிறுவப்படவில்லை, MITM அமைவு வழிகாட்டியை இயக்கவும்</string>
    <string name="mitm_addon_bad_version">மோசமான PCAPDROID MITM ADDON பதிப்பு. பதிப்பு %1$s ஐ நிறுவி மீண்டும் முயற்சிக்கவும்</string>
    <string name="update_available">புதுப்பிப்பு கிடைக்கிறது</string>
    <string name="mitm_addon_update_available">புதிய MITM ADDON புதுப்பிப்பு கிடைக்கிறது. அண்மைக் கால பிழை திருத்தங்களைப் பெற புதுப்பிக்கவும்</string>
    <string name="mitm_addon_new_version">PCAPDroid MITM ADDON புதுப்பிக்கப்பட வேண்டும்</string>
    <string name="mitm_addon">MITM addon</string>
    <string name="update_action">புதுப்பிப்பு</string>
    <string name="export_failed">ஏற்றுமதி தோல்வியடைந்தது</string>
    <string name="not_encrypted">குறியாக்கம் செய்யப்படவில்லை</string>
    <string name="request">கோரிக்கை</string>
    <string name="response">பதில்</string>
    <string name="overview">கண்ணோட்டம்</string>
    <string name="string_http_request">HTTP கோரிக்கை</string>
    <string name="string_http_response">HTTP பதில்</string>
    <string name="payload_truncated">பேலோட் துண்டிக்கப்படுகிறது. அதை முழுமையாகக் காட்ட, பிடிப்பதை நிறுத்தி, பி.சி.ஏ.பி டிராய்டு அமைப்புகளிலிருந்து \"%1$s\" ஐ இயக்கவும்</string>
    <string name="websocket">வெப்சாக்கெட்</string>
    <string name="http">Http</string>
    <string name="payload">தாங்குசுமை</string>
    <string name="tx_direction">Tx</string>
    <string name="rx_direction">ஆர்.எக்ச்</string>
    <string name="full_payload">முழு பேலோட்</string>
    <string name="full_payload_summary">முழு இணைப்புகள் பேலோடைக் காட்டு (எ.கா. முழு HTTP கோரிக்கை மற்றும் பதில்). இதற்கு நிறைய நினைவகம் தேவைப்படுகிறது, நீண்ட காலத்திற்கு பயன்படுத்த வேண்டாம்</string>
    <string name="not_decryptable">மறைகுறியாக்க முடியாதது</string>
    <string name="decrypted">மறைகுறியாக்கப்பட்டது</string>
    <string name="decryption">மறைகுறியாக்கம்</string>
    <string name="decryption_filter">நிலை: %1$s</string>
    <string name="connection_start_not_seen">இந்த இணைப்பின் தொடக்கத்தை pcapdroid பார்த்ததில்லை. சில தகவல்கள் காணவில்லை</string>
    <string name="network_traffic">போக்குவரத்து</string>
    <string name="warn_no_app_data">பயன்பாட்டு தரவு எதுவும் பரிமாறப்படவில்லை</string>
    <string name="waiting_application_data">காத்திருக்கும் தரவு</string>
    <string name="text">உரை</string>
    <string name="hexdump">ஃச் டம்ப்</string>
    <string name="display_as_text">உரையாக காட்டு</string>
    <string name="display_as_hexdump">ஹெக்ஸ்டம்ப்பாகக் காட்டு</string>
    <string name="geolocation">புவிஇருப்பிடம்</string>
    <string name="geolocation_summary">இணைப்பில்லாத தேடல்களைச் செய்வதன் மூலம் நாடு மற்றும் ஏ.எச்.என் தகவலைக் காட்டு</string>
    <string name="downloading">பதிவிறக்கம்…</string>
    <string name="download_in_progress">பதிவிறக்கம் முன்னேற்றம், தயவுசெய்து காத்திருங்கள்</string>
    <string name="pcap_load_in_progress">கோப்பு ஏற்றுதல் முன்னேற்றத்தில் உள்ளது, தயவுசெய்து காத்திருங்கள்</string>
    <string name="download_failed">பதிவிறக்கம் தோல்வியடைந்தது</string>
    <string name="exporting">ஏற்றுமதி செய்கிறது…</string>
    <string name="export_in_progress">ஏற்றுமதி நடைபெறுகிறது, காத்திருக்கவும்</string>
    <string name="geo_db_not_found">தரவுத்தளம் கிடைக்கவில்லை. புவிஇருப்பிடம் முடக்கப்பட்டுள்ளது</string>
    <string name="database">தரவுத்தளம்</string>
    <string name="built_on">கட்டப்பட்டது: %1$s</string>
    <string name="geo_db_download">அண்மைக் கால தரவுத்தளத்தைப் பதிவிறக்க தட்டவும். புதிய தரவுத்தளங்கள் மாதந்தோறும் கிடைக்கின்றன</string>
    <string name="size_x">அளவு: %1$s</string>
    <string name="geo_db_delete">தரவுத்தளத்தை நீக்க மற்றும் இடத்தை சேமிக்க தட்டவும்</string>
    <string name="download">பதிவிறக்கம்</string>
    <string name="connection_blocked">இந்த இணைப்பு pcapdroid ஆல் தடுக்கப்பட்டுள்ளது</string>
    <string name="import_action">இறக்குமதி</string>
    <string name="import_failed">இறக்குமதி தோல்வியடைந்தது</string>
    <string name="invalid_backup">தவறான காப்புப்பிரதி வடிவம்</string>
    <string name="rules_import_success">இறக்குமதி செய்யப்பட்ட %1$d விதிகள்</string>
    <string name="no_rules_to_export">ஏற்றுமதி செய்ய விதிகள் இல்லை</string>
    <string name="rules_merge_msg">இருக்கும் விதிகளை வைத்திருக்கவா?</string>
    <string name="keep_action">வைத்திருங்கள்</string>
    <string name="discard_action">நிராகரிக்கவும்</string>
    <string name="rules_delete_confirm">தேர்ந்தெடுக்கப்பட்ட விதிகளை நீக்கவா?</string>
    <string name="blocklist">பிளாக்லிச்ட்</string>
    <string name="num_configured_rules">கட்டமைக்கப்பட்ட விதிகள்</string>
    <string name="connections_blocked">இணைப்புகள் தடுக்கப்பட்டன</string>
    <string name="last_firewall_block">கடைசி தொகுதி</string>
    <string name="firewall_is_disabled">ஃபயர்வால் முடக்கப்பட்டுள்ளது</string>
    <string name="firewall_is_enabled">ஃபயர்வால் இயக்கப்பட்டது</string>
    <string name="app_info">பயன்பாட்டு செய்தி</string>
    <string name="action_block">தொகுதி</string>
    <string name="action_unblock">தடை நீக்கு</string>
    <string name="netd_block_missed">இந்த இணைப்பு NETD ஆல் தொடங்கப்பட்டது, எனவே அதைத் தடுக்க முடியவில்லை</string>
    <string name="firewall_summary">பயன்பாடுகளுக்கான இணைய அணுகலைத் தடு, குறிப்பிட்ட களங்கள் மற்றும் ஐபி முகவரிகளுக்கான விதிகளை உள்ளமைக்கவும். ரூட் அல்லாத பிடிப்புடன் மட்டுமே வேலை செய்கிறது</string>
    <string name="no_root_firewall">ரூட் ஃபயர்வால் இல்லை</string>
    <string name="block_quick">தொகுதி குவிக்</string>
    <string name="block_private_dns">தனியார் டி.என்.எச்</string>
    <string name="block_private_dns_summary">டி.என்.எச் போக்குவரத்தை ஆய்வு செய்ய தனியார் டி.என்.எச்சைக் கண்டறிந்து தடுக்கலாம். இதை முடக்குவது போக்குவரத்து பகுப்பாய்விற்கு இடையூறு விளைவிக்கும்</string>
    <string name="mitm_setup_wizard_intro">இந்த வழிகாட்டி PCAPDroid MITM துணை நிரல் மற்றும் சான்றிதழ் ஆணையத்தை நிறுவுவதன் மூலம் உங்களுக்கு வழிகாட்டும், அவை <a href="%1$s"> TLS மறைகுறியாக்க </a> செய்ய வேண்டும்</string>
    <string name="mitm_setup_wizard_done">பி.சி.ஏ.பி டிராய்டு இப்போது டி.எல்.எச் போக்குவரத்தை மறைகுறியாக்க தயாராக உள்ளது\n\n மறைகுறியாக்கத்தைத் தடுக்கக்கூடிய பாதுகாப்பு நடவடிக்கைகள் மற்றும் அவற்றை எவ்வாறு புறக்கணிப்பது என்பதைப் பற்றி மேலும் அறிய <a href="%1$s"> பயனர் கையேடு </a> ஐப் பாருங்கள்</string>
    <string name="welcome_to_pcapdroid">PCAPDROID க்கு வருக</string>
    <string name="app_intro_next_button">அடுத்தது</string>
    <string name="app_intro_skip_button">தவிர்</string>
    <string name="app_intro_back_button">பின்</string>
    <string name="app_intro_done_button">முடிந்தது</string>
    <string name="app_intro_welcome_msg">பி.சி.ஏ.பி டிராய்டு என்பது ஒரு தனியுரிமை நட்பு பயன்பாடாகும், இது உங்கள் சாதனத்தில் உள்ள பயன்பாடுகளால் செய்யப்பட்ட இணைப்புகளைக் கண்காணிக்கவும் பகுப்பாய்வு செய்யவும் உங்களை அனுமதிக்கிறது\n\n மேலும், போக்குவரத்தின் பி.சி.ஏ.பி டம்பை ஏற்றுமதி செய்ய, மேனிலை தரவு மற்றும் பலவற்றை ஏற்றுமதி செய்ய இது உங்களை அனுமதிக்கிறது!</string>
    <string name="privacy_first">முதலில் தனியுரிமை</string>
    <string name="app_intro_privacy_msg">பயன்பாடு எந்தவொரு கண்காணிப்பு, பகுப்பாய்வு அல்லது தொலைபேசியில்-வீட்டு-எதிர்ப்பு அம்சங்களைப் பயன்படுத்தாது\n\n நீங்கள் எப்படி உறுதியாக இருக்க முடியும்? அதன் <a href="%1$s"> தனியுரிமைக் கொள்கை </a> மற்றும் அதன் <a href="%2$s"> மூலக் குறியீடு </a> ஐப் பாருங்கள்</string>
    <string name="country_and_asn">நாடு மற்றும் அச்ன்</string>
    <string name="app_intro_geolocation_msg">தொலைநிலை சேவையகத்தின் நாட்டைத் தீர்மானிக்க பி.சி.ஏ.பி டிராய்டு உள்ளக தரவுத்தளத்தை வினவலாம்\n\n நீங்கள் முதலில் பயன்பாட்டு அமைப்புகளிலிருந்து புவிஇருப்பிட தரவுத்தளத்தை பதிவிறக்கம் செய்ய வேண்டும்</string>
    <string name="vpn_setup_msg">ரூட் இல்லாமல் பிணைய போக்குவரத்தை கைப்பற்ற பி.சி.ஏ.பி டிராய்டு ஒரு வி.பி.என் உருவகப்படுத்துகிறது.\n\n பிடிப்பைத் தொடங்க, அடுத்த திரையில் VPN கோரிக்கையை நீங்கள் ஏற்க வேண்டும்.\n\n <b> குறிப்பு: </b> தொடர, ஆண்ட்ராய்டு அமைப்புகளிலிருந்து எப்போதும் உள்ளமைக்கப்பட்ட VPN ஐ முடக்கு</string>
    <string name="app_intro_traffic_inspection">HTTP கோரிக்கைகள், பதில்கள் மற்றும் மூல தரவுகளை ஆய்வு செய்வது எளிதானது, உள்ளமைக்கப்பட்ட டிகோடர்களுக்கு நன்றி\n\n மறைகுறியாக்கப்பட்ட இணைப்பு கிடைத்ததா? மறைகுறியாக்கப்பட்ட தரவைப் பெற நீங்கள் <a href="%1$s"> TLS மறைகுறியாக்கம் </a> ஐ இயக்கலாம்</string>
    <string name="app_intro_firewall_msg">ஒருங்கிணைந்த <a href="%1$s"> ஃபயர்வால் </a> மூலம் தனிப்பட்ட பயன்பாடுகள், களங்கள் மற்றும் நாடுகளுக்கான இணைய அணுகலை நீங்கள் எளிதாக தடுக்கலாம் \n\nஉங்கள் தனியுரிமையைப் பாதுகாக்க இறுதி கருவியைப் பெற உள்ளமைக்கப்பட்ட போக்குவரத்து தெரிவுநிலையுடன் இதை இணைக்கவும்</string>
    <string name="app_intro_malware_detection"><a href="%1$s"> கருப்பொருள் கண்டறிதல் </a> அம்சத்துடன் உங்கள் சாதனத்தின் பாதுகாப்பை மேம்படுத்தவும்\n\n புதுப்பித்த தடுப்புப்பட்டியல்களைப் பயன்படுத்துவதன் மூலம், இது நிகழ்நேரத்தில் தீங்கிழைக்கும் இணைப்புகளைக் கண்டறிந்து, தடுக்கலாம் மற்றும் எச்சரிக்கலாம்</string>
    <string name="app_intro_traffic_dump">பி.சி.ஏ.பி டிராய்டு <a href="%1$s"> பல வழிகளை </a> வழங்குகிறது \n\n<a href="%2$s"> pcapdroid நீட்டிப்பு விருப்பம் </a> வழியாக, நீங்கள் பாக்கெட்டுகளில் பயன்பாட்டு பெயர்களைச் சேர்த்து அவற்றை வயர்சார்க்கில் காண்பிக்கலாம்</string>
    <string name="permission_granted">%1$s இசைவு வழங்கப்பட்டது</string>
    <string name="permission_grant_fail">%1$s இசைவு வழங்க முடியாது</string>
    <string name="connection_not_found">கொடுக்கப்பட்ட இணைப்பைக் கண்டுபிடிக்க முடியவில்லை</string>
    <string name="low_memory">குறைந்த நினைவகம்</string>
    <string name="low_memory_info">பயன்பாடு நினைவகத்திற்கு வெளியே இயங்குகிறது, செயலிழப்புகளை எதிர்பார்க்கலாம்</string>
    <string name="full_payload_disabled">முழு பேலோட் விருப்பம் முடக்கப்பட்டுள்ளது</string>
    <string name="capture_stopped_low_memory">பிடிப்பு நிறுத்தப்பட்டுள்ளது</string>
    <string name="heap_usage">குவியல் பயன்பாடு</string>
    <string name="memory_usage">நினைவக பயன்பாடு</string>
    <string name="vpn_lockdown_notice">PCAPDroid இயங்காதபோது பயன்பாடுகள் இணையத்தை அணுகுவதைத் தடுக்க (எ.கா. மறுதொடக்கத்திற்குப் பிறகு) நீங்கள் பூட்டப்பட்ட பயன்முறையில் எப்போதும் VPN ஆக PCAPDroid ஐ அமைக்கலாம்.\n\n நீங்கள் இப்போது VPN அமைப்புகளைத் திறக்க விரும்புகிறீர்களா?</string>
    <string name="ip_mode">VPN IP முகவரிகள்</string>
    <string name="ipv4_only">IPv4 மட்டும்</string>
    <string name="ipv6_only">IPv6 மட்டும்</string>
    <string name="ip_both">ஐபிவி 4 மற்றும் ஐபிவி 6</string>
    <string name="notifications_notice">ஒழுங்கற்ற நிகழ்வுகளின் போது விழிப்பூட்டல்களை அனுப்ப பயன்பாடு அறிவிப்புகளைப் பயன்படுத்துகிறது. அடுத்த திரையில் அறிவிப்புகளை அனுப்ப இசைவு வழங்கவும்</string>
    <string name="vpn_exemptions">VPN விலக்குகள்</string>
    <string name="vpn_exemptions_summary">VPN இணைப்பிலிருந்து சில பயன்பாடுகளுக்கு விலக்கு. அவர்களின் போக்குவரத்து கண்காணிக்கப்படாது</string>
    <string name="no_matches_found">போட்டிகள் இல்லை</string>
    <string name="cleartext_connection">தெளிவான டெக்ச்ட்</string>
    <string name="unblock_permanently">நிரந்தரமாக தடை நீக்கு</string>
    <string name="unblock_for_n_hours">%1$dh க்கு தடை நீக்கு</string>
    <string name="unblock_for_n_minutes">%1$dm க்கு தடை நீக்கு</string>
    <string name="block_new_apps">புதிதாக நிறுவப்பட்ட பயன்பாடுகளைத் தடுக்கவும்</string>
    <string name="app_blocked">பயன்பாடு தடுக்கப்பட்டது</string>
    <string name="app_blocked_info">%1$s பயன்பாடு ஃபயர்வால் தடுக்கப்பட்டுள்ளது</string>
    <string name="payload_scams_notice">இந்த பார்வையில் உங்கள் கடவுச்சொற்கள் மற்றும் அணுகல் டோக்கன்கள் போன்ற முக்கியமான தகவல்கள் இருக்கலாம்.\n\n இந்த தகவலை ஒருபோதும் யாருக்கும் கொடுக்க வேண்டாம், இது ஒரு மோசடி முயற்சியாக இருக்கலாம்</string>
    <string name="cancel_action">ரத்துசெய்</string>
    <string name="show_data_action">தரவைக் காட்டு</string>
    <string name="remote_collector_notice">தொலைநிலை சேவையகத்திற்கு போக்குவரத்தை அனுப்ப PCAPDroid ஐ கட்டமைத்துள்ளீர்கள். சேவையகம் உங்கள் முக்கியமான தகவல்களை அணுக முடியும்.\n\n இதைச் செய்ய யாராவது உங்களிடம் கேட்டால், அது ஒரு மோசடி முயற்சி</string>
    <string name="remote_server_warning">பாதுகாப்பு காரணங்களுக்காக, தொலை சேவையகத்திற்கு போக்குவரத்தை அனுப்புவது \"%1$s\" அனுமதிக்கப்படவில்லை</string>
    <string name="warning">எச்சரிக்கை</string>
    <string name="paid_features_unlocked">கட்டண நற்பொருத்தங்கள் திறக்கப்பட்டன. ஓடியால் பிடிப்பை மறுதொடக்கம் செய்யுங்கள்</string>
    <string name="build_info">தகவலை உருவாக்குங்கள்</string>
    <string name="tls_decryption_with_root_msg">ரூட் மூலம் டி.எல்.எச்மறைகுறியாக்கத்தை இயக்கும் திறன் ஒரு சோதனை அம்சமாகும். இது அறியப்பட்ட பிழைகளின் பட்டியல்:\n\n - pcapdroid இல், அசல் பயன்பாட்டிற்கு பதிலாக MITM- அடான் பயன்பாட்டிலிருந்து உருவாக்கப்பட்ட போக்குவரத்தை நீங்கள் காண்பீர்கள்\n - SSL கீலாக் டம்ப் ஆதரிக்கப்படவில்லை\n - பயன்பாட்டு வடிகட்டி அமைக்கப்படும்போது, இலக்கு பயன்பாட்டிற்கு மட்டுமே மறைகுறியாக்கம் ஏற்படும், ஆனால் பி.சி.ஏ.பி டிராய்டு இன்னும் மற்ற பயன்பாடுகளின் போக்குவரத்தைக் காண்பிக்கும்\n - பிடிப்பு தொடங்கத் தவறினால், நீங்கள் உண்மையில் iptables கட்டளையை ரூட்டாக இயக்க முடியும் என்பதை உறுதிப்படுத்தவும்\n - இது ஆண்ட்ராய்டு 12 மற்றும் அதற்குப் பிறகு வேலை செய்யாது\n - ஒரு VPN செயலி இயங்கினால், நீங்கள் ஒரு குறிப்பிட்ட செயலியை மறைகுறியாக்கத்திற்காக இலக்காகக் கொள்ள வேண்டும் அல்லது PCAPdroid mitm addon ஐ VPN இலிருந்து விலக்க வேண்டும், இல்லையெனில் போக்குவரத்து ஒரு சுழற்சியில் செல்லும்</string>
    <string name="unlock_token_summary">பயன்பாட்டின் கூகிள் அல்லாத விளையாட்டு கட்டமைப்புகளில் கட்டண அம்சங்களைத் திறக்க பயன்படுத்தக்கூடிய ஒரு கிள்ளாக்கு (எ.கா. எஃப்-டிராய்டு/கிதுப்)</string>
    <string name="unlock_token_error">திறத்தல் கிள்ளாக்கை கோர முடியவில்லை [ %1$d]: %2$s</string>
    <string name="access_paid_features_msg">கட்டண அம்சங்களை எவ்வாறு அணுகுவது என்பதை அறிய <a href="%1$s">பயனர் கையேடு </a> ஐப் பாருங்கள்</string>
    <string name="license_service_unavailable">PCAPDroid உரிம பணி தற்போது கிடைக்கவில்லை. தயவுசெய்து சில நிமிடங்களில் மீண்டும் முயற்சிக்கவும்</string>
    <string name="requesting_unlock_token">திறத்தல் டோக்கனைக் கோருகிறது, தயவுசெய்து காத்திருங்கள்</string>
    <string name="show_action">காட்டு</string>
    <string name="show_connection">இணைப்பைக் காட்டு</string>
    <string name="show_system_apps">கணினி பயன்பாடுகளைக் காட்டு</string>
    <string name="unlock_token_msg1">இது உங்கள் திறத்தல் கிள்ளாக்கு. <a href="%1$s">உங்கள் உரிமக் குறியீடுகளை</a> உருவாக்க உங்களுக்குத் தேவைப்படுவதால் அதைக் கவனியுங்கள்</string>
    <string name="paid_feature">கட்டண நற்பொருத்தம்</string>
    <string name="firewall_purchase_msg">இணைப்புகளைத் தடுக்கத் தொடங்க <i>%1$s </i> அம்சத்தை வாங்கவும்</string>
    <string name="mitm_skip_notice">எம்ஐடிஎம் சான்றிதழ் நிறுவப்பட்டதாகத் தெரியவில்லை. நீங்கள் தொடர்ந்தால், மறைகுறியாக்கம் தோல்வியடையக்கூடும்</string>
    <string name="mitm_wizard_description">TLS மறைகுறியாக்கத்திற்கான சாதனத்தை உள்ளமைக்கவும்</string>
    <string name="mitmproxy_opts">கூடுதல் MITMProxy விருப்பங்கள்</string>
    <string name="mitmproxy_opts_description">MITMProxy க்கு கூடுதல் விருப்பங்களை வழங்கவும்</string>
    <string name="mitm_addon_error">MITM addon ஐத் தொடங்கும் போது பிழை. விவரங்களுக்கு பதிவைச் சரிபார்க்கவும்</string>
    <string name="whitelist_mode">அனுமதிப்பட்டியல் பயன்முறை</string>
    <string name="firewall_whitelist_notice">இந்த பயன்முறையில் அனைத்து இணைப்புகளும் தடுக்கப்படும், கைமுறையாக அனுமதிப்பட்டி செய்யப்படாவிட்டால். சரியான அனுமதிப்பட்டியலாளர் இல்லாமல் புச் அறிவிப்புகளை நீங்கள் இழக்க நேரிடும்</string>
    <string name="firewall_whitelist_help">இந்த விதிகள் எந்த இணைப்புகளை அனுமதிக்க வேண்டும் என்பதைக் குறிப்பிடுகின்றன. பிளாக்லிச்ட் விதிகளுக்கு அனுமதிப்பிடிப்பு விதிகளை விட முன்னுரிமை உள்ளது</string>
    <string name="add_to_fw_whitelist">ஃபயர்வால் அனுமதிப்பட்டியலில் சேர்க்கவும்</string>
    <string name="remove_from_fw_whitelist">ஃபயர்வால் அனுமதிப்பட்டியிலிருந்து அகற்றவும்</string>
    <string name="reset_stats_confirm">இந்த புள்ளிவிவரங்களை மீட்டமைக்க விரும்புகிறீர்களா?</string>
    <string name="port_mapping">போர்ட் மேப்பிங்</string>
    <string name="port_mapping_summary">வேறு புரவலன் அல்லது போர்ட்டிற்கு இணைப்புகளை திருப்பிவிட போர்ட் மேப்பிங் விதிகளை உள்ளமைக்கவும்</string>
    <string name="add_action">கூட்டு</string>
    <string name="redirect_to">இதை திருப்பி விடுங்கள்:</string>
    <string name="original_port">அசல் போர்ட்</string>
    <string name="required">தேவை</string>
    <string name="destination_host">இலக்கு புரவலன்</string>
    <string name="destination_port">இலக்கு போர்ட்</string>
    <string name="port_mapping_exists">போர்ட் மேப்பிங் ஏற்கனவே வரையறுக்கப்பட்டுள்ளது</string>
    <string name="items_delete_confirm">தேர்ந்தெடுக்கப்பட்ட பொருட்களை நீக்கவா?</string>
    <string name="ip_address">ஐபி முகவரி</string>
    <string name="rule_exists">விதி ஏற்கனவே வரையறுக்கப்பட்டுள்ளது</string>
    <string name="dns_servers">டிஎன்எச் சேவையகங்கள்</string>
    <string name="dns_servers_summary">பிடிப்பின் போது பயன்படுத்த டிஎன்எச் சேவையகங்களை உள்ளமைக்கவும்</string>
    <string name="ipv4_dns_server">IPv4 DNS சேவையகம்</string>
    <string name="ipv6_dns_server">IPv6 DNS சேவையகம்</string>
    <string name="use_system_dns">சிச்டம் டி.என்.எச்</string>
    <string name="use_system_dns_summary">முடிந்தால் கணினி டிஎன்எச் சேவையகங்களைப் பயன்படுத்தவும்</string>
    <string name="external_storage_perm_required">வெளிப்புற சேமிப்பக இசைவு தேவை</string>
    <string name="many_rules_warning">நீங்கள் பல விதிகளை இறக்குமதி செய்ய முயற்சிக்கிறீர்கள், இது சில தொடர்புகளின் போது பயன்பாட்டை பதிலளிக்கவில்லை. நீங்கள் உண்மையில் தொடர விரும்புகிறீர்களா?</string>
    <string name="pcapng_format">Pcapng வடிவம்</string>
    <string name="pcapng_format_summary">Pcapng டம்ப் வடிவத்தில் டம்ப் பாக்கெட்டுகள், இது மிகவும் நெகிழ்வானது மற்றும் TLS மறைகுறியாக்க ரகசியங்களை உட்பொதிக்க அனுமதிக்கிறது</string>
    <string name="total_bytes">மொத்த பைட்டுகள்</string>
    <string name="write_ext_storage_failed">வெளிப்புற சேமிப்பகத்திற்கு எழுதுதல் தோல்வியடைந்தது. விவரங்களுக்கு பயன்பாட்டு பதிவை சரிபார்க்கவும்</string>
    <string name="username">பயனர்பெயர்</string>
    <string name="password">கடவுச்சொல்</string>
    <string name="mitm_addon_autostart_workaround">எம்ஐடிஎம் துணை நிரலுக்கான இணைப்பு தோல்வியடைந்தது. ஒரு பணித்தொகுப்பாக, நீங்கள் MITM ADDON பயன்பாட்டைத் திறக்க முயற்சி செய்யலாம், பின்னர் அதை மூடாமல் pcapdroid க்குச் செல்லலாம். இப்போது அதைத் திறக்க விரும்புகிறீர்களா?</string>
    <string name="qr_license_confirm">பின்வரும் திறத்தல் கிள்ளாக்கைப் பயன்படுத்தி \"%1$s\" சாதனத்திற்கான உரிமத்தை உருவாக்க விரும்புகிறீர்களா?</string>
    <string name="connection_error">இணைப்பு பிழை: %1$s</string>
    <string name="activate_via_qr_code">QR குறியீடு வழியாக செயல்படுத்தவும்</string>
    <string name="qr_code_expired">QR குறியீடு காலாவதியானது. புதிய QR குறியீட்டை உருவாக்கி மீண்டும் முயற்சிக்கவும்</string>
    <string name="qr_info_text">Google Play இலிருந்து PCAPDroid ஐ நிறுவி இந்த QR குறியீட்டை ச்கேன் செய்யுங்கள்</string>
    <string name="qr_purchase_required">QR குறியீடு செயல்படுத்தலுடன் தொடர திறத்தல் கிள்ளாக்கை வாங்கவும்</string>
    <string name="license_limit_reached">இந்த திறத்தல் டோக்கனுக்கான உரிம வரம்பை நீங்கள் அடைந்துவிட்டீர்கள். அதிக உரிமங்களை உருவாக்க புதிய கிள்ளாக்கை வாங்கவும்</string>
    <string name="license_error">உரிமம் உருவாக்கும் பிழை [ %1$d]: %2$s</string>
    <string name="requesting_license">உரிமக் குறியீட்டைக் கோருகிறது, தயவுசெய்து காத்திருங்கள்</string>
    <string name="license_activation_ok">உரிமம் செயல்படுத்தல் முடிந்தது</string>
    <string name="mitm_addon_starting">MITM addon தொடங்குகிறது…</string>
    <string name="mitm_addon_running">MITM ADDON இயங்குகிறது</string>
    <string name="decryption_rules">மறைகுறியாக்க விதிகள்</string>
    <string name="decryption_rules_help">இந்த விதிகள் எந்த இணைப்புகளை மறைகுறியாக்குகின்றன என்பதைக் குறிப்பிடுகின்றன. முன் டிஎன்எச் பதில் காணப்பட்டால் மட்டுமே புரவலன் அடிப்படையிலான விதிகள் வேலை செய்கின்றன</string>
    <string name="decrypt_action">டிக்ரிப்ட்…</string>
    <string name="dont_decrypt_action">மறைகுறியாக்க வேண்டாம்…</string>
    <string name="status_encrypted">குறியாக்கப்பட்டது</string>
    <string name="injected">செலுத்தப்பட்டது</string>
    <string name="open_pcap_file">PCAP/PCAPNG கோப்பைத் திறக்கவும்…</string>
    <string name="pcap_load_success">கைப்பற்றப்பட்ட கோப்பு ஏற்றப்பட்டது</string>
    <string name="invalid_pcap_file">தவறான பிடிப்பு கோப்பு வடிவம்</string>
    <string name="capture_interface_open_error">பிடிப்பு இடைமுகத்தைத் திறக்க முடியவில்லை</string>
    <string name="unsupported_pcap_datalink">கோப்பில் ஆதரிக்கப்படாத டேட்டாலிங்க் உள்ளது</string>
    <string name="pcap_file_not_exists">குறிப்பிட்ட கோப்பு இல்லை</string>
    <string name="root_capture_start_failed">தொடக்க தோல்வி. சாதனம் மேகிசுடன் வேரூன்றியிருப்பதை உறுதிசெய்க</string>
    <string name="root_capture_pcapd_start_failure">தொடக்க தோல்வி. PCAPDroid க்கு ரூட் அணுகலை வழங்குவதை உறுதிசெய்க</string>
    <string name="pcap_read_error">பிடிப்பு கோப்பைப் படிப்பதில் பிழை. விவரங்களுக்கு பதிவைச் சரிபார்க்கவும்</string>
    <string name="pcap_file_load_aborted">கைப்பற்றப்பட்ட கோப்பு ஏற்றுதல் நிறுத்தப்பட்டது</string>
    <string name="host_resolution_failed">புரவலன் %1$s ஐ தீர்க்க முடியவில்லை</string>
    <string name="pcapdroid_trailer_notice">\"%1$s\" க்கு பதிலாக உண்மையான பயன்பாடுகளைக் காட்ட, டம்பை உருவாக்குவதற்கு முன் \"%2$s\" விருப்பத்தை இயக்க மறக்காதீர்கள்</string>
    <string name="decryption_info_no_rule">இந்த இணைப்பை மறைகுறியாக்க, இடது டிராயரில் இருந்து அல்லது இணைப்புகள் பட்டியலில் உள்ள சூழல் மெனுவிலிருந்து ஒரு மறைகுறியாக்க விதியை உருவாக்கவும்</string>
    <string name="tls_decryption_no_rules_notice">கட்டமைக்கப்பட்ட விதிகளுடன் பொருந்தக்கூடிய இணைப்புகளுக்கு மட்டுமே டி.எல்.எச் மறைகுறியாக்கம் பயன்படுத்தப்படுகிறது. நீங்கள் இப்போது மறைகுறியாக்க விதிகளை உருவாக்க விரும்புகிறீர்களா?</string>
    <string name="active_vpn_detected">செயலில் VPN கண்டறியப்பட்டது</string>
    <string name="redirected">திருப்பி விடப்பட்டது</string>
    <string name="connection_redirected_port_map">போர்ட் மேப்பிங் விதி காரணமாக இந்த இணைப்பு திருப்பி விடப்பட்டுள்ளது</string>
    <string name="dnscrypt_how_to">PCAPDroid உடன் DOH / DNSCRYPT ஐ எவ்வாறு பயன்படுத்துவது</string>
    <string name="never">ஒருபோதும்</string>
    <string name="always">எப்போதும்</string>
    <string name="for_connections_to_decrypt">மறைகுறியாக்குவதற்கான இணைப்புகளுக்கு மட்டுமே</string>
    <string name="decrypt_quic_notice">மறைகுறியாக்கல் தற்போது ஆதரிக்கப்படவில்லை. ஒரு பணித்தொகுப்பாக, பிடிப்பதை நிறுத்தி, பி.சி.ஏ.பி டிராய்டு அமைப்புகளில் Quic ஐத் தடுக்க விருப்பத்தைத் தேர்ந்தெடுக்கவும்</string>
    <string name="target_apps">இலக்கு பயன்பாடுகள்</string>
    <string name="target_apps_help">கைப்பற்ற பயன்பாடுகளைத் தேர்ந்தெடுக்கவும்</string>
    <string name="headers">தலைப்பிகளுக்கு</string>
    <string name="body">உடல்</string>
    <string name="both">இரண்டும்</string>
    <string name="raw_bytes">மூல பைட்டுகள்</string>
    <string name="restart_on_disconnection">துண்டிக்கப்படுவதை மறுதொடக்கம் செய்யுங்கள்</string>
    <string name="restart_on_disconnection_summary">மற்ற VPN பயன்பாடுகளால் நிறுத்தப்பட்ட பின்னர் தானாகவே பிடிப்பை மறுதொடக்கம் செய்யுங்கள்</string>
    <string name="vpn_reconnection">VPN மறுதொடக்கம்</string>
    <string name="vpn_reconnection_aborted">VPN இணைப்பு கைவிடப்பட்டது</string>
    <string name="waiting_for_vpn_disconnect">செயலில் உள்ள வி.பி.என் துண்டிக்க காத்திருக்கிறது…</string>
    <string name="tcp_collector_info">TCP கலெக்டர்: %1$s: %2$d</string>
    <string name="tcp_exporter">டி.சி.பி ஏற்றுமதியாளர்</string>
    <string name="tcp_udp_exporter">TCP/UDP ஏற்றுமதியாளர்</string>
    <string name="tcp_exporter_info">தொலைநிலை TCP ரிசீவருக்கு PCAP ஐ அனுப்பவும் (PCAP-OVER-IP)</string>
    <string name="geo_db_missing">புவிஇருப்பிட தரவுத்தளம் இல்லை</string>
    <string name="dump_extensions_how_to">வயர்சார்க்கில் பி.சி.ஏ.பி டிராய்டு டம்ப் நீட்டிப்புகளை எவ்வாறு காண்பிப்பது</string>
    <string name="no_permissions_set_info">அனுமதிகள் எதுவும் அமைக்கப்படவில்லை. அனுமதிகள் வரியில் காட்ட StartactivityForresult வழியாக PCAPDROID ஐ அழைக்கவும்</string>
    <string name="generate_api_key">பநிஇ விசையை உருவாக்குங்கள்</string>
    <string name="show_api_key">பநிஇ விசையை காட்டு</string>
    <string name="api_key">பநிஇ விசை</string>
    <string name="api_key_discard_confirm">தற்போதைய பநிஇ விசையை நிராகரித்து புதிய ஒன்றை உருவாக்க விரும்புகிறீர்களா?</string>
    <string name="country_rules_warning">நாட்டை அடிப்படையாகக் கொண்ட ஃபயர்வால் விதிகளைப் பயன்படுத்த, பி.சி.ஏ.பி டிராய்டு அமைப்புகளிலிருந்து புவிஇருப்பிட தரவுத்தளத்தைப் பதிவிறக்குங்கள், இல்லையெனில் நாட்டை அடிப்படையாகக் கொண்ட விதிகள் பயனற்றதாக இருக்கும்</string>
    <string name="unsupported_pcap_file">ஆதரிக்கப்படாத பிடிப்பு கோப்பு வடிவம்</string>
    <string name="decrypt_pcap_file">பிசிஏபி/பி.சி.ஏ.பி.என்.சி கோப்பை டிக்ரிப்ட் செய்யுங்கள்…</string>
    <string name="errno_enetdown">பிணையம் கீழே உள்ளது</string>
    <string name="errno_enetdown_msg">பிணைய இடைமுகம் குறைந்துவிட்டது அல்லது பிணையத்துடன் இணைக்க முடியவில்லை</string>
    <string name="errno_enetunreach">பிணையம் அணுக முடியாதது</string>
    <string name="errno_enetunreach_msg">இலக்கு நெட்வொர்க்கிற்கு சரியான வழியை கணினியால் கண்டுபிடிக்க முடியவில்லை</string>
    <string name="errno_enetreset">பிணையம் மீட்டமைப்பு</string>
    <string name="errno_econnaborted">இணைப்பு கைவிடப்பட்டது</string>
    <string name="errno_econnaborted_msg">பொதுவாக பிணைய மாற்றம் காரணமாக இணைப்பு நிறுத்தப்பட்டது</string>
    <string name="errno_econnreset">இணைப்பு மீட்டமை பியர்</string>
    <string name="errno_econnreset_msg">சேவையகம் திடீரென இணைப்பை மூடியது, பொதுவாக விபத்து அல்லது மோசமான பணிநிறுத்தம் காரணமாக</string>
    <string name="errno_etimedout">இணைப்பு நேரம் முடிந்தது</string>
    <string name="errno_econnrefused">இணைப்பு மறுத்துவிட்டது</string>
    <string name="errno_econnrefused_msg">சேவையகம் இணைப்பை நிராகரித்தது, இது மிகவும் பிசியான அல்லது செயலிழந்த சேவையகத்தைக் குறிக்கலாம்</string>
    <string name="errno_ehostunreach">புரவலனுக்கு பாதை இல்லை</string>
    <string name="errno_ehostunreach_msg">இலக்கு புரவலனுக்கு ஒரு வழியை கணினியால் கண்டுபிடிக்க முடியவில்லை</string>
    <string name="tls_conn_info">TLS/HTTPS போக்குவரத்து குறியாக்கம் செய்யப்படுகிறது. இந்த போக்குவரத்தை ஆய்வு செய்ய, நீங்கள் அதை மறைகுறியாக்க வேண்டும். விவரங்களுக்கு pcapdroid <a href="%1$s"> பயனர் கையேடு </a> ஐப் பாருங்கள்</string>
    <string name="tls_decryption_not_supported_16KB">16 KB சாதனங்களில் TLS மறைகுறியீடு தற்போது ஆதரிக்கப்படவில்லை</string>
    <string name="filename_prefix">கோப்புப்பெயர் முன்னொட்டு</string>
    <string name="filename_prefix_description">PCAPdroid ஏற்றுமதி செய்யும் கோப்புகளுக்கான முன்னொட்டை அமைக்கவும், எ.கா. PCAP கோப்புகள்</string>
    <string name="no_requests">கோரிக்கைகள் இல்லை</string>
    <string name="item_not_found">குறிப்பிட்ட உருப்படியைக் கண்டறிய இயலவில்லை</string>
    <string name="connection_number">இணைப்பு #%1$d</string>
    <string name="http_request_number">HTTP கோரிக்கை #%1$d</string>
    <string name="http_requests">HTTP கோரிக்கைகள்</string>
    <string name="switch_to_http">HTTP கோரிக்கைகளைக் காட்டு</string>
    <string name="switch_to_connections">இணைப்புகளைக் காட்டு</string>
    <string name="decryption_error">மறைகுறியீட்டு பிழை</string>
    <string name="previous">முந்தைய</string>
    <string name="next">அடுத்து</string>
    <string name="save_as_text">உரையாக சேமி</string>
    <string name="save_as_har">HAR ஆக சேமி</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="dump_extensions">Pcapdroid நீட்டிப்புகள்</string>
    <string name="dump_extensions_summary">கொடுக்கப்பட்ட பாக்கெட்டை அனுப்பிய/பெற்ற பயன்பாடு போன்ற கூடுதல் மெட்டாடேட்டாவுடன் பாக்கெட் டம்ப் வடிவமைப்பை நீட்டிக்கவும்</string>
    <string name="malicious_connection_description">பயன்பாட்டின் \"%1$s\" இன் இணைப்பு தீம்பொருள் கண்டறிதல் விதியைத் தூண்டியது (%2$s)</string>
    <string name="malicious_connections_notice">தடுப்புப்பட்டியலில் தவறான நேர்மறைகள் இருக்கலாம். ஐபி முகவரி/டொமைன் நற்பெயரை ஆன்லைனில் இருமுறை சரிபார்க்கவும். தீம்பொருள் வைட்லிச்ட் வழியாக தவறான நேர்மறைகளை நீங்கள் விலக்கலாம்</string>
    <string name="keylog_read_error">SSL KEYLOG READ பிழை</string>
    <string name="bytes_threshold">பைட்டுகள் வாசல்</string>
    <string name="select_the_pcap_file">PCAP/PCAPNG கோப்பைத் தேர்ந்தெடுக்கவும்</string>
    <string name="select_the_keylog_file">SSL கீலாக் கோப்பைத் தேர்ந்தெடுக்கவும்</string>
    <string name="error_code_with_text">%1$s (பிழை %2$d)</string>
    <string name="errno_epipe">உடைந்த குழாய்</string>
    <string name="errno_epipe_msg">தரவு பரிமாற்றத்தின் போது சேவையகம் எதிர்பாராத விதமாக இணைப்பை மூடியது</string>
    <string name="errno_enetreset_msg">பிணைய இணைப்பு ஒரு இடைநிலை சாதனத்தால் மீட்டமைக்கப்பட்டது (எ.கா. திசைவி அல்லது மொபைல் கேரியர்)</string>
    <string name="errno_etimedout_msg">பிணையம் தாமதங்கள் அல்லது பிசியான சேவையகம் காரணமாக சேவையகம் பதிலளிக்க அதிக நேரம் எடுத்தது</string>
    <string name="dns_conn_info">டி.என்.எச் ஒரு டொமைன் பெயரை ஐபி முகவரியாக மொழிபெயர்க்கிறது. உண்மையான தரவு பொதுவாக அடுத்தடுத்த HTTPS/TLS இணைப்புகளில் பரிமாறப்படுகிறது</string>
    <string name="ip_address_or_cidr">ஐபி முகவரி / சிஐடிஆர்</string>
</resources>

```

`app/src/main/res/values-tr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="all_interfaces">Tüm arayüzler</string>
    <string name="hidden_connections_rules">Gizli bağlantı kuralları</string>
    <string name="billing_connecting">Google Play bağlantısı devam ediyor, lütfen biraz sonra tekrar deneyin</string>
    <string name="private_dns_message_notice">Gizli DNS, PCAPdroid\'in DNS trafiğini denetlemesini engeller. Bunu Android ağ ayarlarından kapatabilirsiniz</string>
    <string name="firewall_rules">Güvenlik duvarı kuralları</string>
    <string name="blocked_pkts">Engellendi</string>
    <string name="learn_more">Daha fazla bilgi edin</string>
    <string name="buy_action">Satın al</string>
    <string name="no_intent_handler_found">Bu eylemi gerçekleştirecek uygulama bulunamadı</string>
    <string name="network_interface">Arayüz</string>
    <string name="can_use_purchased_feature">Artık satın alınan özelliği kullanabilirsiniz</string>
    <string name="disconnect_vpn_confirm">Devam edildiğinde etkin VPN bağlantısı kesilecektir</string>
    <string name="http_server">HTTP sunucusu</string>
    <string name="system_default">Sistem öntanımlı değeri</string>
    <string name="ip_address_val">IP adresi: %1$s</string>
    <string name="start_button">Başla</string>
    <string name="protocol">Protokol</string>
    <string name="malware_whitelist_help">Kötü amaçlı yazılım tespitini engellemek için kullanıcı tarafından tanımlanan beyaz liste. Kötü amaçlı yazılım olarak işaretlenmelerini kaldıran kurallar oluşturmak için kötü amaçlı bağlantılara uzun basın</string>
    <string name="n_rules">%1$s kural</string>
    <string name="malware_status_update_failed">Bazı kara listeler güncel değil</string>
    <string name="about">Hakkında</string>
    <string name="app">Uygulama</string>
    <string name="title_activity_settings">Ayarlar</string>
    <string name="http_server_status">HTTP sunucusu: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s alındı — %2$s gönderildi</string>
    <string name="query">Sorgu</string>
    <string name="host">Ana makine</string>
    <string name="ready">Hazır</string>
    <string name="connections_view">Bağlantılar</string>
    <string name="no_connections">Bağlantı yok</string>
    <string name="udp_exporter">UDP aktarıcı</string>
    <string name="no_dump">Döküm yok</string>
    <string name="http_server_info">PCAP indirmesi için bir HTTP sunucusu başlat</string>
    <string name="udp_exporter_info">PCAP dökümünü uzak bir UDP alıcısına gönder</string>
    <string name="http_server_port">HTTP sunucusu bağlantı noktası</string>
    <string name="user_guide">Kullanıcı rehberi</string>
    <string name="stats">İstatistikler</string>
    <string name="active_connections">Etkin bağlantılar</string>
    <string name="dropped_connections">Düşürülen bağlantılar</string>
    <string name="tot_connections">Toplam bağlantı</string>
    <string name="open_sockets">Açık soketler</string>
    <string name="bytes_sent">Gönderilen bayt</string>
    <string name="bytes_rcvd">Alınan bayt</string>
    <string name="packets_sent">Gönderilen paketler</string>
    <string name="cannot_write_file">Dosya yazılamıyor</string>
    <string name="share">Paylaş</string>
    <string name="pcap_file_action">Trafik \"%1$s\" dosyasına kaydedildi (%2$s)</string>
    <string name="delete_error">Dosya silinemedi</string>
    <string name="capture_running">Yakalanıyor</string>
    <string name="notification_msg">%1$s yakalandı, %2$s bağlantı</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">İlk görüldü</string>
    <string name="last_seen">Son görüldü</string>
    <string name="conn_status_closed">Kapalı</string>
    <string name="older_connections_notice">%1$d eski bağlantı gösterilmiyor</string>
    <string name="unknown_app">Bilinmeyen</string>
    <string name="other_prefs">Diğer</string>
    <string name="app_language">Uygulama dili</string>
    <string name="root_capture_summary">PCAPdroid\'in diğer VPN uygulamalarıyla çalışmasına izin verir</string>
    <string name="donate">Bağış yap</string>
    <string name="search">Ara…</string>
    <string name="app_val">Uygulama: %1$s</string>
    <string name="hide">Gizle…</string>
    <string name="n_selected">%1$d seçildi</string>
    <string name="select_all">Tümünü seç</string>
    <string name="package_name">Paket adı</string>
    <string name="uid">UID</string>
    <string name="app_name">Ad</string>
    <string name="version">Sürüm</string>
    <string name="target_sdk">Hedef SDK</string>
    <string name="installed_on">Kurulum tarihi</string>
    <string name="last_update">Son güncelleme</string>
    <string name="permissions">İzinler</string>
    <string name="root_app_info">En yüksek ayrıcalıklarla çalışan sistem arka plan programları</string>
    <string name="packets_dropped">Düşürülen paketler</string>
    <string name="ctrl_consent">Bir uygulama, aygıtınızın trafiğini yakalamak istiyor.
\nEmin değilseniz reddedin</string>
    <string name="deny">Reddet</string>
    <string name="allow">İzin ver</string>
    <string name="ctrl_consent_title">PCAPdroid denetim isteği</string>
    <string name="ctrl_consent_denied">PCAPdroid: denetim isteği reddedildi</string>
    <string name="ctrl_consent_allowed">PCAPdroid: denetim isteğine izin verildi</string>
    <string name="capture_interface">Yakalama arayüzü</string>
    <string name="internet">İnternet</string>
    <string name="edit_filter">Filtreyi düzenle</string>
    <string name="security">Güvenlik</string>
    <string name="malware_detection">Kötü amaçlı yazılım algılama</string>
    <string name="reset">Sıfırla</string>
    <string name="malware_whitelist_rules">Kötü amaçlı yazılım beyaz listesi kuralları</string>
    <string name="feature_not_available">Bu özellik şu anda aygıtınız için kullanılabilir değil</string>
    <string name="hidden_connections_help">İlgili olanlara odaklanabilmeniz için bağlantı listesi girdilerini gizlemek için kurallar listesi</string>
    <string name="malicious_connection_filter">Kötü amaçlı</string>
    <string name="status_filter">HTTP durumu: %1$s</string>
    <string name="not_hidden_filter">Gizli değil</string>
    <string name="copy_action">Kopyala…</string>
    <string name="url_val">URL: %1$s</string>
    <string name="show_me">Göster</string>
    <string name="hint">İpucu</string>
    <string name="once">Bir kere</string>
    <string name="forever">Sonsuza kadar</string>
    <string name="control_permissions">Denetim izinleri</string>
    <string name="control_permissions_summary">Hangi uygulamaların PCAPdroid yakalamasını denetlemesine izin verildiğine göz atın</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">Ülke</string>
    <string name="asn">ASN</string>
    <string name="country_val">Ülke: %1$s</string>
    <string name="send_report">Rapor gönder</string>
    <string name="start_at_boot">Önyüklemede başla</string>
    <string name="start_at_boot_summary">Önyüklemeden sonra yakalamayı otomatik başlatır</string>
    <string name="malware_status_ok">Kötü amaçlı trafik algılanmadı</string>
    <string name="malware_status_detected">Kötü amaçlı bağlantılar algılandı</string>
    <string name="status_outdated">Güncel değil</string>
    <string name="status_not_loaded">Yüklü değil</string>
    <string name="updated_blacklists">Güncellenen kara listeler</string>
    <string name="connections_checked">Denetlenen bağlantılar</string>
    <string name="last_blacklists_update">Son güncelleme</string>
    <string name="domain_rules">Etki alanı kuralları</string>
    <string name="ip_rules">IP kuralları</string>
    <string name="update_now">Şimdi güncelle</string>
    <string name="status_updating">Güncelleniyor…</string>
    <string name="malware_detection_learn_more">Kötü amaçlı yazılım algılama özelliği hakkında daha fazla bilgi edinin</string>
    <string name="block">Engelle…</string>
    <string name="firewall">Güvenlik duvarı</string>
    <string name="n_pkts">%1$s paket</string>
    <string name="blocked_connection_filter">Engellendi</string>
    <string name="validate">Doğrula</string>
    <string name="valid">Geçerli</string>
    <string name="invalid">Geçersiz</string>
    <string name="no_items_for_purchase">Satın alınabilecek ürün yok</string>
    <string name="billing_failure">Google Play\'e bağlanılamadı. Lütfen biraz sonra tekrar deneyin</string>
    <string name="capture_not_running_status">Yakalama çalışmıyor</string>
    <string name="start_capture_first">Önce yakalamayı başlatın</string>
    <string name="copied">Kopyalandı</string>
    <string name="loading_apps">Uygulamalar yükleniyor…</string>
    <string name="open_nav_drawer">Çekmeceyi aç</string>
    <string name="stop_button">Dur</string>
    <string name="close_nav_drawer">Çekmeceyi kapat</string>
    <string name="capture_all_apps">Tüm uygulamaların trafiğini yakala</string>
    <string name="save_ok">Kaydedildi</string>
    <string name="collector_info">UDP toplayıcı: %1$s:%2$d</string>
    <string name="status">Durum</string>
    <string name="connection_details">Bağlantı ayrıntıları</string>
    <string name="packets">Paketler</string>
    <string name="receiver_ip_address">Toplayıcı IP adresi</string>
    <string name="yes">Evet</string>
    <string name="vpn_setup_failed">VPN kurulamadı. Her zaman açık VPN\'in devre dışı bırakıldığından emin olun</string>
    <string name="app_not_found">%1$s uygulaması bulunamadı</string>
    <string name="source">Kaynak</string>
    <string name="receiver_port">Toplayıcı bağlantı noktası</string>
    <string name="source_code">Kaynak kodu</string>
    <string name="no">Hayır</string>
    <string name="destination">Hedef</string>
    <string name="duration">Süre</string>
    <string name="open_telegram_group">Telegram grubu</string>
    <string name="no_dump_info">Trafik dökümü yapılmayacak</string>
    <string name="pcap_file_info">Aygıt depolama alanında bir PCAP dosyası oluştur</string>
    <string name="ok">Tamam</string>
    <string name="copy_to_clipboard">Panoya kopyala</string>
    <string name="conn_status_unreachable">Ulaşılamıyor</string>
    <string name="file_saved_with_name">Dosya \"%1$s\" olarak kaydedildi</string>
    <string name="enable_socks5_proxy_summary">Tüm TCP bağlantılarını bir SOCKS5 vekiline yönlendir</string>
    <string name="protocol_val">Protokol: %1$s</string>
    <string name="android_app_info">Android sistemi</string>
    <string name="capture_prefs">Yakala</string>
    <string name="pending_transaction">Bu özelliği kullanmak için lütfen işleminizi tamamlayın</string>
    <string name="packets_rcvd">Alınan paketler</string>
    <string name="unknown_app_info">\"Bilinmeyen\", uygulaması belirlenemeyen bağlantıları belirtir</string>
    <string name="edit_list">Listeyi düzenle</string>
    <string name="status_uptodate">Güncel</string>
    <string name="private_dns_hinders_detection">Gizli DNS algılamayı engelliyor</string>
    <string name="decryption_no_filter_warn">İnternet bağlantınızı kaybetmemek için TLS\'nin şifresini çözerken bir hedef uygulama seçin</string>
    <string name="paid_features">Ücretli özellikler</string>
    <string name="interface_filter">Arayüz: %1$s</string>
    <string name="purchased">Satın alındı</string>
    <string name="dns_queries">DNS sorguları</string>
    <string name="search_apps">Uygulama ara</string>
    <string name="no_apps">Uygulama yok</string>
    <string name="dns_server">DNS sunucusu</string>
    <string name="apps">Uygulamalar</string>
    <string name="pcap_file">PCAP dosyası</string>
    <string name="delete">Sil</string>
    <string name="save_to_file">Dosyaya kaydet</string>
    <string name="about_text">PCAPdroid, root ayrıcalıkları olmadan çalışan açık kaynaklı bir ağ yakalama ve izleme aracıdır</string>
    <string name="get_app">Edin:</string>
    <string name="error">Hata</string>
    <string name="no_activity_file_selection">Dosya seçimini yapacak uygulama bulunamadı</string>
    <string name="proxy_port">Vekil bağlantı noktası</string>
    <string name="root_capture">Root olarak yakala</string>
    <string name="host_val">Ana makine: %1$s</string>
    <string name="app_details">Uygulama ayrıntıları</string>
    <string name="netd_app_info">DNS çözümlemelerini gerçekleştiren sistem arka plan programı</string>
    <string name="loading">Yükleniyor…</string>
    <string name="capturing_from">\"%1$s\" paketlerini yakala</string>
    <string name="list_is_empty">Liste boş</string>
    <string name="show_only_malicious">Kötü amaçlı bağlantılar</string>
    <string name="malware_detection_summary">Üçüncü taraf kara listeleri kullanarak bilinen kötü niyetli ana makinelere bağlantıları tespit et</string>
    <string name="whitelist">Beyaz liste</string>
    <string name="blacklists">Kara listeler</string>
    <string name="blacklist_type">Tür: %1$s</string>
    <string name="blacklist_type_ip">IP kara listesi</string>
    <string name="blacklist_type_domain">Etki alanı kara listesi</string>
    <string name="last_update_val">Son güncelleme: %1$s</string>
    <string name="malicious_connections">Kötü amaçlı bağlantılar</string>
    <string name="socks5_info">SOCKS5 vekili: %1$s:%2$d</string>
    <string name="unblock">Engeli kaldır…</string>
    <string name="tls_decryption">TLS şifre çözme</string>
    <string name="mitm_setup_wizard">Ortadaki adam kurulum sihirbazı</string>
    <string name="install_action">Kur</string>
    <string name="export_ca_certificate">PCAPdroid CA sertifikasını dışa aktarın, ardından Android \"Şifreleme ve Kimlik Bilgileri\" ayarlarını açın ve \"CA sertifikası\" olarak kurmayı seçin</string>
    <string name="checking_the_certificate">Sertifika denetleniyor…</string>
    <string name="cert_exported_now_installed">Sertifika dışa aktarıldı, şimdi Android ayarlarından onu kurun</string>
    <string name="cert_installed_correctly">CA sertifikası kuruldu</string>
    <string name="mitm_addon_bad_version">Hatalı PCAPdroid ortadaki adam eklentisi sürümü. Lütfen %1$s sürümünü yükleyin ve tekrar deneyin</string>
    <string name="mitm_addon_new_version">PCAPdroid ortadaki adam eklentisi güncellenmelidir</string>
    <string name="request">İstek</string>
    <string name="overview">Genel bakış</string>
    <string name="payload_truncated">Yükün bir kısmı gösteriliyor. Tam olarak göstermek için yakalamayı durdurun ve PCAPdroid ayarlarından \"%1$s\" seçeneğini etkinleştirin</string>
    <string name="http">HTTP</string>
    <string name="payload">Yük</string>
    <string name="tx_direction">Gönder (TX)</string>
    <string name="rx_direction">Al (RX)</string>
    <string name="full_payload">Tam yük</string>
    <string name="full_payload_summary">Tam bağlantı yükünü göster (ör. tam HTTP isteği ve yanıtı). Bu çok fazla bellek gerektirir, uzun süreli kullanmayın</string>
    <string name="not_decryptable">Şifresi çözülemiyor</string>
    <string name="decrypted">Şifresi çözüldü</string>
    <string name="decryption">Şifre çözme</string>
    <string name="connection_start_not_seen">PCAPdroid bu bağlantının başlangıcını görmedi. Bazı bilgiler eksik olabilir</string>
    <string name="warn_no_app_data">Hiçbir uygulama verisi alınıp gönderilmedi</string>
    <string name="waiting_application_data">Veri bekleniyor</string>
    <string name="hexdump">Onaltılık sayı dökümü</string>
    <string name="geolocation">Coğrafi konum</string>
    <string name="geolocation_summary">Çevrim dışı aramalar yaparak ülke ve ASN bilgilerini göster</string>
    <string name="downloading">İndiriliyor…</string>
    <string name="database">Veri tabanı</string>
    <string name="built_on">Oluşturuldu: %1$s</string>
    <string name="geo_db_download">En son veri tabanını indirmek için dokunun. Aylık olarak yeni veri tabanları yayınlanır</string>
    <string name="size_x">Boyut: %1$s</string>
    <string name="keep_action">Koru</string>
    <string name="connections_blocked">Engellenen bağlantılar</string>
    <string name="traffic_dump">Trafik dökümü</string>
    <string name="conn_status_active">Etkin</string>
    <string name="rules_delete_confirm">Seçilen kurallar silinsin mi\?</string>
    <string name="phone_app">Telefon</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="phone_app_info">Telefon hizmetleri</string>
    <string name="install_ca_certificate">\"VPN ve uygulamalar\" seçeneğini seçerek PCAPdroid CA sertifikasını kurun. Android, kilit ekranınızı veya parolanızı soracak</string>
    <string name="tls_decryption_summary">Ortadaki adam gerçekleştirerek SSL/TLS trafiğinin şifresini çöz. Bu artık bazı uygulamalarla çalışabilir, kullanım kılavuzuna bakın</string>
    <string name="traffic_inspection">Trafik denetimi</string>
    <string name="export_action">Dışa aktar</string>
    <string name="mitm_start_failed">Ortadaki adam hizmeti başlatılamadı. Ortadaki adam eklentisini elle açmaya çalışın ve yeniden deneyin</string>
    <string name="not_encrypted">Şifrelenmedi</string>
    <string name="cert_reinstall_required">CA sertifikası kurulmadı, ortadaki adam kurulum sihirbazını çalıştırın</string>
    <string name="export_failed">Dışa aktarılamadı</string>
    <string name="response">Yanıt</string>
    <string name="string_http_request">HTTP isteği</string>
    <string name="string_http_response">HTTP yanıtı</string>
    <string name="websocket">WebSocket</string>
    <string name="decryption_filter">Durum: %1$s</string>
    <string name="download_in_progress">İndirme devam ediyor, lütfen bekleyin</string>
    <string name="import_failed">İçe aktarılamadı</string>
    <string name="rules_merge_msg">Var olan kurallar korunsun mu\?</string>
    <string name="action_unblock">Engellemeyi kaldır</string>
    <string name="network_traffic">Trafik</string>
    <string name="download_failed">İndirilemedi</string>
    <string name="geo_db_not_found">Veri tabanı bulunamadı. Coğrafi konum devre dışı</string>
    <string name="import_action">İçe aktar</string>
    <string name="last_firewall_block">Son engellenen</string>
    <string name="app_info">Uygulama bilgisi</string>
    <string name="geo_db_delete">Veri tabanını silmek ve yerden tasarruf etmek için dokunun</string>
    <string name="download">İndir</string>
    <string name="connection_blocked">Bu bağlantı PCAPdroid tarafından engellendi</string>
    <string name="invalid_backup">Geçersiz yedekleme biçimi</string>
    <string name="rules_import_success">%1$d kural içe aktarıldı</string>
    <string name="no_rules_to_export">Dışa aktarılacak kural yok</string>
    <string name="firewall_is_disabled">Güvenlik duvarı devre dışı</string>
    <string name="action_block">Engelle</string>
    <string name="discard_action">At</string>
    <string name="blocklist">Engelleme listesi</string>
    <string name="num_configured_rules">Yapılandırılan kurallar</string>
    <string name="firewall_is_enabled">Güvenlik duvarı etkin</string>
    <string name="firewall_summary">Uygulamalara internet erişimini engelleyin, belirli etki alanları ve IP adresleri için kurallar yapılandırın. Yalnızca root olmayan yakalama ile çalışır</string>
    <string name="block_quick">QUIC\'i engelle</string>
    <string name="block_private_dns_summary">DNS trafiğini incelemek için özel DNS\'yi algılayın ve muhtemelen engelleyin. Bunu devre dışı bırakmak trafik incelemesini engelleyebilir</string>
    <string name="mitm_setup_wizard_done">PCAPdroid artık TLS trafiğinin şifresini çözmeye hazır
\n
\nŞifre çözmeyi engelleyebilecek güvenlik önlemleri ve bunların nasıl aşılacağı hakkında daha fazla bilgi edinmek için <a href="%1$s">kullanıcı kılavuzuna</a> göz atın</string>
    <string name="welcome_to_pcapdroid">PCAPdroid\'e hoş geldiniz</string>
    <string name="app_intro_next_button">İleri</string>
    <string name="app_intro_skip_button">Atla</string>
    <string name="privacy_first">Önce gizlilik</string>
    <string name="vpn_setup_msg">PCAPdroid, ağ trafiğini root olmadan yakalamak için bir VPN gibi davranır.
\n
\nYakalamayı başlatmak için, bir sonraki ekranda VPN isteğini kabul etmeniz gerekir.
\n
\n<b>NOT:</b> Devam etmek için, Android ayarlarından yapılandırılmış her zaman açık VPN\'lerin tümünü devre dışı bırakın</string>
    <string name="app_intro_firewall_msg">Tümleşik <a href="%1$s">güvenlik duvarı</a> ile tek tek uygulamalara, etki alanlarına ve ülkelere internet erişimini kolayca engelleyebilirsiniz \n \nBunu yerleşik trafik görünürlüğü ile birleştirerek gizliliğinizi korumak için en iyi aracı elde edin</string>
    <string name="app_intro_traffic_dump">PCAPdroid, daha fazla inceleme için trafiği standart PCAP biçiminde dökmek için <a href="%1$s">birden fazla seçenek</a> sunar \n \n<a href="%2$s">İzleme seçeneği</a> aracılığıyla paketlere uygulama adları ekleyebilir ve bunları Wireshark\'ta görüntüleyebilirsiniz</string>
    <string name="mitm_setup_wizard_intro">Bu sihirbaz, <a href="%1$s">TLS şifre çözme</a> işlemini gerçekleştirmek için gerekli olan PCAPdroid ortadaki adam eklentisinin ve sertifika yetkilisinin kurulumunda size rehberlik edecektir</string>
    <string name="app_intro_back_button">Geri</string>
    <string name="netd_block_missed">Bu bağlantı netd tarafından başlatıldığı için engellenemedi</string>
    <string name="ca_cert_export_failed">CA sertifikası dışa aktarılırken bir hata oluştu
\n
\nAygıtınız, arka plan hizmetlerinin yürütülmesini sınırlamak için Autostart veya benzeri bir yazılım kullanıyorsa, <a href="%1$s">PCAPdroid\'i beyaz listeye eklediğinizden</a> emin olun</string>
    <string name="no_root_firewall">Rootsuz güvenlik duvarı</string>
    <string name="block_private_dns">Özel DNS\'yi engelle</string>
    <string name="app_intro_done_button">Bitti</string>
    <string name="app_intro_welcome_msg">PCAPdroid, aygıtınızdaki uygulamalar tarafından yapılan bağlantıları izlemenizi ve incelemenizi sağlayan gizlilik dostu bir uygulamadır
\n
\nAyrıca, trafiğin PCAP dökümünü dışa aktarmanıza, üst verileri çıkarmanıza ve çok daha fazlasına olanak tanır!</string>
    <string name="country_and_asn">Ülke ve ASN</string>
    <string name="app_intro_geolocation_msg">PCAPdroid, uzak bir sunucunun ülkesini belirlemek için yerel bir veri tabanını sorgulayabilir
\n
\nÖnce uygulama ayarlarından coğrafi konum veri tabanını indirmelisiniz</string>
    <string name="app_intro_privacy_msg">Uygulama herhangi bir izleme, analiz veya belirli bir yere bağlanma karşıt özellikleri kullanmaz
\n
\nNasıl emin olabilirsiniz\? <a href="%1$s">Gizlilik politikasına</a> ve <a href="%2$s">kaynak koduna</a> göz atın</string>
    <string name="app_intro_traffic_inspection">Yerleşik kod çözücüler sayesinde HTTP isteklerini, yanıtlarını ve ham verileri incelemek kolaydır
\n
\nŞifreli bir bağlantınız mı var\? Şifresi çözülmüş verileri almak için <a href="%1$s">TLS şifre çözme</a> özelliğini etkinleştirebilirsiniz</string>
    <string name="app_intro_malware_detection"><a href="%1$s">Kötü amaçlı yazılım algılama</a> özelliği ile aygıtınızın güvenliğini artırın
\n
\nGüncel kara listeleri kullanarak, kötü niyetli bağlantıları gerçek zamanlı olarak tespit edebilir, engelleyebilir ve uyarabilir</string>
    <string name="permission_granted">%1$s izni verildi</string>
    <string name="permission_grant_fail">%1$s izni verilemedi</string>
    <string name="memory_usage">Bellek kullanımı</string>
    <string name="allowed_connection_filter">İzin verildi</string>
    <string name="firewall_filter">Güvenlik duvarı: %1$s</string>
    <string name="heap_usage">Yığın kullanımı</string>
    <string name="connection_not_found">Verilen bağlantı bulunamadı</string>
    <string name="low_memory">Düşük bellek</string>
    <string name="low_memory_info">Uygulamanın belleği tükeniyor, çökmeler bekleniyor</string>
    <string name="capture_stopped_low_memory">Yakalama durduruldu</string>
    <string name="full_payload_disabled">Tam yük seçeneği devre dışı bırakıldı</string>
    <string name="vpn_lockdown_notice">PCAPdroid çalışmıyorken (örneğin yeniden başlattıktan sonra) uygulamaların internete erişmesini önlemek için PCAPdroid\'i kilitleme modunda her zaman açık bir VPN olarak ayarlayabilirsiniz.
\n
\nŞimdi VPN ayarlarını açmak istiyor musunuz\?</string>
    <string name="ip_mode">VPN IP adresleri</string>
    <string name="ipv4_only">Yalnızca IPv4</string>
    <string name="ipv6_only">Yalnızca IPv6</string>
    <string name="ip_both">IPv4 ve IPv6</string>
    <string name="vpn_exemptions">VPN Muafiyetleri</string>
    <string name="unblock_for_n_hours">%1$dsa için engellemeyi kaldır</string>
    <string name="block_new_apps">Yeni kurulan uygulamaları engelle</string>
    <string name="app_blocked">Uygulama engellendi</string>
    <string name="no_matches_found">Eşleşme yok</string>
    <string name="unblock_permanently">Kalıcı olarak engellemeyi kaldır</string>
    <string name="app_blocked_info">%1$s uygulaması güvenlik duvarı tarafından engellendi</string>
    <string name="show_only_cleartext">Açık metin bağlantıları</string>
    <string name="vpn_exemptions_summary">Bazı uygulamaları VPN bağlantısından muaf tutun. Onların trafiği izlenmeyecektir</string>
    <string name="notifications_notice">Uygulama, olağan dışı olaylar durumunda uyarı göndermek için bildirimleri kullanır. Bir sonraki ekranda bildirim gönderme izni verin</string>
    <string name="cleartext_connection">Açık metin</string>
    <string name="cancel_action">İptal</string>
    <string name="show_data_action">Verileri göster</string>
    <string name="remote_server_warning">Güvenlik nedeniyle, \"%1$s\" uzak sunucusuna trafik gönderilmesine izin verilmiyor</string>
    <string name="payload_scams_notice">Bu görünüm, parolalarınız ve erişim belirteçleriniz gibi hassas bilgiler içerebilir.
\n
\nBu bilgileri asla kimseye vermeyin, bu bir dolandırıcılık girişimi olabilir</string>
    <string name="remote_collector_notice">PCAPdroid\'i uzak bir sunucuya trafik gönderecek şekilde yapılandırdınız. Sunucu hassas bilgilerinize erişebilecek.
\n
\nEğer birisi sizden bunu yapmanızı istediyse, bu muhtemelen bir dolandırıcılık girişimidir</string>
    <string name="app_unblocked">%1$s uygulamasının engellemesi kaldırıldı</string>
    <string name="build_info">Derleme bilgisi</string>
    <string name="unblock_for_n_minutes">%1$d dakika için engellemeyi kaldır</string>
    <string name="warning">Uyarı</string>
    <string name="paid_features_unlocked">Ücretli özelliklerin kilidi açıldı. Çalışıyorsa yakalamayı yeniden başlatın</string>
    <string name="install_the_mitm_addon">PCAPdroid <a href="%1$s">ortadaki adam eklentisini</a> kurun</string>
    <string name="tls_decryption_with_root_msg">TLS şifre çözme işlemini root ile çalıştırma yeteneği deneysel bir özelliktir. Bilinen hataların bir listesi şöyledir: \n \n - PCAPdroid\'de trafiği orijinal uygulama yerine ortadaki adam eklentisi uygulamasından oluşturulduğu şekilde göreceksiniz \n - SSL keylog dökümü desteklenmez\n - bir uygulama filtresi ayarlandığında, şifre çözme yalnızca hedef uygulama için gerçekleşecektir, ancak PCAPdroid diğer uygulamaların trafiğini göstermeye devam edecektir \n - yakalama başlatılamazsa, iptables komutunu gerçekten root olarak çalıştırabildiğinizden emin olun (örneğin termux aracılığıyla) \n - bu, Android 12 ve sonraki sürümlerde çalışmayabilir \n - Bir VPN uygulaması çalışıyorsa, şifre çözme için belirli bir uygulamayı hedeflemeli veya PCAPdroid ortadaki adam eklentisini VPN\'den hariç tutmalısınız, aksi takdirde trafik bir döngüye girecektir</string>
    <string name="unlock_token_summary">Uygulamanın Google-Play dışı sürümlerinde (örn. F-Droid/Github) ücretli özelliklerin kilidini açmak için kullanılabilecek bir belirteç</string>
    <string name="license_service_unavailable">PCAPdroid lisans hizmeti şu anda kullanılamıyor. Lütfen birkaç dakika içinde yeniden deneyin</string>
    <string name="access_paid_features_msg">Ücretli özelliklere nasıl erişeceğinizi öğrenmek için <a href="%1$s">kullanıcı kılavuzuna</a> göz atın</string>
    <string name="unlock_token_error">Kilit açma belirteci istenemedi [%1$d]: %2$s</string>
    <string name="requesting_unlock_token">Kilit açma belirteci isteniyor, lütfen bekleyin</string>
    <string name="show_action">Göster</string>
    <string name="unlock_token_msg1">Bu sizin kilit açma belirtecinizdir. <a href="%1$s">Lisans kodlarınızı oluşturmak için</a> ihtiyacınız olacağından bunu not edin</string>
    <string name="paid_feature">Ücretli özellik</string>
    <string name="firewall_purchase_msg">Bağlantıları engellemeye başlamak için <i>%1$s</i> özelliğini satın alın</string>
    <string name="mitm_wizard_description">TLS şifre çözme için aygıtı yapılandır</string>
    <string name="mitm_skip_notice">Ortadaki adam sertifikası kurulu görünmüyor. Devam ederseniz, şifre çözme başarısız olabilir</string>
    <string name="app_log">Günlük kaydı</string>
    <string name="no_data">Veri yok</string>
    <string name="malware_whitelist_action">Beyaz liste (kötü amaçlı yazılım)…</string>
    <string name="mitm_addon">ortadaki adam eklentisi</string>
    <string name="mitmproxy_opts">Ek mitmproxy seçenekleri</string>
    <string name="mitmproxy_opts_description">mitmproxy için ek seçenekler sağlayın</string>
    <string name="mitm_addon_error">Ortadaki adam eklentisi başlatılırken hata oluştu. Ayrıntılar için günlüğe bakın</string>
    <string name="whitelist_mode">Beyaz liste modu</string>
    <string name="firewall_whitelist_notice">Bu modda, elle beyaz listeye alınmadığı sürece tüm bağlantılar engellenecektir. Uygun bir beyaz liste olmadan anlık bildirimleri kaçırabilirsiniz</string>
    <string name="firewall_whitelist_help">Bu kurallar hangi bağlantılara izin verileceğini belirtir. Engelleme listesi kurallarının beyaz liste kurallarına göre önceliği vardır</string>
    <string name="add_to_fw_whitelist">Güvenlik duvarı beyaz listesine ekle</string>
    <string name="remove_from_fw_whitelist">Güvenlik duvarı beyaz listesinden kaldır</string>
    <string name="reset_stats_confirm">Bu istatistikleri gerçekten sıfırlamak istiyor musunuz\?</string>
    <string name="port_mapping">Bağlantı noktası eşleme</string>
    <string name="original_port">Asıl bağlantı noktası</string>
    <string name="required">gerekli</string>
    <string name="destination_port">Hedef bağlantı noktası</string>
    <string name="port_mapping_exists">Bağlantı noktası eşleme zaten tanımlandı</string>
    <string name="items_delete_confirm">Seçili ögeler silinsin mi\?</string>
    <string name="ip_address">IP adresi</string>
    <string name="rule_exists">Kural zaten tanımlandı</string>
    <string name="dns_servers">DNS sunucuları</string>
    <string name="ipv4_dns_server">IPv4 DNS sunucusu</string>
    <string name="ipv6_dns_server">IPv6 DNS sunucusu</string>
    <string name="use_system_dns_summary">Mümkünse sistem DNS sunucularını kullanın</string>
    <string name="external_storage_perm_required">Harici depolama izni gerekli</string>
    <string name="many_rules_warning">Çok sayıda kuralı içe aktarmaya çalışıyorsunuz, bu da bazı etkileşimler sırasında uygulamanın yanıt vermemesine neden olabilir. Gerçekten devam etmek istiyor musunuz\?</string>
    <string name="pcapng_format">Pcapng biçimi</string>
    <string name="add_action">Ekle</string>
    <string name="dns_servers_summary">Yakalama sırasında kullanılacak DNS sunucularını yapılandırın</string>
    <string name="use_system_dns">Sistem DNS\'sini kullan</string>
    <string name="port_mapping_summary">Bağlantıları farklı bir ana makineye veya bağlantı noktasına yönlendirmek için bağlantı noktası eşleme kurallarını yapılandırın</string>
    <string name="redirect_to">Şuraya yönlendir:</string>
    <string name="pcapng_format_summary">Paketleri TLS şifre çözme parolalarının gömülmesine olanak tanıyan pcapng biçiminde dök</string>
    <string name="sort_by">Sıralama ölçütü</string>
    <string name="total_bytes">Toplam bayt</string>
    <string name="write_ext_storage_failed">Harici depolama alanına yazma başarısız oldu. Ayrıntılar için uygulama günlüğüne bakın</string>
    <string name="socks5_summary">SOCKS5 vekiline yönlendirmeyi yapılandırın</string>
    <string name="socks5_auth">SOCKS5 kimlik doğrulaması</string>
    <string name="username">Kullanıcı adı</string>
    <string name="mitm_addon_autostart_workaround">Ortadaki adam eklentisine bağlantı başarısız oldu. Geçici bir çözüm olarak, ortadaki adam eklenti uygulamasını açmayı ve ardından kapatmadan PCAPdroid\'e geri dönmeyi deneyebilirsiniz. Şimdi açmak istiyor musunuz\?</string>
    <string name="socks5_auth_summary">Kullanıcı adı ve parola ile vekilde kimlik doğrulaması yapın</string>
    <string name="socks5_redirection">SOCKS5 yönlendirmesi</string>
    <string name="password">Parola</string>
    <string name="connection_error">Bağlantı hatası: %1$s</string>
    <string name="activate_via_qr_code">QR kodu ile etkinleştir</string>
    <string name="qr_code_expired">QR kodunun süresi doldu. Yeni bir QR kodu oluşturun ve yeniden deneyin</string>
    <string name="qr_info_text">Google Play\'den PCAPdroid\'i kurun ve bu QR kodunu tarayın</string>
    <string name="qr_purchase_required">QR kodu ile etkinleştirmeye devam etmek için bir kilit açma belirteci satın alın</string>
    <string name="license_error">Lisans oluşturma hatası [%1$d]: %2$s</string>
    <string name="requesting_license">Lisans kodu isteniyor, lütfen bekleyin</string>
    <string name="license_activation_ok">Lisans etkinleştirme tamamlandı</string>
    <string name="license_limit_reached">Bu kilit açma belirteci için lisans sınırına ulaştınız. Daha fazla lisans oluşturmak için yeni bir belirteç satın alın</string>
    <string name="qr_license_confirm">Aşağıdaki kilit açma belirtecini kullanarak \"%1$s\" aygıtı için bir lisans oluşturmak istiyor musunuz\?</string>
    <string name="invalid_license">Geçersiz lisans</string>
    <string name="decryption_rules">Şifre çözme kuralları</string>
    <string name="injected">Enjekte edildi</string>
    <string name="mitm_addon_running">Ortadaki adam eklentisi çalışıyor</string>
    <string name="mitm_addon_starting">Ortadaki adam eklentisi başlatılıyor…</string>
    <string name="dont_decrypt_action">Şifresini çözme…</string>
    <string name="decryption_rules_help">Bu kurallar hangi bağlantıların şifresinin çözüleceğini belirtir. Ana makine tabanlı kurallar yalnızca önceden bir DNS yanıtı görülürse çalışır</string>
    <string name="decrypt_action">Şifresini çöz…</string>
    <string name="status_encrypted">Şifreli</string>
    <string name="host_resolution_failed">%1$s adresi çözümlenemedi</string>
    <string name="pcap_file_load_aborted">PCAP dosyası yükleme işlemi iptal edildi</string>
    <string name="tls_decryption_no_rules_notice">TLS şifre çözme yalnızca yapılandırılan kurallarla eşleşen bağlantılara uygulanır. Şimdi şifre çözme kuralları oluşturmak istiyor musunuz\?</string>
    <string name="pcap_load_success">PCAP dosyası yüklendi</string>
    <string name="unsupported_pcap_datalink">PCAP dosyası desteklenmeyen bir veri bağlantısına sahip</string>
    <string name="pcap_file_not_exists">Belirtilen PCAP dosyası yok</string>
    <string name="root_capture_start_failed">Yakalama başlatma hatası. Aygıtın Magisk ile root yapıldığından emin olun</string>
    <string name="decryption_info_no_rule">Bu bağlantının şifresini çözmek için, sol çekmeceden veya Bağlantılar listesindeki bağlam menüsünden bir şifre çözme kuralı oluşturun</string>
    <string name="pcap_read_error">Yakalama dosyası okunurken hata oluştu. Ayrıntılar için günlüğe bakın</string>
    <string name="active_vpn_detected">Etkin VPN algılandı</string>
    <string name="pcap_load_in_progress">PCAP dosyası yükleniyor, lütfen bekleyin</string>
    <string name="pcapdroid_trailer_notice">\"%1$s\" yerine gerçek uygulamaları göstermek için, PCAP dosyasını dışa aktarmadan önce \"%2$s\" seçeneğini etkinleştirdiğinizden emin olun</string>
    <string name="copy_error">Dosya yazılamadı</string>
    <string name="open_pcap_file">PCAP dosyasını aç…</string>
    <string name="root_capture_pcapd_start_failure">Yakalama başlatma hatası. PCAPdroid\'e root erişimi verdiğinizden emin olun</string>
    <string name="invalid_pcap_file">Geçersiz PCAP dosyası</string>
    <string name="proxy_host">Vekil sunucu</string>
    <string name="capture_interface_open_error">Yakalama arayüzü açılamadı</string>
    <string name="dnscrypt_how_to">PCAPdroid ile DoH / DNSCrypt nasıl kullanılır</string>
    <string name="never">Hiçbir zaman</string>
    <string name="always">Her zaman</string>
    <string name="for_connections_to_decrypt">Yalnızca şifresi çözülecek bağlantılar için</string>
    <string name="whats_new">Yenilikler</string>
    <string name="export_ellipsis">Dışa aktar…</string>
    <string name="mitm_doze_notice">Pil iyileştirmesi ortadaki adam eklentisinin çalışmasını engelleyebilir</string>
    <string name="redirected">yönlendirildi</string>
    <string name="connection_redirected_port_map">Bu bağlantı bir bağlantı noktası eşleme kuralı nedeniyle yönlendirildi</string>
    <string name="both">Her ikisi de</string>
    <string name="decrypt_quic_notice">QUIC şifresinin çözülmesi şu anda desteklenmiyor. Geçici bir çözüm olarak, yakalamayı durdurun ve PCAPdroid ayarlarında QUIC engelleme seçeneğini seçin</string>
    <string name="target_apps">Hedef uygulamalar</string>
    <string name="target_apps_help">Yakalanacak uygulamaları seçin</string>
    <string name="headers">Başlıklar</string>
    <string name="body">Gövde</string>
    <string name="raw_bytes">Ham baytlar</string>
    <string name="restart_on_disconnection">Bağlantı kesildiğinde yeniden başlat</string>
    <string name="vpn_reconnection">VPN yeniden bağlantısı</string>
    <string name="vpn_reconnection_aborted">VPN yeniden bağlantısı iptal edildi</string>
    <string name="waiting_for_vpn_disconnect">Etkin VPN bağlantısının kesilmesi bekleniyor…</string>
    <string name="restart_on_disconnection_summary">Diğer VPN uygulamaları tarafından durdurulduktan sonra yakalamayı otomatik olarak yeniden başlat</string>
    <string name="ipv6_bytes_sent">Gönderilen IPv6 bayt</string>
    <string name="ipv6_bytes_percentage">IPv6 bayt yüzdesi</string>
    <string name="ipv6_bytes_rcvd">Alınan IPv6 bayt</string>
    <string name="update_available">Güncelleme var</string>
    <string name="mitm_addon_update_available">Yeni bir ortadaki adam eklentisi güncellemesi var. En son hata düzeltmelerini almak için güncelleyin</string>
    <string name="update_action">Güncelle</string>
    <string name="dump_extensions_summary">Paket dökümü biçimini, belirli bir paketi gönderen/alan uygulama gibi ek meta verilerle genişletin</string>
    <string name="errno_econnrefused_msg">Sunucu bağlantıyı reddetti, bu da sunucunun çok meşgul veya hatalı çalıştığını gösterebilir</string>
    <string name="errno_econnaborted">Bağlantı iptal edildi</string>
    <string name="errno_etimedout_msg">Sunucunun, büyük olasılıkla ağ gecikmeleri veya meşgul bir sunucu nedeniyle yanıt vermesi çok uzun sürdü</string>
    <string name="errno_econnrefused">Bağlantı reddedildi</string>
    <string name="tls_conn_info">TLS/HTTPS trafiği şifrelenir. Bu trafiği incelemek için şifresini çözmeniz gerekir. Ayrıntılar için PCAPdroid <a href="%1$s"> kullanıcı kılavuzuna göz atın</a></string>
    <string name="dump_extensions">PCAPdroid eklentileri</string>
    <string name="dump_extensions_how_to">Wireshark\'ta PCAPdroid döküm uzantıları nasıl görüntülenir</string>
    <string name="malicious_connections_notice">Kara listeler yanlış pozitifler içerebilir. IP adresini/alan adı itibarını çevrimiçi olarak iki kez kontrol ettiğinizden emin olun. Kötü amaçlı yazılım beyaz listesi aracılığıyla yanlış pozitifleri hariç tutabilirsiniz</string>
    <string name="geo_db_missing">Coğrafi konum veritabanı eksik</string>
    <string name="malicious_connection_description">\"%1$s\" uygulamasından gelen bir bağlantı, kötü amaçlı yazılım algılama kuralını (%2$s) tetikledi</string>
    <string name="country_rules_warning">Ülke tabanlı güvenlik duvarı kurallarını kullanmak için PCAPdroid ayarlarından coğrafi konum veritabanını indirin, aksi takdirde ülke tabanlı kurallar etkisiz olacaktır</string>
    <string name="bytes_threshold">Bayt eşiği</string>
    <string name="select_the_pcap_file">PCAP/Pcapng dosyasını seçin</string>
    <string name="select_the_keylog_file">SSL keylog dosyasını seçin</string>
    <string name="error_code_with_text">%1$s (hata %2$d)</string>
    <string name="errno_epipe">Kırık boru</string>
    <string name="errno_epipe_msg">Sunucu, veri aktarımı sırasında bağlantıyı beklenmedik bir şekilde kapattı</string>
    <string name="errno_enetdown">Ağ kapalı</string>
    <string name="errno_enetdown_msg">Ağ arabirimi çalışmıyor veya ağa bağlanamıyor</string>
    <string name="errno_enetunreach">Ağa ulaşılamıyor</string>
    <string name="errno_enetunreach_msg">Sistem, hedef ağa giden geçerli bir rota bulamıyor</string>
    <string name="errno_enetreset">Ağ sıfırlama</string>
    <string name="errno_enetreset_msg">Ağ bağlantısı bir aracı cihaz (örn. yönlendirici veya mobil operatör) tarafından sıfırlandı</string>
    <string name="errno_econnaborted_msg">Bağlantı, genellikle bir ağ geçişi nedeniyle iptal edildi</string>
    <string name="errno_econnreset">Eşe göre bağlantı sıfırlama</string>
    <string name="errno_econnreset_msg">Sunucu, genellikle bir çökme veya istenmeyen kapanma nedeniyle bağlantıyı aniden kapattı</string>
    <string name="errno_etimedout">Bağlantı zaman aşımına uğradı</string>
    <string name="errno_ehostunreach">Ev sahibi için rota yok</string>
    <string name="errno_ehostunreach_msg">Sistem, hedef ana bilgisayara giden bir rota bulamıyor</string>
    <string name="dns_conn_info">DNS, bir alan adını bir IP adresine çevirir. Gerçek veriler genellikle sonraki HTTPS/TLS bağlantıları üzerinden değiştirilir</string>
    <string name="unsupported_pcap_file">Desteklenmeyen yakalama dosyası biçimi</string>
    <string name="decrypt_pcap_file">PCAP/Pcapng dosyasının şifresini çöz…</string>
    <string name="keylog_read_error">SSL keylog okuma hatası</string>
    <string name="tcp_collector_info">TCP toplayıcı: %1$s:%2$d</string>
    <string name="tcp_exporter">TCP dışa aktarıcı</string>
    <string name="tcp_udp_exporter">TCP/UDP dışa aktarıcı</string>
    <string name="tcp_exporter_info">PCAP dökümünü uzak bir TCP alıcısına gönder (pcap-over-ip)</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="no_permissions_set_info">İzin ayarlanmadı. İzin istemini görüntülemek için StartActivityForResult aracılığıyla PCAPdroid\'i başlatın</string>
    <string name="generate_api_key">API anahtarı oluştur</string>
    <string name="show_api_key">API anahtarını göster</string>
    <string name="api_key">API anahtarı</string>
    <string name="api_key_discard_confirm">Geçerli API anahtarını gerçekten silmek ve yeni bir tane oluşturmak istiyor musunuz?</string>
    <string name="ip_address_or_cidr">IP adresi / CIDR</string>
    <string name="tls_decryption_not_supported_16KB">TLS şifre çözme şu anda 16 KB aygıtlarda desteklenmiyor</string>
    <string name="filename_prefix">Dosya adı ön eki</string>
    <string name="filename_prefix_description">PCAPdroid tarafından dışa aktarılan dosyalar (örneğin PCAP dosyaları) için ön ek ayarlayın</string>
    <string name="select">Seç</string>
    <string name="request_method">İstek yöntemi</string>
    <string name="content_type">İçerik türü</string>
    <string name="http_status">HTTP durumu</string>
    <string name="payload_size_threshold">Yük boyutu eşiği</string>
    <string name="method_filter">Yöntem: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="text">Metin</string>
    <string name="display_as_text">Metin olarak görüntüle</string>
    <string name="display_as_hexdump">Onaltılık döküm olarak görüntüle</string>
    <string name="exporting">Dışa aktarılıyor…</string>
    <string name="export_in_progress">Dışa aktarma devam ediyor, lütfen bekleyin</string>
    <string name="show_connection">Bağlantıyı göster</string>
    <string name="show_system_apps">Sistem uygulamalarını göster</string>
    <string name="destination_host">Hedef ana makine</string>
    <string name="no_requests">İstek yok</string>
    <string name="item_not_found">Belirtilen öge bulunamadı</string>
    <string name="connection_number">Bağlantı #%1$d</string>
    <string name="http_request_number">HTTP isteği #%1$d</string>
    <string name="http_requests">HTTP istekleri</string>
    <string name="switch_to_http">HTTP isteklerini göster</string>
    <string name="switch_to_connections">Bağlantıları göster</string>
    <string name="decryption_error">Şifre çözme hatası</string>
    <string name="previous">Önceki</string>
    <string name="next">Sonraki</string>
    <string name="save_as_text">Metin olarak kaydet</string>
    <string name="save_as_har">HAR olarak kaydet</string>
</resources>

```

`app/src/main/res/values-uk/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">Пуск</string>
    <string name="bytes_rcvd">Отримано байт</string>
    <string name="packets_sent">Надіслано пакетів</string>
    <string name="packets_rcvd">Отримано пакетів</string>
    <string name="search_apps">Пошук додатків</string>
    <string name="no_apps">Без додатків</string>
    <string name="dns_queries">Запитів DNS</string>
    <string name="notification_msg">%1$s захоплено, %2$s з\'єднань</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="ip_address_val">IP адреса: %1$s</string>
    <string name="host_val">Хост: %1$s</string>
    <string name="protocol_val">Protocol: %1$s</string>
    <string name="select_all">Вибрати все</string>
    <string name="uid">UID</string>
    <string name="version">Версія</string>
    <string name="target_sdk">Цільовий SDK</string>
    <string name="capture_prefs">Захопити</string>
    <string name="show_only_malicious">Зловмисні з\'єднання</string>
    <string name="status_filter">Статус HTTP: %1$s</string>
    <string name="asn">ASN</string>
    <string name="country_val">Країна: %1$s</string>
    <string name="malware_status_detected">Виявлено зловмисні з\'єднання</string>
    <string name="whitelist">Білий список</string>
    <string name="blacklists">Чорний список</string>
    <string name="blacklist_type">Тип: %1$s</string>
    <string name="status_uptodate">Актуально</string>
    <string name="last_blacklists_update">Останнє оновлення</string>
    <string name="connections_checked">Перевірено з\'єднань</string>
    <string name="domain_rules">Правил домену</string>
    <string name="ip_rules">Правил IP</string>
    <string name="update_now">Оновити зараз</string>
    <string name="status_updating">Оновлення…</string>
    <string name="decryption_no_filter_warn">Виберіть цільову програму при дешифруванні TLS, щоб уникнути втрати з\'єднання з Інтернетом</string>
    <string name="block">Блокується…</string>
    <string name="unblock">Розблоковується…</string>
    <string name="firewall">Фаєрвол</string>
    <string name="network_interface">Інтерфейс</string>
    <string name="interface_filter">Інтерфейс: %1$s</string>
    <string name="request_method">Метод запиту</string>
    <string name="content_type">Тип вмісту</string>
    <string name="http_status">HTTP статус</string>
    <string name="payload_size_threshold">Поріг розміру корисного навантаження</string>
    <string name="method_filter">Метод: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="loading">Вантаження…</string>
    <string name="billing_failure">Не вдалося під\'єднатися до Google Play. Будь ласка, спробуйте пізніше</string>
    <string name="learn_more">Дізнатися більше</string>
    <string name="buy_action">Купити</string>
    <string name="open_nav_drawer">Відкрити меню</string>
    <string name="can_use_purchased_feature">Тепер ви можете користуватися придбаною функцією</string>
    <string name="save_ok">Збережено</string>
    <string name="tls_decryption">Дешифрування TLS</string>
    <string name="checking_the_certificate">Перевірка сертифікату…</string>
    <string name="cert_installed_correctly">Сертифікат ЦС встановлено</string>
    <string name="websocket">WebSocket</string>
    <string name="http">HTTP</string>
    <string name="payload">Корисне навантаження</string>
    <string name="decrypted">Дешифровано</string>
    <string name="decryption">Дешифрування</string>
    <string name="waiting_application_data">Очікування даних</string>
    <string name="text">Текст</string>
    <string name="hexdump">Hex дамп</string>
    <string name="display_as_text">Відобразити як текст</string>
    <string name="display_as_hexdump">Відобразити як hexdump</string>
    <string name="geolocation_summary">Показати країну та ASN інформацію, виконавши офлайн пошуки</string>
    <string name="geo_db_not_found">Базу даних не знайдена. Геолокацію вимкнено</string>
    <string name="database">База даних</string>
    <string name="invalid_backup">Недійсний формат резерву</string>
    <string name="firewall_is_enabled">Мережевий екран увімкнено</string>
    <string name="app_info">Про програму</string>
    <string name="action_block">Заблокувати</string>
    <string name="firewall_summary">Блокувати доступ до Інтернету для додатків, налаштувати правила для конкретних доменів і адрес IP. Працює тільки з не-рут захопленням</string>
    <string name="no_root_firewall">Фаєрвол без рут</string>
    <string name="block_quick">Блокувати QUIC</string>
    <string name="block_private_dns">Блокувати приватний DNS</string>
    <string name="block_private_dns_summary">Виявляти та по можливості блокувати приватний DNS для перевірки трафіку DNS. Вимкнення цього може перешкоджати аналізу трафіку</string>
    <string name="welcome_to_pcapdroid">Вітаємо в PCAPdroid</string>
    <string name="app_intro_next_button">Далі</string>
    <string name="app_intro_skip_button">Пропустити</string>
    <string name="app_intro_back_button">Назад</string>
    <string name="privacy_first">Спершу конфіденційність</string>
    <string name="app_intro_privacy_msg">Додаток не використовує функції відстеження, аналітики чи телефонії
\n
\nЯк ви можете впевнитися\? Ознайомтеся з його <a href="%1$s">політикою конфіденційності</a> та <a href="%2$s">початковим кодом</a></string>
    <string name="permission_granted">Дозвіл %1$s надано</string>
    <string name="permission_grant_fail">Не вдалося надати дозвіл %1$s</string>
    <string name="connection_not_found">Не вдалося знайти дане з\'єднання</string>
    <string name="vpn_exemptions">Винятки VPN</string>
    <string name="unblock_permanently">Розблокувати назавжди</string>
    <string name="app_blocked">Додаток заблоковано</string>
    <string name="build_info">Інформація про збірку</string>
    <string name="mitm_wizard_description">Налаштувати пристрій для дешифрування TLS</string>
    <string name="license_error">Помилка генерування ліцензії [%1$d]: %2$s</string>
    <string name="requesting_license">Запит коду ліцензії, будь ласка, зачекайте</string>
    <string name="pcap_file_not_exists">Вказаний файл не існує</string>
    <string name="pcap_read_error">Помилка читання файла захоплення. Перевірте журнал для подробиць</string>
    <string name="pcapdroid_trailer_notice">Для показу актуальних додатків замість \"%1$s\", переконайтеся, що увімкнено опцію \"%2$s\" перед генеруванням дампу</string>
    <string name="active_vpn_detected">Виявлено активний VPN</string>
    <string name="app_intro_firewall_msg">З вбудованим <a href="%1$s">Фаєрволом</a> можна легко блокувати доступ до інтернету для окремих додатків, доменів і країн \n \nПоєднайте це з вбудованим відстеженням трафіку, щоб отримати найкращий інструмент для захисту вашої конфіденційності</string>
    <string name="app_intro_malware_detection">Покращить безпеку вашого пристрою з функцією <a href="%1$s">виявлення зловмисного ПЗ</a>
\n
\nВикористовуючи актуальні чорні списки, він може виявляти, блокувати та попереджати про зловмисні з\'єднання в реальному часі</string>
    <string name="app_intro_traffic_dump">PCAPdroid надає <a href="%1$s">кілька способів</a> дампувати трафік у стандартний формат PCAP для подальшого аналізу \n \nЗа допомогою <a href="%2$s">опції розширення PCAPdroid</a>, ви можете додати назви додатків до пакетів і показувати їх у Wireshark</string>
    <string name="low_memory">Недостатньо пам\'яті</string>
    <string name="low_memory_info">Додатку не вистачає пам\'яті, очікуються збої</string>
    <string name="full_payload_disabled">Опцію повного корисного навантаження вимкнуто</string>
    <string name="capture_stopped_low_memory">Захоплення зупинено</string>
    <string name="heap_usage">Використання купи</string>
    <string name="memory_usage">Використання пам’яті</string>
    <string name="vpn_lockdown_notice">Щоб запобігти отримання додаткам доступу до Інтернету, коли PCAPdroid не запущений (наприклад, після перезавантаження) ви можете встановити PCAPdroid як Постійна мережа VPN в режимі блокування.
\n
\nХочете відкрити налаштування VPN зараз\?</string>
    <string name="ip_mode">IP адреси VPN</string>
    <string name="ipv4_only">Лише IPv4</string>
    <string name="ipv6_only">Лише IPv6</string>
    <string name="ip_both">IPv4 та IPv6</string>
    <string name="notifications_notice">Додаток використовує сповіщення для надсилання попереджень у разі ненормальних подій. Надайте йому дозвіл надсилати сповіщення у наступному екрані</string>
    <string name="vpn_exemptions_summary">Виключити деякі додатки зі з\'єднання VPN. Їхній трафік не відстежуватиметься</string>
    <string name="no_matches_found">Немає збігів</string>
    <string name="cleartext_connection">Незашифрований текст</string>
    <string name="unblock_for_n_hours">Розблокувати на %1$dг</string>
    <string name="unblock_for_n_minutes">Розблокувати на %1$dхв</string>
    <string name="block_new_apps">Блокувати ново встановлені додатки</string>
    <string name="app_blocked_info">Додаток %1$s заблоковано фаєрволом</string>
    <string name="app_unblocked">Додаток %1$s розблоковано</string>
    <string name="payload_scams_notice">Це подання може містити конфіденційну інформацію, наприклад, ваші паролі та токени доступу.
\n
\nНіколи не передавайте цю інформацію комусь, це може бути спробою шахрайства</string>
    <string name="cancel_action">Скасувати</string>
    <string name="show_data_action">Показати дані</string>
    <string name="remote_collector_notice">Ви налаштували PCAPdroid для надсилання трафіку віддаленому серверу. Сервер зможе отримати доступ до вашої конфіденційної інформації.
\n
\nЯкщо хтось попросив вас це зробити, це, ймовірно, спроба шахрайства</string>
    <string name="remote_server_warning">З міркувань безпеки, надсилання трафіку на віддалений сервер \"%1$s\" не дозволено</string>
    <string name="warning">Застереження</string>
    <string name="paid_features_unlocked">Платні функції розблоковано. Перезапустіть захоплення, якщо виконується</string>
    <string name="tls_decryption_with_root_msg">Можливість виконати дешифрування TLS з рут це експериментальна функція. Список відомих багів: \n \n - у PCAPdroid ви побачите трафік, згенерований додатком доповненням mitm замість оригінальним додатком \n - Дамп журналу ключів SSL не підтримується \n - коли встановлено фільтр додатку, дешифрування відбуватиметься лише для цільового додатка, але PCAPdroid все одно показуватиме трафік інших додатків \n - якщо захоплення не вдається запустити, переконайтеся, що ви дійсно можете виконувати команду iptables як рут (наприклад, через termux) \n - може не працювати на Android 12 і вище \n - якщо додаток VPN виконується, ви повинні або вибрати конкретний додаток для дешифрування або виключити доповнення PCAPdroid mitm з VPN, інакше трафік буде зациклений</string>
    <string name="unlock_token_summary">Токен який може використовуватися для розблокування платних функцій в збірках додатку без Google Play (наприклад, F-Droid/Github)</string>
    <string name="unlock_token_error">Не вдався запит токена розблокування [%1$d]: %2$s</string>
    <string name="access_paid_features_msg">Ознайомтесь з <a href="%1$s">посібником користувача</a>, щоб дізнатися, як отримати доступ до платних функцій</string>
    <string name="license_service_unavailable">Служба ліцензування PCAPdroid зараз недоступна. Будь ласка, повторіть спробу через кілька хвилин</string>
    <string name="requesting_unlock_token">Запит токена розблокування, зачекайте, будь ласка</string>
    <string name="show_action">Показати</string>
    <string name="show_connection">Показати з\'єднання</string>
    <string name="show_system_apps">Показати системні додатки</string>
    <string name="unlock_token_msg1">Це ваш токен розблокування. Занотуйте його, оскільки він вам знадобиться <a href="%1$s">для генерування ваших кодів ліцензії</a></string>
    <string name="paid_feature">Платна функція</string>
    <string name="firewall_purchase_msg">Купіть функцію <i>%1$s</i>, щоб розпочати блокування з\'єднання</string>
    <string name="mitm_skip_notice">Здається, сертифікат mitm не встановлено. Якщо ви продовжите, дешифрування може не вдатися</string>
    <string name="mitmproxy_opts">Додаткові опції mitmproxy</string>
    <string name="mitmproxy_opts_description">Надати додаткові опції для mitmproxy</string>
    <string name="mitm_addon_error">Помилка при запуску доповнення mitm. Перевірте лог для подробиць</string>
    <string name="whitelist_mode">Режим білого списку</string>
    <string name="firewall_whitelist_notice">У цьому режимі всі з\'єднання блокуватимуться, якщо не внесено до білого списку вручну. Ви можете пропустити спливаючі повідомлення без належного білого списку</string>
    <string name="firewall_whitelist_help">Ці правила визначають які з\'єднання дозволяти. Правила списку блокування мають пріоритет над правилами білого списку</string>
    <string name="add_to_fw_whitelist">Додати до білого списку фаєрволу</string>
    <string name="remove_from_fw_whitelist">Вилучити з білого списку фаєрволу</string>
    <string name="reset_stats_confirm">Ви дійсно хочете скинути цю статистику\?</string>
    <string name="port_mapping">Мапування порту</string>
    <string name="port_mapping_summary">Налаштувати правила мапування порту для перенаправлення з\'єднань до іншого хосту чи порту</string>
    <string name="add_action">Додати</string>
    <string name="redirect_to">Перенаправити до:</string>
    <string name="original_port">Оригінальний порт</string>
    <string name="required">обов’язково</string>
    <string name="destination_host">Хост призначення</string>
    <string name="destination_port">Порт призначення</string>
    <string name="port_mapping_exists">Мапування порту вже визначене</string>
    <string name="items_delete_confirm">Видалити вибрані елементи\?</string>
    <string name="ip_address">IP адреса</string>
    <string name="rule_exists">Правило вже визначене</string>
    <string name="dns_servers">Сервери DNS</string>
    <string name="dns_servers_summary">Налаштувати сервери DNS, щоб використовувати під час захоплення</string>
    <string name="ipv4_dns_server">IPv4 сервер DNS</string>
    <string name="ipv6_dns_server">IPv6 сервер DNS</string>
    <string name="use_system_dns">Використовувати системний DNS</string>
    <string name="use_system_dns_summary">При можливості використовувати системні сервери DNS</string>
    <string name="external_storage_perm_required">Потрібен дозвіл на доступ до зовнішньої пам\'яті</string>
    <string name="many_rules_warning">Ви намагаєтеся імпортувати багато правил, які можуть зробити додаток не відповідним під час деяких взаємодій. Ви дійсно хочете продовжити\?</string>
    <string name="pcapng_format">Формат Pcapng</string>
    <string name="pcapng_format_summary">Дамп пакетів у форматі дампу Pcapng, який більш гнучкий і дозволяє вкладання секретів дешифрування TLS</string>
    <string name="sort_by">Сортувати за</string>
    <string name="total_bytes">Всього байт</string>
    <string name="write_ext_storage_failed">Не вдалося записати на зовнішню пам\'ять. Перевірте лог додатку для подробиць</string>
    <string name="username">Ім\'я користувача</string>
    <string name="password">Пароль</string>
    <string name="mitm_addon_autostart_workaround">Під\'єднання до доповнення mitm не вдалося. Як обхідний шлях, ви можете спробувати відкрити додаток доповнення mitm і тоді повернутися до PCAPdroid, не закриваючи його. Ви хочете відкрити його зараз\?</string>
    <string name="qr_license_confirm">Ви хочете згенерувати ліцензію для пристрою \"%1$s\" використовуючи нижченаведений токен розблокування\?</string>
    <string name="connection_error">Помилка з’єднання: %1$s</string>
    <string name="invalid_license">Недійсна ліцензія</string>
    <string name="activate_via_qr_code">Активувати через QR код</string>
    <string name="qr_code_expired">QR код застарів. Згенеруйте новий QR код і повторіть спробу</string>
    <string name="qr_info_text">Встановіть PCAPdroid з Google Play та відскануйте цей QR код</string>
    <string name="mitm_addon_starting">Mitm доповнення запускається…</string>
    <string name="mitm_addon_running">Mitm доповнення запущене</string>
    <string name="decryption_rules">Правила дешифрування</string>
    <string name="qr_purchase_required">Придбайте токен розблокування, щоб продовжити активацію з QR кодом</string>
    <string name="license_limit_reached">Ви досягли обмеження ліцензій для цього токена розблокування. Купіть новий токен, щоб згенерувати більше ліцензій</string>
    <string name="license_activation_ok">Активація ліцензії завершена</string>
    <string name="decryption_rules_help">Ці правила визначають які з\'єднання дешифрувати. Правила на основі хосту працюють лише якщо виявлено попередню відповідь DNS</string>
    <string name="decrypt_action">Дешифрується…</string>
    <string name="dont_decrypt_action">Не дешифрується…</string>
    <string name="status_encrypted">Зашифровано</string>
    <string name="injected">Введено</string>
    <string name="open_pcap_file">Відкрити файл PCAP/Pcapng…</string>
    <string name="pcap_load_success">Файл захоплення завантажено</string>
    <string name="invalid_pcap_file">Недійсний формат файла захоплення</string>
    <string name="capture_interface_open_error">Не вдалося відкрити інтерфейс захоплення</string>
    <string name="unsupported_pcap_datalink">Файл не підтримується каналом передачі даних</string>
    <string name="root_capture_start_failed">Запуск захоплення не вдався. Переконайтеся що пристрій рутовано з Magisk</string>
    <string name="pcap_file_load_aborted">Вантаження файлу захоплення перервано</string>
    <string name="host_resolution_failed">Не вдається визначити хост %1$s</string>
    <string name="decryption_info_no_rule">Щоб дешифрувати це з\'єднання, створіть правило дешифрування з лівої панелі або з контекстного меню в списку З\'єднання</string>
    <string name="tls_decryption_no_rules_notice">Дешифрування TLS застосовується лише для з\'єднань, які відповідають налаштованим правилам. Ви хочете створити правила дешифрування зараз\?</string>
    <string name="stop_button">Зупинити</string>
    <string name="title_activity_settings">Налаштування</string>
    <string name="collector_info">Збирач UDP: %1$s:%2$d</string>
    <string name="http_server_status">HTTP сервер: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s отримано — %2$s відправлено</string>
    <string name="query">Запит</string>
    <string name="host">Хост</string>
    <string name="about">Про додаток</string>
    <string name="status">Статус</string>
    <string name="connections_view">З\'єднання</string>
    <string name="no_connections">Немає з\'єднання</string>
    <string name="ready">Готовий</string>
    <string name="connection_details">Деталі з\'єднання</string>
    <string name="app">Додаток</string>
    <string name="protocol">Протокол</string>
    <string name="source">Джерело</string>
    <string name="destination">Призначення</string>
    <string name="duration">Тривалість</string>
    <string name="http_server">HTTP сервер</string>
    <string name="udp_exporter">Експортер UDP</string>
    <string name="no_dump">Без дампу</string>
    <string name="no_dump_info">Трафік не вивантажуватиметься</string>
    <string name="http_server_info">Запустити HTTP сервер для завантаження PCAP</string>
    <string name="udp_exporter_info">Надсилання PCAP до віддаленого UDP приймача</string>
    <string name="http_server_port">Порт HTTP сервера</string>
    <string name="receiver_ip_address">IP адреса для збору</string>
    <string name="receiver_port">Порт для збору</string>
    <string name="traffic_dump">Дамп трафіку</string>
    <string name="user_guide">Посібник користувача</string>
    <string name="open_telegram_group">Група Телеграм</string>
    <string name="source_code">Початковий код</string>
    <string name="yes">Так</string>
    <string name="no">Ні</string>
    <string name="vpn_setup_failed">Не вдалося під\'єднати VPN. Переконайтеся що вимкнена Постійна мережа VPN</string>
    <string name="app_not_found">Не вдалося знайти додаток \"%1$s\"</string>
    <string name="stats">Статистика</string>
    <string name="dropped_connections">Втрачено з\'єднань</string>
    <string name="tot_connections">Всього з\'єднань</string>
    <string name="open_sockets">Відкриті сокети</string>
    <string name="bytes_sent">Надіслано байт</string>
    <string name="dns_server">Сервер DNS</string>
    <string name="apps">Додатки</string>
    <string name="pcap_file">Файл PCAP</string>
    <string name="pcap_file_info">Створити файл PCAP/Pcapng на пристрої</string>
    <string name="cannot_write_file">Неможливо записати файл</string>
    <string name="share">Поділитися</string>
    <string name="delete">Видалити</string>
    <string name="ok">OK</string>
    <string name="pcap_file_action">Трафік збережено в файл \"%1$s\" (%2$s)</string>
    <string name="delete_error">Не вдалося видалити файл</string>
    <string name="copy_error">Не вдалося записати файл</string>
    <string name="capture_running">Захоплення виконується</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="conn_status_active">Активне</string>
    <string name="first_seen">Вперше виявлено</string>
    <string name="last_seen">Востаннє виявлено</string>
    <string name="conn_status_closed">Закрите</string>
    <string name="copy_to_clipboard">Копіювати</string>
    <string name="save_to_file">Зберегти до файлу</string>
    <string name="older_connections_notice">%1$d застарілих з\'єднань не показано</string>
    <string name="about_text">PCAPdroid є інструментом з відкритим кодом для захоплення та моніторингу мережі який працює без рут прав</string>
    <string name="get_app">Отримати:</string>
    <string name="unknown_app">Невідомо</string>
    <string name="phone_app">Телефон</string>
    <string name="error">Помилка</string>
    <string name="conn_status_unreachable">Недосяжне</string>
    <string name="other_prefs">Інші</string>
    <string name="app_language">Мова додатку</string>
    <string name="system_default">Системна</string>
    <string name="no_activity_file_selection">Не знайдено програми для ручного вибирання файлу</string>
    <string name="file_saved_with_name">Файл збережено як \"%1$s\"</string>
    <string name="socks5_redirection">Перенаправлення SOCKS5</string>
    <string name="socks5_summary">Параметри перенаправлення до проксі SOCKS5</string>
    <string name="enable_socks5_proxy_summary">Перенаправити TCP всі з\'єднання до проксі SOCKS5</string>
    <string name="socks5_info">Проксі SOCKS5: %1$s:%2$d</string>
    <string name="socks5_auth">Автентифікація SOCKS5</string>
    <string name="socks5_auth_summary">Автентифікувати до проксі за допомогою імені користувача і пароля</string>
    <string name="proxy_host">Хост проксі</string>
    <string name="proxy_port">Порт проксі</string>
    <string name="root_capture">Захопити як рут</string>
    <string name="root_capture_summary">Дозволяє PCAPdroid працювати з іншими додатками VPN</string>
    <string name="donate">Пожертвувати</string>
    <string name="app_log">Лог</string>
    <string name="no_data">Немає даних</string>
    <string name="search">Пошук…</string>
    <string name="app_val">Додаток: %1$s</string>
    <string name="malware_whitelist_action">Білий список (зловмисне ПЗ)…</string>
    <string name="hide">Приховати…</string>
    <string name="select">Вибрати</string>
    <string name="n_selected">%1$d вибрано</string>
    <string name="app_details">Подробиці додатку</string>
    <string name="package_name">Ім\'я пакету</string>
    <string name="app_name">Назва</string>
    <string name="last_update">Останнє оновлення</string>
    <string name="permissions">Дозволи</string>
    <string name="root_app_info">Системні демони виконуються з максимальними правами</string>
    <string name="netd_app_info">Системний демон виконує резолюції DNS</string>
    <string name="android_app_info">Система Android</string>
    <string name="phone_app_info">Телефонні сервіси</string>
    <string name="unknown_app_info">\"Невідомо\" позначаються з\'єднання, якщо додаток не вдалося визначити</string>
    <string name="packets_dropped">Втрачено пакетів</string>
    <string name="pending_transaction">Будь ласка, виконайте транзакцію, щоб активувати цю функцію</string>
    <string name="ctrl_consent">Додаток хоче захопити трафік вашого пристрою.
\nЗабороніть, якщо не впевнені</string>
    <string name="deny">Заборонити</string>
    <string name="allow">Дозволити</string>
    <string name="ctrl_consent_title">Запит контролю PCAPdroid</string>
    <string name="ctrl_consent_denied">PCAPdroid: запит на контроль заборонено</string>
    <string name="ctrl_consent_allowed">PCAPdroid: запит на контроль дозволено</string>
    <string name="capture_interface">Інтерфейс захоплення</string>
    <string name="internet">Інтернет</string>
    <string name="all_interfaces">Всі інтерфейси</string>
    <string name="capturing_from">Захоплення пакетів з \"%1$s\"</string>
    <string name="edit_filter">Редагувати фільтр</string>
    <string name="edit_list">Редагувати список</string>
    <string name="hidden_connections_rules">Правила прихованих з\'єднань</string>
    <string name="list_is_empty">Список порожній</string>
    <string name="show_only_cleartext">Незашифровані текстові з\'єднання</string>
    <string name="security">Захист</string>
    <string name="malware_detection">Виявлення зловмисного ПЗ</string>
    <string name="malware_detection_summary">Виявляти з\'єднання з відомими зловмисними хостами через сторонні чорні списки</string>
    <string name="reset">Скинути</string>
    <string name="malware_whitelist_rules">Правила білого списку зловмисного ПЗ</string>
    <string name="feature_not_available">Ця функція наразі недоступна для вашого пристрою</string>
    <string name="billing_connecting">Триває з\'єднання з Google Play, будь ласка, спробуйте пізніше</string>
    <string name="malware_whitelist_help">Зазначений користувачем білий список пригнічує виявлення зловмисного ПЗ. Утримуйте зловмисні з\'єднання для створення правил розмаркування їх як зловмисне ПЗ</string>
    <string name="hidden_connections_help">Список правил для приховання записів списку підключень, щоб ви могли зосередитися на доречних</string>
    <string name="malicious_connection_filter">Зловмисні</string>
    <string name="not_hidden_filter">Не приховано</string>
    <string name="copy_action">Копіювати…</string>
    <string name="url_val">URL: %1$s</string>
    <string name="show_me">Показати</string>
    <string name="hint">Підказка</string>
    <string name="once">Раз</string>
    <string name="forever">Назавжди</string>
    <string name="control_permissions_summary">Виберіть, яким програмам дозволено керувати захопленням PCAPdroid</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">Країна</string>
    <string name="send_report">Надіслати звіт</string>
    <string name="start_at_boot">Запускати при завантаженні</string>
    <string name="start_at_boot_summary">Авто починати захоплення після завантаження</string>
    <string name="malware_status_ok">Не виявлено зловмисного трафіку</string>
    <string name="status_outdated">Застаріле</string>
    <string name="status_not_loaded">Не завантажено</string>
    <string name="n_rules">%1$s правил</string>
    <string name="last_update_val">Останнє оновлення: %1$s</string>
    <string name="blacklist_type_ip">IP чорного списку</string>
    <string name="malicious_connections">Зловмисних з\'єднань</string>
    <string name="updated_blacklists">Оновлено чорних списків</string>
    <string name="malware_status_update_failed">Деякі чорні списки застаріли</string>
    <string name="malware_detection_learn_more">Дізнатися більше про функцію виявлення зловмисного ПЗ</string>
    <string name="private_dns_message_notice">Приватна DNS перешкоджає PCAPdroid перевірці трафіку DNS. Потрібно вимкнути її в налаштуваннях мережі Андроїда</string>
    <string name="private_dns_hinders_detection">Приватна DNS перешкоджає виявленню</string>
    <string name="firewall_rules">Правила фаєрволу</string>
    <string name="blocked_pkts">Заблоковано</string>
    <string name="n_pkts">%1$s п-ів</string>
    <string name="blocked_connection_filter">Заблоковано</string>
    <string name="allowed_connection_filter">Дозволено</string>
    <string name="firewall_filter">Фаєрвол: %1$s</string>
    <string name="paid_features">Платні функції</string>
    <string name="validate">Перевірити</string>
    <string name="valid">Дійсні</string>
    <string name="invalid">Недійсні</string>
    <string name="no_intent_handler_found">Не знайдено додатку, щоб виконати цю дію</string>
    <string name="purchased">Придбано</string>
    <string name="no_items_for_purchase">Недоступно для покупки</string>
    <string name="capture_not_running_status">Захоплення не запущене</string>
    <string name="start_capture_first">Спочатку запустіть захоплення</string>
    <string name="copied">Скопійовано</string>
    <string name="disconnect_vpn_confirm">Продовження роз\'єднає активований VPN</string>
    <string name="loading_apps">Додатки вантажаться…</string>
    <string name="close_nav_drawer">Закрити меню</string>
    <string name="capture_all_apps">Захоплюється трафік усіх програм</string>
    <string name="tls_decryption_summary">Дешифрувати трафік SSL/TLS через mitm. Може не працювати з деякими додатками, ознайомтеся з посібником користувача</string>
    <string name="traffic_inspection">Перевірка трафіку</string>
    <string name="mitm_start_failed">Не вдалося запустити сервіс mitm. Спробуйте відкрити додаток доповнення mitm вручну і повторіть спробу</string>
    <string name="mitm_setup_wizard">Майстер встановлення mitm</string>
    <string name="install_action">Встановити</string>
    <string name="export_action">Експортувати</string>
    <string name="install_the_mitm_addon">Встановити <a href="%1$s">доповнення mitm</a> PCAPdroid</string>
    <string name="export_ca_certificate">Експортуйте сертифікат PCAPdroid CA. потім відкрийте налаштування Android \"Шифрування й облікові дані\" та виберіть встановити його як \"Сертифікат ЦС\"</string>
    <string name="install_ca_certificate">Встановіть сертифікат PCAPdroid CA, обираючи \"VPN та додатки\". Android запитає ваше блокування екрану або пароль</string>
    <string name="ca_cert_export_failed">Трапилася помилка при експортуванні сертифікату ЦС
\n
\nЯкщо ваш пристрій оснащено Autostart або подібною програмою для обмеження виконання фонових сервісів, впевніться що <a href="%1$s">PCAPdroid в білому списку</a></string>
    <string name="cert_exported_now_installed">Сертифікат експортовано, тепер встановіть його з налаштувань Android</string>
    <string name="cert_reinstall_required">Сертифікат ЦС не встановлено, запустіть майстер встановлення mitm</string>
    <string name="mitm_addon_bad_version">Неправильна версія доповнення PCAPdroid mitm. Будь ласка, встановіть версію %1$s і повторіть спробу</string>
    <string name="mitm_addon_new_version">Необхідно оновити доповнення PCAPdroid mitm</string>
    <string name="mitm_addon">доповнення mitm</string>
    <string name="export_failed">Не вдалося експортувати</string>
    <string name="not_encrypted">Не зашифровано</string>
    <string name="request">Запит</string>
    <string name="response">Відповідь</string>
    <string name="overview">Перегляд</string>
    <string name="string_http_request">HTTP запит</string>
    <string name="string_http_response">HTTP відповідь</string>
    <string name="payload_truncated">Корисне навантаження скорочене. Щоб показати його повністю, зупиніть захоплення та ввімкніть \"%1$s\" з налаштувань PCAPdroid</string>
    <string name="tx_direction">TX</string>
    <string name="rx_direction">RX</string>
    <string name="full_payload">Повне корисне навантаження</string>
    <string name="full_payload_summary">Показати повне корисне навантаження з\'єднань (наприклад, повний HTTP запит і відповідь). Це вимагає багато пам\'яті, не використовуйте довго</string>
    <string name="not_decryptable">Не дешифрувати</string>
    <string name="decryption_filter">Статус: %1$s</string>
    <string name="connection_start_not_seen">PCAPdroid не виявив початку цього з\'єднання. Деяка інформація може зникнути</string>
    <string name="network_traffic">Трафік</string>
    <string name="warn_no_app_data">Дані програми не обміняно</string>
    <string name="geolocation">Геолокація</string>
    <string name="downloading">Завантаження…</string>
    <string name="download_in_progress">Триває завантаження, зачекайте, будь ласка</string>
    <string name="pcap_load_in_progress">Триває вантаження файлу захоплення, будь ласка, зачекайте</string>
    <string name="download_failed">Не вдалося завантажити</string>
    <string name="exporting">Експорт…</string>
    <string name="export_in_progress">Експорт виконується, зачекайте</string>
    <string name="built_on">Створено: %1$s</string>
    <string name="geo_db_download">Торкніться, щоб завантажити останню базу даних. Нові бази даних доступні щомісячно</string>
    <string name="size_x">Розмір: %1$s</string>
    <string name="geo_db_delete">Торкніться, щоб видалити базу даних і заощадити місце</string>
    <string name="download">Завантажити</string>
    <string name="connection_blocked">Це з\'єднання заблоковано PCAPdroid-ом</string>
    <string name="import_action">Імпортувати</string>
    <string name="import_failed">Не вдалося імпортувати</string>
    <string name="rules_import_success">Імпортовано %1$d правил</string>
    <string name="no_rules_to_export">Немає правил для експорту</string>
    <string name="rules_merge_msg">Залишити наявні правила\?</string>
    <string name="keep_action">Залишити</string>
    <string name="discard_action">Відхилити</string>
    <string name="rules_delete_confirm">Видалити вибрані правила\?</string>
    <string name="blocklist">Список блокування</string>
    <string name="num_configured_rules">Налаштовані правила</string>
    <string name="connections_blocked">З\'єднання заблоковані</string>
    <string name="last_firewall_block">Востаннє заблоковані</string>
    <string name="firewall_is_disabled">Мережевий екран вимкнено</string>
    <string name="action_unblock">Розблокувати</string>
    <string name="netd_block_missed">Це з\'єднання ініційовано мережею, тому його не вдається заблокувати</string>
    <string name="mitm_setup_wizard_intro">Цей майстер допоможе вам встановити доповнення PCAPdroid mitm і центр сертифікації, які потрібно щоб <a href="%1$s">дешифрувати TLS</a></string>
    <string name="mitm_setup_wizard_done">PCAPdroid тепер готовий до дешифрування трафіку TLS
\n
\nОзнайомтесь з <a href="%1$s">посібником користувача</a>, щоб дізнатися більше про заходи безпеки, які можуть перешкоджати дешифруванню і як їх обійти</string>
    <string name="app_intro_done_button">Готово</string>
    <string name="app_intro_welcome_msg">PCAPdroid - це безпечний для конфіденційності додаток, який дозволяє відстежувати та аналізувати з\'єднання, здійснені додатками на вашому пристрої
\n
\nКрім того, він дозволяє експортувати PCAP дамп трафіку, витягувати метадані та багато іншого!</string>
    <string name="country_and_asn">Країна та ASN</string>
    <string name="app_intro_geolocation_msg">PCAPdroid може запитувати локальні бази даних для визначення країни віддаленого сервера
\n
\nСпочатку потрібно завантажити геолокаційну базу даних з налаштувань додатку</string>
    <string name="vpn_setup_msg">PCAPdroid імітує VPN, щоб перехоплювати мережевий трафік без рут.
\n
\nЩоб почати захоплення, потрібно погодити запит VPN у наступному екрані
\n
\n<b>ПРИМІТКА:</b> щоб продовжити, вимкніть будь-яку налаштовану Постійну мережу VPN у налаштуваннях Android</string>
    <string name="app_intro_traffic_inspection">Перевіряти HTTP запити, відповіді та необроблені дані легко завдяки вбудованим декодерам
\n
\nЗ\'єднання зашифровано\? Ви можете ввімкнути <a href="%1$s">дешифрування TLS</a>, щоб отримати дешифровані дані</string>
    <string name="packets">Пакетів</string>
    <string name="active_connections">Активних з\'єднань</string>
    <string name="installed_on">Встановлено</string>
    <string name="control_permissions">Керування дозволами</string>
    <string name="blacklist_type_domain">Домен чорного списку</string>
    <string name="root_capture_pcapd_start_failure">Збій запуску захоплення. Переконайтеся, що ви надали рут доступ PCAPdroid</string>
    <string name="redirected">перенаправлено</string>
    <string name="never">Ніколи</string>
    <string name="both">Обидва</string>
    <string name="whats_new">Що нового</string>
    <string name="ipv6_bytes_sent">Надіслано IPv6 байт</string>
    <string name="ipv6_bytes_rcvd">Отримано IPv6 байт</string>
    <string name="mitm_doze_notice">Оптимізація акумулятора може перешкоджати роботі доповнення mitm</string>
    <string name="headers">Заголовки</string>
    <string name="connection_redirected_port_map">Це з\'єднання перенаправлено через правило мапування портів</string>
    <string name="always">Завжди</string>
    <string name="for_connections_to_decrypt">Тільки для з\'єднань для дешифрування</string>
    <string name="target_apps_help">Виберіть додатки для захоплення</string>
    <string name="restart_on_disconnection_summary">Автоматичний перезапуск захоплення після зупинки іншими VPN-програмами</string>
    <string name="raw_bytes">Необроблених байт</string>
    <string name="waiting_for_vpn_disconnect">Очікується від\'єднання активного VPN…</string>
    <string name="body">Головна частина</string>
    <string name="decrypt_quic_notice">Дешифрування QUIC наразі не підтримується. Як обхідний шлях, зупиніть захоплення і виберіть опцію блокування QUIC в налаштуваннях PCAPdroid</string>
    <string name="ipv6_bytes_percentage">Відсоток IPv6 байт</string>
    <string name="export_ellipsis">Експорт…</string>
    <string name="target_apps">Цільові додатки</string>
    <string name="vpn_reconnection">Перепід\'єднання VPN</string>
    <string name="vpn_reconnection_aborted">Перепід\'єднання VPN перервано</string>
    <string name="restart_on_disconnection">Перезапускати при від\'єднанні</string>
    <string name="dnscrypt_how_to">Як використовувати DoH / DNSCrypt з PCAPdroid</string>
    <string name="update_available">Доступне оновлення</string>
    <string name="mitm_addon_update_available">Вийшло нове оновлення доповнення mitm. Оновіть, щоб отримати найсвіжіші виправлення помилок</string>
    <string name="update_action">Оновити</string>
    <string name="errno_econnreset">З\'єднання скинуто одноранговим пристроєм</string>
    <string name="dns_conn_info">DNS перетворює доменне ім\'я на IP адресу. Фактичні дані зазвичай обмінюються через подальші з\'єднання HTTPS/TLS</string>
    <string name="errno_econnreset_msg">Сервер раптово закрив з\'єднання, зазвичай через збій або несподіване вимкнення</string>
    <string name="errno_econnrefused">Відмовлено у підключенні</string>
    <string name="errno_econnrefused_msg">Сервер відхилив з\'єднання, що може свідчити про надмірну зайнятість або несправність сервера</string>
    <string name="tls_conn_info">Трафік TLS/HTTPS зашифрований. Щоб оглядати цей трафік, необхідно його дешифрувати. Детальніше в <a href="%1$s">посібнику користувача</a> PCAPdroid</string>
    <string name="tls_decryption_not_supported_16KB">Дешифрування TLS наразі не підтримується на пристроях з 16 КБ сторінками</string>
    <string name="filename_prefix">Префікс імені файлу</string>
    <string name="filename_prefix_description">Встановити префікс для файлів, експортованих PCAPdroid, наприклад файлів PCAP</string>
    <string name="no_requests">Немає запитів</string>
    <string name="item_not_found">Не вдалося знайти вказаний елемент</string>
    <string name="connection_number">З\'єднання #%1$d</string>
    <string name="http_request_number">HTTP запит #%1$d</string>
    <string name="http_requests">HTTP запити</string>
    <string name="switch_to_http">Показати HTTP запити</string>
    <string name="switch_to_connections">Показати з\'єднання</string>
    <string name="decryption_error">Помилка дешифрування</string>
    <string name="previous">Назад</string>
    <string name="next">Далі</string>
    <string name="save_as_text">Зберегти як текст</string>
    <string name="save_as_har">Зберегти як HAR</string>
    <string name="select_the_keylog_file">Вибрати файл журналу ключів SSL</string>
    <string name="errno_enetdown_msg">Мережевий інтерфейс не працює або неможливо підключитися до мережі</string>
    <string name="malicious_connection_description">З\'єднання з додатка \"%1$s\" викликало правило виявлення зловмисного ПЗ (%2$s)</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="dump_extensions_summary">Розширити формат дампа пакетів додатковими метаданими, такими як додаток, який відправив/отримав врахований пакет</string>
    <string name="country_rules_warning">Щоб використовувати правила фаєрвола на основі країн, завантажте базу даних геолокацій з налаштувань PCAPdroid, інакше правила на основі країн будуть неефективними</string>
    <string name="malicious_connections_notice">Чорні списки можуть містити помилкові спрацьовування. Обов\'язково перевірте репутацію IP адреси/домену в Інтернеті. Можна виключити хибні спрацьовування за допомогою білого списку зловмисного ПЗ</string>
    <string name="decrypt_pcap_file">Розшифрувати файл PCAP/Pcapng…</string>
    <string name="geo_db_missing">Відсутня база даних геолокацій</string>
    <string name="ip_address_or_cidr">IP адреса / CIDR</string>
    <string name="unsupported_pcap_file">Непідтримуваний формат файла захоплення</string>
    <string name="keylog_read_error">Помилка читання журналу ключів SSL</string>
    <string name="errno_enetunreach_msg">Система не може знайти дійсний маршрут до мережі призначення</string>
    <string name="bytes_threshold">Поріг у байтах</string>
    <string name="errno_enetreset">Мережу скинуто</string>
    <string name="errno_econnaborted">З\'єднання перервано</string>
    <string name="select_the_pcap_file">Вибрати файл PCAP/Pcapng</string>
    <string name="errno_epipe">Розрив тунелювання</string>
    <string name="errno_epipe_msg">Сервер несподівано закрив з\'єднання під час передачі даних</string>
    <string name="errno_enetdown">Мережа не працює</string>
    <string name="errno_enetunreach">Мережа недосяжна</string>
    <string name="errno_econnaborted_msg">З\'єднання було перервано, як правило, через зміну мережі</string>
    <string name="errno_etimedout">Вичерпано час з\'єднання</string>
    <string name="errno_etimedout_msg">Сервер надто довго відповідав, ймовірно, через затримки в мережі чи зайнятість сервера</string>
    <string name="errno_ehostunreach">Немає маршруту до хосту</string>
    <string name="errno_ehostunreach_msg">Система не може знайти маршрут до хоста призначення</string>
    <string name="dump_extensions">Розширення PCAPdroid</string>
    <string name="dump_extensions_how_to">Як зображати розширення дампа PCAPdroid у Wireshark</string>
    <string name="error_code_with_text">%1$s (помилка %2$d)</string>
    <string name="errno_enetreset_msg">Мережеве з\'єднання було скинуто пристроєм-посередником (наприклад, роутером або мобільним оператором)</string>
    <string name="tcp_udp_exporter">Експортер TCP/UDP</string>
    <string name="tcp_collector_info">Збирач TCP: %1$s:%2$d</string>
    <string name="no_permissions_set_info">Дозволи не надано. Викличте PCAPdroid через StartActivityForResult для відображення запиту на отримання дозволів</string>
    <string name="tcp_exporter_info">Надсилання PCAP до віддаленого TCP приймача (pcap-over-ip)</string>
    <string name="tcp_exporter">Експортер TCP</string>
    <string name="generate_api_key">Згенерувати API-ключ</string>
    <string name="show_api_key">Показати API-ключ</string>
    <string name="api_key">API-ключ</string>
    <string name="api_key_discard_confirm">Ви дійсно хочете скасувати поточний API-ключ і згенерувати новий?</string>
</resources>

```

`app/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="start_button">启动</string>
    <string name="stop_button">停止</string>
    <string name="title_activity_settings">设置</string>
    <string name="collector_info">UDP 收集器： %1$s:%2$d</string>
    <string name="tcp_collector_info">TCP 收集器： %1$s:%2$d</string>
    <string name="http_server_status">HTTP 服务器： http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s 已接收 — %2$s 已发送</string>
    <string name="query">查询</string>
    <string name="host">主机</string>
    <string name="ready">就绪</string>
    <string name="about">关于</string>
    <string name="status">状态</string>
    <string name="connections_view">连接</string>
    <string name="no_connections">无连接</string>
    <string name="connection_details">连接详情</string>
    <string name="app">应用程序</string>
    <string name="protocol">协议</string>
    <string name="source">源</string>
    <string name="destination">目的地</string>
    <string name="packets">流量包</string>
    <string name="duration">持续时间</string>
    <string name="http_server">HTTP 服务器</string>
    <string name="udp_exporter">UDP 导出器</string>
    <string name="tcp_exporter">TCP 导出器</string>
    <string name="tcp_udp_exporter">TCP/UDP 导出器</string>
    <string name="no_dump">无转储</string>
    <string name="no_dump_info">不会转储流量</string>
    <string name="http_server_info">启动一个 HTTP 服务器下载 PCAP</string>
    <string name="udp_exporter_info">发送 PCAP 到远程 UDP 接收器</string>
    <string name="tcp_exporter_info">发送 PCAP 到远程 TCP 接收器（pcap-over-ip）</string>
    <string name="http_server_port">HTTP 服务器端口</string>
    <string name="receiver_ip_address">收集器 IP 地址</string>
    <string name="receiver_port">收集器端口</string>
    <string name="user_guide">用户指南</string>
    <string name="open_telegram_group">Telegram 群组</string>
    <string name="source_code">源代码</string>
    <string name="yes">是</string>
    <string name="no">否</string>
    <string name="vpn_setup_failed">无法设置 VPN。确保禁用了“始终开启 VPN”</string>
    <string name="app_not_found">找不到应用 %1$s</string>
    <string name="stats">统计数据</string>
    <string name="active_connections">活动连接</string>
    <string name="dropped_connections">丢失的连接</string>
    <string name="tot_connections">总连接</string>
    <string name="open_sockets">开放套接字</string>
    <string name="bytes_sent">已发送字节数</string>
    <string name="bytes_rcvd">已接收字节数</string>
    <string name="ipv6_bytes_sent">已发送IPv6字节数</string>
    <string name="ipv6_bytes_rcvd">已接收IPv6字节数</string>
    <string name="ipv6_bytes_percentage">IPv6字节数占比</string>
    <string name="packets_sent">已发送数据包</string>
    <string name="packets_rcvd">已接收数据包</string>
    <string name="dns_queries">DNS 查询</string>
    <string name="search_apps">搜索应用</string>
    <string name="no_apps">无应用</string>
    <string name="dns_server">DNS 服务器</string>
    <string name="apps">应用程序</string>
    <string name="pcap_file">PCAP 文件</string>
    <string name="pcap_file_info">在设备存储中创建一个 PCAP/Pcapng 文件</string>
    <string name="cannot_write_file">无法写文件</string>
    <string name="share">分享</string>
    <string name="delete">删除</string>
    <string name="ok">好的</string>
    <string name="pcap_file_action">已保存流量到文件\" %1$s \"(%2$s)</string>
    <string name="delete_error">无法删除文件</string>
    <string name="capture_running">流量捕获运行中</string>
    <string name="notification_msg">%1$s 已捕获, %2$s 连接</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="first_seen">第一次见</string>
    <string name="last_seen">最后一次见</string>
    <string name="conn_status_closed">已关闭</string>
    <string name="copy_to_clipboard">复制到剪贴板</string>
    <string name="save_to_file">保存到文件</string>
    <string name="older_connections_notice">未显示 %1$d 个较旧连接</string>
    <string name="about_text">PCAPdroid 是一款无需获取根权限便可进行网络捕获和监视的开源工具</string>
    <string name="get_app">获取应用:</string>
    <string name="unknown_app">未知</string>
    <string name="error">错误</string>
    <string name="conn_status_unreachable">不可达</string>
    <string name="other_prefs">其他</string>
    <string name="app_language">程序语言</string>
    <string name="system_default">系统默认</string>
    <string name="no_activity_file_selection">没有找到应用来处理选中的文件</string>
    <string name="socks5_proxy">启用 SOCKS5 代理</string>
    <string name="proxy_port">代理端口</string>
    <string name="root_capture">以 root 用户身份捕获流量</string>
    <string name="donate">捐赠</string>
    <string name="search">搜索…</string>
    <string name="app_val">应用: %1$s</string>
    <string name="ip_address_val">IP 地址: %1$s</string>
    <string name="host_val">主机: %1$s</string>
    <string name="protocol_val">协议: %1$s</string>
    <string name="hide">隐藏…</string>
    <string name="n_selected">选中了 %1$d </string>
    <string name="select_all">选择全部</string>
    <string name="app_details">应用详情</string>
    <string name="package_name">包名</string>
    <string name="uid">UID</string>
    <string name="app_name">名称</string>
    <string name="version">版本号</string>
    <string name="target_sdk">目标 SDK</string>
    <string name="installed_on">安装时间</string>
    <string name="last_update">上次更新</string>
    <string name="permissions">权限</string>
    <string name="root_app_info">以最高权限运行的系统守护进程</string>
    <string name="netd_app_info">执行 DNS 解析的系统守护进程</string>
    <string name="android_app_info">安卓系统</string>
    <string name="unknown_app_info">\"未知\" 标记无法确定来自什么应用的连接</string>
    <string name="packets_dropped">丢弃的数据包</string>
    <string name="capture_prefs">捕获</string>
    <string name="pending_transaction">请完成您的交易以兑换此功能</string>
    <string name="ctrl_consent">一个应用程序想要捕获你的设备流量。
\n如果你不确定，最好拒绝</string>
    <string name="deny">拒绝</string>
    <string name="allow">允许</string>
    <string name="ctrl_consent_title">PCAPdroid 控制请求</string>
    <string name="ctrl_consent_denied">PCAPdroid: 控制请求被拒绝</string>
    <string name="ctrl_consent_allowed">PCAPdroid: 控制请求被允许</string>
    <string name="capture_interface">捕获接口</string>
    <string name="internet">互联网</string>
    <string name="all_interfaces">所有接口</string>
    <string name="capturing_from">正从 \"%1$s\" 捕获数据包</string>
    <string name="edit_filter">编辑过滤器</string>
    <string name="edit_list">编辑列表</string>
    <string name="hidden_connections_rules">隐藏的连接规则</string>
    <string name="list_is_empty">列表为空</string>
    <string name="show_only_malicious">恶意连接</string>
    <string name="security">安全</string>
    <string name="malware_detection">恶意软件检测</string>
    <string name="malware_detection_summary">通过第三方黑名单检测到已知恶意主机的连接</string>
    <string name="reset">重置</string>
    <string name="malware_whitelist_rules">恶意软件白名单规则</string>
    <string name="feature_not_available">此功能目前在您的设备上不可用</string>
    <string name="billing_connecting">正在连接 Google Play，请稍候再试</string>
    <string name="malicious_connection_filter">恶意的</string>
    <string name="status_filter">HTTP 状态: %1$s</string>
    <string name="not_hidden_filter">未隐藏</string>
    <string name="copy_action">复制…</string>
    <string name="url_val">"URL：%1$s"</string>
    <string name="show_me">让我看看</string>
    <string name="hint">提示</string>
    <string name="once">一次</string>
    <string name="forever">永久</string>
    <string name="control_permissions">控制权限</string>
    <string name="control_permissions_summary">检查哪些应用被允许控制 PCAPdroid 捕获流量</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="country">国家</string>
    <string name="asn">ASN</string>
    <string name="country_val">国家： %1$s</string>
    <string name="send_report">发送报告</string>
    <string name="start_at_boot">开机启动</string>
    <string name="malware_status_ok">未检测到恶意流量</string>
    <string name="malware_status_detected">检测到恶意连接</string>
    <string name="whitelist">白名单</string>
    <string name="blacklists">黑名单</string>
    <string name="status_outdated">已过期</string>
    <string name="status_not_loaded">未加载</string>
    <string name="status_uptodate">已是最新</string>
    <string name="blacklist_type">"类型：%1$s"</string>
    <string name="blacklist_type_ip">IP 黑名单</string>
    <string name="blacklist_type_domain">域名黑名单</string>
    <string name="n_rules">%1$s 条规则</string>
    <string name="last_update_val">上次更新： %1$s</string>
    <string name="malicious_connections">恶意连接</string>
    <string name="updated_blacklists">已更新黑名单</string>
    <string name="connections_checked">已检查连接</string>
    <string name="last_blacklists_update">上次更新</string>
    <string name="domain_rules">域名规则</string>
    <string name="ip_rules">IP 规则</string>
    <string name="malware_status_update_failed">一些黑名单已过期</string>
    <string name="update_now">立即更新</string>
    <string name="status_updating">更新中…</string>
    <string name="malware_detection_learn_more">了解恶意软件检测功能的更多信息</string>
    <string name="private_dns_message_notice">私人 DNS 阻止 PCAPdroid 检查 DN S流量。你可以在 Android 网络设置中关闭它</string>
    <string name="private_dns_hinders_detection">私人 DNS 妨碍检测</string>
    <string name="block">拦截…</string>
    <string name="firewall">防火墙</string>
    <string name="firewall_rules">防火墙规则</string>
    <string name="blocked_pkts">已拦截</string>
    <string name="n_pkts">%1$s 个数据包</string>
    <string name="blocked_connection_filter">已拦截</string>
    <string name="paid_features">付费功能</string>
    <string name="validate">验证</string>
    <string name="valid">有效</string>
    <string name="invalid">无效</string>
    <string name="no_intent_handler_found">未找到执行此操作的应用</string>
    <string name="network_interface">接口</string>
    <string name="interface_filter">接口: %1$s</string>
    <string name="loading">加载中…</string>
    <string name="purchased">已购买</string>
    <string name="no_items_for_purchase">没有可供购买的项目</string>
    <string name="billing_failure">未能连接到 Google Play，请稍后再试</string>
    <string name="learn_more">了解更多</string>
    <string name="buy_action">购买</string>
    <string name="start_at_boot_summary">开机后自动开始流量捕获</string>
    <string name="capture_not_running_status">流量捕获未在运行</string>
    <string name="start_capture_first">先开始流量捕获</string>
    <string name="copied">已复制</string>
    <string name="can_use_purchased_feature">你现在可以使用购买的功能</string>
    <string name="disconnect_vpn_confirm">继续将断开与活动 VPN 的连接</string>
    <string name="loading_apps">正在加载应用…</string>
    <string name="open_nav_drawer">打开抽屉</string>
    <string name="close_nav_drawer">关闭抽屉</string>
    <string name="capture_all_apps">捕获所有应用的流量</string>
    <string name="save_ok">已保存</string>
    <string name="file_saved_with_name">已将文件另存为 \"%1$s\"</string>
    <string name="enable_socks5_proxy_summary">将所有 TCP 连接重定向到 SOCKS5 代理</string>
    <string name="root_capture_summary">允许 PCAPdroid 与其他 VPN 应用程序一起运行</string>
    <string name="malware_whitelist_help">用户自定义白名单，禁止恶意软件检测。长按“恶意连接”创建取消将它们标记为恶意软件的规则</string>
    <string name="hidden_connections_help">隐藏连接列表条目的规则列表，以便关注相关的规则</string>
    <string name="decryption_no_filter_warn">解密 TLS 时，请选择目标应用，以免失去 Internet 连接</string>
    <string name="built_on">构建于：%1$s</string>
    <string name="traffic_dump">流量转储</string>
    <string name="conn_status_active">活跃</string>
    <string name="socks5_info">SOCKS5 代理: %1$s:%2$d</string>
    <string name="phone_app_info">拨号服务</string>
    <string name="tls_decryption">TLS 解密</string>
    <string name="traffic_inspection">流量检查</string>
    <string name="mitm_start_failed">无法启动 mitm 服务。尝试手动打开 mitm 附加组件应用并重试</string>
    <string name="mitm_setup_wizard">Mitm 设置向导</string>
    <string name="install_action">安装</string>
    <string name="checking_the_certificate">检查证书…</string>
    <string name="cert_exported_now_installed">证书已导出，从 Android 系统设置安装它</string>
    <string name="cert_installed_correctly">CA 证书已安装</string>
    <string name="cert_reinstall_required">CA 证书未安装，运行 mitim 设置向导</string>
    <string name="mitm_addon_bad_version">PCAPdroid mitm 附加组件版本号不对。请安装版本 %1$s 并重试</string>
    <string name="mitm_addon_new_version">必须更新 PCAPdroid mitm 附加组件</string>
    <string name="export_failed">导出失败</string>
    <string name="not_encrypted">未加密</string>
    <string name="request">请求</string>
    <string name="response">响应</string>
    <string name="overview">概览</string>
    <string name="string_http_request">HTTP 请求</string>
    <string name="string_http_response">HTTP 响应</string>
    <string name="websocket">WebSocket</string>
    <string name="http">HTTP</string>
    <string name="payload_truncated">载荷被截断。要显示完整载荷，请停止流量捕获并从 PCAPdroid 设置开启 “%1$s”</string>
    <string name="rx_direction">接收</string>
    <string name="full_payload">完整载荷</string>
    <string name="not_decryptable">不可解密</string>
    <string name="decrypted">已解密</string>
    <string name="decryption">解密</string>
    <string name="decryption_filter">状态：%1$s</string>
    <string name="connection_start_not_seen">PCAPdroid 还没有看到这个连接开始。可能缺失某些信息</string>
    <string name="network_traffic">流量</string>
    <string name="warn_no_app_data">尚未交换应用数据</string>
    <string name="waiting_application_data">等待数据</string>
    <string name="hexdump">十六进制转储</string>
    <string name="geolocation_summary">执行离线查询显示国家和 ASN 信息</string>
    <string name="download_in_progress">正在下载，请等待</string>
    <string name="download_failed">下载失败</string>
    <string name="geo_db_not_found">未找到数据库。定位关闭</string>
    <string name="geolocation">定位</string>
    <string name="connection_blocked">此连接已被 PCAPdroid 拦截</string>
    <string name="import_action">导入</string>
    <string name="import_failed">导入失败</string>
    <string name="invalid_backup">无效的备份格式</string>
    <string name="rules_import_success">导入了 %1$d 条规则</string>
    <string name="rules_merge_msg">保留现有规则？</string>
    <string name="discard_action">放弃</string>
    <string name="rules_delete_confirm">删除选定的规则？</string>
    <string name="blocklist">拦截列表</string>
    <string name="num_configured_rules">配置规则</string>
    <string name="connections_blocked">拦截的连接</string>
    <string name="last_firewall_block">上次拦截</string>
    <string name="firewall_is_enabled">防火墙开启</string>
    <string name="firewall_is_disabled">防火墙关闭</string>
    <string name="app_info">应用信息</string>
    <string name="action_block">拦截</string>
    <string name="action_unblock">解除拦截</string>
    <string name="phone_app">手机</string>
    <string name="unblock">解锁…</string>
    <string name="tls_decryption_summary">通过执行中间人攻击解密 SSL/TLS 流量。这可能适用于一些应用程序，查看用户指南</string>
    <string name="export_action">导出</string>
    <string name="export_ca_certificate">导出 PCAPdroid CA 证书，然后打开 Android 系统“加密&amp;证书”设置，选择将它安装为“CA证书”</string>
    <string name="install_ca_certificate">安装 PCAPdroid CA 证书，选择“VPN 和应用”。Android 系统会要求你输入锁屏或密码</string>
    <string name="payload">载荷</string>
    <string name="download">下载</string>
    <string name="full_payload_summary">显示完整的连接载荷 （例如完整的 HTTP 请求和响应）。这需要大量的内存，不要长时间使用</string>
    <string name="downloading">下载中…</string>
    <string name="database">数据库</string>
    <string name="geo_db_download">轻按下载最新数据库。每月有新数据库可用</string>
    <string name="tx_direction">发送</string>
    <string name="size_x">大小：%1$s</string>
    <string name="geo_db_delete">轻按删除数据库并节省空间</string>
    <string name="no_rules_to_export">无规则可导出</string>
    <string name="keep_action">保留</string>
    <string name="app_intro_traffic_inspection">由于内置的解码器，检查 HTTP 请求、响应和原始数据很容易
\n
\n加密连接怎么办？你可以启用<a href="%1$s">TLS 解密</a>获得解密的数据</string>
    <string name="app_intro_firewall_msg">借助集成的<a href="%1$s">防火墙</a>，你可轻松阻止单个应用联网，以及对域名和国家/地区的互联网访问\n \n将此与内置的流量可见性相结合，以获得保护你隐私的终极工具</string>
    <string name="app_intro_malware_detection">借助 <a href="%1$s">恶意软件检测</a>功能增强你设备的安全性
\n
\n通过使用最新的黑名单，它可以实时检测、阻止和警告恶意连接</string>
    <string name="app_intro_traffic_dump">PCAPdroid 提供<a href="%1$s">多种方式</a>以标准的 PCAP 格式转储流量，以便深入分析 \n \n通过 <a href="%2$s"> PCAPdroid 扩展选项</a>，可以向数据包添加应用名称，并在 Wireshark 中显示它们</string>
    <string name="app_intro_welcome_msg">PCAPdroid 是一款隐私友好的应用，允许你追踪并分析你设备中应用所作的连接
\n
\n此外，它允许你导出流量的 PCAP 转储，提取元数据及其他更多功能！</string>
    <string name="privacy_first">隐私优先</string>
    <string name="app_intro_privacy_msg">本应用没有使用任何跟踪、分析，也不会进行与流量分析无关的网络连接
\n
\n如何确定所言非虚？您可检视其 <a href="%1$s">隐私政策</a>和<a href="%2$s">源代码</a></string>
    <string name="country_and_asn">国家和 ASN</string>
    <string name="app_intro_geolocation_msg">PCAPdroid 可查询本地数据库确定远程服务器所在国家或地区
\n
\n你必须先从应用设置下载地理位置数据库</string>
    <string name="vpn_setup_msg">PCAPdroid 模拟 VPN，以便在没有获取根权限的情况下捕获网络流量。
\n
\n要开始捕获流量，你需要在下一个屏幕中接受 VPN 请求。
\n
\n<b>注：</b>要继续下一步，请在 Android 设置中禁用“始终启用 VPN”</string>
    <string name="netd_block_missed">此连接由 netd 发起，因此无法被拦截</string>
    <string name="firewall_summary">阻断应用联网，配置特定域和 IP 地址规则。仅适用于非 root 捕获</string>
    <string name="block_private_dns_summary">检测并可能阻止私人 DNS 来检查 DNS 流量。禁用此选项会妨碍流量分析</string>
    <string name="app_intro_next_button">下一步</string>
    <string name="app_intro_done_button">完毕</string>
    <string name="ca_cert_export_failed">导出 CA 证书时出错
\n
\n如果你的设备部署了 Autostart 或类似软件来限制后台服务执行，请确保将 <a href="%1$s">PCAPdroid 加入白名单</a></string>
    <string name="block_quick">拦截 QUIC</string>
    <string name="block_private_dns">拦截私人 DNS</string>
    <string name="no_root_firewall">非 root 防火墙</string>
    <string name="mitm_setup_wizard_intro">该向导将指导你安装 PCAPdroid mitm 附加组件和证书颁发机构。需要这两样东西才能执行 <a href="%1$s">TLS 解密</a></string>
    <string name="welcome_to_pcapdroid">欢迎来到 PCAPdroid</string>
    <string name="mitm_setup_wizard_done">PCAPDroid 已准备好解密 TLS 流量
\n
\n查看 <a href="%1$s">用户指南</a>了解更多可能防止解密的安全措施，以及如何绕过这些措施</string>
    <string name="app_intro_skip_button">跳过</string>
    <string name="app_intro_back_button">返回</string>
    <string name="permission_granted">已授予 %1$s 权限</string>
    <string name="permission_grant_fail">无法授予 %1$s 权限</string>
    <string name="memory_usage">内存用量</string>
    <string name="capture_stopped_low_memory">流量捕获已停止</string>
    <string name="low_memory_info">应用程序内存不足，预计会崩溃</string>
    <string name="allowed_connection_filter">已允许</string>
    <string name="firewall_filter">防火墙：%1$s</string>
    <string name="connection_not_found">找不到给定的连接</string>
    <string name="low_memory">内存不足</string>
    <string name="full_payload_disabled">完整载荷选项已被禁用</string>
    <string name="heap_usage">堆使用</string>
    <string name="vpn_lockdown_notice">为了防止应用在 PCAPdroid 未运行时（例如重启后）访问互联网，你可以将 PCAPdroid 设为锁定模式下“永远开启的VPN”。
\n
\n你现在要打开 VPN 设置吗？</string>
    <string name="ip_mode">VPN IP 地址</string>
    <string name="ipv4_only">仅 IPv4</string>
    <string name="ipv6_only">仅 IPv6</string>
    <string name="ip_both">IPv4 和 IPv6</string>
    <string name="vpn_exemptions">VPN 排除</string>
    <string name="vpn_exemptions_summary">将某些应用程序排除在 VPN 连接外。 它们的流量不会被监控</string>
    <string name="no_matches_found">无匹配</string>
    <string name="cleartext_connection">明文</string>
    <string name="unblock_permanently">永久解除拦截</string>
    <string name="unblock_for_n_hours">解除拦截 %1$d 小时</string>
    <string name="block_new_apps">拦截新安装的应用</string>
    <string name="app_blocked_info">防火墙拦截了 %1$s 应用</string>
    <string name="app_blocked">应用被拦截</string>
    <string name="show_only_cleartext">明文连接</string>
    <string name="notifications_notice">该应用程序使用通知在发生异常事件时发送警报。 在下一个屏幕授予它发送通知的权限</string>
    <string name="remote_server_warning">出于安全原因，不允许将流量发送到远程服务器“%1$s”</string>
    <string name="payload_scams_notice">这个视图可能包含敏感信息，比如密码和访问令牌。
\n
\n千万不要把这个信息透露给任何人，这可能是一个骗局</string>
    <string name="cancel_action">取消</string>
    <string name="show_data_action">显示数据</string>
    <string name="remote_collector_notice">你已经将 PCAPdroid 配置为将流量发送到远程服务器。该服务器将能够访问你的敏感信息。
\n
\n如果有人让你这样做，这可能是一个骗局</string>
    <string name="warning">警告</string>
    <string name="app_unblocked">已解除对 %1$s 应用的封锁</string>
    <string name="build_info">构建信息</string>
    <string name="paid_features_unlocked">付费功能已解锁。 如果正在运行，请重启流量捕获</string>
    <string name="unblock_for_n_minutes">解封 %1$d 分钟</string>
    <string name="install_the_mitm_addon">安装 PCAPdroid <a href="%1$s">mitm 附加组件</a></string>
    <string name="tls_decryption_with_root_msg">使用 root 权限运行 TLS 解密是一项实验性功能。 这是已知错误的列表：: \n \n - 在 PCAPdroid 中，流量看起来像是从 mitm-addon 应用生成的，而不是原始应用程\n - 不支持转储 SSL keylog\n - 设置应用过滤器后，只会对目标应用进行解密，但 PCAPdroid 仍会显示其他应用的流量 \n - 如果流量捕获无法启动，请确保你实际上可以以 root 身份运行 iptables 命令（例如，通过 termux） \n - 此功能可能不适用于 Android 12 及更高版本 \n - 如果 VPN 应用正在运行，你应该针对特定应用进行解密或从 VPN 中排除 PCAPdroid mitm 附加组件，否则流量将进入循环</string>
    <string name="unlock_token_summary">可用于解锁非 Google-Play 应用版本（例如 F-Droid/Github）中付费功能的令牌</string>
    <string name="unlock_token_error">无法请求解锁令牌 [%1$d]: %2$s</string>
    <string name="access_paid_features_msg">查看 <a href="%1$s">用户指南</a>了解如何访问付费功能</string>
    <string name="license_service_unavailable">PCAPdroid 许可服务目前不可用。 请在几分钟后重试</string>
    <string name="requesting_unlock_token">请求解锁令牌中，请稍候</string>
    <string name="show_action">显示</string>
    <string name="unlock_token_msg1">这是您的解锁令牌。 请记下它，因为你需要它<a href="%1$s">生成许可证代码</a></string>
    <string name="paid_feature">付费功能</string>
    <string name="firewall_purchase_msg">购买 <i>%1$s</i> 功能开始拦截连接</string>
    <string name="mitm_skip_notice">似乎未安装 mitm 证书。如果继续，解密会失败</string>
    <string name="mitm_wizard_description">配置设备以进行 TLS 解密</string>
    <string name="port_mapping">端口映射</string>
    <string name="required">必需的</string>
    <string name="items_delete_confirm">删除所选项目吗？</string>
    <string name="ip_address">IP 地址</string>
    <string name="rule_exists">已定义了规则</string>
    <string name="dns_servers_summary">配置流量捕获期间要使用的 DNS 服务器</string>
    <string name="many_rules_warning">你正试图导入许多规则，可能使应用程序在某些交互期间无响应。你真想继续吗？</string>
    <string name="pcapng_format_summary">用 Pcapng 格式转储数据包，该格式更为灵活，允许内嵌 TLS 解密 secrets</string>
    <string name="use_system_dns_summary">如果可能，使用系统 DNS 服务器</string>
    <string name="port_mapping_summary">配置将连接重定向到不同主机或端口的端口映射规则</string>
    <string name="app_log">日志</string>
    <string name="no_data">无数据</string>
    <string name="mitm_addon">mitm 附加组件</string>
    <string name="malware_whitelist_action">白名单（恶意软件）…</string>
    <string name="mitmproxy_opts">附加 mitmproxy 选项</string>
    <string name="original_port">原始端口</string>
    <string name="mitmproxy_opts_description">提供附加的 mitmproxy 选项</string>
    <string name="mitm_addon_error">启动 mitm 附加组件时出错。详情请检查日志</string>
    <string name="whitelist_mode">白名单模式</string>
    <string name="firewall_whitelist_notice">此模式下，除了手动加入白名单的项目，所有连接都将被拦截。没有恰当的白名单，你可能会丢失推送通知</string>
    <string name="firewall_whitelist_help">这些规则指定要允许哪些连接。拦截列表规则的优先级高于白名单规则</string>
    <string name="add_to_fw_whitelist">添加到防火墙白名单</string>
    <string name="remove_from_fw_whitelist">从防火墙白名单中删除</string>
    <string name="add_action">添加</string>
    <string name="redirect_to">重定向到：</string>
    <string name="destination_port">目标端口</string>
    <string name="reset_stats_confirm">你真想重置这些统计数据吗？</string>
    <string name="port_mapping_exists">已定义端口映射</string>
    <string name="ipv6_dns_server">IPv6 DNS 服务器</string>
    <string name="pcapng_format">PCAPNG 格式</string>
    <string name="dns_servers">DNS 服务器</string>
    <string name="ipv4_dns_server">IPv4 DNS 服务器</string>
    <string name="use_system_dns">使用系统 DNS</string>
    <string name="external_storage_perm_required">外部存储权限是必需的</string>
    <string name="total_bytes">总字节数</string>
    <string name="sort_by">排序方式</string>
    <string name="write_ext_storage_failed">未能写入外部存储。详情见应用日志</string>
    <string name="socks5_redirection">SOCKS5 重定向</string>
    <string name="socks5_summary">配置到 SOCKS5 代理的重定向</string>
    <string name="socks5_auth">SOCKS5 身份验证</string>
    <string name="socks5_auth_summary">通过用户名和密码进行代理身份验证</string>
    <string name="username">用户名</string>
    <string name="password">密码</string>
    <string name="mitm_addon_autostart_workaround">未能连接到 mitm 附加组件。一个临时解决方法是你可以尝试打开 mitm 附加组件应用，然后在不关闭它的情况下回到 PCAPdroid。你想立即打开它吗？</string>
    <string name="qr_license_confirm">你想用下列解锁令牌为 “%1$s”设备生成许可证吗？</string>
    <string name="invalid_license">无效许可证</string>
    <string name="connection_error">连接错误：%1$s</string>
    <string name="activate_via_qr_code">通过二维码激活</string>
    <string name="qr_code_expired">二维码过期了。生成新的二维码并重试</string>
    <string name="qr_info_text">从 Google Play 安装 PCAPdroid 并扫描这个二维码</string>
    <string name="qr_purchase_required">要继续通过二维码激活请先购买解锁令牌</string>
    <string name="license_limit_reached">你已经达到了这枚解锁令牌的许可证上限。请购买新令牌来生成更多许可证</string>
    <string name="license_error">许可证生成错误 [%1$d]: %2$s</string>
    <string name="requesting_license">正在请求许可代码，请稍等</string>
    <string name="license_activation_ok">已完成许可证激活</string>
    <string name="decrypt_action">解密…</string>
    <string name="decryption_rules_help">这些规则指定解密哪些连接。存在先前的 DNS 响应是基于 Host 的规则生效的前提</string>
    <string name="injected">已注入</string>
    <string name="decryption_rules">解密规则</string>
    <string name="mitm_addon_starting">Mitm 附加组件启动中…</string>
    <string name="mitm_addon_running">Mitim 附加组件运行中</string>
    <string name="dont_decrypt_action">不解密…</string>
    <string name="status_encrypted">已加密</string>
    <string name="pcap_load_in_progress">正在加载捕获的文件，请等待</string>
    <string name="capture_interface_open_error">无法打开流量捕获界面</string>
    <string name="unsupported_pcap_datalink">文件有一个不受支持的数据链</string>
    <string name="pcap_file_not_exists">指定的文件不存在</string>
    <string name="root_capture_start_failed">流量捕获启动失败。请确保设备已使用 Magisk 获取根权限</string>
    <string name="pcap_read_error">读取捕获文件时出错，详情请查看日志</string>
    <string name="pcap_file_load_aborted">捕获文件加载中断</string>
    <string name="copy_error">无法写入文件</string>
    <string name="proxy_host">代理主机</string>
    <string name="open_pcap_file">打开 PCAP/Pcapng 文件…</string>
    <string name="pcap_load_success">已加载捕获的文件</string>
    <string name="host_resolution_failed">无法解析主机 %1$s</string>
    <string name="invalid_pcap_file">无效的捕获文件格式</string>
    <string name="pcapdroid_trailer_notice">要显示实际应用而非“%1$s”，请在生成转储文件前确保开启了“%2$s”选项</string>
    <string name="tls_decryption_no_rules_notice">TLS 解密仅应用于匹配所配置规则的连接。你想立即创建解密规则吗？</string>
    <string name="decryption_info_no_rule">要解密此连接，从左侧抽屉或从连接列表的上下文菜单创建一条解密规则</string>
    <string name="active_vpn_detected">检测到活动 VPN</string>
    <string name="root_capture_pcapd_start_failure">流量捕获启动失败。请确保你授予了 PCAPdroid 根权限</string>
    <string name="whats_new">更新记录</string>
    <string name="mitm_doze_notice">电池优化可能干扰 mitim 附加组件的运作</string>
    <string name="redirected">已重定向</string>
    <string name="connection_redirected_port_map">由于端口映射规则，此连接已被重定向</string>
    <string name="dnscrypt_how_to">如何在 PCAPDroid 中使用 DoH / DNSCrypt</string>
    <string name="never">从不</string>
    <string name="always">始终</string>
    <string name="for_connections_to_decrypt">只对要解密的连接使用</string>
    <string name="target_apps_help">选择要捕获流量的应用</string>
    <string name="decrypt_quic_notice">当前不支持解密 QUIC 连接。作为临时解决方案，停止流量捕获并在 PCAPdroid 设置中选择拦截 QUIC 连接的选项</string>
    <string name="target_apps">目标应用</string>
    <string name="headers">标头</string>
    <string name="body">正文</string>
    <string name="both">两者</string>
    <string name="export_ellipsis">导出…</string>
    <string name="raw_bytes">原始字节</string>
    <string name="restart_on_disconnection">连接断开时重启</string>
    <string name="restart_on_disconnection_summary">在流量捕获被其他 VPN 应用停止后自动重启</string>
    <string name="vpn_reconnection">VPN 重连</string>
    <string name="vpn_reconnection_aborted">VPN 重连被终止</string>
    <string name="waiting_for_vpn_disconnect">等待活跃 VPN 断开…</string>
    <string name="update_action">更新</string>
    <string name="update_available">有更新可用</string>
    <string name="mitm_addon_update_available">有新的 mitim 附加组件更新可用。请更新获得最新的 bug 修复</string>
    <string name="dump_extensions_summary">扩展的数据包转出格式，包含额外的元数据，比如发送/接收了一个给定数据包的应用</string>
    <string name="errno_econnreset_msg">服务器突然关闭了连接，通常由于崩溃或笨拙的关闭</string>
    <string name="cidr_val">CIDR： %1$s</string>
    <string name="errno_enetunreach_msg">系统无法找到前往目标网络的有效路由</string>
    <string name="malicious_connections_notice">黑名单可能包含误报。请在网上仔细检查 IP 地址/域名的信誉。你可以通过恶意软件白名单排除误报</string>
    <string name="errno_econnaborted_msg">连接被终止，通过是由于网络转换</string>
    <string name="keylog_read_error">SSL 密钥记录读取出错</string>
    <string name="bytes_threshold">字节数临界值</string>
    <string name="select_the_pcap_file">选择 PCAP/Pcapng 文件</string>
    <string name="select_the_keylog_file">选择 SSL 密钥记录文件</string>
    <string name="error_code_with_text">%1$s （错误 %2$d）</string>
    <string name="errno_epipe">管道损坏</string>
    <string name="errno_epipe_msg">服务器在数据传输期间意外地关闭了连接</string>
    <string name="errno_enetdown">网络不通</string>
    <string name="errno_enetdown_msg">网络接口不通或无法连接到网络</string>
    <string name="errno_enetunreach">网络无法访问</string>
    <string name="errno_enetreset">网络重置</string>
    <string name="errno_enetreset_msg">网络连接被中间设备重置（如路由器或手机运营商）</string>
    <string name="errno_econnaborted">连接被终止</string>
    <string name="errno_econnreset">连接被 peer 重置</string>
    <string name="errno_etimedout">连接超时</string>
    <string name="errno_etimedout_msg">服务器响应时间过长，可能由于网络延迟或服务器忙</string>
    <string name="errno_econnrefused">连接被拒绝</string>
    <string name="errno_econnrefused_msg">服务器拒绝了连接，可能表示服务器太忙或出了问题</string>
    <string name="errno_ehostunreach">没有到主机的路由</string>
    <string name="errno_ehostunreach_msg">系统无法找到前往目标主机的路由</string>
    <string name="dns_conn_info">DNS 将域名翻译成 IP 地址。实际数据通常经由后续的 HTTPS/TLS 连接进行交换</string>
    <string name="tls_conn_info">TLS/HTTPS 流量是加密的。要检查这样的流量，你需要进行解密。 详情见 PCAPdroid <a href="%1$s">用户指南</a></string>
    <string name="dump_extensions">PCAPdroid 扩展</string>
    <string name="dump_extensions_how_to">如何在 Wireshark 中展示 PCAPdroid 转储扩展</string>
    <string name="malicious_connection_description">来自 \"%1$s\" 应用的连接触发了恶意软件检测规则（%2$s）</string>
    <string name="geo_db_missing">缺少地理位置数据库</string>
    <string name="country_rules_warning">要使用基于地理位置的防火墙规则，请从 PCAPdroid 设置下载地理位置数据库，不然规则无效</string>
    <string name="ip_address_or_cidr">IP 地址 / CIDR</string>
    <string name="unsupported_pcap_file">不受支持的捕获文件格式</string>
    <string name="decrypt_pcap_file">解密 PCAP/Pcapng 文件…</string>
    <string name="generate_api_key">生成 API 密钥</string>
    <string name="show_api_key">显示 API 密钥</string>
    <string name="api_key">API 密钥</string>
    <string name="api_key_discard_confirm">你真要丢弃当前 API 密钥并生成新的 API 密钥吗？</string>
    <string name="no_permissions_set_info">未设置权限。通过 StartActivityForResult 调用 PCAPdroid 来显示权限提示</string>
    <string name="tls_decryption_not_supported_16KB">目前不支持在 16 KB 设备上解密 TLS</string>
    <string name="filename_prefix">文件名前缀</string>
    <string name="filename_prefix_description">设置 PCAPdroid 导出的文件的前缀，比如 PCAP files</string>
    <string name="select">选择</string>
    <string name="content_type">内容类型</string>
    <string name="http_status">HTTP 状态</string>
    <string name="payload_size_threshold">载荷大小阈值</string>
    <string name="method_filter">方式：%1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="text">文本</string>
    <string name="display_as_text">以文本形式显示</string>
    <string name="display_as_hexdump">以 hexdump 形式显示</string>
    <string name="exporting">导出中…</string>
    <string name="export_in_progress">正在导出，请等待</string>
    <string name="show_connection">显示连接</string>
    <string name="show_system_apps">显示系统应用</string>
    <string name="destination_host">目标主机</string>
    <string name="no_requests">无请求</string>
    <string name="item_not_found">找不到指定项目</string>
    <string name="connection_number">连接 #%1$d</string>
    <string name="http_request_number">HTTP 请求 #%1$d</string>
    <string name="http_requests">HTTP 请求</string>
    <string name="switch_to_http">显示 HTTP 请求</string>
    <string name="switch_to_connections">显示连接</string>
    <string name="decryption_error">解密错误</string>
    <string name="previous">上一个</string>
    <string name="next">下一个</string>
    <string name="save_as_text">保存为文本</string>
    <string name="save_as_har">保存为 HAR</string>
    <string name="request_method">请求方式</string>
</resources>

```

`app/src/main/res/values/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="pcap_dump_modes">
        <item>none</item>
        <item>http_server</item>
        <item>pcap_file</item>
        <item>udp_exporter</item>
        <item>tcp_exporter</item>
    </string-array>
    <string-array name="pcap_dump_modes_labels">
        <item>@string/no_dump</item>
        <item>@string/http_server</item>
        <item>@string/pcap_file</item>
        <item>@string/udp_exporter</item>
        <item>@string/tcp_exporter</item>
    </string-array>
    <string-array name="pcap_dump_modes_descriptions">
        <item>@string/no_dump_info</item>
        <item>@string/http_server_info</item>
        <item>@string/pcap_file_info</item>
        <item>@string/udp_exporter_info</item>
        <item>@string/tcp_exporter_info</item>
    </string-array>

    <string-array name="ip_mode">
        <item>ipv4</item>
        <item>ipv6</item>
        <item>both</item>
    </string-array>
    <string-array name="ip_mode_labels">
        <item>@string/ipv4_only</item>
        <item>@string/ipv6_only</item>
        <item>@string/ip_both</item>
    </string-array>

    <string-array name="block_quic">
        <item>never</item>
        <item>always</item>
        <item>to_decrypt</item>
    </string-array>
    <string-array name="block_quic_labels">
        <item>@string/never</item>
        <item>@string/always</item>
        <item>@string/for_connections_to_decrypt</item>
    </string-array>
</resources>

```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorTab">#7A5EBC</color>
    <color name="colorTabText">@android:color/tertiary_text_light</color>
    <color name="colorTabTextSelected">@android:color/secondary_text_light</color>
    <color name="colorPrimary">#4527a0</color>
    <color name="colorPrimaryDark">#4D3294</color>
    <color name="colorActionBar">#4527a0</color>
    <color name="colorAccent">#D81B60</color>
    <color name="colorAccentLight">#D8ADBD</color>
    <color name="colorBackgroundGray">#2C000000</color>
    <color name="navViewBackground">@color/design_default_color_surface</color>
    <color name="backgroundColor">@color/background_material_light</color>
    <color name="drawerItemColor">#404040</color>
    <color name="statusOpen">#28BC36</color>
    <color name="statusClosed">#AAAAAA</color>
    <color name="statusError">#F20015</color>
    <color name="ok">#0CB350</color>
    <color name="warning">#FF9800</color>
    <color name="danger">#F80013</color>
    <color name="in_progress">#29b6f6</color>
    <color name="highContrast">#000000</color>
    <color name="sentPayloadBg">#FBEDED</color>
    <color name="sentPayloadFg">#7F0000</color>
    <color name="rcvdPayloadBg">#EDEDFB</color>
    <color name="rcvdPayloadFg">#00007F</color>
    <color name="lightGray">#aaa</color>
</resources>

```

`app/src/main/res/values/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="drawer_header_height">170dp</dimen>
</resources>

```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="pcapdroid_app_name" translatable="false">PCAPdroid</string>
    <string name="default_collector_ip" translatable="false">127.0.0.1</string>
    <string name="default_collector_port" translatable="false">1234</string>
    <string name="ip_and_port" translatable="false">%1$s:%2$d</string>
    <string name="ipv6_and_port" translatable="false">[%1$s]:%2$d</string>
    <string name="app_and_proto" translatable="false">%1$s (%2$s)</string>
    <string name="sni" translatable="false">SNI</string>
    <string name="url" translatable="false">URL</string>
    <string name="whois_lookup" translatable="false">WHOIS</string>
    <string name="installation_id" translatable="false">Installation ID</string>
    <string name="license_code" translatable="false">License code</string>
    <string name="root" translatable="false">root</string>
    <string name="app_license" translatable="false">PCAPdroid is distributed in the hope that it will be useful, but WITHOUT
        ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        See the <a href='https://www.gnu.org/licenses/gpl-3.0-standalone.html'>GNU General Public License or later</a> for
        more details</string>
    <string name="opensource_licenses" translatable="false"><b>Open Source Licenses:</b><br />\n\n
        - zdtun: <a href='https://github.com/emanuele-f/zdtun/blob/master/COPYING'>LGPL-3.0</a>\n\n
        - nDPI: <a href='https://github.com/ntop/nDPI/blob/dev/COPYING'>LGPL-3.0</a>\n\n
        - CustomActivityOnCrash: <a href='https://github.com/Ereza/CustomActivityOnCrash/blob/master/LICENSE'>Apache-2.0</a>\n\n
        - Gson: <a href='https://github.com/google/gson/blob/master/LICENSE'>Apache-2.0</a>\n\n
        - Brotli decoder: <a href='https://github.com/google/brotli/blob/master/LICENSE'>MIT</a>\n\n
        - zstd: <a href='https://github.com/facebook/zstd/blob/dev/COPYING'>GPL-2.0</a>\n\n
        - mitmproxy: <a href='https://github.com/mitmproxy/mitmproxy/blob/main/LICENSE'>MIT</a>\n\n
        - Chaquopy: <a href='https://github.com/chaquo/chaquopy/blob/master/LICENSE.txt'>MIT</a>\n\n
        - MaxMind DB Reader: <a href='https://github.com/maxmind/MaxMind-DB-Reader-java/blob/main/LICENSE'>Apache-2.0</a>\n\n
        - FlagKit: <a href='https://github.com/madebybowtie/FlagKit/blob/master/LICENSE'>MIT</a>\n\n
        - IP Geolocation by <a href='https://db-ip.com'>DB-IP</a>\n\n
        - AppIntro: <a href='https://github.com/AppIntro/AppIntro/blob/main/LICENSE'>Apache-2.0</a>\n\n
        - QrGenerator: <a href='https://github.com/androidmads/QRGenerator/blob/master/LICENSE.md'>MIT</a>\n\n
        - Sparsehash: <a href='https://github.com/sparsehash/sparsehash/blob/master/COPYING'>BSD-3-Clause</a>\n\n
        - CIDRUtils: <a href='https://github.com/edazdarevic/CIDRUtils'>MIT</a>\n\n
        - Font Awesome: <a href='https://fontawesome.com/license/free'>Licenses</a>\n\n
        - App icon by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">flaticon</a>\n\n
        - SourceCodePro font: <a href='https://github.com/adobe-fonts/source-code-pro/blob/release/LICENSE.md'>OFL-1.1</a>\n\n
        </string>
    <string name="wireshark_licenses" translatable="false"><b>PCAP Decryption:</b><br />\n\n
        - Wireshark: <a href='hhttps://github.com/wireshark/wireshark/blob/master/COPYING'>GPL-2.0</a>\n\n
        - ushark: <a href='https://github.com/altafinance/ushark'>GPL-2.0</a>\n\n
        - libiconv: <a href='https://www.gnu.org/software/libiconv'>LGPL-2.1</a>\n\n
        - glib: <a href='https://gitlab.gnome.org/GNOME/glib/-/blob/main/COPYING'>LGPL-2.1</a>\n\n
        - gpgerror: <a href='https://github.com/gpg/libgpg-error/blob/master/COPYING'>LGPL-2.1</a>\n\n
        - gcrypt: <a href='https://gnupg.org/software/libgcrypt/index.html'>LGPL-2.1</a>\n\n
        - nghttp2: <a href='https://github.com/nghttp2/nghttp2/blob/master/COPYING'>MIT</a>\n\n
        </string>
    <string name="connections_csv_fields" translatable="false">IPProto,SrcIP,SrcPort,DstIp,DstPort,UID,App,PackageName,Proto,Status,Info,BytesSent,BytesRcvd,PktsSent,PktsRcvd,FirstSeen,LastSeen</string>
    <string name="unlock_token" translatable="false">Unlock token</string>
    <string name="method_get" translatable="false">GET</string>
    <string name="method_post" translatable="false">POST</string>

    <!-- Localized -->
    <string name="start_button">Start</string>
    <string name="stop_button">Stop</string>
    <string name="title_activity_settings">Settings</string>
    <string name="collector_info">UDP collector: %1$s:%2$d</string>
    <string name="tcp_collector_info">TCP collector: %1$s:%2$d</string>
    <string name="http_server_status">HTTP server: http://%1$s:%2$d</string>
    <string name="rcvd_and_sent">%1$s received — %2$s sent</string>
    <string name="query">Query</string>
    <string name="host">Host</string>
    <string name="ready">Ready</string>
    <string name="about">About</string>
    <string name="status">Status</string>
    <string name="connections_view">Connections</string>
    <string name="no_connections">No connections</string>
    <string name="connection_details">Connection details</string>
    <string name="app">App</string>
    <string name="protocol">Protocol</string>
    <string name="source">Source</string>
    <string name="destination">Destination</string>
    <string name="packets">Packets</string>
    <string name="duration">Duration</string>
    <string name="http_server">HTTP server</string>
    <string name="udp_exporter">UDP exporter</string>
    <string name="tcp_exporter">TCP exporter</string>
    <string name="tcp_udp_exporter">TCP/UDP exporter</string>
    <string name="no_dump">No dump</string>
    <string name="no_dump_info">Traffic will not be dumped</string>
    <string name="http_server_info">Start an HTTP server for the PCAP download</string>
    <string name="udp_exporter_info">Send the PCAP to a remote UDP receiver</string>
    <string name="tcp_exporter_info">Send the PCAP to a remote TCP receiver (pcap-over-ip)</string>
    <string name="http_server_port">HTTP server port</string>
    <string name="receiver_ip_address">Collector IP address</string>
    <string name="receiver_port">Collector port</string>
    <string name="traffic_dump">Traffic dump</string>
    <string name="user_guide">User guide</string>
    <string name="open_telegram_group">Telegram group</string>
    <string name="source_code">Source code</string>
    <string name="yes">Yes</string>
    <string name="no">No</string>
    <string name="vpn_setup_failed">Could not set up the VPN. Ensure that Always-on VPN is disabled</string>
    <string name="app_not_found">Could not find the "%1$s" app</string>
    <string name="stats">Stats</string>
    <string name="active_connections">Active connections</string>
    <string name="dropped_connections">Dropped connections</string>
    <string name="tot_connections">Total connections</string>
    <string name="open_sockets">Open sockets</string>
    <string name="bytes_sent">Bytes sent</string>
    <string name="bytes_rcvd">Bytes received</string>
    <string name="ipv6_bytes_sent">IPv6 bytes sent</string>
    <string name="ipv6_bytes_rcvd">IPv6 bytes received</string>
    <string name="ipv6_bytes_percentage">IPv6 bytes percentage</string>
    <string name="packets_sent">Packets sent</string>
    <string name="packets_rcvd">Packets received</string>
    <string name="dns_queries">DNS queries</string>
    <string name="search_apps">Search apps</string>
    <string name="no_apps">No apps</string>
    <string name="dns_server">DNS server</string>
    <string name="apps">Apps</string>
    <string name="pcap_file">PCAP file</string>
    <string name="pcap_file_info">Create a PCAP/Pcapng file in the device storage</string>
    <string name="cannot_write_file">Cannot write file</string>
    <string name="share">Share</string>
    <string name="delete">Delete</string>
    <string name="ok">OK</string>
    <string name="pcap_file_action">Traffic saved to the \"%1$s\" file (%2$s)</string>
    <string name="delete_error">Could not delete the file</string>
    <string name="copy_error">Could not write the file</string>
    <string name="capture_running">Capture running</string>
    <string name="notification_msg">%1$s captured, %2$s connections</string>
    <string name="proto_and_port">%1$s, %2$d</string>
    <string name="conn_status_active">Active</string>
    <string name="first_seen">First seen</string>
    <string name="last_seen">Last seen</string>
    <string name="conn_status_closed">Closed</string>
    <string name="copy_to_clipboard">Copy</string>
    <string name="save_to_file">Save to file</string>
    <string name="older_connections_notice">%1$d older connections not shown</string>
    <string name="about_text">PCAPdroid is an open source network capture and monitoring tool which works without root privileges</string>
    <string name="get_app">Get it:</string>
    <string name="unknown_app">Unknown</string>
    <string name="phone_app">Phone</string>
    <string name="error">Error</string>
    <string name="conn_status_unreachable">Unreachable</string>
    <string name="other_prefs">Other</string>
    <string name="app_language">App language</string>
    <string name="system_default">System default</string>
    <string name="no_activity_file_selection">No app found to handle file selection</string>
    <string name="file_saved_with_name">File saved as \"%1$s\"</string>
    <string name="socks5_proxy">SOCKS5</string>
    <string name="socks5_redirection">SOCKS5 redirection</string>
    <string name="socks5_summary">Configure the redirection to a SOCKS5 proxy</string>
    <string name="enable_socks5_proxy_summary">Redirect all the TCP connections to a SOCKS5 proxy</string>
    <string name="socks5_info">SOCKS5 proxy: %1$s:%2$d</string>
    <string name="socks5_auth">SOCKS5 authentication</string>
    <string name="socks5_auth_summary">Authenticate to the proxy via username and password</string>
    <string name="proxy_host">Proxy host</string>
    <string name="proxy_port">Proxy port</string>
    <string name="root_capture">Capture as root</string>
    <string name="root_capture_summary">Allows PCAPdroid to run with other VPN apps</string>
    <string name="donate">Donate</string>
    <string name="app_log">Log</string>
    <string name="no_data">No data</string>
    <string name="search">Search…</string>
    <string name="app_val">App: %1$s</string>
    <string name="ip_address_val">IP address: %1$s</string>
    <string name="cidr_val">CIDR: %1$s</string>
    <string name="host_val">Host: %1$s</string>
    <string name="protocol_val">Protocol: %1$s</string>
    <string name="malware_whitelist_action">Whitelist (malware)…</string>
    <string name="hide">Hide…</string>
    <string name="select">Select</string>
    <string name="n_selected">%1$d selected</string>
    <string name="select_all">Select all</string>
    <string name="app_details">App details</string>
    <string name="package_name">Package name</string>
    <string name="uid">UID</string>
    <string name="app_name">Name</string>
    <string name="version">Version</string>
    <string name="target_sdk">Target SDK</string>
    <string name="installed_on">Installed on</string>
    <string name="last_update">Last update</string>
    <string name="permissions">Permissions</string>
    <string name="root_app_info">System daemons running with maximum privileges</string>
    <string name="netd_app_info">The system daemon performing the DNS resolutions</string>
    <string name="android_app_info">The Android system</string>
    <string name="phone_app_info">Telephony services</string>
    <string name="unknown_app_info">\"Unknown\" marks connections whose app could not be determined</string>
    <string name="packets_dropped">Packets dropped</string>
    <string name="capture_prefs">Capture</string>
    <string name="dump_extensions">PCAPdroid extensions</string>
    <string name="dump_extensions_summary">Extend the packet dump format with additional metadata, such as the app which sent/received a given packet</string>
    <string name="dump_extensions_how_to">How to display the PCAPdroid dump extensions in Wireshark</string>
    <string name="pending_transaction">Please complete your transaction to redeem this feature</string>
    <string name="ctrl_consent">An app wants to capture your device traffic.\nDeny it if you are not sure</string>
    <string name="deny">Deny</string>
    <string name="allow">Allow</string>
    <string name="ctrl_consent_title">PCAPdroid control request</string>
    <string name="ctrl_consent_denied">PCAPdroid: the control request was denied</string>
    <string name="ctrl_consent_allowed">PCAPdroid: the control request was allowed</string>
    <string name="capture_interface">Capture interface</string>
    <string name="internet">Internet</string>
    <string name="all_interfaces">All interfaces</string>
    <string name="capturing_from">Capturing packets from \"%1$s\"</string>
    <string name="edit_filter">Edit filter</string>
    <string name="edit_list">Edit list</string>
    <string name="hidden_connections_rules">Hidden connections rules</string>
    <string name="list_is_empty">The list is empty</string>
    <string name="show_only_malicious">Malicious connections</string>
    <string name="show_only_cleartext">Cleartext connections</string>
    <string name="security">Security</string>
    <string name="malware_detection">Malware detection</string>
    <string name="malware_detection_summary">Detect connections to known malicious hosts via third-party blacklists</string>
    <string name="reset">Reset</string>
    <string name="malware_whitelist_rules">Malware whitelist rules</string>
    <string name="feature_not_available">This feature is currently unavailable for your device</string>
    <string name="billing_connecting">The connection to Google Play is in progress, please retry in a while</string>
    <string name="malware_whitelist_help">User-defined whitelist to inhibit malware detection. Long-press malicious connections to create rules unmarking them as malware</string>
    <string name="hidden_connections_help">List of rules to hide connection-list entries so you can focus on relevant ones</string>
    <string name="malicious_connection_filter">Malicious</string>
    <string name="status_filter">HTTP status: %1$s</string>
    <string name="not_hidden_filter">Not hidden</string>
    <string name="copy_action">Copy…</string>
    <string name="url_val">"URL: %1$s"</string>
    <string name="show_me">Show me</string>
    <string name="hint">Hint</string>
    <string name="once">Once</string>
    <string name="forever">Forever</string>
    <string name="control_permissions">Control permissions</string>
    <string name="control_permissions_summary">Check which apps are allowed to control the PCAPdroid capture</string>
    <string name="control_permissions_item">%1$s: %2$s</string>
    <string name="no_permissions_set_info">No permissions set. Invoke PCAPdroid via StartActivityForResult to show the permissions prompt</string>
    <string name="generate_api_key">Generate API key</string>
    <string name="show_api_key">Show API key</string>
    <string name="api_key">API key</string>
    <string name="api_key_discard_confirm">Do you really want to discard the current API key and generate a new one?</string>
    <string name="country">Country</string>
    <string name="asn">ASN</string>
    <string name="country_val">Country: %1$s</string>
    <string name="send_report">Send report</string>
    <string name="start_at_boot">Start at boot</string>
    <string name="start_at_boot_summary">Auto-starts capture after boot</string>
    <string name="malware_status_ok">No malicious traffic detected</string>
    <string name="malware_status_detected">Malicious connections detected</string>
    <string name="whitelist">Whitelist</string>
    <string name="blacklists">Blacklists</string>
    <string name="status_outdated">Outdated</string>
    <string name="status_not_loaded">Not loaded</string>
    <string name="status_uptodate">Up-to-date</string>
    <string name="blacklist_type">"Type: %1$s"</string>
    <string name="blacklist_type_ip">IP blacklist</string>
    <string name="blacklist_type_domain">Domain blacklist</string>
    <string name="n_rules">%1$s rules</string>
    <string name="last_update_val">Last update: %1$s</string>
    <string name="malicious_connections">Malicious connections</string>
    <string name="malicious_connection_description">A connection from app \"%1$s\" triggered a malware detection rule (%2$s)</string>
    <string name="malicious_connections_notice">Blacklists may contain false positives. Be sure to double check the IP address/domain reputation online. You can exclude false positives via the malware whitelist</string>
    <string name="updated_blacklists">Updated blacklists</string>
    <string name="connections_checked">Connections checked</string>
    <string name="last_blacklists_update">Last update</string>
    <string name="domain_rules">Domain rules</string>
    <string name="ip_rules">IP rules</string>
    <string name="malware_status_update_failed">Some blacklists are outdated</string>
    <string name="update_now">Update now</string>
    <string name="status_updating">Updating…</string>
    <string name="malware_detection_learn_more">Learn more about the malware detection feature</string>
    <string name="private_dns_message_notice">Private DNS prevents PCAPdroid from inspecting the DNS traffic. You can turn it off from the Android network settings</string>
    <string name="private_dns_hinders_detection">Private DNS hinders detection</string>
    <string name="decryption_no_filter_warn">Select a target app when decrypting TLS to avoid losing your connection to the Internet</string>
    <string name="block">Block…</string>
    <string name="unblock">Unblock…</string>
    <string name="firewall">Firewall</string>
    <string name="firewall_rules">Firewall rules</string>
    <string name="blocked_pkts">Blocked</string>
    <string name="n_pkts">%1$s pkts</string>
    <string name="blocked_connection_filter">Blocked</string>
    <string name="allowed_connection_filter">Allowed</string>
    <string name="firewall_filter">Firewall: %1$s</string>
    <string name="paid_features">Paid features</string>
    <string name="validate">Validate</string>
    <string name="valid">Valid</string>
    <string name="invalid">Invalid</string>
    <string name="no_intent_handler_found">No app found to perform this action</string>
    <string name="network_interface">Interface</string>
    <string name="interface_filter">Interface: %1$s</string>
    <string name="request_method">Request method</string>
    <string name="content_type">Content type</string>
    <string name="http_status">HTTP status</string>
    <string name="payload_size_threshold">Payload size threshold</string>
    <string name="method_filter">Method: %1$s</string>
    <string name="content_type_filter">Content-Type: %1$s</string>
    <string name="loading">Loading…</string>
    <string name="purchased">Purchased</string>
    <string name="no_items_for_purchase">No items available for purchase</string>
    <string name="billing_failure">Could not connect to Google Play. Please retry in a while</string>
    <string name="learn_more">Learn more</string>
    <string name="buy_action">Buy</string>
    <string name="capture_not_running_status">The capture is not running</string>
    <string name="start_capture_first">Start the capture first</string>
    <string name="copied">Copied</string>
    <string name="can_use_purchased_feature">You can now use the purchased feature</string>
    <string name="disconnect_vpn_confirm">Continuing will disconnect the active VPN</string>
    <string name="loading_apps">Loading apps…</string>
    <string name="open_nav_drawer">Open drawer</string>
    <string name="close_nav_drawer">Close drawer</string>
    <string name="capture_all_apps">Capture the traffic of all the apps</string>
    <string name="save_ok">Saved</string>
    <string name="tls_decryption">TLS decryption</string>
    <string name="tls_decryption_summary">Decrypt the SSL/TLS traffic by performing mitm. This may now work with some apps, check out the user guide</string>
    <string name="traffic_inspection">Traffic inspection</string>
    <string name="mitm_start_failed">Could not start the mitm service. Try to open the mitm addon app manually and retry</string>
    <string name="mitm_setup_wizard">Mitm setup wizard</string>
    <string name="install_action">Install</string>
    <string name="export_action">Export</string>
    <string name="export_ellipsis">Export…</string>
    <string name="install_the_mitm_addon">Install the PCAPdroid <a href='%1$s'>mitm addon</a></string>
    <string name="export_ca_certificate">Export the PCAPdroid CA certificate, then open the Android \"Encryption &amp; Credentials\" settings and choose install it as a \"CA certificate\"</string>
    <string name="install_ca_certificate">Install the PCAPdroid CA certificate, choosing \"VPN and apps\". Android will ask for your lockscreen or password</string>
    <string name="checking_the_certificate">Checking the certificate…</string>
    <string name="ca_cert_export_failed">An error occurred while exporting the CA certificate\n\nIf your device implements Autostart or similar software to limit background services execution, be sure to <a href='%1$s'>whitelist PCAPdroid</a></string>
    <string name="cert_exported_now_installed">Certificate exported, now install it from the Android settings</string>
    <string name="cert_installed_correctly">The CA certificate is installed</string>
    <string name="cert_reinstall_required">The CA certificate is not installed, run the mitm setup wizard</string>
    <string name="mitm_addon_bad_version">Bad PCAPdroid mitm addon version. Please install version %1$s and retry</string>
    <string name="update_available">Update available</string>
    <string name="mitm_addon_update_available">A new mitm addon update is available. Update to get the latest bug fixes</string>
    <string name="mitm_addon_new_version">The PCAPdroid mitm addon must be updated</string>
    <string name="mitm_addon">mitm addon</string>
    <string name="update_action">Update</string>
    <string name="export_failed">Export failed</string>
    <string name="not_encrypted">Not encrypted</string>
    <string name="request">Request</string>
    <string name="response">Response</string>
    <string name="overview">Overview</string>
    <string name="string_http_request">HTTP request</string>
    <string name="string_http_response">HTTP response</string>
    <string name="payload_truncated">Payload is truncated. To show it in full, stop the capture and enable \"%1$s\" from the PCAPdroid settings</string>
    <string name="websocket">WebSocket</string>
    <string name="http">HTTP</string>
    <string name="payload">Payload</string>
    <string name="tx_direction">TX</string>
    <string name="rx_direction">RX</string>
    <string name="full_payload">Full payload</string>
    <string name="full_payload_summary">Show the full connections payload (e.g. the full HTTP request and response). This requires a lot of memory, don\'t use in the long run</string>
    <string name="not_decryptable">Not decryptable</string>
    <string name="decrypted">Decrypted</string>
    <string name="decryption">Decryption</string>
    <string name="decryption_filter">Status: %1$s</string>
    <string name="connection_start_not_seen">PCAPdroid has not seen the start of this connection. Some information may be missing</string>
    <string name="network_traffic">Traffic</string>
    <string name="warn_no_app_data">No application data has been exchanged</string>
    <string name="waiting_application_data">Waiting data</string>
    <string name="text">Text</string>
    <string name="hexdump">Hexdump</string>
    <string name="display_as_text">Display as text</string>
    <string name="display_as_hexdump">Display as hexdump</string>
    <string name="geolocation">Geolocation</string>
    <string name="geolocation_summary">Show country and ASN info by performing offline lookups</string>
    <string name="downloading">Downloading…</string>
    <string name="download_in_progress">Download in progress, please wait</string>
    <string name="pcap_load_in_progress">Capture file loading in progress, please wait</string>
    <string name="download_failed">Download failed</string>
    <string name="exporting">Exporting…</string>
    <string name="export_in_progress">Export in progress, please wait</string>
    <string name="geo_db_not_found">Database not found. Geolocation is disabled</string>
    <string name="geo_db_missing">Geolocation database missing</string>
    <string name="country_rules_warning">To use country-based firewall rules, download the geolocation database from the PCAPdroid settings, otherwise country-based rules will be ineffective</string>
    <string name="database">Database</string>
    <string name="built_on">Built on: %1$s</string>
    <string name="geo_db_download">Tap to download the latest database. New databases are available monthly</string>
    <string name="size_x">Size: %1$s</string>
    <string name="geo_db_delete">Tap to delete the database and save space</string>
    <string name="download">Download</string>
    <string name="connection_blocked">This connection has been blocked by PCAPdroid</string>
    <string name="import_action">Import</string>
    <string name="import_failed">Import failed</string>
    <string name="invalid_backup">Invalid backup format</string>
    <string name="rules_import_success">Imported %1$d rules</string>
    <string name="no_rules_to_export">No rules to export</string>
    <string name="rules_merge_msg">Keep the existing rules?</string>
    <string name="keep_action">Keep</string>
    <string name="discard_action">Discard</string>
    <string name="rules_delete_confirm">Delete the selected rules?</string>
    <string name="blocklist">Blocklist</string>
    <string name="num_configured_rules">Configured rules</string>
    <string name="connections_blocked">Connections blocked</string>
    <string name="last_firewall_block">Last block</string>
    <string name="firewall_is_disabled">Firewall is disabled</string>
    <string name="firewall_is_enabled">Firewall is enabled</string>
    <string name="app_info">App info</string>
    <string name="action_block">Block</string>
    <string name="action_unblock">Unblock</string>
    <string name="netd_block_missed">This connection was initiated by netd so it could not be blocked</string>
    <string name="firewall_summary">Block internet access to apps, configure rules for specific domains and IP addresses. Only works with the non-root capture</string>
    <string name="no_root_firewall">No-root firewall</string>
    <string name="block_quick">Block QUIC</string>
    <string name="block_private_dns">Block private DNS</string>
    <string name="block_private_dns_summary">Detect and possibly block private DNS to inspect DNS traffic. Disabling this can hinder traffic analysis</string>
    <string name="mitm_setup_wizard_intro">This wizard will guide you through the installation of the PCAPdroid mitm addon and certification authority, which are needed to perform the <a href='%1$s'>TLS decryption</a></string>
    <string name="mitm_setup_wizard_done">PCAPdroid is now ready to decrypt the TLS traffic\n\nCheck out the <a href='%1$s'>user guide</a> to know more about the security measures which may prevent decryption and how to bypass them</string>
    <string name="welcome_to_pcapdroid">Welcome to PCAPdroid</string>
    <string name="app_intro_next_button">Next</string>
    <string name="app_intro_skip_button">Skip</string>
    <string name="app_intro_back_button">Back</string>
    <string name="app_intro_done_button">Done</string>
    <string name="app_intro_welcome_msg">PCAPdroid is a privacy-friendly app which lets you track and analyze the connections made by the apps in your device\n\nMoreover, it allows you to export a PCAP dump of the traffic, extract metadata and much more!</string>
    <string name="privacy_first">Privacy first</string>
    <string name="app_intro_privacy_msg">The app does not employ any tracking, analytics or phoning-home anti-features\n\nHow can you be sure? Check out its <a href='%1$s'>privacy policy</a> and its <a href='%2$s'>source code</a></string>
    <string name="country_and_asn">Country and ASN</string>
    <string name="app_intro_geolocation_msg">PCAPdroid can query a local database to determine the country of a remote server\n\nYou must first download the geolocation database from the app settings</string>
    <string name="vpn_setup_msg">PCAPdroid simulates a VPN in order to capture the network traffic without root.\n\nTo start the capture, you need to accept the VPN request in the next screen.\n\n<b>NOTE:</b> to proceed, disable any configured Always-on VPN from the Android settings</string>
    <string name="app_intro_traffic_inspection">Inspecting HTTP requests, responses and raw data is easy, thanks to the built-in decoders\n\nGot an encrypted connection? You can enable the <a href='%1$s'>TLS decryption</a> to get the decrypted data</string>
    <string name="app_intro_firewall_msg">With the integrated <a href='%1$s'>Firewall</a> you can easily block Internet access to individual apps, domains and countries\n\nCombine this with the built-in traffic visibility to get the ultimate tool to protect your privacy</string>
    <string name="app_intro_malware_detection">Enhance the security of your device with the <a href='%1$s'>malware detection</a> feature\n\nBy using up-to-date blacklists, it can detect, block and alert malicious connections in real-time</string>
    <string name="app_intro_traffic_dump">PCAPdroid provides <a href='%1$s'>multiple ways</a> to dump the traffic in the standard PCAP format for further analysis\n\nVia the <a href='%2$s'>PCAPdroid extensions option</a>, you can add app names to the packets and display them in Wireshark</string>
    <string name="permission_granted">%1$s permission was granted</string>
    <string name="permission_grant_fail">%1$s permission could not be granted</string>
    <string name="connection_not_found">Could not find the given connection</string>
    <string name="low_memory">Low memory</string>
    <string name="low_memory_info">The app is running out of memory, expect crashes</string>
    <string name="full_payload_disabled">The full payload option has been disabled</string>
    <string name="capture_stopped_low_memory">Capture has been stopped</string>
    <string name="heap_usage">Heap usage</string>
    <string name="memory_usage">Memory usage</string>
    <string name="vpn_lockdown_notice">To prevent apps from accessing the Internet when PCAPdroid is not running (e.g. after a reboot) you can set PCAPdroid as an always-on VPN in lockdown mode.\n\nDo you want to open the VPN settings now?</string>
    <string name="ip_mode">VPN IP addresses</string>
    <string name="ipv4_only">IPv4 only</string>
    <string name="ipv6_only">IPv6 only</string>
    <string name="ip_both">IPv4 and IPv6</string>
    <string name="notifications_notice">The app uses notifications to send alerts in case of anomalous events. Grant it the permission to send notifications in the next screen</string>
    <string name="vpn_exemptions">VPN exemptions</string>
    <string name="vpn_exemptions_summary">Exempt some apps from the VPN connection. Their traffic will not be monitored</string>
    <string name="no_matches_found">No matches</string>
    <string name="cleartext_connection">Cleartext</string>
    <string name="unblock_permanently">Unblock permanently</string>
    <string name="unblock_for_n_hours">Unblock for %1$dh</string>
    <string name="unblock_for_n_minutes">Unblock for %1$dm</string>
    <string name="block_new_apps">Block newly installed apps</string>
    <string name="app_blocked">App blocked</string>
    <string name="app_blocked_info">The %1$s app has been blocked by the firewall</string>
    <string name="app_unblocked">The %1$s app has been unblocked</string>
    <string name="payload_scams_notice">This view may contain sensitive information, like your passwords and access tokens.\n\nNever give out this information to anyone, it may be a scam attempt</string>
    <string name="cancel_action">Cancel</string>
    <string name="show_data_action">Show data</string>
    <string name="remote_collector_notice">You have configured PCAPdroid to send traffic to a remote server. The server will be able to access your sensitive information.\n\nIf someone asked you to do this, it is probably a scam attempt</string>
    <string name="remote_server_warning">For security reasons, sending traffic to the remote server \"%1$s\" is not allowed"</string>
    <string name="warning">Warning</string>
    <string name="paid_features_unlocked">Paid features unlocked. Restart the capture if running</string>
    <string name="build_info">Build info</string>
    <string name="tls_decryption_with_root_msg">The ability to run TLS decryption with root is an experimental feature. This is a list of known bugs:\n\n
- in PCAPdroid you will see the traffic as it was generated from the mitm-addon app in place of the original app\n
- dump of the SSL keylog is not supported\n
- when an app filter is set, decryption will only occur for the target app, but PCAPdroid will still show the other apps traffic\n
- if the capture fails to start, ensure that you can actually run the iptables command as root (e.g. via termux)\n
- this may not work on Android 12 and later\n
- if a VPN app is running, you should either target a specific app for decryption or exclude the PCAPdroid mitm addon from the VPN, otherwise traffic will go in a loop
</string>
    <string name="unlock_token_summary">A token which can be used to unlock the paid features in non-Google-Play builds of the app (e.g. F-Droid/Github)</string>
    <string name="unlock_token_error">Could not request unlock token [%1$d]: %2$s</string>
    <string name="access_paid_features_msg">Check out <a href='%1$s'>the user guide</a> to learn how to access the paid features</string>
    <string name="license_service_unavailable">The PCAPdroid license service is currently unavailable. Please retry in some minutes</string>
    <string name="requesting_unlock_token">Requesting an unlock token, please wait</string>
    <string name="show_action">Show</string>
    <string name="show_connection">Show connection</string>
    <string name="show_system_apps">Show system apps</string>
    <string name="unlock_token_msg1">This is your unlock token. Note it down as you will need it <a href='%1$s'>to generate your license codes</a></string>
    <string name="paid_feature">Paid feature</string>
    <string name="firewall_purchase_msg">Buy the <i>%1$s</i> feature to start blocking connections</string>
    <string name="mitm_skip_notice">The mitm certificate does not seem to be installed. If you proceed, decryption may fail</string>
    <string name="mitm_wizard_description">Configure the device for the TLS decryption</string>
    <string name="mitmproxy_opts">Additional mitmproxy options</string>
    <string name="mitmproxy_opts_description">Provide additional options for mitmproxy</string>
    <string name="mitm_addon_error">Error while starting the mitm addon. Check the log for details</string>
    <string name="whitelist_mode">Whitelist mode</string>
    <string name="firewall_whitelist_notice">In this mode all the connections will be blocked, unless manually whitelisted. You may miss push notifications without a proper whitelist</string>
    <string name="firewall_whitelist_help">These rules specify which connections to allow. Blocklist rules have priority over whitelist rules</string>
    <string name="add_to_fw_whitelist">Add to firewall whitelist</string>
    <string name="remove_from_fw_whitelist">Remove from firewall whitelist</string>
    <string name="reset_stats_confirm">Do you really want to reset these stats?</string>
    <string name="port_mapping">Port mapping</string>
    <string name="port_mapping_summary">Configure port mapping rules to redirect connections to a different host or port</string>
    <string name="add_action">Add</string>
    <string name="redirect_to">Redirect to:</string>
    <string name="original_port">Original port</string>
    <string name="required">required</string>
    <string name="destination_host">Destination host</string>
    <string name="destination_port">Destination port</string>
    <string name="port_mapping_exists">Port mapping already defined</string>
    <string name="items_delete_confirm">Delete the selected items?</string>
    <string name="ip_address">IP address</string>
    <string name="ip_address_or_cidr">IP address / CIDR</string>
    <string name="rule_exists">Rule already defined</string>
    <string name="dns_servers">DNS servers</string>
    <string name="dns_servers_summary">Configure the DNS servers to use during the capture</string>
    <string name="ipv4_dns_server">IPv4 DNS server</string>
    <string name="ipv6_dns_server">IPv6 DNS server</string>
    <string name="use_system_dns">Use system DNS</string>
    <string name="use_system_dns_summary">Use the system DNS servers if possible</string>
    <string name="external_storage_perm_required">The external storage permission is required</string>
    <string name="many_rules_warning">You are trying to import many rules, which could make the app unresponsive during some interactions. Do you really want to continue?</string>
    <string name="pcapng_format">Pcapng format</string>
    <string name="pcapng_format_summary">Dump packets in the Pcapng dump format, which is more flexible and allows embedding TLS decryption secrets</string>
    <string name="sort_by">Sort by</string>
    <string name="total_bytes">Total bytes</string>
    <string name="write_ext_storage_failed">Write to external storage failed. Check the app log for details</string>
    <string name="username">Username</string>
    <string name="password">Password</string>
    <string name="mitm_addon_autostart_workaround">Connection to the mitm addon failed. As a workaround, you can try to open the mitm addon app and then go back to PCAPdroid without closing it. Do you want to open it now?</string>
    <string name="qr_license_confirm">Do you want to generate a license for the \"%1$s\" device using the following unlock token?</string>
    <string name="invalid_license">Invalid license</string>
    <string name="connection_error">Connection error: %1$s</string>
    <string name="activate_via_qr_code">Activate via QR code</string>
    <string name="qr_code_expired">QR code expired. Generate a new QR code and retry</string>
    <string name="qr_info_text">Install PCAPdroid from Google Play and scan this QR code</string>
    <string name="qr_purchase_required">Purchase an unlock token to proceed with the QR code activation</string>
    <string name="license_limit_reached">You have reached the licenses limit for this unlock token. Buy a new token to generate more licenses</string>
    <string name="license_error">License generation error [%1$d]: %2$s</string>
    <string name="requesting_license">Requesting a license code, please wait</string>
    <string name="license_activation_ok">License activation completed</string>
    <string name="mitm_addon_starting">Mitm addon is starting…</string>
    <string name="mitm_addon_running">Mitm addon is running</string>
    <string name="decryption_rules">Decryption rules</string>
    <string name="decryption_rules_help">These rules specify which connections to decrypt. Host-based rules only work if a prior DNS reply is seen</string>
    <string name="decrypt_action">Decrypt…</string>
    <string name="dont_decrypt_action">Don\'t decrypt…</string>
    <string name="status_encrypted">Encrypted</string>
    <string name="injected">Injected</string>
    <string name="open_pcap_file">Open PCAP/Pcapng file…</string>
    <string name="pcap_load_success">Capture file loaded</string>
    <string name="unsupported_pcap_file">Unsupported capture file format</string>
    <string name="decrypt_pcap_file">Decrypt PCAP/Pcapng file…</string>
    <string name="invalid_pcap_file">Invalid capture file format</string>
    <string name="capture_interface_open_error">Could not open the capture interface</string>
    <string name="unsupported_pcap_datalink">The file has an unsupported datalink</string>
    <string name="pcap_file_not_exists">The specified file does not exist</string>
    <string name="root_capture_start_failed">Capture start failure. Ensure that the device is rooted with Magisk</string>
    <string name="root_capture_pcapd_start_failure">Capture start failure. Make sure you grant root access to PCAPdroid</string>
    <string name="pcap_read_error">Error reading the capture file. Check the log for details</string>
    <string name="keylog_read_error">SSL keylog read error</string>
    <string name="pcap_file_load_aborted">Capture file loading aborted</string>
    <string name="host_resolution_failed">"Could not resolve host %1$s</string>
    <string name="pcapdroid_trailer_notice">To show the actual apps instead of \"%1$s\", be sure to enable the \"%2$s\" option before generating the dump</string>
    <string name="decryption_info_no_rule">To decrypt this connection, create a decryption rule from the left drawer or from the contextual menu in the Connections list</string>
    <string name="tls_decryption_no_rules_notice">TLS decryption is only applied to connections that match the configured rules. Do you want to create decryption rules now?</string>
    <string name="active_vpn_detected">Active VPN detected</string>
    <string name="mitm_doze_notice">Battery optimization may interfere with the mitm addon</string>
    <string name="redirected">redirected</string>
    <string name="connection_redirected_port_map">This connection has been redirected due to a port mapping rule</string>
    <string name="dnscrypt_how_to">How to use DoH / DNSCrypt with PCAPdroid</string>
    <string name="never">Never</string>
    <string name="always">Always</string>
    <string name="for_connections_to_decrypt">Only for connections to decrypt</string>
    <string name="decrypt_quic_notice">Decrypting QUIC is currently not supported. As a workaround, stop the capture and select the option to block QUIC in the PCAPdroid settings</string>
    <string name="target_apps">Target apps</string>
    <string name="target_apps_help">Select the applications to capture</string>
    <string name="headers">Headers</string>
    <string name="body">Body</string>
    <string name="both">Both</string>
    <string name="whats_new">What\'s new</string>
    <string name="raw_bytes">Raw bytes</string>
    <string name="restart_on_disconnection">Restart on disconnection</string>
    <string name="restart_on_disconnection_summary">Automatically restart the capture after being stopped by other VPN apps</string>
    <string name="vpn_reconnection">VPN reconnection</string>
    <string name="vpn_reconnection_aborted">VPN reconnection aborted</string>
    <string name="waiting_for_vpn_disconnect">Waiting for the active VPN to disconnect…</string>
    <string name="bytes_threshold">Bytes threshold</string>
    <string name="select_the_pcap_file">Select the PCAP/Pcapng file</string>
    <string name="select_the_keylog_file">Select the SSL keylog file</string>
    <string name="error_code_with_text">%1$s (error %2$d)</string>
    <string name="errno_epipe">Broken pipe</string>
    <string name="errno_epipe_msg">The server unexpectedly closed the connection during the data transfer</string>
    <string name="errno_enetdown">Network is down</string>
    <string name="errno_enetdown_msg">The network interface is down or it\'s unable to connect to the network</string>
    <string name="errno_enetunreach">Network is unreachable</string>
    <string name="errno_enetunreach_msg">The system cannot find a valid route to the destination network</string>
    <string name="errno_enetreset">Network reset</string>
    <string name="errno_enetreset_msg">The network connection was reset by an intermediary device (e.g. router or mobile carrier)</string>
    <string name="errno_econnaborted">Connection aborted</string>
    <string name="errno_econnaborted_msg">The connection was aborted, usually due to a network transition</string>
    <string name="errno_econnreset">Connection reset by peer</string>
    <string name="errno_econnreset_msg">The server abruptly closed the connection, usually due to a crash or ungraceful shutdown</string>
    <string name="errno_etimedout">Connection timed out</string>
    <string name="errno_etimedout_msg">The server took too long to respond, likely due to network delays or a busy server</string>
    <string name="errno_econnrefused">Connection refused</string>
    <string name="errno_econnrefused_msg">The server rejected the connection, which may indicate a too busy or malfunctioning server</string>
    <string name="errno_ehostunreach">No route to host</string>
    <string name="errno_ehostunreach_msg">The system cannot find a route to the destination host</string>
    <string name="dns_conn_info">DNS translates a domain name into an IP address. The actual data is typically exchanged over subsequent HTTPS/TLS connections</string>
    <string name="tls_conn_info">TLS/HTTPS traffic is encrypted. To inspect this traffic, you need to decrypt it. Check out the PCAPdroid <a href='%1$s'>user guide</a> for details</string>
    <string name="tls_decryption_not_supported_16KB">TLS decryption is currently unsupported on 16 KB devices</string>
    <string name="filename_prefix">Filename prefix</string>
    <string name="filename_prefix_description">Set the prefix for the files exported by PCAPdroid, e.g. PCAP files</string>
    <string name="no_requests">No requests</string>
    <string name="item_not_found">Could not find the specified item</string>
    <string name="connection_number">Connection #%1$d</string>
    <string name="http_request_number">HTTP request #%1$d</string>
    <string name="http_requests">HTTP requests</string>
    <string name="switch_to_http">Show HTTP requests</string>
    <string name="switch_to_connections">Show connections</string>
    <string name="decryption_error">Decryption error</string>
    <string name="previous">Previous</string>
    <string name="next">Next</string>
    <string name="save_as_text">Save as text</string>
    <string name="save_as_har">Save as HAR</string>
</resources>

```

`app/src/main/res/values/styles.xml`:

```xml
<resources xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Base application theme. -->
    <!-- https://material.io/blog/android-dark-theme-tutorial -->
    <style name="Base.AppTheme" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
        <item name="android:windowAllowReturnTransitionOverlap">true</item>
        <item name="android:windowAllowEnterTransitionOverlap">true</item>
        <item name="alertDialogTheme">@style/AppAlertDialogTheme</item>
        <item name="actionBarStyle">@style/MyActionBar</item>
    </style>

    <!-- Make the Widget.MaterialComponents.Button.TextButton of AlertDialog use the accent color -->
    <style name="AppAlertDialogTheme" parent="Theme.MaterialComponents.DayNight.Dialog">
        <item name="colorPrimary">@color/colorAccent</item>
        <item name="windowMinWidthMajor">@android:dimen/dialog_min_width_major</item>
        <item name="windowMinWidthMinor">@android:dimen/dialog_min_width_minor</item>
    </style>

    <!-- Make the TextInputLayout of AlertDialog use the accent color -->
    <style name="TextInputLayoutOutlined" parent="Widget.MaterialComponents.TextInputLayout.OutlinedBox">
        <item name="boxStrokeColor">@color/colorAccent</item>
        <item name="hintTextColor">@color/colorAccent</item>
    </style>
    <style name="TextInputLayoutOutlinedDropdown" parent="Widget.MaterialComponents.TextInputLayout.OutlinedBox.ExposedDropdownMenu">
        <item name="boxStrokeColor">@color/colorAccent</item>
        <item name="hintTextColor">@color/colorAccent</item>
    </style>
    <style name="Theme.TextInputLayoutOutlined" parent="">
        <item name="colorPrimary">@color/colorAccent</item>
    </style>

    <!-- White app theme. See values-night-v8 for the dark customizations -->
    <style name="AppTheme" parent="Base.AppTheme"/>

    <style name="AppTheme.NoActionBar" parent="AppTheme">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="windowActionModeOverlay">true</item>
    </style>

    <style name="AppTheme.SplashScreen" parent="AppTheme.NoActionBar">
        <item name="android:windowBackground">@drawable/splash_screen</item>
    </style>

    <style name="MyActionBar" parent="@style/Widget.AppCompat.ActionBar.Solid">
        <item name="background">@color/colorActionBar</item>
        <item name="elevation">0dp</item>
        <!--<item name="backgroundStacked">@color/colorActionBar</item>-->
        <!--<item name="backgroundSplit">@color/colorActionBar</item>-->
    </style>

    <style name="AppBarOverlay" parent="ThemeOverlay.MaterialComponents.Dark.ActionBar" />
    <style name="PopupOverlay" parent="ThemeOverlay.MaterialComponents.Light" />

    <style name="QuickSettings.Title" parent="AppTheme">
        <item name="android:textSize">18sp</item>
        <item name="android:textStyle">bold</item>
    </style>

    <style name="AppTheme.Floating" parent="AppTheme">
        <item name="android:windowIsFloating">true</item>
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="android:windowIsTranslucent">true</item>
        <item name="android:windowBackground">@android:color/transparent</item>
    </style>
</resources>

```

`app/src/main/res/xml/dns_preferences.xml`:

```xml
<PreferenceScreen
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:android="http://schemas.android.com/apk/res/android">

    <SwitchPreference
        app:key="system_dns"
        android:title="@string/use_system_dns"
        app:iconSpaceReserved="false"
        app:summary="@string/use_system_dns_summary"
        android:defaultValue="true" />

    <EditTextPreference
        app:key="dns_v4"
        app:title="@string/ipv4_dns_server"
        app:iconSpaceReserved="false"
        app:defaultValue="1.1.1.1"
        app:useSimpleSummaryProvider="true" />

    <EditTextPreference
        app:key="dns_v6"
        app:title="@string/ipv6_dns_server"
        app:iconSpaceReserved="false"
        app:defaultValue="2606:4700:4700::1111"
        app:useSimpleSummaryProvider="true" />
</PreferenceScreen>

```

`app/src/main/res/xml/geoip_preferences.xml`:

```xml
<PreferenceScreen
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:android="http://schemas.android.com/apk/res/android">

    <Preference
        app:key="status"
        app:title="@string/database"
        app:iconSpaceReserved="false"
        android:summary="@string/geo_db_not_found">

        <intent android:action="android.intent.action.VIEW"
            android:data="https://db-ip.com/db/lite.php" />
    </Preference>

    <Preference
        app:key="download"
        app:title="@string/download"
        android:summary="@string/geo_db_download"
        app:iconSpaceReserved="false" />

    <Preference
        app:key="delete"
        app:title="@string/delete"
        android:summary="@string/geo_db_delete"
        app:iconSpaceReserved="false" />
</PreferenceScreen>

```

`app/src/main/res/xml/locales_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<locale-config xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- https://developer.android.com/guide/topics/resources/app-languages -->
    <locale android:name="en-US"/>
    <locale android:name="ar"/> <!-- Arabic -->
    <locale android:name="az"/> <!-- Azerbaijani -->
    <locale android:name="de"/> <!-- German -->
    <locale android:name="es"/> <!-- Spanish  -->
    <locale android:name="in"/> <!-- Indonesian -->
    <locale android:name="it"/> <!-- Italian -->
    <locale android:name="pl"/> <!-- Polish -->
    <locale android:name="pt-BR"/> <!-- Portuguese (Brazil) -->
    <locale android:name="ru"/> <!-- Russian -->
    <locale android:name="ta"/> <!-- Tamil -->
    <locale android:name="tr"/> <!-- Turkish -->
    <locale android:name="uk"/> <!-- Ukrainian -->
    <locale android:name="zh-Hans"/> <!-- Chinese (Simplified) -->
</locale-config>
```

`app/src/main/res/xml/root_preferences.xml`:

```xml
<!--
  ~ Copyright 2018 The app Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<PreferenceScreen
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <PreferenceCategory app:title="@string/http_server" app:iconSpaceReserved="false">
        <EditTextPreference
            app:key="http_server_port"
            app:title="@string/http_server_port"
            app:defaultValue="8080"
            app:iconSpaceReserved="false"
            app:useSimpleSummaryProvider="true" />
    </PreferenceCategory>

    <PreferenceCategory app:title="@string/tcp_udp_exporter" app:iconSpaceReserved="false">
        <EditTextPreference
            app:key="collector_ip_address"
            app:title="@string/receiver_ip_address"
            app:iconSpaceReserved="false"
            app:defaultValue="@string/default_collector_ip"
            app:useSimpleSummaryProvider="true" />

        <EditTextPreference
            app:key="collector_port"
            app:title="@string/receiver_port"
            app:iconSpaceReserved="false"
            app:defaultValue="@string/default_collector_port"
            app:useSimpleSummaryProvider="true" />
    </PreferenceCategory>

    <PreferenceCategory app:title="@string/traffic_inspection" app:iconSpaceReserved="false"  app:key="traffic_inspection">
        <SwitchPreference
            android:key="auto_block_private_dns"
            app:title="@string/block_private_dns"
            app:summary="@string/block_private_dns_summary"
            app:iconSpaceReserved="false"
            app:defaultValue="true" />

        <Preference
            app:key="dnscrypt_link"
            app:title="@string/dnscrypt_how_to"
            app:iconSpaceReserved="false">
            <intent android:action="android.intent.action.VIEW"
                android:data="https://emanuele-f.github.io/PCAPdroid/advanced_features#42-doh-support" />
        </Preference>

        <Preference
            android:key="geolocation"
            app:title="@string/geolocation"
            app:summary="@string/geolocation_summary"
            app:iconSpaceReserved="false"
            app:fragment="com.emanuelef.remote_capture.fragments.GeoipSettings" />

        <SwitchPreference
            app:key="tls_decryption"
            app:title="@string/tls_decryption"
            app:iconSpaceReserved="false"
            app:summary="@string/tls_decryption_summary"
            app:defaultValue="false" />

        <Preference
            app:key="mitm_setup_wizard"
            app:title="@string/mitm_setup_wizard"
            app:summary="@string/mitm_wizard_description"
            app:iconSpaceReserved="false" />

        <EditTextPreference
            app:key="mitmproxy_opts"
            app:title="@string/mitmproxy_opts"
            app:summary="@string/mitmproxy_opts_description"
            app:iconSpaceReserved="false"
            app:useSimpleSummaryProvider="true" />

        <DropDownPreference
            app:key="block_quic_mode"
            app:title="@string/block_quick"
            android:entries="@array/block_quic_labels"
            android:entryValues="@array/block_quic"
            app:iconSpaceReserved="false"
            app:defaultValue="never"
            app:useSimpleSummaryProvider="true" />

        <SwitchPreference
            app:key="full_payload"
            app:title="@string/full_payload"
            app:iconSpaceReserved="false"
            app:summary="@string/full_payload_summary"
            app:defaultValue="false" />

        <Preference
            android:key="socks5_settings"
            app:title="@string/socks5_proxy"
            app:summary="@string/socks5_summary"
            app:iconSpaceReserved="false"
            app:fragment="com.emanuelef.remote_capture.fragments.prefs.Socks5Settings" />
    </PreferenceCategory>

    <PreferenceCategory app:title="@string/capture_prefs" app:iconSpaceReserved="false" >
        <SwitchPreference
            app:key="root_capture"
            app:title="@string/root_capture"
            app:iconSpaceReserved="false"
            app:summary="@string/root_capture_summary"
            app:defaultValue="false" />

        <DropDownPreference
            app:key="capture_interface"
            app:title="@string/capture_interface"
            app:iconSpaceReserved="false"
            app:useSimpleSummaryProvider="true"
            app:defaultValue="\@inet" />

        <Preference
            android:key="vpn_exceptions"
            app:title="@string/vpn_exemptions"
            app:summary="@string/vpn_exemptions_summary"
            app:iconSpaceReserved="false" />

        <SwitchPreference
            app:key="pcapng_format"
            app:title="@string/pcapng_format"
            app:iconSpaceReserved="false"
            app:summary="@string/pcapng_format_summary"
            app:defaultValue="true" />

        <SwitchPreference
            app:key="dump_extensions"
            app:title="@string/dump_extensions"
            app:iconSpaceReserved="false"
            app:summary="@string/dump_extensions_summary"
            app:defaultValue="false" />

        <Preference
            app:key="dump_extensions_how_to"
            app:title="@string/dump_extensions_how_to"
            app:iconSpaceReserved="false">
            <intent android:action="android.intent.action.VIEW"
                android:data="https://emanuele-f.github.io/PCAPdroid/advanced_features#45-pcapdroid-extensions" />
        </Preference>

        <Preference
            android:key="dns_settings"
            app:title="@string/dns_servers"
            app:summary="@string/dns_servers_summary"
            app:iconSpaceReserved="false"
            app:fragment="com.emanuelef.remote_capture.fragments.prefs.DnsSettings" />

        <SwitchPreference
            app:key="start_at_boot"
            android:title="@string/start_at_boot"
            app:iconSpaceReserved="false"
            app:summary="@string/start_at_boot_summary"
            android:defaultValue="false" />

        <SwitchPreference
            app:key="restart_on_disconnect"
            android:title="@string/restart_on_disconnection"
            app:iconSpaceReserved="false"
            app:summary="@string/restart_on_disconnection_summary"
            android:defaultValue="false" />
    </PreferenceCategory>

    <PreferenceCategory app:title="@string/security" app:iconSpaceReserved="false" app:key="security">
        <SwitchPreference
            app:key="malware_detection"
            app:title="@string/malware_detection"
            app:iconSpaceReserved="false"
            app:summary="@string/malware_detection_summary"
            app:defaultValue="true" />

        <Preference
            app:key="malware_detection_docs"
            app:title="@string/malware_detection_learn_more"
            app:iconSpaceReserved="false">
            <intent android:action="android.intent.action.VIEW"
                android:data="https://emanuele-f.github.io/PCAPdroid/paid_features#51-malware-detection" />
        </Preference>
    </PreferenceCategory>

    <PreferenceCategory app:title="@string/other_prefs" app:iconSpaceReserved="false" >
        <DropDownPreference
            app:key="app_language"
            app:title="@string/app_language"
            app:iconSpaceReserved="false"
            app:defaultValue="system"
            app:useSimpleSummaryProvider="true"/>

        <Preference
            app:key="app_language_external"
            app:title="@string/app_language"
            app:isPreferenceVisible="false"
            app:useSimpleSummaryProvider="true"
            app:iconSpaceReserved="false" />

        <Preference
            app:key="port_mapping"
            app:title="@string/port_mapping"
            app:summary="@string/port_mapping_summary"
            app:iconSpaceReserved="false" />

        <DropDownPreference
            app:key="ip_mode"
            app:title="@string/ip_mode"
            android:entries="@array/ip_mode_labels"
            android:entryValues="@array/ip_mode"
            app:iconSpaceReserved="false"
            app:defaultValue="ipv4"
            app:useSimpleSummaryProvider="true" />

        <EditTextPreference
            app:key="filename_prefix"
            app:title="@string/filename_prefix"
            app:summary="@string/filename_prefix_description"
            app:defaultValue="PCAPdroid_"
            app:iconSpaceReserved="false" />

        <Preference
            app:key="control_permissions"
            app:title="@string/control_permissions"
            app:iconSpaceReserved="false"
            android:summary="@string/control_permissions_summary" />
    </PreferenceCategory>
</PreferenceScreen>

```

`app/src/main/res/xml/socks5_preferences.xml`:

```xml
<PreferenceScreen
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:android="http://schemas.android.com/apk/res/android">

    <SwitchPreference
        app:key="socks5_enabled"
        app:title="@string/socks5_redirection"
        app:iconSpaceReserved="false"
        app:summary="@string/enable_socks5_proxy_summary"
        app:defaultValue="false" />

    <EditTextPreference
        app:key="socks5_proxy_ip_address"
        app:title="@string/proxy_host"
        app:defaultValue="0.0.0.0"
        app:iconSpaceReserved="false"
        app:useSimpleSummaryProvider="true" />

    <EditTextPreference
        app:key="socks5_proxy_port"
        app:title="@string/proxy_port"
        app:iconSpaceReserved="false"
        app:defaultValue="8050"
        app:useSimpleSummaryProvider="true" />

    <SwitchPreference
        app:key="socks5_auth_enabled"
        app:title="@string/socks5_auth"
        app:iconSpaceReserved="false"
        app:summary="@string/socks5_auth_summary"
        app:defaultValue="false" />

    <EditTextPreference
        app:key="socks5_username"
        app:title="@string/username"
        app:iconSpaceReserved="false"
        app:useSimpleSummaryProvider="true" />

    <EditTextPreference
        app:key="socks5_password"
        app:title="@string/password"
        app:iconSpaceReserved="false"
        app:useSimpleSummaryProvider="true" />
</PreferenceScreen>

```

`app/src/test/java/com/emanuelef/remote_capture/CidrTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import org.junit.Test;

import java.net.UnknownHostException;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

public class CidrTest {
    @Test
    public void testIpv4Basic() throws Exception {
        Cidr cidr = new Cidr("192.168.1.0/24");
        assertEquals("192.168.1.0", cidr.getNetworkAddress());
        assertEquals("192.168.1.255", cidr.getBroadcastAddress());
    }

    @Test
    public void testIpv4IsInRange() throws Exception {
        Cidr cidr = new Cidr("10.0.0.0/8");
        assertTrue(cidr.isInRange("10.0.0.1"));
        assertTrue(cidr.isInRange("10.255.255.255"));
        assertTrue(cidr.isInRange("10.0.0.0"));
        assertFalse(cidr.isInRange("11.0.0.0"));
        assertFalse(cidr.isInRange("9.255.255.255"));
    }

    @Test
    public void testIpv4Slash32() throws Exception {
        Cidr cidr = new Cidr("192.168.1.100/32");
        assertTrue(cidr.isInRange("192.168.1.100"));
        assertFalse(cidr.isInRange("192.168.1.99"));
        assertFalse(cidr.isInRange("192.168.1.101"));
        assertEquals("192.168.1.100", cidr.getNetworkAddress());
        assertEquals("192.168.1.100", cidr.getBroadcastAddress());
    }

    @Test
    public void testIpv4Slash0() throws Exception {
        Cidr cidr = new Cidr("0.0.0.0/0");
        assertTrue(cidr.isInRange("0.0.0.0"));
        assertTrue(cidr.isInRange("255.255.255.255"));
        assertTrue(cidr.isInRange("10.20.30.40"));
    }

    @Test
    public void testIpv6Basic() throws Exception {
        Cidr cidr = new Cidr("2001:db8::/32");
        assertTrue(cidr.isInRange("2001:db8::1"));
        assertTrue(cidr.isInRange("2001:db8:ffff:ffff:ffff:ffff:ffff:ffff"));
        assertFalse(cidr.isInRange("2001:db9::1"));
    }

    @Test
    public void testIpv6Slash128() throws Exception {
        Cidr cidr = new Cidr("::1/128");
        assertTrue(cidr.isInRange("::1"));
        assertFalse(cidr.isInRange("::2"));
    }

    @Test(expected = RuntimeException.class)
    public void testNoSlashThrows() throws Exception {
        new Cidr("192.168.1.0");
    }

    @Test(expected = UnknownHostException.class)
    public void testBadIpThrows() throws Exception {
        new Cidr("invalid/24");
    }

    @Test
    public void testEquals() throws Exception {
        Cidr a = new Cidr("192.168.1.0/24");
        Cidr b = new Cidr("192.168.1.128/24");
        // same network range despite different host parts
        assertEquals(a, b);

        Cidr c = new Cidr("192.168.2.0/24");
        assertNotEquals(a, c);
    }

    @Test
    public void testIpv4FullRange() throws Exception {
        Cidr v4 = new Cidr("0.0.0.0/0");
        assertTrue(v4.isInRange("1.2.3.4"));
        assertTrue(v4.isInRange("255.255.255.255"));
    }

    @Test
    public void testToString() throws Exception {
        Cidr cidr = new Cidr("10.0.0.0/8");
        assertEquals("10.0.0.0/8", cidr.toString());
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/ConnectionsRegisterTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;

import androidx.test.core.app.ApplicationProvider;

import com.emanuelef.remote_capture.interfaces.ConnectionsListener;
import com.emanuelef.remote_capture.model.AppStats;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.ConnectionUpdate;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

@RunWith(RobolectricTestRunner.class)
public class ConnectionsRegisterTest {
    static final int MAX_CONNECTIONS = 8;
    ConnectionsRegister reg;
    CaptureService service;
    int incrId = 0;
    ArrayList<String> events = new ArrayList<>();

    @Before
    public void setup() {
        incrId = 0;
        events.clear();

        Context context = ApplicationProvider.getApplicationContext();
        reg = new ConnectionsRegister(context, MAX_CONNECTIONS);

        // Mock CaptureService (needed for processConnectionStatus)
        service = new CaptureService();
        Whitebox.setInternalState(service, "INSTANCE", service);
        Whitebox.setInternalState(service, "conn_reg", reg);
    }

    @After
    public void tearDown() {
        Whitebox.setInternalState(service, "INSTANCE", null);
    }

    private ConnectionDescriptor newConn(int uid) {
        ConnectionDescriptor conn = new ConnectionDescriptor(incrId++, 4, 6,
                "1.1.1.1", "2.2.2.2", "", 51234, 80,
                0, uid, 0, false, 0);
        conn.status = ConnectionDescriptor.CONN_STATUS_CONNECTED;
        conn.l7proto = "";
        return conn;
    }

    @Test
    public void testInsert() {
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000)});
        assertEquals(2, reg.getConnCount());
        assertEquals(0, reg.getUntrackedConnCount());
        assertNotNull(reg.getConn(0));
        assertNotNull(reg.getConn(1));
        assertEquals(0, reg.getConn(0).incr_id);
        assertEquals(1, reg.getConn(1).incr_id);
    }

    @Test
    public void testRollover() {
        // fill to capacity
        ConnectionDescriptor[] conns = new ConnectionDescriptor[MAX_CONNECTIONS];
        for (int i = 0; i < MAX_CONNECTIONS; i++)
            conns[i] = newConn(1000);
        reg.newConnections(conns);
        assertEquals(MAX_CONNECTIONS, reg.getConnCount());

        // add 2 more, causing rollover of first 2
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000)});
        assertEquals(MAX_CONNECTIONS, reg.getConnCount());
        assertEquals(2, reg.getUntrackedConnCount());

        // oldest should be id=2
        assertEquals(2, reg.getConn(0).incr_id);
        // newest should be id=9
        assertEquals(9, reg.getConn(MAX_CONNECTIONS - 1).incr_id);
    }

    @Test
    public void testGetConnById() {
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000), newConn(1000)});

        assertNotNull(reg.getConnById(0));
        assertNotNull(reg.getConnById(2));
        assertNull(reg.getConnById(3));
        assertNull(reg.getConnById(-1));
    }

    @Test
    public void testGetConnPositionById() {
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000), newConn(1000)});

        assertEquals(0, reg.getConnPositionById(0));
        assertEquals(1, reg.getConnPositionById(1));
        assertEquals(2, reg.getConnPositionById(2));
        assertEquals(-1, reg.getConnPositionById(3));
        assertEquals(-1, reg.getConnPositionById(-1));
    }

    @Test
    public void testGetConnPositionAfterRollover() {
        ConnectionDescriptor[] conns = new ConnectionDescriptor[MAX_CONNECTIONS];
        for (int i = 0; i < MAX_CONNECTIONS; i++)
            conns[i] = newConn(1000);
        reg.newConnections(conns);
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000)});

        // first connection is now id=2
        assertEquals(-1, reg.getConnPositionById(0));
        assertEquals(-1, reg.getConnPositionById(1));
        assertEquals(0, reg.getConnPositionById(2));
        assertEquals(7, reg.getConnPositionById(9));
    }

    @Test
    public void testGetConnOutOfBounds() {
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000)});
        assertNull(reg.getConn(-1));
        assertNull(reg.getConn(1));
        assertNotNull(reg.getConn(0));
    }

    @Test
    public void testReset() {
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000)});
        reg.reset();
        assertEquals(0, reg.getConnCount());
        assertEquals(0, reg.getUntrackedConnCount());
        assertNull(reg.getConn(0));
    }

    @Test
    public void testAppStats() {
        reg.newConnections(new ConnectionDescriptor[]{
                newConn(1000), newConn(1000), newConn(2000)
        });

        AppStats stats1000 = reg.getAppStats(1000);
        assertNotNull(stats1000);
        assertEquals(2, stats1000.numConnections);

        AppStats stats2000 = reg.getAppStats(2000);
        assertNotNull(stats2000);
        assertEquals(1, stats2000.numConnections);
    }

    @Test
    public void testAppStatsBytes() {
        ConnectionDescriptor conn = newConn(1000);
        conn.sent_bytes = 100;
        conn.rcvd_bytes = 200;
        reg.newConnections(new ConnectionDescriptor[]{conn});

        AppStats stats = reg.getAppStats(1000);
        assertNotNull(stats);
        assertEquals(100, stats.sentBytes);
        assertEquals(200, stats.rcvdBytes);
    }

    @Test
    public void testConnectionsUpdates() {
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000)});

        ConnectionUpdate update = new ConnectionUpdate(1);
        update.setStats(0, 0, 50, 100, 5, 10,
                0, 0, ConnectionDescriptor.CONN_STATUS_CONNECTED);
        reg.connectionsUpdates(new ConnectionUpdate[]{update});

        ConnectionDescriptor conn = reg.getConnById(1);
        assertNotNull(conn);
        assertEquals(50, conn.sent_bytes);
        assertEquals(100, conn.rcvd_bytes);
        assertEquals(5, conn.sent_pkts);
        assertEquals(10, conn.rcvd_pkts);
    }

    @Test
    public void testConnectionsUpdatesIgnoresUntracked() {
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000)});

        // update for non-existent id should not crash
        ConnectionUpdate update = new ConnectionUpdate(999);
        update.setStats(0, 0, 50, 100, 5, 10,
                0, 0, ConnectionDescriptor.CONN_STATUS_CONNECTED);
        reg.connectionsUpdates(new ConnectionUpdate[]{update});

        // original unchanged
        assertEquals(0, reg.getConn(0).sent_bytes);
    }

    @Test
    public void testBlockedConnectionCounting() {
        ConnectionDescriptor conn = newConn(1000);
        conn.is_blocked = true;
        reg.newConnections(new ConnectionDescriptor[]{conn});

        assertEquals(1, reg.getNumBlockedConnections());
    }

    @Test
    public void testMaxBytes() {
        ConnectionDescriptor c1 = newConn(1000);
        c1.sent_bytes = 100;
        c1.rcvd_bytes = 200;

        ConnectionDescriptor c2 = newConn(1000);
        c2.sent_bytes = 50;
        c2.rcvd_bytes = 50;

        reg.newConnections(new ConnectionDescriptor[]{c1, c2});
        assertEquals(300, reg.getMaxBytes());
    }

    @Test
    public void testListenerNotifications() {
        ConnectionsListener listener = new ConnectionsListener() {
            @Override public void connectionsChanges(int num) { events.add("changes:" + num); }
            @Override public void connectionsAdded(int start, ConnectionDescriptor[] conns) { events.add("added:" + start + ":" + conns.length); }
            @Override public void connectionsRemoved(int start, ConnectionDescriptor[] conns) { events.add("removed:" + start + ":" + conns.length); }
            @Override public void connectionsUpdated(int[] positions) { events.add("updated:" + positions.length); }
        };

        reg.addListener(listener);
        // addListener sends initial sync
        assertEquals(1, events.size());
        assertEquals("changes:0", events.get(0));
        events.clear();

        // add connections
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000)});
        assertEquals(1, events.size());
        assertEquals("added:0:2", events.get(0));
        events.clear();

        // update
        ConnectionUpdate update = new ConnectionUpdate(0);
        update.setStats(0, 0, 10, 10, 1, 1,
                0, 0, ConnectionDescriptor.CONN_STATUS_CONNECTED);
        reg.connectionsUpdates(new ConnectionUpdate[]{update});
        assertEquals(1, events.size());
        assertEquals("updated:1", events.get(0));

        reg.removeListener(listener);
    }

    @Test
    public void testListenerNotificationsOnRollover() {
        ConnectionsListener listener = new ConnectionsListener() {
            @Override public void connectionsChanges(int num) { events.add("changes:" + num); }
            @Override public void connectionsAdded(int start, ConnectionDescriptor[] conns) { events.add("added:" + start + ":" + conns.length); }
            @Override public void connectionsRemoved(int start, ConnectionDescriptor[] conns) { events.add("removed:" + start + ":" + conns.length); }
            @Override public void connectionsUpdated(int[] positions) { events.add("updated:" + positions.length); }
        };

        // fill to capacity
        ConnectionDescriptor[] conns = new ConnectionDescriptor[MAX_CONNECTIONS];
        for (int i = 0; i < MAX_CONNECTIONS; i++)
            conns[i] = newConn(1000);
        reg.newConnections(conns);

        reg.addListener(listener);
        events.clear();

        // add 2 more, causing rollover
        reg.newConnections(new ConnectionDescriptor[]{newConn(1000), newConn(1000)});

        // should get removed then added
        assertTrue(events.size() >= 2);
        assertEquals("removed:0:2", events.get(0));
        assertEquals("added:6:2", events.get(1));

        reg.removeListener(listener);
    }

    @Test
    public void testSeenUids() {
        reg.newConnections(new ConnectionDescriptor[]{
                newConn(1000), newConn(2000), newConn(1000)
        });

        assertEquals(2, reg.getSeenUids().size());
        assertTrue(reg.getSeenUids().contains(1000));
        assertTrue(reg.getSeenUids().contains(2000));
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/FilterDescriptorTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.Status;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.DecryptionStatus;
import com.emanuelef.remote_capture.model.ConnectionDescriptor.FilteringStatus;
import com.emanuelef.remote_capture.model.FilterDescriptor;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

@RunWith(RobolectricTestRunner.class)
public class FilterDescriptorTest {
    FilterDescriptor filter;

    @Before
    public void setup() {
        filter = new FilterDescriptor();
    }

    private ConnectionDescriptor makeConn() {
        ConnectionDescriptor conn = new ConnectionDescriptor(0, 4, 6,
                "1.1.1.1", "2.2.2.2", "", 51234, 80,
                0, 1000, 0, false, 0);
        conn.l7proto = "HTTP";
        conn.status = ConnectionDescriptor.CONN_STATUS_CONNECTED;
        return conn;
    }

    @Test
    public void testInitialState() {
        assertFalse(filter.isSet());
    }

    @Test
    public void testDefaultMatchesEverything() {
        ConnectionDescriptor conn = makeConn();
        assertTrue(filter.matches(conn));
    }

    @Test
    public void testStatusFilterActive() {
        filter.status = Status.STATUS_ACTIVE;
        assertTrue(filter.isSet());

        ConnectionDescriptor active = makeConn();
        active.status = ConnectionDescriptor.CONN_STATUS_CONNECTED;
        assertTrue(filter.matches(active));

        ConnectionDescriptor closed = makeConn();
        closed.status = ConnectionDescriptor.CONN_STATUS_CLOSED;
        assertFalse(filter.matches(closed));
    }

    @Test
    public void testStatusFilterClosed() {
        filter.status = Status.STATUS_CLOSED;

        ConnectionDescriptor closed = makeConn();
        closed.status = ConnectionDescriptor.CONN_STATUS_CLOSED;
        assertTrue(filter.matches(closed));

        ConnectionDescriptor active = makeConn();
        active.status = ConnectionDescriptor.CONN_STATUS_CONNECTED;
        assertFalse(filter.matches(active));
    }

    @Test
    public void testOnlyBlacklisted() {
        filter.onlyBlacklisted = true;
        assertTrue(filter.isSet());

        ConnectionDescriptor conn = makeConn();
        assertFalse(filter.matches(conn));

        // set blacklisted via Whitebox
        Whitebox.setInternalState(conn, "blacklisted_ip", true);
        assertTrue(filter.matches(conn));
    }

    @Test
    public void testOnlyCleartext() {
        filter.onlyCleartext = true;
        assertTrue(filter.isSet());

        ConnectionDescriptor cleartext = makeConn();
        assertTrue(filter.matches(cleartext));

        ConnectionDescriptor encrypted = makeConn();
        Whitebox.setInternalState(encrypted, "encrypted_l7", true);
        assertFalse(filter.matches(encrypted));
    }

    @Test
    public void testFilteringStatusBlocked() {
        filter.filteringStatus = FilteringStatus.BLOCKED;
        assertTrue(filter.isSet());

        ConnectionDescriptor blocked = makeConn();
        blocked.is_blocked = true;
        assertTrue(filter.matches(blocked));

        ConnectionDescriptor allowed = makeConn();
        allowed.is_blocked = false;
        assertFalse(filter.matches(allowed));
    }

    @Test
    public void testFilteringStatusAllowed() {
        filter.filteringStatus = FilteringStatus.ALLOWED;

        ConnectionDescriptor allowed = makeConn();
        allowed.is_blocked = false;
        assertTrue(filter.matches(allowed));

        ConnectionDescriptor blocked = makeConn();
        blocked.is_blocked = true;
        assertFalse(filter.matches(blocked));
    }

    @Test
    public void testUidFilter() {
        filter.uid = 1000;
        assertTrue(filter.isSet());

        ConnectionDescriptor match = makeConn(); // uid=1000
        assertTrue(filter.matches(match));

        ConnectionDescriptor noMatch = new ConnectionDescriptor(1, 4, 6,
                "1.1.1.1", "2.2.2.2", "", 51234, 80,
                0, 2000, 0, false, 0);
        noMatch.l7proto = "HTTP";
        noMatch.status = ConnectionDescriptor.CONN_STATUS_CONNECTED;
        assertFalse(filter.matches(noMatch));
    }

    @Test
    public void testMinSizeFilter() {
        filter.minSize = 100;
        assertTrue(filter.isSet());

        ConnectionDescriptor small = makeConn();
        small.sent_bytes = 10;
        small.rcvd_bytes = 10;
        assertFalse(filter.matches(small));

        ConnectionDescriptor big = makeConn();
        big.sent_bytes = 50;
        big.rcvd_bytes = 60;
        assertTrue(filter.matches(big));
    }

    @Test
    public void testCombinedFilters() {
        filter.status = Status.STATUS_ACTIVE;
        filter.onlyCleartext = true;

        ConnectionDescriptor match = makeConn();
        match.status = ConnectionDescriptor.CONN_STATUS_CONNECTED;
        assertTrue(filter.matches(match));

        ConnectionDescriptor wrongStatus = makeConn();
        wrongStatus.status = ConnectionDescriptor.CONN_STATUS_CLOSED;
        assertFalse(filter.matches(wrongStatus));

        ConnectionDescriptor wrongCleartext = makeConn();
        wrongCleartext.status = ConnectionDescriptor.CONN_STATUS_CONNECTED;
        Whitebox.setInternalState(wrongCleartext, "encrypted_l7", true);
        assertFalse(filter.matches(wrongCleartext));
    }

    @Test
    public void testClear() {
        filter.status = Status.STATUS_ACTIVE;
        filter.onlyBlacklisted = true;
        filter.onlyCleartext = true;
        filter.minSize = 100;
        filter.filteringStatus = FilteringStatus.BLOCKED;
        assertTrue(filter.isSet());

        filter.clear();
        assertFalse(filter.isSet());
    }

    @Test
    public void testClearById() {
        filter.onlyBlacklisted = true;
        filter.clear(R.id.blacklisted);
        assertFalse(filter.onlyBlacklisted);

        filter.onlyCleartext = true;
        filter.clear(R.id.only_cleartext);
        assertFalse(filter.onlyCleartext);

        filter.status = Status.STATUS_ACTIVE;
        filter.clear(R.id.status_ind);
        assertTrue(filter.status == Status.STATUS_INVALID);

        filter.filteringStatus = FilteringStatus.BLOCKED;
        filter.clear(R.id.firewall);
        assertTrue(filter.filteringStatus == FilteringStatus.INVALID);

        filter.iface = "wlan0";
        filter.clear(R.id.capture_interface);
        assertTrue(filter.iface == null);

        filter.showMasked = false;
        filter.clear(R.id.not_hidden);
        assertTrue(filter.showMasked);
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/HTTPReassemblyTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import com.emanuelef.remote_capture.model.PayloadChunk;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.zip.GZIPOutputStream;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

@RunWith(RobolectricTestRunner.class)
public class HTTPReassemblyTest {
    private final ArrayList<PayloadChunk> reassembled = new ArrayList<>();

    private HTTPReassembly newReassembly() {
        reassembled.clear();
        return new HTTPReassembly(true, reassembled::add);
    }

    private PayloadChunk makeChunk(String data, boolean is_sent) {
        return new PayloadChunk(data.getBytes(), PayloadChunk.ChunkType.HTTP, is_sent, 0, 0);
    }

    @Test
    public void testSimpleGetRequest() {
        HTTPReassembly ra = newReassembly();
        ra.handleChunk(makeChunk("GET /index.html?q=1 HTTP/1.1\r\nHost: example.org\r\n\r\n", true));

        assertEquals(1, reassembled.size());
        PayloadChunk c = reassembled.get(0);
        assertEquals("GET", c.httpMethod);
        assertEquals("/index.html", c.httpPath);
        assertEquals("?q=1", c.httpQuery);
        assertEquals("example.org", c.httpHost);
        assertEquals("HTTP/1.1", c.httpVersion);
    }

    @Test
    public void testSimpleResponse() {
        HTTPReassembly ra = newReassembly();
        String body = "Hello";
        String resp = "HTTP/1.1 200 OK\r\nContent-Length: " + body.length() + "\r\n\r\n" + body;
        ra.handleChunk(makeChunk(resp, false));

        assertEquals(1, reassembled.size());
        PayloadChunk c = reassembled.get(0);
        assertEquals(200, c.httpResponseCode);
        assertEquals("OK", c.httpResponseStatus);
        assertEquals("HTTP/1.1", c.httpVersion);
        assertEquals(body.length(), c.httpBodyLength);
    }

    @Test
    public void testResponseNoReasonPhrase() {
        HTTPReassembly ra = newReassembly();
        ra.handleChunk(makeChunk("HTTP/1.1 204\r\n\r\n", false));

        assertEquals(1, reassembled.size());
        assertEquals(204, reassembled.get(0).httpResponseCode);
    }

    @Test
    public void testContentTypeExtraction() {
        HTTPReassembly ra = newReassembly();
        ra.handleChunk(makeChunk("HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\n\r\n", false));

        assertEquals(1, reassembled.size());
        assertEquals("text/html", reassembled.get(0).httpContentType);
    }

    @Test
    public void testHostFromRequestLine() {
        HTTPReassembly ra = newReassembly();
        ra.handleChunk(makeChunk("GET http://proxy.example.com/path HTTP/1.1\r\n\r\n", true));

        assertEquals(1, reassembled.size());
        PayloadChunk c = reassembled.get(0);
        assertEquals("proxy.example.com", c.httpHost);
        assertEquals("/path", c.httpPath);
    }

    @Test
    public void testHostHeaderOverridesRequestLine() {
        HTTPReassembly ra = newReassembly();
        ra.handleChunk(makeChunk("GET /path HTTP/1.1\r\nHost: real.example.com\r\n\r\n", true));

        assertEquals(1, reassembled.size());
        assertEquals("real.example.com", reassembled.get(0).httpHost);
    }

    @Test
    public void testChunkedTransferEncoding() {
        HTTPReassembly ra = newReassembly();
        String data = "HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n" +
                "5\r\nHello\r\n0\r\n\r\n";
        ra.handleChunk(makeChunk(data, false));

        assertEquals(1, reassembled.size());
    }

    @Test
    public void testGzipContentEncoding() throws IOException {
        HTTPReassembly ra = newReassembly();

        String body = "Hello, gzipped world!";
        byte[] compressed;
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
             GZIPOutputStream gos = new GZIPOutputStream(bos)) {
            gos.write(body.getBytes());
            gos.finish();
            compressed = bos.toByteArray();
        }

        String headers = "HTTP/1.1 200 OK\r\nContent-Encoding: gzip\r\nContent-Length: "
                + compressed.length + "\r\n\r\n";
        byte[] headersBytes = headers.getBytes();
        byte[] full = new byte[headersBytes.length + compressed.length];
        System.arraycopy(headersBytes, 0, full, 0, headersBytes.length);
        System.arraycopy(compressed, 0, full, headersBytes.length, compressed.length);

        ra.handleChunk(new PayloadChunk(full, PayloadChunk.ChunkType.HTTP, false, 0, 0));

        assertEquals(1, reassembled.size());
        String payload = new String(reassembled.get(0).payload);
        assertTrue(payload.contains(body));
    }

    @Test
    public void testZstdContentEncoding() {
        HTTPReassembly ra = newReassembly();

        // real zstd-compressed response from jsonplaceholder.typicode.com
        byte[] compressed = new byte[] {
            0x28, (byte)0xb5, 0x2f, (byte)0xfd, 0x00, 0x58, 0x25, 0x02,
            0x00, 0x42, 0x44, 0x0e, 0x14, (byte)0xa0, (byte)0xb5, 0x39,
            0x47, 0x20, (byte)0xb9, (byte)0xab, 0x33, 0x47, (byte)0xd7, 0x49,
            (byte)0xf0, (byte)0xf6, (byte)0xbd, (byte)0xdd, 0x14, 0x12, 0x55, (byte)0xc2,
            0x60, 0x01, (byte)0xe2, 0x65, (byte)0x86, 0x60, 0x29, (byte)0xf2,
            0x6d, (byte)0x86, 0x2a, 0x4e, (byte)0x95, 0x7f, (byte)0x86, 0x3f,
            (byte)0xc3, 0x75, 0x3f, 0x36, (byte)0xa3, (byte)0xb2, (byte)0xd4, (byte)0xf6,
            (byte)0xf4, 0x54, (byte)0x92, 0x04, 0x02, 0x4b, (byte)0xd1, 0x70,
            0x78, 0x5d, 0x49, 0x02, 0x08, 0x02, 0x00, 0x3c,
            0x25, 0x5c, 0x6f, (byte)0x85, 0x09
        };

        String headers = "HTTP/1.1 200 OK\r\nContent-Encoding: zstd\r\nContent-Length: "
                + compressed.length + "\r\n\r\n";
        byte[] headersBytes = headers.getBytes();
        byte[] full = new byte[headersBytes.length + compressed.length];
        System.arraycopy(headersBytes, 0, full, 0, headersBytes.length);
        System.arraycopy(compressed, 0, full, headersBytes.length, compressed.length);

        ra.handleChunk(new PayloadChunk(full, PayloadChunk.ChunkType.HTTP, false, 0, 0));

        assertEquals(1, reassembled.size());
        String payload = new String(reassembled.get(0).payload);
        assertTrue(payload.contains("delectus aut autem"));
    }

    @Test
    public void testWebSocketUpgrade() {
        HTTPReassembly ra = newReassembly();
        ra.handleChunk(makeChunk("HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\n\r\n", false));

        assertEquals(1, reassembled.size());
        assertEquals(101, reassembled.get(0).httpResponseCode);

        reassembled.clear();
        PayloadChunk wsChunk = makeChunk("websocket data", false);
        ra.handleChunk(wsChunk);
        assertEquals(PayloadChunk.ChunkType.WEBSOCKET, wsChunk.type);
        // no reassembled output because the raw bytes aren't a valid WebSocket frame
        assertEquals(0, reassembled.size());
    }

    @Test
    public void testNonHttpDetection() {
        HTTPReassembly ra = newReassembly();

        // feed data larger than MAX_HEADERS_SIZE (1024) without \r\n\r\n
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1100; i++)
            sb.append('X');
        byte[] data = sb.toString().getBytes();

        ra.handleChunk(new PayloadChunk(data, PayloadChunk.ChunkType.HTTP, true, 0, 0));

        assertEquals(1, reassembled.size());
        assertEquals(PayloadChunk.ChunkType.RAW, reassembled.get(0).type);
    }

    @Test
    public void testHeadersSplitAcrossChunks() {
        HTTPReassembly ra = newReassembly();

        // first chunk: partial headers (no \r\n\r\n yet)
        ra.handleChunk(makeChunk("GET /path HTTP/1.1\r\n", true));
        assertEquals(0, reassembled.size());

        // second chunk: remaining headers + end marker in same chunk
        ra.handleChunk(makeChunk("Host: example.org\r\n\r\n", true));
        assertEquals(1, reassembled.size());
        assertEquals("/path", reassembled.get(0).httpPath);
    }

    @Test
    public void testSequentialRequestResponse() {
        HTTPReassembly txRa = newReassembly();

        // first request
        txRa.handleChunk(makeChunk("GET /first HTTP/1.1\r\nHost: a.com\r\n\r\n", true));
        assertEquals(1, reassembled.size());
        assertEquals("/first", reassembled.get(0).httpPath);

        // second request on same reassembly (reset happens automatically)
        txRa.handleChunk(makeChunk("POST /second HTTP/1.1\r\nHost: b.com\r\n\r\n", true));
        assertEquals(2, reassembled.size());
        assertEquals("POST", reassembled.get(1).httpMethod);
        assertEquals("/second", reassembled.get(1).httpPath);
    }

    @Test
    public void testRequestWithBody() {
        HTTPReassembly ra = newReassembly();
        String body = "{\"key\":\"value\"}";
        String req = "POST /api HTTP/1.1\r\nHost: api.example.com\r\n" +
                "Content-Length: " + body.length() + "\r\n" +
                "Content-Type: application/json\r\n\r\n" + body;
        ra.handleChunk(makeChunk(req, true));

        assertEquals(1, reassembled.size());
        PayloadChunk c = reassembled.get(0);
        assertEquals("POST", c.httpMethod);
        assertEquals("/api", c.httpPath);
        assertEquals("application/json", c.httpContentType);
        assertEquals(body.length(), c.httpBodyLength);
        assertTrue(new String(c.payload).contains(body));
    }

    @Test
    public void testNoReassemblyMode() {
        reassembled.clear();
        HTTPReassembly ra = new HTTPReassembly(false, reassembled::add);

        ra.handleChunk(makeChunk("GET /path HTTP/1.1\r\nHost: example.org\r\n\r\nbody", true));
        // in non-reassembly mode, each chunk is passed through
        assertFalse(reassembled.isEmpty());
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/HarWriterTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;
import android.content.SharedPreferences;
import androidx.preference.PreferenceManager;

import androidx.test.core.app.ApplicationProvider;

import com.emanuelef.remote_capture.model.CaptureSettings;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.PayloadChunk;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import android.util.Base64;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.GZIPOutputStream;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

@RunWith(RobolectricTestRunner.class)
public class HarWriterTest {
    private Context context;
    private CaptureService service;
    private HttpLog httpLog;

    @Before
    public void setup() {
        context = ApplicationProvider.getApplicationContext();
        httpLog = new HttpLog();

        // Mock CaptureService
        service = new CaptureService();
        Whitebox.setInternalState(service, "INSTANCE", service);
        Whitebox.setInternalState(service, "mHttpLog", httpLog);

        // Create mock settings with full payload mode
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
        CaptureSettings settings = new CaptureSettings(context, prefs);
        settings.full_payload = true;
        Whitebox.setInternalState(service, "mSettings", settings);
    }

    @After
    public void tearDown() {
        Whitebox.setInternalState(service, "INSTANCE", null);
    }

    /**
     * Create a ConnectionDescriptor for testing
     */
    private ConnectionDescriptor createConnection(int incrId, String dstIp, int dstPort) {
        return new ConnectionDescriptor(incrId, 4, 6,
                "192.168.1.100", dstIp, "US",
                54321, dstPort, 0, 1000, 0, false, System.currentTimeMillis());
    }

    /**
     * Create a PayloadChunk with HTTP data
     */
    private PayloadChunk createHttpChunk(String httpText, boolean isSent, long timestamp) {
        byte[] payload = httpText.getBytes(StandardCharsets.UTF_8);
        return new PayloadChunk(payload, PayloadChunk.ChunkType.HTTP, isSent, timestamp, 0);
    }

    /**
     * Add a payload chunk directly to the connection without triggering HTTP logging.
     * This allows us to control test data precisely.
     */
    @SuppressWarnings("unchecked")
    private void addChunkDirect(ConnectionDescriptor conn, PayloadChunk chunk) {
        try {
            java.lang.reflect.Field field = ConnectionDescriptor.class.getDeclaredField("payload_chunks");
            field.setAccessible(true);
            java.util.ArrayList<PayloadChunk> chunks = (java.util.ArrayList<PayloadChunk>) field.get(conn);
            synchronized (conn) {
                chunks.add(chunk);
            }

            if (chunk.type == PayloadChunk.ChunkType.WEBSOCKET) {
                java.lang.reflect.Field wsField = ConnectionDescriptor.class.getDeclaredField("has_websocket_data");
                wsField.setAccessible(true);
                wsField.setBoolean(conn, true);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to add chunk directly", e);
        }
    }

    private List<HttpLog.HttpRequest> getHttpLogRequests(HttpLog log) {
        List<HttpLog.HttpRequest> requests = new ArrayList<>();
        for (int i = 0; i < log.getSize(); i++) {
            HttpLog.HttpRequest req = log.getRequest(i);
            if (req != null)
                requests.add(req);
        }
        return requests;
    }

    /**
     * Write HAR to string using HarWriter
     */
    private String writeHarToString() throws IOException {
        HarWriter writer = new HarWriter(context, getHttpLogRequests(httpLog));
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        writer.write(out);
        return out.toString(StandardCharsets.UTF_8.name());
    }

    /**
     * Parse HAR JSON and return the root object
     */
    private JsonObject parseHar(String harJson) {
        return JsonParser.parseString(harJson).getAsJsonObject();
    }

    @Test
    public void testBasicHarStructure() throws IOException {
        // Create a simple HTTP request/response
        ConnectionDescriptor conn = createConnection(1, "93.184.216.34", 80);
        conn.info = "example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /index.html HTTP/1.1\r\n" +
                "Host: example.com\r\n" +
                "User-Agent: TestAgent/1.0\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: text/html\r\n" +
                "Content-Length: 13\r\n" +
                "\r\n" +
                "Hello, World!";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 100;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "example.com";
        httpReq.path = "/index.html";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "text/html";
        httpReply.bodyLength = 13;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        // Write HAR
        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);

        // Verify basic structure
        assertTrue("HAR should have 'log' object", har.has("log"));
        JsonObject log = har.getAsJsonObject("log");

        // Verify version
        assertEquals("1.2", log.get("version").getAsString());

        // Verify creator
        assertTrue("log should have 'creator' object", log.has("creator"));
        JsonObject creator = log.getAsJsonObject("creator");
        assertEquals("PCAPdroid", creator.get("name").getAsString());
        assertNotNull("creator should have version", creator.get("version"));

        // Verify entries array exists
        assertTrue("log should have 'entries' array", log.has("entries"));
        JsonArray entries = log.getAsJsonArray("entries");
        assertEquals(1, entries.size());

        JsonObject harEntry = entries.get(0).getAsJsonObject();

        // Verify serverIPAddress
        assertEquals("93.184.216.34", harEntry.get("serverIPAddress").getAsString());

        // Verify connection ID
        assertEquals("1", harEntry.get("connection").getAsString());

        // Verify cache object exists
        assertTrue("entry should have 'cache' object", harEntry.has("cache"));
        JsonObject cache = harEntry.getAsJsonObject("cache");
        assertNotNull("cache object should not be null", cache);

        // Verify startedDateTime
        assertTrue("entry should have 'startedDateTime'", harEntry.has("startedDateTime"));
        String startedDateTime = harEntry.get("startedDateTime").getAsString();
        assertNotNull("startedDateTime should not be null", startedDateTime);
        assertTrue("startedDateTime should contain 'T'", startedDateTime.contains("T"));
    }

    @Test
    public void testRequestFields() throws IOException {
        ConnectionDescriptor conn = createConnection(2, "10.0.0.1", 8080);
        conn.info = "api.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /api/users?page=1&limit=10 HTTP/1.1\r\n" +
                "Host: api.example.com\r\n" +
                "Accept: application/json\r\n" +
                "Cookie: session=abc123; user=john\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: application/json\r\n" +
                "\r\n" +
                "[]";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "api.example.com";
        httpReq.path = "/api/users";
        httpReq.query = "?page=1&limit=10";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "application/json";
        httpReply.bodyLength = 2;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");

        // Verify request method
        assertEquals("GET", request.get("method").getAsString());

        // Verify URL
        String url = request.get("url").getAsString();
        assertTrue("URL should contain host", url.contains("api.example.com"));
        assertTrue("URL should contain path", url.contains("/api/users"));

        // Verify HTTP version
        assertEquals("HTTP/1.1", request.get("httpVersion").getAsString());

        // Verify headers
        JsonArray headers = request.getAsJsonArray("headers");
        assertNotNull("headers should not be null", headers);
        assertTrue("should have headers", headers.size() > 0);

        // Check for Host header
        boolean hasHost = false;
        for (int i = 0; i < headers.size(); i++) {
            JsonObject header = headers.get(i).getAsJsonObject();
            if (header.get("name").getAsString().equals("Host")) {
                assertEquals("api.example.com", header.get("value").getAsString());
                hasHost = true;
            }
        }
        assertTrue("should have Host header", hasHost);

        // Verify query string
        JsonArray queryString = request.getAsJsonArray("queryString");
        assertNotNull("queryString should not be null", queryString);
        assertEquals(2, queryString.size());

        // Verify query parameters
        boolean hasPage = false, hasLimit = false;
        for (int i = 0; i < queryString.size(); i++) {
            JsonObject param = queryString.get(i).getAsJsonObject();
            String name = param.get("name").getAsString();
            String value = param.get("value").getAsString();
            if (name.equals("page") && value.equals("1")) hasPage = true;
            if (name.equals("limit") && value.equals("10")) hasLimit = true;
        }
        assertTrue("should have 'page' query param", hasPage);
        assertTrue("should have 'limit' query param", hasLimit);

        // Verify cookies
        JsonArray cookies = request.getAsJsonArray("cookies");
        assertNotNull("cookies should not be null", cookies);
        assertEquals(2, cookies.size());

        boolean hasSession = false, hasUser = false;
        for (int i = 0; i < cookies.size(); i++) {
            JsonObject cookie = cookies.get(i).getAsJsonObject();
            String name = cookie.get("name").getAsString();
            String value = cookie.get("value").getAsString();
            if (name.equals("session") && value.equals("abc123")) hasSession = true;
            if (name.equals("user") && value.equals("john")) hasUser = true;
        }
        assertTrue("should have 'session' cookie", hasSession);
        assertTrue("should have 'user' cookie", hasUser);

        // Verify headersSize and bodySize
        assertTrue("headersSize should be > 0", request.get("headersSize").getAsInt() > 0);
        assertEquals(0, request.get("bodySize").getAsInt());
    }

    @Test
    public void testResponseFields() throws IOException {
        ConnectionDescriptor conn = createConnection(3, "203.0.113.50", 443);
        conn.info = "secure.example.com";
        conn.l7proto = "TLS.HTTP";

        String httpRequest = "GET /secure HTTP/1.1\r\n" +
                "Host: secure.example.com\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 301 Moved Permanently\r\n" +
                "Content-Type: text/html\r\n" +
                "Location: https://secure.example.com/new-path\r\n" +
                "Set-Cookie: tracking=xyz789; Path=/; HttpOnly; Secure\r\n" +
                "\r\n" +
                "<html>Redirecting...</html>";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 75;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "secure.example.com";
        httpReq.path = "/secure";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 301;
        httpReply.responseStatus = "Moved Permanently";
        httpReply.contentType = "text/html";
        httpReply.bodyLength = 27;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");

        // Verify status
        assertEquals(301, response.get("status").getAsInt());
        assertEquals("Moved Permanently", response.get("statusText").getAsString());

        // Verify HTTP version
        assertEquals("HTTP/1.1", response.get("httpVersion").getAsString());

        // Verify redirect URL
        assertEquals("https://secure.example.com/new-path", response.get("redirectURL").getAsString());

        // Verify response headers
        JsonArray headers = response.getAsJsonArray("headers");
        assertNotNull("response headers should not be null", headers);
        assertTrue("should have response headers", headers.size() > 0);

        // Check Location header
        boolean hasLocation = false;
        for (int i = 0; i < headers.size(); i++) {
            JsonObject header = headers.get(i).getAsJsonObject();
            if (header.get("name").getAsString().equals("Location")) {
                assertEquals("https://secure.example.com/new-path", header.get("value").getAsString());
                hasLocation = true;
            }
        }
        assertTrue("should have Location header", hasLocation);

        // Verify response cookies (Set-Cookie parsing)
        JsonArray cookies = response.getAsJsonArray("cookies");
        assertNotNull("response cookies should not be null", cookies);
        assertEquals(1, cookies.size());

        JsonObject cookie = cookies.get(0).getAsJsonObject();
        assertEquals("tracking", cookie.get("name").getAsString());
        assertEquals("xyz789", cookie.get("value").getAsString());
        assertEquals("/", cookie.get("path").getAsString());
        assertTrue("cookie should be httpOnly", cookie.get("httpOnly").getAsBoolean());
        assertTrue("cookie should be secure", cookie.get("secure").getAsBoolean());

        // Verify content
        JsonObject content = response.getAsJsonObject("content");
        assertNotNull("content should not be null", content);
        assertEquals(27, content.get("size").getAsInt());
        assertEquals("text/html", content.get("mimeType").getAsString());

        // Verify headersSize and bodySize
        assertTrue("response headersSize should be > 0", response.get("headersSize").getAsInt() > 0);
        assertEquals(27, response.get("bodySize").getAsInt());
    }

    @Test
    public void testPostRequestWithBody() throws IOException {
        ConnectionDescriptor conn = createConnection(4, "10.0.0.2", 80);
        conn.info = "api.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "POST /api/login HTTP/1.1\r\n" +
                "Host: api.example.com\r\n" +
                "Content-Type: application/x-www-form-urlencoded\r\n" +
                "Content-Length: 30\r\n" +
                "\r\n" +
                "username=admin&password=secret";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: application/json\r\n" +
                "\r\n" +
                "{\"success\":true}";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 100;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "POST";
        httpReq.host = "api.example.com";
        httpReq.path = "/api/login";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 30;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "application/json";
        httpReply.bodyLength = 16;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");

        // Verify method
        assertEquals("POST", request.get("method").getAsString());

        // Verify postData
        assertTrue("POST request should have postData", request.has("postData"));
        JsonObject postData = request.getAsJsonObject("postData");

        assertEquals("application/x-www-form-urlencoded", postData.get("mimeType").getAsString());
        String text = postData.get("text").getAsString();
        // Verify the exact POST body is extracted
        assertEquals("username=admin&password=secret", text);

        // Verify bodySize
        assertEquals(30, request.get("bodySize").getAsInt());
    }

    @Test
    public void testNoResponseEntry() throws IOException {
        // Test entry where no response was received
        ConnectionDescriptor conn = createConnection(8, "10.0.0.5", 80);
        conn.info = "timeout.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /timeout HTTP/1.1\r\n" +
                "Host: timeout.example.com\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        addChunkDirect(conn, reqChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "timeout.example.com";
        httpReq.path = "/timeout";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;
        // No reply set

        httpLog.addHttpRequest(httpReq);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");

        // Verify response with no actual data
        assertEquals(0, response.get("status").getAsInt());
        assertEquals("", response.get("statusText").getAsString());
        assertEquals(-1, response.get("headersSize").getAsInt());
        assertEquals(-1, response.get("bodySize").getAsInt());
        assertEquals("", response.get("redirectURL").getAsString());
    }

    @Test
    public void testMultipleEntries() throws IOException {
        // Test with multiple HTTP requests
        for (int i = 0; i < 3; i++) {
            ConnectionDescriptor conn = createConnection(10 + i, "10.0.0." + (10 + i), 80);
            conn.info = "multi" + i + ".example.com";
            conn.l7proto = "HTTP";

            String httpRequest = "GET /page" + i + " HTTP/1.1\r\n" +
                    "Host: multi" + i + ".example.com\r\n" +
                    "\r\n";

            String httpResponse = "HTTP/1.1 200 OK\r\n" +
                    "Content-Type: text/plain\r\n" +
                    "\r\n" +
                    "page" + i;

            long reqTimestamp = System.currentTimeMillis() + i * 100;
            long respTimestamp = reqTimestamp + 50;

            PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
            PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

            addChunkDirect(conn, reqChunk);
            addChunkDirect(conn, respChunk);

            HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
            httpReq.method = "GET";
            httpReq.host = "multi" + i + ".example.com";
            httpReq.path = "/page" + i;
            httpReq.query = "";
            httpReq.timestamp = reqTimestamp;
            httpReq.bodyLength = 0;

            HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
            httpReply.responseCode = 200;
            httpReply.responseStatus = "OK";
            httpReply.contentType = "text/plain";
            httpReply.bodyLength = 5;
            httpReq.reply = httpReply;

            httpLog.addHttpRequest(httpReq);
            httpLog.addHttpReply(httpReply);
        }

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonArray entries = har.getAsJsonObject("log").getAsJsonArray("entries");

        // Verify we have 3 entries
        assertEquals(3, entries.size());

        // Verify each entry has the expected path
        for (int i = 0; i < 3; i++) {
            JsonObject entry = entries.get(i).getAsJsonObject();
            JsonObject request = entry.getAsJsonObject("request");
            String url = request.get("url").getAsString();
            assertTrue("Entry " + i + " should have correct path", url.contains("/page" + i));
        }
    }

    @Test
    public void testBinaryContentEncoding() throws IOException {
        ConnectionDescriptor conn = createConnection(13, "10.0.0.9", 80);
        conn.info = "binary.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /image.png HTTP/1.1\r\n" +
                "Host: binary.example.com\r\n" +
                "\r\n";

        // Create a response with binary content (non-printable bytes)
        String httpResponseHeaders = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: image/png\r\n" +
                "\r\n";
        byte[] headerBytes = httpResponseHeaders.getBytes(StandardCharsets.UTF_8);
        byte[] binaryBody = new byte[] {(byte)0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A}; // PNG signature
        byte[] fullResponse = new byte[headerBytes.length + binaryBody.length];
        System.arraycopy(headerBytes, 0, fullResponse, 0, headerBytes.length);
        System.arraycopy(binaryBody, 0, fullResponse, headerBytes.length, binaryBody.length);

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 100;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = new PayloadChunk(fullResponse, PayloadChunk.ChunkType.HTTP, false, respTimestamp, 0);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "binary.example.com";
        httpReq.path = "/image.png";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "image/png";
        httpReply.bodyLength = binaryBody.length;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");
        JsonObject content = response.getAsJsonObject("content");

        // Verify binary content is base64 encoded
        assertEquals("image/png", content.get("mimeType").getAsString());
        assertTrue("binary content should have encoding field", content.has("encoding"));
        assertEquals("base64", content.get("encoding").getAsString());

        // Verify the actual base64 text matches the binary body
        assertTrue("content should have text field", content.has("text"));
        String base64Text = content.get("text").getAsString();
        byte[] decoded = Base64.decode(base64Text, Base64.NO_WRAP);
        assertEquals("decoded length should match binary body", binaryBody.length, decoded.length);
        for (int i = 0; i < binaryBody.length; i++) {
            assertEquals("byte " + i + " should match", binaryBody[i], decoded[i]);
        }
    }

    @Test
    public void testTextContentExtraction() throws IOException {
        ConnectionDescriptor conn = createConnection(14, "10.0.0.10", 80);
        conn.info = "text.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /data.json HTTP/1.1\r\n" +
                "Host: text.example.com\r\n" +
                "\r\n";

        String responseBody = "{\"name\":\"test\",\"value\":123}";
        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: application/json\r\n" +
                "Content-Length: " + responseBody.length() + "\r\n" +
                "\r\n" +
                responseBody;

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "text.example.com";
        httpReq.path = "/data.json";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "application/json";
        httpReply.bodyLength = responseBody.length();
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");
        JsonObject content = response.getAsJsonObject("content");

        // Verify text content is NOT base64 encoded
        assertEquals("application/json", content.get("mimeType").getAsString());
        assertFalse("text content should NOT have encoding field", content.has("encoding"));

        // Verify the actual text content matches the response body
        assertTrue("content should have text field", content.has("text"));
        String textContent = content.get("text").getAsString();
        assertEquals("text content should match response body", responseBody, textContent);
    }

    @Test
    public void testGzipCompressedContent() throws IOException {
        ConnectionDescriptor conn = createConnection(15, "10.0.0.11", 80);
        conn.info = "gzip.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /app.js HTTP/1.1\r\n" +
                "Host: gzip.example.com\r\n" +
                "Accept-Encoding: gzip\r\n" +
                "\r\n";

        // Original JavaScript content
        String originalJs = "function hello() { console.log('Hello, World!'); }";

        // Gzip compress the JavaScript
        ByteArrayOutputStream gzipOut = new ByteArrayOutputStream();
        try (GZIPOutputStream gzos = new GZIPOutputStream(gzipOut)) {
            gzos.write(originalJs.getBytes(StandardCharsets.UTF_8));
        }
        byte[] gzippedBody = gzipOut.toByteArray();

        // Build HTTP response with gzipped content
        String httpResponseHeaders = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: application/javascript\r\n" +
                "Content-Encoding: gzip\r\n" +
                "Content-Length: " + gzippedBody.length + "\r\n" +
                "\r\n";
        byte[] headerBytes = httpResponseHeaders.getBytes(StandardCharsets.UTF_8);
        byte[] fullResponse = new byte[headerBytes.length + gzippedBody.length];
        System.arraycopy(headerBytes, 0, fullResponse, 0, headerBytes.length);
        System.arraycopy(gzippedBody, 0, fullResponse, headerBytes.length, gzippedBody.length);

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = new PayloadChunk(fullResponse, PayloadChunk.ChunkType.HTTP, false, respTimestamp, 0);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "gzip.example.com";
        httpReq.path = "/app.js";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "application/javascript";
        httpReply.bodyLength = gzippedBody.length;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");
        JsonObject content = response.getAsJsonObject("content");

        // Verify content type
        assertEquals("application/javascript", content.get("mimeType").getAsString());

        // Since the data is now decompressed before being written to HAR,
        // the content should be plain text (not base64 encoded)
        assertFalse("decompressed text content should NOT have encoding field", content.has("encoding"));

        // Verify the actual content is the original JavaScript (decompressed)
        assertTrue("content should have text field", content.has("text"));
        String textContent = content.get("text").getAsString();
        assertEquals("content should match original JavaScript", originalJs, textContent);
    }

    @Test
    public void testWebSocketMessages() throws IOException {
        ConnectionDescriptor conn = createConnection(20, "10.0.0.20", 80);
        conn.info = "ws.example.com";
        conn.l7proto = "HTTP";

        // HTTP upgrade request/response
        String httpRequest = "GET /websocket HTTP/1.1\r\n" +
                "Host: ws.example.com\r\n" +
                "Upgrade: websocket\r\n" +
                "Connection: Upgrade\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 101 Switching Protocols\r\n" +
                "Upgrade: websocket\r\n" +
                "Connection: Upgrade\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        // Add WebSocket text message (sent)
        byte[] wsTextPayload = "Hello WebSocket".getBytes(StandardCharsets.UTF_8);
        PayloadChunk wsSend = new PayloadChunk(wsTextPayload, PayloadChunk.ChunkType.WEBSOCKET, true, respTimestamp + 100, 0);
        addChunkDirect(conn, wsSend);

        // Add WebSocket text message (received)
        byte[] wsTextPayload2 = "Hello from server".getBytes(StandardCharsets.UTF_8);
        PayloadChunk wsRecv = new PayloadChunk(wsTextPayload2, PayloadChunk.ChunkType.WEBSOCKET, false, respTimestamp + 200, 0);
        addChunkDirect(conn, wsRecv);

        // Add WebSocket binary message
        byte[] wsBinaryPayload = new byte[] {(byte)0x89, 0x50, 0x4E, 0x47}; // Binary data
        PayloadChunk wsBinary = new PayloadChunk(wsBinaryPayload, PayloadChunk.ChunkType.WEBSOCKET, false, respTimestamp + 300, 0);
        addChunkDirect(conn, wsBinary);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "ws.example.com";
        httpReq.path = "/websocket";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 101;
        httpReply.responseStatus = "Switching Protocols";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();

        // Verify WebSocket resource type
        assertTrue("entry should have _resourceType", entry.has("_resourceType"));
        assertEquals("websocket", entry.get("_resourceType").getAsString());

        // Verify WebSocket messages array
        assertTrue("entry should have _webSocketMessages", entry.has("_webSocketMessages"));
        JsonArray wsMessages = entry.getAsJsonArray("_webSocketMessages");
        assertEquals(3, wsMessages.size());

        // Verify first message (text, sent)
        JsonObject msg1 = wsMessages.get(0).getAsJsonObject();
        assertEquals("send", msg1.get("type").getAsString());
        assertEquals(1, msg1.get("opcode").getAsInt()); // Text
        assertEquals("Hello WebSocket", msg1.get("data").getAsString());

        // Verify second message (text, received)
        JsonObject msg2 = wsMessages.get(1).getAsJsonObject();
        assertEquals("receive", msg2.get("type").getAsString());
        assertEquals(1, msg2.get("opcode").getAsInt()); // Text
        assertEquals("Hello from server", msg2.get("data").getAsString());

        // Verify third message (binary, received)
        JsonObject msg3 = wsMessages.get(2).getAsJsonObject();
        assertEquals("receive", msg3.get("type").getAsString());
        assertEquals(2, msg3.get("opcode").getAsInt()); // Binary
        // Binary data should be base64 encoded
        assertNotNull(msg3.get("data").getAsString());
    }

    @Test
    public void testWebSocketEmptyPayload() throws IOException {
        ConnectionDescriptor conn = createConnection(21, "10.0.0.21", 80);
        conn.info = "ws.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /ws HTTP/1.1\r\n" +
                "Host: ws.example.com\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 101 Switching Protocols\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        // Add WebSocket message with empty payload
        PayloadChunk wsEmpty = new PayloadChunk(new byte[0], PayloadChunk.ChunkType.WEBSOCKET, true, respTimestamp + 100, 0);
        addChunkDirect(conn, wsEmpty);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "ws.example.com";
        httpReq.path = "/ws";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 101;
        httpReply.responseStatus = "Switching Protocols";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();

        JsonArray wsMessages = entry.getAsJsonArray("_webSocketMessages");
        assertEquals(1, wsMessages.size());

        JsonObject msg = wsMessages.get(0).getAsJsonObject();
        assertEquals("", msg.get("data").getAsString()); // Empty payload
    }

    @Test
    public void testHttpRstHandling() throws IOException {
        ConnectionDescriptor conn = createConnection(22, "10.0.0.22", 80);
        conn.info = "rst.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /reset HTTP/1.1\r\n" +
                "Host: rst.example.com\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: text/plain\r\n" +
                "\r\n" +
                "data";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "rst.example.com";
        httpReq.path = "/reset";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;
        httpReq.httpRst = true; // HTTP RST flag

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "text/plain";
        httpReply.bodyLength = 4;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");

        // When httpRst is true, response should be empty like no-response case
        assertEquals(0, response.get("status").getAsInt());
        assertEquals("", response.get("statusText").getAsString());
        assertEquals(-1, response.get("headersSize").getAsInt());
        assertEquals(-1, response.get("bodySize").getAsInt());
        assertEquals("", response.get("redirectURL").getAsString());
    }

    @Test
    public void testPutAndPatchMethodsWithBody() throws IOException {
        // Test that PUT and PATCH methods include postData (like POST)
        String[] methods = {"PUT", "PATCH"};
        String[] bodies = {"{\"name\":\"updated\"}", "{\"field\":\"new\"}"};

        for (int i = 0; i < methods.length; i++) {
            httpLog = new HttpLog(); // Reset for each iteration

            ConnectionDescriptor conn = createConnection(23 + i, "10.0.0." + (23 + i), 80);
            conn.info = "api.example.com";
            conn.l7proto = "HTTP";

            String body = bodies[i];
            String httpRequest = methods[i] + " /api/resource/1 HTTP/1.1\r\n" +
                    "Host: api.example.com\r\n" +
                    "Content-Type: application/json\r\n" +
                    "Content-Length: " + body.length() + "\r\n" +
                    "\r\n" +
                    body;

            String httpResponse = "HTTP/1.1 200 OK\r\n" +
                    "Content-Type: application/json\r\n" +
                    "\r\n" +
                    "{}";

            long reqTimestamp = System.currentTimeMillis();
            long respTimestamp = reqTimestamp + 100;

            PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
            PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

            addChunkDirect(conn, reqChunk);
            addChunkDirect(conn, respChunk);

            HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
            httpReq.method = methods[i];
            httpReq.host = "api.example.com";
            httpReq.path = "/api/resource/1";
            httpReq.query = "";
            httpReq.timestamp = reqTimestamp;
            httpReq.bodyLength = body.length();

            HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
            httpReply.responseCode = 200;
            httpReply.responseStatus = "OK";
            httpReply.contentType = "application/json";
            httpReply.bodyLength = 2;
            httpReq.reply = httpReply;

            httpLog.addHttpRequest(httpReq);
            httpLog.addHttpReply(httpReply);

            HarWriter writer = new HarWriter(context, getHttpLogRequests(httpLog));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            writer.write(out);
            String harJson = out.toString(StandardCharsets.UTF_8.name());
            JsonObject har = parseHar(harJson);
            JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
            JsonObject request = entry.getAsJsonObject("request");

            assertEquals(methods[i], request.get("method").getAsString());
            assertTrue(methods[i] + " request should have postData", request.has("postData"));
            JsonObject postData = request.getAsJsonObject("postData");
            assertEquals("application/json", postData.get("mimeType").getAsString());
            assertEquals(body, postData.get("text").getAsString());
        }
    }

    @Test
    public void testNullFieldsFallbacks() throws IOException {
        // Test that null fields fall back to appropriate defaults
        ConnectionDescriptor conn = createConnection(25, "10.0.0.25", 80);
        conn.info = "null.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /path HTTP/1.1\r\n" +
                "Host: null.example.com\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "\r\n" +
                "OK";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = null; // Null method
        httpReq.host = "null.example.com";
        httpReq.path = "/path";
        httpReq.query = null; // Null query
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = null; // Null response status
        httpReply.contentType = null; // Null content type
        httpReply.bodyLength = 2;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonObject response = entry.getAsJsonObject("response");
        JsonObject content = response.getAsJsonObject("content");

        // Verify null fallbacks
        assertEquals("method should fallback to empty", "", request.get("method").getAsString());
        assertTrue("null query should result in empty queryString", request.getAsJsonArray("queryString").isEmpty());
        assertEquals("statusText should fallback to empty", "", response.get("statusText").getAsString());
        assertEquals("null contentType should fallback to octet-stream", "application/octet-stream", content.get("mimeType").getAsString());
    }

    @Test
    public void testMissingChunks() throws IOException {
        // Test missing request chunk
        ConnectionDescriptor conn1 = createConnection(26, "10.0.0.26", 80);
        conn1.info = "nochunk.example.com";
        conn1.l7proto = "HTTP";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: text/plain\r\n" +
                "\r\n" +
                "OK";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);
        addChunkDirect(conn1, respChunk);

        HttpLog.HttpRequest httpReq1 = new HttpLog.HttpRequest(conn1, 0);
        httpReq1.method = "GET";
        httpReq1.host = "nochunk.example.com";
        httpReq1.path = "/path";
        httpReq1.query = "";
        httpReq1.timestamp = reqTimestamp;
        httpReq1.bodyLength = 0;

        HttpLog.HttpReply httpReply1 = new HttpLog.HttpReply(httpReq1, 0);
        httpReply1.responseCode = 200;
        httpReply1.responseStatus = "OK";
        httpReply1.contentType = "text/plain";
        httpReply1.bodyLength = 2;
        httpReq1.reply = httpReply1;

        httpLog.addHttpRequest(httpReq1);
        httpLog.addHttpReply(httpReply1);

        // Test missing response chunk
        ConnectionDescriptor conn2 = createConnection(29, "10.0.0.29", 80);
        conn2.info = "missing.example.com";
        conn2.l7proto = "HTTP";

        String httpRequest = "GET /path HTTP/1.1\r\n" +
                "Host: missing.example.com\r\n" +
                "\r\n";

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        addChunkDirect(conn2, reqChunk);

        HttpLog.HttpRequest httpReq2 = new HttpLog.HttpRequest(conn2, 0);
        httpReq2.method = "GET";
        httpReq2.host = "missing.example.com";
        httpReq2.path = "/path";
        httpReq2.query = "";
        httpReq2.timestamp = reqTimestamp;
        httpReq2.bodyLength = 0;

        HttpLog.HttpReply httpReply2 = new HttpLog.HttpReply(httpReq2, 5); // Invalid chunk position
        httpReply2.responseCode = 200;
        httpReply2.responseStatus = "OK";
        httpReply2.contentType = "text/plain";
        httpReply2.bodyLength = 10;
        httpReq2.reply = httpReply2;

        httpLog.addHttpRequest(httpReq2);
        httpLog.addHttpReply(httpReply2);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonArray entries = har.getAsJsonObject("log").getAsJsonArray("entries");

        // Verify missing request chunk defaults
        JsonObject entry1 = entries.get(0).getAsJsonObject();
        JsonObject request1 = entry1.getAsJsonObject("request");
        assertEquals("HTTP/1.1", request1.get("httpVersion").getAsString());
        assertEquals(-1, request1.get("headersSize").getAsInt());
        assertTrue(request1.getAsJsonArray("headers").isEmpty());

        // Verify missing response chunk defaults
        JsonObject entry2 = entries.get(1).getAsJsonObject();
        JsonObject response2 = entry2.getAsJsonObject("response");
        assertEquals("HTTP/1.1", response2.get("httpVersion").getAsString());
        assertEquals(-1, response2.get("headersSize").getAsInt());
        assertTrue(response2.getAsJsonArray("headers").isEmpty());
        assertFalse("content should NOT have text when chunk is missing",
                entry2.getAsJsonObject("response").getAsJsonObject("content").has("text"));
    }

    @Test
    public void testRedirectURLNotFound() throws IOException {
        // Response without Location header should have empty redirectURL
        ConnectionDescriptor conn = createConnection(30, "10.0.0.30", 80);
        conn.info = "noredirect.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /path HTTP/1.1\r\n" +
                "Host: noredirect.example.com\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: text/plain\r\n" +
                "\r\n" +
                "OK";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "noredirect.example.com";
        httpReq.path = "/path";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "text/plain";
        httpReply.bodyLength = 2;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject harEntry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = harEntry.getAsJsonObject("response");

        assertEquals("", response.get("redirectURL").getAsString());
    }

    @Test
    public void testEmptyResponseBody() throws IOException {
        ConnectionDescriptor conn = createConnection(31, "10.0.0.31", 80);
        conn.info = "empty.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /empty HTTP/1.1\r\n" +
                "Host: empty.example.com\r\n" +
                "\r\n";

        // Response with no body (just headers)
        String httpResponse = "HTTP/1.1 204 No Content\r\n" +
                "Content-Length: 0\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "empty.example.com";
        httpReq.path = "/empty";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 204;
        httpReply.responseStatus = "No Content";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");
        JsonObject content = response.getAsJsonObject("content");

        // When body is empty, no text or encoding fields should be added
        assertFalse("content should NOT have text when body is empty", content.has("text"));
        assertFalse("content should NOT have encoding when body is empty", content.has("encoding"));
    }

    @Test
    public void testNullContentTypeInPostData() throws IOException {
        ConnectionDescriptor conn = createConnection(32, "10.0.0.32", 80);
        conn.info = "post.example.com";
        conn.l7proto = "HTTP";

        // POST request without Content-Type header
        String httpRequest = "POST /submit HTTP/1.1\r\n" +
                "Host: post.example.com\r\n" +
                "Content-Length: 11\r\n" +
                "\r\n" +
                "raw content";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "POST";
        httpReq.host = "post.example.com";
        httpReq.path = "/submit";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 11;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonObject postData = request.getAsJsonObject("postData");

        assertEquals("", postData.get("mimeType").getAsString()); // Fallback to ""
    }

    @Test
    public void testQueryParamWithoutValue() throws IOException {
        ConnectionDescriptor conn = createConnection(34, "10.0.0.34", 80);
        conn.info = "query.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /path?flag&key=value&another HTTP/1.1\r\n" +
                "Host: query.example.com\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "query.example.com";
        httpReq.path = "/path";
        httpReq.query = "?flag&key=value&another"; // Params without '='
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonArray queryString = request.getAsJsonArray("queryString");

        assertEquals(3, queryString.size());

        // First param: flag (no value)
        JsonObject param1 = queryString.get(0).getAsJsonObject();
        assertEquals("flag", param1.get("name").getAsString());
        assertEquals("", param1.get("value").getAsString());

        // Second param: key=value
        JsonObject param2 = queryString.get(1).getAsJsonObject();
        assertEquals("key", param2.get("name").getAsString());
        assertEquals("value", param2.get("value").getAsString());

        // Third param: another (no value)
        JsonObject param3 = queryString.get(2).getAsJsonObject();
        assertEquals("another", param3.get("name").getAsString());
        assertEquals("", param3.get("value").getAsString());
    }

    @Test
    public void testMalformedUrlEncoding() throws IOException {
        ConnectionDescriptor conn = createConnection(35, "10.0.0.35", 80);
        conn.info = "query.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /path?valid=ok&bad=%ZZ&good=yes HTTP/1.1\r\n" +
                "Host: query.example.com\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "query.example.com";
        httpReq.path = "/path";
        httpReq.query = "?valid=ok&bad=%ZZ&good=yes"; // Invalid %ZZ encoding
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonArray queryString = request.getAsJsonArray("queryString");

        // Only valid params should be present (malformed one skipped)
        assertEquals(2, queryString.size());
    }

    @Test
    public void testInvalidRequestCookie() throws IOException {
        ConnectionDescriptor conn = createConnection(36, "10.0.0.36", 80);
        conn.info = "cookie.example.com";
        conn.l7proto = "HTTP";

        // Cookie with invalid format (no '=')
        String httpRequest = "GET /path HTTP/1.1\r\n" +
                "Host: cookie.example.com\r\n" +
                "Cookie: valid=value; invalid; another=ok\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "cookie.example.com";
        httpReq.path = "/path";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonArray cookies = request.getAsJsonArray("cookies");

        // Only valid cookies should be present
        assertEquals(2, cookies.size());
    }

    @Test
    public void testInvalidSetCookie() throws IOException {
        ConnectionDescriptor conn = createConnection(37, "10.0.0.37", 80);
        conn.info = "cookie.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /path HTTP/1.1\r\n" +
                "Host: cookie.example.com\r\n" +
                "\r\n";

        // Set-Cookie with invalid format (no '=' in name=value part)
        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Set-Cookie: invalidcookie; Path=/\r\n" +
                "Set-Cookie: valid=ok; Path=/\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "cookie.example.com";
        httpReq.path = "/path";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");
        JsonArray cookies = response.getAsJsonArray("cookies");

        // Only valid cookie should be present
        assertEquals(1, cookies.size());
        assertEquals("valid", cookies.get(0).getAsJsonObject().get("name").getAsString());
    }

    @Test
    public void testSetCookieAllAttributes() throws IOException {
        ConnectionDescriptor conn = createConnection(38, "10.0.0.38", 80);
        conn.info = "cookie.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /path HTTP/1.1\r\n" +
                "Host: cookie.example.com\r\n" +
                "\r\n";

        // Set-Cookie with all attributes
        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Set-Cookie: session=abc123; Path=/app; Domain=.example.com; HttpOnly; Secure; SameSite=Lax; Expires=Wed, 09 Jun 2027 10:18:14 GMT\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "cookie.example.com";
        httpReq.path = "/path";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");
        JsonArray cookies = response.getAsJsonArray("cookies");

        assertEquals(1, cookies.size());
        JsonObject cookie = cookies.get(0).getAsJsonObject();
        assertEquals("session", cookie.get("name").getAsString());
        assertEquals("abc123", cookie.get("value").getAsString());
        assertEquals("/app", cookie.get("path").getAsString());
        assertEquals(".example.com", cookie.get("domain").getAsString());
        assertTrue(cookie.get("httpOnly").getAsBoolean());
        assertTrue(cookie.get("secure").getAsBoolean());
        assertEquals("Lax", cookie.get("sameSite").getAsString());
        assertEquals("2027-06-09T10:18:14Z", cookie.get("expires").getAsString());
    }

    @Test
    public void testEmptyHttpText() throws IOException {
        ConnectionDescriptor conn = createConnection(39, "10.0.0.39", 80);
        conn.info = "empty.example.com";
        conn.l7proto = "HTTP";

        // Empty request chunk payload
        PayloadChunk reqChunk = new PayloadChunk(new byte[0], PayloadChunk.ChunkType.HTTP, true, System.currentTimeMillis(), 0);
        PayloadChunk respChunk = new PayloadChunk(new byte[0], PayloadChunk.ChunkType.HTTP, false, System.currentTimeMillis() + 50, 0);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "empty.example.com";
        httpReq.path = "/path";
        httpReq.query = "";
        httpReq.timestamp = System.currentTimeMillis();
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonObject response = entry.getAsJsonObject("response");

        // With empty payload, defaults should be used
        assertEquals("HTTP/1.1", request.get("httpVersion").getAsString());
        assertEquals("HTTP/1.1", response.get("httpVersion").getAsString());
    }

    @Test
    public void testMalformedHttpLines() throws IOException {
        // Test malformed request line (no space/HTTP version)
        ConnectionDescriptor conn1 = createConnection(40, "10.0.0.40", 80);
        conn1.info = "malformed.example.com";
        conn1.l7proto = "HTTP";

        String httpRequest1 = "GET/path\r\n" +
                "Host: malformed.example.com\r\n" +
                "\r\n";
        String httpResponse1 = "HTTP/1.1 200 OK\r\n\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        addChunkDirect(conn1, createHttpChunk(httpRequest1, true, reqTimestamp));
        addChunkDirect(conn1, createHttpChunk(httpResponse1, false, respTimestamp));

        HttpLog.HttpRequest httpReq1 = new HttpLog.HttpRequest(conn1, 0);
        httpReq1.method = "GET";
        httpReq1.host = "malformed.example.com";
        httpReq1.path = "/path";
        httpReq1.query = "";
        httpReq1.timestamp = reqTimestamp;
        httpReq1.bodyLength = 0;

        HttpLog.HttpReply httpReply1 = new HttpLog.HttpReply(httpReq1, 1);
        httpReply1.responseCode = 200;
        httpReply1.responseStatus = "OK";
        httpReply1.contentType = "";
        httpReply1.bodyLength = 0;
        httpReq1.reply = httpReply1;

        httpLog.addHttpRequest(httpReq1);
        httpLog.addHttpReply(httpReply1);

        // Test malformed response line (no space)
        ConnectionDescriptor conn2 = createConnection(41, "10.0.0.41", 80);
        conn2.info = "malformed.example.com";
        conn2.l7proto = "HTTP";

        String httpRequest2 = "GET /path HTTP/1.1\r\n" +
                "Host: malformed.example.com\r\n" +
                "\r\n";
        String httpResponse2 = "200OK\r\n\r\n";

        addChunkDirect(conn2, createHttpChunk(httpRequest2, true, reqTimestamp));
        addChunkDirect(conn2, createHttpChunk(httpResponse2, false, respTimestamp));

        HttpLog.HttpRequest httpReq2 = new HttpLog.HttpRequest(conn2, 0);
        httpReq2.method = "GET";
        httpReq2.host = "malformed.example.com";
        httpReq2.path = "/path";
        httpReq2.query = "";
        httpReq2.timestamp = reqTimestamp;
        httpReq2.bodyLength = 0;

        HttpLog.HttpReply httpReply2 = new HttpLog.HttpReply(httpReq2, 1);
        httpReply2.responseCode = 200;
        httpReply2.responseStatus = "OK";
        httpReply2.contentType = "";
        httpReply2.bodyLength = 0;
        httpReq2.reply = httpReply2;

        httpLog.addHttpRequest(httpReq2);
        httpLog.addHttpReply(httpReply2);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonArray entries = har.getAsJsonObject("log").getAsJsonArray("entries");

        // Both should default to HTTP/1.1 for malformed lines
        JsonObject entry1 = entries.get(0).getAsJsonObject();
        assertEquals("HTTP/1.1", entry1.getAsJsonObject("request").get("httpVersion").getAsString());

        JsonObject entry2 = entries.get(1).getAsJsonObject();
        assertEquals("HTTP/1.1", entry2.getAsJsonObject("response").get("httpVersion").getAsString());
    }

    @Test
    public void testInvalidHeaders() throws IOException {
        ConnectionDescriptor conn = createConnection(42, "10.0.0.42", 80);
        conn.info = "header.example.com";
        conn.l7proto = "HTTP";

        // Request with invalid headers (missing colon, colon at position 0)
        String httpRequest = "GET /path HTTP/1.1\r\n" +
                "Valid-Header: value\r\n" +
                "InvalidHeaderNoColon\r\n" +
                ":InvalidColonAtStart\r\n" +
                "Another-Valid: ok\r\n" +
                "\r\n";

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "header.example.com";
        httpReq.path = "/path";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonArray headers = request.getAsJsonArray("headers");

        // Only valid headers should be present (invalid ones skipped)
        assertEquals(2, headers.size());

        boolean hasValid = false, hasAnother = false;
        for (int i = 0; i < headers.size(); i++) {
            String name = headers.get(i).getAsJsonObject().get("name").getAsString();
            if (name.equals("Valid-Header")) hasValid = true;
            if (name.equals("Another-Valid")) hasAnother = true;
        }
        assertTrue("Should have Valid-Header", hasValid);
        assertTrue("Should have Another-Valid", hasAnother);
    }

    @Test
    public void testXmlContentType() throws IOException {
        ConnectionDescriptor conn = createConnection(43, "10.0.0.43", 80);
        conn.info = "xml.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /data.xml HTTP/1.1\r\n" +
                "Host: xml.example.com\r\n" +
                "\r\n";

        String xmlBody = "<?xml version=\"1.0\"?><root><item>value</item></root>";
        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: application/xml\r\n" +
                "\r\n" +
                xmlBody;

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "xml.example.com";
        httpReq.path = "/data.xml";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "application/xml";
        httpReply.bodyLength = xmlBody.length();
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");
        JsonObject content = response.getAsJsonObject("content");

        // XML is text content, should not be base64 encoded
        assertFalse("xml content should NOT have encoding", content.has("encoding"));
        assertEquals(xmlBody, content.get("text").getAsString());
    }

    @Test
    public void testBinaryContentTypesAreBase64Encoded() throws IOException {
        // Test that audio, video, and octet-stream content types result in base64 encoding
        String[] contentTypes = {"audio/mpeg", "video/mp4", "application/octet-stream"};
        byte[] binaryData = new byte[] {0x01, 0x02, 0x03, 0x04};

        for (int i = 0; i < contentTypes.length; i++) {
            httpLog = new HttpLog(); // Reset for each iteration

            ConnectionDescriptor conn = createConnection(44 + i, "10.0.0." + (44 + i), 80);
            conn.info = "binary.example.com";
            conn.l7proto = "HTTP";

            String httpRequest = "GET /file HTTP/1.1\r\n" +
                    "Host: binary.example.com\r\n" +
                    "\r\n";

            String httpResponseHeaders = "HTTP/1.1 200 OK\r\n" +
                    "Content-Type: " + contentTypes[i] + "\r\n" +
                    "\r\n";
            byte[] headerBytes = httpResponseHeaders.getBytes(StandardCharsets.UTF_8);
            byte[] fullResponse = new byte[headerBytes.length + binaryData.length];
            System.arraycopy(headerBytes, 0, fullResponse, 0, headerBytes.length);
            System.arraycopy(binaryData, 0, fullResponse, headerBytes.length, binaryData.length);

            long reqTimestamp = System.currentTimeMillis();
            long respTimestamp = reqTimestamp + 50;

            PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
            PayloadChunk respChunk = new PayloadChunk(fullResponse, PayloadChunk.ChunkType.HTTP, false, respTimestamp, 0);

            addChunkDirect(conn, reqChunk);
            addChunkDirect(conn, respChunk);

            HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
            httpReq.method = "GET";
            httpReq.host = "binary.example.com";
            httpReq.path = "/file";
            httpReq.query = "";
            httpReq.timestamp = reqTimestamp;
            httpReq.bodyLength = 0;

            HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
            httpReply.responseCode = 200;
            httpReply.responseStatus = "OK";
            httpReply.contentType = contentTypes[i];
            httpReply.bodyLength = binaryData.length;
            httpReq.reply = httpReply;

            httpLog.addHttpRequest(httpReq);
            httpLog.addHttpReply(httpReply);

            HarWriter writer = new HarWriter(context, getHttpLogRequests(httpLog));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            writer.write(out);
            String harJson = out.toString(StandardCharsets.UTF_8.name());
            JsonObject har = parseHar(harJson);
            JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
            JsonObject response = entry.getAsJsonObject("response");
            JsonObject content = response.getAsJsonObject("content");

            assertTrue(contentTypes[i] + " content should have encoding", content.has("encoding"));
            assertEquals("base64", content.get("encoding").getAsString());
        }
    }

    @Test
    public void testByteBasedContentDetection() throws IOException {
        // Test text detection: printable bytes with null content type
        ConnectionDescriptor conn1 = createConnection(47, "10.0.0.47", 80);
        conn1.info = "detect.example.com";
        conn1.l7proto = "HTTP";

        String textBody = "This is plain text content";
        String httpResponse1 = "HTTP/1.1 200 OK\r\n\r\n" + textBody;

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        String httpRequest = "GET /data HTTP/1.1\r\n" +
                "Host: detect.example.com\r\n" +
                "\r\n";

        addChunkDirect(conn1, createHttpChunk(httpRequest, true, reqTimestamp));
        addChunkDirect(conn1, createHttpChunk(httpResponse1, false, respTimestamp));

        HttpLog.HttpRequest httpReq1 = new HttpLog.HttpRequest(conn1, 0);
        httpReq1.method = "GET";
        httpReq1.host = "detect.example.com";
        httpReq1.path = "/data";
        httpReq1.query = "";
        httpReq1.timestamp = reqTimestamp;
        httpReq1.bodyLength = 0;

        HttpLog.HttpReply httpReply1 = new HttpLog.HttpReply(httpReq1, 1);
        httpReply1.responseCode = 200;
        httpReply1.responseStatus = "OK";
        httpReply1.contentType = null; // Forces byte-based detection
        httpReply1.bodyLength = textBody.length();
        httpReq1.reply = httpReply1;

        httpLog.addHttpRequest(httpReq1);
        httpLog.addHttpReply(httpReply1);

        // Test binary detection: non-printable bytes with null content type
        ConnectionDescriptor conn2 = createConnection(48, "10.0.0.48", 80);
        conn2.info = "detect.example.com";
        conn2.l7proto = "HTTP";

        byte[] binaryData = new byte[] {(byte)0x00, (byte)0x01, (byte)0xFF, (byte)0xFE};
        String httpResponseHeaders = "HTTP/1.1 200 OK\r\n\r\n";
        byte[] headerBytes = httpResponseHeaders.getBytes(StandardCharsets.UTF_8);
        byte[] fullResponse = new byte[headerBytes.length + binaryData.length];
        System.arraycopy(headerBytes, 0, fullResponse, 0, headerBytes.length);
        System.arraycopy(binaryData, 0, fullResponse, headerBytes.length, binaryData.length);

        addChunkDirect(conn2, createHttpChunk(httpRequest, true, reqTimestamp));
        addChunkDirect(conn2, new PayloadChunk(fullResponse, PayloadChunk.ChunkType.HTTP, false, respTimestamp, 0));

        HttpLog.HttpRequest httpReq2 = new HttpLog.HttpRequest(conn2, 0);
        httpReq2.method = "GET";
        httpReq2.host = "detect.example.com";
        httpReq2.path = "/data";
        httpReq2.query = "";
        httpReq2.timestamp = reqTimestamp;
        httpReq2.bodyLength = 0;

        HttpLog.HttpReply httpReply2 = new HttpLog.HttpReply(httpReq2, 1);
        httpReply2.responseCode = 200;
        httpReply2.responseStatus = "OK";
        httpReply2.contentType = null; // Forces byte-based detection
        httpReply2.bodyLength = binaryData.length;
        httpReq2.reply = httpReply2;

        httpLog.addHttpRequest(httpReq2);
        httpLog.addHttpReply(httpReply2);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonArray entries = har.getAsJsonObject("log").getAsJsonArray("entries");

        // Verify text detection (first entry)
        JsonObject content1 = entries.get(0).getAsJsonObject().getAsJsonObject("response").getAsJsonObject("content");
        assertFalse("text-detected content should NOT have encoding", content1.has("encoding"));
        assertEquals(textBody, content1.get("text").getAsString());

        // Verify binary detection (second entry)
        JsonObject content2 = entries.get(1).getAsJsonObject().getAsJsonObject("response").getAsJsonObject("content");
        assertTrue("binary-detected content should have encoding", content2.has("encoding"));
        assertEquals("base64", content2.get("encoding").getAsString());
    }

    @Test
    public void testEntryTimeWithMissingReplyChunk() throws IOException {
        ConnectionDescriptor conn = createConnection(50, "10.0.0.50", 80);
        conn.info = "time.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /path HTTP/1.1\r\n" +
                "Host: time.example.com\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        addChunkDirect(conn, reqChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "time.example.com";
        httpReq.path = "/path";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 10); // Invalid chunk position
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();

        // With missing reply chunk, time should be -1
        assertEquals(-1, entry.get("time").getAsInt());
    }

    @Test
    public void testPostWithMissingChunk() throws IOException {
        ConnectionDescriptor conn = createConnection(51, "10.0.0.51", 80);
        conn.info = "post.example.com";
        conn.l7proto = "HTTP";

        // Don't add request chunk
        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "\r\n";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 5); // Invalid chunk position
        httpReq.method = "POST";
        httpReq.host = "post.example.com";
        httpReq.path = "/submit";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 100;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 0);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "";
        httpReply.bodyLength = 0;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");

        // POST should have postData even with missing chunk
        assertTrue("POST should have postData", request.has("postData"));
        JsonObject postData = request.getAsJsonObject("postData");
        assertEquals("", postData.get("mimeType").getAsString());
        // text field should not be present when chunk is missing
        assertFalse("postData should NOT have text when chunk is missing", postData.has("text"));
    }

    @Test
    public void testMimeTypeWithCharset() throws IOException {
        ConnectionDescriptor conn = createConnection(53, "10.0.0.53", 80);
        conn.info = "charset.example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /page HTTP/1.1\r\n" +
                "Host: charset.example.com\r\n" +
                "\r\n";

        String htmlBody = "<html><body>Hello</body></html>";
        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: text/html; charset=utf-8\r\n" +
                "\r\n" +
                htmlBody;

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "charset.example.com";
        httpReq.path = "/page";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "text/html; charset=utf-8"; // With charset
        httpReply.bodyLength = htmlBody.length();
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject response = entry.getAsJsonObject("response");
        JsonObject content = response.getAsJsonObject("content");

        // MimeType should include the full content-type with charset
        assertEquals("text/html; charset=utf-8", content.get("mimeType").getAsString());

        // Content should be detected as text (not base64)
        assertFalse("text/html with charset should NOT have encoding", content.has("encoding"));
        assertEquals(htmlBody, content.get("text").getAsString());
    }

    @Test
    public void testPostDataMimeTypeWithCharset() throws IOException {
        ConnectionDescriptor conn = createConnection(54, "10.0.0.54", 80);
        conn.info = "form.example.com";
        conn.l7proto = "HTTP";

        String postBody = "name=test&value=123";
        String httpRequest = "POST /submit HTTP/1.1\r\n" +
                "Host: form.example.com\r\n" +
                "Content-Type: application/x-www-form-urlencoded; charset=utf-8\r\n" +
                "Content-Length: " + postBody.length() + "\r\n" +
                "\r\n" +
                postBody;

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: application/json\r\n" +
                "\r\n" +
                "{}";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "POST";
        httpReq.host = "form.example.com";
        httpReq.path = "/submit";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = postBody.length();

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "application/json";
        httpReply.bodyLength = 2;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonObject postData = request.getAsJsonObject("postData");

        // PostData mimeType should include the full content-type with charset
        assertEquals("application/x-www-form-urlencoded; charset=utf-8", postData.get("mimeType").getAsString());
        assertEquals(postBody, postData.get("text").getAsString());
    }

    @Test
    public void testMimeTypeCaseInsensitive() throws IOException {
        ConnectionDescriptor conn = createConnection(55, "10.0.0.55", 80);
        conn.info = "case.example.com";
        conn.l7proto = "HTTP";

        String jsonBody = "{\"test\": true}";
        String httpRequest = "POST /api HTTP/1.1\r\n" +
                "Host: case.example.com\r\n" +
                "CONTENT-TYPE: APPLICATION/JSON\r\n" + // Uppercase header
                "Content-Length: " + jsonBody.length() + "\r\n" +
                "\r\n" +
                jsonBody;

        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "content-type: TEXT/PLAIN\r\n" + // Lowercase header name, uppercase value
                "\r\n" +
                "OK";

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 50;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "POST";
        httpReq.host = "case.example.com";
        httpReq.path = "/api";
        httpReq.query = "";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = jsonBody.length();

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "TEXT/PLAIN"; // Uppercase
        httpReply.bodyLength = 2;
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();
        JsonObject har = parseHar(harJson);
        JsonObject entry = har.getAsJsonObject("log").getAsJsonArray("entries").get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        JsonObject response = entry.getAsJsonObject("response");

        // PostData mimeType should be found with case-insensitive header lookup
        JsonObject postData = request.getAsJsonObject("postData");
        assertEquals("APPLICATION/JSON", postData.get("mimeType").getAsString());

        // Response mimeType
        JsonObject content = response.getAsJsonObject("content");
        assertEquals("TEXT/PLAIN", content.get("mimeType").getAsString());
    }

    @Test
    public void testHtmlEntitiesNotEscaped() throws IOException {
        // Create a connection with HTML content containing special characters
        ConnectionDescriptor conn = createConnection(1, "93.184.216.34", 80);
        conn.info = "example.com";
        conn.l7proto = "HTTP";

        String httpRequest = "GET /page?foo=1&bar=2 HTTP/1.1\r\n" +
                "Host: example.com\r\n" +
                "\r\n";

        String htmlBody = "<html><body>Hello & goodbye</body></html>";
        String httpResponse = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: text/html\r\n" +
                "Content-Length: " + htmlBody.length() + "\r\n" +
                "\r\n" +
                htmlBody;

        long reqTimestamp = System.currentTimeMillis();
        long respTimestamp = reqTimestamp + 100;

        PayloadChunk reqChunk = createHttpChunk(httpRequest, true, reqTimestamp);
        PayloadChunk respChunk = createHttpChunk(httpResponse, false, respTimestamp);

        addChunkDirect(conn, reqChunk);
        addChunkDirect(conn, respChunk);

        HttpLog.HttpRequest httpReq = new HttpLog.HttpRequest(conn, 0);
        httpReq.method = "GET";
        httpReq.host = "example.com";
        httpReq.path = "/page";
        httpReq.query = "foo=1&bar=2";
        httpReq.timestamp = reqTimestamp;
        httpReq.bodyLength = 0;

        HttpLog.HttpReply httpReply = new HttpLog.HttpReply(httpReq, 1);
        httpReply.responseCode = 200;
        httpReply.responseStatus = "OK";
        httpReply.contentType = "text/html";
        httpReply.bodyLength = htmlBody.length();
        httpReq.reply = httpReply;

        httpLog.addHttpRequest(httpReq);
        httpLog.addHttpReply(httpReply);

        String harJson = writeHarToString();

        // Verify that HTML entities are NOT escaped (disableHtmlEscaping is working)
        // Without disableHtmlEscaping, Gson would convert:
        //   < to \u003c
        //   > to \u003e
        //   & to \u0026
        //   = to \u003d
        assertFalse("HTML entities should not be escaped: \\u003c found",
                harJson.contains("\\u003c"));
        assertFalse("HTML entities should not be escaped: \\u003e found",
                harJson.contains("\\u003e"));
        assertFalse("HTML entities should not be escaped: \\u0026 found",
                harJson.contains("\\u0026"));
        assertFalse("HTML entities should not be escaped: \\u003d found",
                harJson.contains("\\u003d"));

        // Verify the actual characters are present
        assertTrue("Should contain literal < character", harJson.contains("<html>"));
        assertTrue("Should contain literal > character", harJson.contains("</html>"));
        assertTrue("Should contain literal & character", harJson.contains("&bar"));
        assertTrue("Should contain literal = in query", harJson.contains("foo=1"));
    }

    @Test
    public void testSingleRequestExport() throws IOException {
        // Create two HTTP requests to verify that only the specified one is exported
        ConnectionDescriptor conn1 = createConnection(1, "93.184.216.34", 80);
        conn1.info = "example1.com";
        conn1.l7proto = "HTTP";

        ConnectionDescriptor conn2 = createConnection(2, "93.184.216.35", 80);
        conn2.info = "example2.com";
        conn2.l7proto = "HTTP";

        String httpRequest1 = "GET /first HTTP/1.1\r\n" +
                "Host: example1.com\r\n" +
                "\r\n";

        String httpResponse1 = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: text/plain\r\n" +
                "\r\n" +
                "First response";

        String httpRequest2 = "GET /second HTTP/1.1\r\n" +
                "Host: example2.com\r\n" +
                "\r\n";

        String httpResponse2 = "HTTP/1.1 200 OK\r\n" +
                "Content-Type: text/plain\r\n" +
                "\r\n" +
                "Second response";

        long reqTimestamp1 = System.currentTimeMillis();
        long respTimestamp1 = reqTimestamp1 + 50;
        long reqTimestamp2 = reqTimestamp1 + 100;
        long respTimestamp2 = reqTimestamp2 + 50;

        // Add chunks for first request
        PayloadChunk reqChunk1 = createHttpChunk(httpRequest1, true, reqTimestamp1);
        PayloadChunk respChunk1 = createHttpChunk(httpResponse1, false, respTimestamp1);
        addChunkDirect(conn1, reqChunk1);
        addChunkDirect(conn1, respChunk1);

        // Add chunks for second request
        PayloadChunk reqChunk2 = createHttpChunk(httpRequest2, true, reqTimestamp2);
        PayloadChunk respChunk2 = createHttpChunk(httpResponse2, false, respTimestamp2);
        addChunkDirect(conn2, reqChunk2);
        addChunkDirect(conn2, respChunk2);

        // Create first HTTP request
        HttpLog.HttpRequest httpReq1 = new HttpLog.HttpRequest(conn1, 0);
        httpReq1.method = "GET";
        httpReq1.host = "example1.com";
        httpReq1.path = "/first";
        httpReq1.query = "";
        httpReq1.timestamp = reqTimestamp1;
        httpReq1.bodyLength = 0;

        HttpLog.HttpReply httpReply1 = new HttpLog.HttpReply(httpReq1, 1);
        httpReply1.responseCode = 200;
        httpReply1.responseStatus = "OK";
        httpReply1.contentType = "text/plain";
        httpReply1.bodyLength = 14;
        httpReq1.reply = httpReply1;

        // Create second HTTP request
        HttpLog.HttpRequest httpReq2 = new HttpLog.HttpRequest(conn2, 0);
        httpReq2.method = "GET";
        httpReq2.host = "example2.com";
        httpReq2.path = "/second";
        httpReq2.query = "";
        httpReq2.timestamp = reqTimestamp2;
        httpReq2.bodyLength = 0;

        HttpLog.HttpReply httpReply2 = new HttpLog.HttpReply(httpReq2, 1);
        httpReply2.responseCode = 200;
        httpReply2.responseStatus = "OK";
        httpReply2.contentType = "text/plain";
        httpReply2.bodyLength = 15;
        httpReq2.reply = httpReply2;

        // Add both requests to the HTTP log
        httpLog.addHttpRequest(httpReq1);
        httpLog.addHttpReply(httpReply1);
        httpLog.addHttpRequest(httpReq2);
        httpLog.addHttpReply(httpReply2);

        // Export only the second request using single request constructor
        HarWriter singleWriter = new HarWriter(context, httpReq2);
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        singleWriter.write(out);
        String harJson = out.toString(StandardCharsets.UTF_8.name());
        JsonObject har = parseHar(harJson);

        // Verify basic structure
        assertTrue("HAR should have 'log' object", har.has("log"));
        JsonObject log = har.getAsJsonObject("log");
        assertEquals("1.2", log.get("version").getAsString());

        // Verify only one entry is present
        JsonArray entries = log.getAsJsonArray("entries");
        assertEquals("Should have exactly one entry", 1, entries.size());

        // Verify it's the second request
        JsonObject entry = entries.get(0).getAsJsonObject();
        JsonObject request = entry.getAsJsonObject("request");
        String url = request.get("url").getAsString();
        assertTrue("URL should contain example2.com", url.contains("example2.com"));
        assertTrue("URL should contain /second", url.contains("/second"));
        assertFalse("URL should NOT contain example1.com", url.contains("example1.com"));
        assertFalse("URL should NOT contain /first", url.contains("/first"));

        // Verify response content
        JsonObject response = entry.getAsJsonObject("response");
        assertEquals(200, response.get("status").getAsInt());
        JsonObject content = response.getAsJsonObject("content");
        assertEquals("text/plain", content.get("mimeType").getAsString());
        assertEquals("Second response", content.get("text").getAsString());

        // Verify the full log still has both requests
        String fullHarJson = writeHarToString();
        JsonObject fullHar = parseHar(fullHarJson);
        JsonArray fullEntries = fullHar.getAsJsonObject("log").getAsJsonArray("entries");
        assertEquals("Full log should have 2 entries", 2, fullEntries.size());
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/HttpLogFilterDescriptorTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.HttpLogFilterDescriptor;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

@RunWith(RobolectricTestRunner.class)
public class HttpLogFilterDescriptorTest {
    HttpLogFilterDescriptor filter;
    ConnectionDescriptor conn;

    @Before
    public void setup() {
        filter = new HttpLogFilterDescriptor();
        conn = new ConnectionDescriptor(0, 4, 6,
                "1.1.1.1", "2.2.2.2", "", 51234, 443,
                0, -1, 0, false, 0);
        conn.l7proto = "TLS";
    }

    private HttpLog.HttpRequest makeRequest(String method) {
        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        req.method = method;
        req.host = "example.org";
        req.path = "/path";
        return req;
    }

    private HttpLog.HttpReply makeReply(HttpLog.HttpRequest req, int code, String contentType, int bodyLength) {
        HttpLog.HttpReply reply = new HttpLog.HttpReply(req, 1);
        reply.responseCode = code;
        reply.contentType = contentType;
        reply.bodyLength = bodyLength;
        req.reply = reply;
        return reply;
    }

    @Test
    public void testInitialState() {
        assertFalse(filter.isSet());
    }

    @Test
    public void testMethodFilter() {
        HttpLog.HttpRequest req = makeRequest("GET");
        filter.method = "GET";
        assertTrue(filter.isSet());
        assertTrue(filter.matches(req));

        filter.method = "POST";
        assertFalse(filter.matches(req));

        // case insensitive
        filter.method = "get";
        assertTrue(filter.matches(req));
    }

    @Test
    public void testContentTypeFilter() {
        HttpLog.HttpRequest req = makeRequest("GET");
        makeReply(req, 200, "text/html", 100);

        filter.contentType = "text/html";
        assertTrue(filter.matches(req));

        filter.contentType = "application/json";
        assertFalse(filter.matches(req));
    }

    @Test
    public void testContentTypeFilterNoReply() {
        HttpLog.HttpRequest req = makeRequest("GET");
        filter.contentType = "text/html";
        assertFalse(filter.matches(req));
    }

    @Test
    public void testHttpStatusFilter() {
        HttpLog.HttpRequest req = makeRequest("GET");
        makeReply(req, 200, "text/html", 100);

        filter.httpStatus = 200;
        assertTrue(filter.matches(req));

        filter.httpStatus = 404;
        assertFalse(filter.matches(req));
    }

    @Test
    public void testHttpStatusFilterNoReply() {
        HttpLog.HttpRequest req = makeRequest("GET");
        filter.httpStatus = 200;
        assertFalse(filter.matches(req));
    }

    @Test
    public void testMinPayloadSizeFilter() {
        HttpLog.HttpRequest req = makeRequest("POST");
        req.bodyLength = 50;
        makeReply(req, 200, "text/html", 100);

        filter.minPayloadSize = 100;
        assertTrue(filter.matches(req));

        filter.minPayloadSize = 200;
        assertFalse(filter.matches(req));
    }

    @Test
    public void testDecryptionErrorFilter() {
        HttpLog.HttpRequest req = makeRequest("GET");
        req.decryptionError = "handshake failed";

        filter.decryptionError = true;
        assertTrue(filter.matches(req));

        filter.decryptionError = false;
        assertFalse(filter.matches(req));

        // no error
        HttpLog.HttpRequest req2 = makeRequest("GET");
        filter.decryptionError = true;
        assertFalse(filter.matches(req2));

        filter.decryptionError = false;
        assertTrue(filter.matches(req2));
    }

    @Test
    public void testCombinedFilters() {
        HttpLog.HttpRequest req = makeRequest("GET");
        makeReply(req, 200, "text/html", 100);

        filter.method = "GET";
        filter.httpStatus = 200;
        assertTrue(filter.matches(req));

        filter.httpStatus = 404;
        assertFalse(filter.matches(req));
    }

    @Test
    public void testClear() {
        filter.method = "GET";
        filter.contentType = "text/html";
        filter.httpStatus = 200;
        filter.minPayloadSize = 100;
        filter.decryptionError = true;
        assertTrue(filter.isSet());

        filter.clear();
        assertFalse(filter.isSet());
    }

    @Test
    public void testClearById() {
        filter.method = "POST";
        filter.clear(R.id.http_method_filter);
        assertFalse(filter.isSet());

        filter.contentType = "text/html";
        filter.clear(R.id.http_content_type_filter);
        assertFalse(filter.isSet());

        filter.httpStatus = 200;
        filter.clear(R.id.http_status_filter);
        assertFalse(filter.isSet());

        filter.decryptionError = true;
        filter.clear(R.id.decryption_status);
        assertFalse(filter.isSet());
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/HttpLogTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import com.emanuelef.remote_capture.model.ConnectionDescriptor;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;

@RunWith(RobolectricTestRunner.class)
public class HttpLogTest {
    HttpLog log;
    ConnectionDescriptor conn;
    ArrayList<String> events;

    @Before
    public void setup() {
        log = new HttpLog();
        events = new ArrayList<>();
        conn = new ConnectionDescriptor(0, 4, 6,
                "1.1.1.1", "2.2.2.2", "", 51234, 443,
                0, -1, 0, false, 0);
        conn.l7proto = "TLS";
    }

    @Test
    public void testAddAndGetRequest() {
        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        req.method = "GET";
        req.path = "/index.html";
        log.addHttpRequest(req);

        assertEquals(1, log.getSize());
        assertNotNull(log.getRequest(0));
        assertEquals("GET", log.getRequest(0).method);
        assertEquals(0, log.getRequest(0).getPosition());
    }

    @Test
    public void testGetRequestOutOfBounds() {
        assertNull(log.getRequest(0));
        assertNull(log.getRequest(-1));
    }

    @Test
    public void testAddHttpReply() {
        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        req.method = "GET";
        req.host = "example.org";
        log.addHttpRequest(req);

        HttpLog.HttpReply reply = new HttpLog.HttpReply(req, 1);
        reply.responseCode = 200;
        reply.contentType = "text/html";
        req.reply = reply;

        log.setListener(new HttpLog.Listener() {
            @Override public void onHttpRequestAdded(int pos) { events.add("added:" + pos); }
            @Override public void onHttpRequestUpdated(int pos) { events.add("updated:" + pos); }
            @Override public void onHttpRequestsClear() { events.add("clear"); }
        });

        log.addHttpReply(reply);
        assertEquals(1, events.size());
        assertEquals("updated:0", events.get(0));
    }

    @Test
    public void testListenerNotifications() {
        log.setListener(new HttpLog.Listener() {
            @Override public void onHttpRequestAdded(int pos) { events.add("added:" + pos); }
            @Override public void onHttpRequestUpdated(int pos) { events.add("updated:" + pos); }
            @Override public void onHttpRequestsClear() { events.add("clear"); }
        });

        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        log.addHttpRequest(req);
        assertEquals("added:0", events.get(0));

        log.clear();
        assertEquals("clear", events.get(1));
    }

    @Test
    public void testStartStopConnectionsUpdates() {
        log.setListener(new HttpLog.Listener() {
            @Override public void onHttpRequestAdded(int pos) { events.add("added:" + pos); }
            @Override public void onHttpRequestUpdated(int pos) { events.add("updated:" + pos); }
            @Override public void onHttpRequestsClear() { events.add("clear"); }
        });

        log.startConnectionsUpdates();

        // requests added during update should be deferred
        HttpLog.HttpRequest req1 = new HttpLog.HttpRequest(conn, 0);
        req1.timestamp = 200;
        HttpLog.HttpRequest req2 = new HttpLog.HttpRequest(conn, 1);
        req2.timestamp = 100;

        log.addHttpRequest(req1);
        log.addHttpRequest(req2);
        assertEquals(0, events.size());

        log.stopConnectionsUpdates();

        // should be sorted by timestamp and then dispatched
        assertEquals(2, events.size());
        assertEquals(2, log.getSize());
        // req2 (timestamp=100) should come first
        assertEquals(100, log.getRequest(0).timestamp);
        assertEquals(200, log.getRequest(1).timestamp);
    }

    @Test
    public void testDeferredRepliesDuringUpdate() {
        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        req.host = "example.org";
        log.addHttpRequest(req);

        HttpLog.HttpReply reply = new HttpLog.HttpReply(req, 1);
        reply.responseCode = 200;
        reply.contentType = "text/html";
        req.reply = reply;

        log.setListener(new HttpLog.Listener() {
            @Override public void onHttpRequestAdded(int pos) { events.add("added:" + pos); }
            @Override public void onHttpRequestUpdated(int pos) { events.add("updated:" + pos); }
            @Override public void onHttpRequestsClear() { events.add("clear"); }
        });

        log.startConnectionsUpdates();
        log.addHttpReply(reply);
        assertEquals(0, events.size());

        log.stopConnectionsUpdates();
        assertEquals(1, events.size());
        assertEquals("updated:0", events.get(0));
    }

    @Test
    public void testAddDecryptionError() {
        log.addDecryptionError(conn, 12345, "handshake failed");
        assertEquals(1, log.getSize());
        assertEquals("handshake failed", log.getRequest(0).decryptionError);
        assertEquals(12345, log.getRequest(0).timestamp);
    }

    @Test
    public void testHttpRequestGetUrl() {
        conn.l7proto = "HTTP";
        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        req.host = "example.org";
        req.path = "/path";
        req.query = "?q=1";
        assertEquals("http://example.org/path?q=1", req.getUrl());
    }

    @Test
    public void testHttpRequestGetUrlHttps() {
        conn.l7proto = "HTTPS";
        Whitebox.setInternalState(conn, "encrypted_l7", true);
        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        req.host = "secure.example.org";
        req.path = "/secure";
        req.query = "";
        assertEquals("https://secure.example.org/secure", req.getUrl());
    }

    @Test
    public void testHttpRequestGetProtoAndHostFallsBackToInfo() {
        conn.l7proto = "HTTP";
        conn.info = "fallback.example.org";
        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        // host is empty, should use conn.info
        assertEquals("http://fallback.example.org", req.getProtoAndHost());
    }

    @Test
    public void testHttpRequestMatches() {
        conn.l7proto = "HTTP";
        HttpLog.HttpRequest req = new HttpLog.HttpRequest(conn, 0);
        req.host = "example.org";
        req.path = "/api/data";
        req.query = "";

        assertTrue(req.matches("example"));
        assertTrue(req.matches("EXAMPLE"));
        assertTrue(req.matches("/api"));
        assertFalse(req.matches("notfound"));

        // match by content type
        HttpLog.HttpReply reply = new HttpLog.HttpReply(req, 1);
        reply.contentType = "application/json";
        req.reply = reply;
        assertTrue(req.matches("json"));
    }

    @Test
    public void testHttpRequestCompareTo() {
        HttpLog.HttpRequest req1 = new HttpLog.HttpRequest(conn, 0);
        req1.timestamp = 100;
        HttpLog.HttpRequest req2 = new HttpLog.HttpRequest(conn, 1);
        req2.timestamp = 200;
        HttpLog.HttpRequest req3 = new HttpLog.HttpRequest(conn, 2);
        req3.timestamp = 100;

        assertTrue(req1.compareTo(req2) < 0);
        assertTrue(req2.compareTo(req1) > 0);
        assertEquals(0, req1.compareTo(req3));
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/MatchListTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;

import androidx.test.core.app.ApplicationProvider;

import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.MatchList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

@RunWith(RobolectricTestRunner.class)
public class MatchListTest {
    static final String PREF_NAME = "test_matchlist";
    MatchList list;

    @Before
    public void setup() {
        Context ctx = ApplicationProvider.getApplicationContext();
        list = new MatchList(ctx, PREF_NAME);
        list.clear();
    }

    private ConnectionDescriptor makeConn(String dstIp, String info, String l7proto, String country) {
        ConnectionDescriptor conn = new ConnectionDescriptor(0, 4, 6,
                "1.1.1.1", dstIp, country, 51234, 80,
                0, -1, 0, false, 0);
        conn.info = info;
        conn.l7proto = l7proto;
        return conn;
    }

    @Test
    public void testMatchesExactIP() {
        list.addIp("10.0.0.1");
        assertTrue(list.matchesExactIP("10.0.0.1"));
        assertFalse(list.matchesExactIP("10.0.0.2"));
    }

    @Test
    public void testMatchesCidr() {
        list.addIp("192.168.1.0/24");
        assertNotNull(list.matchesCidr("192.168.1.100"));
        assertNull(list.matchesCidr("192.168.2.1"));
    }

    @Test
    public void testMatchesExactHost() {
        list.addHost("example.org");
        assertTrue(list.matchesExactHost("example.org"));
        assertFalse(list.matchesExactHost("other.org"));
    }

    @Test
    public void testMatchesHostSecondLevel() {
        list.addHost("example.org");
        assertTrue(list.matchesHost("sub.example.org"));
        assertTrue(list.matchesHost("a.b.example.org"));
        assertFalse(list.matchesHost("notexample.org"));
    }

    @Test
    public void testMatchesHostWithWww() {
        list.addHost("www.example.org");
        // "www." is cleaned, so it matches "example.org"
        assertTrue(list.matchesHost("example.org"));
        assertTrue(list.matchesHost("sub.example.org"));
    }

    @Test
    public void testMatchesProto() {
        list.addProto("DNS");
        assertTrue(list.matchesProto("DNS"));
        assertFalse(list.matchesProto("HTTP"));
    }

    @Test
    public void testMatchesCountry() {
        list.addCountry("US");
        assertTrue(list.matchesCountry("US"));
        assertFalse(list.matchesCountry("DE"));
    }

    @Test
    public void testMatchesConnection() {
        list.addIp("2.2.2.2");

        ConnectionDescriptor conn = makeConn("2.2.2.2", "example.org", "TLS", "US");
        assertTrue(list.matches(conn));

        ConnectionDescriptor conn2 = makeConn("3.3.3.3", "other.org", "TLS", "US");
        assertFalse(list.matches(conn2));
    }

    @Test
    public void testMatchesConnectionByHost() {
        list.addHost("example.org");

        ConnectionDescriptor conn = makeConn("2.2.2.2", "sub.example.org", "TLS", "US");
        assertTrue(list.matches(conn));
    }

    @Test
    public void testMatchesConnectionByProto() {
        list.addProto("DNS");

        ConnectionDescriptor conn = makeConn("2.2.2.2", "", "DNS", "US");
        assertTrue(list.matches(conn));
    }

    @Test
    public void testMatchesConnectionByCountry() {
        list.addCountry("DE");

        ConnectionDescriptor conn = makeConn("2.2.2.2", "", "TLS", "DE");
        assertTrue(list.matches(conn));

        ConnectionDescriptor conn2 = makeConn("2.2.2.2", "", "TLS", "US");
        assertFalse(list.matches(conn2));
    }

    @Test
    public void testMatchesEmptyList() {
        ConnectionDescriptor conn = makeConn("2.2.2.2", "example.org", "TLS", "US");
        assertFalse(list.matches(conn));
    }

    @Test
    public void testDuplicateIpRejection() {
        assertTrue(list.addIp("10.0.0.1"));
        assertFalse(list.addIp("10.0.0.1"));
        assertEquals(1, list.getSize());
    }

    @Test
    public void testDuplicateHostRejection() {
        assertTrue(list.addHost("example.org"));
        assertFalse(list.addHost("example.org"));
        assertEquals(1, list.getSize());
    }

    @Test
    public void testRemoveIp() {
        list.addIp("10.0.0.1");
        list.removeIp("10.0.0.1");
        assertFalse(list.matchesExactIP("10.0.0.1"));
        assertTrue(list.isEmpty());
    }

    @Test
    public void testRemoveHost() {
        list.addHost("example.org");
        list.removeHost("example.org");
        assertFalse(list.matchesHost("example.org"));
        assertTrue(list.isEmpty());
    }

    @Test
    public void testRemoveCidr() {
        list.addIp("192.168.1.0/24");
        list.removeIp("192.168.1.0/24");
        assertNull(list.matchesCidr("192.168.1.100"));
        assertTrue(list.isEmpty());
    }

    @Test
    public void testClear() {
        list.addIp("10.0.0.1");
        list.addHost("example.org");
        list.addProto("DNS");
        list.addCountry("US");
        assertFalse(list.isEmpty());

        list.clear();
        assertTrue(list.isEmpty());
        assertEquals(0, list.getSize());
    }

    @Test
    public void testJsonRoundtrip() {
        list.addIp("10.0.0.1");
        list.addHost("example.org");
        list.addProto("DNS");
        list.addCountry("US");
        list.addIp("192.168.0.0/16");

        String json = list.toJson(false);

        list.clear();
        assertTrue(list.isEmpty());

        int numRules = list.fromJson(json);
        assertEquals(5, numRules);
        assertEquals(5, list.getSize());

        assertTrue(list.matchesExactIP("10.0.0.1"));
        assertTrue(list.matchesHost("example.org"));
        assertTrue(list.matchesProto("DNS"));
        assertTrue(list.matchesCountry("US"));
        assertNotNull(list.matchesCidr("192.168.1.1"));
    }

    @Test
    public void testAddRulesMerge() {
        list.addIp("10.0.0.1");

        Context ctx = ApplicationProvider.getApplicationContext();
        MatchList other = new MatchList(ctx, PREF_NAME + "_other");
        other.clear();
        other.addIp("10.0.0.2");
        other.addIp("10.0.0.1"); // duplicate

        int added = list.addRules(other);
        assertEquals(1, added);
        assertEquals(2, list.getSize());
    }

    @Test
    public void testListenerNotifications() {
        ArrayList<String> events = new ArrayList<>();
        list.addListChangeListener(() -> events.add("changed"));

        list.addIp("10.0.0.1");
        assertEquals(1, events.size());

        list.removeIp("10.0.0.1");
        assertEquals(2, events.size());

        list.addHost("example.org");
        list.clear();
        assertEquals(4, events.size());
    }

    @Test
    public void testListenerRemoval() {
        ArrayList<String> events = new ArrayList<>();
        MatchList.ListChangeListener listener = () -> events.add("changed");
        list.addListChangeListener(listener);

        list.addIp("10.0.0.1");
        assertEquals(1, events.size());

        list.removeListChangeListener(listener);
        list.addIp("10.0.0.2");
        assertEquals(1, events.size());
    }

    @Test
    public void testFromJsonMalformed() {
        assertEquals(-1, list.fromJson("not json"));
        assertEquals(-1, list.fromJson("[]")); // not a json object
    }

    @Test
    public void testToListDescriptor() {
        list.addIp("10.0.0.1");
        list.addHost("example.org");
        list.addProto("DNS");
        list.addCountry("US");

        MatchList.ListDescriptor desc = list.toListDescriptor();
        assertEquals(1, desc.ips.size());
        assertEquals("10.0.0.1", desc.ips.get(0));
        assertEquals(1, desc.hosts.size());
        assertEquals("example.org", desc.hosts.get(0));
        assertEquals(0, desc.apps.size());
        assertEquals(1, desc.countries.size());
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/PortMappingTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import android.content.Context;

import androidx.test.core.app.ApplicationProvider;

import com.emanuelef.remote_capture.model.PortMapping;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import java.util.Iterator;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

@RunWith(RobolectricTestRunner.class)
public class PortMappingTest {
    PortMapping mapping;

    @Before
    public void setup() {
        Context ctx = ApplicationProvider.getApplicationContext();
        mapping = new PortMapping(ctx);
        mapping.clear();
    }

    @Test
    public void testAddAndIterate() {
        PortMapping.PortMap m = new PortMapping.PortMap(6, 80, 8080, "127.0.0.1");
        assertTrue(mapping.add(m));

        Iterator<PortMapping.PortMap> it = mapping.iter();
        assertTrue(it.hasNext());
        PortMapping.PortMap got = it.next();
        assertEquals(6, got.ipproto);
        assertEquals(80, got.orig_port);
        assertEquals(8080, got.redirect_port);
        assertEquals("127.0.0.1", got.redirect_host);
    }

    @Test
    public void testDuplicateRejection() {
        PortMapping.PortMap m1 = new PortMapping.PortMap(6, 80, 8080, "127.0.0.1");
        assertTrue(mapping.add(m1));

        PortMapping.PortMap m2 = new PortMapping.PortMap(6, 80, 8080, "127.0.0.1");
        assertFalse(mapping.add(m2));
    }

    @Test
    public void testDifferentProtoNotDuplicate() {
        PortMapping.PortMap tcp = new PortMapping.PortMap(6, 80, 8080, "127.0.0.1");
        PortMapping.PortMap udp = new PortMapping.PortMap(17, 80, 8080, "127.0.0.1");
        assertTrue(mapping.add(tcp));
        assertTrue(mapping.add(udp));
    }

    @Test
    public void testRemove() {
        PortMapping.PortMap m = new PortMapping.PortMap(6, 443, 8443, "10.0.0.1");
        mapping.add(m);
        assertTrue(mapping.remove(m));
        assertFalse(mapping.iter().hasNext());
    }

    @Test
    public void testRemoveNonExistent() {
        PortMapping.PortMap m = new PortMapping.PortMap(6, 443, 8443, "10.0.0.1");
        assertFalse(mapping.remove(m));
    }

    @Test
    public void testJsonRoundtrip() {
        mapping.add(new PortMapping.PortMap(6, 80, 8080, "127.0.0.1"));
        mapping.add(new PortMapping.PortMap(17, 53, 5353, "10.0.0.1"));

        String json = mapping.toJson(false);

        // reload from json
        mapping.clear();
        assertTrue(mapping.fromJson(json));

        int count = 0;
        Iterator<PortMapping.PortMap> it = mapping.iter();
        while (it.hasNext()) {
            it.next();
            count++;
        }
        assertEquals(2, count);
    }

    @Test
    public void testBackwardCompatibility() {
        // "redirect_ip" is the old JSON key that maps to redirect_host
        String json = "[{\"ipproto\":6,\"orig_port\":80,\"redirect_port\":8080,\"redirect_ip\":\"192.168.1.1\"}]";
        assertTrue(mapping.fromJson(json));

        Iterator<PortMapping.PortMap> it = mapping.iter();
        assertTrue(it.hasNext());
        assertEquals("192.168.1.1", it.next().redirect_host);
    }

    @Test
    public void testMalformedJson() {
        assertFalse(mapping.fromJson("not json"));
    }

    @Test
    public void testPortMapEquals() {
        PortMapping.PortMap a = new PortMapping.PortMap(6, 80, 8080, "127.0.0.1");
        PortMapping.PortMap b = new PortMapping.PortMap(6, 80, 8080, "127.0.0.1");
        assertEquals(a, b);
        assertEquals(a.hashCode(), b.hashCode());
    }

    @Test
    public void testPortMapNotEquals() {
        PortMapping.PortMap a = new PortMapping.PortMap(6, 80, 8080, "127.0.0.1");
        PortMapping.PortMap b = new PortMapping.PortMap(6, 80, 9090, "127.0.0.1");
        assertFalse(a.equals(b));
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/TestPCAPdroid.java`:

```java
package com.emanuelef.remote_capture;

import org.robolectric.TestLifecycleApplication;

import java.lang.reflect.Method;

// NOTE: this class must be named "TestPCAPdroid"
// https://robolectric.org/custom-test-runner
public class TestPCAPdroid extends PCAPdroid implements TestLifecycleApplication {
    @Override
    public void onCreate() {
        PCAPdroid.isUnderTest = true;
        super.onCreate();
    }

    @Override
    public void beforeTest(Method method) {}

    @Override
    public void prepareTest(Object test) {}

    @Override
    public void afterTest(Method method) {}
}

```

`app/src/test/java/com/emanuelef/remote_capture/UtilsTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2022-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertEquals;

@RunWith(RobolectricTestRunner.class)
public class UtilsTest {
    @Test
    public void subnetContainsIpv4() {
        assertTrue(Utils.subnetContains("192.168.1.1", 24, "192.168.1.0"));
        assertTrue(Utils.subnetContains("192.168.1.20", 24, "192.168.1.255"));
        assertTrue(Utils.subnetContains("192.168.1.0", 24, "192.168.1.128"));
        assertTrue(Utils.subnetContains("10.0.0.0", 8, "10.0.2.0"));
        assertTrue(Utils.subnetContains("127.0.0.0", 8, "127.0.0.1"));
        assertTrue(Utils.subnetContains("192.168.1.123", 32, "192.168.1.123"));

        assertFalse(Utils.subnetContains("192.168.1.0", 24, "192.168.0.0"));
        assertFalse(Utils.subnetContains("192.168.1.0", 24, "192.168.0.255"));
    }

    @Test
    public void subnetContainsIpv6() {
        assertTrue(Utils.subnetContains("2001:0db8:85a3::8a2e:0370:7334", 128, "2001:0db8:85a3::8a2e:0370:7334"));
        assertTrue(Utils.subnetContains("2001:0db8:85a3::8a2e:0370:7334", 112, "2001:0db8:85a3::8a2e:0370:0001"));
        assertTrue(Utils.subnetContains("2001:0db8:85a3::8a2e:0370:7334", 64, "2001:0db8:85a3::8a2e:0370:0001"));

        assertFalse(Utils.subnetContains("2001:0db8:85a3::8a2e:0370:7334", 120, "2001:0db8:85a3::8a2e:0370:0001"));
    }

    @Test
    public void testTimezoneConversionLogic() {
        // Test the RFC 822 -> ISO 8601 timezone conversion logic used in formatMillisIso8601
        // This simulates what the code does on Android < N

        // Test positive timezone (was already working)
        String positiveInput = "2026-01-16T17:15:15.123+0100";
        String positiveExpected = "2026-01-16T17:15:15.123+01:00";
        assertEquals(positiveExpected, convertTimezone(positiveInput));

        // Test negative timezone (was broken before the fix)
        String negativeInput = "2026-01-16T10:15:15.123-0500";
        String negativeExpected = "2026-01-16T10:15:15.123-05:00";
        assertEquals(negativeExpected, convertTimezone(negativeInput));

        // Test UTC (edge case with +0000)
        String utcInput = "2026-01-16T15:15:15.123+0000";
        String utcExpected = "2026-01-16T15:15:15.123+00:00";
        assertEquals(utcExpected, convertTimezone(utcInput));

        // Test negative offset at international date line
        String idlInput = "2026-01-16T03:15:15.123-1200";
        String idlExpected = "2026-01-16T03:15:15.123-12:00";
        assertEquals(idlExpected, convertTimezone(idlInput));
    }

    @Test
    public void testCleanDomain() {
        assertEquals("example.org", Utils.cleanDomain("www.example.org"));
        assertEquals("example.org", Utils.cleanDomain("example.org"));
        assertEquals("", Utils.cleanDomain(""));
        assertEquals("sub.example.org", Utils.cleanDomain("www.sub.example.org"));
        assertEquals("www", Utils.cleanDomain("www.www"));
    }

    @Test
    public void testGetSecondLevelDomain() {
        assertEquals("example.org", Utils.getSecondLevelDomain("a.example.org"));
        assertEquals("example.org", Utils.getSecondLevelDomain("a.b.example.org"));
        assertEquals("example.org", Utils.getSecondLevelDomain("example.org"));
        assertEquals("org", Utils.getSecondLevelDomain("org"));
        assertEquals("", Utils.getSecondLevelDomain(""));
        assertEquals("co.uk", Utils.getSecondLevelDomain("www.example.co.uk"));
    }

    @Test
    public void testValidatePort() {
        assertTrue(Utils.validatePort("1"));
        assertTrue(Utils.validatePort("80"));
        assertTrue(Utils.validatePort("443"));
        assertTrue(Utils.validatePort("65534"));

        assertFalse(Utils.validatePort("0"));
        assertFalse(Utils.validatePort("65535"));
        assertFalse(Utils.validatePort("-1"));
        assertFalse(Utils.validatePort("abc"));
        assertFalse(Utils.validatePort(""));
    }

    @Test
    public void testValidateIpv4Address() {
        assertTrue(Utils.validateIpv4Address("0.0.0.0"));
        assertTrue(Utils.validateIpv4Address("192.168.1.1"));
        assertTrue(Utils.validateIpv4Address("255.255.255.255"));
        assertTrue(Utils.validateIpv4Address("10.0.0.1"));

        assertFalse(Utils.validateIpv4Address("256.1.1.1"));
        assertFalse(Utils.validateIpv4Address("1.2.3"));
        assertFalse(Utils.validateIpv4Address("1.2.3.4.5"));
        assertFalse(Utils.validateIpv4Address(""));
        assertFalse(Utils.validateIpv4Address("abc"));
    }

    @Test
    public void testValidateIpv6Address() {
        assertTrue(Utils.validateIpv6Address("2001:db8::1"));
        assertTrue(Utils.validateIpv6Address("::1"));
        assertTrue(Utils.validateIpv6Address("fe80::1"));
        assertTrue(Utils.validateIpv6Address("2001:0db8:85a3:0000:0000:8a2e:0370:7334"));

        assertFalse(Utils.validateIpv6Address("192.168.1.1"));
        assertFalse(Utils.validateIpv6Address(""));
        assertFalse(Utils.validateIpv6Address("zzzz::1"));
    }

    @Test
    public void testValidateCidr() {
        assertTrue(Utils.validateCidr("192.168.1.0/24"));
        assertTrue(Utils.validateCidr("10.0.0.0/8"));
        assertTrue(Utils.validateCidr("192.168.1.1/32"));
        assertTrue(Utils.validateCidr("0.0.0.0/0"));
        assertTrue(Utils.validateCidr("2001:db8::/32"));
        assertTrue(Utils.validateCidr("::1/128"));

        // plain IP (no slash) is valid
        assertTrue(Utils.validateCidr("192.168.1.1"));

        assertFalse(Utils.validateCidr("192.168.1.0/33"));
        assertFalse(Utils.validateCidr("::1/129"));
        assertFalse(Utils.validateCidr("abc/24"));
        assertFalse(Utils.validateCidr("192.168.1.0/abc"));
    }

    @Test
    public void testValidateHost() {
        assertTrue(Utils.validateHost("example.org"));
        assertTrue(Utils.validateHost("sub.example.org"));
        assertTrue(Utils.validateHost("a.b.c.example.org"));
        assertTrue(Utils.validateHost("example123.org"));

        assertFalse(Utils.validateHost("a"));
        assertFalse(Utils.validateHost("-example.org"));
        assertFalse(Utils.validateHost("example.org-"));
        assertFalse(Utils.validateHost("Example.org"));
        assertFalse(Utils.validateHost("example .org"));
        assertFalse(Utils.validateHost("example?.org"));
    }

    @Test
    public void testGetEndOfHTTPHeaders() {
        byte[] withHeaders = "GET / HTTP/1.1\r\nHost: example.org\r\n\r\nbody".getBytes();
        int end = Utils.getEndOfHTTPHeaders(withHeaders);
        assertTrue(end > 0);
        assertEquals("body", new String(withHeaders, end, withHeaders.length - end));

        byte[] noEnd = "GET / HTTP/1.1\r\nHost: example.org\r\n".getBytes();
        assertEquals(0, Utils.getEndOfHTTPHeaders(noEnd));

        byte[] minimal = "\r\n\r\n".getBytes();
        assertEquals(4, Utils.getEndOfHTTPHeaders(minimal));

        byte[] tooShort = "\r\n\r".getBytes();
        assertEquals(0, Utils.getEndOfHTTPHeaders(tooShort));

        assertEquals(0, Utils.getEndOfHTTPHeaders(new byte[0]));
    }

    // Helper that replicates the conversion logic from Utils.formatMillisIso8601
    private String convertTimezone(String rv) {
        int l = rv.length();
        if ((l > 5) && ((rv.charAt(l - 5) == '+') || (rv.charAt(l - 5) == '-')))
            rv = rv.substring(0, l - 2) + ":" + rv.substring(l - 2);
        return rv;
    }
}
```

`app/src/test/java/com/emanuelef/remote_capture/WebSocketDecoderTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2020-26 - Emanuele Faranda
 */

package com.emanuelef.remote_capture;

import com.emanuelef.remote_capture.model.PayloadChunk;
import com.emanuelef.remote_capture.model.PayloadChunk.ChunkType;

import org.junit.Before;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.*;

import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

@RunWith(RobolectricTestRunner.class)
public class WebSocketDecoderTest {

    private WebSocketDecoder decoder;
    private List<PayloadChunk> receivedFrames;

    @Before
    public void setUp() {
        receivedFrames = new ArrayList<>();
        decoder = new WebSocketDecoder(decoded -> receivedFrames.add(decoded));
    }

    private static byte[] buildFrame(int opcode, boolean fin, boolean mask, byte[] payload) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();

        int byte0 = opcode & 0x0F;
        if (fin) byte0 |= 0x80;
        out.write(byte0);

        int payloadLen = (payload != null) ? payload.length : 0;
        int byte1 = mask ? 0x80 : 0x00;

        if (payloadLen <= 125) {
            byte1 |= payloadLen;
            out.write(byte1);
        } else if (payloadLen <= 65535) {
            byte1 |= 126;
            out.write(byte1);
            out.write((payloadLen >> 8) & 0xFF);
            out.write(payloadLen & 0xFF);
        } else {
            byte1 |= 127;
            out.write(byte1);
            for (int i = 7; i >= 0; i--) {
                out.write((int) (((long) payloadLen >> (i * 8)) & 0xFF));
            }
        }

        byte[] maskingKey = null;
        if (mask) {
            maskingKey = new byte[]{0x12, 0x34, 0x56, 0x78};
            out.write(maskingKey, 0, 4);
        }

        if ((payload != null) && (payload.length > 0)) {
            byte[] payloadToWrite = payload.clone();
            if (mask && (maskingKey != null)) {
                for (int i = 0; i < payloadToWrite.length; i++) {
                    payloadToWrite[i] = (byte) (payloadToWrite[i] ^ maskingKey[i % 4]);
                }
            }
            out.write(payloadToWrite, 0, payloadToWrite.length);
        }

        return out.toByteArray();
    }

    private static byte[] buildFrameWithRsv(int opcode, boolean fin, boolean mask, byte[] payload, int rsv) {
        byte[] frame = buildFrame(opcode, fin, mask, payload);
        frame[0] = (byte) ((frame[0] & 0x8F) | ((rsv & 0x07) << 4));
        return frame;
    }

    private PayloadChunk makeChunk(byte[] data, boolean isSent) {
        return new PayloadChunk(data, ChunkType.WEBSOCKET, isSent, System.currentTimeMillis(), 0);
    }

    private static byte[] concat(byte[]... arrays) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        for (byte[] arr : arrays) {
            out.write(arr, 0, arr.length);
        }
        return out.toByteArray();
    }

    // ========== Basic Frame Parsing ==========

    @Test
    public void testSingleTextFrame() {
        byte[] payload = "Hello".getBytes(StandardCharsets.UTF_8);
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        PayloadChunk result = receivedFrames.get(0);
        assertEquals(WebSocketDecoder.OPCODE_TEXT, result.wsOpcode);
        assertTrue(result.wsIsFinal);
        assertFalse(result.wsWasFragmented);
        assertArrayEquals(payload, result.payload);
    }

    @Test
    public void testSingleBinaryFrame() {
        byte[] payload = new byte[]{0x00, 0x01, 0x02, (byte) 0xFF, (byte) 0xFE};
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_BINARY, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        PayloadChunk result = receivedFrames.get(0);
        assertEquals(WebSocketDecoder.OPCODE_BINARY, result.wsOpcode);
        assertArrayEquals(payload, result.payload);
    }

    @Test
    public void testMaskedFrame() {
        byte[] payload = "Masked message".getBytes(StandardCharsets.UTF_8);
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, true, payload);

        decoder.handleChunk(makeChunk(frame, true));

        assertEquals(1, receivedFrames.size());
        PayloadChunk result = receivedFrames.get(0);
        assertEquals(WebSocketDecoder.OPCODE_TEXT, result.wsOpcode);
        assertArrayEquals(payload, result.payload);
        assertEquals("Masked message", new String(result.payload, StandardCharsets.UTF_8));
    }

    @Test
    public void testEmptyPayload() {
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, new byte[0]);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        PayloadChunk result = receivedFrames.get(0);
        assertEquals(WebSocketDecoder.OPCODE_TEXT, result.wsOpcode);
        assertEquals(0, result.payload.length);
    }

    // ========== Extended Length ==========

    @Test
    public void testLength126() {
        byte[] payload = new byte[126];
        Arrays.fill(payload, (byte) 'A');
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(126, receivedFrames.get(0).payload.length);
    }

    @Test
    public void testLength127() {
        byte[] payload = new byte[70000];
        Arrays.fill(payload, (byte) 'B');
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_BINARY, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(70000, receivedFrames.get(0).payload.length);
    }

    @Test
    public void testLengthBoundary125() {
        byte[] payload = new byte[125];
        Arrays.fill(payload, (byte) 'C');
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(125, receivedFrames.get(0).payload.length);
    }

    @Test
    public void testLengthBoundary65535() {
        byte[] payload = new byte[65535];
        Arrays.fill(payload, (byte) 'D');
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_BINARY, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(65535, receivedFrames.get(0).payload.length);
    }

    // ========== Multiple Frames in Chunk ==========

    @Test
    public void testTwoFramesInChunk() {
        byte[] frame1 = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, "First".getBytes());
        byte[] frame2 = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, "Second".getBytes());
        byte[] combined = concat(frame1, frame2);

        decoder.handleChunk(makeChunk(combined, false));

        assertEquals(2, receivedFrames.size());
        assertEquals("First", new String(receivedFrames.get(0).payload, StandardCharsets.UTF_8));
        assertEquals("Second", new String(receivedFrames.get(1).payload, StandardCharsets.UTF_8));
    }

    @Test
    public void testThreeFramesInChunk() {
        byte[] frame1 = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, "Text".getBytes());
        byte[] frame2 = buildFrame(WebSocketDecoder.OPCODE_BINARY, true, false, new byte[]{1, 2, 3});
        byte[] frame3 = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, "More text".getBytes());
        byte[] combined = concat(frame1, frame2, frame3);

        decoder.handleChunk(makeChunk(combined, false));

        assertEquals(3, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_TEXT, receivedFrames.get(0).wsOpcode);
        assertEquals(WebSocketDecoder.OPCODE_BINARY, receivedFrames.get(1).wsOpcode);
        assertEquals(WebSocketDecoder.OPCODE_TEXT, receivedFrames.get(2).wsOpcode);
    }

    @Test
    public void testMixedTextBinaryFrames() {
        byte[] text1 = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, "Hello".getBytes());
        byte[] binary = buildFrame(WebSocketDecoder.OPCODE_BINARY, true, false, new byte[]{(byte) 0xDE, (byte) 0xAD});
        byte[] text2 = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, "World".getBytes());
        byte[] combined = concat(text1, binary, text2);

        decoder.handleChunk(makeChunk(combined, false));

        assertEquals(3, receivedFrames.size());
        assertArrayEquals("Hello".getBytes(), receivedFrames.get(0).payload);
        assertArrayEquals(new byte[]{(byte) 0xDE, (byte) 0xAD}, receivedFrames.get(1).payload);
        assertArrayEquals("World".getBytes(), receivedFrames.get(2).payload);
    }

    // ========== Frames Spanning Chunks ==========

    @Test
    public void testFrameSplitAtHeader() {
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, "Hello".getBytes());

        byte[] chunk1 = Arrays.copyOfRange(frame, 0, 1);
        byte[] chunk2 = Arrays.copyOfRange(frame, 1, frame.length);

        decoder.handleChunk(makeChunk(chunk1, false));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(chunk2, false));
        assertEquals(1, receivedFrames.size());
        assertEquals("Hello", new String(receivedFrames.get(0).payload, StandardCharsets.UTF_8));
    }

    @Test
    public void testFrameSplitAtExtLength() {
        byte[] payload = new byte[200];
        Arrays.fill(payload, (byte) 'X');
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, payload);

        byte[] chunk1 = Arrays.copyOfRange(frame, 0, 3);
        byte[] chunk2 = Arrays.copyOfRange(frame, 3, frame.length);

        decoder.handleChunk(makeChunk(chunk1, false));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(chunk2, false));
        assertEquals(1, receivedFrames.size());
        assertEquals(200, receivedFrames.get(0).payload.length);
    }

    @Test
    public void testFrameSplitAtMask() {
        byte[] payload = "Masked".getBytes();
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, true, payload);

        byte[] chunk1 = Arrays.copyOfRange(frame, 0, 4);
        byte[] chunk2 = Arrays.copyOfRange(frame, 4, frame.length);

        decoder.handleChunk(makeChunk(chunk1, true));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(chunk2, true));
        assertEquals(1, receivedFrames.size());
        assertEquals("Masked", new String(receivedFrames.get(0).payload, StandardCharsets.UTF_8));
    }

    @Test
    public void testFrameSplitInPayload() {
        byte[] payload = "Hello World from WebSocket!".getBytes();
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, payload);

        int splitPoint = 2 + 10;
        byte[] chunk1 = Arrays.copyOfRange(frame, 0, splitPoint);
        byte[] chunk2 = Arrays.copyOfRange(frame, splitPoint, frame.length);

        decoder.handleChunk(makeChunk(chunk1, false));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(chunk2, false));
        assertEquals(1, receivedFrames.size());
        assertArrayEquals(payload, receivedFrames.get(0).payload);
    }

    @Test
    public void testThreeChunkFrame() {
        byte[] payload = "This is a longer message split across three chunks".getBytes();
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, payload);

        int split1 = frame.length / 3;
        int split2 = 2 * frame.length / 3;

        byte[] chunk1 = Arrays.copyOfRange(frame, 0, split1);
        byte[] chunk2 = Arrays.copyOfRange(frame, split1, split2);
        byte[] chunk3 = Arrays.copyOfRange(frame, split2, frame.length);

        decoder.handleChunk(makeChunk(chunk1, false));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(chunk2, false));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(chunk3, false));
        assertEquals(1, receivedFrames.size());
        assertArrayEquals(payload, receivedFrames.get(0).payload);
    }

    // ========== Fragmented Messages ==========

    @Test
    public void testTwoFragments() {
        byte[] frag1 = buildFrame(WebSocketDecoder.OPCODE_TEXT, false, false, "Hello ".getBytes());
        byte[] frag2 = buildFrame(WebSocketDecoder.OPCODE_CONTINUATION, true, false, "World".getBytes());

        decoder.handleChunk(makeChunk(frag1, false));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(frag2, false));
        assertEquals(1, receivedFrames.size());
        assertEquals("Hello World", new String(receivedFrames.get(0).payload, StandardCharsets.UTF_8));
        assertTrue(receivedFrames.get(0).wsWasFragmented);
        assertEquals(WebSocketDecoder.OPCODE_TEXT, receivedFrames.get(0).wsOpcode);
    }

    @Test
    public void testThreeFragments() {
        byte[] frag1 = buildFrame(WebSocketDecoder.OPCODE_BINARY, false, false, new byte[]{1, 2});
        byte[] frag2 = buildFrame(WebSocketDecoder.OPCODE_CONTINUATION, false, false, new byte[]{3, 4});
        byte[] frag3 = buildFrame(WebSocketDecoder.OPCODE_CONTINUATION, true, false, new byte[]{5, 6});

        decoder.handleChunk(makeChunk(frag1, false));
        decoder.handleChunk(makeChunk(frag2, false));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(frag3, false));
        assertEquals(1, receivedFrames.size());
        assertArrayEquals(new byte[]{1, 2, 3, 4, 5, 6}, receivedFrames.get(0).payload);
        assertTrue(receivedFrames.get(0).wsWasFragmented);
    }

    @Test
    public void testControlFrameBetweenFragments() {
        byte[] frag1 = buildFrame(WebSocketDecoder.OPCODE_TEXT, false, false, "Part1".getBytes());
        byte[] ping = buildFrame(WebSocketDecoder.OPCODE_PING, true, false, "ping-data".getBytes());
        byte[] frag2 = buildFrame(WebSocketDecoder.OPCODE_CONTINUATION, true, false, "Part2".getBytes());

        decoder.handleChunk(makeChunk(frag1, false));
        assertEquals(0, receivedFrames.size());

        decoder.handleChunk(makeChunk(ping, false));
        assertEquals(1, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_PING, receivedFrames.get(0).wsOpcode);

        decoder.handleChunk(makeChunk(frag2, false));
        assertEquals(2, receivedFrames.size());
        assertEquals("Part1Part2", new String(receivedFrames.get(1).payload, StandardCharsets.UTF_8));
    }

    @Test
    public void testFragmentReassemblyPayload() {
        String part1 = "The quick brown fox ";
        String part2 = "jumps over ";
        String part3 = "the lazy dog.";

        byte[] frag1 = buildFrame(WebSocketDecoder.OPCODE_TEXT, false, false, part1.getBytes());
        byte[] frag2 = buildFrame(WebSocketDecoder.OPCODE_CONTINUATION, false, false, part2.getBytes());
        byte[] frag3 = buildFrame(WebSocketDecoder.OPCODE_CONTINUATION, true, false, part3.getBytes());

        decoder.handleChunk(makeChunk(frag1, false));
        decoder.handleChunk(makeChunk(frag2, false));
        decoder.handleChunk(makeChunk(frag3, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(part1 + part2 + part3, new String(receivedFrames.get(0).payload, StandardCharsets.UTF_8));
    }

    // ========== Control Frames ==========

    @Test
    public void testPingFrame() {
        byte[] payload = "ping-test".getBytes();
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_PING, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_PING, receivedFrames.get(0).wsOpcode);
        assertArrayEquals(payload, receivedFrames.get(0).payload);
    }

    @Test
    public void testPongFrame() {
        byte[] payload = "pong-response".getBytes();
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_PONG, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_PONG, receivedFrames.get(0).wsOpcode);
        assertArrayEquals(payload, receivedFrames.get(0).payload);
    }

    @Test
    public void testCloseFrame() {
        byte[] payload = new byte[]{0x03, (byte) 0xE8};  // Status 1000 (normal closure)
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_CLOSE, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_CLOSE, receivedFrames.get(0).wsOpcode);
        assertEquals(2, receivedFrames.get(0).payload.length);
        int statusCode = ((receivedFrames.get(0).payload[0] & 0xFF) << 8) |
                         (receivedFrames.get(0).payload[1] & 0xFF);
        assertEquals(1000, statusCode);
    }

    @Test
    public void testCloseFrameWithReason() {
        ByteArrayOutputStream payload = new ByteArrayOutputStream();
        payload.write(0x03);
        payload.write((byte) 0xE8);
        byte[] reason = "Normal closure".getBytes(StandardCharsets.UTF_8);
        payload.write(reason, 0, reason.length);

        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_CLOSE, true, false, payload.toByteArray());

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_CLOSE, receivedFrames.get(0).wsOpcode);

        byte[] resultPayload = receivedFrames.get(0).payload;
        String reasonText = new String(resultPayload, 2, resultPayload.length - 2, StandardCharsets.UTF_8);
        assertEquals("Normal closure", reasonText);
    }

    // ========== Control Frame RFC Violations ==========

    @Test
    public void testControlFrameWithFinZero() {
        // RFC 6455 Section 5.5: Control frames MUST NOT be fragmented (FIN must be 1)
        // The decoder should still process it (for PCAP analysis) but this is a protocol violation
        byte[] payload = "ping".getBytes();
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_PING, false, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        // Frame should still be emitted (we're a PCAP analyzer, not a strict validator)
        assertEquals(1, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_PING, receivedFrames.get(0).wsOpcode);
        assertFalse(receivedFrames.get(0).wsIsFinal);
        assertArrayEquals(payload, receivedFrames.get(0).payload);
    }

    @Test
    public void testControlFrameWithLargePayload() {
        // RFC 6455 Section 5.5: Control frames MUST have payload <= 125 bytes
        // The decoder should still process it (for PCAP analysis) but this is a protocol violation
        byte[] payload = new byte[130];
        Arrays.fill(payload, (byte) 'X');
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_PING, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        // Frame should still be emitted
        assertEquals(1, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_PING, receivedFrames.get(0).wsOpcode);
        assertEquals(130, receivedFrames.get(0).payload.length);
    }

    @Test
    public void testCloseFrameWithFinZeroAndLargePayload() {
        // Both RFC violations combined
        byte[] payload = new byte[200];
        Arrays.fill(payload, (byte) 'Y');
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_CLOSE, false, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(WebSocketDecoder.OPCODE_CLOSE, receivedFrames.get(0).wsOpcode);
        assertFalse(receivedFrames.get(0).wsIsFinal);
        assertEquals(200, receivedFrames.get(0).payload.length);
    }

    // ========== Edge Cases ==========

    @Test
    public void testMaxLengthPayload() {
        byte[] payload = new byte[1024 * 1024];
        Arrays.fill(payload, (byte) 'Z');
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_BINARY, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(1024 * 1024, receivedFrames.get(0).payload.length);
    }

    @Test
    public void testInvalidOpcode() {
        byte[] payload = "test".getBytes();
        byte[] frame = buildFrame(0x03, true, false, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertEquals(0x03, receivedFrames.get(0).wsOpcode);
    }

    @Test
    public void testUnmaskedClientFrame() {
        byte[] payload = "Client unmasked".getBytes();
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, false, payload);

        decoder.handleChunk(makeChunk(frame, true));

        assertEquals(1, receivedFrames.size());
        assertArrayEquals(payload, receivedFrames.get(0).payload);
    }

    @Test
    public void testMaskedServerFrame() {
        byte[] payload = "Server masked".getBytes();
        byte[] frame = buildFrame(WebSocketDecoder.OPCODE_TEXT, true, true, payload);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertArrayEquals(payload, receivedFrames.get(0).payload);
    }

    @Test
    public void testNonZeroRsvBits() {
        byte[] payload = "RSV test".getBytes();
        byte[] frame = buildFrameWithRsv(WebSocketDecoder.OPCODE_TEXT, true, false, payload, 0x05);

        decoder.handleChunk(makeChunk(frame, false));

        assertEquals(1, receivedFrames.size());
        assertArrayEquals(payload, receivedFrames.get(0).payload);
    }

    @Test
    public void testEmptyChunk() {
        PayloadChunk emptyChunk = makeChunk(new byte[0], false);

        decoder.handleChunk(emptyChunk);

        assertEquals(0, receivedFrames.size());
    }

    // ========== Utility Methods ==========

    @Test
    public void testIsControlOpcode() {
        assertFalse(WebSocketDecoder.isControlOpcode(WebSocketDecoder.OPCODE_CONTINUATION));
        assertFalse(WebSocketDecoder.isControlOpcode(WebSocketDecoder.OPCODE_TEXT));
        assertFalse(WebSocketDecoder.isControlOpcode(WebSocketDecoder.OPCODE_BINARY));
        assertTrue(WebSocketDecoder.isControlOpcode(WebSocketDecoder.OPCODE_CLOSE));
        assertTrue(WebSocketDecoder.isControlOpcode(WebSocketDecoder.OPCODE_PING));
        assertTrue(WebSocketDecoder.isControlOpcode(WebSocketDecoder.OPCODE_PONG));
    }

    @Test
    public void testIsValidOpcode() {
        assertTrue(WebSocketDecoder.isValidOpcode(WebSocketDecoder.OPCODE_CONTINUATION));
        assertTrue(WebSocketDecoder.isValidOpcode(WebSocketDecoder.OPCODE_TEXT));
        assertTrue(WebSocketDecoder.isValidOpcode(WebSocketDecoder.OPCODE_BINARY));
        assertTrue(WebSocketDecoder.isValidOpcode(WebSocketDecoder.OPCODE_CLOSE));
        assertTrue(WebSocketDecoder.isValidOpcode(WebSocketDecoder.OPCODE_PING));
        assertTrue(WebSocketDecoder.isValidOpcode(WebSocketDecoder.OPCODE_PONG));
        assertFalse(WebSocketDecoder.isValidOpcode(0x03));
        assertFalse(WebSocketDecoder.isValidOpcode(0x0B));
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/Whitebox.java`:

```java
/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package com.emanuelef.remote_capture;

import java.lang.reflect.Field;

public class Whitebox {

    public static Object getInternalState(Object target, String field) {
        Class<?> c = target.getClass();
        try {
            Field f = getFieldFromHierarchy(c, field);
            f.setAccessible(true);
            return f.get(target);
        } catch (Exception e) {
            throw new RuntimeException("Unable to set internal state on a private field. Please report to mockito mailing list.", e);
        }
    }

    public static void setInternalState(Object target, String field, Object value) {
        Class<?> c = target.getClass();
        try {
            Field f = getFieldFromHierarchy(c, field);
            f.setAccessible(true);
            f.set(target, value);
        } catch (Exception e) {
            throw new RuntimeException("Unable to set internal state on a private field. Please report to mockito mailing list.", e);
        }
    }

    private static Field getFieldFromHierarchy(Class<?> clazz, String field) {
        Field f = getField(clazz, field);
        while (f == null && clazz != Object.class) {
            clazz = clazz.getSuperclass();
            f = getField(clazz, field);
        }
        if (f == null) {
            throw new RuntimeException(
                    "You want me to set value to this field: '" + field +
                            "' on this class: '" + clazz.getSimpleName() +
                            "' but this field is not declared withing hierarchy of this class!");
        }
        return f;
    }

    private static Field getField(Class<?> clazz, String field) {
        try {
            return clazz.getDeclaredField(field);
        } catch (NoSuchFieldException e) {
            return null;
        }
    }
}
```

`app/src/test/java/com/emanuelef/remote_capture/adapters/ConnectionsAdapterTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2021 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.content.Context;

import androidx.collection.ArraySet;
import androidx.recyclerview.widget.RecyclerView;
import androidx.test.core.app.ApplicationProvider;

import com.emanuelef.remote_capture.AppsResolver;
import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.ConnectionsRegister;
import com.emanuelef.remote_capture.Whitebox;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.ConnectionUpdate;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotSame;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import java.util.ArrayList;
import java.util.Arrays;

@RunWith(RobolectricTestRunner.class)
/* Tests the ConnectionsAdapter class by verifying its notifications sent when a connection is
 * added/removed/updated and the items retrieval via getItem/getItemCount methods.
 *
 * The conditions which characterize the longest code paths are:
 *  - With/without rollover: rollover occurs when the MAX_CONNECTIONS is exceeded so old connections
 *    are replaced with the ones.
 *  - Filtered/Unfiltered: the adapter handles differently the two cases when no connections filter
 *    is set and when one is set. In the first case, it relies on the ConnectionsRegister to retrieve
 *    the connections. In the latter case, it uses its own collection to store the connections matching
 *    the filter. Two types of filter can be applied: pre-defined filters via mFilter or substring
 *    matching via setSearch.
 *  - Stats/Info update: for efficiency reasons, updates are handled differently, via the
 *    setStats/setInfo methods.
 */
public class ConnectionsAdapterTest {
    static final int MAX_CONNECTIONS = 8;
    Context context;
    ConnectionsAdapter adapter;
    ConnectionsRegister reg;
    CaptureService service;
    int incrId = 0;

    /* This stores the notifications generated by the adapter when data changes. assertEvent and
     * getNotifiedPositions are then used to retrieve and test the events.
     */
    ArrayList<DataChangeEvent> pendingEvents = new ArrayList<>();

    enum ChangeType {
        ITEMS_INSERTED,
        ITEMS_UPDATED,
        ITEMS_REMOVED,
    }

    enum UpdateType {
        UPDATE_STATS,
        UPDATE_INFO
    }

    static class DataChangeEvent {
        public final ChangeType tp;
        public final int start;
        public final int count;

        public DataChangeEvent(ChangeType tp, int positionStart, int itemCount) {
            this.tp = tp;
            start = positionStart;
            count = itemCount;
        }
    }

    @Before
    public void setup() {
        incrId = 0;
        pendingEvents.clear();

        // NOTE: @BeforeClass (static) does not work with ApplicationProvider.getApplicationContext
        context = ApplicationProvider.getApplicationContext();
        AppsResolver resolver = new AppsResolver(context);
        adapter = new ConnectionsAdapter(context, resolver);

        // Register events observer
        adapter.registerAdapterDataObserver(new RecyclerView.AdapterDataObserver() {
            @Override
            public void onItemRangeInserted(int positionStart, int itemCount) {
                pendingEvents.add(new DataChangeEvent(ChangeType.ITEMS_INSERTED, positionStart, itemCount));
            }
            @Override
            public void onItemRangeChanged(int positionStart, int itemCount) {
                pendingEvents.add(new DataChangeEvent(ChangeType.ITEMS_UPDATED, positionStart, itemCount));
            }
            @Override
            public void onItemRangeRemoved(int positionStart, int itemCount) {
                pendingEvents.add(new DataChangeEvent(ChangeType.ITEMS_REMOVED, positionStart, itemCount));
            }
        });

        // Max 8 connections
        reg = new ConnectionsRegister(context, MAX_CONNECTIONS);
        reg.addListener(adapter);

        // Mock CaptureService
        service = new CaptureService();
        Whitebox.setInternalState(service, "INSTANCE", service);
        Whitebox.setInternalState(service, "conn_reg", reg);
    }

    @After
    public void tearDown() {
        reg.removeListener(adapter);
        Whitebox.setInternalState(service, "INSTANCE", null);
    }

    @Test
    /* Simple insertion with no filter/rollover */
    public void testSimpleInsertion() {
        // start with 6 connections
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(false),
                newConnection(true),
                newConnection(true),
                newConnection(true),
                newConnection(true),
                newConnection(false),
        });
        assertEvent(ChangeType.ITEMS_INSERTED, 0, 6);
        assertEquals(0, adapter.getItem(0).incr_id);
        assertEquals(5, adapter.getItem(5).incr_id);
    }

    @Test
    /* Insertion with rollover but no filter */
    public void testInsertionRollover() {
        // start with 6 connections
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(false),
                newConnection(true),
                newConnection(true),
                newConnection(true),
                newConnection(true),
                newConnection(false),
        });
        assertEvent(ChangeType.ITEMS_INSERTED, 0, 6);

        // add 4 connections, 2 of which replace the first 2
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(false),
                newConnection(false),
                newConnection(true),
                newConnection(false),
        });

        assertEvent(ChangeType.ITEMS_REMOVED, 0, 2);
        assertEvent(ChangeType.ITEMS_INSERTED, 4, 4);
        assertEquals(2, adapter.getItem(0).incr_id);
        assertEquals(9, adapter.getItem(7).incr_id);
    }

    @Test
    /* Removal of all the connections via reset, no rollover/filter */
    public void testSimpleRemoveAll() {
        // start with 2 connections
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(true),
                newConnection(true),
        });

        // remove all items
        reg.reset();
        assertEquals(0, adapter.getItemCount());
        assertSame(adapter.getItem(0), null);
    }

    @Test
    /* Update of connections stats/info with no rollover and no filter */
    public void testUpdate() {
        // start with 2 connections
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(true),
                newConnection(true),
        });
        assertEvent(ChangeType.ITEMS_INSERTED, 0, 2);

        // update the connections
        reg.connectionsUpdates(new ConnectionUpdate[] {
                connUpdate(1, UpdateType.UPDATE_STATS),
        });
        assertEvent(ChangeType.ITEMS_UPDATED, 1, 1);

        reg.connectionsUpdates(new ConnectionUpdate[] {
                connUpdate(1, UpdateType.UPDATE_STATS),
                connUpdate(0, UpdateType.UPDATE_INFO),
                connUpdate(2, UpdateType.UPDATE_INFO), // untracked item, must be ignored
        });

        ArraySet<Integer> updated = getNotifiedPositions(ChangeType.ITEMS_UPDATED);
        assertEquals(2, updated.size());
        assertTrue(updated.contains(0));
        assertTrue(updated.contains(1));

        assertEquals(0, adapter.getItem(0).sent_pkts);
        assertNotSame(null, adapter.getItem(0).info);
        assertEquals(1, adapter.getItem(1).sent_pkts);
        assertSame(null, adapter.getItem(1).info);
    }

    @Test
    /* Insertion with rollover and status filter */
    public void testFilterRollover() {
        // start with 6 connections
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(false),
                newConnection(true),
                newConnection(true),
                newConnection(true), // pos 0 after remove
                newConnection(true),
                newConnection(false),
        });

        // apply filter: only active connections
        adapter.mFilter.status = ConnectionDescriptor.Status.STATUS_ACTIVE;
        adapter.refreshFilteredConnections();

        assertEquals(4, adapter.getItemCount());
        assertEquals(1, adapter.getItem(0).incr_id);
        assertEquals(4, adapter.getItem(3).incr_id);
        assertSame(null, adapter.getItem(4));
        pendingEvents.clear();

        // add 5 connections, 3 of which replace the first 3
        // this tests: removeFilteredItemAt
        reg.newConnections(new ConnectionDescriptor[]{
                newConnection(true),
                newConnection(false), // this one will be filtered out
                newConnection(true),
                newConnection(true),
                newConnection(true),
        });
        ArraySet<Integer> removed = getNotifiedPositions(ChangeType.ITEMS_REMOVED);
        assertEquals(2, removed.size());
        assertTrue(removed.contains(0));
        assertTrue(removed.contains(1));
        assertEvent(ChangeType.ITEMS_INSERTED, 2, 4);
        assertEquals(6, adapter.getItemCount());
        assertEquals(3, adapter.getItem(0).incr_id);
        assertEquals(10, adapter.getItem(5).incr_id);
        assertSame(null, adapter.getItem(6));

        // Add 3 active connections, which replace connections with ids 4,5,6 (last one filtered out)
        // tests connectionsAdded with non-0 mNumRemovedItems
        reg.newConnections(new ConnectionDescriptor[]{
                newConnection(true),
                newConnection(true),
        });
        removed = getNotifiedPositions(ChangeType.ITEMS_REMOVED);
        assertEquals(2, removed.size());
        assertEvent(ChangeType.ITEMS_INSERTED, 4, 2);
    }

    @Test
    /* Update of connections with rollover and status filter */
    public void testFilterUpdate() {
        adapter.mFilter.status = ConnectionDescriptor.Status.STATUS_ACTIVE;
        adapter.refreshFilteredConnections();

        // 8 connections (5 active connections) with 4 removed connections (mUnfilteredItemsCount not 0).
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(false), // true after remove
                newConnection(true),  // false after remove
                newConnection(true),  // false after remove
                newConnection(true),  // true after remove
                newConnection(true),  // pos 0 after remove
                newConnection(true),  // update: incr_id=5, pos=1
                newConnection(true),
                newConnection(false),
        });
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(true),
                newConnection(false),
                newConnection(false),
                newConnection(true),  // update: incr_id=11, pos=4
        });
        assertEquals(5, adapter.getItemCount());
        assertEquals(4, adapter.getItem(0).incr_id);
        assertEquals(11, adapter.getItem(4).incr_id);
        pendingEvents.clear();

        // update the connections
        // tests fixFilteredPositions
        reg.connectionsUpdates(new ConnectionUpdate[] {
                connUpdate(0, UpdateType.UPDATE_STATS),  // untracked (ignored)
                connUpdate(5, UpdateType.UPDATE_STATS),  // pos 1
                connUpdate(7, UpdateType.UPDATE_STATS),  // filtered out
                connUpdate(11, UpdateType.UPDATE_STATS), // pos 4
        });
        ArraySet<Integer> updated = getNotifiedPositions(ChangeType.ITEMS_UPDATED);
        assertEquals(2, updated.size());
        assertTrue(updated.contains(1));
        assertTrue(updated.contains(4));
        assertEquals(adapter.getItem(1).sent_pkts, 1);
        assertEquals(adapter.getItem(4).sent_pkts, 1);
        assertEquals(adapter.getItem(2).sent_pkts, 0);
    }

    @Test
    /* Test case for unmatched items.
     * When a filter is set, some connections which initially match the filter may not match it
     * anymore afterwards. This occurs, for example, with the "active" connection filter when a
     * connection transits to the "closed" state.
     */
    public void testFilterUnmatch() {
        adapter.mFilter.status = ConnectionDescriptor.Status.STATUS_ACTIVE;
        adapter.refreshFilteredConnections();

        // 8 connections (4 active connections) with 1 removed connections (mUnfilteredItemsCount not 0).
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(true),  // false after remove
                newConnection(false),
                newConnection(false),
                newConnection(true),  // pos 0 after remove, incr_id=3
                newConnection(true),  // unmatch pos 1, incr_id=4
                newConnection(false),
                newConnection(true),
                newConnection(true),  // unmatch pos3, incr_id=7
        });
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(false),
        });
        assertEquals(4, adapter.getItemCount());
        assertEquals(3, adapter.getItem(0).incr_id);
        pendingEvents.clear();

        // generate 2 unmatches
        ConnectionUpdate up1 = connUpdate(4, UpdateType.UPDATE_STATS);
        ConnectionUpdate up3 = connUpdate(7, UpdateType.UPDATE_STATS);
        up1.status = ConnectionDescriptor.CONN_STATUS_CLOSED;
        up3.status = ConnectionDescriptor.CONN_STATUS_CLOSED;

        // NOTE: the positions of the updates are sorted by the adapter. Reporting them here sorted
        // for the reader convenience.
        reg.connectionsUpdates(new ConnectionUpdate[] {
                up1,
                connUpdate(6, UpdateType.UPDATE_INFO), // pos 2
                up3,
        });
        assertEvent(ChangeType.ITEMS_REMOVED, 1, 1);
        assertEvent(ChangeType.ITEMS_UPDATED, 1, 1);
        assertNotSame(adapter.getItem(1).info, null);
        assertEvent(ChangeType.ITEMS_REMOVED, 2, 1);

        assertEquals(2, adapter.getItemCount());
        assertEquals(3, adapter.getItem(0).incr_id);
        assertEquals(6, adapter.getItem(1).incr_id);
    }

    @Test
    /* Insertion and updates with rollover and search string. */
    public void testSearch() {
        // 8 connections with 2 removed connections (mUnfilteredItemsCount not 0).
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(false),
                newConnection(true),
                newConnection(true),
                newConnection(true),
                newConnection(true),
                newConnection(true),
                newConnection(true),
                newConnection(false),
        });
        reg.newConnections(new ConnectionDescriptor[] {
                newConnection(false), // id 8
                newConnection(true),  // id 9
        });
        reg.connectionsUpdates(new ConnectionUpdate[] {
                connInfo(3, "orange"),
                connInfo(5, "juice"),
                connInfo(6, "apple"),
                connInfo(9, "orangejuice"),
        });

        // Set filter
        adapter.setSearch("orange");
        assertEquals(2, adapter.getItemCount());
        assertEquals(3, adapter.getItem(0).incr_id);
        assertEquals(9, adapter.getItem(1).incr_id);

        // Unmatch by changing the info
        reg.connectionsUpdates(new ConnectionUpdate[]{
                connInfo(3, "lemon"),
        });
        assertEquals(1, adapter.getItemCount());
        assertEquals(9, adapter.getItem(0).incr_id);

        // Unset filter
        adapter.setSearch(null);
        assertEquals(8, adapter.getItemCount());
        assertEquals(2, adapter.getItem(0).incr_id);
    }

    /* ******************************************************* */

    /* Creates a new ConnectionDescriptor and allocates an incrId for it. */
    ConnectionDescriptor newConnection(boolean active) {
        ConnectionDescriptor conn = new ConnectionDescriptor(incrId++, 4, 6,
                "1.1.1.1", "2.2.2.2", "", 51234, 80,
                0, -1, 0, false, 0);
        conn.status = active ? ConnectionDescriptor.CONN_STATUS_CONNECTED : ConnectionDescriptor.CONN_STATUS_CLOSED;
        return conn;
    }

    /* Creates a ConnectionUpdate based on the UpdateType:
     *   - UPDATE_STATS: sets the sent/rcvd pkts to 1, sent/rcvd bytes to 10, status to CONN_STATUS_CONNECTED
     *   - UPDATE_INFO: sets the info to "example.org" and L7 protocol to "TLS"
     */
    ConnectionUpdate connUpdate(int incr_id, UpdateType tp) {
        ConnectionUpdate update = new ConnectionUpdate(incr_id);

        if(tp.equals(UpdateType.UPDATE_STATS))
            update.setStats(0, 0, 10, 10, 1, 1,
                    0, 0, ConnectionDescriptor.CONN_STATUS_CONNECTED);
        else
            update.setInfo("example.org", null, "TLS", ConnectionUpdate.UPDATE_INFO_FLAG_ENCRYPTED_L7);

        return update;
    }

    /* Creates a ConnectionUpdate to set the connection info to the specified string.
     * The connection protocol is set to "TLS".
     */
    ConnectionUpdate connInfo(int incr_id, String info) {
        ConnectionUpdate update = new ConnectionUpdate(incr_id);
        update.setInfo(info, null, "TLS", ConnectionUpdate.UPDATE_INFO_FLAG_ENCRYPTED_L7);

        return update;
    }

    /* Retrieve the oldest event in pendingEvents and asserts it is of the specified type and
     * contains the specified range. */
    void assertEvent(ChangeType tp, int positionStart, int itemCount) {
        assertNotEquals(pendingEvents.size(), 0);

        DataChangeEvent ev = pendingEvents.remove(0);
        assertEquals(tp, ev.tp);
        assertEquals(positionStart, ev.start);
        assertEquals(itemCount, ev.count);
    }

    /* Retrieve the oldest consecutive events of the specified type.
     * Some notifications are sent as single events rather than in bulk. For example, when multiple
     * connections are updated, they are currently notified via notifyItemChanged rather than
     * notifyItemRangeChanged even for consecutive connections. By grouping events by type we can
     * ignore the details and provide more robust assertions.
     */
    ArraySet<Integer> getNotifiedPositions(ChangeType tp) {
        ArraySet<Integer> notified = new ArraySet<>();
        boolean[] removed_pos = new boolean[MAX_CONNECTIONS];

        while(!pendingEvents.isEmpty()) {
            DataChangeEvent ev = pendingEvents.get(0);
            if(!ev.tp.equals(tp))
                break;
            pendingEvents.remove(0);

            if(tp.equals(ChangeType.ITEMS_REMOVED)) {
                // Removed notification must be handled carefully as positions of preceding items
                // must be shifted when an item is removed in a previous notification, e.g.
                // rem(0) + rem(0) actually means remove item 0 and 1 in the original array
                boolean[] cur_removed = Arrays.copyOf(removed_pos, removed_pos.length);

                for(int i=0; i<ev.count; i++) {
                    int k = 0;
                    int found = -1;

                    // Skip previously removed items
                    for(int j=0; j<cur_removed.length; j++) {
                        if(cur_removed[j])
                            continue;

                        if(k == (ev.start + i)) {
                            found = j;
                            break;
                        }
                        k++;
                    }
                    assertNotEquals(-1, found);
                    assertFalse(removed_pos[found]);   // the item must not be already deleted
                    notified.add(found);
                    removed_pos[found] = true;
                }
            } else {
                for(int i = 0; i < ev.count; i++)
                    notified.add(ev.start + i);
            }
        }

        return notified;
    }
}

```

`app/src/test/java/com/emanuelef/remote_capture/adapters/PayloadAdapterTest.java`:

```java
/*
 * This file is part of PCAPdroid.
 *
 * PCAPdroid is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PCAPdroid is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2026 - Emanuele Faranda
 */

package com.emanuelef.remote_capture.adapters;

import android.content.Context;
import android.content.SharedPreferences;
import androidx.preference.PreferenceManager;
import androidx.test.core.app.ApplicationProvider;

import com.emanuelef.remote_capture.CaptureService;
import com.emanuelef.remote_capture.Whitebox;
import com.emanuelef.remote_capture.model.CaptureSettings;
import com.emanuelef.remote_capture.model.ConnectionDescriptor;
import com.emanuelef.remote_capture.model.PayloadChunk;
import com.emanuelef.remote_capture.model.PayloadChunk.ChunkType;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;

@RunWith(RobolectricTestRunner.class)
public class PayloadAdapterTest {
    private Context context;
    private CaptureService service;
    private PayloadAdapter adapter;

    @Before
    public void setup() {
        context = ApplicationProvider.getApplicationContext();

        service = new CaptureService();
        Whitebox.setInternalState(service, "INSTANCE", service);

        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
        CaptureSettings settings = new CaptureSettings(context, prefs);
        settings.full_payload = true;
        Whitebox.setInternalState(service, "mSettings", settings);

        ConnectionDescriptor conn = new ConnectionDescriptor(1, 4, 6,
                "192.168.1.100", "93.184.216.34", "US",
                54321, 443, 0, 1000, 0, false, System.currentTimeMillis());

        adapter = new PayloadAdapter(context, conn, ChunkType.HTTP, true);
    }

    @After
    public void tearDown() {
        Whitebox.setInternalState(service, "INSTANCE", null);
    }

    private PayloadChunk makeHttpRequest(int streamId) {
        byte[] payload = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n".getBytes();
        return new PayloadChunk(payload, ChunkType.HTTP, true, System.currentTimeMillis(), streamId);
    }

    private PayloadChunk makeHttpResponse(int streamId) {
        byte[] payload = "HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n".getBytes();
        return new PayloadChunk(payload, ChunkType.HTTP, false, System.currentTimeMillis(), streamId);
    }

    private PayloadChunk makeHttp2Rst(int streamId) {
        PayloadChunk chunk = new PayloadChunk(new byte[0], ChunkType.HTTP, false, System.currentTimeMillis(), streamId);
        chunk.setHttpRst();
        return chunk;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<?> getChunks() {
        return (ArrayList<?>) Whitebox.getInternalState(adapter, "mChunks");
    }

    private PayloadChunk getChunkPayload(int index) {
        Object adapterChunk = getChunks().get(index);
        return (PayloadChunk) Whitebox.getInternalState(adapterChunk, "mChunk");
    }

    // ========== HTTP/1 sequential matching ==========

    @Test
    public void testHttp1SequentialMatching() {
        PayloadChunk req = makeHttpRequest(0);
        PayloadChunk res = makeHttpResponse(0);

        adapter.onChunkReassembled(req);
        adapter.onChunkReassembled(res);

        assertEquals(2, getChunks().size());
        // reply should be placed right after request
        assertTrue(getChunkPayload(0).is_sent);
        assertFalse(getChunkPayload(1).is_sent);
    }

    @Test
    public void testHttp1MultipleRequestsInOrder() {
        PayloadChunk req1 = makeHttpRequest(0);
        PayloadChunk req2 = makeHttpRequest(0);
        PayloadChunk res1 = makeHttpResponse(0);
        PayloadChunk res2 = makeHttpResponse(0);

        adapter.onChunkReassembled(req1);
        adapter.onChunkReassembled(req2);
        adapter.onChunkReassembled(res1);
        adapter.onChunkReassembled(res2);

        assertEquals(4, getChunks().size());
        // expect: req1, res1, req2, res2
        assertSame(req1, getChunkPayload(0));
        assertSame(res1, getChunkPayload(1));
        assertSame(req2, getChunkPayload(2));
        assertSame(res2, getChunkPayload(3));
    }

    // ========== HTTP/2 stream-based matching ==========

    @Test
    public void testHttp2OutOfOrderReplies() {
        PayloadChunk reqA = makeHttpRequest(1);
        PayloadChunk reqB = makeHttpRequest(3);
        // reply to stream 3 arrives before reply to stream 1
        PayloadChunk resB = makeHttpResponse(3);
        PayloadChunk resA = makeHttpResponse(1);

        adapter.onChunkReassembled(reqA);
        adapter.onChunkReassembled(reqB);
        adapter.onChunkReassembled(resB);
        adapter.onChunkReassembled(resA);

        assertEquals(4, getChunks().size());
        // expect: reqA, resA, reqB, resB — each reply right after its request
        assertSame(reqA, getChunkPayload(0));
        assertSame(resA, getChunkPayload(1));
        assertSame(reqB, getChunkPayload(2));
        assertSame(resB, getChunkPayload(3));
    }

    @Test
    public void testHttp2ThreeStreamsOutOfOrder() {
        PayloadChunk req1 = makeHttpRequest(1);
        PayloadChunk req3 = makeHttpRequest(3);
        PayloadChunk req5 = makeHttpRequest(5);
        // replies arrive in reverse order
        PayloadChunk res5 = makeHttpResponse(5);
        PayloadChunk res1 = makeHttpResponse(1);
        PayloadChunk res3 = makeHttpResponse(3);

        adapter.onChunkReassembled(req1);
        adapter.onChunkReassembled(req3);
        adapter.onChunkReassembled(req5);
        adapter.onChunkReassembled(res5);
        adapter.onChunkReassembled(res1);
        adapter.onChunkReassembled(res3);

        assertEquals(6, getChunks().size());
        // expect: req1, res1, req3, res3, req5, res5
        assertSame(req1, getChunkPayload(0));
        assertSame(res1, getChunkPayload(1));
        assertSame(req3, getChunkPayload(2));
        assertSame(res3, getChunkPayload(3));
        assertSame(req5, getChunkPayload(4));
        assertSame(res5, getChunkPayload(5));
    }

    @Test
    public void testHttp2RstMatchesByStream() {
        PayloadChunk req1 = makeHttpRequest(1);
        PayloadChunk req3 = makeHttpRequest(3);
        // RST for stream 3
        PayloadChunk rst3 = makeHttp2Rst(3);
        PayloadChunk res1 = makeHttpResponse(1);

        adapter.onChunkReassembled(req1);
        adapter.onChunkReassembled(req3);
        adapter.onChunkReassembled(rst3);
        adapter.onChunkReassembled(res1);

        // RST is not inserted into the list, so only 3 items
        assertEquals(3, getChunks().size());
        assertSame(req1, getChunkPayload(0));
        assertSame(res1, getChunkPayload(1));
        assertSame(req3, getChunkPayload(2));
    }

    // ========== Edge cases ==========

    @Test
    public void testUnmatchedReply() {
        // reply arrives with no pending request
        PayloadChunk res = makeHttpResponse(1);
        adapter.onChunkReassembled(res);

        // should be appended at the end
        assertEquals(1, getChunks().size());
        assertSame(res, getChunkPayload(0));
    }

    @Test
    public void testRequestOnly() {
        PayloadChunk req = makeHttpRequest(1);
        adapter.onChunkReassembled(req);

        assertEquals(1, getChunks().size());
        assertSame(req, getChunkPayload(0));
    }

    // ========== JSON pretty-printing ==========

    @Test
    public void testJsonBodyIsPrettyPrinted() {
        String headers = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n";
        String raw = headers + "{\"name\":\"test\",\"value\":42}";
        String result = PayloadAdapter.formatHttpPayload(raw, "application/json");

        String expected = headers + "{\n  \"name\": \"test\",\n  \"value\": 42\n}";
        assertEquals(expected, result);
    }

    @Test
    public void testPostJsonBodyIsPrettyPrinted() {
        String headers = "POST /api/data HTTP/1.1\r\nHost: example.com\r\nContent-Type: application/json\r\n\r\n";
        String raw = headers + "{\"name\":\"test\",\"value\":42}";
        String result = PayloadAdapter.formatHttpPayload(raw, "application/json");

        String expected = headers + "{\n  \"name\": \"test\",\n  \"value\": 42\n}";
        assertEquals(expected, result);
    }

    @Test
    public void testJsonArrayIsPrettyPrinted() {
        String headers = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n";
        String raw = headers + "[{\"id\":1},{\"id\":2}]";
        String result = PayloadAdapter.formatHttpPayload(raw, "application/json");

        String expected = headers + "[\n  {\n    \"id\": 1\n  },\n  {\n    \"id\": 2\n  }\n]";
        assertEquals(expected, result);
    }

    @Test
    public void testNonJsonContentTypeIsUnchanged() {
        String headers = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n";
        String raw = headers + "{\"name\":\"test\"}";
        assertEquals(raw, PayloadAdapter.formatHttpPayload(raw, "text/html"));
    }

    @Test
    public void testNullContentTypeIsUnchanged() {
        String headers = "HTTP/1.1 200 OK\r\n\r\n";
        String raw = headers + "{\"name\":\"test\"}";
        assertEquals(raw, PayloadAdapter.formatHttpPayload(raw, null));
    }

    @Test
    public void testInvalidJsonFallsBackToRaw() {
        String headers = "HTTP/1.1 200 OK\r\n\r\n";
        String raw = headers + "{\"name\":\"test\", truncated";
        assertEquals(raw, PayloadAdapter.formatHttpPayload(raw, "application/json"));
    }

    @Test
    public void testHeadersOnlyIsUnchanged() {
        String raw = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n";
        assertEquals(raw, PayloadAdapter.formatHttpPayload(raw, "application/json"));
    }

    @Test
    public void testLargePayloadIsNotFormatted() {
        String headers = "HTTP/1.1 200 OK\r\n\r\n";
        StringBuilder sb = new StringBuilder(headers);
        sb.append("{\"data\":\"");
        for (int i = 0; i < PayloadAdapter.MAX_JSON_FORMAT_SIZE; i++)
            sb.append('x');
        sb.append("\"}");

        String raw = sb.toString();
        assertEquals(raw, PayloadAdapter.formatHttpPayload(raw, "application/json"));
    }

    @Test
    public void testNonJsonBodyIsUnchanged() {
        String headers = "HTTP/1.1 200 OK\r\n\r\n";
        String raw = headers + "plain text body, not json";
        assertEquals(raw, PayloadAdapter.formatHttpPayload(raw, "application/json"));
    }

    @Test
    public void testHttp2InterleavedRequestsAndReplies() {
        PayloadChunk req1 = makeHttpRequest(1);
        PayloadChunk res1 = makeHttpResponse(1);
        PayloadChunk req3 = makeHttpRequest(3);
        PayloadChunk res3 = makeHttpResponse(3);

        adapter.onChunkReassembled(req1);
        adapter.onChunkReassembled(res1);
        adapter.onChunkReassembled(req3);
        adapter.onChunkReassembled(res3);

        assertEquals(4, getChunks().size());
        assertSame(req1, getChunkPayload(0));
        assertSame(res1, getChunkPayload(1));
        assertSame(req3, getChunkPayload(2));
        assertSame(res3, getChunkPayload(3));
    }
}

```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.13.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
        maven { url 'https://jitpack.io' }
    }
    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`docs/app_api.md`:

```md
PCAPdroid exposes an API for other apps to configure and control the packet capture. This can be used to easily enable packet capture in your app, provided that the PCAPdroid app is also installed into the device.

## The API

The [CaptureCtrl.java](https://github.com/emanuele-f/PCAPdroid/blob/master/app/src/main/java/com/emanuelef/remote_capture/activities/CaptureCtrl.java) activity is the one exposed to allow you to control the PCAPdroid capture via Intents.

The activity can be easily invoked from the cli by running:

```bash
adb shell am start -e action [ACTION] -e api_key [API_KEY] -e [SETTINGS] -n com.emanuelef.remote_capture/.activities.CaptureCtrl
```

where ACTION is one of:
  - `start`: starts the capture with the specified parameters
  - `stop`: stops the capture
  - `get_status`: get the capture status

The `api_key` parameter usage is described in the [User Consent section](#user-consent) below.

*Note*: to start the *beta* apk of PCAPdroid (debug build), use the following component name instead (`-n` parameter):

```
com.emanuelef.remote_capture.debug/com.emanuelef.remote_capture.activities.CaptureCtrl
```

The capture parameters are specified via Intent extras, which are discussed below.
For example, you can use the following command to start the capture and write the traffic dump to the PCAP file `Download/PCAPdroid/traffic.pcap`:

```bash
adb shell am start -e action start -e pcap_dump_mode pcap_file -e pcap_name traffic.pcap -n com.emanuelef.remote_capture/.activities.CaptureCtrl
```

A common task is to capture the traffic of a specific app to analyze it into your app. This can be easily accomplished by running PCAPdroid in the
[UDP Exporter mode](https://emanuele-f.github.io/PCAPdroid/dump_modes#24-udp-exporter):

```bash
adb shell am start -e action start -e pcap_dump_mode udp_exporter -e collector_ip_address 127.0.0.1 -e collector_port 5123 -e app_filter org.mozilla.firefox -n com.emanuelef.remote_capture/.activities.CaptureCtrl
```

then your app can listen for UDP packets on port `5123` to handle the Firefox network packets.
Another interesting option is to enable the [dump_extensions](https://emanuele-f.github.io/PCAPdroid/advanced_features#45-pcapdroid-extensions) to be able to get the app UID/name into your app.

The Intent above can also be triggered programmatically from your app:

```java
class YourActivity extends Activity {
  private final ActivityResultLauncher<Intent> captureLauncher =
    registerForActivityResult(new StartActivityForResult(), this::handleCaptureResult);

  void startCapture() {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setClassName("com.emanuelef.remote_capture", "com.emanuelef.remote_capture.activities.CaptureCtrl");

    intent.putExtra("action", "start");
    intent.putExtra("pcap_dump_mode", "udp_exporter");
    intent.putExtra("collector_ip_address", "127.0.0.1");
    intent.putExtra("collector_port", "5123");
    intent.putExtra("app_filter", "org.mozilla.firefox");

    captureLauncher.launch(intent);
  }

  void handleCaptureResult(final ActivityResult result) {
    if(result.getResultCode() == RESULT_OK) {
      // command executed successfully
    }
  }
}
```

The result code tells if the command succeded or not. Check out the [PCAPReceiver sample app](https://github.com/emanuele-f/PCAPReceiver) for a working example.

## User Consent

To prevent malicious apps from monitoring/hijacking the device traffic, PCAPdroid will ask for user consent every time a capture is started, unless a valid `api_key` is provided (see below). If the user denies consent, then the request fails. After an app is granted start permission, subsequent requests from that app are automatically granted.

From the permission dialog the user can choose to permanently grant or deny the capture permission to an app. The permanently granted/denied permissions can be edited from the `Control Permissions` entry in the PCAPdroid settings.

Applications interfacing with PCAPdroid should use the `startActivityForResult` (or the equivalent `ActivityResultLauncher`) when calling its API, rather than `startActivity`. This ensures that the package name of the calling app can be retrieved via [getCallingPackage](https://developer.android.com/reference/android/app/Activity#getCallingPackage()).

### API Key

Since PCAPdroid 1.8.6, you can pass an `api_key` parameter in the Intent to authenticate the request without showing the permission prompt. This is useful, in particular, when invoking PCAPdroid from adb or a third-party app which does not support `startActivityForResult`.

You can generate an API key from the hamburger menu of the `Control Permissions` page, in the the PCAPdroid settings. Then set it as an Intent extra:

```
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setClassName("com.emanuelef.remote_capture", "com.emanuelef.remote_capture.activities.CaptureCtrl");
...
intent.putExtra("api_key", "your_api_key_here");
```

## Capture Settings

As shown above, the capture settings can be specified by using intent extras. The updated list of all the supported parameters is available in
[CaptureSettings.java](https://github.com/emanuele-f/PCAPdroid/blob/master/app/src/main/java/com/emanuelef/remote_capture/model/CaptureSettings.java).

| Parameter               | Type   | Ver | Mode | Value                                                                                                                                 |
|-------------------------|--------|-----|------|---------------------------------------------------------------------------------------------------------------------------------------|
| pcap_dump_mode          | string |     |      | none \| http_server \| udp_exporter \| tcp_exporter \| pcap_file                                                                      |
| app_filter              | string |     |      | package name of the app(s) to capture (73+: comma separated list)                                                                     |
| collector_ip_address    | string |     |      | the IP address of the collector in tcp/udp_exporter mode                                                                              |
| collector_port          | int    |     |      | the UDP port of the collector in tcp/udp_exporter mode                                                                                |
| http_server_port        | int    |     |      | the HTTP server port in http_server mode                                                                                              |
| pcap_uri                | string |     |      | the URI for the PCAP dump in pcap_file mode (overrides pcap_name)                                                                     |
| socks5_enabled          | bool   |     | vpn  | true to redirect the TCP connections to a SOCKS5 proxy                                                                                |
| socks5_proxy_ip_address | string |     | vpn  | (deprecated) the SOCKS5 proxy IP address. Alias for socks5_proxy_host since version 90                                                |
| socks5_proxy_port       | int    |     | vpn  | the SOCKS5 proxy port                                                                                                                 |
| root_capture            | bool   |     |      | true to capture packets in root mode, false to use the VPNService                                                                     |
| pcapdroid_trailer       | bool   |     |      | (deprecated) alias for dump_extensions                                                                                                |
| capture_interface       | string |     | root | @inet \| any \| ifname - network interface to use in root mode                                                                        |
| snaplen                 | int    | 43  |      | max size in bytes for each individual packet in the PCAP dump                                                                         |
| max_pkts_per_flow       | int    | 43  |      | only dump the first max_pkts_per_flow packets per flow                                                                                |
| max_dump_size           | int    | 43  |      | max size in bytes for the PCAP dump                                                                                                   |
| tls_decryption          | bool   | 49  | vpn  | true to enable the built-in TLS decryption                                                                                            |
| auto_block_private_dns  | bool   | 51  | vpn  | true to detect and possibly block private DNS to inspect traffic                                                                      |
| ip_mode                 | string | 56  | vpn  | which IP addresses to use for the VPN: ipv4 \| ipv6 \| both                                                                           |
| mitmproxy_opts          | string | 62  |      | additional options to provide to mitmproxy in decryption mode                                                                         |
| pcap_name               | string | 62  |      | write the PCAP to Download/PCAPdroid/*pcap_name* in pcap_file mode                                                                    |
| pcapng_format           | bool   | 62  |      | true to use the PCAPNG dump format*                                                                                                   |
| socks5_username         | string | 64  | vpn  | username for the optional SOCKS5 proxy authentication                                                                                 |
| socks5_password         | string | 64  | vpn  | password for the optional SOCKS5 proxy authentication                                                                                 |
| block_quic              | string | 73  | vpn  | never \| always \| to_decrypt (matching the decryption whitelist)                                                                     |
| dump_extensions         | bool   | 79  |      | extend the packet dump format with additional metadata                                                                                |
| sslkeylog_name          | bool   | 89  | vpn  | dump the SSLKEYLOGFILE to the /sdcard/Downloads/PCAPDroid directory with the given name                                               |
| decryption_rules        | string | 89  | vpn  | provide decryption rules as json (e.g. [{"type":"APP","value":"com.example.app"},{"type":"IP","value":"1.1.1.1"}])                    |
| full_payload            | bool   | 89  |      | true to dump the full payload of the packets                                                                                          |
| socks5_proxy_host       | string | 90  | vpn  | the SOCKS5 proxy IP address or hostname                                                                                               |

\*: paid feature

The `Ver` column indicates the minimum PCAPdroid version required to use the given parameter. The PCAPdroid version can be queried via the `get_status` action as explained below.
The `Mode` column indicates if the option applies to any mode or only to the VPN or root mode.

*NOTE*: for security reasons, since version 1.5.3 you cannot specify a remote server address in `collector_ip_address` or in `socks5_proxy_ip_address`/`socks5_proxy_host`. If you really want to do this, you should first set such a remote address via the PCAPdroid gui and only then invoke the API.

*NOTE*: since version 1.6.0, the `pcap_uri` behavior is changed as described in the `Dumping PCAP to file` section below

## Query the Capture Status

It is possible to check if the capture is currently running by sending an Intent with the `get_status` action. The response Intent contains the following extras:

| Field               | Type   | Value                                                             |
|---------------------|--------|-------------------------------------------------------------------|
| version_name        | string | the PCAPdroid versionName (e.g. "1.4.5")                          |
| version_code        | int    | the PCAPdroid versionCode, an incremental number for the release  |
| running             | bool   | true if the capture is running                                    |

Other than via the API, the capture may be manually stopped by the user from the PCAPdroid app. In order to be notified when the capture is stopped, you can create a `BroadcastReceiver` and subscribe to the `com.emanuelef.remote_capture.CaptureStatus` action. Here is an example:

```xml
<receiver android:name=".MyBroadcastReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
        <action android:name="com.emanuelef.remote_capture.CaptureStatus" />
    </intent-filter>
</receiver>
```

To tell PCAPdroid to send the Intent to your receiver, you must specify its class name in the `broadcast_receiver` extra of the start intent:

```java
intent.putExtra("action", "start");
intent.putExtra("broadcast_receiver", "com.emanuelef.pcap_receiver.MyBroadcastReceiver");
...
captureStartLauncher.launch(intent);
```

The receiver will get an intent with the `running` extra set to `false` when the capture is stopped.

## Capture Stats

In the result of the `stop` and `get_status` actions and in the broadcast of `CaptureStatus`, PCAPdroid provides the following capture stats in the form of Intent extras:

| Field               | Type   | Ver |  Value                                                             |
|---------------------|--------|-----|--------------------------------------------------------------------|
| bytes_sent          | long   |  50 | bytes sent (from the device to the Internet)                       |
| bytes_rcvd          | long   |  50 | bytes received (from the Internet to the device)                   |
| bytes_dumped        | long   |  50 | size of the PCAP dump                                              |
| pkts_sent           | int    |  50 | packets sent                                                       |
| pkts_rcvd           | int    |  50 | packets received                                                   |
| pkts_dropped        | int    |  50 | in root mode, number of packets not analyzed and not dumped        |
| ipv6_bytes_sent     | long   |  74 | IPv6 bytes sent (from the device to the Internet)                  |
| ipv6_bytes_recv     | long   |  74 | IPv6 bytes received (from the Internet to the device)              |

## Dumping PCAP to file

[Scoped storage](https://developer.android.com/about/versions/11/privacy/storage) restrictions apply to PCAPdroid, which limits in which paths the PCAP file can be stored and how
other apps can access it.

Since version 1.6.0, PCAPdroid dumps the PCAP file to the `Download/PCAPdroid` directory. By using the `pcap_name` parameter, you can get a predictable PCAP file path. The PCAP
file is overwritten if another file with the same `pcap_name` exists.

You can use the `pcap_uri` parameter to write the PCAP file to an arbitrary path. The URI specified in `pcap_uri`, however, is only used as an identifier, it's not the actual file
path. This choice has been made to cope with the scoped storage limitations. This means that, the first time the `pcap_uri` is set and every time it's changed, a file dialog is
displayed to the user to pick the actual file path. On subsequent runs, the same `pcap_uri` identifier can be used to write the selected file without the file dialog to be
presented to the user.

```

`docs/edge-to-edge.md`:

```md
# Edge-to-edge support in PCAPdroid

This document gives a brief introduction to edge-to-edge and contains the guidelines on how to implement proper edge-to-edge support for new views and activities.

See https://medium.com/androiddevelopers/insets-handling-tips-for-android-15s-edge-to-edge-enforcement-872774e8839b for a detailed description.

- Android 35 forces apps to be edge-to-edge
- It's temporary possible to opt out by applying a custom style:

```
<!-- In values-v35.xml -->
<resources>
    <!-- TODO: Remove once activities handle insets. -->
    <style name="OptOutEdgeToEdgeEnforcement">
        <item name="android:windowOptOutEdgeToEdgeEnforcement">true</item>
    </style>
</resources>
```

- Implementing edge-to-edge support requires a lot of efforts, in particular to handle all the possible cases for insets
- Moreover, there can be issues which only appear on older Android versions (e.g. Android 9, see adbc33afe55f2c1795d250707fc3f29aadacdbb0)
- When edge-to-edge support is enabled, it breaks the ability to select a custom theme, see 5f50ae30c1e8b4f2ce73cb684066d12fb0d65b0a

# How it works

- inset types:
  - WindowInsetsCompat.Type.statusBars: the status bar, which is the one with icons and wall clock
  - WindowInsetsCompat.Type.systemBars: any system bar, e.g. 3-buttons navigation bar
  - WindowInsetsCompat.Type.displayCutout: cutouts in the displays, e.g. camera holes
  - WindowInsetsCompat.Type.ime: virtual keyboard. Handling of this inset is not usually required, but it allows to get a better behavior on IME open
    - e.g. to resize the ReciclerView to make all the items visible on screen

- insets handling works hierarchically:
  - the top views first get a chance to handle the insets
  - if the top views don't consume the insets, they get propagated to the children
  - it's unclear how it affects siblings, but it does, see issues on Android 9 adbc33afe55f2c1795d250707fc3f29aadacdbb0

- insets can either be handled via:
  - ViewCompat.setOnApplyWindowInsetsListener
    - you can choose to consume or not the insets
    - makes it possible to implement edge-to-edge
  - fitsSystemWindows="true"
    - it always *consumes* all the insets
    - it just adds margins, without proper edge-to-edge support. Normally it should not be used

- ViewPager2 does not handle insets dispatching properly
  - https://issuetracker.google.com/issues/145617093#comment10
  - to fix it, it's necessary to dispatch the insets manually on tab change: ViewCompat.dispatchApplyWindowInsets
    - see Utils.fixViewPager2Insets

# Guidelines

- To enable proper edge-to-edge support, in particular on older platforms, when creating an Activity be sure to either:
  - just inherit from BaseActivity, which internally calls Utils.enableEdgeToEdge and handles the insets for the toolbar (preferred approach)
  - call Utils.enableEdgeToEdge manually in onCreate, before super.onCreate

- The activity layout must use AppBarLayout and Toolbar (with id `toolbar`) in a CoordinatorLayout. See how it is done for other activities (e.g. about_activity.xml)
  - this makes proper space for the toolbar
  - when possible, reuse `fragment_activity.xml`, for simple activities made of just 1 fragment
  - for tab-based activities, either use `tab_activity.xml` or `tab_activity_fixed.xml`. In the latter case, be sure to call `Utils.fixScrollableTabLayoutInsets`
  - the toolbar needs some top insets handling; if you inherit from BaseActivity, this is already implemented

- When using ViewPager2, be sure to call Utils.fixViewPager2Insets to properly dispatch insets to sub-views
- For ReciclerViews, use EmptyRecyclerView when possible, which already handles insets, IME (virtual keyboard), uses setClipToPadding(false) for edge-to-edge support
- For ListViews, use Utils.fixListviewInsetsBottom for edge-to-edge support

- New activity testing:
  - test with 3-buttons bottom navbar. This can be enabled from the Android settings
  - to properly test scrolling behavior, ensure to populate the views
  - test horizontal insets with rotated device
  - test with IME open/closed in views that use it
  - test on the newest Android version
  - test on Android 9 or lower, as some bugs are only visible there (e.g. adbc33afe55f2c1795d250707fc3f29aadacdbb0)

```

`docs/how_it_works.md`:

```md
This document complements the [Packet Analysis](https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis) section of the user manual to explain how the traffic is managed by PCAPdroid in non-root mode.

PCAPdroid uses the VPNService to capture the network traffic. When the VPNService is active, the traffic is routed to the PCAPdroid app,
which implements a L4 proxy to connect it back to the Internet. The VPNService alone alters the traffic because it uses a different subnet and network interface.
Moreover, what you see in PCAPdroid or in the generated PCAP file is the traffic which goes from the app to the VPNService, but you cannot see the traffic which goes from the VPNService to the Internet.

When the app makes a connection, `saddr1:sport1 -> daddr:dport` (the original), PCAPdroid creates a new connection `saddr2:sport2 -> daddr:dport` (the proxied) which goes over the Internet.
The PCAP generated by PCAPdroid only shows the original connection, but if you capture the data on your router you will capture the proxied connection instead.
The obvious difference between the two is that the source IP address and port are different. Actually, since the L4 proxy works by using L4 sockets, the whole IP and TCP header may also be different (apart from the destination IP address and port, which is the same).

In fact PCAPdroid needs to emulate the TCP features like the TCP window, SEQ and ACK numbers by building fake IP/L4 headers. It does this well enough to trick the app into thinking that it's talking to the remote site, whereas in reality it's talking to the L4 proxy.

```
What app thinks:
  app <-> Internet
 
The reality:
  app <-> PCAPDroid (VPNService) <-> Internet
```

The L4 proxy cannot determine if the data received from the L4 socket was sent as a single packet or multiple packets from the remote site. This is why you cannot reliably use the generated PCAP to perform per-packet analysis.

```

`docs/languages.md`:

```md
To provide a consistent user experience, languages with missing translations are excluded from the app build.
Usually this means languages with 5% or more untranslated strings. Such languages may still be present in the resources folder, however they won't be usable by the users.

The languages currently included into the app need to be specified in 2 places:

- `resourceConfigurations` in `app/build.gradle`: specifies the folder names of the actual translations to include
- `app/src/main/res/xml/locales_config.xml`: specifies the locales which are displayed in the Android own language selector

Note: the locale name in `locales_config.xml` can differ from the language specified in `resourceConfigurations`, see
https://developer.android.com/guide/topics/resources/app-languages#sample-config for some examples

## Updating translations

The `tools/weblate.py` script automates cherry-picking translation commits from the `weblate` remote.
It assumes a `weblate` git remote is configured:

```
git remote add weblate https://hosted.weblate.org/git/pcapdroid/app
```

The correct way to update translations is:

1. Merge origin into weblate
2. Git fetch weblate
3. run the locale update script and push the commits
4. Merge origin into weblate again

The script tracks the last cherry-picked commit for each locale in `tools/weblate_status`.
Only locales listed in `resourceConfigurations` in `app/build.gradle` are considered.

Available commands:

- `tools/weblate.py status` — show which locales have pending translation commits
- `tools/weblate.py update` — cherry-pick pending commits for all supported locales
- `tools/weblate.py update <locale>` — cherry-pick pending commits for a single locale (e.g. `ru`)

Consecutive commits by the same author are automatically squashed into one.
After processing a locale, the script verifies that the local file matches `weblate/master`; if not, it exits with an error for manual resolution.

## Adding a new language

Here is a summary of the steps needed to add a new language:

1. The language translation first needs to be completed on [Weblate](https://hosted.weblate.org/projects/pcapdroid)
2. `build.gradle` and `locales_config.xml` are updated as explained above
3. Run `tools/weblate.py update <locale>` to cherry-pick the translation commits

```

`docs/testing.md`:

```md
## Running tests

Tests in PCAPdroid can be split in the following categories:

- [Java tests](https://github.com/emanuele-f/PCAPdroid/tree/master/app/src/test/java):
  they can be run via `./gradlew test`. They use the
  [robolectric framework](https://github.com/robolectric/robolectric)
  to mock the Android API, allowing them to be run locally (without an Android device).

- [Native tests](https://github.com/emanuele-f/PCAPdroid/tree/master/app/src/main/jni/tests):
  tests and fuzzing targets for native code. Check out their readme for more details.

The tests are executed on every push via the
[Github workflows](https://github.com/emanuele-f/PCAPdroid/tree/master/.github/workflows).

Apart from automatic tests, the following manual tests should be performed
before every release:

- Test on devices matching the `minSdkVersion` (currently Android SDK 21)
- Test on devices matching the `targetSdkVersion` (currently Android SDK 31)
- Rotate the device, put activity in background, clear from recent activities
- Java memory consumption tests via the [Memory Profiler](https://developer.android.com/studio/profile/memory-profiler)
- Manual malware detection test against `internetbadguys.com` and `0.0.0.1`

## VPN mode performance

Performance is essential in VPN mode, as PCAPdroid can become a bottleneck, reducing the max bandwidth. While testing performance, it's useful to measure both the bandwidth and the CPU usage. In fact, a 100% cpu usage on the PCAPdroid process indicates that the capture thread has reached its limit, whereas a lower usage indicates that there could be a problem in the handling of packets (e.g. with the TCP window size).

A basic setup for a vpn performance measurement requires:

- the `iperf3` package, installed in termux, to measure the bandwidth
- the `top` utility, run via `adb`, to get the pcapdroid cpu usage. USB connection is advided to avoid losing the connection on vpn start/stop
- an high throughput wifi connection, e.g. a 5 GHz. The network should not be the bottleneck for the test
- a phone with good wifi hw. Again, it should not be the bottleneck
- a pc connected to the same network via gigabit ethernet

Since the VPN mode only captures connections initiaded from the device, the iperf3 client must be run on the Android device. To run commands more easily, it's adviced to run an sshd daemon via termux and connect to it from the pc.

Here are the commands to run on the phone to perform the different tests with a given bandwidth, assuming iperf3 server running on 192.168.1.10.

- UDP upload: `iperf3 -u -c 192.168.1.10 -b 100M --length 1472`
- UDP download: `iperf3 -u -R -c 192.168.1.10 -b 100M --length 1472`
- TCP upload: `iperf3 -c 192.168.1.10 -b 100M`
- TCP download: `iperf3 -c -R 192.168.1.10 -b 100M`

The `-R` flag enables the reverse mode, which makes the iperf3 client receive data from the server. It's advided to first run the tests without PCAPdroid running to ensure that no bottlenecks are present.

```

`docs/work_profiles.md`:

```md
## Running in work profiles

Work profiles allows users to isolate apps. They also allow running multiple VPN at the same time, as each work profile can run a VPNService.

When PCAPdroid runs in a work profile in VPN mode, it can only capture the traffic of the work profile.

You can install [Island](https://play.google.com/store/apps/details?id=com.oasisfeng.island) to manage work profiles

## Root support

When running with root, PCAPdroid still captures the traffic of the whole device, regardless if it's installed in the main profile or in the work profile.
To properly map UIDs of apps installed into different profiles, it uses the [INTERACT_ACROSS_USERS permission](https://source.android.com/devices/tech/admin/multiuser-apps),
which is granted on the first root capture start. Apps installed in both the main profile and a work profile will have two different UIDs, and are reported
by PCAPdroid as two different apps.

In order to properly grant root privileges to PCAPdroid when installed in a work profile, follow these steps:

1. In the Magisk manager settings, set Multiuser-mode to "User independent"
2. Clone the Magisk manager app to the work profile
3. Start the root capture and grant the root request from magisk dialog

## Debugging

To easily debug PCAPdroid in work profile, create a new run configuration which installs and runs the app into the specific work profile.

First get the work profile user ID from `adb shell pm list users` (e.g. 10). Then add the `--user 10` parameter to the "Install flags" and "Launch flags" of the new configuration.

```

`fastlane/metadata/android/ar/full_description.txt`:

```txt
<i>PCAPdroid</i> هو تطبيق صديق للخصوصية يتيح لك تتبع وتحليل الاتصالات التي تجريها التطبيقات الأخرى في جهازك.
كما يسمح لك بتصدير تفريغ PCAP لحركة المرور، وفحص HTTP، وفك تشفير حركة مرور TLS، وغير ذلك الكثير.

يحاكي PCAPdroid شبكة VPN لالتقاط حركة مرور الشبكة دون الحاجة إلى الجذر. ولا يستخدم خادم VPN عن بعد، وبدلاً من ذلك تتم معالجة البيانات محليًا على الجهاز.

<b>الميزات:</b>

* تسجيل وفحص الاتصالات التي أجراها المستخدم وتطبيقات النظام
* استخرج SNI واستعلام DNS وعنوان URL HTTP وعنوان IP البعيد
* فحص طلبات HTTP والردود بفضل وحدات فك التشفير المضمنة
* فحص حمولة الاتصالات الكاملة كـ hexdump/text
* فك تشفير حركة مرور HTTPS/TLS وتصدير ملف SSLKEYLOGFILE
* تفريغ حركة المرور إلى ملف PCAP، أو تنزيله من متصفح، أو بثه إلى جهاز استقبال بعيد لتحليله في الوقت الفعلي (مثل Wireshark)
* إنشاء قواعد لتصفية حركة المرور الجيدة واكتشاف الحالات الشاذة بسهولة
* تحديد البلد ورقم ASN للخادم البعيد عبر عمليات البحث في قاعدة البيانات دون اتصال بالإنترنت
* على الأجهزة ذات الجذور، يمكنك التقاط حركة المرور أثناء تشغيل تطبيقات VPN الأخرى

إذا كنت تخطط لاستخدام PCAPdroid لإجراء تحليل الحزم، فيُرجى مراجعة <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>القسم المحدّد</a> من الدليل.

انضم إلى مجتمع PCAPdroid الدولي على <a href="https://t.me/PCAPdroid">تيليجرام</a> أو على <a href="https://matrix.to/#/#pcapdroid:matrix.org">ماتركس</a>.

```

`fastlane/metadata/android/ar/short_description.txt`:

```txt
أداة مراقبة الشبكة بدون جذر (root) وتفريغ حركة المرور لأجهزة أندرويد

```

`fastlane/metadata/android/de/full_description.txt`:

```txt
<i>PCAPdroid</i> ist eine datenschutzfreundliche App, mit der Sie die von anderen Apps auf Ihrem Gerät hergestellten Verbindungen verfolgen und analysieren können.
Es ermöglicht Ihnen auch, einen PCAP-Dump des Datenverkehrs zu exportieren, HTTP zu untersuchen, TLS-Datenverkehr zu entschlüsseln und vieles mehr.

PCAPdroid simuliert ein VPN, um den Netzwerkverkehr ohne Root abzufangen. Es wird kein Remote-VPN-Server verwendet, sondern die Daten werden lokal auf dem Gerät verarbeitet.

<b>Eigenschaften:</b>

* Protokollieren und untersuchen Sie die Verbindungen, die von Benutzer- und System-Apps hergestellt wurden
* Extrahieren Sie SNI, DNS-Abfrage, HTTP-URL und die Remote-IP-Adresse
* Untersuchen Sie HTTP-Anforderungen und -Antworten dank der eingebauten Decoder
* Überprüfen Sie die vollständige Verbindungsnutzlast als Hexdump/Text
* Entschlüsseln Sie den HTTPS/TLS-Verkehr und exportieren Sie die SSLKEYLOGFILE
* Dump den Datenverkehr in eine PCAP-Datei, lade ihn von einem Browser herunter oder streame ihn zur Echtzeitanalyse an einen entfernten Empfänger (z. B. Wireshark)
* Erstellen Sie Regeln, um den guten Verkehr herauszufiltern und Anomalien leicht zu erkennen
* Identifizieren Sie das Land und die ASN des Remote-Servers über Offline-DB-Lookups
* Erfassen Sie auf gerooteten Geräten den Datenverkehr, während andere VPN-Apps ausgeführt werden

Wenn Sie planen, PCAPdroid zur Durchführung von Paketanalysen zu verwenden, lesen Sie bitte den <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>spezifischen Abschnitt</a> im Handbuch.

Treten Sie der internationalen PCAPdroid-Community auf <a href="https://t.me/PCAPdroid">Telegram</a> oder auf <a href="https://matrix.to/#/#pcapdroid:matrix.org bei ">Matrix</a>.

```

`fastlane/metadata/android/de/short_description.txt`:

```txt
No-Root Netzwerk Monitor und Traffic Dump Tool für Android Geräte

```

`fastlane/metadata/android/en-US/full_description.txt`:

```txt
<i>PCAPdroid</i> is a privacy-friendly app which lets you track and analyze the connections made by the other apps in your device.
It also allows you to export a PCAP dump of the traffic, inspect HTTP, decrypt TLS traffic and much more.

PCAPdroid simulates a VPN in order to capture the network traffic without root. It does not use a remote VPN server, instead data is processed locally on the device.

<b>Features:</b>

* Log and examine the connections made by user and system apps
* Extract the SNI, DNS query, HTTP URL and the remote IP address
* Inspect HTTP requests and replies thanks to the built-in decoders
* Inspect the full connections payload as hexdump/text
* Decrypt the HTTPS/TLS traffic and export the SSLKEYLOGFILE
* Dump the traffic to a PCAP file, download it from a browser, or stream it to a remote receiver for real-time analysis (e.g. Wireshark)
* Create rules to filter out the good traffic and easily spot anomalies
* Identify the country and ASN of remote server via offline DB lookups
* On rooted devices, capture the traffic while other VPN apps are running

If you plan to use PCAPdroid to perform packet analysis, please check out <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>the specific section</a> of the manual.

Join the PCAPdroid international community on <a href="https://t.me/PCAPdroid">Telegram</a> or on <a href="https://matrix.to/#/#pcapdroid:matrix.org">Matrix</a>.

```

`fastlane/metadata/android/en-US/short_description.txt`:

```txt
No-root network monitor and traffic dump tool for Android devices

```

`fastlane/metadata/android/es/full_description.txt`:

```txt
<i>PCAPdroid</i> es una aplicación respetuosa con la privacidad que le permite rastrear y analizar las conexiones realizadas por otras aplicaciones en su dispositivo.
También le permite exportar un volcado PCAP del tráfico, inspeccionar HTTP, descifrar el tráfico TLS y mucho más.

PCAPdroid simula una VPN para capturar el tráfico de red sin root. No utiliza un servidor VPN remoto, sino que los datos se procesan localmente en el dispositivo.

<b>Características:</b>

* Registrar y examinar las conexiones realizadas por el usuario y las aplicaciones del sistema
* Extraiga el SNI, la consulta DNS, la URL HTTP y la dirección IP remota
* Inspeccione las solicitudes y respuestas HTTP gracias a los decodificadores incorporados
* Inspeccionar la carga útil de conexiones completas como hexdump/text
* Descifrar el tráfico HTTPS/TLS y exportar el SSLKEYLOGFILE
* Vuelque el tráfico a un archivo PCAP, descárguelo desde un navegador o transmítalo a un receptor remoto para un análisis en tiempo real (por ejemplo, Wireshark)
* Cree reglas para filtrar el buen tráfico y detectar anomalías fácilmente
* Identifique el país y el ASN del servidor remoto a través de búsquedas de base de datos fuera de línea
* En dispositivos rooteados, capture el tráfico mientras se ejecutan otras aplicaciones VPN

Si planea usar PCAPdroid para realizar análisis de paquetes, consulte <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>la sección específica</a> de el manual.

Únase a la comunidad internacional de PCAPdroid en<a href="https://t.me/PCAPdroid">Telegrama</a>o en<a href="https://matrix.to/#/#pcapdroid:matrix.org">Matrix</a>.

```

`fastlane/metadata/android/es/short_description.txt`:

```txt
Supervise y capture el tráfico de dispositivos Android no rooteados

```

`fastlane/metadata/android/id/full_description.txt`:

```txt
<i>PCAPdroid</i> adalah aplikasi yang ramah privasi yang memungkinkan Anda melacak dan menganalisis koneksi yang dibuat oleh aplikasi lain di perangkat anda.
Ini juga memungkinkan Aada untuk mengekspor PCAP dump dari lalu lintas, memeriksa lalu lintas HTTP, mendekripsi lalu lintas TLS, dan banyak lagi.

PCAPdroid mensimulasikan VPN untuk menangkap lalu lintas jaringan tanpa perlu akses root. Ini tidak menggunakan server VPN jarak jauh, sebaliknya data diproses secara lokal di perangkat.

<b>Fitur:</b>

* Merekam dan memeriksa koneksi yang dibuat oleh aplikasi pengguna dan sistem
* Ekstrak SNI, pertanyaan DNS, URL HTTP, dan alamat IP jarak jauh
* Memeriksa permintaan dan balasan HTTP berkat decoder bawaan
* Memeriksa muatan koneksi lengkap sebagai hexdump/teks
* Mendekripsi lalu lintas HTTPS/TLS dan mengekspor SSLKEYLOGFILE
* Dump lalu lintas ke file PCAP, unduh dari browser, atau alirkan ke penerima jarak jauh untuk analisis waktu nyata (misalnya Wireshark)
* Buat aturan untuk menyaring lalu lintas yang baik dan dengan mudah menemukan anomali
* Identifikasi negara dan ASN dari server jarak jauh melalui pencarian database offline
* Pada perangkat yang sudah di-root, tangkap lalu lintas saat aplikasi VPN lain berjalan

Jika Anda berencana menggunakan PCAPdroid untuk melakukan analisis paket, silakan cek bagian khusus di <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>manual</a>.

Bergabunglah dengan komunitas internasional PCAPdroid di <a href="https://t.me/PCAPdroid">Telegram</a> atau di <a href="https://matrix.to/#/#pcapdroid:matrix.org">Matrix</a>.

```

`fastlane/metadata/android/id/short_description.txt`:

```txt
Monitor jaringan tanpa root dan alat pembuangan lalu lintas untuk perangkat Android

```

`fastlane/metadata/android/it/full_description.txt`:

```txt
<i>PCAPdroid</i> è un'app privacy-friendly che ti permette di tracciare e analizzare le connessioni di rete effetuate dalle app nel tuo dispositivo.
Ti permette inoltre di salvare il traffico in formato PCAP, ispezionare l'HTTP, decritta il traffico TLS e molto altro.

Per funzionare senza root, PCAPdroid simula una connessione VPN. Non viene usato alcun server di VPN remoto. Al contrario, il traffico è processato localmente al dispositivo.

<b>Funzionalità:</b>

* Registra ed esamina le connessioni effuttuate dalle app utente e di sistema
* Estrae SNI, query DNS, URL HTTP e l'indirizzo IP del server remoto
* Ispeziona le richieste e le risposte HTTP grazie ai decodificatori integrati
* Ispeziona l'intero contenuto delle connessioni di rete, in formato esadecimale/di testo
* Decritta il traffico HTTPS/TLS ed esporta lo SSLKEYLOGFILE
* Esporta il traffico in un file PCAP, scaricalo tramite un browser o effettuane lo streaming a un collettore remoto per l'analisi in tempo reale (es. Wireshark)
* Crea regole per filtrare il traffico buono e rilevare in maniera semplice possibili anomalie
* Identifica la nazione e l'ASN dei server remoti tramite ricerche in database locali
* Su dispositivi con root, cattura il traffico mentre altre app di VPN sono in esecuzione

Se utilizzi PCAPdroid per effettuare l'analisi dei pacchetti di rete, fai riferimento <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>alla sezione specifica</a> del manuale.

Unisciti alla community internazionale di PCAPdroid su <a href="https://t.me/PCAPdroid">telegram</a> o su <a href="https://matrix.to/#/#pcapdroid:matrix.org">matrix</a>.

```

`fastlane/metadata/android/it/short_description.txt`:

```txt
Monitora e cattura il traffico di dispositivi Android senza root

```

`fastlane/metadata/android/ko-KR/full_description.txt`:

```txt
<i>PCAPdroid</i>는 다른 앱에 의해 생성된 커넥션을 추적하고 분석할 수 있는 프라이버시 친화적인 앱입니다.
또한 트래픽을 PCAP 덤프로 추출하거나, HTTP를 검사하고, TLS 트래픽 복호화 등을 할 수 있습니다.

PCAPdroid는 루트 권한 없이 네트워크 트래픽을 캡처하기 위해서 VPN을 시뮬레이션합니다. 원격 VPN 서버를 사용하지 않습니다. 모든 데이터는 디바이스 내에서 처리됩니다.

<b>기능들:</b>

* 사용자와 시스템 앱에 의해 만들어진 커넥션을 기록하고 검사합니다.
* SNI, DNS 쿼리, HTTP URL 및 원격 IP 주소를 추출합니다.
* 내장된 디코더를 이용해 HTTP 요청 및 응답을 확인합니다.
* 모든 커넥션 페이로드를 16진수 또는 텍스트로 확인합니다.
* HTTPS/TLS 트래픽을 해독하고 SSLKEYLOGFILE을 내보냅니다.
* 트래픽을 PCAP 파일로 덤프하거나, 브라우저에서 다운로드 하거나, 실시간 분석을 위해원격 리시버(와이어샤크 등)로 보냅니다.
* 정상 트래픽을 필터링하고 이상 징후를 쉽게 찾아내는 규칙을 생성합니다.
* 오프라인 DB 조회로 원격 서버의 국가 및 ASN을 식별합니다.
* 루팅된 기기에서는 다른 VPN이 실행되는 동안 트래픽을 캡처할 수 있습니다.

PCAPdroid를 사용하여 패킷 분석을 하려는 경우, 설명서의 <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>특정 섹션</a>을 확인하세요.

<a href="https://t.me/PCAPdroid">텔레그램</a> 또는 <a href="https://matrix.to/#/#pcapdroid:matrix.org">매트릭스</a>를 통해 전세계 커뮤니팅에 가입하세요.

```

`fastlane/metadata/android/ko-KR/short_description.txt`:

```txt
안드로이드 기기용 루트 권한이 불필요한 네트워크 모니터 및 트래픽 덤프 도구

```

`fastlane/metadata/android/nb-NO/full_description.txt`:

```txt
<i>PCAPdroid</i> er et personvernsvennlig program som lar deg spore og analysere tilkoblinger godt av andre programmer på enheten din.
Det lar deg også eksportere en PCAP-dump av trafikken, inspisere HTTP, dekryptere TLS-trafikk og mye mer.

PCAPdroid simulerer en VPN-kanal for å fange nettverkstilgang uten rot-tilgang. Det bruker ikke en VPN-tjener annensteds hen. All data behandles lokalt på enheten.

<b>Funksjoner:</b>

* Loggfør og inspiser tilkoblinger gjort av brukeren og systemprogrammer
* Utled SNI, DNS-spørringer, HTTP-nettadresser, og ekstern IP-adresse
* Inspiser HTTP-forespørsler og svar takket være innebygde dekodere
* Inspiser hele nyttelasten til tilkoblinger som heksadesimal dump/tekst
* Dekrypter HTTPS/TLS-trafikk og eksporter SSLKEYLOGFILE
* Dump trafikken til en PCAP-fil, last den ned fra en nettleser, eller strøm den til en fjernmottager for sanntidsanalyse (f.eks. Wireshark)
* Opprett regler for å filtrere ut den legitime trafikken og fang opp unormaliteter
* Indentifiser land og ASN tilhørende tjenere annensteds hen via frakoblede databaseoppslag
* På enheter med rot-tilgang kan du fange trafikk mens andre VPN-programmer kjører

Hvis du vil bruke PCAPdroid til pakkeanalyse kan du sjekke <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>denne delen</a> av manualen.

Ta del i gemenskapen på <a href="https://t.me/PCAPdroid">Telegram</a> eller på <a href="https://matrix.to/#/#pcapdroid:matrix.org">Matrix</a>.

```

`fastlane/metadata/android/nb-NO/short_description.txt`:

```txt
Hold øye med nettverksbruk på din Android-enhet uten å trenge rot-tilgang

```

`fastlane/metadata/android/pl-PL/full_description.txt`:

```txt
<i>PCAPdroid</i> to przyjazna dla prywatności aplikacja, która pozwala śledzić i analizować połączenia nawiązywane przez inne aplikacje na Twoim urządzeniu.
Pozwala także eksportować zrzut ruchu PCAP, sprawdzać HTTP, odszyfrowywać ruch TLS i wiele więcej.

PCAPdroid symuluje VPN w celu przechwytywania ruchu sieciowego bez rootowania. Nie korzysta ze zdalnego serwera VPN, zamiast tego dane są przetwarzane lokalnie na urządzeniu.

<b>Funkcje:</b>

* Rejestruj i sprawdzaj połączenia wykonane przez użytkownika i aplikacje systemowe
* Wyodrębnij SNI, zapytanie DNS, adres URL HTTP i zdalny adres IP
* Sprawdzaj żądania i odpowiedzi HTTP dzięki wbudowanym dekoderom
* Sprawdź payload połączeń jako zrzut szesnastkowy/tekst
* Odszyfruj ruch HTTPS/TLS i wyeksportuj SSLKEYLOGFILE
* Zrzuć ruch do pliku PCAP, pobierz go z przeglądarki lub przesyłaj strumieniowo do zdalnego odbiornika w celu analizy w czasie rzeczywistym (np. Wireshark)
* Twórz reguły, aby odfiltrować dobry ruch i łatwo wykryć anomalie
* Zidentyfikuj kraj i ASN zdalnego serwera za pomocą wyszukiwania w bazie danych offline
* Na zrootowanych urządzeniach przechwytuj ruch, gdy działają inne aplikacje VPN

Jeśli planujesz używać PCAPdroid do przeprowadzania analizy pakietów, sprawdź <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>konkretną sekcję</a> instrukcja.

Dołącz do międzynarodowej społeczności PCAPdroid na <a href="https://t.me/PCAPdroid">Telegram</a> lub na <a href="https://matrix.to/#/#pcapdroid:matrix.org ">Matrix</a>.

```

`fastlane/metadata/android/pl-PL/short_description.txt`:

```txt
Monitor sieci bez roota i narzędzie do zrzutu ruchu dla urządzeń z systemem Android

```

`fastlane/metadata/android/pt-BR/full_description.txt`:

```txt
<i>PCAPdroid</i> é um app que respeita sua privacidade, permite rastrear e analisar as conexões feitas pelos apps no seu dispositivo.
Também permite que você exporte o PCAP dump do tráfego, inspecione HTTP, decodifique o tráfego TLS e muito mais.

PCAPdroid simula uma VPN a fim de capturar o tráfego da rede sem acesso root. Não utiliza nenhum servidor remoto da VPN. Todos os dados são processados localmente no dispositivo.

<b>Funcionalidades:</b>

* Regista e examina conexões feitas pelo usuário e apps do sistema
* Extrai SNI, consultas do DNS, URLs e endereços IP remotos
* Inspeciona solicitações e respostas HTTP graças aos decodificadores integrados
* Inspeciona payload completo de conexões via hexdump/texto
* Descriptografa o tráfego HTTPS/TLS e exporta o SSLKEYLOGFILE
* Despeja o tráfego a um arquivo PCAP, pode baixá-lo de um navegador ou transmiti-lo para um receptor remoto para análise em tempo real (p.ex. wireshark)
* Cria regras para filtrar o bom tráfego e detectar facilmente as anomalias
* Identifica o país e o ASN do servidor remoto via buscas offline de db
* Em dispositivos com acesso root, pode capturar o tráfego enquanto outros apps da VPN estão em execução

Se você planeja usar o PCAPdroid para realizar análise de pacotes, verifique <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>a seção específica</a> do manual.

Junte-se à comunidade internacional do PCAPdroid no <a href="https://t.me/PCAPdroid">telegram</a> ou no <a href="https://matrix.to/#/#pcapdroid:matrix.org">matrix</a>.

```

`fastlane/metadata/android/pt-BR/short_description.txt`:

```txt
Ferramenta de monitoramento e despejo de tráfego para dispositivos Android

```

`fastlane/metadata/android/ru/full_description.txt`:

```txt
<i>PCAPdroid</i> - это приложение ориентированное на конфиденциальность, которое дает вам возможность отслеживать и анализировать соединения, производимые другими приложениями на вашем устройстве.
Так же, оно позволяет экспортировать PCAP-дамп траффика, анализировать HTTP, дешифровывать TLS и многое другое.

PCAPdroid симулирует VPN чтобы производить захват траффика без использования root-прав. Он не использует каких-либо удаленных VPN серверов, вместо этого данные обрабатываются локально на устройстве.

<b>Особенности:</b>

* Запись и проверка подключений, сделанных пользовательскими и системными приложениями
* Извлечение SNI, DNS-запроса, HTTP-запроса, URL-адреса и удалённого IP-адреса
* Изучение HTTP запросов и ответов благодаря встроенным декодерам
* Изучение полного содержимого соединений в форматах текста или HEX
* Дешифрование HTTPS/TLS траффика и экспорт SSLKEYLOGFILE
* Записывайте траффик в PCAP-файл, скачивайте его браузером или отправляйте потоком на внешний приемник для анализа в реальном времени (например в Wireshark)
* Создание правил для скрытия "хорошего" траффика, чтобы легче было засечь аномалии
* Идентификация стран и ASN удаленных серверов с помощью локальных проверок по базе данных
* На устройствах с root-правами, траффик можно захватывать не прерывая работу другого VPN

Если вы планируете заниматься анализом пакетов, пожалуйста ознакомьтесь с <a href='https://emanuele-f.github.io/PCAPdroid/ru/quick_start#14-анализ-пакетов'>соответствующим разделом</a> в руководстве пользователя.

Вы можете присоединиться к международному сообществу PCAPdroid <a href="https://t.me/PCAPdroid">в Telegram</a> или <a href="https://matrix.to/#/#pcapdroid:matrix.org">в Matrix</a>.

```

`fastlane/metadata/android/ru/short_description.txt`:

```txt
Инструмент мониторинга и записи сетевого трафика для Android-устройств без root

```

`fastlane/metadata/android/tr/full_description.txt`:

```txt
<i>PCAPdroid</i>, aygıtınızdaki diğer uygulamalar tarafından yapılan bağlantıları izlemenizi ve incelemenizi sağlayan gizlilik dostu bir uygulamadır.
Ayrıca trafiğin PCAP dökümünü dışa aktarmanıza, HTTP'yi incelemenize, TLS trafiğinin şifresini çözmenize ve çok daha fazlasına olanak tanır.

PCAPdroid, ağ trafiğini root olmadan yakalamak için bir VPN gibi davranır. Uzak bir VPN sunucusu kullanmaz, bunun yerine tüm veriler aygıt üzerinde yerel olarak işlenir.

<b>Özellikler:</b>

* Kullanıcı ve sistem uygulamaları tarafından yapılan bağlantıları günlüğe kaydedin ve inceleyin
* SNI, DNS sorgusu, HTTP URL'si ve uzak IP adresini ayıklayın
* Yerleşik kod çözücüler sayesinde HTTP isteklerini ve yanıtlarını inceleyin
* Tam bağlantı yükünü onaltılık dökümü/metin olarak inceleyin
* HTTPS/TLS trafiğinin şifresini çözün ve SSLKEYLOGFILE dosyasını dışa aktarın
* Trafiği bir PCAP dosyasına aktarın, bir tarayıcıdan indirin veya gerçek zamanlı inceleme için uzak bir alıcıya aktarın (örn. Wireshark)
* İyi trafiği filtrelemek ve anormallikleri kolayca tespit etmek için kurallar oluşturun
* Çevrim dışı veri tabanı aramaları aracılığıyla uzak sunucunun ülkesini ve ASN'sini belirleyin
* Root yapılmış aygıtlarda, diğer VPN uygulamaları çalışırken trafiği yakalayın

Paket incelemesi yapmak için PCAPdroid kullanmayı düşünüyorsanız, lütfen kılavuzun <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>ilgili bölümüne</a> göz atın.

PCAPdroid uluslararası topluluğuna <a href="https://t.me/PCAPdroid">Telegram</a> veya <a href="https://matrix.to/#/#pcapdroid:matrix.org">Matrix</a> üzerinden katılın.

```

`fastlane/metadata/android/tr/short_description.txt`:

```txt
Android aygıtlar için root gerektirmeyen ağ izleme ve trafik dökümü aracı

```

`fastlane/metadata/android/uk/full_description.txt`:

```txt
<i>PCAPdroid</i> це безпечний для конфіденційності додаток, який дозволяє відстежувати та аналізувати з'єднання, здійснені додатками на вашому пристрої.
Крім того, він дозволяє експортувати PCAP дамп трафіку, перевіряти HTTP, дешифрувати трафік TLS та багато іншого.

PCAPdroid імітує VPN, щоб перехоплювати мережевий трафік без рут. Він не використовує віддалений сервер VPN, натомість дані обробляються локально на пристрої.

<b>Можливості:</b>

* Логувати та досліджувати з'єднання здійснені користувачем і системними додатками
* Витягати SNI, запит DNS, посилання HTTP та віддалену адресу IP
* Перевіряти HTTP запити і відповіді завдяки вбудованим декодерам
* Перевіряти повне корисне навантаження з'єднань як hexdump/текст
* Дешифрувати трафік HTTPS/TLS та експортувати SSLKEYLOGFILE
* Дампувати трафік до файлу PCAP, завантажити його з браузера, чи транслювати його до віддаленого приймача для аналізу в реальному часі (наприклад, Wireshark)
* Створити правила для фільтрування хорошого трафіку і легко визначати ненормальний
* Визначати країну та ASN віддаленого сервера за допомогою офлайн пошуків
* На рутованих пристроях, захоплювати трафік коли виконуються інші додатки VPN

Якщо ви плануєте використовувати PCAPdroid для аналізування пакету, будь ласка, ознайомтесь з <a href='https://emanuele-f.github.io/PCAPdroid/quick_start#14-packet-analysis'>відповідним розділом</a> посібника.

Приєднуйтесь до міжнародної спільноти PCAPdroid у <a href="https://t.me/PCAPdroid">Telegram</a> чи на <a href="https://matrix.to/#/#pcapdroid:matrix.org">Matrix</a>.

```

`fastlane/metadata/android/uk/short_description.txt`:

```txt
Інструмент моніторингу мережі та дампу трафіку без рут для пристроїв Android

```

`fastlane/metadata/android/vi/short_description.txt`:

```txt
Công cụ giám sát mạng và lưu lượng truy cập không cần root cho thiết bị Android

```

`funding.json`:

```json
{
  "$schema": "https://fundingjson.org/schema/v1.1.0.json",
  "version": "v1.1.0",
  "entity": {
    "type": "individual",
    "role": "owner",
    "name": "Emanuele Faranda",
    "email": "black.silver@hotmail.it",
    "description": "Independent developer of open-source network security and traffic analysis tools.",
    "webpageUrl": {
      "url": "https://emanuele-f.github.io/PCAPdroid",
      "wellKnown": "https://emanuele-f.github.io/.well-known/funding-manifest-urls"
    }
  },
  "projects": [
    {
      "guid": "pcapdroid",
      "name": "PCAPdroid",
      "description": "No-root network monitor, firewall and PCAP dumper for Android. Enables users to track, analyze, and block app connections while exporting network traffic captures in the PCAP format.",
      "webpageUrl": {
        "url": "https://emanuele-f.github.io/PCAPdroid",
        "wellKnown": "https://emanuele-f.github.io/.well-known/funding-manifest-urls"
      },
      "repositoryUrl": {
        "url": "https://github.com/emanuele-f/PCAPdroid"
      },
      "licenses": [
        "spdx:GPL-3.0"
      ],
      "tags": [
        "network-security",
        "vpn",
        "android",
        "privacy",
        "firewall",
        "wireshark",
        "traffic-monitor",
        "decryption",
        "pcap",
        "networking"
      ]
    },
    {
      "guid": "pcapdroid-mitm",
      "name": "PCAPdroid-mitm",
      "description": "A PCAPdroid addon that uses mitmproxy to decrypt TLS/SSL connections, to display the decrypted data within the app",
      "webpageUrl": {
        "url": "https://github.com/emanuele-f/PCAPdroid-mitm",
        "wellKnown": "https://github.com/emanuele-f/PCAPdroid-mitm/blob/master/.well-known/funding-manifest-urls"
      },
      "repositoryUrl": {
        "url": "https://github.com/emanuele-f/PCAPdroid-mitm",
        "wellKnown": "https://github.com/emanuele-f/PCAPdroid-mitm/blob/master/.well-known/funding-manifest-urls"
      },
      "licenses": [
        "spdx:GPL-3.0"
      ],
      "tags": [
        "android",
        "decryption",
        "tls",
        "mitmproxy",
        "network-security",
        "privacy",
        "pcap",
        "traffic-monitor",
        "security",
        "ssl"
      ]
    }
  ],
  "funding": {
    "channels": [
      {
        "guid": "bank",
        "type": "bank",
        "description": "Will accept direct bank transfers. Please e-mail me for details"
      },
      {
        "guid": "github-sponsors",
        "type": "payment-provider",
        "address": "https://github.com/sponsors/emanuele-f",
        "description": "GitHub Sponsors"
      }
    ],
    "plans": [
      {
        "guid": "monthly-support",
        "status": "active",
        "name": "Monthly support",
        "description": "Monthly recurring donation to support ongoing development",
        "amount": 5,
        "currency": "EUR",
        "frequency": "monthly",
        "channels": [
          "github-sponsors"
        ]
      }
    ]
  }
}

```

`generated/README.md`:

```md
The subfolders in this directory contain pre-generated autotools files. Using these files removes the need to install autotools and allows to build PCAPdroid in Windows.
To update the files, run `./refresh.sh` in this folder.

```

`generated/libpcap/config.h`:

```h
/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Define to 1 if arpa/inet.h declares `ether_hostton' */
/* #undef ARPA_INET_H_DECLARES_ETHER_HOSTTON */

/* Enable optimizer debugging */
/* #undef BDEBUG */

/* define if you want to build the instrument functions code */
/* #undef ENABLE_INSTRUMENT_FUNCTIONS */

/* Define to 1 if remote packet capture is to be supported */
/* #undef ENABLE_REMOTE */

/* define if we have the AIX getnetbyname_r() */
/* #undef HAVE_AIX_GETNETBYNAME_R */

/* define if we have the AIX getprotobyname_r() */
/* #undef HAVE_AIX_GETPROTOBYNAME_R */

/* Define to 1 if you have the 'asprintf' function. */
#define HAVE_ASPRINTF 1

/* Define to 1 if you have the <config/HaikuConfig.h> header file. */
/* #undef HAVE_CONFIG_HAIKUCONFIG_H */

/* Define to 1 if you have the <dagapi.h> header file. */
/* #undef HAVE_DAGAPI_H */

/* define if you have the DAG API */
/* #undef HAVE_DAG_API */

/* define if you have dag_get_erf_types() */
/* #undef HAVE_DAG_GET_ERF_TYPES */

/* define if you have dag_get_stream_erf_types() */
/* #undef HAVE_DAG_GET_STREAM_ERF_TYPES */

/* define if you have large streams capable DAG API */
/* #undef HAVE_DAG_LARGE_STREAMS_API */

/* define if you have vdag_set_device_info() */
/* #undef HAVE_DAG_VDAG */

/* Define to 1 if you have the declaration of `ether_hostton' */
/* #undef HAVE_DECL_ETHER_HOSTTON */

/* Define to 1 if 'dl_module_id_1' is a member of 'dl_hp_ppa_info_t'. */
/* #undef HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1 */

/* Define to 1 if the system has the type 'dl_passive_req_t'. */
/* #undef HAVE_DL_PASSIVE_REQ_T */

/* Define to 1 if you have the 'ether_hostton' function. */
/* #undef HAVE_ETHER_HOSTTON */

/* Define to 1 if you have the 'ffs' function. */
#define HAVE_FFS 1

/* Define to 1 if fseeko (and ftello) are declared in stdio.h. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the 'getspnam' function. */
/* #undef HAVE_GETSPNAM */

/* Define to 1 if you have a GNU-style `strerror_r' function. */
/* #undef HAVE_GNU_STRERROR_R */

/* on HP-UX 10.20 or later */
/* #undef HAVE_HPUX10_20_OR_LATER */

/* on HP-UX 9.x */
/* #undef HAVE_HPUX9 */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the 'bsd' library (-lbsd). */
/* #undef HAVE_LIBBSD */

/* if libdlpi exists */
/* #undef HAVE_LIBDLPI */

/* if libnl exists */
/* #undef HAVE_LIBNL */

/* Define to 1 if you have the <linux/compiler.h> header file. */
/* #undef HAVE_LINUX_COMPILER_H */

/* define if we have the Linux getnetbyname_r() */
/* #undef HAVE_LINUX_GETNETBYNAME_R */

/* define if we have the Linux getprotobyname_r() */
/* #undef HAVE_LINUX_GETPROTOBYNAME_R */

/* Define to 1 if you have the <linux/net_tstamp.h> header file. */
#define HAVE_LINUX_NET_TSTAMP_H 1

/* Define to 1 if you have the <linux/socket.h> header file. */
#define HAVE_LINUX_SOCKET_H 1

/* Define to 1 if you have the <linux/usbdevice_fs.h> header file. */
/* #undef HAVE_LINUX_USBDEVICE_FS_H */

/* Define to 1 if you have the <linux/wireless.h> header file. */
#define HAVE_LINUX_WIRELESS_H 1

/* Define to 1 if you have the <netpacket/packet.h> header file. */
#define HAVE_NETPACKET_PACKET_H 1

/* Define to 1 if you have the <net/bpf.h> header file. */
/* #undef HAVE_NET_BPF_H */

/* Define to 1 if you have the <net/enet.h> header file. */
/* #undef HAVE_NET_ENET_H */

/* Define to 1 if you have the <net/if_dl.h> header file. */
/* #undef HAVE_NET_IF_DL_H */

/* Define to 1 if you have the <net/if.h> header file. */
/* #undef HAVE_NET_IF_H */

/* Define to 1 if you have the <net/if_media.h> header file. */
/* #undef HAVE_NET_IF_MEDIA_H */

/* Define to 1 if you have the <net/if_types.h> header file. */
/* #undef HAVE_NET_IF_TYPES_H */

/* Define to 1 if you have the <net/nit.h> header file. */
/* #undef HAVE_NET_NIT_H */

/* Define to 1 if you have the <net/pfilt.h> header file. */
/* #undef HAVE_NET_PFILT_H */

/* Define to 1 if you have the <net/raw.h> header file. */
/* #undef HAVE_NET_RAW_H */

/* Use OpenSSL */
/* #undef HAVE_OPENSSL */

/* if there's an os_proto.h for this platform, to use additional prototypes */
/* #undef HAVE_OS_PROTO_H */

/* Define to 1 if you have a POSIX-style `strerror_r' function. */
#define HAVE_POSIX_STRERROR_R /**/

/* define if you have the Septel API */
/* #undef HAVE_SEPTEL_API */

/* define if you have the Myricom SNF API */
/* #undef HAVE_SNF_API */

/* Define to 1 if the system has the type 'socklen_t'. */
#define HAVE_SOCKLEN_T 1

/* On solaris */
/* #undef HAVE_SOLARIS */

/* target host supports Solaris "any" device */
/* #undef HAVE_SOLARIS_ANY_DEVICE */

/* define if we have the Solaris/IRIX getnetbyname_r() */
/* #undef HAVE_SOLARIS_IRIX_GETNETBYNAME_R */

/* define if we have the Solaris/IRIX getprotobyname_r() */
/* #undef HAVE_SOLARIS_IRIX_GETPROTOBYNAME_R */

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdio.h> header file. */
#define HAVE_STDIO_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the 'strlcat' function. */
#define HAVE_STRLCAT 1

/* Define to 1 if you have the 'strlcpy' function. */
#define HAVE_STRLCPY 1

/* Define to 1 if you have the 'strtok_r' function. */
#define HAVE_STRTOK_R 1

/* Define to 1 if the system has the type 'struct BPF_TIMEVAL'. */
/* #undef HAVE_STRUCT_BPF_TIMEVAL */

/* Define to 1 if the system has the type 'struct ether_addr'. */
/* #undef HAVE_STRUCT_ETHER_ADDR */

/* Define to 1 if 'msg_control' is a member of 'struct msghdr'. */
/* #undef HAVE_STRUCT_MSGHDR_MSG_CONTROL */

/* Define to 1 if 'msg_flags' is a member of 'struct msghdr'. */
/* #undef HAVE_STRUCT_MSGHDR_MSG_FLAGS */

/* Define to 1 if the system has the type 'struct rte_ether_addr'. */
/* #undef HAVE_STRUCT_RTE_ETHER_ADDR */

/* Define to 1 if 'hci_channel' is a member of 'struct sockaddr_hci'. */
/* #undef HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL */

/* Define to 1 if 'sa_len' is a member of 'struct sockaddr'. */
/* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */

/* Define to 1 if the system has the type 'struct sockaddr_storage'. */
#define HAVE_STRUCT_SOCKADDR_STORAGE 1

/* Define to 1 if 'tp_vlan_tci' is a member of 'struct tpacket_auxdata'. */
#define HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI 1

/* Define to 1 if 'bRequestType' is a member of 'struct
   usbdevfs_ctrltransfer'. */
/* #undef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE */

/* Define to 1 if you have the <sys/bufmod.h> header file. */
/* #undef HAVE_SYS_BUFMOD_H */

/* Define to 1 if you have the <sys/dlpi_ext.h> header file. */
/* #undef HAVE_SYS_DLPI_EXT_H */

/* Define to 1 if you have the <sys/dlpi.h> header file. */
/* #undef HAVE_SYS_DLPI_H */

/* Define to 1 if you have the <sys/ioccom.h> header file. */
/* #undef HAVE_SYS_IOCCOM_H */

/* Define to 1 if you have the <sys/net/nit.h> header file. */
/* #undef HAVE_SYS_NET_NIT_H */

/* Define to 1 if you have the <sys/sockio.h> header file. */
/* #undef HAVE_SYS_SOCKIO_H */

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* define if you have the TurboCap API */
/* #undef HAVE_TC_API */

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the 'vasprintf' function. */
#define HAVE_VASPRINTF 1

/* Define to 1 if you have the 'vsyslog' function. */
#define HAVE_VSYSLOG 1

/* Define to 1 if you have the '_wcserror_s' function. */
/* #undef HAVE__WCSERROR_S */

/* define if __atomic_load_n is supported by the compiler */
#define HAVE___ATOMIC_LOAD_N 1

/* define if __atomic_store_n is supported by the compiler */
#define HAVE___ATOMIC_STORE_N 1

/* IPv6 */
#define INET6 1

/* Define to 1 if netinet/ether.h declares `ether_hostton' */
/* #undef NETINET_ETHER_H_DECLARES_ETHER_HOSTTON */

/* Define to 1 if netinet/if_ether.h declares `ether_hostton' */
/* #undef NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON */

/* Define to 1 if net/ethernet.h declares `ether_hostton' */
/* #undef NET_ETHERNET_H_DECLARES_ETHER_HOSTTON */

/* do not use protochain */
/* #undef NO_PROTOCHAIN */

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT ""

/* Define to the full name of this package. */
#define PACKAGE_NAME "pcap"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "pcap 1.10.5"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "pcap"

/* Define to the home page for this package. */
#define PACKAGE_URL ""

/* Define to the version of this package. */
#define PACKAGE_VERSION "1.10.5"

/* target host supports Bluetooth sniffing */
/* #undef PCAP_SUPPORT_BT */

/* target host supports Bluetooth Monitor */
/* #undef PCAP_SUPPORT_BT_MONITOR */

/* support D-Bus sniffing */
/* #undef PCAP_SUPPORT_DBUS */

/* target host supports DPDK */
/* #undef PCAP_SUPPORT_DPDK */

/* target host supports Linux usbmon for USB sniffing */
/* #undef PCAP_SUPPORT_LINUX_USBMON */

/* target host supports netfilter sniffing */
/* #undef PCAP_SUPPORT_NETFILTER */

/* target host supports netmap */
/* #undef PCAP_SUPPORT_NETMAP */

/* target host supports RDMA sniffing */
/* #undef PCAP_SUPPORT_RDMASNIFF */

/* The size of 'time_t', as computed by sizeof. */
#define SIZEOF_TIME_T 8

/* The size of 'void *', as computed by sizeof. */
#define SIZEOF_VOID_P 8

/* Define to 1 if all of the C89 standard headers exist (not just the ones
   required in a freestanding environment). This macro is provided for
   backward compatibility; new code need not use it. */
#define STDC_HEADERS 1

/* Define to 1 if strings.h declares `ffs' */
#define STRINGS_H_DECLARES_FFS /**/

/* Define to 1 if sys/ethernet.h declares `ether_hostton' */
/* #undef SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON */

/* Enable parser debugging */
/* #undef YYDEBUG */

/* Define to 1 if 'lex' declares 'yytext' as a 'char *' by default, not a
   'char[]'. */
#define YYTEXT_POINTER 1

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 if necessary to make fseeko visible. */
/* #undef _LARGEFILE_SOURCE */

/* Define to 1 on platforms where this makes off_t a 64-bit type. */
/* #undef _LARGE_FILES */

/* define on AIX to get certain functions */
/* #undef _SUN */

/* Number of bits in time_t, on hosts where this is settable. */
/* #undef _TIME_BITS */

/* Define to 1 on platforms where this makes time_t a 64-bit type. */
/* #undef __MINGW_USE_VC2005_COMPAT */

/* to handle Ultrix compilers that don't support const in prototypes */
/* #undef const */

/* Define as token for inline if inlining supported */
#define inline inline

/* on sinix */
/* #undef sinix */

```

`generated/libpcap/grammar.c`:

```c
/* A Bison parser, made by GNU Bison 3.8.2.  */

/* Bison implementation for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
   especially those whose name start with YY_ or yy_.  They are
   private implementation details that can be changed or removed.  */

/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */

/* Identify Bison output, and Bison version.  */
#define YYBISON 30802

/* Bison version string.  */
#define YYBISON_VERSION "3.8.2"

/* Skeleton name.  */
#define YYSKELETON_NAME "yacc.c"

/* Pure parsers.  */
#define YYPURE 1

/* Push parsers.  */
#define YYPUSH 0

/* Pull parsers.  */
#define YYPULL 1


/* Substitute the variable and function names.  */
#define yyparse         pcap_parse
#define yylex           pcap_lex
#define yyerror         pcap_error
#define yydebug         pcap_debug
#define yynerrs         pcap_nerrs

/* First part of user prologue.  */
#line 47 "grammar.y"

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#include <config.h>

/*
 * grammar.h requires gencode.h and sometimes breaks in a polluted namespace
 * (see ftmacros.h), so include it early.
 */
#include "gencode.h"
#include "grammar.h"

#include <stdlib.h>

#ifndef _WIN32
#include <sys/types.h>
#include <sys/socket.h>

#if __STDC__
struct mbuf;
struct rtentry;
#endif

#include <netinet/in.h>
#include <arpa/inet.h>
#endif /* _WIN32 */

#include <stdio.h>

#include "diag-control.h"

#include "pcap-int.h"

#include "scanner.h"

#include "llc.h"
#include "ieee80211.h"
#include "pflog.h"
#include <pcap/namedb.h>

#ifdef HAVE_OS_PROTO_H
#include "os-proto.h"
#endif

/*
 * Work around some bugs in Berkeley YACC prior to the 2017-07-09
 * release.
 *
 * The 2005-05-05 release was the first one to define YYPATCH, so
 * we treat any release that either 1) doesn't define YYPATCH or
 * 2) defines it to a value < 20170709 as being buggy.
 */
#if defined(YYBYACC) && (!defined(YYPATCH) || YYPATCH < 20170709)
/*
 * Both Berkeley YACC and Bison define yydebug (under whatever name
 * it has) as a global, but Bison does so only if YYDEBUG is defined.
 * Berkeley YACC, prior to the 2017-07-09 release, defines it even if
 * YYDEBUG isn't defined; declare it here to suppress a warning.  The
 * 2017-07-09 release fixes that.
 */
#if !defined(YYDEBUG)
extern int yydebug;
#endif

/*
 * In Berkeley YACC, prior to the 2017-07-09 release, yynerrs (under
 * whatever name it has) is global, even if it's building a reentrant
 * parser.  In Bison, and in the Berkeley YACC 2017-07-09 release and
 * later, it's local in reentrant parsers.
 *
 * Declare it to squelch a warning.
 */
extern int yynerrs;
#endif

#define QSET(q, p, d, a) (q).proto = (unsigned char)(p),\
			 (q).dir = (unsigned char)(d),\
			 (q).addr = (unsigned char)(a)

struct tok {
	int v;			/* value */
	const char *s;		/* string */
};

static const struct tok ieee80211_types[] = {
	{ IEEE80211_FC0_TYPE_DATA, "data" },
	{ IEEE80211_FC0_TYPE_MGT, "mgt" },
	{ IEEE80211_FC0_TYPE_MGT, "management" },
	{ IEEE80211_FC0_TYPE_CTL, "ctl" },
	{ IEEE80211_FC0_TYPE_CTL, "control" },
	{ 0, NULL }
};
static const struct tok ieee80211_mgt_subtypes[] = {
	{ IEEE80211_FC0_SUBTYPE_ASSOC_REQ, "assocreq" },
	{ IEEE80211_FC0_SUBTYPE_ASSOC_REQ, "assoc-req" },
	{ IEEE80211_FC0_SUBTYPE_ASSOC_RESP, "assocresp" },
	{ IEEE80211_FC0_SUBTYPE_ASSOC_RESP, "assoc-resp" },
	{ IEEE80211_FC0_SUBTYPE_REASSOC_REQ, "reassocreq" },
	{ IEEE80211_FC0_SUBTYPE_REASSOC_REQ, "reassoc-req" },
	{ IEEE80211_FC0_SUBTYPE_REASSOC_RESP, "reassocresp" },
	{ IEEE80211_FC0_SUBTYPE_REASSOC_RESP, "reassoc-resp" },
	{ IEEE80211_FC0_SUBTYPE_PROBE_REQ, "probereq" },
	{ IEEE80211_FC0_SUBTYPE_PROBE_REQ, "probe-req" },
	{ IEEE80211_FC0_SUBTYPE_PROBE_RESP, "proberesp" },
	{ IEEE80211_FC0_SUBTYPE_PROBE_RESP, "probe-resp" },
	{ IEEE80211_FC0_SUBTYPE_BEACON, "beacon" },
	{ IEEE80211_FC0_SUBTYPE_ATIM, "atim" },
	{ IEEE80211_FC0_SUBTYPE_DISASSOC, "disassoc" },
	{ IEEE80211_FC0_SUBTYPE_DISASSOC, "disassociation" },
	{ IEEE80211_FC0_SUBTYPE_AUTH, "auth" },
	{ IEEE80211_FC0_SUBTYPE_AUTH, "authentication" },
	{ IEEE80211_FC0_SUBTYPE_DEAUTH, "deauth" },
	{ IEEE80211_FC0_SUBTYPE_DEAUTH, "deauthentication" },
	{ 0, NULL }
};
static const struct tok ieee80211_ctl_subtypes[] = {
	{ IEEE80211_FC0_SUBTYPE_PS_POLL, "ps-poll" },
	{ IEEE80211_FC0_SUBTYPE_RTS, "rts" },
	{ IEEE80211_FC0_SUBTYPE_CTS, "cts" },
	{ IEEE80211_FC0_SUBTYPE_ACK, "ack" },
	{ IEEE80211_FC0_SUBTYPE_CF_END, "cf-end" },
	{ IEEE80211_FC0_SUBTYPE_CF_END_ACK, "cf-end-ack" },
	{ 0, NULL }
};
static const struct tok ieee80211_data_subtypes[] = {
	{ IEEE80211_FC0_SUBTYPE_DATA, "data" },
	{ IEEE80211_FC0_SUBTYPE_CF_ACK, "data-cf-ack" },
	{ IEEE80211_FC0_SUBTYPE_CF_POLL, "data-cf-poll" },
	{ IEEE80211_FC0_SUBTYPE_CF_ACPL, "data-cf-ack-poll" },
	{ IEEE80211_FC0_SUBTYPE_NODATA, "null" },
	{ IEEE80211_FC0_SUBTYPE_NODATA_CF_ACK, "cf-ack" },
	{ IEEE80211_FC0_SUBTYPE_NODATA_CF_POLL, "cf-poll"  },
	{ IEEE80211_FC0_SUBTYPE_NODATA_CF_ACPL, "cf-ack-poll" },
	{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_DATA, "qos-data" },
	{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_CF_ACK, "qos-data-cf-ack" },
	{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_CF_POLL, "qos-data-cf-poll" },
	{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_CF_ACPL, "qos-data-cf-ack-poll" },
	{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_NODATA, "qos" },
	{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_NODATA_CF_POLL, "qos-cf-poll" },
	{ IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_SUBTYPE_NODATA_CF_ACPL, "qos-cf-ack-poll" },
	{ 0, NULL }
};
static const struct tok llc_s_subtypes[] = {
	{ LLC_RR, "rr" },
	{ LLC_RNR, "rnr" },
	{ LLC_REJ, "rej" },
	{ 0, NULL }
};
static const struct tok llc_u_subtypes[] = {
	{ LLC_UI, "ui" },
	{ LLC_UA, "ua" },
	{ LLC_DISC, "disc" },
	{ LLC_DM, "dm" },
	{ LLC_SABME, "sabme" },
	{ LLC_TEST, "test" },
	{ LLC_XID, "xid" },
	{ LLC_FRMR, "frmr" },
	{ 0, NULL }
};
struct type2tok {
	int type;
	const struct tok *tok;
};
static const struct type2tok ieee80211_type_subtypes[] = {
	{ IEEE80211_FC0_TYPE_MGT, ieee80211_mgt_subtypes },
	{ IEEE80211_FC0_TYPE_CTL, ieee80211_ctl_subtypes },
	{ IEEE80211_FC0_TYPE_DATA, ieee80211_data_subtypes },
	{ 0, NULL }
};

static int
str2tok(const char *str, const struct tok *toks)
{
	int i;

	for (i = 0; toks[i].s != NULL; i++) {
		if (pcapint_strcasecmp(toks[i].s, str) == 0) {
			/*
			 * Just in case somebody is using this to
			 * generate values of -1/0xFFFFFFFF.
			 * That won't work, as it's indistinguishable
			 * from an error.
			 */
			if (toks[i].v == -1)
				abort();
			return (toks[i].v);
		}
	}
	return (-1);
}

static const struct qual qerr = { Q_UNDEF, Q_UNDEF, Q_UNDEF, Q_UNDEF };

static void
yyerror(void *yyscanner _U_, compiler_state_t *cstate, const char *msg)
{
	bpf_set_error(cstate, "can't parse filter expression: %s", msg);
}

static const struct tok pflog_reasons[] = {
	{ PFRES_MATCH,		"match" },
	{ PFRES_BADOFF,		"bad-offset" },
	{ PFRES_FRAG,		"fragment" },
	{ PFRES_SHORT,		"short" },
	{ PFRES_NORM,		"normalize" },
	{ PFRES_MEMORY,		"memory" },
	{ PFRES_TS,		"bad-timestamp" },
	{ PFRES_CONGEST,	"congestion" },
	{ PFRES_IPOPTIONS,	"ip-option" },
	{ PFRES_PROTCKSUM,	"proto-cksum" },
	{ PFRES_BADSTATE,	"state-mismatch" },
	{ PFRES_STATEINS,	"state-insert" },
	{ PFRES_MAXSTATES,	"state-limit" },
	{ PFRES_SRCLIMIT,	"src-limit" },
	{ PFRES_SYNPROXY,	"synproxy" },
#if defined(__FreeBSD__)
	{ PFRES_MAPFAILED,	"map-failed" },
#elif defined(__NetBSD__)
	{ PFRES_STATELOCKED,	"state-locked" },
#elif defined(__OpenBSD__)
	{ PFRES_TRANSLATE,	"translate" },
	{ PFRES_NOROUTE,	"no-route" },
#elif defined(__APPLE__)
	{ PFRES_DUMMYNET,	"dummynet" },
#endif
	{ 0, NULL }
};

static int
pfreason_to_num(compiler_state_t *cstate, const char *reason)
{
	int i;

	i = str2tok(reason, pflog_reasons);
	if (i == -1)
		bpf_set_error(cstate, "unknown PF reason \"%s\"", reason);
	return (i);
}

static const struct tok pflog_actions[] = {
	{ PF_PASS,		"pass" },
	{ PF_PASS,		"accept" },	/* alias for "pass" */
	{ PF_DROP,		"drop" },
	{ PF_DROP,		"block" },	/* alias for "drop" */
	{ PF_SCRUB,		"scrub" },
	{ PF_NOSCRUB,		"noscrub" },
	{ PF_NAT,		"nat" },
	{ PF_NONAT,		"nonat" },
	{ PF_BINAT,		"binat" },
	{ PF_NOBINAT,		"nobinat" },
	{ PF_RDR,		"rdr" },
	{ PF_NORDR,		"nordr" },
	{ PF_SYNPROXY_DROP,	"synproxy-drop" },
#if defined(__FreeBSD__)
	{ PF_DEFER,		"defer" },
#elif defined(__OpenBSD__)
	{ PF_DEFER,		"defer" },
	{ PF_MATCH,		"match" },
	{ PF_DIVERT,		"divert" },
	{ PF_RT,		"rt" },
	{ PF_AFRT,		"afrt" },
#elif defined(__APPLE__)
	{ PF_DUMMYNET,		"dummynet" },
	{ PF_NODUMMYNET,	"nodummynet" },
	{ PF_NAT64,		"nat64" },
	{ PF_NONAT64,		"nonat64" },
#endif
	{ 0, NULL },
};

static int
pfaction_to_num(compiler_state_t *cstate, const char *action)
{
	int i;

	i = str2tok(action, pflog_actions);
	if (i == -1)
		bpf_set_error(cstate, "unknown PF action \"%s\"", action);
	return (i);
}

/*
 * For calls that might return an "an error occurred" value.
 */
#define CHECK_INT_VAL(val)	if (val == -1) YYABORT
#define CHECK_PTR_VAL(val)	if (val == NULL) YYABORT

DIAG_OFF_BISON_BYACC

#line 386 "grammar.c"

# ifndef YY_CAST
#  ifdef __cplusplus
#   define YY_CAST(Type, Val) static_cast<Type> (Val)
#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
#  else
#   define YY_CAST(Type, Val) ((Type) (Val))
#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
#  endif
# endif
# ifndef YY_NULLPTR
#  if defined __cplusplus
#   if 201103L <= __cplusplus
#    define YY_NULLPTR nullptr
#   else
#    define YY_NULLPTR 0
#   endif
#  else
#   define YY_NULLPTR ((void*)0)
#  endif
# endif

#include "grammar.h"
/* Symbol kind.  */
enum yysymbol_kind_t
{
  YYSYMBOL_YYEMPTY = -2,
  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
  YYSYMBOL_YYerror = 1,                    /* error  */
  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
  YYSYMBOL_DST = 3,                        /* DST  */
  YYSYMBOL_SRC = 4,                        /* SRC  */
  YYSYMBOL_HOST = 5,                       /* HOST  */
  YYSYMBOL_GATEWAY = 6,                    /* GATEWAY  */
  YYSYMBOL_NET = 7,                        /* NET  */
  YYSYMBOL_NETMASK = 8,                    /* NETMASK  */
  YYSYMBOL_PORT = 9,                       /* PORT  */
  YYSYMBOL_PORTRANGE = 10,                 /* PORTRANGE  */
  YYSYMBOL_LESS = 11,                      /* LESS  */
  YYSYMBOL_GREATER = 12,                   /* GREATER  */
  YYSYMBOL_PROTO = 13,                     /* PROTO  */
  YYSYMBOL_PROTOCHAIN = 14,                /* PROTOCHAIN  */
  YYSYMBOL_CBYTE = 15,                     /* CBYTE  */
  YYSYMBOL_ARP = 16,                       /* ARP  */
  YYSYMBOL_RARP = 17,                      /* RARP  */
  YYSYMBOL_IP = 18,                        /* IP  */
  YYSYMBOL_SCTP = 19,                      /* SCTP  */
  YYSYMBOL_TCP = 20,                       /* TCP  */
  YYSYMBOL_UDP = 21,                       /* UDP  */
  YYSYMBOL_ICMP = 22,                      /* ICMP  */
  YYSYMBOL_IGMP = 23,                      /* IGMP  */
  YYSYMBOL_IGRP = 24,                      /* IGRP  */
  YYSYMBOL_PIM = 25,                       /* PIM  */
  YYSYMBOL_VRRP = 26,                      /* VRRP  */
  YYSYMBOL_CARP = 27,                      /* CARP  */
  YYSYMBOL_ATALK = 28,                     /* ATALK  */
  YYSYMBOL_AARP = 29,                      /* AARP  */
  YYSYMBOL_DECNET = 30,                    /* DECNET  */
  YYSYMBOL_LAT = 31,                       /* LAT  */
  YYSYMBOL_SCA = 32,                       /* SCA  */
  YYSYMBOL_MOPRC = 33,                     /* MOPRC  */
  YYSYMBOL_MOPDL = 34,                     /* MOPDL  */
  YYSYMBOL_TK_BROADCAST = 35,              /* TK_BROADCAST  */
  YYSYMBOL_TK_MULTICAST = 36,              /* TK_MULTICAST  */
  YYSYMBOL_NUM = 37,                       /* NUM  */
  YYSYMBOL_INBOUND = 38,                   /* INBOUND  */
  YYSYMBOL_OUTBOUND = 39,                  /* OUTBOUND  */
  YYSYMBOL_IFINDEX = 40,                   /* IFINDEX  */
  YYSYMBOL_PF_IFNAME = 41,                 /* PF_IFNAME  */
  YYSYMBOL_PF_RSET = 42,                   /* PF_RSET  */
  YYSYMBOL_PF_RNR = 43,                    /* PF_RNR  */
  YYSYMBOL_PF_SRNR = 44,                   /* PF_SRNR  */
  YYSYMBOL_PF_REASON = 45,                 /* PF_REASON  */
  YYSYMBOL_PF_ACTION = 46,                 /* PF_ACTION  */
  YYSYMBOL_TYPE = 47,                      /* TYPE  */
  YYSYMBOL_SUBTYPE = 48,                   /* SUBTYPE  */
  YYSYMBOL_DIR = 49,                       /* DIR  */
  YYSYMBOL_ADDR1 = 50,                     /* ADDR1  */
  YYSYMBOL_ADDR2 = 51,                     /* ADDR2  */
  YYSYMBOL_ADDR3 = 52,                     /* ADDR3  */
  YYSYMBOL_ADDR4 = 53,                     /* ADDR4  */
  YYSYMBOL_RA = 54,                        /* RA  */
  YYSYMBOL_TA = 55,                        /* TA  */
  YYSYMBOL_LINK = 56,                      /* LINK  */
  YYSYMBOL_GEQ = 57,                       /* GEQ  */
  YYSYMBOL_LEQ = 58,                       /* LEQ  */
  YYSYMBOL_NEQ = 59,                       /* NEQ  */
  YYSYMBOL_ID = 60,                        /* ID  */
  YYSYMBOL_EID = 61,                       /* EID  */
  YYSYMBOL_HID = 62,                       /* HID  */
  YYSYMBOL_HID6 = 63,                      /* HID6  */
  YYSYMBOL_AID = 64,                       /* AID  */
  YYSYMBOL_LSH = 65,                       /* LSH  */
  YYSYMBOL_RSH = 66,                       /* RSH  */
  YYSYMBOL_LEN = 67,                       /* LEN  */
  YYSYMBOL_IPV6 = 68,                      /* IPV6  */
  YYSYMBOL_ICMPV6 = 69,                    /* ICMPV6  */
  YYSYMBOL_AH = 70,                        /* AH  */
  YYSYMBOL_ESP = 71,                       /* ESP  */
  YYSYMBOL_VLAN = 72,                      /* VLAN  */
  YYSYMBOL_MPLS = 73,                      /* MPLS  */
  YYSYMBOL_PPPOED = 74,                    /* PPPOED  */
  YYSYMBOL_PPPOES = 75,                    /* PPPOES  */
  YYSYMBOL_GENEVE = 76,                    /* GENEVE  */
  YYSYMBOL_ISO = 77,                       /* ISO  */
  YYSYMBOL_ESIS = 78,                      /* ESIS  */
  YYSYMBOL_CLNP = 79,                      /* CLNP  */
  YYSYMBOL_ISIS = 80,                      /* ISIS  */
  YYSYMBOL_L1 = 81,                        /* L1  */
  YYSYMBOL_L2 = 82,                        /* L2  */
  YYSYMBOL_IIH = 83,                       /* IIH  */
  YYSYMBOL_LSP = 84,                       /* LSP  */
  YYSYMBOL_SNP = 85,                       /* SNP  */
  YYSYMBOL_CSNP = 86,                      /* CSNP  */
  YYSYMBOL_PSNP = 87,                      /* PSNP  */
  YYSYMBOL_STP = 88,                       /* STP  */
  YYSYMBOL_IPX = 89,                       /* IPX  */
  YYSYMBOL_NETBEUI = 90,                   /* NETBEUI  */
  YYSYMBOL_LANE = 91,                      /* LANE  */
  YYSYMBOL_LLC = 92,                       /* LLC  */
  YYSYMBOL_METAC = 93,                     /* METAC  */
  YYSYMBOL_BCC = 94,                       /* BCC  */
  YYSYMBOL_SC = 95,                        /* SC  */
  YYSYMBOL_ILMIC = 96,                     /* ILMIC  */
  YYSYMBOL_OAMF4EC = 97,                   /* OAMF4EC  */
  YYSYMBOL_OAMF4SC = 98,                   /* OAMF4SC  */
  YYSYMBOL_OAM = 99,                       /* OAM  */
  YYSYMBOL_OAMF4 = 100,                    /* OAMF4  */
  YYSYMBOL_CONNECTMSG = 101,               /* CONNECTMSG  */
  YYSYMBOL_METACONNECT = 102,              /* METACONNECT  */
  YYSYMBOL_VPI = 103,                      /* VPI  */
  YYSYMBOL_VCI = 104,                      /* VCI  */
  YYSYMBOL_RADIO = 105,                    /* RADIO  */
  YYSYMBOL_FISU = 106,                     /* FISU  */
  YYSYMBOL_LSSU = 107,                     /* LSSU  */
  YYSYMBOL_MSU = 108,                      /* MSU  */
  YYSYMBOL_HFISU = 109,                    /* HFISU  */
  YYSYMBOL_HLSSU = 110,                    /* HLSSU  */
  YYSYMBOL_HMSU = 111,                     /* HMSU  */
  YYSYMBOL_SIO = 112,                      /* SIO  */
  YYSYMBOL_OPC = 113,                      /* OPC  */
  YYSYMBOL_DPC = 114,                      /* DPC  */
  YYSYMBOL_SLS = 115,                      /* SLS  */
  YYSYMBOL_HSIO = 116,                     /* HSIO  */
  YYSYMBOL_HOPC = 117,                     /* HOPC  */
  YYSYMBOL_HDPC = 118,                     /* HDPC  */
  YYSYMBOL_HSLS = 119,                     /* HSLS  */
  YYSYMBOL_LEX_ERROR = 120,                /* LEX_ERROR  */
  YYSYMBOL_OR = 121,                       /* OR  */
  YYSYMBOL_AND = 122,                      /* AND  */
  YYSYMBOL_123_ = 123,                     /* '!'  */
  YYSYMBOL_124_ = 124,                     /* '|'  */
  YYSYMBOL_125_ = 125,                     /* '&'  */
  YYSYMBOL_126_ = 126,                     /* '+'  */
  YYSYMBOL_127_ = 127,                     /* '-'  */
  YYSYMBOL_128_ = 128,                     /* '*'  */
  YYSYMBOL_129_ = 129,                     /* '/'  */
  YYSYMBOL_UMINUS = 130,                   /* UMINUS  */
  YYSYMBOL_131_ = 131,                     /* ')'  */
  YYSYMBOL_132_ = 132,                     /* '('  */
  YYSYMBOL_133_ = 133,                     /* '>'  */
  YYSYMBOL_134_ = 134,                     /* '='  */
  YYSYMBOL_135_ = 135,                     /* '<'  */
  YYSYMBOL_136_ = 136,                     /* '['  */
  YYSYMBOL_137_ = 137,                     /* ']'  */
  YYSYMBOL_138_ = 138,                     /* ':'  */
  YYSYMBOL_139_ = 139,                     /* '%'  */
  YYSYMBOL_140_ = 140,                     /* '^'  */
  YYSYMBOL_YYACCEPT = 141,                 /* $accept  */
  YYSYMBOL_prog = 142,                     /* prog  */
  YYSYMBOL_null = 143,                     /* null  */
  YYSYMBOL_expr = 144,                     /* expr  */
  YYSYMBOL_and = 145,                      /* and  */
  YYSYMBOL_or = 146,                       /* or  */
  YYSYMBOL_id = 147,                       /* id  */
  YYSYMBOL_nid = 148,                      /* nid  */
  YYSYMBOL_not = 149,                      /* not  */
  YYSYMBOL_paren = 150,                    /* paren  */
  YYSYMBOL_pid = 151,                      /* pid  */
  YYSYMBOL_qid = 152,                      /* qid  */
  YYSYMBOL_term = 153,                     /* term  */
  YYSYMBOL_head = 154,                     /* head  */
  YYSYMBOL_rterm = 155,                    /* rterm  */
  YYSYMBOL_pqual = 156,                    /* pqual  */
  YYSYMBOL_dqual = 157,                    /* dqual  */
  YYSYMBOL_aqual = 158,                    /* aqual  */
  YYSYMBOL_ndaqual = 159,                  /* ndaqual  */
  YYSYMBOL_pname = 160,                    /* pname  */
  YYSYMBOL_other = 161,                    /* other  */
  YYSYMBOL_pfvar = 162,                    /* pfvar  */
  YYSYMBOL_p80211 = 163,                   /* p80211  */
  YYSYMBOL_type = 164,                     /* type  */
  YYSYMBOL_subtype = 165,                  /* subtype  */
  YYSYMBOL_type_subtype = 166,             /* type_subtype  */
  YYSYMBOL_pllc = 167,                     /* pllc  */
  YYSYMBOL_dir = 168,                      /* dir  */
  YYSYMBOL_reason = 169,                   /* reason  */
  YYSYMBOL_action = 170,                   /* action  */
  YYSYMBOL_relop = 171,                    /* relop  */
  YYSYMBOL_irelop = 172,                   /* irelop  */
  YYSYMBOL_arth = 173,                     /* arth  */
  YYSYMBOL_narth = 174,                    /* narth  */
  YYSYMBOL_byteop = 175,                   /* byteop  */
  YYSYMBOL_pnum = 176,                     /* pnum  */
  YYSYMBOL_atmtype = 177,                  /* atmtype  */
  YYSYMBOL_atmmultitype = 178,             /* atmmultitype  */
  YYSYMBOL_atmfield = 179,                 /* atmfield  */
  YYSYMBOL_atmvalue = 180,                 /* atmvalue  */
  YYSYMBOL_atmfieldvalue = 181,            /* atmfieldvalue  */
  YYSYMBOL_atmlistvalue = 182,             /* atmlistvalue  */
  YYSYMBOL_mtp2type = 183,                 /* mtp2type  */
  YYSYMBOL_mtp3field = 184,                /* mtp3field  */
  YYSYMBOL_mtp3value = 185,                /* mtp3value  */
  YYSYMBOL_mtp3fieldvalue = 186,           /* mtp3fieldvalue  */
  YYSYMBOL_mtp3listvalue = 187             /* mtp3listvalue  */
};
typedef enum yysymbol_kind_t yysymbol_kind_t;




#ifdef short
# undef short
#endif

/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
   <limits.h> and (if available) <stdint.h> are included
   so that the code can choose integer types of a good width.  */

#ifndef __PTRDIFF_MAX__
# include <limits.h> /* INFRINGES ON USER NAME SPACE */
# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
#  define YY_STDINT_H
# endif
#endif

/* Narrow types that promote to a signed type and that can represent a
   signed or unsigned integer of at least N bits.  In tables they can
   save space and decrease cache pressure.  Promoting to a signed type
   helps avoid bugs in integer arithmetic.  */

#ifdef __INT_LEAST8_MAX__
typedef __INT_LEAST8_TYPE__ yytype_int8;
#elif defined YY_STDINT_H
typedef int_least8_t yytype_int8;
#else
typedef signed char yytype_int8;
#endif

#ifdef __INT_LEAST16_MAX__
typedef __INT_LEAST16_TYPE__ yytype_int16;
#elif defined YY_STDINT_H
typedef int_least16_t yytype_int16;
#else
typedef short yytype_int16;
#endif

/* Work around bug in HP-UX 11.23, which defines these macros
   incorrectly for preprocessor constants.  This workaround can likely
   be removed in 2023, as HPE has promised support for HP-UX 11.23
   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
#ifdef __hpux
# undef UINT_LEAST8_MAX
# undef UINT_LEAST16_MAX
# define UINT_LEAST8_MAX 255
# define UINT_LEAST16_MAX 65535
#endif

#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
typedef __UINT_LEAST8_TYPE__ yytype_uint8;
#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
       && UINT_LEAST8_MAX <= INT_MAX)
typedef uint_least8_t yytype_uint8;
#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
typedef unsigned char yytype_uint8;
#else
typedef short yytype_uint8;
#endif

#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
typedef __UINT_LEAST16_TYPE__ yytype_uint16;
#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
       && UINT_LEAST16_MAX <= INT_MAX)
typedef uint_least16_t yytype_uint16;
#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
typedef unsigned short yytype_uint16;
#else
typedef int yytype_uint16;
#endif

#ifndef YYPTRDIFF_T
# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
#  define YYPTRDIFF_T __PTRDIFF_TYPE__
#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
# elif defined PTRDIFF_MAX
#  ifndef ptrdiff_t
#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  endif
#  define YYPTRDIFF_T ptrdiff_t
#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
# else
#  define YYPTRDIFF_T long
#  define YYPTRDIFF_MAXIMUM LONG_MAX
# endif
#endif

#ifndef YYSIZE_T
# ifdef __SIZE_TYPE__
#  define YYSIZE_T __SIZE_TYPE__
# elif defined size_t
#  define YYSIZE_T size_t
# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  define YYSIZE_T size_t
# else
#  define YYSIZE_T unsigned
# endif
#endif

#define YYSIZE_MAXIMUM                                  \
  YY_CAST (YYPTRDIFF_T,                                 \
           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
            ? YYPTRDIFF_MAXIMUM                         \
            : YY_CAST (YYSIZE_T, -1)))

#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))


/* Stored state numbers (used for stacks). */
typedef yytype_int16 yy_state_t;

/* State numbers in computations.  */
typedef int yy_state_fast_t;

#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(Msgid) Msgid
# endif
#endif


#ifndef YY_ATTRIBUTE_PURE
# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
# else
#  define YY_ATTRIBUTE_PURE
# endif
#endif

#ifndef YY_ATTRIBUTE_UNUSED
# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
# else
#  define YY_ATTRIBUTE_UNUSED
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YY_USE(E) ((void) (E))
#else
# define YY_USE(E) /* empty */
#endif

/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
# else
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
# endif
# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
    _Pragma ("GCC diagnostic pop")
#else
# define YY_INITIAL_VALUE(Value) Value
#endif
#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_END
#endif
#ifndef YY_INITIAL_VALUE
# define YY_INITIAL_VALUE(Value) /* Nothing. */
#endif

#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
# define YY_IGNORE_USELESS_CAST_BEGIN                          \
    _Pragma ("GCC diagnostic push")                            \
    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
# define YY_IGNORE_USELESS_CAST_END            \
    _Pragma ("GCC diagnostic pop")
#endif
#ifndef YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_END
#endif


#define YY_ASSERT(E) ((void) (0 && (E)))

#if !defined yyoverflow

/* The parser invokes alloca or malloc; define the necessary symbols.  */

# ifdef YYSTACK_USE_ALLOCA
#  if YYSTACK_USE_ALLOCA
#   ifdef __GNUC__
#    define YYSTACK_ALLOC __builtin_alloca
#   elif defined __BUILTIN_VA_ARG_INCR
#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
#   elif defined _AIX
#    define YYSTACK_ALLOC __alloca
#   elif defined _MSC_VER
#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
#    define alloca _alloca
#   else
#    define YYSTACK_ALLOC alloca
#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
#     ifndef EXIT_SUCCESS
#      define EXIT_SUCCESS 0
#     endif
#    endif
#   endif
#  endif
# endif

# ifdef YYSTACK_ALLOC
   /* Pacify GCC's 'empty if-body' warning.  */
#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
#  ifndef YYSTACK_ALLOC_MAXIMUM
    /* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */
#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
#  endif
# else
#  define YYSTACK_ALLOC YYMALLOC
#  define YYSTACK_FREE YYFREE
#  ifndef YYSTACK_ALLOC_MAXIMUM
#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
#  endif
#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
       && ! ((defined YYMALLOC || defined malloc) \
             && (defined YYFREE || defined free)))
#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#   ifndef EXIT_SUCCESS
#    define EXIT_SUCCESS 0
#   endif
#  endif
#  ifndef YYMALLOC
#   define YYMALLOC malloc
#   if ! defined malloc && ! defined EXIT_SUCCESS
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined EXIT_SUCCESS
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* !defined yyoverflow */

#if (! defined yyoverflow \
     && (! defined __cplusplus \
         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
  yy_state_t yyss_alloc;
  YYSTYPE yyvs_alloc;
};

/* The size of the maximum gap between one aligned stack and the next.  */
# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)

/* The size of an array large to enough to hold all stacks, each with
   N elements.  */
# define YYSTACK_BYTES(N) \
     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
      + YYSTACK_GAP_MAXIMUM)

# define YYCOPY_NEEDED 1

/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */
# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
    do                                                                  \
      {                                                                 \
        YYPTRDIFF_T yynewbytes;                                         \
        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        Stack = &yyptr->Stack_alloc;                                    \
        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
      }                                                                 \
    while (0)

#endif

#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
/* Copy COUNT objects from SRC to DST.  The source and destination do
   not overlap.  */
# ifndef YYCOPY
#  if defined __GNUC__ && 1 < __GNUC__
#   define YYCOPY(Dst, Src, Count) \
      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
#  else
#   define YYCOPY(Dst, Src, Count)              \
      do                                        \
        {                                       \
          YYPTRDIFF_T yyi;                      \
          for (yyi = 0; yyi < (Count); yyi++)   \
            (Dst)[yyi] = (Src)[yyi];            \
        }                                       \
      while (0)
#  endif
# endif
#endif /* !YYCOPY_NEEDED */

/* YYFINAL -- State number of the termination state.  */
#define YYFINAL  3
/* YYLAST -- Last index in YYTABLE.  */
#define YYLAST   800

/* YYNTOKENS -- Number of terminals.  */
#define YYNTOKENS  141
/* YYNNTS -- Number of nonterminals.  */
#define YYNNTS  47
/* YYNRULES -- Number of rules.  */
#define YYNRULES  221
/* YYNSTATES -- Number of states.  */
#define YYNSTATES  296

/* YYMAXUTOK -- Last valid token kind.  */
#define YYMAXUTOK   378


/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex, with out-of-bounds checking.  */
#define YYTRANSLATE(YYX)                                \
  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
   : YYSYMBOL_YYUNDEF)

/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex.  */
static const yytype_uint8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,   123,     2,     2,     2,   139,   125,     2,
     132,   131,   128,   126,     2,   127,     2,   129,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,   138,     2,
     135,   134,   133,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,   136,     2,   137,   140,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,   124,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
      95,    96,    97,    98,    99,   100,   101,   102,   103,   104,
     105,   106,   107,   108,   109,   110,   111,   112,   113,   114,
     115,   116,   117,   118,   119,   120,   121,   122,   130
};

#if YYDEBUG
/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
static const yytype_int16 yyrline[] =
{
       0,   431,   431,   443,   445,   447,   448,   449,   450,   451,
     453,   455,   457,   458,   460,   462,   463,   482,   501,   520,
     545,   570,   571,   572,   574,   576,   578,   579,   580,   582,
     584,   586,   587,   589,   590,   591,   592,   593,   601,   603,
     604,   605,   606,   608,   610,   611,   612,   613,   614,   615,
     618,   619,   622,   623,   624,   625,   626,   627,   628,   629,
     630,   631,   632,   633,   636,   637,   638,   639,   642,   644,
     645,   646,   647,   648,   649,   650,   651,   652,   653,   654,
     655,   656,   657,   658,   659,   660,   661,   662,   663,   664,
     665,   666,   667,   668,   669,   670,   671,   672,   673,   674,
     675,   676,   677,   678,   679,   680,   681,   682,   684,   685,
     686,   687,   688,   689,   690,   691,   692,   693,   694,   695,
     696,   697,   698,   699,   700,   701,   702,   703,   706,   707,
     708,   709,   710,   711,   714,   719,   722,   726,   729,   735,
     744,   750,   773,   790,   791,   815,   818,   819,   835,   836,
     839,   842,   843,   844,   846,   847,   848,   850,   851,   853,
     854,   855,   856,   857,   858,   859,   860,   861,   862,   863,
     864,   865,   866,   867,   869,   870,   871,   872,   873,   875,
     876,   878,   879,   880,   881,   882,   883,   884,   886,   887,
     888,   889,   892,   893,   895,   896,   897,   898,   900,   907,
     908,   911,   912,   913,   914,   915,   916,   919,   920,   921,
     922,   923,   924,   925,   926,   928,   929,   930,   931,   933,
     946,   947
};
#endif

/** Accessing symbol of state STATE.  */
#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])

#if YYDEBUG || 0
/* The user-facing name of the symbol whose (internal) number is
   YYSYMBOL.  No bounds checking.  */
static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;

/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
static const char *const yytname[] =
{
  "\"end of file\"", "error", "\"invalid token\"", "DST", "SRC", "HOST",
  "GATEWAY", "NET", "NETMASK", "PORT", "PORTRANGE", "LESS", "GREATER",
  "PROTO", "PROTOCHAIN", "CBYTE", "ARP", "RARP", "IP", "SCTP", "TCP",
  "UDP", "ICMP", "IGMP", "IGRP", "PIM", "VRRP", "CARP", "ATALK", "AARP",
  "DECNET", "LAT", "SCA", "MOPRC", "MOPDL", "TK_BROADCAST", "TK_MULTICAST",
  "NUM", "INBOUND", "OUTBOUND", "IFINDEX", "PF_IFNAME", "PF_RSET",
  "PF_RNR", "PF_SRNR", "PF_REASON", "PF_ACTION", "TYPE", "SUBTYPE", "DIR",
  "ADDR1", "ADDR2", "ADDR3", "ADDR4", "RA", "TA", "LINK", "GEQ", "LEQ",
  "NEQ", "ID", "EID", "HID", "HID6", "AID", "LSH", "RSH", "LEN", "IPV6",
  "ICMPV6", "AH", "ESP", "VLAN", "MPLS", "PPPOED", "PPPOES", "GENEVE",
  "ISO", "ESIS", "CLNP", "ISIS", "L1", "L2", "IIH", "LSP", "SNP", "CSNP",
  "PSNP", "STP", "IPX", "NETBEUI", "LANE", "LLC", "METAC", "BCC", "SC",
  "ILMIC", "OAMF4EC", "OAMF4SC", "OAM", "OAMF4", "CONNECTMSG",
  "METACONNECT", "VPI", "VCI", "RADIO", "FISU", "LSSU", "MSU", "HFISU",
  "HLSSU", "HMSU", "SIO", "OPC", "DPC", "SLS", "HSIO", "HOPC", "HDPC",
  "HSLS", "LEX_ERROR", "OR", "AND", "'!'", "'|'", "'&'", "'+'", "'-'",
  "'*'", "'/'", "UMINUS", "')'", "'('", "'>'", "'='", "'<'", "'['", "']'",
  "':'", "'%'", "'^'", "$accept", "prog", "null", "expr", "and", "or",
  "id", "nid", "not", "paren", "pid", "qid", "term", "head", "rterm",
  "pqual", "dqual", "aqual", "ndaqual", "pname", "other", "pfvar",
  "p80211", "type", "subtype", "type_subtype", "pllc", "dir", "reason",
  "action", "relop", "irelop", "arth", "narth", "byteop", "pnum",
  "atmtype", "atmmultitype", "atmfield", "atmvalue", "atmfieldvalue",
  "atmlistvalue", "mtp2type", "mtp3field", "mtp3value", "mtp3fieldvalue",
  "mtp3listvalue", YY_NULLPTR
};

static const char *
yysymbol_name (yysymbol_kind_t yysymbol)
{
  return yytname[yysymbol];
}
#endif

#define YYPACT_NINF (-217)

#define yypact_value_is_default(Yyn) \
  ((Yyn) == YYPACT_NINF)

#define YYTABLE_NINF (-42)

#define yytable_value_is_error(Yyn) \
  0

/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */
static const yytype_int16 yypact[] =
{
    -217,    28,   223,  -217,    13,    18,    21,  -217,  -217,  -217,
    -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,
    -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,    41,
     -30,    24,    51,    79,   -25,    26,  -217,  -217,  -217,  -217,
    -217,  -217,   -24,   -24,  -217,   -24,   -24,  -217,  -217,  -217,
    -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,
    -217,  -217,   -23,  -217,  -217,  -217,  -217,  -217,  -217,  -217,
    -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,
    -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,
    -217,   576,  -217,   -50,   459,   459,  -217,    19,  -217,   745,
       3,  -217,  -217,  -217,   558,  -217,  -217,  -217,  -217,    -5,
    -217,    39,  -217,  -217,   -14,  -217,  -217,  -217,  -217,  -217,
    -217,  -217,  -217,  -217,  -217,   -24,  -217,  -217,  -217,  -217,
    -217,  -217,   576,  -103,   -49,  -217,  -217,   341,   341,  -217,
    -100,     2,    12,  -217,  -217,    -7,    -3,  -217,  -217,  -217,
      19,    19,  -217,    -4,    31,  -217,  -217,  -217,  -217,  -217,
    -217,  -217,  -217,  -217,   -22,    78,   -18,  -217,  -217,  -217,
    -217,  -217,  -217,    60,  -217,  -217,  -217,   576,  -217,  -217,
    -217,   576,   576,   576,   576,   576,   576,   576,   576,  -217,
    -217,  -217,   576,   576,   576,   576,  -217,   125,   126,   127,
    -217,  -217,  -217,   132,   133,   144,  -217,  -217,  -217,  -217,
    -217,  -217,  -217,   145,    12,   602,  -217,   341,   341,  -217,
      10,  -217,  -217,  -217,  -217,  -217,   123,   149,   150,  -217,
    -217,    63,   -50,    12,   191,   192,   194,   195,  -217,  -217,
     151,  -217,  -217,  -217,  -217,  -217,  -217,   585,    64,    64,
     607,    49,   -66,   -66,   -49,   -49,   602,   602,   602,   602,
    -217,   -97,  -217,  -217,  -217,   -92,  -217,  -217,  -217,   -95,
    -217,  -217,  -217,  -217,    19,    19,  -217,  -217,  -217,  -217,
     -12,  -217,   163,  -217,   125,  -217,   132,  -217,  -217,  -217,
    -217,  -217,    65,  -217,  -217,  -217
};

/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
   Performed when YYTABLE does not specify something else to do.  Zero
   means the default is an error.  */
static const yytype_uint8 yydefact[] =
{
       4,     0,    51,     1,     0,     0,     0,    71,    72,    70,
      73,    74,    75,    76,    77,    78,    79,    80,    81,    82,
      83,    84,    85,    86,    88,    87,   179,   113,   114,     0,
       0,     0,     0,     0,     0,     0,    69,   173,    89,    90,
      91,    92,   117,   119,   120,   122,   124,    93,    94,   103,
      95,    96,    97,    98,    99,   100,   102,   101,   104,   105,
     106,   181,   143,   182,   183,   186,   187,   184,   185,   188,
     189,   190,   191,   192,   193,   107,   201,   202,   203,   204,
     205,   206,   207,   208,   209,   210,   211,   212,   213,   214,
      24,     0,    25,     2,    51,    51,     5,     0,    31,     0,
      50,    44,   125,   127,     0,   158,   157,    45,    46,     0,
      48,     0,   110,   111,     0,   115,   128,   129,   130,   131,
     148,   149,   132,   150,   133,     0,   116,   118,   121,   123,
     145,   144,     0,     0,   171,    11,    10,    51,    51,    32,
       0,   158,   157,    15,    21,    18,    20,    22,    39,    12,
       0,     0,    13,    53,    52,    64,    68,    65,    66,    67,
      36,    37,   108,   109,     0,     0,     0,    58,    59,    60,
      61,    62,    63,    34,    35,    38,   126,     0,   152,   154,
     156,     0,     0,     0,     0,     0,     0,     0,     0,   151,
     153,   155,     0,     0,     0,     0,   198,     0,     0,     0,
      47,   194,   219,     0,     0,     0,    49,   215,   175,   174,
     177,   178,   176,     0,     0,     0,     7,    51,    51,     6,
     157,     9,     8,    40,   172,   180,     0,     0,     0,    23,
      26,    30,     0,    29,     0,     0,     0,     0,   138,   139,
     135,   142,   136,   146,   147,   137,    33,     0,   169,   170,
     167,   166,   161,   162,   163,   164,   165,   168,    42,    43,
     199,     0,   195,   196,   220,     0,   216,   217,   112,   157,
      17,    16,    19,    14,     0,     0,    55,    57,    54,    56,
       0,   159,     0,   197,     0,   218,     0,    27,    28,   140,
     141,   134,     0,   200,   221,   160
};

/* YYPGOTO[NTERM-NUM].  */
static const yytype_int16 yypgoto[] =
{
    -217,  -217,  -217,   199,   -26,  -216,   -91,  -133,     7,    -2,
    -217,  -217,   -77,  -217,  -217,  -217,  -217,    32,  -217,     9,
    -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,  -217,
     -43,   -34,   -27,   -81,  -217,   -38,  -217,  -217,  -217,  -217,
    -195,  -217,  -217,  -217,  -217,  -180,  -217
};

/* YYDEFGOTO[NTERM-NUM].  */
static const yytype_int16 yydefgoto[] =
{
       0,     1,     2,   140,   137,   138,   229,   149,   150,   132,
     231,   232,    96,    97,    98,    99,   173,   174,   175,   133,
     101,   102,   176,   240,   291,   242,   103,   245,   122,   124,
     194,   195,   104,   105,   213,   106,   107,   108,   109,   200,
     201,   261,   110,   111,   206,   207,   265
};

/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule whose
   number is the opposite.  If YYTABLE_NINF, syntax error.  */
static const yytype_int16 yytable[] =
{
      95,   226,   260,   -41,   126,   127,   148,   128,   129,    94,
     -13,   100,   120,    26,   141,   238,   275,   139,   230,   243,
     130,   135,   136,   264,   135,   289,   -29,   -29,     3,   135,
     116,   223,   196,   177,   283,   121,   225,   131,   239,   285,
     125,   125,   244,   125,   125,   284,   216,   221,   290,   286,
     112,   141,   178,   179,   180,   113,    26,   142,   114,   152,
     219,   222,   187,   188,   134,   155,   198,   157,   204,   158,
     159,   135,   136,   192,   193,   199,   202,   205,   115,   143,
     144,   145,   146,   147,   117,   230,   123,   214,   118,   293,
     192,   193,    95,    95,   142,   151,   178,   179,   180,   220,
     220,    94,    94,   100,   100,   215,   294,   197,    92,   203,
     208,   209,   152,   233,   181,   182,   119,   234,   235,   210,
     211,   212,   227,   125,   -41,   -41,   228,    92,   189,   190,
     191,   -13,   -13,   224,   -41,   218,   218,   141,   241,   177,
     139,   -13,    90,   225,   217,   217,   100,   100,   151,   125,
     247,    92,   236,   237,   248,   249,   250,   251,   252,   253,
     254,   255,   196,   262,   263,   256,   257,   258,   259,   202,
     266,    92,   189,   190,   191,   185,   186,   187,   188,   220,
     269,   267,   268,   287,   288,   270,   271,   272,   192,   193,
     185,   186,   187,   188,   273,   276,   277,   278,   279,   280,
     292,    93,   295,   192,   193,   246,   274,     0,     0,     0,
       0,     0,     0,     0,     0,   218,    95,     0,     0,     0,
       0,     0,     0,    -3,   217,   217,   100,   100,     0,     0,
       0,     0,     0,     0,     4,     5,   152,   152,     6,     7,
       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
      18,    19,    20,    21,    22,    23,    24,    25,     0,     0,
      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
       0,     0,   151,   151,     0,     0,     0,     0,     0,    36,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,
      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,
      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
      87,    88,    89,     0,     0,     0,    90,     0,     0,     0,
      91,     0,     4,     5,     0,    92,     6,     7,     8,     9,
      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
      20,    21,    22,    23,    24,    25,     0,     0,    26,    27,
      28,    29,    30,    31,    32,    33,    34,    35,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    36,     0,     0,
       0,   143,   144,   145,   146,   147,     0,     0,    37,    38,
      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
      49,    50,    51,    52,    53,    54,    55,    56,    57,    58,
      59,    60,    61,    62,    63,    64,    65,    66,    67,    68,
      69,    70,    71,    72,    73,    74,    75,    76,    77,    78,
      79,    80,    81,    82,    83,    84,    85,    86,    87,    88,
      89,     0,     0,     0,    90,     0,     0,     0,    91,     0,
       4,     5,     0,    92,     6,     7,     8,     9,    10,    11,
      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
      22,    23,    24,    25,     0,     0,    26,    27,    28,    29,
      30,    31,    32,    33,    34,    35,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    36,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    37,    38,    39,    40,
      41,    42,    43,    44,    45,    46,    47,    48,    49,    50,
      51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
      61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
      71,    72,    73,    74,    75,    76,    77,    78,    79,    80,
      81,    82,    83,    84,    85,    86,    87,    88,    89,     0,
       0,     0,    90,     0,     0,     0,    91,     0,     0,     0,
       0,    92,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,     0,     0,    26,     0,   178,   179,   180,     0,     0,
       0,     0,     0,   181,   182,     0,     0,     0,     0,     0,
       0,     0,    36,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    37,    38,    39,    40,    41,     0,     0,
     181,   182,     0,    47,    48,    49,    50,    51,    52,    53,
      54,    55,    56,    57,    58,    59,    60,   181,   182,     0,
       0,     0,   181,   182,     0,     0,     0,     0,     0,     0,
       0,    75,   183,   184,   185,   186,   187,   188,     0,     0,
       0,   189,   190,   191,     0,     0,     0,   192,   193,     0,
       0,     0,     0,    91,     0,     0,     0,     0,    92,   183,
     184,   185,   186,   187,   188,     0,     0,     0,     0,     0,
       0,     0,   281,   282,   192,   193,   183,   184,   185,   186,
     187,   188,   184,   185,   186,   187,   188,     0,     0,     0,
       0,   192,   193,     0,     0,     0,   192,   193,   153,   154,
     155,   156,   157,     0,   158,   159,     0,     0,   160,   161,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     162,   163,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   164,   165,   166,   167,   168,   169,   170,   171,
     172
};

static const yytype_int16 yycheck[] =
{
       2,     8,   197,     0,    42,    43,    97,    45,    46,     2,
       0,     2,    37,    37,    95,    37,   232,    94,   151,    37,
      43,   121,   122,   203,   121,    37,   121,   122,     0,   121,
      60,   131,    37,   136,   131,    60,   131,    60,    60,   131,
      42,    43,    60,    45,    46,   261,   137,   138,    60,   265,
      37,   132,    57,    58,    59,    37,    37,    95,    37,    97,
     137,   138,   128,   129,    91,     5,   109,     7,   111,     9,
      10,   121,   122,   139,   140,   109,    37,   111,    37,    60,
      61,    62,    63,    64,    60,   218,    60,   125,    37,   284,
     139,   140,    94,    95,   132,    97,    57,    58,    59,   137,
     138,    94,    95,    94,    95,   132,   286,   109,   132,   111,
     124,   125,   150,   151,    65,    66,    37,   121,   122,   133,
     134,   135,   129,   125,   121,   122,   129,   132,   133,   134,
     135,   121,   122,   131,   131,   137,   138,   218,    60,   136,
     217,   131,   123,   131,   137,   138,   137,   138,   150,   151,
     177,   132,   121,   122,   181,   182,   183,   184,   185,   186,
     187,   188,    37,    37,    37,   192,   193,   194,   195,    37,
      37,   132,   133,   134,   135,   126,   127,   128,   129,   217,
     218,    37,    37,   274,   275,    62,    37,    37,   139,   140,
     126,   127,   128,   129,   131,     4,     4,     3,     3,    48,
      37,     2,   137,   139,   140,   173,   232,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   217,   218,    -1,    -1,    -1,
      -1,    -1,    -1,     0,   217,   218,   217,   218,    -1,    -1,
      -1,    -1,    -1,    -1,    11,    12,   274,   275,    15,    16,
      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
      27,    28,    29,    30,    31,    32,    33,    34,    -1,    -1,
      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
      -1,    -1,   274,   275,    -1,    -1,    -1,    -1,    -1,    56,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,
      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
      97,    98,    99,   100,   101,   102,   103,   104,   105,   106,
     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
     117,   118,   119,    -1,    -1,    -1,   123,    -1,    -1,    -1,
     127,    -1,    11,    12,    -1,   132,    15,    16,    17,    18,
      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
      29,    30,    31,    32,    33,    34,    -1,    -1,    37,    38,
      39,    40,    41,    42,    43,    44,    45,    46,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    56,    -1,    -1,
      -1,    60,    61,    62,    63,    64,    -1,    -1,    67,    68,
      69,    70,    71,    72,    73,    74,    75,    76,    77,    78,
      79,    80,    81,    82,    83,    84,    85,    86,    87,    88,
      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
      99,   100,   101,   102,   103,   104,   105,   106,   107,   108,
     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
     119,    -1,    -1,    -1,   123,    -1,    -1,    -1,   127,    -1,
      11,    12,    -1,   132,    15,    16,    17,    18,    19,    20,
      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
      31,    32,    33,    34,    -1,    -1,    37,    38,    39,    40,
      41,    42,    43,    44,    45,    46,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    56,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    67,    68,    69,    70,
      71,    72,    73,    74,    75,    76,    77,    78,    79,    80,
      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
      91,    92,    93,    94,    95,    96,    97,    98,    99,   100,
     101,   102,   103,   104,   105,   106,   107,   108,   109,   110,
     111,   112,   113,   114,   115,   116,   117,   118,   119,    -1,
      -1,    -1,   123,    -1,    -1,    -1,   127,    -1,    -1,    -1,
      -1,   132,    16,    17,    18,    19,    20,    21,    22,    23,
      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
      34,    -1,    -1,    37,    -1,    57,    58,    59,    -1,    -1,
      -1,    -1,    -1,    65,    66,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    56,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    67,    68,    69,    70,    71,    -1,    -1,
      65,    66,    -1,    77,    78,    79,    80,    81,    82,    83,
      84,    85,    86,    87,    88,    89,    90,    65,    66,    -1,
      -1,    -1,    65,    66,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   105,   124,   125,   126,   127,   128,   129,    -1,    -1,
      -1,   133,   134,   135,    -1,    -1,    -1,   139,   140,    -1,
      -1,    -1,    -1,   127,    -1,    -1,    -1,    -1,   132,   124,
     125,   126,   127,   128,   129,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   137,   138,   139,   140,   124,   125,   126,   127,
     128,   129,   125,   126,   127,   128,   129,    -1,    -1,    -1,
      -1,   139,   140,    -1,    -1,    -1,   139,   140,     3,     4,
       5,     6,     7,    -1,     9,    10,    -1,    -1,    13,    14,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      35,    36,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    47,    48,    49,    50,    51,    52,    53,    54,
      55
};

/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
   state STATE-NUM.  */
static const yytype_uint8 yystos[] =
{
       0,   142,   143,     0,    11,    12,    15,    16,    17,    18,
      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
      29,    30,    31,    32,    33,    34,    37,    38,    39,    40,
      41,    42,    43,    44,    45,    46,    56,    67,    68,    69,
      70,    71,    72,    73,    74,    75,    76,    77,    78,    79,
      80,    81,    82,    83,    84,    85,    86,    87,    88,    89,
      90,    91,    92,    93,    94,    95,    96,    97,    98,    99,
     100,   101,   102,   103,   104,   105,   106,   107,   108,   109,
     110,   111,   112,   113,   114,   115,   116,   117,   118,   119,
     123,   127,   132,   144,   149,   150,   153,   154,   155,   156,
     160,   161,   162,   167,   173,   174,   176,   177,   178,   179,
     183,   184,    37,    37,    37,    37,    60,    60,    37,    37,
      37,    60,   169,    60,   170,   150,   176,   176,   176,   176,
      43,    60,   150,   160,   173,   121,   122,   145,   146,   153,
     144,   174,   176,    60,    61,    62,    63,    64,   147,   148,
     149,   150,   176,     3,     4,     5,     6,     7,     9,    10,
      13,    14,    35,    36,    47,    48,    49,    50,    51,    52,
      53,    54,    55,   157,   158,   159,   163,   136,    57,    58,
      59,    65,    66,   124,   125,   126,   127,   128,   129,   133,
     134,   135,   139,   140,   171,   172,    37,   150,   171,   172,
     180,   181,    37,   150,   171,   172,   185,   186,   124,   125,
     133,   134,   135,   175,   176,   173,   147,   149,   150,   153,
     176,   147,   153,   131,   131,   131,     8,   129,   129,   147,
     148,   151,   152,   176,   121,   122,   121,   122,    37,    60,
     164,    60,   166,    37,    60,   168,   158,   173,   173,   173,
     173,   173,   173,   173,   173,   173,   173,   173,   173,   173,
     181,   182,    37,    37,   186,   187,    37,    37,    37,   176,
      62,    37,    37,   131,   145,   146,     4,     4,     3,     3,
      48,   137,   138,   131,   146,   131,   146,   147,   147,    37,
      60,   165,    37,   181,   186,   137
};

/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
static const yytype_uint8 yyr1[] =
{
       0,   141,   142,   142,   143,   144,   144,   144,   144,   144,
     145,   146,   147,   147,   147,   148,   148,   148,   148,   148,
     148,   148,   148,   148,   149,   150,   151,   151,   151,   152,
     152,   153,   153,   154,   154,   154,   154,   154,   154,   155,
     155,   155,   155,   155,   155,   155,   155,   155,   155,   155,
     156,   156,   157,   157,   157,   157,   157,   157,   157,   157,
     157,   157,   157,   157,   158,   158,   158,   158,   159,   160,
     160,   160,   160,   160,   160,   160,   160,   160,   160,   160,
     160,   160,   160,   160,   160,   160,   160,   160,   160,   160,
     160,   160,   160,   160,   160,   160,   160,   160,   160,   160,
     160,   160,   160,   160,   160,   160,   160,   160,   161,   161,
     161,   161,   161,   161,   161,   161,   161,   161,   161,   161,
     161,   161,   161,   161,   161,   161,   161,   161,   162,   162,
     162,   162,   162,   162,   163,   163,   163,   163,   164,   164,
     165,   165,   166,   167,   167,   167,   168,   168,   169,   169,
     170,   171,   171,   171,   172,   172,   172,   173,   173,   174,
     174,   174,   174,   174,   174,   174,   174,   174,   174,   174,
     174,   174,   174,   174,   175,   175,   175,   175,   175,   176,
     176,   177,   177,   177,   177,   177,   177,   177,   178,   178,
     178,   178,   179,   179,   180,   180,   180,   180,   181,   182,
     182,   183,   183,   183,   183,   183,   183,   184,   184,   184,
     184,   184,   184,   184,   184,   185,   185,   185,   185,   186,
     187,   187
};

/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
static const yytype_int8 yyr2[] =
{
       0,     2,     2,     1,     0,     1,     3,     3,     3,     3,
       1,     1,     1,     1,     3,     1,     3,     3,     1,     3,
       1,     1,     1,     2,     1,     1,     1,     3,     3,     1,
       1,     1,     2,     3,     2,     2,     2,     2,     2,     2,
       3,     1,     3,     3,     1,     1,     1,     2,     1,     2,
       1,     0,     1,     1,     3,     3,     3,     3,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     2,     2,
       2,     2,     4,     1,     1,     2,     2,     1,     2,     1,
       1,     2,     1,     2,     1,     1,     2,     1,     2,     2,
       2,     2,     2,     2,     4,     2,     2,     2,     1,     1,
       1,     1,     1,     1,     2,     2,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     4,
       6,     3,     3,     3,     3,     3,     3,     3,     3,     3,
       3,     2,     3,     1,     1,     1,     1,     1,     1,     1,
       3,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     2,     2,     3,     1,     1,
       3,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     2,     2,     3,     1,
       1,     3
};


enum { YYENOMEM = -2 };

#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (yychar = YYEMPTY)

#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrorlab
#define YYNOMEM         goto yyexhaustedlab


#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)                                    \
  do                                                              \
    if (yychar == YYEMPTY)                                        \
      {                                                           \
        yychar = (Token);                                         \
        yylval = (Value);                                         \
        YYPOPSTACK (yylen);                                       \
        yystate = *yyssp;                                         \
        goto yybackup;                                            \
      }                                                           \
    else                                                          \
      {                                                           \
        yyerror (yyscanner, cstate, YY_("syntax error: cannot back up")); \
        YYERROR;                                                  \
      }                                                           \
  while (0)

/* Backward compatibility with an undocumented macro.
   Use YYerror or YYUNDEF. */
#define YYERRCODE YYUNDEF


/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)                        \
do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)




# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, "%s ", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Kind, Value, yyscanner, cstate); \
      YYFPRINTF (stderr, "\n");                                           \
    }                                                                     \
} while (0)


/*-----------------------------------.
| Print this symbol's value on YYO.  |
`-----------------------------------*/

static void
yy_symbol_value_print (FILE *yyo,
                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, void *yyscanner, compiler_state_t *cstate)
{
  FILE *yyoutput = yyo;
  YY_USE (yyoutput);
  YY_USE (yyscanner);
  YY_USE (cstate);
  if (!yyvaluep)
    return;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  YY_USE (yykind);
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}


/*---------------------------.
| Print this symbol on YYO.  |
`---------------------------*/

static void
yy_symbol_print (FILE *yyo,
                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, void *yyscanner, compiler_state_t *cstate)
{
  YYFPRINTF (yyo, "%s %s (",
             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));

  yy_symbol_value_print (yyo, yykind, yyvaluep, yyscanner, cstate);
  YYFPRINTF (yyo, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

static void
yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
{
  YYFPRINTF (stderr, "Stack now");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, " %d", yybot);
    }
  YYFPRINTF (stderr, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)                            \
do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

static void
yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
                 int yyrule, void *yyscanner, compiler_state_t *cstate)
{
  int yylno = yyrline[yyrule];
  int yynrhs = yyr2[yyrule];
  int yyi;
  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
             yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
      yy_symbol_print (stderr,
                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
                       &yyvsp[(yyi + 1) - (yynrhs)], yyscanner, cstate);
      YYFPRINTF (stderr, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)          \
do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, cstate); \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args) ((void) 0)
# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif






/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

static void
yydestruct (const char *yymsg,
            yysymbol_kind_t yykind, YYSTYPE *yyvaluep, void *yyscanner, compiler_state_t *cstate)
{
  YY_USE (yyvaluep);
  YY_USE (yyscanner);
  YY_USE (cstate);
  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  YY_USE (yykind);
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}






/*----------.
| yyparse.  |
`----------*/

int
yyparse (void *yyscanner, compiler_state_t *cstate)
{
/* Lookahead token kind.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs = 0;

    yy_state_fast_t yystate = 0;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus = 0;

    /* Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* Their size.  */
    YYPTRDIFF_T yystacksize = YYINITDEPTH;

    /* The state stack: array, bottom, top.  */
    yy_state_t yyssa[YYINITDEPTH];
    yy_state_t *yyss = yyssa;
    yy_state_t *yyssp = yyss;

    /* The semantic value stack: array, bottom, top.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs = yyvsa;
    YYSTYPE *yyvsp = yyvs;

  int yyn;
  /* The return value of yyparse.  */
  int yyresult;
  /* Lookahead symbol kind.  */
  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;



#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  YYDPRINTF ((stderr, "Starting parse\n"));

  yychar = YYEMPTY; /* Cause a token to be read.  */

  goto yysetstate;


/*------------------------------------------------------------.
| yynewstate -- push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;


/*--------------------------------------------------------------------.
| yysetstate -- set current state (the top of the stack) to yystate.  |
`--------------------------------------------------------------------*/
yysetstate:
  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
  YY_IGNORE_USELESS_CAST_BEGIN
  *yyssp = YY_CAST (yy_state_t, yystate);
  YY_IGNORE_USELESS_CAST_END
  YY_STACK_PRINT (yyss, yyssp);

  if (yyss + yystacksize - 1 <= yyssp)
#if !defined yyoverflow && !defined YYSTACK_RELOCATE
    YYNOMEM;
#else
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYPTRDIFF_T yysize = yyssp - yyss + 1;

# if defined yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        yy_state_t *yyss1 = yyss;
        YYSTYPE *yyvs1 = yyvs;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_("memory exhausted"),
                    &yyss1, yysize * YYSIZEOF (*yyssp),
                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
                    &yystacksize);
        yyss = yyss1;
        yyvs = yyvs1;
      }
# else /* defined YYSTACK_RELOCATE */
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        YYNOMEM;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yy_state_t *yyss1 = yyss;
        union yyalloc *yyptr =
          YY_CAST (union yyalloc *,
                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
        if (! yyptr)
          YYNOMEM;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YY_IGNORE_USELESS_CAST_BEGIN
      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
                  YY_CAST (long, yystacksize)));
      YY_IGNORE_USELESS_CAST_END

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }
#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */


  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;


/*-----------.
| yybackup.  |
`-----------*/
yybackup:
  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, "Reading a token\n"));
      yychar = yylex (&yylval, yyscanner);
    }

  if (yychar <= YYEOF)
    {
      yychar = YYEOF;
      yytoken = YYSYMBOL_YYEOF;
      YYDPRINTF ((stderr, "Now at end of input.\n"));
    }
  else if (yychar == YYerror)
    {
      /* The scanner already issued an error message, process directly
         to error recovery.  But do not keep the error token as
         lookahead, it is too special and may lead us to an endless
         loop in error recovery. */
      yychar = YYUNDEF;
      yytoken = YYSYMBOL_YYerror;
      goto yyerrlab1;
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  /* Discard the shifted token.  */
  yychar = YYEMPTY;
  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
  case 2: /* prog: null expr  */
#line 432 "grammar.y"
{
	/*
	 * I'm not sure we have a reason to use yynerrs, but it's
	 * declared, and incremented, whether we need it or not,
	 * which means that Clang 15 will give a "used but not
	 * set" warning.  This should suppress the warning for
	 * yynerrs without suppressing it for other variables.
	 */
	(void) yynerrs;
	CHECK_INT_VAL(finish_parse(cstate, (yyvsp[0].blk).b));
}
#line 1922 "grammar.c"
    break;

  case 4: /* null: %empty  */
#line 445 "grammar.y"
                                { (yyval.blk).q = qerr; }
#line 1928 "grammar.c"
    break;

  case 6: /* expr: expr and term  */
#line 448 "grammar.y"
                                { gen_and((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 1934 "grammar.c"
    break;

  case 7: /* expr: expr and id  */
#line 449 "grammar.y"
                                { gen_and((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 1940 "grammar.c"
    break;

  case 8: /* expr: expr or term  */
#line 450 "grammar.y"
                                { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 1946 "grammar.c"
    break;

  case 9: /* expr: expr or id  */
#line 451 "grammar.y"
                                { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 1952 "grammar.c"
    break;

  case 10: /* and: AND  */
#line 453 "grammar.y"
                                { (yyval.blk) = (yyvsp[-1].blk); }
#line 1958 "grammar.c"
    break;

  case 11: /* or: OR  */
#line 455 "grammar.y"
                                { (yyval.blk) = (yyvsp[-1].blk); }
#line 1964 "grammar.c"
    break;

  case 13: /* id: pnum  */
#line 458 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_ncode(cstate, NULL, (yyvsp[0].h),
						   (yyval.blk).q = (yyvsp[-1].blk).q))); }
#line 1971 "grammar.c"
    break;

  case 14: /* id: paren pid ')'  */
#line 460 "grammar.y"
                                { (yyval.blk) = (yyvsp[-1].blk); }
#line 1977 "grammar.c"
    break;

  case 15: /* nid: ID  */
#line 462 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.blk).b = gen_scode(cstate, (yyvsp[0].s), (yyval.blk).q = (yyvsp[-1].blk).q))); }
#line 1983 "grammar.c"
    break;

  case 16: /* nid: HID '/' NUM  */
#line 463 "grammar.y"
                                {
				  CHECK_PTR_VAL((yyvsp[-2].s));
				  /* Check whether HID/NUM is being used when appropriate */
				  (yyval.blk).q = (yyvsp[-3].blk).q;
				  if ((yyval.blk).q.addr == Q_PORT) {
					bpf_set_error(cstate, "'port' modifier applied to IP address and prefix length");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
					bpf_set_error(cstate, "'portrange' modifier applied to IP address and prefix length");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTO) {
					bpf_set_error(cstate, "'proto' modifier applied to IP address and prefix length");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
					bpf_set_error(cstate, "'protochain' modifier applied to IP address and prefix length");
					YYABORT;
				  }
				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode(cstate, (yyvsp[-2].s), NULL, (yyvsp[0].h), (yyval.blk).q)));
				}
#line 2007 "grammar.c"
    break;

  case 17: /* nid: HID NETMASK HID  */
#line 482 "grammar.y"
                                {
				  CHECK_PTR_VAL((yyvsp[-2].s));
				  /* Check whether HID mask HID is being used when appropriate */
				  (yyval.blk).q = (yyvsp[-3].blk).q;
				  if ((yyval.blk).q.addr == Q_PORT) {
					bpf_set_error(cstate, "'port' modifier applied to IP address and netmask");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
					bpf_set_error(cstate, "'portrange' modifier applied to IP address and netmask");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTO) {
					bpf_set_error(cstate, "'proto' modifier applied to IP address and netmask");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
					bpf_set_error(cstate, "'protochain' modifier applied to IP address and netmask");
					YYABORT;
				  }
				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode(cstate, (yyvsp[-2].s), (yyvsp[0].s), 0, (yyval.blk).q)));
				}
#line 2031 "grammar.c"
    break;

  case 18: /* nid: HID  */
#line 501 "grammar.y"
                                {
				  CHECK_PTR_VAL((yyvsp[0].s));
				  /* Check whether HID is being used when appropriate */
				  (yyval.blk).q = (yyvsp[-1].blk).q;
				  if ((yyval.blk).q.addr == Q_PORT) {
					bpf_set_error(cstate, "'port' modifier applied to IP address");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
					bpf_set_error(cstate, "'portrange' modifier applied to IP address");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTO) {
					bpf_set_error(cstate, "'proto' modifier applied to IP address");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
					bpf_set_error(cstate, "'protochain' modifier applied to IP address");
					YYABORT;
				  }
				  CHECK_PTR_VAL(((yyval.blk).b = gen_ncode(cstate, (yyvsp[0].s), 0, (yyval.blk).q)));
				}
#line 2055 "grammar.c"
    break;

  case 19: /* nid: HID6 '/' NUM  */
#line 520 "grammar.y"
                                {
				  CHECK_PTR_VAL((yyvsp[-2].s));
#ifdef INET6
				  /* Check whether HID6/NUM is being used when appropriate */
				  (yyval.blk).q = (yyvsp[-3].blk).q;
				  if ((yyval.blk).q.addr == Q_PORT) {
					bpf_set_error(cstate, "'port' modifier applied to IP address and prefix length");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
					bpf_set_error(cstate, "'portrange' modifier applied to IP address and prefix length");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTO) {
					bpf_set_error(cstate, "'proto' modifier applied to IP address and prefix length ");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
					bpf_set_error(cstate, "'protochain' modifier applied to IP address and prefix length");
					YYABORT;
				  }
				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode6(cstate, (yyvsp[-2].s), (yyvsp[0].h), (yyval.blk).q)));
#else
				  bpf_set_error(cstate, "IPv6 addresses not supported "
					"in this configuration");
				  YYABORT;
#endif /*INET6*/
				}
#line 2085 "grammar.c"
    break;

  case 20: /* nid: HID6  */
#line 545 "grammar.y"
                                {
				  CHECK_PTR_VAL((yyvsp[0].s));
#ifdef INET6
				  /* Check whether HID6 is being used when appropriate */
				  (yyval.blk).q = (yyvsp[-1].blk).q;
				  if ((yyval.blk).q.addr == Q_PORT) {
					bpf_set_error(cstate, "'port' modifier applied to IP address");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PORTRANGE) {
					bpf_set_error(cstate, "'portrange' modifier applied to IP address");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTO) {
					bpf_set_error(cstate, "'proto' modifier applied to 'ip6addr/prefixlen");
					YYABORT;
				  } else if ((yyval.blk).q.addr == Q_PROTOCHAIN) {
					bpf_set_error(cstate, "'protochain' modifier applied to IP address");
					YYABORT;
				  }
				  CHECK_PTR_VAL(((yyval.blk).b = gen_mcode6(cstate, (yyvsp[0].s), 128, (yyval.blk).q)));
#else
				  bpf_set_error(cstate, "IPv6 addresses not supported "
					"in this configuration");
				  YYABORT;
#endif /*INET6*/
				}
#line 2115 "grammar.c"
    break;

  case 21: /* nid: EID  */
#line 570 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.blk).b = gen_ecode(cstate, (yyvsp[0].s), (yyval.blk).q = (yyvsp[-1].blk).q))); }
#line 2121 "grammar.c"
    break;

  case 22: /* nid: AID  */
#line 571 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.blk).b = gen_acode(cstate, (yyvsp[0].s), (yyval.blk).q = (yyvsp[-1].blk).q))); }
#line 2127 "grammar.c"
    break;

  case 23: /* nid: not id  */
#line 572 "grammar.y"
                                { gen_not((yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 2133 "grammar.c"
    break;

  case 24: /* not: '!'  */
#line 574 "grammar.y"
                                { (yyval.blk) = (yyvsp[-1].blk); }
#line 2139 "grammar.c"
    break;

  case 25: /* paren: '('  */
#line 576 "grammar.y"
                                { (yyval.blk) = (yyvsp[-1].blk); }
#line 2145 "grammar.c"
    break;

  case 27: /* pid: qid and id  */
#line 579 "grammar.y"
                                { gen_and((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 2151 "grammar.c"
    break;

  case 28: /* pid: qid or id  */
#line 580 "grammar.y"
                                { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 2157 "grammar.c"
    break;

  case 29: /* qid: pnum  */
#line 582 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_ncode(cstate, NULL, (yyvsp[0].h),
						   (yyval.blk).q = (yyvsp[-1].blk).q))); }
#line 2164 "grammar.c"
    break;

  case 32: /* term: not term  */
#line 587 "grammar.y"
                                { gen_not((yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 2170 "grammar.c"
    break;

  case 33: /* head: pqual dqual aqual  */
#line 589 "grammar.y"
                                { QSET((yyval.blk).q, (yyvsp[-2].i), (yyvsp[-1].i), (yyvsp[0].i)); }
#line 2176 "grammar.c"
    break;

  case 34: /* head: pqual dqual  */
#line 590 "grammar.y"
                                { QSET((yyval.blk).q, (yyvsp[-1].i), (yyvsp[0].i), Q_DEFAULT); }
#line 2182 "grammar.c"
    break;

  case 35: /* head: pqual aqual  */
#line 591 "grammar.y"
                                { QSET((yyval.blk).q, (yyvsp[-1].i), Q_DEFAULT, (yyvsp[0].i)); }
#line 2188 "grammar.c"
    break;

  case 36: /* head: pqual PROTO  */
#line 592 "grammar.y"
                                { QSET((yyval.blk).q, (yyvsp[-1].i), Q_DEFAULT, Q_PROTO); }
#line 2194 "grammar.c"
    break;

  case 37: /* head: pqual PROTOCHAIN  */
#line 593 "grammar.y"
                                {
#ifdef NO_PROTOCHAIN
				  bpf_set_error(cstate, "protochain not supported");
				  YYABORT;
#else
				  QSET((yyval.blk).q, (yyvsp[-1].i), Q_DEFAULT, Q_PROTOCHAIN);
#endif
				}
#line 2207 "grammar.c"
    break;

  case 38: /* head: pqual ndaqual  */
#line 601 "grammar.y"
                                { QSET((yyval.blk).q, (yyvsp[-1].i), Q_DEFAULT, (yyvsp[0].i)); }
#line 2213 "grammar.c"
    break;

  case 39: /* rterm: head id  */
#line 603 "grammar.y"
                                { (yyval.blk) = (yyvsp[0].blk); }
#line 2219 "grammar.c"
    break;

  case 40: /* rterm: paren expr ')'  */
#line 604 "grammar.y"
                                { (yyval.blk).b = (yyvsp[-1].blk).b; (yyval.blk).q = (yyvsp[-2].blk).q; }
#line 2225 "grammar.c"
    break;

  case 41: /* rterm: pname  */
#line 605 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_proto_abbrev(cstate, (yyvsp[0].i)))); (yyval.blk).q = qerr; }
#line 2231 "grammar.c"
    break;

  case 42: /* rterm: arth relop arth  */
#line 606 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_relation(cstate, (yyvsp[-1].i), (yyvsp[-2].a), (yyvsp[0].a), 0)));
				  (yyval.blk).q = qerr; }
#line 2238 "grammar.c"
    break;

  case 43: /* rterm: arth irelop arth  */
#line 608 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_relation(cstate, (yyvsp[-1].i), (yyvsp[-2].a), (yyvsp[0].a), 1)));
				  (yyval.blk).q = qerr; }
#line 2245 "grammar.c"
    break;

  case 44: /* rterm: other  */
#line 610 "grammar.y"
                                { (yyval.blk).b = (yyvsp[0].rblk); (yyval.blk).q = qerr; }
#line 2251 "grammar.c"
    break;

  case 45: /* rterm: atmtype  */
#line 611 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_atmtype_abbrev(cstate, (yyvsp[0].i)))); (yyval.blk).q = qerr; }
#line 2257 "grammar.c"
    break;

  case 46: /* rterm: atmmultitype  */
#line 612 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_atmmulti_abbrev(cstate, (yyvsp[0].i)))); (yyval.blk).q = qerr; }
#line 2263 "grammar.c"
    break;

  case 47: /* rterm: atmfield atmvalue  */
#line 613 "grammar.y"
                                { (yyval.blk).b = (yyvsp[0].blk).b; (yyval.blk).q = qerr; }
#line 2269 "grammar.c"
    break;

  case 48: /* rterm: mtp2type  */
#line 614 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_mtp2type_abbrev(cstate, (yyvsp[0].i)))); (yyval.blk).q = qerr; }
#line 2275 "grammar.c"
    break;

  case 49: /* rterm: mtp3field mtp3value  */
#line 615 "grammar.y"
                                { (yyval.blk).b = (yyvsp[0].blk).b; (yyval.blk).q = qerr; }
#line 2281 "grammar.c"
    break;

  case 51: /* pqual: %empty  */
#line 619 "grammar.y"
                                { (yyval.i) = Q_DEFAULT; }
#line 2287 "grammar.c"
    break;

  case 52: /* dqual: SRC  */
#line 622 "grammar.y"
                                { (yyval.i) = Q_SRC; }
#line 2293 "grammar.c"
    break;

  case 53: /* dqual: DST  */
#line 623 "grammar.y"
                                { (yyval.i) = Q_DST; }
#line 2299 "grammar.c"
    break;

  case 54: /* dqual: SRC OR DST  */
#line 624 "grammar.y"
                                { (yyval.i) = Q_OR; }
#line 2305 "grammar.c"
    break;

  case 55: /* dqual: DST OR SRC  */
#line 625 "grammar.y"
                                { (yyval.i) = Q_OR; }
#line 2311 "grammar.c"
    break;

  case 56: /* dqual: SRC AND DST  */
#line 626 "grammar.y"
                                { (yyval.i) = Q_AND; }
#line 2317 "grammar.c"
    break;

  case 57: /* dqual: DST AND SRC  */
#line 627 "grammar.y"
                                { (yyval.i) = Q_AND; }
#line 2323 "grammar.c"
    break;

  case 58: /* dqual: ADDR1  */
#line 628 "grammar.y"
                                { (yyval.i) = Q_ADDR1; }
#line 2329 "grammar.c"
    break;

  case 59: /* dqual: ADDR2  */
#line 629 "grammar.y"
                                { (yyval.i) = Q_ADDR2; }
#line 2335 "grammar.c"
    break;

  case 60: /* dqual: ADDR3  */
#line 630 "grammar.y"
                                { (yyval.i) = Q_ADDR3; }
#line 2341 "grammar.c"
    break;

  case 61: /* dqual: ADDR4  */
#line 631 "grammar.y"
                                { (yyval.i) = Q_ADDR4; }
#line 2347 "grammar.c"
    break;

  case 62: /* dqual: RA  */
#line 632 "grammar.y"
                                { (yyval.i) = Q_RA; }
#line 2353 "grammar.c"
    break;

  case 63: /* dqual: TA  */
#line 633 "grammar.y"
                                { (yyval.i) = Q_TA; }
#line 2359 "grammar.c"
    break;

  case 64: /* aqual: HOST  */
#line 636 "grammar.y"
                                { (yyval.i) = Q_HOST; }
#line 2365 "grammar.c"
    break;

  case 65: /* aqual: NET  */
#line 637 "grammar.y"
                                { (yyval.i) = Q_NET; }
#line 2371 "grammar.c"
    break;

  case 66: /* aqual: PORT  */
#line 638 "grammar.y"
                                { (yyval.i) = Q_PORT; }
#line 2377 "grammar.c"
    break;

  case 67: /* aqual: PORTRANGE  */
#line 639 "grammar.y"
                                { (yyval.i) = Q_PORTRANGE; }
#line 2383 "grammar.c"
    break;

  case 68: /* ndaqual: GATEWAY  */
#line 642 "grammar.y"
                                { (yyval.i) = Q_GATEWAY; }
#line 2389 "grammar.c"
    break;

  case 69: /* pname: LINK  */
#line 644 "grammar.y"
                                { (yyval.i) = Q_LINK; }
#line 2395 "grammar.c"
    break;

  case 70: /* pname: IP  */
#line 645 "grammar.y"
                                { (yyval.i) = Q_IP; }
#line 2401 "grammar.c"
    break;

  case 71: /* pname: ARP  */
#line 646 "grammar.y"
                                { (yyval.i) = Q_ARP; }
#line 2407 "grammar.c"
    break;

  case 72: /* pname: RARP  */
#line 647 "grammar.y"
                                { (yyval.i) = Q_RARP; }
#line 2413 "grammar.c"
    break;

  case 73: /* pname: SCTP  */
#line 648 "grammar.y"
                                { (yyval.i) = Q_SCTP; }
#line 2419 "grammar.c"
    break;

  case 74: /* pname: TCP  */
#line 649 "grammar.y"
                                { (yyval.i) = Q_TCP; }
#line 2425 "grammar.c"
    break;

  case 75: /* pname: UDP  */
#line 650 "grammar.y"
                                { (yyval.i) = Q_UDP; }
#line 2431 "grammar.c"
    break;

  case 76: /* pname: ICMP  */
#line 651 "grammar.y"
                                { (yyval.i) = Q_ICMP; }
#line 2437 "grammar.c"
    break;

  case 77: /* pname: IGMP  */
#line 652 "grammar.y"
                                { (yyval.i) = Q_IGMP; }
#line 2443 "grammar.c"
    break;

  case 78: /* pname: IGRP  */
#line 653 "grammar.y"
                                { (yyval.i) = Q_IGRP; }
#line 2449 "grammar.c"
    break;

  case 79: /* pname: PIM  */
#line 654 "grammar.y"
                                { (yyval.i) = Q_PIM; }
#line 2455 "grammar.c"
    break;

  case 80: /* pname: VRRP  */
#line 655 "grammar.y"
                                { (yyval.i) = Q_VRRP; }
#line 2461 "grammar.c"
    break;

  case 81: /* pname: CARP  */
#line 656 "grammar.y"
                                { (yyval.i) = Q_CARP; }
#line 2467 "grammar.c"
    break;

  case 82: /* pname: ATALK  */
#line 657 "grammar.y"
                                { (yyval.i) = Q_ATALK; }
#line 2473 "grammar.c"
    break;

  case 83: /* pname: AARP  */
#line 658 "grammar.y"
                                { (yyval.i) = Q_AARP; }
#line 2479 "grammar.c"
    break;

  case 84: /* pname: DECNET  */
#line 659 "grammar.y"
                                { (yyval.i) = Q_DECNET; }
#line 2485 "grammar.c"
    break;

  case 85: /* pname: LAT  */
#line 660 "grammar.y"
                                { (yyval.i) = Q_LAT; }
#line 2491 "grammar.c"
    break;

  case 86: /* pname: SCA  */
#line 661 "grammar.y"
                                { (yyval.i) = Q_SCA; }
#line 2497 "grammar.c"
    break;

  case 87: /* pname: MOPDL  */
#line 662 "grammar.y"
                                { (yyval.i) = Q_MOPDL; }
#line 2503 "grammar.c"
    break;

  case 88: /* pname: MOPRC  */
#line 663 "grammar.y"
                                { (yyval.i) = Q_MOPRC; }
#line 2509 "grammar.c"
    break;

  case 89: /* pname: IPV6  */
#line 664 "grammar.y"
                                { (yyval.i) = Q_IPV6; }
#line 2515 "grammar.c"
    break;

  case 90: /* pname: ICMPV6  */
#line 665 "grammar.y"
                                { (yyval.i) = Q_ICMPV6; }
#line 2521 "grammar.c"
    break;

  case 91: /* pname: AH  */
#line 666 "grammar.y"
                                { (yyval.i) = Q_AH; }
#line 2527 "grammar.c"
    break;

  case 92: /* pname: ESP  */
#line 667 "grammar.y"
                                { (yyval.i) = Q_ESP; }
#line 2533 "grammar.c"
    break;

  case 93: /* pname: ISO  */
#line 668 "grammar.y"
                                { (yyval.i) = Q_ISO; }
#line 2539 "grammar.c"
    break;

  case 94: /* pname: ESIS  */
#line 669 "grammar.y"
                                { (yyval.i) = Q_ESIS; }
#line 2545 "grammar.c"
    break;

  case 95: /* pname: ISIS  */
#line 670 "grammar.y"
                                { (yyval.i) = Q_ISIS; }
#line 2551 "grammar.c"
    break;

  case 96: /* pname: L1  */
#line 671 "grammar.y"
                                { (yyval.i) = Q_ISIS_L1; }
#line 2557 "grammar.c"
    break;

  case 97: /* pname: L2  */
#line 672 "grammar.y"
                                { (yyval.i) = Q_ISIS_L2; }
#line 2563 "grammar.c"
    break;

  case 98: /* pname: IIH  */
#line 673 "grammar.y"
                                { (yyval.i) = Q_ISIS_IIH; }
#line 2569 "grammar.c"
    break;

  case 99: /* pname: LSP  */
#line 674 "grammar.y"
                                { (yyval.i) = Q_ISIS_LSP; }
#line 2575 "grammar.c"
    break;

  case 100: /* pname: SNP  */
#line 675 "grammar.y"
                                { (yyval.i) = Q_ISIS_SNP; }
#line 2581 "grammar.c"
    break;

  case 101: /* pname: PSNP  */
#line 676 "grammar.y"
                                { (yyval.i) = Q_ISIS_PSNP; }
#line 2587 "grammar.c"
    break;

  case 102: /* pname: CSNP  */
#line 677 "grammar.y"
                                { (yyval.i) = Q_ISIS_CSNP; }
#line 2593 "grammar.c"
    break;

  case 103: /* pname: CLNP  */
#line 678 "grammar.y"
                                { (yyval.i) = Q_CLNP; }
#line 2599 "grammar.c"
    break;

  case 104: /* pname: STP  */
#line 679 "grammar.y"
                                { (yyval.i) = Q_STP; }
#line 2605 "grammar.c"
    break;

  case 105: /* pname: IPX  */
#line 680 "grammar.y"
                                { (yyval.i) = Q_IPX; }
#line 2611 "grammar.c"
    break;

  case 106: /* pname: NETBEUI  */
#line 681 "grammar.y"
                                { (yyval.i) = Q_NETBEUI; }
#line 2617 "grammar.c"
    break;

  case 107: /* pname: RADIO  */
#line 682 "grammar.y"
                                { (yyval.i) = Q_RADIO; }
#line 2623 "grammar.c"
    break;

  case 108: /* other: pqual TK_BROADCAST  */
#line 684 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_broadcast(cstate, (yyvsp[-1].i)))); }
#line 2629 "grammar.c"
    break;

  case 109: /* other: pqual TK_MULTICAST  */
#line 685 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_multicast(cstate, (yyvsp[-1].i)))); }
#line 2635 "grammar.c"
    break;

  case 110: /* other: LESS NUM  */
#line 686 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_less(cstate, (yyvsp[0].h)))); }
#line 2641 "grammar.c"
    break;

  case 111: /* other: GREATER NUM  */
#line 687 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_greater(cstate, (yyvsp[0].h)))); }
#line 2647 "grammar.c"
    break;

  case 112: /* other: CBYTE NUM byteop NUM  */
#line 688 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_byteop(cstate, (yyvsp[-1].i), (yyvsp[-2].h), (yyvsp[0].h)))); }
#line 2653 "grammar.c"
    break;

  case 113: /* other: INBOUND  */
#line 689 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_inbound(cstate, 0))); }
#line 2659 "grammar.c"
    break;

  case 114: /* other: OUTBOUND  */
#line 690 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_inbound(cstate, 1))); }
#line 2665 "grammar.c"
    break;

  case 115: /* other: IFINDEX NUM  */
#line 691 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_ifindex(cstate, (yyvsp[0].h)))); }
#line 2671 "grammar.c"
    break;

  case 116: /* other: VLAN pnum  */
#line 692 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_vlan(cstate, (yyvsp[0].h), 1))); }
#line 2677 "grammar.c"
    break;

  case 117: /* other: VLAN  */
#line 693 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_vlan(cstate, 0, 0))); }
#line 2683 "grammar.c"
    break;

  case 118: /* other: MPLS pnum  */
#line 694 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_mpls(cstate, (yyvsp[0].h), 1))); }
#line 2689 "grammar.c"
    break;

  case 119: /* other: MPLS  */
#line 695 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_mpls(cstate, 0, 0))); }
#line 2695 "grammar.c"
    break;

  case 120: /* other: PPPOED  */
#line 696 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_pppoed(cstate))); }
#line 2701 "grammar.c"
    break;

  case 121: /* other: PPPOES pnum  */
#line 697 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_pppoes(cstate, (yyvsp[0].h), 1))); }
#line 2707 "grammar.c"
    break;

  case 122: /* other: PPPOES  */
#line 698 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_pppoes(cstate, 0, 0))); }
#line 2713 "grammar.c"
    break;

  case 123: /* other: GENEVE pnum  */
#line 699 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_geneve(cstate, (yyvsp[0].h), 1))); }
#line 2719 "grammar.c"
    break;

  case 124: /* other: GENEVE  */
#line 700 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_geneve(cstate, 0, 0))); }
#line 2725 "grammar.c"
    break;

  case 125: /* other: pfvar  */
#line 701 "grammar.y"
                                { (yyval.rblk) = (yyvsp[0].rblk); }
#line 2731 "grammar.c"
    break;

  case 126: /* other: pqual p80211  */
#line 702 "grammar.y"
                                { (yyval.rblk) = (yyvsp[0].rblk); }
#line 2737 "grammar.c"
    break;

  case 127: /* other: pllc  */
#line 703 "grammar.y"
                                { (yyval.rblk) = (yyvsp[0].rblk); }
#line 2743 "grammar.c"
    break;

  case 128: /* pfvar: PF_IFNAME ID  */
#line 706 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.rblk) = gen_pf_ifname(cstate, (yyvsp[0].s)))); }
#line 2749 "grammar.c"
    break;

  case 129: /* pfvar: PF_RSET ID  */
#line 707 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_PTR_VAL(((yyval.rblk) = gen_pf_ruleset(cstate, (yyvsp[0].s)))); }
#line 2755 "grammar.c"
    break;

  case 130: /* pfvar: PF_RNR NUM  */
#line 708 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_pf_rnr(cstate, (yyvsp[0].h)))); }
#line 2761 "grammar.c"
    break;

  case 131: /* pfvar: PF_SRNR NUM  */
#line 709 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_pf_srnr(cstate, (yyvsp[0].h)))); }
#line 2767 "grammar.c"
    break;

  case 132: /* pfvar: PF_REASON reason  */
#line 710 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_pf_reason(cstate, (yyvsp[0].i)))); }
#line 2773 "grammar.c"
    break;

  case 133: /* pfvar: PF_ACTION action  */
#line 711 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_pf_action(cstate, (yyvsp[0].i)))); }
#line 2779 "grammar.c"
    break;

  case 134: /* p80211: TYPE type SUBTYPE subtype  */
#line 715 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_p80211_type(cstate, (yyvsp[-2].i) | (yyvsp[0].i),
					IEEE80211_FC0_TYPE_MASK |
					IEEE80211_FC0_SUBTYPE_MASK)));
				}
#line 2788 "grammar.c"
    break;

  case 135: /* p80211: TYPE type  */
#line 719 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_p80211_type(cstate, (yyvsp[0].i),
					IEEE80211_FC0_TYPE_MASK)));
				}
#line 2796 "grammar.c"
    break;

  case 136: /* p80211: SUBTYPE type_subtype  */
#line 722 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_p80211_type(cstate, (yyvsp[0].i),
					IEEE80211_FC0_TYPE_MASK |
					IEEE80211_FC0_SUBTYPE_MASK)));
				}
#line 2805 "grammar.c"
    break;

  case 137: /* p80211: DIR dir  */
#line 726 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_p80211_fcdir(cstate, (yyvsp[0].i)))); }
#line 2811 "grammar.c"
    break;

  case 138: /* type: NUM  */
#line 729 "grammar.y"
                                { if (((yyvsp[0].h) & (~IEEE80211_FC0_TYPE_MASK)) != 0) {
					bpf_set_error(cstate, "invalid 802.11 type value 0x%02x", (yyvsp[0].h));
					YYABORT;
				  }
				  (yyval.i) = (int)(yyvsp[0].h);
				}
#line 2822 "grammar.c"
    break;

  case 139: /* type: ID  */
#line 735 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s));
				  (yyval.i) = str2tok((yyvsp[0].s), ieee80211_types);
				  if ((yyval.i) == -1) {
					bpf_set_error(cstate, "unknown 802.11 type name \"%s\"", (yyvsp[0].s));
					YYABORT;
				  }
				}
#line 2834 "grammar.c"
    break;

  case 140: /* subtype: NUM  */
#line 744 "grammar.y"
                                { if (((yyvsp[0].h) & (~IEEE80211_FC0_SUBTYPE_MASK)) != 0) {
					bpf_set_error(cstate, "invalid 802.11 subtype value 0x%02x", (yyvsp[0].h));
					YYABORT;
				  }
				  (yyval.i) = (int)(yyvsp[0].h);
				}
#line 2845 "grammar.c"
    break;

  case 141: /* subtype: ID  */
#line 750 "grammar.y"
                                { const struct tok *types = NULL;
				  int i;
				  CHECK_PTR_VAL((yyvsp[0].s));
				  for (i = 0;; i++) {
					if (ieee80211_type_subtypes[i].tok == NULL) {
						/* Ran out of types */
						bpf_set_error(cstate, "unknown 802.11 type");
						YYABORT;
					}
					if ((yyvsp[(-1) - (1)].i) == ieee80211_type_subtypes[i].type) {
						types = ieee80211_type_subtypes[i].tok;
						break;
					}
				  }

				  (yyval.i) = str2tok((yyvsp[0].s), types);
				  if ((yyval.i) == -1) {
					bpf_set_error(cstate, "unknown 802.11 subtype name \"%s\"", (yyvsp[0].s));
					YYABORT;
				  }
				}
#line 2871 "grammar.c"
    break;

  case 142: /* type_subtype: ID  */
#line 773 "grammar.y"
                                { int i;
				  CHECK_PTR_VAL((yyvsp[0].s));
				  for (i = 0;; i++) {
					if (ieee80211_type_subtypes[i].tok == NULL) {
						/* Ran out of types */
						bpf_set_error(cstate, "unknown 802.11 type name");
						YYABORT;
					}
					(yyval.i) = str2tok((yyvsp[0].s), ieee80211_type_subtypes[i].tok);
					if ((yyval.i) != -1) {
						(yyval.i) |= ieee80211_type_subtypes[i].type;
						break;
					}
				  }
				}
#line 2891 "grammar.c"
    break;

  case 143: /* pllc: LLC  */
#line 790 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_llc(cstate))); }
#line 2897 "grammar.c"
    break;

  case 144: /* pllc: LLC ID  */
#line 791 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s));
				  if (pcapint_strcasecmp((yyvsp[0].s), "i") == 0) {
					CHECK_PTR_VAL(((yyval.rblk) = gen_llc_i(cstate)));
				  } else if (pcapint_strcasecmp((yyvsp[0].s), "s") == 0) {
					CHECK_PTR_VAL(((yyval.rblk) = gen_llc_s(cstate)));
				  } else if (pcapint_strcasecmp((yyvsp[0].s), "u") == 0) {
					CHECK_PTR_VAL(((yyval.rblk) = gen_llc_u(cstate)));
				  } else {
					int subtype;

					subtype = str2tok((yyvsp[0].s), llc_s_subtypes);
					if (subtype != -1) {
						CHECK_PTR_VAL(((yyval.rblk) = gen_llc_s_subtype(cstate, subtype)));
					} else {
						subtype = str2tok((yyvsp[0].s), llc_u_subtypes);
						if (subtype == -1) {
							bpf_set_error(cstate, "unknown LLC type name \"%s\"", (yyvsp[0].s));
							YYABORT;
						}
						CHECK_PTR_VAL(((yyval.rblk) = gen_llc_u_subtype(cstate, subtype)));
					}
				  }
				}
#line 2925 "grammar.c"
    break;

  case 145: /* pllc: LLC PF_RNR  */
#line 815 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.rblk) = gen_llc_s_subtype(cstate, LLC_RNR))); }
#line 2931 "grammar.c"
    break;

  case 146: /* dir: NUM  */
#line 818 "grammar.y"
                                { (yyval.i) = (int)(yyvsp[0].h); }
#line 2937 "grammar.c"
    break;

  case 147: /* dir: ID  */
#line 819 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s));
				  if (pcapint_strcasecmp((yyvsp[0].s), "nods") == 0)
					(yyval.i) = IEEE80211_FC1_DIR_NODS;
				  else if (pcapint_strcasecmp((yyvsp[0].s), "tods") == 0)
					(yyval.i) = IEEE80211_FC1_DIR_TODS;
				  else if (pcapint_strcasecmp((yyvsp[0].s), "fromds") == 0)
					(yyval.i) = IEEE80211_FC1_DIR_FROMDS;
				  else if (pcapint_strcasecmp((yyvsp[0].s), "dstods") == 0)
					(yyval.i) = IEEE80211_FC1_DIR_DSTODS;
				  else {
					bpf_set_error(cstate, "unknown 802.11 direction");
					YYABORT;
				  }
				}
#line 2956 "grammar.c"
    break;

  case 148: /* reason: NUM  */
#line 835 "grammar.y"
                                { (yyval.i) = (yyvsp[0].h); }
#line 2962 "grammar.c"
    break;

  case 149: /* reason: ID  */
#line 836 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_INT_VAL(((yyval.i) = pfreason_to_num(cstate, (yyvsp[0].s)))); }
#line 2968 "grammar.c"
    break;

  case 150: /* action: ID  */
#line 839 "grammar.y"
                                { CHECK_PTR_VAL((yyvsp[0].s)); CHECK_INT_VAL(((yyval.i) = pfaction_to_num(cstate, (yyvsp[0].s)))); }
#line 2974 "grammar.c"
    break;

  case 151: /* relop: '>'  */
#line 842 "grammar.y"
                                { (yyval.i) = BPF_JGT; }
#line 2980 "grammar.c"
    break;

  case 152: /* relop: GEQ  */
#line 843 "grammar.y"
                                { (yyval.i) = BPF_JGE; }
#line 2986 "grammar.c"
    break;

  case 153: /* relop: '='  */
#line 844 "grammar.y"
                                { (yyval.i) = BPF_JEQ; }
#line 2992 "grammar.c"
    break;

  case 154: /* irelop: LEQ  */
#line 846 "grammar.y"
                                { (yyval.i) = BPF_JGT; }
#line 2998 "grammar.c"
    break;

  case 155: /* irelop: '<'  */
#line 847 "grammar.y"
                                { (yyval.i) = BPF_JGE; }
#line 3004 "grammar.c"
    break;

  case 156: /* irelop: NEQ  */
#line 848 "grammar.y"
                                { (yyval.i) = BPF_JEQ; }
#line 3010 "grammar.c"
    break;

  case 157: /* arth: pnum  */
#line 850 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.a) = gen_loadi(cstate, (yyvsp[0].h)))); }
#line 3016 "grammar.c"
    break;

  case 159: /* narth: pname '[' arth ']'  */
#line 853 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_load(cstate, (yyvsp[-3].i), (yyvsp[-1].a), 1))); }
#line 3022 "grammar.c"
    break;

  case 160: /* narth: pname '[' arth ':' NUM ']'  */
#line 854 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_load(cstate, (yyvsp[-5].i), (yyvsp[-3].a), (yyvsp[-1].h)))); }
#line 3028 "grammar.c"
    break;

  case 161: /* narth: arth '+' arth  */
#line 855 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_ADD, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3034 "grammar.c"
    break;

  case 162: /* narth: arth '-' arth  */
#line 856 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_SUB, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3040 "grammar.c"
    break;

  case 163: /* narth: arth '*' arth  */
#line 857 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_MUL, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3046 "grammar.c"
    break;

  case 164: /* narth: arth '/' arth  */
#line 858 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_DIV, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3052 "grammar.c"
    break;

  case 165: /* narth: arth '%' arth  */
#line 859 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_MOD, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3058 "grammar.c"
    break;

  case 166: /* narth: arth '&' arth  */
#line 860 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_AND, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3064 "grammar.c"
    break;

  case 167: /* narth: arth '|' arth  */
#line 861 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_OR, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3070 "grammar.c"
    break;

  case 168: /* narth: arth '^' arth  */
#line 862 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_XOR, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3076 "grammar.c"
    break;

  case 169: /* narth: arth LSH arth  */
#line 863 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_LSH, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3082 "grammar.c"
    break;

  case 170: /* narth: arth RSH arth  */
#line 864 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_arth(cstate, BPF_RSH, (yyvsp[-2].a), (yyvsp[0].a)))); }
#line 3088 "grammar.c"
    break;

  case 171: /* narth: '-' arth  */
#line 865 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_neg(cstate, (yyvsp[0].a)))); }
#line 3094 "grammar.c"
    break;

  case 172: /* narth: paren narth ')'  */
#line 866 "grammar.y"
                                        { (yyval.a) = (yyvsp[-1].a); }
#line 3100 "grammar.c"
    break;

  case 173: /* narth: LEN  */
#line 867 "grammar.y"
                                        { CHECK_PTR_VAL(((yyval.a) = gen_loadlen(cstate))); }
#line 3106 "grammar.c"
    break;

  case 174: /* byteop: '&'  */
#line 869 "grammar.y"
                                { (yyval.i) = '&'; }
#line 3112 "grammar.c"
    break;

  case 175: /* byteop: '|'  */
#line 870 "grammar.y"
                                { (yyval.i) = '|'; }
#line 3118 "grammar.c"
    break;

  case 176: /* byteop: '<'  */
#line 871 "grammar.y"
                                { (yyval.i) = '<'; }
#line 3124 "grammar.c"
    break;

  case 177: /* byteop: '>'  */
#line 872 "grammar.y"
                                { (yyval.i) = '>'; }
#line 3130 "grammar.c"
    break;

  case 178: /* byteop: '='  */
#line 873 "grammar.y"
                                { (yyval.i) = '='; }
#line 3136 "grammar.c"
    break;

  case 180: /* pnum: paren pnum ')'  */
#line 876 "grammar.y"
                                { (yyval.h) = (yyvsp[-1].h); }
#line 3142 "grammar.c"
    break;

  case 181: /* atmtype: LANE  */
#line 878 "grammar.y"
                                { (yyval.i) = A_LANE; }
#line 3148 "grammar.c"
    break;

  case 182: /* atmtype: METAC  */
#line 879 "grammar.y"
                                { (yyval.i) = A_METAC;	}
#line 3154 "grammar.c"
    break;

  case 183: /* atmtype: BCC  */
#line 880 "grammar.y"
                                { (yyval.i) = A_BCC; }
#line 3160 "grammar.c"
    break;

  case 184: /* atmtype: OAMF4EC  */
#line 881 "grammar.y"
                                { (yyval.i) = A_OAMF4EC; }
#line 3166 "grammar.c"
    break;

  case 185: /* atmtype: OAMF4SC  */
#line 882 "grammar.y"
                                { (yyval.i) = A_OAMF4SC; }
#line 3172 "grammar.c"
    break;

  case 186: /* atmtype: SC  */
#line 883 "grammar.y"
                                { (yyval.i) = A_SC; }
#line 3178 "grammar.c"
    break;

  case 187: /* atmtype: ILMIC  */
#line 884 "grammar.y"
                                { (yyval.i) = A_ILMIC; }
#line 3184 "grammar.c"
    break;

  case 188: /* atmmultitype: OAM  */
#line 886 "grammar.y"
                                { (yyval.i) = A_OAM; }
#line 3190 "grammar.c"
    break;

  case 189: /* atmmultitype: OAMF4  */
#line 887 "grammar.y"
                                { (yyval.i) = A_OAMF4; }
#line 3196 "grammar.c"
    break;

  case 190: /* atmmultitype: CONNECTMSG  */
#line 888 "grammar.y"
                                { (yyval.i) = A_CONNECTMSG; }
#line 3202 "grammar.c"
    break;

  case 191: /* atmmultitype: METACONNECT  */
#line 889 "grammar.y"
                                { (yyval.i) = A_METACONNECT; }
#line 3208 "grammar.c"
    break;

  case 192: /* atmfield: VPI  */
#line 892 "grammar.y"
                                { (yyval.blk).atmfieldtype = A_VPI; }
#line 3214 "grammar.c"
    break;

  case 193: /* atmfield: VCI  */
#line 893 "grammar.y"
                                { (yyval.blk).atmfieldtype = A_VCI; }
#line 3220 "grammar.c"
    break;

  case 195: /* atmvalue: relop NUM  */
#line 896 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_atmfield_code(cstate, (yyvsp[-2].blk).atmfieldtype, (yyvsp[0].h), (yyvsp[-1].i), 0))); }
#line 3226 "grammar.c"
    break;

  case 196: /* atmvalue: irelop NUM  */
#line 897 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_atmfield_code(cstate, (yyvsp[-2].blk).atmfieldtype, (yyvsp[0].h), (yyvsp[-1].i), 1))); }
#line 3232 "grammar.c"
    break;

  case 197: /* atmvalue: paren atmlistvalue ')'  */
#line 898 "grammar.y"
                                 { (yyval.blk).b = (yyvsp[-1].blk).b; (yyval.blk).q = qerr; }
#line 3238 "grammar.c"
    break;

  case 198: /* atmfieldvalue: NUM  */
#line 900 "grammar.y"
                   {
	(yyval.blk).atmfieldtype = (yyvsp[-1].blk).atmfieldtype;
	if ((yyval.blk).atmfieldtype == A_VPI ||
	    (yyval.blk).atmfieldtype == A_VCI)
		CHECK_PTR_VAL(((yyval.blk).b = gen_atmfield_code(cstate, (yyval.blk).atmfieldtype, (yyvsp[0].h), BPF_JEQ, 0)));
	}
#line 3249 "grammar.c"
    break;

  case 200: /* atmlistvalue: atmlistvalue or atmfieldvalue  */
#line 908 "grammar.y"
                                        { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 3255 "grammar.c"
    break;

  case 201: /* mtp2type: FISU  */
#line 911 "grammar.y"
                                { (yyval.i) = M_FISU; }
#line 3261 "grammar.c"
    break;

  case 202: /* mtp2type: LSSU  */
#line 912 "grammar.y"
                                { (yyval.i) = M_LSSU; }
#line 3267 "grammar.c"
    break;

  case 203: /* mtp2type: MSU  */
#line 913 "grammar.y"
                                { (yyval.i) = M_MSU; }
#line 3273 "grammar.c"
    break;

  case 204: /* mtp2type: HFISU  */
#line 914 "grammar.y"
                                { (yyval.i) = MH_FISU; }
#line 3279 "grammar.c"
    break;

  case 205: /* mtp2type: HLSSU  */
#line 915 "grammar.y"
                                { (yyval.i) = MH_LSSU; }
#line 3285 "grammar.c"
    break;

  case 206: /* mtp2type: HMSU  */
#line 916 "grammar.y"
                                { (yyval.i) = MH_MSU; }
#line 3291 "grammar.c"
    break;

  case 207: /* mtp3field: SIO  */
#line 919 "grammar.y"
                                { (yyval.blk).mtp3fieldtype = M_SIO; }
#line 3297 "grammar.c"
    break;

  case 208: /* mtp3field: OPC  */
#line 920 "grammar.y"
                                { (yyval.blk).mtp3fieldtype = M_OPC; }
#line 3303 "grammar.c"
    break;

  case 209: /* mtp3field: DPC  */
#line 921 "grammar.y"
                                { (yyval.blk).mtp3fieldtype = M_DPC; }
#line 3309 "grammar.c"
    break;

  case 210: /* mtp3field: SLS  */
#line 922 "grammar.y"
                                { (yyval.blk).mtp3fieldtype = M_SLS; }
#line 3315 "grammar.c"
    break;

  case 211: /* mtp3field: HSIO  */
#line 923 "grammar.y"
                                { (yyval.blk).mtp3fieldtype = MH_SIO; }
#line 3321 "grammar.c"
    break;

  case 212: /* mtp3field: HOPC  */
#line 924 "grammar.y"
                                { (yyval.blk).mtp3fieldtype = MH_OPC; }
#line 3327 "grammar.c"
    break;

  case 213: /* mtp3field: HDPC  */
#line 925 "grammar.y"
                                { (yyval.blk).mtp3fieldtype = MH_DPC; }
#line 3333 "grammar.c"
    break;

  case 214: /* mtp3field: HSLS  */
#line 926 "grammar.y"
                                { (yyval.blk).mtp3fieldtype = MH_SLS; }
#line 3339 "grammar.c"
    break;

  case 216: /* mtp3value: relop NUM  */
#line 929 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_mtp3field_code(cstate, (yyvsp[-2].blk).mtp3fieldtype, (yyvsp[0].h), (yyvsp[-1].i), 0))); }
#line 3345 "grammar.c"
    break;

  case 217: /* mtp3value: irelop NUM  */
#line 930 "grammar.y"
                                { CHECK_PTR_VAL(((yyval.blk).b = gen_mtp3field_code(cstate, (yyvsp[-2].blk).mtp3fieldtype, (yyvsp[0].h), (yyvsp[-1].i), 1))); }
#line 3351 "grammar.c"
    break;

  case 218: /* mtp3value: paren mtp3listvalue ')'  */
#line 931 "grammar.y"
                                  { (yyval.blk).b = (yyvsp[-1].blk).b; (yyval.blk).q = qerr; }
#line 3357 "grammar.c"
    break;

  case 219: /* mtp3fieldvalue: NUM  */
#line 933 "grammar.y"
                    {
	(yyval.blk).mtp3fieldtype = (yyvsp[-1].blk).mtp3fieldtype;
	if ((yyval.blk).mtp3fieldtype == M_SIO ||
	    (yyval.blk).mtp3fieldtype == M_OPC ||
	    (yyval.blk).mtp3fieldtype == M_DPC ||
	    (yyval.blk).mtp3fieldtype == M_SLS ||
	    (yyval.blk).mtp3fieldtype == MH_SIO ||
	    (yyval.blk).mtp3fieldtype == MH_OPC ||
	    (yyval.blk).mtp3fieldtype == MH_DPC ||
	    (yyval.blk).mtp3fieldtype == MH_SLS)
		CHECK_PTR_VAL(((yyval.blk).b = gen_mtp3field_code(cstate, (yyval.blk).mtp3fieldtype, (yyvsp[0].h), BPF_JEQ, 0)));
	}
#line 3374 "grammar.c"
    break;

  case 221: /* mtp3listvalue: mtp3listvalue or mtp3fieldvalue  */
#line 947 "grammar.y"
                                          { gen_or((yyvsp[-2].blk).b, (yyvsp[0].blk).b); (yyval.blk) = (yyvsp[0].blk); }
#line 3380 "grammar.c"
    break;


#line 3384 "grammar.c"

      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */
  {
    const int yylhs = yyr1[yyn] - YYNTOKENS;
    const int yyi = yypgoto[yylhs] + *yyssp;
    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
               ? yytable[yyi]
               : yydefgoto[yylhs]);
  }

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
      yyerror (yyscanner, cstate, YY_("syntax error"));
    }

  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct ("Error: discarding",
                      yytoken, &yylval, yyscanner, cstate);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:
  /* Pacify compilers when the user code never invokes YYERROR and the
     label yyerrorlab therefore never appears in user code.  */
  if (0)
    YYERROR;
  ++yynerrs;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  /* Pop stack until we find a state that shifts the error token.  */
  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYSYMBOL_YYerror;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct ("Error: popping",
                  YY_ACCESSING_SYMBOL (yystate), yyvsp, yyscanner, cstate);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturnlab;


/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturnlab;


/*-----------------------------------------------------------.
| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
`-----------------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, cstate, YY_("memory exhausted"));
  yyresult = 2;
  goto yyreturnlab;


/*----------------------------------------------------------.
| yyreturnlab -- parsing is finished, clean up and return.  |
`----------------------------------------------------------*/
yyreturnlab:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval, yyscanner, cstate);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp, yyscanner, cstate);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif

  return yyresult;
}

#line 949 "grammar.y"


```

`generated/libpcap/grammar.h`:

```h
/* A Bison parser, made by GNU Bison 3.8.2.  */

/* Bison interface for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
   especially those whose name start with YY_ or yy_.  They are
   private implementation details that can be changed or removed.  */

#ifndef YY_PCAP_GRAMMAR_H_INCLUDED
# define YY_PCAP_GRAMMAR_H_INCLUDED
/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif
#if YYDEBUG
extern int pcap_debug;
#endif

/* Token kinds.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
  enum yytokentype
  {
    YYEMPTY = -2,
    YYEOF = 0,                     /* "end of file"  */
    YYerror = 256,                 /* error  */
    YYUNDEF = 257,                 /* "invalid token"  */
    DST = 258,                     /* DST  */
    SRC = 259,                     /* SRC  */
    HOST = 260,                    /* HOST  */
    GATEWAY = 261,                 /* GATEWAY  */
    NET = 262,                     /* NET  */
    NETMASK = 263,                 /* NETMASK  */
    PORT = 264,                    /* PORT  */
    PORTRANGE = 265,               /* PORTRANGE  */
    LESS = 266,                    /* LESS  */
    GREATER = 267,                 /* GREATER  */
    PROTO = 268,                   /* PROTO  */
    PROTOCHAIN = 269,              /* PROTOCHAIN  */
    CBYTE = 270,                   /* CBYTE  */
    ARP = 271,                     /* ARP  */
    RARP = 272,                    /* RARP  */
    IP = 273,                      /* IP  */
    SCTP = 274,                    /* SCTP  */
    TCP = 275,                     /* TCP  */
    UDP = 276,                     /* UDP  */
    ICMP = 277,                    /* ICMP  */
    IGMP = 278,                    /* IGMP  */
    IGRP = 279,                    /* IGRP  */
    PIM = 280,                     /* PIM  */
    VRRP = 281,                    /* VRRP  */
    CARP = 282,                    /* CARP  */
    ATALK = 283,                   /* ATALK  */
    AARP = 284,                    /* AARP  */
    DECNET = 285,                  /* DECNET  */
    LAT = 286,                     /* LAT  */
    SCA = 287,                     /* SCA  */
    MOPRC = 288,                   /* MOPRC  */
    MOPDL = 289,                   /* MOPDL  */
    TK_BROADCAST = 290,            /* TK_BROADCAST  */
    TK_MULTICAST = 291,            /* TK_MULTICAST  */
    NUM = 292,                     /* NUM  */
    INBOUND = 293,                 /* INBOUND  */
    OUTBOUND = 294,                /* OUTBOUND  */
    IFINDEX = 295,                 /* IFINDEX  */
    PF_IFNAME = 296,               /* PF_IFNAME  */
    PF_RSET = 297,                 /* PF_RSET  */
    PF_RNR = 298,                  /* PF_RNR  */
    PF_SRNR = 299,                 /* PF_SRNR  */
    PF_REASON = 300,               /* PF_REASON  */
    PF_ACTION = 301,               /* PF_ACTION  */
    TYPE = 302,                    /* TYPE  */
    SUBTYPE = 303,                 /* SUBTYPE  */
    DIR = 304,                     /* DIR  */
    ADDR1 = 305,                   /* ADDR1  */
    ADDR2 = 306,                   /* ADDR2  */
    ADDR3 = 307,                   /* ADDR3  */
    ADDR4 = 308,                   /* ADDR4  */
    RA = 309,                      /* RA  */
    TA = 310,                      /* TA  */
    LINK = 311,                    /* LINK  */
    GEQ = 312,                     /* GEQ  */
    LEQ = 313,                     /* LEQ  */
    NEQ = 314,                     /* NEQ  */
    ID = 315,                      /* ID  */
    EID = 316,                     /* EID  */
    HID = 317,                     /* HID  */
    HID6 = 318,                    /* HID6  */
    AID = 319,                     /* AID  */
    LSH = 320,                     /* LSH  */
    RSH = 321,                     /* RSH  */
    LEN = 322,                     /* LEN  */
    IPV6 = 323,                    /* IPV6  */
    ICMPV6 = 324,                  /* ICMPV6  */
    AH = 325,                      /* AH  */
    ESP = 326,                     /* ESP  */
    VLAN = 327,                    /* VLAN  */
    MPLS = 328,                    /* MPLS  */
    PPPOED = 329,                  /* PPPOED  */
    PPPOES = 330,                  /* PPPOES  */
    GENEVE = 331,                  /* GENEVE  */
    ISO = 332,                     /* ISO  */
    ESIS = 333,                    /* ESIS  */
    CLNP = 334,                    /* CLNP  */
    ISIS = 335,                    /* ISIS  */
    L1 = 336,                      /* L1  */
    L2 = 337,                      /* L2  */
    IIH = 338,                     /* IIH  */
    LSP = 339,                     /* LSP  */
    SNP = 340,                     /* SNP  */
    CSNP = 341,                    /* CSNP  */
    PSNP = 342,                    /* PSNP  */
    STP = 343,                     /* STP  */
    IPX = 344,                     /* IPX  */
    NETBEUI = 345,                 /* NETBEUI  */
    LANE = 346,                    /* LANE  */
    LLC = 347,                     /* LLC  */
    METAC = 348,                   /* METAC  */
    BCC = 349,                     /* BCC  */
    SC = 350,                      /* SC  */
    ILMIC = 351,                   /* ILMIC  */
    OAMF4EC = 352,                 /* OAMF4EC  */
    OAMF4SC = 353,                 /* OAMF4SC  */
    OAM = 354,                     /* OAM  */
    OAMF4 = 355,                   /* OAMF4  */
    CONNECTMSG = 356,              /* CONNECTMSG  */
    METACONNECT = 357,             /* METACONNECT  */
    VPI = 358,                     /* VPI  */
    VCI = 359,                     /* VCI  */
    RADIO = 360,                   /* RADIO  */
    FISU = 361,                    /* FISU  */
    LSSU = 362,                    /* LSSU  */
    MSU = 363,                     /* MSU  */
    HFISU = 364,                   /* HFISU  */
    HLSSU = 365,                   /* HLSSU  */
    HMSU = 366,                    /* HMSU  */
    SIO = 367,                     /* SIO  */
    OPC = 368,                     /* OPC  */
    DPC = 369,                     /* DPC  */
    SLS = 370,                     /* SLS  */
    HSIO = 371,                    /* HSIO  */
    HOPC = 372,                    /* HOPC  */
    HDPC = 373,                    /* HDPC  */
    HSLS = 374,                    /* HSLS  */
    LEX_ERROR = 375,               /* LEX_ERROR  */
    OR = 376,                      /* OR  */
    AND = 377,                     /* AND  */
    UMINUS = 378                   /* UMINUS  */
  };
  typedef enum yytokentype yytoken_kind_t;
#endif

/* Value type.  */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
union YYSTYPE
{
#line 357 "grammar.y"

	int i;
	bpf_u_int32 h;
	char *s;
	struct stmt *stmt;
	struct arth *a;
	struct {
		struct qual q;
		int atmfieldtype;
		int mtp3fieldtype;
		struct block *b;
	} blk;
	struct block *rblk;

#line 202 "grammar.h"

};
typedef union YYSTYPE YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define YYSTYPE_IS_DECLARED 1
#endif




int pcap_parse (void *yyscanner, compiler_state_t *cstate);


#endif /* !YY_PCAP_GRAMMAR_H_INCLUDED  */

```

`generated/libpcap/scanner.c`:

```c
#line 1 "scanner.c"
/* Must come first for _LARGE_FILE_API on AIX. */
#include <config.h>

/*
 * Must come first to avoid warnings on Windows.
 *
 * Flex-generated scanners may only include <inttypes.h> if __STDC_VERSION__
 * is defined with a value >= 199901, meaning "full C99", and MSVC may not
 * define it with that value, because it isn't 100% C99-compliant, even
 * though it has an <inttypes.h> capable of defining everything the Flex
 * scanner needs.
 *
 * We, however, will include it if we know we have an MSVC version that has
 * it; this means that we may define the INTn_MAX and UINTn_MAX values in
 * scanner.c, and then include <stdint.h>, which may define them differently
 * (same value, but different string of characters), causing compiler warnings.
 *
 * If we include it here, and they're defined, that'll prevent scanner.c
 * from defining them.  So we include <pcap/pcap-inttypes.h>, to get
 * <inttypes.h> if we have it.
 */
#include <pcap/pcap-inttypes.h>

/*
 * grammar.h requires gencode.h and sometimes breaks in a polluted namespace
 * (see ftmacros.h), so include it early.
 */
#include "gencode.h"
#include "grammar.h"

#include "diag-control.h"

/*
 * Convert string to 32-bit unsigned integer; the string starts at
 * string and is string_len bytes long.
 *
 * On success, sets *val to the value and returns 1.
 * On failure, sets the BPF error string and returns 0.
 *
 * Also used in gencode.c
 */
typedef enum {
	STOULEN_OK,
	STOULEN_NOT_HEX_NUMBER,
	STOULEN_NOT_OCTAL_NUMBER,
	STOULEN_NOT_DECIMAL_NUMBER,
	STOULEN_ERROR
} stoulen_ret;

stoulen_ret stoulen(const char *string, size_t stringlen, bpf_u_int32 *val,
    compiler_state_t *cstate);

#line 54 "scanner.c"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef yy_create_buffer
#define pcap__create_buffer_ALREADY_DEFINED
#else
#define yy_create_buffer pcap__create_buffer
#endif

#ifdef yy_delete_buffer
#define pcap__delete_buffer_ALREADY_DEFINED
#else
#define yy_delete_buffer pcap__delete_buffer
#endif

#ifdef yy_scan_buffer
#define pcap__scan_buffer_ALREADY_DEFINED
#else
#define yy_scan_buffer pcap__scan_buffer
#endif

#ifdef yy_scan_string
#define pcap__scan_string_ALREADY_DEFINED
#else
#define yy_scan_string pcap__scan_string
#endif

#ifdef yy_scan_bytes
#define pcap__scan_bytes_ALREADY_DEFINED
#else
#define yy_scan_bytes pcap__scan_bytes
#endif

#ifdef yy_init_buffer
#define pcap__init_buffer_ALREADY_DEFINED
#else
#define yy_init_buffer pcap__init_buffer
#endif

#ifdef yy_flush_buffer
#define pcap__flush_buffer_ALREADY_DEFINED
#else
#define yy_flush_buffer pcap__flush_buffer
#endif

#ifdef yy_load_buffer_state
#define pcap__load_buffer_state_ALREADY_DEFINED
#else
#define yy_load_buffer_state pcap__load_buffer_state
#endif

#ifdef yy_switch_to_buffer
#define pcap__switch_to_buffer_ALREADY_DEFINED
#else
#define yy_switch_to_buffer pcap__switch_to_buffer
#endif

#ifdef yypush_buffer_state
#define pcap_push_buffer_state_ALREADY_DEFINED
#else
#define yypush_buffer_state pcap_push_buffer_state
#endif

#ifdef yypop_buffer_state
#define pcap_pop_buffer_state_ALREADY_DEFINED
#else
#define yypop_buffer_state pcap_pop_buffer_state
#endif

#ifdef yyensure_buffer_stack
#define pcap_ensure_buffer_stack_ALREADY_DEFINED
#else
#define yyensure_buffer_stack pcap_ensure_buffer_stack
#endif

#ifdef yylex
#define pcap_lex_ALREADY_DEFINED
#else
#define yylex pcap_lex
#endif

#ifdef yyrestart
#define pcap_restart_ALREADY_DEFINED
#else
#define yyrestart pcap_restart
#endif

#ifdef yylex_init
#define pcap_lex_init_ALREADY_DEFINED
#else
#define yylex_init pcap_lex_init
#endif

#ifdef yylex_init_extra
#define pcap_lex_init_extra_ALREADY_DEFINED
#else
#define yylex_init_extra pcap_lex_init_extra
#endif

#ifdef yylex_destroy
#define pcap_lex_destroy_ALREADY_DEFINED
#else
#define yylex_destroy pcap_lex_destroy
#endif

#ifdef yyget_debug
#define pcap_get_debug_ALREADY_DEFINED
#else
#define yyget_debug pcap_get_debug
#endif

#ifdef yyset_debug
#define pcap_set_debug_ALREADY_DEFINED
#else
#define yyset_debug pcap_set_debug
#endif

#ifdef yyget_extra
#define pcap_get_extra_ALREADY_DEFINED
#else
#define yyget_extra pcap_get_extra
#endif

#ifdef yyset_extra
#define pcap_set_extra_ALREADY_DEFINED
#else
#define yyset_extra pcap_set_extra
#endif

#ifdef yyget_in
#define pcap_get_in_ALREADY_DEFINED
#else
#define yyget_in pcap_get_in
#endif

#ifdef yyset_in
#define pcap_set_in_ALREADY_DEFINED
#else
#define yyset_in pcap_set_in
#endif

#ifdef yyget_out
#define pcap_get_out_ALREADY_DEFINED
#else
#define yyget_out pcap_get_out
#endif

#ifdef yyset_out
#define pcap_set_out_ALREADY_DEFINED
#else
#define yyset_out pcap_set_out
#endif

#ifdef yyget_leng
#define pcap_get_leng_ALREADY_DEFINED
#else
#define yyget_leng pcap_get_leng
#endif

#ifdef yyget_text
#define pcap_get_text_ALREADY_DEFINED
#else
#define yyget_text pcap_get_text
#endif

#ifdef yyget_lineno
#define pcap_get_lineno_ALREADY_DEFINED
#else
#define yyget_lineno pcap_get_lineno
#endif

#ifdef yyset_lineno
#define pcap_set_lineno_ALREADY_DEFINED
#else
#define yyset_lineno pcap_set_lineno
#endif

#ifdef yyget_column
#define pcap_get_column_ALREADY_DEFINED
#else
#define yyget_column pcap_get_column
#endif

#ifdef yyset_column
#define pcap_set_column_ALREADY_DEFINED
#else
#define yyset_column pcap_set_column
#endif

#ifdef yywrap
#define pcap_wrap_ALREADY_DEFINED
#else
#define yywrap pcap_wrap
#endif

#ifdef yyget_lval
#define pcap_get_lval_ALREADY_DEFINED
#else
#define yyget_lval pcap_get_lval
#endif

#ifdef yyset_lval
#define pcap_set_lval_ALREADY_DEFINED
#else
#define yyset_lval pcap_set_lval
#endif

#ifdef yyalloc
#define pcap_alloc_ALREADY_DEFINED
#else
#define yyalloc pcap_alloc
#endif

#ifdef yyrealloc
#define pcap_realloc_ALREADY_DEFINED
#else
#define yyrealloc pcap_realloc
#endif

#ifdef yyfree
#define pcap_free_ALREADY_DEFINED
#else
#define yyfree pcap_free
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yyg->yy_start = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yyg->yy_start - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin , yyscanner )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    
    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = yyg->yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]

void yyrestart ( FILE *input_file , yyscan_t yyscanner );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
void yypop_buffer_state ( yyscan_t yyscanner );

static void yyensure_buffer_stack ( yyscan_t yyscanner );
static void yy_load_buffer_state ( yyscan_t yyscanner );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );

void *yyalloc ( yy_size_t , yyscan_t yyscanner );
void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
void yyfree ( void * , yyscan_t yyscanner );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define pcap_wrap(yyscanner) (/*CONSTCOND*/1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

typedef int yy_state_type;

#define yytext_ptr yytext_r

static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);
static int yy_get_next_buffer ( yyscan_t yyscanner );
static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yyg->yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yyg->yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yyg->yy_c_buf_p = yy_cp;
#define YY_NUM_RULES 188
#define YY_END_OF_BUFFER 189
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static const flex_int16_t yy_accept[1785] =
    {   0,
        0,    0,  189,  187,  114,  114,  115,  187,  115,  115,
      124,  124,  115,  115,  115,  115,  185,  185,  187,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  115,
      118,  122,   67,    0,  185,  124,    0,  185,  185,  185,
        0,  126,  120,  117,  119,  116,  121,  185,  186,  185,
      185,  185,   20,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,    7,  185,   34,   35,

      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,   93,  185,   68,  185,  185,  185,
      185,  185,  185,   60,  185,  185,  185,  185,   87,  185,
      185,  185,  185,  185,  185,   61,  185,    4,  185,  185,
      185,  185,  185,  185,  185,   68,  122,  185,  125,  125,
      185,  124,  185,    0,  126,  124,  126,  126,  126,  185,
      185,  185,   67,    5,  185,   82,  185,  185,  185,  185,
      185,  185,  185,   55,  108,    1,    0,  185,   21,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,   36,  185,

      185,   18,   43,    0,  185,   29,  185,   25,   70,  185,
      185,   80,   37,  185,  101,  185,  185,  185,  185,  102,
      185,   46,   69,   83,  107,  185,   14,  185,    3,  185,
      185,  185,  185,  185,   95,  185,  185,   26,  185,  106,
      185,  109,   38,    2,  185,   42,  185,    9,  185,   10,
       90,  185,   89,  185,  185,    0,  185,  185,  125,  185,
      185,  185,  185,  124,    0,  185,    0,  127,  126,  126,
        0,  126,    0,  126,    0,  126,    0,   23,  185,  185,
      185,  185,   64,   16,   41,  185,   39,  185,  185,  185,
       30,  185,   99,  185,  185,  185,  112,  185,  185,  105,

      111,   45,  110,  113,   11,  185,  185,   12,   13,  185,
      185,  185,   32,   79,  185,   62,    3,  100,   47,  185,
      185,  185,   75,  185,  185,  185,  185,   48,  185,  185,
       40,  185,    6,  185,   94,  185,    8,   96,  185,  185,
        0,  185,   53,   74,   15,  185,  125,  125,  185,  125,
      125,  125,  185,  124,  185,    0,  126,  185,    0,    0,
      126,    0,  126,  127,  126,    0,    0,    0,    0,  126,
      126,  126,  126,  126,    0,  185,   56,   57,   58,   59,
      185,   22,  185,  185,  185,  185,   31,  185,  185,  185,
      103,  104,    0,   19,  185,  185,  185,  185,   88,  185,

       33,  185,   81,   28,   27,  185,  185,   84,  185,  185,
      185,   50,   17,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,    0,  185,  185,
      125,  185,  185,  185,  185,  125,  125,  185,  124,  185,
        0,    0,  126,  126,  126,    0,    0,  127,  126,  126,
      127,  126,    0,    0,  126,  126,  126,  126,  126,    0,
        0,    0,    0,  126,  126,    0,  126,    0,  126,    0,
       98,  185,  185,  185,   24,  185,  185,   78,  185,  185,
      185,  185,  185,  185,  185,  185,  185,    0,  185,  185,
      185,  185,  185,  185,   70,  185,  185,  185,  185,  185,

      185,  185,   76,   77,  185,   97,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      125,  125,  185,  125,  125,  125,  125,  185,  124,  185,
        0,  126,  126,    0,  126,    0,    0,  126,    0,  126,
      127,  126,    0,    0,    0,  126,  126,    0,  126,  127,
      126,    0,    0,    0,    0,    0,    0,    0,  126,  126,
      126,  126,  126,    0,  185,  185,  185,  185,   52,   63,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,   73,   71,  185,  185,   44,   85,

       86,  185,  185,  185,  185,   54,  181,  184,  183,  177,
      185,  179,  178,  182,  185,    0,  185,  185,  125,  185,
      185,  185,  125,  185,  124,  185,    0,    0,  126,  126,
      126,  126,  126,  126,    0,    0,  127,  126,  126,  126,
        0,    0,  126,  126,  126,  126,  126,    0,    0,    0,
        0,    0,    0,    0,  126,  126,  126,  126,  126,    0,
        0,    0,    0,    0,  126,  126,    0,  126,    0,  126,
        0,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  129,

      128,  185,  185,   72,  185,  185,  185,  180,  176,  185,
      185,  125,  125,  125,  125,  185,  124,  185,    0,  126,
      126,    0,  126,  126,    0,  126,    0,    0,  126,    0,
      126,  127,  126,    0,    0,    0,  126,  126,    0,  126,
      127,  126,    0,    0,    0,    0,    0,  126,  126,    0,
      126,  127,  126,    0,  126,  126,    0,    0,    0,    0,
        0,    0,    0,  126,  126,  126,  126,  126,    0,   65,
      185,   55,  134,  141,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  146,  145,  185,   66,

       49,  185,  185,    0,  185,  185,  185,  185,  185,  124,
      185,    0,    0,  126,  126,  126,  126,  126,  126,  126,
      126,  126,    0,    0,  127,  126,  126,  126,    0,    0,
      126,  126,  126,  126,  126,    0,    0,    0,    0,    0,
        0,    0,  126,  126,  126,  126,  126,    0,  126,  126,
        0,    0,    0,    0,    0,    0,    0,  126,  126,  126,
      126,  126,    0,    0,    0,    0,    0,    0,  126,  126,
        0,  126,    0,  126,    0,   91,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  151,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,

      185,   51,  123,  123,  125,  125,  185,  124,  185,    0,
      126,  126,    0,  126,  126,    0,  126,  126,    0,  126,
        0,  123,  126,    0,  126,  127,  126,    0,    0,    0,
      126,  126,    0,  126,  127,  126,    0,    0,    0,    0,
        0,  126,  126,    0,  126,  127,  126,    0,    0,    0,
        0,    0,    0,  126,  126,    0,  126,  127,  126,    0,
      126,  126,  126,    0,    0,    0,    0,    0,    0,    0,
      126,  126,  126,  126,  126,    0,  185,  185,  185,  185,
      185,  185,  185,  185,  139,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,

       92,  123,  123,  125,  185,  123,  123,    0,    0,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      126,    0,  123,  127,  126,  126,  126,    0,    0,  126,
      126,  126,  126,  126,    0,    0,    0,    0,    0,    0,
        0,  126,  126,  126,  126,  126,    0,  126,  126,    0,
        0,    0,    0,    0,    0,    0,  126,  126,  126,  126,
      126,    0,  126,  126,  126,    0,    0,    0,    0,    0,
        0,    0,  126,  126,  126,  126,  126,    0,    0,    0,
        0,    0,    0,  126,  126,    0,  126,    0,  126,    0,
      185,  185,  185,  143,  185,  185,  185,  185,  185,  185,

      185,  131,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  125,  185,  124,    0,
      126,  126,    0,  126,  126,    0,  126,  126,    0,  126,
      126,    0,  126,    0,    0,    0,  126,    0,    0,  126,
      127,  126,    0,    0,    0,  126,  126,    0,  126,  127,
      126,    0,    0,    0,    0,    0,  126,  126,    0,  126,
      127,  126,    0,    0,    0,    0,    0,    0,  126,  126,
        0,  126,  127,  126,    0,    0,    0,    0,    0,    0,
      126,  126,    0,  126,  127,  126,    0,  126,  126,  126,
        0,    0,    0,    0,    0,    0,    0,  126,  126,  126,

      126,  126,    0,  185,  185,  185,  185,  133,  185,  185,
      185,  137,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  123,
        0,    0,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,    0,    0,    0,
      127,    0,    0,  126,    0,    0,  126,  126,  126,    0,
        0,    0,    0,    0,    0,    0,  126,  126,  126,    0,
      126,  126,    0,    0,    0,    0,    0,    0,    0,  126,
      126,  126,    0,  126,  126,  126,    0,    0,    0,    0,
        0,    0,    0,  126,  126,  126,    0,  126,  126,  126,

        0,    0,    0,    0,    0,    0,    0,  126,  126,  126,
        0,    0,    0,    0,    0,    0,  126,  126,    0,  126,
        0,  126,    0,  130,  142,  144,  138,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  160,  185,  185,  185,  185,    0,    0,  126,
        0,  126,    0,  126,  126,    0,  126,  126,    0,  126,
      126,    0,  126,  126,    0,  126,    0,    0,    0,    0,
      126,  126,    0,  126,    0,    0,  126,  126,  126,    0,
        0,    0,    0,  126,  126,  126,    0,    0,    0,    0,
        0,  126,  126,  126,    0,    0,    0,    0,    0,  126,

      126,  126,    0,    0,    0,    0,    0,  126,  126,  126,
      126,  126,  126,    0,    0,    0,    0,    0,    0,    0,
      126,  126,  126,    0,  185,  185,  185,  185,  185,  185,
      185,  152,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,    0,    0,    0,  126,  126,
      126,  126,  126,  126,    0,    0,    0,    0,  126,  126,
        0,    0,    0,    0,  126,  126,  126,    0,    0,    0,
        0,    0,  126,  126,  126,  126,    0,    0,    0,    0,
        0,  126,  126,  126,  126,    0,    0,    0,    0,    0,
      126,  126,  126,  126,    0,    0,    0,    0,    0,  126,

        0,    0,    0,    0,    0,  126,  126,  126,  185,  185,
      185,  140,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  126,
      126,  126,  126,  126,  126,  126,  126,    0,    0,    0,
        0,  126,  126,    0,    0,  126,    0,    0,    0,  126,
        0,    0,    0,  126,    0,    0,    0,  126,    0,    0,
        0,  126,  126,  126,  126,    0,    0,    0,    0,    0,
      126,  135,  185,  132,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  161,  185,
      185,  126,    0,    0,  126,  126,    0,  126,  126,  126,

        0,  126,  126,  126,    0,  126,  126,  126,    0,  126,
      126,  126,    0,    0,    0,    0,  126,  136,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  148,
      185,  157,  185,  149,  126,  126,    0,    0,    0,    0,
        0,    0,  126,  126,  126,    0,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  156,
        0,  126,  126,  126,  126,  126,    0,  172,  185,  185,
      185,  185,  185,  185,  185,  185,  159,  185,  185,  185,
      126,  126,  171,  185,  185,  185,  185,  185,  185,  185,
      158,  185,  185,  185,  185,  185,  185,  185,  185,  185,

      185,  185,  185,  185,  150,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  147,  185,  185,  170,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  169,  185,  185,  185,  185,  185,  175,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  162,
      185,  185,  185,  185,  185,  155,  185,  185,  173,  185,
      185,  185,  185,  185,  185,  153,  185,  174,  185,  168,
      185,  185,  185,  185,  163,  185,  165,  185,  185,  167,
      164,  154,  166,    0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    5,    1,    1,    6,    7,    8,    1,    9,
        9,    7,    7,    1,   10,   11,    7,   12,   13,   14,
       15,   16,   17,   18,   17,   17,   17,   19,    1,   20,
       21,   22,    1,    1,   23,   23,   23,   23,   23,   23,
       24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
       24,   24,   24,   24,   24,   24,   24,   25,   24,   24,
        7,   26,    7,    7,   27,    1,   28,   29,   30,   31,

       32,   33,   34,   35,   36,   24,   37,   38,   39,   40,
       41,   42,   43,   44,   45,   46,   47,   48,   49,   50,
       51,   24,    1,   52,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[53] =
    {   0,
        1,    2,    2,    1,    2,    1,    1,    1,    2,    3,
        4,    5,    5,    5,    5,    5,    5,    5,    6,    1,
        1,    1,    7,    3,    8,    1,    3,    7,    7,    7,
        7,    7,    7,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    8,
        3,    1
    } ;

static const flex_int16_t yy_base[2245] =
    {   0,
        0,    0, 6541, 7736, 7736, 7736, 6491,    0, 7736, 6499,
       43,   70, 6478,   43, 6475,   75,  110,  151,    0,   70,
       85,  102,   67,   61,   77,  105,  113,  155,  158,  170,
       70,  176,  165,  110,  189,  148, 6459,  184, 6448, 6433,
     7736,    0, 7736,  225,  247,  270, 6462,  293,    0,  300,
        0,  322, 7736, 7736, 7736, 7736, 7736,  344,    0, 6433,
     6430, 6442,    0, 6433, 6419, 6430, 6419, 6405, 6379, 6372,
     6373, 6370, 6360, 6369, 6349, 6359, 6342,  284, 6349, 6343,
     6328, 6302, 6298, 6305, 6291, 6296, 6283, 6274,   89,   81,
     6277,   29,  109, 6263, 6250, 6251,  123,  211,    0,    0,

       99,  168, 6239, 6218,  204, 6202, 6194, 6183, 6157, 6140,
     6146, 6135, 6134, 6140,    0, 6147,    0, 6129, 6135, 6129,
     6130, 6128, 6127,  200, 6134, 6115, 6124, 6095,  131, 6073,
      327, 6057,  194, 6046, 6049,    0, 6033,    0, 6032, 6026,
     6017, 6017, 6003, 5991, 6003, 7736, 7736,  363,  386,  180,
      426,  449,  472, 5996,  479, 5996,  502,  241, 5976, 5944,
     5927, 5911,    0,    0, 5912,    0, 5921, 5912, 5897, 5873,
     5874, 5862, 5833, 5827,    0,    0, 5754, 5724,    0, 5703,
     5674, 5662, 5675, 5673, 5676, 5673, 5656, 5636, 5633, 5646,
     5629, 5607, 5599, 5581, 5542, 5553, 5538, 5535,    0, 5539,

     5515,    0,    0, 5476, 5466,    0, 5407,    0, 5404, 5392,
     5399,    0,    0, 5387,    0, 5395, 5386,  201, 5368,    0,
     5365, 5361,    0, 5355,    0, 5341,    0, 5322, 5324, 5299,
     5300, 5286, 5279, 5273,    0, 5271, 5252,    0, 5239,    0,
     5237,    0,    0,    0, 5214,    0,  223,  240, 5224,    0,
        0, 5214,    0, 5194, 5195,  541, 5223,  563,  586, 5220,
      593,  352,  260,  616, 5193,  639, 5191, 5170,  647,  271,
     5150, 5148,  408,  687,  709, 5147,    0,    0, 5123,  374,
     5107, 5112,    0,    0,    0, 5108,    0, 5073, 5069, 5053,
        0, 5052,    0, 5045, 5043, 5034,    0, 5012, 5009,    0,

        0,    0,    0,    0,  519, 5021, 5011,    0,    0, 5013,
     4977, 4958,    0,    0, 4954,    0,    0,    0,    0, 4968,
     4946, 4949,    0, 4942, 4913, 4925, 4899, 4894, 4884, 4835,
        0, 4816,    0, 4815,    0,  250,    0,    0, 4808, 4803,
      715, 4813,    0,    0,    0,  753,  776,  272,  816, 4838,
     4836,  360,  838,  861,  884, 4826,  891,  415, 4793, 4792,
      913,  526,  936,  958, 4789,    0, 4787,  423,  511,  981,
     4769, 1004,  294, 4768, 4774, 4743,    0,    0,    0,    0,
     4720,    0, 4734, 4732, 4714, 4696,    0, 4713, 4707, 4705,
        0,    0, 1023,  516, 4678, 4667, 4665, 4664,    0, 4653,

        0, 4631, 4624,    0,    0, 4628, 4610,  515, 4608, 4606,
       73, 4603,    0, 4592, 4565, 4576, 4552, 4543, 4535, 4514,
     4515, 4507, 4493, 4493, 4469, 4474, 4472, 1059, 4488, 1081,
     1104, 4486, 1111,  669,  313, 1134,  324, 1173, 1195, 1218,
     4476, 4475, 1226,  357, 4456, 4454, 4453, 4434, 1266,  358,
     4431, 4430,  663,  683, 1306, 4429, 1329,  420, 4387, 4394,
     4385,  737,    0,  394, 4382,  798, 1369, 1391, 4364,    0,
        0, 4333, 4330, 4309,    0, 4318, 4270,    0, 4270, 4266,
     4251, 4264, 4263,  703, 4217,  728, 4217, 1395, 4212, 4200,
     4202, 4190, 4179, 4197,    0, 4155, 4162, 4134, 4139, 4136,

     4125, 4092,    0,    0, 4096,    0, 4067, 4058, 4071, 4070,
     4032, 4024, 4034, 4022, 3999, 3997, 4001, 4006, 4005, 1432,
     1455,  421, 1495, 3996, 3993,  684, 1518, 1541, 1548, 1571,
     3983, 1578, 1601, 1623, 3982, 3981, 3969, 1645,  805, 1668,
     1690, 3948,    0, 1026,    0,  571, 3930, 1033, 1713, 1735,
     3905,    0,  747,  750, 3895,  601,  813,  832, 1758, 3883,
     1781,  425, 3882, 3888,  490, 3851, 3848, 3825,    0,    0,
     3830, 3832, 3817, 3793, 3800, 3770, 3769, 3776, 3766, 3748,
     3759, 3739, 3739, 3707, 3688,  227, 1020, 3698, 1025, 3688,
     3692, 3662, 3671, 3649,    0,    0, 3620, 3614,    0,    0,

        0, 3605, 3600, 3586, 3570,    0,    0,    0,    0,    0,
     3556,    0,    0,    0, 3524, 1820, 3558, 1842, 1865, 3554,
     1872,  330, 1894, 1917, 1924, 1947, 3545, 3530, 1955,  426,
     3527, 1995,  449, 3525, 3503, 3485, 3482, 2035,  498, 3480,
     1053, 1143, 2075, 3440, 2098,  538, 3438, 3445, 1144, 1145,
     3424, 3423, 1147, 1149, 2138, 3413, 2161,  564, 3393, 3400,
     1163,    0, 1248,    0,  624, 3390, 1255, 2201, 2223, 3389,
        0, 2245,  301,  407,  302,  246, 1136,  522,  700, 3361,
      539,  478,  538,  661,  569,  455,  790,  650,  682,  406,
      757, 1017,  834, 1056,  887,  571,  796, 1168, 1242, 3360,

     3338, 1254, 3333, 3312, 1255, 1125,  590, 3310, 3307, 2282,
     2305, 2327, 2362,  617, 2385,  627, 2393, 2416, 3302, 2423,
     2446, 2468, 3300, 2491, 2513, 3298, 3277, 3275, 2535, 1290,
     2558, 2580, 3252,    0, 1297,    0, 1119, 3234, 1351, 2603,
     2625, 3231,    0, 1358,    0, 1477,    0, 1399, 3229, 1484,
     2648, 2670, 3227,    0,  706, 1803, 3217, 1366, 1404, 3214,
     3202, 1427, 1432, 2693, 3184, 2716,  752, 3183, 3190,  702,
      854,  769, 1368, 1384, 1493, 1965, 1494,  907,  930,  952,
     1990,  831, 1386, 1795, 1798,  951, 1966, 1967, 1817,  974,
      953, 2005,  997, 2034, 1818, 1074, 1126, 1188, 1323, 1265,

     1322, 2029, 2045, 2757, 1426, 2779, 1448, 2801, 2061, 2824,
     2847, 3181, 3172, 2855,  812, 3147, 2895,  835, 3127, 2935,
      861, 3117, 3108, 3061, 3055, 2975,  862, 3054, 1617, 1971,
     3015, 3020, 3038,  885, 3017, 3010, 2032, 2070, 3007, 2988,
     2072, 2108, 3078, 2977, 3101,  888, 2976, 2951,  978, 2122,
     2948, 2135, 2171, 2946, 2945, 2172, 2176, 3141, 2936, 3164,
      980, 2924, 2911,    0, 2190,    0, 2267,    0, 1503, 2900,
     2334, 3204, 3226, 2898,    0, 1594, 1595, 1616, 1639, 1819,
     1662, 1989, 1683, 1685, 1820, 1729, 2200, 2345, 2115, 1706,
     1728, 2171, 2726, 1886, 2727, 1751, 2262, 2259, 1775, 1887,

     2218, 1730, 3250, 3272, 3295,  981, 3334, 3357, 3380, 2897,
     3387, 3410, 3432, 2896, 3455, 3477, 2884, 3500, 3522, 2863,
     2862, 2860, 3544, 2344, 3567, 3589, 2858,    0, 2351,    0,
     1556, 2857, 2743, 3612, 3634, 2856,    0, 2877,    0, 2884,
        0, 1880, 2832, 2917, 3657, 3679, 2831,    0,    0, 2924,
        0, 2957,    0, 1932, 2829, 2964, 3702, 3724, 2827,    0,
        0, 1031, 2997, 2834, 2277, 2279, 2815, 2814, 2282, 2462,
     3747, 2802, 3770, 1033, 2782, 2789, 2344, 2741, 2974, 2343,
     1888, 2754, 2992, 2009, 3014, 2505, 2135, 3032, 2238, 2461,
     2793, 2239, 1971, 1774, 3095, 3052, 2298, 2299, 3055, 2091,

     1813, 2137, 2240, 3811, 3834, 3843, 2439, 2779, 2759, 3860,
     1035, 2757, 3900, 1055, 2724, 3940, 1082, 2721, 3980, 1083,
     2701, 2700, 2699, 4019, 4042, 1167, 2698, 2727, 2754, 4082,
     2678, 4105, 1196, 2676, 2683, 2972, 3053, 2664, 2661, 3075,
     3112, 4145, 2651, 4168, 1197, 2633, 2616, 1301, 3126, 2614,
     3136, 3138, 2571, 2569, 3174, 3179, 4208, 2543, 4231, 1305,
     2541, 2548,    0, 1306, 3193, 2546, 3201, 3220, 2545, 2527,
     3304, 3305, 4271, 2494, 4294, 1426, 2473, 2479,    0, 3319,
        0, 3326,    0, 1978, 2451, 3792, 4334, 4356, 2449,    0,
     3857, 3859, 3871, 2440, 3157, 3075, 2462, 3220, 2508, 2506,

     2507, 2484, 3784, 2551, 3893, 2573, 2575, 3894, 2596, 3853,
     2574, 3786, 3787, 2619, 3916, 2620, 4380, 4403, 4412, 2429,
     4428, 4451, 4473, 2428, 4496, 4518, 2426, 4541, 4563, 2425,
     4586, 4608, 2424, 2400, 4631, 1431, 2399, 2396, 3962, 4671,
     2365, 2364,    0, 3969,    0, 2011, 2363, 4002, 4694, 2305,
     2287,    0, 4009,    0, 4064,    0, 2113, 2268, 4071, 4717,
     2228, 2225,    0,    0, 4127,    0, 4134,    0, 2401, 2224,
     4190, 4740, 2204, 2180,    0,    0, 4197,    0, 4253,    0,
     2731, 2176, 4260, 4763, 2169, 2146,    0,    0, 1490, 4316,
     2133, 3426, 3471, 2132, 2091, 3516, 3857, 4786, 2081, 4809,

     1492, 2080, 2069, 2618, 2641, 2663, 2686, 2664, 2795, 4641,
     2817, 2796, 3895, 3264, 4018, 4642, 4803, 4819, 4019, 4080,
     4144, 4821, 4823, 3118, 4081, 3050, 3265, 4825, 3266, 4857,
     2021, 4873, 4896, 1494, 2019, 4936, 1518, 2016, 4976, 1520,
     2012, 5016, 1547, 1976, 5056, 1548, 1972, 1971, 4323, 5096,
     1960, 1931,    0, 1930, 3916, 4142, 5119, 1929, 1927, 1933,
     4205, 4268, 1905, 1881, 4331, 4350, 5142, 1847, 1807, 1813,
     1549, 4419, 1771, 4427, 4467, 1769, 1768, 4512, 4557, 5165,
     1718, 1695, 1700,    0, 1575, 4658,  121, 4642, 4666,  145,
      164, 4833, 4868, 5188,  168,  308,  373,    0, 1619, 4918,

      401, 4870, 4912,  458,  534, 4931, 4932, 5211,  532,  548,
      576,    0, 4958,    0, 4998,    0, 3064,  600, 5005, 5234,
        0,  621,    0, 2894, 2934, 3010, 3013, 3349, 5015, 5050,
     5026, 4207, 5027, 3403, 4270, 4333, 3350, 4668, 4872, 4853,
     5051, 4953, 3077, 3404, 5055, 5066, 3351, 5257, 1620,    0,
      622, 5297,    0,  649, 5320,    0,  650, 5343,    0,  652,
     5366,    0,  671, 5389,    0,  672, 4933, 5072, 5412,  673,
      692,  711,  763,  759, 5279,    0, 3065,  761,  779, 5286,
        0, 5434,    0, 3303,  821,  864,    0, 5441,    0, 5448,
        0, 3889,  896,  897,    0, 5455,    0, 5462,    0, 3923,

      918,  937,    0, 5469,    0, 5476,    0, 3927,  939,  983,
        0, 1640, 5483, 1015, 5091, 5294, 1068, 1120, 5491, 5492,
     5532, 1116,    0, 1126, 5296, 3138, 3242, 3426, 3448, 5494,
     5495, 3470, 3471, 3493, 3515, 5496, 3516, 5497, 4826, 3560,
     5510, 3561, 4851, 5503, 3582, 5555, 1164, 1197,    0,    0,
        0,    0,    0,    0, 5577,    0, 3928, 1200, 1201,    0,
     5503, 5504, 1237, 1239,    0, 1710, 5584, 1241, 5507, 5508,
     1242, 1279,    0,    0, 1817, 5591, 1282, 5599, 5600, 1316,
     1317,    0,    0, 1843, 5600, 1378, 5608, 5609, 1379, 1382,
        0,    0, 1844, 5614, 1406, 5610, 5611, 1422, 1429,    0,

        0, 5625,    0, 5639,    0, 3929, 1455,    0, 4950, 5635,
     4600, 3584, 3606, 5636, 5637, 5655, 5656, 5657, 5658, 5659,
     3629, 5660, 3651, 5663, 5662, 5668, 5669, 3628, 3605,    0,
     7736,    0,    0,    0,    0,    0,    0, 5677, 5686, 1468,
     1505,    0, 7736, 5701,    0, 7736,    0, 5708,    0, 7736,
        0, 5716,    0, 7736,    0, 5725,    0, 7736,    0, 5732,
        0, 7736,    0, 1895, 5739, 1528, 5747, 5748, 1558, 4436,
        0, 3672, 5093, 3673, 3674, 5750, 5752, 5751, 5755, 3695,
     5756, 5757, 3717, 5753, 5760, 3740, 5754, 5761, 3719, 5758,
     3741,    0, 5796,    0, 2009, 5803, 1591,    0, 2012, 5810,

     1592,    0, 2046, 5817, 1612,    0, 2175, 5824, 1636,    0,
     2363, 5831, 1639,    0, 5838,    0, 7736, 3763, 5847, 4099,
     5765, 4372, 4512, 5848, 5850, 5851, 5854, 4557, 5766, 3808,
     3935, 3809, 5853, 3979, 2364, 5853, 1677,    0,    0,    0,
        0,    0,    0, 2392, 5870, 1681, 5862, 5880, 5882, 5884,
     5890, 4349, 5891, 4162, 4288, 5892, 5885, 5893, 5895, 4444,
        0,    0,    0,    0,    0,    0,    0, 4466, 5896, 4489,
     5900, 5903, 5914, 5918, 5919, 5925, 4534, 5926, 5927, 4556,
        0,    0, 4579, 4601, 4688, 4711, 4734, 5930, 4757, 5933,
     4603, 5937, 5764, 4780, 5948, 5955, 5958, 5028, 5960, 5090,

     5964, 5030, 5961, 5091, 4867, 5963, 5135, 5136, 5966, 5967,
     5979, 5973, 5986, 5974, 5158, 5987, 4912, 5999, 6001, 4975,
     6006, 6007, 6009, 5181, 5182, 6015, 6010, 6017, 6020, 5205,
     5228, 6028, 5250, 6030, 5251, 6031, 6040, 5337, 5314, 5336,
     6044, 6049, 6050, 6055, 5359, 6053, 6054, 6056, 6069, 5382,
     6076, 6062, 6077, 5383, 6084, 5406, 6080, 6091, 5498, 6096,
     6098, 6099, 5499, 6100, 5549, 5500, 6102, 5852, 6105, 6103,
     6107, 6109, 6111, 6112, 6118, 6130, 6131, 6136, 6151, 6139,
     6141, 6143, 6144, 7736, 6178, 6185, 6189, 6192, 6195, 6198,
     6201, 6204, 6207, 6210, 6213, 6216, 6219, 6222, 6225, 6228,

     6231, 6234, 6237, 6241, 6245, 6248, 6251, 6254, 6257, 6260,
     6263, 6266, 6269, 6273, 6277, 6280, 6283, 6287, 6289, 6292,
     6295, 6298, 6301, 6304, 6307, 6310, 6313, 6317, 6319, 6322,
     6326, 6331, 6335, 6338, 6342, 6345, 6348, 6351, 6354, 6357,
     6360, 6363, 6367, 6371, 6374, 6378, 6382, 6387, 6391, 6393,
     6397, 6400, 6404, 6407, 6410, 6414, 6416, 6419, 6422, 6425,
     6428, 6431, 6434, 6437, 6440, 6443, 6447, 6449, 6452, 6455,
     6458, 6462, 6464, 6467, 6470, 6475, 6479, 6484, 6488, 6490,
     6494, 6497, 6501, 6506, 6510, 6513, 6516, 6519, 6522, 6525,
     6528, 6531, 6535, 6539, 6542, 6546, 6550, 6555, 6559, 6561,

     6565, 6568, 6572, 6575, 6580, 6584, 6589, 6593, 6595, 6599,
     6602, 6606, 6609, 6612, 6615, 6619, 6621, 6624, 6629, 6633,
     6636, 6639, 6642, 6645, 6648, 6651, 6654, 6657, 6661, 6663,
     6666, 6669, 6672, 6676, 6678, 6681, 6684, 6687, 6690, 6694,
     6696, 6699, 6702, 6705, 6710, 6714, 6719, 6723, 6725, 6729,
     6732, 6736, 6741, 6745, 6748, 6751, 6754, 6757, 6760, 6763,
     6766, 6770, 6774, 6777, 6781, 6785, 6790, 6794, 6796, 6800,
     6803, 6807, 6810, 6815, 6819, 6824, 6828, 6830, 6834, 6837,
     6841, 6844, 6847, 6852, 6856, 6861, 6865, 6867, 6871, 6874,
     6878, 6881, 6884, 6887, 6891, 6893, 6896, 6901, 6905, 6908,

     6911, 6914, 6917, 6920, 6923, 6926, 6929, 6932, 6935, 6938,
     6942, 6944, 6947, 6950, 6953, 6956, 6960, 6962, 6965, 6968,
     6971, 6974, 6977, 6981, 6983, 6986, 6989, 6992, 6995, 6998,
     7002, 7004, 7007, 7010, 7013, 7016, 7021, 7025, 7030, 7034,
     7036, 7040, 7043, 7047, 7052, 7056, 7059, 7062, 7065, 7068,
     7071, 7074, 7077, 7080, 7083, 7087, 7091, 7094, 7098, 7102,
     7107, 7111, 7113, 7117, 7120, 7124, 7127, 7132, 7136, 7141,
     7145, 7147, 7151, 7154, 7158, 7161, 7164, 7169, 7173, 7178,
     7182, 7184, 7188, 7191, 7195, 7198, 7201, 7206, 7210, 7215,
     7219, 7221, 7225, 7228, 7232, 7235, 7238, 7241, 7245, 7247,

     7250, 7253, 7258, 7262, 7265, 7268, 7271, 7274, 7277, 7280,
     7283, 7286, 7289, 7292, 7295, 7299, 7303, 7306, 7309, 7313,
     7316, 7319, 7323, 7325, 7328, 7331, 7335, 7337, 7340, 7343,
     7346, 7350, 7352, 7355, 7358, 7361, 7365, 7367, 7370, 7373,
     7376, 7380, 7382, 7385, 7388, 7393, 7397, 7402, 7406, 7408,
     7412, 7415, 7419, 7424, 7428, 7431, 7434, 7437, 7440, 7443,
     7446, 7449, 7452, 7456, 7458, 7461, 7465, 7470, 7474, 7475,
     7478, 7483, 7487, 7492, 7496, 7497, 7500, 7503, 7508, 7512,
     7517, 7521, 7522, 7525, 7528, 7533, 7537, 7542, 7546, 7547,
     7550, 7553, 7558, 7562, 7567, 7571, 7572, 7575, 7578, 7581,

     7585, 7587, 7592, 7596, 7599, 7602, 7605, 7608, 7611, 7614,
     7618, 7623, 7627, 7628, 7631, 7634, 7637, 7640, 7643, 7646,
     7649, 7652, 7655, 7658, 7663, 7667, 7670, 7673, 7676, 7680,
     7684, 7688, 7692, 7696, 7699, 7702, 7706, 7709, 7712, 7715,
     7718, 7721, 7725, 7728
    } ;

static const flex_int16_t yy_def[2245] =
    {   0,
     1784,    1, 1784, 1784, 1784, 1784, 1784, 1785, 1784, 1784,
     1784,   11, 1784, 1784, 1784, 1784,   11,   17, 1786,   17,
       17,   17,   17,   17,   17,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18, 1784,
     1784, 1787, 1784,   18,   18,   17, 1788,   46,   18,   18,
       18, 1784, 1784, 1784, 1784, 1784, 1784,   45, 1786,   48,
       48,   48,   18,   18,   18,   18,   48,   18,   18,   48,
       18,   18,   18,   48,   18,   18,   18,   18,   18,   48,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18, 1784, 1784,   18,   18,  149,
       18,   18,  152, 1789, 1784,   50, 1784,  157, 1790,   18,
       18,  153,   18,   18,   18,  153,   18,   18,   18,   18,
       18,   18,  153,   18,   18,   18,   18,   18,   18,   18,
      153,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,  258,  259,  153, 1791,  264, 1792, 1793, 1784,  269,
     1794, 1795, 1784, 1784, 1784, 1796, 1797,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,  347,   18,  259,
      261,  259,  261,  261,  354, 1798, 1784,  353, 1799, 1800,
     1784, 1784, 1784, 1784, 1801, 1802, 1803, 1804, 1804, 1784,
     1805, 1784,  372, 1806, 1797,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,  430,  431,  431,  436,  430,  354,  439,
     1807, 1808, 1784,  443, 1809, 1784, 1810, 1811, 1784,  449,
     1812, 1813, 1814, 1814, 1784, 1815, 1784,  457, 1816, 1802,
     1784, 1784, 1817, 1818, 1784, 1784, 1784, 1784, 1819, 1820,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,  521,   18,  431,  433,  431,  431,  527,  439,  529,
     1821, 1784, 1784, 1784, 1822, 1823, 1824, 1784, 1784, 1784,
     1784, 1825, 1826, 1784, 1827, 1828, 1784, 1784, 1784, 1784,
     1829, 1830, 1831, 1831, 1817, 1818, 1832, 1832, 1784, 1833,
     1784,  561, 1834, 1835,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,  619,  527,  623,  529,  625, 1836, 1837, 1784,  629,
     1838, 1784,  632, 1839, 1784, 1840, 1841, 1784,  638, 1842,
     1843, 1843, 1784, 1844, 1784,  645, 1845, 1846, 1847, 1847,
     1848, 1849, 1850, 1850, 1784, 1851, 1784,  657, 1852, 1853,
     1784, 1854, 1784, 1855, 1856, 1784, 1784, 1784, 1784, 1857,
     1858,  626,  672,  672,  672,  672,  672,  672,  672,  672,
      672,  672,  672,  672,  672,  672,  672,  672,  672,  672,
      672,  672,  672,  672,  672,  672,  672,  672,  672,  672,

      672,  672,  672,  672,  672,  672,  672,  672,  672,  626,
      626,  672,  712,  712,  712,  672,  712,  717, 1859, 1784,
     1784, 1784, 1860, 1784, 1784, 1861, 1862, 1863, 1784, 1784,
     1784, 1784, 1864, 1865, 1784, 1866, 1867, 1784, 1784, 1784,
     1784, 1868, 1869, 1784, 1870, 1784, 1871, 1872, 1784, 1784,
     1784, 1784, 1873, 1874, 1875, 1784, 1876, 1877, 1877, 1878,
     1879, 1880, 1880, 1784, 1881, 1784,  766, 1882, 1883, 1884,
     1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884,
     1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884,
     1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884,

     1884, 1884, 1884, 1884, 1884,  804, 1884,  804,  808,  808,
      810, 1885, 1886, 1784,  814, 1887, 1784,  817, 1888, 1784,
      820, 1889, 1784, 1890, 1891, 1784,  826, 1892, 1893, 1893,
     1784, 1894, 1784,  833, 1895, 1896, 1897, 1897, 1898, 1899,
     1900, 1900, 1784, 1901, 1784,  845, 1902, 1903, 1904, 1784,
     1905, 1906, 1906, 1907, 1908, 1909, 1909, 1784, 1910, 1784,
      860, 1911, 1912, 1913, 1784, 1914, 1784, 1915, 1916, 1784,
     1784, 1784, 1784, 1917, 1918, 1919, 1919, 1919, 1919, 1919,
     1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919,
     1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919,

     1919, 1919, 1919,  903,  903,  905,  903,  903,  908, 1920,
     1784, 1784, 1784, 1921, 1784, 1784, 1922, 1784, 1784, 1923,
     1924, 1925, 1784, 1784, 1784, 1784, 1926, 1927, 1784, 1928,
     1929, 1784, 1784, 1784, 1784, 1930, 1931, 1784, 1932, 1784,
     1933, 1934, 1784, 1784, 1784, 1784, 1935, 1936, 1937, 1784,
     1938, 1784, 1939, 1940, 1784, 1784, 1784, 1784, 1941, 1942,
     1943, 1944, 1784, 1945, 1946, 1946, 1947, 1948, 1949, 1949,
     1784, 1950, 1784,  973, 1951, 1952, 1953, 1953, 1953, 1953,
     1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953,
     1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953,

     1953, 1953, 1953, 1953, 1004, 1953, 1953, 1954, 1955, 1784,
     1010, 1956, 1784, 1013, 1957, 1784, 1016, 1958, 1784, 1019,
     1959, 1784, 1960, 1784, 1784, 1025, 1961, 1962, 1962, 1784,
     1963, 1784, 1032, 1964, 1965, 1966, 1966, 1967, 1968, 1969,
     1969, 1784, 1970, 1784, 1044, 1971, 1972, 1973, 1784, 1974,
     1975, 1975, 1976, 1977, 1978, 1978, 1784, 1979, 1784, 1059,
     1980, 1981, 1982, 1983, 1784, 1984, 1985, 1985, 1986, 1987,
     1988, 1988, 1784, 1989, 1784, 1075, 1990, 1991, 1992, 1784,
     1993, 1784, 1994, 1995, 1784, 1784, 1784, 1784, 1996, 1997,
     1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998,

     1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998,
     1998, 1998, 1998, 1998, 1998, 1998, 1998, 1117, 1998, 1999,
     1784, 1784, 1784, 2000, 1784, 1784, 2001, 1784, 1784, 2002,
     1784, 1784, 2003, 2004, 1784, 1135, 2005, 2006, 1784, 1784,
     2007, 2008, 2009, 1784, 2010, 2011, 1784, 1784, 1784, 2012,
     2013, 2014, 1784, 2015, 1784, 2016, 2017, 1784, 1784, 1784,
     2018, 2019, 2020, 2021, 1784, 2022, 1784, 2023, 2024, 1784,
     1784, 1784, 2025, 2026, 2027, 2028, 1784, 2029, 1784, 2030,
     2031, 1784, 1784, 1784, 2032, 2033, 2034, 2035, 2036, 1784,
     2037, 2038, 2038, 2039, 2040, 2041, 2041, 1784, 2042, 1784,

     1200, 2043, 2044, 2045, 2045, 2045, 2045, 2045, 2045, 2045,
     2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045,
     2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045,
     2046, 1784, 1784, 1233, 2047, 1784, 1236, 2048, 1784, 1239,
     2049, 1784, 1242, 2050, 1784, 1245, 2051, 1784, 1784, 1784,
     2052, 2053, 2054, 2055, 2056, 2056, 1784, 2057, 2058, 2059,
     2060, 2060, 2061, 2062, 2063, 2063, 1784, 2064, 2065, 2066,
     2067, 1784, 2068, 2069, 2069, 2070, 2071, 2072, 2072, 1784,
     2073, 2074, 2075, 2076, 2077, 1784, 2078, 2079, 2079, 2080,
     2081, 2082, 2082, 1784, 2083, 2084, 2085, 2086, 2087, 1784,

     2088, 2089, 2089, 2090, 2091, 2092, 2092, 1784, 2093, 2094,
     2095, 2096, 1784, 2097, 1784, 2098, 2099, 1784, 1784, 1784,
     2100, 2101, 2102, 2103, 2103, 2103, 2103, 2103, 2103, 2103,
     2103, 2103, 2103, 2103, 2103, 2103, 2103, 2103, 2103, 2103,
     2103, 2103, 2103, 2103, 2103, 2103, 2103, 1784, 1348, 2104,
     2105, 1784, 2106, 2107, 1784, 2108, 2109, 1784, 2110, 2111,
     1784, 2112, 2113, 1784, 2114, 2115, 2116, 2116, 1784, 2117,
     2118, 2119, 2120, 2121, 1784, 2122, 2123, 1784, 2124, 1784,
     2125, 1784, 2126, 2127, 1784, 2128, 2129, 1784, 2130, 1784,
     2131, 2132, 1784, 2133, 2134, 1784, 2135, 1784, 2136, 2137,

     1784, 2138, 2139, 1784, 2140, 1784, 2141, 2142, 1784, 2143,
     2144, 2145, 1784, 2146, 2147, 2147, 2148, 2149, 2150, 2150,
     1784, 2151, 2152, 2153, 2154, 2154, 2154, 2154, 2154, 2154,
     2154, 2154, 2154, 2154, 2154, 2154, 2154, 2154, 2154, 2154,
     2154, 2154, 2154, 2154, 2154, 1784, 2155, 2156, 2157, 2158,
     2159, 2160, 2161, 2162, 1784, 2163, 2164, 1784, 2165, 2166,
     2167, 2167, 2168, 2169, 2170, 2171, 1784, 2172, 2173, 2173,
     2174, 2175, 2176, 2177, 2178, 1784, 2179, 2180, 2180, 2181,
     2182, 2183, 2184, 2185, 1784, 2186, 2187, 2187, 2188, 2189,
     2190, 2191, 2192, 1784, 2193, 2194, 2194, 2195, 2196, 2197,

     2198, 1784, 2199, 1784, 2200, 2201, 1784, 2202, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2204,
     1784, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2211, 2212,
     2213, 2214, 1784, 1784, 2215, 1784, 2216, 1784, 2217, 1784,
     2218, 1784, 2219, 1784, 2220, 1784, 2221, 1784, 2222, 1784,
     2223, 1784, 2198, 2224, 1784, 2199, 2225, 2225, 2200, 2201,
     2226, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2227, 1784, 2228, 2229, 1784, 2215, 2216, 2230, 1784,

     2217, 2218, 2231, 1784, 2219, 2220, 2232, 1784, 2221, 2222,
     2233, 1784, 2223, 2234, 1784, 2235, 1784, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2236, 1784, 2228, 2237, 2238, 2239,
     2240, 2241, 2234, 2242, 1784, 2235, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2243, 2237, 2238, 2239, 2240, 2241, 2244, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2243, 2244, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,

     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203,    0, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784
    } ;

static const flex_int16_t yy_nxt[7789] =
    {   0,
        4,    5,    6,    5,    7,    8,    9,   10,    9,    9,
        4,   11,   12,   12,   12,   12,   12,   12,   13,   14,
       15,   16,   17,   18,   18,   19,    4,   20,   21,   22,
       23,   24,   25,   26,   27,   28,   18,   29,   30,   31,
       32,   33,   18,   34,   35,   36,   37,   38,   39,   18,
       18,   40,   44,   45,   46,   46,   46,   46,   46,   46,
       46,   47,   53,   54,  195,   48,   49,   50,  196,   51,
       48,   48,   48,   48,   48,   48,   49,   49,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
       49,   49,   50,   49,   49,   56,   57,   60,   74,   61,

       62,  112,   75,  503,   63,   78,   79,   80,   76,   64,
      113,   77,   81,   65,   67,   66,  192,  504,  193,   49,
       58,   48,   48,   48,   48,   48,   48,   48,   68,   70,
      190, 1165,   82,  191,   49,   69,   83,  124,  207,   71,
      202,  125,   72,   85,  208,   86,   73,  197,   84,  126,
       87,   88,  198,   89,  127, 1167,  128,   90,  238,   49,
       51,   49,   49,   49,   49,   49,   49,   49,   49, 1784,
       99,  100,  203,   49,  944,  136,  239,  137,   49,   49,
       49,   49,   49,   49,   91,  101, 1362,   92,   93,  102,
       94,  138,   95,  103,   96,  104,   97,  106,  139,   98,

      119,  107,  105,  114,   49,  120,  121,  209,  122,  123,
      108,  109,  210,  141,  110,  115,  111,  116,  129,  117,
      204,  142,  118,  244,  130,  143,  131,  144,  132,   49,
      232,  321,  133,  245,  134,  135,  148,  148,  148,  148,
      148,  148,  148,  233,  322,  213,  205,  148,  214,  341,
      215,  206,  148,  148,  148,  148,  148,  148,  149,  150,
      150,  150,  150,  150,  150, 1784,  339,  690,  340,  151,
       49,  352,  342,  691,  151,  151,  151,  151,  151,  151,
       45,  152,  152,  152,  152,  152,  152,  152,  774,  415,
     1784,   49,  153,  177,  416, 1784,   49,  153,  153,  153,

      153,  153,  153,   58,  153,  153,  153,  153,  153,  153,
      153,  156,  156,  156,  156,  156,  156,  156, 1784,  178,
     1784,   49,  156,   49,  526,  179,  451,  156,  156,  156,
      156,  156,  156,  157,  158,  158,  158,  158,  158,  158,
       49,  714,  773, 1784,  159,  771,   49,   49,   49,  159,
      159,  159,  159,  159,  159,  151,  151,  151,  151,  151,
      151,  151,  241,  349,  349,  349,  349,  349,  349,  349,
      435,  242,  256,   49,  257,  257,  257,  257,  257,  257,
      257, 1784, 1784, 1171,  261,  257,  377,  378,  379,  380,
      257,  257,  257,  257,  257,  257,  258,  259,  259,  259,

      259,  259,  259,  259,  273,  381, 1784, 1784,  260,  261,
      261, 1177,  275,  260,  260,  260,  260,  260,  260,  368,
      369,  369,  369,  369,  369,  369,  438,  438,  438,  438,
      438,  438,  438,  462,  788,  261,  262,  260,  260,  260,
      260,  260,  260,  260, 1784,   49,  772,  463,  260, 1784,
     1784,   49,   49,  260,  260,  260,  260,  260,  260,  263,
      264,  264,  264,  264,  264,  264,  264,  265, 1179, 1784,
       49,  266,  463, 1784, 1784, 1784,  266,  266,  266,  266,
      266,  266,   49,  266,  266,  266,  266,  266,  266,  266,
      269,  270,  270,  270,  270,  270,  270,  271, 1784,  784,

       49,  272,  377,  378,  379,  380,  272,  272,  272,  272,
      272,  272,  273,  274,  274,  274,  274,  274,  274,  274,
      275,  462, 1784,   49,  276,  488,  277,  780,  393,  276,
      276,  276,  276,  276,  276, 1784,  394,  453,  454,  454,
      454,  454,  454,  454,  956,  489,  499, 1784,  395,  776,
     1365,  277,  346,  346,  346,  346,  346,  346,  346,  500,
     1784,  490, 1784,  346,  396,  781,  451,   49,  346,  346,
      346,  346,  346,  346,  347,  348,  348,  348,  348,  348,
      348,  362,  779,   49,   49,  349, 1183, 1784, 1784,  534,
      349,  349,  349,  349,  349,  349,  258,  350,  350,  350,

      350,  350,  350,  350,  351,  351,  351,  351,  351,  351,
      351,  273,  783, 1784,   49,  351,   49,  795, 1088, 1784,
      351,  351,  351,  351,  351,  351,  353,  354,  354,  354,
      354,  354,  354,  354,  466,   49,  803,  809,  355, 1321,
     1447,  621,  468,  355,  355,  355,  355,  355,  355,  358,
      355,  355,  355,  355,  355,  355,  355,  362,  363,  363,
      363,  363,  363,  363,  363,  364,  621, 1353, 1356,  365,
     1359,  366,   49,  544,  365,  365,  365,  365,  365,  365,
      523,  523,  523,  523,  523,  523,  523,  545,  786, 1362,
     1365, 1447,  782,  544,  622,   49,  366,  273,  370,  370,

      370,  370,  370,  370,  370,  275,   49, 1784,  433,  371,
      451,   51,  545,  787,  371,  371,  371,  371,  371,  371,
      372,  373,  373,  373,  373,  373,  373,   49,   51,  451,
      864,  374, 1784,  433,  575,  777,  374,  374,  374,  374,
      374,  374,  419,  576,  420,   49,  421,  422,  553,  554,
      554,  554,  554,  554,  554,  864,  423,  661,  424,  425,
      661,  426,  428,  578,  429,  429,  429,  429,  429,  429,
      429,  662,  579, 1249, 1784,  429, 1784,  451,   51, 1353,
      429,  429,  429,  429,  429,  429,  430,  431,  431,  431,
      431,  431,  431,  431,  789,   51,  662,  451,  432, 1784,

      433, 1784,   49,  432,  432,  432,  432,  432,  432,  557,
      558,  558,  558,  558,  558,  558,  641,  642,  642,  642,
      642,  642,  642,  663,  785,  433,  434,  432,  432,  432,
      432,  432,  432,  432,  796,   49, 1784,  664,  432, 1356,
       51,   49,  663,  432,  432,  432,  432,  432,  432,  436,
      437,  437,  437,  437,  437,  437, 1784,   51,  886, 1784,
      438, 1784,  664,   51,  791,  438,  438,  438,  438,  438,
      438,  263,  439,  439,  439,  439,  439,  439,  439,   49,
       51, 1784,  451,  440, 1784, 1784, 1784,  876,  440,  440,
      440,  440,  440,  440,   49,  440,  440,  440,  440,  440,

      440,  440,  443,  444,  444,  444,  444,  444,  444, 1784,
     1784, 1784, 1784,  445, 1359,  451,   51,  794,  445,  445,
      445,  445,  445,  445,  449,  450,  450,  450,  450,  450,
      450,  451,   49,   51, 1784,  452, 1362, 1784,  882,   51,
      452,  452,  452,  452,  452,  452,  362,  455,  455,  455,
      455,  455,  455,  455,  364,  451,   51, 1365,  456,  883,
       51,   51,   51,  456,  456,  456,  456,  456,  456,  457,
      458,  458,  458,  458,  458,  458,  451,   51,   51,   51,
      459,  884,  890,   51,  895,  459,  459,  459,  459,  459,
      459,  273,  464,  464,  464,  464,  464,  464,  464,  275,

       51,  451,  949,  465, 1784,   49,   51,  894,  465,  465,
      465,  465,  465,  465,  466,  467,  467,  467,  467,  467,
      467,  467,  468,   51,  897, 1313,  469,  949,  470, 1784,
       49,  469,  469,  469,  469,  469,  469,  649,  650,  650,
      650,  650,  650,  650,  653,  654,  654,  654,  654,  654,
      654,  692,  790,  470,  480, 1079,  695, 1784,  481, 1784,
      693,  482,   49,  735,  483,  696,  484,  485,  486,  487,
      520,  520,  520,  520,  520,  520,  520,  736, 1315, 1784,
     1079,  520, 1784,   51, 1784,  792,  520,  520,  520,  520,
      520,  520,  521,  522,  522,  522,  522,  522,  522,  793,

       51,   49,  736,  523, 1784,  900, 1784, 1784,  523,  523,
      523,  523,  523,  523,  430,  524,  524,  524,  524,  524,
      524,  524,  525,  525,  525,  525,  525,  525,  525,  539,
     1086, 1784, 1784,  525, 1321,   51, 1319,  722,  525,  525,
      525,  525,  525,  525,  435,  527,  527,  527,  527,  527,
      527,  527,   51,  735,  744,  744,  528,  746,  261,  746,
      802,  528,  528,  528,  528,  528,  528, 1784,  745, 1784,
       49,  747,  775, 1784,  755,  756,  756,  756,  756,  756,
      756,   49, 1531,  261,  528,  528,  528,  528,  528,  528,
      528, 1784, 1784,  745, 1784,  528,  747,   51, 1784,  797,

      528,  528,  528,  528,  528,  528,  529,  529,  529,  529,
      529,  529,  529,   49,   51, 1447, 1784,  530, 1447,  451,
     1784, 1784,  530,  530,  530,  530,  530,  530,   49,  530,
      530,  530,  530,  530,  530,  530,  362,  533,  533,  533,
      533,  533,  533,  533,  534, 1784, 1784, 1375,  535, 1139,
      366, 1380, 1382,  535,  535,  535,  535,  535,  535,  758,
      759,  759,  759,  759,  759,  759,  762,  763,  763,  763,
      763,  763,  763,  798,   51,  366,  539,  540,  540,  540,
      540,  540,  540,  540,  541,  799,  801,   49,  542, 1148,
      543,   51, 1388,  542,  542,  542,  542,  542,  542,   49,

       49,  829,  830,  830,  830,  830,  830,  830,  837,  838,
      838,  838,  838,  838,  838,  543,  362,  546,  546,  546,
      546,  546,  546,  546,  534, 1164, 1390, 1159,  547, 1784,
     1176,   51,   51,  547,  547,  547,  547,  547,  547,  548,
      549,  549,  549,  549,  549,  549,  549,  550,   51,   51,
     1164,  551,  901,  552, 1784, 1176,  551,  551,  551,  551,
      551,  551,  841,  842,  842,  842,  842,  842,  842,  849,
      850,  850,  850,  850,  850,  850,  865,   51,  552,  466,
      559,  559,  559,  559,  559,  559,  559,  468, 1396, 1398,
      866,  560, 1171,   51,   51,   51,  560,  560,  560,  560,

      560,  560,  561,  562,  562,  562,  562,  562,  562,  548,
       51,  877,   51,  563,  865,  866, 1404,  725,  563,  563,
      563,  563,  563,  563,  581,  582,  583,  878, 1784,  584,
      585,  887, 1406,  586,  587,  804,  588,  867,  589, 1183,
      590,  616,  867,  617,  617,  617,  617,  617,  617,  617,
     1784,  868,   51, 1784,  617, 1784, 1784,   51,  806,  617,
      617,  617,  617,  617,  617,  618,  619,  619,  619,  619,
      619,  619,  619, 1321,   51, 1784,  868,  620, 1455,  621,
     1784, 1784,  620,  620,  620,  620,  620,  620,  852,  853,
      853,  853,  853,  853,  853,  856,  857,  857,  857,  857,

      857,  857,   51,   51,  621,  618,  620,  620,  620,  620,
      620,  620,  620,  667, 1312, 1249, 1784,  620, 1784,   51,
       51,  669,  620,  620,  620,  620,  620,  620,  435,  623,
      623,  623,  623,  623,  623,  623,  879,  881, 1502, 1312,
      624, 1784, 1784, 1784, 1784,  624,  624,  624,  624,  624,
      624,   49,  624,  624,  624,  624,  624,  624,  624,  625,
      625,  625,  625,  625,  625,  625,  730, 1784, 1504, 1784,
      626, 1784, 1784, 1387,  913,  626,  626,  626,  626,  626,
      626,   49,  626,  626,  626,  626,  626,  626,  626,  629,
      630,  630,  630,  630,  630,  630, 1784, 1784, 1387, 1395,

      631, 1544, 1548,   51,   51,  631,  631,  631,  631,  631,
      631,  362,  455,  455,  455,  455,  455,  455,  455,  534,
       51,   51, 1552,  456, 1395,   51,  977,  929,  456,  456,
      456,  456,  456,  456,  632,  633,  633,  633,  633,  633,
      633,  930,   51, 1403, 1784,  634, 1556,  978,   51, 1560,
      634,  634,  634,  634,  634,  634,  638,  639,  639,  639,
      639,  639,  639,  451, 1501,   51,  930,  640, 1403, 1784,
      979,   51,  640,  640,  640,  640,  640,  640,  539,  643,
      643,  643,  643,  643,  643,  643,  541, 1593,   51, 1501,
      644, 1615,   51,  981,   51,  644,  644,  644,  644,  644,

      644,  645,  646,  646,  646,  646,  646,  646,  451,   51,
     1159,   51,  647,  451,  983,   51,  984,  647,  647,  647,
      647,  647,  647,  548,  655,  655,  655,  655,  655,  655,
      655,  550,   51,  990, 1547,  656, 1359,   51,   51,   51,
      656,  656,  656,  656,  656,  656,  657,  658,  658,  658,
      658,  658,  658,  451,   51,   51,   51,  659,  986, 1547,
       51,  991,  659,  659,  659,  659,  659,  659,  466,  665,
      665,  665,  665,  665,  665,  665,  468,   51,  933, 1155,
      666, 1153,  996,   51,   51,  666,  666,  666,  666,  666,
      666,  667,  668,  668,  668,  668,  668,  668,  668,  669,

       51,   51, 1110,  670,   51,  671,  999,   51,  670,  670,
      670,  670,  670,  670,  756,  756,  756,  756,  756,  756,
      756,   51,   51, 1148,   51,  451,   51,   51,   51,   51,
      671,  710,  710,  710,  710,  710,  710,  710,  889,   51,
      888, 1551,  710,   51,   51,   51,   51,  710,  710,  710,
      710,  710,  710,  711,  711,  711,  711,  711,  711,  711,
      980,  985,  893,  899,  711, 1356, 1551, 1555, 1559,  711,
      711,  711,  711,  711,  711,  618,  712,  712,  712,  712,
      712,  712,  712,  713,  713,  713,  713,  713,  713,  713,
      739,  924, 1555, 1559,  713,   51,   51,   51,  916,  713,

      713,  713,  713,  713,  713,  715,  715,  715,  715,  715,
      715,  715,   51,   51,   51, 1144,  716, 1096, 1000, 1614,
      994,  716,  716,  716,  716,  716,  716,   49,  716,  716,
      716,  716,  716,  716,  716,  717,  717,  717,  717,  717,
      717,  717,  750, 1139, 1614,  451,  718, 1353,  451, 1251,
      919,  718,  718,  718,  718,  718,  718,   49,  718,  718,
      718,  718,  718,  718,  718,  539,  721,  721,  721,  721,
      721,  721,  721,  722,   51,   51,   51,  723, 1372,  543,
       51,  929,  723,  723,  723,  723,  723,  723,  871, 1232,
     1365,   51,   51,   51, 1362, 1784,  873,   51,   51,   51,

     1109,  891,  892,  880,  543,  548,  724,  724,  724,  724,
      724,  724,  724,  725,   51,   51,   51,  726,   51,  552,
     1784,  924,  726,  726,  726,  726,  726,  726,  885, 1123,
     1359,   51,  982, 1638, 1356,   51, 1639, 1353,   51, 1232,
     1100,  896,  938,   51,  552,  730,  731,  731,  731,  731,
      731,  731,  731,  732,   51,   51,  939,  733, 1638,  734,
       51, 1639,  733,  733,  733,  733,  733,  733,  902,  898,
     1640,   51,  907,  907,  907,  907,  907,  907,  907, 1086,
      938,  939,  940,  338,  734,  539,  737,  737,  737,  737,
      737,  737,  737,  722, 1784, 1640,  941,  738, 1321, 1088,

       51,  871,  738,  738,  738,  738,  738,  738,  739,  740,
      740,  740,  740,  740,  740,  740,  741,   51,  940, 1784,
      742,  941,  743,  933,   51,  742,  742,  742,  742,  742,
      742, 1126, 1784,  850,  850,  850,  850,  850,  850,  850,
     1116,   51, 1082, 1080,   51,  950,   51,  743,  548,  748,
      748,  748,  748,  748,  748,  748,  725, 1784,  989,  951,
      749,   51, 1103,   51, 1185,  749,  749,  749,  749,  749,
      749,  750,  751,  751,  751,  751,  751,  751,  751,  752,
       51,  950,  952,  753,  951,  754,  952,  451,  753,  753,
      753,  753,  753,  753, 1132, 1784,  953,   51, 1173, 1641,

     1784,  962,  963,  963,  963,  963,  963,  963,  992,   51,
      754,  667,  764,  764,  764,  764,  764,  764,  764,  669,
     1784,  953,  451,  765, 1641, 1784,   51,   51,  765,  765,
      765,  765,  765,  765,  766,  767,  767,  767,  767,  767,
      767,  987, 1129, 1161,   51,  768,  451,   51,   51,   51,
      768,  768,  768,  768,  768,  768,   49,   49,   49,   49,
       49,   49,   49, 1001,   51,   51,   51,   49,   51, 1105,
     1108,   51,   49,   49,   49,   49,   49,   49,  965,  966,
      966,  966,  966,  966,  966,   51, 1126, 1080,   51, 1080,
      770,  804, 1082,  805,  805,  805,  805,  805,  805,  805,

      997, 1081,  998, 1784,  805, 1150, 1083,   51,   51,  805,
      805,  805,  805,  805,  805,  806,  807,  807,  807,  807,
      807,  807,  807,  451,   51,   51, 1081,  807, 1784, 1113,
     1114, 1083,  807,  807,  807,  807,  807,  807,  712,  712,
      712,  712,  712,  712,  712,  969,  970,  970,  970,  970,
      970,  970,   51,   51,   51, 1028, 1029, 1029, 1029, 1029,
     1029, 1029, 1036, 1037, 1037, 1037, 1037, 1037, 1037,   51,
       51,   51,   49,  713,  713,  713,  713,  713,  713,  713,
      988, 1123, 1141,  451,  713, 1091, 1095, 1642, 1661,  713,
      713,  713,  713,  713,  713,  808,  350,  350,  350,  350,

      350,  350,  350,  263,  810,  810,  810,  810,  810,  810,
      810,  944, 1642, 1661, 1251,  811, 1667,  451, 1232, 1129,
      811,  811,  811,  811,  811,  811,   49,  811,  811,  811,
      811,  811,  811,  811,  814,  815,  815,  815,  815,  815,
      815, 1667, 1132, 1129, 1126,  816, 1123, 1232,   51,   51,
      816,  816,  816,  816,  816,  816,  539,  643,  643,  643,
      643,  643,  643,  643,  722,   51,   51, 1088,  644,  873,
       51,   51, 1082,  644,  644,  644,  644,  644,  644,  817,
      818,  818,  818,  818,  818,  818, 1784,   51,   51,  956,
      819, 1185, 1209,   51, 1106,  819,  819,  819,  819,  819,

      819,  548,  655,  655,  655,  655,  655,  655,  655,  725,
       51, 1784, 1132,  656,   51,   51,   51,   51,  656,  656,
      656,  656,  656,  656,  820,  821,  821,  821,  821,  821,
      821,   51,   51,   51,   51,  822, 1212,  750, 1213, 1102,
      822,  822,  822,  822,  822,  822,  826,  827,  827,  827,
      827,  827,  827,  451, 1211,  952,  950,  828,  944, 1173,
       51, 1129,  828,  828,  828,  828,  828,  828,  730,  831,
      831,  831,  831,  831,  831,  831,  732,   51, 1215,  739,
      832,  940,   51,   51,   51,  832,  832,  832,  832,  832,
      832,  833,  834,  834,  834,  834,  834,  834,  451,   51,

       51,   51,  835, 1218, 1217,   51, 1222,  835,  835,  835,
      835,  835,  835,  739,  843,  843,  843,  843,  843,  843,
      843,  741,   51, 1220,  938,  844,  933,   51,   51,   51,
      844,  844,  844,  844,  844,  844,  845,  846,  846,  846,
      846,  846,  846,  451,   51,   51,   51,  847, 1225, 1229,
       51, 1161,  847,  847,  847,  847,  847,  847,  750,  858,
      858,  858,  858,  858,  858,  858,  752,   51, 1324, 1126,
      859,  730,   51,   51,  929,  859,  859,  859,  859,  859,
      859,  860,  861,  861,  861,  861,  861,  861,  451,   51,
       51, 1325,  862,  924, 1150,   51, 1123,  862,  862,  862,

      862,  862,  862,  667,  869,  869,  869,  869,  869,  869,
      869,  669,   51, 1326, 1327,  870, 1141, 1024, 1009, 1132,
      870,  870,  870,  870,  870,  870,  871,  872,  872,  872,
      872,  872,  872,  872,  873,   51,   51, 1144,  874, 1129,
      875,  956, 1126,  874,  874,  874,  874,  874,  874, 1132,
       51, 1145,   51,   51, 1040, 1041, 1041, 1041, 1041, 1041,
     1041,  993,  995,   51, 1144,  875,   51,   51,  903,  903,
      903,  903,  903,  903,  903, 1123, 1145, 1121, 1784,  903,
       51, 1097, 1092,   51,  903,  903,  903,  903,  903,  903,
      904,  904,  904,  904,  904,  904,  904, 1009, 1098,  871,

     1088,  904,   51, 1784,   51,   51,  904,  904,  904,  904,
      904,  904,  905,  906,  906,  906,  906,  906,  906,   51,
      873,   51,   51,  907,  667,  867,   51, 1107,  907,  907,
      907,  907,  907,  907,  263,  908,  908,  908,  908,  908,
      908,  908, 1328,   51,  865,  958,  909,  919, 1330,  946,
      916,  909,  909,  909,  909,  909,  909,   49,  909,  909,
      909,  909,  909,  909,  909,  730,  912,  912,  912,  912,
      912,  912,  912,  913,  935,  913,  926,  914, 1024,  734,
     1009,  919,  914,  914,  914,  914,  914,  914, 1048, 1049,
     1049, 1049, 1049, 1049, 1049, 1051, 1052, 1052, 1052, 1052,

     1052, 1052,  916,   51,  734,  739,  915,  915,  915,  915,
      915,  915,  915,  916,  913, 1009,  873,  917,  669,  743,
       51,  750,  917,  917,  917,  917,  917,  917, 1055, 1056,
     1056, 1056, 1056, 1056, 1056, 1064, 1065, 1065, 1065, 1065,
     1065, 1065,  958,   51,  743,  750,  918,  918,  918,  918,
      918,  918,  918,  919,  919,  548,  746,  920,  744,  754,
       51,  739,  920,  920,  920,  920,  920,  920, 1067, 1068,
     1068, 1068, 1068, 1068, 1068, 1071, 1072, 1072, 1072, 1072,
     1072, 1072, 1153,   51,  754,  924,  925,  925,  925,  925,
      925,  925,  925,  926,  946,  916, 1154,  927,  539,  928,

       51,   51,  927,  927,  927,  927,  927,  927,  963,  963,
      963,  963,  963,  963,  963, 1093, 1094,  735,   51,   51,
      730, 1154,   51,   51,  928,  730,  931,  931,  931,  931,
      931,  931,  931,  913, 1099,  935,   51,  932,  913,   51,
       51,   51,  932,  932,  932,  932,  932,  932,  933,  934,
      934,  934,  934,  934,  934,  934,  935, 1101,   51,   51,
      936,   51,  937, 1153,   51,  936,  936,  936,  936,  936,
      936, 1104,  926,  923, 1086, 1139,   51, 1784,   51,  825,
     1344,   51, 1088, 1353,   51, 1155,   51,  937,  739,  942,
      942,  942,  942,  942,  942,  942,  916, 1112, 1115, 1156,

      943,   51, 1784,   51,   51,  943,  943,  943,  943,  943,
      943,  944,  945,  945,  945,  945,  945,  945,  945,  946,
     1208,   51, 1155,  947, 1156,  948,  813,   51,  947,  947,
      947,  947,  947,  947, 1111,  919, 1784, 1049, 1049, 1049,
     1049, 1049, 1049, 1049,   51,  916, 1165,   51, 1165, 1342,
      948,  750,  954,  954,  954,  954,  954,  954,  954,  919,
     1166, 1784, 1784,  955,   51,  913,   51, 1510,  955,  955,
      955,  955,  955,  955,  956,  957,  957,  957,  957,  957,
      957,  957,  958,   51, 1167, 1166,  959, 1784,  960, 1167,
      911,  959,  959,  959,  959,  959,  959, 1207, 1168,  813,

      667,  873,  669, 1784, 1065, 1065, 1065, 1065, 1065, 1065,
     1065, 1177,  466,  960,  871,  971,  971,  971,  971,  971,
      971,  971,  873, 1168,  663, 1178,  972,  661, 1784,   51,
     1177,  972,  972,  972,  972,  972,  972,  973,  974,  974,
      974,  974,  974,  974, 1784,  752,   51,  725,  975,  741,
     1178,   51,  722,  975,  975,  975,  975,  975,  975,   51,
     1210, 1002, 1002, 1002, 1002, 1002, 1002, 1002,   51, 1784,
      732, 1511, 1002,   51,   51,   51,   51, 1002, 1002, 1002,
     1002, 1002, 1002, 1003, 1003, 1003, 1003, 1003, 1003, 1003,
       51,   51,   51,  825, 1003,  813, 1345, 1347, 1332, 1003,

     1003, 1003, 1003, 1003, 1003,  622, 1004, 1004, 1004, 1004,
     1004, 1004, 1004, 1148, 1179, 1179,  725, 1005,  722,  433,
      813, 1356, 1005, 1005, 1005, 1005, 1005, 1005, 1180, 1784,
     1189, 1190, 1190, 1190, 1190, 1190, 1190, 1192, 1193, 1193,
     1193, 1193, 1193, 1193,  433, 1005, 1005, 1005, 1005, 1005,
     1005, 1005,   49, 1180, 1784,   49, 1005,   49,   51,   51,
       51, 1005, 1005, 1005, 1005, 1005, 1005,  263, 1006, 1006,
     1006, 1006, 1006, 1006, 1006,   51,   51,   51,  800, 1007,
     1425, 1435, 1445,   49, 1007, 1007, 1007, 1007, 1007, 1007,
       49, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1010, 1011,

     1011, 1011, 1011, 1011, 1011,   49,  778,  669,  468, 1012,
      548,  752,   51,   51, 1012, 1012, 1012, 1012, 1012, 1012,
      730,  831,  831,  831,  831,  831,  831,  831,  913,   51,
       51,  725,  832,  362,  544,   51, 1313,  832,  832,  832,
      832,  832,  832, 1013, 1014, 1014, 1014, 1014, 1014, 1014,
     1314, 1442,   51, 1432, 1015,  539,  741,   51,  722, 1015,
     1015, 1015, 1015, 1015, 1015,  739,  843,  843,  843,  843,
      843,  843,  843,  916,   51, 1314, 1512,  844, 1513,   51,
       51, 1313,  844,  844,  844,  844,  844,  844, 1016, 1017,
     1017, 1017, 1017, 1017, 1017, 1784,   51,   51,  732, 1018,

      729, 1516,   51,  637, 1018, 1018, 1018, 1018, 1018, 1018,
      750,  858,  858,  858,  858,  858,  858,  858,  919,   51,
     1784,  628,  859, 1517,   51,   51, 1315,  859,  859,  859,
      859,  859,  859, 1019, 1020, 1020, 1020, 1020, 1020, 1020,
     1316,   51,   51,  725, 1021,  722, 1521, 1518,  720, 1021,
     1021, 1021, 1021, 1021, 1021, 1025, 1026, 1026, 1026, 1026,
     1026, 1026,  451,  628,  618, 1316, 1027,  616,  709,   51,
       51, 1027, 1027, 1027, 1027, 1027, 1027,  924, 1030, 1030,
     1030, 1030, 1030, 1030, 1030,  926,   51,   51, 1524, 1031,
      708,   51, 1526,   51, 1031, 1031, 1031, 1031, 1031, 1031,

     1032, 1033, 1033, 1033, 1033, 1033, 1033,  451,   51,  707,
       51, 1034, 1529,  706,   51,   51, 1034, 1034, 1034, 1034,
     1034, 1034,  933, 1042, 1042, 1042, 1042, 1042, 1042, 1042,
      935,   51,   51,  705, 1043,  704, 1591,   51,   51, 1043,
     1043, 1043, 1043, 1043, 1043, 1044, 1045, 1045, 1045, 1045,
     1045, 1045,  451, 1575,   51,   51, 1046, 1590,  703,  702,
       51, 1046, 1046, 1046, 1046, 1046, 1046,  944, 1057, 1057,
     1057, 1057, 1057, 1057, 1057,  946, 1583,   51, 1585, 1058,
      701,   51,   51,   51, 1058, 1058, 1058, 1058, 1058, 1058,
     1059, 1060, 1060, 1060, 1060, 1060, 1060,  451,   51,   51,

       51, 1061,  700,  699,   51, 1619, 1061, 1061, 1061, 1061,
     1061, 1061,  956, 1073, 1073, 1073, 1073, 1073, 1073, 1073,
      958,   51,  698,  697, 1074,  694,   51,  689,   51, 1074,
     1074, 1074, 1074, 1074, 1074, 1075, 1076, 1076, 1076, 1076,
     1076, 1076,  451,   51, 1624,   51, 1077,  688, 1627,   51,
       51, 1077, 1077, 1077, 1077, 1077, 1077,  871, 1084, 1084,
     1084, 1084, 1084, 1084, 1084,  873,   51,   51,  687, 1085,
      686, 1634,   51, 1630, 1085, 1085, 1085, 1085, 1085, 1085,
     1086, 1087, 1087, 1087, 1087, 1087, 1087, 1087, 1088,   51,
      685,  684, 1089,   51, 1090,   51,   51, 1089, 1089, 1089,

     1089, 1089, 1089, 1196, 1197, 1197, 1197, 1197, 1197, 1197,
       51,  683,   51,   51,  682,  681,  680,   51,   51, 1090,
       51,  622, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1214,
      679, 1223, 1224, 1118,   51,   51,  678,   51, 1118, 1118,
     1118, 1118, 1118, 1118,   49, 1118, 1118, 1118, 1118, 1118,
     1118, 1118,   51,  263, 1119, 1119, 1119, 1119, 1119, 1119,
     1119,  677,   51,  676,  675,  674,   51, 1315,   51,   51,
      924, 1122, 1122, 1122, 1122, 1122, 1122, 1122, 1123,   51,
       51, 1784, 1124,   51,  928,   51,  673, 1124, 1124, 1124,
     1124, 1124, 1124, 1221, 1204,  672, 1205,   51,  466, 1159,

      669,  468,   51,   51,   51,  462, 1784, 1359, 1206,  928,
      933, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1126,   51,
       51,   51, 1127,  550,  937,   51, 1375, 1127, 1127, 1127,
     1127, 1127, 1127, 1171, 1216, 1219, 1331, 1183, 1249, 1319,
     1376, 1362,   51, 1226,   51, 1365, 1447, 1321,  534,  937,
      944, 1128, 1128, 1128, 1128, 1128, 1128, 1128, 1129, 1227,
     1228,   51, 1130, 1659,  948, 1376,  541, 1130, 1130, 1130,
     1130, 1130, 1130, 1255, 1256, 1256, 1256, 1256, 1256, 1256,
     1261, 1262, 1262, 1262, 1262, 1262, 1262,  637,   51,  948,
      956, 1131, 1131, 1131, 1131, 1131, 1131, 1131, 1132,  628,

      534,  628, 1133,  622,  960,   51,  622, 1133, 1133, 1133,
     1133, 1133, 1133, 1265, 1266, 1266, 1266, 1266, 1266, 1266,
     1271, 1272, 1272, 1272, 1272, 1272, 1272,   51,   51,  960,
     1135, 1136, 1136, 1136, 1136, 1136, 1136, 1137,  615,  614,
      613, 1138,  612,  611,   51,   51, 1138, 1138, 1138, 1138,
     1138, 1138, 1139, 1140, 1140, 1140, 1140, 1140, 1140, 1140,
     1141,  610, 1337, 1333, 1142,  609, 1143,  608,  607, 1142,
     1142, 1142, 1142, 1142, 1142, 1274, 1275, 1275, 1275, 1275,
     1275, 1275, 1278, 1279, 1279, 1279, 1279, 1279, 1279,   51,
       51, 1143,  924, 1146, 1146, 1146, 1146, 1146, 1146, 1146,

     1123,  606,  605,  335, 1147,  235,   51,   51,   51, 1147,
     1147, 1147, 1147, 1147, 1147, 1148, 1149, 1149, 1149, 1149,
     1149, 1149, 1149, 1150, 1338,   51, 1343, 1151, 1648, 1152,
      604,  603, 1151, 1151, 1151, 1151, 1151, 1151, 1285, 1286,
     1286, 1286, 1286, 1286, 1286, 1288, 1289, 1289, 1289, 1289,
     1289, 1289, 1375,   51, 1152,  933, 1157, 1157, 1157, 1157,
     1157, 1157, 1157, 1126,  602,  601, 1784, 1158,  600,  599,
       51,   51, 1158, 1158, 1158, 1158, 1158, 1158, 1159, 1160,
     1160, 1160, 1160, 1160, 1160, 1160, 1161, 1339,   51,  598,
     1162, 1784, 1163, 1675,  597, 1162, 1162, 1162, 1162, 1162,

     1162, 1292, 1293, 1293, 1293, 1293, 1293, 1293, 1299, 1300,
     1300, 1300, 1300, 1300, 1300, 1380,   51, 1163,  944, 1169,
     1169, 1169, 1169, 1169, 1169, 1169, 1129,  596,  595, 1381,
     1170,  594,  593,   51, 1429, 1170, 1170, 1170, 1170, 1170,
     1170, 1171, 1172, 1172, 1172, 1172, 1172, 1172, 1172, 1173,
      592, 1430,  591, 1174, 1381, 1175,  580,  577, 1174, 1174,
     1174, 1174, 1174, 1174, 1302, 1303, 1303, 1303, 1303, 1303,
     1303, 1306, 1307, 1307, 1307, 1307, 1307, 1307, 1380,   51,
     1175,  956, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1132,
      574,  573, 1784, 1182,  572,  571,   51,   51, 1182, 1182,

     1182, 1182, 1182, 1182, 1183, 1184, 1184, 1184, 1184, 1184,
     1184, 1184, 1185,  570,   51, 1433, 1186, 1784, 1187, 1676,
      569, 1186, 1186, 1186, 1186, 1186, 1186, 1190, 1190, 1190,
     1190, 1190, 1190, 1190, 1367, 1368, 1368, 1368, 1368, 1368,
     1368, 1382,   51, 1187, 1086, 1198, 1198, 1198, 1198, 1198,
     1198, 1198, 1088,  568,  567, 1383, 1199,  566,   51,   51,
     1382, 1199, 1199, 1199, 1199, 1199, 1199, 1200, 1201, 1201,
     1201, 1201, 1201, 1201, 1784,   51, 1434,  565, 1202, 1673,
     1383,   51,  468, 1202, 1202, 1202, 1202, 1202, 1202,   51,
      622, 1230, 1230, 1230, 1230, 1230, 1230, 1230,   51, 1784,

      275, 1650, 1007,  451,  362,  550,   51, 1007, 1007, 1007,
     1007, 1007, 1007,   49, 1007, 1007, 1007, 1007, 1007, 1007,
     1007,   51,  263, 1119, 1119, 1119, 1119, 1119, 1119, 1119,
     1272, 1272, 1272, 1272, 1272, 1272, 1272, 1388,   51, 1233,
     1234, 1234, 1234, 1234, 1234, 1234, 1319,  534,  541,  451,
     1235, 1389,  538,   51, 1784, 1235, 1235, 1235, 1235, 1235,
     1235,  924, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1123,
       51,  448,  442, 1031,  534,   51, 1389, 1388, 1031, 1031,
     1031, 1031, 1031, 1031, 1236, 1237, 1237, 1237, 1237, 1237,
     1237, 1784,   51,  532,  442, 1238,  434,  428,   51,  519,

     1238, 1238, 1238, 1238, 1238, 1238,  933, 1042, 1042, 1042,
     1042, 1042, 1042, 1042, 1126,   51, 1784,  518, 1043,  517,
     1684,   51, 1390, 1043, 1043, 1043, 1043, 1043, 1043, 1239,
     1240, 1240, 1240, 1240, 1240, 1240, 1391,  516,   51,  515,
     1241, 1651,  514,   51,  513, 1241, 1241, 1241, 1241, 1241,
     1241,  944, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1129,
       51, 1391,  512, 1058,  511,   51,   51, 1390, 1058, 1058,
     1058, 1058, 1058, 1058, 1242, 1243, 1243, 1243, 1243, 1243,
     1243, 1784,   51,   51,  510, 1244, 1657, 1693,   51,  509,
     1244, 1244, 1244, 1244, 1244, 1244,  956, 1073, 1073, 1073,

     1073, 1073, 1073, 1073, 1132,   51, 1784,  508, 1074,   51,
       51,  507,   51, 1074, 1074, 1074, 1074, 1074, 1074, 1245,
     1246, 1246, 1246, 1246, 1246, 1246,   51,   51, 1694,   51,
     1247,  506,  505,  502, 1574, 1247, 1247, 1247, 1247, 1247,
     1247, 1249, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1251,
       51,   51, 1396, 1252,  501, 1253,  498,  497, 1252, 1252,
     1252, 1252, 1252, 1252,  496,  495, 1397,   51,   51, 1286,
     1286, 1286, 1286, 1286, 1286, 1286, 1396,   51, 1329, 1334,
     1253, 1139, 1257, 1257, 1257, 1257, 1257, 1257, 1257, 1141,
     1784, 1397,  494, 1258,   51,  115,  493,   51, 1258, 1258,

     1258, 1258, 1258, 1258, 1148, 1267, 1267, 1267, 1267, 1267,
     1267, 1267, 1150, 1436,   51, 1784, 1268,  492,  491, 1695,
       51, 1268, 1268, 1268, 1268, 1268, 1268, 1159, 1280, 1280,
     1280, 1280, 1280, 1280, 1280, 1161,  479,   51,  478, 1281,
      477,  476, 1696,   51, 1281, 1281, 1281, 1281, 1281, 1281,
     1171, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1173,  475,
       51,  474, 1295,  473,  472, 1697,   51, 1295, 1295, 1295,
     1295, 1295, 1295, 1183, 1308, 1308, 1308, 1308, 1308, 1308,
     1308, 1185,  471,   51,  273, 1309,  468,  275, 1699,   51,
     1309, 1309, 1309, 1309, 1309, 1309, 1086, 1317, 1317, 1317,

     1317, 1317, 1317, 1317, 1088,  451,   51,  364, 1318, 1706,
      448,  442,   51, 1318, 1318, 1318, 1318, 1318, 1318, 1319,
     1320, 1320, 1320, 1320, 1320, 1320, 1320, 1321,   51,   51,
       51, 1322,   51, 1323,   51,   51, 1322, 1322, 1322, 1322,
     1322, 1322, 1335, 1398,  442,   51,  435,   51,  435,   51,
      427,   51,   51,  418,  417,  414,  413, 1399, 1323, 1336,
       51, 1340,   51, 1341, 1523, 1346,   51,  622,  524,  524,
      524,  524,  524,  524,  524,  412,   51,   51, 1398,   51,
     1404,   51, 1399,   51, 1348, 1349, 1349, 1349, 1349, 1349,
     1349, 1350, 1784,   51, 1405, 1351, 1439, 1527,   51, 1437,

     1351, 1351, 1351, 1351, 1351, 1351, 1139, 1352, 1352, 1352,
     1352, 1352, 1352, 1352, 1353,  411, 1438, 1784, 1354, 1405,
     1143,   51, 1404, 1354, 1354, 1354, 1354, 1354, 1354, 1300,
     1300, 1300, 1300, 1300, 1300, 1300, 1784,  410,   51,  409,
      408, 1406, 1406, 1455,  407, 1143, 1148, 1355, 1355, 1355,
     1355, 1355, 1355, 1355, 1356, 1407, 1784, 1456, 1357,   51,
     1152, 1784,   51, 1357, 1357, 1357, 1357, 1357, 1357, 1412,
     1413, 1413, 1413, 1413, 1413, 1413,   51,  406,  405,   51,
     1407, 1784, 1456,  404,   51, 1152, 1159, 1358, 1358, 1358,
     1358, 1358, 1358, 1358, 1359, 1572, 1441,  403, 1360,  402,

     1163,   51,  401, 1360, 1360, 1360, 1360, 1360, 1360, 1415,
     1416, 1416, 1416, 1416, 1416, 1416, 1419, 1420, 1420, 1420,
     1420, 1420, 1420,  400,   51, 1163, 1171, 1361, 1361, 1361,
     1361, 1361, 1361, 1361, 1362,   51,   51,   51, 1363,   51,
     1175,   51,  399, 1363, 1363, 1363, 1363, 1363, 1363,  398,
     1426,  397,   51,   51,   51,  392,   51, 1710,  391,   51,
       51, 1714, 1431, 1428,   51, 1175, 1183, 1364, 1364, 1364,
     1364, 1364, 1364, 1364, 1365,   51,   51,   51, 1366,  390,
     1187,   51, 1455, 1366, 1366, 1366, 1366, 1366, 1366, 1427,
      389, 1440,   51,  388, 1443,  317, 1784,  387,  386,   51,

       51, 1502,   51, 1444,  385, 1187, 1249, 1369, 1369, 1369,
     1369, 1369, 1369, 1369, 1251, 1503,   51,   51, 1370,   51,
     1712, 1784, 1716, 1370, 1370, 1370, 1370, 1370, 1370, 1139,
     1377, 1377, 1377, 1377, 1377, 1377, 1377, 1353, 1618,  384,
     1503, 1378,  383,  382,   51,   51, 1378, 1378, 1378, 1378,
     1378, 1378, 1148, 1384, 1384, 1384, 1384, 1384, 1384, 1384,
     1356,   51,   51,  376, 1385,  275,  364,   51,  271, 1385,
     1385, 1385, 1385, 1385, 1385, 1159, 1392, 1392, 1392, 1392,
     1392, 1392, 1392, 1359,   51, 1718, 1719, 1393,  361, 1728,
       51,   51, 1393, 1393, 1393, 1393, 1393, 1393, 1171, 1400,

     1400, 1400, 1400, 1400, 1400, 1400, 1362,   51,   51,  268,
     1401,  357, 1736, 1737,   51, 1401, 1401, 1401, 1401, 1401,
     1401, 1183, 1408, 1408, 1408, 1408, 1408, 1408, 1408, 1365,
      262,   51,  256, 1409,  138,  345, 1742,   51, 1409, 1409,
     1409, 1409, 1409, 1409, 1319, 1421, 1421, 1421, 1421, 1421,
     1421, 1421, 1321,  344,   51,  343, 1422,  338, 1743,   51,
       51, 1422, 1422, 1422, 1422, 1422, 1422, 1249, 1446, 1446,
     1446, 1446, 1446, 1446, 1446, 1447,   51,   51,  317, 1448,
      337, 1253, 1746,  336, 1448, 1448, 1448, 1448, 1448, 1448,
     1461, 1462, 1462, 1462, 1462, 1462, 1462, 1466, 1467, 1467,

     1467, 1467, 1467, 1467, 1502,   51, 1253, 1139, 1257, 1257,
     1257, 1257, 1257, 1257, 1257, 1353,  335,  334, 1784, 1258,
      333,  332,   51,   51, 1258, 1258, 1258, 1258, 1258, 1258,
     1148, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1356, 1509,
       51,  331, 1268, 1784,  330,   51,   51, 1268, 1268, 1268,
     1268, 1268, 1268, 1159, 1280, 1280, 1280, 1280, 1280, 1280,
     1280, 1359,   51,   51,  329, 1281, 1749,  328,   51,  327,
     1281, 1281, 1281, 1281, 1281, 1281, 1171, 1294, 1294, 1294,
     1294, 1294, 1294, 1294, 1362,   51, 1750,  326, 1295,  325,
     1756,   51,   51, 1295, 1295, 1295, 1295, 1295, 1295, 1183,

     1308, 1308, 1308, 1308, 1308, 1308, 1308, 1365,   51,   51,
      324, 1309,  323,  320, 1764,   51, 1309, 1309, 1309, 1309,
     1309, 1309, 1249, 1457, 1457, 1457, 1457, 1457, 1457, 1457,
     1447,  319,   51,  318, 1458,  317,  316,  315,  314, 1458,
     1458, 1458, 1458, 1458, 1458, 1469, 1470, 1470, 1470, 1470,
     1470, 1470, 1475, 1476, 1476, 1476, 1476, 1476, 1476, 1478,
     1479, 1479, 1479, 1479, 1479, 1479, 1484, 1485, 1485, 1485,
     1485, 1485, 1485, 1487, 1488, 1488, 1488, 1488, 1488, 1488,
     1493, 1494, 1494, 1494, 1494, 1494, 1494, 1496, 1497, 1497,
     1497, 1497, 1497, 1497, 1413, 1413, 1413, 1413, 1413, 1413,

     1413, 1504, 1504,   51,   51,   51,   51,   51,   51,   51,
      313,  312,   51, 1544, 1544, 1505, 1784, 1548, 1548,   51,
       51,   51,   51,   51,   51,   51,   51, 1545, 1784,   51,
     1771, 1549, 1784, 1519, 1514, 1515,   51, 1522, 1528, 1520,
     1505, 1784, 1319, 1506, 1506, 1506, 1506, 1506, 1506, 1506,
     1321, 1525, 1545, 1784, 1507,  311, 1549, 1784,   51, 1507,
     1507, 1507, 1507, 1507, 1507, 1249, 1369, 1369, 1369, 1369,
     1369, 1369, 1369, 1447,  310,   51,  309, 1370, 1773,  308,
      307,  306, 1370, 1370, 1370, 1370, 1370, 1370, 1538, 1539,
     1539, 1539, 1539, 1539, 1539, 1467, 1467, 1467, 1467, 1467,

     1467, 1467, 1476, 1476, 1476, 1476, 1476, 1476, 1476, 1552,
     1552, 1485, 1485, 1485, 1485, 1485, 1485, 1485, 1556, 1556,
     1560, 1560,  305, 1553, 1784, 1494, 1494, 1494, 1494, 1494,
     1494, 1494, 1557, 1784, 1561, 1784, 1564, 1565, 1565, 1565,
     1565, 1565, 1565,  304,   51,   51,   51,  303, 1553, 1784,
     1567, 1568, 1568, 1568, 1568, 1568, 1568, 1557, 1784, 1561,
     1784,   51,   51,   51,   51,   51,   51,   51,   51,   51,
     1573,   51,   51, 1576,  302,  301, 1577,   51,   51,  300,
      299,   51,   51,   51,   51,   51,   51, 1593,   51,   51,
     1578, 1579, 1580, 1581,   51,   51, 1593, 1584, 1586, 1582,

      298, 1594,  297,  296,  295, 1587,  294, 1589,  293,  138,
     1784, 1588, 1595, 1596, 1596, 1596, 1596, 1596, 1596, 1599,
     1600, 1600, 1600, 1600, 1600, 1600, 1594, 1603, 1604, 1604,
     1604, 1604, 1604, 1604,  292, 1784, 1607, 1608, 1608, 1608,
     1608, 1608, 1608, 1611, 1612, 1612, 1612, 1612, 1612, 1612,
     1565, 1565, 1565, 1565, 1565, 1565, 1565, 1615, 1615,   51,
       51,   51,   51,   51,   51,   51,   51,   51,  291,   51,
       51, 1616, 1784,   51,   51,   51,   51,   51,   51,   51,
       51,   51,   51,   51,   51, 1620,   51,   51, 1628,  290,
       51,   51,   51, 1633, 1631, 1622, 1616, 1784, 1621, 1623,

     1625, 1658, 1705, 1626, 1649, 1629, 1632, 1635, 1636, 1636,
     1636, 1636, 1636, 1636, 1596, 1596, 1596, 1596, 1596, 1596,
     1596, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1604, 1604,
     1604, 1604, 1604, 1604, 1604, 1608, 1608, 1608, 1608, 1608,
     1608, 1608, 1612, 1612, 1612, 1612, 1612, 1612, 1612, 1644,
     1645, 1645, 1645, 1645, 1645, 1645,   51,   51,  289,   51,
       51,   51,   51,   51, 1636, 1636, 1636, 1636, 1636, 1636,
     1636,   51,  288,   51,   51, 1652,   51,   51,   51,   51,
       51, 1645, 1645, 1645, 1645, 1645, 1645, 1645,   51,   51,
     1647,   51, 1653,   51,   51, 1654, 1655, 1656, 1660,   51,

       51,   51,   51,  287,   51,   51,   51, 1668,   51,   51,
       51,   51,   51,  286,  285, 1669,   51,   51,   51,   51,
     1678,   51,   51,   51, 1671, 1670,   51,   51,   51,   51,
     1672, 1674, 1680, 1679,   51,   51,   51, 1677,  284,   51,
       51, 1683,   51,  283,   51,   51,   51, 1685,  282,  281,
     1686,   51,   51,   51,  280, 1688,   51,   51, 1689,   51,
     1700, 1687,  279,   51,   51, 1698, 1692,   51, 1690,   51,
       51, 1691,   51,   51,   51,   51,   51, 1701, 1702, 1703,
     1704,   51,   51,   51,   51,  278,   51,   51,   51,   51,
       51, 1707,   51,   51,  275,   51,   51, 1717, 1708,   51,

       51, 1709, 1721, 1711, 1713,   51,  263, 1715,   51, 1722,
       51, 1720,   51,   51,  268,   51,   51, 1727,   51,   51,
     1725, 1723, 1724, 1726,   51,   51,   51,   51, 1731,   51,
      255, 1729,   51,   51,  254,   51,   51,   51,  253,   51,
       51,   51, 1730,   51,  252, 1732,   51, 1734, 1739,   51,
     1738, 1733,  251,   51,   51, 1735,   51,   51,   51,   51,
     1740, 1741,   51,   51,   51,   51,   51,  250, 1744, 1745,
       51,   51, 1747,  249,  248,   51,   51,  247,   51,   51,
       51,   51,   51, 1748, 1751,   51,   51,  246,   51,   51,
     1752, 1753, 1755,   51, 1758,   51, 1757, 1754,  243, 1762,

       51, 1759,   51,   51, 1760,   51,   51,   51,   51,   51,
       51,   51,   51,  240,   51, 1761,   51,   51,   51, 1765,
       51,   51,   51, 1763,   51,   51,   51,   51,   51,   51,
     1766,   51,  237,   51, 1767,   51, 1775,   51,   51,   51,
       51, 1768, 1769, 1772,   51,   51, 1778, 1774,   51, 1770,
       51, 1776,   51,   51, 1777,  236,   51,   51,  235, 1779,
       51,  234,   51, 1782, 1783,   51,  231,   51,  230,   51,
       51,  229,  228,  227,  226, 1780,  225,   51,  224,  223,
      222, 1781,   42,  221,   42,   59,  220,   59,   59,   59,
       59,   59,   59,  147,  219,  147,  154,  154,  154,  267,

      267,  267,  276,  276,  276,  356,  356,  356,  359,  359,
      359,  360,  360,  360,  367,  367,  367,  365,  365,  365,
      371,  371,  371,  375,  218,  375,  441,  441,  441,  446,
      446,  446,  447,  447,  447,  456,  456,  456,  460,  217,
      460,  461,  461,  461,  369,  369,  216,  212,  369,  465,
      465,  465,  469,  469,  469,  359,  359,  359,  531,  531,
      531,  535,  535,  535,  536,  536,  536,  537,  537,  537,
      367,  367,  367,  542,  542,  542,  454,  454,  211,  201,
      454,  547,  547,  547,  551,  551,  551,  555,  200,  555,
      556,  556,  556,  560,  560,  560,  564,  199,  564,  627,

      627,  627,  456,  456,  456,  635,  635,  635,  636,  636,
      636,  644,  644,  644,  648,  194,  648,  651,  189,  651,
      652,  652,  652,  656,  656,  656,  660,  188,  660,  554,
      554,  187,  186,  554,  558,  558,  185,  184,  558,  666,
      666,  666,  670,  670,  670,  564,  564,  183,  564,  536,
      536,  536,  719,  719,  719,  723,  723,  723,  726,  726,
      726,  727,  727,  727,  728,  728,  728,  733,  733,  733,
      642,  642,  182,  181,  642,  738,  738,  738,  742,  742,
      742,  648,  648,  180,  648,  650,  650,  176,  175,  650,
      651,  651,  174,  651,  652,  652,  654,  654,  173,  172,

      654,  749,  749,  749,  753,  753,  753,  660,  660,  171,
      660,  757,  170,  757,  760,  169,  760,  761,  761,  761,
      765,  765,  765,  769,  168,  769,  812,  812,  812,  644,
      644,  644,  656,  656,  656,  823,  823,  823,  824,  824,
      824,  832,  832,  832,  836,  167,  836,  839,  166,  839,
      840,  840,  840,  844,  844,  844,  848,  165,  848,  851,
      164,  851,  854,  163,  854,  855,  855,  855,  859,  859,
      859,  863,  162,  863,  756,  161,  160,  756,  757,  757,
      155,  757,  759,  759,  146,  145,  759,  760,  760,  140,
      760,  761,  761,  763,  763,   55,   52,  763,  870,  870,

      870,  874,  874,  874,  769,  769,   43,  769,   49,   49,
       49,   41,   49,   49,  727,  727,  727,  910,  910,  910,
      914,  914,  914,  917,  917,  917,  920,  920,  920,  921,
      921,  921,  922,  922,  922,  927,  927,  927,  830,  830,
     1784, 1784,  830,  932,  932,  932,  936,  936,  936,  836,
      836, 1784,  836,  838,  838, 1784, 1784,  838,  839,  839,
     1784,  839,  840,  840,  842,  842, 1784, 1784,  842,  943,
      943,  943,  947,  947,  947,  848,  848, 1784,  848,  850,
     1784, 1784,  850,  851,  851, 1784,  851,  853,  853, 1784,
     1784,  853,  854,  854, 1784,  854,  855,  855,  857,  857,

     1784, 1784,  857,  955,  955,  955,  959,  959,  959,  863,
      863, 1784,  863,  961, 1784,  961,  964, 1784,  964,  967,
     1784,  967,  968,  968,  968,  972,  972,  972,  976, 1784,
      976,   49,   49,   49, 1784,   49,   49, 1008, 1008, 1008,
      832,  832,  832,  844,  844,  844,  859,  859,  859, 1022,
     1022, 1022, 1023, 1023, 1023, 1031, 1031, 1031, 1035, 1784,
     1035, 1038, 1784, 1038, 1039, 1039, 1039, 1043, 1043, 1043,
     1047, 1784, 1047, 1050, 1784, 1050, 1053, 1784, 1053, 1054,
     1054, 1054, 1058, 1058, 1058, 1062, 1784, 1062, 1063, 1784,
     1063, 1066, 1784, 1066, 1069, 1784, 1069, 1070, 1070, 1070,

     1074, 1074, 1074, 1078, 1784, 1078,  961, 1784,  961,  963,
     1784, 1784,  963,  964,  964, 1784,  964,  966,  966, 1784,
     1784,  966,  967,  967, 1784,  967,  968,  968,  970,  970,
     1784, 1784,  970, 1085, 1085, 1085, 1089, 1089, 1089,  976,
      976, 1784,  976,   49,   49,   49, 1784,   49,   49,  921,
      921,  921, 1120, 1120, 1120, 1124, 1124, 1124, 1127, 1127,
     1127, 1130, 1130, 1130, 1133, 1133, 1133, 1134, 1134, 1134,
     1142, 1142, 1142, 1029, 1029, 1784, 1784, 1029, 1147, 1147,
     1147, 1151, 1151, 1151, 1035, 1035, 1784, 1035, 1037, 1037,
     1784, 1784, 1037, 1038, 1038, 1784, 1038, 1039, 1039, 1041,

     1041, 1784, 1784, 1041, 1158, 1158, 1158, 1162, 1162, 1162,
     1047, 1047, 1784, 1047, 1049, 1784, 1784, 1049, 1050, 1050,
     1784, 1050, 1052, 1052, 1784, 1784, 1052, 1053, 1053, 1784,
     1053, 1054, 1054, 1056, 1056, 1784, 1784, 1056, 1170, 1170,
     1170, 1174, 1174, 1174, 1062, 1062, 1784, 1062, 1063, 1784,
     1063, 1065, 1784, 1784, 1065, 1066, 1066, 1784, 1066, 1068,
     1068, 1784, 1784, 1068, 1069, 1069, 1784, 1069, 1070, 1070,
     1072, 1072, 1784, 1784, 1072, 1182, 1182, 1182, 1186, 1186,
     1186, 1078, 1078, 1784, 1078, 1188, 1784, 1188, 1191, 1784,
     1191, 1194, 1784, 1194, 1195, 1195, 1195, 1199, 1199, 1199,

     1203, 1784, 1203,   49,   49,   49, 1784,   49,   49, 1231,
     1231, 1231, 1031, 1031, 1031, 1043, 1043, 1043, 1058, 1058,
     1058, 1074, 1074, 1074, 1248, 1248, 1248, 1254, 1254, 1254,
     1252, 1252, 1252, 1259, 1259, 1259, 1258, 1258, 1258, 1260,
     1784, 1260, 1263, 1784, 1263, 1264, 1264, 1264, 1269, 1269,
     1269, 1268, 1268, 1268, 1270, 1784, 1270, 1273, 1784, 1273,
     1276, 1784, 1276, 1277, 1277, 1277, 1282, 1282, 1282, 1281,
     1281, 1281, 1283, 1784, 1283, 1284, 1784, 1284, 1287, 1784,
     1287, 1290, 1784, 1290, 1291, 1291, 1291, 1296, 1296, 1296,
     1295, 1295, 1295, 1297, 1784, 1297, 1298, 1784, 1298, 1301,

     1784, 1301, 1304, 1784, 1304, 1305, 1305, 1305, 1310, 1310,
     1310, 1309, 1309, 1309, 1311, 1784, 1311, 1188, 1784, 1188,
     1190, 1784, 1784, 1190, 1191, 1191, 1784, 1191, 1193, 1193,
     1784, 1784, 1193, 1194, 1194, 1784, 1194, 1195, 1195, 1197,
     1197, 1784, 1784, 1197, 1318, 1318, 1318, 1322, 1322, 1322,
     1203, 1203, 1784, 1203,   49,   49,   49, 1784,   49,   49,
     1134, 1134, 1134, 1354, 1354, 1354, 1357, 1357, 1357, 1360,
     1360, 1360, 1363, 1363, 1363, 1366, 1366, 1366, 1371, 1371,
     1371, 1370, 1370, 1370, 1373, 1784, 1373, 1374, 1374, 1374,
     1256, 1256, 1784, 1784, 1256, 1378, 1378, 1378, 1379, 1379,

     1379, 1260, 1260, 1784, 1260, 1262, 1262, 1784, 1784, 1262,
     1263, 1263, 1784, 1263, 1264, 1264, 1266, 1266, 1784, 1784,
     1266, 1385, 1385, 1385, 1386, 1386, 1386, 1270, 1270, 1784,
     1270, 1272, 1784, 1784, 1272, 1273, 1273, 1784, 1273, 1275,
     1275, 1784, 1784, 1275, 1276, 1276, 1784, 1276, 1277, 1277,
     1279, 1279, 1784, 1784, 1279, 1393, 1393, 1393, 1394, 1394,
     1394, 1283, 1283, 1784, 1283, 1284, 1784, 1284, 1286, 1784,
     1784, 1286, 1287, 1287, 1784, 1287, 1289, 1289, 1784, 1784,
     1289, 1290, 1290, 1784, 1290, 1291, 1291, 1293, 1293, 1784,
     1784, 1293, 1401, 1401, 1401, 1402, 1402, 1402, 1297, 1297,

     1784, 1297, 1298, 1784, 1298, 1300, 1784, 1784, 1300, 1301,
     1301, 1784, 1301, 1303, 1303, 1784, 1784, 1303, 1304, 1304,
     1784, 1304, 1305, 1305, 1307, 1307, 1784, 1784, 1307, 1409,
     1409, 1409, 1410, 1410, 1410, 1311, 1311, 1784, 1311, 1411,
     1784, 1411, 1414, 1784, 1414, 1417, 1784, 1417, 1418, 1418,
     1418, 1423, 1784, 1423, 1422, 1422, 1422, 1424, 1784, 1424,
       49,   49,   49, 1784,   49,   49, 1449, 1784, 1449, 1448,
     1448, 1448, 1450, 1784, 1450, 1258, 1258, 1258, 1451, 1784,
     1451, 1268, 1268, 1268, 1452, 1784, 1452, 1281, 1281, 1281,
     1453, 1784, 1453, 1295, 1295, 1295, 1454, 1784, 1454, 1309,

     1309, 1309, 1368, 1368, 1784, 1784, 1368, 1458, 1458, 1458,
     1459, 1459, 1459,  367,  367,  367, 1373, 1373, 1784, 1373,
     1460, 1460, 1460, 1463, 1784, 1463, 1464, 1464, 1464, 1465,
     1465, 1465, 1468, 1784, 1468, 1471, 1784, 1471, 1472, 1472,
     1472, 1473, 1473, 1473, 1474, 1784, 1474, 1477, 1784, 1477,
     1480, 1784, 1480, 1481, 1481, 1481, 1482, 1482, 1482, 1483,
     1784, 1483, 1486, 1784, 1486, 1489, 1784, 1489, 1490, 1490,
     1490, 1491, 1491, 1491, 1492, 1784, 1492, 1495, 1784, 1495,
     1498, 1784, 1498, 1499, 1499, 1499, 1500, 1500, 1500, 1411,
     1784, 1411, 1413, 1784, 1784, 1413, 1414, 1414, 1784, 1414,

     1416, 1416, 1784, 1784, 1416, 1417, 1417, 1784, 1417, 1418,
     1418, 1420, 1420, 1784, 1784, 1420, 1507, 1507, 1507, 1508,
     1784, 1508, 1424, 1424, 1784, 1424,   49,   49,   49, 1784,
       49,   49, 1530, 1530, 1530, 1370, 1370, 1370, 1532, 1784,
     1532, 1533, 1784, 1533, 1534, 1784, 1534, 1535, 1784, 1535,
     1536, 1784, 1536, 1537, 1784, 1537, 1540, 1784, 1540, 1541,
     1541, 1541, 1542, 1542, 1542, 1543, 1784, 1543, 1462, 1462,
     1784, 1784, 1462, 1463, 1463, 1784, 1463, 1464, 1464, 1546,
     1784, 1546, 1467, 1784, 1784, 1467, 1468, 1468, 1784, 1468,
     1470, 1470, 1784, 1784, 1470, 1471, 1471, 1784, 1471, 1472,

     1472, 1550, 1784, 1550, 1474, 1784, 1474, 1476, 1784, 1784,
     1476, 1477, 1477, 1784, 1477, 1479, 1479, 1784, 1784, 1479,
     1480, 1480, 1784, 1480, 1481, 1481, 1554, 1784, 1554, 1483,
     1784, 1483, 1485, 1784, 1784, 1485, 1486, 1486, 1784, 1486,
     1488, 1488, 1784, 1784, 1488, 1489, 1489, 1784, 1489, 1490,
     1490, 1558, 1784, 1558, 1492, 1784, 1492, 1494, 1784, 1784,
     1494, 1495, 1495, 1784, 1495, 1497, 1497, 1784, 1784, 1497,
     1498, 1498, 1784, 1498, 1499, 1499, 1562, 1784, 1562, 1563,
     1784, 1563, 1566, 1784, 1566, 1569, 1784, 1569, 1570, 1570,
     1570, 1571, 1784, 1571,   49,   49,   49, 1784,   49,   49,

     1592, 1784, 1592, 1460, 1784, 1460, 1465, 1784, 1465, 1473,
     1784, 1473, 1482, 1784, 1482, 1491, 1784, 1491, 1500, 1784,
     1500, 1539, 1539, 1784, 1784, 1539, 1540, 1540, 1784, 1540,
     1541, 1541, 1531, 1784, 1531, 1597, 1784, 1597, 1598, 1784,
     1598, 1601, 1784, 1601, 1602, 1784, 1602, 1605, 1784, 1605,
     1606, 1784, 1606, 1609, 1784, 1609, 1610, 1784, 1610, 1613,
     1784, 1613, 1565, 1784, 1784, 1565, 1568, 1568, 1784, 1784,
     1568, 1617, 1784, 1617, 1542, 1784, 1542, 1637, 1784, 1637,
     1596, 1784, 1784, 1596, 1600, 1784, 1784, 1600, 1604, 1784,
     1784, 1604, 1608, 1784, 1784, 1608, 1612, 1784, 1784, 1612,

     1643, 1784, 1643, 1646, 1784, 1646, 1636, 1784, 1784, 1636,
     1662, 1784, 1662, 1663, 1784, 1663, 1664, 1784, 1664, 1665,
     1784, 1665, 1666, 1784, 1666, 1645, 1784, 1784, 1645, 1681,
     1784, 1681, 1682, 1784, 1682,    3, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784
    } ;

static const flex_int16_t yy_chk[7789] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   14,   14,   92,   11,   11,   11,   92,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   12,   16,   16,   20,   23,   20,

       20,   31,   23,  411,   20,   24,   24,   25,   23,   20,
       31,   23,   25,   20,   21,   20,   90,  411,   90,   12,
       17,   17,   17,   17,   17,   17,   17,   17,   21,   22,
       89, 1287,   26,   89,   17,   21,   26,   34,  101,   22,
       97,   34,   22,   27,  101,   27,   22,   93,   26,   34,
       27,   27,   93,   27,   34, 1290,   34,   27,  129,   17,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       29,   29,   97,   18, 1291,   36,  129,   36,   18,   18,
       18,   18,   18,   18,   28,   29, 1295,   28,   28,   29,
       28,   36,   28,   29,   28,   29,   28,   30,   36,   28,

       33,   30,   29,   32,  150,   33,   33,  102,   33,   33,
       30,   30,  102,   38,   30,   32,   30,   32,   35,   32,
       98,   38,   32,  133,   35,   38,   35,   38,   35,  150,
      124,  218,   35,  133,   35,   35,   44,   44,   44,   44,
       44,   44,   44,  124,  218,  105,   98,   44,  105,  248,
      105,   98,   44,   44,   44,   44,   44,   44,   45,   45,
       45,   45,   45,   45,   45,  158,  247,  586,  247,   45,
      263,  263,  248,  586,   45,   45,   45,   45,   45,   45,
       46,   46,   46,   46,   46,   46,   46,   46,  676,  336,
      158,  676,   46,   78,  336,  270,  348,   46,   46,   46,

       46,   46,   46,   48,   48,   48,   48,   48,   48,   48,
       48,   50,   50,   50,   50,   50,   50,   50,  373,   78,
      270,  348,   50,  435,  435,   78, 1296,   50,   50,   50,
       50,   50,   50,   52,   52,   52,   52,   52,   52,   52,
      622,  622,  675,  373,   52,  673,  673,  675,  437,   52,
       52,   52,   52,   52,   52,   58,   58,   58,   58,   58,
       58,   58,  131,  262,  262,  262,  262,  262,  262,  262,
      352,  131,  148,  437,  148,  148,  148,  148,  148,  148,
      148,  444,  450, 1297,  352,  148,  280,  280,  280,  280,
      148,  148,  148,  148,  148,  148,  149,  149,  149,  149,

      149,  149,  149,  149,  464,  280,  444,  450,  149,  352,
      149, 1301,  464,  149,  149,  149,  149,  149,  149,  273,
      273,  273,  273,  273,  273,  273,  358,  358,  358,  358,
      358,  358,  358,  368,  690,  149,  151,  151,  151,  151,
      151,  151,  151,  151,  458,  522,  674,  368,  151,  562,
      630,  690,  674,  151,  151,  151,  151,  151,  151,  152,
      152,  152,  152,  152,  152,  152,  152,  152, 1304,  458,
      522,  152,  368,  633,  562,  630,  152,  152,  152,  152,
      152,  152,  153,  153,  153,  153,  153,  153,  153,  153,
      155,  155,  155,  155,  155,  155,  155,  155,  633,  686,

      686,  155,  565,  565,  565,  565,  155,  155,  155,  155,
      155,  155,  157,  157,  157,  157,  157,  157,  157,  157,
      157,  369,  639,  682,  157,  394,  157,  682,  305,  157,
      157,  157,  157,  157,  157,  369,  305,  362,  362,  362,
      362,  362,  362,  362, 1305,  394,  408,  639,  305,  678,
     1309,  157,  256,  256,  256,  256,  256,  256,  256,  408,
      369,  394,  646,  256,  305,  683, 1310,  678,  256,  256,
      256,  256,  256,  256,  258,  258,  258,  258,  258,  258,
      258,  546,  681,  683,  681,  258, 1311,  646,  658,  546,
      258,  258,  258,  258,  258,  258,  259,  259,  259,  259,

      259,  259,  259,  259,  261,  261,  261,  261,  261,  261,
      261,  556,  685,  658,  685,  261,  696,  696, 1318,  556,
      261,  261,  261,  261,  261,  261,  264,  264,  264,  264,
      264,  264,  264,  264,  665,  707,  707,  716,  264, 1322,
     1351,  714,  665,  264,  264,  264,  264,  264,  264,  266,
      266,  266,  266,  266,  266,  266,  266,  269,  269,  269,
      269,  269,  269,  269,  269,  269,  714, 1354, 1357,  269,
     1360,  269,  716,  453,  269,  269,  269,  269,  269,  269,
      434,  434,  434,  434,  434,  434,  434,  453,  688, 1363,
     1366, 1370,  684,  454,  526,  688,  269,  274,  274,  274,

      274,  274,  274,  274,  274,  274,  684,  454,  526,  274,
     1371,  770,  453,  689,  274,  274,  274,  274,  274,  274,
      275,  275,  275,  275,  275,  275,  275,  689,  770, 1372,
      755,  275,  454,  526,  484,  679,  275,  275,  275,  275,
      275,  275,  341,  484,  341,  679,  341,  341,  462,  462,
      462,  462,  462,  462,  462,  755,  341,  553,  341,  341,
      554,  341,  346,  486,  346,  346,  346,  346,  346,  346,
      346,  553,  486, 1373,  554,  346,  767, 1374,  772, 1378,
      346,  346,  346,  346,  346,  346,  347,  347,  347,  347,
      347,  347,  347,  347,  691,  772,  553, 1379,  347,  554,

      347,  767,  691,  347,  347,  347,  347,  347,  347,  466,
      466,  466,  466,  466,  466,  466,  539,  539,  539,  539,
      539,  539,  539,  557,  687,  347,  349,  349,  349,  349,
      349,  349,  349,  349,  697,  687,  815,  557,  349, 1385,
      782,  697,  558,  349,  349,  349,  349,  349,  349,  353,
      353,  353,  353,  353,  353,  353,  558,  782,  782,  818,
      353,  815,  557,  771,  693,  353,  353,  353,  353,  353,
      353,  354,  354,  354,  354,  354,  354,  354,  354,  693,
      771,  558, 1386,  354,  818,  821,  827,  771,  354,  354,
      354,  354,  354,  354,  355,  355,  355,  355,  355,  355,

      355,  355,  357,  357,  357,  357,  357,  357,  357,  834,
      821,  827,  846,  357, 1393, 1394,  778,  695,  357,  357,
      357,  357,  357,  357,  361,  361,  361,  361,  361,  361,
      361,  361,  695,  778,  834,  361, 1401,  846,  778,  779,
      361,  361,  361,  361,  361,  361,  363,  363,  363,  363,
      363,  363,  363,  363,  363, 1402,  779, 1409,  363,  779,
      786,  780,  791,  363,  363,  363,  363,  363,  363,  364,
      364,  364,  364,  364,  364,  364,  364,  786,  780,  791,
      364,  780,  786,  790,  791,  364,  364,  364,  364,  364,
      364,  370,  370,  370,  370,  370,  370,  370,  370,  370,

      790, 1410,  849,  370,  861,  906,  793,  790,  370,  370,
      370,  370,  370,  370,  372,  372,  372,  372,  372,  372,
      372,  372,  372,  793,  793, 1414,  372,  849,  372,  861,
      906,  372,  372,  372,  372,  372,  372,  544,  544,  544,
      544,  544,  544,  544,  548,  548,  548,  548,  548,  548,
      548,  587,  692,  372,  393,  962,  589,  974,  393, 1011,
      587,  393,  692,  641,  393,  589,  393,  393,  393,  393,
      428,  428,  428,  428,  428,  428,  428,  641, 1417, 1014,
      962,  428,  974,  796, 1011,  694,  428,  428,  428,  428,
      428,  428,  430,  430,  430,  430,  430,  430,  430,  694,

      796,  694,  641,  430, 1014,  796, 1017, 1020,  430,  430,
      430,  430,  430,  430,  431,  431,  431,  431,  431,  431,
      431,  431,  433,  433,  433,  433,  433,  433,  433,  737,
     1418, 1017, 1020,  433, 1422,  797, 1424,  737,  433,  433,
      433,  433,  433,  433,  436,  436,  436,  436,  436,  436,
      436,  436,  797,  642,  649,  650,  436,  653,  436,  654,
      706,  436,  436,  436,  436,  436,  436,  642,  649,  650,
      706,  653,  677,  654,  661,  661,  661,  661,  661,  661,
      661,  677, 1447,  436,  438,  438,  438,  438,  438,  438,
      438, 1026,  642,  649,  650,  438,  653,  798,  654,  698,

      438,  438,  438,  438,  438,  438,  439,  439,  439,  439,
      439,  439,  439,  698,  798, 1448, 1026,  439, 1458, 1459,
     1033, 1045,  439,  439,  439,  439,  439,  439,  440,  440,
      440,  440,  440,  440,  440,  440,  443,  443,  443,  443,
      443,  443,  443,  443,  443, 1033, 1045, 1463,  443, 1464,
      443, 1468, 1471,  443,  443,  443,  443,  443,  443,  663,
      663,  663,  663,  663,  663,  663,  667,  667,  667,  667,
      667,  667,  667,  699,  800,  443,  449,  449,  449,  449,
      449,  449,  449,  449,  449,  702,  705,  699,  449, 1472,
      449,  800, 1477,  449,  449,  449,  449,  449,  449,  702,

      705,  730,  730,  730,  730,  730,  730,  730,  735,  735,
      735,  735,  735,  735,  735,  449,  455,  455,  455,  455,
      455,  455,  455,  455,  455, 1048, 1480, 1481,  455, 1060,
     1064,  801,  799,  455,  455,  455,  455,  455,  455,  457,
      457,  457,  457,  457,  457,  457,  457,  457,  801,  799,
     1048,  457,  799,  457, 1060, 1064,  457,  457,  457,  457,
      457,  457,  739,  739,  739,  739,  739,  739,  739,  744,
      744,  744,  744,  744,  744,  744,  758,  773,  457,  467,
      467,  467,  467,  467,  467,  467,  467,  467, 1486, 1489,
      758,  467, 1490,  774,  773,  783,  467,  467,  467,  467,

      467,  467,  468,  468,  468,  468,  468,  468,  468,  748,
      774,  773,  783,  468,  759,  758, 1495,  748,  468,  468,
      468,  468,  468,  468,  488,  488,  488,  774,  759,  488,
      488,  783, 1498,  488,  488,  805,  488,  762,  488, 1499,
      488,  520,  763,  520,  520,  520,  520,  520,  520,  520,
     1076,  762,  805,  759,  520, 1136,  763,  807,  807,  520,
      520,  520,  520,  520,  520,  521,  521,  521,  521,  521,
      521,  521,  521, 1507,  807, 1076,  762,  521, 1540,  521,
     1136,  763,  521,  521,  521,  521,  521,  521,  746,  746,
      746,  746,  746,  746,  746,  750,  750,  750,  750,  750,

      750,  750,  775,  777,  521,  523,  523,  523,  523,  523,
      523,  523,  523,  869, 1189, 1541, 1201,  523, 1234,  775,
      777,  869,  523,  523,  523,  523,  523,  523,  527,  527,
      527,  527,  527,  527,  527,  527,  775,  777, 1566, 1189,
      527, 1201, 1237, 1234, 1240,  527,  527,  527,  527,  527,
      527,  528,  528,  528,  528,  528,  528,  528,  528,  529,
      529,  529,  529,  529,  529,  529,  931, 1237, 1569, 1240,
      529, 1243, 1246, 1271,  931,  529,  529,  529,  529,  529,
      529,  530,  530,  530,  530,  530,  530,  530,  530,  532,
      532,  532,  532,  532,  532,  532, 1243, 1246, 1271, 1285,

      532, 1597, 1601,  876,  877,  532,  532,  532,  532,  532,
      532,  533,  533,  533,  533,  533,  533,  533,  533,  533,
      876,  877, 1605,  533, 1285,  878,  877,  829,  533,  533,
      533,  533,  533,  533,  534,  534,  534,  534,  534,  534,
      534,  829,  878, 1299, 1349,  534, 1609,  878,  879, 1613,
      534,  534,  534,  534,  534,  534,  538,  538,  538,  538,
      538,  538,  538,  538, 1412,  879,  829,  538, 1299, 1349,
      879,  881,  538,  538,  538,  538,  538,  538,  540,  540,
      540,  540,  540,  540,  540,  540,  540, 1637,  881, 1412,
      540, 1646,  883,  881,  884,  540,  540,  540,  540,  540,

      540,  541,  541,  541,  541,  541,  541,  541,  541,  883,
     1283,  884,  541, 1282,  883,  890,  884,  541,  541,  541,
      541,  541,  541,  549,  549,  549,  549,  549,  549,  549,
      549,  549,  890,  890, 1466,  549, 1281,  891,  886,  902,
      549,  549,  549,  549,  549,  549,  550,  550,  550,  550,
      550,  550,  550,  550,  891,  886,  902,  550,  886, 1466,
      896,  891,  550,  550,  550,  550,  550,  550,  559,  559,
      559,  559,  559,  559,  559,  559,  559,  896, 1277, 1276,
      559, 1273,  896,  994,  899,  559,  559,  559,  559,  559,
      559,  561,  561,  561,  561,  561,  561,  561,  561,  561,

      994,  899,  994,  561,  784,  561,  899,  785,  561,  561,
      561,  561,  561,  561,  756,  756,  756,  756,  756,  756,
      756,  784, 1001, 1270,  785, 1269,  789,  795,  880,  885,
      561,  616,  616,  616,  616,  616,  616,  616,  785, 1001,
      784, 1475,  616,  789,  795,  880,  885,  616,  616,  616,
      616,  616,  616,  618,  618,  618,  618,  618,  618,  618,
      880,  885,  789,  795,  618, 1268, 1475, 1484, 1493,  618,
      618,  618,  618,  618,  618,  619,  619,  619,  619,  619,
      619,  619,  619,  621,  621,  621,  621,  621,  621,  621,
      942, 1264, 1484, 1493,  621,  894,  900,  981,  942,  621,

      621,  621,  621,  621,  621,  623,  623,  623,  623,  623,
      623,  623,  894,  900,  981, 1263,  623,  981,  900, 1564,
      894,  623,  623,  623,  623,  623,  623,  624,  624,  624,
      624,  624,  624,  624,  624,  625,  625,  625,  625,  625,
      625,  625,  954, 1260, 1564, 1259,  625, 1258, 1254, 1252,
      954,  625,  625,  625,  625,  625,  625,  626,  626,  626,
      626,  626,  626,  626,  626,  629,  629,  629,  629,  629,
      629,  629,  629,  629,  776,  787,  788,  629, 1251,  629,
      993,  830,  629,  629,  629,  629,  629,  629, 1084, 1248,
     1247,  776,  787,  788, 1244,  830, 1084,  993,  882,  781,

      993,  787,  788,  776,  629,  632,  632,  632,  632,  632,
      632,  632,  632,  632,  792,  882,  781,  632,  984,  632,
      830, 1146,  632,  632,  632,  632,  632,  632,  781, 1146,
     1241,  792,  882, 1595, 1238,  984, 1599, 1235,  802, 1231,
      984,  792,  837,  794,  632,  638,  638,  638,  638,  638,
      638,  638,  638,  638,  803,  802,  837,  638, 1595,  638,
      794, 1599,  638,  638,  638,  638,  638,  638,  802,  794,
     1603,  803,  809,  809,  809,  809,  809,  809,  809, 1203,
      838,  837,  841,  803,  638,  643,  643,  643,  643,  643,
      643,  643,  643,  643,  838, 1603,  841,  643, 1202, 1199,

     1000, 1195,  643,  643,  643,  643,  643,  643,  645,  645,
      645,  645,  645,  645,  645,  645,  645, 1000,  842,  838,
      645,  841,  645, 1157,  889,  645,  645,  645,  645,  645,
      645, 1157,  842,  850,  850,  850,  850,  850,  850,  850,
     1000,  889, 1194, 1191,  987,  852, 1002,  645,  655,  655,
      655,  655,  655,  655,  655,  655,  655,  842,  889,  852,
      655,  987,  987, 1002, 1186,  655,  655,  655,  655,  655,
      655,  657,  657,  657,  657,  657,  657,  657,  657,  657,
      892,  853,  856,  657,  852,  657,  857, 1185,  657,  657,
      657,  657,  657,  657, 1182,  853,  856,  892, 1174, 1607,

      857,  865,  865,  865,  865,  865,  865,  865,  892,  887,
      657,  668,  668,  668,  668,  668,  668,  668,  668,  668,
      853,  856, 1173,  668, 1607,  857,  887,  901,  668,  668,
      668,  668,  668,  668,  669,  669,  669,  669,  669,  669,
      669,  887, 1170, 1162,  901,  669, 1161,  989,  992, 1003,
      669,  669,  669,  669,  669,  669,  672,  672,  672,  672,
      672,  672,  672,  901,  989,  992, 1003,  672,  898,  989,
      992,  897,  672,  672,  672,  672,  672,  672,  867,  867,
      867,  867,  867,  867,  867,  898, 1158,  965,  897,  966,
      672,  710,  969,  710,  710,  710,  710,  710,  710,  710,

      897,  965,  898,  966,  710, 1151,  969,  997,  998,  710,
      710,  710,  710,  710,  710,  711,  711,  711,  711,  711,
      711,  711,  711, 1150,  997,  998,  965,  711,  966,  997,
      998,  969,  711,  711,  711,  711,  711,  711,  712,  712,
      712,  712,  712,  712,  712,  871,  871,  871,  871,  871,
      871,  871,  980,  977,  888,  924,  924,  924,  924,  924,
      924,  924,  929,  929,  929,  929,  929,  929,  929,  980,
      977,  888,  712,  713,  713,  713,  713,  713,  713,  713,
      888, 1147, 1142, 1141,  713,  977,  980, 1611, 1635,  713,
      713,  713,  713,  713,  713,  715,  715,  715,  715,  715,

      715,  715,  715,  717,  717,  717,  717,  717,  717,  717,
      717, 1169, 1611, 1635, 1138,  717, 1644, 1137, 1134, 1169,
      717,  717,  717,  717,  717,  717,  718,  718,  718,  718,
      718,  718,  718,  718,  720,  720,  720,  720,  720,  720,
      720, 1644, 1133, 1130, 1127,  720, 1124, 1120, 1007, 1094,
      720,  720,  720,  720,  720,  720,  721,  721,  721,  721,
      721,  721,  721,  721,  721, 1007, 1094, 1089,  721, 1085,
      990, 1097,  970,  721,  721,  721,  721,  721,  721,  722,
      722,  722,  722,  722,  722,  722,  970,  990, 1097, 1078,
      722, 1077, 1097, 1102,  990,  722,  722,  722,  722,  722,

      722,  724,  724,  724,  724,  724,  724,  724,  724,  724,
     1102,  970, 1074,  724,  986, 1100, 1101, 1099,  724,  724,
      724,  724,  724,  724,  725,  725,  725,  725,  725,  725,
      725,  986, 1100, 1101, 1099,  725, 1100, 1070, 1101,  986,
      725,  725,  725,  725,  725,  725,  729,  729,  729,  729,
      729,  729,  729,  729, 1099, 1069, 1066,  729, 1062, 1061,
     1104, 1058,  729,  729,  729,  729,  729,  729,  731,  731,
      731,  731,  731,  731,  731,  731,  731, 1104, 1104, 1054,
      731, 1053, 1106, 1111, 1107,  731,  731,  731,  731,  731,
      731,  732,  732,  732,  732,  732,  732,  732,  732, 1106,

     1111, 1107,  732, 1107, 1106, 1109, 1111,  732,  732,  732,
      732,  732,  732,  740,  740,  740,  740,  740,  740,  740,
      740,  740, 1109, 1109, 1050,  740, 1047, 1204, 1114, 1116,
      740,  740,  740,  740,  740,  740,  741,  741,  741,  741,
      741,  741,  741,  741, 1204, 1114, 1116,  741, 1114, 1116,
     1205, 1046,  741,  741,  741,  741,  741,  741,  751,  751,
      751,  751,  751,  751,  751,  751,  751, 1205, 1204, 1043,
      751, 1039, 1206, 1208, 1038,  751,  751,  751,  751,  751,
      751,  752,  752,  752,  752,  752,  752,  752,  752, 1206,
     1208, 1205,  752, 1035, 1034, 1207, 1031,  752,  752,  752,

      752,  752,  752,  764,  764,  764,  764,  764,  764,  764,
      764,  764, 1207, 1206, 1207,  764, 1027, 1023, 1022, 1021,
      764,  764,  764,  764,  764,  764,  766,  766,  766,  766,
      766,  766,  766,  766,  766,  893,  895, 1028,  766, 1018,
      766, 1181, 1015,  766,  766,  766,  766,  766,  766, 1181,
      978, 1028,  893,  895,  933,  933,  933,  933,  933,  933,
      933,  893,  895,  982, 1029,  766,  804,  978,  804,  804,
      804,  804,  804,  804,  804, 1012, 1028, 1009, 1029,  804,
      982,  982,  978,  804,  804,  804,  804,  804,  804,  804,
      806,  806,  806,  806,  806,  806,  806, 1008,  982,  976,

      975,  806,  991, 1029, 1209, 1212,  806,  806,  806,  806,
      806,  806,  808,  808,  808,  808,  808,  808,  808,  991,
      972, 1209, 1212,  808,  968,  967, 1211,  991,  808,  808,
      808,  808,  808,  808,  810,  810,  810,  810,  810,  810,
      810,  810, 1209, 1211,  964,  959,  810,  955, 1211,  947,
      943,  810,  810,  810,  810,  810,  810,  811,  811,  811,
      811,  811,  811,  811,  811,  814,  814,  814,  814,  814,
      814,  814,  814,  814,  936,  932,  927,  814,  922,  814,
      921,  920,  814,  814,  814,  814,  814,  814,  938,  938,
      938,  938,  938,  938,  938,  940,  940,  940,  940,  940,

      940,  940,  917, 1324,  814,  817,  817,  817,  817,  817,
      817,  817,  817,  817,  914,  910,  874,  817,  870,  817,
     1324,  863,  817,  817,  817,  817,  817,  817,  944,  944,
      944,  944,  944,  944,  944,  950,  950,  950,  950,  950,
      950,  950,  862, 1325,  817,  820,  820,  820,  820,  820,
      820,  820,  820,  820,  859,  855,  854,  820,  851,  820,
     1325,  848,  820,  820,  820,  820,  820,  820,  952,  952,
      952,  952,  952,  952,  952,  956,  956,  956,  956,  956,
      956,  956, 1036,  979,  820,  826,  826,  826,  826,  826,
      826,  826,  826,  826,  847,  844, 1036,  826,  840,  826,

      979,  983,  826,  826,  826,  826,  826,  826,  963,  963,
      963,  963,  963,  963,  963,  979,  979,  839,  983, 1326,
      836, 1036, 1327,  985,  826,  831,  831,  831,  831,  831,
      831,  831,  831,  831,  983,  835, 1326,  831,  832, 1327,
      985,  988,  831,  831,  831,  831,  831,  831,  833,  833,
      833,  833,  833,  833,  833,  833,  833,  985,  988, 1226,
      833,  996,  833, 1037,  999,  833,  833,  833,  833,  833,
      833,  988,  828,  825, 1317, 1377, 1226, 1037,  996,  824,
     1226,  999, 1317, 1377, 1096, 1040, 1343,  833,  843,  843,
      843,  843,  843,  843,  843,  843,  843,  996,  999, 1040,

      843, 1096, 1037, 1343,  995,  843,  843,  843,  843,  843,
      843,  845,  845,  845,  845,  845,  845,  845,  845,  845,
     1096,  995, 1041,  845, 1040,  845,  823, 1224,  845,  845,
      845,  845,  845,  845,  995,  822, 1041, 1049, 1049, 1049,
     1049, 1049, 1049, 1049, 1224,  819, 1051, 1426, 1052, 1224,
      845,  858,  858,  858,  858,  858,  858,  858,  858,  858,
     1051, 1041, 1052,  858, 1426,  816, 1095, 1426,  858,  858,
      858,  858,  858,  858,  860,  860,  860,  860,  860,  860,
      860,  860,  860, 1095, 1055, 1051,  860, 1052,  860, 1056,
      813,  860,  860,  860,  860,  860,  860, 1095, 1055,  812,

      769,  768,  765, 1056, 1065, 1065, 1065, 1065, 1065, 1065,
     1065, 1067,  761,  860,  872,  872,  872,  872,  872,  872,
      872,  872,  872, 1055,  760, 1067,  872,  757, 1056, 1098,
     1068,  872,  872,  872,  872,  872,  872,  873,  873,  873,
      873,  873,  873,  873, 1068,  753, 1098,  749,  873,  742,
     1067, 1427,  738,  873,  873,  873,  873,  873,  873,  903,
     1098,  903,  903,  903,  903,  903,  903,  903, 1427, 1068,
      733, 1427,  903, 1214, 1227, 1229,  903,  903,  903,  903,
      903,  903,  903,  904,  904,  904,  904,  904,  904,  904,
     1214, 1227, 1229,  728,  904,  727, 1227, 1229, 1214,  904,

      904,  904,  904,  904,  904,  905,  905,  905,  905,  905,
      905,  905,  905, 1384, 1071, 1072,  726,  905,  723,  905,
      719, 1384,  905,  905,  905,  905,  905,  905, 1071, 1072,
     1080, 1080, 1080, 1080, 1080, 1080, 1080, 1082, 1082, 1082,
     1082, 1082, 1082, 1082,  905,  907,  907,  907,  907,  907,
      907,  907,  709, 1071, 1072,  708,  907,  704, 1328, 1337,
     1347,  907,  907,  907,  907,  907,  907,  908,  908,  908,
      908,  908,  908,  908,  908, 1328, 1337, 1347,  703,  908,
     1328, 1337, 1347,  701,  908,  908,  908,  908,  908,  908,
      909,  909,  909,  909,  909,  909,  909,  909,  911,  911,

      911,  911,  911,  911,  911,  700,  680,  670,  666,  911,
      660,  659, 1334, 1344,  911,  911,  911,  911,  911,  911,
      912,  912,  912,  912,  912,  912,  912,  912,  912, 1334,
     1344,  656,  912,  652,  651, 1428, 1192,  912,  912,  912,
      912,  912,  912,  913,  913,  913,  913,  913,  913,  913,
     1192, 1344, 1428, 1334,  913,  648,  647, 1429,  644,  913,
      913,  913,  913,  913,  913,  915,  915,  915,  915,  915,
      915,  915,  915,  915, 1429, 1192, 1428,  915, 1429, 1432,
     1433, 1193,  915,  915,  915,  915,  915,  915,  916,  916,
      916,  916,  916,  916,  916, 1193, 1432, 1433,  640,  916,

      637, 1433, 1434,  636,  916,  916,  916,  916,  916,  916,
      918,  918,  918,  918,  918,  918,  918,  918,  918, 1434,
     1193,  635,  918, 1434, 1435, 1437, 1196,  918,  918,  918,
      918,  918,  918,  919,  919,  919,  919,  919,  919,  919,
     1196, 1435, 1437,  634,  919,  631, 1437, 1435,  628,  919,
      919,  919,  919,  919,  919,  923,  923,  923,  923,  923,
      923,  923,  923,  627,  620, 1196,  923,  617,  615, 1440,
     1442,  923,  923,  923,  923,  923,  923,  925,  925,  925,
      925,  925,  925,  925,  925,  925, 1440, 1442, 1440,  925,
      611, 1445, 1442, 1512,  925,  925,  925,  925,  925,  925,

      926,  926,  926,  926,  926,  926,  926,  926, 1445,  605,
     1512,  926, 1445,  604, 1529, 1513,  926,  926,  926,  926,
      926,  926,  934,  934,  934,  934,  934,  934,  934,  934,
      934, 1529, 1513,  603,  934,  602, 1529, 1528, 1521,  934,
      934,  934,  934,  934,  934,  935,  935,  935,  935,  935,
      935,  935,  935, 1513, 1528, 1521,  935, 1528,  598,  597,
     1523,  935,  935,  935,  935,  935,  935,  945,  945,  945,
      945,  945,  945,  945,  945,  945, 1521, 1523, 1523,  945,
      594, 1572, 1574, 1575,  945,  945,  945,  945,  945,  945,
      946,  946,  946,  946,  946,  946,  946,  946, 1572, 1574,

     1575,  946,  593,  592, 1580, 1575,  946,  946,  946,  946,
      946,  946,  957,  957,  957,  957,  957,  957,  957,  957,
      957, 1580,  591,  590,  957,  588, 1583,  585, 1589,  957,
      957,  957,  957,  957,  957,  958,  958,  958,  958,  958,
      958,  958,  958, 1583, 1580, 1589,  958,  584, 1583, 1586,
     1591,  958,  958,  958,  958,  958,  958,  971,  971,  971,
      971,  971,  971,  971,  971,  971, 1586, 1591,  583,  971,
      582, 1591, 1618, 1586,  971,  971,  971,  971,  971,  971,
      973,  973,  973,  973,  973,  973,  973,  973,  973, 1618,
      581,  580,  973, 1103,  973, 1112, 1113,  973,  973,  973,

      973,  973,  973, 1086, 1086, 1086, 1086, 1086, 1086, 1086,
     1103,  579, 1112, 1113,  578,  577,  576, 1630, 1632,  973,
     1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1103,
      575, 1112, 1113, 1004, 1630, 1632,  574, 1004, 1004, 1004,
     1004, 1004, 1004, 1004, 1005, 1005, 1005, 1005, 1005, 1005,
     1005, 1005, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 1006,
     1006,  573, 1110,  572,  571,  568, 1091, 1197, 1092, 1006,
     1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1110,
     1093, 1197, 1010, 1091, 1010, 1092,  567, 1010, 1010, 1010,
     1010, 1010, 1010, 1110, 1091,  566, 1092, 1093,  564, 1392,

      563,  560, 1105, 1108, 1213,  555, 1197, 1392, 1093, 1010,
     1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1105,
     1108, 1213, 1013,  551, 1013, 1115, 1255, 1013, 1013, 1013,
     1013, 1013, 1013, 1400, 1105, 1108, 1213, 1408, 1457, 1506,
     1255, 1400, 1115, 1115, 1631, 1408, 1457, 1506,  547, 1013,
     1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1115,
     1115, 1631, 1016, 1631, 1016, 1255,  542, 1016, 1016, 1016,
     1016, 1016, 1016, 1139, 1139, 1139, 1139, 1139, 1139, 1139,
     1144, 1144, 1144, 1144, 1144, 1144, 1144,  537, 1634, 1016,
     1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019,  536,

      535,  531, 1019,  525, 1019, 1634,  524, 1019, 1019, 1019,
     1019, 1019, 1019, 1148, 1148, 1148, 1148, 1148, 1148, 1148,
     1153, 1153, 1153, 1153, 1153, 1153, 1153, 1215, 1219, 1019,
     1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,  519,  518,
      517, 1024,  516,  515, 1215, 1219, 1024, 1024, 1024, 1024,
     1024, 1024, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,
     1025,  514, 1219, 1215, 1025,  513, 1025,  512,  511, 1025,
     1025, 1025, 1025, 1025, 1025, 1155, 1155, 1155, 1155, 1155,
     1155, 1155, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1220,
     1225, 1025, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030,

     1030,  510,  509,  508, 1030,  507, 1220, 1225, 1620, 1030,
     1030, 1030, 1030, 1030, 1030, 1032, 1032, 1032, 1032, 1032,
     1032, 1032, 1032, 1032, 1220, 1620, 1225, 1032, 1620, 1032,
      505,  502, 1032, 1032, 1032, 1032, 1032, 1032, 1165, 1165,
     1165, 1165, 1165, 1165, 1165, 1167, 1167, 1167, 1167, 1167,
     1167, 1167, 1256, 1221, 1032, 1042, 1042, 1042, 1042, 1042,
     1042, 1042, 1042, 1042,  501,  500, 1256, 1042,  499,  498,
     1221, 1654, 1042, 1042, 1042, 1042, 1042, 1042, 1044, 1044,
     1044, 1044, 1044, 1044, 1044, 1044, 1044, 1221, 1654,  497,
     1044, 1256, 1044, 1654,  496, 1044, 1044, 1044, 1044, 1044,

     1044, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1177, 1177,
     1177, 1177, 1177, 1177, 1177, 1261, 1332, 1044, 1057, 1057,
     1057, 1057, 1057, 1057, 1057, 1057, 1057,  494,  493, 1261,
     1057,  492,  491, 1332, 1332, 1057, 1057, 1057, 1057, 1057,
     1057, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059,
      490, 1332,  489, 1059, 1261, 1059,  487,  485, 1059, 1059,
     1059, 1059, 1059, 1059, 1179, 1179, 1179, 1179, 1179, 1179,
     1179, 1183, 1183, 1183, 1183, 1183, 1183, 1183, 1262, 1335,
     1059, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073,
      483,  482, 1262, 1073,  481,  480, 1335, 1655, 1073, 1073,

     1073, 1073, 1073, 1073, 1075, 1075, 1075, 1075, 1075, 1075,
     1075, 1075, 1075,  479, 1655, 1335, 1075, 1262, 1075, 1655,
      477, 1075, 1075, 1075, 1075, 1075, 1075, 1190, 1190, 1190,
     1190, 1190, 1190, 1190, 1249, 1249, 1249, 1249, 1249, 1249,
     1249, 1265, 1336, 1075, 1087, 1087, 1087, 1087, 1087, 1087,
     1087, 1087, 1087,  476,  474, 1265, 1087,  473, 1652, 1336,
     1266, 1087, 1087, 1087, 1087, 1087, 1087, 1088, 1088, 1088,
     1088, 1088, 1088, 1088, 1266, 1652, 1336,  472, 1088, 1652,
     1265, 1622,  469, 1088, 1088, 1088, 1088, 1088, 1088, 1117,
     1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1622, 1266,

      465, 1622, 1117,  461,  460,  459, 1117, 1117, 1117, 1117,
     1117, 1117, 1117, 1118, 1118, 1118, 1118, 1118, 1118, 1118,
     1118, 1119, 1119, 1119, 1119, 1119, 1119, 1119, 1119, 1119,
     1272, 1272, 1272, 1272, 1272, 1272, 1272, 1274, 1119, 1121,
     1121, 1121, 1121, 1121, 1121, 1121, 1570,  456,  452,  451,
     1121, 1274,  448, 1660, 1570, 1121, 1121, 1121, 1121, 1121,
     1121, 1122, 1122, 1122, 1122, 1122, 1122, 1122, 1122, 1122,
     1660,  447,  446, 1122,  445, 1668, 1274, 1275, 1122, 1122,
     1122, 1122, 1122, 1122, 1123, 1123, 1123, 1123, 1123, 1123,
     1123, 1275, 1668,  442,  441, 1123,  432,  429, 1670,  427,

     1123, 1123, 1123, 1123, 1123, 1123, 1125, 1125, 1125, 1125,
     1125, 1125, 1125, 1125, 1125, 1670, 1275,  426, 1125,  425,
     1670, 1623, 1278, 1125, 1125, 1125, 1125, 1125, 1125, 1126,
     1126, 1126, 1126, 1126, 1126, 1126, 1278,  424, 1623,  423,
     1126, 1623,  422, 1677,  421, 1126, 1126, 1126, 1126, 1126,
     1126, 1128, 1128, 1128, 1128, 1128, 1128, 1128, 1128, 1128,
     1677, 1278,  420, 1128,  419, 1680, 1628, 1279, 1128, 1128,
     1128, 1128, 1128, 1128, 1129, 1129, 1129, 1129, 1129, 1129,
     1129, 1279, 1680, 1628,  418, 1129, 1628, 1680, 1683,  417,
     1129, 1129, 1129, 1129, 1129, 1129, 1131, 1131, 1131, 1131,

     1131, 1131, 1131, 1131, 1131, 1683, 1279,  416, 1131, 1511,
     1684,  415, 1691, 1131, 1131, 1131, 1131, 1131, 1131, 1132,
     1132, 1132, 1132, 1132, 1132, 1132, 1511, 1684, 1684, 1691,
     1132,  414,  412,  410, 1511, 1132, 1132, 1132, 1132, 1132,
     1132, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135,
     1210, 1216, 1288, 1135,  409, 1135,  407,  406, 1135, 1135,
     1135, 1135, 1135, 1135,  403,  402, 1288, 1210, 1216, 1286,
     1286, 1286, 1286, 1286, 1286, 1286, 1289, 1338, 1210, 1216,
     1135, 1140, 1140, 1140, 1140, 1140, 1140, 1140, 1140, 1140,
     1289, 1288,  400, 1140, 1338,  398,  397, 1685, 1140, 1140,

     1140, 1140, 1140, 1140, 1149, 1149, 1149, 1149, 1149, 1149,
     1149, 1149, 1149, 1338, 1685, 1289, 1149,  396,  395, 1685,
     1686, 1149, 1149, 1149, 1149, 1149, 1149, 1160, 1160, 1160,
     1160, 1160, 1160, 1160, 1160, 1160,  390, 1686,  389, 1160,
      388,  386, 1686, 1687, 1160, 1160, 1160, 1160, 1160, 1160,
     1172, 1172, 1172, 1172, 1172, 1172, 1172, 1172, 1172,  385,
     1687,  384, 1172,  383,  381, 1687, 1689, 1172, 1172, 1172,
     1172, 1172, 1172, 1184, 1184, 1184, 1184, 1184, 1184, 1184,
     1184, 1184,  376, 1689,  375, 1184,  374,  371, 1689, 1694,
     1184, 1184, 1184, 1184, 1184, 1184, 1198, 1198, 1198, 1198,

     1198, 1198, 1198, 1198, 1198,  367, 1694,  365, 1198, 1694,
      360,  359, 1217, 1198, 1198, 1198, 1198, 1198, 1198, 1200,
     1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1218, 1217,
     1222, 1200, 1223, 1200, 1228, 1439, 1200, 1200, 1200, 1200,
     1200, 1200, 1217, 1292,  356, 1218,  351, 1222,  350, 1223,
      342, 1228, 1439,  340,  339,  334,  332, 1292, 1200, 1218,
     1443, 1222, 1340, 1223, 1439, 1228, 1230, 1230, 1230, 1230,
     1230, 1230, 1230, 1230, 1230,  330, 1705, 1443, 1293, 1340,
     1302, 1339, 1292, 1230, 1232, 1232, 1232, 1232, 1232, 1232,
     1232, 1232, 1293, 1705, 1302, 1232, 1340, 1443, 1339, 1339,

     1232, 1232, 1232, 1232, 1232, 1232, 1233, 1233, 1233, 1233,
     1233, 1233, 1233, 1233, 1233,  329, 1339, 1293, 1233, 1302,
     1233, 1717, 1303, 1233, 1233, 1233, 1233, 1233, 1233, 1300,
     1300, 1300, 1300, 1300, 1300, 1300, 1303,  328, 1717,  327,
      326, 1306, 1307, 1367,  325, 1233, 1236, 1236, 1236, 1236,
     1236, 1236, 1236, 1236, 1236, 1306, 1307, 1367, 1236, 1509,
     1236, 1303, 1342, 1236, 1236, 1236, 1236, 1236, 1236, 1313,
     1313, 1313, 1313, 1313, 1313, 1313, 1509,  324,  322, 1342,
     1306, 1307, 1367,  321, 1720, 1236, 1239, 1239, 1239, 1239,
     1239, 1239, 1239, 1239, 1239, 1509, 1342,  320, 1239,  315,

     1239, 1720,  312, 1239, 1239, 1239, 1239, 1239, 1239, 1315,
     1315, 1315, 1315, 1315, 1315, 1315, 1319, 1319, 1319, 1319,
     1319, 1319, 1319,  311, 1329, 1239, 1242, 1242, 1242, 1242,
     1242, 1242, 1242, 1242, 1242, 1331, 1333, 1698, 1242, 1702,
     1242, 1329,  310, 1242, 1242, 1242, 1242, 1242, 1242,  307,
     1329,  306, 1331, 1333, 1698,  299, 1702, 1698,  298, 1330,
     1341, 1702, 1333, 1331, 1345, 1242, 1245, 1245, 1245, 1245,
     1245, 1245, 1245, 1245, 1245, 1346, 1330, 1341, 1245,  296,
     1245, 1345, 1368, 1245, 1245, 1245, 1245, 1245, 1245, 1330,
      295, 1341, 1346,  294, 1345,  292, 1368,  290,  289, 1700,

     1704, 1415, 1573, 1346,  288, 1245, 1250, 1250, 1250, 1250,
     1250, 1250, 1250, 1250, 1250, 1415, 1700, 1704, 1250, 1573,
     1700, 1368, 1704, 1250, 1250, 1250, 1250, 1250, 1250, 1257,
     1257, 1257, 1257, 1257, 1257, 1257, 1257, 1257, 1573,  286,
     1415, 1257,  282,  281, 1707, 1708, 1257, 1257, 1257, 1257,
     1257, 1257, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
     1267, 1707, 1708,  279, 1267,  276,  272, 1715,  271, 1267,
     1267, 1267, 1267, 1267, 1267, 1280, 1280, 1280, 1280, 1280,
     1280, 1280, 1280, 1280, 1715, 1707, 1708, 1280,  268, 1715,
     1724, 1725, 1280, 1280, 1280, 1280, 1280, 1280, 1294, 1294,

     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1724, 1725,  267,
     1294,  265, 1724, 1725, 1730, 1294, 1294, 1294, 1294, 1294,
     1294, 1308, 1308, 1308, 1308, 1308, 1308, 1308, 1308, 1308,
      260, 1730,  257, 1308,  255,  254, 1730, 1731, 1308, 1308,
     1308, 1308, 1308, 1308, 1320, 1320, 1320, 1320, 1320, 1320,
     1320, 1320, 1320,  252, 1731,  249, 1320,  245, 1731, 1733,
     1735, 1320, 1320, 1320, 1320, 1320, 1320, 1348, 1348, 1348,
     1348, 1348, 1348, 1348, 1348, 1348, 1733, 1735,  241, 1348,
      239, 1348, 1735,  237, 1348, 1348, 1348, 1348, 1348, 1348,
     1375, 1375, 1375, 1375, 1375, 1375, 1375, 1380, 1380, 1380,

     1380, 1380, 1380, 1380, 1416, 1425, 1348, 1352, 1352, 1352,
     1352, 1352, 1352, 1352, 1352, 1352,  236,  234, 1416, 1352,
      233,  232, 1425, 1739, 1352, 1352, 1352, 1352, 1352, 1352,
     1355, 1355, 1355, 1355, 1355, 1355, 1355, 1355, 1355, 1425,
     1739,  231, 1355, 1416,  230, 1740, 1738, 1355, 1355, 1355,
     1355, 1355, 1355, 1358, 1358, 1358, 1358, 1358, 1358, 1358,
     1358, 1358, 1740, 1738,  229, 1358, 1738,  228, 1745,  226,
     1358, 1358, 1358, 1358, 1358, 1358, 1361, 1361, 1361, 1361,
     1361, 1361, 1361, 1361, 1361, 1745, 1740,  224, 1361,  222,
     1745, 1750, 1754, 1361, 1361, 1361, 1361, 1361, 1361, 1364,

     1364, 1364, 1364, 1364, 1364, 1364, 1364, 1364, 1750, 1754,
      221, 1364,  219,  217, 1754, 1756, 1364, 1364, 1364, 1364,
     1364, 1364, 1369, 1369, 1369, 1369, 1369, 1369, 1369, 1369,
     1369,  216, 1756,  214, 1369,  211,  210,  209,  207, 1369,
     1369, 1369, 1369, 1369, 1369, 1382, 1382, 1382, 1382, 1382,
     1382, 1382, 1388, 1388, 1388, 1388, 1388, 1388, 1388, 1390,
     1390, 1390, 1390, 1390, 1390, 1390, 1396, 1396, 1396, 1396,
     1396, 1396, 1396, 1398, 1398, 1398, 1398, 1398, 1398, 1398,
     1404, 1404, 1404, 1404, 1404, 1404, 1404, 1406, 1406, 1406,
     1406, 1406, 1406, 1406, 1413, 1413, 1413, 1413, 1413, 1413,

     1413, 1419, 1420, 1430, 1431, 1436, 1438, 1759, 1763, 1766,
      205,  204, 1444, 1461, 1462, 1419, 1420, 1469, 1470, 1441,
     1430, 1431, 1436, 1438, 1759, 1763, 1766, 1461, 1462, 1444,
     1763, 1469, 1470, 1436, 1430, 1431, 1441, 1438, 1444, 1436,
     1419, 1420, 1421, 1421, 1421, 1421, 1421, 1421, 1421, 1421,
     1421, 1441, 1461, 1462, 1421,  201, 1469, 1470, 1765, 1421,
     1421, 1421, 1421, 1421, 1421, 1446, 1446, 1446, 1446, 1446,
     1446, 1446, 1446, 1446,  200, 1765,  198, 1446, 1765,  197,
      196,  195, 1446, 1446, 1446, 1446, 1446, 1446, 1455, 1455,
     1455, 1455, 1455, 1455, 1455, 1467, 1467, 1467, 1467, 1467,

     1467, 1467, 1476, 1476, 1476, 1476, 1476, 1476, 1476, 1478,
     1479, 1485, 1485, 1485, 1485, 1485, 1485, 1485, 1487, 1488,
     1496, 1497,  194, 1478, 1479, 1494, 1494, 1494, 1494, 1494,
     1494, 1494, 1487, 1488, 1496, 1497, 1502, 1502, 1502, 1502,
     1502, 1502, 1502,  193, 1510, 1514, 1515,  192, 1478, 1479,
     1504, 1504, 1504, 1504, 1504, 1504, 1504, 1487, 1488, 1496,
     1497, 1510, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1522,
     1510, 1525, 1524, 1514,  191,  190, 1515, 1526, 1527,  189,
      188, 1516, 1517, 1518, 1519, 1520, 1522, 1538, 1525, 1524,
     1516, 1517, 1518, 1519, 1526, 1527, 1539, 1522, 1524, 1520,

      187, 1538,  186,  185,  184, 1525,  183, 1527,  182,  181,
     1539, 1526, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1548,
     1548, 1548, 1548, 1548, 1548, 1548, 1538, 1552, 1552, 1552,
     1552, 1552, 1552, 1552,  180, 1539, 1556, 1556, 1556, 1556,
     1556, 1556, 1556, 1560, 1560, 1560, 1560, 1560, 1560, 1560,
     1565, 1565, 1565, 1565, 1565, 1565, 1565, 1567, 1568, 1576,
     1578, 1577, 1584, 1587, 1579, 1581, 1582, 1590,  178, 1585,
     1588, 1567, 1568, 1693, 1621, 1629, 1576, 1578, 1577, 1584,
     1587, 1579, 1581, 1582, 1590, 1576, 1585, 1588, 1584,  177,
     1693, 1621, 1629, 1590, 1587, 1578, 1567, 1568, 1577, 1579,

     1581, 1629, 1693, 1582, 1621, 1585, 1588, 1593, 1593, 1593,
     1593, 1593, 1593, 1593, 1596, 1596, 1596, 1596, 1596, 1596,
     1596, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1604, 1604,
     1604, 1604, 1604, 1604, 1604, 1608, 1608, 1608, 1608, 1608,
     1608, 1608, 1612, 1612, 1612, 1612, 1612, 1612, 1612, 1615,
     1615, 1615, 1615, 1615, 1615, 1615, 1619, 1624,  174, 1625,
     1626, 1768, 1633, 1627, 1636, 1636, 1636, 1636, 1636, 1636,
     1636, 1647,  173, 1619, 1624, 1624, 1625, 1626, 1768, 1633,
     1627, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1647, 1648,
     1619, 1649, 1624, 1650, 1657, 1625, 1626, 1627, 1633, 1651,

     1653, 1656, 1658,  172, 1659, 1669, 1648, 1647, 1649, 1671,
     1650, 1657, 1672,  171,  170, 1648, 1651, 1653, 1656, 1658,
     1657, 1659, 1669, 1673, 1650, 1649, 1671, 1674, 1675, 1672,
     1651, 1653, 1659, 1658, 1676, 1678, 1679, 1656,  169, 1688,
     1673, 1669, 1690,  168, 1674, 1675, 1692, 1671,  167,  165,
     1672, 1676, 1678, 1679,  162, 1674, 1688, 1695, 1675, 1690,
     1690, 1673,  161, 1692, 1696, 1688, 1679, 1697, 1676, 1699,
     1703, 1678, 1706, 1701, 1695, 1709, 1710, 1690, 1690, 1692,
     1692, 1696, 1712, 1714, 1697,  160, 1699, 1703, 1711, 1706,
     1701, 1695, 1709, 1710,  159, 1713, 1716, 1706, 1696, 1712,

     1714, 1697, 1710, 1699, 1701, 1711,  156, 1703, 1718, 1711,
     1719, 1709, 1713, 1716,  154, 1721, 1722, 1714, 1723, 1727,
     1712, 1711, 1711, 1713, 1726, 1718, 1728, 1719, 1719, 1729,
      145, 1716, 1721, 1722,  144, 1723, 1727, 1732,  143, 1734,
     1736, 1726, 1718, 1728,  142, 1719, 1729, 1722, 1727, 1737,
     1726, 1721,  141, 1741, 1732, 1723, 1734, 1736, 1742, 1743,
     1728, 1729, 1746, 1747, 1744, 1748, 1737,  140, 1732, 1734,
     1741, 1752, 1736,  139,  137, 1742, 1743,  135, 1749, 1746,
     1747, 1744, 1748, 1737, 1741, 1751, 1753,  134, 1752, 1757,
     1742, 1742, 1744, 1755, 1747, 1749, 1746, 1743,  132, 1752,

     1758, 1748, 1751, 1753, 1749, 1760, 1757, 1761, 1762, 1764,
     1755, 1767, 1770,  130, 1769, 1751, 1771, 1758, 1772, 1755,
     1773, 1774, 1760, 1753, 1761, 1762, 1764, 1775, 1767, 1770,
     1757, 1769,  128, 1771, 1758, 1772, 1769, 1773, 1774, 1776,
     1777, 1760, 1761, 1764, 1775, 1778, 1773, 1767, 1780, 1762,
     1781, 1771, 1782, 1783, 1772,  127, 1776, 1777,  126, 1774,
     1779,  125, 1778, 1779, 1779, 1780,  123, 1781,  122, 1782,
     1783,  121,  120,  119,  118, 1776,  116, 1779,  114,  113,
      112, 1778, 1785,  111, 1785, 1786,  110, 1786, 1786, 1786,
     1786, 1786, 1786, 1787,  109, 1787, 1788, 1788, 1788, 1789,

     1789, 1789, 1790, 1790, 1790, 1791, 1791, 1791, 1792, 1792,
     1792, 1793, 1793, 1793, 1794, 1794, 1794, 1795, 1795, 1795,
     1796, 1796, 1796, 1797,  108, 1797, 1798, 1798, 1798, 1799,
     1799, 1799, 1800, 1800, 1800, 1801, 1801, 1801, 1802,  107,
     1802, 1803, 1803, 1803, 1804, 1804,  106,  104, 1804, 1805,
     1805, 1805, 1806, 1806, 1806, 1807, 1807, 1807, 1808, 1808,
     1808, 1809, 1809, 1809, 1810, 1810, 1810, 1811, 1811, 1811,
     1812, 1812, 1812, 1813, 1813, 1813, 1814, 1814,  103,   96,
     1814, 1815, 1815, 1815, 1816, 1816, 1816, 1817,   95, 1817,
     1818, 1818, 1818, 1819, 1819, 1819, 1820,   94, 1820, 1821,

     1821, 1821, 1822, 1822, 1822, 1823, 1823, 1823, 1824, 1824,
     1824, 1825, 1825, 1825, 1826,   91, 1826, 1827,   88, 1827,
     1828, 1828, 1828, 1829, 1829, 1829, 1830,   87, 1830, 1831,
     1831,   86,   85, 1831, 1832, 1832,   84,   83, 1832, 1833,
     1833, 1833, 1834, 1834, 1834, 1835, 1835,   82, 1835, 1836,
     1836, 1836, 1837, 1837, 1837, 1838, 1838, 1838, 1839, 1839,
     1839, 1840, 1840, 1840, 1841, 1841, 1841, 1842, 1842, 1842,
     1843, 1843,   81,   80, 1843, 1844, 1844, 1844, 1845, 1845,
     1845, 1846, 1846,   79, 1846, 1847, 1847,   77,   76, 1847,
     1848, 1848,   75, 1848, 1849, 1849, 1850, 1850,   74,   73,

     1850, 1851, 1851, 1851, 1852, 1852, 1852, 1853, 1853,   72,
     1853, 1854,   71, 1854, 1855,   70, 1855, 1856, 1856, 1856,
     1857, 1857, 1857, 1858,   69, 1858, 1859, 1859, 1859, 1860,
     1860, 1860, 1861, 1861, 1861, 1862, 1862, 1862, 1863, 1863,
     1863, 1864, 1864, 1864, 1865,   68, 1865, 1866,   67, 1866,
     1867, 1867, 1867, 1868, 1868, 1868, 1869,   66, 1869, 1870,
       65, 1870, 1871,   64, 1871, 1872, 1872, 1872, 1873, 1873,
     1873, 1874,   62, 1874, 1875,   61,   60, 1875, 1876, 1876,
       47, 1876, 1877, 1877,   40,   39, 1877, 1878, 1878,   37,
     1878, 1879, 1879, 1880, 1880,   15,   13, 1880, 1881, 1881,

     1881, 1882, 1882, 1882, 1883, 1883,   10, 1883, 1884, 1884,
     1884,    7, 1884, 1884, 1885, 1885, 1885, 1886, 1886, 1886,
     1887, 1887, 1887, 1888, 1888, 1888, 1889, 1889, 1889, 1890,
     1890, 1890, 1891, 1891, 1891, 1892, 1892, 1892, 1893, 1893,
        3,    0, 1893, 1894, 1894, 1894, 1895, 1895, 1895, 1896,
     1896,    0, 1896, 1897, 1897,    0,    0, 1897, 1898, 1898,
        0, 1898, 1899, 1899, 1900, 1900,    0,    0, 1900, 1901,
     1901, 1901, 1902, 1902, 1902, 1903, 1903,    0, 1903, 1904,
        0,    0, 1904, 1905, 1905,    0, 1905, 1906, 1906,    0,
        0, 1906, 1907, 1907,    0, 1907, 1908, 1908, 1909, 1909,

        0,    0, 1909, 1910, 1910, 1910, 1911, 1911, 1911, 1912,
     1912,    0, 1912, 1913,    0, 1913, 1914,    0, 1914, 1915,
        0, 1915, 1916, 1916, 1916, 1917, 1917, 1917, 1918,    0,
     1918, 1919, 1919, 1919,    0, 1919, 1919, 1920, 1920, 1920,
     1921, 1921, 1921, 1922, 1922, 1922, 1923, 1923, 1923, 1924,
     1924, 1924, 1925, 1925, 1925, 1926, 1926, 1926, 1927,    0,
     1927, 1928,    0, 1928, 1929, 1929, 1929, 1930, 1930, 1930,
     1931,    0, 1931, 1932,    0, 1932, 1933,    0, 1933, 1934,
     1934, 1934, 1935, 1935, 1935, 1936,    0, 1936, 1937,    0,
     1937, 1938,    0, 1938, 1939,    0, 1939, 1940, 1940, 1940,

     1941, 1941, 1941, 1942,    0, 1942, 1943,    0, 1943, 1944,
        0,    0, 1944, 1945, 1945,    0, 1945, 1946, 1946,    0,
        0, 1946, 1947, 1947,    0, 1947, 1948, 1948, 1949, 1949,
        0,    0, 1949, 1950, 1950, 1950, 1951, 1951, 1951, 1952,
     1952,    0, 1952, 1953, 1953, 1953,    0, 1953, 1953, 1954,
     1954, 1954, 1955, 1955, 1955, 1956, 1956, 1956, 1957, 1957,
     1957, 1958, 1958, 1958, 1959, 1959, 1959, 1960, 1960, 1960,
     1961, 1961, 1961, 1962, 1962,    0,    0, 1962, 1963, 1963,
     1963, 1964, 1964, 1964, 1965, 1965,    0, 1965, 1966, 1966,
        0,    0, 1966, 1967, 1967,    0, 1967, 1968, 1968, 1969,

     1969,    0,    0, 1969, 1970, 1970, 1970, 1971, 1971, 1971,
     1972, 1972,    0, 1972, 1973,    0,    0, 1973, 1974, 1974,
        0, 1974, 1975, 1975,    0,    0, 1975, 1976, 1976,    0,
     1976, 1977, 1977, 1978, 1978,    0,    0, 1978, 1979, 1979,
     1979, 1980, 1980, 1980, 1981, 1981,    0, 1981, 1982,    0,
     1982, 1983,    0,    0, 1983, 1984, 1984,    0, 1984, 1985,
     1985,    0,    0, 1985, 1986, 1986,    0, 1986, 1987, 1987,
     1988, 1988,    0,    0, 1988, 1989, 1989, 1989, 1990, 1990,
     1990, 1991, 1991,    0, 1991, 1992,    0, 1992, 1993,    0,
     1993, 1994,    0, 1994, 1995, 1995, 1995, 1996, 1996, 1996,

     1997,    0, 1997, 1998, 1998, 1998,    0, 1998, 1998, 1999,
     1999, 1999, 2000, 2000, 2000, 2001, 2001, 2001, 2002, 2002,
     2002, 2003, 2003, 2003, 2004, 2004, 2004, 2005, 2005, 2005,
     2006, 2006, 2006, 2007, 2007, 2007, 2008, 2008, 2008, 2009,
        0, 2009, 2010,    0, 2010, 2011, 2011, 2011, 2012, 2012,
     2012, 2013, 2013, 2013, 2014,    0, 2014, 2015,    0, 2015,
     2016,    0, 2016, 2017, 2017, 2017, 2018, 2018, 2018, 2019,
     2019, 2019, 2020,    0, 2020, 2021,    0, 2021, 2022,    0,
     2022, 2023,    0, 2023, 2024, 2024, 2024, 2025, 2025, 2025,
     2026, 2026, 2026, 2027,    0, 2027, 2028,    0, 2028, 2029,

        0, 2029, 2030,    0, 2030, 2031, 2031, 2031, 2032, 2032,
     2032, 2033, 2033, 2033, 2034,    0, 2034, 2035,    0, 2035,
     2036,    0,    0, 2036, 2037, 2037,    0, 2037, 2038, 2038,
        0,    0, 2038, 2039, 2039,    0, 2039, 2040, 2040, 2041,
     2041,    0,    0, 2041, 2042, 2042, 2042, 2043, 2043, 2043,
     2044, 2044,    0, 2044, 2045, 2045, 2045,    0, 2045, 2045,
     2046, 2046, 2046, 2047, 2047, 2047, 2048, 2048, 2048, 2049,
     2049, 2049, 2050, 2050, 2050, 2051, 2051, 2051, 2052, 2052,
     2052, 2053, 2053, 2053, 2054,    0, 2054, 2055, 2055, 2055,
     2056, 2056,    0,    0, 2056, 2057, 2057, 2057, 2058, 2058,

     2058, 2059, 2059,    0, 2059, 2060, 2060,    0,    0, 2060,
     2061, 2061,    0, 2061, 2062, 2062, 2063, 2063,    0,    0,
     2063, 2064, 2064, 2064, 2065, 2065, 2065, 2066, 2066,    0,
     2066, 2067,    0,    0, 2067, 2068, 2068,    0, 2068, 2069,
     2069,    0,    0, 2069, 2070, 2070,    0, 2070, 2071, 2071,
     2072, 2072,    0,    0, 2072, 2073, 2073, 2073, 2074, 2074,
     2074, 2075, 2075,    0, 2075, 2076,    0, 2076, 2077,    0,
        0, 2077, 2078, 2078,    0, 2078, 2079, 2079,    0,    0,
     2079, 2080, 2080,    0, 2080, 2081, 2081, 2082, 2082,    0,
        0, 2082, 2083, 2083, 2083, 2084, 2084, 2084, 2085, 2085,

        0, 2085, 2086,    0, 2086, 2087,    0,    0, 2087, 2088,
     2088,    0, 2088, 2089, 2089,    0,    0, 2089, 2090, 2090,
        0, 2090, 2091, 2091, 2092, 2092,    0,    0, 2092, 2093,
     2093, 2093, 2094, 2094, 2094, 2095, 2095,    0, 2095, 2096,
        0, 2096, 2097,    0, 2097, 2098,    0, 2098, 2099, 2099,
     2099, 2100,    0, 2100, 2101, 2101, 2101, 2102,    0, 2102,
     2103, 2103, 2103,    0, 2103, 2103, 2104,    0, 2104, 2105,
     2105, 2105, 2106,    0, 2106, 2107, 2107, 2107, 2108,    0,
     2108, 2109, 2109, 2109, 2110,    0, 2110, 2111, 2111, 2111,
     2112,    0, 2112, 2113, 2113, 2113, 2114,    0, 2114, 2115,

     2115, 2115, 2116, 2116,    0,    0, 2116, 2117, 2117, 2117,
     2118, 2118, 2118, 2119, 2119, 2119, 2120, 2120,    0, 2120,
     2121, 2121, 2121, 2122,    0, 2122, 2123, 2123, 2123, 2124,
     2124, 2124, 2125,    0, 2125, 2126,    0, 2126, 2127, 2127,
     2127, 2128, 2128, 2128, 2129,    0, 2129, 2130,    0, 2130,
     2131,    0, 2131, 2132, 2132, 2132, 2133, 2133, 2133, 2134,
        0, 2134, 2135,    0, 2135, 2136,    0, 2136, 2137, 2137,
     2137, 2138, 2138, 2138, 2139,    0, 2139, 2140,    0, 2140,
     2141,    0, 2141, 2142, 2142, 2142, 2143, 2143, 2143, 2144,
        0, 2144, 2145,    0,    0, 2145, 2146, 2146,    0, 2146,

     2147, 2147,    0,    0, 2147, 2148, 2148,    0, 2148, 2149,
     2149, 2150, 2150,    0,    0, 2150, 2151, 2151, 2151, 2152,
        0, 2152, 2153, 2153,    0, 2153, 2154, 2154, 2154,    0,
     2154, 2154, 2155, 2155, 2155, 2156, 2156, 2156, 2157,    0,
     2157, 2158,    0, 2158, 2159,    0, 2159, 2160,    0, 2160,
     2161,    0, 2161, 2162,    0, 2162, 2163,    0, 2163, 2164,
     2164, 2164, 2165, 2165, 2165, 2166,    0, 2166, 2167, 2167,
        0,    0, 2167, 2168, 2168,    0, 2168, 2169, 2169, 2170,
        0, 2170, 2171,    0,    0, 2171, 2172, 2172,    0, 2172,
     2173, 2173,    0,    0, 2173, 2174, 2174,    0, 2174, 2175,

     2175, 2176,    0, 2176, 2177,    0, 2177, 2178,    0,    0,
     2178, 2179, 2179,    0, 2179, 2180, 2180,    0,    0, 2180,
     2181, 2181,    0, 2181, 2182, 2182, 2183,    0, 2183, 2184,
        0, 2184, 2185,    0,    0, 2185, 2186, 2186,    0, 2186,
     2187, 2187,    0,    0, 2187, 2188, 2188,    0, 2188, 2189,
     2189, 2190,    0, 2190, 2191,    0, 2191, 2192,    0,    0,
     2192, 2193, 2193,    0, 2193, 2194, 2194,    0,    0, 2194,
     2195, 2195,    0, 2195, 2196, 2196, 2197,    0, 2197, 2198,
        0, 2198, 2199,    0, 2199, 2200,    0, 2200, 2201, 2201,
     2201, 2202,    0, 2202, 2203, 2203, 2203,    0, 2203, 2203,

     2204,    0, 2204, 2205,    0, 2205, 2206,    0, 2206, 2207,
        0, 2207, 2208,    0, 2208, 2209,    0, 2209, 2210,    0,
     2210, 2211, 2211,    0,    0, 2211, 2212, 2212,    0, 2212,
     2213, 2213, 2214,    0, 2214, 2215,    0, 2215, 2216,    0,
     2216, 2217,    0, 2217, 2218,    0, 2218, 2219,    0, 2219,
     2220,    0, 2220, 2221,    0, 2221, 2222,    0, 2222, 2223,
        0, 2223, 2224,    0,    0, 2224, 2225, 2225,    0,    0,
     2225, 2226,    0, 2226, 2227,    0, 2227, 2228,    0, 2228,
     2229,    0,    0, 2229, 2230,    0,    0, 2230, 2231,    0,
        0, 2231, 2232,    0,    0, 2232, 2233,    0,    0, 2233,

     2234,    0, 2234, 2235,    0, 2235, 2236,    0,    0, 2236,
     2237,    0, 2237, 2238,    0, 2238, 2239,    0, 2239, 2240,
        0, 2240, 2241,    0, 2241, 2242,    0,    0, 2242, 2243,
        0, 2243, 2244,    0, 2244, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784
    } ;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#line 1 "scanner.l"

/*
 * We want a reentrant scanner.
 */
/*
 * And we need to pass the compiler state to the scanner.
 */
/*
 * We don't use input, so don't generate code for it.
 */
#define YY_NO_INPUT 1
/*
 * We don't use unput, so don't generate code for it.
 */
/*
 * We don't read from the terminal.
 */
/*
 * We want to stop processing when we get to the end of the input.
 */
/*
 * We want to generate code that can be used by a reentrant parser
 * generated by Bison or Berkeley YACC.
 */
#line 92 "scanner.l"
/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <string.h>

#include "pcap-int.h"

/*
 * Earlier versions of Flex don't declare these, so we declare them
 * ourselves to squelch warnings.
 */
int pcap_get_column(yyscan_t);
void pcap_set_column(int, yyscan_t);

#ifdef INET6

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
/*
 * To quote the MSDN page for getaddrinfo() at
 *
 *    https://msdn.microsoft.com/en-us/library/windows/desktop/ms738520(v=vs.85).aspx
 *
 * "Support for getaddrinfo on Windows 2000 and older versions
 * The getaddrinfo function was added to the Ws2_32.dll on Windows XP and
 * later. To execute an application that uses this function on earlier
 * versions of Windows, then you need to include the Ws2tcpip.h and
 * Wspiapi.h files. When the Wspiapi.h include file is added, the
 * getaddrinfo function is defined to the WspiapiGetAddrInfo inline
 * function in the Wspiapi.h file. At runtime, the WspiapiGetAddrInfo
 * function is implemented in such a way that if the Ws2_32.dll or the
 * Wship6.dll (the file containing getaddrinfo in the IPv6 Technology
 * Preview for Windows 2000) does not include getaddrinfo, then a
 * version of getaddrinfo is implemented inline based on code in the
 * Wspiapi.h header file. This inline code will be used on older Windows
 * platforms that do not natively support the getaddrinfo function."
 *
 * We use getaddrinfo(), so we include Wspiapi.h here.
 */
#include <wspiapi.h>
#else /* _WIN32 */
#include <sys/socket.h>	/* for "struct sockaddr" in "struct addrinfo" */
#include <netdb.h>	/* for "struct addrinfo" */
#endif /* _WIN32 */

/* Workaround for AIX 4.3 */
#if !defined(AI_NUMERICHOST)
#define AI_NUMERICHOST 0x04
#endif

#endif /*INET6*/

#include <pcap/namedb.h>
#include "grammar.h"

#ifdef HAVE_OS_PROTO_H
#include "os-proto.h"
#endif

static int stou(const char *, YYSTYPE *, compiler_state_t *);

/*
 * Disable diagnostics in the code generated by Flex.
 */
DIAG_OFF_FLEX

#line 3206 "scanner.c"
#line 3207 "scanner.c"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#define YY_EXTRA_TYPE compiler_state_t *

/* Holds the entire state of the reentrant scanner. */
struct yyguts_t
    {

    /* User-defined. Not touched by flex. */
    YY_EXTRA_TYPE yyextra_r;

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    FILE *yyin_r, *yyout_r;
    size_t yy_buffer_stack_top; /**< index of top of stack. */
    size_t yy_buffer_stack_max; /**< capacity of stack. */
    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
    char yy_hold_char;
    int yy_n_chars;
    int yyleng_r;
    char *yy_c_buf_p;
    int yy_init;
    int yy_start;
    int yy_did_buffer_switch_on_eof;
    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int *yy_start_stack;
    yy_state_type yy_last_accepting_state;
    char* yy_last_accepting_cpos;

    int yylineno_r;
    int yy_flex_debug_r;

    char *yytext_r;
    int yy_more_flag;
    int yy_more_len;

    YYSTYPE * yylval_r;

    }; /* end struct yyguts_t */

static int yy_init_globals ( yyscan_t yyscanner );

    /* This must go here because YYSTYPE and YYLTYPE are included
     * from bison output in section 1.*/
    #    define yylval yyg->yylval_r
    
int yylex_init (yyscan_t* scanner);

int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( yyscan_t yyscanner );

int yyget_debug ( yyscan_t yyscanner );

void yyset_debug ( int debug_flag , yyscan_t yyscanner );

YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );

void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );

FILE *yyget_in ( yyscan_t yyscanner );

void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );

FILE *yyget_out ( yyscan_t yyscanner );

void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );

			int yyget_leng ( yyscan_t yyscanner );

char *yyget_text ( yyscan_t yyscanner );

int yyget_lineno ( yyscan_t yyscanner );

void yyset_lineno ( int _line_number , yyscan_t yyscanner );

int yyget_column  ( yyscan_t yyscanner );

void yyset_column ( int _column_no , yyscan_t yyscanner );

YYSTYPE * yyget_lval ( yyscan_t yyscanner );

void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( yyscan_t yyscanner );
#else
extern int yywrap ( yyscan_t yyscanner );
#endif
#endif

#ifndef YY_NO_UNPUT
    
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( yyscan_t yyscanner );
#else
static int input ( yyscan_t yyscanner );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex \
               (YYSTYPE * yylval_param , yyscan_t yyscanner);

#define YY_DECL int yylex \
               (YYSTYPE * yylval_param , yyscan_t yyscanner)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yylval = yylval_param;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
		}

		yy_load_buffer_state( yyscanner );
		}

	{
#line 273 "scanner.l"

#line 3479 "scanner.c"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 1785 )
					yy_c = yy_meta[yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 1784 );
		yy_cp = yyg->yy_last_accepting_cpos;
		yy_current_state = yyg->yy_last_accepting_state;

yy_find_action:
		yy_act = yy_accept[yy_current_state];

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 274 "scanner.l"
return DST;
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 275 "scanner.l"
return SRC;
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 277 "scanner.l"
return LINK;
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 278 "scanner.l"
return LINK;
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 279 "scanner.l"
return ARP;
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 280 "scanner.l"
return RARP;
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 281 "scanner.l"
return IP;
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 282 "scanner.l"
return SCTP;
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 283 "scanner.l"
return TCP;
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 284 "scanner.l"
return UDP;
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 285 "scanner.l"
return ICMP;
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 286 "scanner.l"
return IGMP;
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 287 "scanner.l"
return IGRP;
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 288 "scanner.l"
return PIM;
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 289 "scanner.l"
return VRRP;
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 290 "scanner.l"
return CARP;
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 291 "scanner.l"
return RADIO;
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 293 "scanner.l"
return IPV6;
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 294 "scanner.l"
return ICMPV6;
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 295 "scanner.l"
return AH;
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 296 "scanner.l"
return ESP;
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 298 "scanner.l"
return ATALK;
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 299 "scanner.l"
return AARP;
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 300 "scanner.l"
return DECNET;
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 301 "scanner.l"
return LAT;
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 302 "scanner.l"
return SCA;
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 303 "scanner.l"
return MOPRC;
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 304 "scanner.l"
return MOPDL;
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 306 "scanner.l"
return ISO;
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 307 "scanner.l"
return ESIS;
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 308 "scanner.l"
return ESIS;
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 309 "scanner.l"
return ISIS;
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 310 "scanner.l"
return ISIS;
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 311 "scanner.l"
return L1;
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 312 "scanner.l"
return L2;
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 313 "scanner.l"
return IIH;
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 314 "scanner.l"
return LSP;
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 315 "scanner.l"
return SNP;
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 316 "scanner.l"
return CSNP;
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 317 "scanner.l"
return PSNP;
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 319 "scanner.l"
return CLNP;
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 321 "scanner.l"
return STP;
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 323 "scanner.l"
return IPX;
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 325 "scanner.l"
return NETBEUI;
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 327 "scanner.l"
return HOST;
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 328 "scanner.l"
return NET;
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 329 "scanner.l"
return NETMASK;
	YY_BREAK
case 48:
YY_RULE_SETUP
#line 330 "scanner.l"
return PORT;
	YY_BREAK
case 49:
YY_RULE_SETUP
#line 331 "scanner.l"
return PORTRANGE;
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 332 "scanner.l"
return PROTO;
	YY_BREAK
case 51:
YY_RULE_SETUP
#line 333 "scanner.l"
return PROTOCHAIN;
	YY_BREAK
case 52:
YY_RULE_SETUP
#line 335 "scanner.l"
return GATEWAY;
	YY_BREAK
case 53:
YY_RULE_SETUP
#line 337 "scanner.l"
return TYPE;
	YY_BREAK
case 54:
YY_RULE_SETUP
#line 338 "scanner.l"
return SUBTYPE;
	YY_BREAK
case 55:
YY_RULE_SETUP
#line 339 "scanner.l"
return DIR;
	YY_BREAK
case 56:
YY_RULE_SETUP
#line 340 "scanner.l"
return ADDR1;
	YY_BREAK
case 57:
YY_RULE_SETUP
#line 341 "scanner.l"
return ADDR2;
	YY_BREAK
case 58:
YY_RULE_SETUP
#line 342 "scanner.l"
return ADDR3;
	YY_BREAK
case 59:
YY_RULE_SETUP
#line 343 "scanner.l"
return ADDR4;
	YY_BREAK
case 60:
YY_RULE_SETUP
#line 344 "scanner.l"
return RA;
	YY_BREAK
case 61:
YY_RULE_SETUP
#line 345 "scanner.l"
return TA;
	YY_BREAK
case 62:
YY_RULE_SETUP
#line 347 "scanner.l"
return LESS;
	YY_BREAK
case 63:
YY_RULE_SETUP
#line 348 "scanner.l"
return GREATER;
	YY_BREAK
case 64:
YY_RULE_SETUP
#line 349 "scanner.l"
return CBYTE;
	YY_BREAK
case 65:
YY_RULE_SETUP
#line 350 "scanner.l"
return TK_BROADCAST;
	YY_BREAK
case 66:
YY_RULE_SETUP
#line 351 "scanner.l"
return TK_MULTICAST;
	YY_BREAK
case 67:
YY_RULE_SETUP
#line 353 "scanner.l"
return AND;
	YY_BREAK
case 68:
YY_RULE_SETUP
#line 354 "scanner.l"
return OR;
	YY_BREAK
case 69:
YY_RULE_SETUP
#line 355 "scanner.l"
return '!';
	YY_BREAK
case 70:
YY_RULE_SETUP
#line 357 "scanner.l"
return LEN;
	YY_BREAK
case 71:
YY_RULE_SETUP
#line 358 "scanner.l"
return INBOUND;
	YY_BREAK
case 72:
YY_RULE_SETUP
#line 359 "scanner.l"
return OUTBOUND;
	YY_BREAK
case 73:
YY_RULE_SETUP
#line 361 "scanner.l"
return IFINDEX;
	YY_BREAK
case 74:
YY_RULE_SETUP
#line 363 "scanner.l"
return VLAN;
	YY_BREAK
case 75:
YY_RULE_SETUP
#line 364 "scanner.l"
return MPLS;
	YY_BREAK
case 76:
YY_RULE_SETUP
#line 365 "scanner.l"
return PPPOED;
	YY_BREAK
case 77:
YY_RULE_SETUP
#line 366 "scanner.l"
return PPPOES;
	YY_BREAK
case 78:
YY_RULE_SETUP
#line 367 "scanner.l"
return GENEVE;
	YY_BREAK
case 79:
YY_RULE_SETUP
#line 369 "scanner.l"
return LANE;
	YY_BREAK
case 80:
YY_RULE_SETUP
#line 370 "scanner.l"
return LLC;
	YY_BREAK
case 81:
YY_RULE_SETUP
#line 371 "scanner.l"
return METAC;
	YY_BREAK
case 82:
YY_RULE_SETUP
#line 372 "scanner.l"
return BCC;
	YY_BREAK
case 83:
YY_RULE_SETUP
#line 373 "scanner.l"
return OAM;
	YY_BREAK
case 84:
YY_RULE_SETUP
#line 374 "scanner.l"
return OAMF4;
	YY_BREAK
case 85:
YY_RULE_SETUP
#line 375 "scanner.l"
return OAMF4EC;
	YY_BREAK
case 86:
YY_RULE_SETUP
#line 376 "scanner.l"
return OAMF4SC;
	YY_BREAK
case 87:
YY_RULE_SETUP
#line 377 "scanner.l"
return SC;
	YY_BREAK
case 88:
YY_RULE_SETUP
#line 378 "scanner.l"
return ILMIC;
	YY_BREAK
case 89:
YY_RULE_SETUP
#line 379 "scanner.l"
return VPI;
	YY_BREAK
case 90:
YY_RULE_SETUP
#line 380 "scanner.l"
return VCI;
	YY_BREAK
case 91:
YY_RULE_SETUP
#line 381 "scanner.l"
return CONNECTMSG;
	YY_BREAK
case 92:
YY_RULE_SETUP
#line 382 "scanner.l"
return METACONNECT;
	YY_BREAK
case 93:
YY_RULE_SETUP
#line 384 "scanner.l"
return PF_IFNAME;
	YY_BREAK
case 94:
YY_RULE_SETUP
#line 385 "scanner.l"
return PF_RSET;
	YY_BREAK
case 95:
YY_RULE_SETUP
#line 386 "scanner.l"
return PF_RNR;
	YY_BREAK
case 96:
YY_RULE_SETUP
#line 387 "scanner.l"
return PF_SRNR;
	YY_BREAK
case 97:
YY_RULE_SETUP
#line 388 "scanner.l"
return PF_REASON;
	YY_BREAK
case 98:
YY_RULE_SETUP
#line 389 "scanner.l"
return PF_ACTION;
	YY_BREAK
case 99:
YY_RULE_SETUP
#line 391 "scanner.l"
return FISU;
	YY_BREAK
case 100:
YY_RULE_SETUP
#line 392 "scanner.l"
return LSSU;
	YY_BREAK
case 101:
YY_RULE_SETUP
#line 393 "scanner.l"
return LSSU;
	YY_BREAK
case 102:
YY_RULE_SETUP
#line 394 "scanner.l"
return MSU;
	YY_BREAK
case 103:
YY_RULE_SETUP
#line 395 "scanner.l"
return HFISU;
	YY_BREAK
case 104:
YY_RULE_SETUP
#line 396 "scanner.l"
return HLSSU;
	YY_BREAK
case 105:
YY_RULE_SETUP
#line 397 "scanner.l"
return HMSU;
	YY_BREAK
case 106:
YY_RULE_SETUP
#line 398 "scanner.l"
return SIO;
	YY_BREAK
case 107:
YY_RULE_SETUP
#line 399 "scanner.l"
return OPC;
	YY_BREAK
case 108:
YY_RULE_SETUP
#line 400 "scanner.l"
return DPC;
	YY_BREAK
case 109:
YY_RULE_SETUP
#line 401 "scanner.l"
return SLS;
	YY_BREAK
case 110:
YY_RULE_SETUP
#line 402 "scanner.l"
return HSIO;
	YY_BREAK
case 111:
YY_RULE_SETUP
#line 403 "scanner.l"
return HOPC;
	YY_BREAK
case 112:
YY_RULE_SETUP
#line 404 "scanner.l"
return HDPC;
	YY_BREAK
case 113:
YY_RULE_SETUP
#line 405 "scanner.l"
return HSLS;
	YY_BREAK
case 114:
/* rule 114 can match eol */
YY_RULE_SETUP
#line 407 "scanner.l"
;
	YY_BREAK
case 115:
YY_RULE_SETUP
#line 408 "scanner.l"
return yytext[0];
	YY_BREAK
case 116:
YY_RULE_SETUP
#line 409 "scanner.l"
return GEQ;
	YY_BREAK
case 117:
YY_RULE_SETUP
#line 410 "scanner.l"
return LEQ;
	YY_BREAK
case 118:
YY_RULE_SETUP
#line 411 "scanner.l"
return NEQ;
	YY_BREAK
case 119:
YY_RULE_SETUP
#line 412 "scanner.l"
return '=';
	YY_BREAK
case 120:
YY_RULE_SETUP
#line 413 "scanner.l"
return LSH;
	YY_BREAK
case 121:
YY_RULE_SETUP
#line 414 "scanner.l"
return RSH;
	YY_BREAK
case 122:
YY_RULE_SETUP
#line 415 "scanner.l"
{ yylval->s = sdup(yyextra, yytext); return AID; }
	YY_BREAK
case 123:
YY_RULE_SETUP
#line 416 "scanner.l"
{ yylval->s = sdup(yyextra, yytext); return EID; }
	YY_BREAK
case 124:
YY_RULE_SETUP
#line 417 "scanner.l"
{ return stou(yytext, yylval, yyextra); }
	YY_BREAK
case 125:
YY_RULE_SETUP
#line 418 "scanner.l"
{
			yylval->s = sdup(yyextra, (char *)yytext); return HID; }
	YY_BREAK
case 126:
YY_RULE_SETUP
#line 420 "scanner.l"
{
#ifdef INET6
			  struct addrinfo hints, *res;
			  memset(&hints, 0, sizeof(hints));
			  hints.ai_family = AF_INET6;
			  hints.ai_flags = AI_NUMERICHOST;
			  if (getaddrinfo(yytext, NULL, &hints, &res)) {
				bpf_set_error(yyextra, "bogus IPv6 address %s", yytext);
				yylval->s = NULL;
			  } else {
				freeaddrinfo(res);
				yylval->s = sdup(yyextra, (char *)yytext);
			  }
#else
			  bpf_set_error(yyextra, "IPv6 address %s not supported", yytext);
			  yylval->s = NULL;
#endif /*INET6*/
			  return HID6;
			}
	YY_BREAK
case 127:
YY_RULE_SETUP
#line 439 "scanner.l"
{ bpf_set_error(yyextra, "bogus ethernet address %s", yytext); yylval->s = NULL; return EID; }
	YY_BREAK
case 128:
YY_RULE_SETUP
#line 440 "scanner.l"
{ yylval->h = 0; return NUM; }
	YY_BREAK
case 129:
YY_RULE_SETUP
#line 441 "scanner.l"
{ yylval->h = 1; return NUM; }
	YY_BREAK
case 130:
YY_RULE_SETUP
#line 442 "scanner.l"
{ yylval->h = 0; return NUM; }
	YY_BREAK
case 131:
YY_RULE_SETUP
#line 443 "scanner.l"
{ yylval->h = 3; return NUM; }
	YY_BREAK
case 132:
YY_RULE_SETUP
#line 444 "scanner.l"
{ yylval->h = 4; return NUM; }
	YY_BREAK
case 133:
YY_RULE_SETUP
#line 445 "scanner.l"
{ yylval->h = 5; return NUM; }
	YY_BREAK
case 134:
YY_RULE_SETUP
#line 446 "scanner.l"
{ yylval->h = 8; return NUM; }
	YY_BREAK
case 135:
YY_RULE_SETUP
#line 447 "scanner.l"
{ yylval->h = 9; return NUM; }
	YY_BREAK
case 136:
YY_RULE_SETUP
#line 448 "scanner.l"
{ yylval->h = 10; return NUM; }
	YY_BREAK
case 137:
YY_RULE_SETUP
#line 449 "scanner.l"
{ yylval->h = 11; return NUM; }
	YY_BREAK
case 138:
YY_RULE_SETUP
#line 450 "scanner.l"
{ yylval->h = 12; return NUM; }
	YY_BREAK
case 139:
YY_RULE_SETUP
#line 451 "scanner.l"
{ yylval->h = 13; return NUM; }
	YY_BREAK
case 140:
YY_RULE_SETUP
#line 452 "scanner.l"
{ yylval->h = 14; return NUM; }
	YY_BREAK
case 141:
YY_RULE_SETUP
#line 453 "scanner.l"
{ yylval->h = 15; return NUM; }
	YY_BREAK
case 142:
YY_RULE_SETUP
#line 454 "scanner.l"
{ yylval->h = 16; return NUM; }
	YY_BREAK
case 143:
YY_RULE_SETUP
#line 455 "scanner.l"
{ yylval->h = 17; return NUM; }
	YY_BREAK
case 144:
YY_RULE_SETUP
#line 456 "scanner.l"
{ yylval->h = 18; return NUM; }
	YY_BREAK
case 145:
YY_RULE_SETUP
#line 458 "scanner.l"
{ yylval->h = 0; return NUM; }
	YY_BREAK
case 146:
YY_RULE_SETUP
#line 459 "scanner.l"
{ yylval->h = 1; return NUM; }
	YY_BREAK
case 147:
YY_RULE_SETUP
#line 461 "scanner.l"
{ yylval->h = 1; return NUM; }
	YY_BREAK
case 148:
YY_RULE_SETUP
#line 462 "scanner.l"
{ yylval->h = 2; return NUM; }
	YY_BREAK
case 149:
YY_RULE_SETUP
#line 463 "scanner.l"
{ yylval->h = 3; return NUM; }
	YY_BREAK
case 150:
YY_RULE_SETUP
#line 464 "scanner.l"
{ yylval->h = 4; return NUM; }
	YY_BREAK
case 151:
YY_RULE_SETUP
#line 465 "scanner.l"
{ yylval->h = 128; return NUM; }
	YY_BREAK
case 152:
YY_RULE_SETUP
#line 466 "scanner.l"
{ yylval->h = 129; return NUM; }
	YY_BREAK
case 153:
YY_RULE_SETUP
#line 467 "scanner.l"
{ yylval->h = 130; return NUM; }
	YY_BREAK
case 154:
YY_RULE_SETUP
#line 468 "scanner.l"
{ yylval->h = 131; return NUM; }
	YY_BREAK
case 155:
YY_RULE_SETUP
#line 469 "scanner.l"
{ yylval->h = 132; return NUM; }
	YY_BREAK
case 156:
YY_RULE_SETUP
#line 470 "scanner.l"
{ yylval->h = 133; return NUM; }
	YY_BREAK
case 157:
YY_RULE_SETUP
#line 471 "scanner.l"
{ yylval->h = 134; return NUM; }
	YY_BREAK
case 158:
YY_RULE_SETUP
#line 472 "scanner.l"
{ yylval->h = 135; return NUM; }
	YY_BREAK
case 159:
YY_RULE_SETUP
#line 473 "scanner.l"
{ yylval->h = 136; return NUM; }
	YY_BREAK
case 160:
YY_RULE_SETUP
#line 474 "scanner.l"
{ yylval->h = 137; return NUM; }
	YY_BREAK
case 161:
YY_RULE_SETUP
#line 475 "scanner.l"
{ yylval->h = 138; return NUM; }
	YY_BREAK
case 162:
YY_RULE_SETUP
#line 476 "scanner.l"
{ yylval->h = 139; return NUM; }
	YY_BREAK
case 163:
YY_RULE_SETUP
#line 477 "scanner.l"
{ yylval->h = 140; return NUM; }
	YY_BREAK
case 164:
YY_RULE_SETUP
#line 478 "scanner.l"
{ yylval->h = 141; return NUM; }
	YY_BREAK
case 165:
YY_RULE_SETUP
#line 479 "scanner.l"
{ yylval->h = 142; return NUM; }
	YY_BREAK
case 166:
YY_RULE_SETUP
#line 480 "scanner.l"
{ yylval->h = 143; return NUM; }
	YY_BREAK
case 167:
YY_RULE_SETUP
#line 481 "scanner.l"
{ yylval->h = 144; return NUM; }
	YY_BREAK
case 168:
YY_RULE_SETUP
#line 482 "scanner.l"
{ yylval->h = 145; return NUM; }
	YY_BREAK
case 169:
YY_RULE_SETUP
#line 483 "scanner.l"
{ yylval->h = 146; return NUM; }
	YY_BREAK
case 170:
YY_RULE_SETUP
#line 484 "scanner.l"
{ yylval->h = 147; return NUM; }
	YY_BREAK
case 171:
YY_RULE_SETUP
#line 485 "scanner.l"
{ yylval->h = 148; return NUM; }
	YY_BREAK
case 172:
YY_RULE_SETUP
#line 486 "scanner.l"
{ yylval->h = 149; return NUM; }
	YY_BREAK
case 173:
YY_RULE_SETUP
#line 487 "scanner.l"
{ yylval->h = 151; return NUM; }
	YY_BREAK
case 174:
YY_RULE_SETUP
#line 488 "scanner.l"
{ yylval->h = 152; return NUM; }
	YY_BREAK
case 175:
YY_RULE_SETUP
#line 489 "scanner.l"
{ yylval->h = 153; return NUM; }
	YY_BREAK
case 176:
YY_RULE_SETUP
#line 491 "scanner.l"
{ yylval->h = 13; return NUM; }
	YY_BREAK
case 177:
YY_RULE_SETUP
#line 492 "scanner.l"
{ yylval->h = 0x01; return NUM; }
	YY_BREAK
case 178:
YY_RULE_SETUP
#line 493 "scanner.l"
{ yylval->h = 0x02; return NUM; }
	YY_BREAK
case 179:
YY_RULE_SETUP
#line 494 "scanner.l"
{ yylval->h = 0x04; return NUM; }
	YY_BREAK
case 180:
YY_RULE_SETUP
#line 495 "scanner.l"
{ yylval->h = 0x08; return NUM; }
	YY_BREAK
case 181:
YY_RULE_SETUP
#line 496 "scanner.l"
{ yylval->h = 0x10; return NUM; }
	YY_BREAK
case 182:
YY_RULE_SETUP
#line 497 "scanner.l"
{ yylval->h = 0x20; return NUM; }
	YY_BREAK
case 183:
YY_RULE_SETUP
#line 498 "scanner.l"
{ yylval->h = 0x40; return NUM; }
	YY_BREAK
case 184:
YY_RULE_SETUP
#line 499 "scanner.l"
{ yylval->h = 0x80; return NUM; }
	YY_BREAK
case 185:
YY_RULE_SETUP
#line 500 "scanner.l"
{
			 yylval->s = sdup(yyextra, (char *)yytext); return ID; }
	YY_BREAK
case 186:
YY_RULE_SETUP
#line 502 "scanner.l"
{ yylval->s = sdup(yyextra, (char *)yytext + 1); return ID; }
	YY_BREAK
case 187:
YY_RULE_SETUP
#line 503 "scanner.l"
{ return LEX_ERROR; }
	YY_BREAK
case 188:
YY_RULE_SETUP
#line 504 "scanner.l"
ECHO;
	YY_BREAK
#line 4493 "scanner.c"
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_last_accepting_cpos;
				yy_current_state = yyg->yy_last_accepting_state;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( yywrap( yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	int number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b->yy_ch_buf,
							 (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  , yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 1785 )
				yy_c = yy_meta[yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 1785 )
			yy_c = yy_meta[yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 1784);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
	int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	*yyg->yy_c_buf_p = yyg->yy_hold_char;

	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			/* This was really a NUL. */
			*yyg->yy_c_buf_p = '\0';

		else
			{ /* need more input */
			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
			++yyg->yy_c_buf_p;

			switch ( yy_get_next_buffer( yyscanner ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin , yyscanner);

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap( yyscanner ) )
						return 0;

					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput(yyscanner);
#else
					return input(yyscanner);
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
	yyg->yy_hold_char = *++yyg->yy_c_buf_p;

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack (yyscanner);
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
	yy_load_buffer_state( yyscanner );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack (yyscanner);
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*yyg->yy_c_buf_p = yyg->yy_hold_char;
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state( yyscanner );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yyg->yy_did_buffer_switch_on_eof = 1;
}

static void yy_load_buffer_state  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	yyg->yy_hold_char = *yyg->yy_c_buf_p;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file , yyscanner);

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * @param yyscanner The scanner object.
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree( (void *) b->yy_ch_buf , yyscanner );

	yyfree( (void *) b , yyscanner );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)

{
	int oerrno = errno;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_flush_buffer( b , yyscanner);

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * @param yyscanner The scanner object.
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state( yyscanner );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack(yyscanner);

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*yyg->yy_c_buf_p = yyg->yy_hold_char;
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		yyg->yy_buffer_stack_top++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( yyscanner );
	yyg->yy_did_buffer_switch_on_eof = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if (yyg->yy_buffer_stack_top > 0)
		--yyg->yy_buffer_stack_top;

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state( yyscanner );
		yyg->yy_did_buffer_switch_on_eof = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (yyscan_t yyscanner)
{
	yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		yyg->yy_buffer_stack_max = num_to_alloc;
		yyg->yy_buffer_stack_top = 0;
		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b , yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
{
    
	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) (_yybytes_len + 2);
	buf = (char *) yyalloc( n , yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n , yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyextra;
}

/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int yyget_lineno  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (! YY_CURRENT_BUFFER)
            return 0;
    
    return yylineno;
}

/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int yyget_column  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (! YY_CURRENT_BUFFER)
            return 0;
    
    return yycolumn;
}

/** Get the input stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_in  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyin;
}

/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_out  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyout;
}

/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
int yyget_leng  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyleng;
}

/** Get the current token.
 * @param yyscanner The scanner object.
 */

char *yyget_text  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yytext;
}

/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyextra = user_defined ;
}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
    
    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( "yyset_column called with no buffer" );
    
    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int yyget_debug  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yy_flex_debug;
}

void yyset_debug (int  _bdebug , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yy_flex_debug = _bdebug ;
}

/* Accessor methods for yylval and yylloc */

YYSTYPE * yyget_lval  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yylval;
}

void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yylval = yylval_param;
}

/* User-visible API */

/* yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */
int yylex_init(yyscan_t* ptr_yy_globals)
{
    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );

    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    return yy_init_globals ( *ptr_yy_globals );
}

/* yylex_init_extra has the same functionality as yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to yyalloc in
 * the yyextra field.
 */
int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
{
    struct yyguts_t dummy_yyguts;

    yyset_extra (yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );

    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in
    yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    yyset_extra (yy_user_defined, *ptr_yy_globals);

    return yy_init_globals ( *ptr_yy_globals );
}

static int yy_init_globals (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    yyg->yy_buffer_stack = NULL;
    yyg->yy_buffer_stack_top = 0;
    yyg->yy_buffer_stack_max = 0;
    yyg->yy_c_buf_p = NULL;
    yyg->yy_init = 0;
    yyg->yy_start = 0;

    yyg->yy_start_stack_ptr = 0;
    yyg->yy_start_stack_depth = 0;
    yyg->yy_start_stack =  NULL;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state(yyscanner);
	}

	/* Destroy the stack itself. */
	yyfree(yyg->yy_buffer_stack , yyscanner);
	yyg->yy_buffer_stack = NULL;

    /* Destroy the start condition stack. */
        yyfree( yyg->yy_start_stack , yyscanner );
        yyg->yy_start_stack = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( yyscanner);

    /* Destroy the main struct (reentrant only). */
    yyfree ( yyscanner , yyscanner );
    yyscanner = NULL;
    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 504 "scanner.l"


/*
 * Turn diagnostics back on, so we check the code that we've written.
 */
DIAG_ON_FLEX

stoulen_ret
stoulen(const char *string, size_t string_len, bpf_u_int32 *val,
    compiler_state_t *cstate)
{
	bpf_u_int32 n = 0;
	unsigned int digit;
	const char *s = string;

	/*
	 * string is guaranteed either to be a string of decimal digits
	 * or 0[xX] followed by a string of hex digits.
	 */
	if (string_len >= 1 && *s == '0') {
		if (string_len >= 2  && (s[1] == 'x' || s[1] == 'X')) {
			/*
			 * Begins with 0x or 0X, so hex.
			 * Guaranteed to be all hex digits following the
			 * prefix, so anything that's not 0-9 or a-f is
			 * A-F.
			 */
			s += 2;	/* skip the prefix */
			string_len -= 2;
			while (string_len != 0) {
				digit = *s++;
				string_len--;
				if (digit >= '0' && digit <= '9')
					digit = digit - '0';
				else if (digit >= 'a' && digit <= 'f')
					digit = digit - 'a' + 10;
				else if (digit >= 'A' && digit <= 'F')
					digit = digit - 'A' + 10;
				else {
					/*
					 * Not a valid hex number.
					 * Don't treat this as an error,
					 * in case the caller wants to
					 * interpret it as something else.
					 */
					return STOULEN_NOT_HEX_NUMBER;
				}

				/*
				 * Check for overflow.
				 */
				if (n > 0xFFFFFFFU) {
					/*
					 * We have more than 28 bits of
					 * number, and are about to
					 * add 4 more; that won't fit
					 * in 32 bits.
					 */
					bpf_set_error(cstate,
					    "number %.*s overflows 32 bits",
					   (int)string_len, string);
					return STOULEN_ERROR;
				}
				n = (n << 4) + digit;
			}
		} else {
			/*
			 * Begins with 0, but not 0x or 0X, so octal.
			 * Guaranteed to be all *decimal* digits following
			 * the prefix, so we need to catch 8 and 9 and
			 * report an error.
			 */
			s += 1;
			string_len -= 1;
			while (string_len != 0) {
				digit = *s++;
				string_len--;
				if (digit >= '0' && digit <= '7')
					digit = digit - '0';
				else {
					/*
					 * Not a valid octal number.
					 * Don't treat this as an error,
					 * in case the caller wants to
					 * interpret it as something else.
					 */
					return STOULEN_NOT_OCTAL_NUMBER;
				}
				if (n > 03777777777U) {
					/*
					 * We have more than 29 bits of
					 * number, and are about to add
					 * 3 more; that won't fit in
					 * 32 bits.
					 */
					bpf_set_error(cstate,
					    "number %.*s overflows 32 bits",
					   (int)string_len, string);
					return STOULEN_ERROR;
				}
				n = (n << 3) + digit;
			}
		}
	} else {
		/*
		 * Decimal.
		 */
		while (string_len != 0) {
			digit = *s++;
			string_len--;
			if (digit >= '0' && digit <= '9')
				digit = digit - '0';
			else {
				/*
				 * Not a valid decimal number.
				 * Don't treat this as an error,
				 * in case the caller wants to
				 * interpret it as something else.
				 */
				return STOULEN_NOT_DECIMAL_NUMBER;
			}
#define CUTOFF_DEC	(0xFFFFFFFFU / 10U)
#define CUTLIM_DEC	(0xFFFFFFFFU % 10U)
			if (n > CUTOFF_DEC ||
			    (n == CUTOFF_DEC && digit > CUTLIM_DEC)) {
				/*
				 * Adding that digit will result in a
				 * number that won't fit in 32 bits.
				 */
				bpf_set_error(cstate,
				    "number %.*s overflows 32 bits",
				   (int)string_len, string);
				return STOULEN_ERROR;
			}
			n = (n * 10) + digit;
		}
	}

	*val = n;
	return STOULEN_OK;
}

/*
 * Convert string to 32-bit unsigned integer.  Just like atoi(), but checks for
 * preceding 0x or 0 and uses hex or octal instead of decimal.
 *
 * On success, sets yylval->h to the value and returns NUM.
 * On failure, sets the BPF error string and returns LEX_ERROR, to force
 * the parse to stop.
 */
static int
stou(const char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
{
	stoulen_ret ret;

	ret = stoulen(yytext_arg, strlen(yytext_arg), &yylval_arg->h,
	    yyextra_arg);
	switch (ret) {

	case STOULEN_OK:
		return NUM;

	case STOULEN_NOT_OCTAL_NUMBER:
		bpf_set_error(yyextra_arg, "number %s contains non-octal digit",
		    yytext_arg);
		return LEX_ERROR;

	case STOULEN_NOT_HEX_NUMBER:
		bpf_set_error(yyextra_arg, "number %s contains non-hex digit",
		    yytext_arg);
		return LEX_ERROR;

	case STOULEN_NOT_DECIMAL_NUMBER:
		bpf_set_error(yyextra_arg, "number %s contains non-decimal digit",
		    yytext_arg);
		return LEX_ERROR;

	case STOULEN_ERROR:
		/* Error already set. */
		return LEX_ERROR;

	default:
		/* Should not happen */
		bpf_set_error(yyextra_arg, "stoulen returned %d - this should not happen", ret);
		return LEX_ERROR;
	}
}


```

`generated/libpcap/scanner.h`:

```h
#ifndef pcap_HEADER_H
#define pcap_HEADER_H 1
#define pcap_IN_HEADER 1

#line 5 "scanner.h"
/* Must come first for _LARGE_FILE_API on AIX. */
#include <config.h>

/*
 * Must come first to avoid warnings on Windows.
 *
 * Flex-generated scanners may only include <inttypes.h> if __STDC_VERSION__
 * is defined with a value >= 199901, meaning "full C99", and MSVC may not
 * define it with that value, because it isn't 100% C99-compliant, even
 * though it has an <inttypes.h> capable of defining everything the Flex
 * scanner needs.
 *
 * We, however, will include it if we know we have an MSVC version that has
 * it; this means that we may define the INTn_MAX and UINTn_MAX values in
 * scanner.c, and then include <stdint.h>, which may define them differently
 * (same value, but different string of characters), causing compiler warnings.
 *
 * If we include it here, and they're defined, that'll prevent scanner.c
 * from defining them.  So we include <pcap/pcap-inttypes.h>, to get
 * <inttypes.h> if we have it.
 */
#include <pcap/pcap-inttypes.h>

/*
 * grammar.h requires gencode.h and sometimes breaks in a polluted namespace
 * (see ftmacros.h), so include it early.
 */
#include "gencode.h"
#include "grammar.h"

#include "diag-control.h"

/*
 * Convert string to 32-bit unsigned integer; the string starts at
 * string and is string_len bytes long.
 *
 * On success, sets *val to the value and returns 1.
 * On failure, sets the BPF error string and returns 0.
 *
 * Also used in gencode.c
 */
typedef enum {
	STOULEN_OK,
	STOULEN_NOT_HEX_NUMBER,
	STOULEN_NOT_OCTAL_NUMBER,
	STOULEN_NOT_DECIMAL_NUMBER,
	STOULEN_ERROR
} stoulen_ret;

stoulen_ret stoulen(const char *string, size_t stringlen, bpf_u_int32 *val,
    compiler_state_t *cstate);

#line 58 "scanner.h"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef yy_create_buffer
#define pcap__create_buffer_ALREADY_DEFINED
#else
#define yy_create_buffer pcap__create_buffer
#endif

#ifdef yy_delete_buffer
#define pcap__delete_buffer_ALREADY_DEFINED
#else
#define yy_delete_buffer pcap__delete_buffer
#endif

#ifdef yy_scan_buffer
#define pcap__scan_buffer_ALREADY_DEFINED
#else
#define yy_scan_buffer pcap__scan_buffer
#endif

#ifdef yy_scan_string
#define pcap__scan_string_ALREADY_DEFINED
#else
#define yy_scan_string pcap__scan_string
#endif

#ifdef yy_scan_bytes
#define pcap__scan_bytes_ALREADY_DEFINED
#else
#define yy_scan_bytes pcap__scan_bytes
#endif

#ifdef yy_init_buffer
#define pcap__init_buffer_ALREADY_DEFINED
#else
#define yy_init_buffer pcap__init_buffer
#endif

#ifdef yy_flush_buffer
#define pcap__flush_buffer_ALREADY_DEFINED
#else
#define yy_flush_buffer pcap__flush_buffer
#endif

#ifdef yy_load_buffer_state
#define pcap__load_buffer_state_ALREADY_DEFINED
#else
#define yy_load_buffer_state pcap__load_buffer_state
#endif

#ifdef yy_switch_to_buffer
#define pcap__switch_to_buffer_ALREADY_DEFINED
#else
#define yy_switch_to_buffer pcap__switch_to_buffer
#endif

#ifdef yypush_buffer_state
#define pcap_push_buffer_state_ALREADY_DEFINED
#else
#define yypush_buffer_state pcap_push_buffer_state
#endif

#ifdef yypop_buffer_state
#define pcap_pop_buffer_state_ALREADY_DEFINED
#else
#define yypop_buffer_state pcap_pop_buffer_state
#endif

#ifdef yyensure_buffer_stack
#define pcap_ensure_buffer_stack_ALREADY_DEFINED
#else
#define yyensure_buffer_stack pcap_ensure_buffer_stack
#endif

#ifdef yylex
#define pcap_lex_ALREADY_DEFINED
#else
#define yylex pcap_lex
#endif

#ifdef yyrestart
#define pcap_restart_ALREADY_DEFINED
#else
#define yyrestart pcap_restart
#endif

#ifdef yylex_init
#define pcap_lex_init_ALREADY_DEFINED
#else
#define yylex_init pcap_lex_init
#endif

#ifdef yylex_init_extra
#define pcap_lex_init_extra_ALREADY_DEFINED
#else
#define yylex_init_extra pcap_lex_init_extra
#endif

#ifdef yylex_destroy
#define pcap_lex_destroy_ALREADY_DEFINED
#else
#define yylex_destroy pcap_lex_destroy
#endif

#ifdef yyget_debug
#define pcap_get_debug_ALREADY_DEFINED
#else
#define yyget_debug pcap_get_debug
#endif

#ifdef yyset_debug
#define pcap_set_debug_ALREADY_DEFINED
#else
#define yyset_debug pcap_set_debug
#endif

#ifdef yyget_extra
#define pcap_get_extra_ALREADY_DEFINED
#else
#define yyget_extra pcap_get_extra
#endif

#ifdef yyset_extra
#define pcap_set_extra_ALREADY_DEFINED
#else
#define yyset_extra pcap_set_extra
#endif

#ifdef yyget_in
#define pcap_get_in_ALREADY_DEFINED
#else
#define yyget_in pcap_get_in
#endif

#ifdef yyset_in
#define pcap_set_in_ALREADY_DEFINED
#else
#define yyset_in pcap_set_in
#endif

#ifdef yyget_out
#define pcap_get_out_ALREADY_DEFINED
#else
#define yyget_out pcap_get_out
#endif

#ifdef yyset_out
#define pcap_set_out_ALREADY_DEFINED
#else
#define yyset_out pcap_set_out
#endif

#ifdef yyget_leng
#define pcap_get_leng_ALREADY_DEFINED
#else
#define yyget_leng pcap_get_leng
#endif

#ifdef yyget_text
#define pcap_get_text_ALREADY_DEFINED
#else
#define yyget_text pcap_get_text
#endif

#ifdef yyget_lineno
#define pcap_get_lineno_ALREADY_DEFINED
#else
#define yyget_lineno pcap_get_lineno
#endif

#ifdef yyset_lineno
#define pcap_set_lineno_ALREADY_DEFINED
#else
#define yyset_lineno pcap_set_lineno
#endif

#ifdef yyget_column
#define pcap_get_column_ALREADY_DEFINED
#else
#define yyget_column pcap_get_column
#endif

#ifdef yyset_column
#define pcap_set_column_ALREADY_DEFINED
#else
#define yyset_column pcap_set_column
#endif

#ifdef yywrap
#define pcap_wrap_ALREADY_DEFINED
#else
#define yywrap pcap_wrap
#endif

#ifdef yyget_lval
#define pcap_get_lval_ALREADY_DEFINED
#else
#define yyget_lval pcap_get_lval
#endif

#ifdef yyset_lval
#define pcap_set_lval_ALREADY_DEFINED
#else
#define yyset_lval pcap_set_lval
#endif

#ifdef yyalloc
#define pcap_alloc_ALREADY_DEFINED
#else
#define yyalloc pcap_alloc
#endif

#ifdef yyrealloc
#define pcap_realloc_ALREADY_DEFINED
#else
#define yyrealloc pcap_realloc
#endif

#ifdef yyfree
#define pcap_free_ALREADY_DEFINED
#else
#define yyfree pcap_free
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

void yyrestart ( FILE *input_file , yyscan_t yyscanner );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
void yypop_buffer_state ( yyscan_t yyscanner );

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );

void *yyalloc ( yy_size_t , yyscan_t yyscanner );
void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
void yyfree ( void * , yyscan_t yyscanner );

/* Begin user sect3 */

#define pcap_wrap(yyscanner) (/*CONSTCOND*/1)
#define YY_SKIP_YYWRAP

#define yytext_ptr yytext_r

#ifdef YY_HEADER_EXPORT_START_CONDITIONS
#define INITIAL 0

#endif

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#define YY_EXTRA_TYPE compiler_state_t *

int yylex_init (yyscan_t* scanner);

int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( yyscan_t yyscanner );

int yyget_debug ( yyscan_t yyscanner );

void yyset_debug ( int debug_flag , yyscan_t yyscanner );

YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );

void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );

FILE *yyget_in ( yyscan_t yyscanner );

void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );

FILE *yyget_out ( yyscan_t yyscanner );

void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );

			int yyget_leng ( yyscan_t yyscanner );

char *yyget_text ( yyscan_t yyscanner );

int yyget_lineno ( yyscan_t yyscanner );

void yyset_lineno ( int _line_number , yyscan_t yyscanner );

int yyget_column  ( yyscan_t yyscanner );

void yyset_column ( int _column_no , yyscan_t yyscanner );

YYSTYPE * yyget_lval ( yyscan_t yyscanner );

void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( yyscan_t yyscanner );
#else
extern int yywrap ( yyscan_t yyscanner );
#endif
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
#endif

#ifndef YY_NO_INPUT

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex \
               (YYSTYPE * yylval_param , yyscan_t yyscanner);

#define YY_DECL int yylex \
               (YYSTYPE * yylval_param , yyscan_t yyscanner)
#endif /* !YY_DECL */

/* yy_get_previous_state - get the state just before the EOB char was reached */

#undef YY_NEW_FILE
#undef YY_FLUSH_BUFFER
#undef yy_set_bol
#undef yy_new_buffer
#undef yy_set_interactive
#undef YY_DO_BEFORE_ACTION

#ifdef YY_DECL_IS_OURS
#undef YY_DECL_IS_OURS
#undef YY_DECL
#endif

#ifndef pcap__create_buffer_ALREADY_DEFINED
#undef yy_create_buffer
#endif
#ifndef pcap__delete_buffer_ALREADY_DEFINED
#undef yy_delete_buffer
#endif
#ifndef pcap__scan_buffer_ALREADY_DEFINED
#undef yy_scan_buffer
#endif
#ifndef pcap__scan_string_ALREADY_DEFINED
#undef yy_scan_string
#endif
#ifndef pcap__scan_bytes_ALREADY_DEFINED
#undef yy_scan_bytes
#endif
#ifndef pcap__init_buffer_ALREADY_DEFINED
#undef yy_init_buffer
#endif
#ifndef pcap__flush_buffer_ALREADY_DEFINED
#undef yy_flush_buffer
#endif
#ifndef pcap__load_buffer_state_ALREADY_DEFINED
#undef yy_load_buffer_state
#endif
#ifndef pcap__switch_to_buffer_ALREADY_DEFINED
#undef yy_switch_to_buffer
#endif
#ifndef pcap_push_buffer_state_ALREADY_DEFINED
#undef yypush_buffer_state
#endif
#ifndef pcap_pop_buffer_state_ALREADY_DEFINED
#undef yypop_buffer_state
#endif
#ifndef pcap_ensure_buffer_stack_ALREADY_DEFINED
#undef yyensure_buffer_stack
#endif
#ifndef pcap_lex_ALREADY_DEFINED
#undef yylex
#endif
#ifndef pcap_restart_ALREADY_DEFINED
#undef yyrestart
#endif
#ifndef pcap_lex_init_ALREADY_DEFINED
#undef yylex_init
#endif
#ifndef pcap_lex_init_extra_ALREADY_DEFINED
#undef yylex_init_extra
#endif
#ifndef pcap_lex_destroy_ALREADY_DEFINED
#undef yylex_destroy
#endif
#ifndef pcap_get_debug_ALREADY_DEFINED
#undef yyget_debug
#endif
#ifndef pcap_set_debug_ALREADY_DEFINED
#undef yyset_debug
#endif
#ifndef pcap_get_extra_ALREADY_DEFINED
#undef yyget_extra
#endif
#ifndef pcap_set_extra_ALREADY_DEFINED
#undef yyset_extra
#endif
#ifndef pcap_get_in_ALREADY_DEFINED
#undef yyget_in
#endif
#ifndef pcap_set_in_ALREADY_DEFINED
#undef yyset_in
#endif
#ifndef pcap_get_out_ALREADY_DEFINED
#undef yyget_out
#endif
#ifndef pcap_set_out_ALREADY_DEFINED
#undef yyset_out
#endif
#ifndef pcap_get_leng_ALREADY_DEFINED
#undef yyget_leng
#endif
#ifndef pcap_get_text_ALREADY_DEFINED
#undef yyget_text
#endif
#ifndef pcap_get_lineno_ALREADY_DEFINED
#undef yyget_lineno
#endif
#ifndef pcap_set_lineno_ALREADY_DEFINED
#undef yyset_lineno
#endif
#ifndef pcap_get_column_ALREADY_DEFINED
#undef yyget_column
#endif
#ifndef pcap_set_column_ALREADY_DEFINED
#undef yyset_column
#endif
#ifndef pcap_wrap_ALREADY_DEFINED
#undef yywrap
#endif
#ifndef pcap_get_lval_ALREADY_DEFINED
#undef yyget_lval
#endif
#ifndef pcap_set_lval_ALREADY_DEFINED
#undef yyset_lval
#endif
#ifndef pcap_get_lloc_ALREADY_DEFINED
#undef yyget_lloc
#endif
#ifndef pcap_set_lloc_ALREADY_DEFINED
#undef yyset_lloc
#endif
#ifndef pcap_alloc_ALREADY_DEFINED
#undef yyalloc
#endif
#ifndef pcap_realloc_ALREADY_DEFINED
#undef yyrealloc
#endif
#ifndef pcap_free_ALREADY_DEFINED
#undef yyfree
#endif
#ifndef pcap_text_ALREADY_DEFINED
#undef yytext
#endif
#ifndef pcap_leng_ALREADY_DEFINED
#undef yyleng
#endif
#ifndef pcap_in_ALREADY_DEFINED
#undef yyin
#endif
#ifndef pcap_out_ALREADY_DEFINED
#undef yyout
#endif
#ifndef pcap__flex_debug_ALREADY_DEFINED
#undef yy_flex_debug
#endif
#ifndef pcap_lineno_ALREADY_DEFINED
#undef yylineno
#endif
#ifndef pcap_tables_fload_ALREADY_DEFINED
#undef yytables_fload
#endif
#ifndef pcap_tables_destroy_ALREADY_DEFINED
#undef yytables_destroy
#endif
#ifndef pcap_TABLES_NAME_ALREADY_DEFINED
#undef yyTABLES_NAME
#endif

#line 504 "scanner.l"


#line 767 "scanner.h"
#undef pcap_IN_HEADER
#endif /* pcap_HEADER_H */

```

`generated/nDPI/ndpi_api.h`:

```h
/*
 * ndpi_api.h
 *
 * Copyright (C) 2011-24 - ntop.org
 *
 * This file is part of nDPI, an open source deep packet inspection
 * library based on the OpenDPI and PACE technology by ipoque GmbH
 *
 * nDPI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * nDPI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __NDPI_API_H__
#define __NDPI_API_H__

#include "ndpi_main.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SIZEOF_FLOW_STRUCT                    ( sizeof(struct ndpi_flow_struct) )

#define NDPI_DETECTION_ONLY_IPV4              ( 1 << 0 )
#define NDPI_DETECTION_ONLY_IPV6              ( 1 << 1 )

#define ADD_TO_DETECTION_BITMASK              1
#define NO_ADD_TO_DETECTION_BITMASK           0
#define SAVE_DETECTION_BITMASK_AS_UNKNOWN     1
#define NO_SAVE_DETECTION_BITMASK_AS_UNKNOWN  0

  /*
    In case a custom DGA function is used, the fucntion
    below must be overwritten,
  */
  extern ndpi_custom_dga_predict_fctn ndpi_dga_function;

  /**
   * Check if a string is encoded with punycode
   * ( https://tools.ietf.org/html/rfc3492 )
   *
   * @par    buff = pointer to the string to ckeck
   * @par    len  = len of the string
   * @return 1 if the string is punycoded;
   *         else 0
   *
   */
  int ndpi_check_punycode_string(char *buff, int len);


  /**
   * Get the size of the flow struct
   *
   * @return the size of the flow struct
   *
   */
  u_int32_t ndpi_detection_get_sizeof_ndpi_flow_struct(void);


  /**
   * Get the size of the flow tcp struct
   *
   * @return the size of the flow tcp struct
   *
   */
  u_int32_t ndpi_detection_get_sizeof_ndpi_flow_tcp_struct(void);


  /**
   * Get the size of the flow udp struct
   *
   * @return the size of the flow udp struct
   *
   */
  u_int32_t ndpi_detection_get_sizeof_ndpi_flow_udp_struct(void);

  /*
    Same as the API call above but used for matching raw id's added
    via ndpi_add_string_value_to_automa()
  */
  int ndpi_match_string_value(void *_automa, char *string_to_match,
			      u_int match_len, u_int32_t *num);

  /**
   * Return the protocol error code of a given flow
   *
   * @par    flow    = the flow to analyze
   * @return the error code or 0 otherwise
   *
   */
  u_int32_t ndpi_get_flow_error_code(struct ndpi_flow_struct *flow);

  /**
   * nDPI personal allocation and free functions
   **/
  void * ndpi_malloc(size_t size);
  void * ndpi_calloc(unsigned long count, size_t size);
  void * ndpi_realloc(void *ptr, size_t old_size, size_t new_size);
  char * ndpi_strdup(const char *s);
  char * ndpi_strndup(const char *s, size_t size);
  void   ndpi_free(void *ptr);
  void * ndpi_flow_malloc(size_t size);
  void   ndpi_flow_free(void *ptr);
  u_int32_t ndpi_get_tot_allocated_memory(void);

  char *ndpi_strip_leading_trailing_spaces(char *ptr, int *ptr_len) ;

  /**
   * Finds the first occurrence of the substring 'needle' in the string 'haystack'.
   *
   * This function is similar to the standard `strstr()` function, but it has an additional parameter `len` that
   * specifies the maximum length of the search.
   *
   * @param haystack The string to search in.
   * @param needle The substring to search for.
   * @param len The maximum length of the search.
   * @return Pointer to the first occurrence of 'needle' in 'haystack', or NULL if no match is found.
   */
  char *ndpi_strnstr(const char *haystack, const char *needle, size_t len);

  /**
   * Same as ndpi_strnstr but case insensitive
   *
   * @par    s     = string to parse
   * @par    find  = string to match with -s-
   * @par    slen  = max length to match between -s- and -find-
   * @return a pointer to the beginning of the located substring;
   *         NULL if the substring is not found
   *
   */
  const char* ndpi_strncasestr(const char *s, const char *find, size_t slen);

  /**
   * Returns the nDPI protocol id for IP-based protocol detection
   *
   * @par    ndpi_struct  = the struct created for the protocol detection
   * @par    pin          = IP host address (MUST BE in network byte order):
   *                        See man(7) ip for details
   * @return the nDPI protocol ID
   *
   */
  u_int16_t ndpi_network_ptree_match(struct ndpi_detection_module_struct *ndpi_struct,
				     struct in_addr *pin);

  /**
   * Returns the nDPI protocol id for IP+port-based protocol detection
   *
   * @par    ndpi_struct  = the struct created for the protocol detection
   * @par    pin          = IP host address (MUST BE in network byte order):
   *                        See man(7) ip for details
   * @par    port         = The port (MUST BE in network byte order) or
   *                        0 if ignored
   * @return the nDPI protocol ID
   *
   */
  u_int16_t ndpi_network_port_ptree_match(struct ndpi_detection_module_struct *ndpi_struct,
					  struct in_addr *pin /* network byte order */,
					  u_int16_t port /* network byte order */);
  u_int16_t ndpi_network_port_ptree6_match(struct ndpi_detection_module_struct *ndpi_struct,
					   struct in6_addr *pin,
					   u_int16_t port /* network byte order */);

  /**
   * Creates a protocol match that does not contain any hostnames.
   *
   * @par hostname_list      = the desired hostname list form which the first entry is used to create the match
   * @par empty_app_protocol = the resulting protocol match that does contain all information except the hostname
   *
   * @return 0 on success, 1 otherwise
   */
  int ndpi_init_empty_app_protocol(ndpi_protocol_match const * const hostname_list,
                                   ndpi_protocol_match * const empty_app_protocol);

  /**
   * Init single protocol match.
   *
   * @par ndpi_mod  = the struct created for the protocol detection
   * @par match     = the struct passed to match the protocol
   *
   * @return 0 on success, 1 otherwise
   */
  int ndpi_init_app_protocol(struct ndpi_detection_module_struct *ndpi_str,
                             ndpi_protocol_match const * const match);

  /**
   * Init single protocol match and adds it to the Aho-Corasick automata.
   *
   * @par ndpi_mod  = the struct created for the protocol detection
   * @par match     = the struct passed to match the protocol
   *
   */
  void ndpi_init_protocol_match(struct ndpi_detection_module_struct *ndpi_mod,
                                ndpi_protocol_match const * const match);

  /**
   * Returns a new initialized global context.
   *
   * @return  the initialized global context
   *
   */
  struct ndpi_global_context *ndpi_global_init(void);

  /**
   * Deinit a properly initialized global context.
   *
   * @par g_ctx = global context to free/deinit
   *
   */
  void ndpi_global_deinit(struct ndpi_global_context *g_ctx);

  /**
   * Returns a new initialized detection module
   * Note that before you can use it you can still load
   * hosts and do other things. As soon as you are ready to use
   * it do not forget to call first ndpi_finalize_initialization()
   *
   * You can call this function multiple times, (i.e. to create multiple
   * indipendent detection contexts) but all these calls MUST NOT run
   * in parallel
   *
   * @g_ctx = global context associated to the new detection module; NULL if no global context is needed
   * @return  the initialized detection module
   *
   */
  struct ndpi_detection_module_struct *ndpi_init_detection_module(struct ndpi_global_context *g_ctx);

  /**
   * Completes the initialization (2nd step)
   *
   * @par ndpi_str = the struct created for the protocol detection
   *
   * @return 0 on success
   *
   */
  int ndpi_finalize_initialization(struct ndpi_detection_module_struct *ndpi_str);

  /**
   * Frees the dynamic memory allocated members in the specified flow
   *
   * @par flow  = the flow struct which dynamic allocated members should be deallocated
   *
   */
  void ndpi_free_flow_data(struct ndpi_flow_struct *flow);

  /**
   * Frees the dynamic memory allocated members in the specified flow and the flow struct itself
   *
   * @par flow  = the flow struct and its dynamic allocated members that should be deallocated
   *
   */
  void ndpi_free_flow(struct ndpi_flow_struct *flow);

  /**
   * Destroys the detection module
   *
   * @par ndpi_struct  = the struct to clearing for the detection module
   *
   */
  void ndpi_exit_detection_module(struct ndpi_detection_module_struct *ndpi_struct);

  /**
   * Sets a single protocol bitmask
   * This function does not increment the index of the callback_buffer
   *
   * @par label                    = string for the protocol name
   * @par ndpi_struct              = the detection module
   * @par idx                      = the index of the callback_buffer
   * @par func                     = function pointer of the protocol search
   * @par ndpi_selection_bitmask   = the protocol selected bitmask
   * @par b_save_bitmask_unknow    = if set as "true" save the detection bitmask as unknow
   * @par b_add_detection_bitmask  = if set as "true" add the protocol bitmask to the detection bitmask
   *
   */
  void ndpi_set_bitmask_protocol_detection(char *label,
					   struct ndpi_detection_module_struct *ndpi_struct,
					   const u_int32_t idx,
					   u_int16_t ndpi_protocol_id,
					   void (*func) (struct ndpi_detection_module_struct *,
							 struct ndpi_flow_struct *flow),
					   const NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_bitmask,
					   u_int8_t b_save_bitmask_unknow,
					   u_int8_t b_add_detection_bitmask);

  /**
   * Sets the protocol bitmask2
   *
   * @par ndpi_struct        = the detection module
   * @par detection_bitmask  = the protocol bitmask to set
   * @return 0 if ok, -1 if error
   *
   */
  int ndpi_set_protocol_detection_bitmask2(struct ndpi_detection_module_struct *ndpi_struct,
					    const NDPI_PROTOCOL_BITMASK * detection_bitmask);

  /**
   *  Function to be called before we give up with detection for a given flow.
   *  This function reduces the NDPI_UNKNOWN_PROTOCOL detection
   *
   * @par    ndpi_struct  = the detection module
   * @par    flow         = the flow given for the detection module
   * @par    protocol_was_guessed = 1 if the protocol was guesses (requires enable_guess = 1), 0 otherwise
   * @return the detected protocol even if the flow is not completed;
   *
   */
  ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_struct,
				      struct ndpi_flow_struct *flow,
				      u_int8_t *protocol_was_guessed);

  /**
   * Processes an extra packet in order to get more information for a given protocol
   * (like SSL getting both client and server certificate even if we already know after
   * seeing the client certificate what the protocol is)
   *
   * @par    ndpi_struct    = the detection module
   * @par    flow           = pointer to the connection state machine
   * @par    packet         = unsigned char pointer to the Layer 3 (IP header)
   * @par    packetlen      = the length of the packet
   * @par    packet_time_ms = the current timestamp for the packet (expressed in msec)
   * @par    input_info     = (optional) flow information provided by the (external) flow manager
   * @return void
   *
   */
  void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_struct,
				 struct ndpi_flow_struct *flow,
				 const unsigned char *packet,
				 const unsigned short packetlen,
				 const u_int64_t packet_time_ms,
				 struct ndpi_flow_input_info *input_info);

  /**
   * Processes one packet and returns the ID of the detected protocol.
   * This is the MAIN PACKET PROCESSING FUNCTION.
   *
   * @par    ndpi_struct    = the detection module
   * @par    flow           = pointer to the connection state machine
   * @par    packet         = unsigned char pointer to the Layer 3 (IP header)
   * @par    packetlen      = the length of the packet
   * @par    packet_time_ms = the current timestamp for the packet (expressed in msec)
   * @par    input_info     = (optional) flow information provided by the (external) flow manager
   * @return the detected ID of the protocol
   *
   */
  ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_struct,
					      struct ndpi_flow_struct *flow,
					      const unsigned char *packet,
					      const unsigned short packetlen,
					      const u_int64_t packet_time_ms,
					      struct ndpi_flow_input_info *input_info);
  /**
   * Get the main protocol of the passed flows for the detected module
   *
   *
   * @par    flow         = the flow given for the detection module
   * @return the ID of the master protocol detected
   *
   */
  u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_flow_struct *flow);

  /**
   * Get the app protocol of the passed flows for the detected module
   *
   *
   * @par    flow         = the flow given for the detection module
   * @return the ID of the app protocol detected
   *
   */
  u_int16_t ndpi_get_flow_appprotocol(struct ndpi_flow_struct *flow);

  /**
   * Get the category of the passed flows for the detected module
   *
   *
   * @par    flow         = the flow given for the detection module
   * @return the ID of the category
   *
   */
  ndpi_protocol_category_t ndpi_get_flow_category(struct ndpi_flow_struct *flow);

  /**
   * Get the ndpi protocol data of the passed flows for the detected module
   *
   *
   * @par    flow         = the flow given for the detection module
   * @par    ndpi_proto   = the output struct where to store the requested information
   *
   */
  void ndpi_get_flow_ndpi_proto(struct ndpi_flow_struct *flow,
				struct ndpi_proto * ndpi_proto);

  /**
   * Query the pointer to the layer 4 packet
   *
   * @par    l3 = pointer to the layer 3 data
   * @par    l3_len = length of the layer 3 data
   * @par    l4_return = address to the pointer of the layer 4 data if return value == 0, else undefined
   * @par    l4_len_return = length of the layer 4 data if return value == 0, else undefined
   * @par    l4_protocol_return = protocol of the layer 4 data if return value == 0, undefined otherwise
   * @par    flags = limit operation on ipv4 or ipv6 packets. Possible values: NDPI_DETECTION_ONLY_IPV4 - NDPI_DETECTION_ONLY_IPV6 - 0 (any)
   * @return 0 if layer 4 data could be found correctly;
   else != 0
   *
   */
  u_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len,
				 const u_int8_t **l4_return, u_int16_t *l4_len_return,
				 u_int8_t *l4_protocol_return, u_int32_t flags);

  /**
   * Search and return the protocol based on matched ports
   *
   * @par    ndpi_struct  = the detection module
   * @par    shost        = source address in host byte order
   * @par    sport        = source port number
   * @par    dhost        = destination address in host byte order
   * @par    dport        = destination port number
   * @return the struct ndpi_protocol that match the port base protocol
   *
   */
  ndpi_protocol ndpi_find_port_based_protocol(struct ndpi_detection_module_struct *ndpi_struct/* , u_int8_t proto */,
					      u_int32_t shost, u_int16_t sport,
					      u_int32_t dhost, u_int16_t dport);
  /**
   * Search and return the protocol guessed that is undetected
   *
   * @par    ndpi_struct  = the detection module
   * @par    flow         = the flow we're trying to guess, NULL if not available
   * @par    proto        = the l4 protocol number
   * @return the struct ndpi_protocol that match the port base protocol
   *
   */
  ndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_struct,
					       struct ndpi_flow_struct *flow,
					       u_int8_t proto);

  /**
   * Superset of ndpi_guess_undetected_protocol with additional IPv4 guess based on host/port
   *
   * @par    ndpi_struct  = the detection module
   * @par    flow         = the flow we're trying to guess, NULL if not available
   * @par    proto        = the l4 protocol number
   * @par    shost        = source address in host byte order
   * @par    sport        = source port number
   * @par    dhost        = destination address in host byte order
   * @par    dport        = destination port number
   * @return the struct ndpi_protocol that match the port base protocol
   *
   */
  ndpi_protocol ndpi_guess_undetected_protocol_v4(struct ndpi_detection_module_struct *ndpi_struct,
						  struct ndpi_flow_struct *flow,
						  u_int8_t proto,
						  u_int32_t shost, u_int16_t sport,
						  u_int32_t dhost, u_int16_t dport);
  /**
   * Check if the string passed match with a protocol
   *
   * @par    ndpi_struct         = the detection module
   * @par    string_to_match     = the string to match
   * @par    string_to_match_len = the length of the string
   * @par    ret_match           = completed returned match information
   * @return the ID of the matched subprotocol;
   *         -1 if automa is not finalized;
   *         -2 if automa==NULL or string_to_match==NULL or empty string_to_match
   *
   */
  int ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_struct,
				    char *string_to_match,
				    u_int string_to_match_len,
				    ndpi_protocol_match_result *ret_match);
  /**
   * Check if the host passed match with a protocol
   *
   * @par    ndpi_struct         = the detection module
   * @par    flow                = the flow where match the host
   * @par    string_to_match     = the string to match
   * @par    string_to_match_len = the length of the string
   * @par    ret_match           = completed returned match information
   * @par    master_protocol_id  = value of the ID associated to the master protocol detected
   * @return the ID of the matched subprotocol
   *
   */
  u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_struct,
					struct ndpi_flow_struct *flow,
					char *string_to_match,
					u_int string_to_match_len,
					ndpi_protocol_match_result *ret_match,
					u_int16_t master_protocol_id);

  /**
   * Check if the string content passed match with a protocol
   *
   * @par    ndpi_struct         = the detection module
   * @par    flow                = the flow where match the host
   * @par    subprotocol_id      = subprotocol id
   */
  void ndpi_check_subprotocol_risk(struct ndpi_detection_module_struct *ndpi_str,
				 struct ndpi_flow_struct *flow, u_int16_t subprotocol_id);

  /**
   * Exclude protocol from search
   *
   * @par    ndpi_struct         = the detection module
   * @par    flow                = the flow where match the host
   * @par    master_protocol_id  = value of the ID associated to the master protocol detected
   *
   */
  void ndpi_exclude_protocol(struct ndpi_detection_module_struct *ndpi_struct,
			     struct ndpi_flow_struct *flow,
			     u_int16_t master_protocol_id,
			     const char *_file, const char *_func,int _line);
  /**
   * Check if the string -bigram_to_match- match with a bigram of -automa-
   *
   * @par     ndpi_mod         = the detection module
   * @par     automa           = the struct ndpi_automa for the bigram
   * @par     bigram_to_match  = the bigram string to match
   * @return  0
   *
   */
  int ndpi_match_bigram(const char *bigram_to_match);

  /**
   * Write the protocol name in the buffer -buf- as master_protocol.protocol
   *
   * @par     ndpi_mod      = the detection module
   * @par     proto         = the struct ndpi_protocol contain the protocols name
   * @par     buf           = the buffer to write the name of the protocols
   * @par     buf_len       = the length of the buffer
   * @return  the buffer contains the master_protocol and protocol name
   *
   */
  char* ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_mod,
			   ndpi_protocol proto, char *buf, u_int buf_len);

  /**
   * Same as ndpi_protocol2name() with the difference that the numeric protocol
   * name is returned
   *
   * @par     proto         = the struct ndpi_protocol contain the protocols name
   * @par     buf           = the buffer to write the name of the protocols
   * @par     buf_len       = the length of the buffer
   * @return  the buffer contains the master_protocol and protocol name
   *
   */
  char* ndpi_protocol2id(ndpi_protocol proto, char *buf, u_int buf_len);

  /**
   * Find out if a given category is custom/user-defined
   *
   * @par     category      = the category associated to the protocol
   * @return  1 if this is a custom user category, 0 otherwise
   *
   */
  int ndpi_is_custom_category(ndpi_protocol_category_t category);

  /**
   * Overwrite a protocol category defined by nDPI with the custom category
   *
   * @par     ndpi_mod      = the detection module
   * @par     protoId       = the protocol identifier to overwrite
   * @par     breed         = the breed to be associated to the protocol
   *
   */
  void ndpi_set_proto_breed(struct ndpi_detection_module_struct *ndpi_mod,
			    u_int16_t protoId, ndpi_protocol_breed_t breed);

  /**
   * Overwrite a protocol category defined by nDPI with the custom category
   *
   * @par     ndpi_mod      = the detection module
   * @par     protoId       = the protocol identifier to overwrite
   * @par     category      = the category associated to the protocol
   *
   */
  void ndpi_set_proto_category(struct ndpi_detection_module_struct *ndpi_mod,
			       u_int16_t protoId, ndpi_protocol_category_t protoCategory);

  /**
   * Check if subprotocols of the specified master protocol are just
   * informative (and not real)
   *
   * @par     protoId       = the (master) protocol identifier to query
   * @return  1 = the subprotocol is informative, 0 otherwise.
   *
   */
  u_int8_t ndpi_is_subprotocol_informative(u_int16_t protoId);

  /**
   * Set hostname-based protocol
   *
   * @par ndpi_mod          = the detection module
   * @par flow              = the flow to which this communication belongs to
   * @par master_protocol   = the master protocol for this flow
   * @par name              = the host name
   * @par name_len          = length of the host name
   *
   */
  int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_mod,
				   struct ndpi_flow_struct *flow,
				   u_int16_t master_protocol,
				   char *name, u_int name_len);

  /**
   * Get protocol category as string
   *
   * @par     mod           = the detection module
   * @par     category      = the category associated to the protocol
   * @return  the string name of the category
   *
   */
  const char* ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_mod,
				     ndpi_protocol_category_t category);

  /**
   * Get classification confidence as string
   *
   * @par     confidence      = the confidence value
   * @return  the string name of the confidence result
   *
   */
  const char* ndpi_confidence_get_name(ndpi_confidence_t confidence);

  /**
   * Get FPC confidence as string
   *
   * @par     confidence      = the confidence value
   * @return  the string name of the confidence result
   *
   */
  const char* ndpi_fpc_confidence_get_name(ndpi_fpc_confidence_t fpc_confidence);

  /**
   * Set protocol category string
   *
   * @par     mod           = the detection module
   * @par     category      = the category associated to the protocol
   * @paw     name          = the string name of the category
   *
   */
  void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_mod,
			      ndpi_protocol_category_t category, char *name);

  /**
   * Get protocol category
   *
   * @par     ndpi_mod      = the detection module
   * @par     proto         = the struct ndpi_protocol contain the protocols name
   * @return  the protocol category
   */
  ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_mod,
						   ndpi_protocol proto);

  /**
   * Get the protocol name associated to the ID
   *
   * @par     mod           = the detection module
   * @par     proto_id      = the ID of the protocol
   * @return  the buffer contains the master_protocol and protocol name
   *
   */
  char* ndpi_get_proto_name(struct ndpi_detection_module_struct *mod, u_int16_t proto_id);


  /**
   * Return the protocol breed ID associated to the protocol
   *
   * @par     ndpi_struct   = the detection module
   * @par     proto         = the ID of the protocol
   * @return  the breed ID associated to the protocol
   *
   */
  ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_struct,
					     u_int16_t proto);

  /**
   * Return the string name of the protocol breed
   *
   * @par     ndpi_struct   = the detection module
   * @par     breed_id      = the breed ID associated to the protocol
   * @return  the string name of the breed ID
   *
   */
  char* ndpi_get_proto_breed_name(ndpi_protocol_breed_t breed_id);

  /**
   * Return the name of the protocol given its ID.
   *
   * @par     ndpi_mod   = the detection module
   * @par     name       = the protocol name. You can specify TLS or YouYube but not TLS.YouTube (se ndpi_get_protocol_by_name in this case)
   * @return  the ID of the protocol
   *
   */
  extern u_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_mod, const char *name);

  /**
   * Return the name of the protocol given its ID
   *
   * @par     ndpi_mod   = the detection module
   * @par     id         = the protocol id
   * @return  the name of the protocol
   *
   */
  extern char* ndpi_get_proto_by_id(struct ndpi_detection_module_struct *ndpi_mod, u_int id);

  /**
   * Return the name of the protocol given its ID. You can specify TLS.YouTube or just TLS
   *
   * @par     ndpi_mod   = the detection module
   * @par     id         = the protocol id
   * @return  the name of the protocol
   *
   */
  extern ndpi_master_app_protocol ndpi_get_protocol_by_name(struct ndpi_detection_module_struct *ndpi_str, const char *name);

  /**
   * Return the ID of the category
   *
   * @par     ndpi_mod   = the detection module
   * @par     proto      = the category name
   * @return  the ID of the category
   *
   */
  int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_mod, char *cat);

  /**
   * Write the list of the supported protocols
   *
   * @par  ndpi_mod = the detection module
   */
  void ndpi_dump_protocols(struct ndpi_detection_module_struct *mod, FILE *dump_out);

  /**
   * Generate Options list used in OPNsense firewall plugin
   *
   * @par  opt = The Option list to generate
   * @par  dump_out = Output stream for generated options
   */
  void ndpi_generate_options(u_int opt, FILE *dump_out);

  /**
   * Write the list of the scores and their associated risks
   *
   * @par  dump_out = Output stream for dumped risk scores
   */
  void ndpi_dump_risks_score(FILE *dump_out);

  /**
   * Read a file and load the protocols
   *
   * Format: <tcp|udp>:<port>,<tcp|udp>:<port>,.....@<proto>
   *
   * Example:
   * tcp:80,tcp:3128@HTTP
   * udp:139@NETBIOS
   *
   * @par     ndpi_mod = the detection module
   * @par     path     = the path of the file
   * @return  0 if the file is loaded correctly;
   *          -1 generic error
   *          -2 memory allocation error
   *
   */
  int ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_mod,
			       const char* path);

  /**
   * Add an IP-address based risk mask
   *
   * @par     ndpi_mod = the detection module
   * @par     ip       = the IP address for which you wanna set the mask
   * @par     mask     = the IP risk mask
   * @return  0 if the rule is loaded correctly;
   *          -1 else
   */
  int ndpi_add_ip_risk_mask(struct ndpi_detection_module_struct *ndpi_mod, char *ip, ndpi_risk mask);

  /**
   * Add a host-address based risk mask
   *
   * @par     ndpi_mod = the detection module
   * @par     host     = the hostname/domain for which you wanna set the mask
   * @par     mask     = the host risk mask
   * @return  0 if the rule is loaded correctly;
   *          -1 else
   */
  int ndpi_add_host_risk_mask(struct ndpi_detection_module_struct *ndpi_mod, char *host, ndpi_risk mask);

  /**
   * Add a trusted certificate issuer DN
   *
   * @par     ndpi_mod = the detection module
   * @par     dn       = the issuer DN as it appears in the certificate (example "CN=813845657003339838, O=Code42, OU=TEST, ST=MN, C=US")
   * @return  0 if the rule is loaded correctly; < 0 in case an error is detected
   */
  int ndpi_add_trusted_issuer_dn(struct ndpi_detection_module_struct *ndpi_mod, char *dn);

  /**
   * Read a file and load the categories
   *
   * @par     ndpi_mod = the detection module
   * @par     path     = the path of the file
   * @par     user_data = pointer to some user data value
   * @return  0 if the file is loaded correctly;
   *          -1 else
   */
  int ndpi_load_categories_file(struct ndpi_detection_module_struct *ndpi_str, const char* path, void *user_data);

  /**
   * Loads a file (separated by <cr>) of domain names associated with the specified category
   *
   * @par     ndpi_mod    = the detection module
   * @par     path        = the path of the file
   * @par     category_id = Id of the category to which domains will be associated
   * @return  0 if the file is loaded correctly;
   *          -1 else
   */
  int ndpi_load_category_file(struct ndpi_detection_module_struct *ndpi_str,
			      char* path, ndpi_protocol_category_t category_id);

  /**
   * Load files (whose name is <categoryid>_<label>.<extension>) stored
   * in a directory and bind each domain to the specified category.
   *
   * @par     ndpi_mod    = the detection module
   * @par     path        = the path of the file
   * @return  0 if the file is loaded correctly;
   *          -1 else
   */
  int ndpi_load_categories_dir(struct ndpi_detection_module_struct *ndpi_str,
			       char* path);

  /**
   * Read a file and load the list of risky domains
   *
   * @par     ndpi_mod = the detection module
   * @par     path     = the path of the file
   * @return  0 if the file is loaded correctly;
   *          -1 else
   */
  int ndpi_load_risk_domain_file(struct ndpi_detection_module_struct *ndpi_str, const char* path);

  /**
   * Read a file and load the list of malicious JA3 signatures
   *
   * @par     ndpi_mod = the detection module
   * @par     path     = the path of the file
   * @return  0 if the file is loaded correctly;
   *          -1 else
   */
  int ndpi_load_malicious_ja3_file(struct ndpi_detection_module_struct *ndpi_str, const char *path);

  /**
   * Read a file and load the list of malicious SSL certificate SHA1 fingerprints.
   * @par     ndpi_mod = the detection module
   * @par     path     = the path of the file
   * @return  0 if the file is loaded correctly;
   *          -1 else
   */
  int ndpi_load_malicious_sha1_file(struct ndpi_detection_module_struct *ndpi_str, const char *path);

  /**
   * Get the total number of the supported protocols
   *
   * @par     ndpi_mod = the detection module
   * @return  the number of protocols
   *
   */
  u_int ndpi_get_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_mod);

  /**
   * Get the nDPI version release
   *
   * @return the NDPI_GIT_RELEASE
   *
   */
  char* ndpi_revision(void);

  /**
   * Set the automa for the protocol search
   *
   * @par ndpi_struct = the detection module
   * @par automa      = the automa to match
   *
   */
  void ndpi_set_automa(struct ndpi_detection_module_struct *ndpi_struct,
		       void* automa);

  /* NDPI_PROTOCOL_HTTP */
  /**
   * Retrieve information for HTTP flows
   *
   * @par     flow     = the detected flow
   * @return  the HTTP method information about the flow
   *
   */
  ndpi_http_method ndpi_get_http_method(struct ndpi_flow_struct *flow);

  /**
   * Get the HTTP url
   *
   * @par     flow     = the detected flow
   * @return  the HTTP method information about the flow
   *
   */
  char* ndpi_get_http_url(struct ndpi_flow_struct *flow);

  /**
   * Get the HTTP content-type
   *
   * @par     flow     = the detected flow
   * @return  the HTTP method information about the flow
   *
   */
  char* ndpi_get_http_content_type(struct ndpi_flow_struct *flow);

  /* NDPI_PROTOCOL_TOR */
  /**
   * Check if the flow could be detected as TOR protocol
   *
   * @par     ndpi_struct = the detection module
   * @par     flow = the detected flow
   * @par     certificate = the SSL/TLS certificate
   * @return  1 if the flow is TOR;
   *          0 else
   *
   */
  int ndpi_is_tls_tor(struct ndpi_detection_module_struct *ndpi_struct,
		      struct ndpi_flow_struct *flow, char *certificate);

  /* Wrappers functions */
  /**
   * Init Aho-Corasick automata
   *
   * @return  The requested automata, or NULL if an error occurred
   *
   */
  void* ndpi_init_automa(void);
  void *ndpi_init_automa_domain(void);

  /**
   * Free Aho-Corasick automata allocated with ndpi_init_automa();
   *
   * @par     The automata initialized with ndpi_init_automa();
   *
   */
  void ndpi_free_automa(void *_automa);

  /**
   * Add a string to match to an automata
   *
   * @par     The automata initialized with ndpi_init_automa();
   * @par     The (sub)string to search (malloc'ed memory)
   * @par     The number associated with this string
   * @return  0 in case of no error, or -2 if the string has been already addeed, or -1 if an error occurred.
   *
   */
  int ndpi_add_string_value_to_automa(void *_automa, char *str, u_int32_t num);

  /**
   * Add a string to match to an automata. Same as ndpi_add_string_value_to_automa() with num set to 1
   *
   * @par     The automata initialized with ndpi_init_automa();
   * @par     The (sub)string to search (malloc'ed memory)
   * @return  0 in case of no error, or -1 if an error occurred.
   *
   */
  int ndpi_add_string_to_automa(void *_automa, char *str);

  /**
   * Finalize the automa (necessary before start searching)
   *
   * @par     The automata initialized with ndpi_init_automa();
   *
   */
  void ndpi_finalize_automa(void *_automa);

  /**
   * Get the automa statistics
   *
   * @par     The automata initialized with ndpi_init_automa();
   *
   */

  void ndpi_automa_get_stats(void *_automa, struct ndpi_automa_stats *stats);

  /**
   * Get the statistics of one of the automas used internally by the library
   *
   * @par     ndpi_mod = the detection module
   * @par     automa_type = of which automa we want the stats
   * @par     stats = buffer where to save the stats
   * @return  0 in case of no error, or -1 if an error occurred.
   *
   */

  int ndpi_get_automa_stats(struct ndpi_detection_module_struct *ndpi_struct,
			    automa_type automa_type,
			    struct ndpi_automa_stats *stats);
  /**
   * Add a string to match to an automata
   *
   * @par     The automata initialized with ndpi_init_automa();
   * @par     The (sub)string to search
   * @return  0 in case of match, or -1 if no match, or -2 if an error occurred.
   *
   */
  int ndpi_match_string(void *_automa, char *string_to_match);

  int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_struct,
			    const char *ip_address_and_mask, ndpi_protocol_category_t category,
			    void *user_data);
  int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_struct,
				  const char *name_to_add, ndpi_protocol_category_t category);
  int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct,
			 const char *ip_or_name, ndpi_protocol_category_t category,
			 void *user_data);
  int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_struct);
  void* ndpi_find_ipv4_category_userdata(struct ndpi_detection_module_struct *ndpi_str,
					 u_int32_t saddr);
  void* ndpi_find_ipv6_category_userdata(struct ndpi_detection_module_struct *ndpi_str,
					 struct in6_addr *saddr);
  int ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_struct,
				     struct ndpi_flow_struct *flow,
				     u_int32_t saddr,
				     u_int32_t daddr,
				     ndpi_protocol *ret);
  int ndpi_fill_ipv6_protocol_category(struct ndpi_detection_module_struct *ndpi_str,
				       struct ndpi_flow_struct *flow,
				       struct in6_addr *saddr, struct in6_addr *daddr,
				      ndpi_protocol *ret);
  int ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_struct,
				 char *name, u_int name_len, ndpi_protocol_category_t *id);
  void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_struct,
				   struct ndpi_flow_struct *flow,
				   ndpi_protocol *ret);
  int ndpi_get_custom_category_match(struct ndpi_detection_module_struct *ndpi_struct,
				     char *name_or_ip, u_int name_len,
				     ndpi_protocol_category_t *id);

  u_int16_t ndpi_map_user_proto_id_to_ndpi_id(struct ndpi_detection_module_struct *ndpi_str,
					      u_int16_t user_proto_id);
  u_int16_t ndpi_map_ndpi_id_to_user_proto_id(struct ndpi_detection_module_struct *ndpi_str,
					      u_int16_t ndpi_proto_id);
  void ndpi_self_check_host_match(FILE *error_out);

  /* Tells to called on what l4 protocol given application protocol can be found */
  ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct, u_int16_t ndpi_proto_id);
  const char* ndpi_get_l4_proto_name(ndpi_l4_proto_info proto);

  u_int16_t ndpi_get_lower_proto(ndpi_protocol proto);
  u_int16_t ndpi_get_upper_proto(ndpi_protocol proto);
  bool ndpi_is_proto(ndpi_master_app_protocol proto, u_int16_t p);
  bool ndpi_is_proto_unknown(ndpi_master_app_protocol proto);
  bool ndpi_is_proto_equals(ndpi_master_app_protocol to_check, ndpi_master_app_protocol to_match, bool exact_match_only);

  ndpi_proto_defaults_t* ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_mod);
  u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_mod);
  u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_mod);
  u_int ndpi_get_ndpi_detection_module_size(void);

  /* Simple helper to get current time, in sec */
  u_int32_t ndpi_get_current_time(struct ndpi_flow_struct *flow);

  /* LRU cache */
  struct ndpi_lru_cache* ndpi_lru_cache_init(u_int32_t num_entries, u_int32_t ttl, int shared);
  void ndpi_lru_free_cache(struct ndpi_lru_cache *c);
  u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int64_t key,
			       u_int16_t *value, u_int8_t clean_key_when_found, u_int32_t now_sec);
  void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int64_t key, u_int16_t value, u_int32_t now_sec);
  void ndpi_lru_get_stats(struct ndpi_lru_cache *c, struct ndpi_lru_cache_stats *stats);

  int ndpi_get_lru_cache_stats(struct ndpi_global_context *g_ctx,
			       struct ndpi_detection_module_struct *ndpi_struct,
			       lru_cache_type cache_type,
			       struct ndpi_lru_cache_stats *stats);

  /**
   * Find a protocol id associated with a string automata
   *
   * @par     The automata initialized with ndpi_init_automa();
   * @par     The (sub)string to search
   * @par     The (sub)string length
   * @par     The protocol id associated with the matched string or 0 id not found.
   * @return  0 in case of match, or -1 if no match, or -2 if an error occurred.
   *
   */
  int ndpi_match_string_protocol_id(void *_automa, char *string_to_match, u_int match_len,
				    u_int16_t *protocol_id,
				    ndpi_protocol_category_t *category,
				    ndpi_protocol_breed_t *breed);

  void ndpi_handle_risk_exceptions(struct ndpi_detection_module_struct *ndpi_str,
				   struct ndpi_flow_struct *flow);

  /* Utility functions to set ndpi malloc/free/print wrappers */
  void set_ndpi_malloc(void* (*__ndpi_malloc)(size_t size));
  void set_ndpi_free(void  (*__ndpi_free)(void *ptr));
  void set_ndpi_flow_malloc(void* (*__ndpi_flow_malloc)(size_t size));
  void set_ndpi_flow_free(void  (*__ndpi_flow_free)(void *ptr));
  void set_ndpi_debug_function(struct ndpi_detection_module_struct *ndpi_str,
			       ndpi_debug_function_ptr ndpi_debug_printf);
  u_int16_t ndpi_get_api_version(void);
  const char *ndpi_get_gcrypt_version(void);

  /* https://github.com/corelight/community-id-spec */
  int ndpi_flowv4_flow_hash(u_int8_t l4_proto, u_int32_t src_ip, u_int32_t dst_ip, u_int16_t src_port, u_int16_t dst_port,
			    u_int8_t icmp_type, u_int8_t icmp_code, u_char *hash_buf, u_int8_t hash_buf_len);
  int ndpi_flowv6_flow_hash(u_int8_t l4_proto, struct ndpi_in6_addr *src_ip, struct ndpi_in6_addr *dst_ip,
			    u_int16_t src_port, u_int16_t dst_port, u_int8_t icmp_type, u_int8_t icmp_code,
			    u_char *hash_buf, u_int8_t hash_buf_len);
  u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,
                                          struct ndpi_flow_struct *flow);
  u_int8_t ndpi_is_safe_ssl_cipher(u_int32_t cipher);
  const char* ndpi_cipher2str(u_int32_t cipher, char unknown_cipher[8]);
  const char* ndpi_tunnel2str(ndpi_packet_tunnel tt);
  u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_struct,
					struct ndpi_flow_struct *flow);
  int ndpi_has_human_readeable_string(char *buffer, u_int buffer_size,
				      u_int8_t min_string_match_len, /* Will return 0 if no string > min_string_match_len have been found */
				      char *outbuf, u_int outbuf_len);
  /* Return a flow info string (summarized). Does only work for DNS/HTTP/TLS/QUIC. */
  const char* ndpi_get_flow_info(struct ndpi_flow_struct const * const flow,
                                 ndpi_protocol const * const l7_protocol);
  char* ndpi_ssl_version2str(char *buf, int buf_len,
                             u_int16_t version, u_int8_t *unknown_tls_version);
  char *ndpi_multimedia_flowtype2str(char *buf, int buf_len, u_int8_t m_types);
  char *ndpi_quic_version2str(char *buf, int buf_len, u_int32_t version);
  int ndpi_netbios_name_interpret(u_char *in, u_int in_len, u_char *out, u_int out_len);
  void ndpi_patchIPv6Address(char *str);
  void ndpi_user_pwd_payload_copy(u_int8_t *dest, u_int dest_len, u_int offset,
				  const u_int8_t *src, u_int src_len);
  u_char* ndpi_base64_decode(const u_char *src, size_t len, size_t *out_len);
  char* ndpi_base64_encode(unsigned char const* bytes_to_encode, size_t in_len); /* NOTE: caller MUST free the returned pointer */
  void ndpi_string_sha1_hash(const u_int8_t *message, size_t len, u_char *hash /* 20-bytes */);

  int ndpi_load_ipv4_ptree(struct ndpi_detection_module_struct *ndpi_str,
			   const char *path, u_int16_t protocol_id);
  int ndpi_dpi2json(struct ndpi_detection_module_struct *ndpi_struct,
		    struct ndpi_flow_struct *flow,
		    ndpi_protocol l7_protocol,
		    ndpi_serializer *serializer);
  int ndpi_flow2json(struct ndpi_detection_module_struct *ndpi_struct,
		     struct ndpi_flow_struct *flow,
		     u_int8_t ip_version,
		     u_int8_t l4_protocol,
		     u_int16_t vlan_id,
		     u_int32_t src_v4, u_int32_t dst_v4,
		     struct ndpi_in6_addr *src_v6, struct ndpi_in6_addr *dst_v6,
		     u_int16_t src_port, u_int16_t dst_port,
		     ndpi_protocol l7_protocol,
		     ndpi_serializer *serializer);

  char *ndpi_get_ip_proto_name(u_int16_t ip_proto, char *name, unsigned int name_len);

  const char* ndpi_http_method2str(ndpi_http_method m);
  ndpi_http_method ndpi_http_str2method(const char* method, u_int16_t method_len);

  /* Utility functions to fill prefix (used by the patricia tree) */
  int ndpi_fill_prefix_v4(ndpi_prefix_t *p, const struct in_addr *a, int b, int mb);
  int ndpi_fill_prefix_v6(ndpi_prefix_t *prefix, const struct in6_addr *addr, int bits, int maxbits);
  int ndpi_fill_prefix_mac(ndpi_prefix_t *prefix, u_int8_t *mac, int bits, int maxbits);

  /* Patricia tree API (radix tree supporting IPv4/IPv6/MAC) */
  ndpi_patricia_tree_t *ndpi_patricia_new(u_int16_t maxbits);
  ndpi_patricia_tree_t *ndpi_patricia_clone (const ndpi_patricia_tree_t * const from);
  void ndpi_patricia_destroy(ndpi_patricia_tree_t *patricia, ndpi_void_fn_t func);

  ndpi_patricia_node_t *ndpi_patricia_search_exact(ndpi_patricia_tree_t *patricia, ndpi_prefix_t *prefix);
  ndpi_patricia_node_t *ndpi_patricia_search_best(ndpi_patricia_tree_t *patricia, ndpi_prefix_t *prefix);
  ndpi_patricia_node_t *ndpi_patricia_lookup(ndpi_patricia_tree_t *patricia, ndpi_prefix_t *prefix);
  size_t ndpi_patricia_walk_tree_inorder(ndpi_patricia_tree_t *patricia, ndpi_void_fn3_t func, void *data);
  size_t ndpi_patricia_walk_inorder(ndpi_patricia_node_t *node, ndpi_void_fn3_t func, void *data);
  void ndpi_patricia_remove(ndpi_patricia_tree_t *patricia, ndpi_patricia_node_t *node);
  void ndpi_patricia_process (ndpi_patricia_tree_t *patricia, ndpi_void_fn2_t func);

  void ndpi_patricia_set_node_u64(ndpi_patricia_node_t *node, u_int64_t value);
  u_int64_t ndpi_patricia_get_node_u64(ndpi_patricia_node_t *node);
  void ndpi_patricia_set_node_data(ndpi_patricia_node_t *node, void *data);
  void *ndpi_patricia_get_node_data(ndpi_patricia_node_t *node);
  ndpi_prefix_t *ndpi_patricia_get_node_prefix(ndpi_patricia_node_t *node);
  u_int16_t ndpi_patricia_get_node_bits(ndpi_patricia_node_t *node);
  u_int16_t ndpi_patricia_get_maxbits(ndpi_patricia_tree_t *tree);
  void ndpi_patricia_get_stats(ndpi_patricia_tree_t *tree, struct ndpi_patricia_tree_stats *stats);

  int ndpi_get_patricia_stats(struct ndpi_detection_module_struct *ndpi_struct,
                              ptree_type ptree_type,
                              struct ndpi_patricia_tree_stats *stats);

  /* ptree (trie) API - a wrapper on top of Patricia that seamlessly handle IPv4 and IPv6 */
  ndpi_ptree_t* ndpi_ptree_create(void);
  int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr, u_int8_t bits, u_int64_t user_data);
  int ndpi_ptree_match_addr(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr, u_int64_t *user_data);
  int ndpi_load_ptree_file(ndpi_ptree_t *tree, const char *path, u_int16_t protocol_id);
  void ndpi_ptree_destroy(ndpi_ptree_t *tree);

  /* General purpose utilities */
  u_int8_t ndpi_is_public_ipv4(u_int32_t a /* host byte order */);
  u_int64_t ndpi_htonll(u_int64_t v);
  u_int64_t ndpi_ntohll(u_int64_t v);
  u_int8_t ndpi_is_valid_protoId(u_int16_t protoId);
  u_int8_t ndpi_is_encrypted_proto(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol proto);

  /* DGA */
  int ndpi_check_dga_name(struct ndpi_detection_module_struct *ndpi_str,
			  struct ndpi_flow_struct *flow,
			  char *name, u_int8_t is_hostname, u_int8_t check_subproto);

  /* Serializer (supports JSON, TLV, CSV) */

  /**
   * Initialize a serializer handle (allocated by the caller).
   * @param serializer The serializer handle
   * @param fmt The serialization format (ndpi_serialization_format_json, ndpi_serialization_format_tlv, ndpi_serialization_format_csv)
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_init_serializer(ndpi_serializer *serializer, ndpi_serialization_format fmt);

  /**
   * Initialize a serializer handle. Same as ndpi_init_serializer, but with some low-level settings.
   * @param serializer The serializer handle
   * @param fmt The serialization format (ndpi_serialization_format_json, ndpi_serialization_format_tlv, ndpi_serialization_format_csv)
   * @param buffer_size The initial internal buffer_size
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_init_serializer_ll(ndpi_serializer *serializer, ndpi_serialization_format fmt, u_int32_t buffer_size);

  /**
   * Release all allocated data structure.
   * @param serializer The serializer handle
   */
  void ndpi_term_serializer(ndpi_serializer *serializer);

  /**
   * Reset the serializer (cleanup the internal buffer to start a new serialization)
   * @param serializer The serializer handle
   */
  void ndpi_reset_serializer(ndpi_serializer *serializer);

  /**
   * Hint to not create the header (used to avoid creaign the header when not used)
   * @param serializer The serializer handle
   */
  void ndpi_serializer_skip_header(ndpi_serializer *serializer);

  /**
   * Serialize a 32-bit unsigned int key and a 32-bit unsigned int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_uint32(ndpi_serializer *serializer, u_int32_t key, u_int32_t value);

  /**
   * Serialize a 32-bit unsigned int key and a 64-bit unsigned int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_uint64(ndpi_serializer *serializer, u_int32_t key, u_int64_t value);

  /**
   * Serialize a 32-bit unsigned int key and a 32-bit signed int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_int32(ndpi_serializer *serializer, u_int32_t key, int32_t value);

  /**
   * Serialize a 32-bit unsigned int key and a 64-bit signed int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_int64(ndpi_serializer *serializer, u_int32_t key, int64_t value);

  /**
   * Serialize a 32-bit unsigned int key and a float value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param format The float value format
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_float(ndpi_serializer *serializer, u_int32_t key, float value, const char *format /* e.f. "%.2f" */);

  /**
   * Serialize a 32-bit unsigned int key and a double value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param format The double value format
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_double(ndpi_serializer *serializer, u_int32_t key, double value, const char *format /* e.f. "%.2f" */);

  /**
   * Serialize a 32-bit unsigned int key and a string value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_string(ndpi_serializer *serializer, u_int32_t key, const char *value);

  /**
   * Serialize a 32-bit unsigned int key and a boolean value (JSON/CSV only, not supported by TLV)
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_boolean(ndpi_serializer *serializer, u_int32_t key, u_int8_t value);

  /**
   * Serialize a 32-bit unsigned int and an unterminated string value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param vlen The value length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_uint32_binary(ndpi_serializer *serializer, u_int32_t key, const char *_value, u_int16_t vlen);

  /**
   * Serialize an unterminated string key and a 32-bit signed int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_binary_int32(ndpi_serializer *_serializer, const char *key, u_int16_t klen, int32_t value);

  /**
   * Serialize a string key and a 32-bit signed int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_int32(ndpi_serializer *serializer, const char *key, int32_t value);

  /**
   * Serialize an unterminated string key and a 64-bit signed int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_binary_int64(ndpi_serializer *_serializer, const char *key, u_int16_t klen, int64_t value);

  /**
   * Serialize a string key and a 64-bit signed int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_int64(ndpi_serializer *serializer, const char *key, int64_t value);

  /**
   * Serialize an unterminated string key and a 32-bit unsigned int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_binary_uint32(ndpi_serializer *_serializer, const char *key, u_int16_t klen, u_int32_t value);

  /**
   * Serialize a string key and a 32-bit unsigned int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_uint32(ndpi_serializer *serializer, const char *key, u_int32_t value);

  /**
   * Serialize a string key and a float value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param format The float format
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_uint32_format(ndpi_serializer *serializer, const char *key, u_int32_t value, const char *format);

  /**
   * Serialize an unterminated string key and a 64-bit unsigned int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_binary_uint64(ndpi_serializer *_serializer, const char *key, u_int16_t klen, u_int64_t value);

  /**
   * Serialize a string key and a 64-bit unsigned int value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_uint64(ndpi_serializer *serializer, const char *key, u_int64_t value);

  /**
   * Serialize an unterminated string key and an unterminated string value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @param value The field value
   * @param vlen The value length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_binary_binary(ndpi_serializer *_serializer, const char *key, u_int16_t klen, const char *_value, u_int16_t vlen);

  /**
   * Serialize a string key and a string value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_string(ndpi_serializer *serializer, const char *key, const char *value);

  /**
   * Serialize a string key and a string value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param value_len The field value length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_string_len(ndpi_serializer *serializer, const char *key,
				       const char *value, u_int16_t value_len);

  /**
   * Serialize a string key and an unterminated string value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param vlen The value length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_binary(ndpi_serializer *serializer, const char *key, const char *_value, u_int16_t vlen);

  /**
   * Serialize a string key and a raw value (this is a string which is added to the JSON without any quote or escaping)
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param vlen The value length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_raw(ndpi_serializer *_serializer, const char *key, const char *_value, u_int16_t vlen);

  /**
   * Serialize an unterminated string key and a float value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @param value The field value
   * @param format The float format
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_binary_float(ndpi_serializer *_serializer, const char *key, u_int16_t klen, float value, const char *format /* e.f. "%.2f" */);

  /**
   * Serialize an unterminated string key and a double value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @param value The field value
   * @param format The double format
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_binary_double(ndpi_serializer *_serializer, const char *key, u_int16_t klen, double value, const char *format /* e.f. "%.2f" */);

  /**
   * Serialize a string key and a a float value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param format The float format
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_float(ndpi_serializer *serializer, const char *key, float value, const char *format /* e.f. "%.2f" */);

  /**
   * Serialize a string key and a a double value
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @param format The double format
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_double(ndpi_serializer *serializer, const char *key, double value, const char *format /* e.f. "%.2f" */);

  /**
   * Serialize an unterminated string key and a boolean value (JSON/CSV only, not supported by TLV)
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_binary_boolean(ndpi_serializer *_serializer, const char *key, u_int16_t klen, u_int8_t value);

  /**
   * Serialize a string key and a boolean value (JSON/CSV only, not supported by TLV)
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_string_boolean(ndpi_serializer *serializer, const char *key, u_int8_t value);

  /**
   * Serialize a raw record in an array (this is a low-level function and its use is not recommended)
   * @param serializer The serializer handle
   * @param record The record value
   * @param record_len The record length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_raw_record(ndpi_serializer *_serializer, u_char *record, u_int32_t record_len);

  /**
   * Serialize an End-Of-Record (the current object becomes is terminated and added to an array,
   * and a new object is created where the next items will be added)
   * @param serializer The serializer handle
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_end_of_record(ndpi_serializer *serializer);

  /**
   * Serialize the start of a list with an unterminated string key, where the next serialized items
   * will be added (note: keys for the new items are ignored)
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_start_of_list_binary(ndpi_serializer *_serializer, const char *key, u_int16_t klen);

  /**
   * Serialize the start of a list, where the next serialized items will be added (note: keys for
   * the new items are ignored)
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_start_of_list(ndpi_serializer *serializer, const char *key);

  /**
   * Serialize the end of a list
   * @param serializer The serializer handle
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_end_of_list(ndpi_serializer *serializer);

  /**
   * Serialize the start of a block with an unterminated string key
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param klen The key length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_start_of_block_binary(ndpi_serializer *_serializer, const char *key, u_int16_t klen);

  /**
   * Serialize the start of a block with a string key
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_start_of_block(ndpi_serializer *serializer, const char *key);

  /**
   * Serialize the start of a block with a numeric key
   * @param serializer The serializer handle
   * @param key The numeric key as 32-bit unsigned integer.
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_start_of_block_uint32(ndpi_serializer *serializer, u_int32_t key);

  /**
   * Serialize the end of a block
   * @param serializer The serializer handle
   * @param key The field name or ID
   * @param value The field value
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serialize_end_of_block(ndpi_serializer *serializer);

  /**
   * Return the serialized buffer
   * @param serializer The serializer handle
   * @param buffer_len The buffer length (out)
   * @return The buffer
   */
  char* ndpi_serializer_get_buffer(ndpi_serializer *serializer, u_int32_t *buffer_len);

  /**
   * Return the current serialized buffer length
   * @param serializer The serializer handle
   * @return The buffer length
   */
  u_int32_t ndpi_serializer_get_buffer_len(ndpi_serializer *serializer);

  /**
   * Return the real internal buffer size (containing the serialized buffer)
   * @param serializer The serializer handle
   * @return The internal buffer size
   */
  u_int32_t ndpi_serializer_get_internal_buffer_size(ndpi_serializer *serializer);

  /**
   * Change the serializer buffer length
   * @param serializer The serializer handle
   * @param l The new buffer length
   * @return 0 on success, a negative number otherwise
   */
  int ndpi_serializer_set_buffer_len(ndpi_serializer *serializer, u_int32_t l);

  /**
   * Return the configured serialization format
   * @param serializer The serializer handle
   * @return The serialization format
   */
  ndpi_serialization_format ndpi_serializer_get_format(ndpi_serializer *serializer);

  /**
   * Set the CSV separator
   * @param serializer The serializer handle
   * @param separator The separator
   */
  void ndpi_serializer_set_csv_separator(ndpi_serializer *serializer, char separator);

  /**
   * Return the header automatically built from keys (CSV only)
   * @param serializer The serializer handle
   * @param buffer_len The buffer length (out)
   * @return The header
   */
  char* ndpi_serializer_get_header(ndpi_serializer *serializer, u_int32_t *buffer_len);

  /**
   * Create a snapshot of the internal buffer for later rollback (ndpi_serializer_rollback_snapshot)
   * @param serializer The serializer handle
   */
  void ndpi_serializer_create_snapshot(ndpi_serializer *serializer);

  /**
   * Rollback to the latest snapshot
   * @param serializer The serializer handle
   */
  void ndpi_serializer_rollback_snapshot(ndpi_serializer *serializer);

  /* Deserializer (supports TLV only) */

  int ndpi_init_deserializer(ndpi_deserializer *deserializer,
			     ndpi_serializer *serializer);
  int ndpi_init_deserializer_buf(ndpi_deserializer *deserializer,
				 u_int8_t *serialized_buffer,
				 u_int32_t serialized_buffer_len);

  ndpi_serialization_format ndpi_deserialize_get_format(ndpi_deserializer *_deserializer);
  ndpi_serialization_type ndpi_deserialize_get_item_type(ndpi_deserializer *deserializer, ndpi_serialization_type *key_type);
  int ndpi_deserialize_next(ndpi_deserializer *deserializer);

  int ndpi_deserialize_key_uint32(ndpi_deserializer *deserializer, u_int32_t *key);
  int ndpi_deserialize_key_string(ndpi_deserializer *deserializer, ndpi_string *key);

  int ndpi_deserialize_value_uint32(ndpi_deserializer *deserializer, u_int32_t *value);
  int ndpi_deserialize_value_uint64(ndpi_deserializer *deserializer, u_int64_t *value);
  int ndpi_deserialize_value_int32(ndpi_deserializer *deserializer, int32_t *value);
  int ndpi_deserialize_value_int64(ndpi_deserializer *deserializer, int64_t *value);
  int ndpi_deserialize_value_float(ndpi_deserializer *deserializer, float *value);
  int ndpi_deserialize_value_double(ndpi_deserializer *deserializer, double *value);
  int ndpi_deserialize_value_string(ndpi_deserializer *deserializer, ndpi_string *value);

  int ndpi_deserialize_clone_item(ndpi_deserializer *deserializer, ndpi_serializer *serializer);
  int ndpi_deserialize_clone_all(ndpi_deserializer *deserializer, ndpi_serializer *serializer);

  /*
   * Escape a string to be suitable for a JSON value, adding double quotes, and terminating the string with a null byte.
   * It is recommended to provide a destination buffer (dst) which is as large as double the source buffer (src) at least.
   * Upon successful return, these functions return the number of characters printed (excluding the null byte used to terminate the string).
   */
  int ndpi_json_string_escape(const char *src, int src_len, char *dst, int dst_max_len);

  /* Data analysis */
  struct ndpi_analyze_struct* ndpi_alloc_data_analysis(u_int16_t _max_series_len);
  struct ndpi_analyze_struct* ndpi_alloc_data_analysis_from_series(const u_int32_t *values, u_int16_t num_values);
  void ndpi_init_data_analysis(struct ndpi_analyze_struct *s, u_int16_t _max_series_len);
  void ndpi_free_data_analysis(struct ndpi_analyze_struct *d, u_int8_t free_pointer);
  void ndpi_reset_data_analysis(struct ndpi_analyze_struct *d);
  void ndpi_data_add_value(struct ndpi_analyze_struct *s, const u_int64_t value);

  /* Sliding-window only */
  float ndpi_data_window_average(struct ndpi_analyze_struct *s);
  float ndpi_data_window_variance(struct ndpi_analyze_struct *s);
  float ndpi_data_window_stddev(struct ndpi_analyze_struct *s);

  /* All data */
  float ndpi_data_average(struct ndpi_analyze_struct *s);
  float ndpi_data_entropy(struct ndpi_analyze_struct *s);
  float ndpi_data_variance(struct ndpi_analyze_struct *s);
  float ndpi_data_stddev(struct ndpi_analyze_struct *s);
  float ndpi_data_mean(struct ndpi_analyze_struct *s);
  u_int64_t ndpi_data_last(struct ndpi_analyze_struct *s);
  u_int64_t ndpi_data_min(struct ndpi_analyze_struct *s);
  u_int64_t ndpi_data_max(struct ndpi_analyze_struct *s);
  float ndpi_data_ratio(u_int32_t sent, u_int32_t rcvd);

  /* ******************************* */

  int ndpi_alloc_rsi(struct ndpi_rsi_struct *s, u_int16_t num_learning_values);
  void  ndpi_free_rsi(struct ndpi_rsi_struct *s);
  float ndpi_rsi_add_value(struct ndpi_rsi_struct *s, const u_int32_t value);

  /* ******************************* */

  int  ndpi_hw_init(struct ndpi_hw_struct *hw, u_int16_t num_periods, u_int8_t additive_seeasonal,
		    double alpha, double beta, double gamma, float significance);
  void ndpi_hw_free(struct ndpi_hw_struct *hw);
  int  ndpi_hw_add_value(struct ndpi_hw_struct *hw, const u_int64_t value, double *forecast,  double *confidence_band);
  void ndpi_hw_reset(struct ndpi_hw_struct *hw);

  /* ******************************* */

  int ndpi_ses_init(struct ndpi_ses_struct *ses, double alpha, float significance);
  int ndpi_ses_add_value(struct ndpi_ses_struct *ses, const double _value, double *forecast, double *confidence_band);
  void ndpi_ses_fitting(double *values, u_int32_t num_values, float *ret_alpha);
  void ndpi_ses_reset(struct ndpi_ses_struct *ses);

  /* ******************************* */

  void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]);
  void ndpi_sha256(const u_char *data, size_t data_len, u_int8_t sha_hash[32]);

  u_int16_t ndpi_crc16_ccit(const void* data, size_t n_bytes);
  u_int16_t ndpi_crc16_ccit_false(const void *data, size_t n_bytes);
  u_int16_t ndpi_crc16_xmodem(const void *data, size_t n_bytes);
  u_int16_t ndpi_crc16_x25(const void* data, size_t n_bytes);
  u_int32_t ndpi_crc32(const void *data, size_t length, u_int32_t crc);
  u_int32_t ndpi_nearest_power_of_two(u_int32_t x);

  /* ******************************* */

  u_int32_t ndpi_quick_hash(const unsigned char *str, u_int str_len);
  u_int64_t ndpi_quick_hash64(const char *str, u_int str_len);
  u_int32_t ndpi_hash_string(const char *str);
  u_int32_t ndpi_rev_hash_string(const char *str);
  u_int32_t ndpi_hash_string_len(const char *str, u_int len);
  u_int32_t ndpi_murmur_hash(const char *str, u_int str_len);

  /* ******************************* */

  u_int ndpi_hex2bin(u_char *out, u_int out_len, u_char* in, u_int in_len);
  u_int ndpi_bin2hex(u_char *out, u_int out_len, u_char* in, u_int in_len);

  /* ******************************* */

  int ndpi_des_init(struct ndpi_des_struct *des, double alpha, double beta, float significance);
  int ndpi_des_add_value(struct ndpi_des_struct *des, const double _value, double *forecast, double *confidence_band);
  void ndpi_des_fitting(double *values, u_int32_t num_values, float *ret_alpha, float *ret_beta);
  void ndpi_des_reset(struct ndpi_des_struct *des);

  /* ******************************* */

  int   ndpi_jitter_init(struct ndpi_jitter_struct *hw, u_int16_t num_periods);
  void  ndpi_jitter_free(struct ndpi_jitter_struct *hw);
  float ndpi_jitter_add_value(struct ndpi_jitter_struct *s, const float value);

  /* ******************************* */

  const char* ndpi_data_ratio2str(float ratio);

  void ndpi_data_print_window_values(struct ndpi_analyze_struct *s); /* debug */

  ndpi_risk_enum ndpi_validate_url(char *url);

  u_int8_t ndpi_is_protocol_detected(ndpi_protocol proto);
  void ndpi_serialize_risk(ndpi_serializer *serializer, ndpi_risk risk);
  void ndpi_serialize_risk_score(ndpi_serializer *serializer, ndpi_risk_enum risk);
  void ndpi_serialize_confidence(ndpi_serializer *serializer, ndpi_confidence_t confidence);
  void ndpi_serialize_proto(struct ndpi_detection_module_struct *ndpi_struct,
                            ndpi_serializer *serializer,
                            ndpi_risk risk,
                            ndpi_confidence_t confidence,
                            ndpi_protocol l7_protocol);
  const char* ndpi_risk2str(ndpi_risk_enum risk);
  const char* ndpi_risk2code(ndpi_risk_enum risk);
  ndpi_risk_enum ndpi_code2risk(const char* risk);
  const char* ndpi_severity2str(ndpi_risk_severity s);
  ndpi_risk_info* ndpi_risk2severity(ndpi_risk_enum risk);
  u_int16_t ndpi_risk2score(ndpi_risk risk,
			    u_int16_t *client_score, u_int16_t *server_score);
  char* print_ndpi_address_port(ndpi_address_port *ap, char *buf, u_int buf_len);
  u_int8_t ndpi_check_issuerdn_risk_exception(struct ndpi_detection_module_struct *ndpi_str,
					      char *issuerDN);
  u_int8_t ndpi_check_flow_risk_exceptions(struct ndpi_detection_module_struct *ndpi_str,
					   u_int num_params,
					   ndpi_risk_params params[]);

  /* ******************************* */

  /* HyperLogLog cardinality estimator [count unique items] */

  /* Memory lifecycle */
  int ndpi_hll_init(struct ndpi_hll *hll, u_int8_t bits);
  void ndpi_hll_destroy(struct ndpi_hll *hll);
  void ndpi_hll_reset(struct ndpi_hll *hll);

  /* Add values */
  int ndpi_hll_add(struct ndpi_hll *hll, const char *data, size_t data_len);
  int ndpi_hll_add_number(struct ndpi_hll *hll, u_int32_t value) ;

  /* Get cardinality estimation */
  double ndpi_hll_count(struct ndpi_hll *hll);

  /* ******************************* */

  /* Count-Min Sketch [count how many times a value has been observed] */

  struct ndpi_cm_sketch *ndpi_cm_sketch_init(u_int16_t depth);
  void ndpi_cm_sketch_add(struct ndpi_cm_sketch *sketch, u_int32_t element);
  u_int32_t ndpi_cm_sketch_count(struct ndpi_cm_sketch *sketch, u_int32_t element);
  void ndpi_cm_sketch_destroy(struct ndpi_cm_sketch *sketch);

  /* ******************************* */

  /* PopCount [count how many bits are set to 1] */

  int ndpi_popcount_init(struct ndpi_popcount *h);
  void ndpi_popcount_count(struct ndpi_popcount *h, const u_int8_t *buf, u_int32_t buf_len);

  /* ******************************* */

  /* Mahalanobis distance (https://en.wikipedia.org/wiki/Mahalanobis_distance) between a point x and a distribution with mean u and inverted covariant matrix i_s */
  float ndpi_mahalanobis_distance(const u_int32_t *x, u_int32_t size, const float *u, const float *i_s);

  /* ******************************* */

  int  ndpi_init_bin(struct ndpi_bin *b, enum ndpi_bin_family f, u_int16_t num_bins);
  void ndpi_free_bin(struct ndpi_bin *b);
  struct ndpi_bin* ndpi_clone_bin(struct ndpi_bin *b);
  void ndpi_inc_bin(struct ndpi_bin *b, u_int16_t slot_id, u_int64_t val);
  void ndpi_set_bin(struct ndpi_bin *b, u_int16_t slot_id, u_int64_t value);
  u_int64_t ndpi_get_bin_value(struct ndpi_bin *b, u_int16_t slot_id);
  void ndpi_reset_bin(struct ndpi_bin *b);
  void ndpi_normalize_bin(struct ndpi_bin *b);
  char* ndpi_print_bin(struct ndpi_bin *b, u_int8_t normalize_first, char *out_buf, u_int out_buf_len);
  float ndpi_bin_similarity(struct ndpi_bin *b1, struct ndpi_bin *b2,
			    u_int8_t normalize_first, float similarity_max_threshold);
  int ndpi_cluster_bins(struct ndpi_bin *bins, u_int16_t num_bins,
			u_int8_t num_clusters, u_int16_t *cluster_ids,
			struct ndpi_bin *centroids);

  /* ******************************* */

  /* create a kd-tree for num_dimensions vector items */
  ndpi_kd_tree* ndpi_kd_create(u_int num_dimensions);

  /* free the ndpi_kd_tree */
  void ndpi_kd_free(ndpi_kd_tree *tree);

  /* remove all the elements from the tree */
  void ndpi_kd_clear(ndpi_kd_tree *tree);

  /* insert a node, specifying its position, and optional data.
     Return true = OK, false otherwise
  */
  bool ndpi_kd_insert(ndpi_kd_tree *tree, const double *data_vector, void *user_data);

  /* Find the nearest node from a given point.
   * This function returns a pointer to a result set with at most one element.
   */
  ndpi_kd_tree_result *ndpi_kd_nearest(ndpi_kd_tree *tree, const double *data_vector);

  /* returns the size of the result set (in elements) */
  u_int32_t ndpi_kd_num_results(ndpi_kd_tree_result *res);

  /* returns the current element and updates user_data with the data put during insert */
  double* ndpi_kd_result_get_item(ndpi_kd_tree_result *res, double **user_data);

  /* frees a result set returned by kd_nearest_range() */
  void ndpi_kd_result_free(ndpi_kd_tree_result *res);

  /* Returns the distance (square root of the individual elements difference) */
  double ndpi_kd_distance(double *a1, double *b2, u_int num_dimensions);

  /* ******************************* */

  /*
    Ball Tree: similar to KD-tree but more efficient with high cardinalities

    - https://en.wikipedia.org/wiki/Ball_tree
    - https://www.geeksforgeeks.org/ball-tree-and-kd-tree-algorithms/
    - https://varshasaini.in/kd-tree-and-ball-tree-knn-algorithm/
    - https://varshasaini.in/k-nearest-neighbor-knn-algorithm-in-machine-learning/

    NOTE:
    with ball tree, data is a vector of vector pointers (no array)
  */
  ndpi_btree* ndpi_btree_init(double **data, u_int32_t n_rows, u_int32_t n_columns);
  ndpi_knn ndpi_btree_query(ndpi_btree *b, double **query_data,
			    u_int32_t query_data_num_rows, u_int32_t query_data_num_columns,
			    u_int32_t max_num_results);
  void ndpi_free_knn(ndpi_knn knn);
  void ndpi_free_btree(ndpi_btree *tree);

  /* ******************************* */

  /*
   * Finds outliers using Z-score
   * Z-Score = (Value - Mean) / StdDev
   *
   * @par    values      = pointer to the individual values to be analyzed [in]
   * @par    outliers    = pointer to a list of outliers identified        [out]
   * @par    num_values  = lenght of values and outliers that MUST have the same lenght [in]
   *
   * @return The number of outliers found
  */
  u_int ndpi_find_outliers(u_int32_t *values, bool *outliers, u_int32_t num_values);

  /* ******************************* */

  /*
   * Predicts a value using simple linear regression
   * Z-Score = (Value - Mean) / StdDev
   *
   * @par    values          = pointer to the individual values to be analyzed [in]
   * @par    num_values      = number of 'values' [in]
   * @par    predict_periods = number of periods for which we want to make the prediction [in]
   * @par    prediction      = predicted value after 'predict_periods' [out]
   *
   * @return The number of outliers found
  */
  int ndpi_predict_linear(u_int32_t *values, u_int32_t num_values,
			  u_int32_t predict_periods, u_int32_t *prediction);

  /* ******************************* */

  /*
   * Checks if the two series are correlated using the
   * Pearson correlation coefficient that is a value in the -1..0..+1 range
   * where:
   * -1 < x < 0   Negative correlation (when one changes the other series changes in opposite direction)
   * x = 0        No correlation       (no relationship between the series)
   * 0 < x < 1    Positive correlation (when one changes the other series changes in the same direction)
   * (i.e. when a series increases, the other also increase and vice-versa)
   *
   * @par    values_a   = First series with num_values values
   * @par    values_b   = Second series with num_values values
   * @par    num_values = Number of series entries
   *
   * @return pearson correlation coefficient
   *
   */
  double ndpi_pearson_correlation(u_int32_t *values_a, u_int32_t *values_b, u_int16_t num_values);

  /* ******************************* */

  /*
   * Checks if a specified value is an outlier with respect to past values
   * using the Z-score.
   *
   * @par past_valuea     = List of observed past values (past knowledge)
   * @par num_past_values = Number of observed past values
   * @par value_to_check  = The value to be checked with respect to past values
   * @par threshold       = Threshold on z-score:. Typical values:
   *                        t = 1 - The value to check should not exceed the past values
   *                        t > 1 - The value to check has to be within (t * stddev) boundaries
   * @par lower           - [out] Lower threshold
   * @par upper           - [out] Upper threshold
   *
   * @return true if the specified value is an outlier, false otherwise
   *
   */

  bool ndpi_is_outlier(u_int32_t *past_values, u_int32_t num_past_values,
		       u_int32_t value_to_check, float threshold,
		       float *lower, float *upper);

  /* ******************************* */

  u_int32_t ndpi_quick_16_byte_hash(const u_int8_t *in_16_bytes_long);

  /* ******************************* */

  /**
   * Initialize the hashmap.
   *
   * @par    h            = pointer to the hash map [in, out]
   *
   * @return 0 on success, 1 otherwise
   *
   */
  int ndpi_hash_init(ndpi_str_hash **h);

  /**
   * Free the hashmap.
   *
   * @par    h            = pointer to the hash map [in, out]
   *
   */
  void ndpi_hash_free(ndpi_str_hash **h);

  /**
   * Search for an entry in the hashmap.
   *
   * @par    h            = pointer to the hash map [in]
   * @par    key          = character string (no '\0' required) [in]
   * @par    key_len      = length of the character string @key [in]
   * @par    value        = pointer to a pointer to the value, which contains a
   *                        previously added hash entry [in, out]
   *
   * @return 0 if an entry with that key was found, 1 otherwise
   *
   */
  int ndpi_hash_find_entry(ndpi_str_hash *h, char *key, u_int key_len, u_int16_t *value);

  /**
   * Add an entry to the hashmap.
   *
   * @par    h            = pointer to the hash map [in, out]
   * @par    key          = character string (no '\0' required) [in]
   * @par    key_len      = length of the character string @key [in]
   * @par    value        = value to add [in]
   *
   * @return 0 if the entry was added, 1 otherwise
   *
   */
  int ndpi_hash_add_entry(ndpi_str_hash **h, char *key, u_int8_t key_len, u_int16_t value);

  /* ******************************* */

  int ndpi_load_geoip(struct ndpi_detection_module_struct *ndpi_str,
		      const char *ip_city_data, const char *ip_as_data);
  void ndpi_free_geoip(struct ndpi_detection_module_struct *ndpi_str);
  int ndpi_get_geoip_asn(struct ndpi_detection_module_struct *ndpi_str,
			 char *ip, u_int32_t *asn);
  int ndpi_get_geoip_country_continent(struct ndpi_detection_module_struct *ndpi_str, char *ip,
				       char *country_code, u_int8_t country_code_len,
				       char *continent, u_int8_t continent_len);

  /* ******************************* */

  char* ndpi_get_flow_name(struct ndpi_flow_struct *flow);

  /* ******************************* */

#ifndef NDPI_SLIM

  /*
    Bitmap based on compressed bitmaps
    implemented by https://roaringbitmap.org

    This is
    - NOT a probabilistic datastructure (i.e. no false positives)
    - mutable (i.e. you can add values at any time)
  */

  ndpi_bitmap* ndpi_bitmap_alloc(void);
  void ndpi_bitmap_free(ndpi_bitmap* b);
  ndpi_bitmap* ndpi_bitmap_copy(ndpi_bitmap* b);
  u_int64_t ndpi_bitmap_cardinality(ndpi_bitmap* b);
  bool ndpi_bitmap_is_empty(ndpi_bitmap* b);
  void ndpi_bitmap_set(ndpi_bitmap* b, u_int64_t value);
  void ndpi_bitmap_unset(ndpi_bitmap* b, u_int64_t value);
  bool ndpi_bitmap_isset(ndpi_bitmap* b, u_int64_t value);

  size_t ndpi_bitmap_serialize(ndpi_bitmap* b, char **buf);
  ndpi_bitmap* ndpi_bitmap_deserialize(char *buf, size_t buf_len);

  void ndpi_bitmap_and(ndpi_bitmap* a, ndpi_bitmap* b_and);
  ndpi_bitmap* ndpi_bitmap_and_alloc(ndpi_bitmap* a, ndpi_bitmap* b_and);
  void ndpi_bitmap_andnot(ndpi_bitmap* a, ndpi_bitmap* b_and);
  void ndpi_bitmap_or(ndpi_bitmap* a, ndpi_bitmap* b_or);
  ndpi_bitmap* ndpi_bitmap_ot_alloc(ndpi_bitmap* a, ndpi_bitmap* b_and);
  void ndpi_bitmap_xor(ndpi_bitmap* a, ndpi_bitmap* b_xor);
  void ndpi_bitmap_optimize(ndpi_bitmap* a);

  ndpi_bitmap_iterator* ndpi_bitmap_iterator_alloc(ndpi_bitmap* b);
  void ndpi_bitmap_iterator_free(ndpi_bitmap* b);
  bool ndpi_bitmap_iterator_next(ndpi_bitmap_iterator* i, u_int64_t *value);

  /* ******************************* */

  /*
    Bitmap with 64 bit values based
    on https://github.com/FastFilter/xor_singleheader/tree/master

    This is
    - a probabilistic datastructure !!! (i.e. be prepared to false positives)
    - immutable (i.e. adding keys after a search (i.e. ndpi_bitmap64_fuse_isset)
      is not allowed
   */

  ndpi_bitmap64_fuse* ndpi_bitmap64_fuse_alloc(void);
  bool ndpi_bitmap64_fuse_set(ndpi_bitmap64_fuse *b, u_int64_t value);
  bool ndpi_bitmap64_fuse_compress(ndpi_bitmap64_fuse *b);
  bool ndpi_bitmap64_fuse_isset(ndpi_bitmap64_fuse *b, u_int64_t value);
  void ndpi_bitmap64_fuse_free(ndpi_bitmap64_fuse *b);
  u_int32_t ndpi_bitmap64_fuse_size(ndpi_bitmap64_fuse *b);

  /* ******************************* */

  /*
    Bloom-filter on steroids based on ndpi_bitmap

    The main difference with respect to bloom filters
    is that here the filter cardinality is 2^32 and thus
    not limited as in blooms. This combined with compression
    of ndpi_bitmap creates a memory savvy datastructure at the
    price of little performance penalty due to using a
    compressed datastucture.

    The result is a datatructure with few false positives
    (see https://hur.st/bloomfilter/) computed as

    p = (1 - e(-((k * n)/m)))^k

    number of hash function (k)
    false positive rate (p)
    number of item (n)
    the number of bits (m)

    As in our case m = 2^32, k = 1, for n = 1000000
    (see https://hur.st/bloomfilter/?n=1000000&p=&m=4294967296&k=1)
    p = 2.3 x 10^-4
  */

  ndpi_filter* ndpi_filter_alloc(void);
  bool         ndpi_filter_add(ndpi_filter *f, u_int32_t value); /* returns true on success, false on failure */
  bool         ndpi_filter_add_string(ndpi_filter *f, char *string); /* returns true on success, false on failure */
  bool         ndpi_filter_contains(ndpi_filter *f, u_int32_t value); /* returns true on success, false on failure */
  bool         ndpi_filter_contains_string(ndpi_filter *f, char *string); /* returns true on success, false on failure */
  void         ndpi_filter_free(ndpi_filter *f);
  size_t       ndpi_filter_size(ndpi_filter *f);
  u_int32_t    ndpi_filter_cardinality(ndpi_filter *f);

#endif // NDPI_SLIM

  /* ******************************* */

  /*
    Efficient (space and speed) probabilitic datastructure
    for substring domain matching and classification
  */

  ndpi_domain_classify* ndpi_domain_classify_alloc(void);
  void ndpi_domain_classify_free(ndpi_domain_classify *s);
  u_int32_t ndpi_domain_classify_size(ndpi_domain_classify *s);
  bool ndpi_domain_classify_add(struct ndpi_detection_module_struct *ndpi_mod,
				ndpi_domain_classify *s,
				u_int16_t class_id, char *domain);
  u_int32_t ndpi_domain_classify_add_domains(struct ndpi_detection_module_struct *ndpi_mod,
					     ndpi_domain_classify *s,
					     u_int16_t class_id,
					     char *file_path);
  bool ndpi_domain_classify_hostname(struct ndpi_detection_module_struct *ndpi_mod,
				     ndpi_domain_classify *s,
				     u_int16_t *class_id /* out */,
				     char *hostname);

  /* ******************************* */

  /*
    Similar to ndpi_filter but based on binary search and with the
    ability to store a category per value (as ndpi_domain_classify)
  */
  ndpi_binary_bitmap* ndpi_binary_bitmap_alloc(void);
  bool ndpi_binary_bitmap_set(ndpi_binary_bitmap *b, u_int64_t value, u_int8_t category);
  bool ndpi_binary_bitmap_compress(ndpi_binary_bitmap *b);
  bool ndpi_binary_bitmap_isset(ndpi_binary_bitmap *b, u_int64_t value, u_int8_t *out_category);
  void ndpi_binary_bitmap_free(ndpi_binary_bitmap *b);
  u_int32_t ndpi_binary_bitmap_size(ndpi_binary_bitmap *b);
  u_int32_t ndpi_binary_bitmap_cardinality(ndpi_binary_bitmap *b);

  /* ******************************* */


  /* ******************************* */

  char* ndpi_get_flow_risk_info(struct ndpi_flow_struct *flow,
				char *out, u_int out_len,
				u_int8_t use_json);

  /* ******************************* */

  /**
   * Set user data which can later retrieved with `ndpi_get_user_data()`.
   *
   * @par ndpi_str = the struct created for the protocol detection
   * @par user_data = user data pointer you want to retrieve later with `ndpi_get_user_data()`
   *
   */
  void ndpi_set_user_data(struct ndpi_detection_module_struct *ndpi_str, void *user_data);

  /**
   * Get user data which was previously set with `ndpi_set_user_data()`.
   *
   * @par ndpi_str = the struct created for the protocol detection
   *
   * @return the user data pointer
   *
   */
  void *ndpi_get_user_data(struct ndpi_detection_module_struct *ndpi_str);

  /* ******************************* */

  /**
   * Loads the domain suffixes from the specified path. You need to
   * perform this action once
   *
   * @par ndpi_str = the struct created for the protocol detection
   * @par public_suffix_list_path = path of the public_suffix_list path
   *
   * @return 0 = no error, -1 otherwise
   *
   */
  int ndpi_load_domain_suffixes(struct ndpi_detection_module_struct *ndpi_str,
				char *public_suffix_list_path);

  /**
   * Returns the domain suffix out of the specified hostname.
   * The returned pointer is an offset of the original hostname.
   * Note that you need to call ndpi_load_domain_suffixes() before
   * calling this function.
   *
   * @par ndpi_str = the struct created for the protocol detection
   * @par hostname = the hostname from which the domain name has to be extracted
   * @par suffix_id = the id of the returned domain
   *
   * @return The host domain name suffic or the host itself if not found.
   *
   */
  const char* ndpi_get_host_domain_suffix(struct ndpi_detection_module_struct *ndpi_str,
					  const char *hostname,
					  u_int16_t *suffix_id /* out */);

  /**
   * Returns the domain (including the TLS) suffix out of the specified hostname.
   * The returned pointer is an offset of the original hostname.
   * Note that you need to call ndpi_load_domain_suffixes() before
   * calling this function.
   *
   * @par ndpi_str = the struct created for the protocol detection
   * @par hostname = the hostname from which the domain name has to be extracted
   *
   * @return The host domain name or the hosti tself if not found.
   *
   */
  const char* ndpi_get_host_domain(struct ndpi_detection_module_struct *ndpi_str,
				   const char *hostname);

  /* ******************************* */

  ndpi_cfg_error ndpi_set_config(struct ndpi_detection_module_struct *ndpi_str,
                                 const char *proto, const char *param, const char *value);
  ndpi_cfg_error ndpi_set_config_u64(struct ndpi_detection_module_struct *ndpi_str,
                                     const char *proto, const char *param, uint64_t value);
  char *ndpi_get_config(struct ndpi_detection_module_struct *ndpi_str,
			const char *proto, const char *param, char *buf, int buf_len);
  char *ndpi_dump_config(struct ndpi_detection_module_struct *ndpi_str,
			 FILE *fd);

  /* ******************************* */

  /* Can't call libc functions from kernel space, define some stub instead */

#define ndpi_isalpha(ch) (((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z'))
#define ndpi_isdigit(ch) ((ch) >= '0' && (ch) <= '9')
#define ndpi_isalnum(ch) (ndpi_isalpha(ch) != 0 || ndpi_isdigit(ch) != 0)
#define ndpi_isspace(ch) (((ch) >= '\t' && (ch) <= '\r') || ((ch) == ' '))
#define ndpi_isprint(ch) ((ch) >= 0x20 && (ch) <= 0x7e)
#define ndpi_ispunct(ch) (((ch) >= '!' && (ch) <= '/') ||   \
              ((ch) >= ':' && (ch) <= '@') ||   \
              ((ch) >= '[' && (ch) <= '`') ||   \
              ((ch) >= '{' && (ch) <= '~'))

  /* ******************************* */

  int64_t ndpi_strtonum(const char *numstr, int64_t minval, int64_t maxval, const char **errstrp, int base);
  int ndpi_vsnprintf(char * str, size_t size, char const * format, va_list va_args);
  int ndpi_snprintf(char * str, size_t size, char const * format, ...);
  struct tm *ndpi_gmtime_r(const time_t *timep, struct tm *result);
  char* ndpi_strrstr(const char *haystack, const char *needle);
  int ndpi_str_endswith(const char *s, const char *suffix);

  /* ******************************* */

  size_t ndpi_compress_str(const char * in, size_t len, char * out, size_t bufsize);
  size_t ndpi_decompress_str(const char * in, size_t len, char * out, size_t bufsize);

  /* ******************************* */

  /* NOTE
     this function works best if yout have loaded in memory domain
     suffixes using ndpi_load_domain_suffixes()
  */
  u_int ndpi_encode_domain(struct ndpi_detection_module_struct *ndpi_str,
			   char *domain, char *out, u_int out_len);

  /* ******************************* */

  char* ndpi_quick_encrypt(const char *cleartext_msg,
			   u_int16_t cleartext_msg_len,
			   u_int16_t *encrypted_msg_len,
			   u_char encrypt_key[64]);

  char* ndpi_quick_decrypt(const char *encrypted_msg,
			   u_int16_t encrypted_msg_len,
			   u_int16_t *decrypted_msg_len,
			   u_char decrypt_key[64]);

  /* ******************************* */

  const char* ndpi_print_os_hint(u_int8_t os_hint);

  /* ******************************* */

  bool ndpi_serialize_flow_fingerprint(struct ndpi_detection_module_struct *ndpi_str,
				       struct ndpi_flow_struct *flow, ndpi_serializer *serializer);

  /* ******************************* */

  /* Address cache API */
  struct ndpi_address_cache* ndpi_init_address_cache(u_int32_t max_num_entries);
  void ndpi_term_address_cache(struct ndpi_address_cache *cache);
  u_int32_t ndpi_address_cache_flush_expired(struct ndpi_address_cache *cache, u_int32_t epoch_now);
  struct ndpi_address_cache_item* ndpi_address_cache_find(struct ndpi_address_cache *cache, ndpi_ip_addr_t ip_addr, u_int32_t epoch_now);
  bool ndpi_address_cache_insert(struct ndpi_address_cache *cache, ndpi_ip_addr_t ip_addr, char *hostname,
				 u_int32_t epoch_now, u_int32_t ttl);
  bool ndpi_address_cache_dump(struct ndpi_address_cache *cache, char *path, u_int32_t epoch_now);
  u_int32_t ndpi_address_cache_restore(struct ndpi_address_cache *cache, char *path, u_int32_t epoch_now);


  bool ndpi_cache_address(struct ndpi_detection_module_struct *ndpi_struct,
			ndpi_ip_addr_t ip_addr, char *hostname,
			  u_int32_t epoch_now, u_int32_t ttl);
  struct ndpi_address_cache_item* ndpi_cache_address_find(struct ndpi_detection_module_struct *ndpi_struct, ndpi_ip_addr_t ip_addr);
  bool ndpi_cache_address_dump(struct ndpi_detection_module_struct *ndpi_struct, char *path, u_int32_t epoch_now);
  u_int32_t ndpi_cache_address_restore(struct ndpi_detection_module_struct *ndpi_struct, char *path, u_int32_t epoch_now);
  u_int32_t ndpi_cache_address_flush_expired(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t epoch_now);

  /* ******************************* */

  const char *ndpi_lru_cache_idx_to_name(lru_cache_type idx);

  /**
   * @brief Finds the first occurrence of the sequence `needle` in the array
   * `haystack`.
   *
   * This function searches for the first occurrence of the sequence `needle` of
   * length `needle_len` in the array `haystack` of length `haystack_len`. If
   * `haystack` or `needle` is `NULL`, or `haystack_len` is less than
   * `needle_len`, or `needle_len` is 0, the function returns `NULL`.
   *
   * For optimization, if `needle_len` is 1, the `memchr` function is used.
   *
   * @param haystack Pointer to the array in which the search is performed.
   * @param haystack_len Length of the `haystack` array.
   * @param needle Pointer to the array to be searched for in `haystack`.
   * @param needle_len Length of the `needle` array.
   * @return Pointer to the first occurrence of `needle` in `haystack` or `NULL`
   * if `needle` is not found.
   */
  void* ndpi_memmem(const void* haystack, size_t haystack_len, const void* needle,
                    size_t needle_len);

  /**
   * @brief Copies src string to dst buffer with length limit
   *
   * Copies the string src into dst buffer, limiting the copy length by dst_len.
   * Handles both null-terminated and non null-terminated strings based on
   * src_len. Ensures null-termination in dst if dst_len > 0.
   *
   * @param dst Destination buffer
   * @param src Source string
   * @param dst_len Size of dst buffer
   * @param src_len Length of src string
   *
   * @return Length of src string
   */
  size_t ndpi_strlcpy(char* dst, const char* src, size_t dst_len, size_t src_len);

#ifdef __cplusplus
}
#endif

#endif	/* __NDPI_API_H__ */

```

`generated/nDPI/ndpi_config.h`:

```h
/* src/include/ndpi_config.h.  Generated from ndpi_config.h.in by configure.  */
/* src/include/ndpi_config.h.in.  Generated from configure.ac by autoheader.  */

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you have the <float.h> header file. */
#define HAVE_FLOAT_H 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the 'gcrypt' library (-lgcrypt). */
/* #undef HAVE_LIBGCRYPT */

/* Define to 1 if you have the 'gpg-error' library (-lgpg-error). */
/* #undef HAVE_LIBGPG_ERROR */

/* libjson-c is present */
/* #undef HAVE_LIBJSON_C */

/* Define to 1 if you have the 'm' library (-lm). */
/* #undef HAVE_LIBM */

/* Define to 1 if you have the 'maxminddb' library (-lmaxminddb). */
/* #undef HAVE_LIBMAXMINDDB */

/* Define to 1 if you have the 'pcap' library (-lpcap). */
/* #undef HAVE_LIBPCAP */

/* Define to 1 if you have the 'pthread' library (-lpthread). */
/* #undef HAVE_LIBPTHREAD */

/* Define to 1 if you have the <math.h> header file. */
#define HAVE_MATH_H 1

/* MaxMind DB support */
/* #undef HAVE_MAXMINDDB */

/* Define to 1 if you have the <maxminddb.h> header file. */
/* #undef HAVE_MAXMINDDB_H */

/* PF_RING nBPF is present */
/* #undef HAVE_NBPF */

/* Define to 1 if you have the <netinet/in.h> header file. */
#define HAVE_NETINET_IN_H 1

/* libpcre2(-dev) is present */
/* #undef HAVE_PCRE2 */

/* Define if you have POSIX threads libraries and header files. */
/* #undef HAVE_PTHREAD */

/* Have PTHREAD_PRIO_INHERIT. */
/* #undef HAVE_PTHREAD_PRIO_INHERIT */

/* libc has pthread_setaffinity_np */
/* #undef HAVE_PTHREAD_SETAFFINITY_NP */

/* rrdtool is present */
/* #undef HAVE_RRDTOOL */

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdio.h> header file. */
#define HAVE_STDIO_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to the sub-directory where libtool stores uninstalled libraries. */
#define LT_OBJDIR ".libs/"

/* nDPI base directory */
#define NDPI_BASE_DIR "/home/emanuele/src/PCAPdroid/submodules/nDPI"

/* Enable ndpi_debug_messages */
/* #undef NDPI_ENABLE_DEBUG_MESSAGES */

/* Last GIT change */
#define NDPI_GIT_DATE "Sat Mar 22 16:35:45 2025 +0100"

/* GIT Release */
#define NDPI_GIT_RELEASE "4.12.0-5035-ce606bf"

/* nDPI major release */
#define NDPI_MAJOR_RELEASE "4"

/* nDPI minor release */
#define NDPI_MINOR_RELEASE "12"

/* nDPI patch level */
#define NDPI_PATCH_LEVEL "0"

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* Name of package */
#define PACKAGE "libndpi"

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT ""

/* Define to the full name of this package. */
#define PACKAGE_NAME "libndpi"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "libndpi 4.12.0"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "libndpi"

/* Define to the home page for this package. */
#define PACKAGE_URL ""

/* Define to the version of this package. */
#define PACKAGE_VERSION "4.12.0"

/* Define to necessary symbol if this constant uses a non-standard name on
   your system. */
/* #undef PTHREAD_CREATE_JOINABLE */

/* Define to 1 if all of the C89 standard headers exist (not just the ones
   required in a freestanding environment). This macro is provided for
   backward compatibility; new code need not use it. */
#define STDC_HEADERS 1

/* Use locally installed libgcrypt instead of builtin gcrypt-light */
/* #undef USE_HOST_LIBGCRYPT */

/* Use CRoaring 2.1.x */
/* #undef USE_ROARING_V2 */

/* Version number of package */
#define VERSION "4.12.0"

/* Define to '__inline__' or '__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
#ifndef __cplusplus
/* #undef inline */
#endif

```

`generated/nDPI/ndpi_define.h`:

```h
/*
 *
 * Copyright (C) 2011-17 - ntop.org
 *
 * This file is part of nDPI, an open source deep packet inspection
 * library based on the OpenDPI and PACE technology by ipoque GmbH
 *
 * nDPI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * nDPI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __NDPI_DEFINE_INCLUDE_FILE__
#define __NDPI_DEFINE_INCLUDE_FILE__

#include <stdint.h>
#include <string.h>

/*
 * The #define below is used for apps that dynamically link with nDPI to make
 * sure that datastructures and in sync across versions
 */
#define NDPI_API_VERSION 11721

/*
  gcc -E -dM - < /dev/null |grep ENDIAN
*/

#if defined(__FreeBSD__) || defined(__NetBSD__)
#include <sys/endian.h>
#endif

#ifdef __OpenBSD__
#include <endian.h>
#define __BYTE_ORDER BYTE_ORDER
#if BYTE_ORDER == LITTLE_ENDIAN
#ifndef __LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__
#endif /* __LITTLE_ENDIAN__ */
#else
#define __BIG_ENDIAN__
#endif/* BYTE_ORDER */
#endif/* __OPENBSD__ */


#if __BYTE_ORDER == __LITTLE_ENDIAN
#ifndef __LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__
#endif
#else
#ifndef __BIG_ENDIAN__
#define __BIG_ENDIAN__
#endif
#endif

#ifdef WIN32
#ifndef __LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__ 1
#endif
#endif

#if !(defined(__LITTLE_ENDIAN__) || defined(__BIG_ENDIAN__))
#if defined(__mips__)
#undef __LITTLE_ENDIAN__
#undef __LITTLE_ENDIAN
#define __BIG_ENDIAN__
#endif

/* Everything else */
#if (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__))
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__
#else
#define __BIG_ENDIAN__
#endif
#endif

#endif

#define NDPI_SELECTION_BITMASK_PROTOCOL_SIZE			u_int32_t

/**
 * convenience macro to check for excluded protocol
 * a protocol is excluded if the flow is known and either the protocol is not detected at all
 * or the excluded bitmask contains the protocol
 */
#define NDPI_FLOW_PROTOCOL_EXCLUDED(ndpi_struct,flow,protocol) ((flow) != NULL && \
								( NDPI_COMPARE_PROTOCOL_TO_BITMASK((ndpi_struct)->detection_bitmask, (protocol)) == 0 || \
								  NDPI_COMPARE_PROTOCOL_TO_BITMASK((flow)->excluded_protocol_bitmask, (protocol)) != 0 ) )

#define MAX_DEFAULT_PORTS                                        5

#define NDPI_EXCLUDE_PROTO(mod,flow) ndpi_exclude_protocol(mod, flow, NDPI_CURRENT_PROTO, __FILE__, __FUNCTION__, __LINE__)
#define NDPI_EXCLUDE_PROTO_EXT(mod,flow,proto) ndpi_exclude_protocol(mod, flow, proto, __FILE__, __FUNCTION__, __LINE__)

/**
 * macro for getting the string len of a static string
 *
 * use it instead of strlen to avoid runtime calculations
 */
#define NDPI_STATICSTRING_LEN( s ) ( sizeof( s ) - 1 )

/** macro to compare 2 IPv6 addresses with each other to identify the "smaller" IPv6 address  */
#define NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(x,y)  \
  ((x.u6_addr.u6_addr64[0] < y.u6_addr.u6_addr64[0]) || ((x.u6_addr.u6_addr64[0] == y.u6_addr.u6_addr64[0]) && (x.u6_addr.u6_addr64[1] < y.u6_addr.u6_addr64[1])))

#define NDPI_NUM_BITS              512
#define NDPI_NUM_BITS_MASK         (512-1)

#define NDPI_BITS /* 32 */ (sizeof(ndpi_ndpi_mask) * 8 /* number of bits in a byte */)        /* bits per mask */
#define howmanybits(x, y)   (((x)+((y)-1))/(y))


#define NDPI_SET(p, n)    ((p)->fds_bits[(n)/NDPI_BITS] |=  (1ul << (((u_int32_t)n) % NDPI_BITS)))
#define NDPI_CLR(p, n)    ((p)->fds_bits[(n)/NDPI_BITS] &= ~(1ul << (((u_int32_t)n) % NDPI_BITS)))
#define NDPI_ISSET(p, n)  ((p)->fds_bits[(n)/NDPI_BITS] &   (1ul << (((u_int32_t)n) % NDPI_BITS)))
#define NDPI_ZERO(p)      memset((char *)(p), 0, sizeof(*(p)))
#define NDPI_ONE(p)       memset((char *)(p), 0xFF, sizeof(*(p)))

#define NDPI_NUM_FDS_BITS     howmanybits(NDPI_NUM_BITS, NDPI_BITS)

#define NDPI_PROTOCOL_BITMASK ndpi_protocol_bitmask_struct_t

#define NDPI_BITMASK_ADD(a,b)     NDPI_SET(&a,b)
#define NDPI_BITMASK_DEL(a,b)     NDPI_CLR(&a,b)
#define NDPI_BITMASK_RESET(a)     NDPI_ZERO(&a)
#define NDPI_BITMASK_SET_ALL(a)   NDPI_ONE(&a)
#define NDPI_BITMASK_SET(a, b)    { memcpy(&a, &b, sizeof(NDPI_PROTOCOL_BITMASK)); }

#define NDPI_SET_BIT(num, n)    num |= 1ULL << ( n )
#define NDPI_CLR_BIT(num, n)    num &= ~(1ULL << ( n ))
#define NDPI_CLR_BIT(num, n)    num &= ~(1ULL << ( n ))
#define NDPI_ISSET_BIT(num, n)  (num & (1ULL << ( n )))
#define NDPI_ZERO_BIT(num)      num = 0

/* this is a very very tricky macro *g*,
 * the compiler will remove all shifts here if the protocol is static...
 */
#define NDPI_ADD_PROTOCOL_TO_BITMASK(bmask,value)     NDPI_SET(&bmask,   value & NDPI_NUM_BITS_MASK)
#define NDPI_DEL_PROTOCOL_FROM_BITMASK(bmask,value)   NDPI_CLR(&bmask,   value & NDPI_NUM_BITS_MASK)
#define NDPI_COMPARE_PROTOCOL_TO_BITMASK(bmask,value) NDPI_ISSET(&bmask, value & NDPI_NUM_BITS_MASK)

#define NDPI_SAVE_AS_BITMASK(bmask,value)  { NDPI_ZERO(&bmask) ; NDPI_ADD_PROTOCOL_TO_BITMASK(bmask, value); }


#define ndpi_min(a,b)   ((a < b) ? a : b)
#define ndpi_max(a,b)   ((a > b) ? a : b)

#define NDPI_NUM_DEFAULT_ROOT_NODES        512

#define NDPI_IPSEC_PROTOCOL_ESP    50
#define NDPI_IPSEC_PROTOCOL_AH     51
#define NDPI_GRE_PROTOCOL_TYPE     0x2F
#define NDPI_ICMP_PROTOCOL_TYPE    0x01
#define NDPI_IGMP_PROTOCOL_TYPE    0x02
#define NDPI_EGP_PROTOCOL_TYPE     0x08
#define NDPI_OSPF_PROTOCOL_TYPE    0x59
#define NDPI_VRRP_PROTOCOL_TYPE    112
#define NDPI_SCTP_PROTOCOL_TYPE    132
#define NDPI_IPIP_PROTOCOL_TYPE    0x04
#define NDPI_ICMPV6_PROTOCOL_TYPE  0x3a
#define NDPI_PGM_PROTOCOL_TYPE     0x71
#define NDPI_PIM_PROTOCOL_TYPE     0x67

#define NDPI_ARRAY_LENGTH(array) (sizeof(array) / sizeof((array)[0]))

/* the get_uXX will return raw network packet bytes !! */
#define get_u_int8_t(X,O)   (*(u_int8_t  *)((&(((u_int8_t *)X)[O]))))
#define get_u_int16_t(X,O)  (*(u_int16_t *)((&(((u_int8_t *)X)[O]))))
#if defined(__arm__)
static inline uint32_t get_u_int32_t(const uint8_t* X, int O)
{
  uint32_t tmp;
  memcpy(&tmp, X + O, sizeof(tmp));
  return tmp;
}
#else
#define get_u_int32_t(X,O)  (*(u_int32_t *)((&(((u_int8_t *)X)[O]))))
#endif // __arm__
#if defined(__arm__)
#include <stdint.h>
#include <string.h>
static inline uint64_t get_u_int64_t(const uint8_t* X, int O)
{
  uint64_t tmp;
  memcpy(&tmp, X + O, sizeof(tmp));
  return tmp;
}
#else
#define get_u_int64_t(X,O)  (*(u_int64_t *)((&(((u_int8_t *)X)[O]))))
#endif // __arm__

/* new definitions to get little endian from network bytes */
#define get_ul8(X,O) get_u_int8_t(X,O)

#if defined(__LITTLE_ENDIAN__) || defined(_LITTLE_ENDIAN)
#define get_l16(X,O)  get_u_int16_t(X,O)
#define get_l32(X,O)  get_u_int32_t(X,O)
#elif defined(__BIG_ENDIAN__) || defined(__BIG_ENDIAN)
/* convert the bytes from big to little endian */
# define get_l16(X,O) bswap_16(get_u_int16_t(X,O))
# define get_l32(X,O) bswap_32(get_u_int32_t(X,O))
#else
#error "__BYTE_ORDER MUST BE DEFINED !"
#endif							/* __BYTE_ORDER */

/* define memory callback function */
#define match_first_bytes(payload,st) (memcmp((payload),(st),(sizeof(st)-1))==0)

#if defined(WIN32)
#undef strtok_r
#define strtok_r strtok_s

#if BYTE_ORDER == LITTLE_ENDIAN
#define le16toh(x) (x)
#define le32toh(x) (x)
#else
#error "byte order not supported"
#endif

#endif /* WIN32 */

#define NDPI_MAX_DNS_REQUESTS                   16
#define NDPI_MIN_NUM_STUN_DETECTION             8

#define NDPI_MAJOR                              4
#define NDPI_MINOR                              12
#define NDPI_PATCH                              0

/* IMPORTANT: order according to its severity */
#define NDPI_CIPHER_SAFE                        0
#define NDPI_CIPHER_WEAK                        1
#define NDPI_CIPHER_INSECURE                    2

#define NDPI_OPTIMAL_HLL_NUM_BUCKETS           16

#define NDPI_MAX_NUM_TLS_APPL_BLOCKS            8

//#define TLS_HANDLE_SIGNATURE_ALGORITMS 1

#ifdef __APPLE__

#include <libkern/OSByteOrder.h>

#define htobe16(x) OSSwapHostToBigInt16(x)
#define htole16(x) OSSwapHostToLittleInt16(x)
#define be16toh(x) OSSwapBigToHostInt16(x)
#define le16toh(x) OSSwapLittleToHostInt16(x)

#define htobe32(x) OSSwapHostToBigInt32(x)
#define htole32(x) OSSwapHostToLittleInt32(x)
#define be32toh(x) OSSwapBigToHostInt32(x)
#define le32toh(x) OSSwapLittleToHostInt32(x)

#define htobe64(x) OSSwapHostToBigInt64(x)
#define htole64(x) OSSwapHostToLittleInt64(x)
#define be64toh(x) OSSwapBigToHostInt64(x)
#define le64toh(x) OSSwapLittleToHostInt64(x)

#endif /* __APPLE__ */


#if defined(_WINDOWS_)

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

#ifndef htobe16
#define htobe16(x) htons(x)
#endif

#ifndef htole16
#define htole16(x) (x)
#endif

#ifndef be16toh
#define be16toh(x) ntohs(x)
#endif

#ifndef le16toh
#define le16toh(x) (x)
#endif

#ifndef htobe32
#define htobe32(x) htonl(x)
#endif

#ifndef htole32
#define htole32(x) (x)
#endif

#ifndef be32toh
#define be32toh(x) ntohl(x)
#endif

#ifndef le32toh
#define le32toh(x) (x)
#endif

#ifndef htobe64
#define htobe64(x) ndpi_htonll(x)
#endif

#ifndef htole64
#define htole64(x) (x)
#endif

#ifndef be64toh
#define be64toh(x) ndpi_ntohll(x)
#endif

#ifndef le64toh
#define le64toh(x) (x)
#endif

#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__

#ifndef htobe16
#define htobe16(x) (x)
#endif

#ifndef htole16
#define htole16(x) __builtin_bswap16(x)
#endif

#ifndef be16toh
#define be16toh(x) (x)
#endif

#ifndef le16toh
#define le16toh(x) __builtin_bswap16(x)
#endif

#ifndef htobe32
#define htobe32(x) (x)
#endif

#ifndef htole32
#define htole32(x) __builtin_bswap32(x)
#endif

#ifndef be32toh
#define be32toh(x) (x)
#endif

#ifndef le32toh
#define le32toh(x) __builtin_bswap32(x)
#endif

#ifndef htobe64
#define htobe64(x) (x)
#endif

#ifndef htole64
#define htole64(x) __builtin_bswap64(x)
#endif

#ifndef be64toh
#define be64toh(x) (x)
#endif

#ifndef le64toh
#define le64toh(x) __builtin_bswap64(x)
#endif

#else
#error Unexpected __BYTE_ORDER__

#endif /* __BYTE_ORDER__ */
#endif /* __MINGW32__ */


#ifndef ETH_ARP
#define ETH_ARP                0x0806
#endif

#ifndef ETH_P_IP
#define ETH_P_IP               0x0800 	/* IPv4 */
#endif

#ifndef ETH_P_IPV6
#define ETH_P_IPV6	       0x86dd	/* IPv6 */
#endif

#ifndef ETH_P_VLAN
#define ETH_P_VLAN             0x8100
#endif

#ifndef ETH_P_MPLS_UNI
#define ETH_P_MPLS_UNI         0x8847
#endif

#ifndef ETH_P_MPLS_MULTI
#define ETH_P_MPLS_MULTI       0x8848
#endif

#ifndef ETH_P_PPPoE
#define ETH_P_PPPoE            0x8864
#endif

#define MAX_NBPF_CUSTOM_PROTO  8

#endif /* __NDPI_DEFINE_INCLUDE_FILE__ */

```

`generated/refresh.sh`:

```sh
#!/bin/bash -x
set -e

# Set this to your NDK path
# Should match the ndkVersion in app/build.gradle
ANDROID_NDK="${ANDROID_NDK:-${HOME}/Android/Sdk/ndk}/26.3.11579264"

# https://developer.android.com/ndk/guides/other_build_systems
export TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64
export TARGET=x86_64-linux-android21
export ANDROID_NATIVE_API_LEVEL=21
export AR=$TOOLCHAIN/bin/llvm-ar
export CC=$TOOLCHAIN/bin/$TARGET$API-clang
export AS=$CC
export CXX=$TOOLCHAIN/bin/$TARGET$API-clang++
export LD=$TOOLCHAIN/bin/ld
export RANLIB=$TOOLCHAIN/bin/llvm-ranlib
export STRIP=$TOOLCHAIN/bin/llvm-strip

SUBMODULES_PATH=../submodules

# libpcap
( cd $SUBMODULES_PATH/libpcap && \
  rm -f scanner.c grammar.h scanner.c scanner.h config.h && \
  ./autogen.sh && \
  ac_cv_netfilter_can_compile=no ./configure --host $TARGET --without-libnl --enable-usb=no --enable-netmap=no --enable-bluetooth=no --enable-dbus=no --enable-rdma=no && \
  make scanner.h grammar.h )
cp $SUBMODULES_PATH/libpcap/{grammar.c,grammar.h,scanner.c,scanner.h,config.h} ./libpcap

# nDPI
( cd $SUBMODULES_PATH/nDPI && ./autogen.sh || true; ./configure --host $TARGET --enable-slim --with-only-libndpi )
cp $SUBMODULES_PATH/nDPI/src/include/{ndpi_api.h,ndpi_config.h,ndpi_define.h} ./nDPI

```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true

android.javaCompile.suppressSourceTargetDeprecationWarning=true
android.nonTransitiveRClass=false
android.nonFinalResIds=false

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
include ':app'

```

`tools/pcapdroid.lua`:

```lua
--
--  This file is part of PCAPdroid.
--
--  PCAPdroid is free software: you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation, either version 3 of the License, or
--  (at your option) any later version.
--
--  PCAPdroid is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
--
--  Copyright 2021 - Emanuele Faranda
--

pcapdroid = Proto("PCAPdroid", "PCAPdroid data")

-- #############################################

local PCAPDROID_MAGIC = 0x01072021
local PCAPDROID_TRAILER_SIZE = 32
local PCAPDROID_PEN = 62652

local block_types = {
  [1] = "UID Mapping",
}

-- #############################################

local fields = {}

fields.magic   = ProtoField.uint32("pcapdroid.magic", "Magic", base.HEX)
fields.block_ver = ProtoField.int32("pcapdroid.block_version", "Block version", base.DEC)
fields.block_type = ProtoField.int32("pcapdroid.block_type", "Block type", base.DEC, block_types)
fields.uid     = ProtoField.int32("pcapdroid.uid", "UID", base.DEC)
fields.appname = ProtoField.string("pcapdroid.appname", "App name", base.UNICODE)
fields.appname_len     = ProtoField.uint8("pcapdroid.appname_len", "App name length", base.DEC)
fields.packagename     = ProtoField.string("pcapdroid.packagename", "Package name", base.UNICODE)
fields.packagename_len = ProtoField.uint8("pcapdroid.packagename_len", "Package name length", base.DEC)

pcapdroid.fields = fields

local pen_field = Field.new("frame.cb_pen")
local comment_field = Field.new("frame.comment")
local uid_mapping = {}

-- #############################################

local function dissect_pcap_trailer(buffer, pinfo, tree)
  local length = buffer:len()

  if(length < PCAPDROID_TRAILER_SIZE) then
    return false
  end

  -- -4: skip the FCS
  local trailer = buffer(length - PCAPDROID_TRAILER_SIZE, PCAPDROID_TRAILER_SIZE - 4)
  local magic = trailer(0, 4):uint()

  if(magic ~= PCAPDROID_MAGIC) then
    return false
  end

  local appname = trailer(8, 20):raw()
  local subtree = tree:add(pcapdroid, buffer(), string.format("PCAPdroid, App: %s", appname))

  subtree:add(fields.magic, trailer(0, 4))
  subtree:add(fields.uid, trailer(4, 4))
  subtree:add(fields.appname, trailer(8, 20))
  return true
end

-- #############################################

local function dissect_pcapng(buffer, pinfo, tree)
  local pen_fields = { pen_field() }

  if pen_fields[1] then
    local pen = pen_fields[1].value

    if (pen == PCAPDROID_PEN) and (buffer:len() >= 4) then
      -- PCAPdroid custom block
      local get_uint
      local block_ver

      -- check version and determine endianess
      if (buffer(0, 2):uint() == 1) then
        block_ver = 1
        get_uint = function(buf)
          return buf:uint()
        end
      elseif (buffer(0, 2):le_uint() == 1) then
        block_ver = 1
        get_uint = function(buf)
          return buf:le_uint()
        end
      else
        error(string.format("Unsupported PCAPdroid block version: %u", buffer(0, 2):uint()))
        return
      end

      local block_type = buffer(2, 1):uint()
      local subtree = tree:add(pcapdroid, buffer(), string.format("PCAPdroid, \"%s\" (%u)",
        block_types[block_type] or "Unknown", block_type))
      subtree:add(fields.block_ver, buffer(0, 2), block_ver)
      subtree:add(fields.block_type, buffer(2, 1))

      local block = buffer(4, buffer:len() - 4)

      if block_type == 1 then -- UID Mapping
        -- PCAPdroid uid mapping custom block
        local uid = get_uint(block(0, 4))
        local packagename_len = block(4, 1):uint()
        local appname_len = block(5, 1):uint()
        local package_name = block(6, packagename_len):string()
        local app_name = block(6 + packagename_len, appname_len):string()

        subtree:set_text(string.format("PCAPdroid, uid mapping: %u -> %s", uid, package_name))
        subtree:add(fields.uid, block(0, 4), uid)
        subtree:add(fields.packagename_len, block(4, 1))
        subtree:add(fields.appname_len, block(5, 1))
        subtree:add(fields.packagename, block(6, packagename_len))
        subtree:add(fields.appname, block(6 + packagename_len, appname_len))

        uid_mapping[uid] = {package_name, app_name}
      else
        error(string.format("Unknown PCAPdroid block: %u", block_type))
      end
    end
  else
    local comment_fields = { comment_field() }

    if comment_fields[1] then
      local comment = comment_fields[1].value

      -- e.g. u-12345
      if (string.sub(comment, 0, 2) == "u-") then
        local uid_str = string.sub(comment, 3)
        local uid = tonumber(uid_str)

        if uid ~= nil then
          -- the UID must be mapped
          local mapping = uid_mapping[uid]

          if mapping ~= nil then
            local package_name = mapping[1]
            local app_name = mapping[2]

            -- print(string.format("UID %u - %s %s", uid, package_name, app_name))
            local subtree = tree:add(pcapdroid, buffer(), string.format("PCAPdroid, App: %s", app_name))

            subtree:add(fields.uid, uid_str)
            subtree:add(fields.packagename, package_name)
            subtree:add(fields.appname, app_name)
          end
        end
      end
    end
  end
end

-- #############################################

local status, udpdump_dissector = pcall(require, "pcapdroid_udpdump")
if not status then
  udpdump_dissector = nil
end

function pcapdroid.dissector(buffer, pinfo, tree)
  if udpdump_dissector ~= nil then
    udpdump_dissector(buffer, pinfo, tree)
  end

  if not dissect_pcap_trailer(buffer, pinfo, tree) then
    dissect_pcapng(buffer, pinfo, tree)
  end
end

-- #############################################

register_postdissector(pcapdroid)

```

`tools/pcapdroid_mitm.py`:

```py
#!/usr/bin/env python3
#
#  This file is part of PCAPdroid.
#
#  PCAPdroid is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  PCAPdroid is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
#
#  Copyright 2022 - Emanuele Faranda
#

# mitmdump -q -p 8050 --mode socks5 -s pcapdroid_mitm.py
from enum import Enum
import socket
import errno
from mitmproxy import http
from mitmproxy.net.http.http1.assemble import assemble_request, assemble_response

class PayloadType(Enum):
  HTTP_REQUEST = "http_req"
  HTTP_REPLY = "http_rep"
  WEBSOCKET_CLIENT_MSG = "ws_climsg"
  WEBSOCKET_SERVER_MSG = "ws_srvmsg"

class PCAPdroid:
  def __init__(self):
    try:
      self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      self.sock.connect(("127.0.0.1", 5750))
    except socket.error as e:
      print(e)
      exit(1) # NOTE: this does not terminate mitmdump

  def send_payload(self, flow: http.HTTPFlow, payload_type: PayloadType, payload):
    client_port = flow.client_conn.peername[1]
    header = "%u:%s:%u\n" % (client_port, payload_type.value, len(payload))

    try:
      self.sock.sendall(header.encode('ascii'))
      self.sock.sendall(payload)
    except socket.error as e:
      if e.errno == errno.EPIPE:
        print("PCAPdroid closed")
        exit(0)
      else:
        print(e)
        exit(1)

  def request(self, flow: http.HTTPFlow):
    if flow.request:
      self.send_payload(flow, PayloadType.HTTP_REQUEST, assemble_request(flow.request))

  def response(self, flow: http.HTTPFlow) -> None:
    if flow.response:
      self.send_payload(flow, PayloadType.HTTP_REPLY, assemble_response(flow.response))

  def websocket_message(self, flow: http.HTTPFlow):
    msg = flow.websocket.messages[-1]
    if not msg:
      return

    payload_type = PayloadType.WEBSOCKET_CLIENT_MSG if msg.from_client else PayloadType.WEBSOCKET_SERVER_MSG
    self.send_payload(flow, payload_type, msg.content)

addons = [
  PCAPdroid()
]

```

`tools/pcapdroid_udpdump.lua`:

```lua
--
--  This file is part of PCAPdroid.
--
--  PCAPdroid is free software: you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation, either version 3 of the License, or
--  (at your option) any later version.
--
--  PCAPdroid is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
--
--  Copyright 2024 - Emanuele Faranda
--

-- A dissector which allows capturing PCAPdroid traffic via the Wireshark
-- udpdump interface. PCAPdroid needs to be configured in UDP dump mode,
-- with target port 5555.
--
-- Place this script in the same directory as pcapdroid.lua
--
-- NOTE: decrypting PCAPNG is not currently supported

local PCAP_HEADER_LEN = 16
local PCAP_REC_LEN = 16
local PCAPNG_SHB_LEN = 24
local PCAPNG_EPK_LEN = 28

local ip_dissector = Dissector.get("ip")
local eth_dissector = Dissector.get("eth_withoutfcs")
local pcap_dissector = Dissector.get("file-pcap")
local pcapng_dissector = Dissector.get("file-pcapng")
local exported_pdu_data = Field.new("exported_pdu.exported_pdu")

function udpdump_dissector(buffer, pinfo, tree)
  local epd_fields = { exported_pdu_data() }

  for i in pairs(epd_fields) do
    local data = epd_fields[i].value
    local len = data:len()

    if len >= PCAP_HEADER_LEN then
      -- check if it's the PCAP header
      if data:uint(0, 4) == 0xd4c3b2a1 then
        pcap_dissector:call(data:tvb(), pinfo, tree)
        return
      end
    end

    if len >= PCAPNG_SHB_LEN then
      -- check if it's the PCAPNG section header block
      if (data:uint(0, 4) == 0x0A0D0D0A) and (data:uint(8, 4) == 0x4D3C2B1A) then
        pcapng_dissector:call(data:tvb(), pinfo, tree)
        return
      end
    end

    if len > PCAPNG_EPK_LEN then
      -- check if it's the PCAPNG enhanced packet block
      if ((data:uint(0, 4) == 0x06000000) and (data:uint(8, 4) == 0)) then
        local pcap_data = data:tvb()(PCAPNG_EPK_LEN)

        ip_dissector:call(pcap_data:tvb(), pinfo, tree)
        return
      end
    end

    if len > PCAP_REC_LEN then
      -- guess the linktype (it's ethernet if the PCAPdroid trailer is enabled)
      local ipver = data:get_index(PCAP_REC_LEN)
      local pcap_data = data:tvb()(PCAP_REC_LEN)

      if ((ipver == 0x45) or (ipver == 0x60)) then
        -- IPv4/v6
        ip_dissector:call(pcap_data:tvb(), pinfo, tree)
      else
        -- Ethernet
        eth_dissector:call(pcap_data:tvb(), pinfo, tree)
      end
    end
  end
end

return udpdump_dissector

```

`tools/udp_receiver.py`:

```py
#!/usr/bin/env python3
#
#  This file is part of PCAPdroid.
#
#  PCAPdroid is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  PCAPdroid is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with PCAPdroid.  If not, see <http://www.gnu.org/licenses/>.
#
#  Copyright 2020-21 - Emanuele Faranda
#

import socket
import sys
import argparse

# The buffer to hold the received UDP data
BUFSIZE = 65535

PCAP_HEADER_SIZE = 24

# Standard PCAP header (struct pcap_hdr_s). Must be sent before any other PCAP record (struct pcaprec_hdr_s).
# magic: 0xa1b2c3d4, v2.4
PCAP_HDR_BYTES_PREFIX = bytes.fromhex("d4c3b2a1020004000000000000000000")

# snaplen: 65535, LINKTYPE_RAW
PCAP_HDR_BYTES_RAW_SUFFIX = bytes.fromhex("ffff000065000000")

# snaplen: 65535, LINKTYPE_ETHERNET
PCAP_HDR_BYTES_ETHER_SUFFIX = bytes.fromhex("ffff000001000000")

# PCAP header when PCAPDroid trailer is in use
# magic: 0xa1b2c3d4, v2.4

PCAPDROID_TRAILER_MAGIC = bytes.fromhex("01072021")
PCAPDROID_TRAILER_SIZE = 32

example = '''example:
  udp_receiver.py -p 1234 | wireshark -k -i -
'''

parser = argparse.ArgumentParser(
    description='''Receives data from the PCAPdroid app and outputs it to stdout.''',
    epilog=example,
    formatter_class=argparse.RawDescriptionHelpFormatter)

parser.add_argument('-p', '--port', type=int, help='The UDP port to listen', default=1234)
parser.add_argument('-v', '--verbose', help='Enable verbose log to stderr', action='store_true')
parser.add_argument('-w', '--write', help='Write the PCAP to the specified file', metavar='FILE', default="-")
args = parser.parse_args()

outf = None
if args.write != '-':
  outf = open(args.write, "wb")

def write(data):
  if outf:
    outf.write(data)
  else:
    sys.stdout.buffer.write(data)
    sys.stdout.flush()

def main_loop():
  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  sock.bind(("0.0.0.0", args.port))

  pcap_header_sent = False

  # Send the individual records (struct pcaprec_hdr_s)
  while True:
    data, addr = sock.recvfrom(BUFSIZE)
    is_pcap_header = (len(data) == PCAP_HEADER_SIZE) and (data.startswith(PCAP_HDR_BYTES_PREFIX))

    if(args.verbose):
      sys.stderr.write("Got a {}B packet\n".format(len(data)))

    if(not pcap_header_sent) and (not is_pcap_header):
      # This tool was started after PCAPdroid, so we must build a PCAP header

      # Determine is the PCAPDroid trailer is in use
      offset = len(data) - PCAPDROID_TRAILER_SIZE
      has_trailer = ((offset > 0) and (data[offset:offset+4] == PCAPDROID_TRAILER_MAGIC))

      if(args.verbose):
        sys.stderr.write("Sending PCAP header (trailer " + ("not " if not has_trailer else "") + "detected)\n")

      # Send the PCAP header before any other data
      suffix = PCAP_HDR_BYTES_RAW_SUFFIX if not has_trailer else PCAP_HDR_BYTES_ETHER_SUFFIX
      write(PCAP_HDR_BYTES_PREFIX + suffix)
      pcap_header_sent = True
    elif is_pcap_header:
      if pcap_header_sent:
        # PCAPdroid has been restarted, ignore the PCAP header
        if(args.verbose):
          sys.stderr.write("PCAP header detected, skipping\n");
        continue
      else:
        if(args.verbose):
          sys.stderr.write("PCAP header detected\n");
        pcap_header_sent = True

    # this is a PCAP header/record, send it
    write(data)

if __name__ == "__main__":
  try:
    main_loop()
  except KeyboardInterrupt:
    sys.stderr.write("Terminating...")

    if outf:
      outf.close()
    exit(0)

```

`tools/weblate.py`:

```py
#!/usr/bin/env python3
# Copyright 2026 - Emanuele Faranda
#
# Cherry-pick translation updates from Weblate and squash consecutive
# commits by the same author.
#
# Usage:
#   tools/weblate.py status            Show pending translation commits
#   tools/weblate.py update            Update all tracked locales
#   tools/weblate.py update <locale>   Update a single locale (e.g. "ru")

import subprocess
import sys
import os
import re

REMOTE = "weblate"
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
REPO_ROOT = os.path.dirname(SCRIPT_DIR)
STATUS_FILE = os.path.join(SCRIPT_DIR, "weblate_status")
BUILD_GRADLE = os.path.join(REPO_ROOT, "app", "build.gradle")
STRINGS_BASE = "app/src/main/res"

def die(msg):
    print(f"Error: {msg}", file=sys.stderr)
    sys.exit(1)

def git(*args, check=True, stdin=None):
    result = subprocess.run(["git"] + list(args),
                            input=stdin, capture_output=True, text=True)
    if check and (result.returncode != 0):
        die(f"git {' '.join(args)}\n{result.stderr.strip()}")
    return result

def locale_path(locale):
    return f"{STRINGS_BASE}/values-{locale}/strings.xml"

# ---------------------------------------------------------------------------
# Status file: one "locale=commit_hash" per line
# ---------------------------------------------------------------------------

def load_status():
    status = {}
    if os.path.exists(STATUS_FILE):
        with open(STATUS_FILE) as f:
            for line in f:
                line = line.strip()
                if (not line) or line.startswith("#"):
                    continue
                locale, commit = line.split("=", 1)
                status[locale] = commit
    return status

def save_status(status):
    with open(STATUS_FILE, "w") as f:
        for locale in sorted(status):
            f.write(f"{locale}={status[locale]}\n")

# ---------------------------------------------------------------------------
# Git helpers
# ---------------------------------------------------------------------------

def is_on_master(commit):
    """True if *commit* is already reachable from HEAD."""
    return git("merge-base", "--is-ancestor", commit, "HEAD",
               check=False).returncode == 0

def get_pending_commits(locale, last_commit):
    """Commits on weblate/master after *last_commit* that touch *locale*."""
    path = locale_path(locale)
    args = ["log", "--format=%H", "--reverse", "--no-merges"]
    if last_commit:
        args += ["--ancestry-path", f"{last_commit}..{REMOTE}/master"]
    else:
        args.append(f"{REMOTE}/master")
    args += ["--", path]
    out = git(*args).stdout.strip()
    return [h for h in out.split("\n") if h]

def get_commit_info(commit):
    """Return (name, email, date, message) for *commit*."""
    out = git("log", "-1", "--format=%an\n%ae\n%aI\n%s", commit).stdout.strip()
    name, email, date, message = out.split("\n", 3)
    return name, email, date, message

def has_staged_changes():
    return git("diff", "--cached", "--quiet", check=False).returncode != 0

def locale_exists_on_disk(locale):
    return os.path.isdir(os.path.join(STRINGS_BASE, f"values-{locale}"))

def count_strings(content, translatable_only=False):
    """Count <string name= entries in an Android strings XML."""
    if translatable_only:
        return len(re.findall(r'<string name="[^"]*"(?![^>]*translatable="false")', content))
    return len(re.findall(r'<string name="', content))

def translation_pct(locale):
    """Return translation percentage string for a locale on weblate/master."""
    en_path = f"{STRINGS_BASE}/values/strings.xml"
    path = locale_path(locale)
    en_content = git("show", f"{REMOTE}/master:{en_path}").stdout
    locale_result = git("show", f"{REMOTE}/master:{path}", check=False)
    if locale_result.returncode != 0:
        return "0%"
    total = count_strings(en_content, translatable_only=True)
    if total == 0:
        return "0%"
    translated = count_strings(locale_result.stdout)
    return f"{100 * translated // total}%"

def locale_in_sync(locale):
    """True if the locale file is identical on weblate/master and HEAD."""
    path = locale_path(locale)
    return git("diff", "--quiet", f"{REMOTE}/master", "HEAD", "--", path,
               check=False).returncode == 0

def working_tree_clean():
    return git("diff", "--quiet", "--", STRINGS_BASE, check=False).returncode == 0 and \
           git("diff", "--cached", "--quiet", "--", STRINGS_BASE, check=False).returncode == 0

def get_supported_locales():
    """Non-English locales from resourceConfigurations in build.gradle."""
    with open(BUILD_GRADLE) as f:
        content = f.read()
    locales = re.findall(r'"([a-z]{2}(?:-r[A-Z]{2})?)"',
                         content.split("resourceConfigurations")[1].split("]")[0])
    locales = [l for l in locales if l != "en"]
    return sorted(locales)

# ---------------------------------------------------------------------------
# Grouping consecutive commits by author
# ---------------------------------------------------------------------------

def group_by_author(commits):
    """Return list of groups: {name, email, date, commits, message}."""
    groups = []
    for commit in commits:
        name, email, date, message = get_commit_info(commit)
        if groups and (groups[-1]["email"] == email):
            groups[-1]["commits"].append(commit)
            groups[-1]["date"] = date
            groups[-1]["message"] = message
        else:
            groups.append({
                "name": name,
                "email": email,
                "date": date,
                "commits": [commit],
                "message": message,
            })
    return groups

# ---------------------------------------------------------------------------
# Applying translation changes
# ---------------------------------------------------------------------------

def apply_group(group, path):
    """Apply a group's translation changes via 3-way merge.

    Computes a diff spanning from the parent of the first commit to the
    last commit in the group, then applies it with --3way so that
    master-only changes (e.g. removed strings) are preserved.
    """
    first = group["commits"][0]
    last = group["commits"][-1]
    first_parent = git("rev-parse", f"{first}^").stdout.strip()

    patch = git("diff", "--full-index", first_parent, last, "--", path).stdout
    if not patch.strip():
        return

    result = git("apply", "--3way", check=False, stdin=patch)
    if result.returncode != 0:
        die(f"Failed to apply changes for {path} "
            f"({first[:12]}..{last[:12]}):\n{result.stderr.strip()}")

def verify_locale(locale):
    """Verify that the locale file matches the one on weblate/master."""
    path = locale_path(locale)
    weblate_content = git("show", f"{REMOTE}/master:{path}").stdout

    with open(path) as f:
        our_content = f.read()

    if our_content != weblate_content:
        die(f"locale '{locale}' differs from {REMOTE}/master after update — "
            "manual fix required")

# ---------------------------------------------------------------------------
# Commands
# ---------------------------------------------------------------------------

def cmd_status():
    git("fetch", REMOTE)
    status = load_status()
    supported = get_supported_locales()

    for locale in supported:
        pct = translation_pct(locale)
        last = status.get(locale)
        if last:
            pending = get_pending_commits(locale, last)
            translation = [c for c in pending if not is_on_master(c)]
            if translation and not locale_in_sync(locale):
                print(f"  {locale} ({pct}): {len(translation)} pending translation commit(s)")
            else:
                print(f"  {locale} ({pct}): up-to-date")
        else:
            pending = get_pending_commits(locale, None)
            if not pending:
                continue
            translation = [c for c in pending if not is_on_master(c)]
            if (not translation) or locale_in_sync(locale):
                continue
            if locale_exists_on_disk(locale):
                print(f"  {locale} ({pct}): NOT TRACKED (exists on disk, "
                      f"{len(translation)} commit(s) — add to status file)")
            else:
                print(f"  {locale} ({pct}): NEW ({len(translation)} commit(s))")

def update_locale(locale, status):
    last = status.get(locale)
    path = locale_path(locale)

    if last is None:
        if locale_exists_on_disk(locale):
            die(f"locale '{locale}' exists on disk but is not in the "
                "status file — add it manually first")

    all_pending = get_pending_commits(locale, last)
    if not all_pending:
        print(f"  {locale}: up-to-date")
        return

    pending = [c for c in all_pending if not is_on_master(c)]
    skipped = len(all_pending) - len(pending)

    if not pending:
        print(f"  {locale}: {skipped} commit(s) already in master, bumping status")
        status[locale] = all_pending[-1]
        save_status(status)
        return

    if locale_in_sync(locale):
        print(f"  {locale}: already in sync, bumping status")
        status[locale] = pending[-1]
        save_status(status)
        return

    extra = f" ({skipped} already in master)" if skipped else ""
    print(f"  {locale}: {len(pending)} pending commit(s){extra}")

    locale_dir = os.path.join(STRINGS_BASE, f"values-{locale}")
    os.makedirs(locale_dir, exist_ok=True)

    groups = group_by_author(pending)
    for group in groups:
        apply_group(group, path)
        git("add", path)

        if not has_staged_changes():
            n = len(group["commits"])
            print(f"    Skipping {n} commit(s) by {group['name']} (no diff)")
            continue

        author = f"{group['name']} <{group['email']}>"
        message = group["message"]
        git("commit", f"--author={author}", f"--date={group['date']}", "-m", message)

        n = len(group["commits"])
        squash_note = f" (squashed {n} commits)" if (n > 1) else ""
        print(f"    Committed: {message} by {group['name']}{squash_note}")

    verify_locale(locale)

    # track the last weblate-side commit (not a master commit) so the
    # range for the next run stays on the weblate lineage
    status[locale] = pending[-1]
    save_status(status)
    git("add", STATUS_FILE)
    if has_staged_changes():
        git("commit", "--amend", "--no-edit")
    print(f"  {locale}: done")

def cmd_update(target_locale=None):
    if not working_tree_clean():
        die("working tree has uncommitted changes — commit or stash first")

    git("fetch", REMOTE)
    status = load_status()
    supported = get_supported_locales()

    if target_locale:
        if target_locale not in supported:
            die(f"locale '{target_locale}' is not in resourceConfigurations")
        locales = [target_locale]
    else:
        locales = supported

    for locale in locales:
        update_locale(locale, status)

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def usage():
    print("Usage: weblate.py <status|update> [locale]")
    sys.exit(1)

def main():
    if len(sys.argv) < 2:
        usage()

    cmd = sys.argv[1]

    if cmd == "status":
        cmd_status()
    elif cmd == "update":
        target = sys.argv[2] if (len(sys.argv) > 2) else None
        cmd_update(target)
    else:
        usage()

if __name__ == "__main__":
    main()

```

`tools/weblate_status`:

```
ar=69e383df015e8d9e9b080acba486eacc866beb8e
az=c32ca70ed63e69ef483fb2bb883c43bf130ce5d8
de=40a335d6c7f6e4982ecd272b36dcc93b24411640
es=80a884f77f686f4469c23c0c92d4f9a7661518eb
in=aba5909a1863548e401614d3a6a0f5319aff1e52
it=92052bcc262a5241cb2cc3f75c3f48ba7726d493
pl=62c3da842f634ed4159f6c01233502723673d947
pt-rBR=24ed1dfcf644174ce41a49cd24236ed36fd2d703
ru=553966e3820ba9c3697151cf1406e5102044fc2f
ta=52050959dae8e9f9529227a32b3720a1d78e1536
tr=271737b524caf42484a93619b805617386ceeb47
uk=ed447b67a4e98a5e8214e140864326d3d2222670
zh-rCN=900c2de2fb9503e23c4bdaa0e9f6d7809f648e10

```