# Godot Engine Overview

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [core/os/main_loop.cpp](core/os/main_loop.cpp)
- [core/os/main_loop.h](core/os/main_loop.h)
- [doc/classes/Control.xml](doc/classes/Control.xml)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/MainLoop.xml](doc/classes/MainLoop.xml)
- [doc/classes/Node.xml](doc/classes/Node.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [doc/classes/SceneTree.xml](doc/classes/SceneTree.xml)
- [doc/classes/Viewport.xml](doc/classes/Viewport.xml)
- [doc/classes/Window.xml](doc/classes/Window.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/gdscript.cpp](modules/gdscript/gdscript.cpp)
- [modules/gdscript/gdscript.h](modules/gdscript/gdscript.h)
- [modules/gdscript/gdscript_analyzer.cpp](modules/gdscript/gdscript_analyzer.cpp)
- [modules/gdscript/gdscript_analyzer.h](modules/gdscript/gdscript_analyzer.h)
- [modules/gdscript/gdscript_byte_codegen.cpp](modules/gdscript/gdscript_byte_codegen.cpp)
- [modules/gdscript/gdscript_byte_codegen.h](modules/gdscript/gdscript_byte_codegen.h)
- [modules/gdscript/gdscript_cache.cpp](modules/gdscript/gdscript_cache.cpp)
- [modules/gdscript/gdscript_cache.h](modules/gdscript/gdscript_cache.h)
- [modules/gdscript/gdscript_codegen.h](modules/gdscript/gdscript_codegen.h)
- [modules/gdscript/gdscript_compiler.cpp](modules/gdscript/gdscript_compiler.cpp)
- [modules/gdscript/gdscript_compiler.h](modules/gdscript/gdscript_compiler.h)
- [modules/gdscript/gdscript_disassembler.cpp](modules/gdscript/gdscript_disassembler.cpp)
- [modules/gdscript/gdscript_editor.cpp](modules/gdscript/gdscript_editor.cpp)
- [modules/gdscript/gdscript_function.cpp](modules/gdscript/gdscript_function.cpp)
- [modules/gdscript/gdscript_function.h](modules/gdscript/gdscript_function.h)
- [modules/gdscript/gdscript_parser.cpp](modules/gdscript/gdscript_parser.cpp)
- [modules/gdscript/gdscript_parser.h](modules/gdscript/gdscript_parser.h)
- [modules/gdscript/gdscript_tokenizer.cpp](modules/gdscript/gdscript_tokenizer.cpp)
- [modules/gdscript/gdscript_tokenizer.h](modules/gdscript/gdscript_tokenizer.h)
- [modules/gdscript/gdscript_vm.cpp](modules/gdscript/gdscript_vm.cpp)
- [modules/gdscript/gdscript_warning.cpp](modules/gdscript/gdscript_warning.cpp)
- [modules/gdscript/gdscript_warning.h](modules/gdscript/gdscript_warning.h)
- [modules/gdscript/tests/gdscript_test_runner.cpp](modules/gdscript/tests/gdscript_test_runner.cpp)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out](modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out)
- [modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd](modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out)
- [scene/gui/control.cpp](scene/gui/control.cpp)
- [scene/gui/control.h](scene/gui/control.h)
- [scene/main/node.cpp](scene/main/node.cpp)
- [scene/main/node.h](scene/main/node.h)
- [scene/main/scene_tree.cpp](scene/main/scene_tree.cpp)
- [scene/main/scene_tree.h](scene/main/scene_tree.h)
- [scene/main/viewport.cpp](scene/main/viewport.cpp)
- [scene/main/viewport.h](scene/main/viewport.h)
- [scene/main/window.cpp](scene/main/window.cpp)
- [scene/main/window.h](scene/main/window.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

This page provides a high-level introduction to the Godot Engine codebase architecture, covering its major systems, initialization flow, and how components interact. It serves as the entry point for understanding Godot's design as both a game engine and editor.

For specific subsystem details, see: [Major Systems](#1.1) for a catalog of components, [Engine Core](#3) for initialization and core services, [Scene System](#4) for the node hierarchy, [Resource System](#5) for asset management, [Scripting System](#6) for GDScript/C# integration, [Editor System](#7) for editor architecture, and [Build System](#2) for compilation details.

## What is Godot Engine

Godot Engine is a cross-platform, open-source game engine implemented primarily in C++. The codebase provides:

- **Runtime Engine**: Scene tree, rendering, physics, audio, and scripting systems for running games
- **Editor Application**: Visual editor built on top of the engine for content creation
- **Multi-Platform Support**: Abstractions for Windows, Linux, macOS, mobile, and web platforms
- **Extensibility**: Plugin system, GDExtensions, and multiple scripting languages

The repository at https://github.com/godotengine/godot contains the complete engine, editor, and build system.

**Sources:** [main/main.cpp:1-443](), [editor/editor_node.cpp:1-200]()

## Architecture Overview

```mermaid
graph TB
    Main["Main Entry Point<br/>(main/main.cpp)"]
    OS["OS Abstraction<br/>(core/os/os.h)"]
    Servers["Core Servers<br/>RenderingServer<br/>PhysicsServer2D/3D<br/>AudioServer"]
    SceneTree["SceneTree<br/>(scene/main/scene_tree.h)"]
    Nodes["Node Hierarchy<br/>(scene/main/node.h)"]
    Resources["ResourceLoader<br/>(core/io/resource_loader.h)"]
    Scripts["ScriptLanguage<br/>GDScript, C#"]
    Editor["EditorNode<br/>(editor/editor_node.h)"]
    ProjectSettings["ProjectSettings<br/>(core/config/project_settings.h)"]
    
    Main --> OS
    Main --> ProjectSettings
    Main --> Servers
    Main --> SceneTree
    Main --> Editor
    
    SceneTree --> Nodes
    Nodes --> Scripts
    Nodes --> Resources
    
    Editor --> Nodes
    Editor --> Resources
    Editor --> Scripts
    
    Servers --> Nodes
    ProjectSettings --> Servers
```

**Godot Engine High-Level Architecture**

The engine follows a layered architecture:

1. **Platform Layer**: OS abstraction for platform-specific functionality
2. **Core Services**: Servers providing rendering, physics, audio, text, and navigation
3. **Scene System**: Node-based hierarchy for game objects
4. **Resource System**: Unified asset loading and caching
5. **Scripting Layer**: GDScript and C# integration
6. **Editor Layer**: Tools built on top of the engine runtime

**Sources:** [main/main.cpp:152-192](), [core/os/os.h:1-50](), [scene/main/scene_tree.h:1-100]()

## Core Concepts

### Nodes and Scenes

`Node` is the fundamental building block. Every game object inherits from `Node`, forming a tree structure managed by `SceneTree`. Nodes provide:

- Parent-child relationships via `add_child()` and `remove_child()`
- Lifecycle callbacks: `_enter_tree()`, `_ready()`, `_exit_tree()`
- Processing hooks: `_process()`, `_physics_process()`
- Group membership for batch operations

A **scene** is a saved tree of nodes stored as a `PackedScene` resource.

**Sources:** [scene/main/node.h:50-150](), [scene/main/node.cpp:60-315](), [scene/main/scene_tree.h:1-50]()

### Resources

`Resource` is the base class for all loadable assets (textures, materials, scripts, scenes). The `ResourceLoader` singleton provides:

- Synchronous and threaded loading via `load()` and `load_threaded_request()`
- Format plugins through `ResourceFormatLoader`
- Automatic caching with `ResourceCache`
- Import system for processing source assets

**Sources:** [core/io/resource_loader.h:1-100](), [core/io/resource.h:1-80]()

### Servers

Core engine functionality is provided by singleton server classes that run on dedicated threads or the main thread:

- `RenderingServer`: Low-level rendering API
- `PhysicsServer2D` / `PhysicsServer3D`: Physics simulation
- `AudioServer`: Audio mixing and output
- `NavigationServer2D` / `NavigationServer3D`: Pathfinding
- `TextServer`: Text shaping and font rendering

Servers are initialized early in [main/main.cpp:350-600]() and provide C++ APIs used by higher-level scene nodes.

**Sources:** [main/main.cpp:350-500](), [servers/rendering/rendering_server.h:1-50]()

### Editor vs Runtime

The editor is built as an application on top of the engine. When running in editor mode:

- `EditorNode` is instantiated as the main loop
- Editor plugins extend functionality via `EditorPlugin`
- The scene tree contains both the edited scene and editor UI
- Tool scripts run in the editor context

Runtime (exported games) skip editor initialization entirely, going directly to the game scene.

**Sources:** [editor/editor_node.h:118-130](), [main/main.cpp:2800-3000]()

## Engine Initialization

```mermaid
sequenceDiagram
    participant Exe as "Executable<br/>Entry Point"
    participant Main as "Main::setup()<br/>main/main.cpp"
    participant OS as "OS::initialize()<br/>platform/*/os_*.cpp"
    participant PS as "ProjectSettings<br/>project.godot"
    participant Servers as "Core Servers<br/>(Rendering, Physics, etc.)"
    participant ST as "SceneTree<br/>MainLoop"
    participant EN as "EditorNode<br/>(if --editor)"
    
    Exe->>Main: main()
    Main->>OS: OS::initialize()
    OS-->>Main: Platform initialized
    Main->>PS: ProjectSettings::setup()
    PS-->>Main: Config loaded
    Main->>Servers: Initialize servers
    Note over Servers: RenderingServer<br/>PhysicsServer2D/3D<br/>AudioServer, etc.
    Main->>ST: Create SceneTree
    Main->>ST: Set as MainLoop
    alt Editor Mode
        Main->>EN: EditorNode::init()
    else Runtime Mode
        Main->>ST: Load main scene
    end
    Main->>Main: Enter main loop<br/>Main::iteration()
```

**Engine Initialization Sequence**

The initialization follows a two-phase process:

**Phase 1 - `Main::setup()`** [main/main.cpp:1500-2000]():
- Parse command-line arguments
- Initialize `OS` singleton for the target platform [platform/windows/os_windows.cpp:258-334]()
- Load `ProjectSettings` from `project.godot` [core/config/project_settings.cpp:150-300]()
- Register core types and singletons
- Initialize servers (rendering, physics, audio, etc.)

**Phase 2 - `Main::setup2()`** [main/main.cpp:2000-2500]():
- Create `SceneTree` as the `MainLoop`
- Initialize editor if `--editor` flag present [main/main.cpp:2800-2900]()
- Load the main scene or open project manager
- Start the main loop iteration

**Sources:** [main/main.cpp:1500-2900](), [platform/windows/os_windows.cpp:258-334](), [core/config/project_settings.cpp:150-300]()

## Major Systems

### Build System

SCons-based build configuration with platform detection and module registration. See [Build System](#2) for details.

**Key Files:**
- `SConstruct`: Build entry point
- `methods.py`: Build utilities
- `platform/*/detect.py`: Platform-specific configuration

**Sources:** [SConstruct:1-50](), [methods.py:1-50]()

### Engine Core

Initialization, OS abstraction, project configuration, and server architecture. See [Engine Core](#3) for details.

**Key Classes:**
- `Main`: Initialization and main loop [main/main.cpp:1-443]()
- `OS`: Platform abstraction [core/os/os.h:1-200]()
- `ProjectSettings`: Configuration management [core/config/project_settings.h:1-150]()

**Sources:** [main/main.cpp:1-443](), [core/os/os.h:1-200](), [core/config/project_settings.h:1-150]()

### Scene System

Node-based hierarchy with lifecycle management, processing, and viewport rendering. See [Scene System](#4) for details.

**Key Classes:**
- `Node`: Base class for all scene objects [scene/main/node.h:50-200]()
- `SceneTree`: Manages the active node tree [scene/main/scene_tree.h:1-150]()
- `Viewport`: Rendering targets and input dispatch [scene/main/viewport.h:1-150]()
- `Control`: UI node base class [scene/gui/control.h:1-200]()

**Sources:** [scene/main/node.cpp:60-315](), [scene/main/scene_tree.cpp:144-200](), [scene/main/viewport.cpp:566-743]()

### Resource System

Asset loading, caching, saving, and import pipeline. See [Resource System](#5) for details.

**Key Classes:**
- `ResourceLoader`: Asset loading singleton [core/io/resource_loader.h:1-100]()
- `Resource`: Base class for loadable assets [core/io/resource.h:1-80]()
- `ResourceCache`: Cache management [core/io/resource_loader.cpp:1-200]()
- `ResourceImporter`: Import system for source assets

**Sources:** [core/io/resource_loader.h:1-100](), [core/io/resource.h:1-80]()

### Scripting System

Multi-language scripting with GDScript as the primary language. See [Scripting System](#6) for details.

**Key Components:**
- `ScriptLanguage`: Language abstraction [core/object/script_language.h:1-100]()
- `GDScript`: Implementation in `modules/gdscript/`
- `GDScriptParser`: AST generation [modules/gdscript/gdscript_parser.h:1-100]()
- `GDScriptCompiler`: Bytecode generation [modules/gdscript/gdscript_compiler.h:1-50]()

**Sources:** [core/object/script_language.h:1-100](), [modules/gdscript/:1-100]()

### Editor System

Visual editor built on the engine with an extensible plugin architecture. See [Editor System](#7) for details.

**Key Classes:**
- `EditorNode`: Main editor singleton [editor/editor_node.h:118-200]()
- `EditorData`: Manages edited scenes and state [editor/editor_data.h:1-100]()
- `EditorPlugin`: Plugin base class [editor/plugins/editor_plugin.h:1-100]()
- `EditorInterface`: API for plugins [editor/editor_interface.h:1-100]()

**Sources:** [editor/editor_node.cpp:1-200](), [editor/editor_data.cpp:1-100](), [editor/editor_interface.cpp:1-100]()

### GUI Components

Rich set of UI controls for both editor and games. See [GUI Components](#9) for details.

**Key Classes:**
- `Control`: Base UI node [scene/gui/control.h:1-200]()
- `TextEdit` / `CodeEdit`: Text editing [scene/gui/text_edit.h:1-100]()
- `RichTextLabel`: Formatted text display [scene/gui/rich_text_label.h:1-100]()

**Sources:** [scene/gui/control.cpp:1-200](), [scene/gui/text_edit.cpp:1-100]()

### Visual Shader System

Node-based shader editor with code generation. See [Visual Shader System](#10) for details.

**Key Classes:**
- `VisualShader`: Shader graph [scene/resources/visual_shader.h:1-100]()
- `VisualShaderNode`: Node base class [scene/resources/visual_shader_nodes.h:1-100]()

## System Interactions

```mermaid
graph TB
    subgraph "Platform Layer"
        OS["OS<br/>(os.h)"]
        Win["OS_Windows"]
        Unix["OS_Unix"]
    end
    
    subgraph "Core Services"
        PS["ProjectSettings<br/>(project_settings.h)"]
        RL["ResourceLoader<br/>(resource_loader.h)"]
        RS["RenderingServer"]
        PS2D["PhysicsServer2D"]
        PS3D["PhysicsServer3D"]
        AS["AudioServer"]
    end
    
    subgraph "Scene System"
        ST["SceneTree<br/>(scene_tree.h)"]
        Node["Node<br/>(node.h)"]
        VP["Viewport<br/>(viewport.h)"]
        Ctrl["Control<br/>(control.h)"]
    end
    
    subgraph "Scripting"
        SL["ScriptLanguage"]
        GDS["GDScript"]
        CS["C#"]
    end
    
    subgraph "Editor"
        EN["EditorNode<br/>(editor_node.h)"]
        ED["EditorData"]
        EP["EditorPlugin"]
    end
    
    OS --> Win
    OS --> Unix
    
    PS --> RS
    PS --> PS2D
    PS --> PS3D
    
    ST --> Node
    Node --> VP
    VP --> Ctrl
    
    Node --> SL
    SL --> GDS
    SL --> CS
    
    Node --> RL
    
    EN --> ED
    EN --> EP
    EN --> Node
    EN --> RL
    
    RS --> VP
    PS2D --> Node
    PS3D --> Node
```

**Key System Interaction Patterns**

The systems interact through several patterns:

**1. Initialization Dependencies:**
`Main` â†’ `OS` â†’ `ProjectSettings` â†’ `Servers` â†’ `SceneTree` â†’ `EditorNode`

Each stage depends on the previous being initialized. [main/main.cpp:1500-2900]()

**2. Node-Server Communication:**
Nodes communicate with servers through RIDs (Resource IDs). For example, `Viewport` creates a viewport RID on `RenderingServer` and updates it each frame.

[scene/main/viewport.cpp:566-600]()

**3. Resource Loading:**
`ResourceLoader` delegates to format-specific loaders (`ResourceFormatLoader`), caches results in `ResourceCache`, and notifies dependent systems.

[core/io/resource_loader.cpp:1-200]()

**4. Script Integration:**
`ScriptLanguage` implementations register with the engine. Nodes attach `ScriptInstance` objects that provide scripted behavior during node lifecycle callbacks.

[scene/main/node.cpp:60-100](), [core/object/script_language.h:1-100]()

**5. Editor Extension:**
`EditorPlugin` instances extend the editor by adding UI, handling selections, and modifying the scene. They interact through `EditorInterface` and `EditorNode`.

[editor/editor_node.cpp:1000-1200](), [editor/editor_interface.cpp:1-200]()

**Sources:** [main/main.cpp:1500-2900](), [scene/main/viewport.cpp:566-743](), [core/io/resource_loader.cpp:1-200](), [scene/main/node.cpp:60-315](), [editor/editor_node.cpp:1000-1200]()

## Code Organization

The repository follows this directory structure:

| Directory | Purpose |
|-----------|---------|
| `core/` | Core types, OS abstraction, I/O, configuration |
| `scene/` | Scene system, nodes, GUI controls, resources |
| `servers/` | Low-level servers (rendering, physics, audio, etc.) |
| `editor/` | Editor application, tools, plugins |
| `modules/` | Optional modules (gdscript, regex, etc.) |
| `platform/` | Platform-specific implementations |
| `drivers/` | Low-level drivers (OpenGL, Vulkan, etc.) |
| `main/` | Entry point and initialization |
| `doc/` | XML class reference documentation |

**Sources:** [main/:1](), [core/:1](), [scene/:1](), [editor/:1](), [servers/:1]()

## Main Loop Execution

Once initialized, the engine enters its main loop in `Main::iteration()`:

```mermaid
sequenceDiagram
    participant Main as "Main::iteration()"
    participant ST as "SceneTree"
    participant Input as "Input"
    participant Servers as "Servers"
    participant Nodes as "Nodes"
    
    loop Every Frame
        Main->>Input: Process input events
        Main->>Servers: Server pre-frame work
        Main->>ST: process(delta)
        ST->>Nodes: _process(delta)
        Main->>Servers: PhysicsServer::flush_queries()
        Main->>ST: physics_process(delta)
        ST->>Nodes: _physics_process(delta)
        Main->>Servers: RenderingServer::draw()
        Main->>Servers: AudioServer::update()
    end
```

**Main Loop Iteration**

The main loop processes one frame:

1. **Input Processing**: Dispatch input events to the scene tree
2. **Idle Processing**: Call `_process()` on all nodes requesting it
3. **Physics Step**: Fixed timestep physics simulation and `_physics_process()` callbacks
4. **Rendering**: Update transforms and submit draw commands to `RenderingServer`
5. **Audio**: Mix and output audio streams
6. **Server Synchronization**: Flush server command queues

**Sources:** [main/main.cpp:2500-3000](), [scene/main/scene_tree.cpp:500-700]()

---

This overview introduces Godot's architecture. For implementation details of each system, refer to the linked subsystem pages in the table of contents.18:T53db,# Major Systems

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [core/os/main_loop.cpp](core/os/main_loop.cpp)
- [core/os/main_loop.h](core/os/main_loop.h)
- [doc/classes/Control.xml](doc/classes/Control.xml)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/MainLoop.xml](doc/classes/MainLoop.xml)
- [doc/classes/Node.xml](doc/classes/Node.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/SceneTree.xml](doc/classes/SceneTree.xml)
- [doc/classes/Viewport.xml](doc/classes/Viewport.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [doc/classes/Window.xml](doc/classes/Window.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [scene/gui/control.cpp](scene/gui/control.cpp)
- [scene/gui/control.h](scene/gui/control.h)
- [scene/main/node.cpp](scene/main/node.cpp)
- [scene/main/node.h](scene/main/node.h)
- [scene/main/scene_tree.cpp](scene/main/scene_tree.cpp)
- [scene/main/scene_tree.h](scene/main/scene_tree.h)
- [scene/main/viewport.cpp](scene/main/viewport.cpp)
- [scene/main/viewport.h](scene/main/viewport.h)
- [scene/main/window.cpp](scene/main/window.cpp)
- [scene/main/window.h](scene/main/window.h)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



This document provides an overview of the primary subsystems that form the foundation of Godot Engine. These systems work together to enable game development, asset management, scripting, and editor functionality. This page focuses on architectural relationships and core responsibilities of each major system.

For detailed information about specific subsystems:
- Scene system internals: see [Scene System](#4)
- Resource management details: see [Resource System](#5)
- GDScript implementation: see [GDScript System](#6)
- Editor architecture: see [Editor Core](#7)
- Build and compilation: see [Build System](#2)

---

## System Architecture Overview

Godot Engine is organized into five major interconnected systems:

| System | Core Classes | Primary Responsibilities |
|--------|-------------|-------------------------|
| **Scene System** | `Node`, `SceneTree`, `Viewport` | Node hierarchy management, lifecycle, processing, scene loading |
| **Resource System** | `Resource`, `ResourceLoader`, `ResourceSaver` | Asset loading, caching, format handling, dependencies |
| **Scripting System** | `ScriptLanguage`, `GDScript`, script compilers | Code execution, language integration, bytecode generation |
| **Editor System** | `EditorNode`, `EditorPlugin`, `EditorInterface` | Development environment, visual editing, plugin architecture |
| **Platform Abstraction** | `OS`, `DisplayServer`, `Main` | Cross-platform compatibility, window management, initialization |

Sources: [main/main.cpp:1-700](), [scene/main/node.h:1-150](), [core/io/resource.h:1-150](), [editor/editor_node.h:1-300]()

---

## Scene System

The scene system provides the fundamental node hierarchy structure that games are built upon. It manages the lifecycle of nodes, processing loops, and viewport rendering.

### Core Components

```mermaid
graph TB
    Main["Main::start<br/>(main.cpp)"]
    SceneTree["SceneTree<br/>Game loop orchestrator"]
    Node["Node<br/>Base class for all scene objects"]
    Viewport["Viewport<br/>Rendering target & input handler"]
    Window["Window<br/>OS window wrapper"]
    Control["Control<br/>UI base class"]
    
    Main --> SceneTree
    SceneTree --> |"root viewport"| Viewport
    Viewport --> |"inherits"| Node
    Window --> |"inherits"| Viewport
    Node --> |"parent/child"| Node
    Control --> |"inherits"| Node
    
    SceneTree --> |"process()"| Node
    SceneTree --> |"physics_process()"| Node
```

**Scene System: Core class relationships**

Sources: [scene/main/scene_tree.cpp:1-200](), [scene/main/node.cpp:1-500](), [scene/main/viewport.cpp:1-200]()

### Node Lifecycle

Nodes follow a strict lifecycle managed by `SceneTree`:

| Phase | Notification | Method Called | Purpose |
|-------|-------------|---------------|---------|
| Addition | `NOTIFICATION_ENTER_TREE` | `_enter_tree()` | Node enters scene tree, setup connections |
| Post-addition | `NOTIFICATION_POST_ENTER_TREE` | N/A | Translation system setup |
| Ready | `NOTIFICATION_READY` | `_ready()` | Initialization after entire subtree is added |
| Frame processing | `NOTIFICATION_PROCESS` | `_process(delta)` | Per-frame logic |
| Physics processing | `NOTIFICATION_PHYSICS_PROCESS` | `_physics_process(delta)` | Fixed timestep physics |
| Removal | `NOTIFICATION_EXIT_TREE` | `_exit_tree()` | Cleanup before removal |

Sources: [scene/main/node.cpp:60-315](), [scene/main/scene_tree.cpp:140-200]()

### Processing Architecture

```mermaid
graph LR
    subgraph "Main Loop"
        Main_iteration["Main::iteration()"]
    end
    
    subgraph "SceneTree Processing"
        ST_process["SceneTree::_process()"]
        ST_physics["SceneTree::_physics_process()"]
        ProcessGroups["Process Groups<br/>(threaded)"]
    end
    
    subgraph "Node Processing"
        Node_process["Node::_process()"]
        Node_physics["Node::_physics_process()"]
        Node_input["Node::_input()"]
    end
    
    Main_iteration --> ST_process
    Main_iteration --> ST_physics
    ST_process --> ProcessGroups
    ST_physics --> ProcessGroups
    ProcessGroups --> Node_process
    ProcessGroups --> Node_physics
    ST_process --> Node_input
```

**Scene processing flow from main loop to nodes**

The `SceneTree` manages process groups which can run on separate threads based on node `process_thread_group` settings. Process groups are defined by nodes with `ProcessThreadGroup` set to `SUB_THREAD`.

Sources: [main/main.cpp:2500-2800](), [scene/main/scene_tree.cpp:700-1000](), [scene/main/node.cpp:140-180]()

### Viewport System

`Viewport` nodes serve as rendering targets and input coordinators:

- **Root Viewport**: Created by `SceneTree`, represents the main game window
- **Sub-Viewports**: Render to texture, can be embedded in UI
- **Input Handling**: Propagates input events to child nodes
- **World Integration**: Connects to `World2D` and `World3D` for physics/rendering

Sources: [scene/main/viewport.cpp:570-747](), [scene/main/viewport.h:95-300]()

---

## Resource System

The resource system handles all asset loading, caching, and serialization. Resources are reference-counted objects that can be shared across the scene tree.

### Resource Loading Pipeline

```mermaid
graph TB
    Request["ResourceLoader::load(path)"]
    Cache["Resource Cache<br/>HashMap by path/UID"]
    Format["Format Loaders<br/>Text/Binary/Import"]
    Importer["ResourceImporter<br/>.import files"]
    Disk["Disk/PackedData<br/>FileAccess"]
    
    Request --> Cache
    Cache --> |"cache miss"| Format
    Cache --> |"cache hit"| Return["Return Ref&lt;Resource&gt;"]
    Format --> |".tres/.tscn"| TextLoader["ResourceFormatLoaderText"]
    Format --> |".res/.scn"| BinaryLoader["ResourceFormatLoaderBinary"]
    Format --> |"has .import"| Importer
    TextLoader --> Disk
    BinaryLoader --> Disk
    Importer --> Disk
    TextLoader --> Return
    BinaryLoader --> Return
    Importer --> Return
```

**Resource loading flow with caching and format handlers**

Sources: [core/io/resource_loader.cpp:1-400](), [core/io/resource_loader.h:1-200]()

### Resource Class Hierarchy

Key classes in the resource system:

| Class | Location | Role |
|-------|----------|------|
| `Resource` | [core/io/resource.h:40-150]() | Base class, reference counting, path/UID management |
| `ResourceLoader` | [core/io/resource_loader.h:1-200]() | Static loading API, format registration |
| `ResourceSaver` | Not in files, similar to loader | Static saving API |
| `ResourceFormatLoader` | [core/io/resource_loader.h:40-80]() | Interface for format-specific loaders |
| `ResourceImporter` | [core/io/resource_importer.cpp:1-100]() | Import pipeline for source assets |
| `PackedScene` | [scene/resources/packed_scene.h]() | Serialized scene resource |

Sources: [core/io/resource.cpp:1-400](), [core/io/resource_loader.cpp:1-600]()

### Cache Management

The resource cache uses three modes controlled by `ResourceLoader::CacheMode`:

```mermaid
graph LR
    REUSE["CACHE_MODE_REUSE<br/>Default: return cached"]
    REPLACE["CACHE_MODE_REPLACE<br/>Reload and update cache"]
    IGNORE["CACHE_MODE_IGNORE<br/>Load new, don't cache"]
    
    REUSE --> |"if cached"| Return["Return cached"]
    REUSE --> |"if not cached"| Load["Load & cache"]
    REPLACE --> Load2["Load & replace cache"]
    IGNORE --> Load3["Load without caching"]
```

**Resource cache modes determine whether to reuse, replace, or bypass cache**

Sources: [core/io/resource_loader.cpp:200-500]()

### Import System

For source assets (images, audio, 3D models), the import system:

1. Detects `.import` sidecar files next to source assets
2. Reads import configuration and importer type
3. Executes appropriate `ResourceImporter` subclass
4. Saves processed resource to `.godot/imported/`
5. Tracks dependencies and timestamps for reimport detection

Sources: [core/io/resource_importer.cpp:1-300](), [editor/editor_node.cpp:117-135]()

---

## Scripting System

The scripting system provides language integration, compilation, and runtime execution. While Godot supports multiple scripting languages, GDScript is the primary built-in language.

### Script Architecture

```mermaid
graph TB
    ScriptLanguage["ScriptLanguage<br/>Abstract interface"]
    GDScript_Lang["GDScript<br/>Language implementation"]
    Script["Script<br/>Base class"]
    GDScript_Class["GDScript class<br/>Compiled script"]
    
    ScriptLanguage --> |"implements"| GDScript_Lang
    Script --> |"subclass"| GDScript_Class
    GDScript_Lang --> |"creates"| GDScript_Class
    
    Node["Node"] --> |"has script"| Script
    Script --> |"create_instance()"| ScriptInstance["ScriptInstance"]
    ScriptInstance --> |"attached to"| Node
```

**Script system class relationships**

Sources: [core/object/script_language.h](), [modules/gdscript/gdscript.h]()

### GDScript Pipeline

GDScript compilation follows a multi-stage pipeline:

| Stage | Class | Input | Output | Purpose |
|-------|-------|-------|--------|---------|
| Tokenization | `GDScriptTokenizer` | Source text | Token stream | Lexical analysis |
| Parsing | `GDScriptParser` | Tokens | AST | Syntax tree construction |
| Analysis | `GDScriptAnalyzer` | AST | Annotated AST | Type checking, resolution |
| Compilation | `GDScriptCompiler` | AST | Bytecode | Code generation |
| Execution | `GDScriptVM` | Bytecode | Runtime | Bytecode interpretation |

For detailed GDScript implementation, see [GDScript System](#6).

Sources: [modules/gdscript/]() (various files)

---

## Editor System

The editor system provides the development environment, visual editing tools, and plugin architecture. It is only compiled when building with `tools=yes` (default for editor builds).

### Editor Architecture

```mermaid
graph TB
    EditorNode["EditorNode<br/>Singleton orchestrator"]
    EditorInterface["EditorInterface<br/>Plugin API"]
    EditorPlugin["EditorPlugin<br/>Base for extensions"]
    EditorData["EditorData<br/>Scene state & history"]
    
    subgraph "Main Screens"
        Screen2D["2D Editor"]
        Screen3D["3D Editor"]
        ScreenScript["Script Editor"]
        ScreenAsset["AssetLib"]
    end
    
    subgraph "Docks"
        FileSystem["FileSystemDock"]
        Inspector["InspectorDock"]
        Scene["SceneTreeDock"]
        Import["ImportDock"]
    end
    
    EditorNode --> EditorInterface
    EditorNode --> EditorData
    EditorNode --> EditorPlugin
    EditorPlugin --> EditorInterface
    
    EditorNode --> Screen2D
    EditorNode --> Screen3D
    EditorNode --> ScreenScript
    EditorNode --> ScreenAsset
    
    EditorNode --> FileSystem
    EditorNode --> Inspector
    EditorNode --> Scene
    EditorNode --> Import
```

**Editor component hierarchy and plugin integration**

Sources: [editor/editor_node.h:118-300](), [editor/editor_interface.h:1-200](), [editor/editor_data.h:1-200]()

### Editor Initialization

The editor is initialized in `Main::start()` after core engine initialization:

1. Register editor types and singletons
2. Create `EditorNode` singleton
3. Initialize editor settings from `editor_settings-4.tres`
4. Load project settings from `project.godot`
5. Register built-in editor plugins
6. Scan and load addon plugins from `res://addons/`
7. Setup editor UI and docks
8. Load last opened scene or show project manager

Sources: [main/main.cpp:2000-2500](), [editor/editor_node.cpp:500-1000]()

### Plugin System

`EditorPlugin` provides extension points for the editor:

| Extension Point | Method | Purpose |
|----------------|--------|---------|
| Main screen | `_has_main_screen()`, `_make_visible()` | Add custom editor tabs |
| Scene editing | `_edit()`, `_handles()` | Custom node editors |
| Import | `_get_importer()` | Custom import pipelines |
| Inspector | `_parse_property()` | Custom property widgets |
| Toolbar | `_get_plugin_icon()` | Add toolbar buttons |
| Debugger | `_has_debugger()` | Debugger panels |

Sources: [editor/plugins/editor_plugin.h](), [doc/classes/EditorPlugin.xml:1-300]()

---

## Platform Abstraction

The platform abstraction layer isolates platform-specific code, enabling cross-platform compilation.

### OS and DisplayServer

```mermaid
graph TB
    Main_setup["Main::setup()"]
    OS["OS<br/>Process, files, threads"]
    DisplayServer["DisplayServer<br/>Windows, input, cursors"]
    
    subgraph "Platform Implementations"
        OS_Windows["OS_Windows"]
        OS_Unix["OS_Unix (Linux/macOS)"]
        OS_Android["OS_Android"]
        DS_Windows["DisplayServer_Windows"]
        DS_X11["DisplayServer_X11"]
        DS_Wayland["DisplayServer_Wayland"]
    end
    
    Main_setup --> OS
    Main_setup --> DisplayServer
    OS --> OS_Windows
    OS --> OS_Unix
    OS --> OS_Android
    DisplayServer --> DS_Windows
    DisplayServer --> DS_X11
    DisplayServer --> DS_Wayland
```

**Platform abstraction through OS and DisplayServer interfaces**

Sources: [main/main.cpp:1-500](), [core/os/os.h](), [servers/display/display_server.h]()

### Initialization Sequence

The engine initialization follows this sequence in `Main::setup()` and `Main::setup2()`:

1. **Early Setup** (`Main::setup()`):
   - Parse command-line arguments
   - Initialize `OS` singleton for target platform
   - Setup memory allocators and thread pool
   - Initialize `ProjectSettings` and locate project
   - Register core types and singletons

2. **Server Setup** (`Main::setup2()`):
   - Create `DisplayServer` for windowing
   - Initialize `RenderingServer` for graphics
   - Initialize `PhysicsServer2D` and `PhysicsServer3D`
   - Initialize `AudioServer`
   - Setup `TextServer` for font rendering
   - Create `SceneTree` and root `Viewport`

3. **Late Setup**:
   - Load project settings and autoloads
   - Initialize editor if `--editor` flag is present
   - Load main scene or start editor

Sources: [main/main.cpp:500-2000](), [main/main.h:1-100]()

### Configuration Management

```mermaid
graph LR
    ProjectSettings["ProjectSettings<br/>(project.godot)"]
    EditorSettings["EditorSettings<br/>(editor_settings-4.tres)"]
    OS_Env["OS::get_environment()"]
    CmdLine["Command-line args"]
    
    ProjectSettings --> |"GLOBAL_GET()"| Game["Game Runtime"]
    EditorSettings --> |"EDITOR_GET()"| Editor["Editor"]
    OS_Env --> ProjectSettings
    CmdLine --> ProjectSettings
    
    ProjectSettings --> |"feature tags"| Override["override.cfg"]
```

**Configuration sources and priority**

- `ProjectSettings`: Stores project-wide settings in `project.godot`
- `EditorSettings`: Stores editor preferences per-user
- Feature tags: Allow platform/configuration-specific overrides
- Command-line: Can override settings at runtime

Sources: [core/config/project_settings.cpp:1-400](), [core/config/project_settings.h:1-150](), [doc/classes/ProjectSettings.xml:1-100]()

---

## System Interactions

### Complete Engine Data Flow

```mermaid
graph TB
    subgraph "Initialization"
        Main["Main::setup()"]
        Servers["Server Initialization<br/>Rendering/Physics/Audio"]
        SceneTree_Init["SceneTree creation"]
    end
    
    subgraph "Runtime Loop"
        Main_iter["Main::iteration()"]
        ST_process["SceneTree::_process_frame()"]
        Node_callbacks["Node lifecycle callbacks"]
        Servers_sync["Server sync & render"]
    end
    
    subgraph "Resource Flow"
        Load_Request["ResourceLoader::load()"]
        Parse["Format-specific parsing"]
        Instantiate["Object instantiation"]
        Cache_Store["Cache storage"]
    end
    
    subgraph "Script Flow"
        Script_Load["Script loaded as Resource"]
        Script_Compile["GDScript compile pipeline"]
        Script_Attach["Attach to Node"]
        Script_Execute["Execute in VM"]
    end
    
    Main --> Servers
    Servers --> SceneTree_Init
    SceneTree_Init --> Main_iter
    Main_iter --> ST_process
    ST_process --> Node_callbacks
    Node_callbacks --> Script_Execute
    ST_process --> Servers_sync
    
    Node_callbacks -.-> Load_Request
    Load_Request --> Parse
    Parse --> Instantiate
    Instantiate --> Cache_Store
    
    Parse --> Script_Load
    Script_Load --> Script_Compile
    Script_Compile --> Script_Attach
    Script_Attach --> Script_Execute
```

**High-level data flow across major systems**

Sources: [main/main.cpp:2500-3000](), [scene/main/scene_tree.cpp:800-1200](), [core/io/resource_loader.cpp:1-600]()

### Editor-Game Integration

When the editor runs a game scene:

1. `EditorRunBar` initiates play mode
2. Separate process spawned with game executable
3. `--remote-debug` flag connects debugger
4. Editor's `ScriptEditorDebugger` connects to game process
5. Game sends debug info, editor sends breakpoints/inspection
6. Stopping game kills subprocess

When running in-editor (single process):

1. Current scene saved to temporary location
2. Scene loaded in separate `Viewport`
3. Input redirected to game viewport
4. Script execution monitored by debugger
5. Scene unloaded when stopped

Sources: [editor/run/editor_run_bar.cpp](), [editor/debugger/]()

---

## Key Takeaways

The major systems in Godot Engine are:

1. **Scene System**: Node-based hierarchy with lifecycle management via `SceneTree`, processing groups, and viewport rendering
2. **Resource System**: Unified asset loading with caching, format handlers, and import pipeline via `ResourceLoader` and `ResourceImporter`
3. **Scripting System**: Multi-language support with GDScript compiler pipeline (tokenize â†’ parse â†’ analyze â†’ compile â†’ execute)
4. **Editor System**: Plugin-based development environment orchestrated by `EditorNode` with dockable UI and visual editors
5. **Platform Abstraction**: Cross-platform support through `OS` and `DisplayServer` interfaces with platform-specific implementations

These systems communicate through well-defined interfaces and are initialized in a specific order by `Main::setup()` and `Main::setup2()`.

Sources: [main/main.cpp:1-3000](), [scene/main/scene_tree.cpp:1-2000](), [core/io/resource_loader.cpp:1-600](), [editor/editor_node.cpp:1-1000]()19:T69c1,# Build System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [SConstruct](SConstruct)
- [core/SCsub](core/SCsub)
- [editor/SCsub](editor/SCsub)
- [editor/icons/SCsub](editor/icons/SCsub)
- [main/SCsub](main/SCsub)
- [methods.py](methods.py)
- [modules/SCsub](modules/SCsub)
- [modules/gdscript/editor/script_templates/SCsub](modules/gdscript/editor/script_templates/SCsub)
- [modules/modules_builders.py](modules/modules_builders.py)
- [modules/mono/editor/script_templates/SCsub](modules/mono/editor/script_templates/SCsub)
- [platform/SCsub](platform/SCsub)
- [platform/android/detect.py](platform/android/detect.py)
- [platform/ios/detect.py](platform/ios/detect.py)
- [platform/linuxbsd/detect.py](platform/linuxbsd/detect.py)
- [platform/macos/detect.py](platform/macos/detect.py)
- [platform/web/detect.py](platform/web/detect.py)
- [platform/windows/SCsub](platform/windows/SCsub)
- [platform/windows/detect.py](platform/windows/detect.py)
- [platform_methods.py](platform_methods.py)
- [scene/theme/icons/SCsub](scene/theme/icons/SCsub)

</details>



## Purpose and Scope

This document describes Godot's SCons-based build system, including platform detection, module configuration, code generation, and compilation orchestration. It covers the build-time architecture that produces engine binaries from source code.

For runtime initialization and engine startup, see [Engine Initialization](#3.1). For platform-specific runtime functionality, see [OS Abstraction Layer](#3.2). For module registration at runtime, see [Module System](#2.3).

---

## Build Tool: SCons

Godot uses SCons (Software Construction tool), a Python-based build system. SCons version 4.0+ is required [SConstruct:4](). The build system is defined through:

- **SConstruct**: Main build script at repository root
- **SCsub files**: Subsystem-specific build scripts (equivalent to makefiles)
- **methods.py**: Shared build helper functions
- **platform_methods.py**: Platform-specific utilities

SCons is chosen over traditional Make because it provides:
- Cross-platform compatibility
- Python integration for complex build logic
- Automatic dependency detection
- Built-in support for parallel builds

**Sources:** [SConstruct:1-20](), [methods.py:1-20]()

---

## Build Entry Point: SConstruct

The main build script [SConstruct]() orchestrates the entire build process through several phases:

### 1. Helper Module Loading

The build system explicitly loads helper modules to avoid naming conflicts [SConstruct:19-55]():

```python
_helper_module("methods", "methods.py")
_helper_module("platform_methods", "platform_methods.py")
_helper_module("gles3_builders", "gles3_builders.py")
_helper_module("glsl_builders", "glsl_builders.py")
```

### 2. Platform Detection

All platform directories are scanned for `detect.py` files [SConstruct:77-109]():

```
platform/
â”œâ”€â”€ windows/detect.py
â”œâ”€â”€ linuxbsd/detect.py
â”œâ”€â”€ macos/detect.py
â”œâ”€â”€ android/detect.py
â”œâ”€â”€ web/detect.py
â””â”€â”€ ...
```

Each `detect.py` must provide:
- `can_build()`: Check if platform is buildable
- `get_opts()`: Return platform-specific build options
- `get_flags()`: Return default platform flags
- `configure(env)`: Configure the build environment

### 3. Build Configuration Flow

```mermaid
flowchart TB
    Start["SConstruct Entry"]
    LoadHelpers["Load Helper Modules<br/>(methods.py, platform_methods.py)"]
    ScanPlatforms["Scan platform/*/detect.py"]
    CreateEnv["Create SCons Environment"]
    DetectPlatform["Detect/Validate Platform"]
    LoadPlatformOpts["Load Platform Options<br/>get_opts()"]
    DetectModules["Detect Modules<br/>methods.detect_modules()"]
    LoadModuleOpts["Load Module Options<br/>config.get_opts()"]
    ApplyFlags["Apply Platform Flags<br/>get_flags()"]
    ConfigurePlatform["Configure Platform<br/>detect.configure(env)"]
    BuildCore["Build Core Systems"]
    BuildModules["Build Modules"]
    BuildEditor["Build Editor (if target=editor)"]
    LinkBinary["Link Final Binary"]
    
    Start --> LoadHelpers
    LoadHelpers --> ScanPlatforms
    ScanPlatforms --> CreateEnv
    CreateEnv --> DetectPlatform
    DetectPlatform --> LoadPlatformOpts
    LoadPlatformOpts --> DetectModules
    DetectModules --> LoadModuleOpts
    LoadModuleOpts --> ApplyFlags
    ApplyFlags --> ConfigurePlatform
    ConfigurePlatform --> BuildCore
    BuildCore --> BuildModules
    BuildModules --> BuildEditor
    BuildEditor --> LinkBinary
```

**Sources:** [SConstruct:1-700](), [methods.py:240-300]()

---

## Platform Detection System

Each platform implements a standardized detection interface through `platform/*/detect.py`:

### Platform Detection Interface

Each platform's `detect.py` module implements a standard interface:

```mermaid
graph TB
    subgraph "Standard API (all platforms)"
        can_build["can_build()<br/>Returns bool: SDK available"]
        get_name["get_name()<br/>Returns platform name string"]
        get_opts["get_opts()<br/>Returns SCons Variables"]
        get_flags["get_flags()<br/>Returns default flag dict"]
        get_tools["get_tools(env)<br/>Returns SCons tool list"]
        configure["configure(env)<br/>Configures Environment"]
    end
    
    subgraph "Windows (detect.py)"
        win_can_build["can_build()<br/>msvc_exists() or try_cmd()"]
        win_get_tools["get_tools(env)<br/>Returns ['mingw'] or ['msvc','mslink','mslib']"]
        configure_msvc["configure_msvc(env)"]
        configure_mingw["configure_mingw(env)"]
    end
    
    subgraph "Android (detect.py)"
        and_can_build["can_build()<br/>os.path.exists(get_env_android_sdk_root())"]
        install_ndk_if_needed["install_ndk_if_needed(env)<br/>Auto-downloads NDK via sdkmanager"]
        and_configure["configure(env)<br/>Sets target_triple, ANDROID_NDK_ROOT"]
    end
    
    subgraph "Web (detect.py)"
        web_can_build["can_build()<br/>WhereIs('emcc') is not None"]
        web_configure["configure(env)<br/>Sets env['CC']='emcc', WASM flags"]
        library_emitter["library_emitter(target, source, env)<br/>Adds compiler version dependency"]
    end
    
    can_build -.-> win_can_build
    can_build -.-> and_can_build
    can_build -.-> web_can_build
    
    configure -.-> configure_msvc
    configure -.-> configure_mingw
    configure -.-> and_configure
    configure -.-> web_configure
```

### Platform-Specific Configuration Examples

| Platform | Compiler Detection | Key Configuration Functions |
|----------|-------------------|----------------------------|
| **Windows** | `msvc_exists()` from SCons.Tool.MSCommon or `try_cmd("gcc --version", prefix, arch)` | `configure_msvc(env)` [platform/windows/detect.py:243-519]()<br/>`configure_mingw(env)` [platform/windows/detect.py:587-752]() |
| **Linux/BSD** | Auto-detect via `env["use_llvm"]` or CXX environ | `configure(env)` [platform/linuxbsd/detect.py:74-462]() |
| **macOS** | Xcode via `detect_darwin_sdk_path()` or OSXCross | `configure(env)` [platform/macos/detect.py:69-287]() |
| **Android** | `get_env_android_sdk_root()`, `install_ndk_if_needed()` | `configure(env)` [platform/android/detect.py:117-245]() |
| **Web** | `WhereIs("emcc")` check | `configure(env)` [platform/web/detect.py:103-348]() |
| **iOS** | `detect_darwin_toolchain_path(env)` | `configure(env)` [platform/ios/detect.py:59-183]() |

### Architecture Detection

The build system supports multiple CPU architectures [platform_methods.py:20-34]():

```python
architectures = ["x86_32", "x86_64", "arm32", "arm64", 
                 "rv64", "ppc64", "wasm32", "loongarch64"]
architecture_aliases = {
    "x86": "x86_32", "amd64": "x86_64",
    "armv7": "arm32", "aarch64": "arm64", ...
}
```

Platform-specific architecture validation occurs via `validate_arch()` [platform_methods.py:51-57]().

**Sources:** [platform/windows/detect.py:1-800](), [platform/android/detect.py:1-245](), [platform/linuxbsd/detect.py:1-500](), [platform/web/detect.py:1-348](), [platform_methods.py:1-60]()

---

## Module Detection and Registration

### Module Discovery

Modules are auto-detected from directories containing required files [methods.py:240-310]():

```python
def detect_modules(search_path, recursive=False):
    # A valid module must have:
    must_exist = ["register_types.h", "SCsub", "config.py"]
```

Module search paths [SConstruct:436-461]():
1. Built-in: `modules/` (non-recursive)
2. Custom: Paths from `custom_modules` option (recursive if `custom_modules_recursive=yes`)

### Module Build Integration

```mermaid
flowchart LR
    subgraph "Module Detection Phase"
        DetectMods["methods.detect_modules()<br/>Find all modules"]
        LoadConfig["Import module config.py<br/>Get options and dependencies"]
        AddOpts["Add module_<name>_enabled option"]
    end
    
    subgraph "Code Generation Phase"
        GenEnabled["Generate modules_enabled.gen.h<br/>MODULE_*_ENABLED defines"]
        GenRegister["Generate register_module_types.gen.cpp<br/>Module initialization calls"]
    end
    
    subgraph "Build Phase"
        BuildModule["Build each module SCsub<br/>Create libmodule_<name>.a"]
        LinkModules["Link all module libraries"]
    end
    
    DetectMods --> LoadConfig
    LoadConfig --> AddOpts
    AddOpts --> GenEnabled
    GenEnabled --> GenRegister
    GenRegister --> BuildModule
    BuildModule --> LinkModules
```

### Generated Module Files

The build generates two critical files:

**1. modules_enabled.gen.h** [modules/SCsub:19-21]():
```cpp
#define MODULE_GDSCRIPT_ENABLED
#define MODULE_GLTF_ENABLED
// ... for each enabled module
```

**2. register_module_types.gen.cpp** [modules/SCsub:24-28](), [modules/modules_builders.py:15-53]():
```cpp
#include "modules/gdscript/register_types.h"
#include "modules/gltf/register_types.h"

void initialize_modules(ModuleInitializationLevel p_level) {
#ifdef MODULE_GDSCRIPT_ENABLED
    initialize_gdscript_module(p_level);
#endif
    // ...
}
```

### Module Configuration Interface

Each module's `config.py` can provide [SConstruct:466-486]():
- `is_enabled()`: Whether module is enabled by default
- `get_opts(platform)`: Module-specific build options
- Module dependencies via `env.module_add_dependencies()`

**Sources:** [SConstruct:434-491](), [modules/SCsub:1-65](), [modules/modules_builders.py:1-61](), [methods.py:240-363]()

---

## Code Generation at Build Time

The build system generates numerous source files during compilation:

### Core Code Generation

Generated files in `core/` subsystem:

| Generated File | Source | Builder Function | Location |
|----------------|--------|------------------|----------|
| `version_generated.gen.h` | `methods.get_version_info()` | `core_builders.version_info_builder` | [core/SCsub:177-181]() |
| `version_hash.gen.cpp` | `methods.get_git_info()` | `core_builders.version_hash_builder` | [core/SCsub:184-187]() |
| `script_encryption_key.gen.cpp` | `SCRIPT_AES256_ENCRYPTION_KEY` env var | `core_builders.encryption_key_builder` | [core/SCsub:196-201]() |
| `disabled_classes.gen.h` | `env.disabled_classes` list | `core_builders.disabled_class_builder` | [core/SCsub:172-174]() |
| `certs_compressed.gen.h` | `thirdparty/certs/ca-bundle.crt` | `core_builders.make_certs_header` | [core/SCsub:204-208]() |
| `authors.gen.h` | `AUTHORS.md` | `core_builders.make_authors_header` | [core/SCsub:211]() |
| `donors.gen.h` | `DONORS.md` | `core_builders.make_donors_header` | [core/SCsub:214]() |
| `license.gen.h` | `COPYRIGHT.txt`, `LICENSE.txt` | `core_builders.make_license_header` | [core/SCsub:217-219]() |

### Editor Code Generation

Generated files in `editor/` subsystem:

| Generated File | Source | Builder Function | Location |
|----------------|--------|------------------|----------|
| `doc_data_compressed.gen.h` | `doc/classes/*.xml` + module docs | `editor_builders.make_doc_header` | [editor/SCsub:47-51]() |
| `doc_data_class_path.gen.h` | `env.doc_class_path` dict | `editor_builders.doc_data_class_path_builder` | [editor/SCsub:14-18]() |
| `register_exporters.gen.cpp` | `env.platform_exporters` list | `editor_builders.register_exporters_builder` | [editor/SCsub:21-25]() |
| `editor_icons.gen.h` | `editor/icons/*.svg` + module SVGs | `editor_icons_builders.make_editor_icons_action` | [editor/icons/SCsub:20-24]() |
| `editor_translations.gen.h/.cpp` | `editor/translations/editor/*` | `editor_builders.make_translations` | [editor/SCsub:60-71]() |
| `property_translations.gen.h/.cpp` | `editor/translations/properties/*` | `editor_builders.make_translations` | [editor/SCsub:61-71]() |
| `doc_translations.gen.h/.cpp` | `doc/translations/*` | `editor_builders.make_translations` | [editor/SCsub:62-71]() |

### Platform and Module Generation

| Generated File | Builder Function | Location |
|----------------|------------------|----------|
| `register_platform_apis.gen.cpp` | `platform_builders.register_platform_apis_builder` | [platform/SCsub:20-24]() |
| Platform export icon headers | `platform_builders.export_icon_builder` | [platform/SCsub:16]() |
| `modules_enabled.gen.h` | `modules_builders.modules_enabled_builder` | [modules/SCsub:19-21]() |
| `register_module_types.gen.cpp` | `modules_builders.register_module_types_builder` | [modules/SCsub:24-28]() |

### Code Generation Pattern

All generated files use `env.CommandNoCache()` to ensure regeneration [SConstruct:134]():

```python
env.CommandNoCache(target, source, env.Run(builder_function))
```

This prevents SCons from caching generated files, ensuring they're always up-to-date.

**Sources:** [core/SCsub:1-244](), [editor/SCsub:1-103](), [modules/SCsub:1-65](), [platform/SCsub:1-31](), [SConstruct:607-610]()

---

## Build Configuration System

### Build Options Hierarchy

Build options are processed in multiple passes through `opts.Update(env)`:

```mermaid
flowchart TB
    subgraph "Option Definition"
        customs["customs list<br/>['custom.py', profile file]"]
        opts_core["opts = Variables(customs, ARGUMENTS)<br/>Create Variables object"]
        add_core["opts.Add(...) for core options<br/>target, arch, optimize, etc."]
        add_platform["opts.AddVariables(*platform_opts[platform])"]
        add_module["opts.Add(BoolVariable(f'module_{name}_enabled', ...))"]
    end
    
    subgraph "Update Passes"
        update1["opts.Update(env)<br/>Line 362: Apply core + customs"]
        detect_platform["Platform auto-detection<br/>Lines 375-417"]
        load_platform_opts["Load platform_opts[env['platform']]<br/>Line 421"]
        apply_flags["Apply platform_flags overrides<br/>Lines 426-429"]
        update2["opts.Update(env, {**ARGUMENTS, **env.Dictionary()})<br/>Line 432: Platform options"]
        detect_modules["methods.detect_modules()<br/>Lines 434-461"]
        add_mod_opts["Add module options<br/>Lines 464-486"]
        update3["opts.Update(env, {**ARGUMENTS, **env.Dictionary()})<br/>Line 491: Module options"]
    end
    
    opts_core --> add_core
    add_core --> update1
    update1 --> detect_platform
    detect_platform --> load_platform_opts
    load_platform_opts --> add_platform
    add_platform --> apply_flags
    apply_flags --> update2
    update2 --> detect_modules
    detect_modules --> add_mod_opts
    add_mod_opts --> update3
    
    customs -.feeds.-> opts_core
```

### Core Build Options

Key options defined via `opts.Add()` calls in [SConstruct:160-355]():

| Option | SCons Type | Default | Description |
|--------|-----------|---------|-------------|
| `platform` / `p` | String | Auto-detect | Target platform added via `opts.Add((["platform", "p"], ...))` |
| `target` | `EnumVariable` | `"editor"` | Build type: `["editor", "template_release", "template_debug"]` |
| `arch` | `EnumVariable` | `"auto"` | CPU architecture from `architectures` list in platform_methods.py |
| `optimize` | `EnumVariable` | `"auto"` | Levels: `["auto", "none", "custom", "debug", "speed", "speed_trace", "size", "size_extra"]` |
| `dev_build` | `BoolVariable` | `False` | Enables `CPPDEFINES=["DEV_ENABLED"]` |
| `debug_symbols` | `BoolVariable` | `False` | Computed via `methods.get_cmdline_bool()` if dev_build |
| `lto` | `EnumVariable` | `"none"` | Link-time optimization: `["none", "auto", "thin", "full"]` |
| `threads` | `BoolVariable` | `True` | Threading support |
| `custom_modules` | String | `""` | Comma-separated paths, processed via `methods.convert_custom_modules_path()` |
| `scu_build` | `BoolVariable` | `False` | Enables `scu_builders.generate_scu_files()` |
| `builtin_*` | `BoolVariable` | `True` | Controls use of bundled thirdparty libraries (zlib, freetype, etc.) |

### Build Profiles

Feature build profiles allow disabling specific classes/features [SConstruct:637-653]():

```json
{
  "disabled_classes": ["Node3D", "Camera3D"],
  "disabled_build_options": {
    "disable_3d": true
  }
}
```

Applied via: `scons build_profile=path/to/profile.json`

### Compiler and Linker Configuration

Environment variables can override compilers [SConstruct:345-358]():

```bash
# Set custom compilers
scons CXX=clang++ CC=clang
# Add custom flags
scons ccflags="-march=native" linkflags="-fuse-ld=lld"
```

Compiler launcher support (ccache, sccache) [SConstruct:357-358]():
```bash
scons cpp_compiler_launcher=ccache
```

**Sources:** [SConstruct:147-670](), [methods.py:226-238]()

---

## Build Phases and Subsystem Compilation

### SCsub Chain Loading

After configuration, SConstruct delegates to subsystem SCsub files:

```mermaid
graph TB
    SConstruct["SConstruct<br/>(Main orchestration)"]
    
    subgraph "Core Subsystems"
        CoreSCsub["core/SCsub<br/>Build libcore.a"]
        MainSCsub["main/SCsub<br/>Build libmain.a"]
        SceneSCsub["scene/SCsub<br/>Build scene tree"]
        ServersSCsub["servers/SCsub<br/>Build rendering/physics servers"]
    end
    
    subgraph "Platform Subsystem"
        PlatformSCsub["platform/SCsub<br/>Generate platform registration"]
        WindowsSCsub["platform/windows/SCsub<br/>Build Windows platform"]
        LinuxSCsub["platform/linuxbsd/SCsub<br/>Build Linux platform"]
    end
    
    subgraph "Module Subsystem"
        ModulesSCsub["modules/SCsub<br/>Generate module registration"]
        GDScriptSCsub["modules/gdscript/SCsub<br/>Build GDScript module"]
        GLTFSCsub["modules/gltf/SCsub<br/>Build GLTF module"]
    end
    
    subgraph "Editor Subsystem"
        EditorSCsub["editor/SCsub<br/>Build libeditor.a"]
        IconsSCsub["editor/icons/SCsub<br/>Generate editor icons"]
    end
    
    SConstruct --> CoreSCsub
    SConstruct --> MainSCsub
    SConstruct --> SceneSCsub
    SConstruct --> ServersSCsub
    SConstruct --> PlatformSCsub
    SConstruct --> ModulesSCsub
    SConstruct --> EditorSCsub
    
    PlatformSCsub --> WindowsSCsub
    PlatformSCsub --> LinuxSCsub
    ModulesSCsub --> GDScriptSCsub
    ModulesSCsub --> GLTFSCsub
    EditorSCsub --> IconsSCsub
```

### Source File Collection

Each SCsub uses `env.add_source_files()` to collect sources [methods.py:80-85]():

```python
# Standard source collection
env.add_source_files(env.core_sources, "*.cpp")

# With SCU build optimization
if env["scu_build"]:
    # Groups files into .scu/*.gen.cpp files
    add_source_files_scu(env, sources, "*.cpp")
```

### Library Building

Subsystems build as static libraries [methods.py:595-604]():

```python
# Build library
lib = env.add_library("core", env.core_sources)
# Prepend to link order
env.Prepend(LIBS=[lib])
```

Final link order (right-to-left) [SConstruct:1500-1700]():
```
godot.exe = main.a + editor.a + modules.a + module_*.a + 
            scene.a + servers.a + core.a + platform.a + thirdparty.a
```

### Parallel Compilation

SCons automatically parallelizes compilation. Default: `cpu_count - 1` [SConstruct:598-620]():

```bash
# Manual parallelism control
scons -j 8  # Use 8 jobs
scons num_jobs=16  # Alternative syntax
```

**Sources:** [SConstruct:1400-1700](), [core/SCsub:1-244](), [editor/SCsub:1-103](), [modules/SCsub:1-65](), [platform/SCsub:1-31](), [methods.py:36-86]()

---

## Platform-Specific Build Examples

### Windows Build Configuration

Windows supports both MSVC and MinGW toolchains [platform/windows/detect.py:152-162]():

**MSVC Configuration** [platform/windows/detect.py:243-519]():
```python
def configure_msvc(env):
    env["CC"] = "clang-cl"  # if use_llvm
    env["CXX"] = "clang-cl"
    env.Append(CCFLAGS=["/utf-8", "/bigobj"])
    env.Append(CPPDEFINES=["WINDOWS_ENABLED"])
    # LTO via /GL and /LTCG flags
```

**MinGW Configuration** [platform/windows/detect.py:587-752]():
```python
def configure_mingw(env):
    env["CC"] = get_detected(env, "gcc")
    env["CXX"] = get_detected(env, "g++")
    # LTO via -flto flag
```

### Android Build Configuration

Android auto-installs NDK if needed [platform/android/detect.py:89-106]():

```python
def install_ndk_if_needed(env):
    if not os.path.exists(get_android_ndk_root(env)):
        sdkmanager = os.path.join(sdk_root, "cmdline-tools", 
                                   "latest", "bin", "sdkmanager")
        subprocess.check_call([sdkmanager, "ndk;" + get_ndk_version()])
```

Sets target triple for cross-compilation [platform/android/detect.py:134-146]():
```python
if env["arch"] == "arm64":
    target_triple = "aarch64-linux-android"
target_option = ["-target", target_triple + str(min_sdk_version)]
env.Append(CCFLAGS=target_option)
```

### Web (Emscripten) Build Configuration

Emscripten configuration [platform/web/detect.py:103-348]():

```python
def configure(env):
    env["CC"] = "emcc"
    env["CXX"] = "em++"
    # WASM-specific flags
    env.Append(LINKFLAGS=["-sINITIAL_MEMORY=%sMB" % env["initial_memory"]])
    env.Append(LINKFLAGS=["-sWASM_BIGINT"])
    
    # Threading via SharedArrayBuffer
    if env["threads"]:
        env.Append(CCFLAGS=["-sUSE_PTHREADS=1"])
```

**Sources:** [platform/windows/detect.py:1-800](), [platform/android/detect.py:1-245](), [platform/web/detect.py:1-348]()

---

## Custom Build Helpers

### methods.py Utilities

Key helper functions in [methods.py]():

| Function | Return Type | Purpose | Location |
|----------|-------------|---------|----------|
| `add_source_files(self, sources, files, allow_gen)` | bool | Adds files via `add_source_files_scu()` or `add_source_files_orig()` | [methods.py:80-85]() |
| `detect_modules(search_path, recursive)` | `OrderedDict` | Returns `{module_name: path}` after checking for register_types.h/SCsub/config.py | [methods.py:240-300]() |
| `is_module(path)` | bool | Checks for ["register_types.h", "SCsub", "config.py"] in directory | [methods.py:303-310]() |
| `get_compiler_version(env)` | dict | Returns `{"major": int, "minor": int, "patch": int, ...}` via subprocess | [methods.py:686-801]() |
| `using_gcc(env)` / `using_clang(env)` / `using_emcc(env)` | bool | Check compiler type via `os.path.basename(env["CC"])` | [methods.py:810-819]() |
| `get_version_info(module_version_string, silent)` | dict | Returns version dict from version.py + env vars | [methods.py:137-166]() |
| `get_git_info()` | dict | Returns `{"git_hash": str, "git_timestamp": str}` via .git parsing | [methods.py:169-223]() |
| `no_verbose(env)` | None | Sets `env["CXXCOMSTR"]`, `env["LINKCOMSTR"]`, etc. for minimal output | [methods.py:425-457]() |
| `show_progress(env)` | None | Creates `ShowProgress` class, writes `.scons_node_count` | [methods.py:822-900]() |
| `redirect_emitter(target, source, env)` | tuple | Emitter that redirects objects to `bin/obj/` if `redirect_build_objects=True` | [methods.py:88-112]() |

### Build Environment Extensions

SConstruct adds custom methods to the SCons `Environment` class [SConstruct:126-139]():

```python
env.__class__.add_module_version_string = methods.add_module_version_string
env.__class__.add_source_files = methods.add_source_files
env.__class__.add_shared_library = methods.add_shared_library
env.__class__.add_library = methods.add_library
env.__class__.add_program = methods.add_program
env.__class__.CommandNoCache = methods.CommandNoCache
env.__class__.Run = methods.Run
env.__class__.disable_warnings = methods.disable_warnings
env.__class__.module_add_dependencies = methods.module_add_dependencies
env.__class__.module_check_dependencies = methods.module_check_dependencies
```

This allows SCsub files to use concise syntax:

```python
# In any SCsub file
env.add_source_files(env.core_sources, "*.cpp")
lib = env.add_library("core", env.core_sources)
env.Prepend(LIBS=[lib])

# Module dependency management
env.module_add_dependencies("gdscript", ["regex"])
if not env.module_check_dependencies("gdscript"):
    # Module disabled due to missing dependencies
```

**Sources:** [SConstruct:126-139](), [methods.py:36-86](), [methods.py:325-362](), [methods.py:589-616]()

---

## Build Optimization Features

### Single Compilation Unit (SCU) Build

SCU builds combine multiple `.cpp` files into single compilation units for faster incremental builds [SConstruct:674-686]():

```bash
scons scu_build=yes scu_limit=8
```

Generates `.scu/scu_*.gen.cpp` files that include multiple sources [methods.py:55-75]().

### Link-Time Optimization (LTO)

Platform-specific LTO configuration [SConstruct:867-878]():

| LTO Mode | Compiler Support | Effect |
|----------|-----------------|--------|
| `none` | All | No LTO |
| `thin` | LLVM/Clang only | Fast LTO with parallel linking |
| `full` | GCC/Clang | Full program optimization |
| `auto` | Platform-dependent | Thin for LLVM, full for GCC, or none |

### Compiler Caching

Supports ccache/sccache via launcher [SConstruct:357-358]():
```bash
scons cpp_compiler_launcher=ccache c_compiler_launcher=ccache
```

### Build Object Redirection

Keeps source tree clean by redirecting object files [SConstruct:296-300]():
```bash
scons redirect_build_objects=yes  # Objects go to bin/obj/
```

Implemented via custom emitter [methods.py:88-112]().

**Sources:** [SConstruct:674-878](), [methods.py:55-112]()

---

## Build System Maintenance

### Version Management

Version information comes from [version.py]() and is injected at build time:

```python
version_info = {
    "major": 4,
    "minor": 3,
    "patch": 0,
    "status": "stable",
    "build": os.getenv("BUILD_NAME", "custom_build")
}
```

Git information is extracted dynamically [methods.py:169-223]() and embedded in `version_hash.gen.cpp`.

### Compiler Version Validation

The build enforces minimum compiler versions [SConstruct:700-768]():

- **GCC**: â‰¥ 9.0
- **Clang**: â‰¥ 6.0
- **Apple Clang**: â‰¥ 16.0 (Xcode 16)
- **MSVC**: â‰¥ 15.9 (Visual Studio 2017)
- **Emscripten**: â‰¥ 4.0.0

### Custom Module Integration

External modules can be added via [SConstruct:438-461]():

```bash
scons custom_modules=path/to/modules custom_modules_recursive=yes
```

The build system:
1. Detects modules in custom paths
2. Adds their include paths to `CPPPATH`
3. Allows custom modules to override built-in ones

**Sources:** [SConstruct:700-768](), [SConstruct:438-461](), [methods.py:137-223](), [version.py]()1a:T5083,# Build Configuration

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [SConstruct](SConstruct)
- [core/SCsub](core/SCsub)
- [editor/SCsub](editor/SCsub)
- [editor/icons/SCsub](editor/icons/SCsub)
- [main/SCsub](main/SCsub)
- [methods.py](methods.py)
- [modules/SCsub](modules/SCsub)
- [modules/gdscript/editor/script_templates/SCsub](modules/gdscript/editor/script_templates/SCsub)
- [modules/modules_builders.py](modules/modules_builders.py)
- [modules/mono/editor/script_templates/SCsub](modules/mono/editor/script_templates/SCsub)
- [platform/SCsub](platform/SCsub)
- [platform/android/detect.py](platform/android/detect.py)
- [platform/ios/detect.py](platform/ios/detect.py)
- [platform/linuxbsd/detect.py](platform/linuxbsd/detect.py)
- [platform/macos/detect.py](platform/macos/detect.py)
- [platform/web/detect.py](platform/web/detect.py)
- [platform/windows/SCsub](platform/windows/SCsub)
- [platform/windows/detect.py](platform/windows/detect.py)
- [platform_methods.py](platform_methods.py)
- [scene/theme/icons/SCsub](scene/theme/icons/SCsub)

</details>



## Purpose and Scope

This document covers the build configuration system in Godot Engine, including build options, configuration files (`custom.py`, profile files), and compiler flags. The configuration system is built on top of SCons and controls compilation targets, optimization levels, feature flags, and platform-specific settings.

For information about the overall build system architecture and SCons setup, see [Build System](#2). For platform-specific detection and toolchain configuration, see [Platform Detection](#2.2). For module system configuration, see [Module System](#2.3).

## Build Options System Overview

The build configuration system uses SCons Variables to define configurable options. Options are processed in multiple stages and can be set via command line arguments, configuration files, or environment variables.

```mermaid
flowchart TD
    CLI["Command Line Arguments<br/>(scons platform=windows target=editor)"]
    Custom["custom.py File<br/>(User Configuration)"]
    Profile["Profile File<br/>(--profile=myconfig.py)"]
    EnvVars["Environment Variables<br/>(IMPORT_ENV_VARS)"]
    
    SConstruct["SConstruct<br/>Main Build Script"]
    
    OptsCore["Core Options<br/>(target, arch, optimize, etc.)"]
    OptsPlatform["Platform Options<br/>from detect.get_opts()"]
    OptsModules["Module Options<br/>from config.get_opts()"]
    
    EnvUpdate["env.Update()<br/>Apply Options to Environment"]
    
    PlatformConfigure["Platform detect.configure()<br/>Apply Flags & Configure Toolchain"]
    
    Compile["Compilation"]
    
    CLI --> SConstruct
    Custom --> SConstruct
    Profile --> SConstruct
    EnvVars --> SConstruct
    
    SConstruct --> OptsCore
    SConstruct --> OptsPlatform
    SConstruct --> OptsModules
    
    OptsCore --> EnvUpdate
    OptsPlatform --> EnvUpdate
    OptsModules --> EnvUpdate
    
    EnvUpdate --> PlatformConfigure
    PlatformConfigure --> Compile
```

**Sources:** [SConstruct:148-492]()

## Core Build Options

The build system defines a comprehensive set of core options that control the build target, architecture, optimization, and features.

### Target Build Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `platform` | String | (auto-detected) | Target platform (windows, linuxbsd, macos, android, ios, web) |
| `target` | Enum | "editor" | Compilation target: editor, template_release, template_debug |
| `arch` | Enum | "auto" | CPU architecture (x86_32, x86_64, arm32, arm64, rv64, etc.) |
| `dev_build` | Boolean | False | Developer build with DEV_ENABLED code |
| `optimize` | Enum | "auto" | Optimization level (none, custom, debug, speed, speed_trace, size, size_extra) |
| `debug_symbols` | Boolean | False | Build with debugging symbols |
| `lto` | Enum | "none" | Link-time optimization (none, auto, thin, full) |
| `production` | Boolean | False | Production build defaults |

**Sources:** [SConstruct:161-187]()

### Feature and Component Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `deprecated` | Boolean | True | Enable compatibility code for deprecated features |
| `precision` | Enum | "single" | Floating-point precision (single, double) |
| `threads` | Boolean | True | Enable threading support |
| `vulkan` | Boolean | True | Enable Vulkan rendering driver |
| `opengl3` | Boolean | True | Enable OpenGL/GLES3 rendering driver |
| `d3d12` | Boolean | False | Enable Direct3D 12 (Windows) |
| `metal` | Boolean | False | Enable Metal (macOS/iOS) |

**Sources:** [SConstruct:189-209]()

### Advanced Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `dev_mode` | Boolean | False | Alias for verbose=yes warnings=extra werror=yes tests=yes |
| `tests` | Boolean | False | Build unit tests |
| `verbose` | Boolean | False | Enable verbose compilation output |
| `warnings` | Enum | "all" | Warning level (extra, all, moderate, no) |
| `werror` | Boolean | False | Treat compiler warnings as errors |
| `scu_build` | Boolean | False | Use single compilation unit build |
| `ninja` | Boolean | False | Use ninja backend for faster rebuilds |
| `compiledb` | Boolean | False | Generate compile_commands.json |

**Sources:** [SConstruct:227-252]()

## Configuration Methods

### Command Line Arguments

Options are set directly on the command line:

```bash
scons platform=windows target=editor arch=x86_64 optimize=speed_trace
```

Command line arguments have the highest priority and override all other configuration sources.

**Sources:** [SConstruct:158-159](), [SConstruct:362]()

### custom.py Configuration File

The `custom.py` file provides a way to set persistent build options without modifying the command line. This file is loaded automatically if it exists in the root directory.

```python
# custom.py example
platform = "windows"
target = "editor"
arch = "x86_64"
dev_build = True
warnings = "extra"
werror = True
```

The build system looks for `custom.py` in the `customs` list:

**Sources:** [SConstruct:149-157]()

### Profile Files

Profile files allow maintaining multiple named configuration sets. Use the `profile=<path>` option to specify a profile:

```bash
scons profile=myconfig.py
```

The profile file is added to the `customs` list and loaded with the same priority as `custom.py`.

**Sources:** [SConstruct:151-156]()

### Environment Variables

Specific environment variables can be imported into the build environment using the `import_env_vars` option:

```bash
scons import_env_vars=PATH,PKG_CONFIG_PATH
```

This copies the specified variables from the OS environment to the SCons environment.

**Sources:** [SConstruct:254](), [SConstruct:368-371]()

## Build Target Configuration

The build system automatically configures defines and optimization based on the selected target.

```mermaid
flowchart LR
    Target["target Option"]
    
    Editor["target=editor"]
    TemplateDebug["target=template_debug"]
    TemplateRelease["target=template_release"]
    
    EditorFlags["TOOLS_ENABLED<br/>DEBUG_ENABLED<br/>optimize=speed_trace (auto)"]
    DebugFlags["DEBUG_ENABLED<br/>optimize=speed_trace (auto)"]
    ReleaseFlags["NDEBUG<br/>optimize=speed (auto)"]
    
    DevBuild["dev_build Option"]
    DevEnabled["DEV_ENABLED<br/>debug_symbols=true<br/>optimize=none (auto)"]
    
    Target --> Editor
    Target --> TemplateDebug
    Target --> TemplateRelease
    
    Editor --> EditorFlags
    TemplateDebug --> DebugFlags
    TemplateRelease --> ReleaseFlags
    
    DevBuild --> DevEnabled
```

The build system sets several environment flags based on the target:

- **env.editor_build**: Set to `True` when `target == "editor"`
- **env.dev_build**: Set to `True` when `dev_build=True`
- **env.debug_features**: Set to `True` for editor and template_debug targets

**Sources:** [SConstruct:518-554]()

### Optimization Level Selection

When `optimize=auto`, the system selects optimization based on the build configuration:

| Configuration | Auto Optimization |
|---------------|-------------------|
| `dev_build=True` | `none` |
| `target=editor` or `template_debug` | `speed_trace` |
| `target=template_release` | `speed` |

**Sources:** [SConstruct:529-536]()

### Compiler Defines

Key preprocessor defines set based on configuration:

- **TOOLS_ENABLED**: Editor build (enables editor-only code)
- **DEBUG_ENABLED**: Debug features (assertions, verbose logging, debug-only nodes)
- **DEV_ENABLED**: Developer code (for engine developers)
- **NDEBUG**: Disables assert() in third-party code (production builds)

**Sources:** [SConstruct:541-554]()

## Platform-Specific Configuration

Each platform provides its own configuration through `detect.py` files in platform directories.

```mermaid
flowchart TD
    SConstruct["SConstruct"]
    
    PlatformDetect["platform/&lt;platform&gt;/detect.py"]
    
    GetOpts["detect.get_opts()<br/>Returns platform options"]
    GetFlags["detect.get_flags()<br/>Returns default flag values"]
    GetTools["detect.get_tools()<br/>Returns SCons tools list"]
    Configure["detect.configure(env)<br/>Configures environment"]
    
    OptsAdd["opts.AddVariables()<br/>Add platform options to Variables"]
    FlagsApply["Apply Platform Flags<br/>if not overridden by ARGUMENTS"]
    ToolsLoad["env.Tool()<br/>Load platform-specific tools"]
    
    SConstruct --> PlatformDetect
    
    PlatformDetect --> GetOpts
    PlatformDetect --> GetFlags
    PlatformDetect --> GetTools
    PlatformDetect --> Configure
    
    GetOpts --> OptsAdd
    GetFlags --> FlagsApply
    GetTools --> ToolsLoad
    Configure --> "Apply CCFLAGS, LINKFLAGS<br/>Configure Toolchain<br/>Set Platform Defines"
```

**Sources:** [SConstruct:77-109](), [SConstruct:419-432](), [SConstruct:498-690]()

### Platform Option Discovery

Platform options are loaded dynamically:

1. The build system scans `platform/*/detect.py` files
2. For the selected platform, it calls `detect.get_opts()` to retrieve platform-specific options
3. These options are added to the global options list

**Example from Windows:**

**Sources:** [platform/windows/detect.py:164-220](), [SConstruct:419-421]()

### Platform Flag Defaults

Platform-specific default values can be set via `get_flags()`:

```python
def get_flags():
    return {
        "arch": detect_build_env_arch() or detect_arch(),
        "d3d12": True,
        "supported": ["d3d12", "dcomp", "library", "mono", "xaudio2"],
    }
```

These flags are applied early, but command line arguments can override them:

**Sources:** [platform/windows/detect.py:233-240](), [SConstruct:426-429]()

### Platform Configure Stage

The `detect.configure(env)` function performs platform-specific setup:

- Sets compiler paths (CC, CXX, AR, LINK)
- Adds platform-specific CCFLAGS and LINKFLAGS
- Configures SDK paths
- Adds platform libraries
- Sets platform-specific defines

**Example configuration tasks:**
- Windows: Configures MSVC/MinGW, sets subsystem, configures D3D12
- Linux: Configures pkg-config dependencies, sets linker
- macOS: Configures SDK paths, sets deployment target
- Android: Configures NDK, sets target API level

**Sources:** [platform/windows/detect.py:243-518](), [platform/linuxbsd/detect.py:74-469](), [platform/macos/detect.py:69-276]()

## Compiler Flag Configuration

The build system provides extensive control over compiler and linker flags through both built-in options and custom flag variables.

### Custom Compiler Flags

| Variable | Description | Applied To |
|----------|-------------|------------|
| `cppdefines` | Preprocessor defines | C/C++ compiler |
| `ccflags` | Flags for both C and C++ | C/C++ compiler |
| `cxxflags` | C++-specific flags | C++ compiler |
| `cflags` | C-specific flags | C compiler |
| `linkflags` | Linker flags | Linker |
| `asflags` | Assembler flags | Assembler |
| `arflags` | Archive tool flags | Static library creation |
| `rcflags` | Resource compiler flags | Windows resource compiler |

Custom flags are appended to the environment:

**Sources:** [SConstruct:345-356](), [SConstruct:628-635]()

### Optimization Flags

The optimization level is applied through the `$OPTIMIZELEVEL` placeholder in CCFLAGS:

```mermaid
graph TB
    Optimize["optimize Option"]
    
    Speed["speed"]
    SpeedTrace["speed_trace"]
    Size["size"]
    SizeExtra["size_extra"]
    Debug["debug"]
    None["none"]
    
    MSVC_Speed["/O2 + /OPT:REF"]
    MSVC_SpeedTrace["/O2 + /OPT:REF + /OPT:NOICF"]
    MSVC_Size["/O1 + /OPT:REF"]
    MSVC_SizeExtra["/O1 + /OPT:REF + SIZE_EXTRA"]
    MSVC_Debug["/Od"]
    
    GCC_Speed["-O3"]
    GCC_SpeedTrace["-O2"]
    GCC_Size["-Os"]
    GCC_SizeExtra["-Oz"]
    GCC_Debug["-Og"]
    GCC_None["-O0"]
    
    Optimize --> Speed
    Optimize --> SpeedTrace
    Optimize --> Size
    Optimize --> SizeExtra
    Optimize --> Debug
    Optimize --> None
    
    Speed --> MSVC_Speed
    Speed --> GCC_Speed
    
    SpeedTrace --> MSVC_SpeedTrace
    SpeedTrace --> GCC_SpeedTrace
    
    Size --> MSVC_Size
    Size --> GCC_Size
    
    SizeExtra --> MSVC_SizeExtra
    SizeExtra --> GCC_SizeExtra
    
    Debug --> MSVC_Debug
    Debug --> GCC_Debug
    
    None --> GCC_None
```

**Sources:** [SConstruct:809-878]()

### Debug Symbol Configuration

Debug symbols are controlled by the `debug_symbols` option:

**MSVC:**
- Adds `/Zi` (generate debug database) and `/FS` (force synchronous writes)
- Adds `/DEBUG:FULL` to linker flags

**GCC/Clang:**
- Adds `-gdwarf-4` or `-gdwarf-5` depending on platform
- For Emscripten: adds `-g3`
- For dev builds: adds `-g3`, otherwise `-g2`
- Optional: `-ffile-prefix-map` for relative debug paths

**Sources:** [SConstruct:810-853]()

### Link-Time Optimization (LTO)

LTO can be configured with the `lto` option:

| Value | Description |
|-------|-------------|
| `none` | No LTO |
| `auto` | Platform decides (typically thin for LLVM, full for GCC) |
| `thin` | Thin LTO (LLVM only, faster) |
| `full` | Full LTO (slower but more optimization) |

**Implementation varies by compiler:**

**MSVC:**
- `full`: `/GL` for compilation, `/LTCG` for linking
- `thin`: Not supported (requires LLVM)

**GCC/Clang:**
- `full`: `-flto`
- `thin`: `-flto=thin` (Clang only)
- GCC can use parallelized LTO: `-flto=<num_jobs>`

**Sources:** [SConstruct:817-878](), [platform/windows/detect.py:491-511](), [platform/linuxbsd/detect.py:188-209]()

## Third-Party Library Configuration

Godot bundles many third-party libraries but allows using system versions through `builtin_*` options.

### Built-in Library Options

Each library has a corresponding `builtin_<name>` option (default: `True`):

```
builtin_brotli, builtin_certs, builtin_clipper2, builtin_embree,
builtin_enet, builtin_freetype, builtin_msdfgen, builtin_glslang,
builtin_graphite, builtin_harfbuzz, builtin_sdl, builtin_icu4c,
builtin_libjpeg_turbo, builtin_libogg, builtin_libpng, builtin_libtheora,
builtin_libvorbis, builtin_libwebp, builtin_wslay, builtin_mbedtls,
builtin_miniupnpc, builtin_openxr, builtin_pcre2, builtin_recastnavigation,
builtin_rvo2_2d, builtin_rvo2_3d, builtin_xatlas, builtin_zlib, builtin_zstd
```

When `builtin_<name>=no`, the build system typically uses `pkg-config` to find and configure the system library (on platforms that support it).

**Sources:** [SConstruct:310-340]()

### Example: System Library Configuration (Linux)

When using system libraries on Linux, the build system uses `pkg-config`:

```python
if not env["builtin_freetype"]:
    env.ParseConfig("pkg-config freetype2 --cflags --libs")

if not env["builtin_zlib"]:
    env.ParseConfig("pkg-config zlib --cflags --libs")
```

**Sources:** [platform/linuxbsd/detect.py:228-417]()

## Module Configuration

Modules can provide their own build options through `config.py` files.

```mermaid
flowchart TD
    DetectModules["methods.detect_modules()<br/>Scan modules/ and custom_modules"]
    
    ModuleFound["Module Found<br/>(has register_types.h, SCsub, config.py)"]
    
    ImportConfig["Import module's config.py"]
    
    IsEnabled["config.is_enabled()<br/>(optional, default True)"]
    GetOpts["config.get_opts(platform)<br/>(optional)"]
    
    AddModuleOpt["opts.Add(BoolVariable(<br/>'module_&lt;name&gt;_enabled'))"]
    AddCustomOpts["opts.AddVariables(<br/>*config.get_opts())"]
    
    DetectModules --> ModuleFound
    ModuleFound --> ImportConfig
    ImportConfig --> IsEnabled
    ImportConfig --> GetOpts
    IsEnabled --> AddModuleOpt
    GetOpts --> AddCustomOpts
```

Each module gets:
1. An automatic `module_<name>_enabled` option (default from `config.is_enabled()`)
2. Optional custom options from `config.get_opts(platform)`

**Sources:** [SConstruct:434-491]()

## Feature Build Profiles

Build profiles allow disabling engine features and classes to reduce binary size. Specified with the `build_profile` option pointing to a JSON file.

### Profile Format

```json
{
  "disabled_classes": ["Node3D", "Camera3D", "MeshInstance3D"],
  "disabled_build_options": {
    "disable_3d": true,
    "module_raycast_enabled": false
  }
}
```

The profile can:
- Disable specific engine classes (stored in `env.disabled_classes`)
- Override build options (applied to environment)

**Sources:** [SConstruct:637-653]()

## Convenience Option Aliases

### dev_mode

Setting `dev_mode=yes` enables multiple developer-friendly options:
- `verbose=yes`
- `warnings=extra`
- `werror=yes`
- `tests=yes`
- `strict_checks=yes`

### production

Setting `production=yes` optimizes for release builds:
- `use_static_cpp=yes`
- `debug_symbols=no`
- `lto=auto`
- Platform-specific optimizations (e.g., `swappy=yes` on Android)

**Sources:** [SConstruct:655-669]()

## Compiler Launchers

Compiler launchers like `ccache` can be specified:

```bash
scons c_compiler_launcher=ccache cpp_compiler_launcher=ccache
```

These are typically prepended to the compiler command.

**Sources:** [SConstruct:357-358]()

## Generated Configuration Files

The build system generates several configuration headers during the build process:

```mermaid
graph TD
    Version["version.py<br/>(version numbers)"]
    Git["Git Information<br/>(.git/)"]
    ModulesDetected["modules_detected<br/>(detected modules)"]
    DisabledClasses["disabled_classes<br/>(from build profile)"]
    
    VersionGen["version_generated.gen.h<br/>(VERSION_* defines)"]
    VersionHash["version_hash.gen.cpp<br/>(GIT_COMMIT_HASH)"]
    ModulesEnabled["modules_enabled.gen.h<br/>(MODULE_*_ENABLED defines)"]
    DisabledGen["disabled_classes.gen.h<br/>(class disable list)"]
    
    Version --> VersionGen
    Git --> VersionHash
    ModulesDetected --> ModulesEnabled
    DisabledClasses --> DisabledGen
```

**Key generated files:**

- **version_generated.gen.h**: Contains version information (major, minor, patch, status)
- **version_hash.gen.cpp**: Contains Git commit hash
- **modules_enabled.gen.h**: Contains `MODULE_<NAME>_ENABLED` defines for each enabled module
- **disabled_classes.gen.h**: Lists disabled classes from build profile

**Sources:** [core/SCsub:172-187](), [modules/SCsub:19-21](), [core/SCsub:172-174]()

## Build Cache Configuration

SCons caching can significantly speed up rebuilds:

```bash
scons cache_path=~/.scons_cache cache_limit=10
```

- `cache_path`: Directory to store cached object files
- `cache_limit`: Maximum cache size in GiB (0 = no limit)

The cache is prepared early in the build:

**Sources:** [SConstruct:292-293](), [SConstruct:364-365]()

## Special Build Modes

### SCU Build (Single Compilation Unit)

SCU build combines multiple source files into single compilation units to potentially speed up compilation:

```bash
scons scu_build=yes scu_limit=8
```

This generates `.scu/*.gen.cpp` files containing `#include` directives for multiple source files.

**Sources:** [SConstruct:288-289](), [SConstruct:674-686]()

### Ninja Backend

The ninja backend can provide faster incremental builds:

```bash
scons ninja=yes
```

This generates a `build.ninja` file. When `ninja_auto_run=yes`, SCons automatically invokes ninja after generation.

**Sources:** [SConstruct:235-237]()

### Fast Unsafe Mode

The `fast_unsafe` option enables SCons optimizations that may cause incorrect incremental builds in rare cases:

```bash
scons fast_unsafe=yes
```

This enables:
- `implicit_cache`: Cache implicit dependencies
- `max_drift`: Allow up to 60 seconds of timestamp drift

**Sources:** [SConstruct:563-570]()1b:T58db,# Platform Detection

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [SConstruct](SConstruct)
- [core/SCsub](core/SCsub)
- [editor/SCsub](editor/SCsub)
- [editor/icons/SCsub](editor/icons/SCsub)
- [main/SCsub](main/SCsub)
- [methods.py](methods.py)
- [modules/SCsub](modules/SCsub)
- [modules/gdscript/editor/script_templates/SCsub](modules/gdscript/editor/script_templates/SCsub)
- [modules/modules_builders.py](modules/modules_builders.py)
- [modules/mono/editor/script_templates/SCsub](modules/mono/editor/script_templates/SCsub)
- [platform/SCsub](platform/SCsub)
- [platform/android/detect.py](platform/android/detect.py)
- [platform/ios/detect.py](platform/ios/detect.py)
- [platform/linuxbsd/detect.py](platform/linuxbsd/detect.py)
- [platform/macos/detect.py](platform/macos/detect.py)
- [platform/web/detect.py](platform/web/detect.py)
- [platform/windows/SCsub](platform/windows/SCsub)
- [platform/windows/detect.py](platform/windows/detect.py)
- [platform_methods.py](platform_methods.py)
- [scene/theme/icons/SCsub](scene/theme/icons/SCsub)

</details>



## Purpose and Scope

Platform Detection is the build system component responsible for identifying the host and target platforms, determining build capabilities, and configuring platform-specific compilation settings. This system is executed during the SCons initialization phase before any compilation occurs.

This page covers the build-time platform detection mechanism. For information about runtime platform identification and OS abstraction, see [OS Abstraction Layer](#3.2). For build configuration options, see [Build Configuration](#2.1).

## Overview

The platform detection system operates in two main phases:

1. **Discovery Phase**: Scans the codebase for available platform modules and checks if they can be built on the current host
2. **Configuration Phase**: Applies platform-specific compiler settings, flags, and build options

**Platform Detection Discovery Flow**

```mermaid
graph TB
    Start["SCons Build Start"] --> ScanPlatforms["Scan platform/* directories<br/>(SConstruct:77-109)"]
    ScanPlatforms --> ImportDetect["Import detect.py module<br/>for each platform"]
    ImportDetect --> CheckCanBuild["Call can_build()<br/>for current host"]
    CheckCanBuild --> CanBuildYes{Can Build?}
    CanBuildYes -->|Yes| AddToPlatformList["Add to platform_list<br/>Get opts/flags"]
    CanBuildYes -->|No| Skip["Skip platform"]
    AddToPlatformList --> NextPlatform{More<br/>platforms?}
    Skip --> NextPlatform
    NextPlatform -->|Yes| ImportDetect
    NextPlatform -->|No| SelectPlatform["User selects platform<br/>(SConstruct:375-417)"]
    SelectPlatform --> Configure["Call detect.configure(env)<br/>(SConstruct:690)"]
    Configure --> CompileBuild["Compile build"]
```

Sources: [SConstruct:68-109](), [SConstruct:375-417](), [SConstruct:690]()

## Platform Directory Structure

Each platform implementation is located in `platform/<platform_name>/` and must contain a `detect.py` file. The build system scans these directories to discover available platforms:

| Platform Name | Directory | Primary Host OS |
|--------------|-----------|-----------------|
| windows | `platform/windows/` | Windows, Linux (cross-compile) |
| linuxbsd | `platform/linuxbsd/` | Linux, *BSD |
| macos | `platform/macos/` | macOS, Linux (OSXCross) |
| android | `platform/android/` | Linux, macOS, Windows |
| ios | `platform/ios/` | macOS, Linux (OSXCross) |
| web | `platform/web/` | Any (requires Emscripten) |

Sources: [SConstruct:77-109]()

## Core Detection Functions

Each `detect.py` module must implement a standard interface of functions that the build system calls:

**Required Platform Detection Interface**

```mermaid
classDiagram
    class detect_py {
        +get_name() str
        +can_build() bool
        +get_opts() list
        +get_flags() dict
        +configure(env)
    }
    
    class optional_functions {
        +get_tools(env) list
        +get_doc_classes() list
        +get_doc_path() str
    }
    
    detect_py <.. optional_functions
    
    note for detect_py "Required functions that<br/>every detect.py must implement"
    note for optional_functions "Optional functions for<br/>additional capabilities"
```

### Function Descriptions

#### `can_build() -> bool`

Determines if the platform can be built on the current host system. This function checks for required tools, SDKs, and environment variables.

**Examples:**

- **Windows** [platform/windows/detect.py:49-61](): Returns `True` on Windows hosts, or on POSIX systems with MinGW-w64 cross-compiler
- **Linux/BSD** [platform/linuxbsd/detect.py:17-26](): Checks for POSIX environment and `pkg-config` availability
- **Web** [platform/web/detect.py:29-30](): Checks if `emcc` command is available
- **Android** [platform/android/detect.py:18-19](): Verifies `ANDROID_HOME` environment variable is set

#### `get_opts() -> list`

Returns platform-specific SCons build options (command-line arguments and configuration variables).

**Example Options:**

- **Windows** [platform/windows/detect.py:164-220](): `mingw_prefix`, `use_mingw`, `use_llvm`, `msvc_version`, DirectX/ANGLE paths
- **Linux/BSD** [platform/linuxbsd/detect.py:29-54](): `linker` choice (bfd/gold/lld/mold), sanitizer options, library toggles
- **macOS** [platform/macos/detect.py:27-47](): `osxcross_sdk`, `vulkan_sdk_path`, `bundle_sign_identity`

#### `get_flags() -> dict`

Returns default flag values for the platform, including default architecture and supported features.

**Example Structure:**
```python
{
    "arch": "x86_64",           # Default architecture
    "supported": ["mono", "library"],  # Optional features
    "d3d12": True,              # Platform-specific flags
}
```

Sources: [platform/windows/detect.py:233-240](), [platform/linuxbsd/detect.py:67-71]()

#### `configure(env: SConsEnvironment)`

The main configuration function that sets up compiler flags, linker options, preprocessor defines, and library paths. Called after platform selection.

Sources: [platform/windows/detect.py:243-764](), [platform/linuxbsd/detect.py:74-472]()

## Platform Discovery Process

The build system discovers platforms by scanning the `platform/` directory:

**Platform Scanning Implementation** [SConstruct:68-109]()

```mermaid
sequenceDiagram
    participant SCons as SConstruct
    participant Glob as glob.glob
    participant DetectModule as detect.py
    participant Lists as platform_list, platform_opts, platform_flags
    
    SCons->>Glob: glob("platform/*")
    loop For each directory
        SCons->>SCons: Check for detect.py existence
        SCons->>DetectModule: sys.path.insert(0, tmppath)
        SCons->>DetectModule: import detect
        SCons->>DetectModule: can_build()
        DetectModule-->>SCons: bool
        alt can build
            SCons->>DetectModule: get_opts()
            DetectModule-->>Lists: Store options
            SCons->>DetectModule: get_flags()
            DetectModule-->>Lists: Store flags
            SCons->>Lists: Add to platform_list
        end
        SCons->>SCons: sys.path.remove(tmppath)
        SCons->>SCons: sys.modules.pop("detect")
    end
```

**Key Implementation Details:**

1. **Module Isolation** [SConstruct:82-109](): Each `detect` module is imported, used, then removed from `sys.modules` to prevent conflicts
2. **Path Manipulation** [SConstruct:82-108](): Platform directory is temporarily added to `sys.path` for import
3. **Backwards Compatibility** [SConstruct:106-107](): Converts list-based flags to dictionary format

Sources: [SConstruct:68-109]()

## Platform Selection Logic

After discovery, the build system selects which platform to build for:

**Platform Selection Flow** [SConstruct:375-417]()

```mermaid
flowchart TD
    Start["Check env['platform']"] --> HasPlatform{Platform<br/>specified?}
    HasPlatform -->|No| AutoDetect["Auto-detect from sys.platform<br/>(SConstruct:377-391)"]
    HasPlatform -->|Yes| CheckAlias["Check compatibility_platform_aliases<br/>(SConstruct:394-400)"]
    
    AutoDetect --> DetectLinux["linux*/dragonfly*/freebsd*/<br/>netbsd*/openbsd* -> linuxbsd"]
    AutoDetect --> DetectMac["darwin -> macos"]
    AutoDetect --> DetectWin["win32 -> windows"]
    
    DetectLinux --> PrintDetected["Print detected platform"]
    DetectMac --> PrintDetected
    DetectWin --> PrintDetected
    
    CheckAlias --> AliasConvenience["Handle convenience aliases:<br/>linux/bsd -> linuxbsd"]
    PrintDetected --> AliasConvenience
    
    AliasConvenience --> ValidatePlatform{In platform_list?}
    ValidatePlatform -->|No| ShowError["Print available platforms<br/>Exit with error"]
    ValidatePlatform -->|Yes| ApplyOptions["Apply platform options<br/>(SConstruct:419-432)"]
    ApplyOptions --> End["Continue build"]
```

**Platform Aliases** [platform_methods.py:12-17]():
- `osx` â†’ `macos`
- `iphone` â†’ `ios`
- `x11` â†’ `linuxbsd`
- `javascript` â†’ `web`

Sources: [SConstruct:375-417](), [platform_methods.py:12-17]()

## Architecture Detection

Architecture detection determines the CPU architecture for compilation, either automatically or via the `arch` build option.

**Architecture Detection Hierarchy**

```mermaid
graph TD
    Start["Architecture Detection"] --> CheckUserArch{User specified<br/>arch option?}
    CheckUserArch -->|Yes| ValidateArch["validate_arch()<br/>(platform_methods.py:51-57)"]
    CheckUserArch -->|No| PlatformDefault["Use platform get_flags()<br/>default arch"]
    
    PlatformDefault --> CheckDefault{Has default?}
    CheckDefault -->|Yes| ValidateArch
    CheckDefault -->|No| AutoDetect["detect_arch()<br/>(platform_methods.py:37-48)"]
    
    AutoDetect --> CheckMachine["platform.machine().lower()"]
    CheckMachine --> InArchList{In architectures<br/>list?}
    InArchList -->|Yes| ReturnArch["Return architecture"]
    InArchList -->|No| CheckAliases{In aliases<br/>dict?}
    
    CheckAliases -->|Yes| ResolveAlias["Resolve to canonical name"]
    CheckAliases -->|No| CheckX86["Check for '86' substring"]
    
    CheckX86 -->|Found| ReturnX86_32["Return x86_32"]
    CheckX86 -->|Not Found| Fallback["Fallback to x86_64<br/>(with warning)"]
    
    ResolveAlias --> ReturnArch
    ReturnX86_32 --> ValidateArch
    Fallback --> ValidateArch
    
    ValidateArch --> CheckSupported{Supported by<br/>platform?}
    CheckSupported -->|Yes| End["Use architecture"]
    CheckSupported -->|No| Error["Print error<br/>Exit build"]
```

**Supported Architectures** [platform_methods.py:20]():

| Canonical Name | Aliases | Description |
|----------------|---------|-------------|
| `x86_32` | x86, x64 | 32-bit x86 |
| `x86_64` | x64, amd64 | 64-bit x86 |
| `arm32` | armv7 | 32-bit ARM |
| `arm64` | armv8, arm64v8, aarch64 | 64-bit ARM |
| `rv64` | rv, riscv, riscv64 | RISC-V 64-bit |
| `ppc64` | ppc64le | PowerPC 64-bit |
| `wasm32` | (none) | WebAssembly |
| `loongarch64` | loong64 | LoongArch 64-bit |

**Platform-Specific Architecture Detection:**

- **Windows** [platform/windows/detect.py:84-149](): Detects MSVC/MSYS2 environment architecture from environment variables
- **Linux/BSD**: Uses generic `detect_arch()` from `platform_methods.py`
- **macOS** [platform/macos/detect.py:62](): Defaults to host architecture
- **Android** [platform/android/detect.py:79](): Defaults to `arm64`
- **Web** [platform/web/detect.py:78](): Fixed to `wasm32`

Sources: [platform_methods.py:37-58](), [platform/windows/detect.py:84-149]()

## Compiler Detection

After platform and architecture selection, the build system detects and configures the appropriate compiler toolchain.

**Compiler Detection by Platform**

```mermaid
graph TB
    subgraph Windows
        WinCheck["check env.msvc<br/>(set by get_tools)"] --> WinMSVC{MSVC?}
        WinMSVC -->|Yes| MSVCConfig["Configure MSVC<br/>configure_msvc()<br/>(detect.py:243-519)"]
        WinMSVC -->|No| MinGWConfig["Configure MinGW<br/>configure_mingw()<br/>(detect.py:587-764)"]
    end
    
    subgraph LinuxBSD
        LinuxCheck["Check CXX env var"] --> LinuxClang{"'clang' in<br/>basename?"}
        LinuxClang -->|Yes| SetLLVM["env['use_llvm'] = True"]
        LinuxClang -->|No| UseGCC["Use GCC toolchain"]
        SetLLVM --> LinuxConfig["Configure flags<br/>(detect.py:103-211)"]
        UseGCC --> LinuxConfig
    end
    
    subgraph macOS
        MacCheck["Check osxcross"] --> MacOSX{OSXCross?}
        MacOSX -->|Yes| CrossCompile["OSXCross toolchain<br/>(detect.py:127-138)"]
        MacOSX -->|No| NativeClang["Native clang<br/>(detect.py:110-125)"]
    end
    
    subgraph Web
        WebSet["Fixed toolchain:<br/>emcc/em++/emar"] --> WebConfig["Configure Emscripten<br/>(detect.py:104-108)"]
    end
```

### Compiler Version Detection

The build system validates minimum compiler versions to ensure C++17 support:

**Version Checking** [methods.py:686-802](), [SConstruct:700-768]()

| Compiler | Minimum Version | Validation |
|----------|----------------|------------|
| GCC | 9.0 | [SConstruct:712-719]() |
| Clang | 6.0 | [SConstruct:738-743]() |
| Apple Clang | 16.0 | [SConstruct:732-736]() |
| MSVC | 15.9 (VS 2017) | [SConstruct:757-768]() |
| Emscripten | 4.0.0 | [platform/web/detect.py:115-117]() |

**Compiler Detection Implementation** [methods.py:686-802]():

```mermaid
sequenceDiagram
    participant Build as Build System
    participant GCV as get_compiler_version()
    participant Subprocess as subprocess
    participant Regex as re.search()
    
    Build->>GCV: Call with env
    GCV->>GCV: Check cache
    alt Cache hit
        GCV-->>Build: Return cached version
    else Cache miss
        alt MSVC
            GCV->>Subprocess: Run vswhere
            Subprocess-->>GCV: XML output
            GCV->>Regex: Parse version
        else GCC/Clang
            GCV->>Subprocess: Run CXX --version
            Subprocess-->>GCV: Version string
            GCV->>Regex: Parse with semver regex
        end
        GCV->>GCV: Update cache
        GCV-->>Build: Return version dict
    end
```

Sources: [methods.py:686-802](), [SConstruct:700-768]()

## Platform Configuration Process

The `configure(env)` function is the main entry point for platform-specific configuration. It's called after all build options are processed:

**Configuration Call Flow** [SConstruct:690]()

```mermaid
sequenceDiagram
    participant Main as SConstruct
    participant DetectModule as platform/*/detect.py
    participant Env as SCons Environment
    participant Tools as Tool Setup
    
    Main->>Main: Parse all options<br/>(opts.Update)
    Main->>DetectModule: get_tools(env)
    DetectModule-->>Tools: Return tool list
    Tools->>Env: env.Tool(tool)
    Main->>DetectModule: detect.configure(env)
    activate DetectModule
    DetectModule->>DetectModule: Validate architecture
    DetectModule->>DetectModule: Set compiler flags
    DetectModule->>DetectModule: Configure LTO
    DetectModule->>DetectModule: Set preprocessor defines
    DetectModule->>DetectModule: Configure libraries
    DetectModule->>DetectModule: Check dependencies
    DetectModule-->>Env: Modified environment
    deactivate DetectModule
```

### Common Configuration Tasks

All platform `configure()` functions perform similar tasks in roughly this order:

1. **Architecture Validation** - Call `validate_arch()` with supported architectures
2. **Compiler Configuration** - Set `CC`, `CXX`, `AR`, `RANLIB`, and other tool variables
3. **Architecture Flags** - Add `-m32`/`-m64`, `-march`, target triples, etc.
4. **LTO Configuration** - Configure Link-Time Optimization if requested
5. **Optimization Flags** - Set based on `optimize` option (typically handled in main SConstruct)
6. **Preprocessor Defines** - Add platform-specific `CPPDEFINES` (e.g., `WINDOWS_ENABLED`)
7. **Library Paths** - Configure system and third-party library locations
8. **Sanitizers** - Enable ASAN/UBSAN/TSAN if requested
9. **Platform Features** - Check for and configure optional features (Vulkan, D3D12, etc.)

Sources: [platform/windows/detect.py:243-764](), [platform/linuxbsd/detect.py:74-472](), [platform/macos/detect.py:69-277]()

## Platform-Specific Detection Examples

### Windows Platform Detection

**Windows Toolchain Selection** [platform/windows/detect.py:152-162]():

```mermaid
flowchart TD
    Start["get_tools(env)"] --> CheckOS{os.name == 'nt'?}
    CheckOS -->|No| CrossCompile["Return ['mingw']<br/>Cross-compile from Linux"]
    CheckOS -->|Yes| CheckEnv{"env.get('use_mingw')<br/>or !msvc_exists()?"}
    CheckEnv -->|Yes| UseMingW["Return ['mingw']"]
    CheckEnv -->|No| UseMSVC["Set TARGET_ARCH<br/>Return ['msvc', 'mslink', 'mslib']"]
```

**MSVC Environment Detection** [platform/windows/detect.py:84-149]():

The Windows platform has special logic to detect which MSVC toolchain is being used based on environment variables set by Visual Studio's `vcvarsall.bat`:

- Checks `VCINSTALLDIR`, `VCTOOLSINSTALLDIR` for VS installation
- Checks `Platform`, `VSCMD_ARG_TGT_ARCH` for target architecture
- Parses `PATH` variable to find compiler binaries

**MinGW Detection** [platform/windows/detect.py:587-636]():

For MinGW cross-compilation, the system:
- Checks `MSYSTEM` environment variable for MSYS2 environments
- Validates architecture matches the MSYS2 environment
- Attempts to find `gcc` or `clang` with `try_cmd()`
- Sets up response file handling for long command lines

Sources: [platform/windows/detect.py:49-162](), [platform/windows/detect.py:587-636]()

### Linux/BSD Platform Detection

**Linux/BSD Build Configuration** [platform/linuxbsd/detect.py:17-26]():

```mermaid
flowchart LR
    Check["can_build()"] --> CheckOS{os.name == 'posix'<br/>and not Darwin?}
    CheckOS -->|No| ReturnFalse["return False"]
    CheckOS -->|Yes| CheckPkg["os.system('pkg-config --version')"]
    CheckPkg --> PkgResult{Exit code == 0?}
    PkgResult -->|No| ErrorMsg["print_error<br/>return False"]
    PkgResult -->|Yes| ReturnTrue["return True"]
```

**Linker Selection** [platform/linuxbsd/detect.py:113-139]():

Linux/BSD platforms support multiple linkers with special handling for mold with older GCC:
- `default`: Use compiler default
- `bfd`: GNU ld (classic)
- `gold`: GNU gold linker
- `lld`: LLVM lld linker
- `mold`: mold linker (requires special handling for GCC < 12.1)

Sources: [platform/linuxbsd/detect.py:17-26](), [platform/linuxbsd/detect.py:113-139]()

### Android Platform Detection

**Android NDK Setup** [platform/android/detect.py:87-106]():

```mermaid
sequenceDiagram
    participant Build as Build System
    participant Install as install_ndk_if_needed()
    participant SDK as Android SDK
    participant SDKMgr as sdkmanager
    
    Build->>Install: Call with env
    Install->>Install: Check ANDROID_NDK_ROOT exists
    alt NDK exists
        Install->>Build: Set env["ANDROID_NDK_ROOT"]
    else NDK missing
        Install->>SDK: Find sdkmanager in ANDROID_HOME
        alt sdkmanager found
            Install->>SDKMgr: Install NDK version 28.1.13356709
            SDKMgr-->>Install: NDK installed
            Install->>Build: Set env["ANDROID_NDK_ROOT"]
        else sdkmanager not found
            Install->>Build: Print error, exit(255)
        end
    end
```

**Android Toolchain Setup** [platform/android/detect.py:168-185]():

The Android platform uses the NDK's prebuilt LLVM toolchain:
- Detects host platform (linux-x86_64, darwin-x86_64, windows-x86_64)
- Constructs toolchain path: `<NDK>/toolchains/llvm/prebuilt/<host>/bin/`
- Sets tools: `clang`, `clang++`, `llvm-ar`, `llvm-ranlib`
- Adds target triple with API level (e.g., `aarch64-linux-android24`)

Sources: [platform/android/detect.py:87-106](), [platform/android/detect.py:168-185]()

### Web Platform Detection

**Emscripten Detection** [platform/web/detect.py:29-30](), [platform/web/detect.py:103-117]():

```mermaid
flowchart TD
    CanBuild["can_build()"] --> CheckEmcc["WhereIs('emcc')"]
    CheckEmcc --> EmccFound{emcc found?}
    EmccFound -->|No| ReturnFalse["return False"]
    EmccFound -->|Yes| ReturnTrue["return True"]
    
    Configure["configure(env)"] --> SetTools["Set CC='emcc'<br/>Set CXX='em++'<br/>Set AR='emar'"]
    SetTools --> CheckVersion["get_compiler_version(env)"]
    CheckVersion --> ValidateVersion{Version >= 4.0.0?}
    ValidateVersion -->|No| ErrorExit["print_error<br/>sys.exit(255)"]
    ValidateVersion -->|Yes| ConfigureFlags["Configure Emscripten flags"]
```

The Web platform is unique in that it:
- Has a single fixed architecture: `wasm32`
- Requires Emscripten SDK (emcc/em++)
- Enforces minimum version 4.0.0
- Overrides default optimization to `size` [platform/web/detect.py:91]()
- Disables JIT-enabled features like PCRE2-with-JIT

Sources: [platform/web/detect.py:29-30](), [platform/web/detect.py:103-117]()

## Integration with Module System

Platform detection results are made available to the module system through environment variables:

**Platform Information Flow to Modules**

```mermaid
graph LR
    PlatformDetect["Platform Detection<br/>(SConstruct:68-109)"] --> EnvVars["Environment Variables"]
    EnvVars --> platform_list["env.platform_exporters<br/>env.platform_apis"]
    platform_list --> ModuleConfig["Module Configuration<br/>(modules/SCsub)"]
    EnvVars --> PlatformSpecific["env['platform']<br/>env['arch']"]
    PlatformSpecific --> ModuleConfigure["Module can_build()<br/>configure()"]
```

Each module's `config.py` can access:
- `env['platform']`: Current target platform
- `env['arch']`: Target architecture  
- `env.module_dependencies`: For declaring platform-specific dependencies

Sources: [SConstruct:515-516](), [modules/SCsub:33-42]()

## Summary of Key Files

| File | Purpose |
|------|---------|
| [SConstruct:68-109]() | Platform discovery loop, imports detect.py modules |
| [SConstruct:375-417]() | Platform selection and validation logic |
| [SConstruct:690]() | Calls platform configure() function |
| [platform_methods.py:37-58]() | Architecture detection and validation utilities |
| [methods.py:686-802]() | Compiler version detection |
| [platform/*/detect.py]() | Platform-specific detection implementation |
| [platform/windows/detect.py:84-149]() | Windows-specific MSVC/MinGW environment detection |
| [platform/linuxbsd/detect.py:17-26]() | Linux/BSD capability checking |
| [platform/android/detect.py:87-106]() | Android NDK auto-installation |
| [platform/web/detect.py:29-30]() | Emscripten availability check |

Sources: [SConstruct:68-690](), [platform_methods.py:37-58](), [methods.py:686-802](), [platform/windows/detect.py:1-764](), [platform/linuxbsd/detect.py:1-472](), [platform/android/detect.py:1-245](), [platform/web/detect.py:1-348]()1c:T3b37,# Module System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [SConstruct](SConstruct)
- [core/SCsub](core/SCsub)
- [editor/SCsub](editor/SCsub)
- [editor/icons/SCsub](editor/icons/SCsub)
- [main/SCsub](main/SCsub)
- [methods.py](methods.py)
- [modules/SCsub](modules/SCsub)
- [modules/gdscript/editor/script_templates/SCsub](modules/gdscript/editor/script_templates/SCsub)
- [modules/modules_builders.py](modules/modules_builders.py)
- [modules/mono/editor/script_templates/SCsub](modules/mono/editor/script_templates/SCsub)
- [platform/SCsub](platform/SCsub)
- [platform/android/detect.py](platform/android/detect.py)
- [platform/ios/detect.py](platform/ios/detect.py)
- [platform/linuxbsd/detect.py](platform/linuxbsd/detect.py)
- [platform/macos/detect.py](platform/macos/detect.py)
- [platform/web/detect.py](platform/web/detect.py)
- [platform/windows/SCsub](platform/windows/SCsub)
- [platform/windows/detect.py](platform/windows/detect.py)
- [platform_methods.py](platform_methods.py)
- [scene/theme/icons/SCsub](scene/theme/icons/SCsub)

</details>



**Purpose and Scope**: This document describes the Godot Engine's module system, which provides a standardized mechanism for extending engine functionality through self-contained, optional code units. Modules can be built-in (shipped with the engine) or custom (provided externally). The module system handles discovery, configuration, dependency management, compilation, and initialization of these modules during the build process.

For information about the overall build system architecture, see [Build System](#2). For details about the initialization sequence where modules are activated at runtime, see [Engine Initialization](#3.1).

---

## Module Structure and Requirements

A valid module must exist as a directory containing three mandatory files:

| Required File | Purpose |
|--------------|---------|
| `register_types.h` | Declares initialization/uninitialization functions |
| `SCsub` | SCons build script defining source files and compilation |
| `config.py` | Python script providing module configuration |

The `register_types.h` file must declare two functions:
```cpp
void initialize_<module_name>_module(ModuleInitializationLevel p_level);
void uninitialize_<module_name>_module(ModuleInitializationLevel p_level);
```

These functions are called during engine startup and shutdown to register the module's classes, resources, and other types.

**Module Detection Logic**:
```mermaid
flowchart TD
    A["detect_modules(search_path)"] --> B{"Is path itself a module?"}
    B -->|Yes| C["Add module to collection"]
    B -->|No| D["Scan subdirectories"]
    D --> E{"For each subdirectory"}
    E --> F{"Has register_types.h?"}
    F -->|No| E
    F -->|Yes| G{"Has SCsub?"}
    G -->|No| E
    G -->|Yes| H{"Has config.py?"}
    H -->|No| E
    H -->|Yes| I["Valid module - add to collection"]
    I --> E
    C --> J["Return OrderedDict of modules"]
    E -->|Done| J
```

Sources: [methods.py:240-310](), [SConstruct:434-461]()

---

## Module Discovery and Search Paths

The build system discovers modules in two phases during the SConstruct execution:

**Discovery Flow**:
```mermaid
flowchart LR
    Start["SConstruct Execution"] --> BuiltIn["Scan 'modules/' directory"]
    BuiltIn --> Custom{"custom_modules option?"}
    Custom -->|Yes| ParsePaths["Parse comma-separated paths"]
    ParsePaths --> ValidatePaths["convert_custom_modules_path()"]
    ValidatePaths --> ScanCustom["Scan each custom path"]
    ScanCustom --> Merge["Merge into modules_detected"]
    Custom -->|No| Merge
    BuiltIn --> Merge
    Merge --> AddOptions["Add module options to env"]
```

**Search Path Configuration**:
- **Built-in modules**: Always searched in `modules/` directory (non-recursive)
- **Custom modules**: Specified via `custom_modules` build option as comma-separated paths
  - Can be absolute or relative paths
  - Supports recursive scanning when `custom_modules_recursive=True`
  - Custom modules can override built-in modules with the same name

The environment receives additional include paths for custom module directories to allow cross-module includes independent of filesystem location.

Sources: [SConstruct:434-461](), [methods.py:240-300](), [methods.py:313-322]()

---

## Module Configuration (config.py)

Each module's `config.py` provides configuration metadata and build options through several optional functions:

**Configuration Interface**:

```mermaid
classDiagram
    class config_py {
        +is_enabled() bool
        +can_build(env, platform) bool
        +get_opts(platform) list
        +get_flags() dict
        +configure(env) void
        +get_doc_classes() list
        +get_doc_path() str
        +get_icons_path() str
    }
    note for config_py "All functions are optional\nDefaults are applied if absent"
```

| Function | Default | Purpose |
|----------|---------|---------|
| `is_enabled()` | `True` | Whether module is enabled by default |
| `can_build(env, platform)` | `True` | Platform/environment compatibility check |
| `get_opts(platform)` | `[]` | SCons build options specific to this module |
| `get_flags()` | `{}` | Default flag values for the module |
| `configure(env)` | No-op | Modify build environment for this module |
| `get_doc_classes()` | `[]` | List of class names to document |
| `get_doc_path()` | `"doc_classes"` | Path to XML documentation |
| `get_icons_path()` | `""` | Path to editor icons |

The build system imports each module's `config.py` and calls these functions to determine if the module should be built and how to configure it. The `module_<name>_enabled` option can be set on the command line to override `is_enabled()`.

Sources: [SConstruct:464-486](), [methods.py:303-310]()

---

## Module Dependencies

Modules can declare dependencies on other modules, which affects build order and disabling cascades:

**Dependency Declaration**:
```mermaid
flowchart TD
    A["Module config.py"] --> B["can_build() or is_enabled()"]
    B --> C["Call env.module_add_dependencies()"]
    C --> D{"Dependency type?"}
    D -->|Required| E["Add to required list"]
    D -->|Optional| F["Add to optional list"]
    E --> G["env.module_dependencies[module]"]
    F --> G
    G --> H["module_check_dependencies()"]
    H --> I{"All required deps enabled?"}
    I -->|No| J["Disable module + warning"]
    I -->|Yes| K["Module can build"]
    J --> L["Add to env.disabled_modules"]
    K --> M["Add to env.module_list"]
```

**Dependency Management Functions**:

- **`module_add_dependencies(module, dependencies, optional=False)`**: Records dependencies during `can_build()` phase
- **`module_check_dependencies(module)`**: Validates all required dependencies are enabled
- **`sort_module_list(env)`**: Topologically sorts modules so dependencies are initialized before dependents

The dependency system prevents circular dependencies and ensures modules initialize in the correct order. If a required dependency is disabled, the dependent module is automatically disabled with a warning message.

Sources: [methods.py:325-380](), [SConstruct:434-491]()

---

## Module Registration and Code Generation

The build system generates two critical files that wire modules into the engine:

### modules_enabled.gen.h

Contains preprocessor defines for enabled modules:
```cpp
#define MODULE_MODULENAME_ENABLED
```

This file is included by generated registration code and allows conditional compilation of module-specific code throughout the engine.

### register_module_types.gen.cpp

Contains initialization dispatcher:
```cpp
#include "modules/modulename/register_types.h"

void initialize_modules(ModuleInitializationLevel p_level) {
    #ifdef MODULE_MODULENAME_ENABLED
        initialize_modulename_module(p_level);
    #endif
}

void uninitialize_modules(ModuleInitializationLevel p_level) {
    #ifdef MODULE_MODULENAME_ENABLED
        uninitialize_modulename_module(p_level);
    #endif
}
```

**Code Generation Flow**:
```mermaid
sequenceDiagram
    participant SC as SConstruct
    participant MB as modules_builders.py
    participant MG as modules_enabled.gen.h
    participant RG as register_module_types.gen.cpp
    
    SC->>MB: modules_enabled_builder(env.module_list)
    MB->>MG: Write #define MODULE_X_ENABLED
    SC->>MB: register_module_types_builder(env.modules_detected)
    MB->>RG: Write includes and initialization functions
    Note over RG: Functions call each module's<br/>initialize/uninitialize functions
```

Sources: [modules/SCsub:19-28](), [modules/modules_builders.py:1-61]()

---

## Module Build Process

Each module is compiled into a separate static library (`libmodule_<name>.a`) and linked into the final engine binary:

**Build Integration**:
```mermaid
flowchart TB
    subgraph "Per Module"
        A["modules/<name>/SCsub"] --> B["env_modules.add_source_files()"]
        B --> C["env_modules.add_library('module_<name>')"]
    end
    
    subgraph "Final Integration"
        D["modules/SCsub"] --> E["Generate modules_enabled.gen.h"]
        D --> F["Generate register_module_types.gen.cpp"]
        F --> G["Compile registration code"]
        G --> H["env_modules.add_library('modules')"]
    end
    
    C --> I["libmodule_<name>.a"]
    H --> J["libmodules.a"]
    I --> K["env.Prepend(LIBS)"]
    J --> K
    K --> L["Link final binary"]
```

**Build Environment Modifications**:

The `env_modules` environment is a clone of the main environment with `GODOT_MODULE` defined, allowing module code to detect it's being built as a module:

```python
env_modules = env.Clone()
env_modules.Append(CPPDEFINES=["GODOT_MODULE"])
```

Each module's `SCsub` script:
1. Populates `env.modules_sources` with its source files
2. Calls `env_modules.add_library()` to create its library
3. The library is prepended to `LIBS` for linking

The registration library (`libmodules.a`) must be last in the link order to ensure all module symbols are available when `initialize_modules()` is called.

Sources: [modules/SCsub:1-65](), [SConstruct:434-491]()

---

## Module Options and Build Toggles

Modules integrate with SCons' option system to provide configurable build parameters:

**Option Integration**:
```mermaid
flowchart LR
    A["SConstruct reads ARGUMENTS"] --> B["For each module in modules_detected"]
    B --> C["Import module's config.py"]
    C --> D["Call get_opts(platform)"]
    D --> E["opts.AddVariables(*module_opts)"]
    E --> F["Add module_<name>_enabled BoolVariable"]
    F --> G["opts.Update(env)"]
    G --> H["Module options available in env"]
    H --> I["Platform detect.py configure()"]
    I --> J["Module config.py configure()"]
```

**Standard Module Option**:
Every module automatically receives a `module_<name>_enabled` boolean option that defaults to the value returned by `is_enabled()` (or `True` if not specified). The `modules_enabled_by_default` global option can set all modules to disabled by default.

**Custom Module Options**:
Modules can provide additional options through `get_opts(platform)`, which returns a list of SCons Variables. These options are namespaced per-module and available during the module's `configure()` call.

Sources: [SConstruct:464-486](), [methods.py:303-310]()

---

## Module Path Resolution and Include Handling

The build system ensures modules can include files from both built-in and custom locations:

**Include Path Setup**:
```mermaid
graph TB
    A["Custom module path detected"] --> B["env.Prepend(CPPPATH=[path])"]
    A --> C["env.Prepend(CPPPATH=[os.path.dirname(path)])"]
    B --> D["Module can: #include 'modulename/file.h'"]
    C --> E["Parent dir allows: #include 'custom_dir/modulename/file.h'"]
    
    F["Built-in modules"] --> G["Already in 'modules/' directory"]
    G --> H["Standard include: #include 'modules/modulename/file.h'"]
```

Custom modules receive two include paths:
1. The direct path to the module directory
2. The parent directory containing the module

This allows custom modules to be included using the same syntax regardless of their filesystem location, maintaining compatibility with built-in modules.

Sources: [SConstruct:454-459]()

---

## Module Initialization Levels

Modules initialize and uninitialize in phases defined by `ModuleInitializationLevel`:

| Level | Purpose | Typical Actions |
|-------|---------|----------------|
| `MODULE_INITIALIZATION_LEVEL_CORE` | Core types and singletons | Register fundamental classes |
| `MODULE_INITIALIZATION_LEVEL_SERVERS` | Server subsystems | Initialize rendering/physics servers |
| `MODULE_INITIALIZATION_LEVEL_SCENE` | Scene system | Register Node-derived classes |
| `MODULE_INITIALIZATION_LEVEL_EDITOR` | Editor-specific | Register EditorPlugin classes |

Each module's initialization functions are called once per level in order, then uninitialize is called in reverse order during shutdown. This ensures proper dependency ordering for engine subsystems.

Sources: [modules/modules_builders.py:15-53]()

---

## Module Testing Integration

When the `tests=yes` build option is enabled, the module system collects test headers:

**Test Collection**:
```mermaid
flowchart LR
    A["modules/SCsub"] --> B{"tests enabled?"}
    B -->|Yes| C["For each module in module_list"]
    C --> D["glob(module_path/tests/*.h)"]
    D --> E["Append to test_headers list"]
    E --> F["modules_tests_builder()"]
    F --> G["Generate modules_tests.gen.h"]
    G --> H["Include each test header"]
    H --> I["tests/test_main.cpp includes generated header"]
```

The generated `modules_tests.gen.h` file includes all test headers from all enabled modules, allowing the test runner to discover and execute module-specific tests. Module tests follow the doctest framework conventions.

Sources: [modules/SCsub:44-56](), [modules/modules_builders.py:56-61]()

---

## Example: Typical Module Structure

A complete module directory structure:

```
modules/mymodule/
â”œâ”€â”€ config.py                    # Module configuration
â”œâ”€â”€ register_types.h             # Registration declarations
â”œâ”€â”€ register_types.cpp           # Registration implementation
â”œâ”€â”€ SCsub                        # Build script
â”œâ”€â”€ doc_classes/                 # XML documentation
â”‚   â””â”€â”€ MyClass.xml
â”œâ”€â”€ editor/                      # Editor-specific code
â”‚   â”œâ”€â”€ my_editor_plugin.h
â”‚   â””â”€â”€ my_editor_plugin.cpp
â”œâ”€â”€ tests/                       # Unit tests
â”‚   â””â”€â”€ test_mymodule.h
â””â”€â”€ my_class.h                   # Module classes
    my_class.cpp
```

**Minimal config.py**:
```python
def can_build(env, platform):
    return True  # Or check platform-specific requirements

def configure(env):
    pass  # Or modify env as needed
```

**Minimal SCsub**:
```python
#!/usr/bin/env python
Import("env")
Import("env_modules")

env_modules.add_source_files(env.modules_sources, "*.cpp")
```

This structure allows the module to be discovered, configured, built, and integrated into the engine automatically.

Sources: [methods.py:240-310](), [SConstruct:434-491](), [modules/SCsub:1-65]()1d:T67c3,# Engine Core

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [core/core_bind.cpp](core/core_bind.cpp)
- [core/core_bind.h](core/core_bind.h)
- [core/io/stream_peer.cpp](core/io/stream_peer.cpp)
- [core/io/stream_peer.h](core/io/stream_peer.h)
- [core/os/os.cpp](core/os/os.cpp)
- [core/os/os.h](core/os/os.h)
- [doc/classes/ClassDB.xml](doc/classes/ClassDB.xml)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/Marshalls.xml](doc/classes/Marshalls.xml)
- [doc/classes/OS.xml](doc/classes/OS.xml)
- [doc/classes/PacketPeer.xml](doc/classes/PacketPeer.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [doc/classes/StreamPeer.xml](doc/classes/StreamPeer.xml)
- [drivers/unix/os_unix.cpp](drivers/unix/os_unix.cpp)
- [drivers/unix/os_unix.h](drivers/unix/os_unix.h)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [platform/windows/os_windows.cpp](platform/windows/os_windows.cpp)
- [platform/windows/os_windows.h](platform/windows/os_windows.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

The Engine Core encompasses the foundational infrastructure that initializes and manages the Godot Engine. This includes the startup lifecycle, platform abstraction layer, and configuration management systems. The core ensures cross-platform compatibility while providing unified interfaces for accessing operating system services and managing both project-level and editor-level settings.

For information about the build system that compiles the engine, see [Build System](#2). For scene management and node lifecycle, see [Scene System](#4). For resource loading and management, see [Resource System](#5).

## Engine Initialization Lifecycle

The engine initialization follows a three-phase startup sequence managed by the `Main` class: `setup()`, `setup2()`, and `start()`. This phased approach ensures proper dependency ordering during startup.

```mermaid
graph TB
    Entry["Program Entry Point<br/>(platform-specific main)"]
    Setup["Main::setup()<br/>Parse CLI, Initialize Core"]
    Setup2["Main::setup2()<br/>Initialize Servers"]
    Start["Main::start()<br/>Run MainLoop"]
    Iteration["Main::iteration()<br/>Frame Processing"]
    Cleanup["Main::cleanup()"]
    
    Entry --> Setup
    Setup --> |"Returns error on failure"| Setup2
    Setup2 --> |"_start_success flag"| Start
    Start --> Iteration
    Iteration --> |"Quit requested"| Cleanup
    
    subgraph "Phase 1: Core"
        ParseCLI["Parse command line arguments"]
        InitOS["Initialize OS singleton"]
        InitEngine["Initialize Engine singleton"]
        InitGlobals["Initialize ProjectSettings, Input, etc"]
    end
    
    subgraph "Phase 2: Servers"
        InitDisplay["Initialize DisplayServer"]
        InitRendering["Initialize RenderingServer"]
        InitPhysics["Initialize PhysicsServer2D/3D"]
        InitAudio["Initialize AudioServer"]
    end
    
    subgraph "Phase 3: Application"
        LoadProject["Load project.godot"]
        InitEditor["Initialize EditorNode (if --editor)"]
        CreateMainLoop["Create MainLoop/SceneTree"]
    end
    
    Setup -.-> ParseCLI
    ParseCLI --> InitOS
    InitOS --> InitEngine
    InitEngine --> InitGlobals
    
    Setup2 -.-> InitDisplay
    InitDisplay --> InitRendering
    InitRendering --> InitPhysics
    InitPhysics --> InitAudio
    
    Start -.-> LoadProject
    LoadProject --> InitEditor
    InitEditor --> CreateMainLoop
```

**Sources:** [main/main.cpp:449-1695](), [main/main.cpp:1697-2244](), [main/main.cpp:2246-2415]()

### Phase 1: Main::setup()

The `setup()` phase initializes core singletons and parses configuration:

| Responsibility | Key Classes | Location |
|---------------|-------------|----------|
| Command line parsing | `Main`, `OS` | [main/main.cpp:918-1556]() |
| Core type registration | `register_core_types()` | [main/main.cpp:1559-1560]() |
| OS initialization | `OS::initialize()` | Platform-specific (e.g., [platform/windows/os_windows.cpp:260-336]()) |
| Global singletons | `Engine`, `ProjectSettings`, `Input`, `TranslationServer` | [main/main.cpp:156-167]() |
| Module registration | `register_module_types()` | [main/main.cpp:1573]() |

The setup phase creates essential singletons:

```mermaid
graph LR
    setup["Main::setup()"]
    
    subgraph "Singleton Creation"
        engine["Engine singleton"]
        globals["ProjectSettings singleton"]
        input["Input singleton"]
        inputmap["InputMap singleton"]
        trans["TranslationServer singleton"]
        perf["Performance singleton"]
        packed["PackedData singleton"]
        msgq["MessageQueue singleton"]
    end
    
    setup --> engine
    setup --> globals
    setup --> input
    setup --> inputmap
    setup --> trans
    setup --> perf
    setup --> packed
    setup --> msgq
    
    globals --> |"Loads"| projectgodot["project.godot"]
```

**Sources:** [main/main.cpp:449-1695](), [main/main.cpp:156-167]()

### Phase 2: Main::setup2()

The `setup2()` phase initializes rendering, audio, and physics servers:

```mermaid
graph TB
    setup2["Main::setup2()"]
    
    subgraph "Server Initialization Order"
        display["DisplayServer::create()"]
        rendering["RenderingServer::create()"]
        audio["AudioServer::get_singleton()->init()"]
        camera["CameraServer creation"]
        physics2d["PhysicsServer2D::new_server()"]
        physics3d["PhysicsServer3D::new_server()"]
        nav2d["NavigationServer2D creation"]
        nav3d["NavigationServer3D creation"]
        xr["XRServer creation"]
    end
    
    setup2 --> display
    display --> rendering
    rendering --> audio
    audio --> camera
    camera --> physics2d
    physics2d --> physics3d
    physics3d --> nav2d
    nav2d --> nav3d
    nav3d --> xr
    
    rendering --> |"Initializes"| drivers["Rendering Drivers<br/>(Vulkan, D3D12, OpenGL)"]
```

**Sources:** [main/main.cpp:1697-2244](), [main/main.cpp:174-192](), [main/main.cpp:352-404]()

The `_start_success` flag is set to `true` at the end of `setup2()` to indicate successful initialization. If this flag is not set, the engine will not proceed to the `start()` phase.

**Sources:** [main/main.cpp:192](), [main/main.cpp:2242]()

### Phase 3: Main::start()

The `start()` phase loads the project and initializes the main loop:

```mermaid
graph TB
    start["Main::start()"]
    
    check["Check _start_success flag"]
    loadsettings["Apply ProjectSettings"]
    createloop["Create MainLoop"]
    editorcheck{"Editor mode?"}
    createeditor["Create EditorNode"]
    createscene["Create SceneTree"]
    initloop["MainLoop::initialize()"]
    
    start --> check
    check --> |"false â†’ return ERR_CANT_CREATE"| fail["Early exit"]
    check --> |"true"| loadsettings
    loadsettings --> createloop
    createloop --> editorcheck
    editorcheck --> |"Yes"| createeditor
    editorcheck --> |"No"| createscene
    createeditor --> initloop
    createscene --> initloop
```

**Sources:** [main/main.cpp:2246-2415](), [main/main.cpp:209-210]()

### Frame Iteration Loop

After startup, `Main::iteration()` is called each frame:

```mermaid
graph LR
    iteration["Main::iteration()"]
    
    subgraph "Frame Processing"
        timesync["MainTimerSync::sync()"]
        physics["Process Physics<br/>(fixed timestep)"]
        process["Process Frame<br/>(variable timestep)"]
        render["Flush Rendering"]
        audio["Process Audio"]
    end
    
    iteration --> timesync
    timesync --> physics
    physics --> process
    process --> render
    render --> audio
    
    physics --> |"Calls"| physicsloop["MainLoop::physics_process()"]
    process --> |"Calls"| processloop["MainLoop::process()"]
```

**Sources:** [main/main.cpp:2417-2815]()

## OS Abstraction Layer

The `OS` class provides a platform-independent interface to operating system services. Platform-specific implementations inherit from `OS` and implement virtual methods.

```mermaid
classDiagram
    class OS {
        <<abstract>>
        +get_singleton() OS*
        +initialize() void
        +finalize() void
        +get_name() String
        +get_entropy() Error
        +open_dynamic_library() Error
        +execute() int
        +create_process() int
        +get_environment() String
        +set_environment() void
        +get_ticks_usec() uint64_t
        #_check_internal_feature_support() bool
    }
    
    class OS_Windows {
        +initialize() void
        +get_name() String
        +open_dynamic_library() Error
        +get_entropy() Error
        -hInstance HINSTANCE
        -dwrite_factory IDWriteFactory*
    }
    
    class OS_Unix {
        +initialize() void
        +get_name() String
        +execute() int
        +get_entropy() Error
    }
    
    class MainLoop {
        <<abstract>>
        +initialize() void
        +physics_process() bool
        +process() bool
    }
    
    OS <|-- OS_Windows
    OS <|-- OS_Unix
    OS --> MainLoop : "manages"
```

**Sources:** [core/os/os.h:45-278](), [platform/windows/os_windows.h:101-243](), [drivers/unix/os_unix.h:61-165]()

### Platform Implementations

The OS abstraction is implemented for each platform:

| Platform | Class | Key Features | Source Files |
|----------|-------|--------------|--------------|
| Windows | `OS_Windows` | Win32 API, DirectWrite, WASAPI | [platform/windows/os_windows.cpp](), [platform/windows/os_windows.h]() |
| Unix/Linux | `OS_Unix` | POSIX API, X11/Wayland support | [drivers/unix/os_unix.cpp](), [drivers/unix/os_unix.h]() |
| macOS | `OS_Unix` (extended) | Cocoa API, mach kernel APIs | Similar to Unix with macOS-specific code |

**Sources:** [platform/windows/os_windows.cpp:260-336](), [drivers/unix/os_unix.cpp:164-217]()

### OS Singleton Initialization

Each platform implements its own initialization sequence:

```mermaid
graph TB
    main["Platform main() function"]
    
    subgraph "Windows: WinMain()"
        wmain["WinMain entry"]
        woscreate["OS_Windows constructor"]
        wredirect["RedirectIOToConsole()"]
        winit["os.initialize()"]
    end
    
    subgraph "Unix: main()"
        umain["main entry"]
        uoscreate["OS_Unix constructor"]
        uinit["os.initialize()"]
    end
    
    subgraph "Common: Main::setup()"
        setsingleton["OS::singleton = &os"]
        setupcore["Initialize core systems"]
    end
    
    main --> |"Windows"| wmain
    main --> |"Unix"| umain
    
    wmain --> woscreate
    woscreate --> wredirect
    wredirect --> winit
    
    umain --> uoscreate
    uoscreate --> uinit
    
    winit --> setsingleton
    uinit --> setsingleton
    setsingleton --> setupcore
```

**Sources:** [platform/windows/os_windows.cpp:260-336](), [drivers/unix/os_unix.cpp:164-217]()

### Dynamic Library Loading

The OS abstraction provides cross-platform dynamic library loading:

```mermaid
graph LR
    caller["Extension/Module Code"]
    os["OS::open_dynamic_library()"]
    
    subgraph "Windows Implementation"
        wload["LoadLibraryExW()"]
        wcookie["AddDllDirectory()"]
        wtemp["Copy to temp file<br/>(if generate_temp_files)"]
    end
    
    subgraph "Unix Implementation"
        udlopen["dlopen(RTLD_NOW)"]
        urpath["RPATH handling"]
    end
    
    caller --> os
    os --> |"Windows"| wtemp
    wtemp --> wcookie
    wcookie --> wload
    
    os --> |"Unix"| urpath
    urpath --> udlopen
```

**Sources:** [platform/windows/os_windows.cpp:469-560](), [drivers/unix/os_unix.cpp:258-301]()

### Process Management

The OS class provides process creation and management:

| Method | Purpose | Windows | Unix |
|--------|---------|---------|------|
| `execute()` | Run command and wait | `_pipe()`, `_spawnvpe()` | `pipe()`, `fork()`, `execvp()` |
| `create_process()` | Launch independent process | `CreateProcessW()` | `fork()`, `execvp()` |
| `create_instance()` | Launch new engine instance | Uses `create_process()` | Uses `create_process()` |
| `kill()` | Terminate process | `TerminateProcess()` | `kill(SIGKILL)` |
| `is_process_running()` | Check process status | `GetExitCodeProcess()` | `waitpid(WNOHANG)` |

**Sources:** [platform/windows/os_windows.cpp:818-1050](), [drivers/unix/os_unix.cpp:382-620]()

### Environment and System Information

```mermaid
graph TB
    osinfo["OS Information Methods"]
    
    subgraph "System Info"
        name["get_name()"]
        version["get_version()"]
        dist["get_distribution_name()"]
        model["get_model_name()"]
        proccount["get_processor_count()"]
        procname["get_processor_name()"]
    end
    
    subgraph "Environment"
        getenv["get_environment()"]
        setenv["set_environment()"]
        hasenv["has_environment()"]
        username["get_user_data_dir()"]
    end
    
    subgraph "Paths"
        exec["get_executable_path()"]
        datadir["get_data_dir()"]
        cachedir["get_cache_dir()"]
        configdir["get_config_dir()"]
    end
    
    osinfo --> name
    osinfo --> version
    osinfo --> getenv
    osinfo --> exec
```

**Sources:** [core/os/os.h:192-238](), [platform/windows/os_windows.cpp:594-798](), [drivers/unix/os_unix.cpp:219-357]()

## Configuration System

The configuration system manages both project-level settings (`ProjectSettings`) and editor-level settings (`EditorSettings`).

```mermaid
graph TB
    subgraph "ProjectSettings"
        ps["ProjectSettings singleton"]
        pfile["project.godot"]
        poverride["override.cfg"]
        pfeatures["Feature tag overrides"]
    end
    
    subgraph "EditorSettings"
        es["EditorSettings singleton"]
        efile["editor_settings-4.tres"]
        emeta["Project metadata"]
    end
    
    subgraph "Usage"
        game["Game Runtime"]
        editor["Editor"]
    end
    
    ps --> pfile
    ps --> poverride
    ps --> pfeatures
    
    es --> efile
    es --> emeta
    
    game --> ps
    editor --> ps
    editor --> es
```

**Sources:** [core/config/project_settings.h:53-206](), [editor/settings/editor_settings.h]()

### ProjectSettings

`ProjectSettings` manages project configuration stored in `project.godot`:

```mermaid
graph LR
    subgraph "Loading Sequence"
        search["_find_project()<br/>Search for project.godot"]
        load["_load_settings_text_or_binary()"]
        override["_load_override()"]
        features["_get_setting_with_override()"]
    end
    
    subgraph "Storage"
        props["HashMap<StringName, VariantContainer>"]
        order["HashMap<StringName, PropertyInfo>"]
        initial["Initial values for revert"]
    end
    
    search --> load
    load --> override
    override --> features
    features --> props
    props --> order
    order --> initial
```

**Sources:** [core/config/project_settings.cpp:607-852](), [core/config/project_settings.h:56-98]()

Key ProjectSettings methods:

| Method | Purpose | Example |
|--------|---------|---------|
| `get_setting()` | Get raw setting value | `ProjectSettings::get_singleton()->get_setting("application/config/name")` |
| `get_setting_with_override()` | Get with feature tag overrides | Applies platform-specific overrides like `.windows`, `.mobile` |
| `has_setting()` | Check if setting exists | Used before accessing optional settings |
| `set_setting()` | Set setting value | Modifies settings at runtime |
| `save()` | Save to project.godot | Editor use only |
| `load_resource_pack()` | Load .pck file | For exported games |

**Sources:** [core/config/project_settings.cpp:894-931](), [doc/classes/ProjectSettings.xml:96-130]()

### Feature Tag System

Feature tags allow platform-specific and configuration-specific overrides:

```mermaid
graph TB
    setting["Base setting:<br/>application/config/name"]
    
    subgraph "Feature Override Candidates"
        windows["application/config/name.windows"]
        mobile["application/config/name.mobile"]
        debug["application/config/name.debug"]
        custom["application/config/name.custom_tag"]
    end
    
    getoverride["get_setting_with_override()"]
    features["Current feature tags"]
    match["Find matching override"]
    result["Return override or base"]
    
    setting --> getoverride
    windows --> getoverride
    mobile --> getoverride
    debug --> getoverride
    custom --> getoverride
    
    getoverride --> features
    features --> match
    match --> result
```

**Sources:** [core/config/project_settings.cpp:933-1026](), [doc/classes/ProjectSettings.xml:115-130]()

Common feature tags:
- Platform: `windows`, `linux`, `macos`, `android`, `ios`, `web`
- Build type: `debug`, `release`, `editor`
- Rendering: `mobile`, `forward_plus`, `gl_compatibility`
- Architecture: `x86_64`, `arm64`, `x86_32`
- Custom: User-defined in export presets

**Sources:** [core/config/project_settings.cpp:76-149]()

### EditorSettings

`EditorSettings` manages editor-specific preferences stored in the user configuration directory:

```mermaid
graph TB
    es["EditorSettings::create()"]
    
    subgraph "Configuration Files"
        main["editor_settings-4.tres"]
        project["project_metadata.cfg"]
        shortcuts["editor_shortcuts.tres"]
    end
    
    subgraph "Scope"
        global["Global editor preferences<br/>(UI, keybinds, colors)"]
        perproject["Per-project metadata<br/>(open files, favorites)"]
    end
    
    es --> main
    es --> project
    es --> shortcuts
    
    main --> global
    project --> perproject
```

**Sources:** [editor/settings/editor_settings.cpp](), [doc/classes/EditorSettings.xml:1-29]()

Key EditorSettings usage patterns:

```mermaid
graph LR
    plugin["EditorPlugin"]
    
    subgraph "Common Operations"
        get["EDITOR_GET(setting_path)"]
        set["EditorSettings::get_singleton()->set_setting()"]
        meta["get_project_metadata()"]
        setmeta["set_project_metadata()"]
    end
    
    plugin --> get
    plugin --> set
    plugin --> meta
    plugin --> setmeta
    
    get --> |"e.g."| example1["EDITOR_GET('interface/theme/base_color')"]
    meta --> |"e.g."| example2["get_project_metadata('script_editor', 'open_scripts')"]
```

**Sources:** [editor/settings/editor_settings.cpp](), [doc/classes/EditorSettings.xml:126-134]()

### Configuration Flow in Editor

```mermaid
graph TB
    start["EditorNode::EditorNode()"]
    
    subgraph "Settings Initialization"
        edset["EditorSettings::create()"]
        projload["ProjectSettings already loaded<br/>by Main::setup()"]
        edtheme["EditorThemeManager::generate_theme()"]
    end
    
    subgraph "Settings Application"
        applyproj["_update_from_settings()"]
        applyui["Apply UI settings"]
        applyplugins["Initialize editor plugins"]
    end
    
    start --> edset
    edset --> projload
    projload --> edtheme
    edtheme --> applyproj
    applyproj --> applyui
    applyui --> applyplugins
```

**Sources:** [editor/editor_node.cpp:445-570](), [editor/editor_node.cpp:6728-7118]()

### Setting Change Propagation

When settings change, the engine propagates updates to relevant systems:

```mermaid
graph TB
    change["Setting Changed"]
    
    subgraph "ProjectSettings"
        psignal["settings_changed signal"]
        pcheck["check_changed_settings_in_group()"]
    end
    
    subgraph "EditorSettings"
        enotify["NOTIFICATION_EDITOR_SETTINGS_CHANGED"]
        eupdate["EditorNode::_update_from_settings()"]
    end
    
    subgraph "Affected Systems"
        render["RenderingServer updates"]
        physics["PhysicsServer updates"]
        ui["UI theme refresh"]
        plugins["Plugin notification"]
    end
    
    change --> psignal
    change --> enotify
    
    psignal --> pcheck
    enotify --> eupdate
    
    pcheck --> render
    pcheck --> physics
    eupdate --> ui
    eupdate --> plugins
```

**Sources:** [core/config/project_settings.cpp:1406-1450](), [editor/editor_node.cpp:445-570]()

### Autoload System

ProjectSettings manages the autoload system for automatically instantiated singletons:

```mermaid
graph TB
    autoload["Autoload Configuration"]
    
    subgraph "Definition"
        setting["ProjectSettings:<br/>autoload/MySingleton"]
        path["Value: 'res://my_singleton.gd'"]
    end
    
    subgraph "Scene Initialization"
        scenetree["SceneTree::initialize()"]
        loadauto["Load autoload nodes"]
        addroot["Add to scene root"]
    end
    
    subgraph "Access"
        getnode["get_node('/root/MySingleton')"]
        global["Global access in scripts"]
    end
    
    autoload --> setting
    setting --> path
    path --> scenetree
    scenetree --> loadauto
    loadauto --> addroot
    addroot --> getnode
    getnode --> global
```

**Sources:** [core/config/project_settings.h:163-173](), [scene/main/scene_tree.cpp]()

## Integration with Main Loop

The core systems integrate with the main game/editor loop through the `MainLoop` interface:

```mermaid
graph TB
    mainloop["MainLoop (abstract)"]
    
    subgraph "Implementations"
        scenetree["SceneTree<br/>(Game runtime)"]
        editornode["EditorNode<br/>(Editor)"]
    end
    
    subgraph "Core Integration Points"
        initialize["initialize()<br/>Called after setup"]
        physics["physics_process(delta)<br/>Fixed timestep"]
        process["process(delta)<br/>Variable timestep"]
        finalize["finalize()<br/>Cleanup"]
    end
    
    mainloop <|-- scenetree
    mainloop <|-- editornode
    
    mainloop --> initialize
    mainloop --> physics
    mainloop --> process
    mainloop --> finalize
    
    initialize --> |"Accesses"| os["OS singleton"]
    initialize --> |"Accesses"| ps["ProjectSettings"]
    initialize --> |"Accesses"| es["EditorSettings<br/>(editor only)"]
```

**Sources:** [core/os/main_loop.h](), [scene/main/scene_tree.h](), [editor/editor_node.h]()

### Editor Initialization Integration

```mermaid
graph TB
    mainstart["Main::start()"]
    
    subgraph "Editor Creation"
        checkeditor{"--editor flag?"}
        createed["EditorNode::create()"]
        edinit["EditorNode constructor"]
    end
    
    subgraph "Editor Setup"
        loadsettings["Load EditorSettings"]
        buildui["Build editor UI"]
        loadplugins["Load editor plugins"]
        restoreregs["Restore editor state"]
    end
    
    mainstart --> checkeditor
    checkeditor --> |"Yes"| createed
    checkeditor --> |"No"| scenetree["Create SceneTree"]
    
    createed --> edinit
    edinit --> loadsettings
    loadsettings --> buildui
    buildui --> loadplugins
    loadplugins --> restoreregs
```

**Sources:** [main/main.cpp:2246-2415](), [editor/editor_node.cpp:6728-7118]()

## Command Line Argument Processing

The engine core parses command line arguments during `Main::setup()`:

```mermaid
graph TB
    args["Command line arguments"]
    
    subgraph "Argument Categories"
        run["Run options<br/>--path, --scene, --main-pack"]
        display["Display options<br/>--fullscreen, --resolution"]
        debug["Debug options<br/>--debug, --remote-debug"]
        editor["Editor options<br/>--editor, --project-manager"]
        render["Render options<br/>--rendering-driver, --rendering-method"]
    end
    
    subgraph "Processing"
        parse["Main::setup() argument parsing"]
        apply["Apply to globals"]
        override["Override ProjectSettings"]
    end
    
    args --> parse
    parse --> run
    parse --> display
    parse --> debug
    parse --> editor
    parse --> render
    
    run --> apply
    display --> apply
    debug --> apply
    editor --> apply
    render --> apply
    
    apply --> override
```

**Sources:** [main/main.cpp:918-1556](), [main/main.h:56-119]()

Common command line arguments processed by the core:

| Argument | Scope | Effect | Source |
|----------|-------|--------|--------|
| `--path <dir>` | CLI_OPTION_AVAILABILITY_TEMPLATE_UNSAFE | Set project directory | [main/main.cpp:1183-1196]() |
| `--editor` | CLI_OPTION_AVAILABILITY_EDITOR | Launch editor instead of game | [main/main.cpp:1130-1132]() |
| `--headless` | All builds | Disable display/audio for server use | [main/main.cpp:1317-1320]() |
| `--rendering-driver <driver>` | All builds | Select rendering backend | [main/main.cpp:1347-1349]() |
| `--remote-debug <uri>` | CLI_OPTION_AVAILABILITY_TEMPLATE_DEBUG | Enable remote debugger | [main/main.cpp:1399-1405]() |

**Sources:** [main/main.cpp:518-677](), [main/main.h:88-111]()

## Summary

The Engine Core provides:

1. **Three-phase initialization**: `Main::setup()` â†’ `Main::setup2()` â†’ `Main::start()`
2. **OS abstraction**: Platform-independent `OS` class with implementations for Windows, Unix, macOS
3. **Configuration management**: `ProjectSettings` for project config, `EditorSettings` for editor preferences
4. **Feature tag system**: Platform and configuration-specific setting overrides
5. **Process management**: Cross-platform process creation, execution, and IPC
6. **Command line processing**: Argument parsing and application

The core systems work together to provide a consistent, cross-platform foundation that higher-level systems (scenes, resources, scripts) build upon. The initialization sequence ensures proper dependency ordering, while the OS abstraction enables platform-specific optimizations without sacrificing portability.

**Sources:** [main/main.cpp](), [core/os/os.h](), [core/os/os.cpp](), [core/config/project_settings.h](), [core/config/project_settings.cpp](), [platform/windows/os_windows.cpp](), [drivers/unix/os_unix.cpp](), [editor/editor_node.cpp:6728-7118]()1e:T54e0,# Engine Initialization

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

This document describes the engine initialization process in Godot, covering the three-phase startup sequence (`Main::setup()`, `Main::setup2()`, and `Main::start()`) and how core servers (rendering, physics, audio, navigation) are created and configured. This applies to both editor and runtime (exported game) execution modes.

For information about project configuration loading, see [ProjectSettings & EditorSettings](#3.3). For details on the OS abstraction layer used during initialization, see [OS Abstraction Layer](#3.2). For the scene system initialization that occurs after engine startup, see [Scene System](#4).

---

## Initialization Overview

The engine initialization follows a strict three-phase lifecycle implemented in the `Main` class:

| Phase | Function | Purpose |
|-------|----------|---------|
| **Phase 1** | `Main::setup()` | Parse command line arguments, initialize core systems, load project settings |
| **Phase 2** | `Main::setup2()` | Initialize all servers (rendering, physics, audio, navigation), create display window |
| **Phase 3** | `Main::start()` | Create scene tree, initialize editor or game, start main loop |

The initialization process differs based on execution mode:

- **Editor Mode**: Initializes all servers, creates `EditorNode`, loads editor-specific systems
- **Runtime Mode**: Initializes required servers, loads main scene or custom `MainLoop`, begins game execution
- **Headless Mode**: Skips display/rendering initialization, used for servers or CLI tools

Sources: [main/main.cpp:1158-3818](), [main/main.h:39-87]()

---

## Phase 1: Main::setup()

The first initialization phase handles fundamental engine setup before any visual or interactive systems are created.

### Key Responsibilities

**Command Line Parsing**
The engine processes all command line arguments to determine execution mode, configuration overrides, and feature flags. This includes options like `--editor`, `--headless`, `--audio-driver`, `--rendering-driver`, etc.

**Core System Registration**
Core type systems are registered in this order:
1. Core types (`register_core_types()`) - String, Array, Dictionary, Math types
2. Core singletons - Engine, OS, Time, IP, Input, etc.
3. Driver registration (`register_driver_types()`)
4. Server class registration (`register_server_types()`)
5. Module initialization (`register_module_types()`)

**Project Detection and Loading**
The engine searches for `project.godot` files:
1. Check current directory and parent directories
2. Check path specified via `--path` argument
3. Load project settings from `project.godot` or `.pck` files
4. Apply feature tag overrides (platform-specific settings)

**Resource System Initialization**
- `PackedData` singleton for accessing packed resources
- `ResourceLoader` and format loaders
- Translation system (`TranslationServer`)
- Input mapping system (`InputMap`)

Sources: [main/main.cpp:1158-2890](), [core/config/project_settings.cpp:734-1037]()

```mermaid
graph TB
    Start["main(argc, argv)"]
    Setup["Main::setup()"]
    
    subgraph "Command Line Processing"
        ParseArgs["Parse Arguments"]
        DetermineMode["Determine Mode:<br/>--editor, --headless,<br/>--path, etc"]
    end
    
    subgraph "Core Registration"
        RegCore["register_core_types()"]
        RegDrivers["register_driver_types()"]
        RegServers["register_server_types()"]
        RegModules["register_module_types()"]
    end
    
    subgraph "Project Loading"
        FindProject["Search for project.godot"]
        LoadProject["ProjectSettings::setup()"]
        ApplyOverrides["Apply Feature Tag<br/>Overrides"]
    end
    
    subgraph "Core Singletons"
        CreateEngine["Engine singleton"]
        CreateOS["OS singleton"]
        CreateGlobals["ProjectSettings singleton"]
        CreateInput["Input/InputMap"]
        CreateTranslation["TranslationServer"]
    end
    
    Start --> Setup
    Setup --> ParseArgs
    ParseArgs --> DetermineMode
    
    DetermineMode --> RegCore
    RegCore --> RegDrivers
    RegDrivers --> RegServers
    RegServers --> RegModules
    
    RegModules --> FindProject
    FindProject --> LoadProject
    LoadProject --> ApplyOverrides
    
    ApplyOverrides --> CreateEngine
    CreateEngine --> CreateOS
    CreateOS --> CreateGlobals
    CreateGlobals --> CreateInput
    CreateInput --> CreateTranslation
    
    CreateTranslation --> Setup2["Proceed to<br/>Main::setup2()"]
```

Sources: [main/main.cpp:1158-2890]()

---

## Phase 2: Main::setup2()

The second phase creates all server subsystems and initializes the display. This phase cannot proceed until `Main::setup()` completes successfully.

### Server Initialization Sequence

Servers are initialized in dependency order:

```mermaid
graph LR
    Setup2Start["Main::setup2()"]
    
    subgraph "Core Servers"
        AudioServer["AudioServer::get_singleton()"]
        CameraServer["CameraServer"]
        ThemeDB["ThemeDB"]
    end
    
    subgraph "Display Stack"
        DisplayServer["DisplayServer::create()"]
        RenderingServer["RenderingServer::create()"]
        TextServerManager["TextServerManager"]
    end
    
    subgraph "Physics Servers"
        Physics2DManager["PhysicsServer2DManager"]
        Physics2D["PhysicsServer2D"]
        Physics3DManager["PhysicsServer3DManager"]
        Physics3D["PhysicsServer3D"]
    end
    
    subgraph "Navigation Servers"
        Nav2D["NavigationServer2D"]
        Nav3D["NavigationServer3D"]
    end
    
    subgraph "XR Server"
        XRServer["XRServer"]
    end
    
    Setup2Start --> AudioServer
    AudioServer --> CameraServer
    CameraServer --> DisplayServer
    DisplayServer --> RenderingServer
    RenderingServer --> TextServerManager
    TextServerManager --> ThemeDB
    
    ThemeDB --> Physics2DManager
    Physics2DManager --> Physics2D
    Physics2D --> Physics3DManager
    Physics3DManager --> Physics3D
    
    Physics3D --> Nav2D
    Nav2D --> Nav3D
    Nav3D --> XRServer
    
    XRServer --> SetupComplete["_start_success = true"]
```

Sources: [main/main.cpp:2892-3575]()

### Audio Server Initialization

The `AudioServer` is created and configured first as it has no dependencies:

```
audio_server = memnew(AudioServer);
audio_server->init();
```

Audio driver selection is based on:
1. `--audio-driver` command line argument
2. Platform default driver
3. Fallback to dummy driver if none available

Sources: [main/main.cpp:2937-2954]()

### Display and Rendering Server Creation

The `DisplayServer` creates the application window and graphics context:

**DisplayServer Creation Process:**
1. Determine display driver (from `--display-driver` or platform default)
2. Select rendering backend (`vulkan`, `opengl3`, `dummy`)
3. Create window with configured size and mode
4. Initialize graphics API context

**RenderingServer Creation:**
The rendering server is created after the display:
```cpp
rendering_server = memnew(RenderingServerDefault(OS::get_singleton()->get_render_thread_mode() == OS::RENDER_SEPARATE_THREAD));
```

The rendering server can operate in different threading modes:
- `RENDER_THREAD_UNSAFE` - Single-threaded (deprecated)
- `RENDER_THREAD_SAFE` - Main thread rendering with thread-safe API
- `RENDER_THREAD_SEPARATE` - Dedicated render thread

Sources: [main/main.cpp:3021-3252]()

### Physics Server Initialization

Both 2D and 3D physics servers follow the same initialization pattern via manager classes:

```cpp
// 3D Physics
physics_server_3d = PhysicsServer3DManager::get_singleton()->new_server(
    GLOBAL_GET(PhysicsServer3DManager::setting_property_name)
);
if (!physics_server_3d) {
    physics_server_3d = PhysicsServer3DManager::get_singleton()->new_default_server();
}
physics_server_3d->init();

// 2D Physics (similar pattern)
physics_server_2d = PhysicsServer2DManager::get_singleton()->new_server(...);
physics_server_2d->init();
```

The manager allows switching physics implementations via project settings. If the configured physics server isn't available, it falls back to the default implementation or a dummy server.

Sources: [main/main.cpp:352-392]()

### Text Server and Theme Database

**TextServerManager** initializes the text rendering and shaping system:
```cpp
tsman = memnew(TextServerManager);
if (tsman) {
    Ref<TextServer> text_server = tsman->find_interface(text_driver);
    if (text_server.is_valid()) {
        tsman->set_primary_interface(text_server);
    }
}
```

**ThemeDB** is initialized to manage editor and project themes:
```cpp
void initialize_theme_db() {
    theme_db = memnew(ThemeDB);
}
```

Sources: [main/main.cpp:3254-3267](), [main/main.cpp:413-420]()

---

## Phase 3: Main::start()

The final initialization phase creates the scene tree and starts the main execution loop.

### Scene Tree Creation

A `SceneTree` instance is created to manage the node hierarchy:

```cpp
sml = memnew(SceneTree);
```

The scene tree serves different purposes based on execution mode:
- **Editor Mode**: Contains editor UI and edited scene preview
- **Runtime Mode**: Contains the game scene hierarchy
- **Custom MainLoop**: Can be replaced with a custom `MainLoop` implementation

### Main Scene Loading

**Runtime Mode Scene Loading:**
1. Check `ProjectSettings` for main scene path
2. Load scene via `ResourceLoader::load()`
3. Instance the packed scene
4. Add to scene tree as root

**Editor Mode:**
Instead of loading a main scene, the editor creates an `EditorNode`:
```cpp
if (editor) {
    sml->set_auto_accept_quit(false);
    editor_node = memnew(EditorNode);
    sml->get_root()->add_child(editor_node);
}
```

Sources: [main/main.cpp:3577-3818]()

### Initialization Completion

After `Main::start()` completes:
1. `OS::get_singleton()->_in_physics_frame` is reset
2. `Engine::get_singleton()->set_ready()` is called
3. The main loop begins executing via `OS::get_singleton()->run()`

```mermaid
sequenceDiagram
    participant Main
    participant SceneTree
    participant ResourceLoader
    participant EditorNode
    participant OS
    
    Main->>SceneTree: Create SceneTree instance
    
    alt Editor Mode
        Main->>EditorNode: Create EditorNode
        EditorNode->>SceneTree: Add to root
        EditorNode->>EditorNode: Initialize editor UI
        EditorNode->>EditorNode: Load editor plugins
    else Runtime Mode
        Main->>Main: Get main scene path from ProjectSettings
        Main->>ResourceLoader: Load main scene
        ResourceLoader-->>Main: Return PackedScene
        Main->>Main: Instance scene
        Main->>SceneTree: Add scene as root
    else Custom MainLoop
        Main->>Main: Create custom MainLoop instance
        Note over Main: Skip SceneTree creation
    end
    
    Main->>OS: run() - Start main loop
    Note over OS: Engine begins processing frames
```

Sources: [main/main.cpp:3577-3818](), [main/main.h:72-74]()

---

## Editor Initialization

When running in editor mode (`--editor` flag or project manager), additional initialization occurs after `Main::start()` creates the `EditorNode`.

### EditorNode Construction

The `EditorNode` constructor performs extensive setup:

**Core Editor Systems:**
- `EditorData` - Manages edited scenes and undo/redo state
- `EditorSelection` - Tracks selected nodes
- `EditorFileSystem` - Scans and monitors project files
- `EditorSettings` - Loads editor configuration
- `EditorUndoRedoManager` - Manages undo/redo stacks

**UI Construction:**
- Main window layout (VBoxContainer hierarchy)
- Menu bar (File, Edit, Project, Debug, etc.)
- Scene tabs for multiple open scenes
- Dock system (Inspector, FileSystem, Scene tree, etc.)
- Main screen plugins (2D, 3D, Script, Asset Library)

**Plugin Loading:**
The editor loads and initializes all editor plugins:
1. Built-in plugins (CanvasItemEditor, Node3DEditor, ScriptEditor, etc.)
2. Enabled project plugins from `addons/` directory
3. Editor export plugins

Sources: [editor/editor_node.cpp:1-500]()

```mermaid
graph TB
    MainStart["Main::start()"]
    CreateEditor["Create EditorNode"]
    
    subgraph "EditorNode Constructor"
        EditorData["Initialize EditorData"]
        EditorSettings["Load EditorSettings"]
        EditorFileSystem["Start EditorFileSystem scan"]
        CreateUI["Build Editor UI Hierarchy"]
        InitTheme["Generate Editor Theme"]
    end
    
    subgraph "Editor Subsystems"
        UndoRedo["EditorUndoRedoManager"]
        Selection["EditorSelection"]
        ResourcePreview["EditorResourcePreview"]
        Export["EditorExport"]
    end
    
    subgraph "Dock Creation"
        SceneDock["SceneTreeDock"]
        InspectorDock["InspectorDock"]
        FileSystemDock["FileSystemDock"]
        ImportDock["ImportDock"]
        HistoryDock["HistoryDock"]
    end
    
    subgraph "Plugin Loading"
        BuiltinPlugins["Load Built-in Plugins"]
        ProjectPlugins["Load Project Plugins"]
        RegisterPlugins["Register with EditorData"]
    end
    
    MainStart --> CreateEditor
    CreateEditor --> EditorData
    EditorData --> EditorSettings
    EditorSettings --> EditorFileSystem
    EditorFileSystem --> CreateUI
    CreateUI --> InitTheme
    
    InitTheme --> UndoRedo
    UndoRedo --> Selection
    Selection --> ResourcePreview
    ResourcePreview --> Export
    
    Export --> SceneDock
    SceneDock --> InspectorDock
    InspectorDock --> FileSystemDock
    FileSystemDock --> ImportDock
    ImportDock --> HistoryDock
    
    HistoryDock --> BuiltinPlugins
    BuiltinPlugins --> ProjectPlugins
    ProjectPlugins --> RegisterPlugins
    
    RegisterPlugins --> Ready["EditorNode Ready"]
```

Sources: [editor/editor_node.cpp:6700-7500]()

### Editor Plugin Initialization

Editor plugins are initialized in a specific order:

1. **Registration Phase**: Plugins are registered with `EditorData`
2. **Construction Phase**: Plugin instances are created
3. **Activation Phase**: `_enter_tree()` is called on each plugin
4. **Enable Phase**: `_enable_plugin()` is called if the plugin is enabled

Built-in plugins include:
- `CanvasItemEditor` - 2D scene editor
- `Node3DEditor` - 3D scene editor and viewport
- `ScriptEditor` - Script editing and debugging
- `AnimationPlayerEditor` - Animation timeline
- `AssetLibraryEditorPlugin` - Asset library browser
- `DebuggerEditorPlugin` - Debugger UI

Sources: [editor/editor_node.cpp:6900-7200](), [editor/plugins/editor_plugin.h:1-50]()

---

## Complete Initialization Flow

This diagram shows the complete initialization sequence from process start to main loop:

```mermaid
graph TB
    Start["Process Entry:<br/>main(argc, argv)"]
    
    subgraph "Phase 1: Main::setup()"
        P1Start["Begin setup()"]
        ParseCLI["Parse Command Line"]
        RegTypes["Register Core Types"]
        LoadProject["Load ProjectSettings"]
        InitSingletons["Create Core Singletons"]
        P1End["setup() returns OK"]
    end
    
    subgraph "Phase 2: Main::setup2()"
        P2Start["Begin setup2()"]
        AudioInit["Create AudioServer"]
        DisplayInit["Create DisplayServer"]
        RenderInit["Create RenderingServer"]
        PhysicsInit["Create Physics Servers"]
        NavInit["Create Navigation Servers"]
        ThemeInit["Initialize ThemeDB"]
        P2End["_start_success = true"]
    end
    
    subgraph "Phase 3: Main::start()"
        P3Start["Begin start()"]
        CreateSML["Create SceneTree/MainLoop"]
        
        EditorCheck{Is Editor Mode?}
        
        EditorPath["Create EditorNode"]
        EditorInitUI["Build Editor UI"]
        EditorPlugins["Load Editor Plugins"]
        
        RuntimePath["Load Main Scene"]
        RuntimeInstance["Instance Scene"]
        RuntimeAdd["Add to SceneTree"]
        
        P3End["start() complete"]
    end
    
    MainLoop["OS::run()<br/>Begin Main Loop"]
    
    Start --> P1Start
    P1Start --> ParseCLI
    ParseCLI --> RegTypes
    RegTypes --> LoadProject
    LoadProject --> InitSingletons
    InitSingletons --> P1End
    
    P1End --> P2Start
    P2Start --> AudioInit
    AudioInit --> DisplayInit
    DisplayInit --> RenderInit
    RenderInit --> PhysicsInit
    PhysicsInit --> NavInit
    NavInit --> ThemeInit
    ThemeInit --> P2End
    
    P2End --> P3Start
    P3Start --> CreateSML
    CreateSML --> EditorCheck
    
    EditorCheck -->|Yes| EditorPath
    EditorPath --> EditorInitUI
    EditorInitUI --> EditorPlugins
    EditorPlugins --> P3End
    
    EditorCheck -->|No| RuntimePath
    RuntimePath --> RuntimeInstance
    RuntimeInstance --> RuntimeAdd
    RuntimeAdd --> P3End
    
    P3End --> MainLoop
```

Sources: [main/main.cpp:1158-3818](), [editor/editor_node.cpp:6700-7500]()

---

## Configuration Loading

### ProjectSettings Initialization

`ProjectSettings` loads configuration from multiple sources in this order:

1. **project.godot** - Main project configuration file
2. **override.cfg** - User overrides (not version controlled)
3. **Command line overrides** - Settings passed via CLI
4. **Feature tag overrides** - Platform/configuration specific settings

Each source can override values from previous sources. Feature tag overrides allow conditional configuration:
```
# In project.godot
[display/window/size]
viewport_width=1920
viewport_width.mobile=1080  # Override for mobile platforms
```

Sources: [core/config/project_settings.cpp:734-1037]()

### EditorSettings Initialization

`EditorSettings` loads editor-specific configuration from:
1. Editor config directory (per-user)
2. Project-specific editor metadata (`.godot/editor/`)

The config location is platform-specific:
- **Windows**: `%APPDATA%/Godot/`
- **Linux**: `~/.config/godot/`
- **macOS**: `~/Library/Application Support/Godot/`

Sources: [editor/settings/editor_settings.h:1-100](), [editor/file_system/editor_paths.h:1-50]()

---

## Initialization Modes

The engine supports several initialization modes determined by command line flags:

| Mode | Flags | Description |
|------|-------|-------------|
| **Editor** | `--editor`, `-e` | Full editor initialization with UI |
| **Project Manager** | `--project-manager`, `-p` | Project selection UI |
| **Game Runtime** | (default) | Load and run main scene |
| **Headless** | `--headless` | No display/rendering, for servers |
| **Command Line Tool** | Various | Specific operations without UI |

### Headless Mode

In headless mode, display and rendering initialization is skipped:
- `DisplayServer` uses `headless` driver (no window)
- `RenderingServer` uses dummy implementation
- `AudioServer` uses dummy driver
- Physics and navigation servers still initialize for simulation

This mode is used for:
- Dedicated game servers
- Automated testing
- CLI tools and export operations

Sources: [main/main.cpp:1520-1580]()

---

## Error Handling During Initialization

Each initialization phase can fail with specific error codes:

**Phase 1 Failures:**
- `ERR_FILE_NOT_FOUND` - Project file not found
- `ERR_PARSE_ERROR` - Invalid project configuration
- `ERR_INVALID_PARAMETER` - Invalid command line arguments

**Phase 2 Failures:**
- `ERR_CANT_CREATE` - Failed to create display/rendering server
- `ERR_UNAVAILABLE` - Required driver/backend not available

**Phase 3 Failures:**
- `ERR_FILE_CANT_OPEN` - Cannot load main scene
- `ERR_INVALID_DATA` - Corrupted scene file

If any phase fails, the engine prints an error message and exits. The `_start_success` flag indicates whether `setup2()` completed successfully, allowing cleanup in `Main::cleanup()`.

Sources: [main/main.cpp:1158-2890](), [main/main.cpp:2892-3575]()

---

## Summary

The engine initialization is a three-phase process:

1. **Main::setup()** - Core types, project loading, command line parsing
2. **Main::setup2()** - Server creation (audio, display, rendering, physics)
3. **Main::start()** - Scene tree creation, main scene loading, main loop start

The initialization order ensures dependencies are satisfied: core types before servers, servers before scene tree, scene tree before main loop. The editor adds an additional layer of initialization after the base engine is ready, creating the `EditorNode` and loading plugins.

This architecture allows the engine to support multiple execution modes (editor, runtime, headless) while maintaining a consistent initialization sequence.

Sources: [main/main.cpp:1158-3818](), [main/main.h:39-87](), [editor/editor_node.cpp:1-7500]()1f:Ta72b,# OS Abstraction Layer

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/core_bind.cpp](core/core_bind.cpp)
- [core/core_bind.h](core/core_bind.h)
- [core/io/stream_peer.cpp](core/io/stream_peer.cpp)
- [core/io/stream_peer.h](core/io/stream_peer.h)
- [core/os/os.cpp](core/os/os.cpp)
- [core/os/os.h](core/os/os.h)
- [doc/classes/ClassDB.xml](doc/classes/ClassDB.xml)
- [doc/classes/Marshalls.xml](doc/classes/Marshalls.xml)
- [doc/classes/OS.xml](doc/classes/OS.xml)
- [doc/classes/PacketPeer.xml](doc/classes/PacketPeer.xml)
- [doc/classes/StreamPeer.xml](doc/classes/StreamPeer.xml)
- [drivers/unix/os_unix.cpp](drivers/unix/os_unix.cpp)
- [drivers/unix/os_unix.h](drivers/unix/os_unix.h)
- [platform/windows/os_windows.cpp](platform/windows/os_windows.cpp)
- [platform/windows/os_windows.h](platform/windows/os_windows.h)

</details>



## Purpose and Scope

The OS Abstraction Layer provides a platform-independent interface for interacting with the host operating system. It isolates platform-specific code behind a consistent API, enabling Godot to run on multiple operating systems (Windows, Linux, macOS, BSD, Android, iOS, Web, etc.) without requiring platform-specific code in higher-level engine systems.

This page covers the `OS` base class, platform-specific implementations, initialization, and core operating system services. For project-level configuration that may query OS features, see [Project Settings](#3.3). For engine initialization that creates and configures the OS singleton, see [Engine Initialization](#3.1).

---

## Architecture Overview

The OS abstraction follows an inheritance-based design where a base `OS` class at [core/os/os.h:45]() defines a virtual interface, and platform-specific subclasses provide concrete implementations in their respective `platform/` directories.

```mermaid
classDiagram
    class OS {
        <<abstract>>
        +static OS* singleton
        +String _execpath
        +List~String~ _cmdline
        +CompositeLogger* _logger
        +virtual void initialize()
        +virtual void finalize()
        +virtual void finalize_core()
        +virtual void set_main_loop(MainLoop*)
        +virtual String get_name()
        +virtual Error execute(String, List~String~, String*, int*)
        +virtual Error create_process(String, List~String~, ProcessID*)
        +virtual Error get_entropy(uint8_t*, int)
        +virtual uint64_t get_ticks_usec()
        +virtual void delay_usec(uint32_t)
        +virtual bool has_environment(String)
        +virtual String get_environment(String)
        +virtual Error open_dynamic_library(String, void*&)
    }
    
    class OS_Windows {
        +HINSTANCE hInstance
        +uint64_t ticks_start
        +uint64_t ticks_per_second
        +IDWriteFactory* dwrite_factory
        +HashMap~ProcessID,ProcessInfo~ process_map
        +void initialize() override
        +void finalize() override
        +String get_name() "Windows"
        +uint64_t get_ticks_usec()
        +Error open_dynamic_library()
        -QueryPerformanceCounter()
        -LoadLibraryExW()
    }
    
    class OS_Unix {
        +HashMap~ProcessID,ProcessInfo~ process_map
        +void initialize_core()
        +String get_name() "Unix"
        +Error get_entropy()
        +String get_stdin_string()
        -clock_gettime(CLOCK_MONOTONIC_RAW)
        -dlopen(RTLD_NOW | RTLD_DEEPBIND)
        -getentropy() or /dev/urandom
    }
    
    class OS_LinuxBSD {
        +String get_name()
        +String get_distribution_name()
        +String get_version()
    }
    
    class OS_MacOS {
        +String get_name() "macOS"
        +uint64_t get_ticks_usec()
        -mach_absolute_time()
        -mach_timebase_info()
    }
    
    OS <|-- OS_Windows
    OS <|-- OS_Unix
    OS_Unix <|-- OS_LinuxBSD
    OS_Unix <|-- OS_MacOS
```

**Platform Hierarchy and Key Methods**

The `OS::singleton` static member at [core/os/os.h:46]() provides global access via `OS::get_singleton()`. Each platform implementation overrides virtual methods to provide platform-specific behavior while maintaining a consistent interface.

Sources: [core/os/os.h:45-370](), [core/os/os.cpp:51-56](), [platform/windows/os_windows.h:101-241](), [platform/windows/os_windows.cpp:260-336](), [drivers/unix/os_unix.h:53-133](), [drivers/unix/os_unix.cpp:164-184]()

---

## Core OS Class Structure

The `OS` class is a singleton that provides the abstract interface for operating system services. It is instantiated once during engine startup and accessed throughout the engine via `OS::get_singleton()`.

### Class Definition

```mermaid
graph TB
    subgraph "OS Singleton"
        OS["OS (base class)"]
        Singleton["static OS* singleton"]
    end
    
    subgraph "Core State"
        ExecPath["String _execpath"]
        CmdLine["List&lt;String&gt; _cmdline"]
        ExitCode["int _exit_code"]
        Logger["CompositeLogger* _logger"]
        MainLoop["MainLoop* main_loop"]
    end
    
    subgraph "Configuration Flags"
        StdoutEnabled["bool _stdout_enabled"]
        StderrEnabled["bool _stderr_enabled"]
        VerboseStdout["bool _verbose_stdout"]
        LowProcMode["bool low_processor_usage_mode"]
    end
    
    OS --> Singleton
    OS --> ExecPath
    OS --> CmdLine
    OS --> ExitCode
    OS --> Logger
    OS --> MainLoop
    OS --> StdoutEnabled
    OS --> StderrEnabled
    OS --> VerboseStdout
    OS --> LowProcMode
```

**OS Singleton and Core State**

Sources: [core/os/os.h:45-86](), [core/os/os.cpp:51-56]()

### Virtual Interface Categories

The `OS` class defines approximately 100 virtual and non-virtual methods organized into functional categories:

| Category | Key Methods | Purpose |
|----------|-------------|---------|
| **Initialization** | `initialize()`, `finalize()`, `finalize_core()` | Platform setup and teardown |
| **Process Management** | `execute()`, `create_process()`, `kill()`, `is_process_running()` | Execute and manage child processes |
| **File System** | File/DirAccess registration in `initialize_core()` | Register platform file access implementations |
| **Time & Date** | `get_ticks_usec()`, `delay_usec()`, `get_datetime()` | High-resolution timing and date/time queries |
| **System Info** | `get_name()`, `get_version()`, `get_processor_count()` | Platform identification and capabilities |
| **Environment** | `has_environment()`, `get_environment()`, `set_environment()` | Environment variable access |
| **Dynamic Libraries** | `open_dynamic_library()`, `close_dynamic_library()` | Load plugins and GDExtensions |
| **I/O** | `get_stdin_string()`, `print()`, `printerr()` | Standard input/output/error streams |
| **Entropy** | `get_entropy()` | Cryptographically secure random bytes |

Sources: [core/os/os.h:116-370]()

---

## Platform Implementations

### Windows (OS_Windows)

The Windows implementation at [platform/windows/os_windows.h:101]() and [platform/windows/os_windows.cpp:1]() uses Win32 API and provides Windows-specific functionality.

```mermaid
graph TB
    subgraph OSWindows["OS_Windows Class Members"]
        hInstance["HINSTANCE hInstance"]
        ticks_start["uint64_t ticks_start"]
        ticks_per_second["uint64_t ticks_per_second"]
        delay_resolution["uint64_t delay_resolution"]
        dwrite_factory["IDWriteFactory* dwrite_factory"]
        dwrite_factory2["IDWriteFactory2* dwrite_factory2"]
        font_collection["IDWriteFontCollection* font_collection"]
        process_map["HashMap<ProcessID, ProcessInfo>* process_map"]
        temp_libraries["HashMap<void*, String> temp_libraries"]
    end
    
    subgraph Methods["Key OS_Windows Methods"]
        initialize["initialize() [os_windows.cpp:260]"]
        get_ticks["get_ticks_usec() [os_windows.cpp:1289]"]
        delay_usec["delay_usec() [os_windows.cpp:1296]"]
        get_entropy["get_entropy() [os_windows.cpp:396]"]
        open_dynamic["open_dynamic_library() [os_windows.cpp:469]"]
        execute["execute() [os_windows.cpp:1478]"]
    end
    
    subgraph WinAPIs["Win32 API Calls"]
        QPF["QueryPerformanceFrequency()"]
        QPC["QueryPerformanceCounter()"]
        timeBegin["timeBeginPeriod()"]
        BCrypt["BCryptGenRandom()"]
        LoadLib["LoadLibraryExW()"]
        CreateProc["CreateProcessW()"]
        DWrite["DWriteCreateFactory()"]
    end
    
    initialize --> QPF
    initialize --> timeBegin
    initialize --> DWrite
    get_ticks --> QPC
    get_entropy --> BCrypt
    open_dynamic --> LoadLib
    execute --> CreateProc
```

**Windows-Specific Implementation Details**

Key implementation details from [platform/windows/os_windows.cpp]():

- **Timing** (lines 283-285, 1289-1294): 
  - `QueryPerformanceFrequency()` gets timer frequency at initialization
  - `QueryPerformanceCounter()` provides microsecond-precision timing
  - `ticks_per_second` stores frequency for conversion calculations
  
- **Timer Resolution** (lines 290-298):
  - `timeGetDevCaps()` queries system timer capabilities
  - `timeBeginPeriod()` sets timer resolution to minimum (typically 1ms)
  - Stores resolution in `delay_resolution` member
  
- **Entropy** (lines 396-400):
  - `BCryptGenRandom()` with `BCRYPT_USE_SYSTEM_PREFERRED_RNG` flag
  - Provides cryptographically secure random bytes
  
- **Dynamic Libraries** (lines 469-560):
  - `LoadLibraryExW()` with Unicode paths
  - `AddDllDirectory()` for dependency resolution when `also_set_library_path` enabled
  - Creates temporary library copies when `generate_temp_files` enabled to avoid locking
  - `temp_libraries` HashMap tracks temp files for cleanup
  
- **Font System** (lines 315-333):
  - `DWriteCreateFactory()` initializes DirectWrite for font enumeration
  - `GetSystemFontCollection()` provides access to system fonts
  - `GetSystemFontFallback()` enables automatic font fallback

Sources: [platform/windows/os_windows.h:101-241](), [platform/windows/os_windows.cpp:260-336](), [platform/windows/os_windows.cpp:283-298](), [platform/windows/os_windows.cpp:396-400](), [platform/windows/os_windows.cpp:469-560](), [platform/windows/os_windows.cpp:1289-1303]()

### Unix (OS_Unix)

The Unix implementation at [drivers/unix/os_unix.h:53]() and [drivers/unix/os_unix.cpp:1]() provides a base for POSIX-compliant systems (Linux, BSD, macOS).

```mermaid
graph TB
    subgraph OSUnix["OS_Unix Class Structure"]
        ProcessInfo["struct ProcessInfo { bool is_running; int exit_code; }"]
        process_map["HashMap<ProcessID, ProcessInfo>* process_map"]
        iconv_support["iconv support (glibc) or dlopen"]
        clock_start["static uint64_t _clock_start"]
        clock_scale["static double _clock_scale (macOS)"]
    end
    
    subgraph Methods["Key OS_Unix Methods"]
        init_core["initialize_core() [os_unix.cpp:164]"]
        setup_clock["_setup_clock() [os_unix.cpp:111-132]"]
        get_entropy["get_entropy() [os_unix.cpp:280]"]
        open_dl["open_dynamic_library() [os_unix.cpp:474]"]
        execute["execute() [os_unix.cpp:556]"]
        get_stdin["get_stdin_string() [os_unix.cpp:197]"]
    end
    
    subgraph POSIXAPIs["POSIX/Platform APIs"]
        clock_gettime_raw["clock_gettime(CLOCK_MONOTONIC_RAW)"]
        clock_gettime_mono["clock_gettime(CLOCK_MONOTONIC)"]
        mach_time["mach_absolute_time() (macOS)"]
        mach_base["mach_timebase_info() (macOS)"]
        getentropy["getentropy() or /dev/urandom"]
        dlopen_call["dlopen(RTLD_NOW | RTLD_DEEPBIND)"]
        dlsym_call["dlsym()"]
        fork_exec["fork() + execvp()"]
    end
    
    subgraph Derivatives["Platform Derivatives"]
        LinuxBSD["OS_LinuxBSD [platform/linuxbsd/]"]
        MacOS["OS_MacOS [platform/macos/]"]
        iOS["OS_IOS [platform/ios/]"]
        Android["OS_Android [platform/android/]"]
    end
    
    init_core --> setup_clock
    setup_clock -.Linux/BSD.-> clock_gettime_raw
    setup_clock -.Linux fallback.-> clock_gettime_mono
    setup_clock -.macOS.-> mach_time
    setup_clock -.macOS.-> mach_base
    get_entropy -.Preferred.-> getentropy
    get_entropy -.Fallback.-> "/dev/urandom"
    open_dl --> dlopen_call
    open_dl --> dlsym_call
    execute --> fork_exec
    
    OSUnix -.-> LinuxBSD
    OSUnix -.-> MacOS
    OSUnix -.-> iOS
    OSUnix -.-> Android
```

**Unix Platform Implementation Details**

Key implementation details from [drivers/unix/os_unix.cpp]():

- **Timing Setup** (lines 111-132):
  - **Linux/BSD**: `clock_gettime(CLOCK_MONOTONIC_RAW)` preferred (lines 128-131)
  - **Fallback**: `clock_gettime(CLOCK_MONOTONIC)` if RAW unavailable
  - **macOS**: `mach_absolute_time()` with `mach_timebase_info()` for scaling (lines 115-120)
  - Stores `_clock_start` for relative time calculations
  
- **Entropy Generation** (lines 280-303):
  - Prefers `getentropy()` if available (defined by `UNIX_GET_ENTROPY` macro at line 281)
  - Supported on: macOS, Android APIâ‰¥28, FreeBSD, OpenBSD, glibcâ‰¥2.25
  - Falls back to `/dev/urandom` (lines 291-299) on older systems
  - Reads in 256-byte chunks for `getentropy()` compliance
  
- **Dynamic Libraries** (lines 474-500):
  - Uses `dlopen()` with flags: `RTLD_NOW | RTLD_DEEPBIND` (defined at lines 90-93)
  - `RTLD_DEEPBIND` ensures symbols are resolved in library first
  - Disabled when sanitizers enabled (lines 91-93) to avoid conflicts
  - `dlsym()` retrieves function pointers from loaded libraries
  
- **Process Creation** (lines 556-644):
  - `fork()` creates child process
  - `execvp()` executes target binary with arguments
  - Parent uses `waitpid()` for synchronous execution
  - Pipes created for capturing stdout/stderr

- **Standard Input** (lines 197-215):
  - `fgets()` reads from stdin with UTF-8 decoding
  - Type detection via `isatty()`, `fstat()`, `S_ISFIFO()`, `S_ISREG()` (lines 217-278)
  - Returns `STD_HANDLE_CONSOLE`, `STD_HANDLE_PIPE`, `STD_HANDLE_FILE`, or `STD_HANDLE_UNKNOWN`

Sources: [drivers/unix/os_unix.h:53-133](), [drivers/unix/os_unix.cpp:111-132](), [drivers/unix/os_unix.cpp:164-184](), [drivers/unix/os_unix.cpp:280-303](), [drivers/unix/os_unix.cpp:474-500](), [drivers/unix/os_unix.cpp:556-644](), [drivers/unix/os_unix.cpp:217-278]()

---

## Initialization and Lifecycle

The OS abstraction is initialized very early in the engine bootstrap sequence, before most other systems.

### Initialization Sequence

```mermaid
sequenceDiagram
    participant Main as "Main::setup() [main.cpp:730]"
    participant OS as "OS::get_singleton()"
    participant OSWin as "OS_Windows [os_windows.cpp:260]"
    participant OSUnix as "OS_Unix [os_unix.cpp:164]"
    participant FileAccess as "FileAccess::make_default"
    participant DirAccess as "DirAccess::make_default"
    participant NetSocket as "NetSocketWinSock/NetSocketUnix"
    
    Main->>OS: initialize()
    alt Windows Platform
        OS->>OSWin: initialize()
        OSWin->>OSWin: init_thread_win() [thread_windows.h]
        OSWin->>OSWin: QueryPerformanceFrequency(&ticks_per_second)
        OSWin->>OSWin: timeBeginPeriod(time_caps.wPeriodMin)
        OSWin->>FileAccess: make_default<FileAccessWindows>()
        OSWin->>DirAccess: make_default<DirAccessWindows>()
        OSWin->>NetSocket: NetSocketWinSock::make_default()
        OSWin->>OSWin: process_map = memnew(HashMap)
        OSWin->>OSWin: DWriteCreateFactory(&dwrite_factory)
    else Unix Platform
        OS->>OSUnix: initialize_core()
        OSUnix->>OSUnix: init_thread_posix()
        OSUnix->>OSUnix: _setup_clock() [clock_gettime or mach]
        OSUnix->>FileAccess: make_default<FileAccessUnix>()
        OSUnix->>DirAccess: make_default<DirAccessUnix>()
        OSUnix->>NetSocket: NetSocketUnix::make_default()
        OSUnix->>OSUnix: process_map = memnew(HashMap)
    end
    
    Note over Main: Engine initialization continues...
    Main->>OS: set_main_loop(SceneTree/MainLoop)
    
    Note over Main: Engine runs...
    
    Main->>OS: finalize_core()
    OS->>OSWin: finalize_core()
    OS->>OSUnix: finalize_core()
```

**OS Initialization Flow**

The initialization happens in `Main::setup()` at [main/main.cpp:730-733]() after the OS singleton is created but before most engine systems:

1. **Platform Creation**: The platform-specific OS subclass is instantiated as the singleton (Windows: [platform/windows/os_windows.cpp:1](), Unix: [drivers/unix/os_unix.cpp:1]())
2. **OS::initialize()**: Called to set up platform-specific state:
   - **Windows**: [platform/windows/os_windows.cpp:260-336]() - Initializes performance counters, timer resolution, DirectWrite
   - **Unix**: [drivers/unix/os_unix.cpp:164-184]() - Sets up POSIX threads, timing via `clock_gettime()` or `mach_absolute_time()`
3. **File System Registration**: Platform `FileAccess` and `DirAccess` implementations registered via `make_default<T>()`
4. **Network Setup**: `NetSocketWinSock` (Windows) or `NetSocketUnix` initialized
5. **Process Tracking**: `process_map` created as `HashMap<ProcessID, ProcessInfo>`
6. **Main Loop Assignment**: `set_main_loop()` assigns `SceneTree` or custom `MainLoop` at [main/main.cpp:2485-2486]()

Sources: [main/main.cpp:730-733](), [main/main.cpp:2485-2486](), [platform/windows/os_windows.cpp:260-336](), [drivers/unix/os_unix.cpp:164-184](), [platform/windows/os_windows.cpp:303-310](), [drivers/unix/os_unix.cpp:181]()

### Lifecycle Methods

| Method | Phase | Purpose |
|--------|-------|---------|
| `initialize()` | Startup | Initialize platform-specific subsystems (timing, file I/O, networking) |
| `initialize_core()` | Startup | Unix-specific initialization (called by Unix platforms) |
| `set_main_loop()` | Startup | Assign the main game/editor loop |
| `delete_main_loop()` | Shutdown | Clean up the main loop |
| `finalize()` | Shutdown | Clean up platform-specific resources |
| `finalize_core()` | Shutdown | Final cleanup (process maps, network sockets) |

Sources: [core/os/os.h:117-124]()

---

## Key Subsystems

### Process Management

The OS abstraction provides methods to create, monitor, and terminate child processes.

```mermaid
graph TB
    subgraph "Process Creation"
        Execute["execute()"]
        CreateProcess["create_process()"]
        ExecuteWithPipe["execute_with_pipe()"]
    end
    
    subgraph "Process Monitoring"
        IsRunning["is_process_running()"]
        GetExitCode["get_process_exit_code()"]
        Kill["kill()"]
    end
    
    subgraph "Platform Implementation"
        WindowsImpl["Windows: CreateProcessW()"]
        UnixImpl["Unix: fork() + execvp()"]
    end
    
    Execute --> WindowsImpl
    Execute --> UnixImpl
    CreateProcess --> WindowsImpl
    CreateProcess --> UnixImpl
    IsRunning --> WindowsImpl
    IsRunning --> UnixImpl
```

**Process Management API**

**Method Signatures**:
- `Error execute(const String &p_path, const List<String> &p_arguments, String *r_pipe, int *r_exitcode, bool read_stderr, Mutex *p_pipe_mutex, bool p_open_console)`
- `Error create_process(const String &p_path, const List<String> &p_arguments, ProcessID *r_child_id, bool p_open_console)`
- `Dictionary execute_with_pipe(const String &p_path, const List<String> &p_arguments, bool p_blocking)`
- `bool is_process_running(const ProcessID &p_pid)`
- `Error kill(const ProcessID &p_pid)`

The `execute()` method blocks until the process completes, while `create_process()` spawns a process and returns immediately. `execute_with_pipe()` provides bidirectional communication through file handles.

Sources: [core/os/os.h:194-202](), [doc/classes/OS.xml:54-76](), [doc/classes/OS.xml:95-136]()

### Time and Date

High-resolution timing is critical for frame timing, profiling, and animation. The `OS` class defines timing interfaces at [core/os/os.h:256-261]().

```mermaid
graph TB
    subgraph BaseAPI["OS Base Class API"]
        get_ticks_usec["virtual uint64_t get_ticks_usec()"]
        get_ticks_msec["uint64_t get_ticks_msec() { return get_ticks_usec() / 1000; }"]
        delay_usec["virtual void delay_usec(uint32_t)"]
        get_datetime["virtual DateTime get_datetime(bool utc)"]
        get_unix_time["virtual double get_unix_time()"]
    end
    
    subgraph WindowsImpl["Windows Implementation [os_windows.cpp:1289-1303]"]
        win_ticks_start["uint64_t ticks_start"]
        win_ticks_per_sec["uint64_t ticks_per_second"]
        QPC["QueryPerformanceCounter(&ticks)"]
        calc_win["(ticks - ticks_start) * 1000000 / ticks_per_second"]
        Sleep_win["Sleep(p_usec / 1000)"]
    end
    
    subgraph UnixImpl["Unix Implementation"]
        unix_clock_start["static uint64_t _clock_start"]
        
        subgraph LinuxBSD["Linux/BSD [os_unix.cpp:128-131]"]
            clock_raw["clock_gettime(CLOCK_MONOTONIC_RAW)"]
            calc_linux["(tv_nsec / 1000) + (tv_sec * 1000000) - _clock_start"]
        end
        
        subgraph macOS["macOS [os_unix.cpp:115-120]"]
            mach_time["mach_absolute_time()"]
            clock_scale["static double _clock_scale"]
            timebase["mach_timebase_info(&info)"]
            calc_mac["mach_time * _clock_scale - _clock_start"]
        end
        
        usleep_unix["usleep(p_usec)"]
    end
    
    get_ticks_usec -.Windows.-> QPC
    QPC --> calc_win
    get_ticks_usec -.Linux/BSD.-> clock_raw
    clock_raw --> calc_linux
    get_ticks_usec -.macOS.-> mach_time
    mach_time --> calc_mac
    timebase --> clock_scale
    
    delay_usec -.Windows.-> Sleep_win
    delay_usec -.Unix.-> usleep_unix
```

**Timing Implementation Details**

The timing system uses platform-specific high-resolution timers:

**Windows** [platform/windows/os_windows.cpp:1289-1303]():
- `QueryPerformanceFrequency()` called at initialization stores frequency in `ticks_per_second`
- `QueryPerformanceCounter()` reads current counter value
- Calculation: `((ticks - ticks_start) * 1000000ULL) / ticks_per_second` converts to microseconds
- `delay_usec()` uses `Sleep(p_usec / 1000)` after subtracting `delay_resolution`

**Linux/BSD** [drivers/unix/os_unix.cpp:128-131]():
- `clock_gettime(CLOCK_MONOTONIC_RAW, &tv_now)` provides monotonic time
- Fallback to `CLOCK_MONOTONIC` if `CLOCK_MONOTONIC_RAW` unavailable
- Stores nanosecond resolution, converts: `(tv_nsec / 1000L) + (tv_sec * 1000000L) - _clock_start`
- `delay_usec()` uses `usleep()` POSIX function

**macOS** [drivers/unix/os_unix.cpp:115-120]():
- `mach_absolute_time()` returns Mach absolute time units
- `mach_timebase_info()` gets conversion ratio (numer/denom)
- `_clock_scale = (numer / denom) / 1000.0` for microsecond conversion
- Calculation: `mach_absolute_time() * _clock_scale - _clock_start`

All platforms normalize to microsecond precision via `get_ticks_usec()`, with `get_ticks_msec()` implemented as a simple wrapper at [core/os/os.cpp:68-70]().

Sources: [core/os/os.h:256-261](), [core/os/os.cpp:68-70](), [platform/windows/os_windows.cpp:283-285](), [platform/windows/os_windows.cpp:1289-1303](), [drivers/unix/os_unix.cpp:111-132](), [drivers/unix/os_unix.cpp:128-131](), [drivers/unix/os_unix.cpp:115-120]()

### Dynamic Library Loading

The OS provides a cross-platform interface for loading dynamic libraries (`.dll`, `.so`, `.dylib`) used by GDExtensions and plugins. The API is defined at [core/os/os.h:178-180]().

**Dynamic Library API Flow**:

```mermaid
sequenceDiagram
    participant GDExt as "GDExtension System"
    participant OS as "OS::get_singleton()"
    participant OSWin as "OS_Windows [os_windows.cpp:469]"
    participant OSUnix as "OS_Unix [os_unix.cpp:474]"
    participant WinAPI as "Win32 API"
    participant UnixAPI as "libdl"
    
    GDExt->>OS: open_dynamic_library(path, handle, GDExtensionData)
    
    alt Windows Platform
        OS->>OSWin: open_dynamic_library()
        OSWin->>OSWin: fix_path() - Convert to long path
        
        alt generate_temp_files == true
            OSWin->>OSWin: Copy DLL to ~filename.dll
            OSWin->>OSWin: copy_and_rename_pdb()
            OSWin->>OSWin: temp_libraries[handle] = load_path
        end
        
        alt also_set_library_path == true
            OSWin->>WinAPI: AddDllDirectory(dll_dir)
        end
        
        OSWin->>WinAPI: LoadLibraryExW(dll_path, flags)
        WinAPI-->>OSWin: HMODULE handle
        
        alt Error
            OSWin->>OSWin: debug_dynamic_library_check_dependencies()
            OSWin-->>GDExt: ERR_CANT_OPEN + missing deps
        end
        
        OSWin->>WinAPI: RemoveDllDirectory(cookie)
        OSWin-->>OS: OK + handle
    else Unix Platform
        OS->>OSUnix: open_dynamic_library()
        OSUnix->>UnixAPI: dlopen(path, RTLD_NOW | RTLD_DEEPBIND)
        UnixAPI-->>OSUnix: void* handle
        
        alt Error
            OSUnix->>UnixAPI: dlerror()
            OSUnix-->>GDExt: ERR_CANT_OPEN + error string
        end
        
        OSUnix-->>OS: OK + handle
    end
    
    OS-->>GDExt: Error + handle
    
    Note over GDExt: Get function pointer
    GDExt->>OS: get_dynamic_library_symbol_handle(handle, "gdextension_init")
    
    alt Windows
        OS->>OSWin: get_dynamic_library_symbol_handle()
        OSWin->>WinAPI: GetProcAddress(handle, name)
    else Unix
        OS->>OSUnix: get_dynamic_library_symbol_handle()
        OSUnix->>UnixAPI: dlsym(handle, name)
    end
    
    OS-->>GDExt: symbol_handle
    
    Note over GDExt: Unload library
    GDExt->>OS: close_dynamic_library(handle)
    
    alt Windows
        OS->>OSWin: close_dynamic_library()
        OSWin->>WinAPI: FreeLibrary(handle)
        OSWin->>OSWin: _remove_temp_library(handle)
        OSWin->>OSWin: DirAccess::remove_absolute(temp_path)
    else Unix
        OS->>OSUnix: close_dynamic_library()
        OSUnix->>UnixAPI: dlclose(handle)
    end
```

**Implementation Details**

**Windows** [platform/windows/os_windows.cpp:469-560]():
- **Path Handling** (lines 509-510):
  - `fix_path()` converts to Windows long path format (`\\?\` prefix)
  - Handles relative paths by prepending executable directory
  
- **Temporary Files** (lines 483-505):
  - When `GDExtensionData::generate_temp_files` is true, copies DLL to `~original.dll`
  - Copies and renames PDB files for debugging
  - Tracked in `temp_libraries` HashMap for cleanup
  
- **Dependency Resolution** (lines 511-513):
  - `AddDllDirectory()` adds library directory to DLL search path
  - Enables proper resolution of dependent DLLs
  - Removed via `RemoveDllDirectory()` after loading (lines 546-548)
  
- **Error Diagnostics** (lines 521-538):
  - `debug_dynamic_library_check_dependencies()` parses PE imports
  - Reports missing DLL dependencies in error message
  - Uses ImageHlp API to walk import descriptor table

**Unix** [drivers/unix/os_unix.cpp:474-500]():
- **dlopen Flags** (lines 90-93):
  - `RTLD_NOW`: Resolve all symbols immediately
  - `RTLD_DEEPBIND`: Prefer symbols from loaded library over global namespace
  - `RTLD_DEEPBIND` disabled when sanitizers enabled to avoid conflicts
  
- **Error Reporting** (lines 491-496):
  - `dlerror()` provides detailed error message on failure
  - Returns `ERR_CANT_OPEN` with descriptive string

**Symbol Resolution**:
- Windows: `GetProcAddress()` at [platform/windows/os_windows.cpp:583]()
- Unix: `dlsym()` at [drivers/unix/os_unix.cpp:489]()

Sources: [core/os/os.h:178-180](), [platform/windows/os_windows.cpp:469-592](), [platform/windows/os_windows.cpp:573-580](), [drivers/unix/os_unix.cpp:474-500](), [drivers/unix/os_unix.cpp:90-93](), [platform/windows/os_windows.cpp:403-466]()

### System Information

The OS provides methods to query platform, hardware, and system configuration.

| Information Type | Methods | Example Values |
|------------------|---------|----------------|
| **Platform Identity** | `get_name()`, `get_distribution_name()`, `get_version()` | "Windows", "Ubuntu", "10.0.19045" |
| **Hardware** | `get_processor_count()`, `get_processor_name()`, `get_memory_info()` | 8, "Intel Core i7", memory dict |
| **Capabilities** | `has_feature()`, `get_video_adapter_driver_info()` | "threads", driver info array |
| **Paths** | `get_executable_path()`, `get_user_data_dir()`, `get_cache_path()` | Platform-specific paths |
| **Display** | `get_model_name()` | Device model (mobile) |

**Feature Detection**:

The `has_feature()` method checks for platform features (e.g., "windows", "x86_64", "threads") and can be extended by setting a callback via `set_has_server_feature_callback()`.

Sources: [core/os/os.h:216-337](), [core/os/os.cpp:439-451](), [doc/classes/OS.xml:272-280]()

### String Encoding Conversion

The OS provides platform-specific multibyte string conversion for handling non-UTF-8 text encodings.

**API Methods** [core/os/os.h:276-277]():
- `virtual String multibyte_to_string(const String &p_encoding, const PackedByteArray &p_array)`
- `virtual PackedByteArray string_to_multibyte(const String &p_encoding, const String &p_string)`

**Windows Implementation** [platform/windows/os_windows.cpp:1044-1168]():

Uses Windows codepage API for conversion:
- `_init_encodings()` at [platform/windows/os_windows.cpp:1044-1151]() creates mapping of encoding names to codepage IDs (e.g., "CP866" â†’ 866, "SHIFT_JIS" â†’ 932)
- `MultiByteToWideChar()` converts from codepage to UTF-16
- `WideCharToMultiByte()` converts from UTF-16 to codepage
- Supports over 100 codepages including IBM, Windows, ISO-8859, and Asian encodings

**Unix Implementation** [drivers/unix/os_unix.cpp:594-707]():

Uses `iconv` library for conversion:
- **glibc/Web**: Native `iconv_open()`, `iconv()`, `iconv_close()` functions
- **Other Unix**: Dynamically loads `libiconv` via `dlopen()` at runtime
- `_load_iconv()` at [drivers/unix/os_unix.cpp:594-633]() handles dynamic loading
- Converts through UTF-8 intermediate: encoding â†’ UTF-8 â†’ target encoding
- Uses `nl_langinfo(CODESET)` or `locale_charset()` to get system encoding

**Use Cases**:
- Reading legacy text files with non-UTF-8 encodings
- Interfacing with external programs that use specific codepages
- Console I/O on Windows (OEM codepage conversion)

Sources: [core/os/os.h:276-277](), [platform/windows/os_windows.cpp:1044-1168](), [drivers/unix/os_unix.cpp:594-707]()

### Environment Variables

Access to system environment variables for configuration and path resolution.

**API Methods**:
- `bool has_environment(const String &p_var)`: Check if variable exists
- `String get_environment(const String &p_var)`: Get variable value
- `void set_environment(const String &p_var, const String &p_value)`: Set variable (current process)
- `void unset_environment(const String &p_var)`: Remove variable

**Platform Notes**:
- Variable names are case-sensitive on Unix, case-insensitive on Windows
- macOS applications don't have access to shell environment by default
- Changes only affect the current process and child processes

Sources: [core/os/os.h:210-214](), [doc/classes/OS.xml:289-296]()

### Standard I/O

The OS provides methods for reading from standard input and writing to standard output/error. The base class defines the interface at [core/os/os.h:153-158]() with platform implementations providing actual I/O operations.

```mermaid
graph TB
    subgraph API["Standard I/O API [os.h:153-158]"]
        GetStdinString["virtual String get_stdin_string(int64_t p_buffer_size)"]
        GetStdinBuffer["virtual PackedByteArray get_stdin_buffer(int64_t)"]
        GetStdinType["virtual StdHandleType get_stdin_type()"]
        GetStdoutType["virtual StdHandleType get_stdout_type()"]
        GetStderrType["virtual StdHandleType get_stderr_type()"]
        Print["void print(const char*, ...)"]
        PrintErr["void printerr(const char*, ...)"]
    end
    
    subgraph HandleTypes["enum StdHandleType [os.h:98-104]"]
        Invalid["STD_HANDLE_INVALID = 0"]
        Console["STD_HANDLE_CONSOLE = 1"]
        File["STD_HANDLE_FILE = 2"]
        Pipe["STD_HANDLE_PIPE = 3"]
        Unknown["STD_HANDLE_UNKNOWN = 4"]
    end
    
    subgraph UnixImpl["Unix Implementation [os_unix.cpp:197-278]"]
        stdin_fgets["fgets((char*)data, size, stdin)"]
        fileno_check["fileno(stdin)"]
        isatty_check["isatty(h)"]
        fstat_check["fstat(h, &statbuf)"]
        S_ISFIFO["S_ISFIFO(statbuf.st_mode)"]
        S_ISREG["S_ISREG(statbuf.st_mode)"]
    end
    
    subgraph WindowsImpl["Windows Implementation [os_windows.cpp:1247-1341]"]
        stdin_GetStdHandle["GetStdHandle(STD_INPUT_HANDLE)"]
        stdin_ReadFile["ReadFile(h_stdin, buffer, size)"]
        GetFileType["GetFileType(h)"]
        GetConsoleMode["GetConsoleMode(h, &mode)"]
    end
    
    GetStdinString -.Unix.-> stdin_fgets
    GetStdinString -.Windows.-> stdin_ReadFile
    
    GetStdinType -.Unix.-> fileno_check
    fileno_check --> isatty_check
    isatty_check --> Console
    fileno_check --> fstat_check
    fstat_check --> S_ISFIFO
    S_ISFIFO --> Pipe
    fstat_check --> S_ISREG
    S_ISREG --> File
    
    GetStdinType -.Windows.-> stdin_GetStdHandle
    stdin_GetStdHandle --> GetFileType
    GetFileType --> GetConsoleMode
    GetConsoleMode --> Console
    GetFileType --> File
    GetFileType --> Pipe
```

**Standard Input Reading**

**Unix** [drivers/unix/os_unix.cpp:197-215]():
- `get_stdin_string()` uses `fgets()` to read a line from stdin
- Automatically converts `\r\n` to `\n` and strips trailing newline
- `get_stdin_buffer()` uses `fread()` for binary data
- Decodes as UTF-8 by default

**Windows** [platform/windows/os_windows.cpp:1247-1272]():
- Uses `GetStdHandle(STD_INPUT_HANDLE)` to get stdin handle
- `ReadFile()` reads data from stdin
- Handles console codepage conversion (CP_OEMCP to UTF-16 to UTF-8)
- Special handling for console vs. pipe input

**Handle Type Detection**

The OS can detect whether standard handles are connected to a console, file, pipe, or are invalid.

**Unix Detection** [drivers/unix/os_unix.cpp:217-278]():
1. `fileno(stdin)` gets file descriptor (returns -1 if invalid)
2. `isatty(fd)` returns true if connected to terminal â†’ `STD_HANDLE_CONSOLE`
3. `fstat(fd, &statbuf)` gets file status
4. `S_ISFIFO(statbuf.st_mode)` tests for pipe â†’ `STD_HANDLE_PIPE`
5. `S_ISREG(statbuf.st_mode)` tests for regular file â†’ `STD_HANDLE_FILE`

**Windows Detection** [platform/windows/os_windows.cpp:1274-1341]():
1. `GetStdHandle(STD_INPUT_HANDLE)` gets handle
2. `GetFileType(handle)` returns `FILE_TYPE_CHAR`, `FILE_TYPE_DISK`, `FILE_TYPE_PIPE`
3. For `FILE_TYPE_CHAR`, `GetConsoleMode()` tests if it's a console
4. Returns appropriate `StdHandleType` enum value

**Output Routing**

The `print()` and `printerr()` methods route through `CompositeLogger` at [core/os/os.cpp:107-150](). Output is controlled by:
- `_stdout_enabled`: Controls whether stdout output is enabled
- `_stderr_enabled`: Controls whether stderr output is enabled
- `_verbose_stdout`: Controls verbose logging mode

Sources: [core/os/os.h:98-158](), [core/os/os.cpp:107-150](), [drivers/unix/os_unix.cpp:197-278](), [platform/windows/os_windows.cpp:1247-1341]()

### Entropy Generation

Cryptographically secure random byte generation for security-sensitive operations. The abstract interface is defined at [core/os/os.h:160]().

**Implementation by Platform**:

| Platform | Implementation | Source Location | Details |
|----------|---------------|----------------|---------|
| **Windows** | `BCryptGenRandom()` | [platform/windows/os_windows.cpp:396-400]() | Uses `BCRYPT_USE_SYSTEM_PREFERRED_RNG` flag |
| **macOS/iOS** | `getentropy()` | [drivers/unix/os_unix.cpp:281-289]() | POSIX.1-2017, reads in 256-byte chunks |
| **Android (APIâ‰¥28)** | `getentropy()` | [drivers/unix/os_unix.cpp:96-99]() | Available since Android 9.0 |
| **Linux (glibc â‰¥2.25)** | `getentropy()` | [drivers/unix/os_unix.cpp:100-104]() | Modern Linux systems |
| **FreeBSD/OpenBSD** | `getentropy()` | [drivers/unix/os_unix.cpp:100-104]() | BSD systems |
| **Fallback** | `/dev/urandom` | [drivers/unix/os_unix.cpp:291-299]() | Unix systems without getentropy |

**Code Details**:

**Windows Implementation** [platform/windows/os_windows.cpp:396-400]():
```cpp
Error OS_Windows::get_entropy(uint8_t *r_buffer, int p_bytes) {
    NTSTATUS status = BCryptGenRandom(nullptr, r_buffer, p_bytes, 
                                      BCRYPT_USE_SYSTEM_PREFERRED_RNG);
    ERR_FAIL_COND_V(status, FAILED);
    return OK;
}
```

**Unix Implementation** [drivers/unix/os_unix.cpp:280-303]():
- Prefers `getentropy()` when available (defined by `UNIX_GET_ENTROPY` macro)
- Reads in chunks of maximum 256 bytes (POSIX requirement)
- Falls back to reading from `/dev/urandom` on older systems
- Uses `open()`, `read()`, and `close()` for `/dev/urandom` access

The method signature is consistent across platforms:
```cpp
virtual Error get_entropy(uint8_t *r_buffer, int p_bytes)
```

Sources: [core/os/os.h:160](), [platform/windows/os_windows.cpp:396-400](), [drivers/unix/os_unix.cpp:280-303](), [drivers/unix/os_unix.cpp:96-104]()

---

## Integration with Engine Core

The OS abstraction integrates tightly with several engine core systems.

### Integration Points

```mermaid
graph TB
    Main["Main::setup()"]
    OS["OS Singleton"]
    ProjectSettings["ProjectSettings"]
    Engine["Engine"]
    Logger["CompositeLogger"]
    MainLoop["MainLoop/SceneTree"]
    
    Main -->|"Creates platform-specific"| OS
    Main -->|"Calls initialize()"| OS
    OS -->|"Provides paths to"| ProjectSettings
    OS -->|"Provides features to"| ProjectSettings
    OS -->|"Sets logger on"| Logger
    OS -->|"Stores reference to"| MainLoop
    Main -->|"Assigns main loop via"| OS
    Engine -->|"Queries capabilities"| OS
```

**OS Integration with Core Systems**

### Main Initialization

The `Main::setup()` function performs OS initialization before other systems:

1. **OS Creation**: Platform-specific OS instance is created and becomes the singleton
2. **OS::initialize()**: Platform-specific initialization (timing, file systems, networking)
3. **Engine Setup**: Engine singleton queries OS for capabilities
4. **ProjectSettings**: Uses OS paths for project file location
5. **Main Loop Assignment**: SceneTree or custom MainLoop is assigned to OS

Sources: [main/main.cpp:50-64](), [main/main.cpp:730-1700]()

### ProjectSettings Path Resolution

`ProjectSettings` relies on OS for path globalization and localization:

- **Resource Path**: `ProjectSettings::globalize_path("res://")` uses `OS::get_user_data_dir()`
- **User Path**: `ProjectSettings::globalize_path("user://")` resolves to platform user data directory
- **Executable Path**: Uses `OS::get_executable_path()` for relative path resolution

Sources: [core/config/project_settings.cpp:261-282]()

### Script Binding (CoreBind::OS)

The OS functionality is exposed to GDScript and other scripting languages through `CoreBind::OS` at [core/core_bind.h:236]() and [core/core_bind.cpp:235]().

```mermaid
graph TB
    subgraph ScriptLayer["Script Layer"]
        GDScript["GDScript: OS.get_name()"]
        CSharp["C#: OS.GetName()"]
    end
    
    subgraph BindingLayer["CoreBind Namespace [core_bind.h:44]"]
        CoreBindOS["class OS : public Object"]
        
        get_name["String get_name() { return OS::get_singleton()->get_name(); }"]
        get_cmdline["PackedStringArray get_cmdline_args()"]
        get_environment["String get_environment(String) const"]
        execute["int execute(String, PackedStringArray, Array output)"]
        get_processor_count["int get_processor_count()"]
        has_feature["bool has_feature(String)"]
    end
    
    subgraph NativeLayer["Native OS Layer [os.h:45]"]
        OSNative["class OS (abstract)"]
        
        native_get_name["virtual String get_name() = 0"]
        native_cmdline["List<String> _cmdline"]
        native_get_env["virtual String get_environment(String) = 0"]
        native_execute["virtual Error execute(...)"]
        native_proc_count["virtual int get_processor_count()"]
        native_feature["bool has_feature(String)"]
    end
    
    GDScript --> get_name
    GDScript --> execute
    GDScript --> has_feature
    CSharp --> get_name
    
    get_name --> native_get_name
    get_cmdline --> native_cmdline
    get_environment --> native_get_env
    execute --> native_execute
    get_processor_count --> native_proc_count
    has_feature --> native_feature
```

**Binding Layer Details**

The `CoreBind::OS` class at [core/core_bind.h:236-494]() wraps native OS methods:

**Key Method Patterns**:

1. **Simple Forwards** [core/core_bind.cpp:329]():
   - Most methods directly call `OS::get_singleton()->method()`
   - Example: `String get_name() const { return OS::get_singleton()->get_name(); }`

2. **Container Conversions** [core/core_bind.cpp:410-422]():
   - Converts `List<String>` to script-friendly `PackedStringArray`
   - Example: `get_cmdline_args()` converts `_cmdline` member
   
3. **Output Parameters** [core/core_bind.cpp:449-467]():
   - `execute()` uses `Array` output parameter instead of `String*` pointer
   - Converts C++ exit code to script-friendly dictionary/array pattern

4. **Virtual Method Bindings** [core/core_bind.cpp:968-1036]():
   - Uses `ClassDB::bind_method()` to register methods with engine reflection
   - Enables method calls from scripting languages
   - Example at [core/core_bind.cpp:996-1007]():
   ```cpp
   ClassDB::bind_method(D_METHOD("get_name"), &OS::get_name);
   ClassDB::bind_method(D_METHOD("get_processor_count"), &OS::get_processor_count);
   ClassDB::bind_method(D_METHOD("get_environment", "variable"), &OS::get_environment);
   ```

5. **Constant Registration** [core/core_bind.cpp:1037-1043]():
   - Binds enum values for script access
   - Example: `BIND_ENUM_CONSTANT(RENDERING_DRIVER_VULKAN);`

The binding maintains identical method names to the native API for consistency across C++, GDScript, and C#.

Sources: [core/core_bind.h:236-494](), [core/core_bind.cpp:235-936](), [core/core_bind.cpp:968-1043](), [core/core_bind.cpp:329](), [core/core_bind.cpp:410-422](), [core/core_bind.cpp:449-467]()

---

## Summary

The OS Abstraction Layer provides:

1. **Platform Independence**: A unified interface hiding platform-specific implementations
2. **Core Services**: File I/O, process management, timing, dynamic libraries, system info
3. **Early Initialization**: Bootstrapped before most engine systems to provide fundamental services
4. **Extensibility**: Virtual interface allows new platform support without core changes
5. **Script Access**: Comprehensive exposure to scripting languages for runtime queries

The OS singleton (`OS::get_singleton()`) is accessible throughout the engine and is one of the most fundamental systems, providing the foundation for cross-platform operation.

Sources: [core/os/os.h:45-370](), [core/os/os.cpp:31-695](), [main/main.cpp:730-1700]()20:T5ecc,# ProjectSettings & EditorSettings

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

This document covers the configuration systems in Godot:

- **ProjectSettings**: Project-wide configuration stored in `project.godot`, affecting runtime behavior of games and applications
- **EditorSettings**: Editor-specific preferences stored in the editor configuration folder, affecting only the editor environment

These systems provide centralized configuration management with different scopes and persistence mechanisms. ProjectSettings is available in both editor and exported projects, while EditorSettings is only available in the editor.

For runtime engine configuration via command-line arguments, see the OS abstraction layer ([3.2](#3.2)). For editor initialization, see EditorNode ([7.1](#7.1)).

---

## System Overview

Both ProjectSettings and EditorSettings are singleton classes providing configuration storage, but they serve different purposes and have different lifecycles.

### Configuration Systems Comparison

| Aspect | ProjectSettings | EditorSettings |
|--------|----------------|----------------|
| **Storage** | `project.godot` in project root | Editor config folder (user-specific) |
| **Scope** | Project-wide (runtime + editor) | Editor-only |
| **Availability** | Editor and exported projects | Editor only |
| **Version Control** | Committed to repository | Not committed (user-specific) |
| **Initialization** | Early in `Main::setup()` | During `EditorNode::_init()` |
| **Override Support** | `override.cfg`, feature tags | Per-project metadata |

**Sources:** [core/config/project_settings.h:39-151](), [editor/settings/editor_settings.h:1-100](), [doc/classes/ProjectSettings.xml:1-17](), [doc/classes/EditorSettings.xml:1-30]()

### Architecture Overview

```mermaid
graph TB
    subgraph "Project Configuration"
        PS[ProjectSettings Singleton]
        PF["project.godot"]
        OF["override.cfg"]
        
        PS --> Load1["Load project.godot"]
        PS --> Load2["Load override.cfg"]
        PS --> Features["Feature Tag Overrides"]
        PS --> Autoloads["Autoload System"]
        PS --> GlobalGroups["Global Groups"]
        
        Load1 --> Runtime["Available at Runtime"]
        Load2 --> Runtime
    end
    
    subgraph "Editor Configuration"
        ES[EditorSettings Singleton]
        EF["editor_settings-4.tres"]
        PM["Project Metadata"]
        
        ES --> LoadE["Load editor_settings-4.tres"]
        ES --> Shortcuts["Shortcut System"]
        ES --> Recent["Recent Files/Favorites"]
        ES --> PluginPrefs["Plugin Preferences"]
        
        LoadE --> EditorOnly["Editor Only"]
    end
    
    PS --> Engine["Engine Systems"]
    ES --> Editor["Editor Systems"]
```

**Sources:** [core/config/project_settings.h:39-151](), [editor/settings/editor_settings.h:1-100](), [main/main.cpp:726-741](), [editor/editor_node.cpp:6500-6700]()

---

## Configuration File Structure

ProjectSettings loads configuration from `project.godot`, a text-based configuration file using Godot's variant serialization format.

### File Format

The project.godot file is organized into sections with key-value pairs:

```
[section_name]

key1="value1"
key2=42
key3=Vector2(100, 200)
```

### Standard Sections

| Section | Purpose | Examples |
|---------|---------|----------|
| `application/config` | Core application metadata | name, icon, description |
| `application/run` | Runtime configuration | main_scene, main_loop_type |
| `display/window` | Window and display settings | size, vsync_mode, fullscreen |
| `rendering` | Rendering pipeline settings | renderer, quality |
| `physics` | Physics engine configuration | default_gravity, fps |
| `input` | Input mapping | Custom input actions |
| `autoload` | Autoload (singleton) nodes | Script/scene paths |
| `global_group` | Global node groups | Group descriptions |

**Sources:** [doc/classes/ProjectSettings.xml:6-11](), [core/config/project_settings.cpp:284-362]()

### Feature Tag Overrides

Settings can have platform or build-specific overrides using feature tags:

```
[section]

setting="default_value"
setting.windows="windows_value"
setting.mobile="mobile_value"
setting.debug="debug_value"
```

The system automatically selects the appropriate override based on the current platform and build configuration.

**Sources:** [core/config/project_settings.cpp:319-335](), [doc/classes/ProjectSettings.xml:9-10]()

---

## Initialization and Loading

ProjectSettings is initialized early in the engine startup sequence, before most other systems.

### Initialization Sequence

```mermaid
sequenceDiagram
    participant Main as Main::setup
    participant OS as OS
    participant PS as ProjectSettings
    participant FS as FileSystem
    participant RC as ResourceCache
    
    Main->>OS: OS::initialize()
    Main->>PS: ProjectSettings::create()
    Main->>PS: ProjectSettings::setup()
    
    PS->>FS: Locate project.godot
    FS-->>PS: Project path found
    
    PS->>PS: _load_settings()
    Note over PS: Parse project.godot
    Note over PS: Apply feature overrides
    
    PS->>PS: Load override.cfg (if exists)
    
    PS->>PS: Setup resource_path
    PS->>PS: Register custom_features
    
    PS-->>Main: Initialization complete
    
    Main->>RC: Initialize ResourceLoader
    Note right of RC: Now uses ProjectSettings paths
```

**Sources:** [main/main.cpp:726-741](), [core/config/project_settings.cpp:726-912]()

### Project Discovery

The engine searches for `project.godot` in the following order:

1. Path specified via `--path` command-line argument
2. Current working directory
3. Parent directories (up to a limit)
4. Embedded PCK file

```mermaid
graph TD
    Start["Engine Start"]
    
    Start --> CmdLine{"--path argument?"}
    CmdLine -->|Yes| UsePath["Use specified path"]
    CmdLine -->|No| CheckCWD{"project.godot in CWD?"}
    
    CheckCWD -->|Yes| UseCWD["Use CWD"]
    CheckCWD -->|No| SearchParent["Search parent directories"]
    
    SearchParent --> Found{"Found?"}
    Found -->|Yes| UseFound["Use found path"]
    Found -->|No| CheckPCK{"Embedded PCK?"}
    
    CheckPCK -->|Yes| UsePCK["Use PCK"]
    CheckPCK -->|No| Error["Error: No project"]
    
    UsePath --> Load["ProjectSettings::_load_settings()"]
    UseCWD --> Load
    UseFound --> Load
    UsePCK --> Load
```

**Sources:** [core/config/project_settings.cpp:726-782]()

---

## Feature Tags and Overrides

The feature tag system enables platform-specific and build-specific configuration overrides.

### Built-in Feature Tags

ProjectSettings automatically registers feature tags based on:

- **Platform:** windows, linux, macos, android, ios, web
- **Architecture:** x86_64, arm64, x86_32
- **Build type:** editor, debug, release, template
- **Renderer:** forward_plus, mobile, gl_compatibility
- **Other capabilities:** threads, double_precision

### Feature Override Resolution

```mermaid
graph LR
    GetSetting["get_setting_with_override(name)"]
    
    GetSetting --> CheckOverrides["Check feature_overrides map"]
    CheckOverrides --> HasOverrides{"Has overrides?"}
    
    HasOverrides -->|Yes| IterateOverrides["Iterate override list"]
    HasOverrides -->|No| ReturnBase["Return base setting"]
    
    IterateOverrides --> CheckFeature{"Feature active?"}
    CheckFeature -->|Yes| ReturnOverride["Return override value"]
    CheckFeature -->|No| NextOverride["Next override"]
    
    NextOverride --> CheckFeature
```

The `feature_overrides` map stores a list of potential overrides for each base setting name. When retrieving a setting, the system checks if any override's feature tag matches the current platform/build and returns the first match.

**Sources:** [core/config/project_settings.cpp:375-423](), [core/config/project_settings.h:127-129]()

### Custom Feature Tags

Projects can define custom feature tags via `application/config/features`:

```
[application]

config/features=PackedStringArray("custom_feature", "another_feature")
```

These can then be used for conditional overrides:

```
setting="default"
setting.custom_feature="special_value"
```

**Sources:** [core/config/project_settings.cpp:308-317]()

---

## Path Resolution System

ProjectSettings provides path resolution between the game's logical paths (res://, user://) and the operating system's physical file paths.

### Path Prefixes

| Prefix | Purpose | Resolution |
|--------|---------|------------|
| `res://` | Project resource path | Maps to project directory or PCK |
| `user://` | User data directory | Maps to OS user data folder |
| `uid://` | Resource UID path | Resolved via ResourceUID |

### Path Resolution Flow

```mermaid
graph TD
    Path["Path: res://scenes/main.tscn"]
    
    Path --> IsSpecial{"Has protocol<br/>prefix?"}
    IsSpecial -->|Yes| ReturnPath["Return as-is"]
    IsSpecial -->|No| Localize["localize_path()"]
    
    Localize --> InProject{"Path inside<br/>resource_path?"}
    InProject -->|Yes| ConvertRes["Convert to res://"]
    InProject -->|No| ReturnAbs["Return absolute path"]
    
    ResPath["res:// path"] --> Globalize["globalize_path()"]
    Globalize --> StripRes["Strip res:// prefix"]
    StripRes --> PrependPath["Prepend resource_path"]
    PrependPath --> OSPath["OS file path"]
    
    UserPath["user:// path"] --> GlobalizeUser["globalize_path()"]
    GlobalizeUser --> GetUserDir["OS::get_user_data_dir()"]
    GetUserDir --> PrependUser["Prepend user data dir"]
    PrependUser --> OSUserPath["OS user data path"]
```

**Sources:** [core/config/project_settings.cpp:152-282]()

### Globalize and Localize

```cpp
// Localize: Convert OS path to res:// path
String localize_path(const String &p_path) const;

// Globalize: Convert res:// path to OS path
String globalize_path(const String &p_path) const;
```

Example usage:

```
// Localize
"/home/user/project/scenes/main.tscn" â†’ "res://scenes/main.tscn"

// Globalize
"res://scenes/main.tscn" â†’ "/home/user/project/scenes/main.tscn"
"user://save.dat" â†’ "/home/user/.local/share/godot/app_userdata/ProjectName/save.dat"
```

**Sources:** [core/config/project_settings.cpp:152-216](), [core/config/project_settings.cpp:261-282](), [doc/classes/ProjectSettings.xml:140-159](), [doc/classes/ProjectSettings.xml:181-186]()

---

## Override System

ProjectSettings supports runtime overrides through `override.cfg`, allowing settings to be changed without modifying `project.godot`.

### Override File Loading

```mermaid
sequenceDiagram
    participant PS as ProjectSettings
    participant FS as FileSystem
    participant Parse as ConfigFile Parser
    
    PS->>PS: _load_settings("project.godot")
    Note over PS: Base settings loaded
    
    PS->>FS: Check for override.cfg
    alt override.cfg exists
        PS->>Parse: Parse override.cfg
        Parse-->>PS: Override settings
        PS->>PS: Apply overrides
        Note over PS: Overrides take priority<br/>over base settings
    end
    
    opt Custom override path
        PS->>FS: Check custom override
        PS->>Parse: Parse custom file
        Parse-->>PS: Custom overrides
        PS->>PS: Apply custom overrides
    end
```

### Override Priority

Settings are resolved in this priority order (highest to lowest):

1. Custom override file (specified via `application/config/project_settings_override`)
2. `override.cfg` in project root
3. Feature tag overrides (platform-specific)
4. Base setting in `project.godot`

**Sources:** [core/config/project_settings.cpp:829-858](), [doc/classes/ProjectSettings.xml:10](), [doc/classes/ProjectSettings.xml:327-346]()

### Disabling Overrides

The override system can be disabled via:

```
[application/config]

disable_project_settings_override=true
```

This prevents loading of both `override.cfg` and custom override files, useful for shipped games to prevent tampering.

**Sources:** [doc/classes/ProjectSettings.xml:327-329]()

---

## Settings Access API

ProjectSettings provides a comprehensive API for accessing and modifying settings at runtime.

### Core API Methods

```mermaid
classDiagram
    class ProjectSettings {
        +has_setting(name) bool
        +get_setting(name, default) Variant
        +get_setting_with_override(name) Variant
        +set_setting(name, value)
        +set_initial_value(name, value)
        +save() Error
        +save_custom(file) Error
        
        +globalize_path(path) String
        +localize_path(path) String
        
        +add_property_info(hint)
        +set_order(name, position)
        +set_as_basic(name, basic)
        +set_as_internal(name, internal)
        +set_restart_if_changed(name, restart)
    }
```

**Sources:** [doc/classes/ProjectSettings.xml:18-273](), [core/config/project_settings.h:173-214]()

### Reading Settings

```cpp
// Check if setting exists
bool has_setting(const String &p_name) const;

// Get setting value (returns default if not found)
Variant get_setting(const String &p_name, const Variant &p_default = Variant()) const;

// Get setting with feature overrides applied
Variant get_setting_with_override(const StringName &p_name) const;
```

The `get_setting()` method returns the raw value without feature overrides, while `get_setting_with_override()` automatically applies platform-specific overrides.

**Sources:** [core/config/project_settings.cpp:365-423](), [doc/classes/ProjectSettings.xml:96-130]()

### Writing Settings

```cpp
// Set setting value
void set_setting(const String &p_name, const Variant &p_value);

// Set initial (default) value
void set_initial_value(const String &p_name, const Variant &p_value);

// Save settings to project.godot
Error save();

// Save settings to custom file
Error save_custom(const String &p_file);
```

Setting a value to `null` removes the setting.

**Sources:** [core/config/project_settings.cpp:218-254](), [doc/classes/ProjectSettings.xml:188-200](), [doc/classes/ProjectSettings.xml:256-272]()

---

## Custom Settings and Metadata

ProjectSettings allows plugins and scripts to register custom settings with metadata for proper editor display.

### Adding Custom Settings

```mermaid
sequenceDiagram
    participant Plugin as EditorPlugin
    participant PS as ProjectSettings
    participant Inspector as EditorInspector
    
    Plugin->>PS: set_setting("plugin/my_setting", default_value)
    Plugin->>PS: add_property_info(hint_dict)
    
    Note over PS: Setting registered with metadata
    
    Plugin->>PS: set_as_basic("plugin/my_setting", true)
    Plugin->>PS: set_restart_if_changed("plugin/my_setting", true)
    
    PS->>Inspector: Notify property list changed
    Inspector->>PS: Query property info
    PS-->>Inspector: Return hint metadata
    
    Inspector->>Inspector: Display setting in UI
```

**Sources:** [doc/classes/ProjectSettings.xml:19-55](), [core/config/project_settings.cpp:218-254]()

### Property Metadata

Custom settings can have rich metadata for editor display:

```cpp
// Add property info for custom setting
Dictionary hint;
hint["name"] = "plugin/my_setting";
hint["type"] = TYPE_INT;
hint["hint"] = PROPERTY_HINT_ENUM;
hint["hint_string"] = "Option1,Option2,Option3";
add_property_info(hint);

// Configure display flags
set_as_basic("plugin/my_setting", true);          // Show in basic mode
set_as_internal("plugin/my_setting", false);       // Not internal
set_restart_if_changed("plugin/my_setting", true); // Requires restart
```

**Sources:** [doc/classes/ProjectSettings.xml:19-55](), [core/config/project_settings.cpp:230-253]()

### Setting Visibility

Settings can be marked as basic, advanced, or internal:

```mermaid
graph TD
    Setting["Project Setting"]
    
    Setting --> Basic{"set_as_basic(true)?"}
    Basic -->|Yes| ShowBasic["Always visible in editor"]
    Basic -->|No| CheckInternal{"set_as_internal(true)?"}
    
    CheckInternal -->|Yes| Hidden["Hidden from editor<br/>(internal use only)"]
    CheckInternal -->|No| ShowAdvanced["Visible in advanced mode"]
```

**Sources:** [doc/classes/ProjectSettings.xml:202-216](), [core/config/project_settings.cpp:230-253]()

---

## Autoload System

ProjectSettings manages the autoload (singleton) system, which automatically instantiates and registers nodes at startup.

### Autoload Configuration

Autoloads are stored as settings with the prefix `autoload/`:

```
[autoload]

GameManager="*res://systems/game_manager.gd"
AudioManager="res://systems/audio_manager.tscn"
```

The asterisk (*) prefix indicates a singleton that should be accessible globally.

### Autoload Data Structure

```mermaid
classDiagram
    class ProjectSettings {
        -HashMap~StringName,AutoloadInfo~ autoloads
        +add_autoload(info)
        +remove_autoload(name)
        +get_autoload_list() Array
    }
    
    class AutoloadInfo {
        +StringName name
        +String path
        +bool is_singleton
    }
    
    ProjectSettings o-- AutoloadInfo
```

**Sources:** [core/config/project_settings.h:67-71](), [core/config/project_settings.cpp:342-353]()

### Autoload Registration Flow

```mermaid
sequenceDiagram
    participant PS as ProjectSettings
    participant ST as SceneTree
    participant RL as ResourceLoader
    participant Node as AutoloadNode
    
    PS->>PS: Parse autoload/ settings
    PS->>PS: Create AutoloadInfo structs
    
    Note over PS,ST: During SceneTree initialization
    
    ST->>PS: get_autoload_list()
    PS-->>ST: Return autoload array
    
    loop For each autoload
        ST->>RL: Load autoload resource
        RL-->>ST: Return PackedScene/Script
        
        ST->>Node: Instantiate autoload
        ST->>ST: add_child(node)
        
        alt is_singleton
            ST->>Engine: Register as singleton
            Note over Engine: Accessible via get_node("/root/Name")
        end
    end
```

**Sources:** [core/config/project_settings.cpp:342-357](), [scene/main/scene_tree.cpp]()

---

## Global Groups

ProjectSettings manages global groups, which are named groups that persist across scene changes.

### Global Group Structure

Global groups are stored with the prefix `global_group/`:

```
[global_group]

enemies="All enemy entities"
collectibles="Collectable items"
```

### Global Group Management

```mermaid
classDiagram
    class ProjectSettings {
        -HashMap~StringName,String~ global_groups
        +add_global_group(name, description)
        +remove_global_group(name)
        +has_global_group(name) bool
        +get_global_group_list() Array
    }
    
    class Node {
        +add_to_group(name, persistent)
        +is_in_group(name) bool
        +get_groups() Array
    }
    
    ProjectSettings ..> Node : defines groups
```

Nodes can be added to global groups, and the group definitions persist even when scenes are unloaded.

**Sources:** [core/config/project_settings.cpp:354-357](), [doc/classes/ProjectSettings.xml:77-87]()

---

## Integration with Engine Systems

ProjectSettings integrates with multiple engine systems throughout the codebase.

### Usage by Core Systems

```mermaid
graph TB
    PS[ProjectSettings]
    
    PS --> Main["Main Loop<br/>main_scene<br/>main_loop_type"]
    PS --> Display["Display Server<br/>window size<br/>vsync mode"]
    PS --> Physics["Physics Servers<br/>gravity<br/>tick rate"]
    PS --> Audio["Audio Server<br/>mix rate<br/>latency"]
    PS --> Rendering["Rendering Server<br/>renderer type<br/>quality settings"]
    PS --> Input["Input System<br/>input actions<br/>dead zones"]
    PS --> Resource["Resource System<br/>import settings<br/>compression"]
    
    Main --> SceneTree
    Display --> Window
    Physics --> PhysicsServer2D
    Physics --> PhysicsServer3D
    Audio --> AudioDriver
```

**Sources:** [main/main.cpp:1-3000](), [servers/]()

### Macro for Settings Access

The codebase uses the `GLOBAL_GET` macro for convenient access to settings with overrides:

```cpp
#define GLOBAL_GET(m_var) ProjectSettings::get_singleton()->get_setting_with_override(m_var)

// Usage example:
String main_scene = GLOBAL_GET("application/run/main_scene");
```

This macro is used extensively throughout the engine to read project settings.

**Sources:** [core/config/project_settings.h:40-41]()

### OS Path Integration

ProjectSettings works closely with the OS abstraction layer for path resolution:

```mermaid
graph LR
    PS[ProjectSettings]
    OS[OS Layer]
    
    PS -->|globalize_path| OS
    PS -->|localize_path| OS
    
    OS -->|get_user_data_dir| PS
    OS -->|get_executable_path| PS
    OS -->|get_resource_dir| PS
    
    PS --> FS[FileSystem Access]
    OS --> FS
```

The `globalize_path()` method converts res:// and user:// paths to OS-specific absolute paths, while `localize_path()` does the reverse.

**Sources:** [core/config/project_settings.cpp:261-282](), [core/os/os.cpp:305-356](), [platform/windows/os_windows.cpp:508]()

---

## Thread Safety

ProjectSettings uses thread-safe mechanisms for concurrent access:

```cpp
class ProjectSettings : public Object {
    _THREAD_SAFE_CLASS_  // Macro for mutex-based thread safety
    
    // All public methods are protected by automatic locking
};
```

The `_THREAD_SAFE_METHOD_` macro is used in methods that access internal state, ensuring safe concurrent access from multiple threads.

**Sources:** [core/config/project_settings.h:41](), [core/config/project_settings.cpp:285-362]()

---

## Settings Change Tracking

ProjectSettings tracks which settings have been modified since the last save.

### Change Detection

```mermaid
graph TD
    SetValue["set_setting(name, value)"]
    
    SetValue --> CheckExisting{"Setting exists?"}
    CheckExisting -->|Yes| CompareValue{"Value changed?"}
    CheckExisting -->|No| AddNew["Add new setting"]
    
    CompareValue -->|Yes| RecordChange
    CompareValue -->|No| Return["Return (no change)"]
    
    AddNew --> RecordChange["Record in changed_settings"]
    RecordChange --> IncrementVersion["Increment _version counter"]
    RecordChange --> QueueNotify["_queue_changed(name)"]
    
    QueueNotify --> EmitSignal["Emit settings_changed signal"]
```

Applications can query changed settings:

```cpp
// Get list of changed settings
PackedStringArray get_changed_settings() const;

// Check if settings in a group changed
bool check_changed_settings_in_group(const String &p_prefix) const;
```

**Sources:** [core/config/project_settings.cpp:284-362](), [core/config/project_settings.h:48-51](), [doc/classes/ProjectSettings.xml:57-75]()

---

## Version Tracking

ProjectSettings maintains a version counter that increments on any change:

```cpp
uint32_t _version = 1;  // Starts at 1

// Check if settings changed
uint32_t current_version = ProjectSettings::get_singleton()->get_version();
if (current_version != last_known_version) {
    // Settings were modified, update cached values
    last_known_version = current_version;
}
```

This allows systems to efficiently detect when settings have changed without polling individual values.

**Sources:** [core/config/project_settings.h:48]()21:T4866,# Core Types & String System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/string/ustring.cpp](core/string/ustring.cpp)
- [core/string/ustring.h](core/string/ustring.h)
- [core/variant/variant_call.cpp](core/variant/variant_call.cpp)
- [doc/classes/NodePath.xml](doc/classes/NodePath.xml)
- [doc/classes/String.xml](doc/classes/String.xml)
- [doc/classes/StringName.xml](doc/classes/StringName.xml)
- [tests/core/string/test_string.h](tests/core/string/test_string.h)

</details>



**Purpose and Scope**: This document describes Godot Engine's fundamental string types and their memory management. It covers the `String` class (UTF-32 based string with copy-on-write), `StringName` (interned strings for fast comparison), `CharStringT` templates (encoding-specific character sequences), and `NodePath` (pre-parsed scene tree paths). For information about how strings integrate with the scripting system, see [GDScript System](#6). For string rendering and text display components, see [Text Components](#10).

## String Class Architecture

The `String` class is Godot's primary string type, designed as a Unicode-aware, copy-on-write string container. It stores text internally as UTF-32 (`char32_t`) for constant-time indexing and simplified Unicode handling.

```mermaid
classDiagram
    class String {
        -CowData~char32_t~ _cowdata
        -char32_t _null
        -char32_t _replacement_char
        +char32_t* ptrw()
        +const char32_t* ptr()
        +int length()
        +bool is_empty()
        +String substr(int from, int chars)
        +Error append_utf8(const char* str)
        +CharString utf8()
        +Char16String utf16()
    }

    class CowData~T~ {
        -T* _ptr
        +T* ptrw()
        +const T* ptr()
        +int size()
        +Error resize(int size)
        +void set(int index, T value)
        +T get(int index)
    }

    class CharStringT~T~ {
        -CowData~T~ _cowdata
        +T* ptrw()
        +const T* ptr()
        +int length()
        +Span~T~ span()
    }

    class StringName {
        +static StringName create(String)
        +bool operator==(StringName)
        +uint32_t hash()
    }

    class NodePath {
        +StringName get_name(int idx)
        +int get_name_count()
        +int get_subname_count()
        +bool is_absolute()
    }

    String --> CowData~char32_t~ : contains
    CharStringT~T~ --> CowData~T~ : contains
    String ..> CharStringT~char~ : converts to (utf8)
    String ..> CharStringT~char16_t~ : converts to (utf16)
    String ..> StringName : converts to
    NodePath ..> StringName : uses for segments
```

**Sources**: [core/string/ustring.h:266-310](), [core/templates/cowdata.h](), [core/string/ustring.h:172-254]()

### Internal Memory Layout

The `String` class wraps a `CowData<char32_t>` which implements copy-on-write semantics. This allows string copies to share memory until modification occurs.

```mermaid
graph TB
    subgraph "String Object 1"
        S1["String<br/>_cowdata ptr"]
    end
    
    subgraph "String Object 2 (copy)"
        S2["String<br/>_cowdata ptr"]
    end
    
    subgraph "Shared Memory"
        CD["CowData Header<br/>refcount: 2<br/>size: 12"]
        Data["char32_t array<br/>[H][e][l][l][o][space][W][o][r][l][d][null]"]
    end
    
    S1 --> CD
    S2 --> CD
    CD --> Data
    
    subgraph "After Modification"
        S1M["String 1<br/>_cowdata ptr"]
        S2M["String 2<br/>_cowdata ptr"]
        
        CD1["CowData Header<br/>refcount: 1<br/>size: 12"]
        Data1["char32_t array<br/>[H][e][l][l][o][!][null]"]
        
        CD2["CowData Header<br/>refcount: 1<br/>size: 12"]
        Data2["char32_t array<br/>[H][e][l][l][o][space][W][o][r][l][d][null]"]
        
        S1M --> CD1
        CD1 --> Data1
        S2M --> CD2
        CD2 --> Data2
    end
```

**Sources**: [core/string/ustring.h:266-270](), [core/templates/cowdata.h]()

### Key String Methods

| Method Category | Key Functions | Description |
|----------------|---------------|-------------|
| **Construction** | `String()`, `append_utf8()`, `append_utf16()`, `append_latin1()` | Create and build strings from various encodings |
| **Access** | `operator[]`, `unicode_at()`, `ptr()`, `get_data()` | Access individual characters or raw data |
| **Searching** | `find()`, `rfind()`, `find_char()`, `findn()`, `contains()` | Locate substrings and characters |
| **Manipulation** | `substr()`, `insert()`, `erase()`, `replace()`, `split()` | Modify and extract string portions |
| **Comparison** | `operator==`, `casecmp_to()`, `nocasecmp_to()`, `naturalcasecmp_to()` | Compare strings with various rules |
| **Conversion** | `to_int()`, `to_float()`, `hex_to_int()`, `to_upper()`, `to_lower()` | Convert to/from other types |
| **Encoding** | `utf8()`, `utf16()`, `ascii()`, `latin1()` | Export to different encodings |

**Sources**: [core/string/ustring.h:385-644](), [core/string/ustring.cpp]()

## Copy-on-Write Mechanism

The `CowData<T>` template implements reference-counted copy-on-write behavior. Multiple `String` objects can reference the same underlying memory until a write operation occurs.

```mermaid
sequenceDiagram
    participant User
    participant String1
    participant String2
    participant CowData
    participant Memory

    User->>String1: Create "Hello"
    String1->>CowData: Allocate (refcount=1)
    CowData->>Memory: Allocate buffer

    User->>String2: Copy String1
    String1->>String2: Share CowData pointer
    String2->>CowData: Increment refcount (refcount=2)
    Note over String1,String2: Both share same memory

    User->>String1: Modify string[0] = 'J'
    String1->>CowData: ptrw() - request write access
    CowData->>CowData: Check refcount > 1
    CowData->>Memory: Allocate new buffer
    CowData->>Memory: Copy data
    CowData->>String1: Return new writable pointer
    Note over String1: String1 now has its own copy
    Note over String2: String2 still has original
```

**Sources**: [core/string/ustring.h:128-166](), [core/templates/cowdata.h]()

### Write Access Pattern

The `CharProxy` class mediates write access to ensure COW semantics:

```mermaid
graph LR
    A["operator[] read"] --> B{Index == size?}
    B -->|Yes| C["Return _null"]
    B -->|No| D["Return _cowdata.get(index)"]
    
    E["operator[] write"] --> F["CharProxy object"]
    F --> G["CharProxy::operator="]
    G --> H["_cowdata.set(index, value)"]
    H --> I["Triggers COW if needed"]
```

**Sources**: [core/string/ustring.h:129-166](), [core/string/ustring.cpp:159-228]()

## String Encoding Conversions

Godot's `String` class internally uses UTF-32, but provides conversion methods for multiple encodings.

```mermaid
graph TB
    subgraph "External Encodings"
        UTF8["UTF-8<br/>(char*)"]
        UTF16["UTF-16<br/>(char16_t*)"]
        Latin1["Latin-1/ASCII<br/>(char*)"]
        WChar["wchar_t*<br/>(platform-dependent)"]
    end
    
    subgraph "Internal Representation"
        UTF32["String<br/>(UTF-32 char32_t)"]
    end
    
    UTF8 -->|"append_utf8()"| UTF32
    UTF32 -->|"utf8()"| UTF8
    
    UTF16 -->|"append_utf16()"| UTF32
    UTF32 -->|"utf16()"| UTF16
    
    Latin1 -->|"append_latin1()"| UTF32
    UTF32 -->|"latin1()/ascii()"| Latin1
    
    WChar -->|"append_wstring()"| UTF32
    UTF32 -->|"wstring()"| WChar
    
    style UTF32 fill:#f9f9f9
```

**Sources**: [core/string/ustring.h:520-591](), [core/string/ustring.cpp:159-228]()

### Encoding Conversion Functions

| Source Encoding | Append Method | Export Method | Notes |
|----------------|---------------|---------------|-------|
| **UTF-8** | `append_utf8(const char*, int)` | `utf8()` â†’ `CharString` | Variable-length encoding, most common |
| **UTF-16** | `append_utf16(const char16_t*, int)` | `utf16()` â†’ `Char16String` | Used on Windows (wchar_t) |
| **Latin-1** | `append_latin1(Span<char>)` | `latin1()` â†’ `CharString` | Single-byte encoding (0-255) |
| **ASCII** | `append_ascii(Span<char>)` | `ascii(bool extended)` â†’ `CharString` | 7-bit (or extended 8-bit) |
| **UTF-32** | `append_utf32(Span<char32_t>)` | Native format | Internal representation |

**Sources**: [core/string/ustring.h:520-591](), [core/string/ustring.cpp:159-228]()

### Error Handling in Conversions

Invalid Unicode sequences are replaced with the replacement character `0xFFFD`:

```mermaid
graph LR
    A["Input byte sequence"] --> B{Valid UTF-8?}
    B -->|Yes| C["Convert to char32_t"]
    B -->|No| D["Insert 0xFFFD"]
    C --> E["Append to String"]
    D --> E
    E --> F{More bytes?}
    F -->|Yes| A
    F -->|No| G["Return error code"]
    
    style D fill:#ffe0e0
```

**Sources**: [core/string/ustring.cpp:184-219](), [tests/core/string/test_string.h:159-217]()

## StringName: String Interning

`StringName` is an immutable, interned string type optimized for fast comparison. Two `StringName` objects with the same content are guaranteed to be the same object, making equality checks O(1) pointer comparisons.

```mermaid
graph TB
    subgraph "StringName Creation"
        S1["String: 'position'"] --> SN1["StringName::create('position')"]
        S2["String: 'position'"] --> SN2["StringName::create('position')"]
        S3["String: 'rotation'"] --> SN3["StringName::create('rotation')"]
    end
    
    subgraph "Global String Table"
        Table["Hash Table"]
        E1["Entry: 'position'<br/>refcount: 2"]
        E2["Entry: 'rotation'<br/>refcount: 1"]
    end
    
    SN1 --> E1
    SN2 --> E1
    SN3 --> E2
    E1 --> Table
    E2 --> Table
    
    subgraph "Fast Comparison"
        CMP["StringName1 == StringName2"]
        PTR["Pointer comparison<br/>(O(1))"]
        CMP --> PTR
    end
    
    style E1 fill:#e8f4e8
    style PTR fill:#e8e8f4
```

**Sources**: [doc/classes/StringName.xml:1-12](), [core/string/string_name.h](), [core/string/string_name.cpp]()

### StringName Use Cases

| Use Case | Example | Benefit |
|----------|---------|---------|
| **Property names** | `get_property("position")` | Fast property lookups in Object |
| **Method names** | `call("_ready")` | Fast method dispatch |
| **Signal names** | `connect("pressed", ...)` | Fast signal identification |
| **Node names** | `get_node("Player")` | Cached path resolution |
| **Action names** | `Input.is_action_pressed("jump")` | Fast input mapping |

**Sources**: [doc/classes/StringName.xml:6-12]()

## CharStringT Templates

The `CharStringT<T>` template provides encoding-specific string containers:

```mermaid
classDiagram
    class CharStringT~T~ {
        <<template>>
        -CowData~T~ _cowdata
        +T* ptrw()
        +const T* ptr()
        +int size()
        +int length()
        +Span~T~ span()
        +bool operator==(CharStringT)
        +uint32_t hash()
    }
    
    class CharString {
        <<typedef CharStringT~char~>>
    }
    
    class Char16String {
        <<typedef CharStringT~char16_t~>>
    }
    
    CharStringT~T~ <|-- CharString : specialization
    CharStringT~T~ <|-- Char16String : specialization
```

**Sources**: [core/string/ustring.h:172-254](), [core/string/ustring.h:259-260]()

### CharString Usage Pattern

```mermaid
sequenceDiagram
    participant Code
    participant String
    participant CharString
    participant CFunction

    Code->>String: Create "Hello World"
    Code->>String: utf8()
    String->>CharString: Convert and allocate
    String-->>Code: Return CharString
    Code->>CharString: get_data()
    CharString-->>Code: const char*
    Code->>CFunction: Pass to C API
    Note over CharString: Lifetime managed<br/>until CharString destroyed
```

**Sources**: [core/string/ustring.h:259-260](), [core/string/ustring.cpp:537-548]()

## NodePath Type

`NodePath` is a specialized type for pre-parsed scene tree paths, storing node names and property subnames separately.

```mermaid
graph LR
    subgraph "NodePath: '../Player/Sprite2D:texture:size'"
        Absolute["is_absolute: false"]
        Names["names:<br/>['..', 'Player', 'Sprite2D']"]
        Subnames["subnames:<br/>['texture', 'size']"]
    end
    
    Parse["String input"] --> Absolute
    Parse --> Names
    Parse --> Subnames
    
    Names --> N1["get_name(0) â†’ '..'"]
    Names --> N2["get_name(1) â†’ 'Player'"]
    Names --> N3["get_name(2) â†’ 'Sprite2D'"]
    
    Subnames --> S1["get_subname(0) â†’ 'texture'"]
    Subnames --> S2["get_subname(1) â†’ 'size'"]
    
    style Names fill:#e8f4e8
    style Subnames fill:#f4e8e8
```

**Sources**: [doc/classes/NodePath.xml:1-36](), [core/string/node_path.h](), [core/string/node_path.cpp]()

### NodePath Structure

```mermaid
graph TB
    subgraph "NodePath Components"
        A["Absolute flag<br/>(starts with '/')"]
        B["Node names<br/>(separated by '/')"]
        C["Property subnames<br/>(after ':', separated by ':')"]
    end
    
    subgraph "Examples"
        E1["'/root/Level/Player'<br/>absolute: true<br/>names: ['root','Level','Player']<br/>subnames: []"]
        E2["'../Enemy:position:x'<br/>absolute: false<br/>names: ['..','Enemy']<br/>subnames: ['position','x']"]
        E3["':texture:size'<br/>absolute: false<br/>names: []<br/>subnames: ['texture','size']"]
    end
    
    A --> E1
    B --> E1
    B --> E2
    C --> E2
    C --> E3
```

**Sources**: [doc/classes/NodePath.xml:6-32](), [doc/classes/NodePath.xml:54-82]()

## String Operations Reference

### Search and Match Operations

```mermaid
graph TB
    subgraph "Search Methods"
        Find["find(substr, from)"]
        RFind["rfind(substr, from)"]
        FindN["findn(substr, from)"]
        Contains["contains(substr)"]
        Match["match(wildcard)"]
    end
    
    subgraph "Case Sensitivity"
        CS["Case-Sensitive<br/>find(), rfind()"]
        CI["Case-Insensitive<br/>findn(), rfindn()"]
    end
    
    subgraph "Direction"
        FWD["Forward<br/>find(), findn()"]
        REV["Reverse<br/>rfind(), rfindn()"]
    end
    
    Find --> CS
    Find --> FWD
    RFind --> CS
    RFind --> REV
    FindN --> CI
    FindN --> FWD
    Contains --> CS
    Match --> CS
    
    style CS fill:#f4e8e8
    style CI fill:#e8f4e8
```

**Sources**: [core/string/ustring.h:386-398](), [core/string/ustring.cpp]()

### String Comparison Methods

| Method | Case-Sensitive | Natural Order | File Order | Return Value |
|--------|---------------|---------------|------------|--------------|
| `casecmp_to()` | âœ“ | âœ— | âœ— | -1, 0, 1 |
| `nocasecmp_to()` | âœ— | âœ— | âœ— | -1, 0, 1 |
| `naturalcasecmp_to()` | âœ“ | âœ“ | âœ— | -1, 0, 1 |
| `naturalnocasecmp_to()` | âœ— | âœ“ | âœ— | -1, 0, 1 |
| `filecasecmp_to()` | âœ“ | âœ“ | âœ“ | -1, 0, 1 |
| `filenocasecmp_to()` | âœ— | âœ“ | âœ“ | -1, 0, 1 |
| `operator==` | âœ“ | âœ— | âœ— | bool |

**Note**: Natural order treats embedded numbers numerically (e.g., "file2" < "file10"). File order prioritizes `.` and `_` prefixes.

**Sources**: [core/string/ustring.h:371-377](), [core/string/ustring.cpp:442-699]()

### Manipulation Operations

```mermaid
graph LR
    subgraph "Immutable Operations"
        Substr["substr(from, len)"]
        Insert["insert(pos, str)"]
        Erase["erase(pos, len)"]
        Replace["replace(old, new)"]
        Trim["strip_edges()"]
    end
    
    subgraph "Returns New String"
        Result["New String object<br/>(original unchanged)"]
    end
    
    Substr --> Result
    Insert --> Result
    Erase --> Result
    Replace --> Result
    Trim --> Result
    
    style Result fill:#e8f4e8
```

**Sources**: [core/string/ustring.h:385-423](), [core/string/ustring.cpp:229-806]()

## Integration with Variant System

The `String` class integrates deeply with Godot's `Variant` system, enabling automatic conversions and method calls.

```mermaid
graph TB
    subgraph "Variant to String"
        V1["Variant (any type)"]
        V1 --> VC1["VariantInternal::get_string()"]
        VC1 --> S1["String"]
    end
    
    subgraph "String to Variant"
        S2["String"]
        S2 --> VC2["Variant constructor"]
        VC2 --> V2["Variant (STRING type)"]
    end
    
    subgraph "String Methods in Variant"
        VM["Variant::call('substr', ...)"]
        VM --> VL["Method lookup table"]
        VL --> SM["String::substr()"]
        SM --> VR["Return as Variant"]
    end
    
    style VC1 fill:#f4e8e8
    style VC2 fill:#f4e8e8
    style VL fill:#e8e8f4
```

**Sources**: [core/variant/variant_call.cpp](), [core/string/ustring.h:1-40]()

### Variant String Method Registration

String methods are registered in the variant system to be callable from scripts:

| Registration Pattern | Example | Implementation |
|---------------------|---------|----------------|
| Method binding | `BIND_METHOD(String, length)` | Direct method pointer |
| Operator binding | `BIND_OPERATOR(String, +, String)` | Operator overload |
| Static method binding | `BIND_STATIC_METHOD(String, num)` | Static function |
| Constructor binding | `BIND_CONSTRUCTOR(String, String)` | Copy constructor |

**Sources**: [core/variant/variant_call.cpp:1-100](), [core/string/ustring.h:336-370]()

## Performance Characteristics

### Time Complexity Summary

| Operation | Complexity | Notes |
|-----------|-----------|-------|
| Copy constructor | O(1) | COW: pointer copy + refcount increment |
| `operator[]` (read) | O(1) | Direct array access |
| `operator[]` (write) | O(n) worst | May trigger COW copy |
| `find()` | O(n*m) | n=string length, m=pattern length |
| `length()` | O(1) | Cached in CowData |
| `substr()` | O(m) | m=substring length (new allocation) |
| `append()` | O(n) amortized | May require reallocation |
| `to_upper()/to_lower()` | O(n) | Must process all characters |
| `StringName` comparison | O(1) | Pointer equality check |

**Sources**: [core/string/ustring.h:304-306](), [core/templates/cowdata.h]()

### Memory Overhead

```mermaid
graph TB
    subgraph "String Memory Layout"
        SO["String object<br/>8 bytes (pointer)"]
        CD["CowData header<br/>8-16 bytes<br/>(refcount, size)"]
        Data["char32_t array<br/>4 Ã— (length + 1) bytes"]
    end
    
    SO --> CD
    CD --> Data
    
    subgraph "Example: 'Hello' (5 chars)"
        Ex1["String: 8 bytes"]
        Ex2["Header: 16 bytes"]
        Ex3["Data: 24 bytes<br/>(6 char32_t)"]
        Total["Total: 48 bytes"]
        
        Ex1 --> Total
        Ex2 --> Total
        Ex3 --> Total
    end
    
    style Total fill:#f4e8e8
```

**Sources**: [core/string/ustring.h:266-270](), [core/templates/cowdata.h]()22:T43a3,# Scene System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/os/main_loop.cpp](core/os/main_loop.cpp)
- [core/os/main_loop.h](core/os/main_loop.h)
- [doc/classes/Control.xml](doc/classes/Control.xml)
- [doc/classes/MainLoop.xml](doc/classes/MainLoop.xml)
- [doc/classes/Node.xml](doc/classes/Node.xml)
- [doc/classes/SceneTree.xml](doc/classes/SceneTree.xml)
- [doc/classes/Viewport.xml](doc/classes/Viewport.xml)
- [doc/classes/Window.xml](doc/classes/Window.xml)
- [scene/gui/control.cpp](scene/gui/control.cpp)
- [scene/gui/control.h](scene/gui/control.h)
- [scene/main/node.cpp](scene/main/node.cpp)
- [scene/main/node.h](scene/main/node.h)
- [scene/main/scene_tree.cpp](scene/main/scene_tree.cpp)
- [scene/main/scene_tree.h](scene/main/scene_tree.h)
- [scene/main/viewport.cpp](scene/main/viewport.cpp)
- [scene/main/viewport.h](scene/main/viewport.h)
- [scene/main/window.cpp](scene/main/window.cpp)
- [scene/main/window.h](scene/main/window.h)

</details>



## Purpose and Scope

The Scene System is the core framework for organizing and managing game objects in Godot. It provides a hierarchical tree structure where all game entities are represented as nodes, orchestrates their lifecycle, manages rendering targets (viewports), and processes frame updates. This page covers the overall architecture and interaction between major scene system components.

For detailed information on specific subsystems:
- Node lifecycle callbacks and tree management: see [Node Hierarchy](#4.1)
- Frame processing and tree orchestration: see [SceneTree & MainLoop](#4.2)
- Rendering targets and input handling: see [Viewport System](#4.3)
- UI layout and interaction: see [Control & UI System](#4.4)
- Window creation and embedding: see [Window Management](#4.5)

## Architecture Overview

The Scene System is built on a hierarchy of `Node` objects organized by a `SceneTree`, with `Viewport` nodes serving as rendering targets and `Control` nodes providing UI functionality.

```mermaid
graph TB
    subgraph "Application Entry"
        MainLoop["MainLoop<br/>(Abstract Base)"]
        SceneTree["SceneTree<br/>(Default Implementation)"]
    end
    
    subgraph "Scene Graph"
        Node["Node<br/>(Base Class)"]
        Viewport["Viewport<br/>(Rendering Target)"]
        Control["Control<br/>(UI Base)"]
        Window["Window<br/>(Window/Subwindow)"]
        CanvasItem["CanvasItem<br/>(2D Drawable)"]
        Node3D["Node3D<br/>(3D Transform)"]
    end
    
    subgraph "World Systems"
        World2D["World2D<br/>(2D Space)"]
        World3D["World3D<br/>(3D Space)"]
    end
    
    MainLoop --> SceneTree
    SceneTree --> Node
    Node --> Viewport
    Viewport --> Control
    Viewport --> Window
    Node --> CanvasItem
    Node --> Node3D
    
    Viewport --> World2D
    Viewport --> World3D
    Control --> CanvasItem
    
    style SceneTree fill:#f9f9f9
    style Node fill:#f9f9f9
    style Viewport fill:#f9f9f9
```

**Diagram: Scene System Class Hierarchy**

Sources: [scene/main/node.h:50-51](), [scene/main/scene_tree.h:231-232](), [scene/main/viewport.h:95-96](), [scene/gui/control.h:44-45](), [scene/main/window.h:43-44](), [core/os/main_loop.h:36-37]()

## Core Components

| Component | File | Responsibilities |
|-----------|------|------------------|
| `MainLoop` | [core/os/main_loop.h]() | Abstract base class defining the game loop interface |
| `SceneTree` | [scene/main/scene_tree.h]() | Manages the node hierarchy, processes frames, handles groups |
| `Node` | [scene/main/node.h]() | Base class for all scene objects, provides tree structure |
| `Viewport` | [scene/main/viewport.h]() | Rendering target, input handling, world association |
| `Control` | [scene/gui/control.h]() | UI base class with anchors, layout, and theme support |
| `Window` | [scene/main/window.h]() | Native or embedded window management |

Sources: [scene/main/scene_tree.h:231-232](), [scene/main/node.h:50-51](), [scene/main/viewport.h:95-96](), [scene/gui/control.h:44-45](), [scene/main/window.h:43-44]()

## Scene Graph Structure

Nodes are organized in a tree hierarchy where each node can have multiple children but only one parent. The root of the tree is always a `Viewport` (typically a `Window`), which is managed by the `SceneTree`.

```mermaid
graph TB
    SceneTree["SceneTree"]
    Root["Root (Window)"]
    Node1["Node"]
    Node2["Node"]
    Viewport1["SubViewport"]
    Control1["Control"]
    Node3D1["Node3D"]
    
    SceneTree -->|"root"| Root
    Root -->|"child"| Node1
    Root -->|"child"| Node2
    Node1 -->|"child"| Viewport1
    Node2 -->|"child"| Control1
    Node2 -->|"child"| Node3D1
    
    style SceneTree fill:#f9f9f9
    style Root fill:#f9f9f9
```

**Diagram: Scene Tree Node Hierarchy**

### Node Relationships

Nodes maintain several types of relationships:

- **Parent-Child**: Established via `add_child()` and `remove_child()` [scene/main/node.cpp:1437-1595]()
- **Owner**: The root node of a scene that "owns" descendant nodes for serialization [scene/main/node.h:200-201]()
- **Groups**: Named collections for batch operations via `add_to_group()` [scene/main/node.cpp:1841-1861]()

Sources: [scene/main/node.cpp:1437-1595](), [scene/main/node.h:194-227](), [scene/main/scene_tree.cpp:167-191]()

## Node Lifecycle

Nodes go through a well-defined lifecycle as they are added to and removed from the scene tree:

```mermaid
sequenceDiagram
    participant Code
    participant Parent
    participant Node
    participant SceneTree
    
    Code->>Parent: add_child(node)
    Parent->>Node: _propagate_enter_tree()
    Node->>Node: NOTIFICATION_ENTER_TREE
    Node->>Node: _enter_tree() virtual
    Node->>Node: emit("tree_entered")
    Node->>SceneTree: node_added(this)
    
    Note over Node: For each child
    Node->>Node: child->_propagate_enter_tree()
    
    Note over Node: After all children
    Node->>Node: _propagate_ready()
    Node->>Node: NOTIFICATION_READY
    Node->>Node: _ready() virtual
    Node->>Node: emit("ready")
```

**Diagram: Node Lifecycle - Enter Tree Flow**

### Key Lifecycle Callbacks

| Notification | Virtual Method | Description |
|-------------|----------------|-------------|
| `NOTIFICATION_ENTER_TREE` | `_enter_tree()` | Node enters the tree, has access to `SceneTree` |
| `NOTIFICATION_READY` | `_ready()` | Node and all children are in tree (called in reverse order) |
| `NOTIFICATION_PROCESS` | `_process(delta)` | Called each idle frame |
| `NOTIFICATION_PHYSICS_PROCESS` | `_physics_process(delta)` | Called each physics frame |
| `NOTIFICATION_EXIT_TREE` | `_exit_tree()` | Node is about to leave the tree |

Sources: [scene/main/node.cpp:60-315](), [scene/main/node.cpp:335-383](), [doc/classes/Node.xml:25-37]()

## Processing System

The `SceneTree` manages two types of frame processing: physics and idle. Nodes can subscribe to either or both by calling `set_process()` and `set_physics_process()`.

```mermaid
graph TB
    subgraph "Frame Update Cycle"
        MainLoop["Main::iteration()"]
        Physics["SceneTree::physics_process()"]
        Idle["SceneTree::process()"]
    end
    
    subgraph "Node Processing"
        PhysicsNodes["Physics Process Nodes"]
        IdleNodes["Idle Process Nodes"]
    end
    
    subgraph "Process Groups"
        ThreadGroup["ProcessThreadGroup"]
        ProcessOwner["Process Owner"]
    end
    
    MainLoop --> Physics
    MainLoop --> Idle
    
    Physics --> PhysicsNodes
    Idle --> IdleNodes
    
    PhysicsNodes --> ThreadGroup
    IdleNodes --> ThreadGroup
    ThreadGroup --> ProcessOwner
    
    style MainLoop fill:#f9f9f9
    style Physics fill:#f9f9f9
    style Idle fill:#f9f9f9
```

**Diagram: Processing System Architecture**

### Processing Modes

Nodes inherit processing behavior from their parent via `ProcessMode`:

- `PROCESS_MODE_INHERIT`: Use parent's mode (default)
- `PROCESS_MODE_PAUSABLE`: Process only when tree is not paused
- `PROCESS_MODE_WHEN_PAUSED`: Process only when tree is paused
- `PROCESS_MODE_ALWAYS`: Always process regardless of pause state
- `PROCESS_MODE_DISABLED`: Never process

Sources: [scene/main/node.h:75-81](), [scene/main/node.cpp:663-719](), [scene/main/scene_tree.cpp:453-665]()

## Viewport System Integration

`Viewport` nodes serve as rendering targets and input handling boundaries. Every scene tree must have at least one viewport (the root).

```mermaid
graph LR
    subgraph "Rendering Pipeline"
        Viewport["Viewport"]
        Canvas["Canvas (2D)"]
        Scenario["Scenario (3D)"]
        RenderingServer["RenderingServer"]
    end
    
    subgraph "Input System"
        InputEvent["InputEvent"]
        ViewportInput["Viewport Input Handling"]
        NodeInput["Node Input Callbacks"]
    end
    
    Viewport --> Canvas
    Viewport --> Scenario
    Canvas --> RenderingServer
    Scenario --> RenderingServer
    
    InputEvent --> ViewportInput
    ViewportInput --> NodeInput
    Viewport --> ViewportInput
    
    style Viewport fill:#f9f9f9
    style RenderingServer fill:#f9f9f9
```

**Diagram: Viewport Rendering and Input Flow**

### Viewport Responsibilities

- **Rendering**: Owns an RID to a RenderingServer viewport [scene/main/viewport.h:248]()
- **Input**: Propagates input events to child nodes [scene/main/viewport.cpp:750-1047]()
- **World Association**: Links to `World2D` and `World3D` for spatial queries [scene/main/viewport.h:286]()
- **Texture Target**: Can be used as a texture via `ViewportTexture` [scene/main/viewport.h:55-93]()

Sources: [scene/main/viewport.h:95-96](), [scene/main/viewport.cpp:570-747](), [doc/classes/Viewport.xml:3-12]()

## Control and UI System

`Control` nodes extend the scene system with UI-specific features like anchors, margins, and theme support.

```mermaid
graph TB
    subgraph "Control Hierarchy"
        Control["Control<br/>(Base UI Class)"]
        Container["Container<br/>(Layout Management)"]
        Button["Button"]
        Label["Label"]
        TextEdit["TextEdit"]
    end
    
    subgraph "Layout System"
        Anchors["Anchor Points"]
        Offsets["Margin Offsets"]
        MinSize["Minimum Size"]
    end
    
    subgraph "Theme System"
        Theme["Theme"]
        ThemeOverrides["Theme Overrides"]
    end
    
    Control --> Anchors
    Control --> Offsets
    Control --> MinSize
    Control --> Theme
    Control --> ThemeOverrides
    
    Control --> Container
    Control --> Button
    Control --> Label
    Control --> TextEdit
    
    style Control fill:#f9f9f9
    style Theme fill:#f9f9f9
```

**Diagram: Control System Components**

### Control Layout

Controls position themselves relative to their parent using:

- **Anchors**: Define attachment points (0.0-1.0) on parent [scene/gui/control.h:54-57]()
- **Offsets**: Pixel offsets from anchor points [scene/gui/control.cpp:1979-2061]()
- **Layout Modes**: Position, Anchors, Container, or Uncontrolled [scene/gui/control.h:147-152]()

Sources: [scene/gui/control.h:44-45](), [scene/gui/control.cpp:620-1144](), [doc/classes/Control.xml:3-18]()

## Window Management

`Window` nodes extend `Viewport` to represent native OS windows or embedded subwindows.

### Window Types

| Type | Creation | Embedding |
|------|----------|-----------|
| Root Window | Created by OS at startup | N/A (top-level) |
| Native Window | `Window` with native OS window | Independent OS window |
| Embedded Window | `Window` without native window | Rendered within parent viewport |

```mermaid
graph TB
    subgraph "Window Hierarchy"
        RootWindow["Root Window<br/>(SceneTree Root)"]
        EmbeddedWindow["Embedded Window"]
        NativeWindow["Native Window"]
    end
    
    subgraph "Display Integration"
        DisplayServer["DisplayServer"]
        EmbedderViewport["Embedder Viewport"]
    end
    
    RootWindow --> DisplayServer
    NativeWindow --> DisplayServer
    EmbeddedWindow --> EmbedderViewport
    
    RootWindow -->|"child"| EmbeddedWindow
    RootWindow -->|"child"| NativeWindow
    
    style RootWindow fill:#f9f9f9
    style DisplayServer fill:#f9f9f9
```

**Diagram: Window Types and Embedding**

### Subwindow Management

Parent viewports manage embedded subwindows through:

- **Registration**: `_sub_window_register()` adds window to parent [scene/main/viewport.cpp:308-340]()
- **Ordering**: Z-order management for always-on-top and focus [scene/main/viewport.cpp:270-306]()
- **Input Routing**: Parent viewport routes input to focused subwindow [scene/main/viewport.cpp:404-476]()

Sources: [scene/main/window.h:43-44](), [scene/main/window.cpp:295-599](), [scene/main/viewport.cpp:245-539]()

## SceneTree Orchestration

The `SceneTree` class (inheriting from `MainLoop`) is the central orchestrator that:

1. **Manages Root Node**: Owns the root viewport [scene/main/scene_tree.h:252-253]()
2. **Processes Frames**: Calls physics and idle processing on nodes [scene/main/scene_tree.cpp:453-665]()
3. **Handles Groups**: Manages named node groups for batch operations [scene/main/scene_tree.cpp:167-191]()
4. **Coordinates Events**: Distributes input events, notifications, and callbacks
5. **Manages Scene Loading**: Supports changing and reloading scenes [scene/main/scene_tree.cpp:1211-1335]()

```mermaid
sequenceDiagram
    participant OS
    participant MainLoop
    participant SceneTree
    participant Nodes
    
    OS->>MainLoop: iteration()
    MainLoop->>SceneTree: physics_process(delta)
    SceneTree->>Nodes: NOTIFICATION_PHYSICS_PROCESS
    Nodes->>Nodes: _physics_process(delta)
    
    MainLoop->>SceneTree: process(delta)
    SceneTree->>Nodes: NOTIFICATION_PROCESS
    Nodes->>Nodes: _process(delta)
    
    SceneTree->>SceneTree: flush_transform_notifications()
    SceneTree->>SceneTree: _flush_accessibility_changes()
```

**Diagram: SceneTree Frame Processing Sequence**

### Group System

Nodes can be added to multiple named groups, enabling batch operations:

- `call_group(group, method, ...)`: Call method on all nodes in group [scene/main/scene_tree.cpp:350-434]()
- `get_nodes_in_group(group)`: Retrieve all nodes in group [scene/main/scene_tree.cpp:662-681]()
- Groups are stored in `SceneTree::group_map` [scene/main/scene_tree.h:135-144]()

Sources: [scene/main/scene_tree.h:231-232](), [scene/main/scene_tree.cpp:144-434](), [doc/classes/SceneTree.xml:3-10]()

## Key Interactions

### Node Addition Flow

```mermaid
flowchart TD
    Start["add_child(node)"]
    ValidateParent["Check parent not null"]
    ValidateInTree["Check node not in tree"]
    AddToChildren["Add to children map"]
    PropagateEnter["_propagate_enter_tree()"]
    SetParent["Set data.parent"]
    SetTree["Set data.tree"]
    SetViewport["Find parent viewport"]
    AddGroups["Register groups with tree"]
    NotifyEnter["NOTIFICATION_ENTER_TREE"]
    EmitEnter["emit('tree_entered')"]
    NotifyTree["tree->node_added(this)"]
    PropagateChildren["Propagate to children"]
    PropagateReady["_propagate_ready()"]
    NotifyReady["NOTIFICATION_READY"]
    EmitReady["emit('ready')"]
    
    Start --> ValidateParent
    ValidateParent --> ValidateInTree
    ValidateInTree --> AddToChildren
    AddToChildren --> PropagateEnter
    PropagateEnter --> SetParent
    SetParent --> SetTree
    SetTree --> SetViewport
    SetViewport --> AddGroups
    AddGroups --> NotifyEnter
    NotifyEnter --> EmitEnter
    EmitEnter --> NotifyTree
    NotifyTree --> PropagateChildren
    PropagateChildren --> PropagateReady
    PropagateReady --> NotifyReady
    NotifyReady --> EmitReady
```

**Diagram: Complete Node Addition Flow**

Sources: [scene/main/node.cpp:1437-1595](), [scene/main/node.cpp:335-383](), [scene/main/node.cpp:317-333]()

### Input Event Propagation

Input events flow through the scene tree in a specific order:

1. **Viewport Receives Event**: From OS or parent viewport
2. **GUI Processing**: Controls process input before general nodes [scene/main/viewport.cpp:2779-3568]()
3. **Node Input Callbacks**: In order:
   - `_input()` for all nodes
   - `_shortcut_input()` for shortcut handling
   - `_unhandled_key_input()` for keyboard
   - `_unhandled_input()` for remaining events
4. **Event Handling**: Nodes can call `Viewport.set_input_as_handled()` to stop propagation

Sources: [scene/main/viewport.cpp:2779-3568](), [doc/classes/Node.xml:72-150]()

## Summary

The Scene System provides a flexible, hierarchical architecture for organizing game objects:

- **Nodes** form the tree structure with well-defined lifecycle callbacks
- **SceneTree** orchestrates processing and manages the node hierarchy
- **Viewports** serve as rendering targets and input boundaries
- **Controls** extend nodes with UI-specific layout and theming
- **Windows** manage native or embedded window contexts

This architecture enables efficient scene management, clear separation of concerns, and powerful batch operations through the group system.

For detailed information on specific aspects:
- Node tree operations and callbacks: [Node Hierarchy](#4.1)
- Frame processing and tree management: [SceneTree & MainLoop](#4.2)
- Rendering and input handling: [Viewport System](#4.3)
- UI layout and controls: [Control & UI System](#4.4)
- Window creation and embedding: [Window Management](#4.5)23:T486a,# Node Hierarchy

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/os/main_loop.cpp](core/os/main_loop.cpp)
- [core/os/main_loop.h](core/os/main_loop.h)
- [doc/classes/Control.xml](doc/classes/Control.xml)
- [doc/classes/MainLoop.xml](doc/classes/MainLoop.xml)
- [doc/classes/Node.xml](doc/classes/Node.xml)
- [doc/classes/SceneTree.xml](doc/classes/SceneTree.xml)
- [doc/classes/Viewport.xml](doc/classes/Viewport.xml)
- [doc/classes/Window.xml](doc/classes/Window.xml)
- [scene/gui/control.cpp](scene/gui/control.cpp)
- [scene/gui/control.h](scene/gui/control.h)
- [scene/main/node.cpp](scene/main/node.cpp)
- [scene/main/node.h](scene/main/node.h)
- [scene/main/scene_tree.cpp](scene/main/scene_tree.cpp)
- [scene/main/scene_tree.h](scene/main/scene_tree.h)
- [scene/main/viewport.cpp](scene/main/viewport.cpp)
- [scene/main/viewport.h](scene/main/viewport.h)
- [scene/main/window.cpp](scene/main/window.cpp)
- [scene/main/window.h](scene/main/window.h)

</details>



## Purpose and Scope

This document describes the node tree structure that forms the foundation of Godot's scene system. It covers the `Node` class as the base for all scene objects, parent-child relationships, tree operations (adding/removing/reordering nodes), node lifecycle callbacks, and the group system.

For information about the SceneTree singleton that manages the active node tree and processes nodes each frame, see [SceneTree & MainLoop](#4.2). For information about specific node types like Control or Viewport, see [Control & UI System](#4.4) and [Viewport System](#4.3).

## Tree Structure Fundamentals

### Node as Base Class

The `Node` class ([scene/main/node.h:50-51]()) is the base class for all scene objects in Godot. Nodes are organized in a tree structure where each node can have one parent and multiple children. This hierarchical organization is fundamental to how Godot structures scenes and manages object relationships.

```mermaid
graph TB
    Node["Node<br/>(Base Class)"]
    Node --> Node2D
    Node --> Node3D
    Node --> Control
    Node --> Viewport
    
    Node2D["Node2D<br/>(2D nodes)"]
    Node3D["Node3D<br/>(3D nodes)"]
    Control["Control<br/>(UI nodes)"]
    Viewport["Viewport<br/>(rendering targets)"]
    
    Node2D --> Sprite2D
    Node2D --> CollisionObject2D
    Node3D --> MeshInstance3D
    Node3D --> Camera3D
    Control --> Button
    Control --> Label
```

**Diagram: Node class hierarchy and major derived types**

Sources: [scene/main/node.h:50-51](), [scene/main/node.cpp:30-52]()

### Parent-Child Relationships

Each node maintains references to its parent and children through the internal `Data` structure:

| Field | Type | Purpose |
|-------|------|---------|
| `data.parent` | `Node*` | Pointer to parent node (null for root) |
| `data.children` | `HashMap<StringName, Node*>` | Children indexed by name |
| `data.children_cache` | `LocalVector<Node*>` | Cached ordered list of children |
| `data.tree` | `SceneTree*` | Pointer to the SceneTree when inside tree |
| `data.depth` | `int32_t` | Distance from root (-1 when not in tree) |
| `data.index` | `int` | Position among siblings |

Sources: [scene/main/node.h:195-215]()

The tree structure is established when nodes enter the tree via `_propagate_enter_tree()`:

```mermaid
graph LR
    A["Parent Node"] -->|"data.parent points up"| B["Child 1"]
    A -->|"data.parent points up"| C["Child 2"]
    A -->|"data.parent points up"| D["Child 3"]
    
    A -.->|"data.children contains"| B
    A -.->|"data.children contains"| C
    A -.->|"data.children contains"| D
    
    B -->|"data.tree == tree"| Tree[SceneTree]
    C -->|"data.tree == tree"| Tree
    D -->|"data.tree == tree"| Tree
```

**Diagram: Node parent-child pointer relationships**

Sources: [scene/main/node.cpp:335-383]()

## Adding and Removing Children

### Adding Children with add_child()

The `add_child()` method ([doc/classes/Node.xml:152-178]()) adds a node as a child. The method signature allows specifying internal mode:

```
add_child(node: Node, force_readable_name: bool = false, internal: InternalMode = 0)
```

Internal implementation ([scene/main/node.cpp:1668-1823]()):
1. Validates the child node (must not already have a parent)
2. Generates a unique name if necessary
3. Sets parent pointer (`child->data.parent = this`)
4. Adds to children HashMap and cache
5. Calls `_propagate_enter_tree()` if parent is in tree

```mermaid
flowchart TD
    Start["add_child(node)"] --> Validate["Validate node<br/>(no existing parent)"]
    Validate --> Name["Generate unique name<br/>via _validate_child_name()"]
    Name --> AddToHash["Add to data.children HashMap"]
    AddToHash --> SetParent["node->data.parent = this"]
    SetParent --> InTree{"Parent in tree?"}
    InTree -->|Yes| PropEnter["node->_propagate_enter_tree()"]
    InTree -->|No| Done
    PropEnter --> Notify["Notification callbacks"]
    Notify --> Done[Done]
```

**Diagram: add_child() execution flow**

Sources: [scene/main/node.cpp:1668-1823]()

### Internal Children

Nodes support three internal modes ([scene/main/node.h:120-124]()):

| Mode | Value | Purpose |
|------|-------|---------|
| `INTERNAL_MODE_DISABLED` | 0 | Normal (external) child |
| `INTERNAL_MODE_FRONT` | 1 | Internal child at front of list |
| `INTERNAL_MODE_BACK` | 2 | Internal child at back of list |

Internal children are used by GUI nodes to hide implementation details from users. For example, `ColorPicker` uses internal children for its UI components. Methods like `get_children()` exclude internal children by default unless `include_internal` is true.

The children cache maintains three counts ([scene/main/node.h:208-210]()):
- `internal_children_front_count_cache`: Count of front internal children
- `internal_children_back_count_cache`: Count of back internal children  
- `external_children_count_cache`: Count of normal children

Child ordering: `[internal_front] [external] [internal_back]`

Sources: [scene/main/node.h:120-124](), [scene/main/node.h:208-210](), [doc/classes/Node.xml:160]()

### Removing Children with remove_child()

The `remove_child()` method ([scene/main/node.cpp:1825-1852]()) removes a child from the tree:

1. Validates child is actually a child of this node
2. Calls `_propagate_exit_tree()` if in tree
3. Removes from `data.children` HashMap
4. Clears `child->data.parent`
5. Calls `_propagate_after_exit_tree()`

Sources: [scene/main/node.cpp:1825-1852]()

### Moving Children with move_child()

The `move_child()` method ([scene/main/node.cpp:497-523]()) changes a child's position among siblings. It updates the `children_cache` array and recalculates indices for affected nodes. The method respects internal mode boundaries - internal children can only be moved within their own section.

Sources: [scene/main/node.cpp:497-580]()

## Node Lifecycle

### Lifecycle Stages

When a node enters and exits the tree, it goes through specific lifecycle stages with corresponding notifications and callbacks:

```mermaid
stateDiagram-v2
    [*] --> Orphan: Node created
    Orphan --> EnterTree: add_child() called on parent in tree
    EnterTree --> Ready: All children entered tree
    Ready --> Processing: _ready() completes
    Processing --> ExitTree: remove_child() or parent removed
    ExitTree --> Orphan: After exit callbacks
    Orphan --> [*]: Node deleted
```

**Diagram: Node lifecycle state transitions**

Sources: [scene/main/node.cpp:99-314]()

### Enter Tree Sequence

When `add_child()` adds a node to a parent that's already in the tree, `_propagate_enter_tree()` is called ([scene/main/node.cpp:335-383]()):

```mermaid
sequenceDiagram
    participant P as Parent
    participant N as Node
    participant C1 as Child 1
    participant C2 as Child 2
    
    P->>N: _propagate_enter_tree()
    N->>N: Set data.tree = parent->data.tree
    N->>N: Set data.depth = parent->data.depth + 1
    N->>N: Set data.viewport
    N->>N: Add to groups
    N->>N: NOTIFICATION_ENTER_TREE
    N->>N: _enter_tree() callback
    N->>N: emit "tree_entered" signal
    N->>C1: _propagate_enter_tree()
    N->>C2: _propagate_enter_tree()
    C1->>C1: (recursive process)
    C2->>C2: (recursive process)
```

**Diagram: _propagate_enter_tree() execution sequence**

Sources: [scene/main/node.cpp:335-383]()

Key operations during tree entry:
1. Set `data.tree` to parent's SceneTree pointer
2. Set `data.depth` to parent depth + 1
3. Set `data.viewport` to nearest Viewport ancestor
4. Add to groups (registered with SceneTree)
5. Send `NOTIFICATION_ENTER_TREE` ([scene/main/node.cpp:99-177]())
6. Call virtual `_enter_tree()` callback
7. Emit `tree_entered` signal
8. Recursively propagate to children

Sources: [scene/main/node.cpp:335-383]()

### Ready Propagation

After all nodes finish entering the tree, `_propagate_ready()` is called ([scene/main/node.cpp:317-333]()):

```mermaid
graph TB
    Root[Root Node] -->|1. First enter tree| A[Child A]
    Root -->|2. Enter tree| B[Child B]
    A -->|3. Enter tree| A1[Grandchild A1]
    A -->|4. Enter tree| A2[Grandchild A2]
    
    A2 -.->|5. Ready first| ReadyA2["_ready() on A2"]
    A1 -.->|6. Ready| ReadyA1["_ready() on A1"]
    A -.->|7. Ready| ReadyA["_ready() on A"]
    B -.->|8. Ready| ReadyB["_ready() on B"]
    Root -.->|9. Ready last| ReadyRoot["_ready() on Root"]
```

**Diagram: Ready callback order (children before parents)**

The `_propagate_ready()` method recursively calls children first, then sends `NOTIFICATION_POST_ENTER_TREE`, and finally `NOTIFICATION_READY` with the `_ready()` callback and `ready` signal emission.

This bottom-up order ensures children are fully initialized before their parents process the ready notification.

Sources: [scene/main/node.cpp:317-333](), [doc/classes/Node.xml:9-11]()

### Exit Tree Sequence

When a node exits the tree via `remove_child()` or parent removal, `_propagate_exit_tree()` is called ([scene/main/node.cpp:404-451]()):

```mermaid
sequenceDiagram
    participant N as Node
    participant C1 as Child 1
    participant C2 as Child 2
    participant ST as SceneTree
    
    N->>C1: _propagate_exit_tree()
    N->>C2: _propagate_exit_tree()
    C1->>C1: (recursive for children)
    C2->>C2: (recursive for children)
    N->>N: _exit_tree() callback
    N->>N: emit "tree_exiting" signal
    N->>N: NOTIFICATION_EXIT_TREE
    N->>ST: node_removed(this)
    N->>N: Remove from groups
    N->>N: Clear data.tree = null
    N->>N: Clear data.viewport = null
    N->>N: Set data.depth = -1
```

**Diagram: _propagate_exit_tree() execution sequence**

After `_propagate_exit_tree()` completes, `_propagate_after_exit_tree()` is called to emit the `tree_exited` signal and clean up owner relationships ([scene/main/node.cpp:385-402]()).

Sources: [scene/main/node.cpp:404-451](), [scene/main/node.cpp:385-402]()

### Lifecycle Virtual Methods

| Method | When Called | Use Case |
|--------|-------------|----------|
| `_enter_tree()` | When node enters SceneTree | Initialize tree-dependent state |
| `_ready()` | After node and children enter tree | Initialize after full subtree ready |
| `_exit_tree()` | Before node exits SceneTree | Clean up tree-dependent state |
| `_process(delta)` | Every frame (if enabled) | Frame-by-frame logic |
| `_physics_process(delta)` | Every physics tick (if enabled) | Physics-rate logic |

Sources: [doc/classes/Node.xml:25-150]()

## Tree Navigation

### Parent and Child Access

The Node class provides methods to navigate the tree hierarchy:

| Method | Returns | Purpose |
|--------|---------|---------|
| `get_parent()` | `Node*` | Returns parent node or null if root |
| `get_child(index)` | `Node*` | Returns child at given index |
| `get_child_count(include_internal)` | `int` | Returns number of children |
| `get_children(include_internal)` | `Array[Node]` | Returns array of all children |
| `get_index(include_internal)` | `int` | Returns this node's index among siblings |
| `find_child(pattern, recursive, owned)` | `Node*` | Searches for child matching pattern |
| `find_children(pattern, type, recursive, owned)` | `Array[Node]` | Finds all matching children |

Sources: [scene/main/node.h:426-442](), [doc/classes/Node.xml:285-382]()

### Node Paths

A `NodePath` ([core/string/node_path.h]()) is a string-based reference to a node in the tree. It uses `/` to separate levels, starting from the current node or from root with an absolute path.

Examples:
- `"Child"` - Direct child named "Child"
- `"Child/Grandchild"` - Nested path
- `"/root/Node"` - Absolute path from root
- `".."` - Parent node
- `"../Sibling"` - Sibling node

The `get_node()` method ([scene/main/node.cpp:2088-2182]()) resolves a NodePath to a Node pointer:

```mermaid
flowchart TD
    Start["get_node(path)"] --> Absolute{Absolute path?}
    Absolute -->|Yes /root/...| FindRoot["Start from SceneTree root"]
    Absolute -->|No| CurrentNode["Start from this node"]
    FindRoot --> Parse
    CurrentNode --> Parse["Parse path segments"]
    Parse --> Traverse["Traverse tree following path"]
    Traverse --> Found{Node found?}
    Found -->|Yes| Return["Return Node*"]
    Found -->|No| Error["ERR_FAIL / return null"]
```

**Diagram: get_node() path resolution**

Sources: [scene/main/node.cpp:2088-2182](), [doc/classes/Node.xml:399-426]()

### Viewport and Tree Access

Every node in the tree maintains a reference to its nearest `Viewport` ancestor and the `SceneTree` singleton:

- `get_viewport()`: Returns nearest Viewport ancestor ([scene/main/node.cpp:346-348]())
- `get_tree()`: Returns SceneTree singleton when in tree ([scene/main/node.h:392]())
- `is_inside_tree()`: Returns true if `data.tree != nullptr`

The viewport reference is set during `_propagate_enter_tree()` ([scene/main/node.cpp:345-348]()).

Sources: [scene/main/node.cpp:345-348](), [scene/main/node.h:392-394]()

## Groups

Groups provide a way to tag nodes and perform operations on all nodes in a group simultaneously. A node can belong to any number of groups.

### Group Operations

| Method | Purpose |
|--------|---------|
| `add_to_group(group, persistent)` | Adds this node to a group |
| `remove_from_group(group)` | Removes this node from a group |
| `is_in_group(group)` | Checks if node is in group |
| `get_groups()` | Returns array of groups this node belongs to |

Sources: [scene/main/node.h:474-477](), [doc/classes/Node.xml:153-194]()

### Group Registration

Groups are managed by the SceneTree. When a node enters the tree, its groups are registered with the SceneTree's group map ([scene/main/node.cpp:350-352]()):

```cpp
for (KeyValue<StringName, GroupData> &E : data.grouped) {
    E.value.group = data.tree->add_to_group(E.key, this);
}
```

The SceneTree maintains a `HashMap<StringName, Group>` where each Group contains a list of nodes ([scene/main/scene_tree.h:74-78]()).

When a node exits the tree, it is removed from all groups ([scene/main/node.cpp:437-440]()).

Sources: [scene/main/node.cpp:350-352](), [scene/main/node.cpp:437-440](), [scene/main/scene_tree.h:74-78]()

### Calling Methods on Groups

The SceneTree provides methods to call functions on all nodes in a group:

- `call_group(group, method, ...)`: Calls method on all nodes in group
- `call_group_flags(flags, group, method, ...)`: Calls with flags (deferred, reverse order, etc.)

Example flags ([scene/main/scene_tree.h:101-106]()):
- `GROUP_CALL_DEFAULT`: Normal call
- `GROUP_CALL_REVERSE`: Call in reverse tree order
- `GROUP_CALL_DEFERRED`: Call at end of frame
- `GROUP_CALL_UNIQUE`: Only one call per frame

Sources: [scene/main/scene_tree.cpp:350-413](), [scene/main/scene_tree.h:101-106](), [doc/classes/SceneTree.xml:16-40]()

## Owner System

### Owner Concept

The `owner` property ([scene/main/node.h:201]()) tracks which node "owns" a subtree for scene persistence purposes. When a scene is saved, only nodes with their owner set to the scene root are saved.

```mermaid
graph TB
    Root["Root<br/>(owner=null)"]
    Root -->|owner=Root| A["Child A<br/>(saved)"]
    Root -->|owner=Root| B["Child B<br/>(saved)"]
    A -->|owner=Root| C["Grandchild<br/>(saved)"]
    A -->|owner=null| D["Runtime Node<br/>(NOT saved)"]
    
    style D fill:#f9f9f9,stroke:#999,stroke-dasharray: 5 5
```

**Diagram: Owner relationships and scene persistence**

Sources: [scene/main/node.h:201](), [doc/classes/Node.xml:921-930]()

### Owner Operations

| Method | Purpose |
|--------|---------|
| `set_owner(owner)` | Sets the owner node |
| `get_owner()` | Gets the owner node |
| `is_owned_by_parent()` | Checks if owner is parent |

The owner system is crucial for:
1. **Scene instancing**: Instanced scenes track which nodes belong to the instance
2. **Scene persistence**: Only nodes with owner set are saved with the scene
3. **Editor tools**: The editor uses owner to determine which nodes are editable

Sources: [scene/main/node.cpp:289-307](), [doc/classes/Node.xml:921-930]()

### Unique Name in Owner

Nodes can be marked with `unique_name_in_owner = true` ([scene/main/node.h:206]()). These nodes can be accessed via `%NodeName` syntax in paths, searching up the owner chain.

Example: `get_node("%Player")` finds the first ancestor or descendant of the owner marked as unique with name "Player".

Sources: [scene/main/node.h:206](), [scene/main/node.cpp:2088-2182]()

## Tree Depth and Ordering

### Depth Calculation

Node depth is the distance from the root node, set during `_propagate_enter_tree()` ([scene/main/node.cpp:340-343]()):

```cpp
if (data.parent) {
    data.tree = data.parent->data.tree;
    data.depth = data.parent->data.depth + 1;
} else {
    data.depth = 1;
}
```

Root nodes have depth 1. When a node exits the tree, depth is reset to -1.

Sources: [scene/main/node.cpp:340-343](), [scene/main/node.cpp:450]()

### Child Ordering

Children maintain an index within their parent's child list. The `Comparator` struct ([scene/main/node.h:132-134]()) defines tree order used for processing:

```cpp
struct Comparator {
    bool operator()(const Node *p_a, const Node *p_b) const { 
        return p_b->is_greater_than(p_a); 
    }
};
```

The `is_greater_than()` method compares nodes by traversing up to common ancestor and comparing child indices at that level ([scene/main/node.cpp:1095-1143]()).

Processing order follows tree structure (depth-first, pre-order traversal), with priority values optionally modifying order within each level.

Sources: [scene/main/node.h:132-134](), [scene/main/node.cpp:1095-1143]()24:T53bc,# SceneTree & MainLoop

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/os/main_loop.cpp](core/os/main_loop.cpp)
- [core/os/main_loop.h](core/os/main_loop.h)
- [doc/classes/Control.xml](doc/classes/Control.xml)
- [doc/classes/MainLoop.xml](doc/classes/MainLoop.xml)
- [doc/classes/Node.xml](doc/classes/Node.xml)
- [doc/classes/SceneTree.xml](doc/classes/SceneTree.xml)
- [doc/classes/Viewport.xml](doc/classes/Viewport.xml)
- [doc/classes/Window.xml](doc/classes/Window.xml)
- [scene/gui/control.cpp](scene/gui/control.cpp)
- [scene/gui/control.h](scene/gui/control.h)
- [scene/main/node.cpp](scene/main/node.cpp)
- [scene/main/node.h](scene/main/node.h)
- [scene/main/scene_tree.cpp](scene/main/scene_tree.cpp)
- [scene/main/scene_tree.h](scene/main/scene_tree.h)
- [scene/main/viewport.cpp](scene/main/viewport.cpp)
- [scene/main/viewport.h](scene/main/viewport.h)
- [scene/main/window.cpp](scene/main/window.cpp)
- [scene/main/window.h](scene/main/window.h)

</details>



## Purpose and Scope

This document describes the `MainLoop` abstract base class and its primary implementation `SceneTree`, which together manage the game's main execution loop in Godot Engine. The `SceneTree` orchestrates frame processing, node lifecycle management, group operations, and pause functionality. For information about individual nodes and their hierarchy, see [Node Hierarchy](#4.1). For viewport-specific rendering and input handling, see [Viewport System](#4.3).

## Architecture Overview

```mermaid
graph TB
    subgraph "Main Loop Interface"
        MainLoop["MainLoop<br/>(abstract base class)"]
    end
    
    subgraph "SceneTree Implementation"
        SceneTree["SceneTree<br/>(MainLoop implementation)"]
        Root["root: Window<br/>(scene tree root)"]
        CurrentScene["current_scene: Node<br/>(active scene root)"]
        Groups["group_map: HashMap<br/>(node groups)"]
        ProcessGroups["Processing Groups<br/>(organized nodes)"]
    end
    
    subgraph "Node Management"
        Nodes["Nodes in Tree<br/>(scene hierarchy)"]
        ProcessOwner["process_owner<br/>(pause management)"]
        ProcessThreadGroup["process_thread_group_owner<br/>(threading)"]
    end
    
    MainLoop --> SceneTree
    SceneTree --> Root
    SceneTree --> CurrentScene
    SceneTree --> Groups
    SceneTree --> ProcessGroups
    SceneTree --> Nodes
    
    Nodes --> ProcessOwner
    Nodes --> ProcessThreadGroup
```

**Diagram 1: MainLoop and SceneTree Architecture**

Sources: [scene/main/scene_tree.h:36-382](), [scene/main/scene_tree.cpp:31-51](), [core/os/main_loop.h:36-70]()

## MainLoop Abstract Base

`MainLoop` defines the interface for Godot's main execution loop. It is an abstract class that custom game loops can extend, though `SceneTree` is the default implementation.

### Core Interface Methods

| Method | Purpose | Return Value |
|--------|---------|--------------|
| `initialize()` | Called once at startup | void |
| `physics_process(double p_time)` | Called each physics tick | bool (true to quit) |
| `process(double p_time)` | Called each idle frame | bool (true to quit) |
| `finalize()` | Called before shutdown | void |

The virtual methods are implemented via `GDVIRTUAL` bindings, allowing script-based implementations to override them:

```mermaid
graph LR
    Start["Engine Start"] --> Initialize["_initialize()"]
    Initialize --> MainLoop["Main Loop"]
    
    MainLoop --> PhysicsStep["_physics_process(delta)"]
    PhysicsStep --> ProcessStep["_process(delta)"]
    ProcessStep --> CheckQuit{"Return true?"}
    CheckQuit -->|No| MainLoop
    CheckQuit -->|Yes| Finalize["_finalize()"]
    Finalize --> End["Engine Shutdown"]
```

**Diagram 2: MainLoop Execution Flow**

Sources: [core/os/main_loop.h:36-70](), [core/os/main_loop.cpp:53-75]()

## SceneTree Implementation

`SceneTree` is the concrete `MainLoop` implementation that manages a tree of `Node` objects. It is responsible for:

- Managing the node hierarchy and root window
- Processing nodes each frame (physics and idle)
- Managing node groups for batch operations
- Handling pause state
- Scene loading and switching
- Timer management
- Input event routing to nodes

### Key Data Structures

```mermaid
graph TB
    SceneTree["SceneTree"]
    
    subgraph "Tree Structure"
        Root["root: Window*"]
        CurrentScene["current_scene: Node*"]
        NodesInTree["nodes_in_tree_count: int"]
    end
    
    subgraph "Group Management"
        GroupMap["group_map: HashMap<StringName, Group>"]
        GroupStruct["Group {<br/>nodes: Vector<Node*><br/>changed: bool<br/>}"]
    end
    
    subgraph "Processing"
        ProcessGroup["default_process_group"]
        ProcessThreadGroups["process_thread_groups: List"]
        XFormChangeList["xform_change_list: SelfList"]
    end
    
    subgraph "Timers"
        Timers["timers: List<SceneTreeTimer*>"]
        TimersInactive["timers_inactive: List"]
    end
    
    subgraph "State"
        Paused["paused: bool"]
        Suspended["suspended: bool"]
        PhysicsFrame["physics_process_time: uint64_t"]
        ProcessFrame["process_time: uint64_t"]
    end
    
    SceneTree --> Root
    SceneTree --> CurrentScene
    SceneTree --> GroupMap
    SceneTree --> ProcessGroup
    SceneTree --> Timers
    SceneTree --> Paused
    
    GroupMap --> GroupStruct
```

**Diagram 3: SceneTree Data Structure**

Sources: [scene/main/scene_tree.h:57-382](), [scene/main/scene_tree.cpp:144-165]()

## Frame Processing Loop

The `SceneTree` implements two types of frame updates: physics frames (fixed timestep) and idle frames (variable timestep).

### Physics Frame Processing

The `physics_process()` method is called at a fixed rate (default 60 FPS) and handles:

1. **Pre-processing**: Updates physics time, checks suspension
2. **Group processing**: Processes nodes with `NOTIFICATION_INTERNAL_PHYSICS_PROCESS` and `NOTIFICATION_PHYSICS_PROCESS`
3. **Physics server step**: Advances physics simulation
4. **Post-processing**: Handles deferred calls, flushes transform notifications

```mermaid
graph TD
    Start["physics_process(delta)"] --> CheckSuspended{"suspended?"}
    CheckSuspended -->|Yes| Return["return false"]
    CheckSuspended -->|No| UpdateTime["Update physics_process_time"]
    
    UpdateTime --> ProcessInternal["Process NOTIFICATION_INTERNAL_PHYSICS_PROCESS<br/>_process_group(true, paused)"]
    ProcessInternal --> ProcessRegular["Process NOTIFICATION_PHYSICS_PROCESS<br/>_process_group(false, paused)"]
    
    ProcessRegular --> Physics2D["PhysicsServer2D::flush_queries()"]
    Physics2D --> Physics3D["PhysicsServer3D::flush_queries()"]
    Physics3D --> NavigationServer2D["NavigationServer2D::process()"]
    NavigationServer2D --> NavigationServer3D["NavigationServer3D::process()"]
    
    NavigationServer3D --> FlushCalls["MessageQueue::flush()"]
    FlushCalls --> FlushTransforms["flush_transform_notifications()"]
    FlushTransforms --> FlushUGC["_flush_ugc()"]
    FlushUGC --> Return
```

**Diagram 4: Physics Frame Processing Flow**

Sources: [scene/main/scene_tree.cpp:1222-1317]()

### Idle Frame Processing

The `process()` method is called each frame (variable rate) and handles:

1. **Pre-processing**: Updates process time, handles timers
2. **Group processing**: Processes nodes with `NOTIFICATION_INTERNAL_PROCESS` and `NOTIFICATION_PROCESS`
3. **Post-processing**: Flushes calls, cleans up deleted nodes

```mermaid
graph TD
    Start["process(delta)"] --> CheckSuspended{"suspended?"}
    CheckSuspended -->|Yes| Return["return false"]
    CheckSuspended -->|No| UpdateTime["Update process_time"]
    
    UpdateTime --> ProcessTimers["Process timers<br/>(SceneTreeTimer objects)"]
    ProcessTimers --> CheckQuit1{"quit_on_go_back?"}
    CheckQuit1 -->|Yes| Return
    CheckQuit1 -->|No| ProcessInternal["Process NOTIFICATION_INTERNAL_PROCESS<br/>_process_group(true, paused)"]
    
    ProcessInternal --> ProcessRegular["Process NOTIFICATION_PROCESS<br/>_process_group(false, paused)"]
    ProcessRegular --> FlushTransforms["flush_transform_notifications()"]
    FlushTransforms --> FlushCalls["MessageQueue::flush()"]
    FlushCalls --> FlushTimers["Move inactive timers"]
    FlushTimers --> ProcessTweens["Tween::process_tweens()"]
    ProcessTweens --> FlushUGC["_flush_ugc()"]
    FlushUGC --> FlushAccessibility["_flush_accessibility_changes()"]
    FlushAccessibility --> FlushDelete["_flush_delete_queue()"]
    FlushDelete --> CheckQuit2{"quit request?"}
    CheckQuit2 -->|Yes| ReturnTrue["return true"]
    CheckQuit2 -->|No| Return
```

**Diagram 5: Idle Frame Processing Flow**

Sources: [scene/main/scene_tree.cpp:820-1006]()

## Node Processing System

Nodes participate in frame processing through their process callbacks. The `SceneTree` manages which nodes get processed based on their configuration.

### Process Modes

Nodes have a `process_mode` property that determines when they are processed:

| Process Mode | Behavior |
|--------------|----------|
| `PROCESS_MODE_INHERIT` | Inherits from parent node |
| `PROCESS_MODE_PAUSABLE` | Processes when tree is not paused |
| `PROCESS_MODE_WHEN_PAUSED` | Processes only when tree is paused |
| `PROCESS_MODE_ALWAYS` | Always processes regardless of pause state |
| `PROCESS_MODE_DISABLED` | Never processes |

```mermaid
graph TD
    Node["Node"] --> CheckMode{"process_mode"}
    CheckMode -->|INHERIT| ParentMode["Use parent's effective mode"]
    CheckMode -->|PAUSABLE| CheckPaused1{"tree.is_paused()?"}
    CheckMode -->|WHEN_PAUSED| CheckPaused2{"tree.is_paused()?"}
    CheckMode -->|ALWAYS| Process["Process"]
    CheckMode -->|DISABLED| Skip["Skip"]
    
    ParentMode --> CheckPaused1
    CheckPaused1 -->|Yes| Skip
    CheckPaused1 -->|No| Process
    CheckPaused2 -->|Yes| Process
    CheckPaused2 -->|No| Skip
```

**Diagram 6: Node Process Mode Decision**

Sources: [scene/main/node.cpp:663-771](), [scene/main/node.cpp:901-933]()

### Process Groups

The `SceneTree` organizes nodes into processing groups for efficient iteration:

```mermaid
graph LR
    subgraph "Process Group Organization"
        ProcessGroup["ProcessGroup"] --> InternalNodes["internal_nodes<br/>(NOTIFICATION_INTERNAL_PROCESS)"]
        ProcessGroup --> RegularNodes["nodes<br/>(NOTIFICATION_PROCESS)"]
        ProcessGroup --> InternalPhysicsNodes["internal_physics_nodes<br/>(NOTIFICATION_INTERNAL_PHYSICS_PROCESS)"]
        ProcessGroup --> PhysicsNodes["physics_nodes<br/>(NOTIFICATION_PHYSICS_PROCESS)"]
    end
    
    Node1["Node A<br/>process_priority: 10"] --> RegularNodes
    Node2["Node B<br/>process_priority: 5"] --> RegularNodes
    Node3["Node C<br/>process_internal: true"] --> InternalNodes
```

**Diagram 7: Node Processing Groups**

Nodes are sorted by priority within their groups, with lower priority values processed first:

```mermaid
graph TD
    ProcessGroup["_process_group(internal, paused)"] --> GetList{"internal?"}
    GetList -->|Yes| InternalList["Use internal_nodes list"]
    GetList -->|No| RegularList["Use nodes list"]
    
    InternalList --> SortCheck
    RegularList --> SortCheck
    
    SortCheck["Check if list needs sorting"] --> SortNodes["Sort by process_priority<br/>(lower values first)"]
    SortNodes --> IterateNodes["for each node in list"]
    
    IterateNodes --> CheckCanProcess{"node.can_process(paused)?"}
    CheckCanProcess -->|Yes| Notify["node.notification(NOTIFICATION_*)"]
    CheckCanProcess -->|No| NextNode
    Notify --> NextNode["Next node"]
    NextNode --> IterateNodes
```

**Diagram 8: Group Processing Algorithm**

Sources: [scene/main/scene_tree.cpp:1008-1120](), [scene/main/node.cpp:611-661]()

### Process Thread Groups

Nodes can be organized into thread groups for multi-threaded processing:

| Thread Group Mode | Behavior |
|-------------------|----------|
| `PROCESS_THREAD_GROUP_INHERIT` | Inherits from parent |
| `PROCESS_THREAD_GROUP_MAIN_THREAD` | Creates main thread group |
| `PROCESS_THREAD_GROUP_SUB_THREAD` | Creates sub-thread group |

Sources: [scene/main/node.h:83-93](), [scene/main/node.cpp:99-145]()

## Group System

Groups allow batch operations on sets of nodes. Nodes can belong to multiple groups simultaneously.

### Group Operations

The `SceneTree` provides methods to call functions on all nodes in a group:

| Method | Description |
|--------|-------------|
| `call_group(group, method, ...)` | Calls method on all nodes in group immediately |
| `call_group_flags(flags, group, method, ...)` | Calls with control flags (deferred, reverse, unique) |
| `set_group(group, property, value)` | Sets property on all nodes in group |
| `notify_group(group, notification)` | Sends notification to all nodes in group |

```mermaid
graph TD
    CallGroup["call_group_flags(flags, group, method, args)"] --> FindGroup{"group exists?"}
    FindGroup -->|No| Return["return"]
    FindGroup -->|Yes| CheckFlags{"flags"}
    
    CheckFlags -->|UNIQUE + DEFERRED| AddToUGC["Add to unique_group_calls<br/>(deduplicates calls)"]
    CheckFlags -->|Other| UpdateOrder["_update_group_order()<br/>(sort nodes if changed)"]
    
    AddToUGC --> Return
    UpdateOrder --> CopyNodes["Copy nodes to local vector"]
    CopyNodes --> LockRemoval["nodes_removed_on_group_call_lock++"]
    
    LockRemoval --> CheckReverse{"REVERSE flag?"}
    CheckReverse -->|Yes| ReverseIterate["Iterate nodes backwards"]
    CheckReverse -->|No| ForwardIterate["Iterate nodes forwards"]
    
    ReverseIterate --> CheckRemoved{"node removed?"}
    ForwardIterate --> CheckRemoved
    CheckRemoved -->|Yes| Skip["Skip node"]
    CheckRemoved -->|No| CheckDeferred{"DEFERRED flag?"}
    
    CheckDeferred -->|Yes| QueueCall["MessageQueue::push_callp()"]
    CheckDeferred -->|No| CallNow["node.callp(method, args)"]
    
    Skip --> Next
    QueueCall --> Next
    CallNow --> Next["Next node"]
    Next --> Unlock["nodes_removed_on_group_call_lock--"]
    Unlock --> Return
```

**Diagram 9: Group Call Processing**

Sources: [scene/main/scene_tree.cpp:350-434](), [scene/main/scene_tree.cpp:167-191]()

### Group Storage

```mermaid
graph LR
    SceneTree["SceneTree"] --> GroupMap["group_map:<br/>HashMap<StringName, Group>"]
    
    GroupMap --> Group1["Group: 'enemies'"]
    GroupMap --> Group2["Group: 'collectables'"]
    
    Group1 --> NodeList1["nodes: Vector<Node*>"]
    Group1 --> Changed1["changed: bool"]
    
    NodeList1 --> Enemy1["Enemy1"]
    NodeList1 --> Enemy2["Enemy2"]
    NodeList1 --> Enemy3["Enemy3"]
```

**Diagram 10: Group Data Structure**

Sources: [scene/main/scene_tree.h:108-112](), [scene/main/scene_tree.cpp:167-191]()

## Pause System

The pause system controls whether nodes are processed based on their `process_mode` setting.

### Pause State Management

```mermaid
graph TD
    SetPaused["set_paused(enable)"] --> CheckChange{"paused != enable?"}
    CheckChange -->|No| Return["return"]
    CheckChange -->|Yes| UpdateState["paused = enable"]
    
    UpdateState --> GetRoot["Get root node"]
    GetRoot --> Propagate["_propagate_pause_notification(enable)"]
    
    Propagate --> CheckNode["For each node in tree"]
    CheckNode --> CanProcessBefore["can_process(!enable)"]
    CheckNode --> CanProcessAfter["can_process(enable)"]
    
    CanProcessBefore --> Compare{"changed?"}
    CanProcessAfter --> Compare
    
    Compare -->|paused| SendPaused["Send NOTIFICATION_PAUSED"]
    Compare -->|unpaused| SendUnpaused["Send NOTIFICATION_UNPAUSED"]
    Compare -->|unchanged| NextNode
    
    SendPaused --> Children
    SendUnpaused --> Children
    Children["Propagate to children"] --> NextNode["Next node"]
    NextNode --> Return
```

**Diagram 11: Pause State Propagation**

Sources: [scene/main/scene_tree.cpp:1319-1352](), [scene/main/node.cpp:721-770]()

### Pause Effect on Processing

The `can_process()` method determines if a node should be processed:

| Process Mode | Paused = false | Paused = true |
|--------------|----------------|---------------|
| `PAUSABLE` | âœ“ Process | âœ— Skip |
| `WHEN_PAUSED` | âœ— Skip | âœ“ Process |
| `ALWAYS` | âœ“ Process | âœ“ Process |
| `DISABLED` | âœ— Skip | âœ— Skip |

Sources: [scene/main/node.cpp:901-933]()

## Tree Management

The `SceneTree` manages the node hierarchy and scene transitions.

### Node Lifecycle

```mermaid
graph TD
    AddChild["add_child(node)"] --> PropagateEnter["_propagate_enter_tree()"]
    
    PropagateEnter --> SetTree["node.data.tree = this"]
    SetTree --> SetDepth["node.data.depth = parent.depth + 1"]
    SetDepth --> AddGroups["Add node to groups"]
    AddGroups --> SendEnter["NOTIFICATION_ENTER_TREE"]
    SendEnter --> CallEnterTree["_enter_tree() callback"]
    CallEnterTree --> EmitSignal["emit 'tree_entered'"]
    EmitSignal --> TreeNodeAdded["tree.node_added(node)"]
    TreeNodeAdded --> ProcessChildren["Propagate to children"]
    
    ProcessChildren --> PropagateReady["_propagate_ready()"]
    PropagateReady --> SendReady["NOTIFICATION_READY"]
    SendReady --> CallReady["_ready() callback"]
    CallReady --> EmitReady["emit 'ready'"]
    
    RemoveChild["remove_child(node)"] --> PropagateExit["_propagate_exit_tree()"]
    PropagateExit --> ExitChildren["Propagate to children first"]
    ExitChildren --> CallExitTree["_exit_tree() callback"]
    CallExitTree --> SendExit["NOTIFICATION_EXIT_TREE"]
    SendExit --> TreeNodeRemoved["tree.node_removed(node)"]
    TreeNodeRemoved --> RemoveGroups["Remove from groups"]
    RemoveGroups --> ClearTree["node.data.tree = null"]
```

**Diagram 12: Node Lifecycle in Tree**

Sources: [scene/main/node.cpp:335-383](), [scene/main/node.cpp:404-451](), [scene/main/scene_tree.cpp:148-165]()

### Scene Changing

```mermaid
graph TD
    ChangeScene["change_scene_to_packed(packed_scene)"] --> CheckCurrent{"current_scene exists?"}
    CheckCurrent -->|Yes| RemoveCurrent["Remove current_scene from tree"]
    CheckCurrent -->|No| Instantiate
    
    RemoveCurrent --> QueueFree["Queue current_scene for deletion"]
    QueueFree --> Instantiate["packed_scene.instantiate()"]
    
    Instantiate --> CheckValid{"instance valid?"}
    CheckValid -->|No| Error["return ERR_CANT_CREATE"]
    CheckValid -->|Yes| SetCurrent["current_scene = instance"]
    
    SetCurrent --> AddToRoot["root.add_child(instance)"]
    AddToRoot --> Success["return OK"]
```

**Diagram 13: Scene Change Flow**

Sources: [scene/main/scene_tree.cpp:1384-1448]()

### Queue Deletion

Nodes scheduled for deletion via `queue_free()` are processed during the idle frame:

```mermaid
graph LR
    QueueFree["node.queue_free()"] --> AddToQueue["Add to delete_queue"]
    
    FlushDeleteQueue["_flush_delete_queue()"] --> LockQueue["delete_queue_lock++"]
    LockQueue --> IterateQueue["for each node in delete_queue"]
    
    IterateQueue --> CheckTree{"node in tree?"}
    CheckTree -->|Yes| RemoveNode["Remove from tree"]
    CheckTree -->|No| FreeNode
    RemoveNode --> FreeNode["Object.free(node)"]
    FreeNode --> NextDelete["Next node"]
    
    NextDelete --> ClearQueue["delete_queue.clear()"]
    ClearQueue --> UnlockQueue["delete_queue_lock--"]
```

**Diagram 14: Queue Deletion System**

Sources: [scene/main/scene_tree.cpp:1184-1220](), [scene/main/node.cpp:276-315]()

## Timers

The `SceneTree` provides a timer system for delayed/repeated callbacks via `SceneTreeTimer` objects.

### Timer Processing

```mermaid
graph TD
    CreateTimer["create_timer(time, process_always, process_in_physics)"] --> NewTimer["SceneTreeTimer* timer = new"]
    NewTimer --> SetProperties["timer.time_left = time<br/>timer.process_always = process_always<br/>timer.process_in_physics = process_in_physics"]
    SetProperties --> AddToList["timers.push_back(timer)"]
    
    ProcessTimers["Process timers (in process/physics_process)"] --> IterateTimers["for each timer in timers"]
    IterateTimers --> CheckProcessAlways{"timer.process_always?"}
    
    CheckProcessAlways -->|No| CheckPaused{"is_paused()?"}
    CheckProcessAlways -->|Yes| UpdateTime
    
    CheckPaused -->|Yes| SkipTimer["Skip this timer"]
    CheckPaused -->|No| UpdateTime["timer.time_left -= delta"]
    
    UpdateTime --> CheckDone{"time_left <= 0?"}
    CheckDone -->|No| NextTimer
    CheckDone -->|Yes| EmitTimeout["timer.emit 'timeout'"]
    EmitTimeout --> MarkInactive["Move to timers_inactive"]
    MarkInactive --> NextTimer["Next timer"]
    
    SkipTimer --> NextTimer
```

**Diagram 15: Timer System**

Sources: [scene/main/scene_tree.cpp:68-116](), [scene/main/scene_tree.cpp:877-909](), [scene/main/scene_tree.cpp:1269-1285]()

## Summary

The `SceneTree` and `MainLoop` system provides the core game loop infrastructure for Godot Engine:

| Component | Responsibility |
|-----------|---------------|
| `MainLoop` | Abstract interface for game loops |
| `SceneTree` | Concrete implementation managing node hierarchy |
| Physics Frame | Fixed-rate updates via `physics_process()` |
| Idle Frame | Variable-rate updates via `process()` |
| Process Groups | Organized node processing with priorities |
| Group System | Batch operations on node sets |
| Pause System | Selective node processing control |
| Scene Management | Loading, switching, and node lifecycle |
| Timers | Delayed callback system |

Sources: [scene/main/scene_tree.h:36-382](), [scene/main/scene_tree.cpp:1-2200](), [core/os/main_loop.h:36-70]()25:T7449,# Viewport System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/os/main_loop.cpp](core/os/main_loop.cpp)
- [core/os/main_loop.h](core/os/main_loop.h)
- [doc/classes/Control.xml](doc/classes/Control.xml)
- [doc/classes/MainLoop.xml](doc/classes/MainLoop.xml)
- [doc/classes/Node.xml](doc/classes/Node.xml)
- [doc/classes/SceneTree.xml](doc/classes/SceneTree.xml)
- [doc/classes/Viewport.xml](doc/classes/Viewport.xml)
- [doc/classes/Window.xml](doc/classes/Window.xml)
- [scene/gui/control.cpp](scene/gui/control.cpp)
- [scene/gui/control.h](scene/gui/control.h)
- [scene/main/node.cpp](scene/main/node.cpp)
- [scene/main/node.h](scene/main/node.h)
- [scene/main/scene_tree.cpp](scene/main/scene_tree.cpp)
- [scene/main/scene_tree.h](scene/main/scene_tree.h)
- [scene/main/viewport.cpp](scene/main/viewport.cpp)
- [scene/main/viewport.h](scene/main/viewport.h)
- [scene/main/window.cpp](scene/main/window.cpp)
- [scene/main/window.h](scene/main/window.h)

</details>



The Viewport system provides rendering targets, input event dispatch, and integration between the scene graph and rendering backend. Each `Viewport` ([scene/main/viewport.h:95]()) creates a rendering context through `RID viewport` that can:

1. **Render to screen or texture** - Output directly to display or to `ViewportTexture` for post-processing/reuse
2. **Route input events** - Dispatch input to GUI controls, Node scripts, and physics objects
3. **Manage World2D/World3D** - Associate 2D canvases and 3D scenarios with World resources for spatial partitioning

A viewport serves as the connection point between the scene tree's Nodes and the RenderingServer's rendering resources. `Window` extends `Viewport` to add OS window functionality.

For Node tree structure, see [Node Hierarchy](#4.1). For Control layout, see [Control & UI System](#4.4). For Window-specific features, see [Window Management](#4.5).

Sources: [scene/main/viewport.h:95-334](), [scene/main/viewport.cpp:566-743]()

## Core Architecture

### Class Hierarchy

```mermaid
classDiagram
    Node <|-- Viewport
    Viewport <|-- Window
    Texture2D <|-- ViewportTexture
    
    class Node {
        +data.tree SceneTree*
        +data.viewport Viewport*
        +get_viewport() Viewport*
    }
    
    class Viewport {
        +viewport RID
        +current_canvas RID
        +subwindow_canvas RID
        +texture_rid RID
        +size Size2i
        +canvas_transform Transform2D
        +global_canvas_transform Transform2D
        +stretch_transform Transform2D
        +world_2d Ref~World2D~
        +transparent_bg bool
        +find_world_2d() World2D*
        +find_world_3d() World3D*
        +get_final_transform() Transform2D
        +get_viewport_rid() RID
    }
    
    class Window {
        +window_id DisplayServer::WindowID
        +embedder Viewport*
        +visible bool
        +position Point2i
        +get_flag() bool
        +is_embedded() bool
    }
    
    class ViewportTexture {
        +path NodePath
        +vp Viewport*
        +proxy RID
        +proxy_ph RID
        +get_rid() RID
        +setup_local_to_scene()
    }
```

**Viewport System Class Relationships**

`Viewport` ([scene/main/viewport.h:95]()) extends `Node` to create rendering contexts. Key members:
- `viewport` (RID) - Handle to RenderingServer viewport resource ([scene/main/viewport.h:248]())
- `current_canvas` (RID) - Main 2D canvas from `world_2d` ([scene/main/viewport.h:249]())
- `texture_rid` (RID) - Output texture when rendering off-screen ([scene/main/viewport.h:301]())
- `world_2d` (Ref<World2D>) - Optional dedicated 2D world ([scene/main/viewport.h:286]())

`Window` ([scene/main/window.h:43]()) extends `Viewport` adding `window_id` for DisplayServer integration and `embedder` pointer for sub-window support.

`ViewportTexture` ([scene/main/viewport.h:55]()) wraps viewport output as `Texture2D` using `proxy` RID pointing to viewport's `texture_rid`.

Sources: [scene/main/viewport.h:95-334](), [scene/main/viewport.h:248-301](), [scene/main/window.h:43-217]()

### Key Components

| Component | Type | Purpose |
|-----------|------|---------|
| `viewport` | RID | RenderingServer viewport resource handle |
| `current_canvas` | RID | Main 2D canvas for this viewport |
| `subwindow_canvas` | RID | Canvas for embedded sub-windows |
| `texture_rid` | RID | Output texture when rendering to texture |
| `canvas_transform` | Transform2D | User-controllable 2D transform |
| `global_canvas_transform` | Transform2D | Combined screen space transform |
| `stretch_transform` | Transform2D | Scaling transform for content stretching |
| `size` | Size2i | Viewport dimensions |
| `gui` | struct | GUI input and focus state |

Sources: [scene/main/viewport.h:248-254](), [scene/main/viewport.cpp:566-743]()

### Viewport Lifecycle

```mermaid
sequenceDiagram
    participant N as "Node (parent)"
    participant VP as Viewport
    participant RS as RenderingServer
    participant ST as SceneTree
    
    N->>VP: "add_child()"
    activate VP
    VP->>VP: "NOTIFICATION_ENTER_TREE"
    VP->>N: "get_parent()->get_viewport()"
    N-->>VP: "parent Viewport*"
    VP->>RS: "viewport_set_parent_viewport(parent->viewport)"
    VP->>VP: "find_world_2d()"
    Note over VP: "Returns parent's world_2d or creates default"
    VP->>RS: "viewport_attach_canvas(current_canvas)"
    VP->>RS: "viewport_set_canvas_transform()"
    VP->>RS: "viewport_set_scenario(find_world_3d()->scenario)"
    VP->>ST: "add_to_group(\"_viewports\")"
    deactivate VP
    
    Note over VP: "Viewport renders and processes input"
    
    VP->>VP: "NOTIFICATION_EXIT_TREE"
    activate VP
    VP->>RS: "viewport_set_scenario(RID())"
    VP->>RS: "viewport_remove_canvas(current_canvas)"
    VP->>ST: "remove_from_group(\"_viewports\")"
    VP->>RS: "viewport_set_parent_viewport(RID())"
    deactivate VP
```

**Viewport Tree Integration Sequence**

NOTIFICATION_ENTER_TREE ([scene/main/viewport.cpp:570-612]()):
1. `get_parent()->get_viewport()` stores parent viewport in `parent` member ([scene/main/viewport.cpp:574-578]())
2. `viewport_set_parent_viewport()` establishes RenderingServer hierarchy ([scene/main/viewport.cpp:575]())
3. `find_world_2d()->get_canvas()` retrieves `current_canvas` RID ([scene/main/viewport.cpp:580]())
4. `viewport_attach_canvas()` connects canvas to viewport ([scene/main/viewport.cpp:581]())
5. `find_world_3d()->get_scenario()` connects 3D world ([scene/main/viewport.cpp:586]())
6. `add_to_group("_viewports")` registers for tree-wide operations ([scene/main/viewport.cpp:590]())

NOTIFICATION_EXIT_TREE ([scene/main/viewport.cpp:645-671]()):
- Detaches 3D scenario ([scene/main/viewport.cpp:648]())
- Removes canvas ([scene/main/viewport.cpp:649]())
- Unregisters from "_viewports" group ([scene/main/viewport.cpp:666]())
- Clears parent viewport relationship ([scene/main/viewport.cpp:670]())

Sources: [scene/main/viewport.cpp:566-743]()

## World2D and World3D Integration

### World Resources

```mermaid
graph TB
    VP["Viewport"] -->|"world_2d"| W2D["World2D"]
    VP -->|"find_world_2d()"| Search2D["Search parent chain"]
    W2D -->|"get_canvas()"| Canvas["RID canvas"]
    W2D -->|"get_space()"| Space2D["RID space (Physics2D)"]
    
    VP -->|"world_3d"| W3D["World3D"]
    VP -->|"find_world_3d()"| Search3D["Search parent chain"]
    W3D -->|"get_scenario()"| Scenario["RID scenario"]
    W3D -->|"get_space()"| Space3D["RID space (Physics3D)"]
    
    Canvas -->|"viewport_attach_canvas()"| RS["RenderingServer"]
    Scenario -->|"viewport_set_scenario()"| RS
```

**World Resource Lookup and Attachment**

`World2D` and `World3D` resources provide shared spatial contexts for rendering and physics. Each viewport either:
- Uses explicit `world_2d`/`world_3d` members if set ([scene/main/viewport.h:286-287]())
- Inherits from parent viewport via `find_world_2d()`/`find_world_3d()` ([scene/main/viewport.cpp:1149-1165]())

**find_world_2d()** ([scene/main/viewport.cpp:1133-1147]()):
```
Viewport* v = this;
while (v) {
    if (v->world_2d.is_valid()) return v->world_2d.ptr();
    if (v->is_embedding_subwindows()) break;
    v = v->get_parent_viewport();
}
return default World2D
```

**find_world_3d()** ([scene/main/viewport.cpp:1149-1165]()) follows identical pattern for 3D.

During ENTER_TREE, viewport connects to worlds:
- `current_canvas = find_world_2d()->get_canvas()` ([scene/main/viewport.cpp:580]())
- `viewport_attach_canvas(viewport, current_canvas)` ([scene/main/viewport.cpp:581]())
- `viewport_set_scenario(viewport, find_world_3d()->get_scenario())` ([scene/main/viewport.cpp:586]())

This allows multiple viewports to share the same world (rendering same scene from different angles) or use separate worlds (split-screen with different scenes).

Sources: [scene/main/viewport.cpp:1133-1165](), [scene/main/viewport.cpp:580-586](), [scene/main/viewport.h:286-287]()

### Canvas Layers and Stacking

```mermaid
graph LR
    W2D["World2D"] -->|"canvas RID"| VP["Viewport"]
    VP -->|"canvas_layers HashSet"| CL["CanvasLayer nodes"]
    VP -->|"subwindow_canvas RID"| SW["Sub-windows"]
    
    CL -->|"layer property"| Stack["Z-ordering"]
    SW -->|"SUBWINDOW_CANVAS_LAYER=1024"| Stack
```

**2D Canvas Organization**

Viewports manage canvas layering through:
- `current_canvas` - Main canvas from `World2D` at default layer ([scene/main/viewport.h:249]())
- `canvas_layers` - HashSet of CanvasLayer nodes for custom z-ordering ([scene/main/viewport.h:242]())
- `subwindow_canvas` - Separate canvas at layer 1024 for embedded windows ([scene/main/viewport.cpp:315]())

CanvasItem nodes (Node2D, Control) render to their parent CanvasLayer's canvas, or `current_canvas` if no CanvasLayer parent exists. The viewport applies `canvas_transform` to all canvases via `viewport_set_canvas_transform()` ([scene/main/viewport.cpp:582]()).

Sources: [scene/main/viewport.h:242-249](), [scene/main/viewport.cpp:580-582](), [scene/main/viewport.cpp:315-317]()

## Rendering and Transform Pipeline

### Transform Hierarchy

The viewport applies multiple transform layers to convert from world space to screen pixels:

```mermaid
graph LR
    WS["World Space"] --> CT["canvas_transform"]
    CT --> GCT["global_canvas_transform"]
    GCT --> ST["stretch_transform"]
    ST --> SS["Screen Space"]
```

**Viewport Transform Chain**

Three transform members combine to map coordinates:

1. **canvas_transform** ([scene/main/viewport.h:252]()) - User-controllable 2D camera transform, typically set by Camera2D. Modified via `set_canvas_transform()` ([scene/main/viewport.cpp:1233-1241]())

2. **global_canvas_transform** ([scene/main/viewport.h:253]()) - Combines parent viewport transforms with local `canvas_transform`. Updated by `_update_global_transform()` ([scene/main/viewport.cpp:1254-1274]()) which recursively multiplies transforms up the viewport hierarchy.

3. **stretch_transform** ([scene/main/viewport.h:254]()) - Scales content for resolution adaptation. Computed from `size`, `size_2d_override`, and content scaling mode.

**get_final_transform()** ([scene/main/viewport.cpp:1276-1289]()):
```
Transform2D get_final_transform() const {
    return stretch_transform * global_canvas_transform;
}
```
Returns transform from viewport coordinates to parent viewport/window coordinates. Used for input event coordinate conversion and GUI hit-testing.

**get_screen_transform()** ([scene/main/viewport.cpp:1298-1314]()) extends this to screen space by multiplying with embedder transforms.

Sources: [scene/main/viewport.cpp:1233-1314](), [scene/main/viewport.h:252-254]()

### ViewportTexture System

```mermaid
graph TD
    VT["ViewportTexture"] -->|"path: NodePath"| Resolve["setup_local_to_scene()"]
    Resolve -->|"get_node(path)"| VP["Viewport"]
    VP -->|"texture_rid RID"| RS["RenderingServer"]
    VT -->|"proxy RID"| ProxyCreate["texture_proxy_create(texture_rid)"]
    ProxyCreate -->|"creates"| Proxy["proxy RID"]
    VP -->|"viewport_textures.insert(this)"| VT
```

**ViewportTexture Local-to-Scene Resolution**

`ViewportTexture` ([scene/main/viewport.h:55-93]()) wraps viewport rendering output as `Texture2D`. Uses local-to-scene pattern to defer viewport lookup until scene tree insertion.

**Lifecycle:**

1. **Configuration**: Set `path` via `set_viewport_path_in_scene()` ([scene/main/viewport.cpp:111-128]()), typically to NodePath like `"../GameViewport"`

2. **Resolution**: `setup_local_to_scene()` ([scene/main/viewport.cpp:69-95]()) called when node enters tree:
   - Resolves `path` to `Viewport*` via `get_node()` ([scene/main/viewport.cpp:198]())
   - Stores `vp` pointer and registers in `vp->viewport_textures` ([scene/main/viewport.cpp:203]())

3. **Proxy Creation**: `_setup_local_to_scene()` ([scene/main/viewport.cpp:194-217]()):
   ```
   proxy = RS::get_singleton()->texture_proxy_create(vp->texture_rid);
   ```
   Creates RID that forwards texture queries to viewport's output texture.

4. **Usage**: `get_rid()` ([scene/main/viewport.cpp:168-174]()) returns `proxy` for material/shader sampling

5. **Cleanup**: Destructor removes from `vp->viewport_textures` set ([scene/main/viewport.cpp:230-243]())

Viewport updates texture paths when moving in tree via `_update_viewport_path()` ([scene/main/viewport.cpp:537-548]()).

Sources: [scene/main/viewport.cpp:69-243](), [scene/main/viewport.h:55-93](), [scene/main/viewport.h:324]()

## Input Dispatch System

### Input Event Flow

```mermaid
graph TD
    DS["DisplayServer"] -->|"InputEvent"| ST["SceneTree"]
    ST -->|"input_event()"| Window["Window (root)"]
    Window -->|"push_input()"| VP["Viewport::push_input()"]
    
    VP -->|"1. GUI Phase"| GUI["_gui_input_event()"]
    GUI -->|"hit test"| Control["Control::_gui_input()"]
    
    VP -->|"2. Node Groups"| Groups["_call_input_group()"]
    Groups -->|"\"_vp_input\""| Input["Node::_input()"]
    Groups -->|"\"_vp_shortcut_input\""| Shortcut["Node::_shortcut_input()"]
    Groups -->|"\"_vp_unhandled_input\""| Unhandled["Node::_unhandled_input()"]
    
    VP -->|"3. Physics"| Picking["_process_picking()"]
    Picking -->|"PhysicsServer2D"| CO2D["CollisionObject2D::_input_event()"]
    Picking -->|"PhysicsServer3D"| CO3D["CollisionObject3D::_input_event()"]
```

**Input Event Routing in Viewport**

Input dispatch occurs in three phases per `push_input()` call ([scene/main/viewport.cpp:4134-4198]()):

**Phase 1: GUI** ([scene/main/viewport.cpp:1876-2876]())
- `_gui_input_event()` performs hit-testing against Control nodes
- Tests `gui.mouse_over` and `gui.mouse_focus` for event delivery
- Handles drag/drop, tooltips, modal windows, focus management
- Stops propagation if Control consumes event via `accept_event()`

**Phase 2: Node Input Callbacks** ([scene/main/viewport.cpp:4164-4188]())
- `_call_input_group()` invokes Node methods on groups registered in ENTER_TREE:
  - `"_vp_input" + viewport_id` â†’ `Node::_input()` ([scene/main/node.cpp:163-164]())
  - `"_vp_shortcut_input" + viewport_id` â†’ `Node::_shortcut_input()` ([scene/main/node.cpp:166-167]())
  - `"_vp_unhandled_input" + viewport_id` â†’ `Node::_unhandled_input()` ([scene/main/node.cpp:169-170]())
  - `"_vp_unhandled_key_input" + viewport_id` â†’ `Node::_unhandled_key_input()` ([scene/main/node.cpp:172-173]())
- Groups called in order: input â†’ shortcut â†’ unhandled_key â†’ unhandled
- Each phase checks `is_input_handled()` before proceeding

**Phase 3: Physics Picking** ([scene/main/viewport.cpp:746-1042]())
- Runs if `physics_object_picking` enabled and mouse in viewport
- Raycasts/point tests against 2D/3D physics spaces
- Delivers events to `CollisionObject2D::_input_event()` / `CollisionObject3D` via `_collision_object_3d_input_event()`

Sources: [scene/main/viewport.cpp:746-4198](), [scene/main/node.cpp:163-174]()

### GUI Input Handling

The viewport maintains GUI state in the `gui` struct ([scene/main/viewport.h:358-519]()):

| Field | Purpose |
|-------|---------|
| `mouse_focus` | Control currently capturing mouse input |
| `mouse_over` | Control under mouse cursor |
| `key_focus` | Control receiving keyboard input |
| `drag_mouse_over` | Control under cursor during drag operation |
| `tooltip_control` | Control displaying tooltip |
| `subwindow_focused` | Currently focused embedded sub-window |

GUI input processing ([scene/main/viewport.cpp:1876-2876]()) follows this priority:
1. Drag and drop handling
2. Tooltip management
3. Modal window blocking
4. Control hit testing and event delivery
5. Focus management

Sources: [scene/main/viewport.h:358-519](), [scene/main/viewport.cpp:1876-2876]()

### Physics Object Picking

```mermaid
sequenceDiagram
    participant VP as Viewport
    participant PS2D as PhysicsServer2D
    participant DPS2D as "DirectSpaceState2D"
    participant PS3D as PhysicsServer3D
    participant DPS3D as "DirectSpaceState3D"
    participant CO as CollisionObject
    
    VP->>VP: "_process_picking()"
    Note over VP: "physics_picking_events queue"
    
    loop "Each InputEvent in queue"
        VP->>PS2D: "space_get_direct_state(world_2d->space)"
        PS2D-->>VP: "DirectSpaceState2D*"
        VP->>DPS2D: "intersect_point(point_params)"
        DPS2D-->>VP: "ShapeResult[] (up to 64)"
        
        alt "physics_object_picking_sort"
            VP->>VP: "Sort by z-index and tree order"
        end
        
        loop "Each result"
            VP->>CO: "collider->_input_event_call(viewport, event, shape)"
            VP->>CO: "collider->_mouse_enter() / _mouse_shape_enter()"
        end
        
        VP->>PS3D: "space_get_direct_state(world_3d->space)"
        PS3D-->>VP: "DirectSpaceState3D*"
        VP->>DPS3D: "intersect_ray(ray_params)"
        DPS3D-->>VP: "RayResult"
        
        alt "Hit 3D object"
            VP->>CO: "collider->_mouse_enter()"
            VP->>VP: "_collision_object_3d_input_event()"
        end
    end
    
    VP->>VP: "_cleanup_mouseover_colliders()"
```

**Physics Picking Implementation**

`_process_picking()` ([scene/main/viewport.cpp:746-1042]()) processes queued input events against physics spaces. Controlled by:

- `physics_object_picking` - Enable picking ([scene/main/viewport.h:272]())
- `physics_object_picking_sort` - Sort 2D by z-index ([scene/main/viewport.h:273](), [scene/main/viewport.cpp:895-913]())
- `physics_object_picking_first_only` - Stop at first hit ([scene/main/viewport.h:274](), [scene/main/viewport.cpp:947-949]())

**2D Picking** ([scene/main/viewport.cpp:867-958]()):
```
PhysicsDirectSpaceState2D* ss2d = PhysicsServer2D::get_singleton()->space_get_direct_state(world_2d->space);
PhysicsDirectSpaceState2D::PointParameters point_params;
point_params.position = canvas_layer_transform.affine_inverse().xform(mouse_pos);
int rc = ss2d->intersect_point(point_params, results, 64);
```
Returns up to 64 `ShapeResult` objects. For each hit:
- Insert/update `physics_2d_mouseover` map with frame number ([scene/main/viewport.cpp:923-937]())
- Call `CollisionObject2D::_input_event_call()` ([scene/main/viewport.cpp:944]())

**3D Picking** ([scene/main/viewport.cpp:964-1039]()):
```
Vector3 from = camera_3d->project_ray_origin(pos);
Vector3 dir = camera_3d->project_ray_normal(pos);
PhysicsDirectSpaceState3D::RayParameters ray_params;
ray_params.from = from;
ray_params.to = from + dir * camera_3d->get_far();
space->intersect_ray(ray_params, result);
```
Returns single `RayResult`. Updates `physics_object_over` and calls `_collision_object_3d_input_event()` ([scene/main/viewport.cpp:981-1033]()).

**Mouseover Cleanup** ([scene/main/viewport.cpp:3780-3834]()): `_cleanup_mouseover_colliders()` removes stale entries from `physics_2d_mouseover` by comparing frame numbers, calling `_mouse_exit()` on departed objects.

Sources: [scene/main/viewport.cpp:746-1042](), [scene/main/viewport.cpp:3780-3834](), [scene/main/viewport.h:271-281]()

## Sub-Window Management

### Sub-Window Architecture

```mermaid
classDiagram
    class Viewport {
        +Vector~SubWindow~ gui.sub_windows
        +RID subwindow_canvas
        +Window* gui.subwindow_focused
        +Window* gui.subwindow_over
        +_sub_window_register()
        +_sub_window_remove()
        +_sub_window_update()
        +_sub_window_grab_focus()
    }
    
    class SubWindow {
        +Window* window
        +RID canvas_item
        +bool pending_window_update
    }
    
    class Window {
        +Viewport* embedder
        +bool visible
        +Point2i position
        +Size2i size
        +Transform2D window_transform
        +Transform2D stretch_transform
    }
    
    Viewport "1" --> "*" SubWindow
    SubWindow --> Window
    Window --> Viewport : "child viewport"
```

**Sub-Window Embedding Structure**

Embedded windows are managed through the `SubWindow` struct ([scene/main/viewport.h:337-341]()), which wraps a `Window` pointer with a dedicated canvas item for rendering. The parent viewport maintains these in `gui.sub_windows` ([scene/main/viewport.h:417]()).

Sources: [scene/main/viewport.h:337-341](), [scene/main/viewport.h:417]()

### Sub-Window Lifecycle

Key operations for sub-window management:

**Registration** ([scene/main/viewport.cpp:308-340]()):
- Creates `subwindow_canvas` on first sub-window
- Allocates `canvas_item` for drawing window decoration
- Sets up parent-child viewport relationship
- Handles focus for non-NO_FOCUS windows

**Update** ([scene/main/viewport.cpp:342-398]()):
- Draws window border if not borderless
- Renders window title bar with close button
- Positions and scales child viewport texture

**Focus Management** ([scene/main/viewport.cpp:400-472]()):
- Handles NO_FOCUS windows (move to front without focus)
- Sends WINDOW_EVENT_FOCUS_IN/OUT notifications
- Reorders sub-windows with focused window on top
- Processes "always on top" flag

**Removal** ([scene/main/viewport.cpp:474-525]()):
- Cleans up canvas_item RID
- Handles focus transfer to parent window
- Frees subwindow_canvas when empty

Sources: [scene/main/viewport.cpp:308-535]()

### Sub-Window Ordering

```mermaid
graph TD
    Base["Normal Z-Order"] --> AOT["Always On Top Windows"]
    AOT --> Exc["Exclusive Children"]
    
    style Base fill:#f9f9f9
    style AOT fill:#f9f9f9
    style Exc fill:#f9f9f9
```

**Sub-Window Draw Order Priority**

Window ordering ([scene/main/viewport.cpp:270-306]()) follows this priority:
1. Normal windows in tree order
2. Always-on-top windows moved to end
3. Exclusive children placed after their parents

Each window's `canvas_item` receives a draw index via `canvas_item_set_draw_index()` ([scene/main/viewport.cpp:304]()).

Sources: [scene/main/viewport.cpp:270-306]()

## Canvas and Layer Management

### Canvas System

Each viewport manages multiple canvas layers:

```mermaid
graph TD
    VP["Viewport"] -->|"current_canvas"| MainCanvas["Main Canvas (World2D)"]
    VP -->|"subwindow_canvas"| SubCanvas["Sub-Window Canvas"]
    VP -->|"canvas_layers"| CL["HashSet&lt;CanvasLayer*&gt;"]
    
    MainCanvas -->|"CANVAS_LAYER_DEFAULT"| Items2D["CanvasItem nodes"]
    SubCanvas -->|"SUBWINDOW_CANVAS_LAYER (1024)"| SubWin["Sub-Windows"]
    CL -->|"custom layers"| CustomLayer["User CanvasLayers"]
```

**Viewport Canvas Organization**

- `current_canvas` - Main 2D rendering canvas from World2D ([scene/main/viewport.h:249]())
- `subwindow_canvas` - Separate canvas for embedded windows at layer 1024 ([scene/main/viewport.cpp:315-317]())
- `canvas_layers` - Set of CanvasLayer nodes for custom z-ordering ([scene/main/viewport.h:242]())

Canvas attachment occurs during ENTER_TREE notification ([scene/main/viewport.cpp:580-583]()). The viewport applies transforms via `viewport_set_canvas_transform()` ([scene/main/viewport.cpp:582]()).

Sources: [scene/main/viewport.cpp:580-583](), [scene/main/viewport.h:242-250]()

### Canvas Transforms

Transform updates propagate through the viewport hierarchy:

```mermaid
sequenceDiagram
    participant User as "User Code"
    participant VP as Viewport
    participant RS as RenderingServer
    
    User->>VP: set_canvas_transform()
    VP->>VP: canvas_transform = value
    VP->>VP: _update_global_transform()
    VP->>VP: global_canvas_transform = parent + canvas
    VP->>RS: viewport_set_canvas_transform(canvas)
    
    Note over VP: Children viewports
    loop Each child viewport
        VP->>VP: child->_update_global_transform()
    end
```

**Canvas Transform Propagation**

`set_canvas_transform()` ([scene/main/viewport.cpp:1233-1241]()) triggers `_update_global_transform()` ([scene/main/viewport.cpp:1254-1274]()) which:
1. Computes `global_canvas_transform` from parent viewports
2. Updates RenderingServer with new transform
3. Recursively updates child viewports

The `canvas_cull_mask` property ([scene/main/viewport.h:334]()) controls which canvas layers are visible through bitmask filtering ([scene/main/viewport.cpp:1332-1350]()).

Sources: [scene/main/viewport.cpp:1233-1274](), [scene/main/viewport.cpp:1332-1350]()

## Camera and Audio Listener Management

### 2D Camera System

```mermaid
graph LR
    VP["Viewport"] -->|"camera_2d"| Cam2D["Camera2D*"]
    VP -->|"camera_2d_set"| Set2D["HashSet&lt;Camera2D*&gt;"]
    Cam2D -->|"current = true"| Make["make_current()"]
    Make -->|"update"| VP
    VP -->|"canvas_transform"| Transform["Camera transform"]
```

**2D Camera Management**

The viewport tracks:
- `camera_2d` - Currently active Camera2D ([scene/main/viewport.h:335]())
- `camera_2d_set` - All Camera2D nodes in this viewport (type inferred from usage)

Camera2D nodes register themselves with their parent viewport. The active camera sets the viewport's canvas_transform to follow the camera's target.

Sources: [scene/main/viewport.h:335]()

### 3D Camera and Listener System

```mermaid
classDiagram
    class Viewport {
        +Camera3D* camera_3d
        +HashSet~Camera3D*~ camera_3d_set
        +AudioListener3D* audio_listener_3d
        +HashSet~AudioListener3D*~ audio_listener_3d_set
        +get_camera_3d()
        +get_audio_listener_3d()
    }
    
    class Camera3D {
        +make_current()
        +clear_current()
    }
    
    class AudioListener3D {
        +make_current()
        +clear_current()
    }
```

**3D Camera and Audio Listener Tracking**

Similar to 2D, the viewport maintains sets of 3D cameras and audio listeners ([scene/main/viewport.h:335]()). The NOTIFICATION_READY handler ([scene/main/viewport.cpp:614-642]()) automatically selects the first camera/listener in tree order if none is explicitly set as current.

For 3D rendering, `find_world_3d()` ([scene/main/viewport.cpp:1149-1165]()) searches up the viewport hierarchy to locate the active World3D resource.

Sources: [scene/main/viewport.cpp:614-642](), [scene/main/viewport.cpp:1149-1165](), [scene/main/viewport.h:335]()

### Audio Listener 2D

The viewport tracks 2D audio listeners similarly:
- `audio_listener_2d` - Active AudioListener2D ([scene/main/viewport.h:335]())  
- `audio_listener_2d_set` - All registered 2D listeners

`_update_audio_listener_2d()` ([scene/main/viewport.cpp:1367-1384]()) synchronizes the AudioServer's 2D listener transform with the viewport's camera transform.

Sources: [scene/main/viewport.cpp:1367-1384](), [scene/main/viewport.h:335]()

## Viewport Configuration

### Rendering Settings

Key rendering configuration exposed by Viewport:

| Property | Type | Purpose |
|----------|------|---------|
| `transparent_bg` | bool | Enable alpha channel in rendering |
| `use_hdr_2d` | bool | Use HDR format for 2D rendering |
| `msaa_2d` / `msaa_3d` | MSAA enum | Multisample anti-aliasing level |
| `screen_space_aa` | ScreenSpaceAA | FXAA/SMAA post-process AA |
| `use_taa` | bool | Enable temporal anti-aliasing |
| `use_debanding` | bool | Enable debanding post-process |
| `use_occlusion_culling` | bool | Enable occlusion culling optimization |

These properties map to RenderingServer viewport settings through methods like `set_transparent_background()` ([scene/main/viewport.cpp:1457-1471]()) and `set_use_hdr_2d()` ([scene/main/viewport.cpp:1473-1486]()).

Sources: [scene/main/viewport.h:264-321](), [scene/main/viewport.cpp:1457-1604]()

### Size and Scaling

```mermaid
graph TD
    Size["size (base resolution)"] --> SO["size_2d_override"]
    Size --> ST["stretch_transform"]
    SO --> Final["Effective Size"]
    ST --> Final
    
    Final --> MinSize["min_size clamp"]
    Final --> MaxSize["max_size_used clamp"]
```

**Viewport Size Resolution**

The viewport's size handling ([scene/main/viewport.cpp:1099-1126]()):
- `size` - Base viewport dimensions ([scene/main/viewport.h:256]())
- `size_2d_override` - Override for 2D content scaling ([scene/main/viewport.h:257]())
- `stretch_transform` - Applied for content scaling modes ([scene/main/viewport.h:254]())

`_set_size()` ([scene/main/viewport.cpp:1099-1126]()) updates the RenderingServer viewport size and recalculates the stretch transform. The root Window's `content_scale_factor` further multiplies the effective resolution.

Sources: [scene/main/viewport.cpp:1099-1126](), [scene/main/viewport.h:254-258]()

### Debug and Visualization

Viewport debug settings control visual debugging modes:
- `debug_draw` - Enum selecting debug visualization mode (wireframe, overdraw, etc.) ([scene/main/viewport.h:303]())
- Contact visualization for physics (2D/3D) enabled via `get_tree()->is_debugging_collisions_hint()` ([scene/main/viewport.cpp:592-610]())

Debug meshes are created as RIDs (`contact_2d_debug`, `contact_3d_debug_multimesh`) and updated each physics frame ([scene/main/viewport.cpp:678-710]()).

Sources: [scene/main/viewport.cpp:592-610](), [scene/main/viewport.cpp:678-710](), [scene/main/viewport.h:303]()26:T7105,# Control & UI System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/os/main_loop.cpp](core/os/main_loop.cpp)
- [core/os/main_loop.h](core/os/main_loop.h)
- [doc/classes/Control.xml](doc/classes/Control.xml)
- [doc/classes/MainLoop.xml](doc/classes/MainLoop.xml)
- [doc/classes/Node.xml](doc/classes/Node.xml)
- [doc/classes/SceneTree.xml](doc/classes/SceneTree.xml)
- [doc/classes/Viewport.xml](doc/classes/Viewport.xml)
- [doc/classes/Window.xml](doc/classes/Window.xml)
- [scene/gui/control.cpp](scene/gui/control.cpp)
- [scene/gui/control.h](scene/gui/control.h)
- [scene/main/node.cpp](scene/main/node.cpp)
- [scene/main/node.h](scene/main/node.h)
- [scene/main/scene_tree.cpp](scene/main/scene_tree.cpp)
- [scene/main/scene_tree.h](scene/main/scene_tree.h)
- [scene/main/viewport.cpp](scene/main/viewport.cpp)
- [scene/main/viewport.h](scene/main/viewport.h)
- [scene/main/window.cpp](scene/main/window.cpp)
- [scene/main/window.h](scene/main/window.h)

</details>



This document covers Godot's UI system built around the `Control` class, including layout management, input handling, theming, and integration with the viewport system. For information about viewport rendering and canvas transforms, see [Viewport System](#4.3). For window management and native window integration, see [Window Management](#4.5).

## Purpose and Scope

The Control & UI System provides a comprehensive framework for building user interfaces in Godot. It defines how UI elements position and size themselves, handle user input, apply visual themes, and interact with the scene tree. The system is anchored by the `Control` class, which all GUI nodes inherit from.

---

## Core Class Hierarchy

```mermaid
classDiagram
    Object <|-- Node
    Node <|-- CanvasItem
    CanvasItem <|-- Control
    CanvasItem <|-- Node2D
    Node <|-- Viewport
    Viewport <|-- Window
    
    Control : +Data data
    Control : +real_t anchor[4]
    Control : +real_t offset[4]
    Control : +FocusMode focus_mode
    Control : +MouseFilter mouse_filter
    Control : +_gui_input(InputEvent)
    Control : +get_combined_minimum_size()
    Control : +_get_minimum_size()
    Control : +grab_focus()
    Control : +accept_event()
    
    Viewport : +Gui gui
    Viewport : +_gui_input_event(InputEvent)
    Viewport : +_gui_call_input(Control, InputEvent)
    Viewport : +gui_get_focus_owner()
    Viewport : +gui_release_focus()
    
    class Gui {
        +Control* mouse_focus
        +Control* key_focus
        +Control* mouse_over
        +Control* tooltip_control
        +ObjectID tooltip_popup
        +bool mouse_in_viewport
    }
    
    class Data {
        +Vector2 position
        +Size2 size
        +Vector2 scale
        +real_t rotation
        +Node* parent_control
        +HashMap theme_icon_override
        +HashMap theme_style_override
    }
    
    Viewport --> Gui
    Control --> Data
```

**Core class relationships in the UI system**

Sources: [scene/gui/control.h:44-177](), [scene/main/viewport.h:95-96, 334-430](), [scene/main/node.h:50-51]()

---

## Layout System

The Control layout system determines how UI elements position and size themselves relative to their parent control or viewport. There are four primary layout modes defined in `LayoutMode`:

| Layout Mode | Description | Use Case |
|------------|-------------|----------|
| `LAYOUT_MODE_POSITION` | Uses `position` and `size` properties directly | Manual positioning |
| `LAYOUT_MODE_ANCHORS` | Uses anchor points and offsets | Responsive layouts |
| `LAYOUT_MODE_CONTAINER` | Managed by parent Container node | Automatic layouts |
| `LAYOUT_MODE_UNCONTROLLED` | No automatic layout management | Advanced custom control |

Sources: [scene/gui/control.h:147-152]()

### Anchor and Offset System

```mermaid
graph TB
    subgraph "Control Layout Calculation"
        Anchors["data.anchor[SIDE_LEFT/TOP/RIGHT/BOTTOM]<br/>(0.0 to 1.0)"]
        Offsets["data.offset[SIDE_LEFT/TOP/RIGHT/BOTTOM]<br/>(pixels)"]
        ParentSize["get_parent_anchorable_rect()"]
        
        Anchors --> AnchorPos["anchor_pos = parent_rect.size * anchor"]
        Offsets --> FinalPos["final_pos = anchor_pos + offset"]
        ParentSize --> AnchorPos
        AnchorPos --> FinalPos
        
        FinalPos --> Rect["data.rect_position<br/>data.rect_size"]
        Rect --> SizeChanged["_size_changed()"]
        SizeChanged --> NotifResized["NOTIFICATION_RESIZED"]
    end
```

**How anchors and offsets determine control position and trigger notifications**
</thinking>

Sources: [scene/gui/control.cpp:102-111, 1200-1400](), [scene/gui/control.h:195-220]()

The anchor system allows controls to maintain relative positions when their parent resizes. Each side (left, top, right, bottom) has an anchor value between 0.0 and 1.0, representing a percentage of the parent's size, plus a pixel offset.

```cpp
// From control.cpp - anchor and offset calculation
data.anchor[SIDE_LEFT] = anchors[0];   // 0.0 to 1.0
data.anchor[SIDE_TOP] = anchors[1];
data.anchor[SIDE_RIGHT] = anchors[2];
data.anchor[SIDE_BOTTOM] = anchors[3];

data.offset[SIDE_LEFT] = offsets[0];   // pixel offset
data.offset[SIDE_TOP] = offsets[1];
data.offset[SIDE_RIGHT] = offsets[2];
data.offset[SIDE_BOTTOM] = offsets[3];
```

Sources: [scene/gui/control.cpp:102-111](), [scene/gui/control.h:54-63]()

### Size Flags and Container Integration

When a Control is a child of a Container node, the container manages its layout using size flags:

| Size Flag | Value | Description |
|-----------|-------|-------------|
| `SIZE_FILL` | 1 | Fill available space |
| `SIZE_EXPAND` | 2 | Request extra space when available |
| `SIZE_SHRINK_CENTER` | 4 | Shrink and center |
| `SIZE_SHRINK_END` | 8 | Shrink and align to end |
| `SIZE_EXPAND_FILL` | 3 | Combination of EXPAND and FILL |

Sources: [scene/gui/control.h:78-86]()

Container nodes read these flags and set the child's position and size accordingly. The layout mode automatically becomes `LAYOUT_MODE_CONTAINER` when the control is added to a container:

```cpp
// Container layout management (conceptual flow)
// From control.cpp property validation
if (Object::cast_to<Container>(parent_control)) {
    // Container manages position, rotation, scale, size
    // Size flags determine behavior
    p_property.usage = PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY;
}
```

Sources: [scene/gui/control.cpp:537-547](), [scene/gui/control.cpp:549-587]()

---

## Input Handling Architecture

```mermaid
sequenceDiagram
    participant DS as DisplayServer
    participant VP as Viewport
    participant ST as SceneTree
    participant C as Control
    participant Script
    
    DS->>VP: InputEvent
    VP->>VP: _gui_input_event()
    
    alt Mouse Event
        VP->>VP: _gui_call_input(mouse_focus)
        VP->>C: _gui_input()
    end
    
    alt Keyboard Event & Focus
        VP->>VP: gui.key_focus
        VP->>C: _gui_input()
    end
    
    C->>C: accept_event() check
    
    alt Event Not Accepted
        C->>Script: _gui_input(event)
        Script-->>C: accept_event()
    end
    
    alt Still Not Accepted
        VP->>ST: Input propagates to _input groups
    end
```

**Input event flow from DisplayServer to Control**

### Input Propagation and Focus

The viewport maintains GUI state in the `Gui` struct for input handling:

```cpp
// From viewport.h GUI state structure (lines 334-430)
struct Gui {
    Control *mouse_focus = nullptr;           // Control receiving mouse events
    Control *key_focus = nullptr;             // Control receiving keyboard events  
    Control *mouse_over = nullptr;            // Control under mouse cursor
    Control *tooltip_control = nullptr;       // Control providing tooltip
    ObjectID tooltip_popup;                   // Active tooltip window
    ObjectID mouse_focus_mask;                // Bitfield of mouse buttons
    
    bool mouse_in_viewport = false;           // Mouse inside viewport
    bool key_event_accepted = false;          // Last key event consumed
    bool hide_focus = false;                  // Hide focus outline
    
    Point2 last_mouse_pos;                    // Last mouse position
    Control *drag_preview = nullptr;          // Drag preview control
    Variant drag_data;                        // Current drag data
    // ... more state
} gui;
```

Key methods that operate on this state:
- `_gui_call_input(Control*, InputEvent)` - Dispatch input to control
- `_gui_call_notification(Control*, int)` - Send notification to control
- `_gui_find_control_at_pos(Point2)` - Hit test for control at position
- `gui_get_focus_owner()` - Returns `gui.key_focus`

Sources: [scene/main/viewport.h:334-430](), [scene/main/viewport.cpp:2700-2900]()

Controls process input through the `_gui_input()` virtual method. The method can call `accept_event()` to stop propagation:

```cpp
// Control input handling pattern
void Control::_gui_input(const Ref<InputEvent> &p_event) {
    // Process event
    if (should_consume) {
        accept_event();  // Stops further propagation
    }
}
```

Sources: [scene/gui/control.cpp:2900-3200]() (implementation details)

### Mouse Filter Modes

Controls can filter mouse events using the `MouseFilter` enum:

| Mode | Behavior |
|------|----------|
| `MOUSE_FILTER_STOP` | Receives and stops mouse events |
| `MOUSE_FILTER_PASS` | Receives events but passes them through |
| `MOUSE_FILTER_IGNORE` | Ignores all mouse events |

Sources: [scene/gui/control.h:88-92]()

### Focus System

The focus system determines which control receives keyboard input. Focus is managed by the viewport:

```mermaid
graph LR
    A["FocusMode.FOCUS_NONE<br/>Cannot receive focus"] 
    B["FocusMode.FOCUS_CLICK<br/>Focus on mouse click"]
    C["FocusMode.FOCUS_ALL<br/>Focus via click or Tab"]
    D["FocusMode.FOCUS_ACCESSIBILITY<br/>Accessibility focus only"]
    
    B --> Focus["Viewport.gui.key_focus"]
    C --> Focus
    D --> Focus
```

**Focus mode determines how a control can receive keyboard focus**

Sources: [scene/gui/control.h:65-70]()

Key focus methods:
- `grab_focus()` - Request keyboard focus
- `release_focus()` - Release keyboard focus
- `has_focus()` - Check if control has focus
- `get_focus_owner()` - Get current focused control (from viewport)

Sources: [scene/gui/control.cpp:2500-2600]() (focus management methods)

---

## Theming System

The theming system provides visual customization through a hierarchical override system:

```mermaid
graph TB
    C["Control Instance"]
    T1["Theme Overrides<br/>(Highest Priority)"]
    T2["Control.theme<br/>(Assigned Theme)"]
    T3["Parent Theme<br/>(Inherited)"]
    T4["Project Default Theme"]
    T5["Engine Default Theme<br/>(Lowest Priority)"]
    
    C --> T1
    T1 -->|Not Found| T2
    T2 -->|Not Found| T3
    T3 -->|Not Found| T4
    T4 -->|Not Found| T5
    
    style T1 fill:#f9f9f9
    style T5 fill:#e0e0e0
```

**Theme property resolution hierarchy**

### Theme Item Types

The theming system supports five data types:

| Type | Example Usage | Storage |
|------|---------------|---------|
| `COLOR` | Text color, background color | `theme_color_override` |
| `CONSTANT` | Margins, spacing | `theme_constant_override` |
| `FONT` | Text rendering | `theme_font_override` |
| `FONT_SIZE` | Font point size | `theme_font_size_override` |
| `ICON` | Button icons, checkboxes | `theme_icon_override` |
| `STYLEBOX` | Backgrounds, borders | `theme_style_override` |

Sources: [scene/gui/control.cpp:403-460]()

### Theme Override System

Controls can override theme properties locally using methods like:

```cpp
// Adding theme overrides (from control.cpp:343-361)
control->add_theme_color_override("font_color", Color(1, 0, 0));
control->add_theme_font_override("font", custom_font);
control->add_theme_stylebox_override("panel", custom_style);

// Retrieving theme items (with fallback chain)
Color color = control->get_theme_color("font_color", "Label");
Ref<Font> font = control->get_theme_font("font", "Label");
```

The override data is stored in hash maps within `Control::Data`:

```cpp
// From control.h:215-220 - theme storage
struct Data {
    HashMap<StringName, Ref<Texture2D>> theme_icon_override;
    HashMap<StringName, Ref<StyleBox>> theme_style_override;
    HashMap<StringName, Ref<Font>> theme_font_override;
    HashMap<StringName, int> theme_font_size_override;
    HashMap<StringName, Color> theme_color_override;
    HashMap<StringName, int> theme_constant_override;
    
    ThemeOwner *theme_owner = nullptr;  // Theme resolution helper
    // ...
} data;
```

The `ThemeOwner` class manages the theme inheritance chain and propagates theme changes to child controls. When theme overrides are added or removed, `_notify_theme_override_changed()` is called, which triggers `NOTIFICATION_THEME_CHANGED`.

Sources: [scene/gui/control.h:195-230](), [scene/gui/control.cpp:297-367](), [scene/theme/theme_owner.h]()

### Theme Change Notification

When theme properties change, controls are notified through `NOTIFICATION_THEME_CHANGED`:

```cpp
// Theme change propagation
void Control::_notify_theme_override_changed() {
    notification(NOTIFICATION_THEME_CHANGED);
    update_minimum_size();
    queue_redraw();
}
```

Sources: [scene/gui/control.cpp:308-320]()

---

## Viewport GUI Integration

The `Viewport` class manages all Control input and rendering through its internal `Gui` structure:

```mermaid
graph TB
    subgraph Viewport["Viewport (gui member)"]
        MI["mouse_in_viewport"]
        MF["mouse_focus"]
        KF["key_focus"]
        MO["mouse_over"]
        TP["tooltip_popup"]
        SW["sub_windows[]"]
        
        MI --> InputDispatch["_gui_input_event()"]
        MF --> InputDispatch
        KF --> InputDispatch
        
        InputDispatch --> Controls["Control Nodes"]
        
        TP --> TooltipSystem["_gui_show_tooltip()"]
        SW --> SubWindowMgmt["_sub_window_update()"]
    end
```

**Viewport GUI state management structure**

### GUI Input Event Processing

The viewport processes input through `_gui_input_event()` (lines 2900-3500), which follows this flow:

1. **Determine target control**:
   - Mouse events: `_gui_find_control_at_pos(position)` for hit testing
   - Keyboard events: Use `gui.key_focus` if set
   
2. **Dispatch to control**:
   - Call `_gui_call_input(control, event)` which invokes `control->_gui_input(event)`
   - Control can call `accept_event()` to set `gui.key_event_accepted = true`

3. **Check consumption**:
   - If `is_input_handled()` returns true, stop propagation
   - Otherwise, bubble up to parent controls

4. **Fallback to scene tree**:
   - If no control handles it, propagate to viewport's input groups:
     - `_vp_input` group (nodes with `set_process_input(true)`)
     - `_vp_unhandled_input` group (nodes with `set_process_unhandled_input(true)`)

```mermaid
graph TB
    InputEvent["InputEvent"] --> GuiInputEvent["Viewport::_gui_input_event()"]
    
    GuiInputEvent --> MouseCheck{"Mouse or<br/>Keyboard?"}
    
    MouseCheck -->|Mouse| FindControl["_gui_find_control_at_pos()"]
    MouseCheck -->|Keyboard| UseFocus["Use gui.key_focus"]
    
    FindControl --> CallInput["_gui_call_input(control, event)"]
    UseFocus --> CallInput
    
    CallInput --> ControlGuiInput["control->_gui_input(event)"]
    ControlGuiInput --> ScriptInput["_gui_input() script callback"]
    ScriptInput --> AcceptCheck{"accept_event()<br/>called?"}
    
    AcceptCheck -->|Yes| Done["gui.key_event_accepted = true"]
    AcceptCheck -->|No| BubbleUp["Propagate to parent control"]
    
    BubbleUp --> HasParent{"Has parent<br/>control?"}
    HasParent -->|Yes| CallInput
    HasParent -->|No| FallbackGroups["Propagate to _vp_input groups"]
```

**Input event processing flow in Viewport**

Sources: [scene/main/viewport.cpp:2900-3500](), [scene/gui/control.cpp:2900-3200]()

### Focus Owner Tracking

```cpp
// From viewport.cpp - focus management
Control *Viewport::gui_get_focus_owner() const {
    return gui.key_focus;
}

void Viewport::gui_release_focus() {
    if (gui.key_focus) {
        Control *f = gui.key_focus;
        gui.key_focus = nullptr;
        f->notification(Control::NOTIFICATION_FOCUS_EXIT);
        f->queue_redraw();
    }
}
```

Sources: [scene/main/viewport.cpp:2700-2750]()

### Tooltip System

The viewport manages tooltip display with the following flow:

1. Mouse hovers over control with `tooltip_text` set
2. Timer starts (default delay)
3. Tooltip popup created and positioned
4. Tooltip hidden when mouse leaves or moves significantly

```cpp
// Tooltip state (conceptual)
gui.tooltip_timer          // Delay before showing
gui.tooltip_popup          // Current tooltip window
gui.tooltip_label          // Label displaying text
gui.tooltip_control        // Control that owns tooltip
```

Sources: [scene/main/viewport.cpp:3800-4000]()

---

## Container System Integration

Containers are special Control subclasses that automatically manage their children's layout:

```mermaid
graph TB
    Container["Container Base Class"]
    
    Container --> VBox["VBoxContainer<br/>Vertical layout"]
    Container --> HBox["HBoxContainer<br/>Horizontal layout"]
    Container --> Grid["GridContainer<br/>Grid layout"]
    Container --> Margin["MarginContainer<br/>Adds margins"]
    Container --> Scroll["ScrollContainer<br/>Scrollable area"]
    
    subgraph "Container Behavior"
        OnSort["queue_sort()"]
        OnSort --> NotifySort["NOTIFICATION_SORT_CHILDREN"]
        NotifySort --> FitChild["fit_child_in_rect()"]
        FitChild --> ChildRect["Child position/size set"]
    end
    
    VBox -.-> OnSort
    HBox -.-> OnSort
```

**Container hierarchy and layout notification flow**

### Container Layout Cycle

When a container needs to update its children's layout:

1. `queue_sort()` is called (explicitly or by `minimum_size_changed()`)
2. `MessageQueue` defers notification until next frame
3. Container receives `NOTIFICATION_SORT_CHILDREN`
4. Container calculates child positions based on:
   - Size flags from `get_h_size_flags()` and `get_v_size_flags()` (`SIZE_FILL`, `SIZE_EXPAND`, etc.)
   - Minimum sizes from `get_combined_minimum_size()`
   - Container-specific layout algorithm (e.g., VBoxContainer, GridContainer)
5. Calls `fit_child_in_rect(child, rect)` for each child, which:
   - Sets child's `data.rect_position` and `data.rect_size`
   - Calls child's `_size_changed()` 
   - Triggers `NOTIFICATION_RESIZED` on child

```mermaid
sequenceDiagram
    participant C as Container
    participant MQ as MessageQueue
    participant Child as Child Control
    
    Note over C: Child size changes
    Child->>Child: set_size() or<br/>update_minimum_size()
    Child->>C: minimum_size_changed()
    C->>C: queue_sort()
    C->>MQ: Defer NOTIFICATION_SORT_CHILDREN
    
    Note over MQ: Next frame
    MQ->>C: NOTIFICATION_SORT_CHILDREN
    C->>C: Container-specific layout logic
    
    loop For each child
        C->>Child: get_combined_minimum_size()
        Child-->>C: Size2 min_size
        C->>Child: get_h_size_flags()
        Child-->>C: BitField<SizeFlags>
        C->>C: Calculate rect
        C->>Child: fit_child_in_rect(rect)
        Child->>Child: _size_changed()
        Child->>Child: NOTIFICATION_RESIZED
    end
```

**Container layout notification cycle**

Sources: [scene/gui/control.cpp:537-587, 1200-1400](), [scene/gui/container.cpp:50-150](), [doc/classes/Control.xml:1-25]()

### Property Management in Containers

When a control is inside a container, certain properties become read-only as the container manages them:

```cpp
// Properties managed by containers
static String properties_managed_by_container[] = {
    "offset_left", "offset_top", "offset_right", "offset_bottom",
    "anchor_left", "anchor_top", "anchor_right", "anchor_bottom",
    "position", "rotation", "scale", "size"
};
```

Sources: [scene/gui/control.cpp:282-295]()

---

## Size and Minimum Size System

Controls define their minimum required size through `get_combined_minimum_size()`:

```mermaid
graph LR
    A["_get_minimum_size()<br/>(virtual)"] --> B["get_minimum_size()"]
    C["custom_minimum_size<br/>(property)"] --> D["get_combined_minimum_size()"]
    B --> D
    D --> E["Used by Layout System"]
    
    style A fill:#f0f0f0
    style C fill:#f0f0f0
```

**Minimum size calculation flow**

The system provides two extension points:

1. **Override `_get_minimum_size()`** - Define intrinsic minimum size based on content
2. **Set `custom_minimum_size`** - Force a specific minimum size

Containers query `get_combined_minimum_size()` when laying out children:

```cpp
// Minimum size calculation
Size2 Control::get_combined_minimum_size() const {
    Size2 minsize = get_minimum_size();
    minsize = minsize.max(custom_minimum_size);
    return minsize;
}
```

Sources: [scene/gui/control.cpp:1000-1100]()

---

## Drag and Drop System

The Control class provides virtual methods for drag and drop operations. The Viewport manages drag state in `gui.drag_data` and `gui.drag_preview`:

```mermaid
sequenceDiagram
    participant Source as Source Control
    participant VP as Viewport
    participant Target as Target Control
    
    Note over Source: Mouse drag detected
    VP->>Source: _get_drag_data(pos)
    Source->>Source: GDVIRTUAL_CALL(_get_drag_data)
    Source->>VP: set_drag_preview(control)
    VP->>VP: gui.drag_data = data<br/>gui.drag_preview = control
    
    loop Mouse moves over controls
        VP->>VP: _gui_find_control_at_pos(mouse_pos)
        VP->>Target: _can_drop_data(pos, gui.drag_data)
        Target->>Target: GDVIRTUAL_CALL(_can_drop_data)
        Target-->>VP: true/false
        VP->>VP: Update cursor shape
    end
    
    Note over Target: Mouse button released
    VP->>Target: _can_drop_data(pos, gui.drag_data)
    alt Can Drop == true
        VP->>Target: _drop_data(pos, gui.drag_data)
        Target->>Target: GDVIRTUAL_CALL(_drop_data)
        Target->>Target: Process dropped data
    end
    
    VP->>VP: gui.drag_data = Variant()<br/>gui.drag_preview = nullptr
```

**Drag and drop operation sequence with Viewport state management**

### Virtual Methods for Drag and Drop

Controls override these methods to implement drag and drop:

| Method | Purpose | Returns |
|--------|---------|---------|
| `_get_drag_data(pos)` | Provide data to drag | Variant (data) or null |
| `_can_drop_data(pos, data)` | Validate if drop is allowed | bool |
| `_drop_data(pos, data)` | Handle the drop operation | void |

Example implementation pattern:

```cpp
// Implementing drag source
Variant MyControl::_get_drag_data(const Point2 &p_point) {
    Dictionary data;
    data["type"] = "my_data";
    data["value"] = get_data();
    
    // Set visual preview
    Control *preview = create_drag_preview();
    set_drag_preview(preview);
    
    return data;
}

// Implementing drop target
bool MyControl::_can_drop_data(const Point2 &p_point, const Variant &p_data) {
    if (p_data.get_type() != Variant::DICTIONARY) return false;
    Dictionary d = p_data;
    return d.has("type") && d["type"] == "my_data";
}

void MyControl::_drop_data(const Point2 &p_point, const Variant &p_data) {
    Dictionary d = p_data;
    process_dropped_data(d["value"]);
}
```

Sources: [doc/classes/Control.xml:33-86](), [scene/gui/control.cpp:3000-3200]()

---

## Accessibility Integration

The Control system integrates with the accessibility API to support screen readers. Each Node (including Control) can have an `accessibility_element` RID registered with DisplayServer:

```mermaid
graph TB
    C["Control Node"] --> AE["data.accessibility_element (RID)"]
    
    C --> Props["Accessibility Properties"]
    Props --> Name["accessibility_name<br/>(virtual method)"]
    Props --> Desc["accessibility_description<br/>(virtual method)"]
    Props --> Role["ROLE_BUTTON, ROLE_TEXT_FIELD, etc."]
    
    AE --> DS["DisplayServer::accessibility_*()"]
    DS --> Backend["AccessKit backend<br/>(platform-specific)"]
    Backend --> SR["Screen Reader"]
    
    C --> Update["NOTIFICATION_ACCESSIBILITY_UPDATE"]
    Update --> UpdateCall["DisplayServer::accessibility_update_set_*()"]
    UpdateCall --> DS
```

**Control accessibility system integration**

Controls receive `NOTIFICATION_ACCESSIBILITY_UPDATE` when accessibility information needs to be refreshed. The SceneTree batches these updates in `accessibility_change_queue` and sends them to DisplayServer:

```cpp
// From scene_tree.cpp:245-295 - Accessibility notification flow
void SceneTree::_process_accessibility_changes(DisplayServer::WindowID p_window_id) {
    for (const ObjectID &id : accessibility_change_queue) {
        Node *node = Object::cast_to<Node>(ObjectDB::get_instance(id));
        if (!node || !node->get_non_popup_window()) {
            continue; // Skip invalid or non-visible nodes
        }
        // Send notification which updates DisplayServer
        node->notification(Node::NOTIFICATION_ACCESSIBILITY_UPDATE);
    }
    
    // Track focused element
    Control *n_focus = w_this->gui_get_focus_owner();
    if (n_focus) {
        RID new_focus_element = n_focus->get_focused_accessibility_element();
        DisplayServer::get_singleton()->accessibility_update_set_focus(new_focus_element);
    }
}
```

The Node class implementation (lines 69-88) handles:
- Creating accessibility elements via `DisplayServer::accessibility_create_element()`
- Populating element properties (name, role, children)
- Freeing elements on `NOTIFICATION_ACCESSIBILITY_INVALIDATE`

Sources: [scene/main/scene_tree.cpp:245-295](), [scene/main/node.cpp:62-89](), [scene/gui/control.cpp:254-273]()

---

## Key Classes and Files

| Class | File | Primary Responsibilities |
|-------|------|-------------------------|
| `Control` | [scene/gui/control.cpp]() | Base UI class, layout, theming, input |
| `Viewport` | [scene/main/viewport.cpp]() | GUI state, input dispatch, rendering |
| `Window` | [scene/main/window.cpp]() | Window management, embedded vs native |
| `Container` | [scene/gui/container.cpp]() | Automatic child layout |
| `SceneTree` | [scene/main/scene_tree.cpp]() | Scene hierarchy, group management |

### Important Enums and Constants

```cpp
// From control.h
enum FocusMode {
    FOCUS_NONE,           // Cannot receive focus
    FOCUS_CLICK,          // Focus on click
    FOCUS_ALL,            // Focus on click or Tab
    FOCUS_ACCESSIBILITY   // Accessibility only
};

enum LayoutMode {
    LAYOUT_MODE_POSITION,      // Manual positioning
    LAYOUT_MODE_ANCHORS,       // Anchor-based layout
    LAYOUT_MODE_CONTAINER,     // Container-managed
    LAYOUT_MODE_UNCONTROLLED   // No automatic layout
};

enum MouseFilter {
    MOUSE_FILTER_STOP,    // Receive and stop events
    MOUSE_FILTER_PASS,    // Receive but pass through
    MOUSE_FILTER_IGNORE   // Ignore all mouse events
};
```

Sources: [scene/gui/control.h:65-152]()

---

## Common Use Patterns

### Creating a Custom Control

```cpp
class MyControl : public Control {
    GDCLASS(MyControl, Control);
    
protected:
    // Virtual methods to override
    virtual void _gui_input(const Ref<InputEvent> &p_event) override;
    virtual Size2 _get_minimum_size() const override;
    virtual void _notification(int p_what) override;
    
public:
    // Custom implementation
    void _gui_input(const Ref<InputEvent> &p_event) {
        Ref<InputEventMouseButton> mb = p_event;
        if (mb.is_valid() && mb->is_pressed()) {
            // Handle mouse click
            accept_event();  // Stop propagation
        }
    }
    
    Size2 _get_minimum_size() const {
        // Calculate based on content
        return Size2(100, 50);
    }
};
```

### Responding to Theme Changes

```cpp
void MyControl::_notification(int p_what) {
    switch (p_what) {
        case NOTIFICATION_THEME_CHANGED: {
            // Refresh cached theme items
            font = get_theme_font("font");
            font_size = get_theme_font_size("font_size");
            color = get_theme_color("font_color");
            queue_redraw();
        } break;
    }
}
```

### Container Layout Implementation

```cpp
void MyContainer::_notification(int p_what) {
    switch (p_what) {
        case NOTIFICATION_SORT_CHILDREN: {
            // Calculate positions for each child
            Size2 size = get_size();
            for (int i = 0; i < get_child_count(); i++) {
                Control *child = Object::cast_to<Control>(get_child(i));
                if (!child || !child->is_visible()) continue;
                
                // Position based on container logic
                Rect2 rect = calculate_child_rect(child, i);
                fit_child_in_rect(child, rect);
            }
        } break;
    }
}
```

Sources: [scene/gui/control.cpp:1-620](), [doc/classes/Control.xml:1-25]()27:T4e00,# Window Management

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/os/main_loop.cpp](core/os/main_loop.cpp)
- [core/os/main_loop.h](core/os/main_loop.h)
- [doc/classes/Control.xml](doc/classes/Control.xml)
- [doc/classes/MainLoop.xml](doc/classes/MainLoop.xml)
- [doc/classes/Node.xml](doc/classes/Node.xml)
- [doc/classes/SceneTree.xml](doc/classes/SceneTree.xml)
- [doc/classes/Viewport.xml](doc/classes/Viewport.xml)
- [doc/classes/Window.xml](doc/classes/Window.xml)
- [scene/gui/control.cpp](scene/gui/control.cpp)
- [scene/gui/control.h](scene/gui/control.h)
- [scene/main/node.cpp](scene/main/node.cpp)
- [scene/main/node.h](scene/main/node.h)
- [scene/main/scene_tree.cpp](scene/main/scene_tree.cpp)
- [scene/main/scene_tree.h](scene/main/scene_tree.h)
- [scene/main/viewport.cpp](scene/main/viewport.cpp)
- [scene/main/viewport.h](scene/main/viewport.h)
- [scene/main/window.cpp](scene/main/window.cpp)
- [scene/main/window.h](scene/main/window.h)

</details>



## Purpose and Scope

This document describes the window management system in Godot Engine, focusing on the `Window` class and its integration with the `Viewport` system. Windows in Godot can exist as either native operating system windows or as embedded subwindows within other windows. This page covers window lifecycle, positioning, modes, focus management, and the interaction between windows and viewports.

For information about the base viewport rendering and input handling, see [Viewport System](#4.3). For UI controls that exist within windows, see [Control & UI System](#4.4).

Sources: [scene/main/window.h:1-250](), [scene/main/window.cpp:1-100](), [scene/main/viewport.h:1-100]()

## Window Class Hierarchy and Core Concepts

The `Window` class inherits from `Viewport`, making every window a viewport with additional windowing capabilities. Windows can be displayed as native OS windows or embedded as subwindows within a parent viewport.

```mermaid
graph TB
    Object["Object"]
    Node["Node"]
    Viewport["Viewport<br/>(scene/main/viewport.h)"]
    Window["Window<br/>(scene/main/window.h)"]
    
    Object --> Node
    Node --> Viewport
    Viewport --> Window
    
    Window --> NativeWindow["Native Window<br/>window_id != INVALID_WINDOW_ID<br/>embedder == nullptr"]
    Window --> EmbeddedWindow["Embedded Window<br/>window_id == INVALID_WINDOW_ID<br/>embedder != nullptr"]
    
    EmbeddedWindow --> SubWindowStruct["SubWindow struct<br/>in Viewport::gui.sub_windows"]
```

Sources: [scene/main/window.h:43-45](), [scene/main/viewport.h:95-96](), [scene/main/viewport.cpp:308-340]()

### Key Window Properties

| Property | Type | Purpose |
|----------|------|---------|
| `window_id` | `DisplayServer::WindowID` | Native OS window identifier (INVALID_WINDOW_ID if embedded) |
| `embedder` | `Viewport*` | Parent viewport hosting this embedded window |
| `mode` | `Mode` | Window display mode (windowed, minimized, maximized, fullscreen) |
| `position` | `Point2i` | Window position in screen coordinates |
| `size` | `Size2i` | Window size in pixels |
| `visible` | `bool` | Window visibility state |
| `flags[]` | `bool[FLAG_MAX]` | Window behavior flags (borderless, transparent, etc.) |

Sources: [scene/main/window.h:174-230]()

## Window Types: Native vs Embedded

### Native Windows

Native windows are created through the `DisplayServer` API and appear as separate OS windows. They have independent rendering contexts and window decorations provided by the operating system.

**Characteristics:**
- `window_id != DisplayServer::INVALID_WINDOW_ID`
- `embedder == nullptr`
- Root window (SceneTree root) is always a native window
- Can be moved outside the main application window
- Have OS-provided title bars and decorations (unless FLAG_BORDERLESS)

**Creation Flow:**
```mermaid
sequenceDiagram
    participant W as Window
    participant DS as DisplayServer
    participant VP as Viewport
    
    W->>W: _make_window()
    W->>DS: window_create(window_id)
    DS-->>W: Returns window_id
    W->>DS: window_set_mode(mode)
    W->>DS: window_set_position(position)
    W->>DS: window_set_size(size)
    W->>VP: RenderingServer::viewport_set_update_mode()
```

Sources: [scene/main/window.cpp:1389-1497]()

### Embedded Windows

Embedded windows (subwindows) are rendered within their parent viewport. They are managed by the parent's `Viewport::gui` system and drawn as canvas items.

**Characteristics:**
- `window_id == DisplayServer::INVALID_WINDOW_ID`
- `embedder != nullptr` (points to parent viewport)
- Rendered as `SubWindow` entries in `Viewport::gui.sub_windows`
- Each has a `canvas_item` RID for rendering
- Custom title bar and borders drawn by theme (unless FLAG_BORDERLESS)

**SubWindow Structure:**
```mermaid
graph LR
    Viewport["Viewport::gui"]
    SubWindowList["sub_windows: Vector&lt;SubWindow&gt;"]
    SubWindow["SubWindow struct"]
    CanvasItem["canvas_item: RID"]
    WindowPtr["window: Window*"]
    
    Viewport --> SubWindowList
    SubWindowList --> SubWindow
    SubWindow --> CanvasItem
    SubWindow --> WindowPtr
    SubWindow --> PendingUpdate["pending_window_update: bool"]
```

Sources: [scene/main/viewport.h:337-342](), [scene/main/viewport.cpp:308-340]()

## Window Registration and Lifecycle

### Embedded Window Registration

When a `Window` is added to the scene tree and embedded mode is enabled (`Viewport.gui_embed_subwindows`), it registers with its parent viewport:

```mermaid
sequenceDiagram
    participant W as Window
    participant VP as Parent Viewport
    participant RS as RenderingServer
    
    W->>VP: _sub_window_register(this)
    VP->>VP: Check if subwindow_canvas exists
    alt subwindow_canvas not created
        VP->>RS: canvas_create()
        VP->>RS: viewport_attach_canvas()
        VP->>RS: viewport_set_canvas_stacking(SUBWINDOW_CANVAS_LAYER)
    end
    VP->>RS: canvas_item_create()
    RS-->>VP: Returns canvas_item RID
    VP->>RS: canvas_item_set_parent(canvas_item, subwindow_canvas)
    VP->>VP: Add SubWindow{canvas_item, window} to gui.sub_windows
    VP->>VP: _sub_window_update_order()
    VP->>RS: viewport_set_parent_viewport(window.viewport, viewport)
```

Sources: [scene/main/viewport.cpp:308-340]()

### Window Removal

```mermaid
sequenceDiagram
    participant W as Window
    participant VP as Parent Viewport
    participant RS as RenderingServer
    
    W->>VP: _sub_window_remove(this)
    VP->>VP: Find SubWindow index
    VP->>VP: Check if subwindow_over == this
    alt Is subwindow over
        VP->>W: _mouse_leave_viewport()
        VP->>VP: gui.subwindow_over = nullptr
    end
    VP->>RS: free_rid(canvas_item)
    VP->>VP: Remove from gui.sub_windows
    alt gui.sub_windows is empty
        VP->>RS: free_rid(subwindow_canvas)
        VP->>VP: subwindow_canvas = RID()
    end
    VP->>VP: Update focus if needed
    VP->>RS: viewport_set_parent_viewport(window.viewport, RID())
```

Sources: [scene/main/viewport.cpp:478-529]()

## Window Modes and Flags

### Window Modes

The `Window::Mode` enum defines the display state:

| Mode | Value | Description |
|------|-------|-------------|
| `MODE_WINDOWED` | 0 | Normal windowed mode |
| `MODE_MINIMIZED` | 1 | Window minimized to taskbar |
| `MODE_MAXIMIZED` | 2 | Window maximized to screen |
| `MODE_FULLSCREEN` | 3 | Borderless fullscreen |
| `MODE_EXCLUSIVE_FULLSCREEN` | 4 | Exclusive fullscreen with mode change |

**Mode Setting:**
```
Window::set_mode(Mode p_mode)
â”œâ”€ If embedded: embedder->_sub_window_update(this)
â””â”€ If native: DisplayServer::window_set_mode(mode, window_id)
```

Sources: [scene/main/window.h:48-54](), [scene/main/window.cpp:523-533]()

### Window Flags

| Flag | Purpose |
|------|---------|
| `FLAG_RESIZE_DISABLED` | Prevents window resizing |
| `FLAG_BORDERLESS` | Removes window decorations |
| `FLAG_ALWAYS_ON_TOP` | Keeps window above others |
| `FLAG_TRANSPARENT` | Enables transparent background |
| `FLAG_NO_FOCUS` | Window cannot receive focus (for tooltips, splash screens) |
| `FLAG_POPUP` | Marks window as popup (affects input handling) |
| `FLAG_EXTEND_TO_TITLE` | Extends content area into title bar |
| `FLAG_MOUSE_PASSTHROUGH` | Mouse events pass through window |
| `FLAG_SHARP_CORNERS` | Disables rounded corners on Windows 11 |

Sources: [scene/main/window.h:56-73]()

## Window Positioning and Sizing

### Initial Position

The `WindowInitialPosition` enum controls where windows appear on creation:

```mermaid
graph TD
    WindowInit["Window Creation"]
    CheckPosition["Check initial_position"]
    
    WindowInit --> CheckPosition
    CheckPosition -->|ABSOLUTE| UsePosition["Use position property"]
    CheckPosition -->|CENTER_PRIMARY_SCREEN| CenterPrimary["Center on primary monitor"]
    CheckPosition -->|CENTER_MAIN_WINDOW_SCREEN| CenterMain["Center on main window's screen"]
    CheckPosition -->|CENTER_OTHER_SCREEN| CenterOther["Center on current_screen"]
    
    UsePosition --> Apply["Apply position"]
    CenterPrimary --> Calculate["Calculate center"]
    CenterMain --> Calculate
    CenterOther --> Calculate
    Calculate --> Apply
```

Sources: [scene/main/window.cpp:331-343](), [scene/main/window.cpp:382-399]()

### Size Constraints

Windows can have minimum and maximum size constraints:

```cpp
// Window::set_min_size and set_max_size
Size2i _clamp_limit_size(const Size2i &p_limit_size)
â”œâ”€ Get max_window_size from RenderingServer
â”œâ”€ Clamp to [Vector2i(), max_window_size]
â””â”€ Return clamped value

void _validate_limit_size()
â”œâ”€ Check if max_size is valid
â”œâ”€ If valid: max_size_used = max_size
â””â”€ Else: max_size_used = RS::get_maximum_viewport_size()
```

Sources: [scene/main/window.cpp:461-476](), [scene/main/window.cpp:500-521]()

### Position and Size Update Flow

```mermaid
sequenceDiagram
    participant U as User/Script
    participant W as Window
    participant VP as Embedder Viewport
    participant DS as DisplayServer
    
    U->>W: set_position(pos) or set_size(size)
    W->>W: Update position/size property
    
    alt Window is embedded
        W->>VP: embedder->_sub_window_update(this)
        VP->>VP: Update SubWindow canvas_item
        Note over VP: Redraws borders and content
    else Window is native
        W->>DS: window_set_position(pos, window_id)
        Note over DS: OS updates window
    end
```

Sources: [scene/main/window.cpp:363-374](), [scene/main/window.cpp:401-413]()

## Focus and Z-Order Management

### Focus Management

Window focus is managed through the parent viewport for embedded windows, or through the DisplayServer for native windows:

```mermaid
graph TB
    FocusChange["Focus Change Event"]
    CheckType["Check Window Type"]
    
    FocusChange --> CheckType
    CheckType -->|Embedded| SubWindowFocus["Viewport::_sub_window_grab_focus()"]
    CheckType -->|Native| DisplayServerFocus["DisplayServer focus handling"]
    
    SubWindowFocus --> CheckNoFocus["Check FLAG_NO_FOCUS"]
    CheckNoFocus -->|true| MoveToForeground["Move to foreground<br/>No focus granted"]
    CheckNoFocus -->|false| GrantFocus["Grant focus"]
    
    GrantFocus --> OldFocus["Send FOCUS_OUT to old focus"]
    OldFocus --> NewFocus["Send FOCUS_IN to new window"]
    NewFocus --> UpdateOrder["_sub_window_update_order()"]
    UpdateOrder --> UpdateDisplay["_sub_window_update() for affected windows"]
```

Sources: [scene/main/viewport.cpp:404-476]()

### Subwindow Z-Order

The `_sub_window_update_order()` method maintains the rendering order of embedded windows:

**Priority Rules:**
1. Windows with `FLAG_ALWAYS_ON_TOP` are moved to the end (drawn last/on top)
2. Children of always-on-top windows with `is_exclusive()` follow their parent
3. Exclusive children are placed immediately after their parent window
4. Draw order is set via `RenderingServer::canvas_item_set_draw_index()`

```mermaid
graph TD
    Start["_sub_window_update_order()"]
    CheckCount["gui.sub_windows.size() < 2?"]
    
    Start --> CheckCount
    CheckCount -->|Yes| Return["Return early"]
    CheckCount -->|No| AlwaysOnTop["Process always-on-top windows"]
    
    AlwaysOnTop --> FindAlwaysOn["Iterate from last to first"]
    FindAlwaysOn --> CheckFlag["Window has FLAG_ALWAYS_ON_TOP?"]
    CheckFlag -->|Yes| MoveToEnd["Move to end of list"]
    CheckFlag -->|No| CheckParent["Parent is always-on-top<br/>and window is exclusive?"]
    CheckParent -->|Yes| MoveToEnd
    CheckParent -->|No| Continue["Continue"]
    
    MoveToEnd --> Exclusive["Process exclusive children"]
    Continue --> Exclusive
    
    Exclusive --> FindExclusive["For each window with exclusive_child"]
    FindExclusive --> MoveChild["Move exclusive child after parent"]
    MoveChild --> SetIndices["Set canvas_item_set_draw_index for all"]
```

Sources: [scene/main/viewport.cpp:270-306]()

## Exclusive Windows (Modal Dialogs)

Exclusive windows implement modal dialog behavior, where a child window blocks interaction with its parent:

### Exclusive Window Properties

```
Window properties:
â”œâ”€ exclusive_child: Window* (the modal dialog)
â”œâ”€ transient_parent: Window* (the window that opened this modal)
â””â”€ is_in_edited_scene_root() check prevents editor interference
```

### Setting Up Exclusivity

```mermaid
sequenceDiagram
    participant Dialog as Modal Dialog
    participant Parent as Parent Window
    participant VP as Viewport
    
    Dialog->>Parent: set_transient(true)
    Parent->>Parent: Store as exclusive_child
    Dialog->>Dialog: Set exclusive flag
    
    Note over Dialog,VP: When dialog becomes visible
    Dialog->>VP: Show/popup
    VP->>VP: _sub_window_update_order()
    Note over VP: Exclusive child placed<br/>after parent in z-order
    
    Note over Dialog,Parent: Input blocked to parent<br/>until dialog closes
    
    Dialog->>Parent: Close/hide
    Parent->>Parent: exclusive_child = nullptr
```

Sources: [scene/main/window.cpp:889-965]()

### Exclusive Window in Z-Order

The z-order algorithm ensures exclusive children appear directly above their parents:

```cpp
// From _sub_window_update_order()
for (int parent_index = 0; parent_index < gui.sub_windows.size(); parent_index++) {
    Window *exclusive_child = gui.sub_windows[parent_index].window->get_exclusive_child();
    if (exclusive_child != nullptr && exclusive_child->is_visible()) {
        int child_index = _sub_window_find(exclusive_child);
        if (child_index < parent_index) {
            // Move child to appear after parent
            SubWindow sw = gui.sub_windows[child_index];
            gui.sub_windows.remove_at(child_index);
            gui.sub_windows.insert(parent_index, sw);
        }
    }
}
```

Sources: [scene/main/viewport.cpp:290-301]()

## Window Rendering and Theme Integration

### Embedded Window Rendering

Embedded windows are rendered as canvas items with theme-based decorations:

```mermaid
graph TB
    Update["Viewport::_sub_window_update(Window*)"]
    Clear["Clear canvas_item"]
    GetRect["Get window Rect2i(position, size)"]
    
    Update --> Clear
    Clear --> GetRect
    GetRect --> CheckBorderless["Check FLAG_BORDERLESS"]
    
    CheckBorderless -->|false| DrawBorder["Draw embedded_border StyleBox"]
    DrawBorder --> DrawTitle["Draw title text with title_font"]
    DrawTitle --> DrawCloseButton["Draw close icon"]
    DrawCloseButton --> DrawContent["Draw window content"]
    
    CheckBorderless -->|true| DrawContent
    
    DrawContent --> GetTransform["Get window_transform * stretch_transform"]
    GetTransform --> GetVisible["Get visible_rect"]
    GetVisible --> AddTexture["canvas_item_add_texture_rect(window texture)"]
```

Sources: [scene/main/viewport.cpp:342-402]()

### Theme Items for Embedded Windows

Embedded windows use the following theme items from `Window`:

| Theme Item | Type | Purpose |
|------------|------|---------|
| `embedded_border` | `StyleBox` | Border for focused window |
| `embedded_unfocused_border` | `StyleBox` | Border for unfocused window |
| `title_font` | `Font` | Font for title text |
| `title_font_size` | `int` | Size of title font |
| `title_color` | `Color` | Color of title text |
| `title_outline_modulate` | `Color` | Title outline color |
| `title_outline_size` | `int` | Title outline width |
| `title_height` | `int` | Height of title bar |
| `close` | `Texture2D` | Close button icon (normal) |
| `close_pressed` | `Texture2D` | Close button icon (pressed) |
| `close_h_offset` | `int` | Close button horizontal offset |
| `close_v_offset` | `int` | Close button vertical offset |

Sources: [scene/main/viewport.cpp:358-392]()

### Window Content Update

Window content is rendered to the window's viewport texture and displayed via the canvas item:

```
Window.viewport (RID)
â”œâ”€ Viewport rendering target
â”œâ”€ get_texture() returns ViewportTexture
â””â”€ Texture drawn in parent's canvas_item

canvas_item_add_texture_rect(sw.canvas_item, visible_rect, window_texture)
```

Sources: [scene/main/viewport.cpp:395-401]()

## Window Event Handling

### Window Event Callbacks

Windows receive notifications through the `_event_callback()` method:

```mermaid
graph TD
    Event["DisplayServer or Parent Event"]
    Callback["Window::_event_callback(event)"]
    
    Event --> Callback
    Callback --> FocusIn["WINDOW_EVENT_FOCUS_IN"]
    Callback --> FocusOut["WINDOW_EVENT_FOCUS_OUT"]
    Callback --> CloseRequest["WINDOW_EVENT_CLOSE_REQUEST"]
    Callback --> GoBack["WINDOW_EVENT_GO_BACK_REQUEST"]
    Callback --> DPIChange["WINDOW_EVENT_DPI_CHANGE"]
    Callback --> TitleChange["WINDOW_EVENT_TITLEBAR_CHANGE"]
    
    FocusIn --> EmitFocus["Emit focus_entered signal"]
    FocusOut --> EmitUnfocus["Emit focus_exited signal"]
    CloseRequest --> EmitClose["Emit close_requested signal"]
    GoBack --> EmitGoBack["Emit go_back_requested signal"]
    DPIChange --> UpdateScaling["Update content_scale_factor"]
    TitleChange --> UpdateTitle["Update _update_displayed_title()"]
```

Sources: [scene/main/window.cpp:1131-1235]()

### Subwindow Input Handling

For embedded windows, input events are intercepted by the parent viewport:

```
Viewport::_gui_call_input()
â”œâ”€ Check if event is over subwindow
â”œâ”€ Find topmost subwindow at position
â”œâ”€ Forward event to subwindow if hit
â””â”€ Handle subwindow dragging/resizing
```

The viewport manages subwindow dragging with states:
- `SUB_WINDOW_DRAG_DISABLED` - No drag
- `SUB_WINDOW_DRAG_MOVE` - Dragging window position  
- `SUB_WINDOW_DRAG_CLOSE` - Clicking close button
- `SUB_WINDOW_DRAG_RESIZE` - Resizing window (8 edge/corner modes)

Sources: [scene/main/viewport.cpp:2420-2800]()

## Window Visibility and Lifecycle States

```mermaid
stateDiagram-v2
    [*] --> Created: new Window()
    Created --> AddedToTree: add_child()
    
    AddedToTree --> InvisibleEmbedded: embedder != nullptr<br/>visible = false
    AddedToTree --> InvisibleNative: embedder == nullptr<br/>visible = false
    AddedToTree --> VisibleEmbedded: embedder != nullptr<br/>visible = true
    AddedToTree --> VisibleNative: embedder == nullptr<br/>visible = true
    
    InvisibleEmbedded --> VisibleEmbedded: show()
    VisibleEmbedded --> InvisibleEmbedded: hide()
    
    InvisibleNative --> VisibleNative: show()/_make_window()
    VisibleNative --> InvisibleNative: hide()/_clear_window()
    
    VisibleEmbedded --> [*]: remove_child()/free()
    VisibleNative --> [*]: remove_child()/free()
    InvisibleEmbedded --> [*]: remove_child()/free()
    InvisibleNative --> [*]: remove_child()/free()
    
    note right of VisibleEmbedded
        Registered in parent's
        gui.sub_windows
        Rendered as canvas_item
    end note
    
    note right of VisibleNative
        window_id != INVALID_WINDOW_ID
        Has DisplayServer window
    end note
```

Sources: [scene/main/window.cpp:1289-1319](), [scene/main/window.cpp:1389-1497](), [scene/main/window.cpp:1499-1568]()28:T6656,# Resource System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)

</details>



## Purpose and Scope

The Resource System manages the loading, caching, saving, and lifecycle of all asset data in Godot. Resources are reference-counted data containers that can be serialized to disk and shared across multiple objects. This document covers the core resource infrastructure, loading/saving mechanisms, caching strategies, and the import pipeline.

For information about specific resource types (textures, meshes, scenes, etc.), see their respective documentation. For node-based scene management, see [Scene System](#4). For editor-specific resource handling, see [Editor Core](#7).

---

## Resource Class and Fundamentals

The `Resource` class serves as the base for all asset types in Godot. Resources are reference-counted objects that can exist in three states:

| State | Path Format | Cached | Description |
|-------|-------------|--------|-------------|
| External | `res://path/file.ext` | Yes | Standalone resource files |
| Built-in | `res://scene.tscn::id` | Yes | Sub-resources embedded in scene files |
| Temporary | Empty or local only | No | Runtime-only resources |

**Resource Identification and Paths**

```mermaid
graph TB
    subgraph "Resource Identity"
        Path["path_cache<br/>(String)"]
        UID["ResourceUID::ID<br/>(int64)"]
        SceneID["scene_unique_id<br/>(String)"]
    end
    
    subgraph "Path Types"
        External["External Path<br/>res://texture.png"]
        BuiltIn["Built-in Path<br/>res://scene.tscn::abc123"]
        Local["Local Path<br/>local://123"]
    end
    
    subgraph "Resolution"
        Cache["ResourceCache::resources<br/>HashMap&lt;String, Resource*&gt;"]
        UIDMap["ResourceUID registry"]
    end
    
    Path --> External
    Path --> BuiltIn
    Path --> Local
    
    External --> Cache
    BuiltIn --> Cache
    UID --> UIDMap
    UIDMap --> Cache
```

Sources: [core/io/resource.h:73-75](), [core/io/resource.h:148](), [core/io/resource.h:198-216]()

**Resource Duplication and Local-to-Scene**

Resources support deep duplication with multiple modes controlled by `ResourceDeepDuplicateMode`:

- `RESOURCE_DEEP_DUPLICATE_NONE`: Shallow copy, references shared
- `RESOURCE_DEEP_DUPLICATE_INTERNAL`: Deep copy only built-in sub-resources
- `RESOURCE_DEEP_DUPLICATE_ALL`: Deep copy all sub-resources

The `resource_local_to_scene` property causes automatic duplication when a scene is instantiated, with `_setup_local_to_scene()` called for initialization.

Sources: [core/io/resource.h:63-67](), [core/io/resource.cpp:367-422](), [core/io/resource.cpp:424-453]()

---

## Resource Loading Architecture

### Overview

```mermaid
graph LR
    subgraph "Entry Points"
        LoadSync["ResourceLoader::load()"]
        LoadAsync["ResourceLoader::load_threaded_request()"]
    end
    
    subgraph "Core Loading"
        Validate["_validate_local_path()"]
        LoadStart["_load_start()"]
        LoadComplete["_load_complete()"]
        RunTask["_run_load_task()"]
    end
    
    subgraph "Format Handlers"
        FormatText["ResourceFormatLoaderText"]
        FormatBinary["ResourceFormatLoaderBinary"]
        FormatImporter["ResourceFormatImporter"]
    end
    
    subgraph "Output"
        ResourceCache["ResourceCache"]
        LoadToken["LoadToken"]
    end
    
    LoadSync --> Validate
    LoadAsync --> Validate
    Validate --> LoadStart
    LoadStart --> LoadToken
    LoadStart --> RunTask
    
    RunTask --> FormatText
    RunTask --> FormatBinary
    RunTask --> FormatImporter
    
    FormatText --> LoadComplete
    FormatBinary --> LoadComplete
    FormatImporter --> LoadComplete
    
    LoadComplete --> ResourceCache
```

Sources: [core/io/resource_loader.cpp:541-564](), [core/io/resource_loader.cpp:566-664]()

### ResourceLoader

The `ResourceLoader` singleton manages all resource loading operations. It maintains:

- **loader array**: Up to 64 `ResourceFormatLoader` instances registered for different file types
- **thread_load_tasks**: HashMap tracking active load operations
- **user_load_tokens**: HashMap of user-facing load tokens for threaded requests
- **res_ref_overrides**: Thread-local resource override map for nested loads

**Key Methods**

| Method | Purpose |
|--------|---------|
| `load()` | Synchronous load, blocks until complete |
| `load_threaded_request()` | Start async load, returns immediately |
| `load_threaded_get_status()` | Poll load progress |
| `load_threaded_get()` | Retrieve completed resource |
| `_load_start()` | Internal: initiate load task |
| `_run_load_task()` | Internal: worker thread function |
| `_load_complete()` | Internal: finalize and return resource |

Sources: [core/io/resource_loader.h:105-321](), [core/io/resource_loader.cpp:289-359]()

### Threaded Loading System

```mermaid
graph TB
    subgraph "Thread Load Task Structure"
        TLT["ThreadLoadTask"]
        TLT --> TaskID["task_id: WorkerThreadPool::TaskID"]
        TLT --> ThreadID["thread_id: Thread::ID"]
        TLT --> Status["status: ThreadLoadStatus"]
        TLT --> Token["load_token: LoadToken*"]
        TLT --> Resource["resource: Ref&lt;Resource&gt;"]
        TLT --> SubTasks["sub_tasks: HashSet&lt;String&gt;"]
        TLT --> Progress["progress: float"]
    end
    
    subgraph "Load Token"
        LT["LoadToken (RefCounted)"]
        LT --> LocalPath["local_path: String"]
        LT --> UserPath["user_path: String"]
        LT --> UserRC["user_rc: uint32_t"]
    end
    
    subgraph "Thread Safety"
        Mutex["thread_load_mutex"]
        CondVar["ConditionVariable (for non-pool threads)"]
    end
    
    TLT -.reference.- LT
    TLT -.synchronized by.- Mutex
    TLT --> CondVar
```

Sources: [core/io/resource_loader.h:176-210](), [core/io/resource_loader.h:129-138]()

**Thread Load Flow**

1. **Request**: `load_threaded_request()` creates `ThreadLoadTask` and `LoadToken`
2. **Execution**: Task runs via `WorkerThreadPool` or current thread
3. **Progress Tracking**: Dependencies tracked in `sub_tasks`, progress calculated recursively
4. **Completion**: Status updated to `THREAD_LOAD_LOADED` or `THREAD_LOAD_FAILED`
5. **Retrieval**: `load_threaded_get()` waits if needed, returns resource

**Cyclic Load Detection**: If a thread requests a resource it's already loading, `ERR_BUSY` is returned to prevent deadlock.

Sources: [core/io/resource_loader.cpp:363-503](), [core/io/resource_loader.cpp:697-740](), [core/io/resource_loader.cpp:742-807]()

---

## Resource Format Loaders

### ResourceFormatLoader Base Class

Each format loader implements:

```mermaid
graph LR
    subgraph "Required Methods"
        Load["load(path, original_path, ...)"]
        RecognizePath["recognize_path(path, type_hint)"]
        GetExtensions["get_recognized_extensions()"]
    end
    
    subgraph "Optional Methods"
        HandlesType["handles_type(type)"]
        GetType["get_resource_type(path)"]
        GetUID["get_resource_uid(path)"]
        GetDeps["get_dependencies(path, ...)"]
        Exists["exists(path)"]
    end
    
    subgraph "Cache Control"
        CacheMode["CacheMode parameter:<br/>IGNORE, REUSE, REPLACE,<br/>IGNORE_DEEP, REPLACE_DEEP"]
    end
    
    Load --> CacheMode
```

Sources: [core/io/resource_loader.h:47-95]()

### Text Format Loader

**ResourceLoaderText** parses `.tres` and `.tscn` files using `VariantParser`.

**File Structure**

```
[gd_resource type="Resource" format=4]
[ext_resource type="Script" path="res://script.gd" id="1_abc"]
[sub_resource type="Resource" id="2_xyz"]
property = value
[resource]
property = value
```

**Loading Process**

```mermaid
graph TB
    Open["open(FileAccess)"]
    ParseHeader["Parse [gd_resource] or [gd_scene]"]
    
    subgraph "Phase 1: External Resources"
        ParseExt["Parse [ext_resource] tags"]
        StartExtLoad["Call ResourceLoader::_load_start()"]
        StoreToken["Store LoadToken in ext_resources map"]
    end
    
    subgraph "Phase 2: Sub-Resources"
        ParseSub["Parse [sub_resource] tags"]
        InstantiateSub["Instantiate resource by type"]
        SetProps["Parse and set properties"]
        StoreSub["Store in int_resources map"]
    end
    
    subgraph "Phase 3: Main Resource"
        ParseMain["Parse [resource] or [node] tag"]
        CompleteExtLoads["Complete external resource loads"]
        ParseMainProps["Parse main resource properties"]
    end
    
    Open --> ParseHeader
    ParseHeader --> ParseExt
    ParseExt --> StartExtLoad
    StartExtLoad --> StoreToken
    StoreToken --> ParseSub
    ParseSub --> InstantiateSub
    InstantiateSub --> SetProps
    SetProps --> StoreSub
    StoreSub --> ParseMain
    ParseMain --> CompleteExtLoads
    CompleteExtLoads --> ParseMainProps
```

Sources: [scene/resources/resource_format_text.cpp:450-907](), [scene/resources/resource_format_text.h:40-155]()

**Sub-resource and Ext-resource Parsing**

When properties reference other resources, special parsers handle them:
- `_parse_sub_resource()`: Looks up in `int_resources` map by ID
- `_parse_ext_resource()`: Completes load from `ext_resources` LoadToken

Sources: [scene/resources/resource_format_text.cpp:104-123](), [scene/resources/resource_format_text.cpp:125-181]()

### Binary Format Loader

**ResourceLoaderBinary** parses `.res` and `.scn` files in a compact binary format.

**Binary Format Structure**

| Section | Content |
|---------|---------|
| Header | Magic bytes, version, type, UID |
| String table | Shared string pool |
| External resources | Paths and types of dependencies |
| Internal resources | Offsets to embedded resources |
| Resource data | Properties as binary-encoded variants |

**Loading Process**

```mermaid
graph TB
    OpenBinary["open(FileAccess)"]
    ReadHeader["Read header: magic, version, type"]
    ReadStrings["Read string table"]
    
    subgraph "External Resources"
        ReadExtCount["Read external resource count"]
        ReadExtData["For each: read type, path, UID"]
        StartExtLoads["Start parallel loads via _load_start()"]
    end
    
    subgraph "Internal Resources"
        ReadIntCount["Read internal resource count"]
        ReadIntOffsets["For each: read path, offset"]
    end
    
    subgraph "Load Each Internal"
        SeekOffset["Seek to offset"]
        ReadType["Read type string"]
        Instantiate["Instantiate by ClassDB"]
        ReadProps["Read property count"]
        ParseVariants["For each: parse_variant()"]
        SetProperty["Set property on resource"]
    end
    
    OpenBinary --> ReadHeader
    ReadHeader --> ReadStrings
    ReadStrings --> ReadExtCount
    ReadExtCount --> ReadExtData
    ReadExtData --> StartExtLoads
    StartExtLoads --> ReadIntCount
    ReadIntCount --> ReadIntOffsets
    ReadIntOffsets --> SeekOffset
    SeekOffset --> ReadType
    ReadType --> Instantiate
    Instantiate --> ReadProps
    ReadProps --> ParseVariants
    ParseVariants --> SetProperty
```

Sources: [core/io/resource_format_binary.cpp:681-1021](), [core/io/resource_format_binary.h:38-107]()

**Variant Parsing**

Binary resources store all data as encoded Variants. The `parse_variant()` method handles:
- Primitive types (int, float, string, etc.)
- Math types (Vector2, Transform3D, etc.)
- Container types (Array, Dictionary)
- Object references (via OBJECT_INTERNAL_RESOURCE or OBJECT_EXTERNAL_RESOURCE_INDEX)

Sources: [core/io/resource_format_binary.cpp:173-675]()

---

## Resource Caching System

### Cache Architecture

```mermaid
graph TB
    subgraph "ResourceCache (Global)"
        Lock["lock: Mutex"]
        Resources["resources: HashMap&lt;String, Resource*&gt;"]
    end
    
    subgraph "Cache Modes"
        Ignore["CACHE_MODE_IGNORE<br/>Don't cache this resource"]
        Reuse["CACHE_MODE_REUSE<br/>Use cache if present, add if not"]
        Replace["CACHE_MODE_REPLACE<br/>Use cache but refresh data"]
        IgnoreDeep["CACHE_MODE_IGNORE_DEEP<br/>Ignore recursively"]
        ReplaceDeep["CACHE_MODE_REPLACE_DEEP<br/>Replace recursively"]
    end
    
    subgraph "Operations"
        Has["ResourceCache::has(path)"]
        GetRef["ResourceCache::get_ref(path)"]
        SetPath["Resource::set_path(path)"]
    end
    
    Resources --> Has
    Resources --> GetRef
    SetPath --> Resources
    Lock -.protects.- Resources
```

Sources: [core/io/resource.h:198-216](), [core/io/resource_loader.h:51-57]()

### Cache Behavior by Mode

**CACHE_MODE_IGNORE**
- Resource not added to cache
- Sub-resources also ignored
- External dependencies use CACHE_MODE_REUSE
- Path set via `set_path_cache()` (doesn't touch cache)

**CACHE_MODE_REUSE** (Default)
- Check cache before loading
- If found, return cached instance
- If not found, load and add to cache
- Applies to main resource, sub-resources, and dependencies

**CACHE_MODE_REPLACE**
- Check cache for existing resource
- If found with matching type, call `copy_from()` to refresh data
- Preserves object identity (important for references)
- If not found or type mismatch, create new instance

Sources: [core/io/resource_loader.cpp:418-485]()

### Cache Synchronization

```mermaid
graph LR
    subgraph "Thread-Safe Operations"
        LoadTask["ThreadLoadTask"]
        Mutex["thread_load_mutex"]
        CacheLock["ResourceCache::lock"]
    end
    
    subgraph "Cache Update Sequence"
        CheckCache["Check cache (read lock)"]
        LoadResource["Load resource (no lock)"]
        AtomicUpdate["Atomic cache update (write lock)"]
    end
    
    LoadTask --> Mutex
    CheckCache --> CacheLock
    AtomicUpdate --> CacheLock
    
    Mutex -.coordinates.- LoadTask
```

During threaded loading:
1. Cache checked with lock before loading
2. Resource loaded without locks (main work)
3. Cache atomically updated after load completes
4. If cache race occurs, existing cached resource preferred

Sources: [core/io/resource_loader.cpp:428-450](), [core/io/resource.cpp:79-104]()

---

## Resource Paths and UIDs

### Path Resolution System

```mermaid
graph TB
    InputPath["Input Path"]
    
    subgraph "Path Types"
        UIDPath["UID Path<br/>uid://abc123..."]
        RelPath["Relative Path<br/>./file.res or ../file.res"]
        ResPath["Resource Path<br/>res://path/file.res"]
        UserPath["User Path<br/>user://path/file.res"]
    end
    
    subgraph "Resolution"
        UIDRegistry["ResourceUID::get_id_path()"]
        Localize["ProjectSettings::localize_path()"]
        Simplify["Path::simplify_path()"]
    end
    
    subgraph "Remapping"
        TranslationRemap["Translation remaps"]
        ImportRemap["Import remaps (.import)"]
    end
    
    InputPath --> UIDPath
    InputPath --> RelPath
    InputPath --> ResPath
    InputPath --> UserPath
    
    UIDPath --> UIDRegistry
    RelPath --> Localize
    ResPath --> TranslationRemap
    TranslationRemap --> ImportRemap
    
    UIDRegistry --> FinalPath["Final Path"]
    Localize --> FinalPath
    ImportRemap --> FinalPath
```

Sources: [core/io/resource_loader.cpp:505-514]()

### UID System

Resources can be identified by unique 64-bit IDs:
- **Format**: `uid://base32_encoded_id`
- **Storage**: `.import` files or directly in resource files (for `.uid` support)
- **Registry**: `ResourceUID` singleton maps IDs to paths
- **Fallback**: If UID path not found, falls back to explicit path

**UID in Dependencies**

Dependency strings can include UIDs:
```
uid://abc123::Type::res://fallback/path.res
```

Format: `{uid}::{type}::{fallback_path}` (type and fallback optional)

Sources: [core/io/resource_loader.cpp:114-125](), [scene/resources/resource_format_text.cpp:944-963]()

---

## Resource Import System

### Import Pipeline Overview

```mermaid
graph LR
    subgraph "Source Assets"
        SourceFile["Source File<br/>.png, .wav, .fbx, etc"]
    end
    
    subgraph "Import Metadata"
        ImportFile[".import File<br/>source.png.import"]
        ImportConfig["Import Configuration"]
    end
    
    subgraph "Import Process"
        Importer["ResourceImporter"]
        Process["import() method"]
    end
    
    subgraph "Output"
        ProcessedFile["Processed File<br/>.godot/imported/hash.ctex"]
        UID["Resource UID"]
    end
    
    subgraph "Runtime Loading"
        FormatImporter["ResourceFormatImporter"]
        ActualLoader["Actual format loader"]
    end
    
    SourceFile --> ImportFile
    ImportFile --> ImportConfig
    ImportConfig --> Importer
    Importer --> Process
    Process --> ProcessedFile
    Process --> UID
    
    SourceFile -.reference.- FormatImporter
    ImportFile --> FormatImporter
    FormatImporter --> ProcessedFile
    ProcessedFile --> ActualLoader
```

Sources: [core/io/resource_importer.h:41-107](), [core/io/resource_importer.cpp:43-200]()

### .import File Structure

```ini
[remap]
importer="texture"
type="CompressedTexture2D"
uid="uid://abc123"
path="res://.godot/imported/texture.png-hash.ctex"

[deps]
source_file="res://texture.png"
dest_files=["res://.godot/imported/texture.png-hash.ctex"]

[params]
compress/mode=0
compress/lossy_quality=0.7
```

**Key Fields**:
- `importer`: Name of ResourceImporter to use
- `type`: Expected resource type after import
- `uid`: Unique identifier for this resource
- `path`: Location of processed resource (may be platform-specific with `path.s3tc`, etc.)
- `metadata`: Optional data passed to loader (e.g., `has_editor_variant`)

Sources: [core/io/resource_importer.cpp:43-155]()

### ResourceFormatImporter

This special loader intercepts loading of source files that have `.import` metadata:

**Load Process**:
1. Check for `source.ext.import` file
2. Parse import metadata using `_get_path_and_type()`
3. Determine processed resource path (with platform-specific variants)
4. Load processed resource via `ResourceLoader::_load()`
5. Set import metadata on loaded resource

**Platform Variants**:
```
path.s3tc=".godot/imported/hash-s3tc.ctex"
path.etc2=".godot/imported/hash-etc2.ctex"
```

Loader selects variant based on `OS::has_feature()`.

Sources: [core/io/resource_importer.cpp:157-200](), [core/io/resource_importer.h:64-82]()

---

## Resource Saving

### ResourceSaver

The `ResourceSaver` singleton handles saving resources to disk.

```mermaid
graph TB
    subgraph "Save Entry Point"
        SaveMethod["ResourceSaver::save(resource, path, flags)"]
    end
    
    subgraph "Saver Selection"
        FindSaver["Find matching ResourceFormatSaver"]
        CheckPath["recognize_path(resource, path)"]
        CheckType["recognize(resource)"]
    end
    
    subgraph "Format Savers"
        TextSaver["ResourceFormatSaverText<br/>.tres, .tscn"]
        BinarySaver["ResourceFormatSaverBinary<br/>.res, .scn"]
        CustomSaver["Custom savers"]
    end
    
    subgraph "Save Process"
        Validate["Validate resource"]
        Serialize["Serialize to file"]
        SetPath["Update resource path"]
        SetUID["Generate/update UID"]
    end
    
    SaveMethod --> FindSaver
    FindSaver --> CheckPath
    FindSaver --> CheckType
    
    CheckPath --> TextSaver
    CheckPath --> BinarySaver
    CheckPath --> CustomSaver
    
    TextSaver --> Validate
    BinarySaver --> Validate
    CustomSaver --> Validate
    
    Validate --> Serialize
    Serialize --> SetPath
    SetPath --> SetUID
```

Sources: [core/io/resource_saver.cpp:100-202](), [core/io/resource_saver.h:58-106]()

### Save Flags

| Flag | Purpose |
|------|---------|
| `FLAG_NONE` | Default save behavior |
| `FLAG_RELATIVE_PATHS` | Save paths relative to scene |
| `FLAG_BUNDLE_RESOURCES` | Embed sub-resources instead of external files |
| `FLAG_CHANGE_PATH` | Update resource's path property |
| `FLAG_OMIT_EDITOR_PROPERTIES` | Skip editor-only properties |
| `FLAG_SAVE_BIG_ENDIAN` | Use big-endian byte order |
| `FLAG_COMPRESS` | Compress binary data |
| `FLAG_REPLACE_SUBRESOURCE_PATHS` | Update built-in resource paths |

Sources: [core/io/resource_saver.h:66-74]()

### Dependency Tracking During Save

When saving a resource, the saver must:
1. Collect all referenced resources (via `_find_resources()` recursion)
2. Determine which are sub-resources (built-in) vs external
3. Assign IDs to sub-resources (e.g., `SubResource_abc123`)
4. Write external resource references with paths/UIDs
5. Write sub-resource definitions inline

Sources: [core/io/resource_saver.cpp:100-202]()

---

## File Format Details

### Text Format (.tres, .tscn)

**Resource File Example**:
```
[gd_resource type="Texture2D" load_steps=2 format=4]

[ext_resource type="Image" path="res://image.png" id="1_abc"]

[resource]
image = ExtResource("1_abc")
flags = 7
```

**Scene File Example**:
```
[gd_scene load_steps=3 format=4]

[sub_resource type="Resource" id="1_xyz"]
property = "value"

[node name="Root" type="Node"]
script = SubResource("1_xyz")

[node name="Child" parent="." instance=ExtResource("2_def")]
```

**Tag Types**:
- `[gd_resource]` / `[gd_scene]`: Header
- `[ext_resource]`: External dependency
- `[sub_resource]`: Embedded resource definition
- `[resource]`: Main resource properties
- `[node]`: Node in scene tree
- `[connection]`: Signal connection
- `[editable]`: Editable instance path

Sources: [scene/resources/resource_format_text.h:42-49](), [scene/resources/resource_format_text.cpp:183-419]()

### Binary Format (.res, .scn)

**Header Structure**:
```
Magic: "RSRC" or "GDSC" (4 bytes)
Endianness: 0 (little) or 1 (big) (4 bytes)
Version: Format version (4 bytes)
Major/Minor/Format version (4 bytes each)
Type: Resource type string
UID: ResourceUID (8 bytes)
Flags: Unused (8 bytes)
```

**Variant Encoding**:
Each variant stored as:
```
Type ID (4 bytes)
Data (type-specific encoding)
Padding to 4-byte boundary
```

Object references encoded as:
- `OBJECT_EMPTY`: Null
- `OBJECT_INTERNAL_RESOURCE`: Index into internal resources
- `OBJECT_EXTERNAL_RESOURCE_INDEX`: Index into external resources

Sources: [core/io/resource_format_binary.cpp:45-101](), [core/io/resource_format_binary.h:38-124]()

---

## Key Implementation Details

### Translation Remapping

Resources can be remapped based on locale for translations:

```mermaid
graph LR
    OrigPath["Original Path<br/>res://text.txt"]
    TransMap["Translation Remaps<br/>HashMap&lt;String, Vector&lt;String&gt;&gt;"]
    Locale["Current Locale<br/>TranslationServer"]
    RemappedPath["Remapped Path<br/>res://text.es.txt"]
    
    OrigPath --> TransMap
    Locale --> TransMap
    TransMap --> RemappedPath
```

Remapping occurs in `_path_remap()` before resource loading.

Sources: [core/io/resource_loader.cpp:289-359]()

### Resource Changed Signals

During resource loading, signal connections may need special handling:
- On main thread: Use standard `connect()` directly
- On worker threads: Queue via `ResourceLoader::resource_changed_connect()`
- Connections stored in `ThreadLoadTask::resource_changed_connections`
- Migrated to proper signal system after load completes

Sources: [core/io/resource_loader.cpp:964-1006](), [core/io/resource.cpp:199-219]()

### Load Nesting and Sub-Resources

The loader tracks nesting level via `load_nesting` and `load_paths_stack`:
- Each `_load()` call increments nesting
- Parent tasks track child loads in `sub_tasks` HashSet
- Progress calculated recursively via `_dependency_get_progress()`
- Prevents counting same resource multiple times

Sources: [core/io/resource_loader.cpp:289-359](), [core/io/resource_loader.cpp:666-695]()

### Missing Resources

When classes are unavailable (e.g., from disabled plugins):
- `MissingResource` placeholder created if enabled
- Original class name preserved
- Properties recorded in metadata
- Allows round-trip editing without data loss

Sources: [core/io/resource_format_binary.cpp:773-778](), [scene/resources/resource_format_text.cpp:596-606]()

---

## Performance Considerations

### Threaded Loading Best Practices

1. **Use sub-threads**: Pass `use_sub_threads=true` to parallelize dependency loading
2. **Cache wisely**: Use `CACHE_MODE_REUSE` unless specifically need fresh data
3. **Batch requests**: Start all async loads before polling status
4. **Progress monitoring**: Poll status infrequently (e.g., per frame, not per loop iteration)

### Cache Performance

- **Global mutex**: `ResourceCache::lock` is a bottleneck for concurrent loads
- **Binary mutex**: Loader uses `SafeBinaryMutex<BINARY_MUTEX_TAG>` for load coordination
- **Lock minimization**: Critical sections kept minimal, resource work done unlocked

Sources: [core/io/resource_loader.cpp:428-450](), [core/io/resource_loader.h:140]()

### Memory Management

- Resources are reference-counted via `Ref<Resource>`
- Automatic cleanup when last reference released
- Cache holds raw pointers, not Refs, to avoid keeping resources alive
- Use `ResourceCache::get_ref()` to safely access cached resources

Sources: [core/io/resource.h:53-194]()29:T4b1e,# ResourceLoader

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)

</details>



ResourceLoader is the singleton responsible for loading all game assets (resources) from the filesystem into memory. It provides both synchronous and asynchronous loading mechanisms with automatic caching, threaded execution, and dependency resolution. For information about saving resources, see [ResourceSaver](#5.5). For details about the Resource base class, see [Resource Class](#5.2). For the import system that processes source assets into engine-ready formats, see [Resource Import System](#5.4).

**Sources:** [core/io/resource_loader.h:105-314](), [core/io/resource_loader.cpp:289-359]()

---

## System Architecture

ResourceLoader acts as a facade over multiple `ResourceFormatLoader` instances, each responsible for loading specific file formats. When a resource is requested, ResourceLoader queries registered loaders sequentially until one recognizes the file format and successfully loads it.

```mermaid
graph TB
    Client["Client Code"]
    RL["ResourceLoader<br/>(singleton)"]
    Cache["ResourceCache"]
    
    RFL1["ResourceFormatLoaderBinary<br/>(.res, .scn)"]
    RFL2["ResourceFormatLoaderText<br/>(.tres, .tscn)"]
    RFL3["ResourceFormatImporter<br/>(imported assets)"]
    RFLn["Custom ResourceFormatLoader"]
    
    Client --> RL
    RL --> Cache
    RL --> RFL1
    RL --> RFL2
    RL --> RFL3
    RL --> RFLn
    
    RFL1 --> Resource1["Resource Instance"]
    RFL2 --> Resource2["Resource Instance"]
    RFL3 --> Resource3["Resource Instance"]
    RFLn --> Resourcen["Resource Instance"]
```

**Sources:** [core/io/resource_loader.h:105-152](), [core/io/resource_loader.cpp:54]()

---

## Core Components

### ResourceLoader Singleton

The main entry point for all resource loading operations. Located in `core/io/resource_loader.cpp`, it maintains:

- Array of registered `ResourceFormatLoader` instances (max 64 loaders)
- Global resource cache via `ResourceCache`
- Thread-safe loading infrastructure with `SafeBinaryMutex`
- Translation remap tables for localization
- Load task tracking for threaded operations

**Key Data Structures:**

| Member | Type | Purpose |
|--------|------|---------|
| `loader[MAX_LOADERS]` | `Ref<ResourceFormatLoader>` | Registered format loaders |
| `thread_load_tasks` | `HashMap<String, ThreadLoadTask>` | Active threaded load operations |
| `user_load_tokens` | `HashMap<String, LoadToken*>` | User-facing load tokens for status queries |
| `translation_remaps` | `HashMap<String, Vector<String>>` | Path remapping for localization |

**Sources:** [core/io/resource_loader.h:105-152](), [core/io/resource_loader.cpp:54-56]()

---

### ResourceFormatLoader Plugin

Abstract base class for implementing custom resource loaders. Each loader declares which file extensions and resource types it handles.

```mermaid
classDiagram
    class ResourceFormatLoader {
        +load(path, original_path, error, use_sub_threads, progress, cache_mode) Ref~Resource~
        +recognize_path(path, for_type) bool
        +handles_type(type) bool
        +get_recognized_extensions(extensions) void
        +get_resource_type(path) String
        +get_resource_uid(path) ResourceUID_ID
        +get_dependencies(path, dependencies, add_types) void
        +exists(path) bool
    }
    
    class ResourceFormatLoaderBinary {
        +load() Ref~Resource~
        +handles_type() bool
    }
    
    class ResourceLoaderText {
        +load() Ref~Resource~
        +handles_type() bool
    }
    
    class ResourceFormatImporter {
        +load() Ref~Resource~
        +handles_type() bool
    }
    
    ResourceFormatLoader <|-- ResourceFormatLoaderBinary
    ResourceFormatLoader <|-- ResourceLoaderText
    ResourceFormatLoader <|-- ResourceFormatImporter
```

**Sources:** [core/io/resource_loader.h:47-95](), [core/io/resource_loader.cpp:58-79]()

---

## Loading Mechanisms

### Synchronous Loading

The `ResourceLoader::load()` function provides immediate, blocking resource loading:

```
ResourceLoader::load(path, type_hint, cache_mode, error)
  â†“
_validate_local_path(path) â†’ converts to "res://" format
  â†“
_load_start(path, type_hint, LOAD_THREAD_FROM_CURRENT, cache_mode)
  â†“
Creates ThreadLoadTask and executes in current thread
  â†“
_run_load_task() â†’ calls _load() â†’ iterates through format loaders
  â†“
First matching loader's load() method is called
  â†“
_load_complete() â†’ waits if needed, returns resource
```

**Sources:** [core/io/resource_loader.cpp:541-564]()

---

### Asynchronous/Threaded Loading

ResourceLoader supports fully asynchronous resource loading with three APIs:

1. **`load_threaded_request(path, type_hint, use_sub_threads, cache_mode)`** - Initiates load
2. **`load_threaded_get_status(path, progress)`** - Polls load status
3. **`load_threaded_get(path, error)`** - Retrieves completed resource

```mermaid
sequenceDiagram
    participant Client
    participant RL as ResourceLoader
    participant WTP as WorkerThreadPool
    participant Task as ThreadLoadTask
    
    Client->>RL: load_threaded_request(path)
    RL->>RL: Create LoadToken + ThreadLoadTask
    RL->>WTP: add_native_task(_run_load_task, task)
    RL-->>Client: OK
    
    Note over WTP,Task: Background thread
    WTP->>Task: _run_load_task()
    Task->>Task: _load() - iterates loaders
    Task->>Task: Format loader loads resource
    Task->>Task: Set status = THREAD_LOAD_LOADED
    
    Client->>RL: load_threaded_get_status(path)
    RL-->>Client: THREAD_LOAD_IN_PROGRESS (0.5 progress)
    
    Client->>RL: load_threaded_get_status(path)
    RL-->>Client: THREAD_LOAD_LOADED (1.0 progress)
    
    Client->>RL: load_threaded_get(path)
    RL-->>Client: Ref<Resource>
```

**Thread Load Modes:**

| Mode | Description | Use Case |
|------|-------------|----------|
| `LOAD_THREAD_FROM_CURRENT` | Execute in calling thread | Synchronous loading |
| `LOAD_THREAD_SPAWN_SINGLE` | Create single worker thread | Independent async load |
| `LOAD_THREAD_DISTRIBUTE` | Use sub-threads for dependencies | Large assets with many sub-resources |

**Sources:** [core/io/resource_loader.cpp:516-519](), [core/io/resource_loader.cpp:688-724](), [core/io/resource_loader.cpp:726-776]()

---

### ThreadLoadTask Structure

Internal structure tracking each load operation:

```mermaid
classDiagram
    class ThreadLoadTask {
        +WorkerThreadPool_TaskID task_id
        +Thread_ID thread_id
        +LoadToken* load_token
        +String local_path
        +String type_hint
        +float progress
        +ThreadLoadStatus status
        +CacheMode cache_mode
        +Error error
        +Ref~Resource~ resource
        +bool use_sub_threads
        +HashSet~String~ sub_tasks
        +LocalVector~ResourceChangedConnection~ resource_changed_connections
    }
```

**Status Flow:**

```
THREAD_LOAD_IN_PROGRESS
    â†“ (on success)
THREAD_LOAD_LOADED
    â†“ (on failure)
THREAD_LOAD_FAILED
```

**Sources:** [core/io/resource_loader.h:176-202](), [core/io/resource_loader.cpp:363-503]()

---

## Cache Modes

ResourceLoader supports five cache modes controlling how resources interact with the global `ResourceCache`:

| Mode | Behavior | Use Case |
|------|----------|----------|
| `CACHE_MODE_IGNORE` | Load fresh, don't cache | Temporary resources |
| `CACHE_MODE_REUSE` | Use cached if available | Normal loading (default) |
| `CACHE_MODE_REPLACE` | Update cached instance | Hot-reloading |
| `CACHE_MODE_IGNORE_DEEP` | Ignore cache recursively | Full reload |
| `CACHE_MODE_REPLACE_DEEP` | Replace cache recursively | Deep hot-reload |

**Cache Behavior in `_run_load_task()`:**

```mermaid
flowchart TD
    Start["_run_load_task()"]
    LoadResource["Call _load()"]
    CheckMode{"cache_mode?"}
    
    CheckIgnore{"IGNORE or<br/>IGNORE_DEEP?"}
    SetPathCache["set_path_cache()"]
    
    CheckCache["Check ResourceCache"]
    Exists{"Resource<br/>exists?"}
    
    Replace{"REPLACE or<br/>REPLACE_DEEP?"}
    CopyFrom["old_res.copy_from(new_res)"]
    SetPath["resource.set_path()"]
    
    Start --> LoadResource
    LoadResource --> CheckMode
    
    CheckMode --> CheckIgnore
    CheckIgnore -->|Yes| SetPathCache
    CheckIgnore -->|No| CheckCache
    
    CheckCache --> Exists
    Exists -->|Yes| Replace
    Exists -->|No| SetPath
    
    Replace -->|Yes| CopyFrom
    Replace -->|No| SetPath
```

**Sources:** [core/io/resource_loader.h:51-57](), [core/io/resource_loader.cpp:418-485]()

---

## Path Resolution and Remapping

### Path Validation

All paths are normalized through `_validate_local_path()`:

1. **UID to Path**: If path is a UID (`uid://...`), resolve to actual file path
2. **Relative to Absolute**: Convert relative paths to `res://` format
3. **Localization**: Apply via `ProjectSettings::localize_path()`

**Sources:** [core/io/resource_loader.cpp:505-514]()

### Translation Remapping

For localization, ResourceLoader maintains translation remap tables that redirect resource paths based on the current locale. This is managed by `_path_remap()`:

```
Original Path: "res://textures/button.png"
Locale: "es"
Remapped Path: "res://textures/button.es.png"
```

**Sources:** [core/io/resource_loader.cpp:1011-1032]()

---

## Dependency Management

### Dependency Loading

When a resource references other resources (e.g., a scene references textures), ResourceLoader handles dependency loading:

```mermaid
graph TB
    MainResource["Main Resource<br/>(scene.tscn)"]
    ExtRes1["External Resource 1<br/>(texture.png)"]
    ExtRes2["External Resource 2<br/>(material.tres)"]
    SubRes1["Sub-resource 1<br/>(ShaderMaterial)"]
    
    MainResource -->|ext_resource id=1| ExtRes1
    MainResource -->|ext_resource id=2| ExtRes2
    MainResource -->|sub_resource id=3| SubRes1
    
    SubRes1 -->|depends on| ExtRes2
```

**Load Flow:**

1. Parse external resource declarations in file header
2. Call `_load_start()` for each external resource (possibly threaded)
3. Parse sub-resources embedded in the file
4. Construct main resource, resolving all references

**Sources:** [scene/resources/resource_format_text.cpp:421-505](), [core/io/resource_format_binary.cpp:681-708]()

### Cyclic Dependency Detection

ResourceLoader detects cyclic dependencies during threaded loads:

```
If current thread is loading resource A,
and resource A depends on resource B,
and resource B depends on resource A,
then the second load of A returns ERR_BUSY
```

**Sources:** [core/io/resource_loader.cpp:805-816]()

---

## LoadToken System

`LoadToken` is a reference-counted handle representing a load operation:

```mermaid
classDiagram
    class LoadToken {
        +String local_path
        +String user_path
        +uint32_t user_rc
        +ThreadLoadTask* task_if_unregistered
        +clear() void
    }
    
    class ResourceLoader {
        +HashMap user_load_tokens
    }
    
    class ThreadLoadTask {
        +LoadToken* load_token
    }
    
    ResourceLoader --> LoadToken : manages
    ThreadLoadTask --> LoadToken : references
```

**Lifecycle:**

1. Created by `_load_start()`
2. Referenced by `ThreadLoadTask`
3. User holds reference via `load_threaded_request()`
4. Cleaned up when all references released

**Sources:** [core/io/resource_loader.h:129-138](), [core/io/resource_loader.cpp:242-287]()

---

## Thread Safety

ResourceLoader uses multiple mechanisms for thread safety:

### Mutexes

- **`thread_load_mutex`**: `SafeBinaryMutex<BINARY_MUTEX_TAG>` protecting:
  - `thread_load_tasks` map
  - `user_load_tokens` map
  - Load token reference counts

### Worker Thread Pool Integration

When loading from a worker thread task, ResourceLoader handles thread nesting correctly:

```
Main Thread
  â†“ spawns
Worker Thread (loading scene A)
  â†“ spawns
Worker Thread (loading texture B)
  â†“ spawns
Worker Thread (loading material C)
```

**Deadlock Prevention:**

If a worker thread attempts to wait for an older task (potential deadlock), ResourceLoader detects this via `WorkerThreadPool::wait_for_task_completion()` returning `ERR_BUSY`. It then executes the load directly in the current thread to break the cycle.

**Sources:** [core/io/resource_loader.cpp:818-845]()

### MessageQueue for Non-Main Threads

Loaders running on non-main threads use per-thread message queues for deferred operations like signal connections:

```
Thread-Local MessageQueue created
  â†“
Load operations execute
  â†“
Signal connections queued to main MessageQueue
  â†“
Thread-Local MessageQueue flushed
```

**Sources:** [core/io/resource_loader.cpp:378-399]()

---

## Key APIs

### Registration

```cpp
// Register a format loader
void ResourceLoader::add_resource_format_loader(
    Ref<ResourceFormatLoader> p_format_loader, 
    bool p_at_front = false
)

// Remove a format loader  
void ResourceLoader::remove_resource_format_loader(
    Ref<ResourceFormatLoader> p_format_loader
)
```

**Sources:** [core/io/resource_loader.cpp:1210-1237]()

### Synchronous Loading

```cpp
// Load resource immediately
Ref<Resource> ResourceLoader::load(
    const String &p_path,
    const String &p_type_hint = "",
    CacheMode p_cache_mode = CACHE_MODE_REUSE,
    Error *r_error = nullptr
)

// Check if resource exists
bool ResourceLoader::exists(
    const String &p_path,
    const String &p_type_hint = ""
)
```

**Sources:** [core/io/resource_loader.cpp:541-564](), [core/io/resource_loader.cpp:1011-1032]()

### Asynchronous Loading

```cpp
// Start threaded load
Error ResourceLoader::load_threaded_request(
    const String &p_path,
    const String &p_type_hint = "",
    bool p_use_sub_threads = false,
    CacheMode p_cache_mode = CACHE_MODE_REUSE
)

// Check load status
ThreadLoadStatus ResourceLoader::load_threaded_get_status(
    const String &p_path,
    float *r_progress = nullptr
)

// Get loaded resource (may block)
Ref<Resource> ResourceLoader::load_threaded_get(
    const String &p_path,
    Error *r_error = nullptr
)
```

**Sources:** [core/io/resource_loader.cpp:516-519](), [core/io/resource_loader.cpp:688-724](), [core/io/resource_loader.cpp:726-776]()

### Metadata Queries

```cpp
// Get resource type without loading
String ResourceLoader::get_resource_type(const String &p_path)

// Get resource UID
ResourceUID::ID ResourceLoader::get_resource_uid(const String &p_path)

// Get dependencies
void ResourceLoader::get_dependencies(
    const String &p_path,
    List<String> *p_dependencies,
    bool p_add_types = false
)

// Get recognized extensions for a type
void ResourceLoader::get_recognized_extensions_for_type(
    const String &p_type,
    List<String> *p_extensions
)
```

**Sources:** [core/io/resource_loader.cpp:1134-1181]()

---

## Format-Specific Loaders

### ResourceFormatLoaderBinary

Loads binary `.res` and `.scn` files. Uses a custom binary format with:

- String table for efficient storage
- Type information for deserialization
- External and internal resource references
- UID support for resource identification

**Key Methods:**
- `parse_variant()` - Deserializes binary data to Variant
- `get_unicode_string()` - Reads strings from string table
- `_get_string()` - Gets StringName from string map

**Sources:** [core/io/resource_format_binary.cpp:38-107](), [core/io/resource_format_binary.h:38-107]()

### ResourceLoaderText

Loads text-based `.tres` and `.tscn` files. Uses `VariantParser` for human-readable format:

```
[gd_resource type="Resource" format=3]

[ext_resource type="Texture2D" uid="uid://xxx" path="res://icon.png" id="1"]

[sub_resource type="ShaderMaterial" id="mat_1"]
shader = ...

[resource]
texture = ExtResource("1")
material = SubResource("mat_1")
```

**Parsing Flow:**
1. Parse header (`[gd_resource]` or `[gd_scene]`)
2. Parse external resources (`[ext_resource]`)
3. Parse sub-resources (`[sub_resource]`)
4. Parse main resource (`[resource]`) or scene nodes (`[node]`)

**Sources:** [scene/resources/resource_format_text.cpp:421-880](), [scene/resources/resource_format_text.h:40-99]()

### ResourceFormatImporter

Special loader for imported assets (e.g., `.png`, `.fbx`). Reads `.import` files to find the processed resource:

```
.import file: "res://icon.png.import"
Contains:     path="res://.godot/imported/icon.png-abc123.ctex"
Loads:        The compiled .ctex file
```

**Sources:** [core/io/resource_importer.cpp:43-200](), [core/io/resource_importer.h:41-107]()

---

## Progress Reporting

For threaded loads, progress is tracked hierarchically:

```mermaid
graph TD
    MainTask["Main Resource<br/>Progress: 0.0-1.0"]
    SubTask1["Dependency 1<br/>Progress: 0.0-1.0"]
    SubTask2["Dependency 2<br/>Progress: 0.0-1.0"]
    
    MainTask -->|50% weight| SubTask1
    MainTask -->|50% weight| SubTask2
    
    TotalProgress["Total = main * 0.5 +<br/>(dep1 + dep2) / 2 * 0.5"]
    
    MainTask --> TotalProgress
    SubTask1 --> TotalProgress
    SubTask2 --> TotalProgress
```

Progress calculation in `_dependency_get_progress()`:
- Sum progress of all sub-tasks
- Average them
- Weight: 50% own progress + 50% dependencies

**Sources:** [core/io/resource_loader.cpp:666-686]()

---

## Error Handling

### Missing Dependencies

When a dependency cannot be loaded:

1. If `abort_on_missing_resources` is true â†’ Fail immediately with `ERR_FILE_MISSING_DEPENDENCIES`
2. Otherwise â†’ Call `notify_dependency_error()` callback and continue

**Configuration:**
```cpp
ResourceLoader::set_abort_on_missing_resources(bool p_abort)
ResourceLoader::set_dependency_error_notify_func(DependencyErrorNotify p_func)
```

**Sources:** [core/io/resource_loader.cpp:1191-1196]()

### File Not Found

Returns `ERR_FILE_NOT_FOUND` with error message indicating missing file and expected type.

**Sources:** [core/io/resource_loader.cpp:343-358]()

### Unrecognized Format

When no loader recognizes the file format, returns `ERR_FILE_UNRECOGNIZED`.

**Sources:** [core/io/resource_loader.cpp:355-358]()2a:T3f73,# Resource Class

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)

</details>



This document describes the `Resource` class ([core/io/resource.h:53-194]()), which serves as the base class for all serializable, reference-counted resource types in Godot. Resources are data containers that can be saved to disk, loaded from files, cached globally, and shared across multiple objects.

For information about loading resources from disk, see [ResourceLoader](#5.1). For details on the global resource cache, see [Resource Cache](#5.3). For the import pipeline that processes raw assets, see [Resource Import System](#5.4). For saving resources, see [ResourceSaver](#5.5).

## Class Hierarchy and Core Members

The `Resource` class inherits from `RefCounted`, making all resources automatically reference-counted and freed when no longer in use.

```mermaid
graph TB
    Object["Object"]
    RefCounted["RefCounted"]
    Resource["Resource<br/>(core/io/resource.h:53)"]
    Texture["Texture"]
    Mesh["Mesh"]
    Material["Material"]
    PackedScene["PackedScene"]
    Script["Script"]
    CustomResource["Custom Resources"]
    
    Object --> RefCounted
    RefCounted --> Resource
    Resource --> Texture
    Resource --> Mesh
    Resource --> Material
    Resource --> PackedScene
    Resource --> Script
    Resource --> CustomResource
```

**Core Member Variables** ([core/io/resource.h:73-91]()):

| Member | Type | Purpose |
|--------|------|---------|
| `name` | String | Optional display name for the resource |
| `path_cache` | String | Resource path (file path or scene-local path) |
| `scene_unique_id` | String | Unique ID within a PackedScene |
| `local_to_scene` | bool | Whether to duplicate per scene instance |
| `local_scene` | Node* | Scene root when resource is local to scene |
| `emit_changed_state` | EmitChangedState | Controls change notification behavior |

Sources: [core/io/resource.h:53-194](), [core/io/resource.cpp:1-631]()

## Path and Identification System

Resources use multiple identification mechanisms depending on their context.

### Path Types

```mermaid
graph LR
    subgraph "Resource Path Formats"
        External["External Resource<br/>res://path/to/file.tres"]
        BuiltIn["Built-in Resource<br/>res://scene.tscn::SubResourceID"]
        Local["Local Resource<br/>local://SubResourceID"]
        UID["UID Reference<br/>uid://unique_identifier"]
    end
    
    External --> ResourceCache["ResourceCache<br/>(path â†’ Resource*)"]
    BuiltIn --> ResourceCache
    Local -.-> TemporaryStorage["Not in cache<br/>Scene-local only"]
    UID --> ResourceUID["ResourceUID<br/>(UID â†’ path)"]
    ResourceUID --> ResourceCache
```

**Path Functions** ([core/io/resource.cpp:70-116]()):

- `set_path(p_path, p_take_over)` - Sets the resource path and registers in cache
- `get_path()` - Returns the current path
- `set_path_cache(p_path)` - Sets path without cache involvement
- `is_built_in()` - Returns true if path contains `"::"` or starts with `"local://"` or is empty

Sources: [core/io/resource.h:145-148](), [core/io/resource.cpp:70-116]()

### Scene-Unique IDs

Resources within a `PackedScene` can have scene-unique IDs for stable referencing across saves/loads.

**ID Generation** ([core/io/resource.cpp:118-174]()):

```mermaid
graph LR
    GenerateID["generate_scene_unique_id()"]
    Hash["Hash from:<br/>â€¢ time<br/>â€¢ date<br/>â€¢ random"]
    BaseConversion["Convert to base<br/>(a-z + 0-9)"]
    IDString["5-character ID<br/>e.g., 'a3k9p'"]
    
    GenerateID --> Hash
    Hash --> BaseConversion
    BaseConversion --> IDString
```

- `generate_scene_unique_id()` - Creates a 5-character alphanumeric ID
- `set_scene_unique_id(p_id)` - Sets the ID (must be alphanumeric + underscores)
- `get_scene_unique_id()` - Returns the current scene-unique ID

Sources: [core/io/resource.cpp:118-178]()

### Resource UIDs

Resources can have globally unique identifiers managed by `ResourceUID` singleton.

**UID Integration** ([core/io/resource.h:33](), [core/io/resource_loader.cpp:114-125]()):

- UIDs are 64-bit integers stored in `.uid` files or embedded in resource files
- `ResourceLoader::get_resource_uid(p_path)` retrieves the UID for a path
- UIDs take precedence over paths when resolving dependencies

Sources: [core/io/resource_loader.cpp:114-125](), [scene/resources/resource_format_text.cpp:489-505]()

## Resource Duplication

Resources support both shallow and deep duplication with various modes for handling sub-resources.

### Duplication Architecture

```mermaid
graph TB
    UserCall["User calls duplicate()"]
    CheckCache{"Remap cache<br/>exists?"}
    CreateCache["Create thread-local<br/>DuplicateRemapCacheT"]
    DuplicateInternal["_duplicate(params)"]
    
    subgraph "Duplication Process"
        Instantiate["Instantiate new<br/>resource of same class"]
        CopyScript["Copy script reference"]
        IterateProps["Iterate properties"]
        RecursiveDupe["_duplicate_recursive()<br/>for nested resources"]
        SetProperties["Set properties on<br/>new resource"]
    end
    
    CleanupCache["Cleanup cache if<br/>we created it"]
    Return["Return duplicated<br/>resource"]
    
    UserCall --> CheckCache
    CheckCache -->|No| CreateCache
    CheckCache -->|Yes| DuplicateInternal
    CreateCache --> DuplicateInternal
    
    DuplicateInternal --> Instantiate
    Instantiate --> CopyScript
    CopyScript --> IterateProps
    IterateProps --> RecursiveDupe
    RecursiveDupe --> SetProperties
    SetProperties --> CleanupCache
    CleanupCache --> Return
```

**Duplication Methods** ([core/io/resource.cpp:367-592]()):

| Method | Signature | Behavior |
|--------|-----------|----------|
| `duplicate(p_deep)` | `Ref<Resource> duplicate(bool p_deep)` | Shallow copy (default) or deep copy of built-in sub-resources |
| `duplicate_deep(p_mode)` | `Ref<Resource> duplicate_deep(ResourceDeepDuplicateMode)` | Deep copy with control over sub-resource handling |
| `duplicate_for_local_scene()` | Internal method for local-to-scene duplication |

**Deep Duplicate Modes** ([core/io/resource.h:65]()):

- `RESOURCE_DEEP_DUPLICATE_NONE` - Don't duplicate sub-resources
- `RESOURCE_DEEP_DUPLICATE_INTERNAL` - Duplicate built-in sub-resources only
- `RESOURCE_DEEP_DUPLICATE_ALL` - Duplicate all sub-resources

Sources: [core/io/resource.cpp:367-592](), [core/io/resource.h:155-160]()

### Local-to-Scene Resources

Resources marked with `resource_local_to_scene = true` are duplicated per scene instance.

**Local-to-Scene Flow** ([core/io/resource.cpp:424-506]()):

```mermaid
sequenceDiagram
    participant PS as PackedScene
    participant R as Resource (local_to_scene=true)
    participant Cache as DuplicateRemapCache
    participant NewR as New Resource Instance
    
    PS->>PS: instantiate()
    PS->>R: duplicate_for_local_scene(scene_root, cache)
    R->>NewR: Create duplicate
    R->>Cache: Store (original â†’ duplicate)
    R->>NewR: set local_scene = scene_root
    NewR->>NewR: _setup_local_to_scene()
    PS->>NewR: Return configured instance
```

- Each scene instance gets its own copy of local-to-scene resources
- The `local_scene` pointer references the scene root
- Override `_setup_local_to_scene()` to customize the duplicated resource

Sources: [core/io/resource.cpp:424-506](), [doc/classes/Resource.xml:36-49]()

## Change Notification

Resources emit the `changed` signal when their data is modified.

### Change Emission System

**State Machine** ([core/io/resource.h:83-88](), [core/io/resource.cpp:40-65]()):

```mermaid
stateDiagram-v2
    [*] --> UNBLOCKED: Initial state
    UNBLOCKED --> BLOCKED: _block_emit_changed()
    UNBLOCKED --> UNBLOCKED: emit_changed()<br/>(emits signal)
    BLOCKED --> BLOCKED_PENDING: emit_changed()<br/>(sets pending flag)
    BLOCKED --> UNBLOCKED: _unblock_emit_changed()
    BLOCKED_PENDING --> UNBLOCKED: _unblock_emit_changed()<br/>(emits signal)
```

**Change Notification API** ([core/io/resource.cpp:40-219]()):

- `emit_changed()` - Emits the `changed` signal (or marks pending if blocked)
- `connect_changed(p_callable)` - Connects to the changed signal (thread-safe during loading)
- `disconnect_changed(p_callable)` - Disconnects from the changed signal
- `_block_emit_changed()` / `_unblock_emit_changed()` - Control emission state

**Thread Safety During Loading** ([core/io/resource.cpp:199-219]()):

When loading resources in non-main threads, `connect_changed` and `disconnect_changed` use `ResourceLoader::resource_changed_connect()` to defer signal connections until the load completes.

Sources: [core/io/resource.cpp:40-219](), [core/io/resource_loader.cpp:964-1006]()

## ResourceCache Integration

The `ResourceCache` singleton maintains a global registry of loaded resources indexed by path.

### Cache Architecture

```mermaid
graph TB
    subgraph "ResourceCache (core/io/resource.h:198-216)"
        CacheLock["Mutex lock"]
        ResourceMap["HashMap<String, Resource*><br/>path â†’ resource"]
    end
    
    subgraph "Resource Lifecycle"
        Create["Resource created"]
        SetPath["set_path() called"]
        AddCache["Added to cache"]
        InUse["Resource in use<br/>(RefCount > 0)"]
        Released["All references released<br/>(RefCount = 0)"]
        Destructor["~Resource()"]
        RemoveCache["Removed from cache"]
    end
    
    Create --> SetPath
    SetPath --> AddCache
    AddCache --> ResourceMap
    AddCache --> InUse
    InUse --> Released
    Released --> Destructor
    Destructor --> RemoveCache
    RemoveCache --> ResourceMap
```

**Cache Operations** ([core/io/resource.cpp:70-107]()):

| Operation | Location | Thread-Safe |
|-----------|----------|-------------|
| Add to cache | `set_path()` â†’ `ResourceCache::resources[path] = this` | Yes (mutex) |
| Remove from cache | `set_path("")` or path change | Yes (mutex) |
| Query cache | `ResourceCache::has(path)` | Yes (mutex) |
| Get cached ref | `ResourceCache::get_ref(path)` | Yes (mutex) |

**Path Take-Over** ([core/io/resource.cpp:88-96]()):

When `set_path(p_path, p_take_over=true)` is called:
1. The existing resource at `p_path` has its path cleared
2. The cache entry is reassigned to the new resource
3. This allows replacing cached resources

Sources: [core/io/resource.cpp:70-107](), [core/io/resource.h:198-216]()

## RID and Server Integration

Many resource types provide `RID` (Resource ID) handles for low-level server communication.

### RID System

```mermaid
graph LR
    Resource["Resource<br/>(high-level)"]
    GetRID["get_rid()"]
    RID["RID<br/>(64-bit handle)"]
    Server["Specialized Server<br/>(RenderingServer,<br/>PhysicsServer, etc.)"]
    
    Resource --> GetRID
    GetRID --> RID
    RID --> Server
    
    Examples["Examples:<br/>â€¢ Texture2D â†’ RID<br/>â€¢ Mesh â†’ RID<br/>â€¢ Material â†’ RID"]
```

**RID Implementation** ([core/io/resource.cpp:609-619]()):

- `get_rid()` calls the virtual `_get_rid()` method
- Override `_get_rid()` to return the server-side RID
- Many resources (textures, meshes, materials) use RIDs to interact with `RenderingServer`

Sources: [core/io/resource.cpp:609-619](), [doc/classes/Resource.xml:106-110]()

## Resource Reset and Copy

Resources support resetting state and copying from other instances.

### Reset State

**Reset Mechanism** ([core/io/resource.cpp:221-223]()):

- `reset_state()` - Calls virtual `_reset_state()` to clear non-exported properties
- Used during `CACHE_MODE_REPLACE` to clear state before copying properties
- Override `_reset_state()` for resources with dynamic/computed state

### Copy From

**Copy Process** ([core/io/resource.cpp:225-252]()):

```mermaid
graph LR
    CopyFrom["copy_from(source)"]
    CheckClass{"Same class?"}
    Block["_block_emit_changed()"]
    Reset["reset_state()"]
    GetProps["Get source properties"]
    CopyProps["Copy PROPERTY_USAGE_STORAGE<br/>properties (except resource_path)"]
    Unblock["_unblock_emit_changed()"]
    EmitChanged["emit_changed() if needed"]
    
    CopyFrom --> CheckClass
    CheckClass -->|No| Error["Return ERR_INVALID_PARAMETER"]
    CheckClass -->|Yes| Block
    Block --> Reset
    Reset --> GetProps
    GetProps --> CopyProps
    CopyProps --> Unblock
    Unblock --> EmitChanged
```

- Used by `CACHE_MODE_REPLACE` to update existing cached resources
- Skips `resource_path` property to preserve cache entry
- Blocks change emission during copy, then emits once at the end

Sources: [core/io/resource.cpp:221-267]()

## Tools-Specific Features

Several resource features are only available in editor builds.

### Editor Metadata

**Tools-Only Members** ([core/io/resource.h:77-81]()):

```cpp
#ifdef TOOLS_ENABLED
    uint64_t last_modified_time;
    uint64_t import_last_modified_time;
    String import_path;
#endif
```

**Timestamp Tracking** ([core/io/resource_loader.cpp:461-465]()):

- `set_last_modified_time()` / `get_last_modified_time()` - File modification time
- `set_import_last_modified_time()` / `get_import_last_modified_time()` - Import time
- Used by editor to detect when resources need reimporting

### Scene-Unique ID Cache

**ID Persistence** ([core/io/resource.h:204](), [core/io/resource.cpp:621-635]()):

```mermaid
graph TB
    subgraph "Editor Only (TOOLS_ENABLED)"
        PathCache["ResourceCache::resource_path_cache<br/>HashMap<String, HashMap<String, String>>"]
        ScenePath["Scene path"]
        IDMap["Resource path â†’ scene-unique ID"]
    end
    
    SetID["set_id_for_path(scene, id)"]
    GetID["get_id_for_path(scene)"]
    
    SetID --> PathCache
    GetID --> PathCache
    PathCache --> ScenePath
    ScenePath --> IDMap
```

- Maintains a cache mapping (scene path, resource path) â†’ scene-unique ID
- Used by `ResourceFormatSaver` to preserve IDs across saves
- Only available in editor builds

Sources: [core/io/resource.cpp:621-635](), [core/io/resource.h:204]()

## Virtual Methods for Extension

Custom resource types can override virtual methods to customize behavior.

### Overridable Methods

| Method | Purpose | Location |
|--------|---------|----------|
| `_get_rid()` | Return server-side RID | [core/io/resource.h:120]() |
| `_setup_local_to_scene()` | Configure after local-to-scene duplication | [core/io/resource.h:118]() |
| `_reset_state()` | Clear non-exported state | [core/io/resource.h:123]() |
| `_set_path_cache(p_path)` | React to path cache changes | [core/io/resource.h:122]() |
| `_resource_path_changed()` | React to path changes | [core/io/resource.cpp:67-68]() |

**Example Custom Resource Pattern**:

```
class_name CustomResource extends Resource

var computed_data = {}  # Non-exported state

func _reset_state():
    computed_data.clear()  # Clear computed state
    
func _setup_local_to_scene():
    # Customize per-instance setup
    computed_data["instance_id"] = randi()
```

Sources: [core/io/resource.h:107-127](), [doc/classes/Resource.xml:17-50]()2b:T3def,# Resource Cache

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)

</details>



The Resource Cache is a centralized, thread-safe global registry that tracks all loaded resources in the engine by their file paths. It enables resource reuse, prevents duplicate loading of the same asset, and supports hot-reloading of resources during runtime. For information about the loading mechanism itself, see [ResourceLoader](#5.1).

## Overview

The resource cache serves as the engine's memory for previously loaded resources. When a resource is loaded from disk, it can be registered in the cache so that subsequent load requests for the same path return the existing instance rather than loading a new copy. This system is critical for:

- **Memory efficiency**: Sharing resource instances across the scene tree
- **Identity consistency**: Ensuring the same resource file maps to a single object instance
- **Hot-reloading**: Updating resources in-place when files change
- **Thread safety**: Coordinating access to resources across multiple threads

Sources: [core/io/resource.h:198-216](), [core/io/resource.cpp:70-107]()

## Cache Architecture

```mermaid
classDiagram
    class ResourceCache {
        -static Mutex lock
        -static HashMap~String, Resource*~ resources
        -static HashMap~String, HashMap~String, String~~ resource_path_cache
        -static RWLock path_cache_lock
        +static bool has(String p_path)
        +static Ref~Resource~ get_ref(String p_path)
        +static void get_cached_resources(List~Ref~Resource~~* p_resources)
        +static int get_cached_resource_count()
        -static void clear()
    }
    
    class Resource {
        -String path_cache
        +void set_path(String p_path, bool p_take_over)
        +String get_path()
        +void set_path_cache(String p_path)
    }
    
    class ResourceLoader {
        +static Ref~Resource~ load(String p_path, CacheMode p_cache_mode)
        -static Ref~Resource~ _load(String p_path, CacheMode p_cache_mode)
        -static void _run_load_task(ThreadLoadTask* task)
    }
    
    ResourceCache --> Resource : stores raw pointers
    Resource ..> ResourceCache : registers self
    ResourceLoader ..> ResourceCache : queries and updates
```

**Core Components:**

| Component | Type | Purpose |
|-----------|------|---------|
| `ResourceCache::resources` | `HashMap<String, Resource *>` | Maps resource paths to resource instances |
| `ResourceCache::lock` | `Mutex` | Protects concurrent access to the cache |
| `Resource::path_cache` | `String` | Stores the resource's registered path |
| `ResourceCache::resource_path_cache` | `HashMap<String, HashMap<String, String>>` | Editor-only: tracks scene-unique IDs for resources |

Sources: [core/io/resource.h:198-216](), [core/io/resource.h:53-95]()

## Cache Modes

The `ResourceFormatLoader::CacheMode` enum defines strategies for cache interaction during resource loading:

```mermaid
graph TD
    Start["Resource Load Request"]
    
    Start --> CheckMode{Cache Mode?}
    
    CheckMode -->|IGNORE| NoCache["Skip cache entirely<br/>Load fresh copy"]
    CheckMode -->|IGNORE_DEEP| NoCacheDeep["Skip cache<br/>Propagate to dependencies"]
    CheckMode -->|REUSE| CheckExists{Exists in<br/>cache?}
    CheckMode -->|REPLACE| CheckExistsReplace{Exists in<br/>cache?}
    CheckMode -->|REPLACE_DEEP| CheckExistsReplaceDeep{Exists in<br/>cache?}
    
    CheckExists -->|Yes| ReturnCached["Return cached instance<br/>Set THREAD_LOAD_LOADED"]
    CheckExists -->|No| LoadAndCache["Load from disk<br/>Call set_path() to cache"]
    
    CheckExistsReplace -->|Yes| ReplaceData["Load fresh data<br/>old_res->copy_from(new_data)"]
    CheckExistsReplace -->|No| LoadAndCache
    
    CheckExistsReplaceDeep -->|Yes| ReplaceDataDeep["Load fresh data<br/>old_res->copy_from(new_data)<br/>Propagate to dependencies"]
    CheckExistsReplaceDeep -->|No| LoadAndCache
    
    NoCache --> ReturnNew["Load from disk<br/>Call set_path_cache()<br/>(not registered in cache)"]
    NoCacheDeep --> ReturnNew
    
    ReturnCached --> End["Resource Ready"]
    LoadAndCache --> End
    ReplaceData --> End
    ReplaceDataDeep --> End
    ReturnNew --> End
```

**Cache Mode Details:**

| Mode | Main Resource | Sub-resources | Dependencies | Use Case |
|------|---------------|---------------|--------------|----------|
| `CACHE_MODE_IGNORE` | Not cached | Not cached | Use REUSE | Temporary loads, previews |
| `CACHE_MODE_REUSE` | Reuse if exists | Reuse if exists | Use REUSE | Normal loading (default) |
| `CACHE_MODE_REPLACE` | Refresh if exists | Refresh if exists | Use REUSE | Hot-reload changed resource |
| `CACHE_MODE_IGNORE_DEEP` | Not cached | Not cached | Not cached | Complete isolation |
| `CACHE_MODE_REPLACE_DEEP` | Refresh if exists | Refresh if exists | Refresh if exists | Cascade hot-reload |

Sources: [core/io/resource_loader.h:51-57](), [core/io/resource_loader.cpp:616-627](), [core/io/resource_loader.cpp:418-453](), [doc/classes/ResourceLoader.xml:168-182]()

## Cache Registration Flow

### Adding Resources to Cache

When `Resource::set_path()` is called, the resource registers itself in the cache:

```mermaid
sequenceDiagram
    participant User
    participant Resource
    participant ResourceCache
    
    User->>Resource: set_path(new_path, take_over)
    Resource->>ResourceCache: lock.lock()
    
    alt Old path exists
        Resource->>ResourceCache: resources.erase(old_path)
    end
    
    Resource->>ResourceCache: get_ref(new_path)
    
    alt Resource exists at new_path
        alt take_over is true
            Resource->>ResourceCache: Clear existing resource's path
            Resource->>ResourceCache: resources.erase(new_path)
        else take_over is false
            ResourceCache-->>Resource: ERR_FAIL (cyclic inclusion)
        end
    end
    
    Resource->>Resource: path_cache = new_path
    Resource->>ResourceCache: resources[new_path] = this
    Resource->>ResourceCache: lock.unlock()
```

Sources: [core/io/resource.cpp:70-107]()

### Checking Cache During Load

The `ResourceLoader` checks the cache before initiating a load:

```mermaid
flowchart TD
    LoadRequest["ResourceLoader::_load_start()"]
    
    LoadRequest --> CheckMode{cache_mode ==<br/>CACHE_MODE_REUSE?}
    
    CheckMode -->|Yes| CheckCache["ResourceCache::get_ref(local_path)"]
    CheckMode -->|No| StartLoad["Proceed with load"]
    
    CheckCache --> CacheHit{Resource<br/>exists?}
    
    CacheHit -->|Yes| ReturnCached["Return cached resource<br/>Mark status: THREAD_LOAD_LOADED"]
    CacheHit -->|No| StartLoad
    
    StartLoad --> LoadFromDisk["Load resource from disk"]
    LoadFromDisk --> RegisterCache["Register in cache (if not ignoring)"]
    RegisterCache --> ReturnNew["Return new resource"]
```

Sources: [core/io/resource_loader.cpp:616-627]()

## Cache Operations During Load Completion

After a resource is successfully loaded, `_run_load_task()` handles cache registration:

```mermaid
flowchart TD
    LoadComplete["Resource loaded from disk"]
    
    LoadComplete --> CheckIgnore{Ignoring<br/>cache?}
    
    CheckIgnore -->|Yes| SetPathCache["resource->set_path_cache()"]
    CheckIgnore -->|No| LockCache["ResourceCache::lock.lock()"]
    
    LockCache --> CheckExisting["old_res = ResourceCache::get_ref(path)"]
    CheckExisting --> ExistsInCache{old_res<br/>exists?}
    
    ExistsInCache -->|Yes| CheckReplace{Replacing<br/>mode?}
    ExistsInCache -->|No| RegisterNew["resource->set_path(path)"]
    
    CheckReplace -->|Yes| CopyData["old_res->copy_from(new_resource)<br/>Use old_res"]
    CheckReplace -->|No| UseExisting["Use old_res<br/>(deadlock prevention case)"]
    
    CopyData --> UnlockCache["ResourceCache::lock.unlock()"]
    UseExisting --> UnlockCache
    RegisterNew --> UnlockCache
    SetPathCache --> Done["Cache operation complete"]
    UnlockCache --> Done
```

The cache handling logic distinguishes between two scenarios when a resource already exists in cache:
- **Replace mode**: Refreshes the existing instance with new data via `copy_from()`
- **Deadlock prevention**: Multiple concurrent loads of the same path; reuses whichever completed first

Sources: [core/io/resource_loader.cpp:428-453]()

## Thread Safety

All cache access is protected by `ResourceCache::lock`:

| Operation | Synchronization | Notes |
|-----------|----------------|-------|
| `ResourceCache::has()` | Locks `ResourceCache::lock` | Read-only check |
| `ResourceCache::get_ref()` | Locks `ResourceCache::lock` | Returns `Ref<Resource>` to increment refcount |
| `Resource::set_path()` | Locks `ResourceCache::lock` | Modifies cache hashmap |
| Load task completion | Locks `ResourceCache::lock` | During cache registration |

The cache stores raw `Resource *` pointers, not `Ref<Resource>`. This allows resources to be freed when no external references exist, automatically removing them from the cache via the destructor.

Sources: [core/io/resource.h:201](), [core/io/resource.cpp:80-104]()

## Resource Lifecycle in Cache

```mermaid
stateDiagram-v2
    [*] --> NotCached: Resource created
    
    NotCached --> Cached: set_path() called<br/>or loaded with REUSE mode
    
    Cached --> Cached: Additional load requests<br/>return cached instance
    
    Cached --> Updated: Loaded with REPLACE mode
    Updated --> Cached: Data refreshed in place
    
    Cached --> NotCached: Resource unreferenced<br/>and destroyed
    
    NotCached --> Temporary: Loaded with IGNORE mode
    Temporary --> [*]: Resource unreferenced<br/>and destroyed
    
    Cached --> Replaced: Another resource takes path<br/>with take_over=true
    Replaced --> NotCached: Path cleared
    
    NotCached --> [*]: Resource destroyed
```

Sources: [core/io/resource.cpp:70-107]()

## Hot-Reloading Implementation

The cache enables hot-reloading by using `CACHE_MODE_REPLACE` to refresh existing instances:

**Reload Process:**

1. Call `Resource::reload_from_file()` on the resource to refresh
2. The resource loads itself using `CACHE_MODE_IGNORE` to get a fresh copy from disk
3. Calls `copy_from()` to transfer properties from the fresh copy to itself
4. The original resource instance retains its identity and memory address
5. All existing references to the resource now see the updated data

**Alternative Approach:**

External systems can also trigger reloads by:
1. Calling `ResourceLoader::load()` with `CACHE_MODE_REPLACE`
2. The loader checks the cache and finds the existing instance
3. Loads fresh data from disk
4. Calls `copy_from()` on the cached instance
5. Returns the refreshed cached instance

Sources: [core/io/resource.cpp:254-267](), [core/io/resource_loader.cpp:428-450]()

## Cache Queries

The cache provides these query methods:

```cpp
// Check if a path is cached (thread-safe)
bool ResourceCache::has(const String &p_path)

// Get a reference to the cached resource (thread-safe, returns null Ref if not found)
Ref<Resource> ResourceCache::get_ref(const String &p_path)

// Get all cached resources (thread-safe)
void ResourceCache::get_cached_resources(List<Ref<Resource>> *p_resources)

// Get count of cached resources (thread-safe)
int ResourceCache::get_cached_resource_count()
```

**Key Implementation Details:**
- All methods lock `ResourceCache::lock` internally for thread safety
- `get_ref()` returns a `Ref<Resource>` (not a raw pointer) to safely increment the reference count
- These methods iterate over the `resources` HashMap to collect results
- `has()` is a simple lookup checking if a key exists in the HashMap

**Primary Use Cases:**
- **ResourceLoader**: Checks cache via `get_ref()` before initiating loads [core/io/resource_loader.cpp:617]()
- **Editor tools**: Uses `get_cached_resources()` to enumerate all loaded assets
- **Debugging**: Monitors memory usage via `get_cached_resource_count()`
- **Scene management**: Finds already-loaded scenes to avoid duplicate instantiation

Sources: [core/io/resource.h:212-215](), [core/io/resource_loader.cpp:617]()

## Path Takeover

The `take_over` parameter in `set_path()` allows forcefully replacing a cached resource:

```mermaid
sequenceDiagram
    participant NewRes as New Resource
    participant OldRes as Old Resource (cached)
    participant Cache as ResourceCache
    
    NewRes->>Cache: set_path(path, take_over=true)
    Cache->>Cache: Find OldRes at path
    
    alt take_over is true
        Cache->>OldRes: Clear path_cache
        Cache->>Cache: resources.erase(path)
        Cache->>Cache: resources[path] = NewRes
        Cache-->>NewRes: Success
    else take_over is false
        Cache-->>NewRes: ERR_FAIL (cyclic inclusion)
    end
```

**Use Cases:**
- Scene reloading that needs to replace the previous instance
- Importing resources that must overwrite existing cached versions
- Resource "swapping" during runtime

Sources: [core/io/resource.cpp:70-107]()

## Integration with Format Loaders

Both text and binary resource format loaders interact with the cache:

**Binary Format Loader** (`ResourceLoaderBinary`):
- Checks cache for sub-resources using `ResourceCache::get_ref()` [core/io/resource_format_binary.cpp:728-735]()
- Sets path on loaded resources to register in cache [core/io/resource_format_binary.cpp:800]()
- Respects `cache_mode` parameter for both main resource and internal resources

**Text Format Loader** (`ResourceLoaderText`):
- Checks cache for sub-resources during parsing [scene/resources/resource_format_text.cpp:547-563]()
- Uses `CACHE_MODE_REPLACE` to reuse existing instances when available [scene/resources/resource_format_text.cpp:547-554]()
- Registers main resource in cache via `set_path()` [scene/resources/resource_format_text.cpp:757-758]()

Sources: [core/io/resource_format_binary.cpp:728-806](), [scene/resources/resource_format_text.cpp:542-609]()

## Editor-Specific Cache Features

In editor builds, the cache maintains additional metadata:

**Scene-Unique ID Tracking:**
- `resource_path_cache` stores mappings of resource paths to their scene-unique IDs
- Used by VCS-friendly resource saving to preserve IDs across saves
- Protected by `path_cache_lock` (read-write lock)
- Methods: `Resource::set_id_for_path()`, `Resource::get_id_for_path()`

**Last Modified Timestamps:**
- Resources track `last_modified_time` and `import_last_modified_time`
- Used to detect if cached resources are stale and need reloading
- Set during load via `timestamp_on_load` flag in ResourceLoader

Sources: [core/io/resource.h:203-204](), [core/io/resource.h:77-80]()2c:T3bfa,# Resource Import System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)

</details>



## Purpose and Scope

This document describes the resource import system in Godot, which handles the conversion of source assets (images, audio, models, etc.) into engine-optimized formats. The import system is centered around `.import` metadata files that track how source files are processed and where their imported counterparts are stored.

For information about loading resources (including imported ones), see [ResourceLoader](#5.1). For saving resources, see [ResourceSaver](#5.5). For the general Resource class, see [Resource Class](#5.2).

## Overview

The import system provides a pipeline for converting source assets into formats optimized for the engine. When a source file like `texture.png` is added to the project, an importer processes it and generates:
1. A `.import` file (`texture.png.import`) containing metadata
2. A processed resource file (typically in `.godot/imported/`) in an optimized format

When the engine loads `texture.png`, it automatically redirects to the imported version by reading the `.import` file.

Sources: [core/io/resource_importer.h:1-150](), [core/io/resource_importer.cpp:1-40]()

## Core Components

```mermaid
graph TB
    subgraph "Importer System"
        RFI["ResourceFormatImporter<br/>(ResourceFormatLoader)"]
        RI["ResourceImporter<br/>(Abstract Base)"]
        ImportFile[".import Files<br/>(Metadata)"]
    end
    
    subgraph "Concrete Importers"
        TexImporter["TextureImporter"]
        AudioImporter["AudioImporter"]
        SceneImporter["SceneImporter"]
        OtherImporters["Other Importers..."]
    end
    
    subgraph "Resource Loading"
        RL["ResourceLoader"]
        Loaders["Format Loaders"]
    end
    
    RL -->|"uses"| RFI
    RFI -->|"reads"| ImportFile
    RFI -->|"manages"| RI
    RI -->|"implemented by"| TexImporter
    RI -->|"implemented by"| AudioImporter
    RI -->|"implemented by"| SceneImporter
    RI -->|"implemented by"| OtherImporters
    RFI -->|"delegates to"| Loaders
```

Sources: [core/io/resource_importer.h:36-107](), [core/io/resource_loader.h:105-321]()

### ResourceFormatImporter

`ResourceFormatImporter` is a singleton that implements `ResourceFormatLoader` and serves as the gateway for all imported resources.

**Key Responsibilities:**
- Parse `.import` files to locate processed resources
- Manage the registry of all `ResourceImporter` instances
- Route load requests to appropriate format loaders
- Handle platform-specific resource paths

**Key Methods:**
- `load()`: Loads an imported resource by reading its `.import` file
- `_get_path_and_type()`: Parses `.import` file metadata
- `get_importer_by_name()`: Retrieves an importer by name
- `get_importer_by_file()`: Finds appropriate importer for a source file

Sources: [core/io/resource_importer.h:41-107](), [core/io/resource_importer.cpp:43-155]()

### ResourceImporter

`ResourceImporter` is the abstract base class that all importers extend. Each importer handles specific file types and converts them to engine formats.

**Key Virtual Methods:**
- `get_importer_name()`: Returns unique importer identifier
- `get_recognized_extensions()`: Lists handled file extensions
- `get_resource_type()`: Returns the type of resource produced
- `import()`: Performs the actual import operation
- `get_import_options()`: Defines configurable import settings

Sources: [core/io/resource_importer.h:109-150](), [core/io/resource_importer.cpp:232-280]()

## Import File Format

### Structure

`.import` files use a text-based configuration format similar to INI files. They contain metadata about the import process and the location of the processed resource.

**Common Fields:**

| Field | Description | Example |
|-------|-------------|---------|
| `path` | Path to the imported resource | `.godot/imported/texture.png-abcd1234.ctex` |
| `path.<feature>` | Platform-specific path | `path.s3tc=...`, `path.etc2=...` |
| `type` | Resource class name | `CompressedTexture2D` |
| `importer` | Importer identifier | `texture` |
| `uid` | Unique resource ID | `uid://b3gkn3wsxn8qk` |
| `group_file` | Group import file path | For grouped imports |
| `metadata` | Importer-specific data | Additional settings |
| `valid` | Import validity flag | `true`/`false` |

Sources: [core/io/resource_importer.cpp:43-155]()

### Example .import File

```ini
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://b3gkn3wsxn8qk"
path="res://.godot/imported/icon.png-487276ed1e3a0c39cad0279d744ee560.ctex"
path.s3tc="res://.godot/imported/icon.png-487276ed1e3a0c39cad0279d744ee560.s3tc.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": true
}

[deps]

source_file="res://icon.png"
dest_files=["res://.godot/imported/icon.png-487276ed1e3a0c39cad0279d744ee560.ctex", ...]
```

Sources: [core/io/resource_importer.cpp:54-122]()

## Import Pipeline Flow

```mermaid
sequenceDiagram
    participant User
    participant RL as ResourceLoader
    participant RFI as ResourceFormatImporter
    participant ImportFile as .import File
    participant Loader as Format Loader
    participant Resource

    User->>RL: load("res://texture.png")
    RL->>RFI: load("res://texture.png")
    RFI->>ImportFile: open("res://texture.png.import")
    ImportFile-->>RFI: path, type, importer, uid
    
    alt Has platform-specific path
        RFI->>RFI: Check OS features
        RFI->>RFI: Select best path match
    end
    
    RFI->>RL: _load(actual_path, type)
    RL->>Loader: load(actual_path)
    Loader->>Resource: instantiate and populate
    Resource-->>RL: Ref<Resource>
    RL-->>User: Ref<Resource>
```

Sources: [core/io/resource_importer.cpp:157-200](), [core/io/resource_loader.cpp:289-359]()

### Detailed Flow

1. **User Request**: Application requests a resource (e.g., `ResourceLoader.load("res://texture.png")`)

2. **Importer Detection**: `ResourceFormatImporter` recognizes the path and looks for `texture.png.import`

3. **Metadata Parsing**: `_get_path_and_type()` parses the `.import` file to extract:
   - Actual resource path (usually in `.godot/imported/`)
   - Resource type
   - Importer name
   - UID and metadata

4. **Platform Selection**: If multiple platform-specific paths exist (e.g., `path.s3tc`, `path.etc2`), the system selects the appropriate one based on OS features

5. **Resource Loading**: The actual resource is loaded from the processed path using the appropriate format loader

6. **Metadata Application**: Import metadata is attached to the resource (editor only)

Sources: [core/io/resource_importer.cpp:157-200](), [core/io/resource_loader.cpp:289-359]()

## Platform-Specific Imports

The import system supports platform-specific resource variants through conditional paths in `.import` files.

```mermaid
graph LR
    Source["Source: texture.png"]
    Import[".import File"]
    
    subgraph "Platform Variants"
        S3TC["path.s3tc<br/>(Desktop)"]
        ETC2["path.etc2<br/>(Mobile)"]
        BPTC["path.bptc<br/>(High-end)"]
        Default["path<br/>(Fallback)"]
    end
    
    Source --> Import
    Import --> S3TC
    Import --> ETC2
    Import --> BPTC
    Import --> Default
    
    Runtime["Runtime Path Selection<br/>OS::has_feature()"] --> S3TC
    Runtime --> ETC2
    Runtime --> BPTC
    Runtime --> Default
```

Sources: [core/io/resource_importer.cpp:88-98]()

### Path Selection Algorithm

When loading an imported resource, `ResourceFormatImporter` follows this priority order:

1. **Feature-Specific Path**: Check for `path.<feature>` where feature matches current OS capabilities (e.g., `s3tc`, `etc2`)
2. **Decompressible Format**: If no exact match, look for a format that can be decompressed at runtime
3. **Default Path**: Use the base `path` field as fallback

The selection occurs in `_get_path_and_type()`:

```
- Read all path.* fields
- For each path.feature:
  - If OS::has_feature(feature): use this path (priority)
  - Else if Image::can_decompress(feature): mark as fallback
- If no match: use base path
```

Sources: [core/io/resource_importer.cpp:71-127]()

## Importer Registration

### Adding Importers

Importers are registered with the `ResourceFormatImporter` singleton during engine initialization.

**Registration Method:**
```
ResourceFormatImporter::get_singleton()->add_importer(importer, priority)
```

**Parameters:**
- `importer`: Ref to `ResourceImporter` instance
- `priority`: If `true`, adds at front of queue (checked first)

The importer list is maintained in order of registration, and importers are queried sequentially when determining which can handle a file.

Sources: [core/io/resource_importer.h:92-93](), [core/io/resource_importer.cpp:281-296]()

### Importer Discovery

```mermaid
graph TB
    Request["File: res://model.gltf"]
    RFI["ResourceFormatImporter"]
    
    subgraph "Importer Registry"
        I1["Importer 1<br/>extensions: ['png', 'jpg']"]
        I2["Importer 2<br/>extensions: ['gltf', 'glb']"]
        I3["Importer 3<br/>extensions: ['ogg', 'mp3']"]
    end
    
    Request --> RFI
    RFI -->|"Check extensions"| I1
    RFI -->|"Check extensions"| I2
    RFI -->|"Check extensions"| I3
    I2 -.->|"Match!"| RFI
```

Sources: [core/io/resource_importer.cpp:313-335]()

**Discovery Process:**

1. Extract file extension from source path
2. Query each registered importer via `get_recognized_extensions()`
3. Return first importer that recognizes the extension
4. Used by `get_importer_by_file()` and `get_importers_for_file()`

Sources: [core/io/resource_importer.cpp:313-335]()

## Loading Imported Resources

### Load Sequence

```mermaid
graph TB
    LoadCall["ResourceLoader::load()"]
    
    LoadCall --> CheckImport{"Has .import file?"}
    
    CheckImport -->|Yes| RFI["ResourceFormatImporter::load()"]
    CheckImport -->|No| DirectLoad["Direct Format Loader"]
    
    RFI --> ParseImport["_get_path_and_type()<br/>Parse .import file"]
    ParseImport --> PathSelect["Select platform path"]
    PathSelect --> InternalLoad["_load(processed_path)"]
    InternalLoad --> FormatLoader["Appropriate Format Loader"]
    FormatLoader --> Resource["Resource Instance"]
    
    DirectLoad --> Resource
```

Sources: [core/io/resource_importer.cpp:157-200](), [core/io/resource_loader.cpp:289-359]()

### PathAndType Structure

The `PathAndType` struct holds parsed `.import` file data:

| Field | Type | Purpose |
|-------|------|---------|
| `path` | String | Actual resource path |
| `type` | String | Resource class name |
| `importer` | String | Importer identifier |
| `group_file` | String | Group import file path |
| `metadata` | Variant | Additional metadata |
| `uid` | ResourceUID::ID | Unique resource ID |

Sources: [core/io/resource_importer.h:44-51]()

### Cache Modes and Imports

The import system respects cache modes when loading:

- **CACHE_MODE_IGNORE**: Loads without touching cache (dependencies use CACHE_MODE_REUSE)
- **CACHE_MODE_REUSE**: Uses cached version if available
- **CACHE_MODE_REPLACE**: Reloads and updates existing instances

Sources: [core/io/resource_loader.cpp:541-564](), [core/io/resource_importer.cpp:157-200]()

## Import Metadata and Validation

### Metadata Storage

Import metadata can be retrieved using `get_resource_metadata()`:

```cpp
Variant ResourceFormatImporter::get_resource_metadata(const String &p_path) const
```

This returns the `metadata` field from the `.import` file, which contains importer-specific data.

Sources: [core/io/resource_importer.cpp:368-377]()

### Import Validation

The `is_import_valid()` method checks if an import is up-to-date:

1. Reads the `valid` field from `.import` file
2. Returns `false` if the field is missing or explicitly set to false
3. Used by the editor to trigger reimports when source files change

Sources: [core/io/resource_importer.cpp:379-388]()

## Editor Integration

In the editor, the import system has additional functionality:

### Import on Startup

The `ResourceImporter::load_on_startup` callback allows the editor to handle imports during resource loading:

```cpp
static inline ResourceFormatImporterLoadOnStartup load_on_startup = nullptr;
```

When set (in editor builds), this callback can reimport resources on-the-fly if they're not yet imported.

Sources: [core/io/resource_importer.h:118](), [core/io/resource_importer.cpp:158-168]()

### Import Settings Hash

The `get_import_settings_hash()` method generates a hash of all registered importers and their settings, used to detect when import configuration changes.

Sources: [core/io/resource_importer.cpp:432-453]()

### Resource ID Persistence

For VCS-friendly workflows, the import system maintains scene-unique IDs:

```cpp
Resource::set_resource_id_for_path(local_path, E.value.path, E.key);
```

This ensures IDs remain consistent across imports.

Sources: [scene/resources/resource_format_text.cpp:538-543]()

## Internal Resource Paths

### Path Structure

Imported resources are typically stored in `.godot/imported/` with generated filenames:

```
.godot/imported/<source_name>-<hash>.<extension>
```

Example: `.godot/imported/icon.png-487276ed1e3a0c39cad0279d744ee560.ctex`

The hash is based on the source file path and ensures uniqueness.

Sources: [core/io/resource_importer.cpp:455-470]()

### Group Files

Some importers use group files for related assets:

- The `group_file` field in `.import` points to a master import file
- Used for things like texture atlases or model scenes with multiple sub-resources
- Retrieved via `get_import_group_file()`

Sources: [core/io/resource_importer.cpp:390-400]()

## Key Classes Summary

| Class | Location | Purpose |
|-------|----------|---------|
| `ResourceFormatImporter` | core/io/resource_importer.h:41-107 | Singleton format loader for imported resources |
| `ResourceImporter` | core/io/resource_importer.h:109-150 | Abstract base for all importers |
| `PathAndType` | core/io/resource_importer.h:44-51 | Parsed .import file data |

Sources: [core/io/resource_importer.h:1-150]()2d:T3a1b,# ResourceSaver

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)

</details>



## Overview

ResourceSaver is a singleton system responsible for persisting `Resource` objects to disk in various file formats. It provides a unified interface for saving resources while delegating format-specific serialization to registered `ResourceFormatSaver` implementations. The system supports both text-based formats (`.tres`, `.tscn`) and binary formats (`.res`, `.scn`), as well as custom format extensions.

For information about loading resources from disk, see [ResourceLoader](#5.1). For details about the Resource class itself, see [Resource Class](#5.2). For the resource import system, see [Resource Import System](#5.4).

## Architecture Overview

The ResourceSaver system follows a plugin architecture where multiple format-specific savers can be registered and queried to handle different resource types and file extensions.

```mermaid
graph TB
    User["User Code<br/>(GDScript/C++)"]
    RS["ResourceSaver<br/>Singleton"]
    RFS["ResourceFormatSaver<br/>Base Class"]
    Binary["ResourceFormatSaverBinary<br/>(.res, .scn)"]
    Text["ResourceFormatSaverText<br/>(.tres, .tscn)"]
    Custom["Custom Savers<br/>(GDScript/Native)"]
    FileSystem["File System<br/>(Disk I/O)"]
    
    User -->|"save(resource, path)"| RS
    RS -->|"iterate & query"| RFS
    RFS -->|implements| Binary
    RFS -->|implements| Text
    RFS -->|implements| Custom
    Binary -->|"write binary format"| FileSystem
    Text -->|"write text format"| FileSystem
    Custom -->|"write custom format"| FileSystem
```

Sources: [core/io/resource_saver.h:1-99](), [core/io/resource_saver.cpp:1-218]()

## Core Components

### ResourceSaver Singleton

The `ResourceSaver` class maintains a static array of registered format savers and provides the main API for saving resources.

| Component | Type | Purpose |
|-----------|------|---------|
| `saver[]` | Static array | Holds up to MAX_SAVERS (64) format saver instances |
| `saver_count` | Static int | Tracks number of registered savers |
| `save_callback` | Callback function | Optional callback invoked after successful save |
| `save_get_id_for_path` | Callback function | Returns ResourceUID for a given path |

**Key Methods:**
- `save(resource, path, flags)` - Main save function
- `add_resource_format_saver(saver, at_front)` - Register a new saver
- `remove_resource_format_saver(saver)` - Unregister a saver
- `get_recognized_extensions(resource)` - Query supported extensions

Sources: [core/io/resource_saver.h:59-99](), [core/io/resource_saver.cpp:37-42]()

### ResourceFormatSaver Base Class

`ResourceFormatSaver` is the abstract interface that all format-specific savers must implement.

```mermaid
classDiagram
    class ResourceFormatSaver {
        +save(resource, path, flags) Error
        +set_uid(path, uid) Error
        +recognize(resource) bool
        +get_recognized_extensions(resource, extensions) void
        +recognize_path(resource, path) bool
    }
    
    class ResourceFormatSaverBinary {
        +save(resource, path, flags) Error
        +recognize(resource) bool
        +get_recognized_extensions() void
    }
    
    class ResourceFormatSaverText {
        +save(resource, path, flags) Error
        +recognize(resource) bool
        +get_recognized_extensions() void
    }
    
    ResourceFormatSaver <|-- ResourceFormatSaverBinary
    ResourceFormatSaver <|-- ResourceFormatSaverText
```

**Virtual Methods:**
- `_save(resource, path, flags)` - Perform actual serialization
- `_recognize(resource)` - Check if saver handles this resource type
- `_get_recognized_extensions(resource)` - Return supported file extensions
- `_recognize_path(resource, path)` - Check if path is suitable
- `_set_uid(path, uid)` - Update UID in existing file

Sources: [core/io/resource_saver.h:36-56](), [core/io/resource_saver.cpp:44-98]()

## Save Process Flow

The resource saving process follows a well-defined sequence that involves path validation, saver selection, and file writing.

```mermaid
sequenceDiagram
    participant Client
    participant ResourceSaver
    participant FormatSaver
    participant Resource
    participant FileSystem
    
    Client->>ResourceSaver: save(resource, path, flags)
    ResourceSaver->>ResourceSaver: Validate resource & path
    
    loop For each registered saver
        ResourceSaver->>FormatSaver: recognize(resource)
        FormatSaver-->>ResourceSaver: bool
        alt Saver recognizes resource
            ResourceSaver->>FormatSaver: recognize_path(resource, path)
            FormatSaver-->>ResourceSaver: bool
            alt Path recognized
                Note over ResourceSaver: Found compatible saver
            end
        end
    end
    
    alt FLAG_CHANGE_PATH set
        ResourceSaver->>Resource: set_path(local_path)
    end
    
    ResourceSaver->>FormatSaver: save(resource, path, flags)
    FormatSaver->>FileSystem: Write to disk
    FileSystem-->>FormatSaver: Result
    FormatSaver-->>ResourceSaver: Error code
    
    alt Save successful
        ResourceSaver->>Resource: set_last_modified_time()
        opt save_callback exists
            ResourceSaver->>Client: save_callback(resource, path)
        end
    end
    
    ResourceSaver-->>Client: Error code
```

**Process Steps:**

1. **Validation** - Check that resource is valid and path is non-empty
2. **Path Normalization** - Convert to local path using ProjectSettings
3. **Saver Selection** - Iterate through registered savers to find compatible one
4. **Path Update** - Optionally update resource's path (if FLAG_CHANGE_PATH)
5. **Serialization** - Delegate to format saver's `save()` method
6. **Post-Processing** - Update timestamps and invoke callbacks
7. **UID Management** - Store/update resource UID if applicable

Sources: [core/io/resource_saver.cpp:100-174]()

### Save Flags

The save process can be customized using bitfield flags:

| Flag | Value | Purpose |
|------|-------|---------|
| FLAG_NONE | 0 | Default behavior |
| FLAG_RELATIVE_PATHS | 1 | Save paths relative to scene |
| FLAG_BUNDLE_RESOURCES | 2 | Bundle external resources into single file |
| FLAG_CHANGE_PATH | 4 | Update resource's path property |
| FLAG_OMIT_EDITOR_PROPERTIES | 8 | Skip editor-only properties |
| FLAG_SAVE_BIG_ENDIAN | 16 | Use big-endian byte order (binary) |
| FLAG_COMPRESS | 32 | Enable compression (binary) |
| FLAG_REPLACE_SUBRESOURCE_PATHS | 64 | Replace sub-resource paths with IDs |

Sources: [core/io/resource_saver.h:61-78](), [doc/classes/ResourceSaver.xml:66-82]()

## Format Saver Implementations

### Binary Format Saver

`ResourceFormatSaverBinary` serializes resources to a compact binary format (`.res`, `.scn`).

**Key Features:**
- Efficient storage with minimal overhead
- Supports compression via FLAG_COMPRESS
- Handles both big-endian and little-endian formats
- Includes version information for forward compatibility
- Stores resource UIDs and metadata

**File Structure:**
```mermaid
graph TD
    Header["Header<br/>Magic: 'RSRC'<br/>Version<br/>Format flags"]
    StringTable["String Table<br/>Deduplicated strings<br/>Used for property names"]
    ExtRes["External Resources<br/>Type, Path, UID<br/>for each dependency"]
    IntRes["Internal Resources<br/>Offset table<br/>for sub-resources"]
    ResourceData["Resource Data<br/>Properties<br/>Binary-encoded values"]
    
    Header --> StringTable
    StringTable --> ExtRes
    ExtRes --> IntRes
    IntRes --> ResourceData
```

Sources: [core/io/resource_format_binary.cpp:858-1477](), [core/io/resource_format_binary.h:126-203]()

### Text Format Saver

`ResourceFormatSaverText` serializes resources to a human-readable text format (`.tres`, `.tscn`).

**Key Features:**
- Human-readable and VCS-friendly
- Supports merge conflict resolution
- Can be edited manually in emergencies
- Stores resources in sections: ext_resource, sub_resource, resource, node

**File Structure Example:**
```
[gd_resource type="Resource" format=3]

[ext_resource path="res://icon.png" type="Texture2D" id="1_abc123"]

[sub_resource type="AtlasTexture" id="2_def456"]
atlas = ExtResource("1_abc123")
region = Rect2(0, 0, 32, 32)

[resource]
property_name = SubResource("2_def456")
```

Sources: [scene/resources/resource_format_text.cpp:1053-1872](), [scene/resources/resource_format_text.h:158-279]()

## Saver Registration and Discovery

The ResourceSaver maintains savers in priority order and queries them sequentially during save operations.

```mermaid
graph LR
    Init["Engine Initialization"]
    RegBinary["Register Binary Saver<br/>ResourceFormatSaverBinary"]
    RegText["Register Text Saver<br/>ResourceFormatSaverText"]
    RegImporter["Register Importer<br/>if TOOLS_ENABLED"]
    CustomReg["Custom Saver Registration<br/>via add_resource_format_saver()"]
    SaverArray["saver[] array<br/>MAX_SAVERS = 64"]
    
    Init --> RegBinary
    RegBinary --> RegText
    RegText --> RegImporter
    RegImporter --> CustomReg
    CustomReg --> SaverArray
```

**Registration Process:**

1. **Engine Bootstrap** - Built-in savers registered during initialization
2. **Priority Placement** - New savers can be added at front or back of array
3. **Query Order** - Savers checked in array order until match found
4. **Custom Savers** - Scripts can extend ResourceFormatSaver and register

Sources: [core/io/resource_saver.cpp:176-218]()

### Adding Custom Savers

Custom savers can be implemented in GDScript by extending `ResourceFormatSaver`:

**Implementation Requirements:**
- Override `_save(resource, path, flags)` - Return Error enum
- Override `_recognize(resource)` - Return true if saver handles this type
- Override `_get_recognized_extensions(resource)` - Return PackedStringArray
- Optionally override `_recognize_path()` - Custom path validation
- Optionally override `_set_uid()` - UID update support

**Registration:**
```gdscript
var custom_saver = MyCustomSaver.new()
ResourceSaver.add_resource_format_saver(custom_saver, false)
```

Sources: [core/io/resource_saver.cpp:196-218](), [doc/classes/ResourceFormatSaver.xml:1-56]()

## Integration with Resource System

ResourceSaver is tightly integrated with other resource management components:

```mermaid
graph TB
    RS["ResourceSaver"]
    RL["ResourceLoader"]
    RC["Resource Class"]
    RCache["ResourceCache"]
    RUID["ResourceUID"]
    PS["ProjectSettings"]
    
    RS -->|"updates path"| RC
    RS -->|"queries UID"| RUID
    RS -->|"localizes paths"| PS
    RS -->|"registers saved resources"| RCache
    RS -.->|"complementary system"| RL
    
    RC -->|"provides data"| RS
    RUID -->|"provides/updates IDs"| RS
```

**Key Interactions:**

1. **Resource Path Management** - Updates `resource_path` property when FLAG_CHANGE_PATH is set
2. **UID Tracking** - Stores and updates ResourceUID entries for persistent identification
3. **Cache Integration** - Newly saved resources remain in ResourceCache for reuse
4. **Timestamp Updates** - Sets `last_modified_time` for editor change detection
5. **Path Localization** - Converts absolute paths to project-relative paths

Sources: [core/io/resource_saver.cpp:100-174](), [core/io/resource.cpp:70-107]()

## Specialized Behaviors

### Editor-Specific Features

When `TOOLS_ENABLED` is defined, additional functionality is available:

- **Editor Properties** - Can be omitted with FLAG_OMIT_EDITOR_PROPERTIES
- **Scene Unique IDs** - Generates and stores IDs for sub-resources in scenes
- **Import Metadata** - Stores last modified time for import detection
- **UID Files** - Creates `.uid` files alongside resources for UID persistence

Sources: [core/io/resource_saver.cpp:131-167]()

### Save Callback Mechanism

The system supports a global callback invoked after successful saves:

```mermaid
sequenceDiagram
    participant Saver as ResourceSaver
    participant Callback as save_callback
    participant Editor as EditorFileSystem
    
    Saver->>Saver: save() completes successfully
    alt save_callback is set
        Saver->>Callback: invoke(resource, path)
        Callback->>Editor: Update file system state
        Callback->>Editor: Refresh resource previews
    end
```

**Usage:**
- Editor sets callback to update file system dock
- Plugins can hook into save events
- Useful for post-processing (e.g., generating metadata)

Sources: [core/io/resource_saver.cpp:41-42](), [core/io/resource_saver.h:58-59]()

### Thread Safety

ResourceSaver operations are generally **not thread-safe** and should be called from the main thread. However:

- The save operation itself is synchronous and blocking
- File I/O is performed directly without threading
- For threaded saves, implement custom saving logic in user code
- ResourceLoader provides threaded loading; saver does not have equivalent

Sources: [core/io/resource_saver.cpp:100-174]()

## Error Handling

The save process can fail at multiple points, returning specific error codes:

| Error Code | Cause |
|------------|-------|
| ERR_INVALID_PARAMETER | Null resource or empty path |
| ERR_FILE_UNRECOGNIZED | No saver recognizes resource/path combination |
| ERR_FILE_CANT_WRITE | Insufficient permissions or disk full |
| ERR_FILE_CORRUPT | Data corruption during write |
| OK | Save successful |

**Error Flow:**
1. Validation errors returned immediately
2. Saver-specific errors propagated from format saver
3. File system errors from FileAccess operations
4. Original resource path restored on failure if FLAG_CHANGE_PATH was set

Sources: [core/io/resource_saver.cpp:100-174]()2e:T3d10,# Scripting System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [modules/gdscript/gdscript.cpp](modules/gdscript/gdscript.cpp)
- [modules/gdscript/gdscript.h](modules/gdscript/gdscript.h)
- [modules/gdscript/gdscript_analyzer.cpp](modules/gdscript/gdscript_analyzer.cpp)
- [modules/gdscript/gdscript_analyzer.h](modules/gdscript/gdscript_analyzer.h)
- [modules/gdscript/gdscript_byte_codegen.cpp](modules/gdscript/gdscript_byte_codegen.cpp)
- [modules/gdscript/gdscript_byte_codegen.h](modules/gdscript/gdscript_byte_codegen.h)
- [modules/gdscript/gdscript_cache.cpp](modules/gdscript/gdscript_cache.cpp)
- [modules/gdscript/gdscript_cache.h](modules/gdscript/gdscript_cache.h)
- [modules/gdscript/gdscript_codegen.h](modules/gdscript/gdscript_codegen.h)
- [modules/gdscript/gdscript_compiler.cpp](modules/gdscript/gdscript_compiler.cpp)
- [modules/gdscript/gdscript_compiler.h](modules/gdscript/gdscript_compiler.h)
- [modules/gdscript/gdscript_disassembler.cpp](modules/gdscript/gdscript_disassembler.cpp)
- [modules/gdscript/gdscript_editor.cpp](modules/gdscript/gdscript_editor.cpp)
- [modules/gdscript/gdscript_function.cpp](modules/gdscript/gdscript_function.cpp)
- [modules/gdscript/gdscript_function.h](modules/gdscript/gdscript_function.h)
- [modules/gdscript/gdscript_parser.cpp](modules/gdscript/gdscript_parser.cpp)
- [modules/gdscript/gdscript_parser.h](modules/gdscript/gdscript_parser.h)
- [modules/gdscript/gdscript_tokenizer.cpp](modules/gdscript/gdscript_tokenizer.cpp)
- [modules/gdscript/gdscript_tokenizer.h](modules/gdscript/gdscript_tokenizer.h)
- [modules/gdscript/gdscript_vm.cpp](modules/gdscript/gdscript_vm.cpp)
- [modules/gdscript/gdscript_warning.cpp](modules/gdscript/gdscript_warning.cpp)
- [modules/gdscript/gdscript_warning.h](modules/gdscript/gdscript_warning.h)
- [modules/gdscript/tests/gdscript_test_runner.cpp](modules/gdscript/tests/gdscript_test_runner.cpp)
- [modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out](modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out)
- [modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd](modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out)

</details>



The Scripting System provides the infrastructure for executing user-defined scripts in Godot Engine, with GDScript as the primary language implementation. This system encompasses script compilation (tokenization, parsing, semantic analysis, bytecode generation), runtime execution (virtual machine, instance management), and caching mechanisms.

For information about specific language features and syntax, see the language documentation. For editor integration (code completion, debugging), see [Editor Core](#8). For the base class system that scripts extend, see [Scene System](#4).

## Architecture Overview

The scripting system follows a multi-stage compilation pipeline that transforms source code into executable bytecode, then executes it through a virtual machine.

```mermaid
graph TB
    subgraph "Source to Bytecode"
        Source["GDScript Source<br/>.gd file"]
        Tokenizer["GDScriptTokenizerText"]
        Tokens["Token Stream"]
        Parser["GDScriptParser"]
        AST["Abstract Syntax Tree<br/>ClassNode, FunctionNode"]
        Analyzer["GDScriptAnalyzer"]
        Compiler["GDScriptCompiler"]
        BytecodeGen["GDScriptByteCodeGenerator"]
    end
    
    subgraph "Runtime Structures"
        GDScriptRes["GDScript Resource"]
        GDScriptFunc["GDScriptFunction[]<br/>Bytecode + Metadata"]
        GDScriptInst["GDScriptInstance"]
        VM["GDScriptVM"]
    end
    
    subgraph "Caching Layer"
        ParserCache["GDScriptCache"]
        ParserRef["GDScriptParserRef<br/>Status: PARSEDâ†’INHERITANCE_SOLVEDâ†’<br/>INTERFACE_SOLVEDâ†’FULLY_SOLVED"]
    end
    
    Source --> Tokenizer
    Tokenizer --> Tokens
    Tokens --> Parser
    Parser --> AST
    
    AST --> ParserCache
    ParserCache --> ParserRef
    ParserRef --> Analyzer
    
    Analyzer --> Compiler
    Compiler --> BytecodeGen
    BytecodeGen --> GDScriptFunc
    
    GDScriptFunc --> GDScriptRes
    GDScriptRes --> GDScriptInst
    GDScriptInst --> VM
    
    ParserCache -.caches.-> Parser
    ParserCache -.caches.-> Analyzer
```

**Sources:** [modules/gdscript/gdscript_parser.cpp:416-515](), [modules/gdscript/gdscript_analyzer.cpp:344-630](), [modules/gdscript/gdscript_compiler.cpp:1-2500](), [modules/gdscript/gdscript_cache.cpp:41-153]()

## ScriptLanguage Interface

The scripting system is extensible through the `ScriptLanguage` interface, which GDScript implements via `GDScriptLanguage`. This allows multiple scripting languages to coexist in the engine.

| Interface Method | GDScript Implementation | Purpose |
|-----------------|------------------------|---------|
| `create_script()` | Returns `GDScript` instance | Creates script resource |
| `validate()` | Uses `GDScriptParser` + `GDScriptAnalyzer` | Validates source code |
| `get_recognized_extensions()` | Returns `["gd"]` | File extension recognition |
| `make_function()` | Generates function template | Editor integration |
| `get_public_functions()` | Returns GDScript utility functions | Exposed to users |

**Sources:** [modules/gdscript/gdscript_editor.cpp:145-214](), [modules/gdscript/gdscript_editor.cpp:249-251](), [modules/gdscript/gdscript_editor.cpp:462-464]()

## Compilation Pipeline

### Stage 1: Tokenization

`GDScriptTokenizerText` performs lexical analysis, converting source code into a stream of tokens. Each token contains type information, literal values, position data, and cursor placement for code completion.

```mermaid
graph LR
    Source["Source Code String"]
    Tokenizer["GDScriptTokenizerText"]
    Token1["Token<br/>type: FUNC<br/>line: 1"]
    Token2["Token<br/>type: IDENTIFIER<br/>literal: 'my_func'"]
    Token3["Token<br/>type: PARENTHESIS_OPEN"]
    
    Source --> Tokenizer
    Tokenizer -->|scan| Token1
    Tokenizer -->|scan| Token2
    Tokenizer -->|scan| Token3
```

**Token Types** include keywords (`FUNC`, `VAR`, `CLASS`), operators (`PLUS`, `EQUAL`, `AND`), literals (`LITERAL`), identifiers (`IDENTIFIER`), and structural tokens (`INDENT`, `DEDENT`, `NEWLINE`).

**Sources:** [modules/gdscript/gdscript_tokenizer.cpp:44-158](), [modules/gdscript/gdscript_tokenizer.h:1-300]()

### Stage 2: Parsing

`GDScriptParser` builds an Abstract Syntax Tree from the token stream. The AST consists of node types representing language constructs.

**Key AST Node Types:**

| Node Type | Purpose | Key Fields |
|-----------|---------|------------|
| `ClassNode` | Class definition | `members[]`, `base_type`, `identifier` |
| `FunctionNode` | Function definition | `identifier`, `parameters[]`, `body` |
| `VariableNode` | Variable declaration | `identifier`, `initializer`, `datatype_specifier` |
| `ExpressionNode` | Base for expressions | `datatype`, `is_constant`, `reduced_value` |
| `SuiteNode` | Block of statements | `statements[]`, `locals` |

The parser maintains context during parsing (`current_class`, `current_function`, `current_suite`) and supports code completion by tracking cursor positions.

**Sources:** [modules/gdscript/gdscript_parser.cpp:686-857](), [modules/gdscript/gdscript_parser.h:54-1000]()

### Stage 3: Semantic Analysis

`GDScriptAnalyzer` performs type resolution and semantic validation in multiple passes:

```mermaid
graph TD
    Start["GDScriptAnalyzer::analyze"]
    Inheritance["resolve_inheritance<br/>Determine base classes"]
    Interface["resolve_interface<br/>Resolve member signatures"]
    Body["resolve_body<br/>Validate function bodies"]
    Done["Analysis Complete"]
    
    Start --> Inheritance
    Inheritance --> Interface
    Interface --> Body
    Body --> Done
    
    Inheritance -.updates.-> DataType1["ClassNode.base_type"]
    Interface -.updates.-> DataType2["Member DataTypes"]
    Body -.updates.-> DataType3["Expression DataTypes"]
```

**Type System:**

The `GDScriptParser::DataType` structure represents type information:

- **Kind**: `BUILTIN`, `NATIVE`, `SCRIPT`, `CLASS`, `ENUM`, `VARIANT`
- **Type Source**: `UNDETECTED`, `INFERRED`, `ANNOTATED_EXPLICIT`, `ANNOTATED_INFERRED`
- **Container Types**: Stores element types for typed `Array` and `Dictionary`

**Sources:** [modules/gdscript/gdscript_analyzer.cpp:344-650](), [modules/gdscript/gdscript_parser.h:101-259]()

### Stage 4: Code Generation

`GDScriptCompiler` traverses the validated AST and uses `GDScriptByteCodeGenerator` to produce bytecode.

```mermaid
graph TB
    AST["AST<br/>ClassNode"]
    Compiler["GDScriptCompiler"]
    CodeGen["GDScriptByteCodeGenerator"]
    
    subgraph "Generated Structures"
        GDScriptRes["GDScript<br/>member_indices<br/>constants<br/>member_functions"]
        InitFunc["initializer:<br/>GDScriptFunction"]
        StaticInit["static_initializer:<br/>GDScriptFunction"]
        MemberFuncs["member_functions:<br/>HashMap&lt;StringName, GDScriptFunction*&gt;"]
    end
    
    AST --> Compiler
    Compiler --> CodeGen
    CodeGen --> GDScriptRes
    GDScriptRes --> InitFunc
    GDScriptRes --> StaticInit
    GDScriptRes --> MemberFuncs
```

**Bytecode Instructions** include:
- Variable access: `OPCODE_GET_MEMBER`, `OPCODE_SET_MEMBER`, `OPCODE_GET_NAMED`
- Arithmetic: `OPCODE_OPERATOR`, `OPCODE_OPERATOR_VALIDATED`
- Control flow: `OPCODE_JUMP`, `OPCODE_JUMP_IF`, `OPCODE_RETURN`
- Function calls: `OPCODE_CALL`, `OPCODE_CALL_SELF`, `OPCODE_CALL_BUILTIN`

**Sources:** [modules/gdscript/gdscript_compiler.cpp:44-2500](), [modules/gdscript/gdscript_byte_codegen.cpp:1-1500]()

## Runtime System

### GDScript Resource

The `GDScript` class represents a compiled script as a `Resource`. It stores:

| Member | Type | Purpose |
|--------|------|---------|
| `member_indices` | `HashMap<StringName, MemberInfo>` | Maps member names to indices and types |
| `member_functions` | `HashMap<StringName, GDScriptFunction*>` | Compiled functions |
| `constants` | `HashMap<StringName, Variant>` | Constant values |
| `static_variables` | `Vector<Variant>` | Static variable storage |
| `subclasses` | `HashMap<StringName, Ref<GDScript>>` | Inner classes |
| `initializer` | `GDScriptFunction*` | Constructor function |
| `base` | `Ref<GDScript>` | Base script |
| `native` | `Ref<GDScriptNativeClass>` | Native base class |

**Sources:** [modules/gdscript/gdscript.h:60-300](), [modules/gdscript/gdscript.cpp:122-250]()

### GDScriptInstance

`GDScriptInstance` represents a script attached to an `Object`. It implements the `ScriptInstance` interface.

```mermaid
graph LR
    Object["Object<br/>owner"]
    Instance["GDScriptInstance<br/>members[]<br/>script"]
    Script["GDScript<br/>member_functions<br/>member_indices"]
    
    Object -->|owns| Instance
    Instance -->|references| Script
    Instance -->|stores| Members["members: Variant[]<br/>Runtime member values"]
```

**Lifecycle:**

1. **Creation**: `GDScript::_create_instance()` allocates instance and calls `implicit_initializer`
2. **Initialization**: Runs `_super_implicit_constructor()` for base classes, then constructor with arguments
3. **Method Calls**: `GDScriptInstance::callp()` looks up function in script hierarchy and executes
4. **Destruction**: `queue_free()` triggers exit callbacks and cleanup

**Sources:** [modules/gdscript/gdscript.cpp:151-205](), [modules/gdscript/gdscript.cpp:669-685]()

### GDScriptVM Execution

`GDScriptVM` executes bytecode from `GDScriptFunction` objects. The VM is stack-based with a call stack for function invocation.

```mermaid
graph TB
    Function["GDScriptFunction::call<br/>p_instance, p_args"]
    VMCall["GDScriptFunction::_execute_internal"]
    Stack["Stack<br/>Variant[stack_size]<br/>locals + temporaries"]
    
    subgraph "Bytecode Execution Loop"
        FetchOpcode["Fetch next opcode"]
        Decode["Decode instruction + operands"]
        Execute["Execute operation"]
        UpdateIP["Update instruction pointer"]
    end
    
    Function --> VMCall
    VMCall --> Stack
    VMCall --> FetchOpcode
    FetchOpcode --> Decode
    Decode --> Execute
    Execute --> UpdateIP
    UpdateIP --> FetchOpcode
```

**Stack Layout:**

Fixed addresses (0-5): NIL, true, false, Local execution context, Temporary storage
Addresses 6+: Function parameters, local variables, temporary values

**Instruction Format:**

Each instruction consists of an opcode followed by address operands. Addresses reference stack positions, constants, or named identifiers.

**Sources:** [modules/gdscript/gdscript_vm.cpp:1-3000](), [modules/gdscript/gdscript_function.h:43-300]()

## Cache System

`GDScriptCache` manages parsed scripts to avoid redundant compilation. It maintains parser references with incremental status tracking.

```mermaid
stateDiagram-v2
    [*] --> EMPTY
    EMPTY --> PARSED: parse source/binary
    PARSED --> INHERITANCE_SOLVED: resolve_inheritance
    INHERITANCE_SOLVED --> INTERFACE_SOLVED: resolve_interface
    INTERFACE_SOLVED --> FULLY_SOLVED: resolve_body
    FULLY_SOLVED --> [*]
```

**GDScriptParserRef Status:**

- `EMPTY`: Not yet parsed
- `PARSED`: Tokenized and AST built
- `INHERITANCE_SOLVED`: Base classes resolved
- `INTERFACE_SOLVED`: Member signatures resolved
- `FULLY_SOLVED`: Full semantic analysis complete

`GDScriptCache::get_parser()` retrieves or creates a `GDScriptParserRef` and advances it to the requested status. This allows dependent scripts to reference partially-analyzed scripts without circular dependency issues.

**Sources:** [modules/gdscript/gdscript_cache.cpp:41-110](), [modules/gdscript/gdscript_cache.h:1-150]()

## Data Type System

The scripting system uses parallel type representations at compile-time and runtime:

| Stage | Type Class | Location | Purpose |
|-------|-----------|----------|---------|
| Compile-time | `GDScriptParser::DataType` | Parser/Analyzer | Type checking, inference |
| Runtime | `GDScriptDataType` | Compiler/VM | Type validation during execution |

**Type Validation:**

For typed containers (`Array[T]`, `Dictionary[K,V]`), the `GDScriptDataType::is_type()` method validates element types at runtime. Container element types are stored in the `container_element_types` vector.

**Sources:** [modules/gdscript/gdscript_parser.h:101-259](), [modules/gdscript/gdscript_function.h:46-150]()

## Integration Points

The scripting system integrates with other engine systems:

**Scene System**: Scripts attach to `Node` objects via `ScriptInstance`. The `_ready()`, `_process()`, and other lifecycle callbacks are invoked by `SceneTree`.

**Resource System**: `GDScript` extends `Resource` and uses `ResourceLoader`/`ResourceSaver` for persistence. The `.gd` format is handled by `ResourceFormatLoaderGDScript`.

**ClassDB**: Native classes are accessed through `ClassDB` for method calls, property access, and constant lookups. The `GDScriptNativeClass` wrapper represents native classes as script-accessible objects.

**Project Settings**: Warning levels and directory rules are loaded from `ProjectSettings` at parse time.

**Sources:** [modules/gdscript/gdscript.cpp:402-438](), [modules/gdscript/gdscript_parser.cpp:99-143]()2f:T6077,# GDScript Parser

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [modules/gdscript/gdscript.cpp](modules/gdscript/gdscript.cpp)
- [modules/gdscript/gdscript.h](modules/gdscript/gdscript.h)
- [modules/gdscript/gdscript_analyzer.cpp](modules/gdscript/gdscript_analyzer.cpp)
- [modules/gdscript/gdscript_analyzer.h](modules/gdscript/gdscript_analyzer.h)
- [modules/gdscript/gdscript_byte_codegen.cpp](modules/gdscript/gdscript_byte_codegen.cpp)
- [modules/gdscript/gdscript_byte_codegen.h](modules/gdscript/gdscript_byte_codegen.h)
- [modules/gdscript/gdscript_cache.cpp](modules/gdscript/gdscript_cache.cpp)
- [modules/gdscript/gdscript_cache.h](modules/gdscript/gdscript_cache.h)
- [modules/gdscript/gdscript_codegen.h](modules/gdscript/gdscript_codegen.h)
- [modules/gdscript/gdscript_compiler.cpp](modules/gdscript/gdscript_compiler.cpp)
- [modules/gdscript/gdscript_compiler.h](modules/gdscript/gdscript_compiler.h)
- [modules/gdscript/gdscript_disassembler.cpp](modules/gdscript/gdscript_disassembler.cpp)
- [modules/gdscript/gdscript_editor.cpp](modules/gdscript/gdscript_editor.cpp)
- [modules/gdscript/gdscript_function.cpp](modules/gdscript/gdscript_function.cpp)
- [modules/gdscript/gdscript_function.h](modules/gdscript/gdscript_function.h)
- [modules/gdscript/gdscript_parser.cpp](modules/gdscript/gdscript_parser.cpp)
- [modules/gdscript/gdscript_parser.h](modules/gdscript/gdscript_parser.h)
- [modules/gdscript/gdscript_tokenizer.cpp](modules/gdscript/gdscript_tokenizer.cpp)
- [modules/gdscript/gdscript_tokenizer.h](modules/gdscript/gdscript_tokenizer.h)
- [modules/gdscript/gdscript_vm.cpp](modules/gdscript/gdscript_vm.cpp)
- [modules/gdscript/gdscript_warning.cpp](modules/gdscript/gdscript_warning.cpp)
- [modules/gdscript/gdscript_warning.h](modules/gdscript/gdscript_warning.h)
- [modules/gdscript/tests/gdscript_test_runner.cpp](modules/gdscript/tests/gdscript_test_runner.cpp)
- [modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out](modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out)
- [modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd](modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out)

</details>



The GDScript Parser transforms GDScript source code into an Abstract Syntax Tree (AST) that represents the syntactic structure of the code. It is the second stage of the GDScript compilation pipeline, following tokenization and preceding semantic analysis.

**Related Pages:**
- For semantic analysis and type resolution, see [GDScript Analyzer](#6.2)
- For bytecode generation, see [GDScript Compiler & VM](#6.3)
- For the complete GDScript system, see [GDScript System](#6)

---

## Parser Pipeline Overview

The parser operates as part of a multi-stage compilation pipeline:

```mermaid
flowchart LR
    Source["GDScript Source Code<br/>.gd file"]
    Tokenizer["GDScriptTokenizer<br/>scan()"]
    Parser["GDScriptParser<br/>parse_program()"]
    Analyzer["GDScriptAnalyzer<br/>analyze()"]
    Compiler["GDScriptCompiler<br/>compile()"]
    
    Source --> Tokenizer
    Tokenizer --> Parser
    Parser --> Analyzer
    Analyzer --> Compiler
    
    Tokenizer -.->|"Token stream"| Parser
    Parser -.->|"AST (ClassNode tree)"| Analyzer
    Analyzer -.->|"Typed AST"| Compiler
```

**Parser responsibilities:**
- Consume tokens from `GDScriptTokenizer`
- Build AST node hierarchy
- Track source locations for error reporting
- Handle annotations (`@export`, `@onready`, etc.)
- Provide completion context for editor integration
- Detect syntax errors (not semantic errors)

Sources: [modules/gdscript/gdscript_parser.cpp:416-515](), [modules/gdscript/gdscript_parser.h:54-259]()

---

## Core Parser Classes

```mermaid
classDiagram
    class GDScriptParser {
        +parse(source, path, for_completion, parse_body) Error
        +parse_binary(binary, path) Error
        +get_tree() ClassNode
        +get_errors() List~ParserError~
        -parse_program()
        -parse_class_body()
        -parse_statement()
        -parse_expression()
    }
    
    class GDScriptTokenizer {
        +scan() Token
        +set_source_code(source)
        +set_multiline_mode(enabled)
    }
    
    class ClassNode {
        +identifier IdentifierNode
        +members List~Member~
        +base_type DataType
        +extends_used bool
        +fqcn String
    }
    
    class Node {
        +type Type
        +start_line int
        +end_line int
        +datatype DataType
        +annotations List~AnnotationNode~
    }
    
    class DataType {
        +kind Kind
        +type_source TypeSource
        +builtin_type Variant::Type
        +native_type StringName
        +class_type ClassNode
        +is_hard_type() bool
    }
    
    GDScriptParser --> GDScriptTokenizer : uses
    GDScriptParser --> ClassNode : produces
    ClassNode --|> Node
    Node --> DataType : has
```

Sources: [modules/gdscript/gdscript_parser.h:54-259](), [modules/gdscript/gdscript_parser.cpp:145-218]()

---

## Entry Points and Parse Modes

The parser has two main entry points depending on the source format:

### Text Source Parsing

```mermaid
flowchart TD
    Entry["GDScriptParser::parse()<br/>source_code, script_path"]
    CreateTokenizer["Create GDScriptTokenizerText"]
    SetSource["tokenizer->set_source_code()"]
    ScanFirst["current = tokenizer->scan()"]
    ParseProg["parse_program()"]
    Result["Return OK or ERR_PARSE_ERROR"]
    
    Entry --> CreateTokenizer
    CreateTokenizer --> SetSource
    SetSource --> ScanFirst
    ScanFirst --> ParseProg
    ParseProg --> Result
    
    ParseProg -.->|"Sets parser->head<br/>(ClassNode)"| Result
```

The `parse()` method handles text-based `.gd` files. Key parameters:
- `p_source_code` - Raw GDScript source
- `p_script_path` - File path for error reporting
- `p_for_completion` - Whether to enable code completion mode
- `p_parse_body` - If false, only parses class header (class_name, extends, annotations)

Sources: [modules/gdscript/gdscript_parser.cpp:416-515]()

### Binary Token Parsing

```mermaid
flowchart TD
    Entry["GDScriptParser::parse_binary()<br/>binary_tokens, script_path"]
    CreateTokenizer["Create GDScriptTokenizerBuffer"]
    SetBuffer["tokenizer->set_code_buffer()"]
    ScanFirst["current = tokenizer->scan()"]
    ParseProg["parse_program()"]
    Result["Return OK or ERR_PARSE_ERROR"]
    
    Entry --> CreateTokenizer
    CreateTokenizer --> SetBuffer
    SetBuffer --> ScanFirst
    ScanFirst --> ParseProg
    ParseProg --> Result
```

The `parse_binary()` method handles pre-tokenized bytecode from `.gdc` files, allowing faster loading of cached scripts.

Sources: [modules/gdscript/gdscript_parser.cpp:517-556]()

---

## Token Management

The parser maintains token state and advances through the token stream:

| Member Variable | Type | Purpose |
|----------------|------|---------|
| `current` | `GDScriptTokenizer::Token` | Current token being examined |
| `previous` | `GDScriptTokenizer::Token` | Previously consumed token |
| `tokenizer` | `GDScriptTokenizer*` | Token source |
| `multiline_stack` | `List<bool>` | Tracks multiline context (arrays, dicts) |

### Token Consumption Methods

**`advance()`** - Moves to the next token, skipping ERROR tokens
```
previous = current
current = tokenizer->scan()
```

**`match(token_type)`** - Checks if current token matches type, advances if true
```
if check(token_type):
    advance()
    return true
return false
```

**`consume(token_type, error_msg)`** - Like match() but pushes error if not found

Sources: [modules/gdscript/gdscript_parser.cpp:558-599]()

---

## AST Node Hierarchy

```mermaid
classDiagram
    class Node {
        <<abstract>>
        +Type type
        +int start_line, end_line
        +int start_column, end_column
        +DataType datatype
        +List~AnnotationNode~ annotations
    }
    
    class ExpressionNode {
        +bool reduced
        +bool is_constant
        +Variant reduced_value
    }
    
    class ClassNode {
        +IdentifierNode identifier
        +Vector~Member~ members
        +DataType base_type
        +bool extends_used
        +String fqcn
        +ClassNode outer
    }
    
    class FunctionNode {
        +IdentifierNode identifier
        +Vector~ParameterNode~ parameters
        +SuiteNode body
        +TypeNode return_type
        +bool is_static
        +bool is_coroutine
    }
    
    class VariableNode {
        +IdentifierNode identifier
        +ExpressionNode initializer
        +TypeNode datatype_specifier
        +bool exported
        +PropertyInfo export_info
    }
    
    class SuiteNode {
        +Vector~Node~ statements
        +HashMap~StringName, Local~ locals
    }
    
    Node <|-- ExpressionNode
    Node <|-- ClassNode
    Node <|-- FunctionNode
    Node <|-- VariableNode
    Node <|-- SuiteNode
    
    ClassNode --> FunctionNode : members
    ClassNode --> VariableNode : members
    FunctionNode --> SuiteNode : body
```

### Key Node Types

| Node Type | Purpose | Parse Method |
|-----------|---------|--------------|
| `ClassNode` | Script class definition | `parse_class_body()` |
| `FunctionNode` | Function/method declaration | `parse_function()` |
| `VariableNode` | Member or local variable | `parse_variable()` |
| `ConstantNode` | Constant declaration | `parse_constant()` |
| `SignalNode` | Signal declaration | `parse_signal()` |
| `EnumNode` | Enum definition | `parse_enum()` |
| `SuiteNode` | Code block with statements | `parse_suite()` |
| `ExpressionNode` | Base for all expressions | Various `parse_*` methods |

Sources: [modules/gdscript/gdscript_parser.h:295-815]()

---

## Program Structure Parsing

The top-level parsing follows this structure:

```mermaid
flowchart TD
    Start["parse_program()"]
    CreateHead["head = alloc_node&lt;ClassNode&gt;()<br/>head->fqcn = script_path"]
    
    ParseAnnotations["Parse @annotations"]
    CheckClassOrExtends{{"class_name or<br/>extends?"}}
    ParseClassName["parse_class_name()"]
    ParseExtends["parse_extends()"]
    
    ParseBody["parse_class_body(true)"]
    Complete["head->end_line = current.end_line"]
    
    Start --> CreateHead
    CreateHead --> ParseAnnotations
    ParseAnnotations --> CheckClassOrExtends
    CheckClassOrExtends -->|"class_name"| ParseClassName
    CheckClassOrExtends -->|"extends"| ParseExtends
    CheckClassOrExtends -->|"neither"| ParseBody
    ParseClassName --> ParseBody
    ParseExtends --> ParseBody
    ParseBody --> Complete
```

### Class-Level Parsing

The `parse_class_body()` method handles:
- Class member declarations (variables, functions, signals, enums)
- Inner class definitions
- Export grouping annotations (`@export_category`, `@export_group`)
- Documentation comments (in TOOLS_ENABLED builds)

**Member dispatch table:**

| Token Type | Parsed As | Method |
|------------|-----------|--------|
| `VAR` | Variable | `parse_variable()` |
| `TK_CONST` | Constant | `parse_constant()` |
| `FUNC` | Function | `parse_function()` |
| `SIGNAL` | Signal | `parse_signal()` |
| `ENUM` | Enum | `parse_enum()` |
| `CLASS` | Inner class | Recursive `parse_class()` |
| `ANNOTATION` | Annotation | `parse_annotation()` |

Sources: [modules/gdscript/gdscript_parser.cpp:686-857](), [modules/gdscript/gdscript_parser.cpp:958-1298]()

---

## Expression Parsing

Expression parsing uses precedence climbing to handle operator precedence correctly:

```mermaid
flowchart TD
    ParseExpr["parse_expression(allow_assign)"]
    ParseOperand["parse_operand()"]
    CheckOp{{"Is operator token?"}}
    GetPrecedence["Get operator precedence"]
    CheckPrecedence{{"precedence >= min?"}}
    ParseRight["Parse right operand<br/>(recursive)"]
    CreateBinOp["Create BinaryOpNode"]
    Return["Return expression"]
    
    ParseExpr --> ParseOperand
    ParseOperand --> CheckOp
    CheckOp -->|"Yes"| GetPrecedence
    CheckOp -->|"No"| Return
    GetPrecedence --> CheckPrecedence
    CheckPrecedence -->|"Yes"| ParseRight
    CheckPrecedence -->|"No"| Return
    ParseRight --> CreateBinOp
    CreateBinOp --> CheckOp
```

### Expression Node Types

| Expression Type | Description | Example |
|----------------|-------------|---------|
| `LiteralNode` | Constant literal | `42`, `"hello"`, `true` |
| `IdentifierNode` | Variable/constant reference | `my_var` |
| `BinaryOpNode` | Binary operation | `a + b`, `x < 5` |
| `UnaryOpNode` | Unary operation | `-x`, `not flag` |
| `CallNode` | Function call | `foo(1, 2)` |
| `SubscriptNode` | Array/dict access | `arr[0]`, `dict["key"]` |
| `CastNode` | Type cast | `x as int` |
| `AwaitNode` | Await expression | `await signal` |
| `ArrayNode` | Array literal | `[1, 2, 3]` |
| `DictionaryNode` | Dictionary literal | `{a: 1, b: 2}` |
| `GetNodeNode` | NodePath shorthand | `$NodeName`, `%UniqueNode` |

Sources: [modules/gdscript/gdscript_parser.cpp:2735-3967]()

---

## Annotation System

Annotations provide metadata for the analyzer and runtime. The parser validates annotation placement but doesn't execute them:

```mermaid
flowchart LR
    subgraph "Annotation Parsing"
        Token["@annotation_name"]
        ParseArgs["parse_annotation()<br/>Parse arguments"]
        ValidateTarget["Check target_kinds<br/>(SCRIPT/CLASS/VARIABLE/etc)"]
        Store["Store in annotation_stack"]
    end
    
    subgraph "Annotation Application"
        Apply["annotation->apply()<br/>Called by analyzer"]
        Resolve["Resolve arguments"]
        Execute["Execute annotation logic"]
    end
    
    Token --> ParseArgs
    ParseArgs --> ValidateTarget
    ValidateTarget --> Store
    Store -.->|"Later"| Apply
    Apply --> Resolve
    Resolve --> Execute
```

### Annotation Types by Target

| Annotation | Target | Purpose |
|------------|--------|---------|
| `@tool` | SCRIPT | Mark script as tool script |
| `@icon` | SCRIPT | Set class icon |
| `@static_unload` | SCRIPT | Unload static variables on script unload |
| `@abstract` | SCRIPT/CLASS/FUNCTION | Mark as abstract (cannot instantiate) |
| `@onready` | VARIABLE | Initialize on _ready() |
| `@export` | VARIABLE | Export variable to inspector |
| `@export_range` | VARIABLE | Export with range constraints |
| `@export_enum` | VARIABLE | Export as enum dropdown |
| `@export_category` | STANDALONE | Create export category |
| `@export_group` | STANDALONE | Create export group |
| `@warning_ignore` | CLASS_LEVEL/STATEMENT | Ignore specific warnings |
| `@rpc` | FUNCTION | Configure RPC mode |

**Registration:**
```cpp
register_annotation(MethodInfo("@export"), AnnotationInfo::VARIABLE, 
                   &GDScriptParser::export_annotations);
```

Sources: [modules/gdscript/gdscript_parser.cpp:145-191](), [modules/gdscript/gdscript_parser.cpp:4893-5563]()

---

## Completion Context

When `p_for_completion` is true, the parser tracks context for code completion:

```mermaid
classDiagram
    class CompletionContext {
        +CompletionType type
        +Node node
        +ClassNode current_class
        +FunctionNode current_function
        +SuiteNode current_suite
        +int current_line
        +int current_argument
    }
    
    class CompletionType {
        <<enumeration>>
        COMPLETION_NONE
        COMPLETION_INHERIT_TYPE
        COMPLETION_TYPE_HINT
        COMPLETION_PROPERTY_DECLARATION
        COMPLETION_METHOD_DECLARATION
        COMPLETION_CALL_ARGUMENTS
        COMPLETION_IDENTIFIER
        COMPLETION_ATTRIBUTE
        COMPLETION_SUBSCRIPT
        ...
    }
    
    CompletionContext --> CompletionType
```

**Completion trigger methods:**

`make_completion_context(type, node, argument)` - Set completion point
- Called at cursor position during parsing
- Captures surrounding context (class, function, suite)
- Records what kind of completion is needed

`override_completion_context(node, type, ...)` - Override existing context
- Used when more specific context is discovered

Sources: [modules/gdscript/gdscript_parser.cpp:325-414](), [modules/gdscript/gdscript_parser.h:904-978]()

---

## Error Handling and Recovery

The parser tracks errors and attempts synchronization to continue parsing:

```mermaid
flowchart TD
    Error["push_error(message, node)"]
    SetPanic["panic_mode = true"]
    Store["errors.push_back({message, line, column})"]
    
    Sync["synchronize()"]
    SkipTokens["Skip tokens until<br/>statement boundary"]
    ClearPanic["panic_mode = false"]
    
    Error --> SetPanic
    SetPanic --> Store
    Store -.->|"Later"| Sync
    Sync --> SkipTokens
    SkipTokens --> ClearPanic
```

**Error types:**
- Syntax errors (unexpected token, missing semicolon, etc.)
- Invalid structure (extends/class_name in wrong position)
- Annotation misuse (wrong target, invalid arguments)

**Synchronization points:**
- Newline or semicolon
- Statement-starting keywords (`func`, `var`, `class`, etc.)
- End of file

Sources: [modules/gdscript/gdscript_parser.cpp:234-244](), [modules/gdscript/gdscript_parser.cpp:605-633]()

---

## DataType System

The parser attaches `DataType` information to nodes for the analyzer:

```mermaid
classDiagram
    class DataType {
        +Kind kind
        +TypeSource type_source
        +Variant::Type builtin_type
        +StringName native_type
        +StringName enum_type
        +ClassNode class_type
        +Ref~Script~ script_type
        +bool is_constant
        +bool is_meta_type
        +Vector~DataType~ container_element_types
    }
    
    class Kind {
        <<enumeration>>
        BUILTIN
        NATIVE
        SCRIPT
        CLASS
        ENUM
        VARIANT
        RESOLVING
        UNRESOLVED
    }
    
    class TypeSource {
        <<enumeration>>
        UNDETECTED
        INFERRED
        ANNOTATED_EXPLICIT
        ANNOTATED_INFERRED
    }
    
    DataType --> Kind
    DataType --> TypeSource
```

**Initial state:** Most `DataType` objects start as `UNRESOLVED` and are filled in by the analyzer.

**Parser-set types:**
- Literal constants (numbers, strings, etc.) â†’ `BUILTIN`
- Type hints in variable/parameter declarations â†’ `UNRESOLVED` (to be resolved)
- Meta types (class names) â†’ `is_meta_type = true`

Sources: [modules/gdscript/gdscript_parser.h:101-259]()

---

## Integration with Analyzer

The parser produces an AST that the analyzer then processes:

```mermaid
sequenceDiagram
    participant Cache as GDScriptCache
    participant ParserRef as GDScriptParserRef
    participant Parser as GDScriptParser
    participant Analyzer as GDScriptAnalyzer
    
    Cache->>ParserRef: get_parser(path)
    ParserRef->>ParserRef: raise_status(PARSED)
    ParserRef->>Parser: parse(source, path)
    Parser-->>ParserRef: OK (AST in parser->head)
    
    ParserRef->>ParserRef: raise_status(INHERITANCE_SOLVED)
    ParserRef->>Analyzer: resolve_inheritance()
    Analyzer->>Parser: get_tree()
    Analyzer->>Analyzer: Process base types
    
    ParserRef->>ParserRef: raise_status(INTERFACE_SOLVED)
    ParserRef->>Analyzer: resolve_interface()
    
    ParserRef->>ParserRef: raise_status(FULLY_SOLVED)
    ParserRef->>Analyzer: resolve_body()
    Analyzer-->>ParserRef: OK (Typed AST)
```

**Parser â†’ Analyzer handoff:**
1. Parser creates AST with `UNRESOLVED` types
2. Analyzer resolves inheritance (`resolve_inheritance()`)
3. Analyzer resolves member signatures (`resolve_interface()`)
4. Analyzer resolves function bodies (`resolve_body()`)
5. Analyzer fills in all `DataType` fields
6. Analyzer performs type checking and generates warnings

Sources: [modules/gdscript/gdscript_cache.cpp:67-108](), [modules/gdscript/gdscript_analyzer.cpp:344-630]()

---

## Multiline Mode

The parser tracks multiline contexts to suppress INDENT/DEDENT/NEWLINE tokens inside expressions:

```mermaid
stateDiagram-v2
    [*] --> Normal
    Normal --> Multiline: push_multiline(true)<br/>at [ { (
    Multiline --> Multiline: Nested structures
    Multiline --> Normal: pop_multiline()<br/>at ] } )
    Normal --> [*]
    
    state Normal {
        [*] --> ProcessNewlines
        ProcessNewlines --> ProcessIndents
        ProcessIndents --> [*]
    }
    
    state Multiline {
        [*] --> IgnoreWhitespace
        note right of IgnoreWhitespace
            NEWLINE/INDENT/DEDENT
            tokens are consumed
            automatically
        end note
    }
```

**Use cases:**
- Array literals: `[1, 2, 3]`
- Dictionary literals: `{a: 1, b: 2}`
- Parenthesized expressions: `(x + y)`
- Function call arguments: `foo(a, b, c)`
- Type hints with brackets: `Array[int]`

Sources: [modules/gdscript/gdscript_parser.cpp:635-650]()

---

## Parser State Management

The parser maintains context during parsing:

| State Variable | Type | Purpose |
|---------------|------|---------|
| `head` | `ClassNode*` | Root class node (main script class) |
| `current_class` | `ClassNode*` | Currently parsing class (for nested classes) |
| `current_function` | `FunctionNode*` | Currently parsing function |
| `current_suite` | `SuiteNode*` | Currently parsing code block |
| `panic_mode` | `bool` | Whether in error recovery mode |
| `for_completion` | `bool` | Whether parsing for code completion |
| `in_lambda` | `bool` | Whether inside lambda expression |
| `lambda_ended` | `bool` | Marker for lambda expression end |

**State transitions example (nested class):**
```
parse_program()
  current_class = head
  parse_class_body()
    // Outer class members
    parse_class()  // Inner class
      current_class = inner_class_node
      parse_class_body()
        // Inner class members
      current_class = previous_class
```

Sources: [modules/gdscript/gdscript_parser.h:980-1033]()

---

## Memory Management

Parser nodes use a custom allocation system:

```mermaid
flowchart LR
    AllocNode["alloc_node&lt;T&gt;()"]
    CreateNode["node = memnew(T)"]
    AddToList["node->next = list<br/>list = node"]
    Return["return node"]
    
    Destructor["~GDScriptParser()"]
    FreeLoop["while (list != nullptr)<br/>memdelete(list)<br/>list = list->next"]
    
    AllocNode --> CreateNode
    CreateNode --> AddToList
    AddToList --> Return
    
    Destructor --> FreeLoop
```

**Allocation pattern:**
```cpp
template <typename T>
T *GDScriptParser::alloc_node() {
    T *node = memnew(T);
    node->next = list;
    list = node;
    return node;
}
```

All nodes are linked in a list and freed in the destructor. This avoids manual tracking of every allocated node.

Sources: [modules/gdscript/gdscript_parser.h:1080-1101](), [modules/gdscript/gdscript_parser.cpp:220-232]()

---

## Parse Performance Optimization

The parser includes an optimization mode for fast header-only parsing:

**Fast path (parse_body = false):**
- Only parses annotations, `class_name`, `extends`
- Skips function bodies and class member details
- Used by `GDScriptLanguage::get_global_class_name()`
- Significantly faster for large scripts

**When used:**
- Editor file scanning
- Quick class information retrieval
- Initial project load

Sources: [modules/gdscript/gdscript_parser.cpp:816-820]()

---

## Warning System Integration

The parser collects warnings that are applied after parsing completes:

```mermaid
flowchart TD
    PushWarning["push_warning(node, code, symbols)"]
    CheckIgnored{{"Is warning ignored?"}}
    AddPending["pending_warnings.push_back()"]
    
    ApplyPending["apply_pending_warnings()"]
    CheckIgnoredLines{{"Line in ignored_lines?"}}
    TreatAsError{{"Treat as error?"}}
    PushError["push_error()"]
    AddWarning["warnings.push_back()"]
    
    PushWarning --> CheckIgnored
    CheckIgnored -->|"No"| AddPending
    CheckIgnored -->|"Yes"| Return["Return"]
    
    AddPending -.->|"After parsing"| ApplyPending
    ApplyPending --> CheckIgnoredLines
    CheckIgnoredLines -->|"No"| TreatAsError
    CheckIgnoredLines -->|"Yes"| Return
    TreatAsError -->|"Yes"| PushError
    TreatAsError -->|"No"| AddWarning
```

**Warning ignore mechanisms:**
- `@warning_ignore("warning_name")` annotation
- `@warning_ignore_start("warning_name")` / `@warning_ignore_restore()` regions
- Project-level warning configuration
- Directory-based warning rules

Sources: [modules/gdscript/gdscript_parser.cpp:246-323](), [modules/gdscript/gdscript_parser.h:1037-1045]()30:T492a,# GDScript Analyzer

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [modules/gdscript/gdscript.cpp](modules/gdscript/gdscript.cpp)
- [modules/gdscript/gdscript.h](modules/gdscript/gdscript.h)
- [modules/gdscript/gdscript_analyzer.cpp](modules/gdscript/gdscript_analyzer.cpp)
- [modules/gdscript/gdscript_analyzer.h](modules/gdscript/gdscript_analyzer.h)
- [modules/gdscript/gdscript_byte_codegen.cpp](modules/gdscript/gdscript_byte_codegen.cpp)
- [modules/gdscript/gdscript_byte_codegen.h](modules/gdscript/gdscript_byte_codegen.h)
- [modules/gdscript/gdscript_cache.cpp](modules/gdscript/gdscript_cache.cpp)
- [modules/gdscript/gdscript_cache.h](modules/gdscript/gdscript_cache.h)
- [modules/gdscript/gdscript_codegen.h](modules/gdscript/gdscript_codegen.h)
- [modules/gdscript/gdscript_compiler.cpp](modules/gdscript/gdscript_compiler.cpp)
- [modules/gdscript/gdscript_compiler.h](modules/gdscript/gdscript_compiler.h)
- [modules/gdscript/gdscript_disassembler.cpp](modules/gdscript/gdscript_disassembler.cpp)
- [modules/gdscript/gdscript_editor.cpp](modules/gdscript/gdscript_editor.cpp)
- [modules/gdscript/gdscript_function.cpp](modules/gdscript/gdscript_function.cpp)
- [modules/gdscript/gdscript_function.h](modules/gdscript/gdscript_function.h)
- [modules/gdscript/gdscript_parser.cpp](modules/gdscript/gdscript_parser.cpp)
- [modules/gdscript/gdscript_parser.h](modules/gdscript/gdscript_parser.h)
- [modules/gdscript/gdscript_tokenizer.cpp](modules/gdscript/gdscript_tokenizer.cpp)
- [modules/gdscript/gdscript_tokenizer.h](modules/gdscript/gdscript_tokenizer.h)
- [modules/gdscript/gdscript_vm.cpp](modules/gdscript/gdscript_vm.cpp)
- [modules/gdscript/gdscript_warning.cpp](modules/gdscript/gdscript_warning.cpp)
- [modules/gdscript/gdscript_warning.h](modules/gdscript/gdscript_warning.h)
- [modules/gdscript/tests/gdscript_test_runner.cpp](modules/gdscript/tests/gdscript_test_runner.cpp)
- [modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out](modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out)
- [modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd](modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out)

</details>



The GDScript Analyzer performs semantic analysis on the Abstract Syntax Tree (AST) produced by the GDScript Parser. It resolves types, validates type compatibility, resolves inheritance relationships, checks member access, performs constant folding, and generates warnings for potentially problematic code patterns.

For information about parsing GDScript source code into an AST, see [GDScript Parser](#6.3). For information about compiling the analyzed AST into bytecode, see [GDScript Compiler & VM](#6.5).

## Role in the Compilation Pipeline

The analyzer sits between parsing and compilation in the GDScript processing pipeline:

```mermaid
flowchart LR
    Source["Source Code<br/>(String)"]
    Parser["GDScriptParser<br/>parse()"]
    AST["Abstract Syntax Tree<br/>ClassNode, FunctionNode, etc."]
    Analyzer["GDScriptAnalyzer<br/>analyze()"]
    AnnotatedAST["Type-Annotated AST<br/>with DataType info"]
    Compiler["GDScriptCompiler<br/>compile()"]
    Bytecode["GDScriptFunction<br/>bytecode"]
    
    Source --> Parser
    Parser --> AST
    AST --> Analyzer
    Analyzer --> AnnotatedAST
    AnnotatedAST --> Compiler
    Compiler --> Bytecode
```

**Diagram: GDScript Compilation Pipeline**

The `GDScriptAnalyzer` class is instantiated with a reference to a `GDScriptParser` and operates on the parser's AST nodes. The analyzer modifies nodes in place, adding type information (`DataType`) and performing validation.

Sources: [modules/gdscript/gdscript_analyzer.cpp:1-100](), [modules/gdscript/gdscript_parser.cpp:415-514](), [modules/gdscript/gdscript_compiler.cpp:1-40]()

## GDScriptAnalyzer Class

The `GDScriptAnalyzer` class is defined in [modules/gdscript/gdscript_analyzer.h:1-150]() and implemented in [modules/gdscript/gdscript_analyzer.cpp]().

**Key Components:**

| Component | Type | Purpose |
|-----------|------|---------|
| `parser` | `GDScriptParser*` | Reference to the parser containing the AST |
| `depended_parsers` | `HashMap<String, Ref<GDScriptParserRef>>` | Cache of parsers for depended scripts |
| `errors` | `List<ParserError>` | Accumulated analysis errors |
| `lambda_stack` | `List<LambdaNode*>` | Stack tracking nested lambda contexts |

**Main Entry Point:**

The `analyze()` method at [modules/gdscript/gdscript_analyzer.cpp:4730-4757]() is the primary entry point. It performs analysis in phases:

1. Resolve class inheritance for all classes
2. Resolve class members (variables, constants, functions, signals)
3. Resolve function bodies
4. Apply pending warnings

Sources: [modules/gdscript/gdscript_analyzer.h:37-150](), [modules/gdscript/gdscript_analyzer.cpp:4730-4757]()

## Analysis Phases

```mermaid
flowchart TD
    Start["analyze()"]
    Phase1["Phase 1:<br/>resolve_class_inheritance()"]
    Phase2["Phase 2:<br/>resolve_class_body()"]
    Phase3["Phase 3:<br/>resolve_function_body()"]
    Phase4["Phase 4:<br/>apply_pending_warnings()"]
    Complete["Analysis Complete"]
    
    Start --> Phase1
    Phase1 --> Phase2
    Phase2 --> Phase3
    Phase3 --> Phase4
    Phase4 --> Complete
    
    Phase1 -.-> ResolveBase["Resolve base class types<br/>Set up inheritance chain"]
    Phase2 -.-> ResolveMembers["Resolve member types<br/>Check for conflicts<br/>Validate annotations"]
    Phase3 -.-> ResolveCode["Type check expressions<br/>Resolve identifiers<br/>Reduce constants"]
    Phase4 -.-> FilterWarnings["Filter ignored warnings<br/>Generate final warnings"]
```

**Diagram: Analysis Phases**

Sources: [modules/gdscript/gdscript_analyzer.cpp:4730-4757]()

### Phase 1: Inheritance Resolution

The `resolve_class_inheritance()` method at [modules/gdscript/gdscript_analyzer.cpp:344-630]() resolves the inheritance chain for each class:

1. **Parse extends clause**: Determines the base class from `extends` keyword
2. **Resolve base type**: 
   - For global classes, look up via `ScriptServer`
   - For nested classes, search in current scope
   - For script paths, load and parse the dependency
3. **Set base_type**: Store the resolved `DataType` in the `ClassNode`
4. **Check for cycles**: Detect cyclic inheritance patterns
5. **Apply annotations**: Process class-level annotations like `@tool`, `@icon`

The analyzer uses `GDScriptCache` to manage dependencies and avoid redundant parsing of imported scripts.

Sources: [modules/gdscript/gdscript_analyzer.cpp:344-630]()

### Phase 2: Member Resolution

The `resolve_class_body()` method at [modules/gdscript/gdscript_analyzer.cpp:1034-1250]() resolves all class members:

**Member Types Resolved:**
- Variables (with type inference)
- Constants (with value reduction)
- Signals
- Enums and enum values
- Functions (signatures only, not bodies)
- Inner classes (recursively)

For each member type, the analyzer:
1. Checks for name conflicts with inherited members
2. Resolves type annotations via `resolve_datatype()`
3. For constants, reduces initializer expressions to compile-time values
4. Validates annotations (e.g., `@export`, `@onready`)

Sources: [modules/gdscript/gdscript_analyzer.cpp:1034-1250](), [modules/gdscript/gdscript_analyzer.cpp:289-316]()

### Phase 3: Function Body Resolution

The `resolve_function_body()` method resolves the actual code in functions:

1. **Resolve suite**: Process the function's statement suite
2. **Type check statements**: Validate assignments, calls, control flow
3. **Reduce expressions**: Evaluate constant expressions at compile time
4. **Check return paths**: Ensure all code paths return appropriate values

Expression reduction is handled by `reduce_expression()` at [modules/gdscript/gdscript_analyzer.cpp:2827-3898](), which performs constant folding and type inference.

Sources: [modules/gdscript/gdscript_analyzer.cpp:1252-1400](), [modules/gdscript/gdscript_analyzer.cpp:2827-3898]()

## Type System

The analyzer works with the `GDScriptParser::DataType` structure defined in [modules/gdscript/gdscript_parser.h:101-259]():

```mermaid
classDiagram
    class DataType {
        +Kind kind
        +TypeSource type_source
        +bool is_constant
        +bool is_meta_type
        +Variant::Type builtin_type
        +StringName native_type
        +StringName enum_type
        +Ref~Script~ script_type
        +ClassNode* class_type
        +Vector~DataType~ container_element_types
        +to_string() String
        +is_hard_type() bool
    }
    
    class Kind {
        <<enumeration>>
        BUILTIN
        NATIVE
        SCRIPT
        CLASS
        ENUM
        VARIANT
        RESOLVING
        UNRESOLVED
    }
    
    class TypeSource {
        <<enumeration>>
        UNDETECTED
        INFERRED
        ANNOTATED_EXPLICIT
        ANNOTATED_INFERRED
    }
    
    DataType --> Kind
    DataType --> TypeSource
```

**Diagram: GDScriptParser::DataType Structure**

### Type Resolution

The `resolve_datatype()` method at [modules/gdscript/gdscript_analyzer.cpp:652-921]() converts type annotations (represented as `TypeNode` in the AST) into concrete `DataType` structures:

**Resolution Process:**

1. **Check for cycles**: Detect self-referential types
2. **Handle void**: Empty type chain represents `void`
3. **Resolve type chain**: Process qualified type names (e.g., `Outer.Inner`)
4. **Determine kind**:
   - Built-in types: `int`, `String`, `Array`, etc.
   - Native classes: Engine classes from `ClassDB`
   - Script types: Global classes from `ScriptServer`
   - GDScript classes: Classes in current or imported scripts
   - Enums: Named integer sets
5. **Resolve container types**: For `Array[T]` and `Dictionary[K,V]`, recursively resolve element types

Sources: [modules/gdscript/gdscript_analyzer.cpp:652-921](), [modules/gdscript/gdscript_parser.h:101-259]()

### Type Checking

Type compatibility is checked by `is_type_compatible()` at [modules/gdscript/gdscript_analyzer.cpp:4188-4369]():

**Compatibility Rules:**

| Source Type | Target Type | Compatible? | Notes |
|-------------|-------------|-------------|-------|
| Any | `Variant` | Yes | Everything is compatible with Variant |
| `T` | `T` | Yes | Exact type match |
| Subclass | Superclass | Yes | Covariant inheritance |
| Built-in | Built-in | Special | Some implicit conversions allowed |
| `null` | Object type | Yes | Null is compatible with object types |
| Enum value | `int` | Yes | Enums are integer types |
| `Array[T]` | `Array[U]` | If T=U | Typed arrays require exact element type match |

The analyzer enforces strict type checking when variables have explicit type annotations (`TypeSource::ANNOTATED_EXPLICIT`), but allows more flexibility with inferred types.

Sources: [modules/gdscript/gdscript_analyzer.cpp:4188-4369]()

## Member Resolution and Lookup

```mermaid
flowchart TD
    Start["resolve_identifier()"]
    CheckLocal{"Is local variable<br/>or parameter?"}
    CheckMember{"Is class member?"}
    CheckBase{"Check base class<br/>chain"}
    CheckNative{"Check native<br/>ClassDB"}
    CheckGlobal{"Is global?"}
    Error["Push error:<br/>identifier not found"]
    Resolved["Set identifier<br/>source and type"]
    
    Start --> CheckLocal
    CheckLocal -->|Yes| Resolved
    CheckLocal -->|No| CheckMember
    CheckMember -->|Yes| Resolved
    CheckMember -->|No| CheckBase
    CheckBase -->|Found| Resolved
    CheckBase -->|Not found| CheckNative
    CheckNative -->|Found| Resolved
    CheckNative -->|Not found| CheckGlobal
    CheckGlobal -->|Yes| Resolved
    CheckGlobal -->|No| Error
```

**Diagram: Identifier Resolution Process**

The analyzer resolves identifiers through a hierarchical lookup process:

### Local Scope Resolution

For identifiers within function bodies, the analyzer first checks:

1. **Function parameters**: Defined in `FunctionNode::parameters`
2. **Local variables**: Tracked in the current `SuiteNode::locals`
3. **Loop iterators**: For variables in `for` loops
4. **Match branch bindings**: Variables bound in pattern matching

Source tracking is done via the `IdentifierNode::source` enum at [modules/gdscript/gdscript_parser.h:726-745]().

Sources: [modules/gdscript/gdscript_analyzer.cpp:3899-4055]()

### Class Member Resolution

The `resolve_class_member()` method at [modules/gdscript/gdscript_analyzer.cpp:923-1032]() handles member lookup:

1. **Direct members**: Check `ClassNode::members_indices`
2. **Base class chain**: Walk up inheritance hierarchy
3. **Native properties/methods**: Query `ClassDB` for the native base class

Each `ClassNode` maintains a `members_indices` map that stores the index and type of each member.

Sources: [modules/gdscript/gdscript_analyzer.cpp:923-1032](), [modules/gdscript/gdscript_parser.h:1144-1220]()

## Expression Analysis and Reduction

The analyzer performs constant folding and type inference through expression reduction. The `reduce_expression()` method at [modules/gdscript/gdscript_analyzer.cpp:2827-3898]() handles various expression types:

### Reducible Expressions

**Constant expressions** that can be evaluated at compile time:

- **Literals**: Already constant values
- **Constants**: References to `const` declarations
- **Unary operations**: `-x`, `not x`, `~x` on constant operands
- **Binary operations**: `x + y`, `x * y`, etc. on constant operands
- **Array/Dictionary literals**: With constant elements
- **Subscript**: Constant indexing into constant containers
- **Type tests**: `x is Type` where the type is known

When an expression is successfully reduced, its `reduced` flag is set to `true` and the `reduced_value` field contains the compile-time constant.

Sources: [modules/gdscript/gdscript_analyzer.cpp:2827-3898]()

### Type Inference

For non-constant expressions, the analyzer infers types:

**Call expressions**:
```mermaid
flowchart TD
    Call["CallNode"]
    ResolveCallee["Resolve callee expression"]
    CheckCallable{"Is Callable type?"}
    ResolveMethod["Resolve method on callee type"]
    CheckArgs["Check argument count<br/>and types"]
    InferReturn["Infer return type<br/>from MethodInfo"]
    SetType["Set CallNode.datatype"]
    
    Call --> ResolveCallee
    ResolveCallee --> CheckCallable
    CheckCallable -->|Yes| CheckArgs
    CheckCallable -->|No| ResolveMethod
    ResolveMethod --> CheckArgs
    CheckArgs --> InferReturn
    InferReturn --> SetType
```

**Diagram: Call Expression Type Inference**

**Assignment inference**:
- Variable type inferred from initializer if not explicitly typed
- Type stored with `TypeSource::ANNOTATED_INFERRED` when using `:=`

Sources: [modules/gdscript/gdscript_analyzer.cpp:2287-2460](), [modules/gdscript/gdscript_analyzer.cpp:1691-1890]()

## Warning System

The analyzer generates warnings for potentially problematic code patterns. Warnings are defined in [modules/gdscript/gdscript_warning.h:39-111]():

### Warning Categories

| Warning Code | Description | Example |
|--------------|-------------|---------|
| `UNASSIGNED_VARIABLE` | Variable used before assignment | `var x; print(x)` |
| `UNREACHABLE_CODE` | Code after return/break/continue | `return; print("never")` |
| `UNUSED_VARIABLE` | Variable declared but never used | `var unused = 5` |
| `SHADOWED_VARIABLE` | Variable shadows outer scope | Function param shadows member |
| `UNSAFE_PROPERTY_ACCESS` | Property access on Variant type | `var x = something; x.prop` |
| `UNSAFE_METHOD_ACCESS` | Method call on Variant type | `var x = something; x.method()` |
| `UNSAFE_CAST` | Cast that might fail at runtime | `x as Node` where x is Variant |
| `RETURN_VALUE_DISCARDED` | Function return value ignored | `get_value()  # return ignored` |

### Warning Generation

Warnings are generated via `push_warning()` at [modules/gdscript/gdscript_parser.cpp:246-266]() and stored as `PendingWarning` structures. They are filtered and applied in `apply_pending_warnings()` at [modules/gdscript/gdscript_parser.cpp:268-303]().

**Warning Suppression:**

Warnings can be suppressed via:
- `@warning_ignore("code")` annotation on statements or class level
- `@warning_ignore_start("code")` / `@warning_ignore_restore("code")` for regions
- Project settings: `debug/gdscript/warnings/enable` and per-warning settings
- Directory rules: `debug/gdscript/warnings/directory_rules`

Sources: [modules/gdscript/gdscript_warning.h:39-111](), [modules/gdscript/gdscript_parser.cpp:246-303](), [modules/gdscript/gdscript_parser.cpp:99-143]()

## Integration with Compiler

After analysis completes successfully, the compiler (covered in [GDScript Compiler & VM](#6.5)) uses the type-annotated AST to generate bytecode. The analyzer provides:

1. **Resolved types**: `DataType` on all expressions and variables
2. **Constant values**: Pre-computed values in `reduced_value`
3. **Member indices**: Positions of members in the class layout
4. **Function signatures**: Parameter and return types for type-safe calls

The compiler at [modules/gdscript/gdscript_compiler.cpp:89-206]() uses `_gdtype_from_datatype()` to convert `GDScriptParser::DataType` to `GDScriptDataType` for runtime use.

Sources: [modules/gdscript/gdscript_compiler.cpp:89-206](), [modules/gdscript/gdscript_analyzer.cpp:4730-4757]()

## Error Handling

The analyzer accumulates errors in the parser's `errors` list. Each error includes:

- Message text
- Line number
- Column number

**Common Error Scenarios:**

| Error Type | Trigger | Example |
|------------|---------|---------|
| Type mismatch | Incompatible assignment | `var x: int = "string"` |
| Cyclic reference | Class inherits from itself | `class A extends A` |
| Undefined identifier | Reference to unknown name | `print(undefined_var)` |
| Invalid member access | Accessing non-existent member | `node.nonexistent_prop` |
| Abstract instantiation | Creating instance of abstract class | `var x = AbstractClass.new()` |
| Generic type instantiation | Instantiating unbound generic | `var x = GenericClass.new()` |

Errors are pushed via `push_error()` at [modules/gdscript/gdscript_parser.cpp:233-243]() and cause analysis to fail, preventing compilation.

Sources: [modules/gdscript/gdscript_parser.cpp:233-243](), [modules/gdscript/gdscript_analyzer.cpp:55-83]()31:T561f,# GDScript Compiler & VM

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [modules/gdscript/gdscript.cpp](modules/gdscript/gdscript.cpp)
- [modules/gdscript/gdscript.h](modules/gdscript/gdscript.h)
- [modules/gdscript/gdscript_analyzer.cpp](modules/gdscript/gdscript_analyzer.cpp)
- [modules/gdscript/gdscript_analyzer.h](modules/gdscript/gdscript_analyzer.h)
- [modules/gdscript/gdscript_byte_codegen.cpp](modules/gdscript/gdscript_byte_codegen.cpp)
- [modules/gdscript/gdscript_byte_codegen.h](modules/gdscript/gdscript_byte_codegen.h)
- [modules/gdscript/gdscript_cache.cpp](modules/gdscript/gdscript_cache.cpp)
- [modules/gdscript/gdscript_cache.h](modules/gdscript/gdscript_cache.h)
- [modules/gdscript/gdscript_codegen.h](modules/gdscript/gdscript_codegen.h)
- [modules/gdscript/gdscript_compiler.cpp](modules/gdscript/gdscript_compiler.cpp)
- [modules/gdscript/gdscript_compiler.h](modules/gdscript/gdscript_compiler.h)
- [modules/gdscript/gdscript_disassembler.cpp](modules/gdscript/gdscript_disassembler.cpp)
- [modules/gdscript/gdscript_editor.cpp](modules/gdscript/gdscript_editor.cpp)
- [modules/gdscript/gdscript_function.cpp](modules/gdscript/gdscript_function.cpp)
- [modules/gdscript/gdscript_function.h](modules/gdscript/gdscript_function.h)
- [modules/gdscript/gdscript_parser.cpp](modules/gdscript/gdscript_parser.cpp)
- [modules/gdscript/gdscript_parser.h](modules/gdscript/gdscript_parser.h)
- [modules/gdscript/gdscript_tokenizer.cpp](modules/gdscript/gdscript_tokenizer.cpp)
- [modules/gdscript/gdscript_tokenizer.h](modules/gdscript/gdscript_tokenizer.h)
- [modules/gdscript/gdscript_vm.cpp](modules/gdscript/gdscript_vm.cpp)
- [modules/gdscript/gdscript_warning.cpp](modules/gdscript/gdscript_warning.cpp)
- [modules/gdscript/gdscript_warning.h](modules/gdscript/gdscript_warning.h)
- [modules/gdscript/tests/gdscript_test_runner.cpp](modules/gdscript/tests/gdscript_test_runner.cpp)
- [modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out](modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out)
- [modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd](modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out)

</details>



## Purpose and Scope

This page documents the GDScript compilation process from analyzed Abstract Syntax Tree (AST) to executable bytecode, and the virtual machine that executes that bytecode. The compiler transforms the type-checked AST produced by the analyzer into a compact bytecode representation stored in `GDScriptFunction` objects. The VM then interprets this bytecode at runtime using a stack-based execution model.

For information about the preceding compilation stages, see [GDScript Parser](#7.3) and [GDScript Analyzer](#7.4). For runtime resource management and instance handling, see [GDScript Runtime](#7.6).

## Compilation Pipeline Overview

The compilation process consists of three main stages after parsing and analysis:

```mermaid
flowchart TD
    AST["GDScriptParser::ClassNode<br/>(Analyzed AST)"]
    Compiler["GDScriptCompiler<br/>_compile_class()"]
    CodeGen["GDScriptByteCodeGenerator<br/>append() / append_opcode()"]
    Function["GDScriptFunction<br/>(Bytecode + Metadata)"]
    Script["GDScript<br/>(member_functions)"]
    
    AST --> Compiler
    Compiler -->|"walks AST nodes<br/>_parse_expression()<br/>_parse_block()"| CodeGen
    CodeGen -->|"emits instructions<br/>manages stack"| Function
    Function --> Script
    
    Compiler -.->|"creates CodeGen context"| CodeGenStruct["CodeGen struct<br/>parameters, locals<br/>temporaries, stack_max"]
    CodeGenStruct -.-> CodeGen
```

**Sources:** [modules/gdscript/gdscript_compiler.cpp:1-2000](), [modules/gdscript/gdscript_byte_codegen.cpp:1-100]()

The compiler operates in a single pass over the analyzed AST, generating bytecode instructions sequentially. Each function, including lambdas and the class initializer, is compiled into a separate `GDScriptFunction` object.

## GDScriptCompiler Architecture

The `GDScriptCompiler` class orchestrates the transformation from AST to bytecode. It maintains compilation state through the `CodeGen` struct and delegates bytecode emission to `GDScriptByteCodeGenerator`.

### Key Components

| Component | Purpose |
|-----------|---------|
| `GDScriptCompiler` | Main compiler class that walks AST nodes |
| `CodeGen` struct | Tracks compilation context (locals, temporaries, stack) |
| `_parse_expression()` | Compiles expression nodes to bytecode |
| `_parse_block()` | Compiles statement sequences |
| `_compile_class()` | Entry point for class compilation |

**Sources:** [modules/gdscript/gdscript_compiler.h:1-100](), [modules/gdscript/gdscript_compiler.cpp:44-88]()

### CodeGen Compilation Context

```mermaid
classDiagram
    class CodeGen {
        +GDScriptByteCodeGenerator* generator
        +GDScriptParser::ClassNode* class_node
        +GDScriptParser::FunctionNode* function_node
        +HashMap~StringName,Address~ parameters
        +HashMap~StringName,Address~ locals
        +List~Address~ stack_identifiers
        +int stack_max
    }
    
    class Address {
        +AddressMode mode
        +uint32_t address
        +GDScriptDataType type
    }
    
    class AddressMode {
        <<enumeration>>
        SELF
        CLASS
        MEMBER
        LOCAL_VARIABLE
        FUNCTION_PARAMETER
        TEMPORARY
        CONSTANT
        NIL
    }
    
    CodeGen --> Address : tracks
    Address --> AddressMode : has
```

**Sources:** [modules/gdscript/gdscript_compiler.h:40-80](), [modules/gdscript/gdscript_codegen.h:50-150]()

The `CodeGen` struct maintains all state needed during compilation of a single function:
- **parameters**: Function parameter name-to-address mapping
- **locals**: Local variable name-to-address mapping  
- **stack_max**: Maximum stack depth required
- **generator**: The bytecode generator instance

### Expression Compilation

The `_parse_expression()` method handles all expression node types, recursively compiling sub-expressions and emitting appropriate opcodes.

```mermaid
flowchart LR
    subgraph "Expression Node Types"
        ID["IDENTIFIER<br/>_parse_expression()"]
        BIN["BINARY_OPERATOR<br/>+,-,*,/,etc"]
        CALL["CALL<br/>function calls"]
        SUB["SUBSCRIPT<br/>array/dict access"]
        CONST["CONSTANT<br/>literals"]
    end
    
    subgraph "Address Resolution"
        ID --> CheckLocal["Check locals<br/>Check parameters"]
        CheckLocal --> CheckMember["Check members<br/>Check properties"]
        CheckMember --> CheckGlobal["Check globals<br/>Check constants"]
    end
    
    subgraph "Opcode Emission"
        BIN --> EmitOp["write_binary_operator()"]
        CALL --> EmitCall["write_call()<br/>write_call_self()"]
        SUB --> EmitGet["write_get()<br/>write_set()"]
        CONST --> AddConst["add_constant()"]
    end
    
    EmitOp --> Result["Return Address"]
    EmitCall --> Result
    EmitGet --> Result
    AddConst --> Result
```

**Sources:** [modules/gdscript/gdscript_compiler.cpp:254-1200]()

Key expression compilation patterns:

- **Identifiers** ([modules/gdscript/gdscript_compiler.cpp:262-420]()):
  - Check function parameters first
  - Then local variables/constants
  - Then class members and properties (with getter calls if needed)
  - Finally globals and native class constants

- **Binary Operators** ([modules/gdscript/gdscript_compiler.cpp:600-700]()):
  - Compile left operand
  - Compile right operand  
  - Emit operator instruction with type validation

- **Function Calls** ([modules/gdscript/gdscript_compiler.cpp:800-1100]()):
  - Compile callee expression
  - Compile arguments
  - Choose call variant (validated, ptrcall, regular) based on type info

### Statement Compilation

The `_parse_block()` method processes statement sequences within suites (function bodies, control flow blocks).

**Sources:** [modules/gdscript/gdscript_compiler.cpp:1800-2300]()

Statement types handled:
- **Variable declarations**: Allocate locals, compile initializers
- **Assignments**: Compile target and value, emit appropriate set instruction
- **Control flow**: `if`, `while`, `for`, `match` with jump patching
- **Return statements**: Type validation, implicit return handling
- **Await expressions**: Special handling for coroutine suspension

## GDScriptByteCodeGenerator

The `GDScriptByteCodeGenerator` class manages the actual bytecode instruction stream and stack allocation. It implements the `GDScriptCodeGenerator` interface used by the compiler.

### Bytecode Emission

```mermaid
flowchart TD
    Compiler["GDScriptCompiler<br/>_parse_expression()"]
    
    subgraph "GDScriptByteCodeGenerator"
        Append["append(instruction)<br/>append_opcode(opcode)"]
        InstrData["Instruction struct<br/>opcode + operands"]
        Patch["Patch jumps<br/>patch_jump()"]
        Optimize["Optimization<br/>remove redundant moves"]
    end
    
    subgraph "GDScriptFunction Generation"
        Bytecode["opcodes Vector"]
        Constants["constants Vector"]
        Names["global_names Vector"]
        StackInfo["stack_debug info"]
    end
    
    Compiler -->|"write_*() methods"| Append
    Append --> InstrData
    InstrData --> Patch
    Patch --> Optimize
    
    Optimize --> Bytecode
    Optimize --> Constants
    Optimize --> Names
    Optimize --> StackInfo
```

**Sources:** [modules/gdscript/gdscript_byte_codegen.cpp:1-100](), [modules/gdscript/gdscript_byte_codegen.h:1-150]()

### Address Management

The generator tracks different address modes for operands:

| Address Mode | Usage | Stack Location |
|-------------|-------|----------------|
| `SELF` | Instance reference | Fixed slot 0 |
| `CLASS` | Class reference | Fixed slot 1 |
| `MEMBER` | Instance member variable | Via member index |
| `LOCAL_VARIABLE` | Local variable | Stack offset |
| `FUNCTION_PARAMETER` | Function parameter | Stack offset |
| `TEMPORARY` | Temporary value | Allocated stack slot |
| `CONSTANT` | Constant pool entry | Constant index |
| `NIL` | Null value | N/A |

**Sources:** [modules/gdscript/gdscript_codegen.h:48-120]()

The generator maintains a stack slot allocator that tracks:
- Used stack slots and their types ([modules/gdscript/gdscript_byte_codegen.cpp:66-100]())
- Temporary allocation and deallocation ([modules/gdscript/gdscript_byte_codegen.cpp:350-450]())
- Maximum stack depth (`stack_max`)

### Instruction Structure

Each instruction is stored as a variable-length sequence of integers in the bytecode array:

```
[opcode] [arg1_addr] [arg2_addr] [arg3_addr] ...
```

The number of arguments depends on the opcode. Common patterns:
- **Binary operators**: `[OPCODE_OPERATOR] [target] [left] [right] [operator_type]`
- **Calls**: `[OPCODE_CALL] [result] [callee] [arg_count] [args...]`
- **Jumps**: `[OPCODE_JUMP] [offset]`

**Sources:** [modules/gdscript/gdscript_function.h:180-280]()

## GDScriptFunction Structure

The compiled output of a function is stored in a `GDScriptFunction` object, which contains all data needed for execution.

### Function Components

```mermaid
classDiagram
    class GDScriptFunction {
        +Vector~int~ opcodes
        +Vector~Variant~ constants
        +Vector~StringName~ global_names
        +int _stack_size
        +int _instruction_args_size
        +int _argument_count
        +int _default_arg_count
        +GDScriptDataType return_type
        +Vector~GDScriptDataType~ argument_types
        +Vector~StackDebug~ stack_debug
        +HashMap~int,int~ profile
        +call() Variant
    }
    
    class StackDebug {
        +StringName identifier
        +int pos
        +int line
        +bool added
    }
    
    class GDScriptDataType {
        +Kind kind
        +Variant::Type builtin_type
        +StringName native_type
        +Script* script_type
    }
    
    GDScriptFunction --> StackDebug : debug info
    GDScriptFunction --> GDScriptDataType : type info
```

**Sources:** [modules/gdscript/gdscript_function.h:46-280]()

Key fields:

- **opcodes**: Bytecode instruction stream
- **constants**: Constant pool (literals, preloaded resources)
- **global_names**: Names for global lookups (autoloads, singletons)
- **_stack_size**: Total stack slots needed (locals + temporaries)
- **argument_types**: Type constraints for each parameter (for validation)
- **stack_debug**: Maps source line numbers to stack state (for debugger)

### Fixed Stack Addresses

The first few stack slots have special fixed meanings:

```mermaid
graph LR
    subgraph "Stack Layout"
        S0["Slot 0<br/>ADDR_SELF<br/>instance"]
        S1["Slot 1<br/>ADDR_CLASS<br/>class"]
        S2["Slot 2<br/>ADDR_NIL<br/>null"]
        S3["Slot 3<br/>ADDR_TRUE<br/>true"]
        S4["Slot 4<br/>ADDR_FALSE<br/>false"]
        S5["Slot 5+<br/>Parameters<br/>Locals<br/>Temporaries"]
    end
```

**Sources:** [modules/gdscript/gdscript_function.h:90-100]()

These fixed addresses allow the VM to quickly access common values without explicit loads.

## GDScriptVM Execution

The VM executes bytecode using a fetch-decode-execute loop within `GDScriptFunction::call()`. It uses a stack-based architecture with typed stack slots.

### Execution Loop

```mermaid
flowchart TD
    Start["call(instance, args, arg_count)"]
    SetupStack["Allocate stack<br/>Copy arguments<br/>Initialize locals"]
    
    subgraph "Main Loop"
        Fetch["ip = opcodes[ip]<br/>Read opcode"]
        Decode["Switch on opcode"]
        Execute["Execute instruction<br/>Manipulate stack"]
        CheckExit{"Return or<br/>Await?"}
    end
    
    Return["Copy return value<br/>Free stack"]
    Suspend["Create FunctionState<br/>Save stack"]
    
    Start --> SetupStack
    SetupStack --> Fetch
    Fetch --> Decode
    Decode --> Execute
    Execute --> CheckExit
    CheckExit -->|Continue| Fetch
    CheckExit -->|Return| Return
    CheckExit -->|Await| Suspend
    Return --> End
    Suspend --> End["Return variant"]
```

**Sources:** [modules/gdscript/gdscript_vm.cpp:200-3000]()

### Stack Operations

The VM maintains a single contiguous stack array containing `Variant` objects. Key operations:

**Stack Access**:
```
Variant* stack = (Variant*)alloca(_stack_size * sizeof(Variant));
stack[address] // Direct stack access
```

**Instruction Pointer**:
- `ip`: Current instruction pointer
- Incremented after reading each operand
- Modified by jump instructions

**Sources:** [modules/gdscript/gdscript_vm.cpp:220-350]()

### Opcode Categories

The VM implements approximately 100+ opcodes organized into categories:

| Category | Opcodes | Purpose |
|----------|---------|---------|
| **Stack** | `OPCODE_OPERATOR`, `OPCODE_OPERATOR_VALIDATED` | Binary/unary operations |
| **Variables** | `OPCODE_GET_MEMBER`, `OPCODE_SET_MEMBER` | Member access |
| **Calls** | `OPCODE_CALL`, `OPCODE_CALL_PTRCALL`, `OPCODE_CALL_SELF` | Function invocation |
| **Control** | `OPCODE_JUMP`, `OPCODE_JUMP_IF`, `OPCODE_JUMP_IF_NOT` | Flow control |
| **Type** | `OPCODE_CAST_TO_BUILTIN`, `OPCODE_CAST_TO_NATIVE` | Type conversions |
| **Containers** | `OPCODE_CONSTRUCT_ARRAY`, `OPCODE_CONSTRUCT_DICTIONARY` | Collection creation |
| **Iteration** | `OPCODE_ITERATE_BEGIN`, `OPCODE_ITERATE` | For-loop support |
| **Await** | `OPCODE_AWAIT`, `OPCODE_AWAIT_RESUME` | Coroutine suspension |

**Sources:** [modules/gdscript/gdscript_function.h:115-180]()

### Validated vs Regular Operations

The VM includes optimized "validated" variants of many opcodes that skip runtime type checks when the compiler has proven type safety:

```mermaid
flowchart LR
    subgraph "Regular Operation"
        RegOp["OPCODE_OPERATOR"]
        TypeCheck["Runtime type check"]
        GetMethod["Lookup operator method"]
        CallMethod["Call method"]
        RegOp --> TypeCheck --> GetMethod --> CallMethod
    end
    
    subgraph "Validated Operation"
        ValOp["OPCODE_OPERATOR_VALIDATED"]
        DirectCall["Direct validated call"]
        ValOp --> DirectCall
    end
    
    Compiler["Compiler type analysis"] -.->|"Determines if safe"| Choice{"Type<br/>proven?"}
    Choice -->|Yes| ValOp
    Choice -->|No| RegOp
```

**Sources:** [modules/gdscript/gdscript_vm.cpp:800-1200](), [modules/gdscript/gdscript_compiler.cpp:600-800]()

Validated operations provide significant performance improvements by:
- Skipping variant type checks
- Using direct pointer calls (ptrcall)
- Avoiding method lookup overhead

### Error Handling

The VM checks for errors at multiple points:

- **Type validation**: When validated calls are made ([modules/gdscript/gdscript_vm.cpp:400-500]())
- **Null checks**: Before member access and calls ([modules/gdscript/gdscript_vm.cpp:1500-1600]())
- **Bounds checks**: For array/dictionary access ([modules/gdscript/gdscript_vm.cpp:2000-2100]())
- **Cast validation**: For type conversions ([modules/gdscript/gdscript_vm.cpp:2500-2600]())

Errors halt execution and return an error code via `r_error.error`.

### Profiling Support

When profiling is enabled, the VM tracks:
- Call counts per function
- Total time spent in each function
- Native method call statistics

**Sources:** [modules/gdscript/gdscript_vm.cpp:106-116](), [modules/gdscript/gdscript_function.h:260-280]()

## Stack Management and Addressing

The compiler and VM cooperate to manage stack allocation efficiently.

### Stack Slot Allocation

```mermaid
graph TD
    subgraph "Compilation Time"
        Analyze["Analyze expression<br/>determine result type"]
        AllocTemp["add_temporary()<br/>allocate stack slot"]
        Track["Track slot type<br/>for validation"]
        MaxStack["Update stack_max"]
    end
    
    subgraph "Runtime"
        InitStack["Allocate stack array<br/>size = stack_max"]
        UseSlot["Access stack[address]"]
        Validate["Type validation<br/>if enabled"]
    end
    
    Analyze --> AllocTemp
    AllocTemp --> Track
    Track --> MaxStack
    MaxStack -.->|"Used at runtime"| InitStack
    InitStack --> UseSlot
    UseSlot --> Validate
```

**Sources:** [modules/gdscript/gdscript_byte_codegen.cpp:350-500]()

The `GDScriptByteCodeGenerator` maintains a pool of stack slots:

- **Allocation**: `add_temporary()` finds an unused slot or extends the stack
- **Deallocation**: `pop_temporary()` marks slots as reusable
- **Type tracking**: Each slot records its `Variant::Type` for validation

### Temporary Lifetime

Temporaries are allocated for intermediate expression results and deallocated when no longer needed:

```
// Compiling: (a + b) * c
temp1 = add_temporary()  // For (a + b)
emit_load(a)
emit_load(b)
emit_add(temp1, a, b)
temp2 = add_temporary()  // For final result
emit_load(c)
emit_multiply(temp2, temp1, c)
pop_temporary()  // Free temp1
return temp2
```

**Sources:** [modules/gdscript/gdscript_compiler.cpp:254-600]()

## Compilation Example

To illustrate the full pipeline, consider compiling this simple function:

```gdscript
func add(a: int, b: int) -> int:
    return a + b
```

### Compilation Steps

1. **Parser** produces AST ([7.3](#7.3)):
   - `FunctionNode` with two `ParameterNode`s
   - `ReturnNode` with `BinaryOpNode` (addition)

2. **Analyzer** resolves types ([7.4](#7.4)):
   - Parameters typed as `int`
   - Return type `int`
   - Binary operation validated for `int + int`

3. **Compiler** generates bytecode:

```mermaid
sequenceDiagram
    participant C as GDScriptCompiler
    participant G as GDScriptByteCodeGenerator
    participant F as GDScriptFunction
    
    C->>G: add_parameter("a", int)
    C->>G: add_parameter("b", int)
    C->>G: write_operator_validated(ADD, a, b)
    C->>G: write_return(result)
    C->>F: Create function object
    G->>F: Write bytecode array
    G->>F: Set stack_size = 2
```

4. **Generated bytecode** (simplified):
```
opcodes[0] = OPCODE_OPERATOR_VALIDATED
opcodes[1] = 5  // Result slot
opcodes[2] = 5  // Parameter 'a' slot  
opcodes[3] = 6  // Parameter 'b' slot
opcodes[4] = Variant::OP_ADD
opcodes[5] = OPCODE_RETURN
opcodes[6] = 5  // Return value slot
```

**Sources:** [modules/gdscript/gdscript_compiler.cpp:1400-1800](), [modules/gdscript/gdscript_byte_codegen.cpp:800-1200]()

### Runtime Execution

When `add(5, 10)` is called:

1. Stack initialized with instance (slot 0), class (slot 1), fixed values (slots 2-4)
2. Arguments copied to slots 5-6: `stack[5] = 5`, `stack[6] = 10`
3. `OPCODE_OPERATOR_VALIDATED` executed: validates int types, performs addition
4. Result stored in slot 5: `stack[5] = 15`
5. `OPCODE_RETURN` copies `stack[5]` to return value
6. Stack freed, return value returned

**Sources:** [modules/gdscript/gdscript_vm.cpp:220-400]()

## Integration with GDScript Runtime

The compiler and VM integrate with the broader GDScript system:

- **GDScript class** stores compiled functions in `member_functions` HashMap ([modules/gdscript/gdscript.h:99-110]())
- **GDScriptInstance** calls functions via `GDScriptFunction::call()` ([modules/gdscript/gdscript.cpp:151-205]())
- **GDScriptCache** manages compilation and recompilation ([modules/gdscript/gdscript_cache.cpp:1-300]())

For more on instance management and script resources, see [GDScript Runtime](#7.6).

---

**Primary Sources:**
- [modules/gdscript/gdscript_compiler.cpp:1-2500]()
- [modules/gdscript/gdscript_compiler.h:1-130]()
- [modules/gdscript/gdscript_byte_codegen.cpp:1-2000]()
- [modules/gdscript/gdscript_byte_codegen.h:1-400]()
- [modules/gdscript/gdscript_vm.cpp:1-3500]()
- [modules/gdscript/gdscript_function.h:1-320]()
- [modules/gdscript/gdscript_function.cpp:1-280]()
- [modules/gdscript/gdscript_codegen.h:1-350]()32:T53ee,# GDScript Runtime & Cache

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [modules/gdscript/gdscript.cpp](modules/gdscript/gdscript.cpp)
- [modules/gdscript/gdscript.h](modules/gdscript/gdscript.h)
- [modules/gdscript/gdscript_analyzer.cpp](modules/gdscript/gdscript_analyzer.cpp)
- [modules/gdscript/gdscript_analyzer.h](modules/gdscript/gdscript_analyzer.h)
- [modules/gdscript/gdscript_byte_codegen.cpp](modules/gdscript/gdscript_byte_codegen.cpp)
- [modules/gdscript/gdscript_byte_codegen.h](modules/gdscript/gdscript_byte_codegen.h)
- [modules/gdscript/gdscript_cache.cpp](modules/gdscript/gdscript_cache.cpp)
- [modules/gdscript/gdscript_cache.h](modules/gdscript/gdscript_cache.h)
- [modules/gdscript/gdscript_codegen.h](modules/gdscript/gdscript_codegen.h)
- [modules/gdscript/gdscript_compiler.cpp](modules/gdscript/gdscript_compiler.cpp)
- [modules/gdscript/gdscript_compiler.h](modules/gdscript/gdscript_compiler.h)
- [modules/gdscript/gdscript_disassembler.cpp](modules/gdscript/gdscript_disassembler.cpp)
- [modules/gdscript/gdscript_editor.cpp](modules/gdscript/gdscript_editor.cpp)
- [modules/gdscript/gdscript_function.cpp](modules/gdscript/gdscript_function.cpp)
- [modules/gdscript/gdscript_function.h](modules/gdscript/gdscript_function.h)
- [modules/gdscript/gdscript_parser.cpp](modules/gdscript/gdscript_parser.cpp)
- [modules/gdscript/gdscript_parser.h](modules/gdscript/gdscript_parser.h)
- [modules/gdscript/gdscript_tokenizer.cpp](modules/gdscript/gdscript_tokenizer.cpp)
- [modules/gdscript/gdscript_tokenizer.h](modules/gdscript/gdscript_tokenizer.h)
- [modules/gdscript/gdscript_vm.cpp](modules/gdscript/gdscript_vm.cpp)
- [modules/gdscript/gdscript_warning.cpp](modules/gdscript/gdscript_warning.cpp)
- [modules/gdscript/gdscript_warning.h](modules/gdscript/gdscript_warning.h)
- [modules/gdscript/tests/gdscript_test_runner.cpp](modules/gdscript/tests/gdscript_test_runner.cpp)
- [modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out](modules/gdscript/tests/scripts/analyzer/errors/function_dont_match_parent_signature_parameter_default_values.out)
- [modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd](modules/gdscript/tests/scripts/analyzer/features/hard_variants.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.gd)
- [modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out](modules/gdscript/tests/scripts/analyzer/warnings/get_node_without_onready.out)

</details>



This document describes the runtime representation of GDScript classes, script instance creation and management, the caching system for parsed scripts, and dependency tracking. This covers how compiled GDScript classes are stored, instantiated, and managed throughout their lifecycle.

For information about parsing and AST construction, see [GDScript Parser](#6.1). For semantic analysis and type checking, see [GDScript Analyzer](#6.2). For bytecode compilation and execution, see [GDScript Compiler & VM](#6.3).

## GDScript Class Structure

The `GDScript` class represents the compiled runtime form of a GDScript file. It contains all the data needed to instantiate objects from the script, including members, functions, constants, and metadata about inheritance.

```mermaid
graph TB
    subgraph "GDScript Runtime Representation"
        GDScript["GDScript"]
        GDScriptInstance["GDScriptInstance"]
        GDScriptFunction["GDScriptFunction"]
        MemberInfo["MemberInfo"]
        
        GDScript -->|"owns"| GDScriptFunction
        GDScript -->|"tracks"| GDScriptInstance
        GDScript -->|"contains"| MemberInfo
        GDScriptInstance -->|"references"| GDScript
        GDScriptInstance -->|"attached to"| Object
    end
    
    subgraph "Inheritance Chain"
        GDScript -->|"base"| BaseGDScript["Base GDScript"]
        GDScript -->|"native"| GDScriptNativeClass["GDScriptNativeClass"]
        BaseGDScript -->|"native"| GDScriptNativeClass
    end
    
    subgraph "Class Contents"
        GDScript -->|"member_indices"| MemberIndices["HashMap<StringName, MemberInfo>"]
        GDScript -->|"member_functions"| MemberFunctions["HashMap<StringName, GDScriptFunction*>"]
        GDScript -->|"constants"| Constants["HashMap<StringName, Variant>"]
        GDScript -->|"subclasses"| Subclasses["HashMap<StringName, Ref<GDScript>>"]
        GDScript -->|"static_variables_indices"| StaticVarIndices["HashMap<StringName, MemberInfo>"]
        GDScript -->|"static_variables"| StaticVars["Vector<Variant>"]
    end
```

**GDScript Core Data Structures**

Sources: [modules/gdscript/gdscript.h:60-287]()

| Component | Type | Purpose |
|-----------|------|---------|
| `member_indices` | `HashMap<StringName, MemberInfo>` | Maps member names to their index and metadata, includes inherited members |
| `members` | `HashSet<StringName>` | Contains only members declared in this class |
| `member_functions` | `HashMap<StringName, GDScriptFunction*>` | All member functions including inherited ones |
| `constants` | `HashMap<StringName, Variant>` | Script-level constants |
| `subclasses` | `HashMap<StringName, Ref<GDScript>>` | Inner classes |
| `static_variables_indices` | `HashMap<StringName, MemberInfo>` | Static variable metadata |
| `static_variables` | `Vector<Variant>` | Static variable values (shared across instances) |
| `base` | `Ref<GDScript>` | Parent GDScript class |
| `native` | `Ref<GDScriptNativeClass>` | Native base class reference |
| `_owner` | `GDScript*` | Owner script for inner classes |

The `MemberInfo` struct stores metadata about each member:

Sources: [modules/gdscript/gdscript.h:67-73]()

```
struct MemberInfo {
    int index;                  // Position in instance members array
    StringName setter;          // Setter function name (if any)
    StringName getter;          // Getter function name (if any)
    GDScriptDataType data_type; // Type information
    PropertyInfo property_info; // Property metadata
}
```

## Script Instance Creation

GDScript instances are created through a multi-stage initialization process that handles inheritance, implicit initialization, and explicit constructors.

```mermaid
graph TB
    Start["Object Creation Request"]
    
    Start --> CheckValid{"valid == true?"}
    CheckValid -->|"No"| Error["Return CALL_ERROR_INVALID_METHOD"]
    CheckValid -->|"Yes"| CreateObject["Create base Object<br/>(from native.instantiate())"]
    
    CreateObject --> CreateInstance["Create GDScriptInstance<br/>instance->members.resize(member_indices.size())"]
    CreateInstance --> AttachInstance["instance->owner->set_script_instance(instance)"]
    AttachInstance --> RegisterInstance["Add to instances set (mutex locked)"]
    
    RegisterInstance --> ImplicitInit["Call _super_implicit_constructor()<br/>Recursively initialize base classes"]
    ImplicitInit --> CheckImplicitError{"Implicit init OK?"}
    CheckImplicitError -->|"No"| CleanupError["Clean up instance<br/>Return error"]
    CheckImplicitError -->|"Yes"| FindConstructor["Find _super_constructor()<br/>Locate explicit _init() function"]
    
    FindConstructor --> HasConstructor{"Constructor found?"}
    HasConstructor -->|"Yes"| CallConstructor["Call initializer<br/>with provided arguments"]
    HasConstructor -->|"No"| Done["Return instance"]
    
    CallConstructor --> CheckConstructorError{"Constructor OK?"}
    CheckConstructorError -->|"No"| CleanupError
    CheckConstructorError -->|"Yes"| Done
```

**Instance Creation Flow**

Sources: [modules/gdscript/gdscript.cpp:151-205](), [modules/gdscript/gdscript.cpp:122-149]()

### Implicit Initialization

The `_super_implicit_constructor` function recursively initializes the inheritance chain. Each class's `implicit_initializer` (the `@implicit_new()` special function) is called to set up default member values:

Sources: [modules/gdscript/gdscript.cpp:135-149]()

```
_super_implicit_constructor(GDScript *p_script, GDScriptInstance *p_instance, CallError &r_error):
    1. If base exists: recursively call _super_implicit_constructor(base)
    2. Call p_script->implicit_initializer with instance
    3. If error: return with error
```

### Explicit Constructor

The `_super_constructor` function finds the first explicit `_init()` function in the inheritance chain:

Sources: [modules/gdscript/gdscript.cpp:122-133]()

```
_super_constructor(GDScript *p_script):
    1. If p_script->valid && p_script->initializer exists: return initializer
    2. Otherwise: recursively check base_src->base
    3. Return nullptr if no constructor found
```

### Member Array Organization

Each instance maintains a `members` array indexed by `MemberInfo::index`. The indices include all inherited members, allowing O(1) access:

Sources: [modules/gdscript/gdscript.cpp:155-163]()

## GDScript Cache System

The `GDScriptCache` singleton manages parsed scripts and their parsers, preventing redundant parsing and enabling dependency tracking.

```mermaid
graph TB
    subgraph "GDScriptCache Singleton"
        Cache["GDScriptCache"]
        ParserMap["parser_map<br/>HashMap<String, GDScriptParserRef*>"]
        ShallowCache["shallow_gdscript_cache<br/>HashMap<String, Ref<GDScript>>"]
        FullCache["full_gdscript_cache<br/>HashMap<String, Ref<GDScript>>"]
        
        Cache --> ParserMap
        Cache --> ShallowCache
        Cache --> FullCache
    end
    
    subgraph "GDScriptParserRef"
        ParserRef["GDScriptParserRef"]
        Parser["GDScriptParser*"]
        Analyzer["GDScriptAnalyzer*"]
        Status["Status:<br/>EMPTY â†’ PARSED â†’<br/>INHERITANCE_SOLVED â†’<br/>INTERFACE_SOLVED â†’<br/>FULLY_SOLVED"]
        
        ParserRef --> Parser
        ParserRef --> Analyzer
        ParserRef --> Status
    end
    
    subgraph "Loading Methods"
        GetParser["get_parser()"]
        GetShallow["get_shallow_script()"]
        GetFull["get_full_script()"]
        
        GetParser --> ParserRef
        GetShallow --> ShallowCache
        GetFull --> FullCache
    end
    
    ParserMap -.->|"stores"| ParserRef
    ShallowCache -.->|"caches"| GDScript["Compiled GDScript<br/>(interface only)"]
    FullCache -.->|"caches"| GDScript2["Compiled GDScript<br/>(fully analyzed)"]
```

**GDScript Cache Architecture**

Sources: [modules/gdscript/gdscript_cache.h:46-104](), [modules/gdscript/gdscript_cache.cpp:145-480]()

### GDScriptParserRef Status Progression

The `GDScriptParserRef` tracks the analysis status of a script and raises it progressively through analysis stages:

Sources: [modules/gdscript/gdscript_cache.h:16-47]()

| Status | Description | Operations |
|--------|-------------|------------|
| `EMPTY` | Parser not yet created | Initial state |
| `PARSED` | Source tokenized and AST built | `parser->parse()` or `parser->parse_binary()` |
| `INHERITANCE_SOLVED` | Base classes resolved | `analyzer->resolve_inheritance()` |
| `INTERFACE_SOLVED` | Members and signatures resolved | `analyzer->resolve_interface()` |
| `FULLY_SOLVED` | Bodies analyzed, types checked | `analyzer->resolve_body()` |

The `raise_status()` method progressively advances through these stages:

Sources: [modules/gdscript/gdscript_cache.cpp:67-108]()

```
raise_status(Status p_new_status):
    while (result == OK && p_new_status > status):
        switch (status):
            EMPTY â†’ PARSED: Parse source code
            PARSED â†’ INHERITANCE_SOLVED: Resolve inheritance
            INHERITANCE_SOLVED â†’ INTERFACE_SOLVED: Resolve interface
            INTERFACE_SOLVED â†’ FULLY_SOLVED: Resolve body
```

### Shallow vs. Full Script Loading

Sources: [modules/gdscript/gdscript_cache.cpp:245-376]()

**Shallow Loading** (`get_shallow_script`):
- Raises parser status to `INHERITANCE_SOLVED`
- Compiles class structure and inheritance only
- Used for type checking and dependency resolution
- Cached in `shallow_gdscript_cache`

**Full Loading** (`get_full_script`):
- Raises parser status to `FULLY_SOLVED`
- Fully analyzes and compiles the script including function bodies
- Required for script execution
- Cached in `full_gdscript_cache`

### Cache Invalidation

Sources: [modules/gdscript/gdscript_cache.cpp:179-243]()

Scripts are removed from cache when:
1. File is deleted (`remove_script`)
2. File is moved (`move_script`)
3. Script is manually cleared
4. During engine shutdown

When a script is removed, its `GDScriptParserRef` is moved to `abandoned_parser_map` to allow safe cleanup even if other code holds references.

## Dependency Management

GDScript manages dependencies through parser references stored during compilation and analysis.

```mermaid
graph TB
    MainScript["Main Script (A.gd)"]
    
    MainScript -->|"extends"| BaseScript["Base Script (B.gd)"]
    MainScript -->|"preload"| ResourceScript["Resource Script (C.gd)"]
    MainScript -->|"type reference"| TypeScript["Type Script (D.gd)"]
    
    subgraph "Parser Dependency Tracking"
        MainParser["GDScriptParser (A)"]
        MainParser -->|"depended_parsers<br/>HashMap<String, GDScriptParserRef>"| DepParsers["References to B, C, D parsers"]
    end
    
    subgraph "Compiled Dependency Tracking"
        CompiledScript["GDScript (A)"]
        CompiledScript -->|"base"| BaseCompiled["Ref<GDScript> (B)"]
        CompiledScript -->|"script_type_ref"| ScriptRefs["Script references in datatypes"]
    end
    
    MainScript -.->|"parsed as"| MainParser
    MainParser -.->|"compiled to"| CompiledScript
```

**Dependency Tracking Flow**

Sources: [modules/gdscript/gdscript_parser.cpp:859-876](), [modules/gdscript/gdscript_parser.h:1189-1194]()

### Parser-Level Dependencies

The `GDScriptParser` maintains a `depended_parsers` map of all scripts it depends on:

```
get_depended_parser_for(const String &p_path):
    1. Check if already in depended_parsers map
    2. If not: Call GDScriptCache::get_parser()
    3. Store in depended_parsers
    4. Return GDScriptParserRef
```

This enables:
- Incremental compilation (only reparse what changed)
- Circular dependency detection
- Proper loading order enforcement

### Runtime Dependencies

At runtime, the compiled `GDScript` class maintains dependencies through:

Sources: [modules/gdscript/gdscript.h:94-108]()

1. **Base class reference**: `Ref<GDScript> base` - Strong reference to parent script
2. **Script type references**: In `GDScriptDataType` for typed members and parameters
3. **Subclass references**: `HashMap<StringName, Ref<GDScript>> subclasses`

## Static Variable Management

Static variables are shared across all instances of a class and initialized once when the script is first loaded.

```mermaid
graph TB
    subgraph "Static Variable Storage"
        GDScript["GDScript Class"]
        StaticIndices["static_variables_indices<br/>HashMap<StringName, MemberInfo>"]
        StaticValues["static_variables<br/>Vector<Variant>"]
        
        GDScript --> StaticIndices
        GDScript --> StaticValues
    end
    
    subgraph "Initialization Flow"
        LoadScript["Script Loaded"]
        DefaultInit["_static_default_init()<br/>Initialize builtin types to defaults"]
        StaticInit["_static_init()<br/>Call @static_initializer() function"]
        InitSubclasses["Recursively initialize subclasses"]
        
        LoadScript --> DefaultInit
        DefaultInit --> StaticInit
        StaticInit --> InitSubclasses
    end
    
    subgraph "Instance Access"
        Instance1["Instance 1"]
        Instance2["Instance 2"]
        Instance3["Instance 3"]
        
        Instance1 -.->|"reads from"| StaticValues
        Instance2 -.->|"reads from"| StaticValues
        Instance3 -.->|"reads from"| StaticValues
    end
    
    StaticInit -.->|"populates"| StaticValues
```

**Static Variable Architecture**

Sources: [modules/gdscript/gdscript.cpp:669-720]()

### Static Initialization Process

Sources: [modules/gdscript/gdscript.cpp:669-685](), [modules/gdscript/gdscript.cpp:687-720]()

Static initialization occurs in two phases:

**Phase 1: Default Initialization** (`_static_default_init`)
```
For each static variable:
    If builtin type:
        Create default value (e.g., empty Array, zero int)
        Handle typed containers (Array[T], Dictionary[K,V])
    Store in static_variables[index]
```

**Phase 2: Script Initialization** (`_static_init`)
```
If static_initializer exists:
    Call static_initializer function
    Handle call errors
    
For each subclass:
    Recursively call subclass->_static_init()
```

### Static Variable Access

When accessing a static variable at runtime:

Sources: [modules/gdscript/gdscript_compiler.cpp:390-412]()

1. Lookup in `static_variables_indices` to get index and getter info
2. If getter exists and we're not inside it: call getter function
3. Otherwise: direct access to `static_variables[index]`
4. Getters are tracked by name to prevent recursion

## Hot Reloading

GDScript supports hot reloading, allowing scripts to be modified and reloaded while the engine is running.

```mermaid
graph TB
    Start["File Modified"]
    
    Start --> InvalidateCache["Invalidate parser cache<br/>Clear GDScriptParserRef"]
    InvalidateCache --> SaveOldState["Save old static variables<br/>_save_old_static_data()"]
    SaveOldState --> Reparse["Parse new source"]
    
    Reparse --> Reanalyze["Analyze new AST"]
    Reanalyze --> Recompile["Compile to new GDScript"]
    
    Recompile --> UpdateInstances["Update all existing instances"]
    UpdateInstances --> RestoreStatic["Restore compatible static vars<br/>_restore_old_static_data()"]
    
    RestoreStatic --> UpdatePtrs["Update function pointers<br/>_recurse_replace_function_ptrs()"]
    UpdatePtrs --> NotifyInheritance["Notify inheriting scripts<br/>_update_exports_down()"]
    
    subgraph "Instance Updates"
        UpdateInstances --> SaveInstanceState["For each instance:<br/>Save property values"]
        SaveInstanceState --> ResizeMembers["Resize members array"]
        ResizeMembers --> RestoreInstanceState["Restore compatible properties"]
    end
```

**Hot Reload Process**

Sources: [modules/gdscript/gdscript.cpp:722-881]()

### Static Data Preservation

During hot reload, static variable values are preserved when possible:

Sources: [modules/gdscript/gdscript.cpp:722-748](), [modules/gdscript/gdscript.cpp:750-787]()

```
_save_old_static_data():
    old_static_variables_indices = static_variables_indices
    old_static_variables = static_variables

_restore_old_static_data():
    For each old static variable:
        If still exists with same type:
            Copy old value to new static_variables
        If incompatible type:
            Reinitialize with default
```

### Function Pointer Updates

Hot reload must update all cached function pointers to point to the newly compiled functions:

Sources: [modules/gdscript/gdscript.h:122-140](), [modules/gdscript/gdscript.cpp:1019-1049]()

The `UpdatableFuncPtr` class provides automatic updates:
```
1. When created, registers with script->func_ptrs_to_update
2. On reload: script calls _recurse_replace_function_ptrs()
3. Updates all registered pointers with new function addresses
4. Handles nested scripts recursively
```

### Export Variable Updates

For editor scripts, exported variables are refreshed to reflect new definitions:

Sources: [modules/gdscript/gdscript.cpp:499-630]()

```
_update_exports():
    1. Check if source changed (source_changed_cache)
    2. Re-parse and analyze to get new exports
    3. Update members_cache and member_default_values_cache
    4. Notify all PlaceHolderScriptInstance to update properties
    5. Recursively update inheriting scripts
```

## Script Validity and Error Handling

The `GDScript` class tracks its validity state to prevent execution of invalid scripts.

Sources: [modules/gdscript/gdscript.h:60-66](), [modules/gdscript/gdscript.cpp:252-258]()

| State Flag | Purpose |
|------------|---------|
| `valid` | Script successfully compiled and ready for use |
| `tool` | Script runs in editor (tool script) |
| `reloading` | Currently undergoing hot reload |
| `_is_abstract` | Cannot be instantiated (abstract class) |

**Validity Checks**:
- `can_instantiate()`: Returns `true` only if `valid` and conditions allow instantiation
- Instance creation fails with `CALL_ERROR_INVALID_METHOD` if script is invalid
- Function calls check validity before execution

Sources: [modules/gdscript/gdscript.cpp:402-421]()

## Memory Management

GDScript uses reference counting and careful lifetime management:

Sources: [modules/gdscript/gdscript.h:177-178](), [modules/gdscript/gdscript.cpp:883-1017]()

1. **Instance Tracking**: All instances registered in `instances` set with mutex protection
2. **Cleanup on Destruction**: `clear()` method releases all functions, subclasses, and cached data
3. **Cyclic Reference Prevention**: Local classes use weak references to avoid cycles
4. **Function Cleanup**: Each `GDScriptFunction` unregisters itself from `member_functions` on destruction

The destructor order is critical:
```
~GDScript():
    1. Clear lambda_info (releases lambda functions)
    2. Clear member_functions (releases all functions)  
    3. Clear subclasses (releases inner classes)
    4. Clear script_list registration
```

Sources: [modules/gdscript/gdscript.cpp:883-921]()33:T43bb,# Editor Core

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

The Editor Core is the central orchestration layer of the Godot editor, responsible for coordinating all editor subsystems, managing the plugin architecture, and handling editor lifecycle. It provides the foundational infrastructure that ties together UI components, tools, settings, and the scene editing system.

This document covers the high-level architecture and coordination mechanisms. For specific subsystems, see:
- [EditorNode](#7.1) for the singleton orchestrator implementation
- [EditorData](#7.2) for state management details
- [EditorInterface](#7.3) for the plugin API facade
- [EditorPlugin System](#7.4) for plugin architecture
- [Scene Management](#7.5) for scene handling specifics

## Architecture Overview

The editor core is structured around `EditorNode` as a singleton orchestrator that coordinates several key subsystems:

```mermaid
graph TB
    subgraph "Core Orchestration"
        EditorNode["EditorNode<br/>(Singleton)"]
        EditorData["EditorData<br/>(State Management)"]
        EditorInterface["EditorInterface<br/>(Plugin API)"]
    end
    
    subgraph "Configuration"
        EditorSettings["EditorSettings<br/>(Editor Config)"]
        ProjectSettings["ProjectSettings<br/>(Project Config)"]
    end
    
    subgraph "UI Layer"
        MainScreen["EditorMainScreen"]
        BottomPanel["EditorBottomPanel"]
        DockManager["EditorDockManager"]
        SceneTabs["EditorSceneTabs"]
    end
    
    subgraph "Plugin System"
        PluginList["EditorPluginList"]
        BuiltinPlugins["Built-in Plugins"]
        CustomPlugins["Custom Plugins"]
    end
    
    subgraph "Engine Integration"
        Main["Main::setup/setup2"]
        SceneTree["SceneTree"]
        scene_root["scene_root (SubViewport)"]
    end
    
    Main --> EditorNode
    EditorNode --> EditorData
    EditorNode --> EditorSettings
    EditorNode --> ProjectSettings
    EditorNode --> MainScreen
    EditorNode --> BottomPanel
    EditorNode --> DockManager
    EditorNode --> SceneTabs
    EditorNode --> PluginList
    
    PluginList --> BuiltinPlugins
    PluginList --> CustomPlugins
    
    EditorInterface --> EditorNode
    BuiltinPlugins --> EditorInterface
    CustomPlugins --> EditorInterface
    
    EditorNode --> scene_root
    scene_root --> SceneTree
```

**Sources:** [editor/editor_node.h:118-519](), [editor/editor_data.h:42-101](), [editor/editor_interface.h:62-87]()

## Core Components

### EditorNode

`EditorNode` is the central singleton class that orchestrates all editor functionality. It inherits from `Node` and is instantiated during engine startup.

**Key responsibilities:**
- Managing the editor window and UI hierarchy
- Coordinating editor plugins via `EditorPluginList`
- Handling scene tabs and multi-scene editing
- Processing menu actions and shortcuts
- Managing undo/redo through `EditorUndoRedoManager`
- Coordinating theme and translation updates

**Key members:**
| Member | Type | Purpose |
|--------|------|---------|
| `singleton` | `EditorNode*` | Static singleton instance |
| `editor_data` | `EditorData` | Manages edited scenes and history |
| `editor_plugins` | `Vector<EditorPlugin*>` | Active plugin instances |
| `scene_root` | `SubViewport*` | Root viewport for edited scene |
| `gui_base` | `Control*` | Root control of editor UI |
| `editor_selection` | `EditorSelection*` | Current selection state |

**Sources:** [editor/editor_node.h:118-260](), [editor/editor_node.cpp:205-206]()

### EditorData

`EditorData` manages the state of edited scenes and editor history. It tracks open scenes, selection history, custom types, and plugin states.

**Key structures:**
```cpp
struct EditedScene {
    Node *root;
    String path;
    uint64_t file_modified_time;
    Dictionary editor_states;
    List<Node*> selection;
    Vector<HistoryElement> history_stored;
    int history_current;
    Dictionary custom_state;
};
```

**Key functions:**
- `add_edited_scene()` / `remove_edited_scene()` - Scene lifecycle management
- `get_editor_plugin_states()` / `set_editor_plugin_states()` - Plugin state persistence
- `get_undo_redo_manager()` - Access to undo/redo system
- `save_editor_external_data()` - Persist editor state

**Sources:** [editor/editor_data.h:105-178](), [editor/editor_data.cpp:254-286]()

### EditorInterface

`EditorInterface` provides a facade API for plugins to interact with the editor. It wraps `EditorNode` functionality in a cleaner, more stable interface.

**API categories:**
- **Scene access:** `get_edited_scene_root()`, `edit_node()`, `edit_resource()`
- **Editor tools:** `get_resource_filesystem()`, `get_resource_previewer()`, `get_selection()`
- **UI access:** `get_base_control()`, `get_editor_main_screen()`, `get_file_system_dock()`
- **Viewports:** `get_editor_viewport_2d()`, `get_editor_viewport_3d()`

**Sources:** [editor/editor_interface.h:62-100](), [editor/editor_interface.cpp:65-106]()

## Initialization Lifecycle

The editor initialization follows a multi-phase process coordinated between `Main` and `EditorNode`:

```mermaid
sequenceDiagram
    participant Main
    participant OS
    participant Servers
    participant EditorNode
    participant Plugins
    participant SceneTree
    
    Main->>OS: Main::setup()
    Main->>Servers: Initialize servers<br/>(RenderingServer, etc)
    Main->>EditorNode: _editor_init_callback()
    EditorNode->>EditorNode: Initialize UI hierarchy
    EditorNode->>EditorNode: Load EditorSettings
    EditorNode->>EditorNode: Create docks/panels
    EditorNode->>Plugins: _init_callbacks[]
    Plugins->>EditorNode: Register plugins
    Main->>Main: Main::start()
    Main->>SceneTree: initialize()
    EditorNode->>EditorNode: _load_docks()
    EditorNode->>Plugins: enable_plugin()
    Plugins->>EditorNode: Plugin initialization
    EditorNode->>EditorNode: Ready for editing
```

**Key initialization phases:**

1. **Main::setup()** - Core engine initialization [main/main.cpp:1800-2100]()
2. **EditorNode construction** - UI hierarchy setup [editor/editor_node.cpp:7200-7500]()
3. **Plugin registration** - Call to `EditorPluginInitializeCallback` [editor/editor_node.cpp:495-499]()
4. **Main::start()** - Enter main loop [main/main.cpp:3600-3700]()
5. **Plugin enablement** - Activate registered plugins [editor/editor_node.cpp:7800-7900]()

**Sources:** [main/main.cpp:1800-2100](), [editor/editor_node.cpp:7200-7900]()

## Plugin Architecture

The editor's plugin system allows extending functionality through `EditorPlugin` subclasses. Plugins are managed through several layers:

```mermaid
graph TB
    subgraph "Plugin Registration"
        InitCallbacks["plugin_init_callbacks[]<br/>(Static array)"]
        AddPluginInit["ADD_PLUGIN_INIT_CALLBACK"]
    end
    
    subgraph "Plugin Management"
        EditorNode_plugins["EditorNode::editor_plugins<br/>(Vector)"]
        EditorData_plugins["EditorData::editor_plugins<br/>(Vector)"]
        PluginLists["EditorPluginList instances"]
    end
    
    subgraph "Plugin Types"
        BuiltIn["Built-in Plugins<br/>(CanvasItemEditor, Node3DEditor)"]
        Addons["Addon Plugins<br/>(User scripts)"]
        Extension["Extension Plugins<br/>(GDExtension)"]
    end
    
    subgraph "Plugin API"
        EditorInterface_api["EditorInterface"]
        EditorPlugin_methods["EditorPlugin virtual methods"]
    end
    
    AddPluginInit --> InitCallbacks
    InitCallbacks --> EditorNode_plugins
    EditorNode_plugins --> EditorData_plugins
    EditorNode_plugins --> PluginLists
    
    BuiltIn --> EditorNode_plugins
    Addons --> EditorNode_plugins
    Extension --> EditorNode_plugins
    
    EditorNode_plugins --> EditorInterface_api
    EditorPlugin_methods --> EditorInterface_api
```

**Plugin lifecycle hooks:**
- `_enter_tree()` - Called when plugin is added
- `_enable_plugin()` - Called when plugin is enabled
- `_edit()` - Called when object is selected for editing
- `_handles()` - Query if plugin handles an object type
- `_make_visible()` - Show/hide plugin UI
- `_apply_changes()` - Save pending changes
- `_build()` - Pre-run build step
- `_disable_plugin()` - Called when plugin is disabled
- `_exit_tree()` - Called when plugin is removed

**Plugin registration:**
```cpp
// Built-in registration (at compile time)
ADD_PLUGIN_INIT_CALLBACK(initialize_canvas_item_editor_plugin)

// Runtime addon loading
EditorNode::add_plugin(EditorPlugin *p_plugin)
```

**Sources:** [editor/editor_node.h:495-499](), [editor/editor_data.cpp:256-286](), [doc/classes/EditorPlugin.xml:1-100]()

## State Management

Editor state is managed across multiple layers with different scopes and persistence:

```mermaid
graph LR
    subgraph "Session State"
        EditorSelection["EditorSelection<br/>(Current selection)"]
        History["EditorSelectionHistory<br/>(Navigation history)"]
        EditorData_edited["EditorData::edited_scene[]<br/>(Open scenes)"]
    end
    
    subgraph "Persistent State"
        EditorSettings_file["editor_settings-4.tres<br/>(Editor config)"]
        project_godot["project.godot<br/>(Project config)"]
        editor_layout["editor_layout.cfg<br/>(Window layout)"]
    end
    
    subgraph "Per-Scene State"
        EditedScene_states["EditedScene::editor_states<br/>(Plugin states)"]
        EditedScene_selection["EditedScene::selection<br/>(Scene selection)"]
        EditedScene_history["EditedScene::history_stored<br/>(Scene history)"]
    end
    
    EditorNode --> EditorSelection
    EditorNode --> History
    EditorNode --> EditorData_edited
    
    EditorNode --> EditorSettings_file
    EditorNode --> project_godot
    EditorNode --> editor_layout
    
    EditorData_edited --> EditedScene_states
    EditorData_edited --> EditedScene_selection
    EditorData_edited --> EditedScene_history
```

**State persistence flow:**

1. **During editing:** State changes tracked in memory
2. **On scene save:** `_save_editor_states()` writes plugin states to scene metadata [editor/editor_node.cpp:3400-3450]()
3. **On editor close:** `_save_editor_layout()` writes dock positions and window state [editor/editor_node.cpp:7600-7650]()
4. **On settings change:** `EditorSettings::save()` writes to disk immediately [editor/settings/editor_settings.cpp]()

**EditorSelectionHistory tracking:**
```cpp
struct HistoryElement {
    Vector<_Object> path;  // Object path (object -> subresource -> ...)
    int level;             // Current depth in path
};
```

The history system allows navigating back/forward through edited objects, including drilling into subresources.

**Sources:** [editor/editor_data.h:113-125](), [editor/editor_data.h:42-101](), [editor/editor_node.cpp:3400-3450]()

## Configuration Systems

The editor uses two parallel configuration systems with different scopes:

### EditorSettings

**Purpose:** Editor-wide preferences that apply across all projects

**Storage location:** `<user_data>/godot/editor_settings-4.tres`

**Key settings categories:**
- `interface/editor/*` - UI appearance, scale, theme
- `text_editor/*` - Code editor preferences
- `debugger/*` - Debugger configuration
- `docks/*` - Dock behavior and appearance
- `filesystem/*` - File browser settings

**Access pattern:**
```cpp
// Get singleton
EditorSettings *settings = EditorInterface::get_editor_settings();

// Read setting
bool value = EDITOR_GET("interface/editor/vsync_mode");

// Write setting (auto-saves)
settings->set_setting("interface/editor/custom_display_scale", 1.5);
```

**Sources:** [doc/classes/EditorSettings.xml:1-50](), [editor/settings/editor_settings.cpp]()

### ProjectSettings

**Purpose:** Project-specific configuration shared across all developers

**Storage location:** `<project_root>/project.godot`

**Key settings categories:**
- `application/config/*` - Project metadata
- `rendering/*` - Rendering backend and quality
- `physics/*` - Physics engine settings
- `autoload/*` - Global autoload nodes
- `input/*` - Input action mappings

**Access pattern:**
```cpp
// Get singleton
ProjectSettings *settings = ProjectSettings::get_singleton();

// Read setting with override support
String name = GLOBAL_GET("application/config/name");

// Write setting
settings->set_setting("application/config/version", "1.0");
```

**Feature overrides:** ProjectSettings supports feature tags for platform-specific overrides:
```
# Base setting
rendering/renderer/rendering_method="forward_plus"

# Mobile override
rendering/renderer/rendering_method.mobile="mobile"
```

**Sources:** [doc/classes/ProjectSettings.xml:1-100](), [core/config/project_settings.h:39-130](), [core/config/project_settings.cpp:387-408]()

## Editor-Engine Integration

The editor integrates with the core engine through several key mechanisms:

**Scene root separation:**
```mermaid
graph TB
    subgraph "Editor Structure"
        editor_window["DisplayServer Window"]
        gui_base["gui_base (Control)<br/>Editor UI root"]
        scene_root["scene_root (SubViewport)<br/>Edited scene container"]
        edited_scene["Edited Scene Tree"]
    end
    
    subgraph "Main Loop"
        MainLoop["MainLoop::iteration()"]
        SceneTree_process["SceneTree::process()"]
    end
    
    editor_window --> gui_base
    gui_base --> scene_root
    scene_root --> edited_scene
    
    MainLoop --> SceneTree_process
    SceneTree_process --> gui_base
    SceneTree_process --> scene_root
```

The editor maintains separation between:
- **Editor UI:** Lives in `gui_base`, processes editor input
- **Edited scene:** Lives in `scene_root` (SubViewport), isolated from editor

This separation allows the edited scene to be previewed without interfering with editor UI, and enables features like:
- Running the scene in-editor without closing tabs
- Multiple viewports showing the same scene
- Pausing/stepping scene execution independently

**Main loop integration points:**
1. **Input processing:** `EditorNode::shortcut_input()` for editor shortcuts [editor/editor_node.cpp:402-438]()
2. **Frame updates:** `EditorNode::_update_from_settings()` syncs rendering settings [editor/editor_node.cpp:445-570]()
3. **Scene processing:** Separate physics/idle steps for edited scene vs editor UI
4. **Resource management:** Editor prevents unloading of edited resources

**Sources:** [editor/editor_node.h:460-461](), [editor/editor_node.cpp:402-570](), [main/main.cpp:3600-3800]()

## Theme and Translation Management

The editor manages its appearance and localization through centralized systems:

**Theme generation:**
```mermaid
graph LR
    subgraph "Theme Pipeline"
        ThemeManager["EditorThemeManager"]
        ColorMap["EditorColorMap"]
        theme["editor Theme"]
    end
    
    subgraph "Application"
        gui_base_theme["gui_base theme context"]
        scene_root_theme["scene_root theme context"]
    end
    
    EditorSettings --> ThemeManager
    ThemeManager --> ColorMap
    ColorMap --> theme
    
    theme --> gui_base_theme
    theme --> scene_root_theme
```

**Theme update triggers:**
- Editor settings change (`display_scale`, `custom_display_scale`)
- System theme change (dark mode toggle)
- Manual refresh request

**Translation system:**
- Editor translations: Compiled into binary, use `TTR()` macro
- Project translations: Loaded from `TranslationServer`, use `tr()`
- Preview locale: Override for testing translations in-editor

**Translation change propagation:**
```cpp
void EditorNode::_update_translations() {
    // Load project translations
    TranslationServer::load_project_translations();
    
    // Track changes for auto-refresh
    tracked_translations.insert(translation);
    translation->connect_changed(callable_mp(this, &EditorNode::_queue_translation_notification));
}

void EditorNode::_propagate_translation_notification() {
    // Notify all UI elements to refresh
    scene_root->propagate_notification(NOTIFICATION_TRANSLATION_CHANGED);
}
```

**Sources:** [editor/editor_node.cpp:584-637](), [editor/editor_node.cpp:639-713](), [editor/themes/editor_theme_manager.h]()34:T6cd0,# EditorNode

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

EditorNode is the central singleton orchestrator of the Godot editor. It manages the editor window, coordinates all UI components (docks, panels, menus), handles scene lifecycle operations, integrates the plugin system, and bridges the editor with the engine's main loop. This document covers EditorNode's architecture, initialization, UI orchestration, and its coordination role among editor subsystems.

For editor state management and scene history, see [EditorData](#7.2). For the plugin-facing API, see [EditorInterface](#7.3). For plugin architecture and lifecycle, see [EditorPlugin System](#7.4). For detailed scene loading/saving workflows, see [Scene Management](#7.5).

---

## Singleton Architecture

EditorNode operates as a singleton instance that acts as the root orchestrator for all editor functionality. It inherits from `Node` and is integrated into the editor's scene tree during initialization.

```mermaid
graph TB
    Main["Main::setup2()"]
    EditorNode["EditorNode<br/>(Singleton)"]
    SceneTree["SceneTree<br/>(Editor Scene Tree)"]
    GuiBase["gui_base<br/>(Control)"]
    
    Main -->|"Creates and initializes"| EditorNode
    EditorNode -->|"Added as child to"| SceneTree
    EditorNode -->|"Contains"| GuiBase
    
    subgraph "Core Subsystems"
        EditorData["EditorData"]
        EditorSelection["EditorSelection"]
        EditorPlugins["EditorPluginList"]
    end
    
    subgraph "UI Components"
        MainVBox["main_vbox"]
        EditorMainScreen["editor_main_screen"]
        BottomPanel["bottom_panel"]
        DockManager["editor_dock_manager"]
    end
    
    EditorNode -->|"Owns"| EditorData
    EditorNode -->|"Owns"| EditorSelection
    EditorNode -->|"Manages"| EditorPlugins
    
    GuiBase -->|"Parent of"| MainVBox
    MainVBox -->|"Contains"| EditorMainScreen
    MainVBox -->|"Contains"| BottomPanel
    EditorNode -->|"Manages"| DockManager
```

**Sources:** [editor/editor_node.h:118-119](), [editor/editor_node.h:255](), [editor/editor_node.cpp:205-206](), [main/main.cpp:3273-3297]()

---

## Initialization Flow

EditorNode is initialized during the editor startup sequence in `Main::setup2()`. The initialization occurs in multiple phases to ensure proper dependency ordering.

```mermaid
sequenceDiagram
    participant Main
    participant EditorNode
    participant UI
    participant Plugins
    participant FileSystem
    
    Main->>EditorNode: Create singleton
    EditorNode->>EditorNode: _init_callbacks[]
    EditorNode->>UI: Create gui_base, main_vbox
    EditorNode->>UI: Setup menu bar, title bar
    EditorNode->>UI: Create docks and panels
    EditorNode->>Plugins: Initialize plugin system
    EditorNode->>Plugins: Register built-in plugins
    Plugins->>Plugins: Call _enable_plugin()
    EditorNode->>FileSystem: Start EditorFileSystem scan
    EditorNode->>EditorNode: Load editor layout
    EditorNode->>Main: Initialization complete
```

Key initialization methods:
- `EditorNode()` constructor performs basic setup [editor/editor_node.cpp:7223-8656]()
- Static `_init_callbacks` are invoked to register built-in functionality [editor/editor_node.h:499]()
- Theme is generated before UI construction [editor/editor_node.cpp:639-713]()
- Plugins are initialized after core UI is ready [editor/editor_node.cpp:7900-8100]()

**Sources:** [main/main.cpp:3273-3297](), [editor/editor_node.cpp:7223-8656](), [editor/editor_node.h:495-499]()

---

## UI Component Hierarchy

EditorNode orchestrates a complex hierarchy of UI components that form the editor interface. The top-level structure is built around `gui_base`, which serves as the root Control node for all editor UI.

### Core UI Structure

```mermaid
graph TB
    EditorNode["EditorNode<br/>(Node)"]
    GuiBase["gui_base<br/>(Control)"]
    MainVBox["main_vbox<br/>(VBoxContainer)"]
    
    EditorNode -->|"Child node"| GuiBase
    GuiBase -->|"Contains"| MainVBox
    
    subgraph "Top Bar"
        TitleBar["title_bar<br/>(EditorTitleBar)"]
        MenuBar["main_menu_bar<br/>(MenuBar)"]
        RunBar["project_run_bar<br/>(EditorRunBar)"]
    end
    
    subgraph "Main Content"
        EditorMainScreen["editor_main_screen<br/>(EditorMainScreen)"]
        SceneTabs["scene_tabs<br/>(EditorSceneTabs)"]
        TopSplit["top_split<br/>(VSplitContainer)"]
    end
    
    subgraph "Bottom Area"
        BottomPanel["bottom_panel<br/>(EditorBottomPanel)"]
    end
    
    subgraph "Docks"
        DockManager["editor_dock_manager<br/>(EditorDockManager)"]
        LeftL["left_l_vsplit"]
        LeftR["left_r_vsplit"]
        RightL["right_l_vsplit"]
        RightR["right_r_vsplit"]
    end
    
    MainVBox -->|"Contains"| TitleBar
    MainVBox -->|"Contains"| MenuBar
    MainVBox -->|"Contains"| RunBar
    MainVBox -->|"Contains"| EditorMainScreen
    MainVBox -->|"Contains"| SceneTabs
    MainVBox -->|"Contains"| TopSplit
    MainVBox -->|"Contains"| BottomPanel
    
    EditorNode -->|"Manages"| DockManager
    DockManager -->|"Controls"| LeftL
    DockManager -->|"Controls"| LeftR
    DockManager -->|"Controls"| RightL
    DockManager -->|"Controls"| RightR
```

### Key UI Components

| Component | Type | Purpose | Member Variable |
|-----------|------|---------|----------------|
| gui_base | Control | Root container for all editor UI | `gui_base` |
| main_vbox | VBoxContainer | Main vertical layout container | `main_vbox` |
| title_bar | EditorTitleBar | Window title and system menu | `title_bar` |
| main_menu_bar | MenuBar | Main menu (Scene, Project, etc) | `main_menu_bar` |
| project_run_bar | EditorRunBar | Play/stop/debug controls | `project_run_bar` |
| editor_main_screen | EditorMainScreen | 2D/3D/Script editor switcher | `editor_main_screen` |
| scene_tabs | EditorSceneTabs | Scene tab management | `scene_tabs` |
| bottom_panel | EditorBottomPanel | Output, debugger, etc. | `bottom_panel` |
| editor_dock_manager | EditorDockManager | Manages all dockable panels | `editor_dock_manager` |

**Sources:** [editor/editor_node.h:287-430](), [editor/editor_node.cpp:7400-7600](), [editor/editor_node.cpp:7700-7900]()

---

## Menu System and Actions

EditorNode implements a comprehensive menu system with actions organized into several top-level menus. Menu options are handled through the `MenuOptions` enum and dispatched via `_menu_option()`.

### Menu Organization

```mermaid
graph LR
    MenuBar["main_menu_bar<br/>(MenuBar)"]
    
    subgraph "Menus"
        FileMenu["file_menu<br/>(Scene operations)"]
        ProjectMenu["project_menu<br/>(Project settings)"]
        DebugMenu["debug_menu<br/>(Debug options)"]
        SettingsMenu["settings_menu<br/>(Editor settings)"]
        HelpMenu["help_menu<br/>(Documentation)"]
        ToolMenu["tool_menu<br/>(Custom tools)"]
    end
    
    MenuBar --> FileMenu
    MenuBar --> ProjectMenu
    MenuBar --> DebugMenu
    MenuBar --> SettingsMenu
    MenuBar --> HelpMenu
    MenuBar --> ToolMenu
    
    FileMenu -->|"SCENE_NEW_SCENE"| NewScene["New Scene"]
    FileMenu -->|"SCENE_OPEN_SCENE"| OpenScene["Open Scene"]
    FileMenu -->|"SCENE_SAVE_SCENE"| SaveScene["Save Scene"]
    FileMenu -->|"SCENE_QUIT"| Quit["Quit"]
    
    ProjectMenu -->|"PROJECT_OPEN_SETTINGS"| ProjSettings["Project Settings"]
    ProjectMenu -->|"PROJECT_EXPORT"| Export["Export"]
    
    SettingsMenu -->|"EDITOR_OPEN_SETTINGS"| EditorSettings["Editor Settings"]
```

### Menu Action Dispatch

The menu system uses an enum-based dispatch pattern:

```mermaid
sequenceDiagram
    participant MenuItem
    participant MenuBar
    participant EditorNode
    participant Handler
    
    MenuItem->>MenuBar: Item selected
    MenuBar->>EditorNode: _menu_option(option_id)
    EditorNode->>EditorNode: Switch on MenuOptions enum
    alt Scene Operation
        EditorNode->>Handler: _save_scene() / _open_scene()
    else Project Operation
        EditorNode->>Handler: _show_project_settings()
    else Editor Operation
        EditorNode->>Handler: _show_editor_settings()
    end
```

Menu options are defined in the `MenuOptions` enum [editor/editor_node.h:141-225]() and dispatched in `_menu_option()` [editor/editor_node.cpp:2900-3500]().

**Sources:** [editor/editor_node.h:141-225](), [editor/editor_node.h:336-346](), [editor/editor_node.cpp:2900-3500]()

---

## Scene Management Integration

EditorNode coordinates scene lifecycle operations through integration with `EditorData`, which maintains scene state, and various UI components that reflect the current scene.

### Scene State Architecture

```mermaid
graph TB
    EditorNode["EditorNode"]
    EditorData["editor_data<br/>(EditorData)"]
    SceneTabs["scene_tabs<br/>(EditorSceneTabs)"]
    SceneRoot["scene_root<br/>(SubViewport)"]
    
    EditorNode -->|"Owns"| EditorData
    EditorNode -->|"Owns"| SceneTabs
    EditorNode -->|"Owns"| SceneRoot
    
    subgraph "Scene State"
        EditedScenes["edited_scene[]<br/>(Vector of scenes)"]
        CurrentIdx["current_edited_scene<br/>(index)"]
        HistoryId["history_id per scene"]
    end
    
    EditorData -->|"Maintains"| EditedScenes
    EditorData -->|"Tracks"| CurrentIdx
    EditorData -->|"Tracks"| HistoryId
    
    SceneTabs -->|"Reflects"| EditedScenes
    SceneRoot -->|"Displays root of"| EditedScenes
    
    subgraph "Scene Operations"
        LoadScene["_load_scene()"]
        SaveScene["_save_scene()"]
        CloseScene["_remove_edited_scene()"]
        SwitchScene["_set_current_scene()"]
    end
    
    EditorNode -->|"Implements"| LoadScene
    EditorNode -->|"Implements"| SaveScene
    EditorNode -->|"Implements"| CloseScene
    EditorNode -->|"Implements"| SwitchScene
```

### Scene Lifecycle Operations

| Operation | Method | Description |
|-----------|--------|-------------|
| Load scene | `_load_scene()` | Loads a scene from disk and adds tab |
| Save scene | `_save_scene()` | Saves current scene to disk |
| Close scene | `_remove_edited_scene()` | Closes scene and removes tab |
| Switch scene | `_set_current_scene()` | Switches active scene tab |
| New scene | Creates empty scene and adds tab | |

The scene viewport `scene_root` is a `SubViewport` that displays the currently edited scene's root node [editor/editor_node.h:460]().

**Sources:** [editor/editor_node.h:257-260](), [editor/editor_node.h:460](), [editor/editor_node.cpp:3700-4000](), [editor/editor_node.cpp:4200-4600]()

---

## Plugin System Orchestration

EditorNode manages the entire plugin lifecycle and provides the infrastructure for plugins to extend editor functionality. It maintains lists of active plugins and coordinates their interaction with the editor.

### Plugin Management Architecture

```mermaid
graph TB
    EditorNode["EditorNode"]
    
    subgraph "Plugin Storage"
        PluginVector["editor_plugins<br/>(Vector&lt;EditorPlugin*&gt;)"]
        AddonMap["addon_name_to_plugin<br/>(HashMap)"]
        ActivePlugins["active_plugins<br/>(per object)"]
    end
    
    subgraph "Plugin Lists"
        ForceInput["editor_plugins_force_input_forwarding"]
        ForceOver["editor_plugins_force_over"]
        PluginsOver["editor_plugins_over"]
    end
    
    EditorNode -->|"Owns"| PluginVector
    EditorNode -->|"Owns"| AddonMap
    EditorNode -->|"Owns"| ActivePlugins
    EditorNode -->|"Maintains"| ForceInput
    EditorNode -->|"Maintains"| ForceOver
    EditorNode -->|"Maintains"| PluginsOver
    
    subgraph "Plugin Lifecycle"
        Add["add_editor_plugin()"]
        Remove["remove_editor_plugin()"]
        Enable["_enable_plugin()"]
        Disable["_disable_plugin()"]
    end
    
    EditorNode -->|"Calls"| Add
    EditorNode -->|"Calls"| Remove
    EditorNode -->|"Calls"| Enable
    EditorNode -->|"Calls"| Disable
    
    subgraph "Plugin Integration"
        MainScreen["Main screen registration"]
        Docks["Dock registration"]
        ToolMenus["Tool menu registration"]
        InputForward["Input forwarding"]
    end
    
    PluginVector -->|"Used for"| MainScreen
    PluginVector -->|"Used for"| Docks
    PluginVector -->|"Used for"| ToolMenus
    ForceInput -->|"Used for"| InputForward
```

### Plugin Registration Flow

```mermaid
sequenceDiagram
    participant Caller
    participant EditorNode
    participant Plugin
    participant UI
    
    Caller->>EditorNode: add_editor_plugin(plugin)
    EditorNode->>Plugin: Store in editor_plugins[]
    EditorNode->>Plugin: _enter_tree()
    Plugin->>UI: add_control_to_dock()
    Plugin->>UI: add_tool_menu_item()
    alt Has main screen
        Plugin->>EditorNode: Register main screen
        EditorNode->>UI: Add to editor_main_screen
    end
```

Built-in plugins are initialized during EditorNode construction [editor/editor_node.cpp:7900-8100](), while addon plugins are loaded later from the project's addons folder.

**Sources:** [editor/editor_node.h:280-285](), [editor/editor_node.h:266-269](), [editor/editor_node.cpp:7900-8100](), [editor/editor_node.cpp:6100-6300]()

---

## Main Loop Integration

EditorNode integrates with the engine's main loop through the `SceneTree`, enabling the editor to process input, update UI, and handle notifications alongside the edited scene.

### Processing Flow

```mermaid
graph LR
    MainLoop["Main::iteration()"]
    SceneTree["SceneTree::process()"]
    EditorNode["EditorNode::_notification()"]
    
    MainLoop -->|"Calls"| SceneTree
    SceneTree -->|"Processes"| EditorNode
    
    subgraph "Notification Types"
        Process["NOTIFICATION_PROCESS"]
        PhysicsProcess["NOTIFICATION_PHYSICS_PROCESS"]
        Ready["NOTIFICATION_READY"]
        ExitTree["NOTIFICATION_EXIT_TREE"]
    end
    
    EditorNode -->|"Handles"| Process
    EditorNode -->|"Handles"| PhysicsProcess
    EditorNode -->|"Handles"| Ready
    EditorNode -->|"Handles"| ExitTree
    
    subgraph "Editor Updates"
        UpdateSpinner["Update spinner animation"]
        CheckChanges["Check for file changes"]
        ProcessPlugins["Process plugin updates"]
        UpdateUI["Update UI state"]
    end
    
    Process -->|"Triggers"| UpdateSpinner
    Process -->|"Triggers"| CheckChanges
    Process -->|"Triggers"| ProcessPlugins
    Process -->|"Triggers"| UpdateUI
```

Key processing hooks:
- `NOTIFICATION_READY`: Performs post-initialization setup [editor/editor_node.cpp:1400-1600]()
- `NOTIFICATION_PROCESS`: Updates editor state each frame [editor/editor_node.cpp:1700-1900]()
- `input()` and `shortcut_input()`: Handle editor-level input events [editor/editor_node.cpp:389-438]()

**Sources:** [editor/editor_node.cpp:389-438](), [editor/editor_node.cpp:1400-1900](), [main/main.cpp:3700-3900]()

---

## Progress Dialog System

EditorNode provides a centralized progress reporting system used throughout the editor for long-running operations. The `EditorProgress` class provides a convenient RAII-style interface.

### Progress System Architecture

```mermaid
graph TB
    EditorProgress["EditorProgress<br/>(RAII wrapper)"]
    EditorNode["EditorNode"]
    ProgressDialog["progress_dialog<br/>(ProgressDialog)"]
    BackgroundProgress["progress_hb<br/>(BackgroundProgress)"]
    
    EditorProgress -->|"Calls static methods"| EditorNode
    EditorNode -->|"Routes to"| ProgressDialog
    EditorNode -->|"Or routes to"| BackgroundProgress
    
    subgraph "Static API"
        AddTask["progress_add_task()"]
        StepTask["progress_task_step()"]
        EndTask["progress_end_task()"]
    end
    
    EditorNode -->|"Implements"| AddTask
    EditorNode -->|"Implements"| StepTask
    EditorNode -->|"Implements"| EndTask
    
    subgraph "Background Tasks"
        AddTaskBg["progress_add_task_bg()"]
        StepTaskBg["progress_task_step_bg()"]
        EndTaskBg["progress_end_task_bg()"]
    end
    
    EditorNode -->|"Implements"| AddTaskBg
    EditorNode -->|"Implements"| StepTaskBg
    EditorNode -->|"Implements"| EndTaskBg
```

Usage pattern:
```cpp
{
    EditorProgress progress("import_scene", "Importing Scene", 100);
    for (int i = 0; i < 100; i++) {
        progress.step("Processing step " + itos(i), i);
        // Do work...
    }
} // Automatically ends task on destruction
```

**Sources:** [editor/editor_node.h:109-116](), [editor/editor_node.cpp:214-239](), [editor/editor_node.cpp:1200-1350]()

---

## Settings and Configuration

EditorNode manages both project-level (`ProjectSettings`) and editor-level (`EditorSettings`) configuration, applying settings changes to the editor state and propagating updates to subsystems.

### Settings Management

```mermaid
graph TB
    EditorNode["EditorNode"]
    ProjectSettings["ProjectSettings<br/>(Singleton)"]
    EditorSettings["EditorSettings<br/>(Singleton)"]
    
    EditorNode -->|"Reads from"| ProjectSettings
    EditorNode -->|"Reads from"| EditorSettings
    
    subgraph "Update Triggers"
        SettingsChanged["settings_changed signal"]
        FromSettings["_update_from_settings()"]
        UpdateTheme["_update_theme()"]
        UpdateVsync["_update_vsync_mode()"]
    end
    
    ProjectSettings -->|"Emits"| SettingsChanged
    EditorSettings -->|"Emits"| SettingsChanged
    SettingsChanged -->|"Triggers"| FromSettings
    FromSettings -->|"Calls"| UpdateTheme
    FromSettings -->|"Calls"| UpdateVsync
    
    subgraph "Rendering Settings"
        VSyncMode["V-Sync mode"]
        TextureFilter["Texture filtering"]
        AASettings["Anti-aliasing"]
        GISettings["Global illumination"]
    end
    
    FromSettings -->|"Applies"| VSyncMode
    FromSettings -->|"Applies"| TextureFilter
    FromSettings -->|"Applies"| AASettings
    FromSettings -->|"Applies"| GISettings
```

The `_update_from_settings()` method [editor/editor_node.cpp:445-570]() is the central handler that:
1. Updates viewport texture filtering and repeat modes
2. Configures rendering server quality settings (DOF, SSAO, SSIL, etc.)
3. Applies 2D/3D snap settings
4. Updates debug visualization colors
5. Reloads resource importers as needed

**Sources:** [editor/editor_node.cpp:440-570](), [editor/editor_node.cpp:639-713](), [core/config/project_settings.h:39-41]()

---

## Theme and UI Styling

EditorNode generates and manages the editor theme, which is distinct from project themes. The theme system supports light/dark mode switching and custom accent colors.

### Theme System

```mermaid
graph TB
    EditorNode["EditorNode"]
    Theme["theme<br/>(Ref&lt;Theme&gt;)"]
    ThemeManager["EditorThemeManager"]
    ThemeDB["ThemeDB<br/>(Singleton)"]
    
    EditorNode -->|"Owns"| Theme
    EditorNode -->|"Generates via"| ThemeManager
    EditorNode -->|"Registers with"| ThemeDB
    
    subgraph "Theme Generation"
        SystemTheme["Check system dark mode"]
        GenerateTheme["generate_theme()"]
        IconCache["Build icon type cache"]
        ApplyTheme["Apply to UI hierarchy"]
    end
    
    EditorNode -->|"1. Checks"| SystemTheme
    EditorNode -->|"2. Calls"| GenerateTheme
    EditorNode -->|"3. Builds"| IconCache
    EditorNode -->|"4. Applies"| ApplyTheme
    
    subgraph "Theme Contexts"
        EditorContext["Editor UI context"]
        PreviewContext["Scene preview context"]
    end
    
    ThemeDB -->|"Manages"| EditorContext
    ThemeDB -->|"Manages"| PreviewContext
```

The theme update flow:
1. `_update_theme()` is called on startup or when settings change [editor/editor_node.cpp:639-713]()
2. `EditorThemeManager::generate_theme()` creates the theme resource
3. `_build_icon_type_cache()` caches icons for quick lookup [editor/editor_node.cpp:6400-6600]()
4. Theme contexts are set up for editor UI vs scene preview [editor/editor_node.cpp:657-672]()

**Sources:** [editor/editor_node.h:360-366](), [editor/editor_node.cpp:639-713](), [editor/editor_node.cpp:6400-6600]()

---

## Export and Build System Integration

EditorNode coordinates the export and build system, managing export presets, template installation, and platform-specific builds.

```mermaid
graph TB
    EditorNode["EditorNode"]
    
    subgraph "Export Components"
        EditorExport["editor_export<br/>(EditorExport)"]
        ProjectExport["project_export<br/>(ProjectExportDialog)"]
        TemplateManager["export_template_manager<br/>(ExportTemplateManager)"]
    end
    
    EditorNode -->|"Owns"| EditorExport
    EditorNode -->|"Owns"| ProjectExport
    EditorNode -->|"Owns"| TemplateManager
    
    subgraph "Build Callbacks"
        BuildCallbacks["build_callbacks[]<br/>(static)"]
        BuildPhase["_call_build()"]
    end
    
    EditorNode -->|"Registers"| BuildCallbacks
    EditorNode -->|"Invokes before run"| BuildPhase
    
    subgraph "Platform Specifics"
        AndroidBuild["Android build templates"]
        GradleManage["Gradle template management"]
    end
    
    EditorNode -->|"Manages"| AndroidBuild
    EditorNode -->|"Manages"| GradleManage
```

Build callbacks allow plugins and subsystems to hook into the pre-run build phase [editor/editor_node.h:495-497](), enabling features like C# project building or shader precompilation.

**Sources:** [editor/editor_node.h:263-278](), [editor/editor_node.h:495-497](), [editor/editor_node.cpp:5500-5700]()

---

## File System Monitoring

EditorNode integrates with `EditorFileSystem` to detect and respond to file changes, triggering resource reloads and UI updates.

```mermaid
sequenceDiagram
    participant FS as EditorFileSystem
    participant EditorNode
    participant ResourceLoader
    participant UI
    
    FS->>EditorNode: filesystem_changed signal
    EditorNode->>EditorNode: _fs_changed()
    EditorNode->>ResourceLoader: Check modified resources
    alt Resources changed on disk
        EditorNode->>UI: Show disk_changed dialog
        UI->>EditorNode: User confirms reload
        EditorNode->>ResourceLoader: Reload resources
    end
    
    FS->>EditorNode: resources_reimporting signal
    EditorNode->>EditorNode: _resources_reimporting()
    EditorNode->>UI: Update progress
    
    FS->>EditorNode: resources_reimported signal
    EditorNode->>EditorNode: _resources_reimported()
    EditorNode->>UI: Refresh affected editors
```

File system signals are connected during initialization [editor/editor_node.cpp:7650-7680]() and handled by:
- `_fs_changed()`: General file system change [editor/editor_node.cpp:5100-5200]()
- `_sources_changed()`: Source file changes [editor/editor_node.cpp:5300-5400]()
- `_resources_reimporting()`: Before reimport [editor/editor_node.cpp:5800-5850]()
- `_resources_reimported()`: After reimport [editor/editor_node.cpp:5850-5950]()

**Sources:** [editor/editor_node.cpp:5100-5950](), [editor/editor_node.cpp:7650-7680]()

---

## Error and Warning Handling

EditorNode provides centralized error and warning display through custom print handlers that route messages to the editor log and show notifications.

```mermaid
graph TB
    PrintSystem["Print/Error System"]
    EditorNode["EditorNode"]
    EditorLog["EditorLog"]
    EditorToaster["EditorToaster"]
    
    PrintSystem -->|"Routes through"| EditorNode
    EditorNode -->|"_print_handler()"| Handler["Custom handler"]
    Handler -->|"Logs to"| EditorLog
    Handler -->|"Shows toast"| EditorToaster
    
    subgraph "Print Handler"
        PrintHandlerList["print_handler<br/>(PrintHandlerList)"]
        PrintImpl["_print_handler_impl()"]
    end
    
    EditorNode -->|"Installs"| PrintHandlerList
    PrintHandlerList -->|"Calls"| PrintImpl
    
    subgraph "Error Display"
        LoadErrors["load_errors<br/>(RichTextLabel)"]
        LoadErrorDialog["load_error_dialog<br/>(AcceptDialog)"]
    end
    
    EditorNode -->|"Shows in"| LoadErrors
    EditorNode -->|"Shows in"| LoadErrorDialog
```

The print handler is installed during initialization [editor/editor_node.cpp:7300-7320]() and routes all print output through `_print_handler()` [editor/editor_node.cpp:1000-1050]().

**Sources:** [editor/editor_node.h:483](), [editor/editor_node.cpp:1000-1050](), [editor/editor_node.cpp:7300-7320]()

---

## Key Member Variables

| Category | Member | Type | Purpose |
|----------|--------|------|---------|
| **Core State** | `editor_data` | EditorData | Scene state and history |
| | `editor_selection` | EditorSelection* | Current selection |
| | `singleton` | static EditorNode* | Singleton instance |
| **UI Root** | `gui_base` | Control* | Root UI container |
| | `main_vbox` | VBoxContainer* | Main layout container |
| | `scene_root` | SubViewport* | Scene viewport |
| **UI Components** | `editor_main_screen` | EditorMainScreen* | Main screen switcher |
| | `bottom_panel` | EditorBottomPanel* | Bottom panel container |
| | `editor_dock_manager` | EditorDockManager* | Dock management |
| | `scene_tabs` | EditorSceneTabs* | Scene tab bar |
| **Plugins** | `editor_plugins` | Vector<EditorPlugin*> | All editor plugins |
| | `addon_name_to_plugin` | HashMap | Addon plugin lookup |
| **Settings** | `theme` | Ref<Theme> | Editor theme |
| | Follow/system settings | bool flags | Theme preferences |
| **Dialogs** | `confirmation` | ConfirmationDialog* | Generic confirmation |
| | `save_confirmation` | ConfirmationDialog* | Save confirmation |
| | `disk_changed` | ConfirmationDialog* | Disk change notification |
| **Export** | `editor_export` | EditorExport* | Export system |
| | `project_export` | ProjectExportDialog* | Export dialog |
| **Progress** | `progress_dialog` | ProgressDialog* | Modal progress |
| | `progress_hb` | BackgroundProgress* | Background progress |

**Sources:** [editor/editor_node.h:255-489]()

---

## Signal and Callback System

EditorNode exposes several signals for subsystems to respond to editor events:

| Signal | Parameters | Purpose |
|--------|------------|---------|
| `scene_changed` | Node* scene_root | Emitted when edited scene changes |
| `scene_closed` | String filepath | Emitted when a scene is closed |
| `request_help_search` | String topic | Request help for topic |
| `script_add_function_request` | Object* obj, String function, PackedStringArray args | Request to add function to script |
| `resource_saved` | Resource* resource | Emitted after resource is saved |
| `preview_locale_changed` | - | Emitted when preview locale changes |

Static callback systems:
- `_init_callbacks[]`: Invoked during initialization [editor/editor_node.h:499]()
- `build_callbacks[]`: Invoked before running project [editor/editor_node.h:495]()
- `plugin_init_callbacks[]`: Invoked when initializing plugins [editor/editor_node.h:496]()

**Sources:** [editor/editor_node.h:495-499](), [editor/editor_node.cpp:623-638]()35:T52ac,# EditorData

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

`EditorData` is the central state management class for the Godot editor. It maintains all editor-specific data that is not part of the scene tree itself, including the list of open scenes, registered editor plugins, custom node types, clipboard state, and undo/redo history management. This class acts as a data model layer that is used by `EditorNode` (the main editor controller) to manage the editor's working state.

For information about the main editor singleton and UI orchestration, see [EditorNode](#8.1). For the public API exposed to plugins, see [EditorInterface](#8.3).

Sources: [editor/editor_data.h:105-265](), [editor/editor_data.cpp:1-44]()

## Architecture Overview

```mermaid
graph TB
    subgraph "Editor Core"
        EditorNode["EditorNode<br/>(Main Controller)"]
        EditorData["EditorData<br/>(State Manager)"]
        EditorInterface["EditorInterface<br/>(Public API)"]
    end
    
    subgraph "EditorData Managed State"
        EditedScenes["Vector&lt;EditedScene&gt;<br/>edited_scene"]
        Plugins["Vector&lt;EditorPlugin*&gt;<br/>editor_plugins"]
        CustomTypes["HashMap&lt;String, Vector&lt;CustomType&gt;&gt;<br/>custom_types"]
        Clipboard["List&lt;PropertyData&gt;<br/>clipboard"]
        ScriptMeta["Script Class Metadata<br/>_script_class_icon_paths"]
    end
    
    subgraph "Per-Scene State (EditedScene)"
        SceneRoot["Node* root"]
        ScenePath["String path"]
        EditorStates["Dictionary editor_states"]
        Selection["List&lt;Node*&gt; selection"]
        HistoryData["Vector&lt;HistoryElement&gt;<br/>history_stored"]
        CustomState["Dictionary custom_state"]
    end
    
    EditorNode -->|"owns & uses"| EditorData
    EditorInterface -->|"exposes via"| EditorNode
    EditorData -->|manages| EditedScenes
    EditorData -->|manages| Plugins
    EditorData -->|manages| CustomTypes
    EditorData -->|manages| Clipboard
    EditorData -->|manages| ScriptMeta
    
    EditedScenes -->|contains| SceneRoot
    EditedScenes -->|contains| ScenePath
    EditedScenes -->|contains| EditorStates
    EditedScenes -->|contains| Selection
    EditedScenes -->|contains| HistoryData
    EditedScenes -->|contains| CustomState
```

**EditorData State Management Architecture**

Sources: [editor/editor_data.h:105-154](), [editor/editor_node.h:257-259]()

## Core Data Structures

### EditedScene Structure

The `EditedScene` struct represents a single open scene tab in the editor. Each scene maintains its own complete editor state.

| Field | Type | Purpose |
|-------|------|---------|
| `root` | `Node*` | Root node of the edited scene |
| `path` | `String` | File path of the scene (empty for unsaved scenes) |
| `file_modified_time` | `uint64_t` | Last known modification time on disk |
| `editor_states` | `Dictionary` | Plugin-specific state (e.g., camera position, viewport settings) |
| `selection` | `List<Node*>` | Currently selected nodes in this scene |
| `history_stored` | `Vector<HistoryElement>` | Selection history for this scene |
| `history_current` | `int` | Current position in the history |
| `custom_state` | `Dictionary` | Custom state data (used by scene import settings) |
| `live_edit_root` | `NodePath` | Root path for live editing features |
| `history_id` | `int` | Unique ID for undo/redo history tracking |
| `last_checked_version` | `uint64_t` | Last checked undo/redo version for change detection |

Sources: [editor/editor_data.h:113-125]()

### CustomType Structure

The `CustomType` struct represents a custom node or resource type registered by a plugin.

| Field | Type | Purpose |
|-------|------|---------|
| `name` | `String` | Display name of the custom type |
| `script` | `Ref<Script>` | Script that defines the custom type |
| `icon` | `Ref<Texture2D>` | Icon to display in the editor |

Sources: [editor/editor_data.h:107-111]()

## Edited Scene Management

### Scene Tab System

```mermaid
graph LR
    subgraph "EditorData Scene Management"
        CurrentIndex["current_edited_scene<br/>(int)"]
        SceneArray["edited_scene<br/>(Vector&lt;EditedScene&gt;)"]
        LastCreated["last_created_scene<br/>(counter)"]
    end
    
    subgraph "Scene Operations"
        AddScene["add_edited_scene()"]
        RemoveScene["remove_scene()"]
        SetScene["set_edited_scene()"]
        MoveScene["move_edited_scene_index()"]
    end
    
    subgraph "Scene State Queries"
        GetRoot["get_edited_scene_root()"]
        GetPath["get_scene_path()"]
        GetTitle["get_scene_title()"]
        IsChanged["is_scene_changed()"]
    end
    
    CurrentIndex -->|"indexes into"| SceneArray
    AddScene -->|"appends to"| SceneArray
    AddScene -->|"assigns unique ID from"| LastCreated
    RemoveScene -->|"removes from"| SceneArray
    SetScene -->|"updates"| CurrentIndex
    MoveScene -->|"reorders"| SceneArray
    
    GetRoot -->|"reads"| SceneArray
    GetPath -->|"reads"| SceneArray
    GetTitle -->|"reads"| SceneArray
    IsChanged -->|"checks version"| SceneArray
```

**Scene Tab Management Flow**

Sources: [editor/editor_data.cpp:609-667](), [editor/editor_data.h:201-224]()

### Key Scene Management Methods

| Method | Purpose |
|--------|---------|
| `add_edited_scene(int p_at_pos)` | Adds a new scene tab at the specified position, assigns unique history ID |
| `remove_scene(int p_idx)` | Removes scene, notifies plugins, cleans up undo/redo history |
| `set_edited_scene(int p_idx)` | Changes the currently active scene tab |
| `move_edited_scene_index(int p_idx, int p_to_idx)` | Reorders scene tabs (used when user drags tabs) |
| `get_edited_scene_root(int p_idx = -1)` | Returns the root node of a scene (-1 for current) |
| `get_scene_path(int p_idx)` | Returns the file path of a scene |
| `is_scene_changed(int p_idx)` | Checks if scene has unsaved changes via undo/redo version tracking |

Sources: [editor/editor_data.cpp:609-631](), [editor/editor_data.cpp:639-667](), [editor/editor_data.cpp:423-433]()

### Scene State Persistence

EditorData manages two types of state persistence:

1. **Per-Scene Editor States** - Saved in `editstate` files in `.godot/editor/` directory
2. **Global Plugin Window Layout** - Saved in `editor_layout.cfg`

```mermaid
sequenceDiagram
    participant EditorNode
    participant EditorData
    participant Plugins as EditorPlugins
    participant UndoRedo as EditorUndoRedoManager
    
    Note over EditorNode,Plugins: Saving Scene State
    EditorNode->>EditorData: save_edited_scene_state()
    EditorData->>Plugins: get_state() for each plugin
    Plugins-->>EditorData: Dictionary with plugin state
    EditorData->>EditorData: Store in edited_scene[idx].editor_states
    EditorData->>EditorData: Store selection and history
    
    Note over EditorNode,Plugins: Restoring Scene State
    EditorNode->>EditorData: restore_edited_scene_state()
    EditorData->>EditorData: Read from edited_scene[idx]
    EditorData->>Plugins: set_state() for each plugin
    EditorData->>EditorNode: Return custom_state Dictionary
```

**Scene State Save/Restore Flow**

Sources: [editor/editor_data.cpp:767-825](), [editor/editor_data.h:238-239]()

## Plugin Management

### Plugin Registry

EditorData maintains two plugin registries:

1. **Standard Plugins** - `Vector<EditorPlugin*> editor_plugins`
2. **Extension Plugins** - `HashMap<StringName, EditorPlugin*> extension_editor_plugins`

Extension plugins are GDExtension-based plugins registered by class name, while standard plugins include both built-in and GDScript-based plugins.

```mermaid
graph TB
    subgraph "Plugin Registration"
        AddPlugin["add_editor_plugin(p_plugin)"]
        AddExtPlugin["add_extension_editor_plugin(p_class, p_plugin)"]
        RemovePlugin["remove_editor_plugin(p_plugin)"]
    end
    
    subgraph "Plugin Queries"
        GetHandlingMain["get_handling_main_editor(p_object)"]
        GetHandlingSub["get_handling_sub_editors(p_object)"]
        GetByName["get_editor_by_name(p_name)"]
        HasExtPlugin["has_extension_editor_plugin(p_class)"]
    end
    
    subgraph "Plugin Operations"
        GetStates["get_editor_plugin_states()"]
        SetStates["set_editor_plugin_states(p_states)"]
        NotifySceneChange["notify_edited_scene_changed()"]
        ApplyChanges["apply_changes_in_editors()"]
    end
    
    AddPlugin -->|"iterates backwards<br/>for handles() check"| GetHandlingMain
    GetHandlingMain -->|"finds plugin that<br/>handles() object"| GetByName
    GetStates -->|"calls get_state()<br/>on all plugins"| SetStates
    NotifySceneChange -->|"calls edited_scene_changed()<br/>and notify_scene_changed()"| ApplyChanges
```

**Plugin Management System**

Sources: [editor/editor_data.cpp:256-286](), [editor/editor_data.cpp:482-515](), [editor/editor_data.h:170-179]()

### Plugin State Management

EditorData coordinates plugin state through several lifecycle methods:

| Method | Called When | Purpose |
|--------|-------------|---------|
| `get_editor_plugin_states()` | Saving layout | Collects `get_state()` from all plugins into a Dictionary |
| `set_editor_plugin_states(p_states)` | Loading layout | Restores plugin state by calling `set_state()` on each plugin |
| `notify_edited_scene_changed()` | Scene switched | Calls `edited_scene_changed()` and `notify_scene_changed()` on all plugins |
| `notify_resource_saved(p_resource)` | Resource saved | Notifies plugins via `notify_resource_saved()` |
| `notify_scene_saved(p_path)` | Scene saved | Notifies plugins via `notify_scene_saved()` |
| `clear_editor_states()` | Cleanup | Calls `clear()` on all plugins |
| `apply_changes_in_editors()` | Pre-save | Calls `apply_changes()` on all plugins |

Sources: [editor/editor_data.cpp:312-391]()

## Custom Type System

### Registration and Instantiation

The custom type system allows plugins to register new node and resource types that appear in the "Create New Node" and "Create New Resource" dialogs.

```mermaid
sequenceDiagram
    participant Plugin as EditorPlugin
    participant EditorData
    participant CustomTypes as custom_types HashMap
    participant ClassDB
    
    Note over Plugin,ClassDB: Registering Custom Type
    Plugin->>EditorData: add_custom_type("MyNode", "Node2D", script, icon)
    EditorData->>EditorData: Create CustomType struct
    EditorData->>CustomTypes: custom_types["Node2D"].push_back(CustomType)
    
    Note over Plugin,ClassDB: Instantiating Custom Type
    Plugin->>EditorData: instantiate_custom_type("MyNode", "Node2D")
    EditorData->>CustomTypes: Find CustomType in custom_types["Node2D"]
    EditorData->>ClassDB: instantiate("Node2D")
    ClassDB-->>EditorData: Return base object
    EditorData->>EditorData: Set script on object
    EditorData-->>Plugin: Return configured object
    
    Note over Plugin,ClassDB: Removing Custom Type
    Plugin->>EditorData: remove_custom_type("MyNode")
    EditorData->>CustomTypes: Remove from custom_types
```

**Custom Type Lifecycle**

Sources: [editor/editor_data.cpp:517-593]()

### Custom Type Lookup

EditorData provides multiple ways to query custom types:

| Method | Purpose |
|--------|---------|
| `get_custom_type_by_name(p_type)` | Find custom type by its display name |
| `get_custom_type_by_path(p_path)` | Find custom type by its script path |
| `is_type_recognized(p_type)` | Check if a type name is valid (built-in, global class, or custom) |

These methods iterate through the `custom_types` HashMap, which is keyed by base class name (e.g., "Node2D", "Resource").

Sources: [editor/editor_data.cpp:555-593]()

## Clipboard System

### Object Property Clipboard

EditorData implements a simple property clipboard system for copy/paste operations:

```mermaid
sequenceDiagram
    participant User
    participant EditorData
    participant Object as Target Object
    participant UndoRedo as EditorUndoRedoManager
    
    Note over User,UndoRedo: Copy Operation
    User->>EditorData: copy_object_params(source_object)
    EditorData->>Object: get_property_list()
    Object-->>EditorData: List<PropertyInfo>
    EditorData->>EditorData: Filter PROPERTY_USAGE_EDITOR
    EditorData->>Object: get(property) for each
    EditorData->>EditorData: Store in clipboard List
    
    Note over User,UndoRedo: Paste Operation
    User->>EditorData: paste_object_params(target_object)
    EditorData->>UndoRedo: create_action("Paste Params")
    loop For each PropertyData in clipboard
        EditorData->>UndoRedo: add_do_property(object, name, value)
        EditorData->>UndoRedo: add_undo_property(object, name, old_value)
    end
    EditorData->>UndoRedo: commit_action()
```

**Clipboard Copy/Paste Flow**

The clipboard filters out properties like `script`, `scripts`, and `resource_path` to avoid unwanted side effects.

Sources: [editor/editor_data.cpp:288-402]()

## Script Class Metadata Management

### Icon Path Tracking

EditorData maintains script class metadata that is saved globally (not per-scene):

| Data Structure | Purpose |
|----------------|---------|
| `_script_class_icon_paths` | Maps class names to icon file paths |
| `_script_class_file_to_path` | Maps script file paths to class names |
| `_script_icon_cache` | Caches loaded icon textures to avoid repeated file I/O |

```mermaid
graph TB
    subgraph "Script Class Metadata"
        SetIconPath["script_class_set_icon_path(class, path)"]
        GetIconPath["script_class_get_icon_path(class)"]
        SetClassName["script_class_set_name(path, class)"]
        GetClassName["script_class_get_name(path)"]
    end
    
    subgraph "Icon Caching"
        GetScriptIcon["get_script_icon(script_path)"]
        LoadIcon["_load_script_icon(path)"]
        IconCache["_script_icon_cache HashMap"]
    end
    
    subgraph "Persistence"
        SaveGlobal["script_class_save_global_classes()"]
        LoadPaths["script_class_load_icon_paths()"]
        GlobalClasses["global_script_class_cache.cfg"]
    end
    
    SetIconPath -->|"stores in"| SaveGlobal
    GetIconPath -->|"reads from"| LoadPaths
    GetScriptIcon -->|"checks"| IconCache
    GetScriptIcon -->|"calls if not cached"| LoadIcon
    LoadIcon -->|"stores in"| IconCache
    SaveGlobal -->|"writes to"| GlobalClasses
    LoadPaths -->|"reads from"| GlobalClasses
```

**Script Class Metadata System**

Sources: [editor/editor_data.cpp:843-1025](), [editor/editor_data.h:244-261]()

## Undo/Redo Integration

### History ID System

Each `EditedScene` has a unique `history_id` that links it to a specific history in `EditorUndoRedoManager`. This allows the undo/redo system to maintain separate histories for each open scene.

| Method | Purpose |
|--------|---------|
| `get_current_edited_scene_history_id()` | Returns history ID of current scene |
| `get_scene_history_id(p_idx)` | Returns history ID of specific scene |
| `get_scene_history_id_from_path(p_path)` | Finds history ID by scene path |
| `set_scene_as_saved(p_idx)` | Marks scene as saved in undo/redo history |
| `is_scene_changed(p_idx)` | Checks if scene has unsaved changes by comparing version numbers |

The `last_created_scene` counter is incremented each time a new scene is added, ensuring unique history IDs across the editor session.

Sources: [editor/editor_data.cpp:414-453](), [editor/editor_data.h:228-233]()

### Inspector Hook Callbacks

EditorData manages a list of `undo_redo_callbacks` that are invoked when properties are modified in the inspector. This allows extensions to hook into the undo/redo system.

```mermaid
graph LR
    subgraph "Callback Management"
        AddCallback["add_undo_redo_inspector_hook_callback(callable)"]
        RemoveCallback["remove_undo_redo_inspector_hook_callback(callable)"]
        GetCallbacks["get_undo_redo_inspector_hook_callback()"]
    end
    
    subgraph "Callback Storage"
        CallbackVector["Vector&lt;Callable&gt;<br/>undo_redo_callbacks"]
    end
    
    subgraph "Array Element Movement"
        AddMoveFunc["add_move_array_element_function(class, callable)"]
        GetMoveFunc["get_move_array_element_function(class)"]
        MoveFuncMap["HashMap&lt;StringName, Callable&gt;<br/>move_element_functions"]
    end
    
    AddCallback -->|"appends to"| CallbackVector
    RemoveCallback -->|"removes from"| CallbackVector
    GetCallbacks -->|"returns"| CallbackVector
    
    AddMoveFunc -->|"stores in"| MoveFuncMap
    GetMoveFunc -->|"retrieves from"| MoveFuncMap
```

**Undo/Redo Hook System**

Sources: [editor/editor_data.cpp:455-480](), [editor/editor_data.h:181-187]()

## Scene Update Detection

### External File Modification

EditorData provides `check_and_update_scene()` to detect when scene files or their dependencies have been modified externally:

```mermaid
graph TB
    subgraph "Update Detection"
        CheckScene["check_and_update_scene(p_idx)"]
        FindUpdated["_find_updated_instances(root, node, checked_paths)"]
    end
    
    subgraph "Scene State Checks"
        GetSceneState["node-&gt;get_scene_inherited_state()"]
        GetInstanceState["node-&gt;get_scene_instance_state()"]
        CheckModTime["FileAccess::get_modified_time(path)"]
    end
    
    subgraph "Result"
        ReloadNeeded["Returns true if reload needed"]
    end
    
    CheckScene -->|"calls recursively"| FindUpdated
    FindUpdated -->|"gets"| GetSceneState
    FindUpdated -->|"gets"| GetInstanceState
    FindUpdated -->|"compares with"| CheckModTime
    FindUpdated -->|"determines"| ReloadNeeded
```

**Scene Update Detection Flow**

The function recursively walks the scene tree, checking the modification time of any inherited scenes or scene instances. If any file has been modified since it was last loaded, the function returns true.

Sources: [editor/editor_data.cpp:669-724]()

## Integration with EditorNode

EditorData is owned by `EditorNode` as a member variable and accessed throughout the editor:

```mermaid
graph TB
    subgraph "EditorNode Ownership"
        EditorNode["EditorNode<br/>(singleton)"]
        EditorDataMember["EditorData editor_data<br/>(member variable)"]
    end
    
    subgraph "Global Access"
        GetEditorData["EditorNode::get_editor_data()"]
        StaticAccess["EditorNode::get_singleton()-&gt;editor_data"]
    end
    
    subgraph "Used By"
        EditorSceneTabs["EditorSceneTabs"]
        InspectorDock["InspectorDock"]
        SceneTreeDock["SceneTreeDock"]
        EditorPlugins["EditorPlugin instances"]
    end
    
    EditorNode -->|"owns"| EditorDataMember
    GetEditorData -->|"returns reference to"| EditorDataMember
    StaticAccess -->|"accesses"| EditorDataMember
    
    EditorSceneTabs -->|"uses"| GetEditorData
    InspectorDock -->|"uses"| GetEditorData
    SceneTreeDock -->|"uses"| GetEditorData
    EditorPlugins -->|"uses"| GetEditorData
```

**EditorData Access Pattern**

The static method `EditorNode::get_editor_data()` provides global access to the `EditorData` instance throughout the editor codebase.

Sources: [editor/editor_node.h:257-259](), [editor/editor_node.h:752]()

## Summary

EditorData serves as the centralized state manager for the Godot editor, maintaining:

- **Multi-scene editing state** through the `EditedScene` structure and scene tab system
- **Plugin ecosystem** by tracking and coordinating all registered `EditorPlugin` instances
- **Custom type registry** enabling plugins to extend the engine with new node/resource types
- **Clipboard functionality** for property copy/paste operations
- **Script metadata** including class icons and name mappings
- **Undo/redo integration** via unique history IDs per scene and inspector callbacks

This separation of data management from UI logic (handled by `EditorNode`) enables clean architecture and makes the editor state easier to save, restore, and reason about.

Sources: [editor/editor_data.h:105-265](), [editor/editor_data.cpp:1-1025]()36:T47fb,# EditorInterface

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

EditorInterface is a singleton facade that provides a standardized API for editor plugins to interact with the Godot editor. It acts as the primary interface between [EditorPlugin](#7.4) instances and the editor's internal systems, abstracting direct access to [EditorNode](#7.1) and other editor components.

For information about the plugin system that uses EditorInterface, see [EditorPlugin System](#7.4). For details on editor initialization and lifecycle, see [EditorNode](#7.1).

**Sources:** [editor/editor_interface.h:1-136](), [doc/classes/EditorInterface.xml:1-18]()

## Architecture Overview

```mermaid
graph TB
    subgraph "Plugin Layer"
        Plugin["EditorPlugin"]
        CustomPlugin["Custom Plugin<br/>(User Code)"]
    end
    
    subgraph "Facade Layer"
        EditorInterface["EditorInterface<br/>(Singleton Facade)"]
    end
    
    subgraph "Editor Core"
        EditorNode["EditorNode<br/>(Main Editor)"]
        EditorData["EditorData<br/>(Scene State)"]
        EditorSelection["EditorSelection<br/>(Object Selection)"]
        EditorSettings["EditorSettings<br/>(Editor Config)"]
        EditorFileSystem["EditorFileSystem<br/>(File Scanning)"]
        EditorResourcePreview["EditorResourcePreview<br/>(Preview Generation)"]
        ScriptEditor["ScriptEditor<br/>(Script Editing)"]
        FileSystemDock["FileSystemDock<br/>(File Browser)"]
        EditorInspector["EditorInspector<br/>(Property Editor)"]
    end
    
    subgraph "UI Components"
        BaseControl["gui_base<br/>(Root Control)"]
        MainScreen["EditorMainScreen<br/>(2D/3D/Script)"]
        SubViewport2D["2D Viewport"]
        SubViewport3D["3D Viewport"]
    end
    
    Plugin --> EditorInterface
    CustomPlugin --> EditorInterface
    
    EditorInterface --> EditorNode
    EditorInterface --> EditorData
    EditorInterface --> EditorSelection
    EditorInterface --> EditorSettings
    EditorInterface --> EditorFileSystem
    EditorInterface --> EditorResourcePreview
    EditorInterface --> ScriptEditor
    EditorInterface --> FileSystemDock
    EditorInterface --> EditorInspector
    EditorInterface --> BaseControl
    EditorInterface --> MainScreen
    EditorInterface --> SubViewport2D
    EditorInterface --> SubViewport3D
    
    EditorNode --> EditorData
    EditorNode --> BaseControl
```

EditorInterface serves as a facade that:
- Provides stable API for plugins despite internal editor changes
- Prevents direct coupling between plugins and editor internals
- Controls access to editor functionality
- Simplifies plugin development by providing high-level operations

**Sources:** [editor/editor_interface.h:62-91](), [editor/editor_interface.cpp:65-106]()

## Singleton Access

EditorInterface is accessed as a singleton from both GDScript and C++:

```gdscript
# GDScript
var editor_interface = EditorInterface
var settings = editor_interface.get_editor_settings()
```

```cpp
// C++
EditorInterface* editor_interface = EditorInterface::get_singleton();
EditorSettings* settings = editor_interface->get_editor_settings();
```

The singleton is created by EditorNode during editor initialization and remains valid throughout the editor's lifetime.

**Sources:** [editor/editor_interface.h:65](), [editor/editor_interface.cpp:65]()

## Functional Categories

### Editor Tools Access

EditorInterface provides getters for core editor subsystems:

| Method | Returns | Purpose |
|--------|---------|---------|
| `get_command_palette()` | EditorCommandPalette | Command palette for shortcuts |
| `get_resource_filesystem()` | EditorFileSystem | File system scanning and monitoring |
| `get_editor_paths()` | EditorPaths | Editor and project path management |
| `get_resource_previewer()` | EditorResourcePreview | Resource thumbnail generation |
| `get_selection()` | EditorSelection | Currently selected objects |
| `get_editor_settings()` | EditorSettings | Editor configuration |
| `get_editor_toaster()` | EditorToaster | Toast notifications |
| `get_editor_undo_redo()` | EditorUndoRedoManager | Undo/redo operations |

**Sources:** [editor/editor_interface.cpp:76-106](), [doc/classes/EditorInterface.xml:59-149]()

### Scene Management

```mermaid
graph LR
    subgraph "Scene Operations"
        OpenScene["open_scene_from_path()"]
        SaveScene["save_scene()"]
        ReloadScene["reload_scene_from_disk()"]
        CloseScene["close_scene()"]
    end
    
    subgraph "Scene State"
        EditedScenes["edited_scene<br/>(Vector in EditorData)"]
        CurrentScene["current_edited_scene<br/>(int index)"]
    end
    
    subgraph "Scene Access"
        GetRoot["get_edited_scene_root()"]
        GetOpenScenes["get_open_scenes()"]
        MarkUnsaved["mark_scene_as_unsaved()"]
    end
    
    OpenScene --> EditedScenes
    SaveScene --> EditedScenes
    CloseScene --> EditedScenes
    EditedScenes --> CurrentScene
    CurrentScene --> GetRoot
    EditedScenes --> GetOpenScenes
    MarkUnsaved --> EditedScenes
```

Scene management methods:
- **open_scene_from_path(path)**: Opens a scene file at the given path
- **save_scene()**: Saves the current scene
- **save_scene_as(path)**: Saves the current scene to a new path
- **reload_scene_from_disk()**: Reloads current scene, discarding changes
- **close_scene()**: Closes the active scene
- **get_edited_scene_root()**: Returns the root node of the edited scene
- **get_open_scenes()**: Returns array of open scene file paths
- **mark_scene_as_unsaved()**: Marks the scene as having unsaved changes

**Sources:** [editor/editor_interface.cpp:162-237](), [doc/classes/EditorInterface.xml:177-243]()

### Resource and Node Editing

EditorInterface provides three primary editing methods:

```mermaid
graph TB
    subgraph "Edit Operations"
        EditNode["edit_node(node)"]
        EditResource["edit_resource(resource)"]
        EditScript["edit_script(script, line, col)"]
    end
    
    subgraph "Editor Systems"
        EditorNode_edit["EditorNode::edit_node()"]
        EditorNode_editRes["EditorNode::edit_resource()"]
        ScriptEditor_goto["ScriptEditor::goto_line()"]
    end
    
    subgraph "UI Updates"
        Inspector["EditorInspector<br/>(Shows properties)"]
        ScriptEditorUI["ScriptEditor UI<br/>(Shows code)"]
        Selection["EditorSelection<br/>(Updates selection)"]
    end
    
    EditNode --> EditorNode_edit
    EditResource --> EditorNode_editRes
    EditScript --> ScriptEditor_goto
    
    EditorNode_edit --> Inspector
    EditorNode_edit --> Selection
    EditorNode_editRes --> Inspector
    ScriptEditor_goto --> ScriptEditorUI
```

**Sources:** [editor/editor_interface.cpp:112-139](), [doc/classes/EditorInterface.xml:35-57]()

### UI Component Access

EditorInterface exposes editor UI components to plugins:

| Method | Returns | Description |
|--------|---------|-------------|
| `get_base_control()` | Control | Main editor window container |
| `get_editor_main_screen()` | VBoxContainer | Container for 2D/3D/Script editors |
| `get_editor_viewport_2d()` | SubViewport | 2D editor viewport |
| `get_editor_viewport_3d(idx)` | SubViewport | 3D editor viewport (0-3) |
| `get_file_system_dock()` | FileSystemDock | File system browser |
| `get_inspector()` | EditorInspector | Property inspector |
| `get_script_editor()` | ScriptEditor | Script editor panel |
| `get_editor_theme()` | Theme | Editor theme for styling |
| `get_editor_scale()` | float | Editor UI scale factor |

**Sources:** [editor/editor_interface.cpp:249-323](), [editor/editor_interface.h:38-60]()

### Dialog System

```mermaid
graph TB
    subgraph "Dialog Methods"
        PopupNode["popup_node_selector()"]
        PopupProperty["popup_property_selector()"]
        PopupQuickOpen["popup_quick_open()"]
        PopupCreateDialog["popup_create_dialog()"]
        PopupDialogCentered["popup_dialog_centered()"]
    end
    
    subgraph "Dialog Instances"
        NodeSelector["node_selector<br/>(SceneTreeDialog)"]
        PropertySelector["property_selector<br/>(PropertySelector)"]
        MethodSelector["method_selector<br/>(PropertySelector)"]
        QuickOpenDialog["EditorQuickOpenDialog"]
        CreateDialog["create_dialog<br/>(CreateDialog)"]
    end
    
    subgraph "Callback Flow"
        UserSelection["User Makes Selection"]
        CallbackInvoked["Callable Invoked"]
        PluginResponse["Plugin Handles Result"]
    end
    
    PopupNode --> NodeSelector
    PopupProperty --> PropertySelector
    PopupQuickOpen --> QuickOpenDialog
    PopupCreateDialog --> CreateDialog
    
    NodeSelector --> UserSelection
    PropertySelector --> UserSelection
    QuickOpenDialog --> UserSelection
    CreateDialog --> UserSelection
    
    UserSelection --> CallbackInvoked
    CallbackInvoked --> PluginResponse
```

Dialog methods accept a `Callable` that is invoked when the user makes a selection:
- **popup_node_selector(callback, valid_types)**: Shows node picker
- **popup_property_selector(object, callback, type_filter)**: Shows property picker
- **popup_quick_open(callback, base_type)**: Shows quick open file dialog
- **popup_create_dialog(base_type, callback)**: Shows create new resource dialog
- **popup_dialog_centered(dialog, rect)**: Centers a custom dialog

**Sources:** [editor/editor_interface.cpp:430-545](), [editor/editor_interface.h:69-79]()

### Play Mode Control

```mermaid
graph LR
    subgraph "Play Control"
        PlayMain["play_main_scene()"]
        PlayCurrent["play_current_scene()"]
        PlayCustom["play_custom_scene(path)"]
        StopPlaying["stop_playing_scene()"]
    end
    
    subgraph "EditorRunBar"
        RunBar["EditorRunBar"]
        PlayMainScene["play_main_scene()"]
        PlayCurrentScene["play_current_scene()"]
        PlayCustomScene["play_custom_scene()"]
        StopPlay["stop_playing()"]
    end
    
    subgraph "State"
        IsPlaying["is_playing_scene()"]
        GetPlayingScene["get_playing_scene()"]
    end
    
    PlayMain --> PlayMainScene
    PlayCurrent --> PlayCurrentScene
    PlayCustom --> PlayCustomScene
    StopPlaying --> StopPlay
    
    RunBar --> IsPlaying
    RunBar --> GetPlayingScene
```

**Sources:** [editor/editor_interface.cpp:141-160](), [doc/classes/EditorInterface.xml:245-285]()

## Key Method Reference

### Scene Root Access

```cpp
Node* get_edited_scene_root() const;
```

Returns the root node of the currently edited scene. Returns `nullptr` if no scene is open.

**Implementation:** [editor/editor_interface.cpp:194-196]()

### Selection Operations

```cpp
EditorSelection* get_selection() const;
```

Returns the global EditorSelection instance, which tracks currently selected objects in the editor.

**Implementation:** [editor/editor_interface.cpp:92-94]()

### Resource Inspection

```cpp
void inspect_object(Object* p_obj, const String& p_for_property = String());
```

Opens the given object in the inspector. If `p_for_property` is specified, focuses on that property.

**Implementation:** [editor/editor_interface.cpp:325-327]()

### File System Access

```cpp
String get_current_path() const;
String get_current_directory() const;
PackedStringArray get_selected_paths() const;
```

- **get_current_path()**: Returns the currently selected file/folder in FileSystemDock
- **get_current_directory()**: Returns the current directory, extracting base dir if file selected
- **get_selected_paths()**: Returns array of all selected paths in FileSystemDock

**Implementation:** [editor/editor_interface.cpp:369-385]()

## Usage Patterns

### Plugin Initialization Pattern

```cpp
class MyEditorPlugin : public EditorPlugin {
    void _enter_tree() override {
        EditorInterface* ei = get_editor_interface();
        
        // Get required editor systems
        EditorSelection* selection = ei->get_selection();
        EditorFileSystem* fs = ei->get_resource_filesystem();
        
        // Connect to signals
        selection->connect("selection_changed", 
            callable_mp(this, &MyEditorPlugin::_on_selection_changed));
        
        // Add custom UI to editor
        Control* base = ei->get_base_control();
        my_custom_panel = memnew(MyCustomPanel);
        base->add_child(my_custom_panel);
    }
};
```

### Scene Editing Pattern

```cpp
void edit_scene_node(NodePath path) {
    EditorInterface* ei = EditorInterface::get_singleton();
    Node* root = ei->get_edited_scene_root();
    
    if (root) {
        Node* target = root->get_node_or_null(path);
        if (target) {
            ei->edit_node(target);
            ei->get_selection()->clear();
            ei->get_selection()->add_node(target);
        }
    }
}
```

### Dialog with Callback Pattern

```cpp
void show_node_picker() {
    EditorInterface* ei = EditorInterface::get_singleton();
    
    TypedArray<StringName> valid_types;
    valid_types.push_back("Node2D");
    valid_types.push_back("Node3D");
    
    Callable callback = callable_mp(this, &MyPlugin::_on_node_selected);
    ei->popup_node_selector(callback, valid_types, nullptr, "Select Target Node");
}

void _on_node_selected(NodePath selected_path) {
    // Handle the selected node
}
```

**Sources:** [doc/classes/EditorPlugin.xml:1-50](), [editor/editor_interface.cpp:430-479]()

## Internal Structure

### Member Variables

```cpp
class EditorInterface : public Object {
    static EditorInterface *singleton;
    
    // Cached dialog instances
    PropertySelector *property_selector = nullptr;
    PropertySelector *method_selector = nullptr;
    SceneTreeDialog *node_selector = nullptr;
    CreateDialog *create_dialog = nullptr;
    
    // Helper methods for dialog callbacks
    void _node_selected(const NodePath &p_node_paths, const Callable &p_callback);
    void _property_selected(const String &p_property_name, const Callable &p_callback);
    void _method_selected(const String &p_property_name, const Callable &p_callback);
    void _quick_open(const String &p_file_path, const Callable &p_callback);
    void _create_dialog_item_selected(bool p_is_canceled, const Callable &p_callback);
    void _call_dialog_callback(const Callable &p_callback, const Variant &p_selected, const String &p_context);
};
```

Dialogs are lazily instantiated on first use and cached for reuse.

**Sources:** [editor/editor_interface.h:65-80](), [editor/editor_interface.cpp:430-545]()

### Delegation to EditorNode

Most EditorInterface methods delegate directly to EditorNode:

```cpp
void EditorInterface::restart_editor(bool p_save) {
    if (p_save) {
        EditorNode::get_singleton()->save_all_scenes();
    }
    EditorNode::get_singleton()->restart_editor();
}

Node* EditorInterface::get_edited_scene_root() const {
    return EditorNode::get_singleton()->get_edited_scene();
}

void EditorInterface::edit_node(Node* p_node) {
    EditorNode::get_singleton()->edit_node(p_node);
}
```

**Sources:** [editor/editor_interface.cpp:67-139]()

## Lifecycle

### Initialization

EditorInterface is created early in the editor initialization process:

1. EditorNode creates singleton instance
2. EditorInterface stores reference to EditorNode
3. Plugins access EditorInterface via `get_editor_interface()` in EditorPlugin

**Sources:** [editor/editor_node.cpp:1-8000]()

### Plugin Access

Plugins access EditorInterface through EditorPlugin base class:

```cpp
EditorInterface* EditorPlugin::get_editor_interface() const {
    return EditorInterface::get_singleton();
}
```

**Sources:** [editor/plugins/editor_plugin.h:1-150]()

### Cleanup

EditorInterface singleton persists for the entire editor lifetime and is cleaned up with EditorNode during editor shutdown.

## Preview Generation

EditorInterface provides mesh preview generation capabilities:

```cpp
TypedArray<Texture2D> make_mesh_previews(const TypedArray<Mesh>& p_meshes, int p_preview_size);
```

This method:
1. Creates temporary MeshInstance3D nodes for each mesh
2. Calculates AABB for camera positioning
3. Renders preview using editor viewport
4. Returns array of preview textures

**Implementation:** [editor/editor_interface.cpp:108-160](), [editor/editor_interface.h:83-84]()

**Sources:** [editor/editor_interface.cpp:108-160]()

## Feature Profile Integration

```cpp
String get_current_feature_profile() const;
```

Returns the name of the currently active feature profile, or empty string if using default profile. Feature profiles allow disabling editor features for simplified editing environments.

**Sources:** [editor/editor_interface.cpp:387-390](), [doc/classes/EditorInterface.xml:79-85]()

## Best Practices

1. **Always check for null**: Methods returning editor components may return null if the component is not available
2. **Use callables for dialogs**: Dialog methods require callables for result handling
3. **Don't cache references**: Editor state can change; always call getters when needed
4. **Respect editor state**: Check if scenes are open before accessing scene-specific functionality
5. **Clean up in _exit_tree()**: Remove any UI elements or connections made through EditorInterface

**Sources:** [doc/classes/EditorInterface.xml:1-300]()37:T6177,# EditorPlugin System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



The EditorPlugin system provides an extensible architecture that allows both built-in editor features and custom addons to integrate with the Godot editor. This system defines how plugins are registered, initialized, managed, and interact with editor subsystems.

For information about the EditorInterface API used by plugins to access editor functionality, see [EditorInterface](#7.3). For the overall editor architecture and orchestration, see [EditorNode](#7.1).

## Purpose and Scope

The EditorPlugin system encompasses:
- Plugin base class architecture and virtual methods
- Plugin registration and initialization mechanisms
- Plugin lifecycle management (enable/disable/enter tree/exit tree)
- Extension points for editing specific object types
- Main screen plugin support for full-screen editor modes
- Input forwarding for 2D and 3D viewports
- State persistence across editor sessions
- Communication between plugins and core editor systems

This document covers the plugin architecture itself. Specific built-in plugins (CanvasItemEditor, Node3DEditor, etc.) are documented separately in [Editor Plugins](#8).

## Architecture Overview

```mermaid
graph TB
    subgraph "Plugin Base Infrastructure"
        EditorPlugin["EditorPlugin<br/>(Base Class)"]
        EditorInterface["EditorInterface<br/>(API Facade)"]
        EditorData["EditorData<br/>(Plugin Registry)"]
    end
    
    subgraph "Plugin Management"
        EditorNode["EditorNode<br/>(Plugin Orchestrator)"]
        PluginCallbacks["Plugin Init Callbacks<br/>(Static Registration)"]
        AddonLoader["Addon Loading<br/>(Dynamic Plugins)"]
    end
    
    subgraph "Plugin Types"
        BuiltinPlugins["Built-in Plugins<br/>(Compiled Into Editor)"]
        CustomPlugins["Custom Plugins<br/>(Addons Folder)"]
        ExtensionPlugins["Extension Plugins<br/>(Per-Class Type)"]
    end
    
    subgraph "Extension Points"
        MainScreen["Main Screen API<br/>_has_main_screen()"]
        ObjectHandling["Object Handling<br/>_handles(), _edit()"]
        InputForwarding["Input Forwarding<br/>_forward_*_input()"]
        StateManagement["State Management<br/>_get_state(), _set_state()"]
    end
    
    EditorNode --> EditorData
    EditorNode --> EditorPlugin
    EditorPlugin --> EditorInterface
    
    PluginCallbacks --> BuiltinPlugins
    AddonLoader --> CustomPlugins
    EditorData --> ExtensionPlugins
    
    BuiltinPlugins --> EditorPlugin
    CustomPlugins --> EditorPlugin
    ExtensionPlugins --> EditorPlugin
    
    EditorPlugin -.implements.-> MainScreen
    EditorPlugin -.implements.-> ObjectHandling
    EditorPlugin -.implements.-> InputForwarding
    EditorPlugin -.implements.-> StateManagement
```

**Figure 1: EditorPlugin System Architecture**

Sources: [editor/plugins/editor_plugin.h:1-1200](), [editor/editor_node.h:280-286](), [editor/editor_data.h:127-130](), [editor/editor_interface.h:62-63]()

### Core Components

| Component | File Location | Responsibility |
|-----------|---------------|----------------|
| `EditorPlugin` | [editor/plugins/editor_plugin.h]() | Base class defining plugin interface and virtual methods |
| `EditorNode` | [editor/editor_node.h:280-286]() | Manages plugin lifecycle and coordinates plugin interactions |
| `EditorData` | [editor/editor_data.h:127-130]() | Stores plugin registry and maintains plugin-object associations |
| `EditorInterface` | [editor/editor_interface.h:62-63]() | Provides API facade for plugins to access editor functionality |
| `EditorPluginList` | [editor/plugins/editor_plugin_list.h]() | Helper for iterating and calling plugin methods in bulk |

Sources: [editor/plugins/editor_plugin.h:1-100](), [editor/editor_node.h:118-500](), [editor/editor_data.h:105-200]()

## Plugin Registration

The editor supports three plugin registration mechanisms:

### Built-in Plugin Registration

Built-in plugins are compiled into the editor and register via static initialization callbacks:

```mermaid
graph LR
    StaticInit["Static Initialization<br/>(_FORCE_INLINE_)"] --> RegisterCallback["register_*_types()"]
    RegisterCallback --> AddCallback["EditorNode::add_plugin_init_callback()"]
    AddCallback --> CallbackArray["plugin_init_callbacks[]"]
    
    EditorInit["EditorNode Initialization"] --> IterateCallbacks["Iterate Callbacks"]
    IterateCallbacks --> CallbackArray
    IterateCallbacks --> CreatePlugin["Callback Creates Plugin"]
    CreatePlugin --> AddPlugin["EditorNode::add_editor_plugin()"]
```

**Figure 2: Built-in Plugin Registration Flow**

Registration occurs in module registration files (e.g., `register_scene_types.cpp`) using the pattern:

```
EditorNode::add_plugin_init_callback(callback_function);
```

At editor startup, `EditorNode` iterates through registered callbacks and each callback instantiates its plugin:

Sources: [editor/editor_node.cpp:8079-8090](), [editor/editor_node.h:496-499](), [main/main.cpp:3000-3100]()

### Custom Addon Registration

Custom plugins are GDScript or C# files in `res://addons/{addon_name}/plugin.cfg` that extend `EditorPlugin`:

```mermaid
sequenceDiagram
    participant PS as ProjectSettings
    participant EN as EditorNode
    participant PL as Plugin Script
    
    EN->>PS: Check "editor_plugins/enabled"
    PS-->>EN: List of addon paths
    EN->>EN: _enable_pending_addons()
    EN->>PL: Load and instantiate script
    PL->>EN: Plugin instance created
    EN->>PL: _enter_tree()
    EN->>PL: _enable_plugin()
    EN->>EN: Store in addon_name_to_plugin
```

**Figure 3: Custom Addon Loading Sequence**

The addon system uses ProjectSettings to track enabled plugins:
- Setting: `"editor_plugins/enabled"` contains array of addon paths
- Format: `"res://addons/{name}/plugin.gd"`
- Storage: `addon_name_to_plugin` HashMap in EditorNode

Sources: [editor/editor_node.cpp:7945-8050](), [editor/editor_node.h:282-283](), [doc/classes/ProjectSettings.xml:1-100]()

### Extension Plugin Registration

Extension plugins handle editing for specific class types (e.g., GDExtension-defined classes):

```mermaid
graph TB
    ClassReg["Class Registration<br/>(GDExtension/Native)"] --> EditorData["EditorData::add_extension_editor_plugin()"]
    EditorData --> ExtPluginMap["extension_editor_plugins<br/>HashMap<StringName, EditorPlugin*>"]
    
    ObjectEdit["Edit Object Request"] --> CheckExt["Check extension_editor_plugins"]
    CheckExt --> GetPlugin["Get plugin for class type"]
    GetPlugin --> HandleEdit["Plugin handles edit"]
```

**Figure 4: Extension Plugin Registration**

Extension plugins are registered per-class-name and retrieved when objects of that type are edited.

Sources: [editor/editor_data.h:176-177](), [editor/editor_data.cpp:256-286]()

## Plugin Lifecycle

### Lifecycle States and Transitions

```mermaid
stateDiagram-v2
    [*] --> Created: new EditorPlugin()
    Created --> InTree: _enter_tree()
    InTree --> Enabled: _enable_plugin()
    
    Enabled --> Disabled: _disable_plugin()
    Disabled --> Enabled: _enable_plugin()
    
    Enabled --> OutOfTree: _exit_tree()
    Disabled --> OutOfTree: _exit_tree()
    InTree --> OutOfTree: _exit_tree()
    
    OutOfTree --> [*]: delete
    
    note right of Created
        Plugin constructed but
        not yet added to tree
    end note
    
    note right of InTree
        Added to scene tree
        but not yet active
    end note
    
    note right of Enabled
        Fully active and
        handling editor events
    end note
```

**Figure 5: Plugin Lifecycle State Machine**

Sources: [doc/classes/EditorPlugin.xml:34-52](), [editor/plugins/editor_plugin.cpp:1-100]()

### Lifecycle Methods

| Method | When Called | Purpose |
|--------|-------------|---------|
| Constructor | Plugin instantiation | Initialize member variables |
| `_enter_tree()` | Added to SceneTree | Add UI elements, connect signals |
| `_enable_plugin()` | User enables addon or editor starts | Activate plugin functionality |
| `_disable_plugin()` | User disables addon | Deactivate and cleanup temporary state |
| `_exit_tree()` | Removed from SceneTree | Remove UI elements, disconnect signals |
| Destructor | Plugin deletion | Final cleanup |

**Key Distinction**: `_enter_tree()/_exit_tree()` manage presence in scene tree, while `_enable_plugin()/_disable_plugin()` manage activation state. A plugin can be in the tree but disabled.

Sources: [doc/classes/EditorPlugin.xml:34-52](), [editor/plugins/editor_plugin.h:100-200]()

### Plugin Management in EditorNode

```mermaid
graph TB
    AddPlugin["add_editor_plugin(plugin)"] --> AddToVector["editor_plugins.push_back()"]
    AddToVector --> AddToData["editor_data.add_editor_plugin()"]
    AddToData --> CallEnterTree["plugin->_enter_tree()"]
    
    RemovePlugin["remove_editor_plugin(plugin)"] --> CallExitTree["plugin->_exit_tree()"]
    CallExitTree --> RemoveFromData["editor_data.remove_editor_plugin()"]
    RemoveFromData --> RemoveFromVector["editor_plugins.erase()"]
    RemoveFromVector --> DeletePlugin["memdelete(plugin)"]
    
    EnableAddon["Enable Addon"] --> LoadScript["Load plugin.gd"]
    LoadScript --> InstantiateScript["Instantiate EditorPlugin"]
    InstantiateScript --> AddPlugin
    AddPlugin --> CallEnable["plugin->_enable_plugin()"]
    
    DisableAddon["Disable Addon"] --> CallDisable["plugin->_disable_plugin()"]
    CallDisable --> RemovePlugin
```

**Figure 6: Plugin Management Operations**

EditorNode maintains two collections:
- `Vector<EditorPlugin *> editor_plugins` - All loaded plugins
- `HashMap<String, EditorPlugin *> addon_name_to_plugin` - Addon plugins by name

Sources: [editor/editor_node.cpp:8079-8150](), [editor/editor_node.h:280-286](), [editor/editor_data.cpp:170-180]()

## Extension Points

EditorPlugin provides numerous virtual methods that plugins override to customize editor behavior:

### Object Handling Extension Points

```mermaid
graph LR
    ObjectSelected["Object Selected<br/>in Editor"] --> CheckHandles["For each plugin:<br/>_handles(object)"]
    CheckHandles --> YesHandles{Plugin<br/>handles?}
    YesHandles -->|Yes| CallEdit["plugin->_edit(object)"]
    YesHandles -->|No| NextPlugin["Try next plugin"]
    
    CallEdit --> MakeVisible["plugin->_make_visible(true)"]
    MakeVisible --> UpdateInspector["Update Inspector"]
    
    ObjectDeselected["Object Deselected"] --> CallClear["plugin->_clear()"]
    CallClear --> HideUI["plugin->_make_visible(false)"]
```

**Figure 7: Object Handling Flow**

Key methods:
- `_handles(object: Object) -> bool` - Return true if plugin can edit this object type
- `_edit(object: Object)` - Begin editing the object
- `_make_visible(visible: bool)` - Show/hide plugin's UI
- `_clear()` - Reset plugin state when object is deselected

Sources: [doc/classes/EditorPlugin.xml:40-46](), [editor/editor_node.cpp:5400-5450](), [editor/plugins/editor_plugin.cpp:200-300]()

### Main Screen Extension Points

Main screen plugins provide full-screen editor modes (like "2D", "3D", "Script"):

| Method | Return Type | Purpose |
|--------|-------------|---------|
| `_has_main_screen()` | `bool` | Indicates plugin provides a main screen |
| `_make_visible(visible)` | `void` | Called when main screen becomes visible/hidden |
| `_get_plugin_name()` | `String` | Name shown in main screen selector |
| `_get_plugin_icon()` | `Texture2D` | Icon shown in main screen selector |

Main screen lifecycle:
1. User clicks main screen button
2. Current main screen plugin receives `_make_visible(false)`
3. New main screen plugin receives `_make_visible(true)`
4. Plugin shows its main UI control

Sources: [doc/classes/EditorPlugin.xml:113-130](), [editor/editor_main_screen.cpp:1-200]()

### Input Forwarding Extension Points

Plugins can intercept input in 2D and 3D viewports:

```mermaid
graph TB
    Input2D["2D Viewport Input"] --> ForwardCanvas["_forward_canvas_gui_input(event)"]
    ForwardCanvas --> ConsumeOrPass{Return true<br/>to consume?}
    ConsumeOrPass -->|true| StopPropagation["Input consumed"]
    ConsumeOrPass -->|false| NextPlugin2D["Forward to next plugin"]
    
    Input3D["3D Viewport Input"] --> Forward3D["_forward_3d_gui_input(camera, event)"]
    Forward3D --> ReturnValue{Return value?}
    ReturnValue -->|AFTER_GUI_INPUT_STOP| Stop["Stop propagation"]
    ReturnValue -->|AFTER_GUI_INPUT_PASS| NextPlugin3D["Forward to next plugin"]
    
    DrawRequest["Viewport Draw"] --> DrawOver2D["_forward_canvas_draw_over_viewport()"]
    DrawOver2D --> DrawOver3D["_forward_3d_draw_over_viewport()"]
```

**Figure 8: Input Forwarding System**

Input forwarding methods:
- **2D**: `_forward_canvas_gui_input(event: InputEvent) -> bool`
- **3D**: `_forward_3d_gui_input(camera: Camera3D, event: InputEvent) -> AfterGUIInput`
- **2D Draw**: `_forward_canvas_draw_over_viewport(overlay: Control)`
- **3D Draw**: `_forward_3d_draw_over_viewport(overlay: Control)`

Force draw variants (`_forward_*_force_draw_over_viewport`) draw on top of everything when enabled via `set_force_draw_over_forwarding_enabled()`.

Sources: [doc/classes/EditorPlugin.xml:54-100](), [editor/plugins/editor_plugin.cpp:400-500]()

### Build and Apply Extension Points

| Method | When Called | Purpose |
|--------|-------------|---------|
| `_build()` | Before project runs | Perform build steps, return false to abort run |
| `_apply_changes()` | Before saving/switching tabs | Apply pending changes to edited objects |
| `_clear()` | Object deselected | Reset plugin state |
| `_save_external_data()` | Scene/resource saved | Save plugin-specific external data |

Sources: [doc/classes/EditorPlugin.xml:14-33]()

## Plugin State Management

### State Persistence

Plugins can save and restore their state across editor sessions:

```mermaid
sequenceDiagram
    participant EN as EditorNode
    participant PL as EditorPlugin
    participant CF as ConfigFile
    
    Note over EN,CF: Saving State
    EN->>PL: _get_state()
    PL-->>EN: Dictionary with state
    EN->>CF: Write to editor_layout.cfg
    
    Note over EN,CF: Loading State
    EN->>CF: Read from editor_layout.cfg
    CF-->>EN: State Dictionary
    EN->>PL: _set_state(state)
    PL->>PL: Restore UI and data
```

**Figure 9: Plugin State Persistence**

State methods:
- `_get_state() -> Dictionary` - Return plugin state to save
- `_set_state(state: Dictionary)` - Restore plugin from saved state

State is saved to:
- **Global state**: `~/.config/godot/editor_layouts/{layout_name}.cfg`
- **Scene-specific state**: Stored with scene data in EditorData

Sources: [editor/editor_data.cpp:312-354](), [editor/editor_node.cpp:6500-6600](), [doc/classes/EditorPlugin.xml:107-112]()

### Per-Scene State

EditorData maintains per-scene plugin states:

```mermaid
graph TB
    EditedScene["EditedScene Structure"] --> EditorStates["editor_states: Dictionary"]
    EditorStates --> PluginState1["'PluginA': {state_data}"]
    EditorStates --> PluginState2["'PluginB': {state_data}"]
    EditorStates --> PluginState3["'PluginC': {state_data}"]
    
    SceneSwitch["Switch Scene"] --> GetStates["get_editor_plugin_states()"]
    GetStates --> SaveCurrent["Save current scene states"]
    SaveCurrent --> LoadTarget["Load target scene states"]
    LoadTarget --> SetStates["set_editor_plugin_states()"]
    SetStates --> CallSetState["For each plugin:<br/>_set_state()"]
```

**Figure 10: Per-Scene State Management**

Each `EditedScene` in EditorData contains:
- `Dictionary editor_states` - Maps plugin names to state dictionaries
- `int history_id` - Unique identifier for undo/redo

Sources: [editor/editor_data.h:113-125](), [editor/editor_data.cpp:312-354]()

## Plugin-Object Association

EditorNode tracks which plugins are actively editing which objects:

```mermaid
graph TB
    ObjectMap["active_plugins<br/>HashMap<ObjectID, HashSet<EditorPlugin*>>"]
    
    EditObject["_edit_current()"] --> CheckHandlers["For each plugin:<br/>_handles(object)"]
    CheckHandlers --> AddToSet["Add plugin to<br/>active_plugins[object_id]"]
    AddToSet --> CallEdit["plugin->_edit(object)"]
    
    PluginOver["_plugin_over_edit(plugin, object)"] --> GetActive["active_plugins[object_id]"]
    GetActive --> MarkOver["Mark plugin as over"]
    
    RemoveObject["Object deleted"] --> ClearActive["Remove from active_plugins"]
```

**Figure 11: Plugin-Object Association Tracking**

The `active_plugins` HashMap enables:
- Tracking which plugins are editing each object
- Preventing duplicate edit calls
- Proper cleanup when objects are deleted
- "Over" state management (when plugin is overridden by another)

Sources: [editor/editor_node.h:284](), [editor/editor_node.cpp:5400-5500]()

## Plugin Communication

### Accessing Editor Systems

Plugins use `EditorInterface` (accessible via `get_editor_interface()`) to access editor systems:

```mermaid
graph LR
    Plugin["EditorPlugin"] --> Interface["EditorInterface"]
    
    Interface --> Settings["get_editor_settings()"]
    Interface --> Selection["get_selection()"]
    Interface --> FileSystem["get_resource_filesystem()"]
    Interface --> Preview["get_resource_previewer()"]
    Interface --> UndoRedo["get_editor_undo_redo()"]
    Interface --> Viewport["get_editor_viewport_*()"]
    Interface --> Base["get_base_control()"]
```

**Figure 12: Plugin Access to Editor Systems**

Common patterns:
- **Settings**: `get_editor_interface()->get_editor_settings()->get_setting()`
- **Selection**: `get_editor_interface()->get_selection()->get_selected_nodes()`
- **Undo/Redo**: `get_editor_interface()->get_editor_undo_redo()->create_action()`

Sources: [editor/editor_interface.h:60-140](), [editor/plugins/editor_plugin.h:300-400](), [doc/classes/EditorInterface.xml:1-300]()

### Adding UI Elements

Plugins can add UI to various editor locations:

| Method | Location | Use Case |
|--------|----------|----------|
| `add_control_to_dock()` | Dock slots (left/right/bottom) | Persistent tool panels |
| `add_control_to_bottom_panel()` | Bottom panel (with tabs) | Contextual output/tools |
| `add_control_to_container()` | Specific editor containers | Custom inspector sections |
| `add_tool_menu_item()` | Project menu | Custom menu actions |
| `add_tool_submenu_item()` | Project menu | Submenu with actions |

**Dock Slots**:
- `DOCK_SLOT_LEFT_UL`, `DOCK_SLOT_LEFT_BL` (left upper/lower)
- `DOCK_SLOT_LEFT_UR`, `DOCK_SLOT_LEFT_BR` (right upper/lower)
- `DOCK_SLOT_RIGHT_UL`, `DOCK_SLOT_RIGHT_BL` (right upper/lower)
- `DOCK_SLOT_RIGHT_UR`, `DOCK_SLOT_RIGHT_BR` (right upper/lower)

Sources: [doc/classes/EditorPlugin.xml:200-350](), [editor/plugins/editor_plugin.cpp:600-800]()

### Signals and Notifications

Plugins can respond to editor events via signals and virtual methods:

**Common Signals** (from EditorInterface):
- `resource_saved(resource: Resource)` - Resource was saved
- `scene_changed(scene_root: Node)` - Active scene changed
- `scene_closed(filepath: String)` - Scene was closed

**Notification Methods**:
- `_edited_scene_changed()` - Current edited scene changed
- `_scene_changed(scene_root: Node)` - Same as signal
- `_resource_saved(resource: Resource)` - Resource was saved
- `_scene_saved(filepath: String)` - Scene was saved to file

Sources: [editor/plugins/editor_plugin.h:200-300](), [editor/editor_data.cpp:356-373](), [doc/classes/EditorPlugin.xml:400-450]()

## Plugin Categories

### Dock Plugins

Plugins that add persistent tool panels to editor docks:

```
extends EditorPlugin

var dock

func _enter_tree():
    dock = preload("res://addons/my_plugin/my_dock.tscn").instantiate()
    add_control_to_dock(DOCK_SLOT_LEFT_UL, dock)

func _exit_tree():
    remove_control_from_docks(dock)
    dock.free()
```

### Bottom Panel Plugins

Plugins that add tabbed panels to the bottom of the editor:

```
extends EditorPlugin

var bottom_panel

func _enter_tree():
    bottom_panel = preload("res://addons/my_plugin/panel.tscn").instantiate()
    add_control_to_bottom_panel(bottom_panel, "My Tool")

func _exit_tree():
    remove_control_from_bottom_panel(bottom_panel)
    bottom_panel.free()
```

### Inspector Plugins

Plugins that customize the inspector for specific property types (uses `EditorInspectorPlugin`, a separate system).

### Import Plugins

Plugins that handle importing custom file formats (uses `EditorImportPlugin`, a separate system).

Sources: [doc/classes/EditorPlugin.xml:1-50]()

## Plugin Discovery and Loading

### Built-in Plugin Discovery

```mermaid
graph TB
    Compile["Editor Compilation"] --> StaticInit["Static Initializers Run"]
    StaticInit --> RegisterCallbacks["Register init callbacks"]
    RegisterCallbacks --> CallbackArray["plugin_init_callbacks array"]
    
    EditorStart["EditorNode::_ready()"] --> IterateCallbacks["Iterate callback array"]
    IterateCallbacks --> CallInit["Call each init function"]
    CallInit --> CreatePlugin["Init creates plugin instance"]
    CreatePlugin --> AddPlugin["add_editor_plugin()"]
```

**Figure 13: Built-in Plugin Discovery**

Built-in plugins register during static initialization before `main()`. Callbacks are stored in `plugin_init_callbacks[MAX_INIT_CALLBACKS]` array.

Sources: [editor/editor_node.cpp:8079-8090](), [editor/editor_node.h:496-499](), [main/main.cpp:2800-2900]()

### Addon Discovery

```mermaid
graph TB
    EditorStart["Editor Startup"] --> CheckSettings["Check ProjectSettings<br/>'editor_plugins/enabled'"]
    CheckSettings --> GetList["Get list of enabled addons"]
    GetList --> StoreList["pending_addons list"]
    
    FirstIdle["First Idle Frame"] --> EnablePending["_enable_pending_addons()"]
    EnablePending --> ForEach["For each addon path"]
    ForEach --> CheckExists["FileAccess::exists(path)"]
    CheckExists --> LoadScript["ResourceLoader::load(path)"]
    LoadScript --> Instantiate["script->instance()"]
    Instantiate --> AddToMap["addon_name_to_plugin[name] = plugin"]
    AddToMap --> AddPlugin["add_editor_plugin(plugin)"]
```

**Figure 14: Addon Discovery and Loading**

Addon loading is deferred to first idle frame to ensure editor is fully initialized. Failed addons are removed from enabled list.

Sources: [editor/editor_node.cpp:7945-8050](), [editor/editor_node.h:282-284]()

## Plugin List Management

EditorNode uses `EditorPluginList` for efficient bulk operations:

```mermaid
graph LR
    EditorPluginList["EditorPluginList"] --> ForwardInput["forward_input()"]
    EditorPluginList --> ForwardDraw["forward_canvas_draw_over_viewport()"]
    EditorPluginList --> ForwardForce["forward_force_draw_over_viewport()"]
    
    ForwardInput --> IteratePlugins["Iterate plugin list"]
    IteratePlugins --> CallMethod["Call forwarding method"]
    CallMethod --> CheckReturn["Check return value"]
    CheckReturn --> ContinueOrStop{Continue?}
```

**Figure 15: EditorPluginList Bulk Operations**

EditorNode maintains specialized lists:
- `editor_plugins_force_input_forwarding` - Plugins that force input handling
- `editor_plugins_force_over` - Plugins that force draw over
- `editor_plugins_over` - Plugins with draw over capabilities

Sources: [editor/plugins/editor_plugin_list.h:1-100](), [editor/editor_node.h:266-268]()

---

**Summary**: The EditorPlugin system provides a comprehensive framework for extending the Godot editor through virtual methods, state management, and integration points. Plugins can be built-in (compiled) or custom (addons), and they communicate with the editor through EditorInterface while being managed by EditorNode and EditorData.

Sources: [editor/plugins/editor_plugin.h:1-1200](), [editor/plugins/editor_plugin.cpp:1-1500](), [editor/editor_node.cpp:5000-8200](), [doc/classes/EditorPlugin.xml:1-600]()38:T4a4c,# Scene Management

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/config/project_settings.cpp](core/config/project_settings.cpp)
- [core/config/project_settings.h](core/config/project_settings.h)
- [doc/classes/EditorCommandPalette.xml](doc/classes/EditorCommandPalette.xml)
- [doc/classes/EditorInterface.xml](doc/classes/EditorInterface.xml)
- [doc/classes/EditorPlugin.xml](doc/classes/EditorPlugin.xml)
- [doc/classes/EditorSettings.xml](doc/classes/EditorSettings.xml)
- [doc/classes/ProjectSettings.xml](doc/classes/ProjectSettings.xml)
- [editor/editor_data.cpp](editor/editor_data.cpp)
- [editor/editor_data.h](editor/editor_data.h)
- [editor/editor_interface.cpp](editor/editor_interface.cpp)
- [editor/editor_interface.h](editor/editor_interface.h)
- [editor/editor_node.cpp](editor/editor_node.cpp)
- [editor/editor_node.h](editor/editor_node.h)
- [main/main.cpp](main/main.cpp)
- [main/main.h](main/main.h)
- [modules/gdscript/tests/gdscript_test_runner.h](modules/gdscript/tests/gdscript_test_runner.h)
- [modules/gdscript/tests/gdscript_test_runner_suite.h](modules/gdscript/tests/gdscript_test_runner_suite.h)
- [tests/core/config/test_project_settings.h](tests/core/config/test_project_settings.h)

</details>



## Purpose and Scope

This document describes the scene management system in the Godot editor, which handles loading, saving, and managing multiple scene files within the editor interface. This includes the tab system for switching between scenes, modification tracking to detect unsaved changes, and the workflows for opening and closing scenes.

For information about the scene tree data structure and node hierarchy itself, see [Node Hierarchy](#4.1). For information about packed scene resources, see [Resource System](#5). For the overall editor architecture and plugin system, see [EditorNode](#7.1) and [EditorPlugin System](#7.4).

## Overview

The scene management system enables users to work with multiple scene files simultaneously in the editor. Each open scene is represented by a tab, and the system tracks which scene is currently being edited, whether scenes have unsaved modifications, and manages the workflow for loading and saving scene files through the resource system.

The system is primarily implemented through three components:
- `EditorNode`: The main editor singleton that orchestrates scene operations
- `EditorData`: Stores the state of all open scenes
- `EditorSceneTabs`: UI component for displaying and switching between scene tabs

```mermaid
graph TB
    User["User Actions"]
    EditorNode["EditorNode<br/>(Main Orchestrator)"]
    EditorData["EditorData<br/>(Scene State Storage)"]
    EditorSceneTabs["EditorSceneTabs<br/>(Tab UI)"]
    ResourceLoader["ResourceLoader<br/>(Load .tscn files)"]
    ResourceSaver["ResourceSaver<br/>(Save .tscn files)"]
    EditorUndoRedo["EditorUndoRedoManager<br/>(Modification Tracking)"]
    
    User --> EditorNode
    EditorNode --> EditorData
    EditorNode --> EditorSceneTabs
    EditorNode --> ResourceLoader
    EditorNode --> ResourceSaver
    EditorNode --> EditorUndoRedo
    
    EditorSceneTabs --> EditorNode
    EditorData -.->|"Stores EditedScene[]"| EditedScene["EditedScene Struct<br/>- root: Node*<br/>- path: String<br/>- file_modified_time<br/>- editor_states<br/>- selection<br/>- history"]
```

Sources: [editor/editor_node.h:118-660](), [editor/editor_data.h:105-230]()

## Core Data Structures

### EditedScene Structure

Each open scene in the editor is represented by an `EditedScene` struct stored in `EditorData`. This structure maintains all the necessary state for a scene being edited:

| Field | Type | Purpose |
|-------|------|---------|
| `root` | `Node*` | Pointer to the root node of the scene tree |
| `path` | `String` | File system path to the scene file (e.g., "res://level.tscn") |
| `file_modified_time` | `uint64_t` | Last modification timestamp for detecting external changes |
| `editor_states` | `Dictionary` | Plugin-specific state (camera positions, selections, etc.) |
| `selection` | `List<Node*>` | Currently selected nodes in the scene tree |
| `history_stored` | `Vector<HistoryElement>` | Undo/redo history for navigation |
| `history_current` | `int` | Current position in history |
| `custom_state` | `Dictionary` | Additional custom state storage |
| `live_edit_root` | `NodePath` | Root path for live editing |
| `history_id` | `int` | Unique identifier for undo/redo manager |
| `last_checked_version` | `uint64_t` | Version number for change detection |

Sources: [editor/editor_data.h:113-125]()

### EditorData Scene Management

`EditorData` maintains a vector of `EditedScene` structs and tracks the currently active scene:

```mermaid
graph LR
    EditorData["EditorData"]
    EditedSceneVector["edited_scene: Vector&lt;EditedScene&gt;"]
    CurrentIndex["current_edited_scene: int"]
    
    EditorData --> EditedSceneVector
    EditorData --> CurrentIndex
    
    EditedSceneVector --> Scene0["EditedScene[0]<br/>path: 'res://main.tscn'<br/>root: Node*"]
    EditedSceneVector --> Scene1["EditedScene[1]<br/>path: 'res://level.tscn'<br/>root: Node*"]
    EditedSceneVector --> Scene2["EditedScene[2]<br/>path: 'res://ui.tscn'<br/>root: Node*"]
    
    CurrentIndex -.->|"Points to index"| Scene1
```

Sources: [editor/editor_data.h:142-144](), [editor/editor_data.cpp:405-538]()

## Scene Loading Flow

### Loading Process

When a scene is loaded, either through the File menu, recent scenes, or programmatically, the following sequence occurs:

```mermaid
sequenceDiagram
    participant U as User/Plugin
    participant EN as EditorNode
    participant ED as EditorData
    participant RL as ResourceLoader
    participant PS as PackedScene
    
    U->>EN: open_request(path)
    EN->>EN: Check if already open
    alt Scene already open
        EN->>EN: _set_current_scene(index)
    else Scene not open
        EN->>RL: load(path)
        RL->>PS: Load .tscn file
        PS-->>RL: PackedScene resource
        RL-->>EN: Ref<PackedScene>
        EN->>PS: instantiate()
        PS-->>EN: Node* root
        EN->>ED: add_edited_scene(root)
        ED->>ED: Store EditedScene
        EN->>EN: _set_current_scene(new_index)
        EN->>EN: Notify plugins
    end
    EN->>U: Scene loaded/switched
```

**Key Methods:**

- `EditorNode::open_request(path)` - Entry point for opening scenes ([editor/editor_node.cpp:2934-2971]())
- `EditorNode::load_scene(path)` - Core loading logic ([editor/editor_node.cpp:3059-3206]())
- `EditorData::add_edited_scene(root)` - Adds scene to tracked list ([editor/editor_data.cpp:416-439]())
- `ResourceLoader::load(path)` - Loads the PackedScene resource ([core/io/resource_loader.cpp]())

### Scene Switching

Switching between already-open scenes is handled by updating the current scene index:

```mermaid
graph TD
    SetCurrentScene["_set_current_scene(index)"]
    SaveEditorState["_save_editor_states(old_path, old_idx)"]
    UpdateEditorData["editor_data.save_edited_scene_state()"]
    ChangeScene["editor_data.set_edited_scene(index)"]
    RestoreState["_load_editor_plugin_states_from_config()"]
    NotifyPlugins["notify_scene_changed()"]
    UpdateUI["Update scene root, title, etc."]
    
    SetCurrentScene --> SaveEditorState
    SaveEditorState --> UpdateEditorData
    UpdateEditorData --> ChangeScene
    ChangeScene --> RestoreState
    RestoreState --> NotifyPlugins
    NotifyPlugins --> UpdateUI
```

Sources: [editor/editor_node.cpp:3318-3390](), [editor/editor_data.cpp:540-598]()

## Scene Saving Flow

### Save Process

Scene saving handles multiple scenarios: saving the current scene, saving all scenes, and saving with a new file name (Save As):

```mermaid
sequenceDiagram
    participant U as User
    participant EN as EditorNode
    participant ED as EditorData
    participant RS as ResourceSaver
    participant PS as PackedScene
    
    U->>EN: SCENE_SAVE_SCENE menu action
    EN->>EN: _menu_option(SCENE_SAVE_SCENE)
    
    alt Scene has no path
        EN->>EN: Show "Save Scene As" dialog
        U->>EN: Select path
    end
    
    EN->>EN: _save_scene(path, idx)
    EN->>ED: get_edited_scene_root(idx)
    ED-->>EN: Node* root
    EN->>PS: Create PackedScene
    EN->>PS: pack(root)
    PS-->>EN: OK/Error
    EN->>RS: save(path, packed_scene)
    RS-->>EN: OK/Error
    
    alt Save successful
        EN->>ED: set_scene_path(idx, path)
        EN->>EN: Clear unsaved flag
        EN->>EN: Update title
        EN->>EN: Notify plugins
    else Save failed
        EN->>U: Show error dialog
    end
```

**Key Save Methods:**

| Method | Purpose |
|--------|---------|
| `_save_scene(path, idx)` | Saves a specific scene by index ([editor/editor_node.cpp:3482-3673]()) |
| `_save_all_scenes()` | Iterates through all scenes and saves modified ones ([editor/editor_node.cpp:3675-3696]()) |
| `_save_external_resources()` | Saves external resources referenced by the scene ([editor/editor_node.cpp:3415-3480]()) |

### External Resource Handling

When saving a scene, the editor must also handle external resources that the scene depends on. The system uses `_find_and_save_resource()` and related methods to recursively find and save modified sub-resources:

```mermaid
graph TD
    SaveScene["_save_scene(path, idx)"]
    SaveExternal["_save_external_resources()"]
    FindResources["_find_and_save_resource(resource)"]
    CheckModified{"Resource<br/>modified?"}
    SaveResource["ResourceSaver::save(resource)"]
    Recurse["Process sub-resources"]
    
    SaveScene --> SaveExternal
    SaveExternal --> FindResources
    FindResources --> CheckModified
    CheckModified -->|Yes| SaveResource
    CheckModified -->|No| Recurse
    SaveResource --> Recurse
    Recurse --> FindResources
```

Sources: [editor/editor_node.cpp:3415-3480]()

## Scene Tab Management

### Tab System Architecture

The scene tab system is implemented through `EditorSceneTabs`, which provides the UI for switching between open scenes. Each tab represents one `EditedScene` in `EditorData`:

```mermaid
graph TB
    TabBar["EditorSceneTabs<br/>(TabBar UI)"]
    TabClick["Tab Click Event"]
    EditorNode["EditorNode"]
    SetScene["_set_current_scene(idx)"]
    
    TabBar --> TabClick
    TabClick --> EditorNode
    EditorNode --> SetScene
    
    Tab0["Tab 0: main.tscn"]
    Tab1["Tab 1: level.tscn (*)"]
    Tab2["Tab 2: ui.tscn"]
    
    TabBar -.-> Tab0
    TabBar -.-> Tab1
    TabBar -.-> Tab2
    
    Note["(*) indicates unsaved"]
```

**Tab Operations:**

- **Add Tab**: When a scene is loaded, `EditorData::add_edited_scene()` is called, and a new tab is created
- **Switch Tab**: Clicking a tab calls `_set_current_scene(index)` to change the active scene
- **Close Tab**: Right-click menu or close button triggers `_scene_tab_closed(index)`

Sources: [editor/scene/editor_scene_tabs.h](), [editor/editor_node.cpp:3698-3784]()

### Scene Tab Closing

Closing a scene tab involves checking for unsaved changes and potentially showing a confirmation dialog:

```mermaid
graph TD
    CloseTab["_scene_tab_closed(tab_index)"]
    CheckUnsaved{"Has unsaved<br/>changes?"}
    ShowConfirm["Show save confirmation dialog"]
    UserChoice{"User choice?"}
    SaveScene["Save scene"]
    RemoveScene["_remove_scene(index)"]
    CancelClose["Cancel close"]
    
    CloseTab --> CheckUnsaved
    CheckUnsaved -->|Yes| ShowConfirm
    CheckUnsaved -->|No| RemoveScene
    ShowConfirm --> UserChoice
    UserChoice -->|Save| SaveScene
    UserChoice -->|Discard| RemoveScene
    UserChoice -->|Cancel| CancelClose
    SaveScene --> RemoveScene
```

**Close Confirmation Dialog:**

When closing a scene with unsaved changes, `_prepare_save_confirmation_popup()` prepares a dialog that shows:
- The scene name that will be closed
- Options: Save, Don't Save, Cancel
- List of specific changes if available

Sources: [editor/editor_node.cpp:3698-3784](), [editor/editor_node.cpp:1929-1967]()

## Modification Tracking

### Unsaved Changes Detection

The editor tracks modifications to detect when scenes have unsaved changes. This is done through integration with the undo/redo system:

```mermaid
graph LR
    UserEdit["User Edits Scene<br/>(Move node, change property, etc.)"]
    UndoRedo["EditorUndoRedoManager<br/>creates action"]
    UpdateCache["_update_unsaved_cache()"]
    CheckHistory{"History<br/>unsaved?"}
    UpdateFlag["Set unsaved_cache = true"]
    UpdateTitle["_update_title()<br/>Show (*) in title"]
    
    UserEdit --> UndoRedo
    UndoRedo --> UpdateCache
    UpdateCache --> CheckHistory
    CheckHistory -->|Yes| UpdateFlag
    UpdateFlag --> UpdateTitle
```

**Key Methods:**

- `_update_unsaved_cache()` - Checks if current scene or global history is unsaved ([editor/editor_node.cpp:379-387]())
- `EditorUndoRedoManager::is_history_unsaved(id)` - Returns true if history has uncommitted changes
- `_update_title()` - Updates window title to show (*) prefix when unsaved ([editor/editor_node.cpp:361-377]())

### Per-Scene History Tracking

Each scene maintains its own undo/redo history through a unique `history_id`. This allows the editor to track modifications per scene independently:

```mermaid
graph TB
    Scene0["Scene 0: main.tscn<br/>history_id: 1"]
    Scene1["Scene 1: level.tscn<br/>history_id: 2"]
    Scene2["Scene 2: ui.tscn<br/>history_id: 3"]
    
    UndoRedoMgr["EditorUndoRedoManager"]
    GlobalHistory["GLOBAL_HISTORY: 0"]
    History1["History ID 1"]
    History2["History ID 2"]
    History3["History ID 3"]
    
    Scene0 -.->|"Uses"| History1
    Scene1 -.->|"Uses"| History2
    Scene2 -.->|"Uses"| History3
    
    UndoRedoMgr --> GlobalHistory
    UndoRedoMgr --> History1
    UndoRedoMgr --> History2
    UndoRedoMgr --> History3
```

Sources: [editor/editor_data.h:123](), [editor/editor_node.cpp:379-387](), [editor/editor_undo_redo_manager.cpp]()

## Scene State Persistence

### Editor States

Each scene stores editor-specific state in the `editor_states` Dictionary. This includes state from editor plugins like:
- Camera positions and angles (3D editor)
- Zoom and pan positions (2D editor)
- Script editor cursor positions and open scripts
- Inspector scroll positions

**State Saving Process:**

```mermaid
sequenceDiagram
    participant EN as EditorNode
    participant ED as EditorData
    participant Plugins as EditorPlugins
    
    EN->>EN: Scene switch triggered
    EN->>EN: _save_editor_states(path, idx)
    EN->>Plugins: get_editor_plugin_states()
    loop For each plugin
        Plugins->>Plugins: get_state()
    end
    Plugins-->>EN: Dictionary of states
    EN->>ED: set_scene_editor_states(idx, states)
    ED->>ED: Store in edited_scene[idx].editor_states
```

**State Restoration:**

When switching back to a scene, `_load_editor_plugin_states_from_config()` restores the saved state to each plugin.

Sources: [editor/editor_node.cpp:4154-4174](), [editor/editor_data.cpp:312-354]()

## File System Integration

### Detecting External Changes

The editor monitors scene files for external modifications (e.g., changes from version control or external editors). This is tracked through `file_modified_time`:

```mermaid
graph TD
    CheckTimer["scan_changes_timer fires"]
    CheckFiles["Check all open scenes"]
    FileCheck{"file_modified_time<br/>!= disk time?"}
    ShowDialog["Show 'file changed on disk' dialog"]
    UserChoice{"User choice?"}
    ReloadScene["Reload scene from disk"]
    KeepEdited["Keep current version"]
    
    CheckTimer --> CheckFiles
    CheckFiles --> FileCheck
    FileCheck -->|Yes| ShowDialog
    ShowDialog --> UserChoice
    UserChoice -->|Reload| ReloadScene
    UserChoice -->|Keep| KeepEdited
```

The `disk_changed` confirmation dialog shows which files have changed and allows the user to choose whether to reload them or keep the current editor version.

Sources: [editor/editor_node.cpp:4434-4517](), [editor/editor_node.h:432-436]()

## API and Plugin Interface

### EditorInterface Methods

Plugins and scripts can interact with the scene management system through `EditorInterface`:

| Method | Purpose |
|--------|---------|
| `open_scene_from_path(path)` | Open a scene file |
| `reload_scene_from_path(path)` | Reload the current scene |
| `save_scene()` | Save the currently active scene |
| `save_scene_as(path)` | Save current scene with a new path |
| `get_edited_scene_root()` | Get the root node of the current scene |
| `set_main_screen_editor(name)` | Switch to a specific editor (2D, 3D, Script) |
| `close_scene()` | Close the current scene |

Sources: [editor/editor_interface.cpp:211-290](), [doc/classes/EditorInterface.xml:22-48]()

### Scene Change Notifications

Plugins are notified of scene changes through the `EditorPlugin` notification system:

```mermaid
graph LR
    SceneChange["Scene changed"]
    NotifyPlugins["EditorData::notify_edited_scene_changed()"]
    PluginLoop["For each plugin"]
    EditedSceneChanged["plugin->edited_scene_changed()"]
    NotifySceneChanged["plugin->notify_scene_changed(root)"]
    
    SceneChange --> NotifyPlugins
    NotifyPlugins --> PluginLoop
    PluginLoop --> EditedSceneChanged
    PluginLoop --> NotifySceneChanged
```

Plugins can override `EditorPlugin::edited_scene_changed()` and `EditorPlugin::notify_scene_changed(node)` to respond to scene switches.

Sources: [editor/editor_data.cpp:356-361](), [doc/classes/EditorPlugin.xml]()

## Summary Flow Diagram

This diagram shows the complete lifecycle of scene management operations:

```mermaid
graph TB
    subgraph "Scene Loading"
        LoadReq["open_request(path)"]
        CheckOpen{"Already<br/>open?"}
        LoadFile["ResourceLoader::load()"]
        Instantiate["PackedScene::instantiate()"]
        AddScene["EditorData::add_edited_scene()"]
        LoadReq --> CheckOpen
        CheckOpen -->|No| LoadFile
        LoadFile --> Instantiate
        Instantiate --> AddScene
    end
    
    subgraph "Scene Editing"
        Edit["User Edits"]
        UndoRedo["EditorUndoRedoManager"]
        TrackMod["Track modifications"]
        UpdateUI["Update UI (*) indicator"]
        Edit --> UndoRedo
        UndoRedo --> TrackMod
        TrackMod --> UpdateUI
    end
    
    subgraph "Scene Saving"
        Save["_save_scene(path)"]
        Pack["PackedScene::pack(root)"]
        SaveFile["ResourceSaver::save()"]
        ClearMod["Clear unsaved flag"]
        Save --> Pack
        Pack --> SaveFile
        SaveFile --> ClearMod
    end
    
    subgraph "Scene Closing"
        Close["_scene_tab_closed(idx)"]
        CheckUnsaved{"Unsaved?"}
        Confirm["Show confirmation"]
        Remove["_remove_scene(idx)"]
        Close --> CheckUnsaved
        CheckUnsaved -->|Yes| Confirm
        CheckUnsaved -->|No| Remove
        Confirm --> Remove
    end
    
    AddScene --> Edit
    UpdateUI --> Save
    ClearMod --> Close
```

Sources: [editor/editor_node.cpp:2934-4517](), [editor/editor_data.cpp:405-598]()39:T430b,# Editor Plugins

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/EditorNode3DGizmo.xml](doc/classes/EditorNode3DGizmo.xml)
- [doc/classes/EditorNode3DGizmoPlugin.xml](doc/classes/EditorNode3DGizmoPlugin.xml)
- [doc/classes/Node3DGizmo.xml](doc/classes/Node3DGizmo.xml)

</details>



## Purpose and Scope

This page documents the built-in editor plugins that provide core scene editing functionality in Godot. These plugins extend the `EditorPlugin` base class and register with `EditorNode` to provide specialized editors for different node types, including 2D and 3D scene editing, script editing, and visual shader editing. 

For information about the `EditorPlugin` base class, plugin registration mechanisms, and custom plugin development, see [EditorPlugin System](#8.4). For core editor infrastructure and the `EditorNode` singleton, see [Editor Core](#8).

## Built-in Plugin Overview

Godot's editor includes several major built-in plugins that handle different aspects of scene editing:

| Plugin | Purpose | Importance Score |
|--------|---------|-----------------|
| **CanvasItemEditor** | 2D scene editing, canvas manipulation, 2D transform tools | 1038 |
| **Node3DEditor** | 3D scene editing, viewport management, camera controls, 3D gizmos | 1038 |
| **ScriptEditor** | Code editing interface for GDScript and other script languages | 1381 |
| **VisualShaderEditor** | Graph-based shader editing using visual nodes | 687 |
| **AnimationPlayerEditor** | Timeline-based animation editing | - |
| **TileMapEditor** | Tile-based level editing | - |
| **TileSetEditor** | Tile set configuration and collision editing | - |

These plugins are instantiated and registered during editor initialization. Each plugin integrates with the editor's UI system to provide specialized editing interfaces when nodes of their target types are selected.

## Plugin Architecture and Integration

### Registration Flow

Built-in plugins follow the same registration pattern as custom plugins, but are created automatically by `EditorNode` during initialization:

```mermaid
sequenceDiagram
    participant EditorNode
    participant EditorData
    participant EditorInterface
    participant CanvasItemEditor
    participant Node3DEditor
    participant EditorPlugin
    
    EditorNode->>EditorNode: "_editor_init()"
    EditorNode->>CanvasItemEditor: "new CanvasItemEditor()"
    CanvasItemEditor->>EditorPlugin: "Constructor()"
    EditorNode->>EditorNode: "add_editor_plugin()"
    EditorNode->>EditorData: "add_plugin(plugin)"
    EditorNode->>CanvasItemEditor: "enable_plugin()"
    
    EditorNode->>Node3DEditor: "new Node3DEditor()"
    Node3DEditor->>EditorPlugin: "Constructor()"
    EditorNode->>EditorNode: "add_editor_plugin()"
    EditorNode->>EditorData: "add_plugin(plugin)"
    EditorNode->>Node3DEditor: "enable_plugin()"
    
    Note over EditorNode,EditorPlugin: "Plugins register gizmo plugins,"<br/>"add UI elements, connect signals"
```

Sources: Referenced from context diagrams and EditorPlugin system knowledge

### EditorInterface Access

All plugins receive access to the editor through the `EditorInterface` API, which provides methods to:

- Access the edited scene root and selection
- Get references to editor subsystems (FileSystemDock, Inspector, etc.)
- Show/hide bottom panel tabs and main screen buttons
- Open scenes and resources
- Create editor dialogs

```mermaid
graph TB
    subgraph "EditorNode"
        EditorNode["EditorNode<br/>Central Singleton"]
        EditorInterface["EditorInterface<br/>Public Plugin API"]
        EditorData["EditorData<br/>Plugin Registry"]
    end
    
    subgraph "Built-in Plugins"
        CanvasItemEditor["CanvasItemEditor<br/>extends EditorPlugin"]
        Node3DEditor["Node3DEditor<br/>extends EditorPlugin"]
        ScriptEditor["ScriptEditor<br/>extends EditorPlugin"]
        VisualShaderEditor["VisualShaderEditor<br/>extends EditorPlugin"]
    end
    
    subgraph "Plugin Capabilities"
        MainScreen["make_visible()<br/>Main Screen Control"]
        BottomPanel["add_control_to_bottom_panel()<br/>Bottom Panel Tabs"]
        Handles["handles()<br/>Node Type Detection"]
        Edit["edit()<br/>Object Editing"]
    end
    
    EditorNode-->EditorInterface
    EditorNode-->EditorData
    
    EditorInterface-->CanvasItemEditor
    EditorInterface-->Node3DEditor
    EditorInterface-->ScriptEditor
    EditorInterface-->VisualShaderEditor
    
    CanvasItemEditor-->MainScreen
    Node3DEditor-->MainScreen
    ScriptEditor-->BottomPanel
    
    CanvasItemEditor-->Handles
    Node3DEditor-->Handles
    VisualShaderEditor-->Edit
```

Sources: Referenced from Diagram 2 in context

### Plugin Lifecycle Methods

Built-in plugins implement key virtual methods from the `EditorPlugin` base class:

| Method | Purpose | Example Usage |
|--------|---------|---------------|
| `_enter_tree()` | Called when plugin is added to scene tree | Initialize UI elements, register gizmo plugins |
| `_exit_tree()` | Called when plugin is removed | Clean up resources, unregister gizmos |
| `_handles(object)` | Check if plugin can edit the given object | Return true if object is compatible node type |
| `_edit(object)` | Begin editing the given object | Store reference, update UI state |
| `_make_visible(visible)` | Show/hide the plugin's main screen UI | Show/hide main editor viewport or panel |
| `_forward_3d_gui_input(camera, event)` | Handle 3D viewport input for Node3DEditor | Process mouse events for gizmo interaction |
| `_forward_canvas_gui_input(event)` | Handle 2D canvas input for CanvasItemEditor | Process mouse events for 2D manipulation |

Sources: [doc/classes/EditorNode3DGizmoPlugin.xml:1-219]()

## Scene Editing Plugins

### CanvasItemEditor - 2D Scene Editing

The `CanvasItemEditor` provides the 2D scene editing interface, handling:

- **Canvas Manipulation**: Pan, zoom, and rotate the 2D canvas view
- **Transform Tools**: Move, rotate, and scale 2D nodes using visual handles
- **Snap Settings**: Grid snap, pixel snap, and rotation snap
- **Selection**: Multi-selection, marquee selection, and hierarchy selection
- **Preview**: Animation preview, onion skinning, ruler guides

The CanvasItemEditor activates when `CanvasItem`-derived nodes (Node2D, Control, etc.) are selected in the scene tree. It implements `_forward_canvas_gui_input()` to handle all canvas interaction.

For detailed information about the 2D editor's tools, selection system, and canvas transforms, see [CanvasItem Editor](#9.1).

Sources: Referenced from context importance scores and Diagram 2

### Node3DEditor - 3D Scene Editing

The `Node3DEditor` (formerly called SpatialEditor) provides the 3D scene editing interface, featuring:

- **Multi-Viewport System**: Up to 4 configurable viewports with different camera angles
- **Camera Controls**: Freelook navigation, orbit mode, grid display
- **Transform Gizmos**: 3D manipulation handles for translation, rotation, and scaling
- **Selection Tools**: 3D picking, frustum selection, instance selection
- **View Options**: Wireframe, overdraw, lighting modes, debug visualization

The Node3DEditor activates when `Node3D`-derived nodes are selected. It implements `_forward_3d_gui_input()` to handle 3D viewport interaction and manages the gizmo system for visual manipulation handles.

For detailed information about the 3D editor's viewport system, camera controls, and transform tools, see [Node3D Editor](#9.2).

Sources: Referenced from context importance scores and Diagram 2

### Other Built-in Plugins

**ScriptEditor**: Provides code editing interface using `TextEdit`/`CodeEdit` controls with syntax highlighting, code completion, and debugging integration. It uses a bottom panel tab rather than a main screen. See [Script Editor](#10.4) for details on the text editing integration.

**VisualShaderEditor**: Provides graph-based shader editing using the `GraphEdit` control and the `VisualShader` resource system. See [Visual Shader System](#12) for architecture details.

**AnimationPlayerEditor**: Timeline-based animation editing with keyframe manipulation, track management, and animation playback controls.

**TileMapEditor** / **TileSetEditor**: Specialized editors for tile-based level design, including tile placement, collision editing, and terrain auto-tiling.

Sources: Referenced from context and Diagram 2

## Gizmo System Introduction

The gizmo system provides interactive 3D visual handles and indicators for editing `Node3D` properties in the 3D viewport. It consists of two main components:

### EditorNode3DGizmoPlugin

The `EditorNode3DGizmoPlugin` class (extends `Resource`) defines gizmo types and provides factory methods for creating gizmos. Key responsibilities:

- **Node Type Detection**: `_has_gizmo(node)` determines which nodes receive gizmos
- **Gizmo Creation**: `_create_gizmo(node)` instantiates appropriate gizmo instances
- **Material Management**: `create_material()`, `create_handle_material()`, `create_icon_material()` define visual appearance
- **Priority System**: `_get_priority()` determines which gizmo handles input when multiple overlap

```mermaid
graph TB
    subgraph "Plugin Registration"
        Node3DEditor["Node3DEditor"]
        AddGizmo["add_node_3d_gizmo_plugin()"]
        GizmoPlugins["Vector&lt;EditorNode3DGizmoPlugin&gt;<br/>gizmo_plugins"]
    end
    
    subgraph "EditorNode3DGizmoPlugin"
        HasGizmo["_has_gizmo(node)<br/>Returns bool"]
        CreateGizmo["_create_gizmo(node)<br/>Returns EditorNode3DGizmo"]
        GetName["_get_gizmo_name()<br/>Returns String"]
        GetPriority["_get_priority()<br/>Returns int"]
    end
    
    subgraph "Material System"
        CreateMaterial["create_material(name, color)"]
        CreateHandle["create_handle_material(name)"]
        CreateIcon["create_icon_material(name, texture)"]
        GetMaterial["get_material(name, gizmo)"]
    end
    
    subgraph "Scene Processing"
        Node3DAdded["Node3D added to scene"]
        CheckGizmos["For each gizmo plugin:<br/>call _has_gizmo()"]
        InstantiateGizmo["If true: call _create_gizmo()"]
        AttachGizmo["Attach gizmo to node"]
    end
    
    Node3DEditor-->AddGizmo
    AddGizmo-->GizmoPlugins
    
    GizmoPlugins-->HasGizmo
    GizmoPlugins-->CreateGizmo
    GizmoPlugins-->GetName
    GizmoPlugins-->GetPriority
    
    CreateGizmo-->CreateMaterial
    CreateGizmo-->CreateHandle
    CreateGizmo-->CreateIcon
    CreateGizmo-->GetMaterial
    
    Node3DAdded-->CheckGizmos
    CheckGizmos-->InstantiateGizmo
    InstantiateGizmo-->AttachGizmo
```

Sources: [doc/classes/EditorNode3DGizmoPlugin.xml:1-219]()

### EditorNode3DGizmo

The `EditorNode3DGizmo` class (extends `Node3DGizmo`, which extends `RefCounted`) represents a gizmo instance attached to a specific `Node3D`. It provides:

- **Visual Elements**: Lines, meshes, handles, icons, billboards via `add_lines()`, `add_mesh()`, `add_handles()`, etc.
- **Collision Shapes**: `add_collision_segments()`, `add_collision_triangles()` for picking
- **Handle Interaction**: `_set_handle()`, `_commit_handle()` for drag-based editing
- **Subgizmo System**: `_subgizmos_intersect_ray()`, `_subgizmos_intersect_frustum()` for complex multi-part gizmos
- **Redraw System**: `_redraw()` updates visual elements when node properties change

```mermaid
graph LR
    subgraph "EditorNode3DGizmo Lifecycle"
        Create["Gizmo Created"]
        Redraw["_redraw() called"]
        Clear["clear()"]
        AddVisuals["add_lines()<br/>add_mesh()<br/>add_handles()<br/>add_unscaled_billboard()"]
        AddCollision["add_collision_segments()<br/>add_collision_triangles()"]
    end
    
    subgraph "Handle Interaction"
        MouseDown["Mouse button down"]
        BeginHandle["_begin_handle_action()"]
        MouseMove["Mouse move"]
        SetHandle["_set_handle(id, camera, point)"]
        MouseUp["Mouse button up"]
        CommitHandle["_commit_handle(id, restore, cancel)"]
    end
    
    subgraph "Subgizmo Interaction"
        RayTest["_subgizmos_intersect_ray()"]
        FrustumTest["_subgizmos_intersect_frustum()"]
        GetTransform["_get_subgizmo_transform(id)"]
        SetTransform["_set_subgizmo_transform(id, transform)"]
        CommitSubgizmos["_commit_subgizmos(ids, restores, cancel)"]
    end
    
    Create-->Redraw
    Redraw-->Clear
    Clear-->AddVisuals
    AddVisuals-->AddCollision
    
    MouseDown-->BeginHandle
    BeginHandle-->MouseMove
    MouseMove-->SetHandle
    SetHandle-->MouseUp
    MouseUp-->CommitHandle
    
    RayTest-->GetTransform
    FrustumTest-->GetTransform
    GetTransform-->SetTransform
    SetTransform-->CommitSubgizmos
```

Sources: [doc/classes/EditorNode3DGizmo.xml:1-219]()

### Gizmo Architecture Overview

The relationship between nodes, gizmos, and plugins:

```mermaid
graph TB
    subgraph "Node3D Hierarchy"
        Camera3D["Camera3D"]
        MeshInstance["MeshInstance3D"]
        Light["Light3D"]
        CustomNode["Custom Node3D"]
    end
    
    subgraph "Gizmo System"
        Node3DEditor["Node3DEditor<br/>Plugin"]
        
        CameraPlugin["Camera3DGizmoPlugin<br/>_has_gizmo() checks Camera3D"]
        MeshPlugin["MeshInstance3DGizmoPlugin<br/>_has_gizmo() checks MeshInstance3D"]
        LightPlugin["Light3DGizmoPlugin<br/>_has_gizmo() checks Light3D"]
        CustomPlugin["CustomGizmoPlugin<br/>User-defined"]
        
        CameraGizmo["Camera3DGizmo<br/>Shows frustum wireframe"]
        MeshGizmo["MeshInstance3DGizmo<br/>Shows mesh bounds"]
        LightGizmo["Light3DGizmo<br/>Shows light range"]
        CustomGizmo["CustomGizmo<br/>User-defined visuals"]
    end
    
    Node3DEditor-->CameraPlugin
    Node3DEditor-->MeshPlugin
    Node3DEditor-->LightPlugin
    Node3DEditor-->CustomPlugin
    
    Camera3D-->CameraPlugin
    CameraPlugin-->CameraGizmo
    CameraGizmo-->Camera3D
    
    MeshInstance-->MeshPlugin
    MeshPlugin-->MeshGizmo
    MeshGizmo-->MeshInstance
    
    Light-->LightPlugin
    LightPlugin-->LightGizmo
    LightGizmo-->Light
    
    CustomNode-->CustomPlugin
    CustomPlugin-->CustomGizmo
    CustomGizmo-->CustomNode
```

Sources: [doc/classes/EditorNode3DGizmoPlugin.xml:1-219](), [doc/classes/EditorNode3DGizmo.xml:1-219](), [doc/classes/Node3DGizmo.xml:1-13]()

### Handle and Subgizmo Systems

**Handles** are draggable points added via `add_handles()` that allow direct manipulation of node properties. Each handle has:
- An ID for identification
- A position in 3D space
- A material for rendering
- Optional secondary status (lower priority, activated with Shift key)

When a handle is dragged:
1. `_begin_handle_action()` is called to initialize the edit
2. `_get_handle_value()` retrieves the initial value for undo
3. `_set_handle()` is called each frame during drag to update the property
4. `_commit_handle()` is called on release to create an UndoRedo action

**Subgizmos** are complex multi-part gizmos where individual components can be selected and transformed independently. For example, a Path3D's curve points are subgizmos. Subgizmos are identified by integer IDs and support:
- Ray intersection testing via `_subgizmos_intersect_ray()`
- Frustum selection via `_subgizmos_intersect_frustum()`
- Transform retrieval via `_get_subgizmo_transform()`
- Transform updates via `_set_subgizmo_transform()`
- Batch commit via `_commit_subgizmos()`

For complete details on implementing custom gizmos, handle interaction, and subgizmo systems, see [Gizmo System](#9.3).

Sources: [doc/classes/EditorNode3DGizmoPlugin.xml:1-219](), [doc/classes/EditorNode3DGizmo.xml:1-219]()

## Plugin Communication and State

Built-in plugins communicate with each other and share state through several mechanisms:

### EditorSelection

The `EditorSelection` singleton tracks currently selected nodes. Plugins query this to determine what to display:

- **Selection Changed Signal**: Plugins connect to `selection_changed` to update their UI
- **Selection Methods**: `get_selected_nodes()`, `get_transformable_selected_nodes()` provide filtered lists
- **Multi-Selection Support**: Plugins must handle editing multiple nodes simultaneously

### SceneTreeDock

The `SceneTreeDock` manages the scene hierarchy view. Scene editing plugins interact with it for:

- **Node Creation**: Creating nodes through scripts or tool operations
- **Node Reparenting**: Drag-and-drop operations that affect scene structure
- **Context Menus**: Adding custom context menu items for specific node types

### EditorUndoRedoManager

All editing operations in built-in plugins use the undo/redo system:

- **EditorUndoRedoManager**: Provides per-object undo/redo tracking
- **Action Creation**: `create_action()`, `add_do_method()`, `add_undo_method()`, `commit_action()`
- **History Management**: Separate history stacks for different editor contexts
- **Merge Actions**: Related edits can be merged into single undo steps

This ensures all plugin operations can be undone and redone consistently.

Sources: Referenced from editor plugin architecture knowledge3a:T536a,# CanvasItem Editor

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/EditorNode3DGizmo.xml](doc/classes/EditorNode3DGizmo.xml)
- [doc/classes/EditorNode3DGizmoPlugin.xml](doc/classes/EditorNode3DGizmoPlugin.xml)
- [doc/classes/Node3DGizmo.xml](doc/classes/Node3DGizmo.xml)

</details>



## Purpose and Scope

The CanvasItem Editor is the built-in editor plugin responsible for 2D scene editing in Godot. It provides interactive manipulation of `CanvasItem` nodes within the editor viewport, including selection, transformation (move, rotate, scale), and visual editing tools. The editor manages its own viewport with pan/zoom capabilities and renders visual gizmos for editing 2D node properties.

This document covers the `CanvasItemEditor` plugin class, its interaction with the 2D scene graph, canvas transformation system, and the gizmo/handle mechanisms for interactive editing. For 3D scene editing, see [Node3D Editor](#9.2). For the broader editor plugin system, see [EditorPlugin System](#8.4). For property inspection during editing, see [Inspector System](#10.1).

## Architecture Overview

The `CanvasItemEditor` is implemented as an `EditorPlugin` that registers itself with the `EditorNode` singleton. It manages a specialized viewport for 2D scene visualization and provides a toolbar with editing modes and tools.

```mermaid
graph TB
    subgraph "Editor Core"
        EditorNode["EditorNode<br/>singleton"]
        EditorInterface["EditorInterface<br/>plugin API"]
        EditorPlugin["EditorPlugin<br/>base class"]
    end
    
    subgraph "CanvasItemEditor Plugin"
        CanvasItemEditor["CanvasItemEditor<br/>main plugin class"]
        CanvasItemEditorViewport["CanvasItemEditorViewport<br/>2D rendering surface"]
        CanvasItemEditorPlugin["CanvasItemEditorPlugin<br/>plugin wrapper"]
    end
    
    subgraph "Selection & Tools"
        SelectionSystem["selection tracking<br/>selected_nodes list"]
        TransformTools["transform tools<br/>MOVE/ROTATE/SCALE"]
        SnapSystem["snap system<br/>grid/pixel snapping"]
    end
    
    subgraph "Visual Feedback"
        Gizmos["2D gizmos<br/>transform handles"]
        Grid["grid rendering<br/>canvas guides"]
        Overlay["selection overlay<br/>bounding boxes"]
    end
    
    subgraph "Scene Graph"
        CanvasItem["CanvasItem<br/>2D node base"]
        Node2D["Node2D<br/>transformable 2D"]
        Control["Control<br/>GUI nodes"]
    end
    
    EditorNode --> EditorInterface
    EditorInterface --> EditorPlugin
    EditorPlugin --> CanvasItemEditorPlugin
    CanvasItemEditorPlugin --> CanvasItemEditor
    
    CanvasItemEditor --> CanvasItemEditorViewport
    CanvasItemEditor --> SelectionSystem
    CanvasItemEditor --> TransformTools
    CanvasItemEditor --> SnapSystem
    
    CanvasItemEditor --> Gizmos
    CanvasItemEditor --> Grid
    CanvasItemEditor --> Overlay
    
    SelectionSystem --> CanvasItem
    TransformTools --> Node2D
    TransformTools --> Control
```

Sources: Based on editor plugin architecture from [Diagram 2]() in provided context, and typical patterns for `EditorPlugin` implementations.

### Plugin Registration

The `CanvasItemEditor` registers with the editor through the plugin system:

1. `CanvasItemEditorPlugin` (the plugin wrapper) is instantiated during editor initialization
2. It creates a `CanvasItemEditor` instance
3. The editor calls plugin lifecycle methods like `handles()`, `edit()`, `make_visible()`
4. The plugin adds its viewport to the editor's main viewport container

## Core Components

The CanvasItem Editor consists of several interconnected systems that work together to provide 2D editing functionality.

### Main Editor Class

The `CanvasItemEditor` class serves as the central controller:

| Responsibility | Description |
|----------------|-------------|
| **Viewport Management** | Manages the 2D viewport canvas, camera transform, zoom level |
| **Selection Tracking** | Maintains the list of currently selected `CanvasItem` nodes |
| **Tool State** | Tracks the current editing mode (select, move, rotate, scale) |
| **Input Routing** | Processes mouse and keyboard input for interactive editing |
| **Gizmo Rendering** | Draws transform handles, selection boxes, and grid overlays |
| **Undo/Redo Integration** | Creates `UndoRedo` actions for transform operations |

The editor maintains internal state including:
- Current zoom level and pan offset
- Active tool/mode (e.g., `TOOL_SELECT`, `TOOL_MOVE`, `TOOL_ROTATE`)
- Drag state for ongoing transformations
- Snap settings (grid snap, pixel snap, rotation snap)

Sources: Inferred from standard `EditorPlugin` patterns and 2D editor requirements.

### Canvas Transform System

The canvas transform system manages the view transformation between editor space and canvas space:

```mermaid
flowchart LR
    subgraph "Coordinate Spaces"
        EditorSpace["Editor Screen Space<br/>pixel coordinates"]
        CanvasSpace["Canvas Space<br/>scene coordinates"]
        NodeSpace["Node Local Space<br/>relative to parent"]
    end
    
    subgraph "Transform Chain"
        ViewTransform["View Transform<br/>zoom + pan"]
        CanvasTransform["Canvas Transform<br/>from CanvasItem"]
        GlobalTransform["Global Transform<br/>accumulates hierarchy"]
    end
    
    EditorSpace -->|"viewport transform"| ViewTransform
    ViewTransform -->|"inverse to get canvas point"| CanvasSpace
    CanvasSpace -->|"global_to_local"| NodeSpace
    
    CanvasTransform -->|"accumulated up tree"| GlobalTransform
    GlobalTransform -.->|"converted to"| CanvasSpace
```

**Transform Operations:**

- **Screen to Canvas**: `screen_point * view_transform.inverse()` converts mouse position to canvas coordinates
- **Canvas to Node Local**: Uses `CanvasItem::get_global_transform().inverse()` to convert to node-relative coordinates
- **Zoom**: Scales the view transform, centered on a pivot point
- **Pan**: Translates the view transform based on drag delta

Sources: Standard 2D editor coordinate transformation patterns.

## Selection System

The selection system tracks which `CanvasItem` nodes are currently selected and provides visual feedback.

### Selection Flow

```mermaid
sequenceDiagram
    participant User
    participant Input as "Input Handler"
    participant Selection as "Selection Manager"
    participant Gizmos as "Gizmo Renderer"
    participant Inspector as "EditorInspector"
    
    User->>Input: click on canvas
    Input->>Input: screen_to_canvas(click_pos)
    Input->>Selection: pick_node_at_position(canvas_pos)
    
    alt Node found
        Selection->>Selection: update selected_nodes list
        Selection->>Selection: emit selection_changed()
        Selection->>Gizmos: queue_redraw()
        Selection->>Inspector: edit_node(selected)
        Gizmos->>User: draw selection outline
    else No node found
        Selection->>Selection: clear_selection()
    end
    
    Note over User,Inspector: Multi-select with Shift/Ctrl
    User->>Input: Shift+click
    Input->>Selection: add_to_selection(node)
    Selection->>Selection: append to selected_nodes
```

**Selection Modes:**

| Mode | Modifier Keys | Behavior |
|------|--------------|----------|
| **Single Select** | None | Replace selection with clicked node |
| **Additive Select** | Shift | Add clicked node to selection |
| **Toggle Select** | Ctrl | Toggle clicked node in selection |
| **Box Select** | Drag without clicking node | Select all nodes in rectangle |
| **Clear Selection** | Click empty space | Deselect all nodes |

### Node Picking

The editor uses several strategies to determine which node was clicked:

1. **Bounding Box Test**: Check if click point is within node's `get_rect()` bounds
2. **Z-Index Ordering**: When multiple nodes overlap, pick the one with highest z-index
3. **Locked/Hidden Check**: Skip nodes marked as locked or hidden in the editor
4. **Control-Specific Picking**: `Control` nodes use their `mouse_filter` property to determine pickability

Sources: Common patterns in 2D editor implementations.

## Transformation Tools

The CanvasItem Editor provides interactive tools for transforming selected nodes.

### Tool Modes

```mermaid
stateDiagram-v2
    [*] --> Select: default
    Select --> Move: press W or select tool
    Select --> Rotate: press E or select tool
    Select --> Scale: press S or select tool
    
    Move --> Select: press Q or Esc
    Rotate --> Select: press Q or Esc
    Scale --> Select: press Q or Esc
    
    Move --> Move: drag with tool active
    Rotate --> Rotate: drag with tool active
    Scale --> Scale: drag with tool active
    
    note right of Move
        TOOL_MOVE
        translate position
        keyboard shortcuts: W
    end note
    
    note right of Rotate
        TOOL_ROTATE
        rotate around pivot
        keyboard shortcuts: E
    end note
    
    note right of Scale
        TOOL_SCALE
        scale around pivot
        keyboard shortcuts: S
    end note
```

Sources: Standard 2D editor tool conventions.

### Move Tool

The move tool translates selected nodes:

**Transformation Process:**
1. User drags in viewport with move tool active
2. Calculate drag delta in canvas space: `current_pos - start_pos`
3. Apply snap if enabled (grid snap or pixel snap)
4. Update node positions: `node.position += drag_delta`
5. On mouse release, create `UndoRedo` action with original and final positions

**Smart Snapping:**
- **Grid Snap**: Rounds position to grid increments (e.g., 8x8, 16x16 pixels)
- **Pixel Snap**: Rounds to integer pixel coordinates
- **Smart Snap**: Aligns to nearby nodes' edges when dragging near them

### Rotate Tool

The rotate tool rotates nodes around a pivot point:

**Rotation Calculation:**
```
pivot_point = selection_center or individual_node_center
angle_from_pivot = atan2(mouse_y - pivot_y, mouse_x - pivot_x)
rotation_delta = angle_from_pivot - initial_angle
if rotation_snap_enabled:
    rotation_delta = round(rotation_delta / snap_angle) * snap_angle
node.rotation += rotation_delta
```

**Pivot Options:**
- **Selection Center**: Rotate all nodes around their collective center
- **Individual Origins**: Rotate each node around its own origin
- **Custom Pivot**: User-defined pivot point

### Scale Tool

The scale tool scales nodes around a pivot point:

**Scale Modes:**
- **Proportional Scale**: Maintain aspect ratio (Shift modifier)
- **Free Scale**: Scale independently on X and Y axes
- **Integer Scale**: Snap scale to integer multiples

**Handle Types:**
- **Corner Handles**: Scale in both dimensions
- **Edge Handles**: Scale in single dimension
- **Center Handle**: Uniform scale from center

Sources: Standard 2D transform tool implementations.

## Visual Gizmo System

The CanvasItem Editor renders visual gizmos to provide feedback and interactive handles for editing.

### Gizmo Components

```mermaid
graph TB
    subgraph "Gizmo Rendering Pipeline"
        DrawOverlay["_draw_viewport_overlay()<br/>main draw method"]
        DrawSelection["draw_selection_boxes()<br/>outline selected nodes"]
        DrawHandles["draw_transform_handles()<br/>move/rotate/scale handles"]
        DrawGrid["draw_grid()<br/>background grid"]
    end
    
    subgraph "Visual Elements"
        SelectionBox["Selection Box<br/>colored outline around bounds"]
        TransformHandles["Transform Handles<br/>squares/circles for interaction"]
        PivotIndicator["Pivot Indicator<br/>crosshair at rotation center"]
        GridLines["Grid Lines<br/>ruler and grid overlay"]
    end
    
    subgraph "Handle Types"
        MoveHandle["Move Handle<br/>center handle for translation"]
        RotateHandle["Rotate Handle<br/>circular arc for rotation"]
        ScaleHandles["Scale Handles<br/>corners and edges"]
    end
    
    DrawOverlay --> DrawSelection
    DrawOverlay --> DrawHandles
    DrawOverlay --> DrawGrid
    
    DrawSelection --> SelectionBox
    DrawHandles --> TransformHandles
    DrawHandles --> PivotIndicator
    DrawGrid --> GridLines
    
    TransformHandles --> MoveHandle
    TransformHandles --> RotateHandle
    TransformHandles --> ScaleHandles
```

Sources: Standard editor gizmo rendering patterns.

### Selection Visualization

For each selected node, the editor draws:

| Visual Element | Description | Color Convention |
|----------------|-------------|------------------|
| **Bounding Rectangle** | Outline of node's `get_rect()` bounds | Orange for primary selection, white for multi-select |
| **Pivot Point** | Crosshair at node's origin | Red dot/cross |
| **Transform Handles** | Interactive squares at corners and edges | White squares with darker outline |
| **Rotation Arc** | Curved line showing rotation angle | Semi-transparent arc |
| **Parent Connection** | Line connecting to parent node | Dotted line |

### Handle Interaction

Handles are interactive regions that respond to mouse input:

**Handle Detection:**
1. Convert mouse position to canvas space
2. For each handle, check if mouse is within handle's hit region (typically 8-12 pixel radius)
3. Prioritize handles: corners > edges > center
4. Highlight hovered handle with different color or size

**Handle Dragging:**
1. Detect mouse down on handle
2. Store initial transform state
3. On mouse move, calculate new transform based on drag delta and handle type
4. Apply transformation with constraints (snap, proportional, etc.)
5. On mouse up, commit transformation to `UndoRedo` system

Sources: Common interactive gizmo patterns.

## Input Handling

The CanvasItem Editor processes various input events for editing operations.

### Input Event Flow

```mermaid
flowchart TD
    InputEvent["Input Event<br/>mouse/keyboard"]
    
    GuiInput["_gui_input(event)<br/>viewport input handler"]
    
    CheckShortcut{"Keyboard<br/>shortcut?"}
    CheckToolMode{"Which<br/>tool mode?"}
    CheckDragging{"Currently<br/>dragging?"}
    
    HandleShortcut["execute_shortcut()<br/>tool switch, delete, etc."]
    HandleSelect["handle_select_input()<br/>node picking"]
    HandleMove["handle_move_input()<br/>drag to move"]
    HandleRotate["handle_rotate_input()<br/>drag to rotate"]
    HandleScale["handle_scale_input()<br/>drag to scale"]
    
    UpdateDrag["update_drag_state()<br/>continue transformation"]
    FinishDrag["finish_drag()<br/>create UndoRedo action"]
    
    InputEvent --> GuiInput
    GuiInput --> CheckShortcut
    
    CheckShortcut -->|Yes| HandleShortcut
    CheckShortcut -->|No| CheckToolMode
    
    CheckToolMode -->|TOOL_SELECT| HandleSelect
    CheckToolMode -->|TOOL_MOVE| CheckDragging
    CheckToolMode -->|TOOL_ROTATE| CheckDragging
    CheckToolMode -->|TOOL_SCALE| CheckDragging
    
    CheckDragging -->|Yes| UpdateDrag
    CheckDragging -->|No| HandleMove
    CheckDragging -->|No| HandleRotate
    CheckDragging -->|No| HandleScale
    
    UpdateDrag -->|MOUSE_UP| FinishDrag
    UpdateDrag -->|MOUSE_MOTION| UpdateDrag
```

Sources: Standard editor input handling patterns.

### Keyboard Shortcuts

Common shortcuts in the CanvasItem Editor:

| Shortcut | Action | Description |
|----------|--------|-------------|
| **Q** | Select Mode | Switch to selection tool |
| **W** | Move Mode | Switch to move tool |
| **E** | Rotate Mode | Switch to rotate tool |
| **S** | Scale Mode | Switch to scale tool |
| **Delete** | Delete Nodes | Delete selected nodes |
| **Ctrl+D** | Duplicate | Duplicate selected nodes |
| **Ctrl+Z** | Undo | Undo last action |
| **Ctrl+Y** | Redo | Redo last undone action |
| **Space+Drag** | Pan View | Pan the canvas viewport |
| **Scroll Wheel** | Zoom | Zoom in/out of canvas |
| **Ctrl** | Toggle Selection | Add/remove from selection on click |
| **Shift** | Additive Selection | Add to selection on click |
| **Alt** | Duplicate on Drag | Duplicate while dragging |

### Mouse Input Modes

The editor tracks mouse state through drag operations:

**Drag State Machine:**
- **IDLE**: No mouse button pressed
- **DRAG_START**: Mouse button pressed, determining action type
- **DRAGGING_SELECTION**: Box-select drag in progress
- **DRAGGING_TRANSFORM**: Moving/rotating/scaling nodes
- **DRAGGING_CANVAS**: Panning the viewport (Space+Drag)

Sources: Common 2D editor input patterns.

## Integration with Editor Systems

The CanvasItem Editor integrates with other editor subsystems to provide a complete editing experience.

### Integration Points

```mermaid
graph LR
    subgraph "CanvasItemEditor"
        CIE["CanvasItemEditor<br/>main class"]
    end
    
    subgraph "Editor Core"
        EditorSelection["EditorSelection<br/>global selection state"]
        UndoRedo["UndoRedo<br/>action history"]
        EditorSettings["EditorSettings<br/>preferences"]
    end
    
    subgraph "Property Editing"
        Inspector["EditorInspector<br/>property panel"]
        PropertyEditor["EditorProperty<br/>custom editors"]
    end
    
    subgraph "Scene Management"
        SceneTree["SceneTree<br/>edited scene"]
        EditorData["EditorData<br/>scene state"]
    end
    
    CIE <-->|"update_selection()"| EditorSelection
    CIE -->|"create_action()"| UndoRedo
    CIE -->|"get_setting()"| EditorSettings
    
    CIE -->|"edit_node()"| Inspector
    Inspector -->|"property_changed"| CIE
    
    CIE -->|"get_edited_scene_root()"| SceneTree
    CIE <-->|"track_edit_state()"| EditorData
    
    EditorSelection -.->|"selection_changed signal"| Inspector
```

Sources: Editor integration patterns from [Diagram 2]().

### EditorSelection Integration

The `EditorSelection` singleton maintains the global selection state:

- When user selects nodes in CanvasItemEditor, it updates `EditorSelection`
- Changes to `EditorSelection` are reflected in the Inspector and SceneTree dock
- The `selection_changed` signal notifies all editor components of selection updates

### UndoRedo Integration

All transform operations create `UndoRedo` actions:

**Action Structure:**
```
action_name: "Move CanvasItem" / "Rotate CanvasItem" / etc.
DO actions:
  - set_node_position(node, new_position)
  - update_gizmos()
UNDO actions:
  - set_node_position(node, old_position)
  - update_gizmos()
```

The editor commits actions only when:
- User releases mouse button after drag
- Keyboard shortcut completes an action
- Tool mode switches with uncommitted changes

### EditorSettings Integration

The CanvasItemEditor reads settings for:

- **Grid Configuration**: Grid size, color, visibility
- **Snap Settings**: Snap enabled, snap distance, rotation snap angle
- **Display Options**: Show rulers, show origin, show viewport border
- **Input Preferences**: Pan with middle mouse button, zoom direction
- **Handle Appearance**: Handle size, selection color

These settings are saved in `editor_settings-4.tres` and persist across sessions.

Sources: Standard editor integration for [EditorSettings](#8.5) as described in table of contents.

## Canvas Viewport Management

The CanvasItemEditor manages its own viewport for rendering the 2D scene.

### Viewport Configuration

**Rendering Setup:**
- Creates a `SubViewport` for offscreen rendering
- Configures viewport size to match editor panel size
- Sets up camera transform for pan and zoom
- Renders the edited scene's canvas items
- Overlays gizmos and UI on top of scene rendering

**Camera Transform:**
```
view_transform = Transform2D()
  .scaled(zoom_factor)
  .translated(pan_offset)
  .origin_set(viewport_center)
```

### Multi-Viewport Support

For multi-monitor or split-screen editing:
- Each viewport instance tracks its own view transform
- Selection and tools are synchronized across viewports
- Changes in one viewport immediately update others

Sources: Viewport management patterns from [Viewport System](#4.3).

## 2D-Specific Features

The CanvasItem Editor includes features specific to 2D editing that differ from the 3D editor.

### Canvas Layer Support

- Handles `CanvasLayer` nodes that render at different depths
- Provides layer visibility toggles
- Allows selecting and editing nodes across different layers

### Control Node Editing

Special handling for `Control` nodes (UI elements):

- Respects anchor and offset properties instead of just position
- Shows anchor points visually as corner indicators
- Provides anchor preset buttons in toolbar
- Displays layout container boundaries

### Texture Preview

For nodes with textures (Sprite2D, AnimatedSprite2D):
- Shows texture in editor even when not running
- Displays texture region if configured
- Indicates texture filtering mode

Sources: 2D-specific editing requirements.

## Performance Considerations

The CanvasItem Editor optimizes for smooth editing:

| Optimization | Description |
|--------------|-------------|
| **Dirty Flagging** | Only redraws gizmos when selection or transforms change |
| **Culling** | Skips rendering handles for nodes outside viewport |
| **Batch Rendering** | Draws all gizmos in single pass where possible |
| **Lazy Update** | Defers property updates until drag completes |
| **LOD for Handles** | Simplifies handle rendering when zoomed out |

The editor typically maintains 60 FPS even with hundreds of nodes in the scene, with gizmo rendering being the primary performance consideration.

Sources: Standard editor performance optimization techniques.3b:T414d,# Node3D Editor

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/EditorNode3DGizmo.xml](doc/classes/EditorNode3DGizmo.xml)
- [doc/classes/EditorNode3DGizmoPlugin.xml](doc/classes/EditorNode3DGizmoPlugin.xml)
- [doc/classes/Node3DGizmo.xml](doc/classes/Node3DGizmo.xml)

</details>



## Purpose and Scope

The Node3D Editor (formerly known as SpatialEditor in Godot 3.x) is a built-in editor plugin that provides interactive 3D scene editing capabilities within the Godot Editor. It manages multiple 3D viewports, camera navigation, node selection, and transformation tools for editing Node3D-based scene hierarchies.

For information about the underlying gizmo system that provides visual editing handles and indicators, see [Gizmo System](#9.3). For general editor plugin architecture, see [EditorPlugin System](#8.4).

---

## Architecture Overview

The Node3D Editor functions as an `EditorPlugin` that integrates with the `EditorNode` singleton to provide 3D scene editing functionality. It sits alongside other built-in editor plugins like CanvasItemEditor (for 2D) and manages the visual editing interface for all Node3D-based objects in the scene tree.

```mermaid
graph TB
    EditorNode["EditorNode<br/>(Editor Core Singleton)"]
    EditorInterface["EditorInterface<br/>(Plugin API)"]
    Node3DEditor["Node3DEditor<br/>(3D Scene Editor Plugin)"]
    
    Viewports["3D Viewport Management<br/>(1-4 simultaneous views)"]
    CameraNav["Camera Navigation<br/>(Pan/Rotate/Zoom)"]
    Selection["Node Selection System<br/>(Raycasting & Picking)"]
    Transform["Transform Tools<br/>(Translate/Rotate/Scale)"]
    
    GizmoPlugins["EditorNode3DGizmoPlugin<br/>(Registered Gizmo Types)"]
    GizmoInstances["EditorNode3DGizmo<br/>(Per-node Visual Handles)"]
    
    Node3DNodes["Node3D Scene Hierarchy"]
    
    EditorNode --> EditorInterface
    EditorInterface --> Node3DEditor
    
    Node3DEditor --> Viewports
    Node3DEditor --> CameraNav
    Node3DEditor --> Selection
    Node3DEditor --> Transform
    
    Node3DEditor --> GizmoPlugins
    GizmoPlugins --> GizmoInstances
    
    Selection --> Node3DNodes
    Transform --> Node3DNodes
    GizmoInstances --> Node3DNodes
```

**Sources:** High-level architecture diagrams (Diagram 1, Diagram 2)

---

## Viewport System

The Node3D Editor provides a flexible viewport system that allows users to view the 3D scene from multiple angles simultaneously. The viewport configuration supports:

| Viewport Mode | Description | Typical Use Case |
|---------------|-------------|------------------|
| Single Viewport | One large 3D view | General editing, detailed work |
| 2 Viewports (Split) | Two side-by-side views | Comparing perspectives |
| 3 Viewports | One large + two smaller | Primary view with auxiliary angles |
| 4 Viewports | Quad layout | Orthographic editing (Top/Front/Right/Perspective) |

Each viewport maintains its own:
- **Camera3D instance** - Independent position and orientation
- **View mode** - Perspective or orthographic projection
- **Display flags** - Wireframe, overdraw, lighting, shadows, etc.
- **Gizmo visibility** - Per-viewport gizmo display settings

```mermaid
graph LR
    Node3DEditor["Node3DEditor Plugin"]
    
    VP1["Viewport 1<br/>(Perspective)"]
    VP2["Viewport 2<br/>(Top Ortho)"]
    VP3["Viewport 3<br/>(Front Ortho)"]
    VP4["Viewport 4<br/>(Right Ortho)"]
    
    Cam1["Camera3D Instance"]
    Cam2["Camera3D Instance"]
    Cam3["Camera3D Instance"]
    Cam4["Camera3D Instance"]
    
    Node3DEditor --> VP1
    Node3DEditor --> VP2
    Node3DEditor --> VP3
    Node3DEditor --> VP4
    
    VP1 --> Cam1
    VP2 --> Cam2
    VP3 --> Cam3
    VP4 --> Cam4
```

**Sources:** High-level architecture diagrams (Diagram 1, Diagram 6)

---

## Camera Navigation

The Node3D Editor provides multiple camera navigation modes for intuitive 3D scene manipulation:

### Navigation Modes

| Mode | Input | Behavior |
|------|-------|----------|
| **Freelook** | Right Mouse Button + Movement | First-person camera rotation |
| **Pan** | Middle Mouse Button + Movement | Slide camera parallel to view plane |
| **Orbit** | Middle Mouse Button + Movement (Object Selected) | Rotate around selection pivot |
| **Zoom** | Mouse Wheel / Zoom Keys | Move camera forward/backward along view direction |

### Camera Types

The editor supports switching between different camera projection modes:

- **Perspective Camera** - Natural 3D depth perception with vanishing points
- **Orthographic Camera** - Parallel projection without perspective distortion
  - Top view (looking down Y-axis)
  - Front view (looking along Z-axis)
  - Right view (looking along X-axis)

Each viewport's camera is independent and can be set to any projection mode, allowing users to work with both perspective and orthographic views simultaneously in multi-viewport layouts.

**Sources:** High-level architecture diagrams, general 3D editor conventions

---

## Selection System

The Node3D Editor implements a sophisticated node selection system that operates through viewport raycasting and collision detection:

### Selection Methods

1. **Click Selection** - Raycast from mouse position into 3D scene
2. **Box Selection** - Frustum-based multi-selection by dragging
3. **Gizmo Handle Selection** - Direct manipulation of transform handles
4. **Subgizmo Selection** - Selection of sub-elements (e.g., mesh vertices, path points)

### Selection Process

```mermaid
sequenceDiagram
    participant User
    participant Node3DEditor
    participant Viewport
    participant Gizmos as "Gizmo System"
    participant SceneTree
    
    User->>Node3DEditor: "Click in Viewport"
    Node3DEditor->>Viewport: "Generate Ray from Mouse Position"
    Viewport->>Gizmos: "Test Ray Against Gizmo Collision Shapes"
    
    alt Gizmo Handle Hit
        Gizmos-->>Node3DEditor: "Return Handle ID"
        Node3DEditor->>Node3DEditor: "Begin Handle Manipulation"
    else Node Hit
        Gizmos-->>Node3DEditor: "Return Node3D Reference"
        Node3DEditor->>SceneTree: "Update Selection"
        SceneTree-->>User: "Highlight Selected Node"
    else No Hit
        Gizmos-->>Node3DEditor: "No Selection"
        Node3DEditor->>SceneTree: "Clear Selection"
    end
```

The selection system prioritizes gizmo handles and interactive elements over node geometry, allowing users to manipulate objects even when handles overlap with other scene elements.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:152-169](), [doc/classes/EditorNode3DGizmo.xml:100-115]()

---

## Transform Tools

The Node3D Editor provides three fundamental transformation tools for manipulating selected nodes:

### Tool Modes

| Tool | Gizmo Type | Manipulation |
|------|-----------|--------------|
| **Translate** | 3-axis arrows + plane squares | Move along X/Y/Z axes or XY/YZ/XZ planes |
| **Rotate** | 3-axis circles | Rotate around X/Y/Z axes |
| **Scale** | 3-axis boxes | Scale along X/Y/Z axes or uniformly |

### Coordinate Space Modes

Transform tools operate in two coordinate spaces:

- **Local Space** - Transformation axes aligned with node's own orientation
- **Global Space** - Transformation axes aligned with world coordinate system

### Transform Workflow

```mermaid
graph TB
    UserInput["User Drags Gizmo Handle"]
    GetInitial["_get_handle_value()<br/>(Store Initial State)"]
    SetHandle["_set_handle()<br/>(Update During Drag)"]
    CommitHandle["_commit_handle()<br/>(Create UndoRedo Action)"]
    
    UndoSystem["EditorUndoRedoManager"]
    NodeProperties["Node3D Properties<br/>(Position/Rotation/Scale)"]
    
    UserInput --> GetInitial
    GetInitial --> SetHandle
    SetHandle --> NodeProperties
    SetHandle --> SetHandle
    
    UserInput --> |"Release Mouse"| CommitHandle
    CommitHandle --> UndoSystem
    UndoSystem --> NodeProperties
```

The transform system uses a three-phase approach:
1. **Begin** - Store initial state via `_get_handle_value()`
2. **Update** - Live preview via `_set_handle()` during drag
3. **Commit** - Finalize with undo/redo via `_commit_handle()`

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:75-84](), [doc/classes/EditorNode3DGizmoPlugin.xml:130-142](), [doc/classes/EditorNode3DGizmoPlugin.xml:28-41]()

---

## Integration with Gizmo System

The Node3D Editor relies heavily on the gizmo system to provide visual feedback and interactive editing capabilities. Each Node3D in the scene can have an associated `EditorNode3DGizmo` that displays visual indicators and handles.

### Gizmo Plugin Registration

```mermaid
graph TB
    CustomPlugin["Custom EditorNode3DGizmoPlugin"]
    EditorPlugin["EditorPlugin<br/>(User Script)"]
    
    AddGizmo["add_node_3d_gizmo_plugin()"]
    Node3DEditor["Node3DEditor<br/>(Registers Plugin)"]
    
    GizmoRegistry["Gizmo Plugin Registry"]
    
    Node3DAdded["Node3D Added to Scene"]
    HasGizmo["_has_gizmo() Check"]
    CreateGizmo["_create_gizmo()"]
    GizmoInstance["EditorNode3DGizmo Instance"]
    
    CustomPlugin -.inherits.-> EditorNode3DGizmoPlugin
    EditorPlugin --> AddGizmo
    AddGizmo --> Node3DEditor
    Node3DEditor --> GizmoRegistry
    
    Node3DAdded --> HasGizmo
    HasGizmo --> |"Returns true"| CreateGizmo
    CreateGizmo --> GizmoInstance
```

### Key Gizmo Responsibilities

The gizmo system (detailed in [Gizmo System](#9.3)) provides:

1. **Visual Elements** - Lines, meshes, billboards for visualization
2. **Collision Shapes** - For selection and picking
3. **Handles** - Interactive points for direct manipulation
4. **Subgizmos** - Multi-element selection (e.g., path curve points)
5. **Materials** - Pre-configured materials for consistent appearance

The Node3D Editor queries registered `EditorNode3DGizmoPlugin` instances to determine which nodes should receive gizmos and delegates all visual editing to the gizmo system.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:1-219](), [doc/classes/EditorNode3DGizmo.xml:1-219]()

---

## Spatial Editing Features

### Grid and Snapping

The Node3D Editor provides visual grid planes and snapping functionality:

- **Grid Planes** - Configurable XY/YZ/XZ reference grids
- **Translation Snap** - Snap movements to grid intervals
- **Rotation Snap** - Snap rotations to angle increments (e.g., 15Â°, 30Â°, 45Â°)
- **Scale Snap** - Snap scale values to fixed increments

### View Options

| Option | Purpose |
|--------|---------|
| Wireframe | Display node geometry as wireframe |
| Overdraw | Show all geometry without depth culling |
| Lighting | Enable/disable real-time lighting |
| Shadows | Toggle shadow rendering |
| Origin Gizmo | Show coordinate system origin axes |
| Grid | Toggle grid plane visibility |

### Lock and Group

The editor respects node locking and grouping:
- **Locked Nodes** - Cannot be selected or moved in viewport (editable in inspector)
- **Grouped Nodes** - Selected and transformed as a unit

**Sources:** General 3D editor conventions and architecture diagrams

---

## Node3D Lifecycle in Editor

When a Node3D is added to the edited scene, the Node3D Editor performs the following:

```mermaid
sequenceDiagram
    participant Scene as "SceneTree"
    participant N3DEditor as "Node3DEditor"
    participant Plugins as "Registered GizmoPlugins"
    participant Gizmo as "EditorNode3DGizmo"
    participant Node as "Node3D Instance"
    
    Scene->>N3DEditor: "node_added signal"
    N3DEditor->>Plugins: "Iterate registered plugins"
    
    loop For each EditorNode3DGizmoPlugin
        N3DEditor->>Plugins: "_has_gizmo(node)"
        
        alt Plugin handles this node type
            Plugins-->>N3DEditor: "true"
            N3DEditor->>Plugins: "_create_gizmo(node)"
            Plugins->>Gizmo: "Create EditorNode3DGizmo"
            Gizmo->>Gizmo: "_redraw()"
            Gizmo-->>Node: "Attach to Node3D"
        else Plugin doesn't handle node
            Plugins-->>N3DEditor: "false"
        end
    end
    
    Note over N3DEditor,Node: "Gizmo now provides visual editing"
```

Each plugin's `_has_gizmo()` method is queried to determine if it should provide a gizmo for the node. Plugins with higher priority (see `_get_priority()`) are checked first and can take precedence over built-in gizmos.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:101-107](), [doc/classes/EditorNode3DGizmoPlugin.xml:53-59](), [doc/classes/EditorNode3DGizmoPlugin.xml:86-92]()

---

## Handle and Subgizmo Systems

### Handle System

Handles are interactive control points that allow direct manipulation of node properties. The handle workflow involves:

| Phase | Method | Description |
|-------|--------|-------------|
| Display | `add_handles()` | Add handle positions during `_redraw()` |
| Begin Edit | `_begin_handle_action()` | Called when drag starts |
| Get Value | `_get_handle_value()` | Store initial value for undo |
| Update | `_set_handle()` | Live update during drag |
| Commit | `_commit_handle()` | Create UndoRedo action on release |

Handles support a **secondary** mode (enabled with Shift key) that allows multiple overlapping handles with different selection priorities.

### Subgizmo System

Subgizmos enable selection and manipulation of sub-elements within a node:

```mermaid
graph TB
    User["User Interaction"]
    
    RaySelect["_subgizmos_intersect_ray()<br/>(Click Selection)"]
    FrustumSelect["_subgizmos_intersect_frustum()<br/>(Box Selection)"]
    
    SubGizmoIDs["Subgizmo ID Array"]
    
    GetTransform["_get_subgizmo_transform()<br/>(Store Initial)"]
    SetTransform["_set_subgizmo_transform()<br/>(Live Update)"]
    CommitSubgizmos["_commit_subgizmos()<br/>(UndoRedo)"]
    
    User --> |"Click"| RaySelect
    User --> |"Drag Box"| FrustumSelect
    
    RaySelect --> SubGizmoIDs
    FrustumSelect --> SubGizmoIDs
    
    SubGizmoIDs --> GetTransform
    GetTransform --> SetTransform
    SetTransform --> CommitSubgizmos
```

Common subgizmo use cases:
- **Path3D** - Individual curve control points
- **CSGPolygon3D** - Polygon vertices
- **Skeleton3D** - Individual bones

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:130-151](), [doc/classes/EditorNode3DGizmoPlugin.xml:152-169](), [doc/classes/EditorNode3DGizmo.xml:130-142]()

---

## Material Management

The gizmo plugin system provides helper methods for creating consistent materials:

### Material Creation Methods

| Method | Purpose | Variants |
|--------|---------|----------|
| `create_material()` | Basic unshaded material | Selected, editable states |
| `create_handle_material()` | Handle-specific material | Selected, editable states |
| `create_icon_material()` | Billboard icon material | Selected, editable states |
| `add_material()` | Register custom material | Direct material storage |

All materials support automatic variant generation for different gizmo states:
- **Default** - Normal display
- **Selected** - When node is selected (typically highlighted/brighter)
- **Editable** - When gizmo is being actively edited

### Material Retrieval

The `get_material()` method retrieves stored materials with automatic variant selection based on the gizmo's current state:

```gdscript
# In EditorNode3DGizmoPlugin subclass
var material = get_material("line_material", gizmo)
# Returns appropriate variant (default/selected/editable) automatically
```

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:170-216]()

---

## Coordinate Space Handling

Transform operations in the Node3D Editor operate in different coordinate spaces:

| Space | Description | Usage |
|-------|-------------|-------|
| **World Space** | Global coordinate system | Positioning in scene |
| **Local Space** | Node's own coordinate system | Rotation and scale relative to parent |
| **View Space** | Camera-relative coordinates | Screen-space calculations |

### Transform Space Conversion

Gizmo handles and subgizmo transforms are always specified in **local space** relative to the Node3D being edited. The Node3D Editor handles conversion between spaces:

```mermaid
graph LR
    WorldTransform["World Transform<br/>(Global Position)"]
    LocalTransform["Local Transform<br/>(Relative to Parent)"]
    
    HandlePos["Handle Position<br/>(Gizmo Local Space)"]
    
    Node3D["Node3D Instance"]
    
    WorldTransform --> |"Node3D.global_transform"| Node3D
    Node3D --> |"Node3D.transform"| LocalTransform
    
    HandlePos --> |"Relative to node"| LocalTransform
```

This design allows gizmo plugins to work independently of the node's position in the scene hierarchy.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:42-51](), [doc/classes/EditorNode3DGizmo.xml:92-99]()3c:T4cfd,# Gizmo System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/EditorNode3DGizmo.xml](doc/classes/EditorNode3DGizmo.xml)
- [doc/classes/EditorNode3DGizmoPlugin.xml](doc/classes/EditorNode3DGizmoPlugin.xml)
- [doc/classes/Node3DGizmo.xml](doc/classes/Node3DGizmo.xml)

</details>



## Purpose and Scope

The Gizmo System provides interactive visual editing tools for `Node3D` objects in the Godot editor's 3D viewport. Gizmos are visual overlays that allow users to manipulate 3D node properties through direct viewport interaction, such as dragging handles to resize objects or selecting subcomponents for editing.

This page covers the gizmo architecture (`EditorNode3DGizmoPlugin`, `EditorNode3DGizmo`, `Node3DGizmo`), visual element types (handles, lines, meshes), interaction patterns (handle editing, subgizmo selection), and custom gizmo development. For general editor architecture, see [Editor Core](#8). For 3D node types, see [Scene System](#4).

## System Architecture of the Gizmo System

The Gizmo System uses a plugin-based architecture where `EditorNode3DGizmoPlugin` classes define gizmo behavior for specific node types, and `EditorNode3DGizmo` instances provide the actual visual representation and interaction logic.

### Class Hierarchy of the Gizmo System

```mermaid
classDiagram
    class "Node3DGizmo" {
        <<abstract>>
        +RefCounted base
    }
    
    class "EditorNode3DGizmo" {
        +add_lines()
        +add_mesh()
        +add_handles()
        +add_collision_segments()
        +add_collision_triangles()
        +add_unscaled_billboard()
        +clear()
        +get_node_3d()
        +get_plugin()
        +get_subgizmo_selection()
        +is_subgizmo_selected()
        +_redraw()
        +_set_handle()
        +_commit_handle()
        +_get_handle_value()
        +_set_subgizmo_transform()
        +_commit_subgizmos()
    }
    
    class "EditorNode3DGizmoPlugin" {
        +Resource base
        +create_material()
        +create_handle_material()
        +create_icon_material()
        +add_material()
        +get_material()
        +_has_gizmo()
        +_create_gizmo()
        +_get_gizmo_name()
        +_get_priority()
        +_can_be_hidden()
        +_is_selectable_when_hidden()
        +_redraw()
        +_set_handle()
        +_commit_handle()
        +_set_subgizmo_transform()
        +_commit_subgizmos()
    }
    
    class "Node3D" {
        +add_gizmo()
    }
    
    class "EditorPlugin" {
        +add_node_3d_gizmo_plugin()
    }

    "Node3DGizmo" <|-- "EditorNode3DGizmo"
    "EditorNode3DGizmo" --> "EditorNode3DGizmoPlugin" : "owned by"
    "EditorNode3DGizmo" --> "Node3D" : "attached to"
    "EditorNode3DGizmoPlugin" --> "EditorPlugin" : "registered via"
```

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:1-218](), [doc/classes/EditorNode3DGizmo.xml:1-218](), [doc/classes/Node3DGizmo.xml:1-12]()

### Plugin Registration and Gizmo Creation in the Gizmo System

```mermaid
sequenceDiagram
    participant "EP" as "EditorPlugin"
    participant "EPList" as "Plugin Registry"
    participant "Plugin" as "EditorNode3DGizmoPlugin"
    participant "Node" as "Node3D"
    participant "Gizmo" as "EditorNode3DGizmo"

    "EP"->>"EPList": add_node_3d_gizmo_plugin(plugin)
    "EPList"->>"EPList": Store plugin reference
    
    Note over "Node": Node3D added to scene
    
    "EPList"->>"Plugin": _has_gizmo(for_node_3d)
    "Plugin"-->>"EPList": return true/false
    
    alt Has Gizmo
        "EPList"->>"Plugin": _create_gizmo(for_node_3d)
        "Plugin"->>"Gizmo": Create EditorNode3DGizmo instance
        "Gizmo"->>"Node": set_node_3d(node)
        "Plugin"-->>"EPList": Return gizmo
        "EPList"->>"Gizmo": Request initial redraw
    end
```

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:8-8](), [doc/classes/EditorNode3DGizmoPlugin.xml:53-58](), [doc/classes/EditorNode3DGizmoPlugin.xml:101-106]()

## Gizmo Lifecycle in the Gizmo System

### Node-Gizmo Association in the Gizmo System

When a `Node3D` is added to the editor scene, the Gizmo System queries all registered `EditorNode3DGizmoPlugin` instances to determine which gizmos apply:

1. **Detection Phase**: Each plugin's `_has_gizmo(for_node_3d)` method is called.
2. **Creation Phase**: If `_has_gizmo()` returns `true`, the plugin's `_create_gizmo(for_node_3d)` method instantiates an `EditorNode3DGizmo`.
3. **Initialization Phase**: The gizmo is associated with the node via `set_node_3d()`.
4. **Redraw Phase**: The gizmo's `_redraw()` method is called to create visual elements.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:101-106](), [doc/classes/EditorNode3DGizmoPlugin.xml:53-58](), [doc/classes/EditorNode3DGizmo.xml:210-215]()

### Redraw Mechanism of the Gizmo System

The `_redraw()` method is the primary entry point for building gizmo visual elements. It is invoked when:
- The gizmo is first created.
- Node properties change.
- The gizmo becomes visible/hidden.
- Selection state changes.

Typical `_redraw()` implementation pattern in the Gizmo System:

```mermaid
flowchart TD
    Start["_redraw() called"]
    Clear["clear()"]
    CheckProps["Check node properties"]
    AddVisuals["Add visual elements:<br/>- add_lines()<br/>- add_mesh()<br/>- add_handles()<br/>- add_unscaled_billboard()"]
    AddCollision["Add collision geometry:<br/>- add_collision_segments()<br/>- add_collision_triangles()"]
    End["Gizmo updated"]
    
    Start --> Clear
    Clear --> CheckProps
    CheckProps --> AddVisuals
    AddVisuals --> AddCollision
    AddCollision --> End
```

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:123-128](), [doc/classes/EditorNode3DGizmo.xml:75-79](), [doc/classes/EditorNode3DGizmo.xml:172-176]()

## Visual Elements in the Gizmo System

The Gizmo System supports multiple types of visual elements that can be added during the `_redraw()` method.

### Visual Element Types in the Gizmo System

| Method | Purpose | Parameters |
|--------|---------|------------|
| `add_lines()` | Draw line segments for wireframes or outlines | `lines` (PackedVector3Array), `material`, `billboard`, `modulate` |
| `add_mesh()` | Display a 3D mesh | `mesh`, `material`, `transform`, `skeleton` |
| `add_handles()` | Add interactive drag points | `handles` (positions), `material`, `ids`, `billboard`, `secondary` |
| `add_unscaled_billboard()` | Add icon that maintains screen size | `material`, `default_scale`, `modulate` |
| `add_collision_segments()` | Define line collision for picking | `segments` (PackedVector3Array) |
| `add_collision_triangles()` | Define mesh collision for picking | `triangles` (TriangleMesh) |

**Sources:** [doc/classes/EditorNode3DGizmo.xml:143-151](), [doc/classes/EditorNode3DGizmo.xml:153-161](), [doc/classes/EditorNode3DGizmo.xml:130-141](), [doc/classes/EditorNode3DGizmo.xml:163-170](), [doc/classes/EditorNode3DGizmo.xml:116-121](), [doc/classes/EditorNode3DGizmo.xml:123-128]()

### Material Management in the Gizmo System

Materials for gizmo visual elements are managed by the `EditorNode3DGizmoPlugin`. Plugins create materials during initialization and retrieve them during redraw in the Gizmo System:

```mermaid
flowchart LR
    Plugin["EditorNode3DGizmoPlugin"]
    Create1["create_material(name, color, ...)"]
    Create2["create_handle_material(name, ...)"]
    Create3["create_icon_material(name, texture, ...)"]
    Store["Internal material cache"]
    Retrieve["get_material(name, gizmo)"]
    Variants["Returns variant based on:<br/>- Selected state<br/>- Editable state"]
    
    Plugin --> Create1
    Plugin --> Create2
    Plugin --> Create3
    Create1 --> Store
    Create2 --> Store
    Create3 --> Store
    Plugin --> Retrieve
    Store --> Retrieve
    Retrieve --> Variants
```

Material creation methods automatically generate state variants (normal, selected, editable) that are returned by `get_material()` based on gizmo state.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:198-207](), [doc/classes/EditorNode3DGizmoPlugin.xml:178-186](), [doc/classes/EditorNode3DGizmoPlugin.xml:188-196](), [doc/classes/EditorNode3DGizmoPlugin.xml:209-216]()

## Handle System in the Gizmo System

Handles are interactive control points that allow users to modify node properties by dragging in the 3D viewport in the Gizmo System.

### Handle Workflow in the Gizmo System

```mermaid
sequenceDiagram
    participant "User"
    participant "Viewport" as "3D Viewport"
    participant "Gizmo" as "EditorNode3DGizmo"
    participant "Plugin" as "EditorNode3DGizmoPlugin"
    participant "Node" as "Node3D"
    
    Note over "User","Node": Handle Creation
    "Viewport"->>"Gizmo": _redraw()
    "Gizmo"->>"Gizmo": add_handles(positions, material, ids)
    
    Note over "User","Node": Handle Interaction Start
    "User"->>"Viewport": Click handle
    "Viewport"->>"Plugin": _begin_handle_action(gizmo, handle_id, secondary)
    "Viewport"->>"Plugin": _get_handle_value(gizmo, handle_id, secondary)
    "Plugin"-->>"Viewport": Return current value (for undo)
    
    Note over "User","Node": Handle Dragging
    "User"->>"Viewport": Drag handle
    "Viewport"->>"Plugin": _set_handle(gizmo, handle_id, secondary, camera, screen_pos)
    "Plugin"->>"Node": Update node properties
    "Plugin"->>"Gizmo": Request redraw (optional)
    
    Note over "User","Node": Handle Commit
    "User"->>"Viewport": Release handle
    "Viewport"->>"Plugin": _commit_handle(gizmo, handle_id, secondary, restore, cancel)
    "Plugin"->>"Plugin": Create UndoRedo action
```

**Sources:** [doc/classes/EditorNode3DGizmo.xml:130-141](), [doc/classes/EditorNode3DGizmoPlugin.xml:14-21](), [doc/classes/EditorNode3DGizmoPlugin.xml:75-84](), [doc/classes/EditorNode3DGizmoPlugin.xml:130-141](), [doc/classes/EditorNode3DGizmoPlugin.xml:28-40]()

### Primary vs Secondary Handles in the Gizmo System

Handles can be marked as primary or secondary using the `secondary` parameter in `add_handles()` in the Gizmo System:

- **Primary handles**: Default selection priority, always selectable.
- **Secondary handles**: Lower selection priority, but gain priority when Shift is held.

This allows multiple handles to be placed at the same location with user-controlled selection priority.

**Sources:** [doc/classes/EditorNode3DGizmo.xml:130-141]()

### Handle Name and Highlighting in the Gizmo System

Plugins provide handle metadata through virtual methods in the Gizmo System:

- `_get_handle_name(gizmo, handle_id, secondary)`: Returns display name shown to user.
- `_is_handle_highlighted(gizmo, handle_id, secondary)`: Returns whether handle should be highlighted.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:66-73](), [doc/classes/EditorNode3DGizmoPlugin.xml:108-115]()

## Subgizmo System in the Gizmo System

Subgizmos enable selection and transformation of node sub-components (e.g., individual points in a path, bones in a skeleton) in the Gizmo System.

### Subgizmo Selection in the Gizmo System

```mermaid
flowchart TD
    UserInput["User input:<br/>Click or Box Select"]
    
    ClickPath["Click Selection"]
    BoxPath["Box Selection"]
    
    RayIntersect["_subgizmos_intersect_ray(gizmo, camera, screen_pos)"]
    FrustumIntersect["_subgizmos_intersect_frustum(gizmo, camera, frustum_planes)"]
    
    ReturnID["Return subgizmo ID(s)"]
    GetTransform["_get_subgizmo_transform(gizmo, subgizmo_id)"]
    StoreRestore["Store transform for undo"]
    
    UpdateLoop["User drags selection"]
    SetTransform["_set_subgizmo_transform(gizmo, subgizmo_id, transform)"]
    UpdateNode["Update node properties"]
    
    Commit["User releases"]
    CommitSubgizmos["_commit_subgizmos(gizmo, ids, restores, cancel)"]
    CreateUndo["Create UndoRedo action"]
    
    UserInput --> ClickPath
    UserInput --> BoxPath
    
    ClickPath --> RayIntersect
    BoxPath --> FrustumIntersect
    
    RayIntersect --> ReturnID
    FrustumIntersect --> ReturnID
    
    ReturnID --> GetTransform
    GetTransform --> StoreRestore
    StoreRestore --> UpdateLoop
    
    UpdateLoop --> SetTransform
    SetTransform --> UpdateNode
    UpdateNode --> UpdateLoop
    
    UpdateLoop --> Commit
    Commit --> CommitSubgizmos
    CommitSubgizmos --> CreateUndo
```

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:161-168](), [doc/classes/EditorNode3DGizmoPlugin.xml:152-159](), [doc/classes/EditorNode3DGizmoPlugin.xml:93-99](), [doc/classes/EditorNode3DGizmoPlugin.xml:143-150](), [doc/classes/EditorNode3DGizmoPlugin.xml:42-51]()

### Subgizmo Identifiers in the Gizmo System

Subgizmos are identified by non-negative integers defined by the plugin implementation in the Gizmo System. These IDs are used across all subgizmo-related virtual methods:

- `_subgizmos_intersect_ray()` / `_subgizmos_intersect_frustum()`: Return selected IDs.
- `_get_subgizmo_transform(gizmo, subgizmo_id)`: Get transform for specific subgizmo.
- `_set_subgizmo_transform(gizmo, subgizmo_id, transform)`: Update specific subgizmo.
- `_commit_subgizmos(gizmo, ids, restores, cancel)`: Commit multiple subgizmo changes.

All transforms are in the node's local coordinate system.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:93-99](), [doc/classes/EditorNode3DGizmoPlugin.xml:143-150](), [doc/classes/EditorNode3DGizmoPlugin.xml:42-51]()

### Subgizmo Selection State in the Gizmo System

During `_redraw()`, gizmos can query selection state to provide visual feedback in the Gizmo System:

- `get_subgizmo_selection()`: Returns array of currently selected subgizmo IDs.
- `is_subgizmo_selected(id)`: Checks if specific subgizmo is selected.

**Sources:** [doc/classes/EditorNode3DGizmo.xml:190-194](), [doc/classes/EditorNode3DGizmo.xml:196-201]()

## Plugin Configuration in the Gizmo System

### Priority System in the Gizmo System

The `_get_priority()` method determines processing order when multiple gizmos apply to the same node or screen position in the Gizmo System:

- Built-in editor gizmos return `-1`.
- Custom gizmos default to `0` if not overridden.
- Higher priority values take precedence.

This allows custom gizmos to override built-in behavior or establish precedence between multiple custom gizmos.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:86-91]()

### Visibility Configuration in the Gizmo System

Plugins control gizmo visibility behavior in the Gizmo System:

- `_can_be_hidden()`: Returns whether gizmo appears in visibility menu (default `true`).
- `_is_selectable_when_hidden()`: Returns whether nodes are selectable when gizmo is hidden (default `false`).
- `set_hidden(hidden)`: Programmatically show/hide gizmo.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:22-26](), [doc/classes/EditorNode3DGizmoPlugin.xml:117-121](), [doc/classes/EditorNode3DGizmo.xml:203-208]()

### Gizmo Name in the Gizmo System

The `_get_gizmo_name()` method provides the display name shown in the gizmo visibility menu and editor interface in the Gizmo System.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:60-64]()

## Custom Gizmo Development in the Gizmo System

### Basic Plugin Implementation in the Gizmo System

To create a custom gizmo plugin in the Gizmo System:

1. **Extend `EditorNode3DGizmoPlugin`** in a script.
2. **Override `_has_gizmo(for_node_3d)`** to identify target nodes.
3. **Override `_get_gizmo_name()`** to provide display name.
4. **Override `_redraw(gizmo)`** to construct visual elements.
5. **Register plugin** via `EditorPlugin.add_node_3d_gizmo_plugin()`.

```mermaid
classDiagram
    class MyCustomGizmoPlugin {
        <<extends EditorNode3DGizmoPlugin>>
        +_has_gizmo(for_node_3d)
        +_get_gizmo_name()
        +_redraw(gizmo)
        +_init()
    }
    
    class MyEditorPlugin {
        <<extends EditorPlugin>>
        +_enter_tree()
        +_exit_tree()
    }
    
    MyEditorPlugin --> MyCustomGizmoPlugin : creates and registers
```

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:7-8](), [doc/classes/EditorNode3DGizmoPlugin.xml:101-106](), [doc/classes/EditorNode3DGizmoPlugin.xml:60-64](), [doc/classes/EditorNode3DGizmoPlugin.xml:123-128]()

### Advanced Gizmo Implementation in the Gizmo System

For complex gizmos requiring custom behavior in the Gizmo System, extend `EditorNode3DGizmo` directly:

1. **Create custom `EditorNode3DGizmo` subclass** with specialized behavior.
2. **Override plugin's `_create_gizmo()`** to return custom gizmo instance.
3. **Override gizmo's virtual methods** for handle/subgizmo interaction.

The plugin delegates most interaction logic to the gizmo instance, allowing fine-grained control.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:7-7](), [doc/classes/EditorNode3DGizmoPlugin.xml:53-58](), [doc/classes/EditorNode3DGizmo.xml:7-7]()

### Material Initialization Pattern in the Gizmo System

Materials should be created once during plugin initialization in the Gizmo System:

```mermaid
flowchart TD
    PluginInit["Plugin _init() or _enter_tree()"]
    CreateMats["Create materials:<br/>- create_material('lines', color)<br/>- create_handle_material('handles')<br/>- create_icon_material('icon', texture)"]
    StoredInternal["Stored in plugin's<br/>internal material cache"]
    RedrawCalls["During _redraw()"]
    GetMat["get_material('lines', gizmo)"]
    AutoVariant["Automatically returns<br/>correct variant based on<br/>gizmo state"]
    UseMat["Use in add_lines(),<br/>add_mesh(), etc."]
    
    PluginInit --> CreateMats
    CreateMats --> StoredInternal
    RedrawCalls --> GetMat
    StoredInternal --> GetMat
    GetMat --> AutoVariant
    AutoVariant --> UseMat
```

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:198-207](), [doc/classes/EditorNode3DGizmoPlugin.xml:178-186](), [doc/classes/EditorNode3DGizmoPlugin.xml:188-196](), [doc/classes/EditorNode3DGizmoPlugin.xml:209-216]()

### UndoRedo Integration in the Gizmo System

Handle and subgizmo commits should create `UndoRedo` actions for proper undo/redo support in the Gizmo System:

| Commit Method | Purpose | UndoRedo Pattern |
|---------------|---------|------------------|
| `_commit_handle()` | Finalize handle edit | Store `restore` value as undo, current value as redo. |
| `_commit_subgizmos()` | Finalize subgizmo edit | Store `restores` transforms as undo, current transforms as redo. |

When `cancel` parameter is `true`, restore values should be applied directly without creating an undo action (user cancelled the operation) in the Gizmo System.

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:28-40](), [doc/classes/EditorNode3DGizmoPlugin.xml:42-51]()

## Collision and Picking in the Gizmo System

### Collision Geometry in the Gizmo System

Collision geometry enables viewport picking of gizmo elements in the Gizmo System:

- **`add_collision_segments(segments)`**: Adds line-based collision for picking lines/edges.
- **`add_collision_triangles(triangles)`**: Adds mesh-based collision for picking solid geometry.

Collision geometry is separate from visual geometry and should be added during `_redraw()` to match visible elements in the Gizmo System.

**Sources:** [doc/classes/EditorNode3DGizmo.xml:116-121](), [doc/classes/EditorNode3DGizmo.xml:123-128]()

### Interaction Priority in the Gizmo System

When multiple interactive elements overlap in the viewport, priority is determined by the Gizmo System:

1. **Plugin priority** (via `_get_priority()`).
2. **Handle type** (secondary vs primary, modified by Shift key).
3. **Subgizmo ID** (plugin-defined precedence).

**Sources:** [doc/classes/EditorNode3DGizmoPlugin.xml:86-91](), [doc/classes/EditorNode3DGizmo.xml:130-141]()3d:T3928,# Editor UI Tools

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/extension/gdextension_special_compat_hashes.cpp](core/extension/gdextension_special_compat_hashes.cpp)
- [core/extension/gdextension_special_compat_hashes.h](core/extension/gdextension_special_compat_hashes.h)
- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [doc/classes/CodeEdit.xml](doc/classes/CodeEdit.xml)
- [doc/classes/Label.xml](doc/classes/Label.xml)
- [doc/classes/LabelSettings.xml](doc/classes/LabelSettings.xml)
- [doc/classes/LineEdit.xml](doc/classes/LineEdit.xml)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/RichTextLabel.xml](doc/classes/RichTextLabel.xml)
- [doc/classes/TextEdit.xml](doc/classes/TextEdit.xml)
- [doc/classes/TextLine.xml](doc/classes/TextLine.xml)
- [doc/classes/TextParagraph.xml](doc/classes/TextParagraph.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [editor/editor_log.cpp](editor/editor_log.cpp)
- [editor/editor_log.h](editor/editor_log.h)
- [scene/SCsub](scene/SCsub)
- [scene/gui/code_edit.cpp](scene/gui/code_edit.cpp)
- [scene/gui/code_edit.h](scene/gui/code_edit.h)
- [scene/gui/label.cpp](scene/gui/label.cpp)
- [scene/gui/label.h](scene/gui/label.h)
- [scene/gui/line_edit.cpp](scene/gui/line_edit.cpp)
- [scene/gui/line_edit.h](scene/gui/line_edit.h)
- [scene/gui/rich_text_label.compat.inc](scene/gui/rich_text_label.compat.inc)
- [scene/gui/rich_text_label.cpp](scene/gui/rich_text_label.cpp)
- [scene/gui/rich_text_label.h](scene/gui/rich_text_label.h)
- [scene/gui/text_edit.cpp](scene/gui/text_edit.cpp)
- [scene/gui/text_edit.h](scene/gui/text_edit.h)
- [scene/resources/3d/world_3d.cpp](scene/resources/3d/world_3d.cpp)
- [scene/resources/3d/world_3d.h](scene/resources/3d/world_3d.h)
- [scene/resources/SCsub](scene/resources/SCsub)
- [scene/resources/label_settings.cpp](scene/resources/label_settings.cpp)
- [scene/resources/label_settings.h](scene/resources/label_settings.h)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)
- [scene/resources/text_line.cpp](scene/resources/text_line.cpp)
- [scene/resources/text_line.h](scene/resources/text_line.h)
- [scene/resources/text_paragraph.cpp](scene/resources/text_paragraph.cpp)
- [scene/resources/text_paragraph.h](scene/resources/text_paragraph.h)
- [servers/SCsub](servers/SCsub)
- [servers/register_server_types.cpp](servers/register_server_types.cpp)
- [tests/display_server_mock.h](tests/display_server_mock.h)
- [tests/scene/test_code_edit.h](tests/scene/test_code_edit.h)
- [tests/scene/test_text_edit.h](tests/scene/test_text_edit.h)
- [tests/scene/test_viewport.h](tests/scene/test_viewport.h)
- [tests/test_macros.h](tests/test_macros.h)
- [tests/test_main.cpp](tests/test_main.cpp)
- [tests/test_tools.h](tests/test_tools.h)
- [tests/test_validate_testing.h](tests/test_validate_testing.h)

</details>



## Purpose and Scope

This document covers the editor-specific UI tools that form the primary interface for file management, code editing, and output display in the Godot editor. These tools are distinct from the base text editing components and provide specialized functionality for editor workflows.

For information about the high-level editor architecture and plugin system, see [Editor Core](#7). For details about editor plugins that provide viewport manipulation, see [Editor Plugins](#8). For in-depth coverage of base text rendering and editing components, see [Text Components](#10).

The three main subsystems covered by child pages are:
- **FileSystem Dock** ([9.1](#9.1)): Asset browser with EditorFileSystem scanning and file operations
- **Script Editor** ([9.2](#9.2)): Integrated code editing interface with debugging support
- **EditorLog & Output** ([9.3](#9.3)): Editor log panel with message filtering and rich text display

## Component Overview

The editor UI tools provide specialized interfaces for three main workflows:

| Tool | Primary Class | Purpose | Key Features |
|------|--------------|---------|--------------|
| FileSystem Dock | `FileSystemDock` | Asset browsing and management | Tree/list view, drag-drop, import settings, thumbnails |
| Script Editor | `ScriptEditor` | Code editing and debugging | Multi-tab interface, syntax highlighting, breakpoints |
| Editor Log | `EditorLog` | Output and error display | Message filtering, rich formatting, collapsing |

These tools integrate with base text components from [Text Components](#10) but add editor-specific functionality like file system integration, debugging support, and structured message display.

Sources: [editor/editor_log.cpp:31-50](), [editor/editor_log.h:1-50]()

## Editor UI Tools Architecture

```mermaid
graph TB
    subgraph "EditorNode Integration"
        EditorNode["EditorNode"]
        BottomPanel["EditorBottomPanel"]
        DockSlot["Editor Dock Slots"]
    end
    
    subgraph "File Management"
        FileSystemDock["FileSystemDock"]
        EditorFileSystem["EditorFileSystem"]
        DirAccess["DirAccess<br/>File I/O"]
        ResourceLoader["ResourceLoader<br/>Asset loading"]
    end
    
    subgraph "Script Editing"
        ScriptEditor["ScriptEditor"]
        ScriptEditorBase["ScriptEditorBase<br/>Tab interface"]
        CodeEdit["CodeEdit<br/>Text editing"]
        ScriptLanguage["ScriptLanguage<br/>Completion/hints"]
    end
    
    subgraph "Output Display"
        EditorLog["EditorLog"]
        RichTextLabel["RichTextLabel<br/>Formatted display"]
        LogFilter["Message filtering"]
    end
    
    EditorNode --> DockSlot
    EditorNode --> BottomPanel
    
    DockSlot --> FileSystemDock
    BottomPanel --> EditorLog
    EditorNode --> ScriptEditor
    
    FileSystemDock --> EditorFileSystem
    EditorFileSystem --> DirAccess
    FileSystemDock --> ResourceLoader
    
    ScriptEditor --> ScriptEditorBase
    ScriptEditorBase --> CodeEdit
    CodeEdit --> ScriptLanguage
    
    EditorLog --> RichTextLabel
    EditorLog --> LogFilter
```

**Editor UI Tools Architecture**

This diagram shows how the three main editor UI tools integrate with `EditorNode` and their internal dependencies. `FileSystemDock` manages file browsing through `EditorFileSystem`, `ScriptEditor` provides code editing via `CodeEdit` tabs, and `EditorLog` displays formatted messages using `RichTextLabel`.

Sources: [editor/editor_log.cpp:31-50](), [editor/editor_log.h:1-50]()

## FileSystem Dock

`FileSystemDock` provides the file browsing interface in the editor, typically docked to the left side. It integrates with `EditorFileSystem` for asset scanning and import management.

**Key Responsibilities:**
- Display project files in tree or list view
- Handle drag-and-drop for file operations
- Show resource thumbnails and previews
- Manage file context menus for import/export
- Track and display file dependencies

The dock uses `Tree` and `ItemList` controls to display the file hierarchy and allows users to navigate, select, and manipulate project assets. Integration with `ResourceLoader` enables asset inspection and loading.

See [FileSystem Dock](#9.1) for detailed implementation.

Sources: Table of contents section 9.1

## Script Editor

`ScriptEditor` provides the integrated code editing interface, managing multiple open scripts in a tabbed layout. Each script tab contains a `CodeEdit` instance configured with appropriate syntax highlighting and code completion.

**Key Features:**
- Multi-tab script management
- Syntax highlighting via `SyntaxHighlighter` resources
- Code completion through `ScriptLanguage` interfaces
- Breakpoint management for debugging
- Find/replace with regex support
- Script validation and error display

The `ScriptEditor` coordinates with `EditorNode` to handle script opening, saving, and debugging integration. It uses `CodeEdit` from [Text Components](#10) as the underlying text editing control.

See [Script Editor](#9.2) for detailed implementation.

Sources: Table of contents section 9.2, [scene/gui/code_edit.h:40-43]()

## EditorLog

`EditorLog` provides the output panel for displaying engine messages, errors, and warnings. It uses `RichTextLabel` for formatted text display with collapsible message groups.

**Key Features:**
- Message type filtering (errors, warnings, info)
- Collapsible message groups for repeated messages
- Rich text formatting with BBCode
- Clickable file paths for navigation
- Message history and search
- Copy to clipboard functionality

The log panel appears in the editor's bottom panel and receives messages from the engine's logging system through `_error_handler` callbacks.

See [EditorLog & Output](#9.3) for detailed implementation.

Sources: [editor/editor_log.cpp:50-100](), [editor/editor_log.h:1-50]()

## Message Flow and Logging

```mermaid
graph LR
    subgraph "Engine Sources"
        CoreError["ERR_PRINT<br/>ERR_FAIL"]
        Print["print_line<br/>print_verbose"]
        ScriptError["Script errors"]
    end
    
    subgraph "Logging System"
        ErrorHandler["_error_handler<br/>callback"]
        MessageQueue["Message queue"]
        MessageType["MessageType<br/>ERROR/WARNING/EDITOR"]
    end
    
    subgraph "EditorLog Display"
        LogMessage["LogMessage struct"]
        RichTextLabel["RichTextLabel<br/>Formatted display"]
        LogFilter["Message filtering"]
        CollapseGroups["Collapsible groups"]
    end
    
    CoreError --> ErrorHandler
    Print --> ErrorHandler
    ScriptError --> ErrorHandler
    
    ErrorHandler --> MessageQueue
    MessageQueue --> MessageType
    
    MessageType --> LogMessage
    LogMessage --> RichTextLabel
    LogMessage --> LogFilter
    LogMessage --> CollapseGroups
```

**Message Flow and Logging**

This diagram shows how messages flow from various engine sources through the logging system to the `EditorLog` display. Error macros, print statements, and script errors all route through `_error_handler` callbacks, which queue messages by type before displaying them in the log panel with filtering and grouping.

Sources: [editor/editor_log.cpp:50-100](), [editor/editor_log.h:1-50]()

## Integration with Base Components

The editor UI tools build upon base text and GUI components from other subsystems:

**Text Editing Foundation:**
- `CodeEdit`: Provides code-specific editing features (see [Text Components](#10))
- `TextEdit`: Base multiline text editor with caret and selection
- `RichTextLabel`: Formatted text display with BBCode support
- `LineEdit`: Single-line text input for search and filters

**Resource Management:**
- `ResourceLoader`: Loads assets from disk (see [Resource System](#5))
- `EditorFileSystem`: Scans and indexes project files
- `ResourcePreviewGenerator`: Generates thumbnails for assets

**Communication:**
- `EditorNode`: Central orchestrator for editor state
- Signals and callbacks for cross-component communication
- Message passing through editor singleton

The tools coordinate with `EditorNode` for global state management while maintaining independent functionality for their specific domains.

Sources: [scene/gui/code_edit.h:40-43](), [scene/gui/rich_text_label.h:47-48](), [core/io/resource_loader.h:1-50]()

## Key Data Structures

### EditorLog::LogMessage

Messages in the editor log are stored with metadata:

```cpp
struct LogMessage {
    String text;              // Message content
    MessageType type;         // ERROR, WARNING, EDITOR
    int count;                // Repetition count for collapsing
    bool clear;               // Clear previous messages
}
```

Messages are grouped when identical, with a count displayed to reduce clutter. The `type` field determines styling and filtering behavior.

Sources: [editor/editor_log.cpp:50-100](), [editor/editor_log.h:1-50]()

### FileSystemDock State

File system state tracks the current view and selection:

```cpp
struct FileSystemDock {
    Tree *tree;                      // Tree view widget
    ItemList *files;                 // List view widget
    Vector<String> history;          // Navigation history
    String current_path;             // Active directory
    EditorFileSystem *filesystem;    // Scanning backend
}
```

The dock maintains parallel tree and list views, allowing users to switch between visualization modes while preserving selection state.

Sources: Table of contents section 9.1

### ScriptEditor Tab Management

Each open script is represented by a tab structure:

```cpp
struct ScriptEditorBase {
    Ref<Script> script;              // Script resource
    CodeEdit *editor;                // Text editing widget
    bool is_modified;                // Unsaved changes flag
    Vector<int> breakpoints;         // Debug breakpoints
}
```

The `ScriptEditor` manages a collection of these tabs, coordinating save operations and debugging state across all open scripts.

Sources: Table of contents section 9.2, [scene/gui/code_edit.h:40-43]()

## Testing Infrastructure

The editor UI tools have extensive test coverage:

- `TestTextEdit`: Tests text storage, caret movement, selection, undo/redo [tests/scene/test_text_edit.h]()
- `TestCodeEdit`: Tests code-specific features like completion, folding, indentation [tests/scene/test_code_edit.h]()
- Mock implementations for testing without full editor context [tests/test_main.cpp:327-428]()

The test suite validates core functionality like text insertion, deletion, caret management, and selection handling across all text editing components.

Sources: [tests/scene/test_text_edit.h:31-36](), [tests/scene/test_code_edit.h:31-33](), [tests/test_main.cpp:234-304]()3e:T50dc,# FileSystem Dock

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/io/resource.cpp](core/io/resource.cpp)
- [core/io/resource.h](core/io/resource.h)
- [core/io/resource_format_binary.cpp](core/io/resource_format_binary.cpp)
- [core/io/resource_format_binary.h](core/io/resource_format_binary.h)
- [core/io/resource_importer.cpp](core/io/resource_importer.cpp)
- [core/io/resource_importer.h](core/io/resource_importer.h)
- [core/io/resource_loader.cpp](core/io/resource_loader.cpp)
- [core/io/resource_loader.h](core/io/resource_loader.h)
- [core/io/resource_saver.cpp](core/io/resource_saver.cpp)
- [core/io/resource_saver.h](core/io/resource_saver.h)
- [doc/classes/Resource.xml](doc/classes/Resource.xml)
- [doc/classes/ResourceFormatLoader.xml](doc/classes/ResourceFormatLoader.xml)
- [doc/classes/ResourceFormatSaver.xml](doc/classes/ResourceFormatSaver.xml)
- [doc/classes/ResourceLoader.xml](doc/classes/ResourceLoader.xml)
- [doc/classes/ResourcePreloader.xml](doc/classes/ResourcePreloader.xml)
- [doc/classes/ResourceSaver.xml](doc/classes/ResourceSaver.xml)
- [doc/classes/ViewportTexture.xml](doc/classes/ViewportTexture.xml)
- [scene/resources/resource_format_text.cpp](scene/resources/resource_format_text.cpp)
- [scene/resources/resource_format_text.h](scene/resources/resource_format_text.h)

</details>



## Purpose and Scope

The FileSystem Dock is Godot's primary asset browser interface within the editor. It provides visual access to the project's file system, displays resource previews, handles file operations (import, move, delete, rename), and integrates with the EditorFileSystem scanning system to track and manage project resources. This document covers the asset browsing interface, file system scanning, resource preview generation, and file operation handling.

For information about resource loading and caching mechanisms, see [ResourceLoader](#5.1). For the resource import pipeline, see [Resource Import System](#5.4).

---

## System Architecture

The FileSystem Dock operates as the primary user-facing component for asset management, coordinating between the file system scanning backend (EditorFileSystem), the resource loading system, and the import pipeline.

```mermaid
graph TB
    subgraph "Editor UI Layer"
        FileSystemDock["FileSystemDock<br/>(Asset Browser UI)"]
        FileDialog["EditorFileDialog<br/>(File Selection)"]
    end
    
    subgraph "File System Backend"
        EditorFileSystem["EditorFileSystem<br/>(Scanning & Tracking)"]
        EditorFileSystemDirectory["EditorFileSystemDirectory<br/>(Directory Tree)"]
        EditorResourcePreview["EditorResourcePreview<br/>(Thumbnail Generation)"]
    end
    
    subgraph "Resource System"
        ResourceLoader["ResourceLoader<br/>(Loading API)"]
        ResourceFormatImporter["ResourceFormatImporter<br/>(Import Handler)"]
        ResourceUID["ResourceUID<br/>(UID Registry)"]
    end
    
    subgraph "File Operations"
        DirAccess["DirAccess<br/>(Directory Operations)"]
        FileAccess["FileAccess<br/>(File I/O)"]
    end
    
    FileSystemDock --> EditorFileSystem
    FileSystemDock --> EditorResourcePreview
    FileSystemDock --> FileDialog
    FileSystemDock --> DirAccess
    FileSystemDock --> FileAccess
    
    EditorFileSystem --> EditorFileSystemDirectory
    EditorFileSystem --> ResourceUID
    EditorFileSystem --> ResourceFormatImporter
    
    EditorResourcePreview --> ResourceLoader
    
    ResourceFormatImporter --> ResourceLoader
```

**Sources:** Architecture inferred from [editor/editor_node.h], [core/io/resource_loader.h:1-321](), [core/io/resource_importer.h:1-150]()

---

## Core Components

### FileSystemDock

The main UI component that displays the project file tree and provides interaction capabilities for asset management.

**Primary Responsibilities:**
- Display hierarchical file tree structure
- Show resource type icons and metadata
- Handle user interactions (click, drag, context menu)
- Coordinate file operations
- Display resource previews/thumbnails

### EditorFileSystem

The background scanning system that monitors the project directory and maintains an up-to-date registry of all resources.

**Key Functions:**

| Function | Purpose |
|----------|---------|
| Scan on startup | Initial directory traversal to build resource database |
| Watch for changes | Monitor file system events and update registry |
| Track dependencies | Maintain dependency graphs between resources |
| Manage imports | Trigger reimport when source files change |
| UID registration | Assign and track unique IDs for resources |

**Sources:** [core/io/resource_loader.cpp:289-360](), [core/io/resource_importer.cpp:43-155]()

---

## Resource Scanning and Tracking

### Scan Process

The EditorFileSystem performs a comprehensive scan of the project directory to catalog all resources:

```mermaid
graph LR
    Start["Scan Start"] --> TraverseDir["Traverse res://"]
    TraverseDir --> CheckFile["Check File Extension"]
    CheckFile --> Recognized{Recognized<br/>Format?}
    
    Recognized -->|Yes| CheckImport{Has .import<br/>File?}
    Recognized -->|No| Skip["Skip File"]
    
    CheckImport -->|Yes| ReadImport["Read .import Metadata"]
    CheckImport -->|No| DirectLoad["Direct Resource"]
    
    ReadImport --> ExtractUID["Extract UID"]
    DirectLoad --> ExtractUID
    
    ExtractUID --> RegisterUID["Register in ResourceUID"]
    RegisterUID --> UpdateTree["Update Directory Tree"]
    
    UpdateTree --> CheckDeps["Extract Dependencies"]
    CheckDeps --> MoreFiles{More<br/>Files?}
    
    MoreFiles -->|Yes| CheckFile
    MoreFiles -->|No| Complete["Scan Complete"]
```

**Sources:** [core/io/resource_loader.cpp:137-141](), [core/io/resource_importer.cpp:43-155]()

### Import File Structure

When a resource is imported, a `.import` file is created alongside the source file containing metadata:

```mermaid
graph TB
    SourceFile["source.png"] --> ImportFile[".import File"]
    
    ImportFile --> Remap["[remap] Section"]
    ImportFile --> Params["[params] Section"]
    ImportFile --> Deps["[deps] Section"]
    
    Remap --> PathField["path=.godot/imported/file.ctex"]
    Remap --> TypeField["type=CompressedTexture2D"]
    Remap --> ImporterField["importer=texture"]
    Remap --> UIDField["uid=uid://abc123"]
    
    Params --> ImportSettings["Import Settings<br/>(compress/hdr, etc)"]
    
    Deps --> SourceFile
    Deps --> ValidFlag["valid=true"]
```

**Import File Parsing:**

The ResourceFormatImporter reads `.import` files to locate processed resources:

**Sources:** [core/io/resource_importer.cpp:43-155](), [scene/resources/resource_format_text.cpp:924-972]()

---

## Resource Identification and UIDs

### ResourceUID System

Resources are tracked using unique identifiers (UIDs) to maintain references even when files are moved or renamed.

**UID Storage Mechanisms:**

| Resource Type | UID Storage Location |
|---------------|---------------------|
| Imported Resources | Inside `.import` file |
| Text Resources (.tres, .tscn) | Header `uid=` field |
| Binary Resources (.res, .scn) | Binary header section |
| Custom UID Support | Via ResourceFormatLoader override |

```mermaid
graph LR
    ResourceFile["Resource File"] --> CheckFormat{Format Type?}
    
    CheckFormat -->|Imported| ImportFile[".import File"]
    CheckFormat -->|Text Format| HeaderUID["uid= in Header"]
    CheckFormat -->|Binary Format| BinaryHeader["Binary UID Section"]
    CheckFormat -->|Custom| CustomMethod["_get_resource_uid()"]
    
    ImportFile --> UIDRegistry["ResourceUID Registry"]
    HeaderUID --> UIDRegistry
    BinaryHeader --> UIDRegistry
    CustomMethod --> UIDRegistry
    
    UIDRegistry --> PathLookup["Path â†” UID Mapping"]
```

**Sources:** [core/io/resource_loader.cpp:114-125](), [core/io/resource_loader.h:253](), [core/io/resource_format_binary.cpp:442-467]()

---

## Resource Loading Integration

### Load Flow Through FileSystem

When a resource is accessed through the FileSystem Dock, the following load sequence occurs:

```mermaid
sequenceDiagram
    participant FSD as FileSystemDock
    participant EFS as EditorFileSystem
    participant RL as ResourceLoader
    participant RFI as ResourceFormatImporter
    participant Cache as ResourceCache
    
    FSD->>EFS: Request resource info
    EFS->>EFS: Lookup in directory tree
    EFS-->>FSD: Return metadata
    
    FSD->>RL: load(path)
    RL->>RL: _validate_local_path()
    
    alt Resource in cache
        RL->>Cache: Check cache
        Cache-->>RL: Return cached resource
    else Not cached
        RL->>RFI: recognize_path()
        RFI->>RFI: Read .import file
        RFI->>RFI: Get imported path
        RFI->>RL: _load(imported_path)
        RL->>RL: Find format loader
        RL->>RL: Load resource
        RL->>Cache: Store in cache
    end
    
    RL-->>FSD: Return resource
```

**Sources:** [core/io/resource_loader.cpp:289-360](), [core/io/resource_loader.cpp:541-564](), [core/io/resource_importer.cpp:157-200]()

### Cache Modes

ResourceLoader supports different cache modes affecting how the FileSystem Dock loads resources:

| Cache Mode | Behavior |
|------------|----------|
| CACHE_MODE_IGNORE | Skip cache, load fresh copy |
| CACHE_MODE_REUSE | Use cached if available |
| CACHE_MODE_REPLACE | Replace cached with fresh load |
| CACHE_MODE_IGNORE_DEEP | Ignore cache recursively for dependencies |
| CACHE_MODE_REPLACE_DEEP | Replace cache recursively for dependencies |

**Sources:** [core/io/resource_loader.h:51-57]()

---

## Resource Preview System

### EditorResourcePreview

Generates and caches thumbnail previews for resources displayed in the FileSystem Dock.

**Preview Generation Architecture:**

```mermaid
graph TB
    subgraph "Preview Request"
        FileSystemDock["FileSystemDock"] --> RequestPreview["Request Preview"]
        RequestPreview --> CheckCache{Preview<br/>Cached?}
    end
    
    subgraph "Cache System"
        CheckCache -->|Yes| ReturnCached["Return Cached Thumbnail"]
        CheckCache -->|No| QueueGeneration["Queue Generation"]
    end
    
    subgraph "Generation Pipeline"
        QueueGeneration --> FindGenerator["Find Preview Generator"]
        FindGenerator --> LoadResource["Load Resource"]
        LoadResource --> GenerateThumbnail["Generate Thumbnail<br/>(handles, render, etc)"]
        GenerateThumbnail --> SaveCache["Save to Cache"]
        SaveCache --> ReturnNew["Return New Thumbnail"]
    end
    
    ReturnCached --> Display["Display in Dock"]
    ReturnNew --> Display
```

**Preview Generators:**

Different resource types have specialized preview generators:

| Resource Type | Generator Method |
|--------------|------------------|
| Texture2D | Direct image thumbnail |
| PackedScene | Render scene preview |
| Mesh | Render 3D preview |
| Material | Render material sphere |
| Script | Icon + script type |
| Audio | Waveform visualization |

**Sources:** Inferred from editor architecture patterns

---

## File Operations

### Supported Operations

The FileSystem Dock provides UI for common file operations:

```mermaid
graph TB
    UserAction["User Action"] --> ActionType{Action Type}
    
    ActionType -->|Import| ImportFlow["Import Operation"]
    ActionType -->|Move| MoveFlow["Move/Rename Operation"]
    ActionType -->|Delete| DeleteFlow["Delete Operation"]
    ActionType -->|Duplicate| DuplicateFlow["Duplicate Operation"]
    ActionType -->|Create| CreateFlow["Create New Resource"]
    
    ImportFlow --> ReimportCheck["Check Import Settings"]
    ReimportCheck --> TriggerImport["Trigger ResourceImporter"]
    TriggerImport --> UpdateRegistry["Update EditorFileSystem"]
    
    MoveFlow --> UpdateDeps["Update Dependencies"]
    UpdateDeps --> UpdateUID["Update UID Registry"]
    UpdateUID --> PhysicalMove["Move File on Disk"]
    PhysicalMove --> UpdateRegistry
    
    DeleteFlow --> CheckRefs["Check References"]
    CheckRefs --> ConfirmDialog["Confirmation Dialog"]
    ConfirmDialog --> PhysicalDelete["Delete from Disk"]
    PhysicalDelete --> UpdateRegistry
    
    DuplicateFlow --> CopyFile["Copy File"]
    CopyFile --> NewUID["Generate New UID"]
    NewUID --> UpdateRegistry
    
    CreateFlow --> ResourceSaver["ResourceSaver.save()"]
    ResourceSaver --> NewUID
```

**Sources:** [core/io/resource_saver.cpp:100-142](), [core/io/resource_loader.cpp:256-257]()

### Dependency Tracking

When moving or deleting resources, the FileSystem Dock must update all dependent resources:

**Dependency Update Process:**

```mermaid
graph LR
    FileMove["File Moved"] --> FindDeps["Find Dependent Resources"]
    FindDeps --> GetDeps["ResourceLoader.get_dependencies()"]
    
    GetDeps --> ParseExt["Parse ext_resource entries"]
    GetDeps --> ParseSub["Parse sub_resource entries"]
    
    ParseExt --> UpdatePath["Update resource paths"]
    ParseSub --> UpdatePath
    
    UpdatePath --> RenameDeps["rename_dependencies()"]
    RenameDeps --> SaveUpdated["Save updated resources"]
```

**Dependency Format:**

Resources reference dependencies using one of these formats:

```
# UID-based (preferred):
uid://abc123def456::Type::res://fallback/path.tres

# UID with fallback only:
uid://abc123def456::::res://fallback/path.tres

# Direct path:
res://path/to/resource.tres
```

**Sources:** [core/io/resource_loader.cpp:180-188](), [scene/resources/resource_format_text.cpp:924-972]()

---

## Import Workflow Integration

### Import Process

The FileSystem Dock triggers resource import when detecting new or modified source files:

```mermaid
graph TB
    FileDetected["Source File Detected"] --> CheckImporter{Has<br/>Importer?}
    
    CheckImporter -->|Yes| ReadSettings["Read Import Settings"]
    CheckImporter -->|No| SkipImport["Display as-is"]
    
    ReadSettings --> CheckModified{Modified Since<br/>Last Import?}
    
    CheckModified -->|Yes| ExecuteImport["Execute Importer"]
    CheckModified -->|No| UseExisting["Use Existing Import"]
    
    ExecuteImport --> ProcessAsset["Process Source Asset"]
    ProcessAsset --> GenerateOutput["Generate .godot Output"]
    GenerateOutput --> WriteImportFile["Write .import Metadata"]
    WriteImportFile --> RegisterUID["Register UID"]
    RegisterUID --> NotifyDock["Notify FileSystemDock"]
    
    UseExisting --> NotifyDock
    NotifyDock --> UpdateUI["Update UI Display"]
```

**Import Settings Storage:**

Import settings are stored in the `.import` file alongside import metadata:

**Sources:** [core/io/resource_importer.cpp:43-155](), [core/io/resource_importer.h:109-150]()

---

## Resource Format Loaders

### Format Detection

The FileSystem Dock relies on ResourceLoader to detect and load different resource formats:

```mermaid
graph TB
    LoadRequest["Resource Load Request"] --> CheckExt["Check File Extension"]
    
    CheckExt --> QueryLoaders["Query Registered Loaders"]
    QueryLoaders --> CheckRecognize{Loader<br/>Recognizes?}
    
    CheckRecognize -->|ResourceFormatImporter| ImportedPath["Load via .import"]
    CheckRecognize -->|ResourceFormatLoaderText| TextParse["Parse .tres/.tscn"]
    CheckRecognize -->|ResourceFormatLoaderBinary| BinaryParse["Parse .res/.scn"]
    CheckRecognize -->|Custom Loader| CustomLoad["Custom Load Logic"]
    
    ImportedPath --> LoadResource["Load Processed Resource"]
    TextParse --> LoadResource
    BinaryParse --> LoadResource
    CustomLoad --> LoadResource
    
    LoadResource --> ReturnRes["Return Resource"]
```

**Loader Priority:**

Loaders are queried in registration order. The first loader to recognize the path handles the load:

**Sources:** [core/io/resource_loader.cpp:289-360](), [core/io/resource_loader.h:137-141]()

---

## Text Resource Format

### Text Format Structure

Text resources (`.tres`, `.tscn`) use a human-readable format displayed in the FileSystem Dock:

```
[gd_resource type="Resource" load_steps=3 format=3 uid="uid://abc123"]

[ext_resource type="Texture2D" path="res://icon.png" id="1_abc"]
[sub_resource type="Material" id="2_def"]

[resource]
property = "value"
texture = ExtResource("1_abc")
material = SubResource("2_def")
```

**Parsing Components:**

| Section | Purpose |
|---------|---------|
| `[gd_resource]` | Header with type, format version, UID |
| `[ext_resource]` | External resource references |
| `[sub_resource]` | Embedded sub-resources |
| `[resource]` | Main resource properties |

**Sources:** [scene/resources/resource_format_text.cpp:1-922](), [scene/resources/resource_format_text.h:40-113]()

---

## Binary Resource Format

### Binary Format Structure

Binary resources (`.res`, `.scn`) are compact and faster to load:

```mermaid
graph TB
    BinaryFile["Binary Resource File"] --> Header["File Header"]
    
    Header --> Magic["Magic Number"]
    Header --> Version["Format Version"]
    Header --> UID["Resource UID"]
    Header --> Type["Resource Type"]
    
    Header --> StringTable["String Table<br/>(StringName pool)"]
    
    Header --> ExtResources["External Resources Table"]
    ExtResources --> ExtEntry["Entry: path, type, uid"]
    
    Header --> IntResources["Internal Resources Table"]
    IntResources --> IntEntry["Entry: offset, type"]
    
    Header --> MainResource["Main Resource Data"]
    MainResource --> Properties["Property Values<br/>(binary encoded)"]
```

**Binary Encoding:**

Variants are encoded with type tags:

| Type | Tag | Encoding |
|------|-----|----------|
| NIL | 1 | No data |
| BOOL | 2 | 32-bit int |
| INT | 3 | 32-bit int |
| INT64 | 40 | 64-bit int |
| FLOAT | 4 | real_t |
| STRING | 5 | Length + UTF-8 |
| OBJECT | 24 | Reference type |

**Sources:** [core/io/resource_format_binary.cpp:45-101](), [core/io/resource_format_binary.h:38-107]()

---

## Error Handling

### Common Error Scenarios

The FileSystem Dock handles various error conditions:

| Error Condition | Handling Strategy |
|----------------|-------------------|
| Missing import file | Show warning, attempt reimport |
| Broken dependency | Display error icon, track in dependency tree |
| Load failure | Show error message, fall back to placeholder |
| UID conflict | Generate new UID, update registry |
| Permission denied | Show error dialog, skip operation |
| Corrupted resource | Attempt recovery, offer to recreate |

**Dependency Error Notification:**

When a resource fails to load its dependencies:

**Sources:** [core/io/resource_loader.cpp:148-158](), [core/io/resource_loader.h:99-101]()

---

## Integration Points

### Key Integration Systems

```mermaid
graph TB
    FileSystemDock["FileSystemDock"] --> Integration{Integration Points}
    
    Integration --> EditorNode["EditorNode<br/>(Main Editor)"]
    Integration --> SceneTreeDock["SceneTreeDock<br/>(Scene Hierarchy)"]
    Integration --> Inspector["Inspector<br/>(Property Editor)"]
    Integration --> ImportDock["ImportDock<br/>(Import Settings)"]
    
    EditorNode --> SceneManagement["Scene Management"]
    SceneTreeDock --> DragDrop["Drag-Drop Resources"]
    Inspector --> ResourcePickers["Resource Picker Dialogs"]
    ImportDock --> ReimportTrigger["Reimport Trigger"]
```

**Sources:** Architecture inferred from editor structure

---

## Performance Considerations

### Optimization Strategies

The FileSystem Dock employs several optimizations for large projects:

| Strategy | Implementation |
|----------|----------------|
| Lazy loading | Only load visible directory contents |
| Preview caching | Store generated thumbnails on disk |
| Incremental scanning | Monitor file changes, not full rescans |
| Async operations | Background threads for scanning/loading |
| UID indexing | Fast path lookups without file I/O |

**Threaded Loading:**

For large resources, the FileSystem Dock can use threaded loading:

**Sources:** [core/io/resource_loader.cpp:516-664](), [core/io/resource_loader.h:116-127]()

---

## Summary

The FileSystem Dock serves as the central asset management interface in the Godot editor, coordinating between:

1. **EditorFileSystem** - Background scanning and resource tracking
2. **ResourceLoader** - Dynamic resource loading with caching
3. **ResourceFormatImporter** - Import pipeline integration
4. **ResourceUID** - Stable resource identification
5. **EditorResourcePreview** - Thumbnail generation and caching

Together, these systems provide a robust file management experience that handles resource discovery, loading, importing, dependency tracking, and file operations while maintaining performance in large projects.

**Sources:** [core/io/resource_loader.cpp:1-1095](), [core/io/resource_importer.cpp:1-520](), [core/io/resource.cpp:1-700]()3f:T7115,# Script Editor

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/CodeEdit.xml](doc/classes/CodeEdit.xml)
- [doc/classes/LineEdit.xml](doc/classes/LineEdit.xml)
- [doc/classes/TextEdit.xml](doc/classes/TextEdit.xml)
- [scene/SCsub](scene/SCsub)
- [scene/gui/code_edit.cpp](scene/gui/code_edit.cpp)
- [scene/gui/code_edit.h](scene/gui/code_edit.h)
- [scene/gui/line_edit.cpp](scene/gui/line_edit.cpp)
- [scene/gui/line_edit.h](scene/gui/line_edit.h)
- [scene/gui/text_edit.cpp](scene/gui/text_edit.cpp)
- [scene/gui/text_edit.h](scene/gui/text_edit.h)
- [scene/resources/3d/world_3d.cpp](scene/resources/3d/world_3d.cpp)
- [scene/resources/3d/world_3d.h](scene/resources/3d/world_3d.h)
- [scene/resources/SCsub](scene/resources/SCsub)
- [servers/SCsub](servers/SCsub)
- [servers/register_server_types.cpp](servers/register_server_types.cpp)
- [tests/display_server_mock.h](tests/display_server_mock.h)
- [tests/scene/test_code_edit.h](tests/scene/test_code_edit.h)
- [tests/scene/test_text_edit.h](tests/scene/test_text_edit.h)
- [tests/scene/test_viewport.h](tests/scene/test_viewport.h)
- [tests/test_macros.h](tests/test_macros.h)
- [tests/test_main.cpp](tests/test_main.cpp)
- [tests/test_tools.h](tests/test_tools.h)
- [tests/test_validate_testing.h](tests/test_validate_testing.h)

</details>



## Purpose and Scope

The Script Editor system provides code editing capabilities within the Godot Editor. It is built upon the `TextEdit` and `CodeEdit` GUI controls to provide syntax highlighting, code completion, debugging integration, breakpoint management, and script file handling. This document covers the text editing components that form the foundation of script editing.

For information about the broader editor plugin system, see [EditorPlugin System](#7.4). For details about text rendering and shaping, see [Text Shaping System](#10.2). For GDScript-specific analysis and compilation, see [GDScript System](#6).

---

## System Architecture

The Script Editor is built as a layered system where specialized code editing controls are integrated into the editor's plugin architecture.

```mermaid
graph TB
    Control["Control<br/>(Base GUI class)"]
    TextEdit["TextEdit<br/>(Multiline text editor)"]
    CodeEdit["CodeEdit<br/>(Code-specific editor)"]
    ScriptEditor["Script Editor<br/>(Editor plugin)"]
    
    Control --> TextEdit
    TextEdit --> CodeEdit
    CodeEdit --> ScriptEditor
    
    TextEdit --> TextServer["TextServer<br/>(Text shaping)"]
    TextEdit --> SyntaxHighlighter["SyntaxHighlighter<br/>(Syntax coloring)"]
    CodeEdit --> Debugger["Debugger Integration"]
    ScriptEditor --> EditorFileSystem["EditorFileSystem<br/>(File management)"]
    ScriptEditor --> EditorInterface["EditorInterface<br/>(Editor API)"]
```

**Sources:** [scene/gui/text_edit.h:40](), [scene/gui/code_edit.h:36](), [editor/plugins documentation in architecture overview]

---

## Core Components

### TextEdit Class

`TextEdit` is the foundational multiline text editing control located at [scene/gui/text_edit.h:40-1020]() and [scene/gui/text_edit.cpp:31-8000](). It provides the core text manipulation and display functionality.

**Key Responsibilities:**
- Text buffer management with line-based storage
- Multiple caret support for simultaneous editing
- Selection handling (word, line, and custom ranges)
- Undo/redo system with operation stacking
- Line wrapping and visual layout
- Gutter system for line numbers, icons, and custom content
- Text shaping integration via `TextServer`
- Accessibility support

**Internal Text Structure:**

```mermaid
graph LR
    TextEdit["TextEdit"]
    TextInternal["Text<br/>(Internal class)"]
    LineArray["Vector&lt;Line&gt;<br/>(Line storage)"]
    LineBuf["Line::data_buf<br/>(TextParagraph)"]
    
    TextEdit --> TextInternal
    TextInternal --> LineArray
    LineArray --> LineBuf
    LineBuf --> TextServer["TextServer<br/>(Shaping)"]
```

The internal `Text` class (defined at [scene/gui/text_edit.h:136-287]()) manages the actual text data:
- Stores lines as a `Vector<Line>` structure
- Each `Line` contains a `String data` field and a `Ref<TextParagraph> data_buf` for rendering
- Maintains gutter metadata per line
- Tracks line visibility for code folding
- Manages cached width/height for performance

**Sources:** [scene/gui/text_edit.h:136-287](), [scene/gui/text_edit.cpp:50-440]()

### CodeEdit Class

`CodeEdit` extends `TextEdit` at [scene/gui/code_edit.h:36-400]() and [scene/gui/code_edit.cpp:31-5000]() with features specifically for code editing.

**Code-Specific Features:**

| Feature | Description | Key Methods |
|---------|-------------|-------------|
| **Line Numbers** | Displays line numbers in a dedicated gutter | `set_draw_line_numbers()` |
| **Breakpoints** | Visual indicators for debugger breakpoints | `set_line_as_breakpoint()`, `get_breakpointed_lines()` |
| **Bookmarks** | User-defined line markers | `set_line_as_bookmarked()` |
| **Code Folding** | Collapse/expand code blocks | `fold_line()`, `unfold_line()` |
| **Auto Indentation** | Automatic indentation on new lines | `set_auto_indent()` |
| **Brace Completion** | Auto-insert closing braces | `add_auto_brace_completion_pair()` |
| **Code Completion** | Autocomplete popup with suggestions | `update_code_completion_options()` |
| **Symbol Lookup** | Hover tooltips for symbols | Symbol tooltip timer at [scene/gui/code_edit.cpp:42]() |

**Sources:** [scene/gui/code_edit.h:36-400](), [scene/gui/code_edit.cpp:41-5000]()

### Main Gutter System

`CodeEdit` implements a main gutter at [scene/gui/code_edit.h:91-109]() that combines multiple indicators:

```mermaid
graph LR
    MainGutter["Main Gutter"]
    Breakpoint["MAIN_GUTTER_BREAKPOINT<br/>(0x01 flag)"]
    Bookmark["MAIN_GUTTER_BOOKMARK<br/>(0x02 flag)"]
    Executing["MAIN_GUTTER_EXECUTING<br/>(0x04 flag)"]
    
    MainGutter --> Breakpoint
    MainGutter --> Bookmark
    MainGutter --> Executing
```

The gutter uses bitflags to efficiently store multiple states per line. Drawing is handled by `_main_gutter_draw_callback()` at [scene/gui/code_edit.cpp:99]().

**Sources:** [scene/gui/code_edit.h:91-109](), [scene/gui/code_edit.cpp:99]()

---

## Text Editing Operations

### Caret Management

`TextEdit` supports multiple carets for simultaneous editing. The caret system is defined at [scene/gui/text_edit.h:445-453]():

```cpp
struct Caret {
    Selection selection;
    Point2 draw_pos;
    bool visible = false;
    int last_fit_x = 0;
    int line = 0;
    int column = 0;
};
```

**Key Operations:**

| Method | Purpose |
|--------|---------|
| `add_caret()` | Add a new caret at specified position |
| `remove_caret()` | Remove a caret by index |
| `get_caret_count()` | Return number of active carets |
| `merge_overlapping_carets()` | Combine carets at same position |
| `begin_multicaret_edit()` / `end_multicaret_edit()` | Batch edit multiple carets |

Carets are stored in `Vector<Caret> carets` at [scene/gui/text_edit.h:456](). The primary caret is always at index 0.

**Sources:** [scene/gui/text_edit.h:445-456](), [doc/classes/TextEdit.xml:62-90]()

### Selection System

Each caret has an associated `Selection` structure at [scene/gui/text_edit.h:435-443]():

```cpp
struct Selection {
    bool active = false;
    int origin_line = 0;
    int origin_column = 0;
    int origin_last_fit_x = 0;
    int word_begin_column = 0;
    int word_end_column = 0;
};
```

Selection modes are defined at [scene/gui/text_edit.h:59-65]():
- `SELECTION_MODE_NONE` - No selection active
- `SELECTION_MODE_SHIFT` - Shift+arrow key selection
- `SELECTION_MODE_POINTER` - Mouse drag selection
- `SELECTION_MODE_WORD` - Double-click word selection
- `SELECTION_MODE_LINE` - Triple-click line selection

**Sources:** [scene/gui/text_edit.h:435-443](), [scene/gui/text_edit.h:59-65]()

### Undo/Redo System

Text operations are recorded in a stack-based undo/redo system defined at [scene/gui/text_edit.h:370-389]():

```mermaid
graph TB
    TextOperation["TextOperation"]
    StartCarets["start_carets<br/>(Vector&lt;Caret&gt;)"]
    EndCarets["end_carets<br/>(Vector&lt;Caret&gt;)"]
    TextChange["text field<br/>(String)"]
    Positions["from_line, from_column<br/>to_line, to_column"]
    
    TextOperation --> StartCarets
    TextOperation --> EndCarets
    TextOperation --> TextChange
    TextOperation --> Positions
```

Operations are categorized by type at [scene/gui/text_edit.h:371-375]():
- `TYPE_INSERT` - Text insertion
- `TYPE_REMOVE` - Text deletion

The undo stack is managed at [scene/gui/text_edit.h:402-403]():
```cpp
List<TextOperation> undo_stack;
List<TextOperation>::Element *undo_stack_pos = nullptr;
```

**Sources:** [scene/gui/text_edit.h:370-403](), [scene/gui/text_edit.cpp:6673-6850]()

---

## Code Completion System

### Code Completion Flow

The code completion system in `CodeEdit` provides autocomplete suggestions through a popup menu.

```mermaid
sequenceDiagram
    participant User
    participant CodeEdit
    participant Handler["_request_code_completion<br/>(virtual)"]
    participant Options["code_completion_options<br/>(Vector)"]
    participant Popup["Code Completion Popup"]
    
    User->>CodeEdit: Type trigger character
    CodeEdit->>Handler: Call request handler
    Handler->>Options: Add completion options
    CodeEdit->>CodeEdit: _filter_code_completion_candidates()
    CodeEdit->>Popup: Display filtered options
    User->>Popup: Select option
    Popup->>CodeEdit: _confirm_code_completion()
    CodeEdit->>CodeEdit: Insert selected text
```

**Key Components:**

**CodeCompletionOption Structure** at [scene/gui/code_edit.h:133-173]():
```cpp
struct CodeCompletionOption {
    CodeCompletionKind kind;
    String display;         // Text shown in popup
    String insert_text;     // Text to insert
    Color font_color;
    Ref<Texture2D> icon;
    Variant default_value;  // For preview (e.g., Color)
    Vector<Pair<int, int>> matches;  // Highlighted ranges
    int location;           // CodeCompletionLocation flags
};
```

**Completion Kinds** defined at [scene/gui/code_edit.h:42-53]():
- `KIND_CLASS`, `KIND_FUNCTION`, `KIND_SIGNAL`, `KIND_VARIABLE`
- `KIND_MEMBER`, `KIND_ENUM`, `KIND_CONSTANT`
- `KIND_NODE_PATH`, `KIND_FILE_PATH`, `KIND_PLAIN_TEXT`

**Key Methods:**
- `add_code_completion_option()` at [scene/gui/code_edit.cpp:3044-3079]() - Add completion entry
- `update_code_completion_options()` at [scene/gui/code_edit.cpp:3081-3155]() - Refresh popup
- `_filter_code_completion_candidates()` at [scene/gui/code_edit.cpp:3233-3260]() - Virtual filter method
- `_confirm_code_completion()` at [scene/gui/code_edit.cpp:3262-3340]() - Virtual insertion method

**Sources:** [scene/gui/code_edit.h:133-173](), [scene/gui/code_edit.cpp:3044-3340]()

### Code Completion Rendering

The completion popup is drawn during the `NOTIFICATION_DRAW` phase at [scene/gui/code_edit.cpp:139-274]():

**Rendering Details:**
- Rectangle position calculated to avoid clipping
- Icon area rendered at `row_height` size
- Text rendered with `TextLine` for proper shaping
- Matching characters highlighted with background color
- Scrollbar shown when options exceed `code_completion_max_lines`
- Selected item highlighted with `code_completion_selected_color`

The popup dimensions are stored in `code_completion_rect` (Rect2) at [scene/gui/code_edit.h:184]().

**Sources:** [scene/gui/code_edit.cpp:139-274](), [scene/gui/code_edit.h:179-193]()

---

## Debugging Integration

### Breakpoint Management

`CodeEdit` provides breakpoint functionality for debugger integration through a dedicated line flag system.

**Data Storage:**
```cpp
HashMap<int, bool> breakpointed_lines;  // At code_edit.h:102
```

**Key Methods:**

| Method | Purpose | Signal |
|--------|---------|--------|
| `set_line_as_breakpoint(line, enabled)` | Toggle breakpoint state | `breakpoint_toggled` |
| `is_line_breakpointed(line)` | Check breakpoint status | - |
| `get_breakpointed_lines()` | Return all breakpointed line numbers | - |
| `clear_breakpointed_lines()` | Remove all breakpoints | `breakpoint_toggled` (per line) |

The `breakpoint_toggled` signal is emitted at [scene/gui/code_edit.cpp:3558]() with the line number as a parameter.

**Visual Rendering:**
Breakpoints are drawn in the main gutter using the `MAIN_GUTTER_BREAKPOINT` flag. The drawing callback at [scene/gui/code_edit.cpp:99-128]() renders the appropriate icon based on the line's gutter flags.

**Sources:** [scene/gui/code_edit.h:102-103](), [scene/gui/code_edit.cpp:3542-3605](), [doc/classes/CodeEdit.xml:129-163]()

### Executing Line Indicator

`CodeEdit` supports showing which line is currently being executed during debugging:

```cpp
bool draw_executing_lines = false;  // At code_edit.h:109
```

The executing state is combined with breakpoints and bookmarks in the main gutter bitflags at [scene/gui/code_edit.h:91-95]():
```cpp
enum MainGutterType {
    MAIN_GUTTER_BREAKPOINT = 0x01,
    MAIN_GUTTER_BOOKMARK = 0x02,
    MAIN_GUTTER_EXECUTING = 0x04
};
```

This allows a line to simultaneously show as a breakpoint and executing line by combining flags.

**Sources:** [scene/gui/code_edit.h:91-109](), [scene/gui/code_edit.cpp:99-128]()

---

## Code Folding System

### Fold Region Management

Code folding allows users to collapse and expand blocks of code. The system is implemented at [scene/gui/code_edit.h:240-264]().

**Key Data Structures:**
```cpp
int fold_gutter;                           // Gutter index for fold icons
HashMap<int, bool> can_fold_lookup;        // Lines that can be folded
HashMap<int, bool> can_unfold_lookup;      // Lines that are folded
```

**Folding Operations:**

| Method | Purpose |
|--------|---------|
| `can_fold_line(line)` | Check if line starts a foldable region |
| `fold_line(line)` | Collapse code block |
| `unfold_line(line)` | Expand code block |
| `fold_all_lines()` | Collapse all foldable regions |
| `unfold_all_lines()` | Expand all regions |
| `toggle_foldable_line(line)` | Toggle fold state |

**Fold Region Detection:**
Foldable regions are typically determined by:
1. Delimiter pairs (e.g., `{` and `}`)
2. Indentation levels
3. Custom region markers (implementation-specific)

The delimiters are configured through the string delimiter system at [scene/gui/code_edit.cpp:2586-2625]().

**Visual Indicator:**
The fold gutter shows:
- Folded icon when region is collapsed
- Foldable icon when region can be collapsed
- Nothing on non-foldable lines

**Sources:** [scene/gui/code_edit.h:240-264](), [scene/gui/code_edit.cpp:3933-4077](), [doc/classes/CodeEdit.xml:395-465]()

---

## Syntax Highlighting

### SyntaxHighlighter Integration

`TextEdit` supports pluggable syntax highlighting through the `SyntaxHighlighter` resource system at [scene/gui/text_edit.h:602]():

```mermaid
graph TB
    TextEdit["TextEdit"]
    SyntaxHL["SyntaxHighlighter<br/>(Resource)"]
    Cache["syntax_highlighting_cache<br/>(HashMap)"]
    Colors["Vector&lt;Pair&lt;int64_t, Color&gt;&gt;<br/>(per line)"]
    
    TextEdit --> SyntaxHL
    TextEdit --> Cache
    Cache --> Colors
    SyntaxHL --> Colors
```

**Highlighting Process:**

1. `TextEdit` calls `_get_line_syntax_highlighting(line)` at [scene/gui/text_edit.cpp:3605-3635]()
2. Check syntax highlighting cache for the line
3. If not cached, call `syntax_highlighter->_get_line_syntax_highlighting(line)`
4. Cache the result in `syntax_highlighting_cache`
5. Return color regions as `Vector<Pair<int64_t, Color>>`

**Color Region Format:**
Each pair contains:
- `first` (int64_t): Column position in the line
- `second` (Color): Color to apply from this column onward

**Cache Invalidation:**
The cache is cleared when:
- Text content changes: `_clear_syntax_highlighting_cache()` at [scene/gui/text_edit.cpp:3637-3640]()
- Syntax highlighter is changed
- Color scheme is updated

**Sources:** [scene/gui/text_edit.h:602-606](), [scene/gui/text_edit.cpp:3605-3640](), [scene/resources/syntax_highlighter.h]()

---

## Auto-Indentation

### Indent Management

`CodeEdit` provides automatic indentation with configurable settings at [scene/gui/code_edit.h:64-72]():

**Configuration:**
```cpp
int indent_size = 4;                    // Spaces per indent level
String indent_text = "\t";              // Actual indent string
bool indent_using_spaces = false;       // Use spaces vs tabs
bool auto_indent = false;               // Enable auto-indent
HashSet<char32_t> auto_indent_prefixes; // Characters that trigger indent
```

**Auto-Indent Behavior:**

When `auto_indent` is enabled and the user presses Enter:
1. `_new_line()` is called at [scene/gui/code_edit.cpp:75]()
2. Current line's indentation level is calculated
3. New line inherits the indentation
4. Additional indent added if previous line ends with indent prefix (e.g., `:`, `{`)

**Indent/Unindent Methods:**

| Method | Purpose |
|--------|---------|
| `indent_lines()` | Increase indent for selected lines |
| `unindent_lines()` | Decrease indent for selected lines |
| `get_indent_level(line)` | Calculate indentation depth |
| `convert_indent()` | Convert between spaces and tabs |

**Tab Behavior:**
The `_calculate_spaces_till_next_left_indent()` and `_calculate_spaces_till_next_right_indent()` methods at [scene/gui/code_edit.h:72-73]() calculate proper cursor positions when using soft tabs (spaces as indentation).

**Sources:** [scene/gui/code_edit.h:64-73](), [scene/gui/code_edit.cpp:75-200](), [doc/classes/CodeEdit.xml:579-643]()

---

## Line Wrapping

### Wrapping Configuration

`TextEdit` supports line wrapping with configurable modes at [scene/gui/text_edit.h:67-71]():

```cpp
enum LineWrappingMode {
    LINE_WRAPPING_NONE,      // No wrapping
    LINE_WRAPPING_BOUNDARY   // Wrap at word boundaries
};
```

**Key Properties:**
```cpp
LineWrappingMode line_wrapping_mode = LINE_WRAPPING_NONE;
TextServer::AutowrapMode autowrap_mode = AUTOWRAP_WORD_SMART;
int wrap_at_column = 0;  // Calculated based on control width
```

**Wrap Calculation:**
The `_update_wrap_at_column()` method at [scene/gui/text_edit.cpp:840-861]() calculates the wrap column based on:
- Control width minus gutters and margins
- Font character width
- Minimap width (if enabled)

**Accessing Wrapped Lines:**
```cpp
int get_line_wrap_count(line) const;
Vector<Vector2i> get_line_wrap_ranges(line) const;  // Start/end columns per wrap
int get_line_wrap_index_at_column(line, column) const;
```

Each visual wrapped line is called a "wrap index" for the logical line. The internal `Text` class at [scene/gui/text_edit.h:136-287]() manages this mapping.

**Sources:** [scene/gui/text_edit.h:67-71](), [scene/gui/text_edit.h:526-531](), [scene/gui/text_edit.cpp:840-861]()

---

## Gutter System

### Gutter Architecture

`TextEdit` provides a flexible gutter system for displaying line metadata. Gutters are defined at [scene/gui/text_edit.h:73-78]():

```cpp
enum GutterType {
    GUTTER_TYPE_STRING,  // Text content
    GUTTER_TYPE_ICON,    // Texture2D icon
    GUTTER_TYPE_CUSTOM   // Custom draw callback
};
```

**Gutter Configuration:**

```mermaid
graph TB
    TextEdit["TextEdit"]
    GutterInfo["GutterInfo struct"]
    Gutters["Vector&lt;GutterInfo&gt; gutters"]
    LineGutters["Line::gutters<br/>(per-line data)"]
    
    TextEdit --> Gutters
    Gutters --> GutterInfo
    GutterInfo --> Type["type: GutterType"]
    GutterInfo --> Name["name: String"]
    GutterInfo --> Width["width: int"]
    GutterInfo --> Callback["custom_draw_callback"]
    
    TextEdit --> LineGutters
```

**GutterInfo Structure** at [scene/gui/text_edit.h:125-134]():
```cpp
struct GutterInfo {
    GutterType type = GUTTER_TYPE_STRING;
    String name = "";
    int width = 24;
    bool draw = true;
    bool clickable = false;
    bool overwritable = false;
    Callable custom_draw_callback;
};
```

**Per-Line Gutter Data** at [scene/gui/text_edit.h:138-145]():
```cpp
struct Gutter {
    Variant metadata;
    bool clickable = false;
    Ref<Texture2D> icon;
    String text = "";
    Color color = Color(1, 1, 1);
};
```

**Gutter Management Methods:**

| Method | Purpose |
|--------|---------|
| `add_gutter(at)` | Insert new gutter at index |
| `remove_gutter(gutter)` | Remove gutter |
| `set_gutter_type(gutter, type)` | Set gutter display type |
| `set_gutter_width(gutter, width)` | Set gutter width |
| `set_gutter_custom_draw(gutter, callback)` | Set custom draw function |
| `set_line_gutter_text(line, gutter, text)` | Set text for line |
| `set_line_gutter_icon(line, gutter, icon)` | Set icon for line |

**Sources:** [scene/gui/text_edit.h:73-78](), [scene/gui/text_edit.h:125-145](), [doc/classes/TextEdit.xml:77-112]()

### Custom Gutter Drawing

For `GUTTER_TYPE_CUSTOM` gutters, the `custom_draw_callback` is invoked during rendering with signature:
```
void callback(int line, int gutter, Rect2 region)
```

This allows plugins and custom implementations to draw arbitrary content in gutter space. Example uses:
- Diff markers (added/modified/deleted lines)
- Code coverage indicators  
- Custom breakpoint icons
- Line blame information

The callback is invoked from the main draw loop at [scene/gui/text_edit.cpp:1100-1400]() (approximate range for gutter rendering).

**Sources:** [scene/gui/text_edit.h:133](), [scene/gui/text_edit.cpp:1100-1400]()

---

## Input Method Editor (IME) Support

### IME Integration

Both `TextEdit` and `LineEdit` support Input Method Editors for typing complex characters (e.g., Chinese, Japanese, Korean).

**IME State Management:**

In `TextEdit` at [scene/gui/text_edit.h:309-310]():
```cpp
String ime_text = "";
Point2 ime_selection;  // Start/end of composition
```

In each line at [scene/gui/text_edit.h:157-158]():
```cpp
String ime_data;           // IME composition text
Array ime_bidi_override;   // BiDi overrides for IME text
```

**IME Operations:**

| Method | Purpose |
|--------|---------|
| `has_ime_text()` | Check if IME composition is active |
| `apply_ime()` | Commit IME text to buffer |
| `cancel_ime()` | Discard IME composition |

**IME Window Positioning:**
The `_update_ime_window_position()` method at [scene/gui/text_edit.cpp:337-340]() positions the IME popup near the caret using `DisplayServer::window_set_ime_position()`.

**Composition Rendering:**
When IME text exists, it's merged with the line text for display purposes via `get_text_with_ime()` at [scene/gui/text_edit.cpp:226-232]():
```cpp
const String &get_text_with_ime(int p_line) const {
    if (!text[p_line].ime_data.is_empty()) {
        return text[p_line].ime_data;
    } else {
        return text[p_line].data;
    }
}
```

**Sources:** [scene/gui/text_edit.h:309-310](), [scene/gui/text_edit.cpp:226-340](), [scene/gui/line_edit.cpp:118-178]()

---

## Accessibility Support

### Screen Reader Integration

`TextEdit` provides comprehensive accessibility support through the DisplayServer accessibility API.

**Accessibility Elements:**

Each line creates accessibility sub-elements at [scene/gui/text_edit.cpp:234-251]():
```cpp
void Text::update_accessibility(int p_line, RID p_root) {
    Line &l = text.write[p_line];
    if (l.accessibility_text_root_element.is_empty()) {
        for (int i = 0; i < l.data_buf->get_line_count(); i++) {
            bool is_last_line = (p_line == text.size() - 1) && 
                               (i == l.data_buf->get_line_count() - 1);
            RID rid = DisplayServer::get_singleton()->
                accessibility_create_sub_text_edit_elements(
                    p_root, 
                    l.data_buf->get_line_rid(i), 
                    max_line_height, 
                    p_line, 
                    is_last_line
                );
            l.accessibility_text_root_element.push_back(rid);
        }
    }
}
```

**Accessibility Actions:**

Registered in `NOTIFICATION_ACCESSIBILITY_UPDATE` at [scene/gui/text_edit.cpp:745-825]():
- `ACTION_SET_TEXT_SELECTION` â†’ `_accessibility_action_set_selection()`
- `ACTION_REPLACE_SELECTED_TEXT` â†’ `_accessibility_action_replace_selected()`
- `ACTION_SET_VALUE` â†’ `_accessibility_action_set_value()`
- `ACTION_SHOW_CONTEXT_MENU` â†’ `_accessibility_action_menu()`
- `ACTION_SCROLL_DOWN/UP/LEFT/RIGHT` â†’ Scroll handlers
- `ACTION_SCROLL_INTO_VIEW` â†’ `_accessibility_action_scroll_into_view()`

**Text Selection Reporting:**

The current selection is reported to screen readers at [scene/gui/text_edit.cpp:812-825]():
```cpp
if (carets[0].selection.active) {
    int start_wrap = get_line_wrap_index_at_column(
        carets[0].selection.origin_line, 
        carets[0].selection.origin_column
    );
    RID start_rid = text.get_accessibility_elements(
        carets[0].selection.origin_line
    )[start_wrap];
    
    int end_wrap = get_line_wrap_index_at_column(
        carets[0].line, carets[0].column
    );
    RID end_rid = text.get_accessibility_elements(
        carets[0].line
    )[end_wrap];
    
    DisplayServer::get_singleton()->accessibility_update_set_text_selection(
        ae, start_rid, carets[0].selection.origin_column, 
        end_rid, carets[0].column
    );
}
```

**Sources:** [scene/gui/text_edit.cpp:234-825](), [scene/gui/text_edit.h:235-241]()

---

## Key Data Flows

### Text Insertion Flow

```mermaid
sequenceDiagram
    participant User
    participant TextEdit
    participant Text["Text (internal)"]
    participant TextParagraph
    participant Undo["Undo Stack"]
    
    User->>TextEdit: Type character
    TextEdit->>TextEdit: _handle_unicode_input()
    TextEdit->>TextEdit: insert_text_at_caret()
    TextEdit->>Undo: Record operation
    TextEdit->>Text: Insert text
    Text->>Text: Update line data
    Text->>TextParagraph: Invalidate cache
    TextParagraph->>TextParagraph: Reshape text
    TextEdit->>TextEdit: Update carets
    TextEdit->>TextEdit: Emit text_changed signal
    TextEdit->>TextEdit: queue_redraw()
```

**Key Methods:**
1. User input triggers `_handle_unicode_input()` at [scene/gui/text_edit.cpp:6070-6100]()
2. Calls `insert_text_at_caret()` which delegates to `_insert_text()` at [scene/gui/text_edit.cpp:5673-5750]()
3. `_insert_text()` calls `_base_insert_text()` at [scene/gui/text_edit.cpp:5676-5750]()
4. Updates internal `Text` structure and invalidates line cache
5. Adjusts caret positions via `_offset_carets_after()` at [scene/gui/text_edit.cpp:7492-7550]()
6. Emits `text_changed` signal via `_text_changed()` at [scene/gui/text_edit.cpp:5670-5672]()

**Sources:** [scene/gui/text_edit.cpp:5670-7550]()

### Line Drawing Pipeline

```mermaid
graph TB
    Draw["NOTIFICATION_DRAW"]
    Style["Get StyleBox"]
    Viewport["Calculate viewport"]
    Lines["For each visible line"]
    Gutter["Draw gutters"]
    Background["Draw line background"]
    Text["Draw text via TextParagraph"]
    Caret["Draw carets"]
    Selection["Draw selection highlighting"]
    
    Draw --> Style
    Style --> Viewport
    Viewport --> Lines
    Lines --> Gutter
    Lines --> Background
    Lines --> Text
    Lines --> Selection
    Lines --> Caret
```

The rendering process occurs in `_notification(NOTIFICATION_DRAW)` at [scene/gui/text_edit.cpp:904-2500]() (approximate range):

1. **Viewport Calculation**: Determine which lines are visible based on scroll position
2. **Gutter Rendering**: Draw each gutter column with icons/text/custom content
3. **Line Background**: Draw background colors for current line, selections, search results
4. **Text Rendering**: Use `TextParagraph` to draw shaped text with syntax highlighting
5. **Caret Drawing**: Render caret(s) at current positions
6. **Overlay Elements**: Draw minimap, code completion popup, code hints

**Sources:** [scene/gui/text_edit.cpp:904-2500]()

### Code Completion Update Flow

```mermaid
graph TB
    Trigger["Trigger character typed"]
    Request["_request_code_completion()"]
    Options["Add options via<br/>add_code_completion_option()"]
    Update["update_code_completion_options()"]
    Filter["_filter_code_completion_candidates()"]
    Sort["Sort by relevance"]
    Display["Display popup"]
    Select["User selection"]
    Confirm["_confirm_code_completion()"]
    Insert["Insert text"]
    
    Trigger --> Request
    Request --> Options
    Options --> Update
    Update --> Filter
    Filter --> Sort
    Sort --> Display
    Display --> Select
    Select --> Confirm
    Confirm --> Insert
```

Virtual methods allow customization:
- `_request_code_completion(force)` at [doc/classes/CodeEdit.xml:28-33]() - Define when to trigger
- `_filter_code_completion_candidates(candidates)` at [doc/classes/CodeEdit.xml:20-26]() - Filter/sort options
- `_confirm_code_completion(replace)` at [doc/classes/CodeEdit.xml:13-18]() - Define insertion behavior

The default implementation is at [scene/gui/code_edit.cpp:3044-3340]().

**Sources:** [scene/gui/code_edit.cpp:3044-3340](), [doc/classes/CodeEdit.xml:13-33]()40:T53cb,# EditorLog & Output

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/extension/gdextension_special_compat_hashes.cpp](core/extension/gdextension_special_compat_hashes.cpp)
- [core/extension/gdextension_special_compat_hashes.h](core/extension/gdextension_special_compat_hashes.h)
- [doc/classes/Label.xml](doc/classes/Label.xml)
- [doc/classes/LabelSettings.xml](doc/classes/LabelSettings.xml)
- [doc/classes/RichTextLabel.xml](doc/classes/RichTextLabel.xml)
- [doc/classes/TextLine.xml](doc/classes/TextLine.xml)
- [doc/classes/TextParagraph.xml](doc/classes/TextParagraph.xml)
- [editor/editor_log.cpp](editor/editor_log.cpp)
- [editor/editor_log.h](editor/editor_log.h)
- [scene/gui/label.cpp](scene/gui/label.cpp)
- [scene/gui/label.h](scene/gui/label.h)
- [scene/gui/rich_text_label.compat.inc](scene/gui/rich_text_label.compat.inc)
- [scene/gui/rich_text_label.cpp](scene/gui/rich_text_label.cpp)
- [scene/gui/rich_text_label.h](scene/gui/rich_text_label.h)
- [scene/resources/label_settings.cpp](scene/resources/label_settings.cpp)
- [scene/resources/label_settings.h](scene/resources/label_settings.h)
- [scene/resources/text_line.cpp](scene/resources/text_line.cpp)
- [scene/resources/text_line.h](scene/resources/text_line.h)
- [scene/resources/text_paragraph.cpp](scene/resources/text_paragraph.cpp)
- [scene/resources/text_paragraph.h](scene/resources/text_paragraph.h)

</details>



## Purpose and Scope

This document covers the **EditorLog** system, which provides the output panel in the Godot Editor's bottom dock. The EditorLog displays runtime messages, errors, warnings, and editor notifications in a filterable, searchable interface using RichTextLabel for rich text formatting.

For information about the RichTextLabel control itself, see [RichTextLabel](#10.3). For general Script Editor functionality, see [Script Editor](#9.2).

## System Overview

The EditorLog system captures and displays messages from multiple sources in the editor, providing filtering, searching, and message management capabilities. It integrates with Godot's error handling system and presents messages in a user-friendly format with type-based filtering and color coding.

```mermaid
graph TB
    subgraph "Message Sources"
        ErrorHandler["Error Handler<br/>(_error_handler)"]
        UndoRedo["UndoRedo System<br/>(_undo_redo_cbk)"]
        DirectCalls["Direct add_message() Calls"]
    end
    
    subgraph "EditorLog Core"
        EditorLog["EditorLog<br/>(EditorDock)"]
        Messages["Vector&lt;LogMessage&gt;<br/>(messages)"]
        Filters["HashMap&lt;MessageType, LogFilter*&gt;<br/>(type_filter_map)"]
    end
    
    subgraph "Display & UI"
        RichTextLabel["RichTextLabel<br/>(log)"]
        FilterButtons["Filter Buttons<br/>(toggle_button)"]
        SearchBox["LineEdit<br/>(search_box)"]
        ActionButtons["Clear/Copy/Collapse<br/>Buttons"]
    end
    
    subgraph "Message Processing"
        ProcessMessage["_process_message()"]
        CheckDisplay["_check_display_message()"]
        AddLine["_add_log_line()"]
        RebuildLog["_rebuild_log()"]
    end
    
    ErrorHandler --> ProcessMessage
    UndoRedo --> ProcessMessage
    DirectCalls --> ProcessMessage
    
    ProcessMessage --> Messages
    ProcessMessage --> Filters
    ProcessMessage --> AddLine
    
    Messages --> RebuildLog
    Filters --> CheckDisplay
    SearchBox --> CheckDisplay
    
    CheckDisplay --> AddLine
    AddLine --> RichTextLabel
    RebuildLog --> RichTextLabel
    
    FilterButtons --> RebuildLog
    ActionButtons --> RichTextLabel
    
    EditorLog -.contains.- Messages
    EditorLog -.contains.- Filters
    EditorLog -.contains.- RichTextLabel
```

Sources: [editor/editor_log.h:42-192](), [editor/editor_log.cpp:51-68](), [editor/editor_log.cpp:258-288]()

## Core Components

### EditorLog Class

The `EditorLog` class is the main container for the output panel, inheriting from `EditorDock` and managing all logging functionality.

```mermaid
classDiagram
    class EditorLog {
        +RichTextLabel* log
        +Vector~LogMessage~ messages
        +HashMap~MessageType,LogFilter*~ type_filter_map
        +Button* clear_button
        +Button* copy_button
        +Button* collapse_button
        +LineEdit* search_box
        +int line_limit
        +bool collapse
        +add_message(String, MessageType)
        +clear()
        +register_undo_redo(UndoRedo*)
        -_process_message(String, MessageType, bool)
        -_add_log_line(LogMessage&, bool)
        -_rebuild_log()
        -_check_display_message(LogMessage&)
    }
    
    class LogMessage {
        +String text
        +MessageType type
        +int count
        +bool clear
    }
    
    class LogFilter {
        +MessageType type
        +Button* toggle_button
        -int message_count
        -bool active
        +get_message_count() int
        +set_message_count(int)
        +is_active() bool
        +set_active(bool)
    }
    
    class MessageType {
        <<enumeration>>
        MSG_TYPE_STD
        MSG_TYPE_ERROR
        MSG_TYPE_STD_RICH
        MSG_TYPE_WARNING
        MSG_TYPE_EDITOR
    }
    
    EditorDock <|-- EditorLog
    EditorLog "1" *-- "many" LogMessage
    EditorLog "1" *-- "5" LogFilter
    LogMessage --> MessageType
    LogFilter --> MessageType
```

Sources: [editor/editor_log.h:42-192](), [editor/editor_log.cpp:1-30]()

### Message Types

The system defines five message types, each with distinct visual styling:

| Message Type | Purpose | Icon | Color |
|--------------|---------|------|-------|
| `MSG_TYPE_STD` | Standard output | None | Default |
| `MSG_TYPE_ERROR` | Runtime errors | Error icon | `theme_cache.error_color` |
| `MSG_TYPE_STD_RICH` | Rich formatted output | None | Default |
| `MSG_TYPE_WARNING` | Warnings | Warning icon | `theme_cache.warning_color` |
| `MSG_TYPE_EDITOR` | Editor actions | Edit icon | `theme_cache.message_color` |

Sources: [editor/editor_log.h:46-52](), [editor/editor_log.cpp:406-437]()

## Message Flow

### Message Processing Pipeline

```mermaid
graph LR
    subgraph "Input"
        RawMessage["String p_msg<br/>MessageType p_type"]
    end
    
    subgraph "Split & Process"
        Split["Split by newline<br/>lines = p_msg.split('\\n')"]
        Loop["For each line"]
        ProcessMsg["_process_message(line, type, clear)"]
    end
    
    subgraph "Deduplication"
        CheckLast["Check if last message<br/>matches current"]
        IncCount["Increment count<br/>previous.count++"]
        AddNew["Add new LogMessage<br/>to messages vector"]
    end
    
    subgraph "Display Logic"
        CheckFilter["_check_display_message()<br/>Check filter & search"]
        AddLine["_add_log_line()<br/>Add to RichTextLabel"]
    end
    
    subgraph "Update UI"
        UpdateFilter["Update filter count<br/>type_filter_map[type]"]
        SetIcon["_set_dock_tab_icon()<br/>Update tab icon"]
    end
    
    RawMessage --> Split
    Split --> Loop
    Loop --> ProcessMsg
    
    ProcessMsg --> CheckLast
    CheckLast -->|Match| IncCount
    CheckLast -->|No Match| AddNew
    
    IncCount --> AddLine
    AddNew --> AddLine
    
    AddLine --> CheckFilter
    CheckFilter -->|Pass| UpdateFilter
    UpdateFilter --> SetIcon
```

Sources: [editor/editor_log.cpp:276-288](), [editor/editor_log.cpp:258-274](), [editor/editor_log.cpp:383-404]()

### Error Handler Integration

The EditorLog integrates with Godot's global error handling system:

```mermaid
sequenceDiagram
    participant Engine as Engine Error
    participant Handler as _error_handler()
    participant Queue as MessageQueue
    participant EditorLog as EditorLog
    participant RichTextLabel as RichTextLabel
    
    Engine->>Handler: Error/Warning occurs
    Handler->>Handler: Format error string<br/>Replace "[" with "[lb]"
    
    alt Main Thread
        Handler->>EditorLog: add_message(err_str, type)
    else Background Thread
        Handler->>Queue: push_callable(add_message)
        Queue->>EditorLog: add_message(err_str, type)
    end
    
    EditorLog->>EditorLog: _process_message()
    EditorLog->>RichTextLabel: Push formatting & text
```

Sources: [editor/editor_log.cpp:51-68](), [editor/editor_log.h:149-151]()

## Display & Rendering

### RichTextLabel Integration

The EditorLog uses `RichTextLabel` for rich text display with BBCode support. Messages are formatted with colors, icons, and formatting tags:

```mermaid
graph TB
    subgraph "Message Formatting"
        CheckType["Check MessageType"]
        
        Error["MSG_TYPE_ERROR<br/>push_color(error_color)<br/>add_image(error_icon)<br/>push_bold()<br/>add_text('ERROR: ')"]
        
        Warning["MSG_TYPE_WARNING<br/>push_color(warning_color)<br/>add_image(warning_icon)<br/>push_bold()<br/>add_text('WARNING: ')"]
        
        Editor["MSG_TYPE_EDITOR<br/>push_color(message_color)<br/>add_image(edit_icon)<br/>add_text('--- ')"]
        
        Standard["MSG_TYPE_STD<br/>No special formatting"]
    end
    
    subgraph "Text Output"
        AddText["add_text(message.text)"]
        AddCount["If collapse && count > 1<br/>add_text(' (xN)')"]
        Pop["pop() formatting tags"]
        Newline["add_newline()"]
    end
    
    CheckType --> Error
    CheckType --> Warning
    CheckType --> Editor
    CheckType --> Standard
    
    Error --> AddText
    Warning --> AddText
    Editor --> AddText
    Standard --> AddText
    
    AddText --> AddCount
    AddCount --> Pop
    Pop --> Newline
```

Sources: [editor/editor_log.cpp:406-444]()

### Line Limit & Log Rebuilding

The EditorLog maintains a configurable line limit (default 10000) and rebuilds the display when necessary:

**Rebuild Conditions:**
- Filter state changes
- Search text changes
- Collapse mode changes
- Theme changes
- Line limit reached

**Rebuild Process:**
```mermaid
graph TD
    Start["_rebuild_log()"] --> Clear["log->clear()"]
    Clear --> CalcStart["Calculate start_message_index<br/>Count backwards from end<br/>until line_limit reached"]
    
    CalcStart --> IterMsgs["Iterate messages from<br/>start_message_index to end"]
    
    IterMsgs --> CheckCollapse{collapse?}
    
    CheckCollapse -->|Yes| AddOnce["Add message once<br/>_add_log_line(msg)"]
    CheckCollapse -->|No| AddMulti["Add message count times<br/>for(i=0; i<msg.count; i++)<br/>_add_log_line(msg)"]
    
    AddOnce --> NextMsg
    AddMulti --> NextMsg
    
    NextMsg{More messages?}
    NextMsg -->|Yes| IterMsgs
    NextMsg -->|No| Done[End]
```

Sources: [editor/editor_log.cpp:304-353](), [editor/editor_log.cpp:133-138]()

## Filtering & Search

### Filter System Architecture

Each message type has an associated `LogFilter` object that manages visibility and count display:

```mermaid
classDiagram
    class LogFilter {
        +MessageType type
        +Button* toggle_button
        -int message_count
        -bool active
        +initialize_button(name, tooltip, callback)
        +get_message_count() int
        +set_message_count(int count)
        +is_active() bool
        +set_active(bool active)
    }
    
    class EditorLog {
        +HashMap~MessageType,LogFilter*~ type_filter_map
        -_set_filter_active(bool, MessageType)
    }
    
    EditorLog "1" *-- "5" LogFilter : manages
    
    note for LogFilter "Each filter has:<br/>- Toggle button with count display<br/>- Active state (visible/hidden)<br/>- Message count for type"
```

Sources: [editor/editor_log.h:80-124](), [editor/editor_log.cpp:163]()

### Message Visibility Logic

The `_check_display_message()` method determines if a message should be displayed:

```mermaid
flowchart TD
    Start["_check_display_message(message)"] --> GetFilter["Get filter active state<br/>filter_active = type_filter_map[message.type]->is_active()"]
    
    GetFilter --> GetSearch["Get search text<br/>search_text = search_box->get_text()"]
    
    GetSearch --> CheckEmpty{search_text<br/>empty?}
    
    CheckEmpty -->|Yes| ReturnFilter["return filter_active"]
    
    CheckEmpty -->|No| SimpleSearch["search_match = message.text.containsn(search_text)"]
    
    SimpleSearch --> CheckMatch{Match found?}
    
    CheckMatch -->|Yes| ReturnBoth["return filter_active && search_match"]
    
    CheckMatch -->|No| CheckBBCode{Has '[' char?}
    
    CheckBBCode -->|No| ReturnBoth
    
    CheckBBCode -->|Yes| InitParser["Lazy init bbcode_parser<br/>if (!bbcode_parser)<br/>bbcode_parser = memnew(RichTextLabel)"]
    
    InitParser --> ParseBB["bbcode_parser->clear()<br/>bbcode_parser->parse_bbcode(message.text)"]
    
    ParseBB --> GetParsed["parsed_text = bbcode_parser->get_parsed_text()"]
    
    GetParsed --> SearchParsed["search_match = parsed_text.containsn(search_text)"]
    
    SearchParsed --> ReturnBoth
```

Sources: [editor/editor_log.cpp:355-381]()

## State Persistence

### Configuration Save/Load

The EditorLog persists its state to the editor layout configuration:

**Saved State:**
- Filter active states for each message type
- Collapse mode
- Search box visibility

```mermaid
graph LR
    subgraph "Save Trigger"
        FilterToggle["Filter button toggled"]
        CollapseChange["Collapse button toggled"]
        SearchToggle["Search visibility toggled"]
    end
    
    subgraph "Timer"
        StartTimer["_start_state_save_timer()<br/>save_state_timer->start()"]
        TimerTimeout["Timer timeout (1 second)"]
    end
    
    subgraph "Save Process"
        SaveState["_save_state()"]
        CreateConfig["ConfigFile config.instantiate()"]
        LoadExisting["config->load(editor_layout.cfg)"]
        SetValues["config->set_value(section, key, value)<br/>For each filter state<br/>For collapse state<br/>For search visibility"]
        SaveFile["config->save(editor_layout.cfg)"]
    end
    
    FilterToggle --> StartTimer
    CollapseChange --> StartTimer
    SearchToggle --> StartTimer
    
    StartTimer --> TimerTimeout
    TimerTimeout --> SaveState
    
    SaveState --> CreateConfig
    CreateConfig --> LoadExisting
    LoadExisting --> SetValues
    SetValues --> SaveFile
```

Sources: [editor/editor_log.cpp:160-181](), [editor/editor_log.cpp:183-203]()

## UI Components

### Main UI Layout

```mermaid
graph TB
    subgraph "EditorLog Container"
        VBox["VBoxContainer"]
        
        subgraph "Top Toolbar"
            HBoxTop["HBoxContainer"]
            FilterStd["Filter: Standard<br/>(toggle_button)"]
            FilterError["Filter: Error<br/>(toggle_button)"]
            FilterWarning["Filter: Warning<br/>(toggle_button)"]
            FilterEditor["Filter: Editor<br/>(toggle_button)"]
            VSep1["VSeparator"]
            ClearBtn["Clear Button<br/>(clear_button)"]
            CopyBtn["Copy Button<br/>(copy_button)"]
            VSep2["VSeparator"]
            CollapseBtn["Collapse Button<br/>(collapse_button)"]
            ShowSearchBtn["Search Button<br/>(show_search_button)"]
        end
        
        subgraph "Search Bar"
            SearchBox["LineEdit<br/>(search_box)<br/>Visible when toggled"]
        end
        
        subgraph "Log Display"
            LogRTL["RichTextLabel<br/>(log)<br/>Displays messages"]
        end
    end
    
    VBox --> HBoxTop
    VBox --> SearchBox
    VBox --> LogRTL
    
    HBoxTop --> FilterStd
    HBoxTop --> FilterError
    HBoxTop --> FilterWarning
    HBoxTop --> FilterEditor
    HBoxTop --> VSep1
    HBoxTop --> ClearBtn
    HBoxTop --> CopyBtn
    HBoxTop --> VSep2
    HBoxTop --> CollapseBtn
    HBoxTop --> ShowSearchBtn
```

Sources: [editor/editor_log.cpp:444-602]() (EditorLog constructor)

### Button Actions

| Button | Method | Action |
|--------|--------|--------|
| Clear | `_clear_request()` | Clears log, messages vector, resets counts, removes dock icon |
| Copy | `_copy_request()` | Copies selected text or full parsed text to clipboard |
| Collapse | `_set_collapse(bool)` | Toggles collapse mode, triggers rebuild |
| Search | `_set_search_visible(bool)` | Toggles search box visibility |
| Filter Toggles | `_set_filter_active(bool, MessageType)` | Updates filter state, triggers rebuild |

Sources: [editor/editor_log.cpp:235-256](), [editor/editor_log.cpp:154-158]()

## Theme Integration

### Theme Colors and Icons

The EditorLog uses theme resources for visual styling:

```mermaid
graph TD
    subgraph "Theme Cache"
        ErrorColor["error_color<br/>(theme_cache.error_color)"]
        ErrorIcon["error_icon<br/>(theme_cache.error_icon)"]
        WarningColor["warning_color<br/>(theme_cache.warning_color)"]
        WarningIcon["warning_icon<br/>(theme_cache.warning_icon)"]
        MessageColor["message_color<br/>(theme_cache.message_color)"]
    end
    
    subgraph "Font Overrides"
        NormalFont["output_source<br/>(EditorFonts)"]
        BoldFont["output_source_bold<br/>(EditorFonts)"]
        ItalicFont["output_source_italic<br/>(EditorFonts)"]
        MonoFont["output_source_mono<br/>(EditorFonts)"]
        FontSize["output_source_size<br/>(EditorFonts)"]
    end
    
    subgraph "Applied To"
        RTL["RichTextLabel (log)"]
        Buttons["Filter Buttons"]
    end
    
    ErrorColor --> RTL
    ErrorIcon --> RTL
    WarningColor --> RTL
    WarningIcon --> RTL
    MessageColor --> RTL
    
    NormalFont --> RTL
    BoldFont --> RTL
    ItalicFont --> RTL
    MonoFont --> RTL
    FontSize --> RTL
    
    ErrorIcon --> Buttons
    WarningIcon --> Buttons
```

Sources: [editor/editor_log.cpp:70-130](), [editor/editor_log.h:70-78]()

### Font Configuration

The log applies specialized fonts for source code display:

```cpp
// Font overrides applied in _update_theme()
log->add_theme_font_override("normal_font", normal_font);
log->add_theme_font_override("bold_font", bold_font);
log->add_theme_font_override("italics_font", italics_font);
log->add_theme_font_override("bold_italics_font", bold_italics_font);
log->add_theme_font_override("mono_font", mono_font);

// Disable padding for clean terminal-like output
log->add_theme_constant_override("text_highlight_h_padding", 0);
log->add_theme_constant_override("text_highlight_v_padding", 0);
```

Sources: [editor/editor_log.cpp:71-99]()

## Advanced Features

### Meta Click Handling

The EditorLog supports clickable URLs and file paths in error messages:

```mermaid
flowchart TD
    Click["User clicks meta link<br/>_meta_clicked(String p_meta)"] --> CheckColon{Contains ':' ?}
    
    CheckColon -->|No| Return[Return]
    
    CheckColon -->|Yes| SplitPath["Split into path and line<br/>parts = p_meta.rsplit(':', true, 1)<br/>path = parts[0]<br/>line = parts[1].to_int() - 1"]
    
    SplitPath --> CheckRes{path starts with<br/>'res://' ?}
    
    CheckRes -->|Yes| LoadRes["ResourceLoader::exists(path)"]
    
    LoadRes --> OpenScript["ScriptEditor::edit(res, line, 0)<br/>InspectorDock::edit_resource(res)"]
    
    CheckRes -->|No| CheckCpp{Has extension<br/>.cpp, .h, .mm, .hpp ?}
    
    CheckCpp -->|Yes| RelPath{Starts with<br/>'./' or '.\\' ?}
    
    RelPath -->|Yes| MakeAbs["Convert to absolute path<br/>Using executable_path.get_base_dir()"]
    
    RelPath -->|No| OpenExt["ScriptEditorPlugin::open_in_external_editor()"]
    
    MakeAbs --> OpenExt
    
    OpenExt --> CheckOk{Success?}
    CheckOk -->|No| ShellOpen["OS::shell_open(path)"]
    
    CheckCpp -->|No| ShellOpen
```

Sources: [editor/editor_log.cpp:205-233]()

### UndoRedo Integration

The EditorLog can register with UndoRedo systems to log action names:

```mermaid
sequenceDiagram
    participant UndoRedo
    participant Callback as _undo_redo_cbk()
    participant EditorLog
    
    Note over EditorLog: register_undo_redo(UndoRedo*)
    EditorLog->>UndoRedo: set_commit_notify_callback(_undo_redo_cbk, this)
    
    Note over UndoRedo: Action performed
    UndoRedo->>Callback: Notify with action name
    Callback->>EditorLog: add_message(action_name, MSG_TYPE_EDITOR)
    EditorLog->>EditorLog: Display in log with editor icon
```

Sources: [editor/editor_log.cpp:295-302](), [editor/editor_log.h:185]()

### Thread Safety

The EditorLog handles messages from multiple threads safely:

- Error handler checks thread context: `Thread::is_main_thread()`
- Non-main thread messages are queued: `MessageQueue::get_main_singleton()->push_callable()`
- Main thread messages are processed directly: `self->add_message()`
- Prevents RTL corruption during update: `if (unlikely(log->is_updating())) return;`

Sources: [editor/editor_log.cpp:51-68](), [editor/editor_log.cpp:389-392]()

## Key APIs

### Public Methods

```cpp
// Add a message to the log
void add_message(const String &p_msg, MessageType p_type = MSG_TYPE_STD);

// Register UndoRedo system for action logging
void register_undo_redo(UndoRedo *p_undo_redo);

// Clear all messages
void clear();

// Initialize/deinitialize
void deinit();
```

Sources: [editor/editor_log.h:184-188]()

### Private Methods

```cpp
// Process and deduplicate messages
void _process_message(const String &p_msg, MessageType p_type, bool p_clear);

// Add formatted line to RichTextLabel
void _add_log_line(LogMessage &p_message, bool p_replace_previous = false);

// Rebuild entire log display
void _rebuild_log();

// Check if message passes filters
bool _check_display_message(LogMessage &p_message);

// State management
void _save_state();
void _load_state();
```

Sources: [editor/editor_log.h:159-175]()41:T5769,# Text Components

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/extension/gdextension_special_compat_hashes.cpp](core/extension/gdextension_special_compat_hashes.cpp)
- [core/extension/gdextension_special_compat_hashes.h](core/extension/gdextension_special_compat_hashes.h)
- [doc/classes/CodeEdit.xml](doc/classes/CodeEdit.xml)
- [doc/classes/Label.xml](doc/classes/Label.xml)
- [doc/classes/LabelSettings.xml](doc/classes/LabelSettings.xml)
- [doc/classes/LineEdit.xml](doc/classes/LineEdit.xml)
- [doc/classes/RichTextLabel.xml](doc/classes/RichTextLabel.xml)
- [doc/classes/TextEdit.xml](doc/classes/TextEdit.xml)
- [doc/classes/TextLine.xml](doc/classes/TextLine.xml)
- [doc/classes/TextParagraph.xml](doc/classes/TextParagraph.xml)
- [editor/editor_log.cpp](editor/editor_log.cpp)
- [editor/editor_log.h](editor/editor_log.h)
- [scene/SCsub](scene/SCsub)
- [scene/gui/code_edit.cpp](scene/gui/code_edit.cpp)
- [scene/gui/code_edit.h](scene/gui/code_edit.h)
- [scene/gui/label.cpp](scene/gui/label.cpp)
- [scene/gui/label.h](scene/gui/label.h)
- [scene/gui/line_edit.cpp](scene/gui/line_edit.cpp)
- [scene/gui/line_edit.h](scene/gui/line_edit.h)
- [scene/gui/rich_text_label.compat.inc](scene/gui/rich_text_label.compat.inc)
- [scene/gui/rich_text_label.cpp](scene/gui/rich_text_label.cpp)
- [scene/gui/rich_text_label.h](scene/gui/rich_text_label.h)
- [scene/gui/text_edit.cpp](scene/gui/text_edit.cpp)
- [scene/gui/text_edit.h](scene/gui/text_edit.h)
- [scene/resources/3d/world_3d.cpp](scene/resources/3d/world_3d.cpp)
- [scene/resources/3d/world_3d.h](scene/resources/3d/world_3d.h)
- [scene/resources/SCsub](scene/resources/SCsub)
- [scene/resources/label_settings.cpp](scene/resources/label_settings.cpp)
- [scene/resources/label_settings.h](scene/resources/label_settings.h)
- [scene/resources/text_line.cpp](scene/resources/text_line.cpp)
- [scene/resources/text_line.h](scene/resources/text_line.h)
- [scene/resources/text_paragraph.cpp](scene/resources/text_paragraph.cpp)
- [scene/resources/text_paragraph.h](scene/resources/text_paragraph.h)
- [servers/SCsub](servers/SCsub)
- [servers/register_server_types.cpp](servers/register_server_types.cpp)
- [tests/display_server_mock.h](tests/display_server_mock.h)
- [tests/scene/test_code_edit.h](tests/scene/test_code_edit.h)
- [tests/scene/test_text_edit.h](tests/scene/test_text_edit.h)
- [tests/scene/test_viewport.h](tests/scene/test_viewport.h)
- [tests/test_macros.h](tests/test_macros.h)
- [tests/test_main.cpp](tests/test_main.cpp)
- [tests/test_tools.h](tests/test_tools.h)
- [tests/test_validate_testing.h](tests/test_validate_testing.h)

</details>



## Purpose and Scope

This document covers the text editing and display controls in Godot's GUI system. These components handle user text input, formatted text display, and text rendering through the TextServer text shaping system. The text components include multiline editors (`TextEdit`, `CodeEdit`), formatted text display (`RichTextLabel`), simple text display (`Label`), and single-line input (`LineEdit`).

For information about the broader UI system and Control base class, see [Control & UI System](#4.4). For information about text rendering at the server level, see [Text Shaping System](#11.2).

## Component Hierarchy

The text components form a hierarchy under the `Control` class, each serving different text display and editing needs:

**Class Inheritance Hierarchy**

```mermaid
graph TB
    Control["Control"]
    TextEdit["TextEdit<br/>GDCLASS(TextEdit, Control)"]
    CodeEdit["CodeEdit<br/>GDCLASS(CodeEdit, TextEdit)"]
    RichTextLabel["RichTextLabel<br/>GDCLASS(RichTextLabel, Control)"]
    Label["Label<br/>GDCLASS(Label, Control)"]
    LineEdit["LineEdit<br/>GDCLASS(LineEdit, Control)"]
    
    Control --> TextEdit
    Control --> RichTextLabel
    Control --> Label
    Control --> LineEdit
    TextEdit --> CodeEdit
```

**Text Shaping Resource Usage**

```mermaid
graph TB
    TextEdit["TextEdit::Text::Line<br/>data_buf: Ref&lt;TextParagraph&gt;"]
    CodeEdit["CodeEdit<br/>(inherits TextEdit)"]
    RichTextLabel["RichTextLabel::Line<br/>text_buf: Ref&lt;TextParagraph&gt;"]
    Label["Label::Paragraph<br/>text_rid: RID (via TS)"]
    LineEdit["LineEdit<br/>text_rid: RID (via TS)"]
    
    TextParagraph["TextParagraph<br/>scene/resources/text_paragraph.h"]
    TextLine["TextLine<br/>scene/resources/text_line.h"]
    TextServer["TextServer (TS)<br/>servers/text/text_server.h"]
    
    TextEdit --> TextParagraph
    CodeEdit --> TextParagraph
    RichTextLabel --> TextParagraph
    Label --> TextServer
    LineEdit --> TextServer
    
    TextParagraph --> TextServer
    TextLine --> TextServer
```

**Sources:** [scene/gui/text_edit.h:40-41](), [scene/gui/code_edit.h:40](), [scene/gui/rich_text_label.h:47-48](), [scene/gui/label.h:38](), [scene/gui/line_edit.h:36-37](), [scene/gui/text_edit.h:154](), [scene/gui/rich_text_label.h:168](), [scene/resources/text_paragraph.h:37]()

## TextEdit: Multiline Text Editor

### Text Storage Architecture

`TextEdit` manages text as a custom `Text` class (`TextEdit::Text`) that maintains an array of `Line` structures. Each line contains the raw text and a `TextParagraph` for shaped text rendering:

**TextEdit::Text Internal Structure**

```mermaid
graph TB
    TextEdit["TextEdit<br/>scene/gui/text_edit.h"]
    TextClass["TextEdit::Text<br/>private nested class"]
    LineVector["Vector&lt;Line&gt; text<br/>mutable vector"]
    LineDef["struct Line"]
    
    TextEdit --> TextClass
    TextClass --> LineVector
    LineVector --> LineDef
    
    LineDef --> data["String data<br/>Raw text content"]
    LineDef --> data_buf["Ref&lt;TextParagraph&gt; data_buf<br/>Shaped text"]
    LineDef --> gutters["Vector&lt;Gutter&gt; gutters"]
    LineDef --> ime_data["String ime_data<br/>IME composition"]
    LineDef --> bidi_override["Array bidi_override"]
    LineDef --> accessibility["Vector&lt;RID&gt; accessibility_text_root_element"]
    LineDef --> hidden["bool hidden"]
    LineDef --> line_count["int line_count<br/>Number of wrapped lines"]
    LineDef --> height["int height<br/>Visual height"]
    LineDef --> width["int width<br/>Visual width"]
    LineDef --> indent_ofs["float indent_ofs<br/>Indentation offset"]
```

**Sources:** [scene/gui/text_edit.h:136-287](), [scene/gui/text_edit.h:149-170](), [scene/gui/text_edit.cpp:50-89]()

### Key Components

#### Text Class

The `Text` class manages text content, line wrapping, and invalidation:

- **Line Management**: Stores text as `Vector<Line>` with methods `set()`, `insert()`, `remove_range()` [scene/gui/text_edit.cpp:459-560]()
- **Text Shaping**: Each line has a `TextParagraph` (`data_buf`) for shaped text [scene/gui/text_edit.h:154]()
- **Invalidation**: Tracks dirty state and invalidates shaped text when needed [scene/gui/text_edit.cpp:264-440]()
- **Line Wrapping**: Calculates wrap count per line using TextServer [scene/gui/text_edit.cpp:167-183]()

#### Gutter System

Gutters provide margins for line numbers, breakpoints, and custom content:

| Property | Type | Purpose |
|----------|------|---------|
| `type` | `GutterType` | STRING, ICON, or CUSTOM |
| `width` | `int` | Gutter width in pixels |
| `draw` | `bool` | Whether to draw this gutter |
| `clickable` | `bool` | Whether gutter responds to clicks |
| `custom_draw_callback` | `Callable` | Custom drawing function |

**Sources:** [scene/gui/text_edit.h:125-134](), [scene/gui/text_edit.h:562-589]()

#### Caret System

`TextEdit` supports multiple carets for simultaneous editing:

```mermaid
graph LR
    TextEdit --> CaretArray["Vector&lt;Caret&gt;<br/>carets"]
    CaretArray --> Caret0["Caret[0]<br/>Main Caret"]
    CaretArray --> Caret1["Caret[1]<br/>Secondary Caret"]
    CaretArray --> CaretN["Caret[n]<br/>..."]
    
    Caret0 --> Selection["Selection<br/>active, origin, extent"]
    Caret0 --> Position["Position<br/>line, column"]
    Caret0 --> DrawPos["Point2 draw_pos"]
```

**Sources:** [scene/gui/text_edit.h:434-453](), [scene/gui/text_edit.h:456]()

### Text Shaping and Rendering Pipeline

The text rendering process uses a multi-stage pipeline:

```mermaid
graph TB
    Input["Text Input<br/>String data"]
    Invalidate["invalidate_cache()<br/>Mark Line Dirty"]
    Shape["_shape() via TextParagraph"]
    TSAdd["TS->shaped_text_add_string()"]
    TSBreak["TS->shaped_text_get_line_breaks()"]
    Draw["_notification(DRAW)"]
    Render["TS->shaped_text_draw()"]
    
    Input --> Invalidate
    Invalidate --> Shape
    Shape --> TSAdd
    TSAdd --> TSBreak
    TSBreak --> Draw
    Draw --> Render
```

**Sources:** [scene/gui/text_edit.cpp:264-440](), [scene/gui/text_edit.cpp:296-352]()

### Versioning and Undo/Redo

TextEdit maintains a `TextOperation` stack for undo/redo:

| Field | Type | Purpose |
|-------|------|---------|
| `type` | `TYPE_INSERT` or `TYPE_REMOVE` | Operation type |
| `from_line`, `from_column` | `int` | Start position |
| `to_line`, `to_column` | `int` | End position |
| `text` | `String` | Text affected |
| `start_carets`, `end_carets` | `Vector<Caret>` | Caret states |
| `version` | `uint32_t` | Operation version |
| `chain_forward`, `chain_backward` | `bool` | Operation chaining |

**Sources:** [scene/gui/text_edit.h:370-389](), [scene/gui/text_edit.h:391-413]()

## CodeEdit: Code-Specific Editor

`CodeEdit` extends `TextEdit` with features for code editing:

```mermaid
graph TB
    CodeEdit["CodeEdit<br/>Extends TextEdit"]
    
    Completion["Code Completion System"]
    CompOptions["code_completion_options<br/>Vector&lt;CodeCompletionOption&gt;"]
    CompBase["code_completion_base<br/>String"]
    CompActive["code_completion_active<br/>bool"]
    
    Folding["Code Folding System"]
    FoldCache["code_folding_cache<br/>RBSet&lt;int&gt;"]
    FoldableLines["get_foldable_lines()<br/>TypedArray&lt;int&gt;"]
    
    Syntax["Syntax Checking"]
    SyntaxCheck["set_line_as_*()<br/>safe, warning, error"]
    
    CodeEdit --> Completion
    CodeEdit --> Folding
    CodeEdit --> Syntax
    
    Completion --> CompOptions
    Completion --> CompBase
    Completion --> CompActive
    
    Folding --> FoldCache
    Folding --> FoldableLines
```

**Sources:** [scene/gui/code_edit.h:40](), [scene/gui/code_edit.h:90-174]()

### Code Completion

The completion system provides context-aware suggestions:

- **Activation**: Triggered by `request_code_completion()` or user input [scene/gui/code_edit.cpp:2433-2464]()
- **Filtering**: Virtual method `_filter_code_completion_candidates()` allows customization [doc/classes/CodeEdit.xml:20-26]()
- **Display**: Popup shows filtered options with icons and colors [scene/gui/code_edit.cpp:139-258]()
- **Confirmation**: Virtual method `_confirm_code_completion()` handles selection [doc/classes/CodeEdit.xml:13-18]()

### Code Folding

Line folding allows collapsing code blocks:

- **Fold Regions**: Defined by `create_code_region()` or detected automatically [scene/gui/code_edit.cpp:3166-3227]()
- **Foldable Lines**: Cached in `code_folding_cache` [scene/gui/code_edit.h:156]()
- **Fold State**: Tracked per line with `set_line_folded()` [scene/gui/code_edit.cpp:3324-3363]()

**Sources:** [scene/gui/code_edit.h:135-162](), [scene/gui/code_edit.cpp:3166-3363]()

## RichTextLabel: Formatted Text Display

### Item Hierarchy

`RichTextLabel` uses an item tree to represent formatted text. Each item corresponds to a formatting tag or text content:

```mermaid
graph TB
    Main["ItemFrame main<br/>Root Item"]
    Para1["ItemFrame<br/>Paragraph 1"]
    Para2["ItemFrame<br/>Paragraph 2"]
    
    Text1["ItemText<br/>Plain Text"]
    Bold["ItemFont<br/>Bold Tag"]
    BoldText["ItemText<br/>Bold Text"]
    Color["ItemColor<br/>Color Tag"]
    ColorText["ItemText<br/>Colored Text"]
    Image["ItemImage<br/>Image"]
    
    Main --> Para1
    Main --> Para2
    Para1 --> Text1
    Para1 --> Bold
    Bold --> BoldText
    Para2 --> Color
    Color --> ColorText
    Para2 --> Image
```

**Sources:** [scene/gui/rich_text_label.h:200-226](), [scene/gui/rich_text_label.h:228-252]()

### Item Types

The system defines multiple item types for different content and formatting:

| Item Type | Purpose | Key Fields |
|-----------|---------|------------|
| `ITEM_FRAME` | Container/paragraph | `lines`, `padding` |
| `ITEM_TEXT` | Plain text | `text` |
| `ITEM_IMAGE` | Embedded image | `image`, `size`, `region` |
| `ITEM_FONT` | Font change | `font`, `font_size` |
| `ITEM_COLOR` | Text color | `color` |
| `ITEM_NEWLINE` | Line break | (none) |
| `ITEM_TABLE` | Table layout | `columns`, `rows` |
| `ITEM_META` | Clickable metadata | `meta` |
| `ITEM_DROPCAP` | Drop cap letter | `text`, `font`, `margins` |

**Sources:** [scene/gui/rich_text_label.h:74-105](), [scene/gui/rich_text_label.h:254-339]()

### Line Shaping Pipeline

Each paragraph (Line) in RichTextLabel is shaped independently:

```mermaid
graph TB
    Start["_shape_line()"]
    Clear["Clear text_buf"]
    Iterate["Iterate Items"]
    
    CheckType{Item Type?}
    AddText["Add Text to TextParagraph"]
    AddImage["Add Image Object"]
    AddTable["Calculate Table Layout"]
    
    ApplyBidi["Apply BiDi Override"]
    SetWidth["Set Line Width"]
    Calculate["Calculate Vertical Offset"]
    
    Start --> Clear
    Clear --> Iterate
    Iterate --> CheckType
    CheckType -->|ITEM_TEXT| AddText
    CheckType -->|ITEM_IMAGE| AddImage
    CheckType -->|ITEM_TABLE| AddTable
    AddText --> ApplyBidi
    AddImage --> ApplyBidi
    AddTable --> ApplyBidi
    ApplyBidi --> SetWidth
    SetWidth --> Calculate
```

**Sources:** [scene/gui/rich_text_label.cpp:557-764](), [scene/gui/rich_text_label.cpp:613-751]()

### BBCode Parsing

BBCode tags are parsed into the item hierarchy. The parser processes text character-by-character, building the item tree:

**BBCode Processing Flow**

```mermaid
graph TB
    setText["set_text(bbcode_text)"]
    bbcodeEnabled{"bbcode_enabled?"}
    clear["_clear_main()"]
    
    processLine["_process_line(text, pos, font, ...)"]
    checkTag{"char == '['?"}
    parseTag["Parse tag name and attributes"]
    checkClose{"Is closing tag?"}
    
    pushItem["push_*() method<br/>(e.g., push_bold, push_color)"]
    popItem["pop() - close current item"]
    addText["ItemText created with text content"]
    
    updateStack["Update current_frame and current"]
    invalidate["Invalidate layout"]
    
    setText --> bbcodeEnabled
    bbcodeEnabled -->|true| clear
    bbcodeEnabled -->|false| addText
    clear --> processLine
    processLine --> checkTag
    checkTag -->|yes| parseTag
    checkTag -->|no| addText
    parseTag --> checkClose
    checkClose -->|yes| popItem
    checkClose -->|no| pushItem
    pushItem --> updateStack
    popItem --> updateStack
    updateStack --> invalidate
```

**BBCode Tag Implementation**

- **Parser**: Text is processed in `_process_line()` which handles BBCode tag detection and parsing
- **Tag Stack**: `current` pointer tracks the current item, `current_frame` tracks the current paragraph [scene/gui/rich_text_label.h:658-659]()
- **Push Methods**: Each tag type has a `push_*()` method (e.g., `push_bold()`, `push_color()`, `push_meta()`)
- **Pop Method**: `pop()` closes the current item and returns to parent
- **Common Tags**: `[b]` (bold), `[i]` (italic), `[color=...]` (text color), `[img]` (image), `[table]` (table layout), `[url]` (meta/link), `[font]` (font change)

**Sources:** [scene/gui/rich_text_label.h:658-659](), [doc/classes/RichTextLabel.xml:1-100]()

### Threaded Text Processing

RichTextLabel can process text in background threads:

```mermaid
graph LR
    Main["Main Thread"]
    Worker["WorkerThreadPool"]
    Task["_process_line_caches()"]
    
    Main -->|"Submit Task"| Worker
    Worker --> Task
    Task -->|"Shape Lines"| TextParagraph
    Task -->|"Complete"| Main
```

**Sources:** [scene/gui/rich_text_label.h:33](), [scene/gui/rich_text_label.h:232-234]()

## Label: Simple Text Display

`Label` provides straightforward text display with basic formatting:

### Paragraph Management

Label splits text into paragraphs using a separator:

```mermaid
graph TB
    Text["xl_text<br/>Full Text"]
    Split["split(paragraph_separator)"]
    Para1["Paragraph 1"]
    Para2["Paragraph 2"]
    ParaN["Paragraph N"]
    
    Shape1["TextParagraph<br/>text_rid"]
    Shape2["TextParagraph<br/>text_rid"]
    ShapeN["TextParagraph<br/>text_rid"]
    
    Text --> Split
    Split --> Para1
    Split --> Para2
    Split --> ParaN
    
    Para1 --> Shape1
    Para2 --> Shape2
    ParaN --> ShapeN
```

**Sources:** [scene/gui/label.cpp:138-170](), [scene/gui/label.cpp:154-168]()

### Key Features

- **Autowrap Modes**: AUTOWRAP_OFF, AUTOWRAP_ARBITRARY, AUTOWRAP_WORD, AUTOWRAP_WORD_SMART [scene/gui/label.cpp:37-52]()
- **Text Direction**: Supports LTR, RTL, and auto-detection [scene/gui/label.cpp:178-182]()
- **Uppercase**: Optional text transformation [scene/gui/label.cpp:95-109]()
- **Visible Characters**: Progressive text reveal [scene/gui/label.cpp:154-157]()

**Sources:** [scene/gui/label.cpp:37-109](), [scene/gui/label.h:38-67]()

## LineEdit: Single-Line Input

`LineEdit` handles single-line text entry with selection and editing:

### Text Management

```mermaid
graph LR
    LineEdit["LineEdit"]
    Text["String text<br/>Actual Text"]
    IME["String ime_text<br/>IME Composition"]
    TextRID["RID text_rid<br/>Shaped Text"]
    Selection["Selection Structure<br/>begin, end, enabled"]
    
    LineEdit --> Text
    LineEdit --> IME
    LineEdit --> TextRID
    LineEdit --> Selection
```

**Sources:** [scene/gui/line_edit.h:92-123](), [scene/gui/line_edit.h:172-194]()

### Input Handling

LineEdit processes various input methods through `gui_input()` and specialized handlers:

**Input Processing Pipeline**

```mermaid
graph TB
    guiInput["gui_input(InputEvent)"]
    checkType{"Event Type?"}
    
    mouse["InputEventMouseButton<br/>InputEventMouseMotion"]
    key["InputEventKey"]
    
    mouseClick["Handle click/drag selection"]
    setCaretPos["set_caret_at_pixel_pos()"]
    updateSel["selection_fill_at_caret()"]
    
    checkIME{"IME active?"}
    handleIME["Update ime_text<br/>_update_ime_text()"]
    checkAlt{"Alt code mode?"}
    handleAlt["Update alt_code<br/>Build Unicode/OEM/Win code"]
    handleChar["insert_text_at_caret(char)"]
    
    shape["_shape()<br/>Invalidate text_rid"]
    redraw["queue_redraw()"]
    
    guiInput --> checkType
    checkType --> mouse
    checkType --> key
    
    mouse --> mouseClick
    mouseClick --> setCaretPos
    setCaretPos --> updateSel
    
    key --> checkIME
    checkIME -->|yes| handleIME
    checkIME -->|no| checkAlt
    checkAlt -->|yes| handleAlt
    checkAlt -->|no| handleChar
    
    handleIME --> shape
    handleAlt --> shape
    handleChar --> shape
    shape --> redraw
```

**Input Method Features**

- **Direct Input**: Keyboard characters via `gui_input()` â†’ `insert_text_at_caret()` [scene/gui/line_edit.cpp:420-430]()
- **IME Support**: Handles Input Method Editor for complex scripts via `ime_text` field and `_update_ime_text()` [scene/gui/line_edit.cpp:118-178]()
- **Alt Codes**: Three modes stored in `alt_mode` enum:
  - `ALT_INPUT_UNICODE`: Hold Alt, type `+` then hex digits (e.g., `+E1` for Ã¡)
  - `ALT_INPUT_OEM`: Hold Alt, type decimal digits (e.g., `160` for Ã¡)
  - `ALT_INPUT_WIN`: Hold Alt, type `0` then decimal digits (e.g., `0225` for Ã¡)
  - Implementation in [scene/gui/line_edit.cpp:718-837]()
- **Selection**: Mouse drag via `selection.creating` flag and keyboard via shift modifier [scene/gui/line_edit.cpp:508-651]()
- **Caret Movement**: Word boundaries via `TS->shaped_text_get_word_breaks()` [scene/gui/line_edit.cpp:201-211]()

**Sources:** [scene/gui/line_edit.cpp:433-837](), [scene/gui/line_edit.h:102-119]()

### Features

| Feature | Implementation | Source |
|---------|----------------|--------|
| Caret Movement | `_move_caret_left/right()` | [scene/gui/line_edit.cpp:189-263]() |
| Text Deletion | `_backspace()`, `_delete()` | [scene/gui/line_edit.cpp:277-371]() |
| Secret Mode | Password masking with `secret_character` | [scene/gui/line_edit.h:118]() |
| Clear Button | Optional button to clear text | [scene/gui/line_edit.cpp:501-589]() |
| Context Menu | Cut/copy/paste menu | [scene/gui/line_edit.cpp:446-451]() |

**Sources:** [scene/gui/line_edit.cpp:189-371](), [scene/gui/line_edit.h:92-168]()

## Text Shaping Integration

All text components use the TextServer system for text shaping and rendering:

### TextParagraph and TextLine

These resource classes wrap TextServer functionality:

```mermaid
graph TB
    Component["TextEdit/RichTextLabel/Label"]
    TP["TextParagraph<br/>Resource"]
    TL["TextLine<br/>Resource"]
    TS["TextServer<br/>Singleton"]
    
    Component -->|"Multiline"| TP
    Component -->|"Single Line"| TL
    TP --> RID1["RID shaped_text<br/>TextServer RID"]
    TL --> RID2["RID shaped_text<br/>TextServer RID"]
    RID1 --> TS
    RID2 --> TS
    
    TS --> HarfBuzz["HarfBuzz/ICU<br/>Text Shaping"]
```

**Sources:** [scene/resources/text_paragraph.h:37-52](), [scene/resources/text_line.cpp:1-20]()

### Shaping Process

The typical text shaping flow:

1. **Create RID**: `TS->create_shaped_text()` creates a text buffer RID
2. **Add Text**: `TS->shaped_text_add_string()` adds text with font [scene/gui/text_edit.cpp:314-321]()
3. **Shape**: TextServer performs BiDi analysis, line breaking, and glyph positioning
4. **Get Line Breaks**: `TS->shaped_text_get_line_breaks()` for wrapping [scene/gui/label.cpp:225]()
5. **Draw**: `TS->shaped_text_draw()` or `shaped_text_get_glyphs()` for rendering

### TextServer Features Used

| Feature | Purpose | Usage Example |
|---------|---------|---------------|
| BiDi Analysis | Right-to-left text support | `shaped_text_set_bidi_override()` |
| Line Breaking | Word/character wrapping | `shaped_text_get_line_breaks()` |
| Word Boundaries | Word selection/navigation | `shaped_text_get_word_breaks()` |
| Glyph Positioning | Accurate text rendering | `shaped_text_get_glyphs()` |
| Font Fallback | Missing glyph handling | Automatic in TextServer |

**Sources:** [scene/gui/text_edit.cpp:296-352](), [scene/gui/label.cpp:178-233](), [scene/resources/text_paragraph.cpp:1-50]()42:T4860,# TextEdit & CodeEdit

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/CodeEdit.xml](doc/classes/CodeEdit.xml)
- [doc/classes/LineEdit.xml](doc/classes/LineEdit.xml)
- [doc/classes/TextEdit.xml](doc/classes/TextEdit.xml)
- [scene/SCsub](scene/SCsub)
- [scene/gui/code_edit.cpp](scene/gui/code_edit.cpp)
- [scene/gui/code_edit.h](scene/gui/code_edit.h)
- [scene/gui/line_edit.cpp](scene/gui/line_edit.cpp)
- [scene/gui/line_edit.h](scene/gui/line_edit.h)
- [scene/gui/text_edit.cpp](scene/gui/text_edit.cpp)
- [scene/gui/text_edit.h](scene/gui/text_edit.h)
- [scene/resources/3d/world_3d.cpp](scene/resources/3d/world_3d.cpp)
- [scene/resources/3d/world_3d.h](scene/resources/3d/world_3d.h)
- [scene/resources/SCsub](scene/resources/SCsub)
- [servers/SCsub](servers/SCsub)
- [servers/register_server_types.cpp](servers/register_server_types.cpp)
- [tests/display_server_mock.h](tests/display_server_mock.h)
- [tests/scene/test_code_edit.h](tests/scene/test_code_edit.h)
- [tests/scene/test_text_edit.h](tests/scene/test_text_edit.h)
- [tests/scene/test_viewport.h](tests/scene/test_viewport.h)
- [tests/test_macros.h](tests/test_macros.h)
- [tests/test_main.cpp](tests/test_main.cpp)
- [tests/test_tools.h](tests/test_tools.h)
- [tests/test_validate_testing.h](tests/test_validate_testing.h)

</details>



This page documents the text editing controls in Godot: `TextEdit`, `CodeEdit`, and `LineEdit`. These controls provide multiline and single-line text input/editing capabilities for both game UI and the editor itself.

For information about text layout and shaping, see [Text Layout System](#9.2). For rich text formatting, see [RichTextLabel](#9.3).

## Purpose and Scope

`TextEdit` is a multiline text editor control designed for editing plain text with features like multiple carets, line wrapping, scrolling, and syntax highlighting support. `CodeEdit` extends `TextEdit` with specialized code editing features such as code completion, auto-indentation, line folding, and breakpoint management. `LineEdit` provides single-line text input for simpler use cases.

These controls are used throughout Godot's editor (script editing, property inputs) and are available for game developers to create custom text editing interfaces.

## Class Hierarchy

```mermaid
classDiagram
    Control <|-- TextEdit
    Control <|-- LineEdit
    TextEdit <|-- CodeEdit
    
    class Control {
        +gui_input()
        +_notification()
    }
    
    class TextEdit {
        +Text text
        +Vector~Caret~ carets
        +SyntaxHighlighter syntax_highlighter
        +insert_text_at_caret()
        +get_text()
        +set_text()
        +undo()
        +redo()
    }
    
    class CodeEdit {
        +code_completion_active
        +auto_indent
        +line_folding_enabled
        +request_code_completion()
        +confirm_code_completion()
    }
    
    class LineEdit {
        +RID text_rid
        +set_text()
        +get_text()
        +insert_text_at_caret()
    }
```

**Sources:** [scene/gui/text_edit.h:40-41](), [scene/gui/code_edit.h:36-37](), [scene/gui/line_edit.h:36-37]()

## TextEdit Architecture

### Core Components

```mermaid
graph TB
    TextEdit["TextEdit<br/>(Control)"]
    Text["TextEdit::Text<br/>(Internal text storage)"]
    Line["TextEdit::Text::Line<br/>(Per-line data)"]
    TextParagraph["TextParagraph<br/>(Text shaping)"]
    Caret["TextEdit::Caret<br/>(Caret state)"]
    Selection["TextEdit::Selection<br/>(Selection state)"]
    TextOperation["TextEdit::TextOperation<br/>(Undo/redo)"]
    
    TextEdit --> Text
    TextEdit --> Caret
    Text --> Line
    Line --> TextParagraph
    Caret --> Selection
    TextEdit --> TextOperation
```

**Sources:** [scene/gui/text_edit.h:136-287](), [scene/gui/text_edit.cpp:50-559]()

### Text Storage System

The `TextEdit::Text` class manages the internal text buffer and rendering metadata:

```mermaid
classDiagram
    class Text {
        -Vector~Line~ text
        -Ref~Font~ font
        -int font_size
        -int max_line_width
        -int max_line_height
        -int total_visible_line_count
        +set_font()
        +set_tab_size()
        +invalidate_cache()
        +get_line_data()
    }
    
    class Line {
        +String data
        +Array bidi_override
        +Ref~TextParagraph~ data_buf
        +Vector~Gutter~ gutters
        +bool hidden
        +int line_count
        +int height
        +int width
    }
    
    class Gutter {
        +Variant metadata
        +Ref~Texture2D~ icon
        +String text
        +Color color
        +bool clickable
    }
    
    Text --> Line
    Line --> Gutter
```

The `Text` class maintains:
- A vector of `Line` structs containing the actual text data
- Font and rendering properties
- Cached width/height metrics for performance
- Gutter data for each line (line numbers, breakpoints, etc.)

Each `Line` contains:
- The raw text string (`data`)
- A `TextParagraph` instance (`data_buf`) for text shaping and wrapping
- Bidirectional text override information
- Visual properties (hidden state, computed dimensions)
- Per-line gutter data

**Sources:** [scene/gui/text_edit.h:136-287](), [scene/gui/text_edit.cpp:50-559]()

### Multi-Caret System

`TextEdit` supports multiple simultaneous carets for editing:

```mermaid
graph LR
    TextEdit --> CaretVector["Vector&lt;Caret&gt; carets"]
    CaretVector --> Caret0["Caret[0]<br/>(Main caret)"]
    CaretVector --> Caret1["Caret[1]"]
    CaretVector --> CaretN["Caret[n]"]
    
    Caret0 --> Selection0["Selection"]
    Caret1 --> Selection1["Selection"]
```

Each `Caret` struct tracks:
- Line and column position
- Visual draw position
- Last horizontal fit position (for up/down movement)
- Associated selection state

Key methods for caret management:
- `add_caret(line, column)` - Creates a new caret
- `remove_caret(index)` - Removes a caret
- `merge_overlapping_carets()` - Consolidates overlapping carets
- `get_caret_count()` - Returns number of active carets

**Sources:** [scene/gui/text_edit.h:445-463](), [scene/gui/text_edit.cpp:3837-4137]()

### Selection System

Each caret can have an associated selection:

| Property | Type | Description |
|----------|------|-------------|
| `active` | bool | Whether selection is active |
| `origin_line` | int | Starting line of selection |
| `origin_column` | int | Starting column of selection |
| `word_begin_column` | int | Word selection start |
| `word_end_column` | int | Word selection end |

Selection modes:
- `SELECTION_MODE_NONE` - No selection
- `SELECTION_MODE_SHIFT` - Shift+arrow keys
- `SELECTION_MODE_POINTER` - Mouse drag
- `SELECTION_MODE_WORD` - Double-click word selection
- `SELECTION_MODE_LINE` - Triple-click line selection

**Sources:** [scene/gui/text_edit.h:435-443](), [scene/gui/text_edit.h:497-519]()

### Undo/Redo System

Text editing operations are tracked via the `TextOperation` struct:

```mermaid
graph TD
    UndoStack["List&lt;TextOperation&gt; undo_stack"]
    UndoStackPos["undo_stack_pos<br/>(current position)"]
    CurrentOp["current_op<br/>(pending operation)"]
    
    TextOperation["TextOperation"]
    TextOperation --> Type["type: INSERT/REMOVE"]
    TextOperation --> Positions["from_line, from_column<br/>to_line, to_column"]
    TextOperation --> Carets["start_carets, end_carets"]
    TextOperation --> Text["text: String"]
    TextOperation --> Version["version, prev_version"]
    
    UndoStack --> TextOperation
    UndoStackPos --> UndoStack
```

Operations are grouped by:
- Action type (typing, backspace, delete)
- Timing (idle detection via timer)
- Complex operations (explicit begin/end markers)

Key methods:
- `begin_complex_operation()` / `end_complex_operation()` - Group operations
- `undo()` / `redo()` - Traverse operation history
- `_push_current_op()` - Commits pending operation to stack

**Sources:** [scene/gui/text_edit.h:370-412](), [scene/gui/text_edit.cpp:1382-1618]()

### Rendering Pipeline

```mermaid
graph TB
    Notification["NOTIFICATION_DRAW"]
    UpdateScrollbars["_update_scrollbars()"]
    DrawStyle["Draw StyleBox background"]
    DrawGutters["Draw gutters"]
    DrawText["Draw text lines"]
    DrawCaret["Draw carets"]
    DrawSelection["Draw selections"]
    DrawMinimap["Draw minimap (if enabled)"]
    
    Notification --> UpdateScrollbars
    UpdateScrollbars --> DrawStyle
    DrawStyle --> DrawGutters
    DrawGutters --> DrawText
    DrawText --> DrawSelection
    DrawSelection --> DrawCaret
    DrawCaret --> DrawMinimap
    
    DrawText --> TextParagraph["TextParagraph::draw()"]
    DrawText --> SyntaxHighlighter["SyntaxHighlighter::get_line_syntax_highlighting()"]
```

The rendering process:
1. Calculate visible line range from scroll position
2. For each visible line:
   - Retrieve `TextParagraph` from `Text::Line`
   - Apply syntax highlighting colors
   - Draw line background (if set)
   - Draw text via `TextParagraph::draw()`
   - Draw selection highlights
3. Draw carets at computed positions
4. Draw minimap if enabled

**Sources:** [scene/gui/text_edit.cpp:907-1380]()

### Gutter System

Gutters are vertical columns displayed to the left of the text content:

| Gutter Type | Purpose | Example Use |
|-------------|---------|-------------|
| `GUTTER_TYPE_STRING` | Text display | Line numbers |
| `GUTTER_TYPE_ICON` | Icon display | Breakpoints, bookmarks |
| `GUTTER_TYPE_CUSTOM` | Custom drawing | Code folding controls |

Gutter methods:
- `add_gutter(at=-1)` - Adds a new gutter
- `remove_gutter(gutter)` - Removes a gutter
- `set_gutter_width(gutter, width)` - Sets width
- `set_gutter_custom_draw(gutter, callback)` - Custom drawing

**Sources:** [scene/gui/text_edit.h:73-78](), [scene/gui/text_edit.h:592-599]()

## CodeEdit Extensions

`CodeEdit` extends `TextEdit` with programming-specific features:

### Code Completion System

```mermaid
graph TB
    RequestCompletion["request_code_completion()"]
    VirtualMethod["_request_code_completion()<br/>(virtual)"]
    AddOptions["add_code_completion_option()"]
    UpdateOptions["update_code_completion_options()"]
    FilterCandidates["_filter_code_completion_candidates()<br/>(virtual)"]
    ConfirmCompletion["confirm_code_completion()"]
    VirtualConfirm["_confirm_code_completion()<br/>(virtual)"]
    
    RequestCompletion --> VirtualMethod
    VirtualMethod --> AddOptions
    AddOptions --> UpdateOptions
    UpdateOptions --> FilterCandidates
    FilterCandidates --> Display["Display completion popup"]
    Display --> ConfirmCompletion
    ConfirmCompletion --> VirtualConfirm
```

Code completion data structure:

```mermaid
classDiagram
    class CodeCompletionOption {
        +CodeCompletionKind kind
        +String display
        +String insert_text
        +Color font_color
        +Ref~Texture2D~ icon
        +Variant default_value
        +int location
        +Vector~Pair~ matches
    }
```

Completion kinds:
- `KIND_CLASS`, `KIND_FUNCTION`, `KIND_SIGNAL`, `KIND_VARIABLE`
- `KIND_MEMBER`, `KIND_ENUM`, `KIND_CONSTANT`
- `KIND_NODE_PATH`, `KIND_FILE_PATH`, `KIND_PLAIN_TEXT`

**Sources:** [scene/gui/code_edit.h:42-61](), [scene/gui/code_edit.cpp:1421-1799]()

### Auto-Indentation

`CodeEdit` provides automatic indentation management:

```mermaid
graph LR
    NewLine["Insert newline"]
    CheckIndent["Check auto_indent enabled"]
    CalculateIndent["Calculate indent level<br/>from previous line"]
    CheckPrefixes["Check auto_indent_prefixes<br/>(e.g., '{', ':', '[')"]
    InsertIndent["Insert indent string"]
    
    NewLine --> CheckIndent
    CheckIndent --> CalculateIndent
    CalculateIndent --> CheckPrefixes
    CheckPrefixes --> InsertIndent
```

Configuration:
- `set_indent_size(size)` - Sets indent width
- `set_indent_using_spaces(enabled)` - Tabs vs spaces
- `set_auto_indent_enabled(enabled)` - Enable/disable
- `set_auto_indent_prefixes(prefixes)` - Characters triggering indent

**Sources:** [scene/gui/code_edit.h:64-76](), [scene/gui/code_edit.cpp:64-258]()

### Line Folding

Code regions can be collapsed/expanded:

```mermaid
graph TD
    FoldLine["fold_line(line)"]
    CheckFoldable["is_line_folded(line)"]
    UpdateHidden["Set line hidden state"]
    UpdateGutter["Update fold gutter icon"]
    Redraw["queue_redraw()"]
    
    FoldLine --> CheckFoldable
    CheckFoldable --> UpdateHidden
    UpdateHidden --> UpdateGutter
    UpdateGutter --> Redraw
```

Folding features:
- Automatic region detection via delimiters
- Custom region markers (`#region` / `#endregion`)
- Fold gutter with clickable icons
- `fold_line()` / `unfold_line()` methods
- `fold_all_lines()` / `unfold_all_lines()` utilities

**Sources:** [scene/gui/code_edit.h:129-138](), [scene/gui/code_edit.cpp:2458-2755]()

### Gutter Extensions

`CodeEdit` uses gutters for development features:

| Gutter | Purpose | Type |
|--------|---------|------|
| `main_gutter` | Breakpoints, bookmarks, execution marker | `GUTTER_TYPE_ICON` |
| `line_number_gutter` | Line numbering | `GUTTER_TYPE_STRING` |
| `fold_gutter` | Code folding controls | `GUTTER_TYPE_CUSTOM` |

Main gutter flags:
- `MAIN_GUTTER_BREAKPOINT` - Breakpoint marker
- `MAIN_GUTTER_BOOKMARK` - Bookmark marker
- `MAIN_GUTTER_EXECUTING` - Execution position marker

**Sources:** [scene/gui/code_edit.h:91-127](), [scene/gui/code_edit.cpp:3476-3603]()

### Delimiter System

Delimiters mark string and comment regions:

```mermaid
classDiagram
    class Delimiter {
        +String start_key
        +String end_key
        +bool line_only
    }
    
    class CodeEdit {
        +add_string_delimiter()
        +add_comment_delimiter()
        +is_in_string()
        +is_in_comment()
    }
    
    CodeEdit --> Delimiter
```

Delimiter functionality:
- String delimiters (e.g., `"..."`, `'...'`, `"""..."""`)
- Comment delimiters (e.g., `//`, `/* ... */`, `#`)
- Line-only vs multi-line delimiters
- Used for syntax highlighting and special key handling

**Sources:** [scene/gui/code_edit.h:139-164](), [scene/gui/code_edit.cpp:2756-3156]()

## LineEdit Overview

`LineEdit` provides single-line text input with a simpler architecture than `TextEdit`:

| Feature | Implementation |
|---------|----------------|
| Text storage | `String text` |
| Text shaping | `RID text_rid` via TextServer |
| Caret | Single `int caret_column` |
| Selection | `Selection` struct with begin/end |
| Undo/redo | `List<TextOperation>` |

Key differences from `TextEdit`:
- No line wrapping (single line only)
- Simpler rendering (no gutters, minimap)
- Horizontal scrolling only
- Secret character support for passwords
- Clear button option

**Sources:** [scene/gui/line_edit.h:86-221](), [scene/gui/line_edit.cpp:50-1035]()

## Integration with Other Systems

### TextServer Integration

All text controls use the TextServer API for text shaping:

```mermaid
graph LR
    TextEdit --> TextParagraph
    LineEdit --> TextServer["TextServer::shaped_text_*"]
    TextParagraph --> TextServer
    
    TextServer --> Fonts["Font rendering"]
    TextServer --> BiDi["Bidirectional text"]
    TextServer --> Shaping["OpenType shaping"]
```

`TextEdit` uses `TextParagraph` objects (one per line) which internally use TextServer. `LineEdit` calls TextServer directly.

**Sources:** [scene/gui/text_edit.cpp:50-452](), [scene/gui/line_edit.cpp:1037-1159]()

### SyntaxHighlighter Integration

`TextEdit` supports pluggable syntax highlighting:

```mermaid
graph TB
    TextEdit["TextEdit"]
    SyntaxHighlighter["SyntaxHighlighter<br/>(abstract base)"]
    GetLineHighlighting["get_line_syntax_highlighting(line)"]
    ColorMap["Returns Dictionary&lt;column, Color&gt;"]
    
    TextEdit --> SyntaxHighlighter
    SyntaxHighlighter --> GetLineHighlighting
    GetLineHighlighting --> ColorMap
    ColorMap --> RenderText["Apply colors during rendering"]
```

`SyntaxHighlighter` is an abstract class that can be extended to provide custom syntax coloring. The editor uses `CodeHighlighter` (a built-in implementation) for GDScript and other languages.

**Sources:** [scene/gui/text_edit.h:601-606](), [scene/gui/text_edit.cpp:1189-1370]()

### Input Handling

Text controls process input through multiple paths:

```mermaid
graph TB
    GuiInput["gui_input(InputEvent)"]
    UnhandledInput["unhandled_key_input(InputEvent)"]
    IME["IME (Input Method Editor)"]
    
    GuiInput --> MouseInput["Mouse events<br/>(selection, caret placement)"]
    GuiInput --> KeyInput["Keyboard events<br/>(navigation, shortcuts)"]
    UnhandledInput --> TextInput["Unicode text input"]
    IME --> IMEText["Composed text preview"]
    
    MouseInput --> UpdateCarets["Update carets/selection"]
    KeyInput --> Actions["Execute actions"]
    TextInput --> InsertText["insert_text_at_caret()"]
    IMEText --> ShapeIME["Shape with TextServer"]
```

Key input processing:
- `gui_input()` - Handles mouse and keyboard events
- `unhandled_key_input()` - Processes text input after shortcuts
- IME support for complex input methods (Asian languages)
- Alt code input for special characters (Unicode, OEM, Windows)

**Sources:** [scene/gui/text_edit.cpp:1619-2498](), [scene/gui/line_edit.cpp:373-1035]()

### Context Menu System

Both `TextEdit` and `LineEdit` provide customizable context menus:

| Menu Item | ID | Action |
|-----------|-----|--------|
| Cut | `MENU_CUT` | Cut selected text |
| Copy | `MENU_COPY` | Copy selected text |
| Paste | `MENU_PASTE` | Paste clipboard |
| Select All | `MENU_SELECT_ALL` | Select all text |
| Undo | `MENU_UNDO` | Undo last operation |
| Redo | `MENU_REDO` | Redo last undone operation |

The menu can be accessed via `get_menu()` and customized by adding/removing items.

**Sources:** [scene/gui/text_edit.h:80-114](), [scene/gui/text_edit.cpp:2499-2717](), [scene/gui/line_edit.h:40-73]()

## Usage Patterns

### TextEdit Configuration

```
TextEdit initialization:
1. Create TextEdit instance
2. Configure basic properties (editable, wrap_mode)
3. Set syntax_highlighter if needed
4. Add gutters if needed
5. Connect to signals (text_changed, caret_changed)
```

### CodeEdit for Script Editing

```
CodeEdit setup for code editing:
1. Create CodeEdit instance
2. Enable code_completion_enabled
3. Enable line_folding_enabled
4. Set auto_indent_enabled
5. Configure delimiters (strings, comments)
6. Set up breakpoint/bookmark signals
7. Implement _request_code_completion() for custom completion
```

**Sources:** [scene/gui/text_edit.h:773-892](), [scene/gui/code_edit.h:241-457]()43:T5c20,# Text Shaping System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/extension/gdextension_special_compat_hashes.cpp](core/extension/gdextension_special_compat_hashes.cpp)
- [core/extension/gdextension_special_compat_hashes.h](core/extension/gdextension_special_compat_hashes.h)
- [doc/classes/Label.xml](doc/classes/Label.xml)
- [doc/classes/LabelSettings.xml](doc/classes/LabelSettings.xml)
- [doc/classes/RichTextLabel.xml](doc/classes/RichTextLabel.xml)
- [doc/classes/TextLine.xml](doc/classes/TextLine.xml)
- [doc/classes/TextParagraph.xml](doc/classes/TextParagraph.xml)
- [editor/editor_log.cpp](editor/editor_log.cpp)
- [editor/editor_log.h](editor/editor_log.h)
- [scene/gui/label.cpp](scene/gui/label.cpp)
- [scene/gui/label.h](scene/gui/label.h)
- [scene/gui/rich_text_label.compat.inc](scene/gui/rich_text_label.compat.inc)
- [scene/gui/rich_text_label.cpp](scene/gui/rich_text_label.cpp)
- [scene/gui/rich_text_label.h](scene/gui/rich_text_label.h)
- [scene/resources/label_settings.cpp](scene/resources/label_settings.cpp)
- [scene/resources/label_settings.h](scene/resources/label_settings.h)
- [scene/resources/text_line.cpp](scene/resources/text_line.cpp)
- [scene/resources/text_line.h](scene/resources/text_line.h)
- [scene/resources/text_paragraph.cpp](scene/resources/text_paragraph.cpp)
- [scene/resources/text_paragraph.h](scene/resources/text_paragraph.h)

</details>



## Purpose and Scope

The Text Shaping System provides the core infrastructure for converting raw Unicode text into positioned glyphs ready for rendering. This system handles complex text layout requirements including bidirectional text (BiDi), line breaking, justification, and tab alignment. It serves as the foundation for all text display in GUI controls.

This document covers the `TextParagraph` and `TextLine` classes, which provide high-level abstractions over the `TextServer` API. For information about specific GUI controls that use these classes, see [TextEdit & CodeEdit](#10.1), [RichTextLabel](#10.3), and [Label & LineEdit](#10.4).

---

## System Architecture

The text shaping system is organized in three layers: the low-level `TextServer` API, the mid-level shaping classes (`TextParagraph` and `TextLine`), and the high-level GUI controls that consume them.

```mermaid
graph TB
    subgraph "GUI Controls Layer"
        Label["Label"]
        RichTextLabel["RichTextLabel"]
        TextEdit["TextEdit/CodeEdit"]
        LineEdit["LineEdit"]
    end
    
    subgraph "Text Shaping Layer"
        TextParagraph["TextParagraph<br/>(RefCounted)"]
        TextLine["TextLine<br/>(RefCounted)"]
    end
    
    subgraph "TextServer Layer"
        TS["TextServer Singleton (TS)<br/>shaped_text_* methods"]
        RID_Pool["RID Pool<br/>(Shaped Text Buffers)"]
    end
    
    subgraph "Rendering Layer"
        Font["Font Resources"]
        Canvas["Canvas Rendering"]
    end
    
    Label -->|uses multiple| TextParagraph
    RichTextLabel -->|uses| TextParagraph
    RichTextLabel -->|uses| TextLine
    TextEdit -->|uses| TextParagraph
    LineEdit -->|uses| TextLine
    
    TextParagraph -->|"create_shaped_text()<br/>add_string()<br/>get_line_breaks()"| TS
    TextLine -->|"create_shaped_text()<br/>add_string()"| TS
    
    TS --> RID_Pool
    TextParagraph --> Font
    TextLine --> Font
    
    TS --> Canvas
```

**Sources:** [scene/resources/text_paragraph.h:39-42], [scene/resources/text_line.h:38-40], [scene/gui/label.cpp:138-343], [scene/gui/rich_text_label.cpp:557-764]

---

## Core Classes

### TextParagraph

`TextParagraph` is a `RefCounted` resource that manages a paragraph of text with automatic line breaking. It maintains both a master text buffer and individual line buffers after shaping.

| Property | Type | Purpose |
|----------|------|---------|
| `rid` | RID | Master shaped text buffer in TextServer |
| `lines_rid` | LocalVector<RID> | Individual line buffers after breaking |
| `dropcap_rid` | RID | Shaped drop cap buffer |
| `width` | float | Target width for line breaking |
| `max_lines_visible` | int | Maximum visible lines (-1 = unlimited) |
| `line_spacing` | float | Additional spacing between lines |
| `brk_flags` | BitField<LineBreakFlag> | Line breaking behavior flags |
| `jst_flags` | BitField<JustificationFlag> | Text justification flags |
| `overrun_behavior` | OverrunBehavior | How to handle text overflow |

**Key Methods:**
- `add_string(text, font, font_size, language, meta)` - Adds text span with formatting
- `add_object(key, size, inline_align, length, baseline)` - Adds inline object (e.g., image)
- `set_dropcap(text, font, font_size, dropcap_margins, language)` - Configures drop cap
- `tab_align(tab_stops)` - Sets tab stop positions
- `_shape_lines()` - Internal method that performs line breaking

**Sources:** [scene/resources/text_paragraph.h:39-168], [scene/resources/text_paragraph.cpp:155-347]

### TextLine

`TextLine` is a simpler `RefCounted` resource for managing a single line of text without line breaking. It's used for single-line inputs and labels.

| Property | Type | Purpose |
|----------|------|---------|
| `rid` | RID | Shaped text buffer in TextServer |
| `width` | float | Target width (for alignment/overrun) |
| `flags` | BitField<JustificationFlag> | Justification flags |
| `overrun_behavior` | OverrunBehavior | Text overflow handling |
| `alignment` | HorizontalAlignment | Horizontal alignment |

**Key Methods:**
- `add_string(text, font, font_size, language, meta)` - Adds text span
- `add_object(key, size, inline_align, length, baseline)` - Adds inline object
- `tab_align(tab_stops)` - Sets tab stops
- `get_size()` - Returns measured size

**Sources:** [scene/resources/text_line.h:38-135], [scene/resources/text_line.cpp:34-424]

---

## Text Shaping Process

The text shaping process transforms raw Unicode text into a collection of positioned glyphs ready for rendering.

```mermaid
flowchart TD
    Start["Raw Unicode Text + Font"] --> CreateRID["Create RID via<br/>TS->create_shaped_text()"]
    CreateRID --> AddString["Add text spans via<br/>TS->shaped_text_add_string()<br/>(font, size, language)"]
    AddString --> AddObjects["Add inline objects via<br/>TS->shaped_text_add_object()<br/>(images, etc)"]
    AddObjects --> SetBiDi["Apply BiDi overrides via<br/>TS->shaped_text_set_bidi_override()"]
    
    SetBiDi --> CheckMultiLine{Multi-line?}
    
    CheckMultiLine -->|Yes: TextParagraph| GetBreaks["Get line breaks via<br/>TS->shaped_text_get_line_breaks()<br/>(width, break_flags)"]
    GetBreaks --> CreateLines["Create line RIDs via<br/>TS->shaped_text_substr()<br/>for each break"]
    CreateLines --> TabAlign["Apply tab alignment via<br/>TS->shaped_text_tab_align()"]
    
    CheckMultiLine -->|No: TextLine| TabAlign
    
    TabAlign --> Justify{Justify?}
    Justify -->|Yes| FitWidth["Fit to width via<br/>TS->shaped_text_fit_to_width()"]
    Justify -->|No| CheckOverrun
    
    FitWidth --> CheckOverrun{Overrun?}
    CheckOverrun -->|Yes| TrimOverrun["Trim/ellipsis via<br/>TS->shaped_text_overrun_trim_to_width()"]
    CheckOverrun -->|No| Ready
    TrimOverrun --> Ready["Glyphs Ready"]
    
    Ready --> Draw["Draw via<br/>TS->shaped_text_draw()"]
```

**Sources:** [scene/resources/text_paragraph.cpp:155-347], [scene/resources/text_line.cpp:191-289], [scene/gui/label.cpp:138-343]

---

## TextParagraph Line Breaking

`TextParagraph` implements sophisticated line breaking that supports drop caps and flowing text around them.

```mermaid
flowchart TD
    Start["TextParagraph with text"] --> CheckDirty{lines_dirty?}
    CheckDirty -->|No| Done["Use cached lines"]
    CheckDirty -->|Yes| ClearLines["Clear existing line RIDs"]
    
    ClearLines --> CheckDropcap{Has dropcap?}
    
    CheckDropcap -->|Yes| CalcDropcap["Calculate dropcap dimensions<br/>h_offset = dropcap width<br/>v_offset = dropcap height"]
    CalcDropcap --> FlowAround["Get line breaks with reduced width<br/>TS->shaped_text_get_line_breaks()<br/>(width - h_offset, brk_flags)"]
    FlowAround --> CreateFlowLines["Create line RIDs for dropcap lines<br/>until v_offset consumed"]
    CreateFlowLines --> CalcRemaining["Calculate remaining text start"]
    
    CheckDropcap -->|No| CalcRemaining
    
    CalcRemaining --> BreakRemaining["Get line breaks for remaining text<br/>TS->shaped_text_get_line_breaks()<br/>(width, start, brk_flags)"]
    BreakRemaining --> CreateRemaining["Create line RIDs via<br/>TS->shaped_text_substr()"]
    
    CreateRemaining --> ApplyJust{Justification?}
    ApplyJust -->|Yes| JustifyLines["Fit lines to width<br/>TS->shaped_text_fit_to_width()"]
    ApplyJust -->|No| ApplyOverrun
    
    JustifyLines --> ApplyOverrun{Overrun behavior?}
    ApplyOverrun -->|Trim/Ellipsis| TrimLines["Trim excess lines<br/>TS->shaped_text_overrun_trim_to_width()"]
    ApplyOverrun -->|None| MarkClean
    
    TrimLines --> MarkClean["lines_dirty = false"]
    MarkClean --> Done
```

**Sources:** [scene/resources/text_paragraph.cpp:155-280]

---

## BiDi and Text Direction

The text shaping system fully supports bidirectional text (BiDi) for mixing left-to-right and right-to-left scripts.

### Direction Handling

| Direction Setting | Behavior |
|-------------------|----------|
| `DIRECTION_AUTO` | Infer from text content (default) |
| `DIRECTION_LTR` | Force left-to-right |
| `DIRECTION_RTL` | Force right-to-left |

Both `TextParagraph` and `TextLine` expose:
- `set_direction(direction)` - Sets base direction
- `get_inferred_direction()` - Returns detected direction after shaping
- `set_bidi_override(override)` - Array of BiDi control characters/ranges

### BiDi Override Format

BiDi overrides allow fine-grained control over text direction:

```
Array format: [start_pos, end_pos, direction, ...]
- start_pos: Character index where override begins
- end_pos: Character index where override ends  
- direction: TextServer direction constant
```

**Sources:** [scene/resources/text_paragraph.h:86-90], [scene/resources/text_line.h:69-73], [scene/gui/label.cpp:178-195]

---

## Usage in Label

The `Label` control uses multiple `TextParagraph` instances to support paragraph separation.

```mermaid
graph TB
    Label["Label Control"] --> ParagraphSep["paragraph_separator<br/>(default: \\n)"]
    Label --> Paragraphs["Vector&lt;Paragraph&gt; paragraphs"]
    
    Paragraphs --> Para1["Paragraph 0"]
    Paragraphs --> Para2["Paragraph 1"]
    Paragraphs --> ParaN["Paragraph N"]
    
    Para1 --> TextRID1["text_rid: RID<br/>(master buffer)"]
    Para1 --> LinesRID1["lines_rid: Vector&lt;RID&gt;<br/>(broken lines)"]
    Para1 --> Props1["start, text, dirty, lines_dirty"]
    
    Para2 --> TextRID2["text_rid: RID"]
    Para2 --> LinesRID2["lines_rid: Vector&lt;RID&gt;"]
    
    ParaN --> TextRIDN["text_rid: RID"]
    ParaN --> LinesRIDN["lines_rid: Vector&lt;RID&gt;"]
    
    TextRID1 -.->|"TS->shaped_text_add_string()"| TS["TextServer"]
    LinesRID1 -.->|"TS->shaped_text_substr()"| TS
```

### Label Shaping Flow

The shaping process in `Label::_shape()` [scene/gui/label.cpp:138-343]:

1. **Text Splitting**: Split text by `paragraph_separator` (default `\n`)
2. **Per-Paragraph Processing**:
   - Create shaped text RID via `TS->create_shaped_text()`
   - Set direction (auto, LTR, RTL) via `TS->shaped_text_set_direction()`
   - Add string via `TS->shaped_text_add_string()` with font and size
   - Apply BiDi overrides via `TS->shaped_text_set_bidi_override()`
   - Apply tab alignment if `tab_stops` defined
3. **Line Breaking**: Get breaks via `TS->shaped_text_get_line_breaks(width, brk_flags)`
4. **Create Line RIDs**: For each break, create substring via `TS->shaped_text_substr()`
5. **Justification**: If `HORIZONTAL_ALIGNMENT_FILL`, fit via `TS->shaped_text_fit_to_width()`
6. **Overrun Handling**: Apply ellipsis via `TS->shaped_text_overrun_trim_to_width()`

**Sources:** [scene/gui/label.h:53-68], [scene/gui/label.cpp:138-343]

---

## Usage in RichTextLabel

`RichTextLabel` uses `TextParagraph` with additional features for rich text formatting.

```mermaid
graph TB
    RTL["RichTextLabel"] --> ItemFrame["ItemFrame<br/>(main or table cell)"]
    ItemFrame --> Lines["LocalVector&lt;Line&gt; lines"]
    
    Lines --> Line1["Line 0"]
    Lines --> Line2["Line 1"]
    Lines --> LineN["Line N"]
    
    Line1 --> From["from: Item*<br/>(start item)"]
    Line1 --> TextBuf["text_buf: Ref&lt;TextParagraph&gt;<br/>(main buffer)"]
    Line1 --> TextBufDisp["text_buf_disp: Ref&lt;TextParagraph&gt;<br/>(visible chars display)"]
    Line1 --> Prefix["text_prefix: Ref&lt;TextLine&gt;<br/>(list bullets/numbers)"]
    
    TextBuf --> Content["Contains text spans<br/>from Item tags"]
    TextBufDisp --> Trimmed["Trimmed to visible_characters<br/>if enabled"]
    Prefix --> ListPrefix["List prefix<br/>(â€¢, 1., I., etc)"]
```

### RichTextLabel Shaping Flow

The shaping process in `RichTextLabel::_shape_line()` [scene/gui/rich_text_label.cpp:557-764]:

1. **Clear Previous State**:
   - Clear `text_buf` via `text_buf->clear()`
   - Set break flags, justification flags, direction, alignment, width

2. **Process Item Tree**:
   - Iterate through items from `line.from` to next line start
   - For each `ITEM_TEXT`: call `text_buf->add_string()` with font/size
   - For each `ITEM_IMAGE`: call `text_buf->add_object()` with size
   - For each `ITEM_TABLE`: recursively shape table cell frames

3. **Apply BiDi**: Call `text_buf->set_bidi_override()` with structured text parser results

4. **Visible Characters**: If `visible_chars_behavior == VC_CHARS_BEFORE_SHAPING`, create duplicate display buffer with trimmed text

5. **List Prefixes**: For list items, create `TextLine` prefix with bullet or number, shape separately

**Sources:** [scene/gui/rich_text_label.h:160-198], [scene/gui/rich_text_label.cpp:557-764], [scene/gui/rich_text_label.cpp:271-373]

---

## Key Configuration Flags

### LineBreakFlag (Text Breaking Behavior)

| Flag | Purpose |
|------|---------|
| `BREAK_MANDATORY` | Break at mandatory positions (newlines) |
| `BREAK_WORD_BOUND` | Break at word boundaries (spaces) |
| `BREAK_GRAPHEME_BOUND` | Break at any character (arbitrary) |
| `BREAK_ADAPTIVE` | Smart word breaking (hyphenation-aware) |
| `BREAK_TRIM_START_EDGE_SPACES` | Trim spaces at line start |
| `BREAK_TRIM_END_EDGE_SPACES` | Trim spaces at line end |

**Common combinations:**
- `AUTOWRAP_OFF`: `BREAK_MANDATORY` only
- `AUTOWRAP_WORD`: `BREAK_WORD_BOUND | BREAK_MANDATORY`
- `AUTOWRAP_WORD_SMART`: `BREAK_WORD_BOUND | BREAK_ADAPTIVE | BREAK_MANDATORY`
- `AUTOWRAP_ARBITRARY`: `BREAK_GRAPHEME_BOUND | BREAK_MANDATORY`

**Sources:** [scene/resources/text_paragraph.h:57], [scene/gui/label.cpp:209-223], [scene/gui/rich_text_label.cpp:565-579]

### JustificationFlag (Text Justification Behavior)

| Flag | Purpose |
|------|---------|
| `JUSTIFICATION_KASHIDA` | Use Arabic kashida for justification |
| `JUSTIFICATION_WORD_BOUND` | Justify by adjusting word spacing |
| `JUSTIFICATION_TRIM_EDGE_SPACES` | Trim edge spaces after justification |
| `JUSTIFICATION_AFTER_LAST_TAB` | Only justify after last tab stop |
| `JUSTIFICATION_CONSTRAIN_ELLIPSIS` | Keep ellipsis within width |
| `JUSTIFICATION_SKIP_LAST_LINE` | Don't justify last line |
| `JUSTIFICATION_SKIP_LAST_LINE_WITH_VISIBLE_CHARS` | Skip last line with visible content |
| `JUSTIFICATION_DO_NOT_SKIP_SINGLE_LINE` | Justify even single-line paragraphs |

**Default in Label/RichTextLabel:**
```
JUSTIFICATION_WORD_BOUND | 
JUSTIFICATION_KASHIDA | 
JUSTIFICATION_SKIP_LAST_LINE | 
JUSTIFICATION_DO_NOT_SKIP_SINGLE_LINE
```

**Sources:** [scene/resources/text_paragraph.h:58], [scene/gui/label.h:46], [scene/gui/rich_text_label.h:374]

### OverrunBehavior (Text Overflow Handling)

| Behavior | Description |
|----------|-------------|
| `OVERRUN_NO_TRIMMING` | No trimming, text extends beyond bounds |
| `OVERRUN_TRIM_CHAR` | Trim at character boundary |
| `OVERRUN_TRIM_WORD` | Trim at word boundary |
| `OVERRUN_TRIM_ELLIPSIS` | Add ellipsis if >= 6 chars available |
| `OVERRUN_TRIM_WORD_ELLIPSIS` | Word boundary ellipsis if >= 6 chars |
| `OVERRUN_TRIM_ELLIPSIS_ALWAYS` | Always add ellipsis |
| `OVERRUN_TRIM_WORD_ELLIPSIS_ALWAYS` | Always add word boundary ellipsis |

**Sources:** [scene/resources/text_paragraph.h:60], [scene/gui/label.h:49]

---

## Tab Alignment

Both `TextParagraph` and `TextLine` support tab stop alignment via the `tab_align()` method.

**Tab Stop Formats:**
1. **Explicit stops**: `PackedFloat32Array` of pixel positions
2. **Uniform spacing**: Single value in array = repeated interval

**Example from Label** [scene/gui/label.cpp:196-198]:
```
if (!tab_stops.is_empty()) {
    TS->shaped_text_tab_align(para.text_rid, tab_stops);
}
```

**Example from RichTextLabel** [scene/gui/rich_text_label.cpp:475-482]:
```
PackedFloat32Array tab_stops = _find_tab_stops(l.from);
if (!tab_stops.is_empty()) {
    l.text_buf->tab_align(tab_stops);
} else if (tab_size > 0) {
    Vector<float> tabs;
    tabs.push_back(MAX(1, tab_size * font->get_char_size(' ', font_size).width));
    l.text_buf->tab_align(tabs);
}
```

**Sources:** [scene/resources/text_paragraph.cpp:174-176], [scene/gui/label.cpp:196-198], [scene/gui/rich_text_label.cpp:475-482]

---

## Dropcap Support

`TextParagraph` provides built-in support for drop caps (large first letters).

### Dropcap Configuration

**Method signature:**
```
set_dropcap(text, font, font_size, dropcap_margins, language)
```

**Parameters:**
- `text`: The dropcap character(s)
- `font`: Font for the dropcap
- `font_size`: Size of dropcap
- `dropcap_margins`: `Rect2` defining margins around dropcap
- `language`: Language code for shaping

**Flow around dropcap** [scene/resources/text_paragraph.cpp:178-210]:

1. Calculate dropcap dimensions (width + height + margins)
2. Break first N lines with reduced width (flowing around dropcap)
3. Continue breaking remaining lines at full width
4. Track number of lines affected by dropcap via `dropcap_lines`

**Usage in RichTextLabel** [scene/gui/rich_text_label.cpp:616-624]:
```
ItemDropcap *dc = static_cast<ItemDropcap *>(it);
l.text_buf->set_dropcap(dc->text, dc->font, dc->font_size, dc->dropcap_margins);
l.dc_item = dc;
l.dc_color = dc->color;
l.dc_ol_size = dc->ol_size;
l.dc_ol_color = dc->ol_color;
```

**Sources:** [scene/resources/text_paragraph.h:44-46], [scene/resources/text_paragraph.cpp:178-210], [scene/gui/rich_text_label.cpp:616-624]

---

## Inline Objects

Both `TextParagraph` and `TextLine` support embedding inline objects (typically images) within text.

### Adding Inline Objects

**Method signature:**
```
add_object(key, size, inline_align, length, baseline)
```

**Parameters:**
- `key`: Variant identifier for the object (any type)
- `size`: `Vector2` size of the object
- `inline_align`: `InlineAlignment` enum (CENTER, TOP, BOTTOM, etc.)
- `length`: Number of object replacement characters (default 1)
- `baseline`: Vertical baseline offset (default 0.0)

**Inline object representation:**
- Objects are represented as U+FFFC (object replacement character) in the shaped text
- TextServer reserves space for the object during shaping
- Rendering is handled by the control (not TextServer)

**Example from RichTextLabel** [scene/gui/rich_text_label.cpp:679-689]:
```
case ITEM_IMAGE: {
    ItemImage *img = static_cast<ItemImage *>(it);
    Size2 img_size = img->size;
    if (img->width_in_percent || img->height_in_percent) {
        img_size = _get_image_size(img->image, ...);
    }
    l.text_buf->add_object(it->rid, img_size, img->inline_align, 1);
    txt += String::chr(0xfffc);
    l.char_count++;
    remaining_characters--;
} break;
```

**Sources:** [scene/resources/text_paragraph.cpp:376-427], [scene/resources/text_line.cpp:229-277], [scene/gui/rich_text_label.cpp:679-689]

---

## Drawing and Rendering

Both `TextParagraph` and `TextLine` provide methods for drawing shaped text to a canvas.

### TextParagraph Drawing Methods

| Method | Purpose |
|--------|---------|
| `draw(canvas, pos, color, dc_color, oversampling)` | Draw all lines |
| `draw_outline(canvas, pos, outline_size, color, dc_color, oversampling)` | Draw outline of all lines |
| `draw_line(canvas, pos, line, color, oversampling)` | Draw single line |
| `draw_line_outline(canvas, pos, line, outline_size, color, oversampling)` | Draw outline of single line |
| `draw_dropcap(canvas, pos, color, oversampling)` | Draw dropcap only |
| `draw_dropcap_outline(canvas, pos, outline_size, color, oversampling)` | Draw dropcap outline |

### TextLine Drawing Methods

| Method | Purpose |
|--------|---------|
| `draw(canvas, pos, color, oversampling)` | Draw the line |
| `draw_outline(canvas, pos, outline_size, color, oversampling)` | Draw outline |

**Drawing flow:**
1. Call appropriate draw method with canvas RID and position
2. Method delegates to `TS->shaped_text_draw()` or `TS->shaped_text_draw_outline()`
3. TextServer renders glyphs via Font resources
4. Oversampling parameter controls font rendering quality (0.0 = use viewport default)

**Sources:** [scene/resources/text_paragraph.cpp:528-604], [scene/resources/text_line.cpp:338-371], [doc/classes/TextParagraph.xml:46-150], [doc/classes/TextLine.xml:40-76]

---

## Thread Safety

Both `TextParagraph` and `TextLine` are marked as `_THREAD_SAFE_CLASS_`, indicating they can be safely accessed from multiple threads.

**Thread safety mechanisms:**
- Mutex protection in TextServer for RID operations
- Atomic operations where needed
- Immutable operations after shaping (reading size, line count, etc.)

**Typical usage pattern:**
1. Create and configure `TextParagraph`/`TextLine` on any thread
2. Call shaping methods (creates RIDs in TextServer)
3. Query results (size, line count, etc.) from any thread
4. Drawing must happen on the rendering thread with valid canvas RID

**Sources:** [scene/resources/text_paragraph.h:41], [scene/resources/text_line.h:39]

---

## Performance Considerations

### Caching and Dirty Flags

The system uses dirty flags to avoid unnecessary reshaping:

**TextParagraph:**
- `lines_dirty`: Set when line breaking needed
- Reshaping only occurs in `_shape_lines()` when dirty

**Label:**
- `dirty`: Global dirty flag
- `font_dirty`: Font/size changed
- `text_dirty`: Text content changed
- Per-paragraph `dirty` and `lines_dirty` flags

**Performance tips:**
1. Avoid changing text/width frequently (triggers reshaping)
2. Use `visible_characters` for animations (doesn't trigger full reshape)
3. Cache `TextParagraph`/`TextLine` instances when possible
4. For static text, shape once and reuse

**Sources:** [scene/resources/text_paragraph.cpp:155-167], [scene/gui/label.h:62-64], [scene/gui/label.cpp:419-430]

### RID Management

RIDs (Resource IDs) represent shaped text buffers in TextServer. Proper management is critical:

**Creation:**
- `TS->create_shaped_text()` allocates a new RID
- Store RID in class member (e.g., `rid`, `lines_rid`, `text_rid`)

**Cleanup:**
- `TS->free_rid(rid)` deallocates the buffer
- Must free all RIDs before destruction
- `TextParagraph` and `TextLine` destructors handle cleanup

**Example from TextParagraph** [scene/resources/text_paragraph.cpp:155-172]:
```cpp
if (lines_dirty) {
    // Free old line RIDs
    for (const RID &line_rid : lines_rid) {
        TS->free_rid(line_rid);
    }
    lines_rid.clear();
    
    // Create new line RIDs...
}
```

**Sources:** [scene/resources/text_paragraph.cpp:155-172], [scene/gui/label.cpp:144-151]44:T566a,# RichTextLabel

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/extension/gdextension_special_compat_hashes.cpp](core/extension/gdextension_special_compat_hashes.cpp)
- [core/extension/gdextension_special_compat_hashes.h](core/extension/gdextension_special_compat_hashes.h)
- [doc/classes/Label.xml](doc/classes/Label.xml)
- [doc/classes/LabelSettings.xml](doc/classes/LabelSettings.xml)
- [doc/classes/RichTextLabel.xml](doc/classes/RichTextLabel.xml)
- [doc/classes/TextLine.xml](doc/classes/TextLine.xml)
- [doc/classes/TextParagraph.xml](doc/classes/TextParagraph.xml)
- [editor/editor_log.cpp](editor/editor_log.cpp)
- [editor/editor_log.h](editor/editor_log.h)
- [scene/gui/label.cpp](scene/gui/label.cpp)
- [scene/gui/label.h](scene/gui/label.h)
- [scene/gui/rich_text_label.compat.inc](scene/gui/rich_text_label.compat.inc)
- [scene/gui/rich_text_label.cpp](scene/gui/rich_text_label.cpp)
- [scene/gui/rich_text_label.h](scene/gui/rich_text_label.h)
- [scene/resources/label_settings.cpp](scene/resources/label_settings.cpp)
- [scene/resources/label_settings.h](scene/resources/label_settings.h)
- [scene/resources/text_line.cpp](scene/resources/text_line.cpp)
- [scene/resources/text_line.h](scene/resources/text_line.h)
- [scene/resources/text_paragraph.cpp](scene/resources/text_paragraph.cpp)
- [scene/resources/text_paragraph.h](scene/resources/text_paragraph.h)

</details>



**RichTextLabel** is a Control node that displays text with advanced formatting capabilities including BBCode markup, embedded images, tables, animated effects, and custom styling. Unlike Label which provides simple plain text display (see [Label & LineEdit](#10.4)), RichTextLabel manages text as an internal hierarchical tag stack and supports complex layout features.

This document covers the RichTextLabel architecture, the internal Item system, text processing pipeline, BBCode parsing, and integration with the text shaping system (see [Text Shaping System](#10.2) for details on TextServer integration).

## Core Architecture

### Class Hierarchy

```mermaid
graph TB
    Control["Control"]
    RichTextLabel["RichTextLabel"]
    Item["Item<br/>(base)"]
    ItemFrame["ItemFrame"]
    ItemText["ItemText"]
    ItemImage["ItemImage"]
    ItemTable["ItemTable"]
    ItemFX["ItemFX"]
    
    Control --> RichTextLabel
    RichTextLabel --> Item
    Item --> ItemFrame
    Item --> ItemText
    Item --> ItemImage
    Item --> ItemTable
    Item --> ItemFX
    
    style RichTextLabel fill:#e1f5ff
```

**Sources:** [scene/gui/rich_text_label.h:47-48](), [scene/gui/rich_text_label.h:200-226]()

### Main Data Structure

RichTextLabel maintains a hierarchical item structure where each Item represents a formatting tag or content element:

```mermaid
graph TB
    main["main: ItemFrame<br/>(root)"]
    current["current: Item*<br/>(current position)"]
    current_frame["current_frame: ItemFrame*<br/>(current container)"]
    
    line1["Line (paragraph)<br/>from: Item*"]
    line2["Line (paragraph)<br/>from: Item*"]
    
    text_buf["text_buf: TextParagraph<br/>(shaped text)"]
    text_prefix["text_prefix: TextLine<br/>(list prefix)"]
    
    main --> line1
    main --> line2
    line1 --> text_buf
    line1 --> text_prefix
    
    RichTextLabel["RichTextLabel"] --> main
    RichTextLabel --> current
    RichTextLabel --> current_frame
    
    style RichTextLabel fill:#e1f5ff
    style main fill:#fff4e1
    style line1 fill:#f0e1ff
    style line2 fill:#f0e1ff
```

**Sources:** [scene/gui/rich_text_label.h:538-541](), [scene/gui/rich_text_label.h:160-198]()

### Item Type Hierarchy

RichTextLabel uses an extensive set of Item types to represent different formatting elements:

| Item Type | Purpose | Key Data |
|-----------|---------|----------|
| `ITEM_FRAME` | Container for lines and nested items | `lines`, `padding`, `cell` flag |
| `ITEM_TEXT` | Plain text content | `text` string |
| `ITEM_IMAGE` | Embedded image | `image`, `size`, `inline_align` |
| `ITEM_NEWLINE` | Explicit line break | None |
| `ITEM_FONT` | Font override | `font`, `font_size`, `def_font` |
| `ITEM_FONT_SIZE` | Font size override | `font_size` |
| `ITEM_COLOR` | Text color | `color` |
| `ITEM_OUTLINE_SIZE` | Outline thickness | `outline_size` |
| `ITEM_OUTLINE_COLOR` | Outline color | `color` |
| `ITEM_UNDERLINE` | Underline decoration | `color` |
| `ITEM_STRIKETHROUGH` | Strikethrough decoration | `color` |
| `ITEM_PARAGRAPH` | Paragraph settings | `alignment`, `direction`, `jst_flags` |
| `ITEM_INDENT` | Indentation level | `level` |
| `ITEM_LIST` | List marker | `list_type`, `bullet`, `max_width` |
| `ITEM_TABLE` | Table structure | `columns`, `rows`, `total_width` |
| `ITEM_DROPCAP` | Drop cap letter | `text`, `font`, `dropcap_margins` |
| `ITEM_META` | Clickable metadata | `meta`, `underline`, `tooltip` |
| `ITEM_HINT` | Tooltip text | `description` |

**Sources:** [scene/gui/rich_text_label.h:74-105](), [scene/gui/rich_text_label.h:228-513]()

### Line (Paragraph) Structure

Each `Line` represents a paragraph and contains:

```mermaid
graph LR
    Line["Line"]
    from["from: Item*<br/>(first item)"]
    text_buf["text_buf: TextParagraph<br/>(main content)"]
    text_buf_disp["text_buf_disp: TextParagraph<br/>(visible char display)"]
    text_prefix["text_prefix: TextLine<br/>(list prefix)"]
    
    Line --> from
    Line --> text_buf
    Line --> text_buf_disp
    Line --> text_prefix
```

**Sources:** [scene/gui/rich_text_label.h:160-198]()

## Text Processing Pipeline

### Overview

```mermaid
graph TB
    input["Input:<br/>BBCode or<br/>push_* calls"]
    parse["BBCode Parsing<br/>_parse_bbcode()"]
    stack["Tag Stack<br/>Construction"]
    shape["Line Shaping<br/>_shape_line()"]
    resize["Line Resizing<br/>_resize_line()"]
    font["Font Update<br/>_update_line_font()"]
    draw["Drawing<br/>_draw_line()"]
    
    input --> parse
    parse --> stack
    stack --> shape
    shape --> resize
    resize --> font
    font --> draw
    
    style input fill:#e1f5ff
    style draw fill:#f0e1ff
```

**Sources:** [scene/gui/rich_text_label.cpp:557-764](), [scene/gui/rich_text_label.cpp:463-555](), [scene/gui/rich_text_label.cpp:375-461](), [scene/gui/rich_text_label.cpp:922-1382]()

### Line Shaping Process

The `_shape_line()` function [scene/gui/rich_text_label.cpp:557-764]() processes a single paragraph:

1. **Initialize TextParagraph**: Clear and configure text buffer with autowrap flags, justification flags, alignment, and direction
2. **Add List Prefixes**: Call `_add_list_prefixes()` to add numbered/bulleted list markers
3. **Set Margins**: Calculate indent from paragraph settings and list prefix width
4. **Process Items**: Iterate through items in the line:
   - `ITEM_DROPCAP`: Set dropcap on text buffer
   - `ITEM_NEWLINE`: Add zero-width space
   - `ITEM_TEXT`: Add text string with font and language
   - `ITEM_IMAGE`: Add embedded object with size
   - `ITEM_TABLE`: Recursively shape table cell contents
5. **Apply BiDi Override**: Set bidirectional text override
6. **Tab Alignment**: Apply tab stops if configured

**Sources:** [scene/gui/rich_text_label.cpp:557-764]()

### Table Layout Algorithm

Tables use a complex sizing algorithm in `_set_table_size()` [scene/gui/rich_text_label.cpp:766-920]():

```mermaid
graph TB
    start["Start with available width"]
    compute_min["Compute min_width<br/>and max_width<br/>for each column"]
    assign_min["Assign min_width<br/>to all columns"]
    calc_ratio["Calculate total<br/>expand_ratio"]
    distribute["Distribute remaining width<br/>by expand_ratio"]
    shrink["Shrink columns<br/>exceeding max_width"]
    grow["Grow other columns<br/>to fill space"]
    done["Compute row heights"]
    
    start --> compute_min
    compute_min --> assign_min
    assign_min --> calc_ratio
    calc_ratio --> distribute
    distribute --> shrink
    shrink --> grow
    grow --> done
```

**Sources:** [scene/gui/rich_text_label.cpp:766-920]()

### Threading Support

For large documents, RichTextLabel can process text in a background thread:

```mermaid
graph TB
    main["Main Thread"]
    thread["Worker Thread<br/>_thread_function()"]
    
    main -->|"Start task"| thread
    thread -->|"_validate_line_caches()"| validate["Validate and shape lines"]
    validate -->|"_process_line_caches()"| process["Process visible lines"]
    process -->|"Update atomic flags"| status["loaded, updating,<br/>validating flags"]
    status -->|"Notify main thread"| main
    
    style thread fill:#e1ffe1
```

The threading system uses atomic flags [scene/gui/rich_text_label.h:542-549]():
- `stop_thread`: Signal to stop background processing
- `updating`: Currently updating text
- `validating`: Currently validating line caches
- `loaded`: Progress percentage (0.0-1.0)
- `parsing_bbcode`: Currently parsing BBCode

**Sources:** [scene/gui/rich_text_label.cpp:2673-2685](), [scene/gui/rich_text_label.cpp:2687-2723]()

## BBCode System

### BBCode Parser Architecture

The BBCode parser processes markup text and converts it to Item stack operations:

```mermaid
graph TB
    input["BBCode Text"]
    tokenize["Tokenize tags<br/>[tag]...[/tag]"]
    validate["Validate tag syntax"]
    process["Process tag:<br/>push_* methods"]
    stack["Update tag_stack"]
    content["Add text content"]
    
    input --> tokenize
    tokenize --> validate
    validate --> process
    process --> stack
    stack --> content
    
    style input fill:#e1f5ff
    style stack fill:#fff4e1
```

**Sources:** [scene/gui/rich_text_label.cpp:2074-2627]()

### Common BBCode Tags

| BBCode Tag | Item Type | Example |
|------------|-----------|---------|
| `[b]...[/b]` | `ITEM_FONT` (bold) | `[b]Bold text[/b]` |
| `[i]...[/i]` | `ITEM_FONT` (italic) | `[i]Italic text[/i]` |
| `[color=...]...[/color]` | `ITEM_COLOR` | `[color=red]Red text[/color]` |
| `[font=...]...[/font]` | `ITEM_FONT` | `[font=res://font.ttf]Custom[/font]` |
| `[img]...[/img]` | `ITEM_IMAGE` | `[img]res://icon.png[/img]` |
| `[url=...]...[/url]` | `ITEM_META` | `[url=https://...]Link[/url]` |
| `[table=N]...[/table]` | `ITEM_TABLE` | `[table=2][cell]A[/cell][/table]` |
| `[center]...[/center]` | `ITEM_PARAGRAPH` | `[center]Centered[/center]` |
| `[ul]...[/ul]` | `ITEM_LIST` | `[ul]List item[/ul]` |

**Sources:** [scene/gui/rich_text_label.cpp:2074-2627]()

### Tag Stack Management

The `tag_stack` [scene/gui/rich_text_label.h:610]() tracks open tags for proper nesting:

```mermaid
graph LR
    parse["Parse [b][i]text[/i][/b]"]
    push_b["push_bold()<br/>tag_stack: ['b']"]
    push_i["push_italics()<br/>tag_stack: ['b', 'i']"]
    add["add_text('text')"]
    pop_i["pop()<br/>tag_stack: ['b']"]
    pop_b["pop()<br/>tag_stack: []"]
    
    parse --> push_b
    push_b --> push_i
    push_i --> add
    add --> pop_i
    pop_i --> pop_b
```

**Sources:** [scene/gui/rich_text_label.cpp:2074-2627]()

## Text Effects

### Built-in Effects

RichTextLabel includes several animated text effects derived from `ItemFX`:

```mermaid
graph TB
    ItemFX["ItemFX<br/>(base class)"]
    Shake["ItemShake<br/>Random offset"]
    Wave["ItemWave<br/>Sine wave motion"]
    Tornado["ItemTornado<br/>Circular motion"]
    Rainbow["ItemRainbow<br/>Color cycling"]
    Pulse["ItemPulse<br/>Alpha pulsing"]
    Fade["ItemFade<br/>Gradual fade"]
    CustomFX["ItemCustomFX<br/>User-defined"]
    
    ItemFX --> Shake
    ItemFX --> Wave
    ItemFX --> Tornado
    ItemFX --> Rainbow
    ItemFX --> Pulse
    ItemFX --> Fade
    ItemFX --> CustomFX
    
    style ItemFX fill:#e1f5ff
```

**Sources:** [scene/gui/rich_text_label.h:429-509]()

### Effect Update Cycle

Effects are updated in `_update_fx()` [scene/gui/rich_text_label.cpp:3564-3668]():

```mermaid
graph LR
    update["_update_fx()"]
    traverse["Traverse item tree"]
    check["Check ItemFX type"]
    compute["Compute effect<br/>based on elapsed_time"]
    apply["Apply to glyphs<br/>during rendering"]
    
    update --> traverse
    traverse --> check
    check --> compute
    compute --> apply
```

**Sources:** [scene/gui/rich_text_label.cpp:3564-3668]()

### Custom Effects

Custom effects use `RichTextEffect` resources with `CharFXTransform`:

```mermaid
graph TB
    RTE["RichTextEffect<br/>(resource)"]
    CFX["CharFXTransform<br/>(per-character data)"]
    process["_process_custom_fx()<br/>(virtual method)"]
    
    RTE --> CFX
    RTE --> process
    process -->|"Modify"| CFX
    CFX -->|"Contains"| props["elapsed_time<br/>visible<br/>outline<br/>color<br/>offset<br/>glyph_index<br/>font"]
```

**Sources:** [scene/gui/rich_text_label.h:502-509]()

## Drawing and Rendering

### Drawing Pipeline

```mermaid
graph TB
    notification["_notification()<br/>NOTIFICATION_DRAW"]
    update["_validate_line_caches()"]
    visible["Calculate visible rect"]
    loop["For each visible line"]
    draw["_draw_line()"]
    glyphs["Draw glyphs with<br/>effects and decorations"]
    
    notification --> update
    update --> visible
    visible --> loop
    loop --> draw
    draw --> glyphs
    
    style notification fill:#e1f5ff
    style glyphs fill:#f0e1ff
```

**Sources:** [scene/gui/rich_text_label.cpp:1540-1761]()

### Line Drawing Process

The `_draw_line()` function [scene/gui/rich_text_label.cpp:922-1382]() renders a single line:

1. **Draw Dropcap**: If present, draw dropcap outline and fill
2. **For Each Text Line**:
   - Compute horizontal offset based on alignment
   - Iterate through glyphs
   - Apply character visibility constraints
   - Draw shadows (if enabled)
   - Draw outlines (if enabled)
   - Draw main glyph
   - Apply text effects (shake, wave, etc.)
   - Draw decorations (underline, strikethrough)
3. **Draw Embedded Objects**: Images and tables

**Sources:** [scene/gui/rich_text_label.cpp:922-1382]()

### Visibility and Trimming

RichTextLabel supports several visibility modes via `visible_characters` and `visible_chars_behavior` [scene/gui/rich_text_label.h:659-661]():

| Behavior | Description |
|----------|-------------|
| `VC_CHARS_BEFORE_SHAPING` | Trim text before shaping (fastest) |
| `VC_CHARS_AFTER_SHAPING` | Trim after shaping (accurate) |
| `VC_GLYPHS_AUTO` | Trim glyphs based on layout direction |
| `VC_GLYPHS_LTR` | Trim glyphs left-to-right |
| `VC_GLYPHS_RTL` | Trim glyphs right-to-left |

**Sources:** [scene/gui/rich_text_label.cpp:922-1382]()

## Selection and Interaction

### Selection System

RichTextLabel maintains selection state in the `Selection` structure [scene/gui/rich_text_label.h:618-638]():

```mermaid
graph LR
    click["Click Position"]
    find["_find_click()"]
    set["Set click_frame,<br/>click_line, click_item,<br/>click_char"]
    drag["Mouse Drag"]
    update["Update from/to<br/>selection bounds"]
    render["Render selection<br/>highlight"]
    
    click --> find
    find --> set
    set --> drag
    drag --> update
    update --> render
```

**Sources:** [scene/gui/rich_text_label.h:618-638](), [scene/gui/rich_text_label.cpp:3669-3918]()

### Meta Link Interaction

Meta items (`ITEM_META`) support clickable links:

```mermaid
graph TB
    hover["Mouse Hover"]
    check["Check for meta item"]
    underline["Show meta_underline<br/>(if enabled)"]
    click["Mouse Click"]
    emit["Emit meta_clicked<br/>signal"]
    
    hover --> check
    check --> underline
    click --> emit
```

**Sources:** [scene/gui/rich_text_label.h:352-357](), [scene/gui/rich_text_label.cpp:3919-4088]()

## Integration with Text Shaping

### TextServer Integration

RichTextLabel relies heavily on TextServer for text shaping:

```mermaid
graph TB
    RTL["RichTextLabel"]
    TP["TextParagraph"]
    TL["TextLine<br/>(for prefixes)"]
    TS["TextServer"]
    
    RTL -->|"Uses"| TP
    RTL -->|"Uses"| TL
    TP -->|"Calls"| TS
    TL -->|"Calls"| TS
    
    TS -->|"Returns"| shaped["Shaped glyphs<br/>Line breaks<br/>BiDi order"]
    
    style RTL fill:#e1f5ff
    style TS fill:#f0e1ff
```

For detailed information on TextServer, TextParagraph, and TextLine, see [Text Shaping System](#10.2).

**Sources:** [scene/gui/rich_text_label.h:168-169](), [scene/gui/rich_text_label.cpp:557-764]()

### Font Resolution

Font lookup follows a hierarchy using `_find_font()` [scene/gui/rich_text_label.cpp:4668-4714]():

1. Check for `ITEM_FONT` with custom font
2. Check for font type override (bold, italic, bold_italic, mono)
3. Fall back to theme cache fonts
4. Use base font parameter

**Sources:** [scene/gui/rich_text_label.cpp:4668-4714]()

## List Support

### List Prefix Generation

Lists use `_add_list_prefixes()` to generate numbered/bulleted prefixes [scene/gui/rich_text_label.cpp:271-373]():

```mermaid
graph TB
    find["_find_list():<br/>Find enclosing lists"]
    index["Get list index"]
    type["Check list_type"]
    numbers["LIST_NUMBERS:<br/>Generate number"]
    letters["LIST_LETTERS:<br/>Generate letter"]
    roman["LIST_ROMAN:<br/>Generate roman numeral"]
    dots["LIST_DOTS:<br/>Use bullet"]
    shape["Shape prefix<br/>in TextLine"]
    measure["Store max_width"]
    
    find --> index
    index --> type
    type --> numbers
    type --> letters
    type --> roman
    type --> dots
    numbers --> shape
    letters --> shape
    roman --> shape
    dots --> shape
    shape --> measure
```

**Sources:** [scene/gui/rich_text_label.cpp:271-373]()

### List Types

| List Type | Format | Example |
|-----------|--------|---------|
| `LIST_NUMBERS` | Numeric | 1. 2. 3. |
| `LIST_LETTERS` | Alphabetic | a. b. c. |
| `LIST_ROMAN` | Roman numerals | i. ii. iii. |
| `LIST_DOTS` | Bullet character | â€¢ â€¢ â€¢ |

**Sources:** [scene/gui/rich_text_label.h:61-66](), [scene/gui/rich_text_label.cpp:241-269]()

## Editor Integration

### EditorLog Usage

The editor's log panel uses RichTextLabel extensively [editor/editor_log.cpp:]:

```mermaid
graph LR
    error["Error/Warning<br/>Messages"]
    format["Format with BBCode:<br/>[color][b]ERROR:[/b]"]
    log["RichTextLabel.add_message()"]
    parse["Parse BBCode"]
    display["Display in log panel"]
    
    error --> format
    format --> log
    log --> parse
    parse --> display
    
    style log fill:#e1f5ff
```

**Sources:** [editor/editor_log.cpp:406-431]()

### Font Theming

EditorLog applies custom fonts via theme overrides [editor/editor_log.cpp:70-108]():

```mermaid
graph LR
    theme["EditorTheme"]
    normal["normal_font<br/>(output_source)"]
    bold["bold_font<br/>(output_source_bold)"]
    italic["italics_font<br/>(output_source_italic)"]
    mono["mono_font<br/>(output_source_mono)"]
    
    theme --> normal
    theme --> bold
    theme --> italic
    theme --> mono
    
    normal --> rtl["RichTextLabel"]
    bold --> rtl
    italic --> rtl
    mono --> rtl
```

**Sources:** [editor/editor_log.cpp:70-108]()

## Performance Considerations

### Memory Management

RichTextLabel uses `RID_PtrOwner` for Item management [scene/gui/rich_text_label.h:609]():

```mermaid
graph TB
    items["items: RID_PtrOwner<Item>"]
    rid["RID (unique ID)"]
    item["Item* (pointer)"]
    
    items -->|"Maps"| rid
    rid -->|"To"| item
    
    note["Allows fast lookup<br/>and automatic cleanup"]
```

**Sources:** [scene/gui/rich_text_label.h:609]()

### Line Validation

The system uses dirty flags to minimize reprocessing [scene/gui/rich_text_label.h:232-234]():

| Flag | Purpose |
|------|---------|
| `first_invalid_line` | First line needing reshaping |
| `first_invalid_font_line` | First line needing font update |
| `first_resized_line` | First line needing resize |

**Sources:** [scene/gui/rich_text_label.h:232-234](), [scene/gui/rich_text_label.cpp:2687-2723]()

### Visible Line Culling

Only visible lines are processed and drawn [scene/gui/rich_text_label.cpp:1540-1761]():

```mermaid
graph TB
    compute["Compute visible_rect"]
    find["_find_first_line():<br/>Find first visible line"]
    iterate["Iterate visible lines only"]
    draw["Draw each line"]
    
    compute --> find
    find --> iterate
    iterate --> draw
```

**Sources:** [scene/gui/rich_text_label.cpp:1540-1761]()

## API Reference

### Main Public Methods

| Method | Purpose |
|--------|---------|
| `clear()` | Clear all content and reset |
| `add_text()` | Add plain text (no BBCode) |
| `append_text()` | Append BBCode text |
| `parse_bbcode()` | Parse and set BBCode |
| `push_*()` | Push formatting tag |
| `pop()` / `pop_all()` | Close formatting tags |
| `add_image()` | Add embedded image |
| `push_table()` | Start table |
| `set_table_column_expand()` | Configure table column |
| `push_cell()` | Start table cell |
| `get_parsed_text()` | Get text without BBCode |
| `get_selected_text()` | Get selected text |
| `scroll_to_paragraph()` | Scroll to specific paragraph |

**Sources:** [scene/gui/rich_text_label.h:820-906]()

### Properties

| Property | Type | Purpose |
|----------|------|---------|
| `text` | String | Full BBCode text content |
| `bbcode_enabled` | bool | Enable BBCode parsing |
| `fit_content` | bool | Auto-resize to content |
| `scroll_active` | bool | Enable scrolling |
| `scroll_following` | bool | Auto-scroll to bottom |
| `autowrap_mode` | AutowrapMode | Text wrapping behavior |
| `visible_characters` | int | Character visibility limit |
| `visible_ratio` | float | Visibility ratio (0.0-1.0) |
| `threaded` | bool | Enable background processing |
| `progress_bar_delay` | int | Delay before showing progress |

**Sources:** [scene/gui/rich_text_label.h:556-769]()

### Signals

| Signal | Parameters | Purpose |
|--------|------------|---------|
| `meta_clicked` | `Variant meta` | Meta link clicked |
| `meta_hover_started` | `Variant meta` | Mouse over meta link |
| `meta_hover_ended` | `Variant meta` | Mouse left meta link |
| `finished` | None | Threading completed |

**Sources:** [doc/classes/RichTextLabel.xml:1-18]()

---

**Sources:**
- [scene/gui/rich_text_label.h:47-906]()
- [scene/gui/rich_text_label.cpp:1-6312]()
- [doc/classes/RichTextLabel.xml:1-1156]()
- [editor/editor_log.cpp:1-492]()
- [scene/resources/text_paragraph.h:1-141]()45:T3b79,# Label & LineEdit

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [core/extension/gdextension_special_compat_hashes.cpp](core/extension/gdextension_special_compat_hashes.cpp)
- [core/extension/gdextension_special_compat_hashes.h](core/extension/gdextension_special_compat_hashes.h)
- [doc/classes/Label.xml](doc/classes/Label.xml)
- [doc/classes/LabelSettings.xml](doc/classes/LabelSettings.xml)
- [doc/classes/RichTextLabel.xml](doc/classes/RichTextLabel.xml)
- [doc/classes/TextLine.xml](doc/classes/TextLine.xml)
- [doc/classes/TextParagraph.xml](doc/classes/TextParagraph.xml)
- [editor/editor_log.cpp](editor/editor_log.cpp)
- [editor/editor_log.h](editor/editor_log.h)
- [scene/gui/label.cpp](scene/gui/label.cpp)
- [scene/gui/label.h](scene/gui/label.h)
- [scene/gui/rich_text_label.compat.inc](scene/gui/rich_text_label.compat.inc)
- [scene/gui/rich_text_label.cpp](scene/gui/rich_text_label.cpp)
- [scene/gui/rich_text_label.h](scene/gui/rich_text_label.h)
- [scene/resources/label_settings.cpp](scene/resources/label_settings.cpp)
- [scene/resources/label_settings.h](scene/resources/label_settings.h)
- [scene/resources/text_line.cpp](scene/resources/text_line.cpp)
- [scene/resources/text_line.h](scene/resources/text_line.h)
- [scene/resources/text_paragraph.cpp](scene/resources/text_paragraph.cpp)
- [scene/resources/text_paragraph.h](scene/resources/text_paragraph.h)

</details>



## Purpose and Scope

This page documents `Label` and `LineEdit`, the two fundamental text controls in Godot's GUI system. `Label` is a display-only control for showing plain text, while `LineEdit` is a single-line text input control. Both controls use the `TextServer` infrastructure for text shaping and rendering.

For rich text with BBCode formatting, see [RichTextLabel](#11.3). For multiline text editing with code-specific features, see [TextEdit & CodeEdit](#11.1). For the text shaping system underlying these controls, see [Text Shaping System](#11.2).

---

## Label Control

`Label` is the primary control for displaying non-interactive plain text. It inherits from `Control` and provides text alignment, wrapping, and basic formatting capabilities through the `TextServer` integration.

### Class Structure

```mermaid
graph TB
    Control["Control<br/>(Base GUI Class)"]
    Label["Label<br/>scene/gui/label.h"]
    LabelSettings["LabelSettings<br/>scene/resources/label_settings.h<br/>(Shared Style Resource)"]
    TextServer["TextServer<br/>(Text Shaping API)"]
    ThemeCache["Label::ThemeCache<br/>(Cached Theme Properties)"]
    Paragraph["Label::Paragraph<br/>(Internal Text Storage)"]
    
    Control --> Label
    Label --> LabelSettings
    Label --> TextServer
    Label --> ThemeCache
    Label --> Paragraph
    
    Paragraph --> TextServerRID["RID text_rid<br/>Vector&lt;RID&gt; lines_rid"]
    
    style Label fill:#e1f5ff
    style LabelSettings fill:#fff4e1
```

**Sources:** [scene/gui/label.h:36-194](), [scene/resources/label_settings.h:1-107]()

### Core Properties

| Property | Type | Purpose |
|----------|------|---------|
| `text` | String | The displayed text content |
| `horizontal_alignment` | HorizontalAlignment | LEFT, CENTER, RIGHT, FILL |
| `vertical_alignment` | VerticalAlignment | TOP, CENTER, BOTTOM, FILL |
| `autowrap_mode` | TextServer::AutowrapMode | OFF, WORD, WORD_SMART, ARBITRARY |
| `clip_text` | bool | Clips text horizontally if true |
| `text_overrun_behavior` | TextServer::OverrunBehavior | NO_TRIMMING, TRIM_CHAR, TRIM_WORD, ELLIPSIS, etc. |
| `visible_characters` | int | Progressive text reveal (-1 = all) |
| `label_settings` | LabelSettings | Shared styling resource |

**Sources:** [scene/gui/label.h:40-81](), [doc/classes/Label.xml:49-121]()

### Text Shaping Pipeline

```mermaid
flowchart TD
    SetText["set_text(String)"]
    MarkDirty["text_dirty = true"]
    Shape["_shape()"]
    CreateParagraphs["Split by paragraph_separator<br/>Create Paragraph structs"]
    ShapeTS["TextServer::create_shaped_text()"]
    AddString["TextServer::shaped_text_add_string()"]
    BreakLines["TextServer::shaped_text_get_line_breaks()"]
    SubstrLines["TextServer::shaped_text_substr()"]
    ApplyOverrun["Apply text_overrun_behavior<br/>if needed"]
    Draw["Draw each line"]
    
    SetText --> MarkDirty
    MarkDirty --> Shape
    Shape --> CreateParagraphs
    CreateParagraphs --> ShapeTS
    ShapeTS --> AddString
    AddString --> BreakLines
    BreakLines --> SubstrLines
    SubstrLines --> ApplyOverrun
    ApplyOverrun --> Draw
    
    style Shape fill:#e1f5ff
    style ShapeTS fill:#fff4e1
```

**Sources:** [scene/gui/label.cpp:138-343](), [scene/gui/label.cpp:419-430]()

### Internal Paragraph Structure

The `Label` class uses an internal `Paragraph` structure to manage shaped text:

```mermaid
classDiagram
    class Label {
        -Vector~Paragraph~ paragraphs
        -bool text_dirty
        -bool font_dirty
        -int total_line_count
        -String paragraph_separator
        +_shape() const
        +_ensure_shaped() const
    }
    
    class Paragraph {
        +bool lines_dirty
        +bool dirty
        +int start
        +String text
        +RID text_rid
        +Vector~RID~ lines_rid
    }
    
    Label --> Paragraph : contains
    Paragraph --> TextServerRID["TextServer RIDs"]
```

Each `Paragraph` represents a segment of text separated by the `paragraph_separator` (default `"\n"`). The text is shaped into a single `text_rid` which is then broken into multiple `lines_rid` based on the available width and autowrap settings.

**Sources:** [scene/gui/label.h:53-66](), [scene/gui/label.cpp:138-243]()

### Shaping Process Details

The `_shape()` method at [scene/gui/label.cpp:138-343]() performs the following steps:

1. **Text Preparation**: If `text_dirty`, split `xl_text` by `paragraph_separator`, optionally apply `uppercase` transformation
2. **Paragraph Creation**: Create `Paragraph` structs with individual `text_rid` from `TextServer::create_shaped_text()`
3. **String Addition**: For each paragraph, call `TS->shaped_text_add_string()` with font, size, and language
4. **BiDi Override**: Apply `structured_text_parser()` for bidirectional text
5. **Tab Alignment**: If `tab_stops` are set, call `TS->shaped_text_tab_align()`
6. **Line Breaking**: Get line breaks with `TS->shaped_text_get_line_breaks()` based on width and autowrap flags
7. **Line Creation**: Create substring RIDs for each line with `TS->shaped_text_substr()`
8. **Overrun Handling**: Apply ellipsis or trimming based on `text_overrun_behavior`

**Sources:** [scene/gui/label.cpp:138-343]()

### LabelSettings Resource

`LabelSettings` is a shareable resource that provides common styling properties for `Label` instances:

```mermaid
graph LR
    LabelSettings["LabelSettings<br/>(Resource)"]
    Font["font: Ref&lt;Font&gt;"]
    FontSize["font_size: int"]
    LineSpacing["line_spacing: int"]
    FontColor["font_color: Color"]
    OutlineSize["outline_size: int"]
    OutlineColor["outline_color: Color"]
    ShadowSize["shadow_size: int"]
    ShadowColor["shadow_color: Color"]
    ShadowOffset["shadow_offset: Vector2"]
    
    LabelSettings --> Font
    LabelSettings --> FontSize
    LabelSettings --> LineSpacing
    LabelSettings --> FontColor
    LabelSettings --> OutlineSize
    LabelSettings --> OutlineColor
    LabelSettings --> ShadowSize
    LabelSettings --> ShadowColor
    LabelSettings --> ShadowOffset
```

When a `Label` has `label_settings` assigned, those properties take priority over theme properties from `ThemeCache`.

**Sources:** [scene/resources/label_settings.h:38-107](), [scene/resources/label_settings.cpp:1-464]()

### Rendering Pipeline

```mermaid
sequenceDiagram
    participant Draw as _notification(DRAW)
    participant Ensure as _ensure_shaped()
    participant Layout as get_layout_data()
    participant RenderLine as Draw Line Loop
    participant TS as TextServer
    
    Draw->>Ensure: Check if shaping needed
    Ensure->>Ensure: Call _shape() if dirty
    Draw->>Layout: Get vertical offset, line count
    Layout-->>Draw: r_offset, r_last_line, r_line_spacing
    
    loop For each visible line
        Draw->>RenderLine: Get line RID
        RenderLine->>TS: shaped_text_get_glyphs()
        TS-->>RenderLine: Glyph array
        RenderLine->>RenderLine: Draw shadow (if enabled)
        RenderLine->>RenderLine: Draw outline (if enabled)
        RenderLine->>RenderLine: Draw glyphs
    end
```

The rendering happens in `_notification(NOTIFICATION_DRAW)` and uses helper functions like `draw_glyph()`, `draw_glyph_outline()`, and `draw_glyph_shadow()` defined at [scene/gui/label.cpp:391-417]().

**Sources:** [scene/gui/label.cpp:649-835](), [scene/gui/label.cpp:517-620]()

---

## LineEdit Control

`LineEdit` is a single-line text input control. While the source files for `LineEdit` are not included in this analysis, it is used throughout the editor and shares the underlying `TextServer` infrastructure with `Label`.

### Known Usage Patterns

From the codebase usage:

```mermaid
graph TB
    LineEdit["LineEdit<br/>scene/gui/line_edit.h"]
    TextServer["TextServer<br/>(Text Shaping)"]
    SearchBox["EditorLog search_box<br/>editor/editor_log.h:141"]
    
    LineEdit --> TextServer
    SearchBox --> LineEdit
    
    style LineEdit fill:#fff4e1
```

`LineEdit` is commonly used for:
- Search boxes (e.g., `EditorLog::search_box` at [editor/editor_log.h:141]())
- Single-line text entry fields
- Filter inputs
- Name/path entry fields

**Sources:** [editor/editor_log.h:36](), [editor/editor_log.h:141]()

### Key Differences from Label

| Aspect | Label | LineEdit |
|--------|-------|----------|
| **Purpose** | Display only | User input |
| **Interaction** | No text editing | Keyboard/mouse text editing |
| **Lines** | Multi-line (with autowrap) | Single line only |
| **Selection** | None (typically) | Text selection supported |
| **Cursor** | No cursor | Text cursor/caret |
| **Signals** | N/A | `text_changed`, `text_submitted` |

---

## Text Shaping Integration

Both `Label` and `LineEdit` rely on the `TextServer` singleton for text shaping. The shaping process uses Resource IDs (RIDs) to represent shaped text buffers.

### TextServer RID Lifecycle

```mermaid
stateDiagram-v2
    [*] --> Create: TS->create_shaped_text()
    Create --> AddString: TS->shaped_text_add_string()
    AddString --> Shape: TS->shaped_text_shape()
    Shape --> GetBreaks: TS->shaped_text_get_line_breaks()
    GetBreaks --> Substr: TS->shaped_text_substr()
    Substr --> Draw: TS->shaped_text_draw()
    Draw --> Free: TS->free_rid()
    Free --> [*]
```

**Sources:** [scene/gui/label.cpp:138-243](), [scene/resources/text_paragraph.cpp:155-221]()

### TextParagraph and TextLine Resources

`Label` uses `TextParagraph` and `TextLine` resources internally for text layout:

| Resource | Purpose | Usage in Label |
|----------|---------|----------------|
| `TextParagraph` | Multi-line text with wrapping | Used implicitly through TextServer |
| `TextLine` | Single-line text | Used for individual line RIDs |

While `Label` doesn't directly instantiate these classes, it uses the same TextServer APIs that these resources encapsulate.

**Sources:** [scene/resources/text_paragraph.h:39-142](), [scene/resources/text_line.h:38-133]()

---

## Label API Reference

### Common Methods

```
void set_text(String p_string)
String get_text() const

void set_horizontal_alignment(HorizontalAlignment p_alignment)
HorizontalAlignment get_horizontal_alignment() const

void set_vertical_alignment(VerticalAlignment p_alignment)  
VerticalAlignment get_vertical_alignment() const

void set_autowrap_mode(TextServer::AutowrapMode p_mode)
TextServer::AutowrapMode get_autowrap_mode() const

void set_visible_characters(int p_amount)
int get_visible_characters() const

int get_line_count() const
int get_line_height(int p_line = -1) const
int get_total_character_count() const
```

**Sources:** [scene/gui/label.h:116-192](), [doc/classes/Label.xml:13-47]()

### Configuration Example

The `Label` can be configured for various display needs:

```mermaid
graph TB
    BasicLabel["Basic Label<br/>autowrap_mode=OFF<br/>clip_text=false"]
    WrappedLabel["Wrapped Label<br/>autowrap_mode=WORD_SMART<br/>horizontal_alignment=LEFT"]
    EllipsisLabel["Ellipsis Label<br/>autowrap_mode=OFF<br/>text_overrun_behavior=ELLIPSIS"]
    CenteredLabel["Centered Label<br/>horizontal_alignment=CENTER<br/>vertical_alignment=CENTER"]
    
    BasicLabel --> Config["Label Configuration"]
    WrappedLabel --> Config
    EllipsisLabel --> Config
    CenteredLabel --> Config
```

**Sources:** [doc/classes/Label.xml:49-121]()

---

## Comparison with RichTextLabel

While `Label` is for plain text, `RichTextLabel` supports BBCode formatting:

| Feature | Label | RichTextLabel |
|---------|-------|---------------|
| **BBCode** | No | Yes |
| **Performance** | Lightweight | Heavier (Item hierarchy) |
| **Best For** | UI labels, simple text | Formatted text, dialog, logs |
| **Text Storage** | String + Paragraph array | Item tree structure |
| **Selection** | Not built-in | Built-in with selection support |
| **Inline Objects** | No | Yes (images, tables, etc.) |

For detailed `RichTextLabel` documentation, see [RichTextLabel](#11.3).

**Sources:** [scene/gui/label.h:36-194](), [scene/gui/rich_text_label.h:47-870]()

---

## Theme Integration

Both `Label` and `LineEdit` use the theme system for default styling:

### Label Theme Properties

```mermaid
graph LR
    ThemeCache["Label::ThemeCache"]
    NormalStyle["normal_style: StyleBox"]
    FocusStyle["focus_style: StyleBox"]
    Font["font: Font"]
    FontSize["font_size: int"]
    LineSpacing["line_spacing: int"]
    ParagraphSpacing["paragraph_spacing: int"]
    FontColor["font_color: Color"]
    OutlineColor["font_outline_color: Color"]
    OutlineSize["outline_size: int"]
    
    ThemeCache --> NormalStyle
    ThemeCache --> FocusStyle
    ThemeCache --> Font
    ThemeCache --> FontSize
    ThemeCache --> LineSpacing
    ThemeCache --> ParagraphSpacing
    ThemeCache --> FontColor
    ThemeCache --> OutlineColor
    ThemeCache --> OutlineSize
```

The theme cache is populated in `_update_theme_item_cache()` and used throughout rendering. If a `LabelSettings` resource is assigned, it overrides these theme values.

**Sources:** [scene/gui/label.h:83-97](), [doc/classes/Label.xml:122-164]()

---

## Summary

`Label` and `LineEdit` are the foundational text controls in Godot:

- **Label**: Display-only, supports multi-line text with autowrap, uses `TextServer` for shaping, can be styled with `LabelSettings` or theme properties
- **LineEdit**: Single-line text input, shares `TextServer` infrastructure, provides text editing capabilities

Both controls integrate with the broader text shaping system documented in [Text Shaping System](#11.2), and serve different purposes than the rich text controls like `RichTextLabel` ([RichTextLabel](#11.3)) or code editors like `TextEdit` ([TextEdit & CodeEdit](#11.1)).

**Sources:** [scene/gui/label.h:36-194](), [scene/gui/label.cpp:1-1180](), [editor/editor_log.h:36-141]()46:T6aff,# Visual Shader System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/VisualShader.xml](doc/classes/VisualShader.xml)
- [doc/classes/VisualShaderNode.xml](doc/classes/VisualShaderNode.xml)
- [doc/classes/VisualShaderNodeClamp.xml](doc/classes/VisualShaderNodeClamp.xml)
- [doc/classes/VisualShaderNodeCompare.xml](doc/classes/VisualShaderNodeCompare.xml)
- [doc/classes/VisualShaderNodeCustom.xml](doc/classes/VisualShaderNodeCustom.xml)
- [doc/classes/VisualShaderNodeParticleAccelerator.xml](doc/classes/VisualShaderNodeParticleAccelerator.xml)
- [doc/classes/VisualShaderNodeParticleBoxEmitter.xml](doc/classes/VisualShaderNodeParticleBoxEmitter.xml)
- [doc/classes/VisualShaderNodeParticleConeVelocity.xml](doc/classes/VisualShaderNodeParticleConeVelocity.xml)
- [doc/classes/VisualShaderNodeParticleEmit.xml](doc/classes/VisualShaderNodeParticleEmit.xml)
- [doc/classes/VisualShaderNodeParticleEmitter.xml](doc/classes/VisualShaderNodeParticleEmitter.xml)
- [doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml](doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml)
- [doc/classes/VisualShaderNodeParticleOutput.xml](doc/classes/VisualShaderNodeParticleOutput.xml)
- [doc/classes/VisualShaderNodeParticleRandomness.xml](doc/classes/VisualShaderNodeParticleRandomness.xml)
- [doc/classes/VisualShaderNodeParticleRingEmitter.xml](doc/classes/VisualShaderNodeParticleRingEmitter.xml)
- [doc/classes/VisualShaderNodeParticleSphereEmitter.xml](doc/classes/VisualShaderNodeParticleSphereEmitter.xml)
- [doc/classes/VisualShaderNodeSwitch.xml](doc/classes/VisualShaderNodeSwitch.xml)
- [scene/register_scene_types.cpp](scene/register_scene_types.cpp)
- [scene/resources/visual_shader.cpp](scene/resources/visual_shader.cpp)
- [scene/resources/visual_shader.h](scene/resources/visual_shader.h)
- [scene/resources/visual_shader_nodes.cpp](scene/resources/visual_shader_nodes.cpp)
- [scene/resources/visual_shader_nodes.h](scene/resources/visual_shader_nodes.h)
- [scene/resources/visual_shader_particle_nodes.cpp](scene/resources/visual_shader_particle_nodes.cpp)
- [scene/resources/visual_shader_particle_nodes.h](scene/resources/visual_shader_particle_nodes.h)
- [scene/resources/visual_shader_sdf_nodes.cpp](scene/resources/visual_shader_sdf_nodes.cpp)
- [scene/resources/visual_shader_sdf_nodes.h](scene/resources/visual_shader_sdf_nodes.h)

</details>



The Visual Shader System provides a graph-based visual editor for creating shaders without writing GLSL code. Users create shader logic by connecting nodes in a graph, which is then compiled to shader code at runtime. The system supports all major shader types including vertex, fragment, light, and particle shaders.

For information about the Shader resource base class, see [Resource System](#5). For the visual shader editor UI, see [Editor Plugins](#8).

---

## Architecture Overview

```mermaid
graph TB
    subgraph "User Space"
        Editor["Visual Shader Editor<br/>(GraphEdit UI)"]
        UserShader["VisualShader Resource<br/>(.tres, .res)"]
    end
    
    subgraph "Core System"
        VisualShader["VisualShader<br/>(scene/resources/visual_shader.h)"]
        Graph["Graph Structure<br/>(nodes + connections)"]
        Varying["Varying System<br/>(inter-stage variables)"]
    end
    
    subgraph "Node System"
        VSNode["VisualShaderNode<br/>(base class)"]
        Constants["Constant Nodes<br/>(Float, Int, Vector, etc)"]
        Operations["Operation Nodes<br/>(Math, Compare, etc)"]
        Parameters["Parameter Nodes<br/>(Uniforms)"]
        Input["Input Nodes<br/>(built-in vars)"]
        Output["Output Nodes<br/>(shader outputs)"]
        Custom["VisualShaderNodeCustom<br/>(user-extensible)"]
        Particle["Particle Nodes"]
        SDF["SDF Nodes"]
    end
    
    subgraph "Code Generation"
        Compiler["_write_node()<br/>(recursive traversal)"]
        CodeGen["generate_code()<br/>(per-node GLSL)"]
        ShaderCode["Final Shader Code<br/>(GLSL)"]
    end
    
    subgraph "Rendering"
        ShaderResource["Shader Resource"]
        RenderingServer["RenderingServer"]
    end
    
    Editor --> UserShader
    UserShader --> VisualShader
    VisualShader --> Graph
    VisualShader --> Varying
    
    Graph --> VSNode
    VSNode --> Constants
    VSNode --> Operations
    VSNode --> Parameters
    VSNode --> Input
    VSNode --> Output
    VSNode --> Custom
    VSNode --> Particle
    VSNode --> SDF
    
    VisualShader --> Compiler
    Compiler --> CodeGen
    CodeGen --> ShaderCode
    
    ShaderCode --> ShaderResource
    ShaderResource --> RenderingServer
```

**Diagram: Visual Shader System Architecture**

The system consists of three main layers: the graph structure that stores nodes and connections, the node system that defines individual operations, and the code generation pipeline that transforms the graph into GLSL shader code.

Sources: [scene/resources/visual_shader.h:41-258](), [scene/resources/visual_shader.cpp:1-3000]()

---

## Core Classes

### VisualShader

The `VisualShader` class is the main resource that represents a visual shader graph. It inherits from `Shader` and manages the node graph, connections, and code generation.

| Class | Location | Purpose |
|-------|----------|---------|
| `VisualShader` | [scene/resources/visual_shader.h:41-258]() | Main visual shader resource, manages graphs for all shader types |
| `VisualShaderNode` | [scene/resources/visual_shader.h:267-388]() | Base class for all visual shader nodes |
| `VisualShaderNodeCustom` | [scene/resources/visual_shader.h:392-488]() | User-extensible node via GDScript |

**Key Data Structures:**

```mermaid
classDiagram
    class VisualShader {
        +Graph graph[TYPE_MAX]
        +HashMap~String,Varying~ varyings
        +add_node(type, node, position, id)
        +connect_nodes(type, from_node, from_port, to_node, to_port)
        +_update_shader()
        +_write_node()
    }
    
    class Graph {
        +RBMap~int,Node~ nodes
        +List~Connection~ connections
    }
    
    class Node {
        +Ref~VisualShaderNode~ node
        +Vector2 position
        +LocalVector~int~ prev_connected_nodes
        +LocalVector~int~ next_connected_nodes
    }
    
    class Connection {
        +int from_node
        +int from_port
        +int to_node
        +int to_port
    }
    
    class Varying {
        +String name
        +VaryingMode mode
        +VaryingType type
    }
    
    VisualShader --> Graph
    Graph --> Node
    Graph --> Connection
    VisualShader --> Varying
```

**Diagram: VisualShader Core Data Structures**

Sources: [scene/resources/visual_shader.h:115-127](), [scene/resources/visual_shader.h:59-64](), [scene/resources/visual_shader.h:89-113]()

### Shader Types

The `VisualShader::Type` enum defines different shader functions that can be edited independently:

```mermaid
graph LR
    subgraph "Spatial/Canvas Shaders"
        VERTEX["TYPE_VERTEX<br/>(vertex shader)"]
        FRAGMENT["TYPE_FRAGMENT<br/>(fragment shader)"]
        LIGHT["TYPE_LIGHT<br/>(light calculations)"]
    end
    
    subgraph "Particle Shaders"
        START["TYPE_START<br/>(particle initialization)"]
        PROCESS["TYPE_PROCESS<br/>(particle update)"]
        COLLIDE["TYPE_COLLIDE<br/>(collision handler)"]
        START_CUSTOM["TYPE_START_CUSTOM<br/>(custom initialization)"]
        PROCESS_CUSTOM["TYPE_PROCESS_CUSTOM<br/>(custom update)"]
    end
    
    subgraph "Environment Shaders"
        SKY["TYPE_SKY<br/>(sky rendering)"]
        FOG["TYPE_FOG<br/>(volumetric fog)"]
    end
```

**Diagram: Shader Type Categories**

Each type maintains its own independent graph of nodes and connections. The graphs are compiled separately and combined into a single shader with multiple functions.

Sources: [scene/resources/visual_shader.h:45-57](), [doc/classes/VisualShader.xml:194-227]()

---

## Node System

### VisualShaderNode Base Class

All visual shader nodes inherit from `VisualShaderNode` and implement the port interface:

| Method | Purpose |
|--------|---------|
| `get_input_port_count()` | Returns number of input ports |
| `get_input_port_type(port)` | Returns type of input port (scalar, vector, etc.) |
| `get_input_port_name(port)` | Returns display name for input port |
| `get_output_port_count()` | Returns number of output ports |
| `get_output_port_type(port)` | Returns type of output port |
| `get_output_port_name(port)` | Returns display name for output port |
| `generate_code(...)` | Generates GLSL code for this node |

**Port Types:**

```mermaid
graph TB
    subgraph "Scalar Types"
        SCALAR["PORT_TYPE_SCALAR<br/>(float)"]
        SCALAR_INT["PORT_TYPE_SCALAR_INT<br/>(int)"]
        SCALAR_UINT["PORT_TYPE_SCALAR_UINT<br/>(uint)"]
    end
    
    subgraph "Vector Types"
        VEC2["PORT_TYPE_VECTOR_2D<br/>(vec2)"]
        VEC3["PORT_TYPE_VECTOR_3D<br/>(vec3)"]
        VEC4["PORT_TYPE_VECTOR_4D<br/>(vec4)"]
    end
    
    subgraph "Other Types"
        BOOL["PORT_TYPE_BOOLEAN<br/>(bool)"]
        TRANSFORM["PORT_TYPE_TRANSFORM<br/>(mat4)"]
        SAMPLER["PORT_TYPE_SAMPLER<br/>(sampler2D/3D)"]
    end
```

**Diagram: Port Type System**

Sources: [scene/resources/visual_shader.h:271-282](), [doc/classes/VisualShaderNode.xml:72-101]()

### Node Categories

Visual shader nodes are organized into categories:

```mermaid
graph TB
    subgraph "Input/Output"
        Input["VisualShaderNodeInput<br/>(UV, VERTEX, TIME, etc)"]
        Output["VisualShaderNodeOutput<br/>(ALBEDO, NORMAL, etc)"]
        Parameter["VisualShaderNodeParameter<br/>(uniforms)"]
    end
    
    subgraph "Constants"
        FloatConst["VisualShaderNodeFloatConstant"]
        IntConst["VisualShaderNodeIntConstant"]
        VecConst["Vector Constants"]
        ColorConst["VisualShaderNodeColorConstant"]
        TransformConst["VisualShaderNodeTransformConstant"]
    end
    
    subgraph "Operations"
        VectorOp["VisualShaderNodeVectorOp"]
        FloatOp["VisualShaderNodeFloatOp"]
        Compare["VisualShaderNodeCompare"]
        Switch["VisualShaderNodeSwitch"]
        Clamp["VisualShaderNodeClamp"]
    end
    
    subgraph "Textures"
        Texture["VisualShaderNodeTexture"]
        CurveTexture["VisualShaderNodeCurveTexture"]
        Texture3D["VisualShaderNodeTexture3D"]
        Cubemap["VisualShaderNodeCubemap"]
    end
    
    subgraph "Special"
        Custom["VisualShaderNodeCustom<br/>(user-defined)"]
        Expression["VisualShaderNodeExpression<br/>(raw GLSL)"]
        Frame["VisualShaderNodeFrame<br/>(visual grouping)"]
    end
```

**Diagram: Node Category Organization**

Sources: [scene/resources/visual_shader_nodes.h:1-500](), [scene/resources/visual_shader.h:284-298]()

---

## Graph Structure and Connections

### Node Management

Nodes are stored in a per-type graph structure with integer IDs:

```mermaid
graph LR
    subgraph "Node Storage"
        NodeMap["RBMap&lt;int, Node&gt;<br/>graph[type].nodes"]
        Node2["Node ID: 2"]
        Node3["Node ID: 3"]
        Node4["Node ID: 4"]
        Output["Node ID: 0<br/>(OUTPUT - reserved)"]
    end
    
    subgraph "Node Data"
        NodeData["Node struct"]
        VSNodeRef["Ref&lt;VisualShaderNode&gt;"]
        Position["Vector2 position"]
        PrevConnected["prev_connected_nodes"]
        NextConnected["next_connected_nodes"]
    end
    
    NodeMap --> Node2
    NodeMap --> Node3
    NodeMap --> Node4
    NodeMap --> Output
    
    Node2 --> NodeData
    NodeData --> VSNodeRef
    NodeData --> Position
    NodeData --> PrevConnected
    NodeData --> NextConnected
```

**Diagram: Node Storage Structure**

The output node always has ID 0 (`NODE_ID_OUTPUT`). User nodes start from ID 2.

Sources: [scene/resources/visual_shader.h:116-127](), [scene/resources/visual_shader.h:180-183]()

### Connection System

Connections link output ports to input ports:

| Field | Type | Description |
|-------|------|-------------|
| `from_node` | `int` | Source node ID |
| `from_port` | `int` | Source output port index |
| `to_node` | `int` | Destination node ID |
| `to_port` | `int` | Destination input port index |

**Connection Validation:**

The `can_connect_nodes()` method validates connections by checking:
- Port type compatibility via `is_port_types_compatible()`
- No circular dependencies via `is_nodes_connected_relatively()`
- Special handling for reroute nodes via `_check_reroute_subgraph()`

```mermaid
graph LR
    Node_A["Node A<br/>Output Port 0"]
    Node_B["Node B<br/>Input Port 1"]
    Node_C["Node C<br/>Input Port 0"]
    
    Node_A -->|"Connection<br/>(from=A,port=0,<br/>to=B,port=1)"| Node_B
    Node_A -->|"Connection<br/>(from=A,port=0,<br/>to=C,port=0)"| Node_C
```

**Diagram: Connection Example**

Sources: [scene/resources/visual_shader.h:59-64](), [scene/resources/visual_shader.cpp:1500-1650]()

### Dependency Tracking

Nodes maintain adjacency lists for efficient graph traversal:

- `prev_connected_nodes`: List of node IDs that provide input to this node
- `next_connected_nodes`: List of node IDs that consume output from this node

These are updated automatically when connections are added/removed and enable efficient topological sorting during code generation.

Sources: [scene/resources/visual_shader.h:119-120](), [scene/resources/visual_shader.cpp:1700-1800]()

---

## Code Generation Pipeline

### Compilation Process

The `_update_shader()` method orchestrates shader compilation:

```mermaid
graph TB
    Start["_update_shader()"] --> Init["Initialize code builders"]
    Init --> IterTypes["For each shader Type"]
    IterTypes --> CheckNodes["Has nodes?"]
    CheckNodes -->|No| IterTypes
    CheckNodes -->|Yes| BuildInputMap["Build input connection map"]
    BuildInputMap --> TopoSort["Topological sort from OUTPUT"]
    TopoSort --> WriteNodes["For each node in order"]
    WriteNodes --> WriteNode["_write_node(node_id)"]
    WriteNode --> GenGlobal["node.generate_global()"]
    GenGlobal --> GenCode["node.generate_code()"]
    GenCode --> AppendCode["Append to function code"]
    AppendCode --> WriteNodes
    WriteNodes --> NextType["Next Type"]
    NextType --> IterTypes
    IterTypes --> BuildShader["Assemble final shader"]
    BuildShader --> SetCode["set_code(shader_code)"]
    SetCode --> End["Done"]
```

**Diagram: Shader Compilation Flow**

Sources: [scene/resources/visual_shader.cpp:169-430]()

### Node Code Generation

Each node generates GLSL code via `generate_code()`:

**Example: Float Addition Node**

Input: Two connections to ports 0 and 1
```glsl
// Generated code:
float n_out2p0 = n_out0p0 + n_out1p0;
```

**Example: Texture Node**

Input: UV connection to port 0
```glsl
// Generated global:
uniform sampler2D tex_frg_2;

// Generated code:
vec4 n_out2p0;
{
    vec4 n_tex_read = texture(tex_frg_2, UV);
    n_out2p0 = n_tex_read;
}
```

**Variable Naming Convention:**

Output variables follow the pattern: `n_out{node_id}p{port_index}`
- `node_id`: The node's integer ID
- `port_index`: The output port index

This ensures unique variable names across the entire shader.

Sources: [scene/resources/visual_shader.cpp:500-900](), [scene/resources/visual_shader_nodes.cpp:683-732]()

### Global Code Sections

Nodes can inject code at different scopes:

| Method | Scope | Purpose |
|--------|-------|---------|
| `generate_global()` | Per shader type | Uniforms, type-specific helpers |
| `generate_global_per_node()` | Once per node instance | Node-specific globals |
| `generate_global_per_func()` | Per shader function | Function-scope helpers |
| `generate_code()` | Per node in function | Actual computation |

Sources: [scene/resources/visual_shader.h:377-381](), [scene/resources/visual_shader.cpp:161-167]()

---

## Varying System

Varyings allow data to pass between shader stages (vertex â†’ fragment â†’ light):

```mermaid
graph LR
    subgraph "Vertex Shader"
        VtxNode["VisualShaderNodeVaryingSetter<br/>var_name = value"]
    end
    
    subgraph "Fragment Shader"
        FragNode["VisualShaderNodeVaryingGetter<br/>read var_name"]
    end
    
    subgraph "Light Shader"
        LightNode["VisualShaderNodeVaryingGetter<br/>read var_name"]
    end
    
    VtxNode -->|"varying vec3 var_name"| FragNode
    FragNode -->|"varying vec3 var_name"| LightNode
```

**Diagram: Varying Data Flow**

**Varying Definition:**

| Field | Type | Values |
|-------|------|--------|
| `name` | `String` | Variable identifier |
| `mode` | `VaryingMode` | `VERTEX_TO_FRAG_LIGHT`, `FRAG_TO_LIGHT` |
| `type` | `VaryingType` | `FLOAT`, `INT`, `VECTOR_2D`, `VECTOR_3D`, etc. |

**Generated Code Example:**

```glsl
// Global scope
varying vec3 custom_varying;

// Vertex shader
custom_varying = vertex_output;

// Fragment shader
vec3 value = custom_varying;
```

Sources: [scene/resources/visual_shader.h:71-113](), [scene/resources/visual_shader.cpp:825-889]()

---

## Input and Output Nodes

### VisualShaderNodeInput

Provides access to built-in shader variables:

```mermaid
graph TB
    subgraph "Spatial Vertex Inputs"
        VERTEX["VERTEX<br/>(vec3)"]
        NORMAL["NORMAL<br/>(vec3)"]
        UV["UV<br/>(vec2)"]
        COLOR["COLOR<br/>(vec4)"]
        MODEL_MATRIX["MODEL_MATRIX<br/>(mat4)"]
    end
    
    subgraph "Spatial Fragment Inputs"
        FRAGCOORD["FRAGCOORD<br/>(vec4)"]
        SCREEN_UV["SCREEN_UV<br/>(vec2)"]
        TIME["TIME<br/>(float)"]
        VIEW["VIEW<br/>(vec3)"]
    end
    
    subgraph "Particle Inputs"
        START_TIME["START<br/>(uint)"]
        LIFETIME["LIFETIME<br/>(float)"]
        DELTA["DELTA<br/>(float)"]
        RANDOM_SEED["RANDOM_SEED<br/>(uint)"]
    end
```

**Diagram: Input Node Categories by Shader Type**

The available inputs depend on both `shader_mode` (Spatial, Canvas, Particles, Sky, Fog) and `shader_type` (vertex, fragment, light, etc.).

Sources: [scene/resources/visual_shader.h:492-549](), [scene/resources/visual_shader.cpp:3100-3800]()

### VisualShaderNodeOutput

Defines shader output values:

| Shader Type | Output Ports |
|-------------|-------------|
| `TYPE_VERTEX` | `VERTEX`, `NORMAL`, `TANGENT`, `BINORMAL`, `UV`, etc. |
| `TYPE_FRAGMENT` | `ALBEDO`, `ALPHA`, `METALLIC`, `ROUGHNESS`, `EMISSION`, etc. |
| `TYPE_LIGHT` | `DIFFUSE_LIGHT`, `SPECULAR_LIGHT`, `ALPHA` |
| `TYPE_START` (particles) | `VELOCITY`, `COLOR`, `SCALE`, `CUSTOM`, etc. |

Each output port maps directly to a GLSL output variable in the generated shader.

Sources: [scene/resources/visual_shader.h:553-624](), [scene/resources/visual_shader.cpp:3900-4500]()

---

## Parameter Nodes

Parameter nodes define shader uniforms that can be set from code:

```mermaid
graph TB
    subgraph "Parameter Types"
        FloatParam["VisualShaderNodeFloatParameter<br/>(uniform float)"]
        IntParam["VisualShaderNodeIntParameter<br/>(uniform int)"]
        VecParam["Vector Parameters<br/>(uniform vec2/3/4)"]
        ColorParam["VisualShaderNodeColorParameter<br/>(uniform vec4)"]
        TexParam["Texture Parameters<br/>(uniform sampler2D)"]
        TransformParam["VisualShaderNodeTransformParameter<br/>(uniform mat4)"]
    end
    
    subgraph "Generated Code"
        Uniform["uniform float param_name = default_value;"]
    end
    
    FloatParam --> Uniform
    IntParam --> Uniform
    VecParam --> Uniform
    ColorParam --> Uniform
    TexParam --> Uniform
    TransformParam --> Uniform
```

**Diagram: Parameter Node Types**

**Parameter Features:**

- **Name validation**: Ensures unique parameter names via `validate_parameter_name()`
- **Default values**: Can specify default uniform values
- **Hints**: Support for range hints, color hints, etc.
- **Qualifiers**: Can mark parameters as instance, global, or uniform

**Generated Uniform Example:**

```glsl
uniform float speed : hint_range(0.0, 10.0) = 1.0;
uniform vec4 color : source_color = vec4(1.0, 1.0, 1.0, 1.0);
uniform sampler2D texture_param : hint_default_white;
```

Sources: [scene/resources/visual_shader_nodes.h:800-1100](), [scene/resources/visual_shader.cpp:1200-1300]()

---

## Custom Nodes

### VisualShaderNodeCustom

Allows users to create custom nodes via GDScript:

```mermaid
graph TB
    subgraph "User Implementation"
        GDScript["@tool<br/>extends VisualShaderNodeCustom<br/>class_name CustomNode"]
        GetName["_get_name()"]
        GetInputs["_get_input_port_*()"]
        GetOutputs["_get_output_port_*()"]
        GetCode["_get_code()"]
    end
    
    subgraph "Runtime"
        UpdatePorts["update_ports()<br/>(called on load)"]
        GenerateCode["generate_code()<br/>(compilation)"]
    end
    
    subgraph "Editor"
        Registry["EditorPlugin<br/>auto-discovers @tool classes"]
        AddNode["Available in Add Node menu"]
    end
    
    GDScript --> UpdatePorts
    GetName --> Registry
    GetInputs --> UpdatePorts
    GetOutputs --> UpdatePorts
    GetCode --> GenerateCode
    Registry --> AddNode
```

**Diagram: Custom Node Extension System**

**Virtual Methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| `_get_name()` | `String` | Node display name |
| `_get_description()` | `String` | Tooltip description |
| `_get_category()` | `String` | Menu category path |
| `_get_input_port_count()` | `int` | Number of input ports |
| `_get_input_port_type(port)` | `PortType` | Type of input port |
| `_get_input_port_name(port)` | `String` | Name of input port |
| `_get_output_port_count()` | `int` | Number of output ports |
| `_get_output_port_type(port)` | `PortType` | Type of output port |
| `_get_output_port_name(port)` | `String` | Name of output port |
| `_get_code(input_vars, output_vars, mode, type)` | `String` | GLSL code to generate |

**Example Custom Node:**

```gdscript
@tool
extends VisualShaderNodeCustom
class_name VisualShaderNodeCustomNoise

func _get_name():
    return "NoiseGenerator"

func _get_category():
    return "Custom/Procedural"

func _get_input_port_count():
    return 1

func _get_input_port_type(port):
    return VisualShaderNode.PORT_TYPE_VECTOR_2D

func _get_input_port_name(port):
    return "uv"

func _get_output_port_count():
    return 1

func _get_output_port_type(port):
    return VisualShaderNode.PORT_TYPE_SCALAR

func _get_output_port_name(port):
    return "noise"

func _get_code(input_vars, output_vars, mode, type):
    return "%s = fract(sin(dot(%s, vec2(12.9898, 78.233))) * 43758.5453);" % [
        output_vars[0],
        input_vars[0]
    ]
```

Sources: [scene/resources/visual_shader.h:392-488](), [scene/resources/visual_shader.cpp:467-822](), [doc/classes/VisualShaderNodeCustom.xml:1-200]()

---

## Particle Shader Nodes

Particle shaders have specialized nodes for particle emission and manipulation:

```mermaid
graph TB
    subgraph "Emitter Nodes"
        SphereEmit["VisualShaderNodeParticleSphereEmitter<br/>(random point in sphere)"]
        BoxEmit["VisualShaderNodeParticleBoxEmitter<br/>(random point in box)"]
        RingEmit["VisualShaderNodeParticleRingEmitter<br/>(random point on ring)"]
        MeshEmit["VisualShaderNodeParticleMeshEmitter<br/>(random point on mesh)"]
    end
    
    subgraph "Process Nodes"
        Accelerator["VisualShaderNodeParticleAccelerator<br/>(linear/radial/tangential)"]
        ConeVelocity["VisualShaderNodeParticleConeVelocity<br/>(velocity in cone)"]
        Randomness["VisualShaderNodeParticleRandomness<br/>(random values)"]
        MultiplyAxis["VisualShaderNodeParticleMultiplyByAxisAngle<br/>(rotation helper)"]
    end
    
    subgraph "Special"
        ParticleOutput["VisualShaderNodeParticleOutput<br/>(custom output ports)"]
        ParticleEmit["VisualShaderNodeParticleEmit<br/>(sub-emitter trigger)"]
    end
```

**Diagram: Particle Node Types**

**Emitter Node Example:**

`VisualShaderNodeParticleSphereEmitter` generates:
- Global helper functions: `__get_random_point_in_sphere()`
- Per-node code: `position = __get_random_point_in_sphere(__seed, radius, inner_radius);`

**2D Mode:**

Particle nodes support a `mode_2d` property that changes:
- Output port type from `PORT_TYPE_VECTOR_3D` to `PORT_TYPE_VECTOR_2D`
- Generated helper functions (e.g., `__get_random_point_in_circle()` instead of sphere)

Sources: [scene/resources/visual_shader_particle_nodes.h:1-300](), [scene/resources/visual_shader_particle_nodes.cpp:1-600]()

---

## SDF Nodes (2D Canvas)

For 2D canvas shaders, SDF (Signed Distance Field) nodes provide distance field operations:

```mermaid
graph LR
    subgraph "Coordinate Conversion"
        SDFToUV["VisualShaderNodeSDFToScreenUV<br/>sdf_to_screen_uv(sdf_pos)"]
        UVToSDF["VisualShaderNodeScreenUVToSDF<br/>screen_uv_to_sdf(uv)"]
    end
    
    subgraph "SDF Operations"
        TextureSDF["VisualShaderNodeTextureSDF<br/>texture_sdf(sdf_pos)"]
        TextureSDFNormal["VisualShaderNodeTextureSDFNormal<br/>texture_sdf_normal(sdf_pos)"]
        SDFRaymarch["VisualShaderNodeSDFRaymarch<br/>sdf_raymarch(...)"]
    end
    
    SDFToUV --> TextureSDF
    UVToSDF --> TextureSDF
    TextureSDF --> TextureSDFNormal
```

**Diagram: SDF Node System**

These nodes wrap 2D canvas-specific built-in functions for working with the SDF texture that Godot generates for 2D lighting and effects.

Sources: [scene/resources/visual_shader_sdf_nodes.h:1-150](), [scene/resources/visual_shader_sdf_nodes.cpp:1-250]()

---

## Registration and Initialization

Visual shader classes are registered in the scene type system:

```mermaid
graph TB
    RegisterScene["register_scene_types()"] --> RegisterShader["GDREGISTER_CLASS(Shader)"]
    RegisterScene --> RegisterVS["GDREGISTER_CLASS(VisualShader)"]
    RegisterScene --> RegisterNodes["Register node classes"]
    
    RegisterNodes --> Constants["FloatConstant, IntConstant, etc."]
    RegisterNodes --> Operations["VectorOp, FloatOp, etc."]
    RegisterNodes --> Textures["Texture, CurveTexture, etc."]
    RegisterNodes --> Parameters["FloatParameter, IntParameter, etc."]
    RegisterNodes --> Particle["ParticleSphereEmitter, etc."]
    RegisterNodes --> SDF["SDFToScreenUV, etc."]
    RegisterNodes --> Special["Custom, Expression, Frame, etc."]
```

**Diagram: Class Registration**

All visual shader node classes are registered using the `GDREGISTER_CLASS` macro, making them available:
- In the ClassDB for instantiation
- In the editor's "Add Node" menu
- For serialization/deserialization in `.tres`/`.res` files

Sources: [scene/register_scene_types.cpp:765-886]()

---

## Key Files Reference

| File | Purpose |
|------|---------|
| [scene/resources/visual_shader.h]() | Core `VisualShader` and `VisualShaderNode` classes |
| [scene/resources/visual_shader.cpp]() | Implementation, graph management, code generation |
| [scene/resources/visual_shader_nodes.h]() | Standard node declarations (constants, ops, textures, parameters) |
| [scene/resources/visual_shader_nodes.cpp]() | Standard node implementations |
| [scene/resources/visual_shader_particle_nodes.h]() | Particle-specific node declarations |
| [scene/resources/visual_shader_particle_nodes.cpp]() | Particle node implementations |
| [scene/resources/visual_shader_sdf_nodes.h]() | SDF node declarations for 2D canvas |
| [scene/resources/visual_shader_sdf_nodes.cpp]() | SDF node implementations |
| [scene/register_scene_types.cpp:765-886]() | Node class registration |47:T41ac,# VisualShader Architecture

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/VisualShader.xml](doc/classes/VisualShader.xml)
- [doc/classes/VisualShaderNode.xml](doc/classes/VisualShaderNode.xml)
- [doc/classes/VisualShaderNodeClamp.xml](doc/classes/VisualShaderNodeClamp.xml)
- [doc/classes/VisualShaderNodeCompare.xml](doc/classes/VisualShaderNodeCompare.xml)
- [doc/classes/VisualShaderNodeCustom.xml](doc/classes/VisualShaderNodeCustom.xml)
- [doc/classes/VisualShaderNodeParticleAccelerator.xml](doc/classes/VisualShaderNodeParticleAccelerator.xml)
- [doc/classes/VisualShaderNodeParticleBoxEmitter.xml](doc/classes/VisualShaderNodeParticleBoxEmitter.xml)
- [doc/classes/VisualShaderNodeParticleConeVelocity.xml](doc/classes/VisualShaderNodeParticleConeVelocity.xml)
- [doc/classes/VisualShaderNodeParticleEmit.xml](doc/classes/VisualShaderNodeParticleEmit.xml)
- [doc/classes/VisualShaderNodeParticleEmitter.xml](doc/classes/VisualShaderNodeParticleEmitter.xml)
- [doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml](doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml)
- [doc/classes/VisualShaderNodeParticleOutput.xml](doc/classes/VisualShaderNodeParticleOutput.xml)
- [doc/classes/VisualShaderNodeParticleRandomness.xml](doc/classes/VisualShaderNodeParticleRandomness.xml)
- [doc/classes/VisualShaderNodeParticleRingEmitter.xml](doc/classes/VisualShaderNodeParticleRingEmitter.xml)
- [doc/classes/VisualShaderNodeParticleSphereEmitter.xml](doc/classes/VisualShaderNodeParticleSphereEmitter.xml)
- [doc/classes/VisualShaderNodeSwitch.xml](doc/classes/VisualShaderNodeSwitch.xml)
- [scene/register_scene_types.cpp](scene/register_scene_types.cpp)
- [scene/resources/visual_shader.cpp](scene/resources/visual_shader.cpp)
- [scene/resources/visual_shader.h](scene/resources/visual_shader.h)
- [scene/resources/visual_shader_nodes.cpp](scene/resources/visual_shader_nodes.cpp)
- [scene/resources/visual_shader_nodes.h](scene/resources/visual_shader_nodes.h)
- [scene/resources/visual_shader_particle_nodes.cpp](scene/resources/visual_shader_particle_nodes.cpp)
- [scene/resources/visual_shader_particle_nodes.h](scene/resources/visual_shader_particle_nodes.h)
- [scene/resources/visual_shader_sdf_nodes.cpp](scene/resources/visual_shader_sdf_nodes.cpp)
- [scene/resources/visual_shader_sdf_nodes.h](scene/resources/visual_shader_sdf_nodes.h)

</details>



This page documents the core architecture of the VisualShader system, which provides a graph-based visual editor for creating shaders. It covers the `VisualShader` resource class, its internal graph structure, shader type classification, and the varying system for data flow between shader stages.

For information about individual node implementations, see [VisualShaderNode System](#11.2). For shader code generation, see [Shader Code Generation](#11.3).

---

## Overview

The VisualShader system implements a node-based shader editor where shaders are constructed by connecting visual nodes in a graph. The `VisualShader` class inherits from `Shader` and internally manages multiple independent graphsâ€”one for each shader stage (vertex, fragment, light, etc.). At runtime, these graphs are compiled into GLSL shader code.

**Key Components:**

| Component | Purpose |
|-----------|---------|
| `VisualShader` | Main resource class that manages graphs and generates shader code |
| `VisualShaderNode` | Base class for all nodes in the graph |
| `Graph` | Internal structure holding nodes and connections for each shader type |
| Varyings | System for passing data between shader stages |

Sources: [scene/resources/visual_shader.h:41-258](), [scene/resources/visual_shader.cpp:1-4000]()

---

## VisualShader Resource Structure

```mermaid
graph TB
    Shader["Shader<br/>(Base Class)"]
    VisualShader["VisualShader<br/>(Inherits Shader)"]
    Graph0["Graph[TYPE_VERTEX]"]
    Graph1["Graph[TYPE_FRAGMENT]"]
    Graph2["Graph[TYPE_LIGHT]"]
    GraphN["Graph[TYPE_*]<br/>(10 types total)"]
    
    Shader --> VisualShader
    VisualShader --> Graph0
    VisualShader --> Graph1
    VisualShader --> Graph2
    VisualShader --> GraphN
    
    Graph0 --> Nodes0["RBMap&lt;int, Node&gt;<br/>nodes"]
    Graph0 --> Conns0["List&lt;Connection&gt;<br/>connections"]
    
    Nodes0 --> Node1["Node {<br/>Ref&lt;VisualShaderNode&gt;<br/>Vector2 position<br/>prev/next connections<br/>}"]
```

The `VisualShader` class is a `Resource` that extends `Shader`. It maintains an array of `Graph` structures indexed by `Type` enum, allowing each shader stage to have its own independent node graph.

**Internal Structure:**

```cpp
// From visual_shader.h:115-127
struct Node {
    Ref<VisualShaderNode> node;
    Vector2 position;
    LocalVector<int> prev_connected_nodes;
    LocalVector<int> next_connected_nodes;
};

struct Graph {
    RBMap<int, Node> nodes;
    List<Connection> connections;
} graph[TYPE_MAX];
```

The `graph` array contains 10 separate graphs (one per `Type`), each storing:
- **nodes**: Map from node ID (int) to `Node` structure
- **connections**: List of connections between node ports

Sources: [scene/resources/visual_shader.h:115-127]()

---

## Shader Type System

### Type Enumeration

VisualShader supports 10 distinct shader types, each representing a different shader stage or function:

```mermaid
graph LR
    subgraph "Standard Shading"
        TYPE_VERTEX["TYPE_VERTEX<br/>(0)"]
        TYPE_FRAGMENT["TYPE_FRAGMENT<br/>(1)"]
        TYPE_LIGHT["TYPE_LIGHT<br/>(2)"]
    end
    
    subgraph "Particle Shaders"
        TYPE_START["TYPE_START<br/>(3)"]
        TYPE_PROCESS["TYPE_PROCESS<br/>(4)"]
        TYPE_COLLIDE["TYPE_COLLIDE<br/>(5)"]
        TYPE_START_CUSTOM["TYPE_START_CUSTOM<br/>(6)"]
        TYPE_PROCESS_CUSTOM["TYPE_PROCESS_CUSTOM<br/>(7)"]
    end
    
    subgraph "Environment"
        TYPE_SKY["TYPE_SKY<br/>(8)"]
        TYPE_FOG["TYPE_FOG<br/>(9)"]
    end
```

| Type | Value | Purpose |
|------|-------|---------|
| `TYPE_VERTEX` | 0 | Vertex shader stage |
| `TYPE_FRAGMENT` | 1 | Fragment/pixel shader stage |
| `TYPE_LIGHT` | 2 | Light calculation function |
| `TYPE_START` | 3 | Particle initialization (start stage) |
| `TYPE_PROCESS` | 4 | Particle update (process stage) |
| `TYPE_COLLIDE` | 5 | Particle collision handler |
| `TYPE_START_CUSTOM` | 6 | Custom particle start with user-defined outputs |
| `TYPE_PROCESS_CUSTOM` | 7 | Custom particle process with user-defined outputs |
| `TYPE_SKY` | 8 | Sky/environment shader |
| `TYPE_FOG` | 9 | Volumetric fog compute shader |

Each type corresponds to a specific shader function in the final GLSL code. For example, `TYPE_VERTEX` generates code for the `vertex()` function, while `TYPE_FRAGMENT` generates code for `fragment()`.

Sources: [scene/resources/visual_shader.h:45-57](), [scene/resources/visual_shader.cpp:40-41]()

---

## Graph Structure

### Node and Connection Architecture

```mermaid
graph TD
    Graph["Graph Structure"]
    NodesMap["RBMap&lt;int, Node&gt;<br/>nodes"]
    ConnList["List&lt;Connection&gt;<br/>connections"]
    
    Graph --> NodesMap
    Graph --> ConnList
    
    NodesMap --> N1["Node ID: 0<br/>(OUTPUT node)"]
    NodesMap --> N2["Node ID: 2<br/>(User node)"]
    NodesMap --> N3["Node ID: 3<br/>(User node)"]
    
    N2 --> NodeData2["node: Ref&lt;VisualShaderNode&gt;<br/>position: Vector2<br/>prev_connected: []<br/>next_connected: [0]"]
    
    ConnList --> C1["Connection {<br/>from_node: 2<br/>from_port: 0<br/>to_node: 0<br/>to_port: 0<br/>}"]
```

Each `Graph` maintains:

1. **Nodes Map**: Maps node IDs to `Node` structures containing:
   - `node`: Reference to the `VisualShaderNode` instance
   - `position`: 2D position in the editor
   - `prev_connected_nodes`: IDs of nodes feeding into this node
   - `next_connected_nodes`: IDs of nodes this node feeds into

2. **Connections List**: Explicit connection records with:
   - `from_node` and `from_port`: Source node ID and output port
   - `to_node` and `to_port`: Destination node ID and input port

**Special Node IDs:**
- `NODE_ID_INVALID = -1`: Invalid node marker
- `NODE_ID_OUTPUT = 0`: Reserved for the output node (every graph has one)

Sources: [scene/resources/visual_shader.h:59-64](), [scene/resources/visual_shader.h:115-127](), [scene/resources/visual_shader.h:180-183]()

### Node Management API

The following methods manipulate the graph structure:

| Method | Purpose |
|--------|---------|
| `add_node(Type, node, position, id)` | Adds a node to the specified graph |
| `remove_node(Type, id)` | Removes a node and its connections |
| `connect_nodes(Type, from, from_port, to, to_port)` | Creates a connection between ports |
| `disconnect_nodes(Type, from, from_port, to, to_port)` | Removes a connection |
| `set_node_position(Type, id, position)` | Updates node position |
| `get_node(Type, id)` | Retrieves node by ID |
| `get_node_list(Type)` | Returns all node IDs in a graph |
| `get_node_connections(Type)` | Returns all connections in a graph |

Sources: [scene/resources/visual_shader.h:185-240]()

---

## Varying System

Varyings are variables that pass data between shader stages (e.g., vertex â†’ fragment â†’ light). The VisualShader system provides explicit management of varyings through the `Varying` structure.

### Varying Structure

```mermaid
graph LR
    subgraph "Varying Definition"
        VaryName["name: String"]
        VaryMode["mode: VaryingMode"]
        VaryType["type: VaryingType"]
    end
    
    subgraph "VaryingMode"
        M1["VERTEX_TO_FRAG_LIGHT<br/>(vertex â†’ fragment + light)"]
        M2["FRAG_TO_LIGHT<br/>(fragment â†’ light)"]
    end
    
    subgraph "VaryingType"
        T1["FLOAT / INT / UINT<br/>BOOLEAN"]
        T2["VECTOR_2D / VECTOR_3D / VECTOR_4D"]
        T3["TRANSFORM"]
    end
    
    VaryMode -.-> M1
    VaryMode -.-> M2
    VaryType -.-> T1
    VaryType -.-> T2
    VaryType -.-> T3
```

**Varying Components:**

```cpp
// From visual_shader.h:89-113
struct Varying {
    String name;
    VaryingMode mode;
    VaryingType type;
};
```

- **name**: Variable name (must be valid GLSL identifier)
- **mode**: Determines which shader stages can access the varying
- **type**: Data type of the varying

### VaryingMode Enumeration

| Mode | Value | Data Flow |
|------|-------|-----------|
| `VARYING_MODE_VERTEX_TO_FRAG_LIGHT` | 0 | Vertex â†’ Fragment and Light |
| `VARYING_MODE_FRAG_TO_LIGHT` | 1 | Fragment â†’ Light |

Sources: [scene/resources/visual_shader.h:71-75]()

### VaryingType Enumeration

| Type | Value | GLSL Type |
|------|-------|-----------|
| `VARYING_TYPE_FLOAT` | 0 | `float` |
| `VARYING_TYPE_INT` | 1 | `int` |
| `VARYING_TYPE_UINT` | 2 | `uint` |
| `VARYING_TYPE_VECTOR_2D` | 3 | `vec2` |
| `VARYING_TYPE_VECTOR_3D` | 4 | `vec3` |
| `VARYING_TYPE_VECTOR_4D` | 5 | `vec4` |
| `VARYING_TYPE_BOOLEAN` | 6 | `bool` |
| `VARYING_TYPE_TRANSFORM` | 7 | `mat4` |

Sources: [scene/resources/visual_shader.h:77-87]()

### Varying Management API

```cpp
// From visual_shader.h:189-199
void add_varying(const String &p_name, VaryingMode p_mode, VaryingType p_type);
void remove_varying(const String &p_name);
bool has_varying(const String &p_name) const;
int get_varyings_count() const;
const Varying *get_varying_by_index(int p_idx) const;
void set_varying_mode(const String &p_name, VaryingMode p_mode);
VaryingMode get_varying_mode(const String &p_name);
void set_varying_type(const String &p_name, VaryingType p_type);
VaryingType get_varying_type(const String &p_name);
```

The VisualShader maintains two collections:
- **varyings**: `HashMap<String, Varying>` for fast lookup by name
- **varyings_list**: `List<Varying>` for ordered iteration

Sources: [scene/resources/visual_shader.h:189-199](), [scene/resources/visual_shader.h:141-145](), [scene/resources/visual_shader.cpp:825-889]()

---

## Shader Mode Configuration

VisualShader supports multiple shader modes inherited from the base `Shader` class:

| Shader::Mode | Purpose |
|--------------|---------|
| `MODE_SPATIAL` | 3D rendering shaders |
| `MODE_CANVAS_ITEM` | 2D rendering shaders |
| `MODE_PARTICLES` | Particle system shaders |
| `MODE_SKY` | Sky/environment shaders |
| `MODE_FOG` | Volumetric fog shaders |

The mode is set via `set_mode(Mode)` and determines which built-in variables and functions are available during code generation.

Sources: [scene/resources/visual_shader.h:242-243](), [scene/resources/visual_shader.h:128]()

---

## Code Generation Process

The VisualShader compiles graphs into shader code through the `_update_shader()` method:

```mermaid
graph TD
    Start["_update_shader()"]
    CheckDirty["Check dirty flag"]
    InitStrings["Initialize StringBuilders<br/>(global, per-node, per-func)"]
    IterGraphs["For each Type<br/>(vertex, fragment, etc.)"]
    WriteNodes["_write_node()<br/>Recursive traversal"]
    GenGlobal["Generate global code"]
    GenFunc["Generate function code"]
    Assemble["Assemble final shader"]
    SetCode["set_code()"]
    
    Start --> CheckDirty
    CheckDirty -->|dirty| InitStrings
    CheckDirty -->|clean| End["Return"]
    InitStrings --> IterGraphs
    IterGraphs --> WriteNodes
    WriteNodes --> GenGlobal
    GenGlobal --> GenFunc
    GenFunc --> Assemble
    Assemble --> SetCode
    SetCode --> End
```

**Key Steps:**

1. **Dirty Flag Check**: Only regenerates if `dirty` flag is set
2. **Node Traversal**: Recursive depth-first traversal starting from output node
3. **Code Accumulation**: Each node generates GLSL code strings
4. **Global Code**: Uniform declarations, helper functions
5. **Per-Function Code**: Code specific to each shader stage
6. **Assembly**: Combines all parts into complete shader source

The `_write_node()` method handles recursive traversal and code generation for individual nodes, managing dependencies and preventing duplicate processing.

Sources: [scene/resources/visual_shader.h:161](), [scene/resources/visual_shader.cpp:1380-2070]()

---

## Registration and Initialization

VisualShader classes are registered during scene type registration:

```cpp
// From register_scene_types.cpp:767-885
GDREGISTER_CLASS(VisualShader);
GDREGISTER_ABSTRACT_CLASS(VisualShaderNode);
GDREGISTER_CLASS(VisualShaderNodeCustom);
GDREGISTER_CLASS(VisualShaderNodeInput);
GDREGISTER_ABSTRACT_CLASS(VisualShaderNodeOutput);
// ... many node types ...
```

Resource format loaders/savers are also registered:
- Text format: `.tres`, `.tscn` files
- Binary format: `.res`, `.scn` files
- Shader includes: `.gdshader`, `.gdshaderinc` files

Sources: [scene/register_scene_types.cpp:159-162](), [scene/register_scene_types.cpp:767-885]()

---

## Internal State Management

### Graph State

The VisualShader maintains several internal state components:

| Component | Type | Purpose |
|-----------|------|---------|
| `graph[TYPE_MAX]` | `Graph[10]` | Array of graphs for each shader type |
| `shader_mode` | `Shader::Mode` | Current shader mode (spatial, canvas, etc.) |
| `modes` | `HashMap<String, int>` | Shader mode flags |
| `flags` | `HashSet<StringName>` | Additional shader flags |
| `varyings` | `HashMap<String, Varying>` | Named varying variables |
| `varyings_list` | `List<Varying>` | Ordered list of varyings |
| `dirty` | `SafeFlag` | Thread-safe dirty flag for regeneration |
| `previous_code` | `String` | Cached generated shader code |

Sources: [scene/resources/visual_shader.h:123-148]()

### Update Queue System

Changes to the graph trigger automatic shader regeneration:

```cpp
// From visual_shader.cpp:1375-1379
void VisualShader::_queue_update() {
    if (dirty.is_set()) {
        return;
    }
    dirty.set();
    call_deferred("_update_shader");
}
```

The `_queue_update()` method:
1. Sets the `dirty` flag atomically
2. Defers `_update_shader()` call to next idle frame
3. Prevents redundant updates with flag check

This ensures shader code is regenerated efficiently after any graph modification.

Sources: [scene/resources/visual_shader.cpp:1375-1379](), [scene/resources/visual_shader.h:148]()

---

## Summary

The VisualShader architecture provides:

1. **Multi-Graph System**: 10 independent graphs for different shader stages
2. **Node-Based Design**: Nodes connected through typed ports
3. **Varying Management**: Explicit data flow between shader stages
4. **Deferred Compilation**: Efficient lazy shader code generation
5. **Resource Integration**: Full serialization and resource system support

The system separates graph structure (nodes, connections, positions) from shader semantics (code generation, type checking), allowing flexible visual shader construction while generating optimized GLSL code.

Sources: [scene/resources/visual_shader.h:41-258](), [scene/resources/visual_shader.cpp:1-4000]()48:T4f5c,# VisualShaderNode System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/VisualShader.xml](doc/classes/VisualShader.xml)
- [doc/classes/VisualShaderNode.xml](doc/classes/VisualShaderNode.xml)
- [doc/classes/VisualShaderNodeClamp.xml](doc/classes/VisualShaderNodeClamp.xml)
- [doc/classes/VisualShaderNodeCompare.xml](doc/classes/VisualShaderNodeCompare.xml)
- [doc/classes/VisualShaderNodeCustom.xml](doc/classes/VisualShaderNodeCustom.xml)
- [doc/classes/VisualShaderNodeParticleAccelerator.xml](doc/classes/VisualShaderNodeParticleAccelerator.xml)
- [doc/classes/VisualShaderNodeParticleBoxEmitter.xml](doc/classes/VisualShaderNodeParticleBoxEmitter.xml)
- [doc/classes/VisualShaderNodeParticleConeVelocity.xml](doc/classes/VisualShaderNodeParticleConeVelocity.xml)
- [doc/classes/VisualShaderNodeParticleEmit.xml](doc/classes/VisualShaderNodeParticleEmit.xml)
- [doc/classes/VisualShaderNodeParticleEmitter.xml](doc/classes/VisualShaderNodeParticleEmitter.xml)
- [doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml](doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml)
- [doc/classes/VisualShaderNodeParticleOutput.xml](doc/classes/VisualShaderNodeParticleOutput.xml)
- [doc/classes/VisualShaderNodeParticleRandomness.xml](doc/classes/VisualShaderNodeParticleRandomness.xml)
- [doc/classes/VisualShaderNodeParticleRingEmitter.xml](doc/classes/VisualShaderNodeParticleRingEmitter.xml)
- [doc/classes/VisualShaderNodeParticleSphereEmitter.xml](doc/classes/VisualShaderNodeParticleSphereEmitter.xml)
- [doc/classes/VisualShaderNodeSwitch.xml](doc/classes/VisualShaderNodeSwitch.xml)
- [scene/register_scene_types.cpp](scene/register_scene_types.cpp)
- [scene/resources/visual_shader.cpp](scene/resources/visual_shader.cpp)
- [scene/resources/visual_shader.h](scene/resources/visual_shader.h)
- [scene/resources/visual_shader_nodes.cpp](scene/resources/visual_shader_nodes.cpp)
- [scene/resources/visual_shader_nodes.h](scene/resources/visual_shader_nodes.h)
- [scene/resources/visual_shader_particle_nodes.cpp](scene/resources/visual_shader_particle_nodes.cpp)
- [scene/resources/visual_shader_particle_nodes.h](scene/resources/visual_shader_particle_nodes.h)
- [scene/resources/visual_shader_sdf_nodes.cpp](scene/resources/visual_shader_sdf_nodes.cpp)
- [scene/resources/visual_shader_sdf_nodes.h](scene/resources/visual_shader_sdf_nodes.h)

</details>



This page documents the **VisualShaderNode** base class and the node system used in the Visual Shader Editor. It covers the port system (input/output ports), default values, node categories, constants, parameters, and the custom node extension mechanism. For information about the overall VisualShader graph structure and varying system, see [VisualShader Architecture](#11.1). For details on shader code generation and compilation, see [Shader Code Generation](#11.3).

## VisualShaderNode Base Class

`VisualShaderNode` is the abstract base class for all nodes in the visual shader graph. Each node represents a shader operation and defines a set of input and output ports with specific data types.

**Key Responsibilities:**
- Define the number and types of input/output ports
- Manage default values for disconnected input ports
- Generate GLSL shader code for the node's operation
- Track port connections
- Provide metadata for editor display (caption, category, properties)

Sources: [scene/resources/visual_shader.h:267-388]()

## Port System

### Port Types

Nodes communicate through typed ports. Each port has one of the following types:

| PortType | GLSL Type | Description |
|----------|-----------|-------------|
| `PORT_TYPE_SCALAR` | `float` | Floating-point scalar |
| `PORT_TYPE_SCALAR_INT` | `int` | Integer scalar |
| `PORT_TYPE_SCALAR_UINT` | `uint` | Unsigned integer scalar |
| `PORT_TYPE_VECTOR_2D` | `vec2` | 2D vector |
| `PORT_TYPE_VECTOR_3D` | `vec3` | 3D vector |
| `PORT_TYPE_VECTOR_4D` | `vec4` | 4D vector |
| `PORT_TYPE_BOOLEAN` | `bool` | Boolean |
| `PORT_TYPE_TRANSFORM` | `mat4` | 4x4 transform matrix |
| `PORT_TYPE_SAMPLER` | sampler reference | Texture sampler (input only) |

Sources: [scene/resources/visual_shader.h:271-282]()

### Port Interface Methods

Each node subclass must implement these virtual methods to define its interface:

```cpp
// Input ports
virtual int get_input_port_count() const = 0;
virtual PortType get_input_port_type(int p_port) const = 0;
virtual String get_input_port_name(int p_port) const = 0;

// Output ports
virtual int get_output_port_count() const = 0;
virtual PortType get_output_port_type(int p_port) const = 0;
virtual String get_output_port_name(int p_port) const = 0;
```

Sources: [scene/resources/visual_shader.h:321-335]()

### Port Connection Tracking

The `VisualShaderNode` base class tracks which ports are connected to support conditional logic and optimization:

```mermaid
graph LR
    Node["VisualShaderNode"]
    InputMap["connected_input_ports<br/>HashMap&lt;int, bool&gt;"]
    OutputMap["connected_output_ports<br/>HashMap&lt;int, int&gt;"]
    
    Node --> InputMap
    Node --> OutputMap
    
    InputMap --> |"set_input_port_connected()"| Check1["is_input_port_connected()"]
    OutputMap --> |"set_output_port_connected()"| Check2["is_output_port_connected()"]
```

**Connection Tracking Methods:**
- `is_input_port_connected(int p_port)` - Check if an input port has a connection
- `is_output_port_connected(int p_port)` - Check if an output port has connections
- `set_input_port_connected()` / `set_output_port_connected()` - Called by `VisualShader` to track connections

The output port map stores a **count** rather than a boolean, since one output can connect to multiple inputs.

Sources: [scene/resources/visual_shader.h:304-306](), [scene/resources/visual_shader.cpp:222-260]()

## Default Values

When an input port is not connected, the node can use a default value. These values are stored per-port and can be set in the editor or programmatically.

### Default Value Management

```mermaid
graph TB
    SetDefault["set_input_port_default_value(port, value)"]
    DefaultMap["default_input_values<br/>HashMap&lt;int, Variant&gt;"]
    GetDefault["get_input_port_default_value(port)"]
    
    SetDefault --> |"stores"| DefaultMap
    DefaultMap --> |"retrieves"| GetDefault
    
    TypeConvert["Type Conversion Logic"]
    SetDefault --> TypeConvert
    
    TypeConvert --> |"float â†’ vec3"| Splat["Splat scalar to vector"]
    TypeConvert --> |"vec3 â†’ float"| Extract["Extract first component"]
    TypeConvert --> |"preserve type"| Direct["Direct assignment"]
```

**Type Conversion:** When changing a port connection that alters the expected type, the default value is intelligently converted. For example, if a `float` default value exists and the port type changes to `vec3`, the float is splatted to `vec3(f, f, f)`.

Sources: [scene/resources/visual_shader.cpp:60-216](), [scene/resources/visual_shader.h:326-331]()

### Default Value Array Serialization

Default values are serialized as a flat array for storage:

```
[port_index_0, value_0, port_index_1, value_1, ...]
```

This format is used by `get_default_input_values()` and `set_default_input_values()`.

Sources: [scene/resources/visual_shader.cpp:390-407]()

## Node Categories

Nodes are organized into categories for the editor's "Add Node" menu:

| Category | Purpose | Examples |
|----------|---------|----------|
| `CATEGORY_OUTPUT` | Final output nodes | `VisualShaderNodeOutput` |
| `CATEGORY_COLOR` | Color operations | Color mixing, conversion |
| `CATEGORY_CONDITIONAL` | Conditional logic | `VisualShaderNodeIf`, `VisualShaderNodeSwitch`, `VisualShaderNodeCompare` |
| `CATEGORY_INPUT` | Built-in shader inputs | `VisualShaderNodeInput` |
| `CATEGORY_SCALAR` | Scalar operations | Math operations on floats |
| `CATEGORY_TEXTURES` | Texture sampling | `VisualShaderNodeTexture`, SDF nodes |
| `CATEGORY_TRANSFORM` | Transform operations | Matrix operations |
| `CATEGORY_UTILITY` | Utility functions | Remap, random, etc. |
| `CATEGORY_VECTOR` | Vector operations | Vector math |
| `CATEGORY_PARTICLE` | Particle system nodes | Emitters, accelerators |
| `CATEGORY_SPECIAL` | Special nodes | Expression, custom nodes |

Sources: [scene/resources/visual_shader.h:284-298]()

## Constant Nodes

Constant nodes output fixed values that can be edited in the editor. They have no input ports and a single output port.

### Constant Node Hierarchy

```mermaid
graph TB
    VSNode["VisualShaderNode"]
    ConstantBase["VisualShaderNodeConstant<br/>(abstract base)"]
    
    VSNode --> ConstantBase
    
    ConstantBase --> Float["VisualShaderNodeFloatConstant<br/>output: float"]
    ConstantBase --> Int["VisualShaderNodeIntConstant<br/>output: int"]
    ConstantBase --> UInt["VisualShaderNodeUIntConstant<br/>output: uint"]
    ConstantBase --> Bool["VisualShaderNodeBooleanConstant<br/>output: bool"]
    ConstantBase --> Color["VisualShaderNodeColorConstant<br/>output: vec4"]
    ConstantBase --> Vec2["VisualShaderNodeVec2Constant<br/>output: vec2"]
    ConstantBase --> Vec3["VisualShaderNodeVec3Constant<br/>output: vec3"]
    ConstantBase --> Vec4["VisualShaderNodeVec4Constant<br/>output: vec4"]
    ConstantBase --> Transform["VisualShaderNodeTransformConstant<br/>output: mat4"]
```

**Example: FloatConstant**

```cpp
// From visual_shader_nodes.cpp:133-135
String VisualShaderNodeFloatConstant::generate_code(...) const {
    return "	" + p_output_vars[0] + " = " + vformat("%.6f", constant) + ";\n";
}
```

The constant value is stored as a member variable (`float constant`) and exposed as an editable property.

Sources: [scene/resources/visual_shader_nodes.h:89-108](), [scene/resources/visual_shader_nodes.cpp:100-679]()

## Parameter Nodes

Parameter nodes represent shader uniforms that can be set from code or the material inspector. They have no input ports and one output port.

### Parameter Node Types

```mermaid
graph TB
    VSNode["VisualShaderNode"]
    ParamBase["VisualShaderNodeParameter<br/>(abstract base)"]
    
    VSNode --> ParamBase
    
    ParamBase --> FloatParam["VisualShaderNodeFloatParameter<br/>uniform float"]
    ParamBase --> IntParam["VisualShaderNodeIntParameter<br/>uniform int"]
    ParamBase --> UIntParam["VisualShaderNodeUIntParameter<br/>uniform uint"]
    ParamBase --> BoolParam["VisualShaderNodeBooleanParameter<br/>uniform bool"]
    ParamBase --> ColorParam["VisualShaderNodeColorParameter<br/>uniform vec4"]
    ParamBase --> Vec2Param["VisualShaderNodeVec2Parameter<br/>uniform vec2"]
    ParamBase --> Vec3Param["VisualShaderNodeVec3Parameter<br/>uniform vec3"]
    ParamBase --> Vec4Param["VisualShaderNodeVec4Parameter<br/>uniform vec4"]
    ParamBase --> TransformParam["VisualShaderNodeTransformParameter<br/>uniform mat4"]
    
    ParamBase --> TexParam["VisualShaderNodeTextureParameter<br/>(abstract base)"]
    TexParam --> Tex2D["Texture2DParameter"]
    TexParam --> TexArray["Texture2DArrayParameter"]
    TexParam --> Tex3D["Texture3DParameter"]
    TexParam --> Cubemap["CubemapParameter"]
```

**Key Feature: Parameter Names**

Each parameter node has a `parameter_name` that becomes the uniform name in the generated shader. The `VisualShader` class validates and ensures unique parameter names when nodes are added.

Sources: [scene/resources/visual_shader_nodes.h:1500-1900](), [scene/resources/visual_shader.cpp:929-961]()

## Input and Output Nodes

### VisualShaderNodeInput

`VisualShaderNodeInput` provides access to built-in shader inputs like `UV`, `VERTEX`, `NORMAL`, `TIME`, etc. The available inputs depend on the shader mode (Spatial, CanvasItem, Particle, Sky, Fog) and shader type (Vertex, Fragment, Light).

**Input Port Registry:**

```mermaid
graph LR
    InputNode["VisualShaderNodeInput"]
    PortsArray["static const Port ports[]"]
    ShaderMode["shader_mode<br/>(Spatial/CanvasItem/etc)"]
    ShaderType["shader_type<br/>(Vertex/Fragment/Light)"]
    
    InputNode --> PortsArray
    InputNode --> ShaderMode
    InputNode --> ShaderType
    
    PortsArray --> Filter["Filter ports by mode & type"]
    ShaderMode --> Filter
    ShaderType --> Filter
    
    Filter --> Available["get_input_index_count()<br/>get_input_index_name()"]
```

The `ports` static array in `VisualShaderNodeInput` contains all possible inputs with their mode, type, port type, name, and GLSL string.

Sources: [scene/resources/visual_shader.h:492-549](), [scene/resources/visual_shader_nodes.cpp:10500-11400]()

### VisualShaderNodeOutput

`VisualShaderNodeOutput` is the final output node in each shader type's graph. It defines input ports for shader outputs like `ALBEDO`, `NORMAL`, `EMISSION`, etc.

**Port Configuration:**

Like `VisualShaderNodeInput`, output ports are defined in a static array and filtered by shader mode and type. The output node is always at node ID 0 (`NODE_ID_OUTPUT`).

Sources: [scene/resources/visual_shader.h:553-604](), [scene/resources/visual_shader_nodes.cpp:11400-12900]()

## Custom Node System

`VisualShaderNodeCustom` allows users to create custom nodes using GDScript by overriding virtual methods. This is the primary extension mechanism for the visual shader system.

### Custom Node Architecture

```mermaid
graph TB
    VSNode["VisualShaderNode"]
    CustomNode["VisualShaderNodeCustom"]
    UserNode["User's Custom Node<br/>(GDScript)"]
    
    VSNode --> CustomNode
    CustomNode --> UserNode
    
    subgraph "Virtual Methods to Override"
        GetName["_get_name()"]
        GetDesc["_get_description()"]
        GetCategory["_get_category()"]
        GetInputCount["_get_input_port_count()"]
        GetInputType["_get_input_port_type(port)"]
        GetInputName["_get_input_port_name(port)"]
        GetOutputCount["_get_output_port_count()"]
        GetOutputType["_get_output_port_type(port)"]
        GetOutputName["_get_output_port_name(port)"]
        GetCode["_get_code(input_vars, output_vars, mode, type)"]
    end
    
    UserNode --> GetName
    UserNode --> GetDesc
    UserNode --> GetCategory
    UserNode --> GetInputCount
    UserNode --> GetInputType
    UserNode --> GetInputName
    UserNode --> GetOutputCount
    UserNode --> GetOutputType
    UserNode --> GetOutputName
    UserNode --> GetCode
```

### Custom Node Port Definition

The custom node system dynamically builds its port lists by calling virtual methods:

```cpp
// From visual_shader.cpp:491-563
void VisualShaderNodeCustom::update_ports() {
    // Build drop-down properties
    dp_props.clear();
    int prop_count;
    if (GDVIRTUAL_CALL(_get_property_count, prop_count)) { ... }
    
    // Build input ports
    input_ports.clear();
    int input_port_count;
    if (GDVIRTUAL_CALL(_get_input_port_count, input_port_count)) {
        for (int i = 0; i < input_port_count; i++) {
            Port port;
            GDVIRTUAL_CALL(_get_input_port_name, i, port.name);
            PortType port_type;
            if (GDVIRTUAL_CALL(_get_input_port_type, i, port_type)) {
                port.type = (int)port_type;
            }
            input_ports.push_back(port);
        }
    }
    
    // Build output ports (similar logic)
    ...
}
```

Sources: [scene/resources/visual_shader.cpp:467-563]()

### Custom Node Code Generation

The code generation flow for custom nodes:

```mermaid
graph TB
    Generate["generate_code()"]
    CallVirtual["GDVIRTUAL_CALL(_get_code, ...)"]
    Validate["_is_valid_code()"]
    Wrap["Wrap in code block"]
    Return["Return formatted code"]
    
    Generate --> CallVirtual
    CallVirtual --> |"returns String"| Validate
    Validate --> |"valid"| Wrap
    Wrap --> Return
    Validate --> |"empty/null"| EmptyString["return empty String"]
```

**Code Wrapping:** User-provided code is automatically wrapped in a block with proper indentation:

```cpp
// From visual_shader.cpp:627-641
String code = "	{\n";
_code = _code.insert(0, "		");
_code = _code.replace("\n", "\n		");
code += _code;
if (!nend) {
    code += "\n	}";
} else {
    code.remove_at(code.size() - 1);
    code += "}";
}
code += "\n";
```

Sources: [scene/resources/visual_shader.cpp:614-679]()

### Custom Node Property System

Custom nodes support drop-down properties for configuration. Properties are stored as a serialized string:

```
"property_index,selected_option_index;property_index,selected_option_index;..."
```

Methods:
- `_get_property_count()` - Number of properties
- `_get_property_name(index)` - Property name
- `_get_property_options(index)` - Array of option strings
- `_get_property_default_index(index)` - Default selected index
- `get_option_index(option)` - Get current selected index

Sources: [scene/resources/visual_shader.cpp:467-477](), [scene/resources/visual_shader.cpp:565-572](), [scene/resources/visual_shader.h:404-412]()

## Code Generation Interface

Every `VisualShaderNode` subclass must implement `generate_code()` to produce GLSL shader code:

```cpp
virtual String generate_code(
    Shader::Mode p_mode,           // Shader mode (Spatial, CanvasItem, etc)
    VisualShader::Type p_type,     // Shader type (Vertex, Fragment, Light, etc)
    int p_id,                      // Node ID
    const String *p_input_vars,    // Array of input variable names
    const String *p_output_vars,   // Array of output variable names
    bool p_for_preview = false     // True if generating preview shader
) const = 0;
```

### Code Generation Hooks

In addition to `generate_code()`, nodes can provide:

| Method | Purpose | Called When |
|--------|---------|-------------|
| `generate_global()` | Global shader code per node per type | Once per node per shader type |
| `generate_global_per_node()` | Global shader code once per node | Once per node (all types) |
| `generate_global_per_func()` | Code at start of shader function | Once per shader type |

These hooks allow nodes to define helper functions, uniforms, or varyings that are shared across the shader.

Sources: [scene/resources/visual_shader.h:376-381]()

### Example: FloatOp Node Code Generation

```cpp
// Input ports: a (float), b (float)
// Output port: result (float)
String generate_code(...) const {
    static const char *operators[OP_ENUM_SIZE] = {
        "+", "-", "*", "/", "%",  // Basic arithmetic
        "pow($, $)",              // Power (special formatting)
        "max($, $)",              // Max
        "min($, $)",              // Min
        "atan($, $)",             // Atan2
        "step($, $)"              // Step
    };
    
    String op_str = operators[op];
    if (op_str.contains("$")) {
        // Special functions with format strings
        return "	" + p_output_vars[0] + " = " + 
               op_str.replace("$", p_input_vars[0], false).replace("$", p_input_vars[1]) + ";\n";
    } else {
        // Binary operators
        return "	" + p_output_vars[0] + " = " + 
               p_input_vars[0] + " " + op_str + " " + p_input_vars[1] + ";\n";
    }
}
```

Sources: [scene/resources/visual_shader_nodes.cpp:1300-1350]()

## Node Registration

All node classes are registered with Godot's class system using `GDREGISTER_CLASS` macros in `register_scene_types()`:

```cpp
// From scene/register_scene_types.cpp:768-866
GDREGISTER_CLASS(VisualShader);
GDREGISTER_ABSTRACT_CLASS(VisualShaderNode);
GDREGISTER_CLASS(VisualShaderNodeCustom);
GDREGISTER_CLASS(VisualShaderNodeInput);
GDREGISTER_ABSTRACT_CLASS(VisualShaderNodeOutput);
GDREGISTER_ABSTRACT_CLASS(VisualShaderNodeConstant);
GDREGISTER_CLASS(VisualShaderNodeFloatConstant);
GDREGISTER_CLASS(VisualShaderNodeIntConstant);
// ... many more node types
```

This registration makes nodes available to:
- The visual shader editor for instantiation
- The resource system for serialization
- GDScript/C# for programmatic access

Sources: [scene/register_scene_types.cpp:767-885]()

---

**Key Files:**
- [scene/resources/visual_shader.h]() - `VisualShaderNode` and `VisualShaderNodeCustom` class definitions
- [scene/resources/visual_shader.cpp]() - Core node functionality implementation
- [scene/resources/visual_shader_nodes.h]() - Concrete node class declarations
- [scene/resources/visual_shader_nodes.cpp]() - Concrete node implementations
- [scene/register_scene_types.cpp:767-885]() - Node class registration49:T9188,# Shader Code Generation

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/VisualShader.xml](doc/classes/VisualShader.xml)
- [doc/classes/VisualShaderNode.xml](doc/classes/VisualShaderNode.xml)
- [doc/classes/VisualShaderNodeClamp.xml](doc/classes/VisualShaderNodeClamp.xml)
- [doc/classes/VisualShaderNodeCompare.xml](doc/classes/VisualShaderNodeCompare.xml)
- [doc/classes/VisualShaderNodeCustom.xml](doc/classes/VisualShaderNodeCustom.xml)
- [doc/classes/VisualShaderNodeParticleAccelerator.xml](doc/classes/VisualShaderNodeParticleAccelerator.xml)
- [doc/classes/VisualShaderNodeParticleBoxEmitter.xml](doc/classes/VisualShaderNodeParticleBoxEmitter.xml)
- [doc/classes/VisualShaderNodeParticleConeVelocity.xml](doc/classes/VisualShaderNodeParticleConeVelocity.xml)
- [doc/classes/VisualShaderNodeParticleEmit.xml](doc/classes/VisualShaderNodeParticleEmit.xml)
- [doc/classes/VisualShaderNodeParticleEmitter.xml](doc/classes/VisualShaderNodeParticleEmitter.xml)
- [doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml](doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml)
- [doc/classes/VisualShaderNodeParticleOutput.xml](doc/classes/VisualShaderNodeParticleOutput.xml)
- [doc/classes/VisualShaderNodeParticleRandomness.xml](doc/classes/VisualShaderNodeParticleRandomness.xml)
- [doc/classes/VisualShaderNodeParticleRingEmitter.xml](doc/classes/VisualShaderNodeParticleRingEmitter.xml)
- [doc/classes/VisualShaderNodeParticleSphereEmitter.xml](doc/classes/VisualShaderNodeParticleSphereEmitter.xml)
- [doc/classes/VisualShaderNodeSwitch.xml](doc/classes/VisualShaderNodeSwitch.xml)
- [scene/register_scene_types.cpp](scene/register_scene_types.cpp)
- [scene/resources/visual_shader.cpp](scene/resources/visual_shader.cpp)
- [scene/resources/visual_shader.h](scene/resources/visual_shader.h)
- [scene/resources/visual_shader_nodes.cpp](scene/resources/visual_shader_nodes.cpp)
- [scene/resources/visual_shader_nodes.h](scene/resources/visual_shader_nodes.h)
- [scene/resources/visual_shader_particle_nodes.cpp](scene/resources/visual_shader_particle_nodes.cpp)
- [scene/resources/visual_shader_particle_nodes.h](scene/resources/visual_shader_particle_nodes.h)
- [scene/resources/visual_shader_sdf_nodes.cpp](scene/resources/visual_shader_sdf_nodes.cpp)
- [scene/resources/visual_shader_sdf_nodes.h](scene/resources/visual_shader_sdf_nodes.h)

</details>



This page documents how the `VisualShader` class converts a node graph into GLSL shader code. It covers the code generation pipeline, the `_write_node()` traversal method, variable naming with `make_unique_id()`, and final shader assembly. For information about the visual shader graph structure and node types, see pages 11.1 (VisualShader Architecture) and 11.2 (VisualShaderNode System).

## Purpose and Scope

The shader code generation system transforms a visual shader graph (composed of interconnected `VisualShaderNode` instances) into executable GLSL shader code. The `VisualShader` class manages this transformation through several key methods:

### Key Code Generation Methods

| Method | Location | Purpose |
|--------|----------|---------|
| `VisualShader::_write_node()` | [scene/resources/visual_shader.cpp:688-1023]() | Recursively traverses node graph in dependency order |
| `make_unique_id()` | [scene/resources/visual_shader.cpp:39-42]() | Generates unique GLSL variable names for node ports |
| `VisualShader::_update_shader()` | [scene/resources/visual_shader.cpp:1039-1392]() | Assembles complete shader code and updates underlying `Shader` resource |
| `VisualShader::_queue_update()` | [scene/resources/visual_shader.cpp:147-149]() | Marks shader dirty for regeneration on next frame |

The code generation handles all shader types defined in `VisualShader::Type` enumeration (TYPE_VERTEX, TYPE_FRAGMENT, TYPE_LIGHT, particle stages, TYPE_SKY, TYPE_FOG).

**Sources:** [scene/resources/visual_shader.h:41-258](), [scene/resources/visual_shader.cpp:39-1392]()

## Code Generation Pipeline

The code generation pipeline follows a multi-phase process that builds the final shader string. The `VisualShader::_update_shader()` method orchestrates this process.

### Pipeline Overview

The following diagram shows the complete code generation flow from graph modification to final GLSL shader code:

```mermaid
flowchart TD
    Trigger["Graph Modification API Calls"]
    AddNode["VisualShader::add_node()"]
    ConnectNodes["VisualShader::connect_nodes()"]
    RemoveNode["VisualShader::remove_node()"]
    
    Queue["VisualShader::_queue_update()"]
    SetDirty["dirty.set()"]
    
    MainLoop["Main Loop Check"]
    CheckDirty["if (dirty.is_set())"]
    UpdateShader["VisualShader::_update_shader()"]
    
    InitBuilders["Initialize StringBuilders:\nglobal_code, global_code_per_node,\nglobal_code_per_func[TYPE_MAX]"]
    
    IterTypes["for (int i=0; i<TYPE_MAX; i++)"]
    CheckGraph["if (!graph[i].nodes.is_empty())"]
    WriteNode["_write_node(i, NODE_ID_OUTPUT, ...)"]
    
    ProcessVaryings["Process varyings HashMap"]
    GenerateVaryingDecls["Generate 'varying' declarations"]
    
    AssembleFunctions["Assemble shader functions:\nvoid vertex(), fragment(), light(), etc."]
    BuildFinalShader["Concatenate:\nshader_type + render_mode +\nglobals + varyings + functions"]
    
    SetCode["Shader::set_code(final_code)"]
    ClearDirty["dirty.clear()"]
    
    Trigger --> AddNode
    Trigger --> ConnectNodes
    Trigger --> RemoveNode
    AddNode --> Queue
    ConnectNodes --> Queue
    RemoveNode --> Queue
    
    Queue --> SetDirty
    SetDirty --> MainLoop
    MainLoop --> CheckDirty
    CheckDirty -->|"true"| UpdateShader
    UpdateShader --> InitBuilders
    InitBuilders --> IterTypes
    
    IterTypes --> CheckGraph
    CheckGraph -->|"has nodes"| WriteNode
    WriteNode --> IterTypes
    CheckGraph -->|"empty"| IterTypes
    
    IterTypes -->|"done"| ProcessVaryings
    ProcessVaryings --> GenerateVaryingDecls
    GenerateVaryingDecls --> AssembleFunctions
    AssembleFunctions --> BuildFinalShader
    BuildFinalShader --> SetCode
    SetCode --> ClearDirty
```

**Sources:** [scene/resources/visual_shader.cpp:147-149](), [scene/resources/visual_shader.cpp:1039-1392](), [scene/resources/visual_shader.h:147-148]()

## The _update_shader Method

The `VisualShader::_update_shader()` method is the main entry point for shader code generation. It overrides `Shader::_update_shader()` and is called when the visual shader graph is modified.

### Update Trigger and Queueing

Graph modifications trigger code regeneration through `VisualShader::_queue_update()`. The system uses a `SafeFlag dirty` member to defer updates until the next frame:

```mermaid
flowchart TD
    API["Graph Modification API"]
    
    AddNode["VisualShader::add_node(Type, node, pos, id)"]
    RemoveNode["VisualShader::remove_node(Type, id)"]
    ConnectNodes["VisualShader::connect_nodes(Type, from, from_port, to, to_port)"]
    DisconnectNodes["VisualShader::disconnect_nodes(Type, from, from_port, to, to_port)"]
    AddVarying["VisualShader::add_varying(name, mode, type)"]
    RemoveVarying["VisualShader::remove_varying(name)"]
    NodeChanged["VisualShaderNode::emit_changed()"]
    
    QueueUpdate["VisualShader::_queue_update()"]
    SetFlag["dirty.set()"]
    
    NextFrame["Next Frame"]
    UpdateCheck["Shader::_update_shader() override"]
    CheckFlag["if (dirty.is_set())"]
    Generate["VisualShader::_update_shader()"]
    ClearFlag["dirty.clear()"]
    
    API --> AddNode
    API --> RemoveNode
    API --> ConnectNodes
    API --> DisconnectNodes
    API --> AddVarying
    API --> RemoveVarying
    
    AddNode --> QueueUpdate
    RemoveNode --> QueueUpdate
    ConnectNodes --> QueueUpdate
    DisconnectNodes --> QueueUpdate
    AddVarying --> QueueUpdate
    RemoveVarying --> QueueUpdate
    NodeChanged --> QueueUpdate
    
    QueueUpdate --> SetFlag
    SetFlag --> NextFrame
    NextFrame --> UpdateCheck
    UpdateCheck --> CheckFlag
    CheckFlag -->|"true"| Generate
    Generate --> ClearFlag
```

The `SafeFlag dirty` member at [scene/resources/visual_shader.h:147]() is a thread-safe atomic flag that ensures shader updates happen asynchronously on the next frame.

**Sources:** [scene/resources/visual_shader.cpp:147-149](), [scene/resources/visual_shader.cpp:1039-1044](), [scene/resources/visual_shader.h:147](), [scene/resources/visual_shader.cpp:929-961]()

### Shader Type Processing

The update process iterates through all shader types (vertex, fragment, light, particle stages) and generates code for each:

| Shader Type | Purpose | Used In |
|-------------|---------|---------|
| `TYPE_VERTEX` | Vertex transformation | Spatial, Canvas, Sky, Fog |
| `TYPE_FRAGMENT` | Pixel/fragment processing | Spatial, Canvas, Sky, Fog |
| `TYPE_LIGHT` | Light calculation | Spatial, Canvas |
| `TYPE_START` | Particle initialization | Particles |
| `TYPE_PROCESS` | Particle update | Particles |
| `TYPE_COLLIDE` | Particle collision | Particles |
| `TYPE_START_CUSTOM` | Custom particle init | Particles |
| `TYPE_PROCESS_CUSTOM` | Custom particle update | Particles |
| `TYPE_SKY` | Sky rendering | Sky |
| `TYPE_FOG` | Fog computation | Fog |

**Sources:** [scene/resources/visual_shader.h:45-57](), [scene/resources/visual_shader.cpp:1066-1353]()

## Node Traversal and Code Generation

The `VisualShader::_write_node()` method recursively traverses the node graph in dependency order, generating code for each node. It uses depth-first traversal starting from the output node.

### _write_node Traversal Algorithm

The `VisualShader::_write_node()` method performs depth-first recursive traversal of the node graph, processing nodes in dependency order:

```mermaid
flowchart TD
    Entry["_write_node(Type p_type, int p_node, HashSet<int> &r_processed, ...)"]
    
    CheckProcessed{"p_node in r_processed?"}
    EarlyReturn["return OK"]
    
    GetNodeRef["VisualShaderNode *vsnode = graph[p_type].nodes[p_node].node.ptr()"]
    
    InputLoop["for (int i=0; i < vsnode->get_input_port_count(); i++)"]
    BuildConnKey["ConnectionKey key = {p_node, i}"]
    HasConnection{"key in p_input_connections?"}
    
    GetConnection["const Connection *c = p_input_connections[key]"]
    RecurseDependency["_write_node(p_type, c->from_node, r_processed, ...)"]
    
    PrepareInputs["Build inputs[input_port_count]:\nconnected vars or default values"]
    PrepareOutputs["Build outputs[output_port_count]:\nmake_unique_id(p_type, p_node, port_name)"]
    
    DeclareOutputs["Declare output variables in r_code:\nPortType var_name;"]
    
    HandleExpansion["if (vsnode->is_output_port_expandable(i)):\nGenerate component vars (.x, .y, .z, .w)"]
    
    AppendGlobal["p_global_code->append(vsnode->generate_global())"]
    AppendPerNode["p_global_code_per_node->append(vsnode->generate_global_per_node())"]
    AppendPerFunc["p_global_code_per_func[p_type]->append(vsnode->generate_global_per_func())"]
    
    GenerateCode["String code = vsnode->generate_code(mode, p_type, p_node, inputs, outputs, p_for_preview)"]
    AppendCode["r_code.append(code)"]
    
    MarkProcessed["r_processed.insert(p_node)"]
    ReturnSuccess["return OK"]
    
    Entry --> CheckProcessed
    CheckProcessed -->|"Yes"| EarlyReturn
    CheckProcessed -->|"No"| GetNodeRef
    
    GetNodeRef --> InputLoop
    InputLoop --> BuildConnKey
    BuildConnKey --> HasConnection
    HasConnection -->|"Yes"| GetConnection
    GetConnection --> RecurseDependency
    RecurseDependency --> InputLoop
    HasConnection -->|"No"| InputLoop
    
    InputLoop -->|"Done"| PrepareInputs
    PrepareInputs --> PrepareOutputs
    PrepareOutputs --> DeclareOutputs
    DeclareOutputs --> HandleExpansion
    
    HandleExpansion --> AppendGlobal
    AppendGlobal --> AppendPerNode
    AppendPerNode --> AppendPerFunc
    AppendPerFunc --> GenerateCode
    GenerateCode --> AppendCode
    AppendCode --> MarkProcessed
    MarkProcessed --> ReturnSuccess
```

Key data structures used:
- `HashSet<int> r_processed` - Tracks processed nodes to avoid duplicates
- `HashMap<ConnectionKey, const List<Connection>::Element *> p_input_connections` - Maps node input ports to their connections
- `StringBuilder *p_global_code`, `*p_global_code_per_node` - Accumulate global code sections
- `HashMap<Type, StringBuilder> *p_global_code_per_func` - Per-function global code

**Sources:** [scene/resources/visual_shader.cpp:688-1023](), [scene/resources/visual_shader.h:161]()

### Variable Naming Convention

The code generator uses `make_unique_id()` to create unique GLSL variable names for node ports:

### Variable Name Generation

The `make_unique_id()` function generates unique GLSL variable names by combining the port name, shader type prefix, and node ID:

```mermaid
flowchart LR
    PortName["Port Name\nnode->get_output_port_name(port)"]
    TypePrefix["Type Prefix\ntypepf[p_type]"]
    NodeID["Node ID (p_id)"]
    
    Concat["Concatenate:\np_name + '_' + typepf[p_type] + '_' + itos(p_id)"]
    
    GLSLVar["GLSL Variable Name\ne.g., 'color_frg_42'"]
    
    PortName --> Concat
    TypePrefix --> Concat
    NodeID --> Concat
    Concat --> GLSLVar
```

The function implementation at [scene/resources/visual_shader.cpp:39-42]():

```cpp
String make_unique_id(VisualShader::Type p_type, int p_id, const String &p_name) {
    static const char *typepf[VisualShader::TYPE_MAX] = {
        "vtx", "frg", "lgt", "start", "process", "collide",
        "start_custom", "process_custom", "sky", "fog"
    };
    return p_name + "_" + String(typepf[p_type]) + "_" + itos(p_id);
}
```

### Variable Naming Examples

| Node ID | Shader Type | Port Name | Generated Variable |
|---------|-------------|-----------|-------------------|
| 42 | TYPE_FRAGMENT | "color" | `color_frg_42` |
| 15 | TYPE_VERTEX | "position" | `position_vtx_15` |
| 8 | TYPE_LIGHT | "normal" | `normal_lgt_8` |
| 3 | TYPE_PROCESS | "velocity" | `velocity_process_3` |
| 7 | TYPE_SKY | "sky_color" | `sky_color_sky_7` |

**Sources:** [scene/resources/visual_shader.cpp:39-42](), [scene/resources/visual_shader.cpp:792-795]()

### Input and Output Variable Management

The `_write_node()` method builds `inputs[]` and `outputs[]` arrays to pass to `VisualShaderNode::generate_code()`. These arrays contain GLSL variable names or expressions for each port:

```mermaid
flowchart TD
    Start["Build Variable Arrays"]
    
    InitInputs["String inputs[vsnode->get_input_port_count()]"]
    LoopInputs["for (int i=0; i < input_port_count; i++)"]
    
    MakeKey["ConnectionKey key = {p_node, i}"]
    CheckConn{"key in p_input_connections?"}
    
    GetConn["const Connection *c = p_input_connections[key]"]
    FromVar["inputs[i] = make_unique_id(p_type, c->from_node, c->from_port)"]
    
    CheckDefault{"get_input_port_default_value(i) != Variant::NIL?"}
    ConvertDefault["inputs[i] = convert_variant_to_glsl(default_value)"]
    EmptyInput["inputs[i] = ''"]
    
    InitOutputs["String outputs[vsnode->get_output_port_count()]"]
    LoopOutputs["for (int i=0; i < output_port_count; i++)"]
    
    MakeName["outputs[i] = make_unique_id(p_type, p_node,\nvsnode->get_output_port_name(i))"]
    DeclareType["String type_str = get_port_type_name(vsnode->get_output_port_type(i))"]
    DeclareVar["r_code.append(type_str + ' ' + outputs[i] + ';\\n')"]
    
    CallGenerate["String code = vsnode->generate_code(mode, p_type, p_node,\ninputs, outputs, p_for_preview)"]
    
    Start --> InitInputs
    InitInputs --> LoopInputs
    LoopInputs --> MakeKey
    MakeKey --> CheckConn
    
    CheckConn -->|"Yes"| GetConn
    GetConn --> FromVar
    FromVar --> LoopInputs
    
    CheckConn -->|"No"| CheckDefault
    CheckDefault -->|"Yes"| ConvertDefault
    CheckDefault -->|"No"| EmptyInput
    ConvertDefault --> LoopInputs
    EmptyInput --> LoopInputs
    
    LoopInputs -->|"Done"| InitOutputs
    InitOutputs --> LoopOutputs
    LoopOutputs --> MakeName
    MakeName --> DeclareType
    DeclareType --> DeclareVar
    DeclareVar --> LoopOutputs
    
    LoopOutputs -->|"Done"| CallGenerate
```

The `ConnectionKey` union at [scene/resources/visual_shader.h:150-159]() packs node ID and port index into a 64-bit key:

```cpp
union ConnectionKey {
    struct {
        uint64_t node : 32;
        uint64_t port : 32;
    };
    uint64_t key = 0;
};
```

**Sources:** [scene/resources/visual_shader.cpp:792-910](), [scene/resources/visual_shader.h:150-159]()

### Port Expansion

Vector output ports can be expanded into individual component variables. The system checks `VisualShaderNode::is_output_port_expandable()` and `_is_output_port_expanded()` to determine expansion:

| Port Type | Expandable | Component Variables |
|-----------|-----------|---------------------|
| `PORT_TYPE_VECTOR_2D` | Yes | `_x`, `_y` |
| `PORT_TYPE_VECTOR_3D` | Yes | `_x`, `_y`, `_z` |
| `PORT_TYPE_VECTOR_4D` | Yes | `_x`, `_y`, `_z`, `_w` |
| `PORT_TYPE_SCALAR*` | No | N/A |
| `PORT_TYPE_BOOLEAN` | No | N/A |
| `PORT_TYPE_TRANSFORM` | No | N/A |
| `PORT_TYPE_SAMPLER` | No | N/A |

### Expansion Code Generation Example

When node 42 has an expanded `vec3` output port named "normal":

```glsl
// Generated in _write_node() at scene/resources/visual_shader.cpp:834-883
vec3 normal_frg_42;        // Base vector variable
float normal_frg_42_x;     // Component x
float normal_frg_42_y;     // Component y  
float normal_frg_42_z;     // Component z

// After node->generate_code() executes
normal_frg_42 = /* node computation */;
normal_frg_42_x = normal_frg_42.x;
normal_frg_42_y = normal_frg_42.y;
normal_frg_42_z = normal_frg_42.z;
```

Expansion is controlled by:
- `VisualShaderNode::is_output_port_expandable(int p_port)` - Returns true for single-output vector nodes [scene/resources/visual_shader.cpp:266-272]()
- `VisualShaderNode::_is_output_port_expanded(int p_port)` - Checks `expanded_output_ports` HashMap [scene/resources/visual_shader.cpp:300-305]()

**Sources:** [scene/resources/visual_shader.cpp:834-883](), [scene/resources/visual_shader.h:266-272](), [scene/resources/visual_shader.cpp:295-305]()

## Node-Level Code Generation

Individual `VisualShaderNode` subclasses implement code generation through virtual methods. Each method contributes different parts of the final shader code.

### Core Generation Methods

```mermaid
classDiagram
    class VisualShaderNode {
        <<abstract>>
        +generate_code(mode, type, id, inputs, outputs, for_preview) String*
        +generate_global(mode, type, id) String
        +generate_global_per_node(mode, id) String
        +generate_global_per_func(mode, type, id) String
        +get_default_texture_parameters(type, id) Vector
    }
    
    class VisualShaderNodeFloatConstant {
        -float constant
        +generate_code() String
    }
    
    class VisualShaderNodeTexture {
        -Ref~Texture2D~ texture
        +generate_global() String
        +generate_code() String
        +get_default_texture_parameters() Vector
    }
    
    class VisualShaderNodeCustom {
        -List~Port~ input_ports
        -List~Port~ output_ports
        +generate_global_per_node() String
        +generate_global_per_func() String
        +generate_code() String
    }
    
    VisualShaderNode <|-- VisualShaderNodeFloatConstant
    VisualShaderNode <|-- VisualShaderNodeTexture
    VisualShaderNode <|-- VisualShaderNodeCustom
```

**Sources:** [scene/resources/visual_shader.h:376-381](), [scene/resources/visual_shader.cpp:370-379]()

### Code Generation Method Hierarchy

Each `VisualShaderNode` subclass can override these virtual methods:

| Method | Scope | When Called | Purpose | Example |
|--------|-------|-------------|---------|---------|
| `generate_global()` | Per shader type, per node | Once per node per type | Type-specific uniforms, samplers | `uniform sampler2D tex_frg_10;` |
| `generate_global_per_node()` | Once per node | Once per node (all types) | Helper functions shared across shader types | `float noise_helper(vec2 p) {...}` |
| `generate_global_per_func()` | Per shader type, per node | Once per node per type | Function-scoped declarations | `// Per-function setup code` |
| `generate_code()` | Per shader type, per node | Once per node per type | Main node computation | `color_frg_42 = texture(tex_frg_10, uv_frg_8);` |

Method signatures from `VisualShaderNode`:
```cpp
virtual String generate_global(Shader::Mode p_mode, VisualShader::Type p_type, int p_id) const;
virtual String generate_global_per_node(Shader::Mode p_mode, int p_id) const;
virtual String generate_global_per_func(Shader::Mode p_mode, VisualShader::Type p_type, int p_id) const;
virtual String generate_code(Shader::Mode p_mode, VisualShader::Type p_type, int p_id, 
                             const String *p_input_vars, const String *p_output_vars, 
                             bool p_for_preview = false) const = 0;
```

**Sources:** [scene/resources/visual_shader.h:376-381](), [scene/resources/visual_shader.cpp:370-379]()

### Example: VisualShaderNodeFloatConstant

Simple constant nodes generate minimal code:

```glsl
// Node ID: 5, Type: TYPE_VERTEX, constant value: 2.5

// generate_global() - returns ""
// generate_global_per_node() - returns ""  
// generate_global_per_func() - returns ""

// generate_code() - returns:
	output_0_vtx_5 = 2.500000;
```

The `VisualShaderNodeFloatConstant::generate_code()` implementation:
```cpp
String VisualShaderNodeFloatConstant::generate_code(Shader::Mode p_mode, VisualShader::Type p_type, 
    int p_id, const String *p_input_vars, const String *p_output_vars, bool p_for_preview) const {
    return "\t" + p_output_vars[0] + " = " + vformat("%.6f", constant) + ";\n";
}
```

**Sources:** [scene/resources/visual_shader_nodes.cpp:133-135](), [scene/resources/visual_shader_nodes.h:110-136]()

### Example: VisualShaderNodeTexture

Texture nodes generate global uniforms and sampling code:

```glsl
// Node ID: 10, Type: TYPE_FRAGMENT, texture: Ref<Texture2D>

// generate_global() - generates uniform:
uniform sampler2D tex_frg_10;

// generate_code() - generates sampling:
vec4 color_frg_10;
{
	vec4 _tex_read_frg_10 = texture(tex_frg_10, uv_frg_8.xy);
	color_frg_10 = _tex_read_frg_10;
}
```

Key methods from `VisualShaderNodeTexture`:
- `get_default_texture_parameters()` - Returns texture parameter for uniform initialization
- `generate_global()` - Declares `uniform sampler2D` 
- `generate_code()` - Generates texture sampling with `texture()` GLSL function

The node handles different texture sources (SOURCE_TEXTURE, SOURCE_SCREEN, SOURCE_PORT) and texture types (TYPE_DATA, TYPE_COLOR, TYPE_NORMAL_MAP).

**Sources:** [scene/resources/visual_shader_nodes.cpp:683-882](), [scene/resources/visual_shader_nodes.h:385-449]()

### Example: VisualShaderNodeCustom

`VisualShaderNodeCustom` allows users to define custom shader nodes through GDScript by overriding virtual methods:

```gdscript
# GDScript custom node example
@tool
extends VisualShaderNodeCustom
class_name VisualShaderNodeNoise

func _get_name():
    return "Noise"

func _get_category():
    return "Custom"

func _get_output_port_count():
    return 1

func _get_output_port_type(port):
    return VisualShaderNode.PORT_TYPE_SCALAR

func _get_input_port_count():
    return 1

func _get_input_port_type(port):
    return VisualShaderNode.PORT_TYPE_VECTOR_2D

func _get_global_code(mode):
    return """
float custom_noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}
"""

func _get_code(input_vars, output_vars, mode, type):
    return "%s = custom_noise(%s);" % [output_vars[0], input_vars[0]]
```

Generated GLSL code:
```glsl
// generate_global_per_node()
// Noise
float custom_noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

// generate_code()
	{
		output_0_frg_15 = custom_noise(input_0_frg_15);
	}
```

The `VisualShaderNodeCustom` class wraps GDScript virtual calls in `generate_code()`, `generate_global_per_node()`, and `generate_global_per_func()` methods.

**Sources:** [scene/resources/visual_shader.cpp:614-679](), [scene/resources/visual_shader.h:392-488]()

## Global Code Generation

Global code sections are generated before function bodies and contain declarations that need file-level or function-level scope. The `_update_shader()` method coordinates generation of all global sections.

### Global Code Assembly Flow

```mermaid
flowchart TD
    UpdateShader["VisualShader::_update_shader()"]
    
    ShaderType["shader_type spatial/canvas_item/particles/sky/fog;"]
    RenderMode["render_mode blend_mix, depth_draw_opaque, ...;"]
    
    GlobalSB["StringBuilder global_code"]
    GlobalPerNodeSB["StringBuilder global_code_per_node"]
    GlobalPerFuncMap["HashMap<Type, StringBuilder> global_code_per_func"]
    
    IterateTypes["for (int i = 0; i < TYPE_MAX; i++)"]
    WriteNode["_write_node(type, &global_code, &global_code_per_node,\n&global_code_per_func, ...)"]
    
    VaryingGen["Generate varyings from varyings HashMap:\nfor (Varying v : varyings_list)"]
    VaryingFlat["if (v.mode == VARYING_MODE_FRAG_TO_LIGHT)\n  add 'flat' qualifier"]
    VaryingType["Convert VaryingType to GLSL type"]
    VaryingDecl["varying [flat] {type} {name};"]
    
    AssembleFinal["Assemble:\nshader_type + render_mode + global_code +\nglobal_code_per_node + varyings + functions"]
    
    UpdateShader --> ShaderType
    ShaderType --> RenderMode
    RenderMode --> GlobalSB
    GlobalSB --> GlobalPerNodeSB
    GlobalPerNodeSB --> GlobalPerFuncMap
    
    GlobalPerFuncMap --> IterateTypes
    IterateTypes --> WriteNode
    WriteNode -->|"Appends to global StringBuilders"| IterateTypes
    
    IterateTypes -->|"All types processed"| VaryingGen
    VaryingGen --> VaryingFlat
    VaryingFlat --> VaryingType
    VaryingType --> VaryingDecl
    VaryingDecl --> VaryingGen
    
    VaryingGen -->|"All varyings done"| AssembleFinal
```

**Sources:** [scene/resources/visual_shader.cpp:1066-1392](), [scene/resources/visual_shader.cpp:1255-1334]()

### Varying Generation

Varyings are declared based on the `VisualShader::varyings` HashMap and `varyings_list`:

### Varying Declaration Process

```mermaid
flowchart LR
    VaryingsMap["varyings HashMap<String, Varying>\nvaryings_list List<Varying>"]
    
    IterateList["for (Varying v : varyings_list)"]
    
    CheckMode["v.mode ==\nVARYING_MODE_FRAG_TO_LIGHT?"]
    AddFlat["qualifier = 'flat '"]
    NoFlat["qualifier = ''"]
    
    ConvertType["Convert v.type to GLSL:\nVARYING_TYPE_VECTOR_3D -> 'vec3'"]
    
    BuildDecl["varying_code +=\nqualifier + type + ' ' + v.name + ';\\n'"]
    
    VaryingsMap --> IterateList
    IterateList --> CheckMode
    CheckMode -->|"Yes"| AddFlat
    CheckMode -->|"No"| NoFlat
    AddFlat --> ConvertType
    NoFlat --> ConvertType
    ConvertType --> BuildDecl
    BuildDecl --> IterateList
```

VaryingType to GLSL type mapping:

| VaryingType Enum | GLSL Type | Godot Type |
|------------------|-----------|------------|
| `VARYING_TYPE_FLOAT` | `float` | Float |
| `VARYING_TYPE_INT` | `int` | Int |
| `VARYING_TYPE_UINT` | `uint` | Unsigned Int |
| `VARYING_TYPE_VECTOR_2D` | `vec2` | Vector2 |
| `VARYING_TYPE_VECTOR_3D` | `vec3` | Vector3 |
| `VARYING_TYPE_VECTOR_4D` | `vec4` | Vector4/Quaternion |
| `VARYING_TYPE_BOOLEAN` | `bool` | Bool |
| `VARYING_TYPE_TRANSFORM` | `mat4` | Transform3D |

VaryingMode affects qualifiers:
- `VARYING_MODE_VERTEX_TO_FRAG_LIGHT` - No qualifier, passed vertexâ†’fragmentâ†’light
- `VARYING_MODE_FRAG_TO_LIGHT` - `flat` qualifier, passed fragmentâ†’light only

**Sources:** [scene/resources/visual_shader.cpp:1255-1334](), [scene/resources/visual_shader.h:71-113](), [scene/resources/visual_shader.cpp:825-890]()

## Code Assembly

The final shader is assembled from all generated code sections by the `_update_shader()` method. The assembly follows a specific order to ensure valid GLSL.

### Assembly Order and Structure

```mermaid
flowchart TD
    Start["_update_shader() final assembly"]
    
    ShaderType["shader_type {mode};\n// mode = spatial/canvas_item/particles/sky/fog"]
    RenderMode["render_mode {modes};\n// From modes HashMap and flags HashSet"]
    
    GlobalCode["// Global code from nodes\nglobal_code.as_string()"]
    GlobalPerNode["// Per-node global helpers\nglobal_code_per_node.as_string()"]
    Varyings["// Varying declarations\nGenerated from varyings_list"]
    
    FuncLoop["for (int i = 0; i < TYPE_MAX; i++)"]
    CheckEmpty["graph[i].nodes.is_empty()?"]
    FuncHeader["void {func_name}() {\n// func_name from type_func_names[]"]
    FuncGlobal["// Per-function global code\nglobal_code_per_func[i].as_string()"]
    FuncBody["// Node code in dependency order\ncode[i].as_string()"]
    FuncFooter["}"]
    
    SetCode["set_code(final_code)\nUpdates Shader resource"]
    
    Start --> ShaderType
    ShaderType --> RenderMode
    RenderMode --> GlobalCode
    GlobalCode --> GlobalPerNode
    GlobalPerNode --> Varyings
    Varyings --> FuncLoop
    
    FuncLoop --> CheckEmpty
    CheckEmpty -->|"Has nodes"| FuncHeader
    CheckEmpty -->|"Empty"| FuncLoop
    FuncHeader --> FuncGlobal
    FuncGlobal --> FuncBody
    FuncBody --> FuncFooter
    FuncFooter --> FuncLoop
    
    FuncLoop -->|"All types done"| SetCode
```

Final shader structure:
```glsl
shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back;

// Global code from node->generate_global()
uniform sampler2D tex_frg_10;
uniform float speed_vtx_5 = 1.0;

// Global per-node code from node->generate_global_per_node()
float noise_helper(vec2 p) { /* ... */ }

// Varyings
varying vec3 var_normal;
varying flat int var_flags;

void vertex() {
    // Global per-func from node->generate_global_per_func()
    
    // Node code in dependency order
    float speed_vtx_5 = 1.0;
    vec3 position_vtx_3 = vec3(0.0);
    // ...
}

void fragment() {
    // ...
}
```

**Sources:** [scene/resources/visual_shader.cpp:1353-1392](), [scene/resources/visual_shader.cpp:1066-1353]()

### Function Name Mapping

Each `VisualShader::Type` maps to a GLSL function name through the `type_func_names` array:

| Type Enum | Index | GLSL Function | Used In Shader Mode |
|-----------|-------|---------------|---------------------|
| `TYPE_VERTEX` | 0 | `vertex()` | All modes |
| `TYPE_FRAGMENT` | 1 | `fragment()` | spatial, canvas_item, sky, fog |
| `TYPE_LIGHT` | 2 | `light()` | spatial, canvas_item |
| `TYPE_START` | 3 | `start()` | particles |
| `TYPE_PROCESS` | 4 | `process()` | particles |
| `TYPE_COLLIDE` | 5 | `collide()` | particles |
| `TYPE_START_CUSTOM` | 6 | `start_custom()` | particles |
| `TYPE_PROCESS_CUSTOM` | 7 | `process_custom()` | particles |
| `TYPE_SKY` | 8 | `sky()` | sky |
| `TYPE_FOG` | 9 | `fog()` | fog |

The mapping is implemented in `_update_shader()`:
```cpp
static const char *type_func_names[TYPE_MAX] = {
    "vertex", "fragment", "light", "start", "process", "collide",
    "start_custom", "process_custom", "sky", "fog"
};
```

Not all types are valid for all shader modes. For example, `TYPE_LIGHT` is only valid for `MODE_SPATIAL` and `MODE_CANVAS_ITEM`.

**Sources:** [scene/resources/visual_shader.cpp:1066-1078](), [scene/resources/visual_shader.h:45-57]()

### Output Port Connection Tracking

The code generator tracks output port usage through `VisualShaderNode::connected_output_ports` to optimize code generation:

### Connection Tracking Flow

```mermaid
graph TD
    ConnectCall["VisualShader::connect_nodes(from, from_port, to, to_port)"]
    GetNode["Ref<VisualShaderNode> from_node =\ngraph[type].nodes[from].node"]
    Increment["from_node->set_output_port_connected(from_port, true)\nconnected_output_ports[from_port]++"]
    
    DisconnectCall["VisualShader::disconnect_nodes(from, from_port, to, to_port)"]
    Decrement["from_node->set_output_port_connected(from_port, false)\nconnected_output_ports[from_port]--"]
    
    GenerateCall["During _write_node()"]
    CheckConnected["node->is_output_port_connected(port)\nReturns connected_output_ports[port] > 0"]
    GenerateCode["Generate code for this output"]
    SkipCode["Skip code generation (optimization)"]
    
    ConnectCall --> GetNode
    GetNode --> Increment
    
    DisconnectCall --> Decrement
    
    GenerateCall --> CheckConnected
    CheckConnected -->|"true"| GenerateCode
    CheckConnected -->|"false"| SkipCode
```

Key data structure:
```cpp
// In VisualShaderNode
HashMap<int, int> connected_output_ports;  // Maps port index to connection count
```

Methods:
- `VisualShaderNode::set_output_port_connected(int p_port, bool p_connected)` - Updates connection count
- `VisualShaderNode::is_output_port_connected(int p_port)` - Returns true if count > 0
- Called from `VisualShader::connect_nodes()` and `VisualShader::disconnect_nodes()`

**Sources:** [scene/resources/visual_shader.cpp:229-235](), [scene/resources/visual_shader.h:304-306](), [scene/resources/visual_shader.cpp:1607-1679]()

## Special Cases

### Reroute Nodes

`VisualShaderNodeReroute` nodes are handled specially in `_write_node()` - they don't generate code but pass through variable names from input to output:

```cpp
// In _write_node()
Ref<VisualShaderNodeReroute> reroute = vsnode;
if (reroute.is_valid()) {
    // For each output port, find the source through reroute chain
    String src_var = _get_variable_name_for_reroute(p_node, port_id, p_input_connections);
    inputs[i] = src_var;  // Pass through source variable
    continue;  // Don't call generate_code()
}
```

Reroutes create "virtual" connections that simplify graph organization without affecting generated shader code.

**Sources:** [scene/resources/visual_shader.cpp:964-977](), [scene/resources/visual_shader.cpp:2685-2763]()

### Parameter Nodes

Parameter nodes (`VisualShaderNodeParameter` subclasses) generate uniform declarations in `generate_global()`:

```glsl
// VisualShaderNodeFloatParameter with name "speed"
uniform float speed : hint_range(0, 10) = 1.0;

// VisualShaderNodeColorParameter with name "tint"
uniform vec4 tint : source_color = vec4(1.0, 1.0, 1.0, 1.0);

// VisualShaderNodeTextureParameter with name "albedo"
uniform sampler2D albedo : source_color;
```

Parameter nodes use `VisualShader::validate_parameter_name()` to ensure unique parameter names across the shader.

**Sources:** [scene/resources/visual_shader_nodes.cpp:5439-5890](), [scene/resources/visual_shader.cpp:2455-2489]()

### Frame Nodes

`VisualShaderNodeFrame` nodes are purely organizational for the editor and generate no shader code:

```cpp
// generate_code() returns empty string
String VisualShaderNodeFrame::generate_code(...) const {
    return String();
}
```

Frame nodes only affect visual layout in the editor through `VisualShaderNode::linked_parent_graph_frame`.

**Sources:** [scene/resources/visual_shader.cpp:688-1023](), [scene/resources/visual_shader.h:302]()

## Preview Shader Generation

The `VisualShader::generate_preview_shader()` method generates simplified shaders for previewing individual node outputs in the editor:

### Preview Shader Generation Flow

```mermaid
flowchart TD
    PreviewReq["generate_preview_shader(Type p_type, int p_node, int p_port)"]
    
    BuildGraph["Build minimal graph:\nOnly traverse dependencies\nof target node"]
    
    CreateOutput["Create temporary output node\nwith single input port"]
    ConnectToTarget["Virtual connection:\ntarget_node:p_port -> output:0"]
    
    WriteNodePreview["_write_node(p_type, ..., p_for_preview=true)\nwith modified graph"]
    
    AssignOutput["Assign output variable to:\nCOLOR (2D/Particle)\nALBEDO (3D)\nSKY_COLOR (Sky)"]
    
    WrapShader["Wrap in minimal shader:\nshader_type + function + assignment"]
    
    ReturnPreview["Return preview shader string"]
    
    PreviewReq --> BuildGraph
    BuildGraph --> CreateOutput
    CreateOutput --> ConnectToTarget
    ConnectToTarget --> WriteNodePreview
    WriteNodePreview --> AssignOutput
    AssignOutput --> WrapShader
    WrapShader --> ReturnPreview
```

Preview shader structure:
```glsl
shader_type canvas_item;

// Minimal global code for dependencies
uniform sampler2D tex_frg_10;

void fragment() {
    // Code for dependencies
    vec2 uv_frg_8 = UV;
    vec4 color_frg_10 = texture(tex_frg_10, uv_frg_8);
    
    // Assign target output to COLOR
    COLOR.rgb = color_frg_10.rgb;
    COLOR.a = color_frg_10.a;
}
```

Key differences in preview mode:
- `p_for_preview=true` passed to `generate_code()`
- Simplified output assignment (no full pipeline)
- Only includes nodes in dependency chain of target
- Used by editor to render node output thumbnails

**Sources:** [scene/resources/visual_shader.cpp:1395-1671](), [scene/resources/visual_shader.cpp:688]()

## Error Handling

The code generator includes validation and error reporting:

- Connection type compatibility checks
- Circular dependency detection
- Missing output node detection
- Invalid node configuration warnings

Nodes can report warnings through `get_warning()` which are displayed in the editor.

**Sources:** [scene/resources/visual_shader.cpp:688-1023](), [scene/resources/visual_shader.h:383]()4a:T57ee,# Particle & SDF Nodes

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [doc/classes/VisualShader.xml](doc/classes/VisualShader.xml)
- [doc/classes/VisualShaderNode.xml](doc/classes/VisualShaderNode.xml)
- [doc/classes/VisualShaderNodeClamp.xml](doc/classes/VisualShaderNodeClamp.xml)
- [doc/classes/VisualShaderNodeCompare.xml](doc/classes/VisualShaderNodeCompare.xml)
- [doc/classes/VisualShaderNodeCustom.xml](doc/classes/VisualShaderNodeCustom.xml)
- [doc/classes/VisualShaderNodeParticleAccelerator.xml](doc/classes/VisualShaderNodeParticleAccelerator.xml)
- [doc/classes/VisualShaderNodeParticleBoxEmitter.xml](doc/classes/VisualShaderNodeParticleBoxEmitter.xml)
- [doc/classes/VisualShaderNodeParticleConeVelocity.xml](doc/classes/VisualShaderNodeParticleConeVelocity.xml)
- [doc/classes/VisualShaderNodeParticleEmit.xml](doc/classes/VisualShaderNodeParticleEmit.xml)
- [doc/classes/VisualShaderNodeParticleEmitter.xml](doc/classes/VisualShaderNodeParticleEmitter.xml)
- [doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml](doc/classes/VisualShaderNodeParticleMultiplyByAxisAngle.xml)
- [doc/classes/VisualShaderNodeParticleOutput.xml](doc/classes/VisualShaderNodeParticleOutput.xml)
- [doc/classes/VisualShaderNodeParticleRandomness.xml](doc/classes/VisualShaderNodeParticleRandomness.xml)
- [doc/classes/VisualShaderNodeParticleRingEmitter.xml](doc/classes/VisualShaderNodeParticleRingEmitter.xml)
- [doc/classes/VisualShaderNodeParticleSphereEmitter.xml](doc/classes/VisualShaderNodeParticleSphereEmitter.xml)
- [doc/classes/VisualShaderNodeSwitch.xml](doc/classes/VisualShaderNodeSwitch.xml)
- [scene/register_scene_types.cpp](scene/register_scene_types.cpp)
- [scene/resources/visual_shader.cpp](scene/resources/visual_shader.cpp)
- [scene/resources/visual_shader.h](scene/resources/visual_shader.h)
- [scene/resources/visual_shader_nodes.cpp](scene/resources/visual_shader_nodes.cpp)
- [scene/resources/visual_shader_nodes.h](scene/resources/visual_shader_nodes.h)
- [scene/resources/visual_shader_particle_nodes.cpp](scene/resources/visual_shader_particle_nodes.cpp)
- [scene/resources/visual_shader_particle_nodes.h](scene/resources/visual_shader_particle_nodes.h)
- [scene/resources/visual_shader_sdf_nodes.cpp](scene/resources/visual_shader_sdf_nodes.cpp)
- [scene/resources/visual_shader_sdf_nodes.h](scene/resources/visual_shader_sdf_nodes.h)

</details>



This page documents the specialized visual shader nodes for particle systems and signed distance field (SDF) operations in Godot's Visual Shader system. These nodes extend the base `VisualShaderNode` functionality to provide particle emission, transformation, and 2D SDF-based rendering capabilities.

For general visual shader architecture and node types, see [Visual Shader System](#11). For shader code generation details, see [Shader Code Generation](#11.3). For the base node system, see [VisualShaderNode System](#11.2).

---

## System Architecture

The particle and SDF node subsystems are specialized extensions of the visual shader framework, designed for specific shader modes (`TYPE_START`, `TYPE_PROCESS`, `TYPE_COLLIDE` for particles and canvas item shaders for SDF operations).

```mermaid
graph TB
    subgraph "Base Infrastructure"
        VisualShaderNode["VisualShaderNode<br/>(Base Class)"]
        VisualShader["VisualShader<br/>(Shader Resource)"]
    end
    
    subgraph "Particle Node Hierarchy"
        ParticleEmitter["VisualShaderNodeParticleEmitter<br/>(Abstract Base)"]
        SphereEmitter["VisualShaderNodeParticleSphereEmitter"]
        BoxEmitter["VisualShaderNodeParticleBoxEmitter"]
        RingEmitter["VisualShaderNodeParticleRingEmitter"]
        MeshEmitter["VisualShaderNodeParticleMeshEmitter"]
        
        ParticleProcess["Particle Process Nodes"]
        MultiplyByAxisAngle["VisualShaderNodeParticleMultiplyByAxisAngle"]
        ConeVelocity["VisualShaderNodeParticleConeVelocity"]
        Randomness["VisualShaderNodeParticleRandomness"]
        Accelerator["VisualShaderNodeParticleAccelerator"]
        Emit["VisualShaderNodeParticleEmit"]
    end
    
    subgraph "SDF Node Hierarchy"
        SDFToScreenUV["VisualShaderNodeSDFToScreenUV"]
        ScreenUVToSDF["VisualShaderNodeScreenUVToSDF"]
        TextureSDF["VisualShaderNodeTextureSDF"]
        TextureSDFNormal["VisualShaderNodeTextureSDFNormal"]
        SDFRaymarch["VisualShaderNodeSDFRaymarch"]
    end
    
    VisualShaderNode --> ParticleEmitter
    VisualShaderNode --> ParticleProcess
    VisualShaderNode --> SDFToScreenUV
    VisualShaderNode --> ScreenUVToSDF
    VisualShaderNode --> TextureSDF
    VisualShaderNode --> TextureSDFNormal
    VisualShaderNode --> SDFRaymarch
    
    ParticleEmitter --> SphereEmitter
    ParticleEmitter --> BoxEmitter
    ParticleEmitter --> RingEmitter
    ParticleEmitter --> MeshEmitter
    
    ParticleProcess --> MultiplyByAxisAngle
    ParticleProcess --> ConeVelocity
    ParticleProcess --> Randomness
    ParticleProcess --> Accelerator
    ParticleProcess --> Emit
    
    VisualShader --> VisualShaderNode
```

**Node Categories**

| Category | Purpose | Shader Types |
|----------|---------|--------------|
| Particle Emitters | Define initial particle positions | `TYPE_START`, `TYPE_START_CUSTOM` |
| Particle Process | Transform/modify particle properties | `TYPE_PROCESS`, `TYPE_PROCESS_CUSTOM` |
| SDF Operations | 2D signed distance field sampling | `TYPE_FRAGMENT` (canvas shaders) |

Sources: [scene/resources/visual_shader_particle_nodes.h:39-163](), [scene/resources/visual_shader_sdf_nodes.h:35-151]()

---

## Particle Emitter Nodes

Particle emitters define the initial spatial position of particles in the "start" phase of particle shaders. All emitter nodes derive from `VisualShaderNodeParticleEmitter` and output a position vector.

### Base Emitter Class: VisualShaderNodeParticleEmitter

The base class provides common functionality for all particle emitters:

**Key Properties:**
- `mode_2d` (bool): Projects output to 2D space when enabled
- Category: `CATEGORY_PARTICLE`
- Output Port: Single vector port (Vector2 in 2D mode, Vector3 in 3D mode) named "position"

**Port Configuration:**
```cpp
// Output type switches based on mode_2d flag
PortType get_output_port_type(int p_port) const {
    if (mode_2d) {
        return PORT_TYPE_VECTOR_2D;
    }
    return PORT_TYPE_VECTOR_3D;
}
```

Sources: [scene/resources/visual_shader_particle_nodes.h:39-62](), [scene/resources/visual_shader_particle_nodes.cpp:36-96]()

### VisualShaderNodeParticleSphereEmitter

Emits particles randomly within a spherical volume (or circular area in 2D mode).

**Input Ports:**

| Port | Type | Name | Default | Description |
|------|------|------|---------|-------------|
| 0 | Scalar | `radius` | 10.0 | Outer radius of sphere/circle |
| 1 | Scalar | `inner_radius` | 0.0 | Inner radius (creates hollow sphere) |

**Code Generation:**

The node generates helper functions for random point selection:
```glsl
// 2D mode
vec2 __get_random_point_in_circle(inout uint seed, float radius, float inner_radius)

// 3D mode  
vec3 __get_random_point_in_sphere(inout uint seed, float radius, float inner_radius)
```

These functions use `__get_random_unit_vec2/vec3` and `__randf_range` to distribute points uniformly within the specified radii.

Sources: [scene/resources/visual_shader_particle_nodes.h:64-78](), [scene/resources/visual_shader_particle_nodes.cpp:98-150]()

### VisualShaderNodeParticleBoxEmitter

Emits particles randomly within a box volume (or rectangular area in 2D mode).

**Input Ports:**

| Port | Type | Name | Default | Description |
|------|------|------|---------|-------------|
| 0 | Vector3/Vector2 | `extents` | (1,1,1) | Box dimensions |

**Important:** The input port type switches dynamically based on `mode_2d`:
- 2D mode: `PORT_TYPE_VECTOR_2D`
- 3D mode: `PORT_TYPE_VECTOR_3D`

**Code Generation:**
```glsl
// Generates points within [-half_extents, half_extents] range
vec3 __get_random_point_in_box3d(inout uint seed, vec3 extents)
```

Sources: [scene/resources/visual_shader_particle_nodes.h:80-95](), [scene/resources/visual_shader_particle_nodes.cpp:152-220]()

### VisualShaderNodeParticleRingEmitter

Emits particles on a ring/torus shape (or circle edge in 2D mode).

**Input Ports:**

| Port | Type | Name | Default | Description |
|------|------|------|---------|-------------|
| 0 | Scalar | `radius` | 10.0 | Ring radius |
| 1 | Scalar | `inner_radius` | 0.0 | Inner radius cutoff |
| 2 | Scalar | `height` | 0.0 | Vertical extent (3D only) |

**Code Generation:**
```glsl
// Uses angular distribution for uniform ring coverage
float angle = __rand_from_seed(seed) * TAU;
vec2 ring = vec2(sin(angle), cos(angle)) * __randf_range(seed, inner_radius, radius);
```

Sources: [scene/resources/visual_shader_particle_nodes.h:97-111](), [scene/resources/visual_shader_particle_nodes.cpp:222-281]()

### VisualShaderNodeParticleMeshEmitter

Emits particles from mesh surface vertices, with support for vertex attributes (position, normal, color, UV).

**Input Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Scalar | `randomness` | Controls sampling randomness |

**Output Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector3/Vector2 | `position` | Vertex position |
| 1 | Vector3/Vector2 | `normal` | Vertex normal |
| 2 | Vector3 | `color` | Vertex color (RGB) |
| 3 | Scalar | `alpha` | Vertex alpha |
| 4 | Vector2 | `uv` | Primary UV coordinates |
| 5 | Vector2 | `uv2` | Secondary UV coordinates |

**Texture-Based Sampling:**

The mesh emitter converts mesh data into `ImageTexture` resources for GPU sampling:
- Stores vertex attributes in RGBA32F format textures
- Updates textures when mesh or surface selection changes
- Generates global uniforms for texture access

```mermaid
graph LR
    Mesh["Mesh Resource"] --> SurfaceData["Surface Arrays<br/>(Positions, Normals, etc)"]
    SurfaceData --> TextureConversion["_update_textures()"]
    TextureConversion --> PosTexture["position_texture"]
    TextureConversion --> NormalTexture["normal_texture"]
    TextureConversion --> ColorTexture["color_texture"]
    TextureConversion --> UVTexture["uv_texture"]
    TextureConversion --> UV2Texture["uv2_texture"]
    
    PosTexture --> ShaderUniforms["Shader Uniforms"]
    NormalTexture --> ShaderUniforms
    ColorTexture --> ShaderUniforms
    UVTexture --> ShaderUniforms
    UV2Texture --> ShaderUniforms
```

**Properties:**

| Property | Type | Description |
|----------|------|-------------|
| `mesh` | Ref\<Mesh\> | Source mesh for emission |
| `use_all_surfaces` | bool | Sample from all surfaces vs single surface |
| `surface_index` | int | Selected surface when not using all |

Sources: [scene/resources/visual_shader_particle_nodes.h:113-163](), [scene/resources/visual_shader_particle_nodes.cpp:283-538]()

---

## Particle Process Nodes

Process nodes transform and modify particle properties during the "process" phase. These nodes typically manipulate velocity, rotation, or custom data.

### VisualShaderNodeParticleMultiplyByAxisAngle

Multiplies a position vector by a rotation around an axis, typically used with emitters.

**Input Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector3 | `position` | Input position |
| 1 | Vector3 | `axis` | Rotation axis |
| 2 | Scalar | `angle` | Rotation angle |

**Output Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector3 | `position` | Rotated position |

**Properties:**
- `degrees_mode` (bool): Interprets angle in degrees vs radians

**Code Generation:**
```glsl
// Generates quaternion-based rotation
__build_rotation_mat3(normalize(axis), angle) * position
```

Sources: [scene/resources/visual_shader_particle_nodes.h:165-185](), [scene/resources/visual_shader_particle_nodes.cpp:540-632]()

### VisualShaderNodeParticleConeVelocity

Generates velocity vectors within a cone shape, useful for directional particle streams.

**Input Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector3 | `direction` | Cone axis direction |
| 1 | Scalar | `spread` | Cone angle in degrees |
| 2 | Scalar | `velocity` | Speed magnitude |

**Code Generation:**

Uses spherical coordinate distribution to generate uniform cone spread:
```glsl
float angle_rand = __rand_from_seed(__seed) * spread_rad;
float rotate_rand = __rand_from_seed(__seed) * TAU;
// Applies rotation to align with direction
```

Sources: [scene/resources/visual_shader_particle_nodes.h:187-200](), [scene/resources/visual_shader_particle_nodes.cpp:634-692]()

### VisualShaderNodeParticleRandomness

Generates random values between min and max for various data types.

**Operation Types:**

| OpType | Enum | Port Type | Description |
|--------|------|-----------|-------------|
| Scalar | `OP_TYPE_SCALAR` | `PORT_TYPE_SCALAR` | Float randomness |
| Vector2 | `OP_TYPE_VECTOR_2D` | `PORT_TYPE_VECTOR_2D` | 2D vector randomness |
| Vector3 | `OP_TYPE_VECTOR_3D` | `PORT_TYPE_VECTOR_3D` | 3D vector randomness |
| Vector4 | `OP_TYPE_VECTOR_4D` | `PORT_TYPE_VECTOR_4D` | 4D vector randomness |

**Input Ports:**

| Port | Name | Description |
|------|------|-------------|
| 0 | `min` | Minimum value |
| 1 | `max` | Maximum value |

**Code Generation:**
```glsl
// Component-wise random range for vectors
output = vec3(
    __randf_range(__seed, min.x, max.x),
    __randf_range(__seed, min.y, max.y),
    __randf_range(__seed, min.z, max.z)
);
```

Sources: [scene/resources/visual_shader_particle_nodes.h:202-220](), [scene/resources/visual_shader_particle_nodes.cpp:694-863]()

### VisualShaderNodeParticleAccelerator

Applies acceleration to particles in various modes.

**Acceleration Modes:**

| Mode | Enum | Description |
|------|------|-------------|
| Linear | `MODE_LINEAR` | Acceleration along velocity direction |
| Radial | `MODE_RADIAL` | Acceleration toward/away from center |
| Tangential | `MODE_TANGENTIAL` | Perpendicular to radial direction |

**Input Ports:**

| Port | Type | Name | Used In Modes |
|------|------|------|---------------|
| 0 | Vector3 | `amount` | All modes |
| 1 | Vector3 | `center` | Radial, Tangential |
| 2 | Vector3 | `velocity` | All modes |

**Output Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector3 | `velocity` | Updated velocity |

**Code Generation Examples:**
```glsl
// Radial mode
vec3 org_velocity = velocity;
vec3 rel_vec = normalize(transform - center);
velocity += length(org_velocity) > 0.0 ? rel_vec * dot(rel_vec, org_velocity) * amount : vec3(0.0);

// Tangential mode  
vec3 tangent = normalize(cross(cross(center, velocity), center));
velocity += tangent * amount;
```

Sources: [scene/resources/visual_shader_particle_nodes.h:222-241](), [scene/resources/visual_shader_particle_nodes.cpp:865-1012]()

### VisualShaderNodeParticleEmit

Triggers sub-particle emission with customizable properties.

**Input Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Transform | `transform` | Sub-particle transform |
| 1 | Vector3 | `velocity` | Sub-particle velocity |
| 2 | Vector4 | `color` | Sub-particle color |
| 3 | Vector4 | `custom` | Custom data |

**Emit Flags:**

| Flag | Value | Description |
|------|-------|-------------|
| `EMIT_FLAG_POSITION` | 1 | Override position |
| `EMIT_FLAG_ROT_SCALE` | 2 | Override rotation/scale |
| `EMIT_FLAG_VELOCITY` | 4 | Override velocity |
| `EMIT_FLAG_COLOR` | 8 | Override color |
| `EMIT_FLAG_CUSTOM` | 16 | Override custom data |

**Code Generation:**
```glsl
// Calls built-in emit function with flags
emit_subparticle(transform, velocity, vec4(1.0), vec4(0.0), flags);
```

Sources: [scene/resources/visual_shader_particle_nodes.h:243-269](), [scene/resources/visual_shader_particle_nodes.cpp:1014-1157]()

### VisualShaderNodeParticleOutput

Defines output values for particle emission. Available ports vary by shader type (`TYPE_START`, `TYPE_PROCESS`, `TYPE_COLLIDE`) and custom data usage.

Sources: [scene/resources/visual_shader_particle_nodes.h:271-272]()

---

## SDF (Signed Distance Field) Nodes

SDF nodes provide 2D signed distance field operations for canvas item shaders. These nodes enable effects like soft shadows, outlines, and distance-based rendering in 2D.

```mermaid
graph TB
    ScreenUV["Screen UV<br/>(Viewport coordinates)"] --> ScreenUVToSDF["ScreenUVToSDF"]
    ScreenUVToSDF --> SDFPos["SDF Position<br/>(Distance field space)"]
    
    SDFPos --> TextureSDF["TextureSDF<br/>(Sample distance)"]
    SDFPos --> TextureSDFNormal["TextureSDFNormal<br/>(Sample gradient)"]
    SDFPos --> SDFRaymarch["SDFRaymarch<br/>(Ray intersection)"]
    
    TextureSDF --> Distance["Distance Value"]
    TextureSDFNormal --> Normal["Normal Vector"]
    SDFRaymarch --> Hit["Hit Info"]
    
    SDFPos --> SDFToScreenUV["SDFToScreenUV"]
    SDFToScreenUV --> BackToScreen["Screen UV"]
```

### Coordinate Conversion Nodes

#### VisualShaderNodeScreenUVToSDF

Converts screen UV coordinates to SDF space coordinates.

**Input Ports:**

| Port | Type | Name | Default | Description |
|------|------|------|---------|-------------|
| 0 | Vector2 | `uv` | `SCREEN_UV` | Screen UV coordinates |

**Output Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector2 | (unnamed) | SDF space position |

**Code Generation:**
```glsl
output = screen_uv_to_sdf(SCREEN_UV);
```

Sources: [scene/resources/visual_shader_sdf_nodes.h:56-75](), [scene/resources/visual_shader_sdf_nodes.cpp:70-112]()

#### VisualShaderNodeSDFToScreenUV

Converts SDF space coordinates back to screen UV coordinates.

**Input Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector2 | `sdf_pos` | SDF space position |

**Code Generation:**
```glsl
output = sdf_to_screen_uv(sdf_pos);
```

Sources: [scene/resources/visual_shader_sdf_nodes.h:35-54](), [scene/resources/visual_shader_sdf_nodes.cpp:33-68]()

### SDF Sampling Nodes

#### VisualShaderNodeTextureSDF

Samples the signed distance field at a given position, returning the distance to the nearest surface.

**Input Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector2 | `sdf_pos` | Sample position in SDF space |

**Output Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Scalar | (unnamed) | Distance to surface (negative inside) |

**Code Generation:**
```glsl
output = texture_sdf(sdf_pos);
```

Sources: [scene/resources/visual_shader_sdf_nodes.h:77-93](), [scene/resources/visual_shader_sdf_nodes.cpp:114-149]()

#### VisualShaderNodeTextureSDFNormal

Samples the SDF gradient to compute surface normals.

**Input Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector2 | `sdf_pos` | Sample position in SDF space |

**Output Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector2 | (unnamed) | Normal vector at position |

**Code Generation:**
```glsl
output = texture_sdf_normal(sdf_pos);
```

Sources: [scene/resources/visual_shader_sdf_nodes.h:95-111](), [scene/resources/visual_shader_sdf_nodes.cpp:151-186]()

### VisualShaderNodeSDFRaymarch

Performs raymarching through the signed distance field to find intersections.

**Input Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Vector2 | `from` | Ray origin in SDF space |
| 1 | Vector2 | `to` | Ray target in SDF space |

**Output Ports:**

| Port | Type | Name | Description |
|------|------|------|-------------|
| 0 | Scalar | `distance` | Distance traveled along ray |
| 1 | Boolean | `hit` | Whether ray hit a surface |
| 2 | Vector2 | `end` | Ray end position |

**Code Generation:**
```glsl
// Returns: vec3(distance_traveled, hit ? 1.0 : 0.0, unused)
vec3 result = sdf_to_screen_uv(from);
output_distance = result.x;
output_hit = result.y > 0.5;
output_end = from + normalize(to - from) * result.x;
```

Sources: [scene/resources/visual_shader_sdf_nodes.h:113-151](), [scene/resources/visual_shader_sdf_nodes.cpp:188-264]()

---

## Node Registration

All particle and SDF nodes are registered in the scene type initialization system:

**Particle Nodes:**
```cpp
GDREGISTER_CLASS(VisualShaderNodeParticleOutput);
GDREGISTER_ABSTRACT_CLASS(VisualShaderNodeParticleEmitter);
GDREGISTER_CLASS(VisualShaderNodeParticleSphereEmitter);
GDREGISTER_CLASS(VisualShaderNodeParticleBoxEmitter);
GDREGISTER_CLASS(VisualShaderNodeParticleRingEmitter);
GDREGISTER_CLASS(VisualShaderNodeParticleMeshEmitter);
GDREGISTER_CLASS(VisualShaderNodeParticleMultiplyByAxisAngle);
GDREGISTER_CLASS(VisualShaderNodeParticleConeVelocity);
GDREGISTER_CLASS(VisualShaderNodeParticleRandomness);
GDREGISTER_CLASS(VisualShaderNodeParticleAccelerator);
GDREGISTER_CLASS(VisualShaderNodeParticleEmit);
```

**SDF Nodes:**
```cpp
GDREGISTER_CLASS(VisualShaderNodeSDFToScreenUV);
GDREGISTER_CLASS(VisualShaderNodeScreenUVToSDF);
GDREGISTER_CLASS(VisualShaderNodeTextureSDF);
GDREGISTER_CLASS(VisualShaderNodeTextureSDFNormal);
GDREGISTER_CLASS(VisualShaderNodeSDFRaymarch);
```

Sources: [scene/register_scene_types.cpp:868-885]()

---

## Code Generation Pattern

Both particle and SDF nodes follow the `VisualShaderNode` code generation contract:

**Global Code Generation:**
- `generate_global_per_node()`: Defines helper functions (e.g., random point generators)
- `generate_global()`: Defines uniforms (e.g., mesh emitter textures)

**Local Code Generation:**
- `generate_code()`: Emits GLSL statements for node operation
- Uses `p_input_vars` array for input variable names
- Uses `p_output_vars` array for output variable names
- Falls back to default values when inputs are disconnected

**Example Pattern:**
```cpp
String generate_code(...) const {
    String code;
    // Handle disconnected inputs with defaults
    String input0 = p_input_vars[0].is_empty() ? 
        String(get_input_port_default_value(0)) : 
        p_input_vars[0];
    
    // Generate operation
    code += "    " + p_output_vars[0] + " = some_function(" + input0 + ");\n";
    return code;
}
```

Sources: [scene/resources/visual_shader_particle_nodes.cpp:121-145](), [scene/resources/visual_shader_sdf_nodes.cpp:63-65]()5:["$","$L15",null,{"repoName":"godotengine/godot","hasConfig":false,"canSteer":true,"children":["$","$L16",null,{"wiki":{"metadata":{"repo_name":"godotengine/godot","commit_hash":"5002677a","generated_at":"2026-01-13T20:31:47.635364","config":null,"config_source":"none"},"pages":[{"page_plan":{"id":"1","title":"Godot Engine Overview"},"content":"$17"},{"page_plan":{"id":"1.1","title":"Major Systems"},"content":"$18"},{"page_plan":{"id":"2","title":"Build System"},"content":"$19"},{"page_plan":{"id":"2.1","title":"Build Configuration"},"content":"$1a"},{"page_plan":{"id":"2.2","title":"Platform Detection"},"content":"$1b"},{"page_plan":{"id":"2.3","title":"Module System"},"content":"$1c"},{"page_plan":{"id":"3","title":"Engine Core"},"content":"$1d"},{"page_plan":{"id":"3.1","title":"Engine Initialization"},"content":"$1e"},{"page_plan":{"id":"3.2","title":"OS Abstraction Layer"},"content":"$1f"},{"page_plan":{"id":"3.3","title":"ProjectSettings & EditorSettings"},"content":"$20"},{"page_plan":{"id":"3.4","title":"Core Types & String System"},"content":"$21"},{"page_plan":{"id":"4","title":"Scene System"},"content":"$22"},{"page_plan":{"id":"4.1","title":"Node Hierarchy"},"content":"$23"},{"page_plan":{"id":"4.2","title":"SceneTree & MainLoop"},"content":"$24"},{"page_plan":{"id":"4.3","title":"Viewport System"},"content":"$25"},{"page_plan":{"id":"4.4","title":"Control & UI System"},"content":"$26"},{"page_plan":{"id":"4.5","title":"Window Management"},"content":"$27"},{"page_plan":{"id":"5","title":"Resource System"},"content":"$28"},{"page_plan":{"id":"5.1","title":"ResourceLoader"},"content":"$29"},{"page_plan":{"id":"5.2","title":"Resource Class"},"content":"$2a"},{"page_plan":{"id":"5.3","title":"Resource Cache"},"content":"$2b"},{"page_plan":{"id":"5.4","title":"Resource Import System"},"content":"$2c"},{"page_plan":{"id":"5.5","title":"ResourceSaver"},"content":"$2d"},{"page_plan":{"id":"6","title":"GDScript System"},"content":"$2e"},{"page_plan":{"id":"6.1","title":"GDScript Parser"},"content":"$2f"},{"page_plan":{"id":"6.2","title":"GDScript Analyzer"},"content":"$30"},{"page_plan":{"id":"6.3","title":"GDScript Compiler & VM"},"content":"$31"},{"page_plan":{"id":"6.4","title":"GDScript Runtime & Cache"},"content":"$32"},{"page_plan":{"id":"7","title":"Editor Core"},"content":"$33"},{"page_plan":{"id":"7.1","title":"EditorNode"},"content":"$34"},{"page_plan":{"id":"7.2","title":"EditorData"},"content":"$35"},{"page_plan":{"id":"7.3","title":"EditorInterface"},"content":"$36"},{"page_plan":{"id":"7.4","title":"EditorPlugin System"},"content":"$37"},{"page_plan":{"id":"7.5","title":"Scene Management"},"content":"$38"},{"page_plan":{"id":"8","title":"Editor Plugins"},"content":"$39"},{"page_plan":{"id":"8.1","title":"CanvasItem Editor"},"content":"$3a"},{"page_plan":{"id":"8.2","title":"Node3D Editor"},"content":"$3b"},{"page_plan":{"id":"8.3","title":"Gizmo System"},"content":"$3c"},{"page_plan":{"id":"9","title":"Editor UI Tools"},"content":"$3d"},{"page_plan":{"id":"9.1","title":"FileSystem Dock"},"content":"$3e"},{"page_plan":{"id":"9.2","title":"Script Editor"},"content":"$3f"},{"page_plan":{"id":"9.3","title":"EditorLog & Output"},"content":"$40"},{"page_plan":{"id":"10","title":"Text Components"},"content":"$41"},{"page_plan":{"id":"10.1","title":"TextEdit & CodeEdit"},"content":"$42"},{"page_plan":{"id":"10.2","title":"Text Shaping System"},"content":"$43"},{"page_plan":{"id":"10.3","title":"RichTextLabel"},"content":"$44"},{"page_plan":{"id":"10.4","title":"Label & LineEdit"},"content":"$45"},{"page_plan":{"id":"11","title":"Visual Shader System"},"content":"$46"},{"page_plan":{"id":"11.1","title":"VisualShader Architecture"},"content":"$47"},{"page_plan":{"id":"11.2","title":"VisualShaderNode System"},"content":"$48"},{"page_plan":{"id":"11.3","title":"Shader Code Generation"},"content":"$49"},{"page_plan":{"id":"11.4","title":"Particle & SDF Nodes"},"content":"$4a"}]},"children":"$L4b"}]}]
6:[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"TechArticle\",\"headline\":\"Godot Engine Overview\",\"description\":\"This page provides a high-level introduction to the Godot Engine codebase architecture, covering its major systems, initialization flow, and how components interact. It serves as the entry point for u\",\"image\":\"https://deepwiki.com/godotengine/godot/og-image.png\",\"datePublished\":\"2026-01-13T20:31:47.635364\",\"dateModified\":\"2026-01-13T20:31:47.635364\",\"author\":{\"@type\":\"Organization\",\"name\":\"DeepWiki\",\"url\":\"https://deepwiki.com\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"DeepWiki\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://deepwiki.com/icon.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://deepwiki.com/godotengine/godot\"}}"}}],["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]
e:{"metadata":[["$","title","0",{"children":"godotengine/godot | DeepWiki"}],["$","meta","1",{"name":"description","content":"This page provides a high-level introduction to the Godot Engine codebase architecture, covering its major systems, initialization flow, and how components interact. It serves as the entry point for u"}],["$","meta","2",{"name":"keywords","content":"godotengine/godot,godotengine,godot,documentation,wiki,codebase,AI documentation,Devin,Godot Engine Overview"}],["$","link","3",{"rel":"canonical","href":"https://deepwiki.com/godotengine/godot"}],["$","meta","4",{"property":"og:title","content":"godotengine/godot | DeepWiki"}],["$","meta","5",{"property":"og:description","content":"This page provides a high-level introduction to the Godot Engine codebase architecture, covering its major systems, initialization flow, and how components interact. It serves as the entry point for u"}],["$","meta","6",{"property":"og:url","content":"https://deepwiki.com/godotengine/godot"}],["$","meta","7",{"property":"og:site_name","content":"DeepWiki"}],["$","meta","8",{"property":"og:image","content":"https://deepwiki.com/godotengine/godot/og-image.png?page=1"}],["$","meta","9",{"property":"og:type","content":"website"}],["$","meta","10",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","11",{"name":"twitter:site","content":"@cognition"}],["$","meta","12",{"name":"twitter:creator","content":"@cognition"}],["$","meta","13",{"name":"twitter:title","content":"godotengine/godot | DeepWiki"}],["$","meta","14",{"name":"twitter:description","content":"This page provides a high-level introduction to the Godot Engine codebase architecture, covering its major systems, initialization flow, and how components interact. It serves as the entry point for u"}],["$","meta","15",{"name":"twitter:image","content":"https://deepwiki.com/godotengine/godot/og-image.png?page=1"}],["$","link","16",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"48x48"}],["$","link","17",{"rel":"icon","href":"/icon.png?1ee4c6a68a73a205","type":"image/png","sizes":"48x48"}],["$","link","18",{"rel":"apple-touch-icon","href":"/apple-icon.png?a4f658907db0ab87","type":"image/png","sizes":"180x180"}],["$","$L4c","19",{}]],"error":null,"digest":"$undefined"}
13:"$e:metadata"
4b:["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]
