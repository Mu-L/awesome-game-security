Project Path: arc_xan105_Mini-Launcher_26e4lc82

Source Tree:

```txt
arc_xan105_Mini-Launcher_26e4lc82
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ banner.png
â”œâ”€â”€ banner@2x.png
â”œâ”€â”€ build.cmd
â”œâ”€â”€ build.sh
â”œâ”€â”€ dist
â”‚   â”œâ”€â”€ URL.url
â”‚   â”œâ”€â”€ launcher.json
â”‚   â””â”€â”€ lua
â”‚       â””â”€â”€ Examples on GitHub.url
â”œâ”€â”€ example
â”‚   â”œâ”€â”€ config
â”‚   â”‚   â”œâ”€â”€ AoE2-DE
â”‚   â”‚   â”‚   â”œâ”€â”€ launcher.json
â”‚   â”‚   â”‚   â””â”€â”€ launcher.lua
â”‚   â”‚   â”œâ”€â”€ C&C3 Kane's Wrath
â”‚   â”‚   â”‚   â”œâ”€â”€ keygen.lua
â”‚   â”‚   â”‚   â””â”€â”€ launcher.json
â”‚   â”‚   â”œâ”€â”€ FEAR
â”‚   â”‚   â”‚   â”œâ”€â”€ launcher.json
â”‚   â”‚   â”‚   â”œâ”€â”€ launcher.lua
â”‚   â”‚   â”‚   â”œâ”€â”€ xp.json
â”‚   â”‚   â”‚   â””â”€â”€ xp2.json
â”‚   â”‚   â”œâ”€â”€ No Man's Sky
â”‚   â”‚   â”‚   â”œâ”€â”€ launcher.json
â”‚   â”‚   â”‚   â”œâ”€â”€ launcher.lua
â”‚   â”‚   â”‚   â””â”€â”€ patch.lua
â”‚   â”‚   â”œâ”€â”€ Quake 3
â”‚   â”‚   â”‚   â”œâ”€â”€ keygen.lua
â”‚   â”‚   â”‚   â””â”€â”€ launcher.json
â”‚   â”‚   â”œâ”€â”€ Quake 4
â”‚   â”‚   â”‚   â””â”€â”€ launcher.json
â”‚   â”‚   â”œâ”€â”€ Red Alert 3
â”‚   â”‚   â”‚   â”œâ”€â”€ keygen.lua
â”‚   â”‚   â”‚   â””â”€â”€ launcher.json
â”‚   â”‚   â”œâ”€â”€ Split Fiction
â”‚   â”‚   â”‚   â”œâ”€â”€ launcher.json
â”‚   â”‚   â”‚   â””â”€â”€ launcher.lua
â”‚   â”‚   â”œâ”€â”€ Telltale Walking Dead
â”‚   â”‚   â”‚   â”œâ”€â”€ launcher.json
â”‚   â”‚   â”‚   â””â”€â”€ launcher.lua
â”‚   â”‚   â””â”€â”€ XCOM2
â”‚   â”‚       â”œâ”€â”€ launcher.json
â”‚   â”‚       â”œâ”€â”€ launcher.lua
â”‚   â”‚       â””â”€â”€ splash.bmp
â”‚   â””â”€â”€ lua script
â”‚       â”œâ”€â”€ keygen
â”‚       â”‚   â”œâ”€â”€ Quake 3 Arena.lua
â”‚       â”‚   â””â”€â”€ Red Alert 3.lua
â”‚       â”œâ”€â”€ mods
â”‚       â”‚   â”œâ”€â”€ EAX (DSOAL) CLSID.lua
â”‚       â”‚   â””â”€â”€ XCOM2.lua
â”‚       â”œâ”€â”€ playtime
â”‚       â”‚   â””â”€â”€ playtime.lua
â”‚       â”œâ”€â”€ steam emu
â”‚       â”‚   â”œâ”€â”€ CDX-RUNE.lua
â”‚       â”‚   â”œâ”€â”€ GBE Fork.lua
â”‚       â”‚   â”œâ”€â”€ GSE.lua
â”‚       â”‚   â””â”€â”€ steamclient.lua
â”‚       â””â”€â”€ updater
â”‚           â”œâ”€â”€ FFNx (semver).lua
â”‚           â””â”€â”€ Quake3e (timestamp).lua
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ addons.go
â”‚   â”œâ”€â”€ alert.go
â”‚   â”œâ”€â”€ attrib.go
â”‚   â”œâ”€â”€ cmdLine.go
â”‚   â”œâ”€â”€ compatibility.go
â”‚   â”œâ”€â”€ config.go
â”‚   â”œâ”€â”€ go.mod
â”‚   â”œâ”€â”€ go.sum
â”‚   â”œâ”€â”€ integrity.go
â”‚   â”œâ”€â”€ internal
â”‚   â”‚   â”œâ”€â”€ affinity
â”‚   â”‚   â”‚   â””â”€â”€ affinity.go
â”‚   â”‚   â”œâ”€â”€ elevated
â”‚   â”‚   â”‚   â””â”€â”€ elevated.go
â”‚   â”‚   â”œâ”€â”€ expand
â”‚   â”‚   â”‚   â””â”€â”€ expand.go
â”‚   â”‚   â”œâ”€â”€ fs
â”‚   â”‚   â”‚   â””â”€â”€ fs.go
â”‚   â”‚   â”œâ”€â”€ ini
â”‚   â”‚   â”‚   â”œâ”€â”€ parse.go
â”‚   â”‚   â”‚   â””â”€â”€ stringify.go
â”‚   â”‚   â”œâ”€â”€ locale
â”‚   â”‚   â”‚   â””â”€â”€ locale.go
â”‚   â”‚   â”œâ”€â”€ pe
â”‚   â”‚   â”‚   â”œâ”€â”€ characteristics.go
â”‚   â”‚   â”‚   â”œâ”€â”€ machine.go
â”‚   â”‚   â”‚   â””â”€â”€ pe.go
â”‚   â”‚   â”œâ”€â”€ priority
â”‚   â”‚   â”‚   â””â”€â”€ priority.go
â”‚   â”‚   â”œâ”€â”€ regedit
â”‚   â”‚   â”‚   â””â”€â”€ regedit.go
â”‚   â”‚   â”œâ”€â”€ shortcut
â”‚   â”‚   â”‚   â””â”€â”€ shortcut.go
â”‚   â”‚   â”œâ”€â”€ steam
â”‚   â”‚   â”‚   â””â”€â”€ steamid.go
â”‚   â”‚   â”œâ”€â”€ thread
â”‚   â”‚   â”‚   â””â”€â”€ thread.go
â”‚   â”‚   â”œâ”€â”€ trust
â”‚   â”‚   â”‚   â””â”€â”€ trust.go
â”‚   â”‚   â”œâ”€â”€ ui
â”‚   â”‚   â”‚   â”œâ”€â”€ gdi32.go
â”‚   â”‚   â”‚   â”œâ”€â”€ kernel32.go
â”‚   â”‚   â”‚   â”œâ”€â”€ menu.go
â”‚   â”‚   â”‚   â”œâ”€â”€ shell32.go
â”‚   â”‚   â”‚   â”œâ”€â”€ splash.go
â”‚   â”‚   â”‚   â”œâ”€â”€ user32.go
â”‚   â”‚   â”‚   â””â”€â”€ util.go
â”‚   â”‚   â”œâ”€â”€ version
â”‚   â”‚   â”‚   â””â”€â”€ version.go
â”‚   â”‚   â”œâ”€â”€ video
â”‚   â”‚   â”‚   â””â”€â”€ video.go
â”‚   â”‚   â””â”€â”€ wine
â”‚   â”‚       â””â”€â”€ wine.go
â”‚   â”œâ”€â”€ launcher.go
â”‚   â”œâ”€â”€ lua
â”‚   â”‚   â”œâ”€â”€ global
â”‚   â”‚   â”‚   â”œâ”€â”€ array
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ array.go
â”‚   â”‚   â”‚   â”œâ”€â”€ console.go
â”‚   â”‚   â”‚   â””â”€â”€ sleep.go
â”‚   â”‚   â”œâ”€â”€ lua.go
â”‚   â”‚   â”œâ”€â”€ module
â”‚   â”‚   â”‚   â”œâ”€â”€ archive
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ 7z.go
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ archive.go
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ zip.go
â”‚   â”‚   â”‚   â”œâ”€â”€ config
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ config.go
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ini
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ini.go
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ json
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ json.go
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ toml
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ toml.go
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ xml
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ xml.go
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ yaml
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ yaml.go
â”‚   â”‚   â”‚   â”œâ”€â”€ file
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ file.go
â”‚   â”‚   â”‚   â”œâ”€â”€ http
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ download.go
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ fetch.go
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ http.go
â”‚   â”‚   â”‚   â”œâ”€â”€ process
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ process.go
â”‚   â”‚   â”‚   â”œâ”€â”€ random
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ alphanum.go
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ random.go
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ steamid.go
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ userprocess.go
â”‚   â”‚   â”‚   â”œâ”€â”€ regedit
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ regedit.go
â”‚   â”‚   â”‚   â”œâ”€â”€ shell
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ shell.go
â”‚   â”‚   â”‚   â”œâ”€â”€ steamid
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ steamid.go
â”‚   â”‚   â”‚   â”œâ”€â”€ time
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ time.go
â”‚   â”‚   â”‚   â”œâ”€â”€ user
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.go
â”‚   â”‚   â”‚   â””â”€â”€ video
â”‚   â”‚   â”‚       â””â”€â”€ video.go
â”‚   â”‚   â”œâ”€â”€ script
â”‚   â”‚   â”‚   â”œâ”€â”€ lua_modules
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ steamclient.lua
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types.lua
â”‚   â”‚   â”‚   â””â”€â”€ script.go
â”‚   â”‚   â””â”€â”€ type
â”‚   â”‚       â”œâ”€â”€ failure
â”‚   â”‚       â”‚   â””â”€â”€ failure.go
â”‚   â”‚       â””â”€â”€ steamid
â”‚   â”‚           â””â”€â”€ steamid.go
â”‚   â”œâ”€â”€ menu.go
â”‚   â”œâ”€â”€ patches.go
â”‚   â”œâ”€â”€ shortcut.go
â”‚   â”œâ”€â”€ splash.go
â”‚   â””â”€â”€ symlink.go
â”œâ”€â”€ update.cmd
â”œâ”€â”€ update.sh
â””â”€â”€ winres
    â”œâ”€â”€ icon.ico
    â”œâ”€â”€ icon.png
    â””â”€â”€ winres.json

```

`LICENSE`:

```
MIT License

Copyright (c) Anthony Beaumont

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
About
=====

<p align="center">
  <img src="https://github.com/xan105/Mini-Launcher/raw/main/banner.png" width="384" height="256"/>
</p>

Mini-Launcher is an application launcher with various gaming-related features. <br />
I built this tool as part of my personal game preservation efforts.

Here is a highlight of its features:

  - DLL Injection / ASI plugin loading
  - Lua Scripting
  - Splash screen (optional)
  - Large Address Aware patching
  - Setting environment variables and arguments with expanding variables
  - Setting compatibility flags or Wine/Proton prefix options
  - Set process priority and affinity (pin to specific cores)

ğŸ§ This software has an emphasis on being compatible with Linux/Proton.
  
ğŸ’» This software is for my own personal use but feel free to use it.

Command Line
============

### `--config string` (launcher.json)

File path to the json configuration file to use. Defaults to `launcher.json`.<br />
Path can be absolute or relative (to the current working dir)

### `--dry-run`

Program will exit before starting the executable.

ğŸ’¡ This flag can come in handy when testing Lua Script.

### `--help`

Display a message box with all the command line arguments and a short description.

Config file
===========

JSON configuration file. By default `launcher.json` (use `--config` to change it).

_Example:_

```json
{
  "bin": "Data/ra3_1.12.game",
  "args": "-config \"%CURRENTDIR%\\RA3_%LANGUAGE%_1.12.SkuDef\"",
  "script": {
    "path": "keygen.lua",
    "reg": true
  },
  "addons": [
    { "path": "opencnconline.dll", "required": true }
  ],
  "patch": {
    "laa": true
  },
  "prefix": {
    "overrides": {
      "xinput1_3": "native,builtin"
    }
  }
}
```

<details>
<summary>JSON schema:</summary>
<br />
  
```ts
{
  bin: string,
  cwd?: string,
  args?: string,
  env?: object,
  priority?: string,
  hide?: bool,
  shell?: bool,
  wait?: bool,
  script?: {
    path: string,
    fs?: bool,
    net?: bool,
    reg?: bool,
    exec?: bool,
    import?: bool
  },
  addons?: []{
    path: string, 
    required?: bool
  },
  suspended?: bool,
  affinity?: []number,
  integrity?: []{
    sri: string, 
    path?: string, 
    size?: number,
    signed?: bool
  },
  splash?: {
    show: bool,
    image: []string,
    timeout?: number,
    wait?: string
  },
  symlink?: []{
    path: string,
    dest: string
  },
  shortcut?: {
    name: string,
    desktop?: bool,
    startmenu?: bool
  },
  compatibility?: {
    version?: string,
    fullscreen?: bool,
    admin?: bool,
    invoker?: bool,
    aware?: bool
  },
  patch?: {
    laa?: bool
  },
  prefix?: {
    winver?: string,
    dpi?: number,
    overrides?: object
  },
  attrib?: []{
    path: string,
    hidden?: boolean,
    readonly?: boolean
  },
  menu?: object
}
```
</details>

### `bin: string`

File path to the executable to launch.<br />
Path can be absolute or relative (to the current working dir).

`%VAR%` are expanded if any (see Expanding Variable for more details).

### `cwd?: string` (parent directory)

An option to override the current working dir of the executable to be launched.<br />
This is equivalent to the "Start In" option of a Windows shortcut.

By default the parent directory of the executable is used.<br />
Example: `G:\METAPHOR\METAPHOR.exe` => `G:\METAPHOR\`

### `args?: string` (none)

Optional argument(s) to pass to the executable.<br />
Argument(s) are passed "verbatim" ie: no quoting or escaping is done.

`%VAR%` are expanded if any (see Expanding Variable for more details).

### `env?: object` (none)

Add additional environment key-value pairs to the executable process.

Example:

```json
{
  "env": {
    "GAMEPAD_LED": "BATTERYLVL"
  }
}
```

`%VAR%` in value are expanded if any (see Expanding Variable for more details).

### `priority?: string` (none)

Set the executable process priority class:

- `IDLE`:          Threads run only when the system is idle.
- `BELOW_NORMAL`:  _Above `IDLE` but below `NORMAL`._
- `NORMAL`:        This is the default.
- `ABOVE_NORMAL`:  _Above `NORMAL` but below `HIGH`._ 
- `HIGH`:          Performs time-critical tasks that must be executed immediately. 
- `REALTIME`:      Highest possible priority, higher than operating system processes performing important tasks.

> [!WARNING] 
> Use extreme care when using **HIGH**, because a high-priority class application can use nearly all available CPU time.
> Even more so with **REALTIME** which can cause issues like disk cache not flushing or unresponsive mouse.

### `hide?: bool` (false)

When enabled, the executable will run without displaying a window, making it invisible to the user.

### `shell?: bool` (false)

When enabled runs inside of a shell (%COMSPEC% ie `cmd.exe`).<br />
ğŸ’¡ Use the `hide` option above to hide the shell.

### `wait?: bool` (false)

When enabled, will wait for the executable to terminate before exiting.

> [!TIP]
> This option can be used in conjunction with the Lua API (see below) to run some code on executable exit! 

```lua
local process = require("process")
process.On("will-quit", function()
  print("Bye bye!")
  -- do some cleanup for example
  -- like idk deleting logs generated by mods ğŸ™ƒ
end)
```

### `script?: { path: string, fs, net, reg, exec, import?: bool }` (none)

Lua script to be run just before the executable.<br />
See the `./example` directory for some examples.

Originally this feature was for handling CD Key generation in old games.<br />
The Lua API has since become quite extensive, so please kindly see the **Lua Scripting** section below for more details.

- `path: string`

  Script file path can be absolute or relative (to the current working dir).<br />
  `%VAR%` are expanded if any (see Expanding Variable for more details).

- `fs, net, reg, exec, import ?: bool` (false)

  These flags act as a simple permissions system: 
  + `fs`: Filesystem operation
  + `net`: Network request
  + `reg`: Windows registry
  + `exec`: Shell command
  + `import`: Load external Lua code (via require, loadfile, loadstring, ...)

  You must explicitly grant access to these resources.

### `addons?: []{ path: string, required?: boolean }` (none)

> DLL Injection / ASI plugin loading

> [!WARNING]
> DLL Injection is generally associated with malware or cheats.
> Using this feature has a high chance of triggering an antivirus false positive.

List of addons to inject to the executable process.<br />
Supported file extension:
  - `.dll` (Dynamic link library)
  - `.asi` (Commonly used in game modding; technically it's a `.dll` file with a different extension).

When `required` is set to `true` and the injection failed: alert the user and kill the process.

Path can be absolute or relative (to the current working dir).<br />
`%VAR%` are expanded if any (see Expanding Variable for more details).

Example:
```json
{
  "addons": [
    { "path": "Launcher/opencnconline.dll", "required": true }
  ]
}
```

> [!IMPORTANT]
> This launcher does not support Wow64 injection so make sure the launcher, the executable and the addon are all the same arch (x86 or x64).

### `suspended?: bool` (false)

When enabled, the main thread of the executable process is created in a suspended state and does not run until resumed.

The main thread will be automatically resumed after the process affinity and addons injection steps.

> [!TIP]
> Some addons may require the executable to be started in such state in order to function properly.

### `affinity?: []number` (none)

> [!IMPORTANT] 
> This option requires the `suspended` option to be enabled (see above) otherwise it is skipped!.

Set the CPU affinity (pin to specific cores).<br />
CPU indices are **logical** cores, exactly as shown in Windows' Task Manager.

Examples:

Pinning to the first core

```json
{
  "affinity": [0]
}
```

Pinning to the 3rd and 4th cores

```json
{
  "affinity": [2, 3]
}
```

Process affinity is set before any addons injection occurs to ensure that all threads are pinned to the specified logical cores.

**When should I use this?**

Some games behave better when restricted to specific CPU cores:

  - Old games not designed for multi-core CPUs (ex: extreme gameplay speed on multi-core CPUs).
  - Games that stutter or misbehave on modern systems.
  
âš ï¸ Most games do not need this option, use it only when required.

### `integrity?: []{sri: string, path?: string, size?: number, signed?: bool}` (none)

Check file(s) integrity before starting the executable.

- `sri: string` 
  is a [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity), algo supported are `sha256, sha384, sha512`.

- `path?: string` (executable path) 
  File path, can be absolute or relative (to the current working dir). If no path is specified then the sri targets the executable path.<br />
  `%VAR%` are expanded if any (see Expanding Variable for more details).

- `size?: number`
  optional file size (in bytes), to accelerate sum comparison.
  
- `signed?: bool` (false)
  When true, will check if the file is signed and trusted.
  
### `splash?: { show: bool, image: []string, timeout?: number }` (none)

Display a splash screen until the executable process change the cursor or display a window. The splash screen should be a BMP file. 

- `show: bool` (false)
  Wether to display the splash screen or not.

- `image: []string` 
  Splash screen filepath. When more than one, a splash screen is selected at random.<br />
  File path can be absolute or relative (to the current working dir).<br />
  `%VAR%` are expanded if any (see Expanding Variable for more details).
  
- `timeout?: number` (10 sec)
  Failsafe timeout in seconds.<br />
  There was no event dispatched under Linux/Proton on Wayland in my limited testing.
  
- `wait?: string` ("FOREGROUND")
  Which window event to wait for (case insensitive):
  
  + `FOREGROUND`: The foreground window has changed and is visible.
  + `WINDOW`: An hidden window is shown.
  + `CURSOR`: An hidden cursor is shown.
  
### `symlink?: []{path: string, dest: string}` (none)

Creates folder symlink before starting the executable.<br />
Path can be absolute or relative (to the current working dir).<br />
`%VAR%` are expanded if any (see Expanding Variable for more details).

ğŸ’¡ Useful for savegames:

```json
{
  "symlink": [
    { 
      "path": "%DOCUMENTS%/Telltale Games/The Walking Dead",
      "dest": "%SAVEGAME%/The Walking Dead"
    }
  ]
}
```

> [!CAUTION]
> This requires elevated privileges ("Admin rights") or the `SeCreateSymbolicLinkPrivilege` privilege.

> [!TIP]
> On Windows the launcher will restart automatically with elevated privileges triggering an UAC prompt for the end user.

### `shortcut?: { name: string, desktop?: bool, startmenu?: bool}` (none)

Creates desktop / start menu shortcut(s) on launch.

### `compatibility?: object` (none)

Set `Program Compatibility Assistant` (PCA) flags, this is equivalent to the `right click > Properties > Compatibility tab` on Windows.

PCA flag(s) are set in `HKCU/Software/Microsoft/Windows NT/CurrentVersion/AppCompatFlags/Layers`.

ğŸ§ This has no effect on application behavior under Wine/Proton

- `version?: string`
  Run the executable in compatibility mode for:
    + `WIN95`
    + `WIN98`
    + `WIN2000`
    + `WINXP`
    + `WINXPSP1`
    + `WINXPSP2`
    + `WINXPSP3`
    + `VISTARTM`
    + `VISTASP1`
    + `VISTASP2`
    + `WIN7RTM`
    + `WIN8RTM`
    
- `fullscreen?: bool`
  Disable fullscreen optimizations.

- `admin?: bool`
  Run the executable as an Administrator.
  
- `invoker?: bool`
  Enforce running the executable as the invoker.
  
- `aware?: bool`
  Override high DPI scaling behavior (Application).

NB: `admin` and `invoker` are mutually exclusive. If both are set `admin` supersede `invoker`.

### `patch?: object` (none)

Patch(es) to apply to the executable.

Does nothing by default; You must explicitly set a patch to `true` or `false`.

- `laa?: bool`:<br/>
  **Large Adress Aware**<br/>
  Allow x86 binary to access up to 4GB of virtual memory (instead of only 2) on x64 Windows.<br/>
  This option set (`true`) or unset (`false`) the LAA flag bit in the PE Header.<br/>
  
NB: Patching is done prior to any integrity check because it directly modifies the executable.

### `prefix?: {winver?: string, dpi?: number, overrides?: object}` (none)

ğŸ§ Linux Wine/Proton only.

Update current prefix settings.

- `winver?: string`
  Windows version. Accepted values are: 
    + `win11`
    + `win10`
    + `win81` 
    + `win8`
    + `win7`
    + `vista` 
    + `winxp`
  
- `dpi?: number`
  Scale factor: 96 (100%), 120 (125%), 144 (150%), 192 (200%) to 480 (500%).

- `overrides?: object` 
  key-value pairs of dll overrrides. Accepted values:
    + `native,builtin`
    + `builtin,native`
    + `native`
    + `builtin`
    
Example: 

```json
{
  "prefix": {
    "winver": "win10",
    "dpi": 96,
    "overrides": {
      "winmm": "native,builtin"
    }
  }
}
```

### `attrib?: []{path: string, hidden?: boolean = false, readonly?: boolean = false}` (none)

Set file(s) attributes: read only and/or hidden.

Path can be absolute or relative (to the current working dir).<br />
`%VAR%` are expanded if any (see Expanding Variable for more details).

ğŸ’¡NB: This is done before running any Lua Script.
If you are dynamically creating/modifying file(s), consider the Lua API: `file.SetAttributes()` (see below).

### `menu?: object` (none)

Show a very simple button menu where each key/value pair is a button label and its corresponding override config file.

Example:

```json
{
  "menu": {
    "Mass Effect": "me.json",
    "Mass Effect 2": "me2.json",
    "Mass Effect 3": "me3.json"
  }
}
```

Path can be absolute or relative (to the current working dir).
`%VAR%` in the path are expanded if any (see Expanding Variable for more details).

ğŸ’¡ You can point an entry to the default config file.
If empty, the default is assumed ie: the value of `--config string` which defaults to `launcher.json`

Example:

```json
{
  "binary": "bin/bg3_dx11.exe"
  "menu": {
    "Baldurs Gate 3": "",
    "Baldurs Gate 3 (Vulkan)": "vulkan.json"
  }
}
```

Expanding Variable
==================

List of variables that will get expanded:

- `%APPDATA%`
- `%LOCALAPPDATA%`
- `%PROGRAMDATA%`
- `%DESKTOP%`
- `%DOCUMENTS%`
- `%MUSIC%`
- `%PICTURES%`
- `%VIDEOS%`
- `%DOWNLOAD%`
- `%SAVEGAME%`
- `%HOMEDIR%`, `%USERPROFILE%`
- `%PUBLIC%` 
- `%SYSTEMDIR%`
- `%TEMP%`, `%TMP%`
- `%CURRENTDIR%`: Current working dir of the mini-launcher
- `%BINDIR%`: Dir where the mini-launcher is located at
- `%USERNAME%`
- `%LANGCODE%`: User's language as ISO 639 language code (ex: `en`, `fr`, `de`)
- `%LANGUAGE%`: User's language in English (ex: `english`, `french`, `german`)
- `%SCREENWIDTH%`, `%XRES%`: Current primary display horizontal resolution (DPI Aware)
- `%SCREENHEIGHT%`, `%YRES%`: Current primary display vertical resolution (DPI Aware)
- `%SCREENREFRESH%`: Current primary display refresh rate

Lua Scripting
=============

Very simple scripting engine powered by [yuin/gopher-lua](https://github.com/yuin/gopher-lua) (Lua 5.1).<br />
See the `./example` directory for some examples.

Standard libs available are:

  - Package
  - Basic
  - Table
  - String
  - Math
  - Coroutine

Some standard libraries are not enabled by design.<br />
`goto` and `::label::` statements from Lua 5.2 are supported.<br />

The followings modules are exposed to the Lua VM, I might add more later on.

> [!NOTE]
By default the VM is mostly sandboxed: you can only _require_ from the available modules.
If you want to _require_ an external lua file you must set the permission `import: true` in the config file.

## ğŸŒ Globals

### `sleep(ms: int)`

Suspends the execution of the Lua engine until the time-out interval elapses (interval is in milliseconds).

### `console: SetFuncs`

  + `log(any, ...)`
  + `warn(any, ...)`
  + `error(any, ...)`
  
Convenience methods to print value or array with timestamp and log level. Values are colored depending on their type.

ğŸ’¡ `print()` is an alias to `console.log()`

### `Array: SetFuncs`

  + `find(table, func) any`
  + `some(table, func) bool`
  + `includes(table, any) bool`
  
Convenience methods to search ~~array~~ Lua table.

Example: 

```lua
local arr = {1, 2, 3, 4, 5}

Array.find(arr, function(x) return x > 3 end)
Array.includes(arr, 3)

local arr = {
  {foo = "bar", value = 1},
  {foo = "baz", value = 2}
}

Array.find(arr, function(x) return x.foo == "bar" end)
Array.some(arr, function(x) return x.foo == "baz" end)
```

### `Failure(code?: string, message?: string) Failure{ code: string, message: string }`

Failure is a custom type (_userdata_) that represents an "error object" with an associated error code and message.
This provides a structured way to handle error.

- `code?: string` ("ERR_UNKNOWN")
  Error code.
  
- `message?: string` ("An unknown error occurred")
  Error message.
  
ğŸ’¡ `Failure` has a `__tostring` metamethod. If not invoked automatically, you can explicitly call it using `tostring(Failure)`

Example:

```lua
local err = Failure("ERR_NOT_FOUND", "The requested item was not found")
print(err.code)    -- "ERR_NOT_FOUND"
print(err.message) -- "The requested item was not found"
print(err)         -- "[ERR_NOT_FOUND]: The requested item was not found"

local value, err = Foo()
if err and err.code == "ERR_UNKNOWN" then
  error(err.message) -- Raise an error "An unknown error occurred"
  -- or
  error(tostring(err))
end
```

## ğŸ“¦ Modules

### `ğŸ“¦ Regedit`

This is a module to read and write from/to the registry.

> Requires the `reg` permission.

```lua
local regedit = require("regedit")
```

- `KeyExists(root: string, path: string) bool`
- `ListAllSubkeys(root: string, path: string) []string`
- `ListAllValues(root: string, path: string) []string`
- `QueryValueType(root: string, path: string, key: string) string`
- `QueryStringValue(root: string, path: string, key: string) string` //REG_SZ & REG_EXPAND_SZ
- `QueryMultiStringValue(root: string, path: string, key: string) []string` //REG_MULTI_SZ
- `QueryBinaryValue(root: string, path: string, key: string) string` //REG_BINARY
- `QueryIntegerValue(root: string, path: string, key: string) string` //REG_DWORD & REG_QWORD
- `Create(root: string, path: string)`
- `Delete(root: string, path: string)`
- `WriteStringValue(root: string, path: string, key: string, value: string)` //REG_SZ
- `WriteExpandStringValue(root: string, path: string, key: string, value: string)` //REG_EXPAND_SZ
- `WriteMultiStringValue(root: string, path: string, key: string, value: []string)` //REG_MULTI_SZ
- `WriteBinaryValue(root: string, path: string, key: string, value: string)` //REG_BINARY
- `WriteDwordValue(root: string, path: string, key: string, value: string)` //REG_DWORD 
- `WriteQwordValue(root: string, path: string, key: string, value: string)` //REG_QWORD
- `DeleteValue(root: string, path: string, key: string)`

âœ”ï¸ `root` key accepted values are `"HKCR", "HKCU", "HKLM", "HKU" or "HKCC"`.<br />
ğŸ’¡For the default key `@` use `key = ""`

`%VAR%` in `WriteStringValue(..., value)` are expanded if any (see Expanding Variable for more details).

NB: `REG_DWORD` & `REG_QWORD` are represented as string due to floating-point precision limits, if you need to perform arithmetic on them in Lua use `tonumber()`.

### `ğŸ“¦ Random`

This is a module to generate random things.

```lua
local random = require("random")
```

- `AlphaNumString(length: number) string`
- `UserPID() number`
- `SteamID() number`

#### `AlphaNumString(length: number) string`

Generate a random alpha numeric string of specified length.

#### `UserPID() number`

Picks a random PID from the user-owned processes.

#### `SteamID() number`

Generate a random SteamID64.

### `ğŸ“¦ File`

This is a module to read and write text data from/to file.

> Requires the `fs` permission.

```lua
local file = require("file")
```

- `Write(filename: string, data: string, format?: string = "utf8") Failure`
- `Read(filename: string, format?: string = "utf8") string, Failure`
- `Remove(path: string) Failure`
- `Info(filename: string) table, Failure`
- `Glob(root: string, pattern: string, options?: { recursive?: bool = false, absolute?: bool = false }) []string, Failure`
- `Basename(path: string, suffix?: bool = true) string`
- `SetAttributes(filename: string, flags?: { readonly?: bool = false, hidden?: bool = false }) Failure`

Encoding format:

  - `utf8`
  - `utf8sig`
  - `utf16le`
  - `windows1252`

`%VAR%` in `filename` / `root` are expanded if any (see Expanding Variable for more details).

#### `Write(filename: string, data: string, format?: string = "utf8") Failure`

Overwrite text data with specified format encoding (default to utf8).<br /> 
Create target parent dir if doesn't exist.<br />
File is created if doesn't exist.

#### `Read(filename: string, format?: string = "utf8") string, Failure`

Read text data as specified format encoding (default to utf8).

#### `Remove(path: string) Failure`

Delete file or directory and any children it contains at the given path.

#### `Info(filename: string) table, Failure`

Retrieves information for the specified path.<br/>
Time information are represented as Unix epoch time (seconds).<br/>
If the target is a file this will also include the file version information (if any) and whether the file is signed and trusted or not.

```ts
{
  size: number, 
  time: { 
    modification: number, 
    creation?: number, 
    access?: number
  }, 
  version?: { 
    major: number, 
    minor: number, 
    build: number, 
    revision: number 
  },
  signed?: bool
}
```

#### `Glob(root: string, pattern: string, options?: { recursive?: bool = false, absolute?: bool = false }) []string, Failure`

Returns the names of all files matching pattern. The pattern syntax is the same as in Go [path/filepath Match](https://pkg.go.dev/path/filepath#Match).
With the addition that, to return only directories the pattern should end with `/`.

#### `Basename(path: string, suffix?: bool = true) string`

Returns the last element of path. When `suffix` is `false` the file extension is removed.

Example:

```lua
file.Basename("/foo/bar/quux.html");
-- Returns: "quux.html"

file.Basename("/foo/bar/quux.html", false);
-- Returns: "quux" 
```

#### `SetAttributes(filename: string, flags?: { readonly?: bool = false, hidden?: bool = false }) Failure`

Set file attributes: read only and/or hidden.

### `ğŸ“¦ Config`

This is a module to parse/stringify config files.

```lua
local JSON = require("config/json")
local TOML = require("config/toml")
local INI  = require("config/ini")
local YAML = require("config/yaml")
local XML  = require("config/xml")
```

- `JSON`
  + `Parse(data: string) table | nil, Failure`
  + `Stringify(data: table, pretty?: bool = true) string | nil, Failure`
- `TOML`
  + `Parse(data: string) table | nil, Failure`
  + `Stringify(data: table) string | nil, Failure`
- `INI`
  + `Parse(data: string, options?: table) table`
  + `Stringify(data: table, options?: table) string`
- `YAML`
  + `Parse(data: string) table | nil, Failure`
  + `Stringify(data: table) string | nil, Failure`
- `XML`
  + `Parse(data: string) table | nil, Failure`
  + `Stringify(data: table, pretty?: bool = true) string | nil, Failure`
  
âš ï¸ Due to GoLang using hashmap the key order is not guaranteed !

#### `INI`

Parse options: 

- `filter?: []string (none)` Section filter
- `global?: bool (true)` Include global section
- `unquote?: bool (true)` Unquote string (starting/ending with `"` or `'`)
- `boolean?: bool (true)` String to boolean type conversion
- `number?: bool (true)` String to number type conversion (same rules as JavaScript's JSON.parse())

Stringify options:

- `whitespace?: bool (true)` add space between delimiter `=`
- `blankLine?: bool (false)` add empty line between sections
- `quote?: bool (false)` quote string with `"`
- `eol?: string (system)` Either `\n` or `\r\n`

### `ğŸ“¦ Http`

This is a module to do http request.

> Requires the `net` permission.

```lua
local http = require("http")
```

- `Fetch(url: string, options?: {method?: string, headers?: table, body?: string }) {status: number , body: string, headers: table} | nil, Failure`
- `Download(url: string, destDir: string) string, Failure`

#### `Fetch(url: string, options?: {method?: string, headers?: table, body?: string }) {status: number , body: string, headers: table} | nil, Failure`

A [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) like API.

Example:

```lua
local http = require("http")
local JSON = require("config/json")

local repo = "xan105/Mini-Launcher"
local url = "https://api.github.com/repos/" .. repo .. "/releases/latest"

local res, err = http.Fetch(url, {
  method = "GET",
  headers = {
    ["Accept"] = "application/vnd.github.v3+json",
    ["User-Agent"] = "Chrome/"
  }
})
if err then
  console.error(err)
end

local github, err = JSON.Parse(res.body)
if err then
  console.error(err)
end

local latestRelease = github["tag_name"]
```

#### `Download(url: string, destDir: string) string, Failure`

Download a file. Filename is determined by the `Content-Disposition` header.
Create target parent dir if doesn't exist.<br />
Overwrite existing file.<br />
Return the downloaded file path.

`%VAR%` in `destDir` are expanded if any (see Expanding Variable for more details).

Example:

```lua
local http = require("http")

local filepath, err = http.Download("http://.../foo.bar", "%DOWNLOAD%")
if err then
  console.error(err)
else
  console.log("downloaded: " .. filepath)
end
```

### `ğŸ“¦ Archive`

This is a module to decompress archive file.

> Requires the `fs` permission.

```lua
local archive = require("archive")
```

- `Unzip(filePath: string, destDir: string, excludeList?: []string) Failure`
- `Un7z(filePath: string, destDir: string, excludeList?: []string) Failure`

Extract `.zip` / `7.z` archive to `destDir`. Overwriting existing files.

`%VAR%` are expanded if any (see Expanding Variable for more details).

### `ğŸ“¦ User`

This is a module to get info about the current user.

```lua
local user = require("user")
```

- `name: string` : User name
- `admin: bool` : has elevated rights ?
- `language: string`: User's language in English (ex: `english`, `french`, `german`)
- `locale`: User's language as ISO 639
  + `code: string`: language code (ex: `en`, `fr`, `de`)
  + `region: string`: language region (ex: `US`, `BE`, `DE`)
  
### `ğŸ“¦ Video`

This is a module to get info about the current display mode.

```lua
local video = require("video")
```

- `Current() { width?: number (px), height?: number (px), hz?: number, scale?: number (%)}, Failure`

### `ğŸ“¦ Process`

This is a module to get info about the current Mini-Launcher process.

```lua
local process = require("process")
```

- `platform: string` : operating system target (GOOS)
- `arch: string` : architecture target (GOARCH)
- `pid: number` : process id
- `Cwd() string` : process current working dir
- `ExecPath() string` : process absolute pathname
- `On(event: string, callback: function)` : register callback function to be run for specified event

**Events**

- `will-quit` : Fired when process is about to terminate.

### `ğŸ“¦ Shell`

This is a module to execute shell command. 

> Requires the `exec` permission.

```lua
local shell = require("shell")
```

- `Run(command: string) {stdout?: string, stderr?: string}, Failure`

#### `Run(command: string) {stdout?: string, stderr?: string}, Failure`

Spawns a shell then execute the command within that shell (ComSpec).

### `ğŸ“¦ Time`

This is a module to handle time conversion. 

```lua
local time = require("time")
```

- `Current() number`: Current Unix time
- `HumanizeDuration(seconds: number) string`
- `ToUnix(datetime: string, format?: string = "ISO8601") number, Failure`
- `ToIso8601(datetime: number) string`

NB: `ToUnix()` supported formats are:
- "ISO8601"
- "YYYY-MM-DD"
- "YYYY/MM/DD"
- "YYYY_MM_DD"
- "DD-MM-YYYY"
- "DD/MM/YYYY"
- "MM-DD-YYYY"
- "MM/DD/YYYY"
- "YYYY-MM-DD HH:MM:SS"
- "YYYY/MM/DD HH:MM:SS"

### `ğŸ“¦ SteamID`

This is a module to help working with Steam-related user identification.

```lua
local SteamID = require("SteamID")
```

#### `SteamID(userid: string) SteamID{...}`

`SteamID` is a custom type (_userdata_) that represents a _Steam ID_ with its associated _universe_, _type_, _instance_, and _account ID_.

It is created from a _"Steam2 ID"_ (`STEAM_X:Y:Z`), a _"Steam3 ID"_ (`[U:1:Z]`) or a _"Steam64 ID"_ string.

This provides a structured and easy way to handle conversion:

- `universe: number`

- `type: number`

- `instance: number`

- `accountid: number`

- `:asSteam2() string`

  Returns a "Steam2 ID": `STEAM_X:Y:Z`
  
  eg: `STEAM_1:0:354782281`

- `:asSteam3() string`

  Returns a "Steam3 ID": `[U:1:Z]`
  
  eg: `[U:1:709564562]`

- `:asSteam64() string`
  
  Returns a "Steam64 ID"
  
  eg: `76561198669830290`


Example:

```lua
local SteamID = require("SteamID")
local id = SteamID("76561198669830290")

print(id.accountid)   -- 709564562
print(id:asSteam2())  -- STEAM_1:0:354782281
print(id:asSteam3())  -- [U:1:709564562]
print(id:asSteam64()) -- 76561198669830290
```

### `ğŸ“¦ Steam Client`

This module provides utilities to help launching games that require the Steam client.

These utilities can be used to create what is often referred to as a _"Steam loader"_.

ğŸ’¡If you have no idea what I'm talking about, I invite you to read [my blog post about it](https://xan105.com/blog/scripting-a-steam-loader-using-gopherlua).

> [!IMPORTANT]
> You also have to set Steam-related env. var. with `env:{key:value,...}` in the config file.

```json
{
  "env": {
    "SteamAppId": "480",
    "SteamGameId": "480",
    "SteamClientLaunch": "1",
    "SteamEnv": "1",
    "SteamPath": "%CURRENTDIR%\\Launcher.exe"
  }
}
```

> Requires the `reg` permission.

```lua
local steamclient = require("steamclient")
```

- `HasGenuineDLL(root?: string) bool`

  Recursively search, within the specified root directory, for the presence of genuine (signed) `steam_api(64).dll`.
  If omitted then the launcher's current working directory is used.
  
- `Backup() table`

  Backup the Steam-related registry values.
  
- `Restore(backup: table)`

  Restore previously backed up Steam-related registry values.
  
> [!TIP]
> Use the event _"will-quit"_ from the `process` module to restore the values later on.
> 
> You can also set the option `wait: true` in the config file so the event triggers when the game exits rather than when the launcher terminates.
  
- `Load(client?: { appid?: string, dll:? string, dll64?: string, user?: number })`

  Write the Steam-related values to the registry.<br/>
  You can specify the game's appid, steamclient dlls path and user account id.<br/>
  If omitted they are set automatically by looking for `steam_appid.txt`, `steamclient(64).dll` within the launcher's current working directory.
  
> [!TIP]
> To force inject steamclient/GameOverlayRenderer dll(s) use the `addons` option.
 

**Full example:**

```lua
local process = require("process")
local steamclient = require("steamclient")

if steamclient.HasGenuineDLL() then
  local backup = steamclient.Backup()
  steamclient.Load()
  process.On("will-quit", function() 
    steamclient.Restore(backup)
  end)
 end
```

Config file

```json
{
  "env": {
    "SteamAppId": "480",
    "SteamGameId": "480",
    "SteamClientLaunch": "1",
    "SteamEnv": "1",
    "SteamPath": "%CURRENTDIR%\\Launcher.exe"
  },
  "wait": true,
  "addons": [
    { "path": "steamclient64.dll", "required": true},
    { "path": "GameOverlayRenderer64.dll", "required": true}
  ]
}
```

> [!TIP]
> ğŸ§ Linux/Proton: you may need to set the env. var. `PROTON_DISABLE_LSTEAMCLIENT=1` _(Linux environment)_ to disable Proton Steam client bridge shenanigans, otherwise it may conflict with the `steamclient(64).dll`.

### `ğŸ“¦ Types`

This is module for type checking at runtime.

```lua
local types = require("types")
```

- `is(typestring: string, value: unknown) bool`
- `as(typestring: string, value: unknown) unknown|nil`
  
  Return the given value when the condition is true otherwise nil.

- `should(typestring: string, value: unknown) unknown`
  
  Return the given value when the condition is true otherwise raise an Error (similar to Lua's `assert()`).

<details><summary>List of supported "type string":</summary>

- string
- str
- number
- nbr
- int
- integer
- uint
- boolean
- bool
- table
- array
- arr
- function
- func
- fn
- userdata
- thread

You can add the suffix `[]` for an array, and add a number for fixed length array.

Example:

```lua
local types = require("types")
print(types.is("string[]", {"hello", "foo", "bar"})) -- true
```

</details>

Build
=====

- Golang v1.26.x
- [go-winres](https://github.com/tc-hib/go-winres) installed in `%PATH%` env var for win32 manifest & cie

Run `build.cmd` on Windows<br/>
Run `build.sh` on Linux<br/>

Output files are located in `./build/${platform}/${config}`

## Github Actions

- `./.github/workflows/go-build-on-linux.yaml` 
- `./.github/workflows/go-build-on-windows.yaml`

Build all targets (debug and release) and create a release.

```

`build.cmd`:

```cmd
@echo off
cd %~dp0src
set GOOS=windows
set CGO_ENABLED=0
go-winres make --in "..\winres\winres.json"

set GOARCH=386
echo Compiling x86 (DEBUG)...
go build -o "..\build\x86\Debug\Launcher.exe" launcher
echo Compiling x86 (RELEASE)...
go build -trimpath -ldflags "-w -s -H windowsgui -buildid=" -o "..\build\x86\Release\Launcher.exe" launcher

set GOARCH=amd64
echo Compiling x64 (DEBUG)...
go build -o "..\build\x64\Debug\Launcher.exe" launcher
echo Compiling x64 (RELEASE)...
go build -trimpath -ldflags "-w -s -H windowsgui -buildid=" -o "..\build\x64\Release\Launcher.exe" launcher
```

`build.sh`:

```sh
#!/bin/sh
cd "$(dirname "$0")/src"
export GOOS=windows
export CGO_ENABLED=0
${GOPATH:-$HOME/go}/bin/go-winres make --in "../winres/winres.json"

export GOARCH=386
echo "Compiling x86 (DEBUG)..."
go build -o "../build/x86/Debug/Launcher.exe" launcher
echo "Compiling x86 (RELEASE)..."
go build -trimpath -ldflags "-w -s -H windowsgui -buildid=" -o "../build/x86/Release/Launcher.exe" launcher

export GOARCH=amd64
echo "Compiling x64 (DEBUG)..."
go build -o "../build/x64/Debug/Launcher.exe" launcher
echo "Compiling x64 (RELEASE)..."
go build -trimpath -ldflags "-w -s -H windowsgui -buildid=" -o "../build/x64/Release/Launcher.exe" launcher


```

`dist/URL.url`:

```url
[InternetShortcut]
URL=https://github.com/xan105/Mini-Launcher
IDList=
HotKey=0
IconFile=C:\Users\Xan\AppData\Local\Mozilla\Firefox\Profiles\s83s1vxq.default-release\shortcutCache\fP4RNhpXmU5fMb6v9UGF0_8K5o9PjdpmWyeBNGd6D9k=.ico
IconIndex=0

```

`dist/launcher.json`:

```json
{
  "bin": "path/to/executable.exe",
  "cwd": "path/",
  "args": "--foo --bar --dir=\"%SAVEGAME%\" --xres=%SCREENWIDTH% --yres=%SCREENHEIGHT%",
  "env": {
    "foo": "bar"
  },
  "priority": "NORMAL",
  "hide": false,
  "shell": false,
  "wait": false,
  "script": {
    "path": "../lua/hello world.lua",
    "fs": false,
    "net": false,
    "reg": false,
    "exec": false,
    "import": false
  },
  "addons": [
    { "path": "path/to/dll/or/asi", "required": false }
  ],
  "suspended": false,
  "affinity": [0, 1, 2, 3],
  "splash": {
    "show": false,
    "image": ["path/to/bmp"],
    "timeout": 10,
    "wait": "FOREGROUND"
  },
  "symlink": [
    {
      "path": "%DOCUMENTS%/My Games",
      "dest": "%SAVEGAME%"
    }
  ],
  "shortcut": {
    "name": "foo",
    "desktop": false,
    "startmenu": false
  },
  "compatibility": {
    "fullscreen": false,
    "admin": false,
    "invoker": false,
    "aware": false
  },
  "patch": {
    "laa": false
  },
  "prefix": {
    "winver": "win10",
    "dpi": 96,
    "overrides": {
      "dinput8": "native,builtin"
    }
  },
  "attrib": [
    { "path": "config.ini", "readonly": true }
  ],
  "menu": {
    "Mass Effect": "me.json",
    "Mass Effect 2": "me2.json",
    "Mass Effect 3": "me3.json"
  },
  "integrity": [
    {
      "path": "some/file",
      "sri": "sha384-ABC...DEF",
      "size": 42,
      "signed": false
    }
  ]
}
```

`dist/lua/Examples on GitHub.url`:

```url
[InternetShortcut]
URL=https://github.com/xan105/Mini-Launcher/tree/main/example/lua%20script
IDList=
HotKey=0
IconFile=C:\Users\Xan\AppData\Local\Mozilla\Firefox\Profiles\s83s1vxq.default-release\shortcutCache\fP4RNhpXmU5fMb6v9UGF0_8K5o9PjdpmWyeBNGd6D9k=.ico
IconIndex=0
[{000214A0-0000-0000-C000-000000000046}]
Prop3=19,11

```

`example/config/AoE2-DE/launcher.json`:

```json
{
  "bin": "AoE2DE_s.exe",
  "args": "SKIPINTRO",
  "env": {
    "SteamAppId": "813780",
    "SteamGameId": "813780",
    "SteamClientLaunch": "1",
    "SteamEnv": "1",
    "SteamPath": "%CURRENTDIR%\\AoE2DE_s.exe",
    "SRV_IP": "25.48.175.46"
  },
  "symlink": [
    {
      "path": "%USERPROFILE%/Games/Age of Empires 2 DE",
      "dest": "%SAVEGAME%/PC/Age of Empires 2 DE"
    }
  ],
  "addons": [
    { "path": "AoE2DE_LAN.dll", "required": true }
  ],
  "script": {
    "path": "launcher.lua",
    "fs": true,
    "reg": true
  },
  "wait": true,
  "integrity": [
    {
      "sri": "sha384-clBFlzv8wZDMKpRwfq+I6PtSBxBe34FHnP6Y2UDpfm5mFqr0pDD3Bt1f7Dknhini",
      "size": 82017824
    },
    {
      "path": "launcher.lua",
      "sri": "sha384-gzFYJJ96IBtESeziGez1EmqG/tk29shUz3a6UzZSzVjMjU6f+yTmr6svl6OrcYVp",
      "size": 5279
    },
    {
      "path": "manifest.json",
      "sri": "sha384-vosdMWYbEnrJyYaxmSLjpAqY0EDKqYmEdJ4zfeQBw2vPg5B9WziuKpqfo1oJ6xwK",
      "size": 990
    },
    {
      "path": "steam_api.dll",
      "sri": "sha384-1XE/89enWqW4GMUbYLnLYuIx1hZRBL2JtoaRkrhkGvgxFPMf9cmVYXGmX74kUWeX",
      "size": 257312,
      "signed": true
    },
    {
      "path": "steam_api64.dll",
      "sri": "sha384-3Z2YXmw48mwbUunEMGGB1bKZAAuHWKZ+MFCrVHaPe72MBIdry9fRfVx9yhoJZ3e3",
      "size": 288032,
      "signed": true
    },
    {
      "path": "steamclient.dll",
      "sri": "sha384-171iHtGQ9mSzmw/+SHWRRCp9jla86lrPVG+lLQoMX16hxZJFoNFSQjrxbp4f5qRl",
      "size": 15125928
    },
    {
      "path": "steamclient64.dll",
      "sri": "sha384-UaFfn+ytWfbXiOvvl8QAoN+cY5PocIbHOTEa7l5Q6vv4ogHtC2atmy1b8cClEX7s",
      "size": 16777128
    },
    {
      "path": "AoE2DE_LAN.dll",
      "sri": "sha384-EGqfJ45kPG+Cmc1MYRMnqusY4l630YhMeKcqjFzZAZUzfV4d2+10zynfgwpWHEyp",
      "size": 40960
    }
  ]
}

```

`example/config/AoE2-DE/launcher.lua`:

```lua
local file = require("file")
local INI = require("config/ini")
local user = require("user")
local regedit = require("regedit")
local process = require("process")

-- Settings path

local path = "%APPDATA%/GSE Saves/settings"
local local_user_file = file.Read("steam_settings/configs.user.ini")

if local_user_file then
  user_cfg = INI.Parse(local_user_file)
  if user_cfg and user_cfg["user::saves"] then
    local_save_path = user_cfg["user::saves"]["local_save_path"]
    if not local_save_path or local_save_path == "" then
      saves_folder_name = user_cfg["user::saves"]["saves_folder_name"]
      if saves_folder_name and saves_folder_name ~= "" then
        path = "%APPDATA%/" .. saves_folder_name .. "/settings"
      end
    end
  end
end

local global_user_cfg = {}
local global_user_file = file.Read(path .. "/configs.user.ini")
if global_user_file then
  global_user_cfg = INI.Parse(global_user_file)
end

if not global_user_cfg["user::general"] then
  global_user_cfg["user::general"] = {}
end
    
-- User name
    
local account_name = global_user_cfg["user::general"]["account_name"]
if not account_name or account_name == "" or account_name == "Noob" then
  account_name = user.name
end
    
-- User Language
    
local steam_languages = {
  "arabic", "bulgarian", "chinese", "czech",
  "danish", "dutch", "english", "finnish", "french",
  "german", "greek", "hungarian", "italian", "japanese", 
  "korean", "norwegian", "polish", "portuguese",
  "romanian", "russian", "spanish", "swedish",
  "thai", "turkish", "ukrainian", "vietnamese"
}
    
local language = global_user_cfg["user::general"]["language"]
if not language or language == "" then
  language = user.language
  if not Array.includes(steam_languages, language) then
    language = "english"
  elseif language == "spanish" and user.locale.region ~= "ES" then
    language = "latam"
  elseif language == "portuguese" and user.locale.region == "BR" then
    language = "brazilian"
  elseif language == "chinese" then
    if user.locale.region == "CN" or user.locale.region == "SG" then
      language = "schinese"
    else
      language = "tchinese"
    end
  elseif language == "korean" then
    language = "koreana"
  end
end

-- User Region
    
local region = global_user_cfg["user::general"]["ip_country"]
if not region or region == "" then
  region = user.locale.region
end

-- Save
    
global_user_cfg["user::general"]["account_name"] = account_name
global_user_cfg["user::general"]["language"] = language
global_user_cfg["user::general"]["ip_country"] = region

file.Write(path .. "/configs.user.ini", INI.Stringify(global_user_cfg))

-- Steam Loader

local backup = {}
backup["ActiveUser"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser")
backup["pid"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid")
backup["SteamClientDll"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll")
backup["SteamClientDll64"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64")
backup["Universe"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe")
backup["RunningAppID"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam", "RunningAppID")
backup["SteamExe"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam", "SteamExe")
backup["SteamPath"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam", "SteamPath")

regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser", "1999874061")
regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid", tostring(process.pid))
regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll", "%CURRENTDIR%\\steamclient.dll")
regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64", "%CURRENTDIR%\\steamclient64.dll")
regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe", "Public")
regedit.WriteDwordValue("HKCU", "Software/Valve/Steam", "RunningAppID", "813780")
regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamExe", "%CURRENTDIR%\\AoE2DE_s.exe")
regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamPath", "%CURRENTDIR%")

process.On("will-quit", function() 
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser", backup["ActiveUser"])
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid", backup["pid"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll", backup["SteamClientDll"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64", backup["SteamClientDll64"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe", backup["Universe"])
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam", "RunningAppID", backup["RunningAppID"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamExe", backup["SteamExe"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamPath", backup["SteamPath"]) 
end)
```

`example/config/C&C3 Kane's Wrath/keygen.lua`:

```lua
local regedit = require("regedit")

function randAlphaNumString(length)
    local charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    local result = {}

    for i = 1, length do
        local randIndex = math.random(1, #charset)
        result[i] = charset:sub(randIndex, randIndex)
    end

    return table.concat(result)
end

local path = "SOFTWARE/Electronic Arts/Electronic Arts/Command and Conquer 3 Kanes Wrath/ergc"
local current = regedit.QueryStringValue("HKLM", path , "")
if current == "" or current == "%CDKEY%" then
    local key = randAlphaNumString(20)
    regedit.WriteStringValue("HKLM", path, "", key)
end
```

`example/config/C&C3 Kane's Wrath/launcher.json`:

```json
{
  "bin": "RetailExe/1.2/cnc3ep1.dat",
  "args": "-config \"%CURRENTDIR%\\CNC3EP1_english_1.2.SkuDef\"",
  "script": {
    "path": "keygen.lua"
    "reg": true
  },
  "splash": {
    "show": true,
    "image": [
      "Launcher/splash.bmp"
    ]
  },
  "addons": [
    { "path": "Launcher/opencnconline.dll", "required": true }
  ],
  "integrity": [
    { 
      "sri": "sha384-DmnzXx8cJldEX+zlfSgw6WZ/8JLTTz+xN1LIah9/I7VOj+1kw8ueTby51cf069QI",
      "size": 8865840
    }
  ]
}

```

`example/config/FEAR/launcher.json`:

```json
{
  "menu": {
    "F.E.A.R.": "",
    "F.E.A.R. Extraction Point": "xp.json",
    "F.E.A.R. Perseus Mandate": "xp2.json"
  },
  "bin": "First Encounter Assault Recon/FEAR.exe",
  "env": {
    "DSOAL_LOGLEVEL": "0",
    "DSOAL_LOGFILE": ""
  },
  "script": {
    "path": "launcher.lua",
    "reg": true
  },
  "wait": true,
  "patch": {
    "LAA": true
  },
  "symlink": [
    { 
      "path": "%DOCUMENTS%/My Games/Monolith Productions/FEAR",
      "dest": "%SAVEGAME%/FEAR"
    }
  ],
  "prefix": {
    "overrides": {
      "dinput8": "native,builtin"
    }
  },
  "integrity": [
    {
      "sri": "sha384-doh4gvVCSLwZZ1TjMi7Ytm3fPrQIkat/rEE4a+O8sw+2llBMSxtKWyZT6zxiMjzm",
      "size": 1626112
    },
    {
      "path": "First Encounter Assault Recon/dinput8.dll",
      "sri": "sha384-nZVhClFs3FZkxy/GYnkFwIqwUtzm1QSXWGQkEQvjUbRygs5RhO+2xOO6GQe43GG6",
      "size": 142848
    },
    {
      "path": "First Encounter Assault Recon/dsound.dll",
      "sri": "sha384-sQ+8FlRcCpH6XIlW7lfj/GpPMH3Fg/JEiZeBZJ5yZlyvmPWEDFSbYeVf204sVOma",
      "size": 311808
    },
    {
      "path": "First Encounter Assault Recon/dsoal-aldrv.dll",
      "sri": "sha384-3Kv0NK14N4rSesVPs+p3FlYr613/xfRTvdyu1F6qQ42LJE2+mHzkNwIn7R4rvUJq",
      "size": 1546240
    },
    {
      "path": "First Encounter Assault Recon/xinput1_4.dll",
      "sri": "sha384-cw4kHL6PZ07gHYfzIGuOAfY11+IbllKznGJY96opk9nhabITuQhZr4Vxvz5UkiX8",
      "size": 1910784
    }
  ]
}
```

`example/config/FEAR/launcher.lua`:

```lua
local process = require("process")
local regedit = require("regedit")

-- EAX (DSOAL)

regedit.WriteStringValue("HKCU", "SOFTWARE/Classes/CLSID/{3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}/InprocServer32", "", "dsound.dll")
regedit.WriteStringValue("HKCU", "SOFTWARE/Classes/CLSID/{47D4D946-62E8-11CF-93BC-444553540000}/InprocServer32", "", "dsound.dll")
regedit.WriteStringValue("HKCU", "SOFTWARE/Classes/WOW6432Node/CLSID/{3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}/InprocServer32", "", "dsound.dll")
regedit.WriteStringValue("HKCU", "SOFTWARE/Classes/WOW6432Node/CLSID/{47D4D946-62E8-11CF-93BC-444553540000}/InprocServer32", "", "dsound.dll")

process.On("will-quit", function() 
  regedit.Delete("HKCU", "SOFTWARE/Classes/CLSID/{3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}")
  regedit.Delete("HKCU", "SOFTWARE/Classes/CLSID/{47D4D946-62E8-11CF-93BC-444553540000}")
  regedit.Delete("HKCU", "SOFTWARE/Classes/WOW6432Node/CLSID/{3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}")
  regedit.Delete("HKCU", "SOFTWARE/Classes/WOW6432Node/CLSID/{47D4D946-62E8-11CF-93BC-444553540000}")
end)
```

`example/config/FEAR/xp.json`:

```json
{
  "bin": "First Encounter Assault Recon/FEARXP/FEARXP.exe",
  "integrity": [
    {
      "sri": "sha384-Tr6OghUoFpuNn5awyIB/CDoIMoupY7G9b9N3g9sRFZngDtSH526DAYR0TmAWtq4g",
      "size": 9285632
    },
    {
      "path": "First Encounter Assault Recon/FEARXP/dinput8.dll",
      "sri": "sha384-nZVhClFs3FZkxy/GYnkFwIqwUtzm1QSXWGQkEQvjUbRygs5RhO+2xOO6GQe43GG6",
      "size": 142848
    },
    {
      "path": "First Encounter Assault Recon/FEARXP/dsound.dll",
      "sri": "sha384-sQ+8FlRcCpH6XIlW7lfj/GpPMH3Fg/JEiZeBZJ5yZlyvmPWEDFSbYeVf204sVOma",
      "size": 311808
    },
    {
      "path": "First Encounter Assault Recon/FEARXP/dsoal-aldrv.dll",
      "sri": "sha384-3Kv0NK14N4rSesVPs+p3FlYr613/xfRTvdyu1F6qQ42LJE2+mHzkNwIn7R4rvUJq",
      "size": 1546240
    },
    {
      "path": "First Encounter Assault Recon/FEARXP/xinput1_4.dll",
      "sri": "sha384-cw4kHL6PZ07gHYfzIGuOAfY11+IbllKznGJY96opk9nhabITuQhZr4Vxvz5UkiX8",
      "size": 1910784
    }
  ]
}

```

`example/config/FEAR/xp2.json`:

```json
{
  "bin": "First Encounter Assault Recon/FEARXP2/FEARXP2.exe",
  "integrity": [
    {
      "sri": "sha384-mRRmPWc0jmVBz25NVSnsVpS5xymkDMq2aYsDrVurbKkhF9WIHz+sbNoJUGbBreqU",
      "size": 9285632
    },
    {
      "path": "First Encounter Assault Recon/FEARXP/dinput8.dll",
      "sri": "sha384-nZVhClFs3FZkxy/GYnkFwIqwUtzm1QSXWGQkEQvjUbRygs5RhO+2xOO6GQe43GG6",
      "size": 142848
    },
    {
      "path": "First Encounter Assault Recon/FEARXP/dsound.dll",
      "sri": "sha384-sQ+8FlRcCpH6XIlW7lfj/GpPMH3Fg/JEiZeBZJ5yZlyvmPWEDFSbYeVf204sVOma",
      "size": 311808
    },
    {
      "path": "First Encounter Assault Recon/FEARXP/dsoal-aldrv.dll",
      "sri": "sha384-3Kv0NK14N4rSesVPs+p3FlYr613/xfRTvdyu1F6qQ42LJE2+mHzkNwIn7R4rvUJq",
      "size": 1546240
    },
    {
      "path": "First Encounter Assault Recon/FEARXP/xinput1_4.dll",
      "sri": "sha384-cw4kHL6PZ07gHYfzIGuOAfY11+IbllKznGJY96opk9nhabITuQhZr4Vxvz5UkiX8",
      "size": 1910784
    }
  ]
}
```

`example/config/No Man's Sky/launcher.json`:

```json
{
  "bin": "Binaries/NMS.exe",
  "env": {
    "SteamAppId": "275850",
    "SteamGameId": "275850",
    "SteamClientLaunch": "1",
    "SteamEnv": "1",
    "SteamPath": "%CURRENTDIR%\\Launcher.exe",
    "GAMEPAD_API_XINPUT": "HOOK",
    "ANYLUA_FILEPATH": "%CURRENTDIR%\\patch.lua"
  },
  "script": {
    "path": "launcher.lua",
    "fs": true,
    "reg": true
  },
  "wait": true,
  "addons": [
    { "path": "Binaries/InputFusion.asi", "required": true },
    { "path": "Binaries/AnyLua.asi", "required": true }
  ],
  "symlink": [
    {
      "path": "%APPDATA%/HelloGames/NMS",
      "dest": "%SAVEGAME%/No Man's Sky"
    }
  ],
  "shortcut": {
    "name": "No Man's Sky",
    "startmenu": true
  },
  "attrib": [
    {
      "path": "GAMEDATA/FullLog.txt",
      "readonly": true
    }
  ],
  "integrity": [
    {
      "sri": "sha384-7iKzzfcRG+OlGzlIIbvY4nYY18G5306DNNzhpuQaytFYgiUrF9moI4E1YX3dZNNQ",
      "size": 83350016
    },
    {
      "path": "Binaries/steam_api64.dll",
      "sri": "sha384-sDhT+N8bhLlmSdY6QuoCuo0qhzXbc5fAv/4jEo4MykVofuwBh7qothtCTfAaiMXY",
      "size": 298384,
      "signed": true
    },
    {
      "path": "Binaries/steamclient64.dll",
      "sri": "sha384-BnU9KVh2DVsq0eMcNVCt+nDlHiBWoyyo9rO2UYRUoIx3ySVh5c609EVMaiNaBQde",
      "size": 17849256
    },
    {
      "path": "Binaries/GameOverlayRenderer64.dll",
      "sri": "sha384-ZRnSMHuVT3aXYH8ix+K69PuH0Wr8n6gbmSsaRJLpfdXYxRB0EZkw588dQRyW7M7x",
      "size": 1946536
    },
    {
      "path": "Binaries/InputFusion.asi",
      "sri": "sha384-IWkVWnCPbL9D/qKiV+uxMR7NZ778nR9eg3W935Om0GVpC46JjKKwKRm/wjBoSzf4",
      "size": 2209280
    },
    {
      "path": "Binaries/AnyLua.asi",
      "sri": "sha384-ui9eZWcvT68zK2n4M4m7GggJSZ/smUypKVtU2MdTP7XovMpbC+GXWA3UWGgPasdf",
      "size": 582656
    }
  ]
}
```

`example/config/No Man's Sky/launcher.lua`:

```lua
local user = require("user")
local file = require("file")
local INI = require("config/ini")

local path = "%APPDATA%/GSE Saves/settings"

local content = file.Read(path .. "/configs.user.ini")
local steam = INI.Parse(content)
local update = false

if not steam["user::general"] then
  steam["user::general"] = {}
  update = true
end
    
-- User name
    
if not steam["user::general"]["account_name"] or Array.includes({"", "Noob"}, steam["user::general"]["account_name"]) then
  steam["user::general"]["account_name"] = user.name
  update = true
end
    
-- User Language
    
local steam_languages = {
  "arabic", "bulgarian", "chinese", "czech",
  "danish", "dutch", "english", "finnish", "french",
  "german", "greek", "hungarian", "italian", "japanese", 
  "korean", "norwegian", "polish", "portuguese",
  "romanian", "russian", "spanish", "swedish",
  "thai", "turkish", "ukrainian", "vietnamese"
}
    
if not steam["user::general"]["language"] or steam["user::general"]["language"] == "" then
  steam["user::general"]["language"] = user.language
  if not Array.includes(steam_languages, steam["user::general"]["language"]) then
    steam["user::general"]["language"] = "english"
  elseif steam["user::general"]["language"] == "spanish" and user.locale.region ~= "ES" then
    steam["user::general"]["language"] = "latam"
  elseif steam["user::general"]["language"] == "portuguese" and user.locale.region == "BR" then
    steam["user::general"]["language"] = "brazilian"
  elseif steam["user::general"]["language"] == "chinese" then
    if user.locale.region == "CN" or user.locale.region == "SG" then
      steam["user::general"]["language"] = "schinese"
    else
      steam["user::general"]["language"] = "tchinese"
    end
  elseif steam["user::general"]["language"] == "korean" then
    steam["user::general"]["language"] = "koreana"
  end
  update = true
end

-- User Region
    
if not steam["user::general"]["ip_country"] or steam["user::general"]["ip_country"] == "" then
  steam["user::general"]["ip_country"] = user.locale.region
  update = true
end

-- Save

if update then
  local data = INI.Stringify(steam)
  if data ~= "" then
    file.Write(path .. "/configs.user.ini", data)
  end
end

-- Steam Loader

local process = require("process")
local steamclient = require("steamclient")

if steamclient.hasGenuineDLL() then
  local backup = steamclient.backup()
  steamclient.load({})
  process.On("will-quit", function() 
    steamclient.restore(backup)
  end)
 end
```

`example/config/No Man's Sky/patch.lua`:

```lua
local memory = require("memory")

local patch = { -- Remove the "Mod Enabled" Warning screen on startup
  pattern = "48 8B 01 48 85 C0 74 08 0F B6 80 5A 46 00 00 C3", 
  offset = 0x06, 
  value = "EB",
}

function apply(patch)
  local address, err = memory.Find(patch.pattern)
  if err then
    error(err.message)
  end
  local success, err = memory.Write(address + patch.offset, patch.value)
  if err then
    error(err.message)
  end
  return success
end

if apply(patch) then
  console.log("Applied patch!")
end
```

`example/config/Quake 3/keygen.lua`:

```lua
local file = require("file")

function keygen()
    local charset = {"2", "3", "7", "a", "b", "c", "d", "g", "h", "j", "l", "p", "r", "s", "t", "w"}
    local key = ""
    for i = 1, 16 do
        key = key .. charset[math.random(#charset)]
    end
    return key
end

function getCurrentKey()
  local value, err = file.Read("baseq3/q3key")
  if err then
    return ""
  end

  local current = {}
  for line in value:gmatch("[^\r\n]+") do
      if not line:match("^//") then
          table.insert(current, line)
      end
  end
  return current[1]
end

local current = getCurrentKey()
if (current == "") then
  local arr = {}
  table.insert(arr, keygen())
  table.insert(arr, "// generated by quake, do not modify")
  table.insert(arr, "// Do not give this file to ANYONE.")
  table.insert(arr, "// id Software and Activision will NOT ask you to send this file to them.")
  local key = table.concat(arr, "\n")
  
  local err = file.Write("baseq3/q3key", key)
  if err then
    console.log(err)
  end
end

```

`example/config/Quake 3/launcher.json`:

```json
{
  "bin": "quake3.exe",
  "args": "+wait +set fs_homepath \"%SAVEGAME%\\Quake III Arena\""
  "script": {
    "path": "keygen.lua",
    "fs": true
  }
}


```

`example/config/Quake 4/launcher.json`:

```json
{
  "bin": "Quake4.exe",
  "args": "+set r_mode -1 +set r_customWidth %SCREENWIDTH% +set r_customHeight %SCREENHEIGHT% +set fs_savepath \"%SAVEGAME%\\Quake IV\"",
  "compatibility": {
    "invoker": true
  }
}



```

`example/config/Red Alert 3/keygen.lua`:

```lua
local regedit = require("regedit")
local random = require("random")

local path = "SOFTWARE/Electronic Arts/Electronic Arts/Red Alert 3/ergc"
local current = regedit.QueryStringValue("HKLM", path, "")
if current == "" or current == "%CDKEY%" then
    local key = random.AlphaNumString(20)
    regedit.WriteStringValue("HKLM", path, "", key)
end
```

`example/config/Red Alert 3/launcher.json`:

```json
{
  "bin": "Data/ra3_1.12.game",
  "args": "-config \"%CURRENTDIR%\\RA3_english_1.12.SkuDef\"",
  "script": {
    "path": "keygen.lua"
    "reg": true
  },
  "splash": {
    "show": true,
    "image": [
      "Launcher/ally_splash.bmp",
      "Launcher/empire_splash.bmp",
      "Launcher/soviet_splash.bmp"
    ]
  },
  "addons": [
    { "path": "Launcher/opencnconline.dll", "required": true }
  ],
  "integrity": [
    { 
      "sri": "sha384-v/yq054Nio/bx9xpEn/FAjQNbIf0oXhL1xxig1cf3SKNzaUvaQxXCQyZyXOwwxuA",
      "size": 9402416
    }
  ]
}
```

`example/config/Split Fiction/launcher.json`:

```json
{
  "bin": "Split/Binaries/Win64/SplitFiction.exe",
  "script": {
    "path": "launcher.lua"
    "file": true
  },
  "symlink": [
    {
      "path": "%LOCALAPPDATA%/SplitFiction",
      "dest": "%SAVEGAME%/Split Fiction"
    }
  ]
}
```

`example/config/Split Fiction/launcher.lua`:

```lua
local file = require("file")
local INI = require("config/ini")
local user = require("user")

-- Settings path

local path = "%APPDATA%/GSE Saves/settings"
local local_user_file = file.Read("Split/Binaries/Win64/steam_settings/configs.user.ini")

if local_user_file then
  user_cfg = INI.Parse(local_user_file)
  if user_cfg and user_cfg["user::saves"] then
    local_save_path = user_cfg["user::saves"]["local_save_path"]
    if not local_save_path or local_save_path == "" then
      saves_folder_name = user_cfg["user::saves"]["saves_folder_name"]
      if saves_folder_name and saves_folder_name ~= "" then
        path = "%APPDATA%/" .. saves_folder_name .. "/settings"
      end
    end
  end
end

local global_user_cfg = {}
local global_user_file = file.Read(path .. "/configs.user.ini")
if global_user_file then
  global_user_cfg = INI.Parse(global_user_file)
end

if not global_user_cfg["user::general"] then
  global_user_cfg["user::general"] = {}
end
    
-- User name
    
local account_name = global_user_cfg["user::general"]["account_name"]
if not account_name or account_name == "" or account_name == "Noob" then
  account_name = user.name
end
    
-- User Language
    
local steam_languages = {
  "arabic", "bulgarian", "chinese", "czech",
  "danish", "dutch", "english", "finnish", "french",
  "german", "greek", "hungarian", "italian", "japanese", 
  "korean", "norwegian", "polish", "portuguese",
  "romanian", "russian", "spanish", "swedish",
  "thai", "turkish", "ukrainian", "vietnamese"
}
    
local language = global_user_cfg["user::general"]["language"]
if not language or language == "" then
  language = user.language
  if not Array.includes(steam_languages, language) then
    language = "english"
  elseif language == "spanish" and user.locale.region ~= "ES" then
    language = "latam"
  elseif language == "portuguese" and user.locale.region == "BR" then
    language = "brazilian"
  elseif language == "chinese" then
    if user.locale.region == "CN" or user.locale.region == "SG" then
      language = "schinese"
    else
      language = "tchinese"
    end
  elseif language == "korean" then
    language = "koreana"
  end
end

-- User Region
    
local region = global_user_cfg["user::general"]["ip_country"]
if not region or region == "" then
  region = user.locale.region
end

-- Save
    
global_user_cfg["user::general"]["account_name"] = account_name
global_user_cfg["user::general"]["language"] = language
global_user_cfg["user::general"]["ip_country"] = region

file.Write(path .. "/configs.user.ini", INI.Stringify(global_user_cfg))
```

`example/config/Telltale Walking Dead/launcher.json`:

```json
{
  "bin": "WDC.exe",
  "script": {
    "path": "launcher.lua"
    "file": true
  },
  "env": {
    "GAMEPAD_API_XINPUT": "HOOK",
    "GAMEPAD_API_DINPUT8": "HOOK",
    "GAMEPAD_LED": "BATTERYLVL"
  },
  "addons": [
    { "path": "InputFusion.dll", "required": true }
  ]
  "symlink":[
    {
      "path": "%DOCUMENTS%/Telltale Games/The Walking Dead - The Telltale Definitive Series", 
      "dest": "%SAVEGAME%/The Walking Dead - The Telltale Definitive Series"
    }
  ]
}
```

`example/config/Telltale Walking Dead/launcher.lua`:

```lua
local file = require("file")
local user = require("user")

local path = "%APPDATA%/Goldberg SteamEmu Saves/settings/"

-- User name

local account_name = file.Read(path .. "account_name.txt")
if not account_name or account_name == "" or account_name == "Noob" then
  file.Write(path .. "account_name.txt", user.name)
end

-- User Language

local steam_languages = {
  "arabic", "bulgarian", "chinese", "czech",
  "danish", "dutch", "english", "finnish", "french",
  "german", "greek", "hungarian", "italian", "japanese", 
  "korean", "norwegian", "polish", "portuguese",
  "romanian", "russian", "spanish", "swedish",
  "thai", "turkish", "ukrainian", "vietnamese"
}

local language = file.Read(path .. "language.txt")
if not language or language == "" then
  language = user.language
  if not Array.includes(steam_languages, language) then
    language = "english"
  elseif language == "spanish" and user.locale.region ~= "ES" then
    language = "latam"
  elseif language == "portuguese" and user.locale.region == "BR" then
    language = "brazilian"
  elseif language == "chinese" then
    if user.locale.region == "CN" or user.locale.region == "SG" then
      language = "schinese"
    else
      language = "tchinese"
    end
  elseif language == "korean" then
    language = "koreana"
  end
  file.Write(path .. "language.txt", language)
end

```

`example/config/XCOM2/launcher.json`:

```json
{
  "bin": "XCom2-WarOfTheChosen/Binaries/Win64/XCom2.exe",
  "args": "-nostartupmovies -steam_auto_login -game-61483=-review -game-61483=-noRedscreens",
  "script": {
    "path": "launcher.lua"
    "file": true
  },
  "splash": {
    "show": true,
    "image": ["splash.bmp"],
    "timeout": 20,
    "wait": "cursor"
  }
}
```

`example/config/XCOM2/launcher.lua`:

```lua
local file = require("file")
local user = require("user")

local path = "%APPDATA%/Goldberg SteamEmu Saves/settings/"

-- User name

local account_name = file.Read(path .. "account_name.txt")
if not account_name or account_name == "" or account_name == "Noob" then
  file.Write(path .. "account_name.txt", user.name)
end

-- User Language

local steam_languages = {
  "arabic", "bulgarian", "chinese", "czech",
  "danish", "dutch", "english", "finnish", "french",
  "german", "greek", "hungarian", "italian", "japanese", 
  "korean", "norwegian", "polish", "portuguese",
  "romanian", "russian", "spanish", "swedish",
  "thai", "turkish", "ukrainian", "vietnamese"
}

local language = file.Read(path .. "language.txt")
if not language or language == "" then
  language = user.language
  if not Array.includes(steam_languages, language) then
    language = "english"
  elseif language == "spanish" and user.locale.region ~= "ES" then
    language = "latam"
  elseif language == "portuguese" and user.locale.region == "BR" then
    language = "brazilian"
  elseif language == "chinese" then
    if user.locale.region == "CN" or user.locale.region == "SG" then
      language = "schinese"
    else
      language = "tchinese"
    end
  elseif language == "korean" then
    language = "koreana"
  end
  file.Write(path .. "language.txt", language)
end

-- Mods

mods = file.Glob("XCom2-WarOfTheChosen/XComGame/Mods/", "*.XComMod", { recursive = true })
list = { "[Engine.XComModOptions]" }
if mods then
  for i, value in ipairs(mods) do
      table.insert(list, "ActiveMods=\"" .. file.Basename(value, false) .. "\"")
  end
end
config = table.concat(list, "\r\n")
file.Write("XCom2-WarOfTheChosen/XComGame/Config/DefaultModOptions.ini", config)
```

`example/lua script/keygen/Quake 3 Arena.lua`:

```lua
local file = require("file")

function keygen()
    local charset = {"2", "3", "7", "a", "b", "c", "d", "g", "h", "j", "l", "p", "r", "s", "t", "w"}
    local key = ""
    for i = 1, 16 do
        key = key .. charset[math.random(#charset)]
    end
    return key
end

function getCurrentKey()
  local value, err = file.Read("baseq3/q3key")
  if err then
    return ""
  end

  local current = {}
  for line in value:gmatch("[^\r\n]+") do
      if not line:match("^//") then
          table.insert(current, line)
      end
  end
  return current[1]
end

local current = getCurrentKey()
if (current == "") then
  local arr = {}
  table.insert(arr, keygen())
  table.insert(arr, "// generated by quake, do not modify")
  table.insert(arr, "// Do not give this file to ANYONE.")
  table.insert(arr, "// id Software and Activision will NOT ask you to send this file to them.")
  local key = table.concat(arr, "\n")
  
  local err = file.Write("baseq3/q3key", key)
  if err then
    console.log(err)
  end
end

```

`example/lua script/keygen/Red Alert 3.lua`:

```lua
local regedit = require("regedit")
local random = require("random")

function randAlphaNumString(length)
    local charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    local result = {}

    for i = 1, length do
        local randIndex = math.random(1, #charset)
        result[i] = charset:sub(randIndex, randIndex)
    end

    return table.concat(result)
end

local path = "SOFTWARE/Electronic Arts/Electronic Arts/Red Alert 3/ergc"
local current = regedit.QueryStringValue("HKLM", path, "")
if current == "" or current == "%CDKEY%" then
    -- randAlphaNumString(): Pure Lua implementation
    -- random.AlphaNumString(): Better "randomness"
    -- You can use either one
    local key = random.AlphaNumString(20)
    regedit.WriteStringValue("HKLM", path, "", key)
end
```

`example/lua script/mods/EAX (DSOAL) CLSID.lua`:

```lua
local process = require("process")
local regedit = require("regedit")

-- EAX (DSOAL)

regedit.WriteStringValue("HKCU", "SOFTWARE/Classes/CLSID/{3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}/InprocServer32", "", "dsound.dll")
regedit.WriteStringValue("HKCU", "SOFTWARE/Classes/CLSID/{47D4D946-62E8-11CF-93BC-444553540000}/InprocServer32", "", "dsound.dll")
regedit.WriteStringValue("HKCU", "SOFTWARE/Classes/WOW6432Node/CLSID/{3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}/InprocServer32", "", "dsound.dll")
regedit.WriteStringValue("HKCU", "SOFTWARE/Classes/WOW6432Node/CLSID/{47D4D946-62E8-11CF-93BC-444553540000}/InprocServer32", "", "dsound.dll")

process.On("will-quit", function()
  regedit.Delete("HKCU", "SOFTWARE/Classes/CLSID/{3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}")
  regedit.Delete("HKCU", "SOFTWARE/Classes/CLSID/{47D4D946-62E8-11CF-93BC-444553540000}")
  regedit.Delete("HKCU", "SOFTWARE/Classes/WOW6432Node/CLSID/{3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}")
  regedit.Delete("HKCU", "SOFTWARE/Classes/WOW6432Node/CLSID/{47D4D946-62E8-11CF-93BC-444553540000}")
end)
```

`example/lua script/mods/XCOM2.lua`:

```lua
local file = require("file")

-- Mods

mods = file.Glob("XCom2-WarOfTheChosen/XComGame/Mods/", "*.XComMod", { recursive = true })
list = { "[Engine.XComModOptions]" }
if mods then
  for i, value in ipairs(mods) do
      table.insert(list, "ActiveMods=\"" .. file.Basename(value, false) .. "\"")
  end
end
config = table.concat(list, "\r\n")
file.Write("XCom2-WarOfTheChosen/XComGame/Config/DefaultModOptions.ini", config)
```

`example/lua script/playtime/playtime.lua`:

```lua
local time = require("time")
local process = require("process")

local started = time.Current()
process.On("will-quit", function() -- Use option `wait: true` in launcher.json
  local playtime = time.Current() - started
  console.log("You played for " .. time.HumanizeDuration(playtime))
end)
```

`example/lua script/steam emu/CDX-RUNE.lua`:

```lua
local user = require("user")
local file = require("file")
local INI = require("config/ini")

local filePath = "steam_emu.ini"

local steam_languages = {
  "arabic", "bulgarian", "chinese", "czech",
  "danish", "dutch", "english", "finnish", "french",
  "german", "greek", "hungarian", "italian", "japanese", 
  "korean", "norwegian", "polish", "portuguese",
  "romanian", "russian", "spanish", "swedish",
  "thai", "turkish", "ukrainian", "vietnamese"
}

local content, err = file.Read(filePath)
if err or content == "" then
  return
end

local steam = INI.Parse(content)
local update = false

if steam["Settings"] then
  if not steam["Settings"]["UserName"] or Array.includes({"", "CODEX", "RUNE"}, steam["Settings"]["UserName"]) then
    steam["Settings"]["UserName"] = user.name
    update = true
  end

  if not steam["Settings"]["Language"] or steam["Settings"]["Language"] == "" then
    steam["Settings"]["Language"] = user.language
    if not Array.includes(steam_languages, steam["Settings"]["Language"]) then
      steam["Settings"]["Language"] = "english"
    elseif steam["Settings"]["Language"] == "spanish" and user.locale.region ~= "ES" then
      steam["Settings"]["Language"] = "latam"
    elseif steam["Settings"]["Language"] == "portuguese" and user.locale.region == "BR" then
      steam["Settings"]["Language"] = "brazilian"
    elseif steam["Settings"]["Language"] == "chinese" then
      if user.locale.region == "CN" or user.locale.region == "SG" then
        steam["Settings"]["Language"] = "schinese"
      else
        steam["Settings"]["Language"] = "tchinese"
      end
    elseif steam["Settings"]["Language"] == "korean" then
      steam["Settings"]["Language"] = "koreana"
    end
    update = true
  end
end
  
if update then
  local data = INI.Stringify(steam, { 
    whitespace = false, 
    blankLine = true 
  })
  
  if data ~= "" then
    file.Write(filePath, data)
  end
end
```

`example/lua script/steam emu/GBE Fork.lua`:

```lua
local user = require("user")
local file = require("file")
local INI = require("config/ini")

local path = "%APPDATA%/GSE Saves/settings"

local content = file.Read(path .. "/configs.user.ini")
local steam = INI.Parse(content, {
  number = false
})
local update = false

if not steam["user::general"] then
  steam["user::general"] = {}
  update = true
end
    
-- User name
    
if not steam["user::general"]["account_name"] or Array.includes({"", "Noob"}, steam["user::general"]["account_name"]) then
  steam["user::general"]["account_name"] = user.name
  update = true
end
    
-- User Language
    
local steam_languages = {
  "arabic", "bulgarian", "chinese", "czech",
  "danish", "dutch", "english", "finnish", "french",
  "german", "greek", "hungarian", "italian", "japanese", 
  "korean", "norwegian", "polish", "portuguese",
  "romanian", "russian", "spanish", "swedish",
  "thai", "turkish", "ukrainian", "vietnamese"
}
    
if not steam["user::general"]["language"] or steam["user::general"]["language"] == "" then
  steam["user::general"]["language"] = user.language
  if not Array.includes(steam_languages, steam["user::general"]["language"]) then
    steam["user::general"]["language"] = "english"
  elseif steam["user::general"]["language"] == "spanish" and user.locale.region ~= "ES" then
    steam["user::general"]["language"] = "latam"
  elseif steam["user::general"]["language"] == "portuguese" and user.locale.region == "BR" then
    steam["user::general"]["language"] = "brazilian"
  elseif steam["user::general"]["language"] == "chinese" then
    if user.locale.region == "CN" or user.locale.region == "SG" then
      steam["user::general"]["language"] = "schinese"
    else
      steam["user::general"]["language"] = "tchinese"
    end
  elseif steam["user::general"]["language"] == "korean" then
    steam["user::general"]["language"] = "koreana"
  end
  update = true
end

-- User Region
    
if not steam["user::general"]["ip_country"] or steam["user::general"]["ip_country"] == "" then
  steam["user::general"]["ip_country"] = user.locale.region
  update = true
end

-- Save

if update then
  local data = INI.Stringify(steam)
  if data ~= "" then
    file.Write(path .. "/configs.user.ini", data)
  end
end

-- Steam Loader

local process = require("process")
local steamclient = require("steamclient")
local SteamID = require("SteamID")

-- NB: You also have to set env var with `env:{key:value,...}` in launcher.json
-- Example: 
-- "env": {
--    "SteamAppId": "480",
--    "SteamGameId": "480",
--    "SteamClientLaunch": "1",
--    "SteamEnv": "1",
--    "SteamPath": "%CURRENTDIR%\\Launcher.exe"
-- }
-- You need to use option `wait: true` in launcher.json if you want to restore modified values on game exit
-- To force inject steamclient/GameOverlayRenderer dll(s) use the `addons` option in launcher.json

if steamclient.HasGenuineDLL() then
  local client = {}
  local sid64 = steam["user::general"]["account_steamid"]
  if sid64 ~= "" then
    client.user = SteamID(sid64).accountid
  end

  local backup = steamclient.Backup()
  steamclient.Load(client)
  process.On("will-quit", function() 
    steamclient.Restore(backup)
  end)
 end
```

`example/lua script/steam emu/GSE.lua`:

```lua
local file = require("file")
local user = require("user")

local path = "%APPDATA%/Goldberg SteamEmu Saves/settings/"

-- User name

local account_name = file.Read(path .. "account_name.txt")
if account_name == "" or account_name == "Noob" then
  file.Write(path .. "account_name.txt", user.name)
end

-- User Language

local steam_languages = {
  "arabic", "bulgarian", "chinese", "czech",
  "danish", "dutch", "english", "finnish", "french",
  "german", "greek", "hungarian", "italian", "japanese", 
  "korean", "norwegian", "polish", "portuguese",
  "romanian", "russian", "spanish", "swedish",
  "thai", "turkish", "ukrainian", "vietnamese"
}

local language = file.Read(path .. "language.txt")
if language == "" then
  language = user.language
  if not Array.includes(steam_languages, language) then
    language = "english"
  elseif language == "spanish" and user.locale.region ~= "ES" then
    language = "latam"
  elseif language == "portuguese" and user.locale.region == "BR" then
    language = "brazilian"
  elseif language == "chinese" then
    if user.locale.region == "CN" or user.locale.region == "SG" then
      language = "schinese"
    else
      language = "tchinese"
    end
  elseif language == "korean" then
    language = "koreana"
  end
  file.Write(path .. "language.txt", language)
end
```

`example/lua script/steam emu/steamclient.lua`:

```lua
-- Copyright (c) Anthony Beaumont
-- This source code is licensed under the MIT License
-- found in the LICENSE file in the root directory of this source tree.

-- This is now integrated into the Launcher:
-- local steamclient = require("steamclient")
-- cf: https://github.com/xan105/Mini-Launcher#-steam-client

local file = require("file")
local regedit = require("regedit")
local process = require("process")

local steamclient = {}

function steamclient.HasGenuineDLL()
  local dlls = {"steam_api64.dll", "steam_api.dll"}
  for _, dll in ipairs(dlls) do
    local path = file.Glob(process.Cwd(), dll, { recursive = true })
    if path[1] and path[1] ~= "" then
      local info = file.Info(path[1])
      return info.signed
    end
  end
  return false
end

function steamclient.Backup()
  local backup = {}
  backup["ActiveUser"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser")
  backup["pid"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid")
  backup["SteamClientDll"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll")
  backup["SteamClientDll64"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64")
  backup["Universe"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe")
  backup["RunningAppID"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam", "RunningAppID")
  backup["SteamExe"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam", "SteamExe")
  backup["SteamPath"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam", "SteamPath")
  return backup
end

function steamclient.Restore(backup)
  assert(type(backup) == "table" and next(backup) ~= nil, "Expected non-empty table!")
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser", backup["ActiveUser"])
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid", backup["pid"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll", backup["SteamClientDll"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64", backup["SteamClientDll64"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe", backup["Universe"])
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam", "RunningAppID", backup["RunningAppID"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamExe", backup["SteamExe"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamPath", backup["SteamPath"])
end

function steamclient.Load(client)
  client = client or {}
  assert(type(client) == "table", "Expected table!")

  if not client.appid ~= "" then
    local paths = file.Glob(process.Cwd(), "steam_appid.txt", {
      recursive = true
    })
    for _, path in ipairs(paths) do
      client.appid = file.Read(path)
      if client.appid ~= "" then
        break
      end
    end  
  end

  if not client.dll ~= "" then
    local paths, err = file.Glob(process.Cwd(), "steamclient.dll", {
      recursive = true,
      absolute = true
    })
    for _, path in ipairs(paths) do
      local info = file.Info(path)
      if not info.signed then
        client.dll = path
        break
      end
    end
  end

  if not client.dll64 ~= "" then
    local paths = file.Glob(process.Cwd(), "steamclient64.dll", {
      recursive = true,
      absolute = true
    })
    for _, path in ipairs(paths) do
      local info = file.Info(path)
      if not info.signed then
        client.dll64 = path
        break
      end
    end
  end
  
  if type(client.user) ~= "number" or client.user % 1 ~= 0 or client.user == 0 then
    client.user = 1999874061
  end

  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser", tostring(client.user))
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid", tostring(process.pid))
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll", client.dll)
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64", client.dll64)
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe", "Public")
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam", "RunningAppID", client.appid)
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamExe", process.ExecPath())
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamPath", process.Cwd())  
end

return steamclient
```

`example/lua script/updater/FFNx (semver).lua`:

```lua
local file = require("file")
local http = require("http")
local JSON = require("config/json")
local time = require("time")
local archive = require("archive")

local DIR = "%CURRENTDIR%/"
local FILEPATH = DIR .. "AF3DN.P"
local REPO = "julianxhokaxhiu/FFNx"
local ASSET = "^FFNx%-Steam%-v[%d%.]+%.zip$"
local URL = "https://api.github.com/repos/" .. REPO .. "/releases/latest"

function parse_version(str)
  local major, minor, build, revision = str:match("^(%d+)%.(%d+)%.(%d+)%.?(%d*)$")
  return {
    major    = tonumber(major) or 0,
    minor    = tonumber(minor) or 0,
    build    = tonumber(build) or 0,
    revision = tonumber(revision) or 0
  }
end

function compare_versions(a, b)
  if a.major > b.major then
    return true
  elseif a.major < b.major then
    return false
  elseif a.minor > b.minor then
    return true
  elseif a.minor < b.minor then
    return false
  elseif a.build > b.build then
    return true
  elseif a.build < b.build then
    return false
  elseif a.revision > b.revision then
    return true
  else
    return false
  end
end

local info, err = file.Info(FILEPATH)
if err then
  error(err.message)
end

local res, err = http.Fetch(URL, {
  method = "GET",
  headers = {
    ["Accept"] = "application/vnd.github.v3+json",
    ["User-Agent"] = "Chrome/"
  }
})
if err then 
  error(err.message)
end

local github, err = JSON.Parse(res.body)
if err then
  error(err.message)
end

local remote = parse_version(github["tag_name"])
if compare_versions(remote, info.version) then

  local target = Array.find(github.assets, function(asset) return asset.name:match(ASSET) end)
  if not target then
    error("No asset found in GitHub response")
  end

  local TMP = "%TEMP%/FFNX"
  
  local path, err = http.Download(target.browser_download_url, TMP)
  if err then
    error(err.message)
  end

  local err = archive.Unzip(path, DIR, { "steam_api.dll" })
  file.Remove(TMP)
  if err then
    error(err.message)
  end

end
```

`example/lua script/updater/Quake3e (timestamp).lua`:

```lua
local file = require("file")
local http = require("http")
local JSON = require("config/json")
local time = require("time")
local archive = require("archive")

local DIR = "bin/"
local FILEPATH = DIR .. "quake3e-vulkan.x64.exe"
local REPO = "ec-/Quake3e"
local ASSET = "quake3e-windows-msvc-x86_64.zip"
local URL = "https://api.github.com/repos/" .. REPO .. "/releases/latest"

local info, err = file.Info(FILEPATH)
if err then
  error(err.message)
end

local res, err = http.Fetch(URL, {
  method = "GET",
  headers = {
    ["Accept"] = "application/vnd.github.v3+json",
    ["User-Agent"] = "Chrome/"
  }
})
if err then 
  error(err.message)
end

local github, err = JSON.Parse(res.body)
if err then
  error(err.message)
end

local target = Array.find(github.assets, function(asset) return asset.name == ASSET end)
if not target then
  error("No asset found in GitHub response")
end

if(time.ToUnix(target.updated_at) > info.time.modification) then

  local TMP = "%TEMP%/Quake3"
  
  local path, err = http.Download(target.browser_download_url, TMP)
  if err then
    error(err.message)
  end

  local err = archive.Unzip(path, DIR)
  file.Remove(TMP)
  if err then
    error(err.message)
  end
  
end
```

`src/addons.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "os"
  "strings"
  "runtime"
  "path/filepath"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/internal/pe"
  "launcher/internal/thread"
)

func loadAddons(binary string, process *os.Process, addons []Addon) {
  if addons != nil && len(addons) > 0 {
    targetArch, err := pe.GetArchFromMachineType(binary)
    for _, addon := range addons {
      if len(addon.Path) > 0 {
        dylib := fs.Resolve(expand.ExpandVariables(addon.Path))
        ext := strings.ToLower(filepath.Ext(dylib))
        if ext == ".dll" || ext == ".asi" {
          if ok, _ := fs.FileExist(dylib); ok {

            if targetArch != runtime.GOARCH {
              if addon.Required {
                process.Kill()
                if err != nil {
                  panic("Remote Thread", "\"" + filepath.Base(binary) + "\": " + err.Error())
                } else {
                  panic("Remote Thread", "\"" + filepath.Base(binary)  + "\" and the Launcher are of different architecture!")
                }
              } else {
                continue
              } 
            }
            
            if arch, err := pe.GetArchFromMachineType(dylib); arch != runtime.GOARCH {
              if addon.Required {
                process.Kill()
                if err != nil {
                  panic("Remote Thread", "\"" + filepath.Base(dylib) + "\": " + err.Error())
                } else {
                  panic("Remote Thread", "\"" + filepath.Base(dylib)  + "\" and the target process are of different architecture!")
                }
              } else {
                continue
              }
            }
   
            if err := thread.CreateRemoteThread(process.Pid, dylib); err != nil {
              if addon.Required {
                process.Kill()
                panic("Remote Thread", "\"" + filepath.Base(dylib) + "\": " + err.Error())
              } else {
                continue
              }
            }
            
          }
        }
      }
    }
  }
}
```

`src/alert.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "os"
  "log/slog"
  "golang.org/x/sys/windows"
  "launcher/lua"
)

func alert(title string, message string){
  slog.Warn(message)
  windows.MessageBox(
    windows.HWND(uintptr(0)),
    windows.StringToUTF16Ptr(message),
    windows.StringToUTF16Ptr(title),
    windows.MB_OK,
  )
}

func panic(title string, message string){
  slog.Error(message)
  windows.MessageBox(
    windows.HWND(uintptr(0)),
    windows.StringToUTF16Ptr(message),
    windows.StringToUTF16Ptr(title),
    windows.MB_OK | windows.MB_ICONERROR,
  )
  lua.CloseLua()
  os.Exit(1)
}
```

`src/attrib.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "launcher/internal/fs"
  "launcher/internal/expand"
)

func applyFileAttributes(attributes []Attrib) {
  if attributes != nil && len(attributes) > 0 {
    for _, attribute := range attributes {
      if len(attribute.Path) > 0 {
        file := fs.Resolve(expand.ExpandVariables(attribute.Path))
        if ok, _ := fs.FileExist(file); ok {   
          err := fs.SetFileAttributes(file, attribute.ReadOnly, attribute.Hidden)
          if err != nil {
            panic("File Attribute", err.Error())
          }
        }
      }
    }
  }
}
```

`src/cmdLine.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "os"
  "flag"
)

type Args struct {
  Help        bool
  DryRun      bool
  ConfigPath  string
}

func parseArgs() (Args) {
  var args Args
  
  flag.BoolVar(&args.Help, "help", false, "Show list of all arguments.")
  flag.BoolVar(&args.DryRun, "dry-run", false, "Program will exit before starting the executable.")
  flag.StringVar(&args.ConfigPath, "config", "launcher.json", "File path to the config file to use.")
  flag.Parse()
  
  if args.Help {
    alert(
      "Launcher",
      "--config filePath\n" +
      "File path to the config file to use.\n" +
      "--dry-run\n" +
      "Program will exit before starting the executable.\n" +
      "\n" +
      "--help\n" +
      "Show list of all arguments\n",
    )
    os.Exit(0)
  }
  return args
}


```

`src/compatibility.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "slices"
  "strings"
  "launcher/internal/regedit"
  "launcher/internal/wine"
)

func setCompatFlags(binary string, flags CompatFlags) {

  //Win10: "~ [Fullscreen Optimization] + [Privilege Level] + [Flags...] + [Compatibility Mode]"

  const path = "Software/Microsoft/Windows NT/CurrentVersion/AppCompatFlags/Layers"
  template := []string{}
    
  if flags.Fullscreen != nil && *flags.Fullscreen {
    template = append(template, "DISABLEDXMAXIMIZEDWINDOWEDMODE")
  }

  if flags.Admin != nil && *flags.Admin {
    template = append(template, "RUNASADMIN")
  } else if flags.Invoker != nil && *flags.Invoker {
    template = append(template, "RUNASINVOKER")
  }
    
  if flags.Aware != nil && *flags.Aware {
    template = append(template, "HIGHDPIAWARE")
  }
    
  if len(flags.Version) > 0 {
    versions := []string{
      "WIN95",
      "WIN98", 
      "WIN2000",
      "WINXP", 
      "WINXPSP1",
      "WINXPSP2",
      "WINXPSP3",
      "VISTARTM",
      "VISTASP1",
      "VISTASP2",
      "WIN7RTM",
      "WIN8RTM",
    }
    if slices.Contains(versions, flags.Version) {
      template = append(template, flags.Version)
    }
  }

  if len(template) > 0 {
    slices.Insert(template, 0, "~")
    regedit.WriteStringValue("HKCU", path, binary, strings.Join(template, " "))
  } else {
    regedit.DeleteValue("HKCU", path, binary)
  }
}

func updatePrefixSettings(prefix WinePrefix) {

  if !wine.IsWineOrProton() { return }

  if len(prefix.WinVer) > 0 {
    versions := []string{
      "win11",
      "win10",
      "win81", 
      "win8", 
      "win7",  
      "vista", 
      "winxp",
    }
    if slices.Contains(versions, prefix.WinVer) {
      regedit.WriteStringValue("HKCU", "HKCU/Software/Wine", "Version", prefix.WinVer)
    }
  }
  
  if prefix.DPI >= 96 && prefix.DPI <= 480 {
    regedit.WriteDwordValue("HKCU", "Control Panel/Desktop", "LogPixels", prefix.DPI)
  }
  
  if len(prefix.DllOverrides) > 0 {
    overrides := []string{
      "native,builtin",
      "builtin,native",
      "native",
      "builtin",
    }
    for dll, override := range prefix.DllOverrides {
      if len(dll) > 0 && len(override) > 0 {
        if slices.Contains(overrides, override) {
          regedit.WriteStringValue("HKCU", "HKCU/Software/Wine/DllOverrides", strings.ToLower(dll), override)
        }
      }
    }
  }
}
```

`src/config.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

type Addon struct {
  Path            string               `json:"path"`
  Required        bool                 `json:"required"`
}

type File struct {
  Path            string               `json:"path"`
  SRI             string               `json:"sri"` 
  Size            int64                `json:"size"`
  Signed          bool                 `json:"signed"`
}

type Splash struct {
  Show            *bool               `json:"show"`
  Images          []string            `json:"image"`
  Timeout         uint                `json:"timeout"`
  Wait            string              `json:"wait"`
}

type Link struct {
  Origin          string              `json:"path"`
  Destination     string              `json:"dest"`
}

type Attrib struct {
  Path            string               `json:"path"`
  Hidden          bool                 `json:"hidden"` 
  ReadOnly        bool                 `json:"readonly"`
}

type CompatFlags struct {
  Version         string              `json:"version"`
  Fullscreen      *bool               `json:"fullscreen"`
  Admin           *bool               `json:"admin"`
  Invoker         *bool               `json:"invoker"`
  Aware           *bool               `json:"aware"`
}

type Patch struct {
  LAA             *bool               `json:"laa"`
}

type WinePrefix struct {
  WinVer          string              `json:"winver"`
  DllOverrides    map[string]string   `json:"overrides"`
  DPI             uint32              `json:"dpi"`
}

type Script struct {
  Path            string              `json:"path"`
  Fs              *bool               `json:"fs"`
  Net             *bool               `json:"net"`
  Reg             *bool               `json:"reg"`
  Exec            *bool               `json:"exec"`
  Import          *bool               `json:"import"`
}

type Shortcut struct {
  Name            string              `json:"name"`
  Desktop         *bool               `json:"desktop"`
  StartMenu       *bool               `json:"startmenu"`
}

type Config struct {
  Bin             string              `json:"bin"`
  Cwd             string              `json:"cwd"`
  Args            string              `json:"args"`
  Priority        string              `json:"priority"`
  Env             map[string]string   `json:"env"`
  Hide            *bool               `json:"hide"`
  Shell           *bool               `json:"shell"`
  Wait            *bool               `json:"wait"`
  Suspended       *bool               `json:"suspended"`
  Affinity        []uint              `json:"affinity"`
  Script          Script              `json:"script"`
  Addons          []Addon             `json:"addons"`
  Integrity       []File              `json:"integrity"`
  Splash          Splash              `json:"splash"`
  Symlink         []Link              `json:"symlink"`
  Compatibility   CompatFlags         `json:"compatibility"`
  Patch           Patch               `json:"patch"`
  Prefix          WinePrefix          `json:"prefix"`
  Attrib          []Attrib            `json:"attrib"`
  Menu            map[string]string   `json:"menu"`
  Shortcut        Shortcut            `json:"shortcut"`
}

func mergeConfig(config *Config, override *Config) {
  
  //string
  if len(override.Bin) > 0 { config.Bin = override.Bin }
  if len(override.Cwd) > 0 { config.Cwd = override.Cwd }
  if len(override.Args) > 0 { config.Args = override.Args }
  if len(override.Priority) > 0 { config.Priority = override.Priority }
  
  //bool
  if override.Hide != nil { config.Hide = override.Hide }
  if override.Shell != nil { config.Shell = override.Shell }
  if override.Wait != nil { config.Wait = override.Wait }
  if override.Suspended != nil { config.Suspended = override.Suspended }
  
  //map
  if len(override.Env) > 0 {
    for k, v := range override.Env { config.Env[k] = v }
  }
  
  //Array
  if override.Addons != nil && len(override.Addons) > 0 { config.Addons = override.Addons }
  if override.Integrity != nil && len(override.Integrity) > 0 { config.Integrity = override.Integrity }
  if override.Symlink != nil && len(override.Symlink) > 0 { config.Symlink = override.Symlink }
  if override.Attrib != nil && len(override.Attrib) > 0 { config.Attrib = override.Attrib }
  if override.Affinity != nil && len(override.Affinity) > 0 { config.Affinity = override.Affinity }
  
  //Nested
  if len(override.Script.Path) > 0 { config.Script.Path = override.Script.Path }
  if override.Script.Fs != nil { config.Script.Fs = override.Script.Fs }
  if override.Script.Net != nil { config.Script.Net = override.Script.Net }
  if override.Script.Reg != nil { config.Script.Reg = override.Script.Reg }
  if override.Script.Exec != nil { config.Script.Exec = override.Script.Exec }
  if override.Script.Import != nil { config.Script.Import = override.Script.Import }
  
  if len(override.Shortcut.Name) > 0 { config.Shortcut.Name = override.Shortcut.Name }
  if override.Shortcut.Desktop != nil { config.Shortcut.Desktop = override.Shortcut.Desktop }
  if override.Shortcut.StartMenu != nil { config.Shortcut.StartMenu = override.Shortcut.StartMenu }

  if override.Splash.Show != nil { config.Splash.Show = override.Splash.Show }
  if override.Splash.Images != nil && len(override.Splash.Images) > 0 { config.Splash.Images = override.Splash.Images }
  if override.Splash.Timeout > 0 { config.Splash.Timeout = override.Splash.Timeout }
  if len(override.Splash.Wait) > 0 { config.Splash.Wait = override.Splash.Wait }
  
  if len(override.Compatibility.Version) > 0 { config.Compatibility.Version = override.Compatibility.Version }
  if override.Compatibility.Fullscreen != nil  { config.Compatibility.Fullscreen = override.Compatibility.Fullscreen }
  if override.Compatibility.Admin != nil { config.Compatibility.Admin = override.Compatibility.Admin }
  if override.Compatibility.Invoker != nil { config.Compatibility.Invoker = override.Compatibility.Invoker }
  if override.Compatibility.Aware != nil { config.Compatibility.Aware = override.Compatibility.Aware }
  
  if override.Patch.LAA != nil { config.Patch.LAA = override.Patch.LAA }
  
  if len(override.Prefix.WinVer) > 0 { config.Prefix.WinVer = override.Prefix.WinVer }
  if override.Prefix.DPI > 0 { config.Prefix.DPI = override.Prefix.DPI }
  if len(override.Prefix.DllOverrides) > 0 {
    for k, v := range override.Prefix.DllOverrides {
      config.Prefix.DllOverrides[k] = v
    }
  }
}
```

`src/go.mod`:

```mod
module launcher

go 1.26.0

require (
	github.com/yuin/gopher-lua v1.1.1
	golang.org/x/sys v0.41.0
)

require golang.org/x/text v0.34.0

require github.com/pelletier/go-toml/v2 v2.2.4

require (
	github.com/bodgit/sevenzip v1.6.1
	github.com/go-ole/go-ole v1.3.0
	gopkg.in/yaml.v3 v3.0.1
)

require (
	github.com/andybalholm/brotli v1.2.0 // indirect
	github.com/bodgit/plumbing v1.3.0 // indirect
	github.com/bodgit/windows v1.0.1 // indirect
	github.com/hashicorp/golang-lru/v2 v2.0.7 // indirect
	github.com/klauspost/compress v1.18.4 // indirect
	github.com/pierrec/lz4/v4 v4.1.25 // indirect
	github.com/spf13/afero v1.15.0 // indirect
	github.com/ulikunitz/xz v0.5.15 // indirect
	go4.org v0.0.0-20260112195520-a5071408f32f // indirect
)

require (
	github.com/clbanning/mxj/v2 v2.7.0
	github.com/google/go-cmp v0.7.0 // indirect
)

```

`src/go.sum`:

```sum
github.com/andybalholm/brotli v1.2.0 h1:ukwgCxwYrmACq68yiUqwIWnGY0cTPox/M94sVwToPjQ=
github.com/andybalholm/brotli v1.2.0/go.mod h1:rzTDkvFWvIrjDXZHkuS16NPggd91W3kUSvPlQ1pLaKY=
github.com/bodgit/plumbing v1.3.0 h1:pf9Itz1JOQgn7vEOE7v7nlEfBykYqvUYioC61TwWCFU=
github.com/bodgit/plumbing v1.3.0/go.mod h1:JOTb4XiRu5xfnmdnDJo6GmSbSbtSyufrsyZFByMtKEs=
github.com/bodgit/sevenzip v1.6.1 h1:kikg2pUMYC9ljU7W9SaqHXhym5HyKm8/M/jd31fYan4=
github.com/bodgit/sevenzip v1.6.1/go.mod h1:GVoYQbEVbOGT8n2pfqCIMRUaRjQ8F9oSqoBEqZh5fQ8=
github.com/bodgit/windows v1.0.1 h1:tF7K6KOluPYygXa3Z2594zxlkbKPAOvqr97etrGNIz4=
github.com/bodgit/windows v1.0.1/go.mod h1:a6JLwrB4KrTR5hBpp8FI9/9W9jJfeQ2h4XDXU74ZCdM=
github.com/clbanning/mxj/v2 v2.7.0 h1:WA/La7UGCanFe5NpHF0Q3DNtnCsVoxbPKuyBNHWRyME=
github.com/clbanning/mxj/v2 v2.7.0/go.mod h1:hNiWqW14h+kc+MdF9C6/YoRfjEJoR3ou6tn/Qo+ve2s=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/go-ole/go-ole v1.3.0 h1:Dt6ye7+vXGIKZ7Xtk4s6/xVdGDQynvom7xCFEdWr6uE=
github.com/go-ole/go-ole v1.3.0/go.mod h1:5LS6F96DhAwUc7C+1HLexzMXY1xGRSryjyPPKW6zv78=
github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
github.com/hashicorp/golang-lru/v2 v2.0.7 h1:a+bsQ5rvGLjzHuww6tVxozPZFVghXaHOwFs4luLUK2k=
github.com/hashicorp/golang-lru/v2 v2.0.7/go.mod h1:QeFd9opnmA6QUJc5vARoKUSoFhyfM2/ZepoAG6RGpeM=
github.com/klauspost/compress v1.18.4 h1:RPhnKRAQ4Fh8zU2FY/6ZFDwTVTxgJ/EMydqSTzE9a2c=
github.com/klauspost/compress v1.18.4/go.mod h1:R0h/fSBs8DE4ENlcrlib3PsXS61voFxhIs2DeRhCvJ4=
github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=
github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=
github.com/pierrec/lz4/v4 v4.1.25 h1:kocOqRffaIbU5djlIBr7Wh+cx82C0vtFb0fOurZHqD0=
github.com/pierrec/lz4/v4 v4.1.25/go.mod h1:EoQMVJgeeEOMsCqCzqFm2O0cJvljX2nGZjcRIPL34O4=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/spf13/afero v1.15.0 h1:b/YBCLWAJdFWJTN9cLhiXXcD7mzKn9Dm86dNnfyQw1I=
github.com/spf13/afero v1.15.0/go.mod h1:NC2ByUVxtQs4b3sIUphxK0NioZnmxgyCrfzeuq8lxMg=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/ulikunitz/xz v0.5.15 h1:9DNdB5s+SgV3bQ2ApL10xRc35ck0DuIX/isZvIk+ubY=
github.com/ulikunitz/xz v0.5.15/go.mod h1:nbz6k7qbPmH4IRqmfOplQw/tblSgqTqBwxkY0oWt/14=
github.com/xyproto/randomstring v1.0.5 h1:YtlWPoRdgMu3NZtP45drfy1GKoojuR7hmRcnhZqKjWU=
github.com/xyproto/randomstring v1.0.5/go.mod h1:rgmS5DeNXLivK7YprL0pY+lTuhNQW3iGxZ18UQApw/E=
github.com/yuin/gopher-lua v1.1.1 h1:kYKnWBjvbNP4XLT3+bPEwAXJx262OhaHDWDVOPjL46M=
github.com/yuin/gopher-lua v1.1.1/go.mod h1:GBR0iDaNXjAgGg9zfCvksxSRnQx76gclCIb7kdAd1Pw=
go4.org v0.0.0-20260112195520-a5071408f32f h1:ziUVAjmTPwQMBmYR1tbdRFJPtTcQUI12fH9QQjfb0Sw=
go4.org v0.0.0-20260112195520-a5071408f32f/go.mod h1:ZRJnO5ZI4zAwMFp+dS1+V6J6MSyAowhRqAE+DPa1Xp0=
golang.org/x/sync v0.19.0 h1:vV+1eWNmZ5geRlYjzm2adRgW2/mcpevXNg50YZtPCE4=
golang.org/x/sync v0.19.0/go.mod h1:9KTHXmSnoGruLpwFjVSX0lNNA75CykiMECbovNTZqGI=
golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.41.0 h1:Ivj+2Cp/ylzLiEU89QhWblYnOE9zerudt9Ftecq2C6k=
golang.org/x/sys v0.41.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.34.0 h1:oL/Qq0Kdaqxa1KbNeMKwQq0reLCCaFtqu2eNuSeNHbk=
golang.org/x/text v0.34.0/go.mod h1:homfLqTYRFyVYemLBFl5GgL/DWEiH5wcsQ5gSh1yziA=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

```

`src/integrity.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "os"
  "strings"
  "regexp"
  "errors"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/internal/trust"
)

func verifyIntegrity(binary string, files []File) {
  if files != nil && len(files) > 0 {
    for _, file := range files {
      
      target := binary
      if len(file.Path) > 0 {
        target = fs.Resolve(expand.ExpandVariables(file.Path))
      }
      
      stats, err := os.Stat(target)
      if err != nil { 
        if errors.Is(err, os.ErrNotExist) {
          panic("Integrity failure", "File does not exist: \"" + target + "\"") 
        }
        panic("Integrity failure", err.Error())  
      }
      if file.Size > 0 && stats.Size() != file.Size { 
        panic("Integrity failure", "Size mismatch: \"" + target + "\"") 
      }
      
      re := regexp.MustCompile(`(?i)^(sha(?:256|384|512)-[A-Za-z0-9+/=]{43,}={0,2})$`)
      if !re.MatchString(file.SRI) {
        panic("Integrity failure", "Unexpected SRI format: \"" + file.SRI + "\"")
      }
      
      SRI := strings.SplitN(file.SRI, "-", 2)
      if len(SRI) != 2 {
        panic("Integrity failure", "Failed to parse SRI: \"" + file.SRI + "\"")
      }

      algo, expected := SRI[0], SRI[1]
      sum, err := fs.CheckSum(target, algo)
      if err != nil { panic("Integrity failure", err.Error()) }
      if sum != expected { 
        panic("Integrity failure", 
              "Hash mismatch: \"" + target + "\"\n" +
              "SRI: " + algo + "-" + sum)
      }
      
      if file.Signed {
        if ok, err := trust.VerifySignature(target); !ok {
          panic("Integrity failure", "File is not signed: \"" + target + "\"\n\nError: " + err.Error())   
        }
      }

    }
  }
}
```

`src/internal/affinity/affinity.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package affinity

import (
  "golang.org/x/sys/windows"
)

var (
  kernel32                  = windows.NewLazySystemDLL("kernel32.dll")
  pSetProcessAffinityMask   = kernel32.NewProc("SetProcessAffinityMask")
)

func SetProcessAffinity(pid int, logicalCores []uint) error {

  hProcess, err := windows.OpenProcess(
    windows.PROCESS_SET_INFORMATION,
    false,
    uint32(pid),
  )
  if err != nil {
    return err
  }
  defer windows.CloseHandle(hProcess)
  
  var mask uintptr = 0;
  for _, core := range logicalCores {
    mask |= uintptr(1) << core
  }

  ret, _, err := pSetProcessAffinityMask.Call(
    uintptr(hProcess), 
    mask,
  )
  if ret == 0 {
    return err
  }
  return nil
}
```

`src/internal/elevated/elevated.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package elevated

import (
  "os"
  "strings"
  "unsafe"
  "golang.org/x/sys/windows"
)

func IsElevated() bool {

  hProcess, err := windows.GetCurrentProcess()
  if err != nil {
    return false
  }

  var token windows.Token
  if err := windows.OpenProcessToken(hProcess, windows.TOKEN_QUERY, &token); err != nil {
    return false
  }
  defer token.Close()

  var elevation uint32
  var returned uint32
  if err := windows.GetTokenInformation(
    token,
    windows.TokenElevation,
    (*byte)(unsafe.Pointer(&elevation)),
    uint32(unsafe.Sizeof(elevation)),
    &returned,
  ); err != nil {
    return false
  }

  return elevation > 0
}

func RestartElevated() {

  exePath, _ := os.Executable()
  verb, _ := windows.UTF16PtrFromString("runas")
  exe, _ := windows.UTF16PtrFromString(exePath)
  args, _ := windows.UTF16PtrFromString(strings.Join(os.Args[1:], " "))
      
  windows.ShellExecute(
    0,
    verb, 
    exe, 
    args, 
    nil,
    windows.SW_SHOWDEFAULT,
  )
  
  os.Exit(0)
}
```

`src/internal/expand/expand.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package expand

import(
  "os"
  "os/user"
  "regexp"
  "strings"
  "strconv"
  "path/filepath"
  "launcher/internal/regedit"
  "launcher/internal/locale"
  "launcher/internal/video"
)

func getShellFolder(keys []string, root string) string {
  const path = "Software/Microsoft/Windows/CurrentVersion/Explorer/User Shell Folders"
  for _, key := range keys {
    value := regedit.QueryStringValue(root, path, key)
    if len(value) > 0 {
      return value
    }
  }
  return ""
}

func getUserShellFolder(keys []string) string {
  return getShellFolder(keys, "HKCU")
}

func getCommonShellFolder(keys []string) string {
  return getShellFolder(keys, "HKLM")
}

func ExpandVariables(input string) string {
  re := regexp.MustCompile(`%([^%]+)%`)
  
  return re.ReplaceAllStringFunc(input, func(match string) string {
    variable := strings.Trim(match, "%")
    switch variable { 
      case "APPDATA": {
        value:= getUserShellFolder([]string{"AppData"})
        if len(value) > 0 {
          return value
        }
        env:= os.Getenv("APPDATA")
        if len(env) > 0 {
          return env
        }
        return match
      }
      case "LOCALAPPDATA": {
        value:= getUserShellFolder([]string{"Local AppData"})
        if len(value) > 0 {
          return value
        }
        env:= os.Getenv("LOCALAPPDATA")
        if len(env) > 0 {
          return env
        }
        return match
      }
      case "PROGRAMDATA": {
        value:= getCommonShellFolder([]string{"Common AppData"})
        if len(value) > 0 {
          return value
        }
        env:= os.Getenv("PROGRAMDATA")
        if len(env) > 0 {
          return env
        }
        return match
      }
      case "DESKTOP": {
        value:= getUserShellFolder([]string{"Desktop"})
        if len(value) > 0 {
          return value
        }
        profile := os.Getenv("USERPROFILE")
        if len(profile) > 0 {
          return filepath.Join(os.Getenv("USERPROFILE"), "Desktop")
        }
        return match
      }
      case "DOCUMENTS": {
        value:= getUserShellFolder([]string{
                "{F42EE2D3-909F-4907-8871-4C22FC0BF756}", //win10
                "Personal"})
        if len(value) > 0 {
          return value
        }
        profile := os.Getenv("USERPROFILE")
        if len(profile) > 0 {
          return filepath.Join(os.Getenv("USERPROFILE"), "Documents")
        }
        return match
      }
      case "MUSIC": {
        value:= getUserShellFolder([]string{
                "{A0C69A99-21C8-4671-8703-7934162FCF1D}", //win10
                "My Music"})
        if len(value) > 0 {
          return value
        }
        profile := os.Getenv("USERPROFILE")
        if len(profile) > 0 {
          return filepath.Join(os.Getenv("USERPROFILE"), "Music")
        }
        return match
      }
      case "PICTURES": {
        value:= getUserShellFolder([]string{
                "{0DDD015D-B06C-45D5-8C4C-F59713854639}", //win10
                "My Pictures"})
        if len(value) > 0 {
          return value
        }
        profile := os.Getenv("USERPROFILE")
        if len(profile) > 0 {
          return filepath.Join(os.Getenv("USERPROFILE"), "Pictures")
        }
        return match
      }
      case "VIDEOS": {
        value:= getUserShellFolder([]string{
                "{35286A68-3C57-41A1-BBB1-0EAE73D76C95}", //win10
                "My Video"})
        if len(value) > 0 {
          return value
        }
        profile := os.Getenv("USERPROFILE")
        if len(profile) > 0 {
          return filepath.Join(os.Getenv("USERPROFILE"), "Videos")
        }
        return match
      }
      case "DOWNLOAD": {
        value:= getUserShellFolder([]string{
                "{7D83EE9B-2244-4E70-B1F5-5393042AF1E4}", //win10
                "{374DE290-123F-4565-9164-39C4925E467B}"})
        if len(value) > 0 {
          return value
        }
        profile := os.Getenv("USERPROFILE")
        if len(profile) > 0 {
          return filepath.Join(os.Getenv("USERPROFILE"), "Downloads")
        }
        return match
      }
      case "SAVEGAME": {
        value:= getUserShellFolder([]string{"{4C5C32FF-BB9D-43b0-B5B4-2D72E54EAAA4}"})
        if len(value) > 0 {
          return value
        }
        profile := os.Getenv("USERPROFILE")
        if len(profile) > 0 {
          return filepath.Join(os.Getenv("USERPROFILE"), "Saved Games")
        }
        return match
      }
      case "HOMEDIR", "USERPROFILE": {
        value:= os.Getenv("USERPROFILE")
        if len(value) > 0 {
          return value
        }
        return match
      }
      case "PUBLIC": {
        value:= os.Getenv("PUBLIC")
        if len(value) > 0 {
          return value
        }
        return match
      }
      case "SYSTEMDIR": {
        variables := []string{ "SYSTEMROOT", "WINDIR" }
        for _, variable := range variables {
          value := os.Getenv(variable)
          if len(value) > 0 {
            return value
          }
        }
        return match
      }
      case "TEMP", "TMP": {
        variables := []string{"TEMP", "TMP"}
        for _, variable := range variables {
          value := os.Getenv(variable)
          if len(value) > 0 {
            return value
          }
        }
        return match
      }
      case "CURRENTDIR": {
        cwd, err := os.Getwd()
        if err != nil {
          return match
        }
        return cwd
      }
      case "BINDIR": {
        process, err := os.Executable()
        if err != nil {
          return match
        }
        return filepath.Dir(process)
      }
      case "USERNAME": {
        user, err := user.Current()
        if err != nil {
          return match
        }
        parts := strings.Split(user.Username, "\\")
        last := len(parts)-1
        return parts[last]
      }
      case "LANGCODE": {
        localeName, err := locale.GetUserLocale()
        if err != nil || !strings.Contains(localeName, "-") {
          return match
        }
        loc := strings.SplitN(localeName, "-", 2)
        if len(loc) != 2 { 
          return match 
        }
        code := loc[0]
        return code
      }
      case "LANGUAGE": {
        localeName, err := locale.GetUserLocale()
        if err != nil {
          return match
        }
        language, err := locale.GetLanguageFromLocale(localeName)
        if err != nil {
          return match
        }
        return language
      }
      case "SCREENWIDTH", "XRES": {
        display, err := video.GetCurrentDisplayMode()
        if err != nil {
          return match
        }
        return strconv.FormatUint(display.Width, 10)
      }
      case "SCREENHEIGHT", "YRES": {
        display, err := video.GetCurrentDisplayMode()
        if err != nil {
          return match
        }
        return strconv.FormatUint(display.Height, 10)
      }
      case "SCREENREFRESH": {
        display, err := video.GetCurrentDisplayMode()
        if err != nil {
          return match
        }
        return strconv.FormatUint(display.Hz, 10)
      }  
    }
    return match
  })
}
```

`src/internal/fs/fs.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package fs

import(
  "os"
  "io"
  "hash"
  "bufio"
  "errors"
  "strings"
  "runtime"
  "path/filepath"
  "encoding/json"
  "crypto/sha256"
  "crypto/sha512"
  "encoding/base64"
  "golang.org/x/text/encoding"
  "golang.org/x/text/transform"
  "golang.org/x/text/encoding/charmap"
  "golang.org/x/text/encoding/unicode"
  "golang.org/x/sys/windows"
)

func Resolve(filePath string) string {
  path := filepath.FromSlash(filePath)
  if !filepath.IsAbs(path) {
    fullPath, err := filepath.Abs(path) //Uses GetFullPathNameW() on Windows
    if err != nil && runtime.GOOS == "windows" {
      cwd, _ := os.Getwd()
      path = filepath.Join(cwd, path)
    } else {
      path = fullPath
    }
  }
  return path
}

func ReadJSON[T any](filePath string) (config T, err error) {

  file, err := os.Open(filePath)
  if err != nil { return }
  defer file.Close()
  
  bytes, err := io.ReadAll(file)
  if err != nil { return }

  err = json.Unmarshal(bytes, &config)
  if err != nil { return }

  return
}

func FileExist(path string) (bool, error) {
  target, err := os.Stat(path)
  if err == nil {
    return !target.IsDir(), nil
  }
  if errors.Is(err, os.ErrNotExist) {
    return false, nil
  }
  return false, err
}

func CheckSum(filePath string, algo string) (string, error) {
    file, err := os.Open(filePath)
    if err != nil { return "", err }
    defer file.Close()

    var h hash.Hash
    switch algo {
      case "sha256":
        h = sha256.New()
      case "sha384":
        h = sha512.New384()
      case "sha512":
        h = sha512.New()
      default:
        return "", errors.New("Unsupported hash algorithm: \"" + algo + "\"")
    }

    if _, err = io.Copy(h, file); err != nil { 
      return "", err
    }

    return base64.StdEncoding.EncodeToString(h.Sum(nil)), nil
}

func WriteFile(filePath string, data string, format string) error {
  
  dir := filepath.Dir(filePath)
  if err := os.MkdirAll(dir, 0755); err != nil {
    return err
  }
  
  file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
  if err != nil {
    return err
  }
  defer file.Close()

  var enc encoding.Encoding
  switch format {
    case "utf8":
      enc = encoding.Nop //UTF-8 is default
    case "utf8sig":
      enc = unicode.UTF8BOM
    case "utf16le":
      enc = unicode.UTF16(unicode.LittleEndian, unicode.UseBOM)
    case "windows1252":
      enc = charmap.Windows1252
    default:
      return errors.New("Unsupported encoding: : \"" + format + "\"")
  }

  encoder := enc.NewEncoder()
  writer := bufio.NewWriter(transform.NewWriter(file, encoder))
  _, err = writer.WriteString(data)
  if err != nil {
    return err
  }

  return writer.Flush()
}

func ReadFile(filePath string, format string) (string, error) {

  file, err := os.Open(filePath)
  if err != nil {
    return "", err
  }
  defer file.Close()

  var enc encoding.Encoding
  switch format {
  case "utf8":
    enc = encoding.Nop //UTF-8 is default
  case "utf8sig":
    enc = unicode.UTF8BOM
  case "utf16le":
    enc = unicode.UTF16(unicode.LittleEndian, unicode.ExpectBOM)
  case "windows1252":
    enc = charmap.Windows1252
  default:
    return "", errors.New("Unsupported encoding: \"" + format + "\"")
  }

  decoder := enc.NewDecoder()
  reader := bufio.NewReader(transform.NewReader(file, decoder))
  data, err := io.ReadAll(reader)
  if err != nil {
    return "", err
  }

  return string(data), nil
}

func moveDir(oldPath string, newPath string) error {
  entries, err := os.ReadDir(oldPath)
  if err != nil {
    return err
  }
  if len(entries) == 0 { //Empty so safe to delete
    if err := os.Remove(oldPath); err != nil {
      return err
    }
  } else { //Non-Empty
    if err := os.MkdirAll(filepath.Dir(newPath), 0755); err != nil {
      return err
    }
    if err := os.Rename(oldPath, newPath); err != nil { //Try to move
      if linkErr, ok := err.(*os.LinkError); ok {
        if errors.Is(linkErr.Err, windows.Errno(windows.ERROR_NOT_SAME_DEVICE)) { 
          if err := os.CopyFS(newPath, os.DirFS(oldPath)); err != nil { //Fallback to copy
            return err
          }
          if err := os.RemoveAll(oldPath); err != nil {
            return err
          }
        } else {
          return err
        }
      } else {
        return err
      }
    } 
  }
  return nil
}

func CreateFolderSymlink(origin string, destination string) error {

  target, err := os.Lstat(origin)
  if err != nil {
    if !errors.Is(err, os.ErrNotExist) {
      return err
    }
  }
  
  if err == nil {
    if target.Mode() & os.ModeSymlink != 0 { //Already a symlink
      
      targetDest, err := os.Readlink(origin)
      if err != nil {
        return err
      }
      
      if targetDest == destination {
        return nil //Nothing to do
      }
      
      if err := moveDir(targetDest, destination); err != nil {
        return err
      }
      
      if err := os.Remove(origin); err != nil {
        return err
      }
                             
    } else if target.IsDir() {
      if err := moveDir(origin, destination); err != nil {
        return err
      }
    } else {
      return errors.New("Symlink target is a file, aborting !")
    }
  }

  if err := os.MkdirAll(destination, 0755); err != nil {
    return err
  }
  
  if err := os.MkdirAll(filepath.Dir(origin), 0755); err != nil {
    return err
  }

  return os.Symlink(destination, origin)
}

//Go path/filepath Glob() is too limited, build our own
func Glob(root string, pattern string, recursive bool, absolute bool) ([]string, error) {
  var matches []string
  onlyDir := strings.HasSuffix(pattern, "/")

  err := filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {
    if err != nil {
      return err
    }
    
    if onlyDir && !d.IsDir() {
      return nil
    }

    match, err := filepath.Match(strings.TrimSuffix(pattern, "/"), filepath.Base(path))
    if err != nil {
      return err
    }

    if match && path != root {
      if absolute {
        matches = append(matches, path)
      } else {
        relPath, err := filepath.Rel(root, path)
        if err != nil {
          return err
        }
        matches = append(matches, relPath)
      }
    }

    if !recursive && d.IsDir() && path != root {
      return filepath.SkipDir
    }

    return nil
  })

  if err != nil {
    return nil, err
  }

  return matches, nil
}

func Remove(path string) error {
  info, err := os.Stat(path)
  if err != nil {
    return err
  }

  if info.IsDir() {
    err := os.RemoveAll(path)
    if err != nil {
      return err
    }
  } else {
    err := os.Remove(path)
    if err != nil {
      return err
    }
  }

  return nil
}

func SetFileAttributes(filePath string, readonly bool, hidden bool) error {
  attrs, err := windows.GetFileAttributes(windows.StringToUTF16Ptr(filePath))
  if err != nil { return err }

  if current := (attrs & windows.FILE_ATTRIBUTE_READONLY) != 0; readonly != current {
    if readonly {
      attrs |= windows.FILE_ATTRIBUTE_READONLY //add
    } else {
      attrs &^= windows.FILE_ATTRIBUTE_READONLY //remove
    }
  }

  if current := (attrs & windows.FILE_ATTRIBUTE_HIDDEN) != 0; hidden != current {
    if hidden {
      attrs |= windows.FILE_ATTRIBUTE_HIDDEN //add
    } else {
      attrs &^= windows.FILE_ATTRIBUTE_HIDDEN //remove
    }
  }

  err = windows.SetFileAttributes(windows.StringToUTF16Ptr(filePath), attrs)
  if err != nil { return err }
  
  return nil
}
```

`src/internal/ini/parse.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

//Ported to GoLang from https://github.com/xan105/node-ini (MIT)

package ini

import (
  "bufio"
  "regexp"
  "slices"
  "strings"
  "strconv"
)

type ParserOptions struct {
  Filter    []string
  Global    bool
  Unquote   bool
  Boolean   bool
  Number    bool
}

func translate(value string, options *ParserOptions) interface{} {
  
  if options.Unquote && len(value) > 2 {
    first := value[0]
    last  := value[len(value)-1]
    if (first == '"' || first == '\'') && first == last {
      value = value[1 : len(value)-1]
    }
  }
  
  if options.Boolean {
    str := strings.ToLower(value)
    if str == "true" || str == "false" {
      if boolean, err := strconv.ParseBool(str); err == nil {
        return boolean
      }
    }
  }
  
  if options.Number {
    // Regex for valid number (same-ish as JSON.parse() rules)
    regex := regexp.MustCompile(`^-?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$`)
    if regex.MatchString(value) {
      if number, err := strconv.ParseFloat(value, 64); err == nil {
        return number
      }
    } 
  }

  return value
}

func Parse(data string, options *ParserOptions) map[string]interface{} {

  if options == nil {
    options = &ParserOptions{
      Filter: []string{},
      Global: true,
      Unquote: true,
      Boolean: true,
      Number: true,
    }
  }

  result := make(map[string]interface{})
  
  var section map[string]interface{}
  ignore := !options.Global
  
  sectionRegex := regexp.MustCompile(`^\[([^\]]*)\]`)
  commentRegex := regexp.MustCompile(`^\s*[;#]`)
  blankLineRegex := regexp.MustCompile(`^\s*$`)

  scanner := bufio.NewScanner(strings.NewReader(data))
  for scanner.Scan() {
    line := strings.TrimSpace(scanner.Text())
    if line == "" || commentRegex.MatchString(line) || blankLineRegex.MatchString(line)  { continue }

    if strings.HasPrefix(line, "[") {
      match := sectionRegex.FindStringSubmatch(line)
      if match != nil && len(match) > 1 {
        name := strings.TrimSpace(match[1])
        ignore = slices.Contains(options.Filter, name)
        if !ignore {
          if _, exists := result[name]; !exists {
            result[name] = make(map[string]interface{})
          }
          section = result[name].(map[string]interface{})
        }
      } else { 
        ignore = true 
      }
      continue
    }
    
    pos := strings.Index(line, "=")
    if pos < 1 { continue }

    key := strings.TrimSpace(line[:pos])
    value := strings.TrimSpace(line[pos+1:])

    if !ignore { 
      if section == nil {
        result[key] = translate(value, options)
      } else {
        section[key] = translate(value, options)
      }
    }
  }

  return result
}
```

`src/internal/ini/stringify.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

//Ported to GoLang from https://github.com/xan105/node-ini (MIT)

package ini

import (
  "strconv"
  "strings"
  "runtime"
)

type StringifyOptions struct {
  Whitespace   bool
  BlankLine    bool
  Quote        bool
  Eol          string
}

func Stringify(data map[string]interface{}, options *StringifyOptions) string {
    if options == nil {
      options = &StringifyOptions{
        Whitespace: true,
        BlankLine: false,
        Quote: false,
      }
    }
    
    delimiter := "="
    if options.Whitespace {
      delimiter = " = "
    }
    
    eol := "\n"
    if options.Eol == "\n" || options.Eol == "\r\n" {
      eol = options.Eol
    } else if runtime.GOOS == "windows" {
      eol = "\r\n" 
    }
    
    var result []string
    var section []string
    
    for key, v := range data {
        switch value := v.(type) {
        case string:
            if options.Quote {
              result = append(result, key + delimiter + "\"" + value + "\"")
            } else {
              result = append(result, key + delimiter + value)
            }
        case bool:
            result = append(result, key + delimiter + strconv.FormatBool(value))
        case float64:
            result = append(result, key + delimiter + strconv.FormatFloat(value, 'f', -1, 64))
        case map[string]interface{}:
            name := "[" + key + "]"
            section = append(section, name)
            section = append(section, Stringify(value, options))
      }
    }
    
    if options.BlankLine { result = append(result, "") }
    
    // Append sections at the end to ensure global keys appear first
    // Go Map order is not guaranteed !
    result = append(result, section...)

    return strings.Join(result, eol)
}
```

`src/internal/locale/locale.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package locale

import (
  "unsafe"
  "strings"
  "golang.org/x/sys/windows"
)

var (
  kernel32                    = windows.NewLazySystemDLL("kernel32.dll")
  pGetUserDefaultLocaleName   = kernel32.NewProc("GetUserDefaultLocaleName")
  pGetLocaleInfoEx            = kernel32.NewProc("GetLocaleInfoEx")
)

const (
  LOCALE_NAME_MAX_LENGTH      = 85
  LOCALE_SENGLISHLANGUAGENAME = 0x1001
)

func GetUserLocale() (string, error) {
  buffer := make([]uint16, LOCALE_NAME_MAX_LENGTH)
  ret, _, err := pGetUserDefaultLocaleName.Call(
    uintptr(unsafe.Pointer(&buffer[0])),
    uintptr(LOCALE_NAME_MAX_LENGTH),
  )
  if ret == 0 {
    return "", err
  }
  return windows.UTF16ToString(buffer), nil
}

func GetLanguageFromLocale(locale string) (string, error) {
  localePtr, _ := windows.UTF16PtrFromString(locale)
  buffer := make([]uint16, 100)

  ret, _, err := pGetLocaleInfoEx.Call(
    uintptr(unsafe.Pointer(localePtr)),
    uintptr(LOCALE_SENGLISHLANGUAGENAME),
    uintptr(unsafe.Pointer(&buffer[0])),
    uintptr(len(buffer)),
  )
  if ret == 0 {
    return "", err
  }
  return strings.ToLower(windows.UTF16ToString(buffer)), nil
}

```

`src/internal/pe/characteristics.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package pe

import (
  "os"
  "errors"
  "encoding/binary"
)

func PatchLargeAddress(filename string, aware bool) error {
  file, err := os.OpenFile(filename, os.O_RDWR, 0)
  if err != nil {
    return err
  }
  defer file.Close()

  var dosHeader ImageDosHeader
  err = binary.Read(file, binary.LittleEndian, &dosHeader)
  if err != nil {
    return err
  }
  if dosHeader.E_magic != IMAGE_DOS_SIGNATURE {
    return errors.New("Unexpected DOS signature")
  }

  //Seek to PE header
  _, err = file.Seek(int64(dosHeader.E_lfanew), 0)
  if err != nil {
    return err
  }

  //Read and check PE signature
  var peSignature uint32
  err = binary.Read(file, binary.LittleEndian, &peSignature)
  if err != nil {
    return err
  }
  if peSignature != IMAGE_NT_SIGNATURE {
    return errors.New("Unexpected PE signature")
  }

  //Read File Header
  var fileHeader ImageFileHeader
  err = binary.Read(file, binary.LittleEndian, &fileHeader)
  if err != nil {
    return err
  }
  if fileHeader.Machine != IMAGE_FILE_MACHINE_I386 {
    return nil //Not a x86 binary
  }

  if current := (fileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) != 0; aware == current {
    return nil //Nothing to do
  }

  if aware {
    fileHeader.Characteristics |= IMAGE_FILE_LARGE_ADDRESS_AWARE
  } else {
    fileHeader.Characteristics &= ^IMAGE_FILE_LARGE_ADDRESS_AWARE
  }

  //Seek back to File Header position
  _, err = file.Seek(int64(dosHeader.E_lfanew)+4, 0) // +4 for PE signature
  if err != nil {
    return err
  }

  //Write the updated header
  err = binary.Write(file, binary.LittleEndian, &fileHeader)
  if err != nil {
    return err
  }

  return nil
}
```

`src/internal/pe/machine.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package pe

import (
  "os"
  "errors"
  "encoding/binary"
)

func GetArchFromMachineType(path string) (string, error) {
  
  const location = 0x3C

  var machineTypes = map[uint16]string{
    IMAGE_FILE_MACHINE_I386:  "386",
    IMAGE_FILE_MACHINE_AMD64: "amd64",
    IMAGE_FILE_MACHINE_ARM64: "arm64",
  }
  
  file, err := os.Open(path)
  if err != nil {
    return "", err
  }
  defer file.Close()

  header := make([]byte, 4)
  _, err = file.ReadAt(header, location)
  if err != nil {
    return "", err
  }
  offset := int64(binary.LittleEndian.Uint32(header))

  machine := make([]byte, 2)
  _, err = file.ReadAt(machine, offset + 4)
  if err != nil {
    return "", err
  }
  machineType := binary.LittleEndian.Uint16(machine)

  arch, found := machineTypes[machineType]
  if !found {
    return "", errors.New("Unsupported machine type !")
  }

  return arch, nil
}
```

`src/internal/pe/pe.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package pe

const (
  IMAGE_FILE_MACHINE_I386         uint16 = 0x014c
  IMAGE_FILE_MACHINE_AMD64        uint16 = 0x8664
  IMAGE_FILE_MACHINE_ARM64        uint16 = 0xAA64
  IMAGE_DOS_SIGNATURE             uint16 = 0x5A4D
  IMAGE_FILE_LARGE_ADDRESS_AWARE  uint16 = 0x0020
  IMAGE_NT_SIGNATURE              uint32 = 0x00004550
)

type ImageDosHeader struct {
  E_magic    uint16
  E_cblp     uint16
  E_cp       uint16
  E_crlc     uint16
  E_cparhdr  uint16
  E_minalloc uint16
  E_maxalloc uint16
  E_ss       uint16
  E_sp       uint16
  E_csum     uint16
  E_ip       uint16
  E_cs       uint16
  E_lfarlc   uint16
  E_ovno     uint16
  E_res      [4]uint16
  E_oemid    uint16
  E_oeminfo  uint16
  E_res2     [10]uint16
  E_lfanew   int32 // file address of new exe header
}

type ImageFileHeader struct {
  Machine              uint16
  NumberOfSections     uint16
  TimeDateStamp        uint32
  PointerToSymbolTable uint32
  NumberOfSymbols      uint32
  SizeOfOptionalHeader uint16
  Characteristics      uint16
}
```

`src/internal/priority/priority.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package priority

import (
  "strings"
  "golang.org/x/sys/windows"
)

var PRIORITY_CLASS = map[string]uint32{
  "IDLE":          windows.IDLE_PRIORITY_CLASS,
  "BELOW_NORMAL":  windows.BELOW_NORMAL_PRIORITY_CLASS,
  "NORMAL":        windows.NORMAL_PRIORITY_CLASS,
  "ABOVE_NORMAL":  windows.ABOVE_NORMAL_PRIORITY_CLASS,
  "HIGH":          windows.HIGH_PRIORITY_CLASS,
  "REALTIME":      windows.REALTIME_PRIORITY_CLASS,
}

func GetPriorityClass(priority string) uint32 {

  if code, found := PRIORITY_CLASS[strings.ToUpper(priority)]; found {
    return code
  }

  return PRIORITY_CLASS["NORMAL"]
}
```

`src/internal/regedit/regedit.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

//ref: https://github.com/xan105/node-cgo-regodit

package regedit

import (
  "strings"
  "path/filepath"
  "golang.org/x/sys/windows/registry"
)

var rootKeys = map[string]registry.Key{
  "HKCU": registry.CURRENT_USER,
  "HKLM": registry.LOCAL_MACHINE,
  "HKU":  registry.USERS,
  "HKCC": registry.CURRENT_CONFIG,
  "HKCR": registry.CLASSES_ROOT,
}

func KeyExists(root string, path string) bool {
  k, err := registry.OpenKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.QUERY_VALUE)
  defer k.Close()
  if err != nil {
    return false
  } else {
    return true
  }
}

func ListAllSubkeys(root string, path string) []string {
  k, _ := registry.OpenKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.QUERY_VALUE | registry.ENUMERATE_SUB_KEYS)
  defer k.Close()
  list, _ := k.ReadSubKeyNames(-1)
  return list
}

func ListAllValues(root string, path string) []string {
  k, _ := registry.OpenKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.QUERY_VALUE | registry.ENUMERATE_SUB_KEYS)
  defer k.Close()
  list, _ := k.ReadValueNames(-1)
  return list
}

func QueryValueType(root string, path string, key string) string {
  var buf []byte;
  k, _ := registry.OpenKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.QUERY_VALUE)
  defer k.Close()
  _, valtype, _ := k.GetValue(key, buf)
 
  switch valtype {
    case 0: return "NONE"
    case 1: return "SZ"
    case 2: return "EXPAND_SZ"
    case 3: return "BINARY"
    case 4: return "DWORD"
    case 5: return "DWORD_BIG_ENDIAN"
    case 6: return "LINK"
    case 7: return "MULTI_SZ"
    case 8: return "RESOURCE_LIST"
    case 9: return "FULL_RESOURCE_DESCRIPTOR"
    case 10: return "RESOURCE_REQUIREMENTS_LIST"
    case 11: return "QWORD"
    default: return "NONE"
  }
}

func QueryStringValue(root string, path string, key string) string { //REG_SZ & REG_EXPAND_SZ
  var result string
  k, _ := registry.OpenKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.QUERY_VALUE)
  defer k.Close()
  result, keyType, _ := k.GetStringValue(key)
  
  if keyType == registry.EXPAND_SZ {
    expanded, err := registry.ExpandString(result)
    if err == nil {
      result = expanded
    }
  }
 
  return result
}

func QueryMultiStringValue(root string, path string, key string) []string { //REG_MULTI_SZ
  k, _ := registry.OpenKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.QUERY_VALUE)
  defer k.Close()
  list, _, _ := k.GetStringsValue(key)
  return list
}

func QueryBinaryValue(root string, path string, key string) []byte { //REG_BINARY
  k, _ := registry.OpenKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.QUERY_VALUE)
  defer k.Close()
  bytes, _, _ := k.GetBinaryValue(key)
  return bytes
}

func QueryIntegerValue(root string, path string, key string) uint64 { //REG_DWORD & REG_QWORD
  k, _ := registry.OpenKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.QUERY_VALUE)
  defer k.Close()
  i, _, _ := k.GetIntegerValue(key)
  return i
}

func Create(root string, path string) {
  k, _, _ := registry.CreateKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.ALL_ACCESS) 
  defer k.Close()
}

func Delete(root string, path string) {
  subkeys := ListAllSubkeys(root, path)
  for _, subkey := range subkeys {
    Delete(root, path + "/" + subkey)
  }
  registry.DeleteKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path))
}

func WriteStringValue(root string, path string, key string, value string) { //REG_SZ
  k, _, _ := registry.CreateKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.ALL_ACCESS)
  defer k.Close()
  k.SetStringValue(key, value)
}

func WriteExpandStringValue(root string, path string, key string, value string) { //REG_EXPAND_SZ
  k, _, _ := registry.CreateKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.ALL_ACCESS)
  defer k.Close()
  k.SetExpandStringValue(key, value)
}

func WriteMultiStringValue(root string, path string, key string, value []string) { //REG_MULTI_SZ
  k, _, _ := registry.CreateKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.ALL_ACCESS) 
  defer k.Close()
  k.SetStringsValue(key, value)
}

func WriteBinaryValue(root string, path string, key string, value []byte) { //REG_BINARY
  k, _, _ := registry.CreateKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.ALL_ACCESS) 
  defer k.Close()
  k.SetBinaryValue(key, value)
}

func WriteDwordValue(root string, path string, key string, value uint32) { //REG_DWORD
  k, _, _ := registry.CreateKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.ALL_ACCESS) 
  defer k.Close()
  k.SetDWordValue(key, value)
}

func WriteQwordValue(root string, path string, key string, value uint64) { //REG_QWORD
  k, _, _ := registry.CreateKey(rootKeys[strings.ToUpper(root)], filepath.FromSlash(path), registry.ALL_ACCESS) 
  defer k.Close()
  k.SetQWordValue(key, value)
}

func DeleteValue (root string, path string, key string) {
  k, _ := registry.OpenKey(rootKeys[strings.ToUpper(root)] , filepath.FromSlash(path), registry.ALL_ACCESS) 
  defer k.Close()
  k.DeleteValue(key)
}
```

`src/internal/shortcut/shortcut.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package shortcut

import (
  "runtime"
  "github.com/go-ole/go-ole"
  "github.com/go-ole/go-ole/oleutil" 
)

type Shortcut struct {
  Path              string
  TargetPath        string
  Arguments         string
  WorkingDirectory  string
  Description       string
  IconLocation      string
}

func CreateShortcut(s Shortcut) (error){
  runtime.LockOSThread()
  defer runtime.UnlockOSThread()
  
  err := ole.CoInitialize(0)
  if err != nil {
    return err
  }
  defer ole.CoUninitialize()
  
  com, err := oleutil.CreateObject("WScript.Shell")
  if err != nil {
    return err
  }
  defer com.Release()
  
  wshell, err := com.QueryInterface(ole.IID_IDispatch)
  if err != nil {
    return err
  }
  defer wshell.Release()
  
  shortcut, err := oleutil.CallMethod(wshell, "CreateShortcut", s.Path)
  if err != nil {
    return err
  }
  sc := shortcut.ToIDispatch()
  defer sc.Release()
  
  if _, err := oleutil.PutProperty(sc, "TargetPath", s.TargetPath); err != nil {
    return err
  }
  if _, err := oleutil.PutProperty(sc, "Arguments", s.Arguments); err != nil {
    return err
  }
  if _, err := oleutil.PutProperty(sc, "WorkingDirectory", s.WorkingDirectory); err != nil {
    return err
  }
  if _, err := oleutil.PutProperty(sc, "Description", s.Description); err != nil {
    return err
  }
  if _, err := oleutil.PutProperty(sc, "IconLocation", s.IconLocation); err != nil {
    return err
  }
  
  _, err = oleutil.CallMethod(sc, "Save")
  if err != nil {
    return err;
  }
  
  return nil
}
```

`src/internal/steam/steamid.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package steam

import (
  "strings"
  "strconv"
  "errors"
)

type SteamID struct {
  Universe  uint64
  Type      uint64
  Instance  uint64
  AccountID uint64
}

const (
  EUniverseInvalid  = 0
  EUniversePublic   = 1
  EUniverseBeta     = 2
  EUniverseInternal = 3
  EUniverseDev      = 4
)

const (
  ETypeInvalid      = 0
  ETypeIndividual   = 1
  ETypeMultiseat    = 2
  ETypeGameServer   = 3
  ETypeAnonGameSrv  = 4
  ETypePending      = 5
  ETypeContentSrv   = 6
  ETypeClan         = 7
  ETypeChat         = 8
  ETypeP2P          = 9
)

const (
  EInstanceAll      = 0
  EInstanceDesktop  = 1
  EInstanceConsole  = 2
  EInstanceWeb      = 4
)

func FromSteam64(id uint64) *SteamID {
  return &SteamID{
    Universe:  (id >> 56) & 0xFF,
    Type:      (id >> 52) & 0xF,
    Instance:  (id >> 32) & 0xFFFFF,
    AccountID: id & 0xFFFFFFFF,
  }
}

// "STEAM_X:Y:Z"
func FromSteam2(s string) (*SteamID, error) {
  parts := strings.Split(s, ":")
  if len(parts) != 3 || !strings.HasPrefix(parts[0], "STEAM_") {
    return nil, errors.New("Invalid Steam2 ID")
  }
  X, _ := strconv.ParseUint(parts[0][6:], 10, 64) 
  Y, _ := strconv.ParseUint(parts[1], 10, 64)
  Z, _ := strconv.ParseUint(parts[2], 10, 64)

  var universe uint64 = EUniversePublic
  if X > 1 {
    universe = X
  }
  
  return &SteamID{
    Universe: universe, 
    Type: ETypeIndividual, 
    Instance: EInstanceDesktop, 
    AccountID: Z*2 + Y,
  }, nil
}

// "[U:1:Z]"
func FromSteam3(s string) (*SteamID, error) {
  s = strings.Trim(s, "[]")
  parts := strings.Split(s, ":")
  if len(parts) != 3 {
    return nil, errors.New("Invalid Steam3 ID")
  }

  universe, err := strconv.ParseUint(parts[1], 10, 64);
    if err != nil {
    return nil, err
  }
  
  accountID, err := strconv.ParseUint(parts[2], 10, 64)
  if err != nil {
    return nil, err
  }
  
  sid := &SteamID{
    Universe: universe, 
    Type: ETypeIndividual, 
    Instance: EInstanceAll, 
    AccountID: accountID,
  }

  switch parts[0] {
    case "I": 
      sid.Type = ETypeInvalid
    case "U":
      sid.Type = ETypeIndividual
      sid.Instance = EInstanceDesktop
    case "M":
      sid.Type = ETypeMultiseat
    case "G":
      sid.Type = ETypeGameServer
    case "A":
      sid.Type = ETypeAnonGameSrv
    case "P":
      sid.Type = ETypePending
    case "C":
      sid.Type = ETypeContentSrv
    case "g":
      sid.Type = ETypeClan
    case "c":
      sid.Type = ETypeChat
    case "a":
      sid.Type = ETypeP2P
    default:
      sid.Type = ETypeIndividual
  }

  return sid, nil
}

func ParseSteamID(input string) (*SteamID, error) {
  if strings.HasPrefix(input, "STEAM_") {
    return FromSteam2(input)
  }
  if strings.HasPrefix(input, "[") && strings.HasSuffix(input, "]") {
    return FromSteam3(input)
  }
  if id, err := strconv.ParseUint(input, 10, 64); err == nil {
    return FromSteam64(id), nil
  }
  return nil, errors.New("Unknown SteamID format")
}

func (sid *SteamID) AsSteam64() string {
  id := ((sid.Universe & 0xFF) << 56) |
        ((sid.Type & 0xF) << 52) |
        ((sid.Instance & 0xFFFFF) << 32) |
        (sid.AccountID & 0xFFFFFFFF)
  return strconv.FormatUint(id, 10)
}

func (sid *SteamID) AsSteam3() string {
  result := "["
  switch sid.Type {
    case ETypeInvalid:
      result += "I"
    case ETypeIndividual:
      result += "U"
    case ETypeMultiseat:
      result += "M"
    case ETypeGameServer:
      result += "G"
    case ETypeAnonGameSrv:
      result += "A"
    case ETypePending:
      result += "P"
    case ETypeContentSrv:
      result += "C"
    case ETypeClan:
      result += "g"
    case ETypeChat:
      result += "c"
    case ETypeP2P:
      result += "a"
    default:
      result += "U"
  }
  result += ":"
  result += strconv.FormatUint(sid.Universe, 10)
  result += ":"
  result += strconv.FormatUint(sid.AccountID, 10)
  result += "]"

  return result
}

func (sid *SteamID) AsSteam2() string {
  Y := sid.AccountID % 2
  Z := sid.AccountID / 2

  result := "STEAM_"
  result += strconv.FormatUint(sid.Universe, 10)
  result += ":"
  result += strconv.FormatUint(Y, 10)
  result += ":"
  result += strconv.FormatUint(Z, 10)
  
  return result 
}
```

`src/internal/thread/thread.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package thread

import (
  "unsafe"
  "golang.org/x/sys/windows"
)

var (
  kernel32            = windows.NewLazySystemDLL("kernel32.dll")
  pVirtualAllocEx     = kernel32.NewProc("VirtualAllocEx")
  pVirtualFreeEx      = kernel32.NewProc("VirtualFreeEx")
  pCreateRemoteThread = kernel32.NewProc("CreateRemoteThread")
)

func CreateRemoteThread(pid int, path string) error {

  //Opens a handle to the target process with the needed permissions
  hProcess, err := windows.OpenProcess(
    windows.PROCESS_CREATE_THREAD | 
    windows.PROCESS_VM_OPERATION | 
    windows.PROCESS_VM_WRITE | 
    windows.PROCESS_VM_READ |
    windows.PROCESS_QUERY_INFORMATION,
    false,
    uint32(pid),
  )
  if err != nil {
    return err
  }
  defer windows.CloseHandle(hProcess)

 //Allocates virtual memory for the file path
  lpBaseAddress, _, err := pVirtualAllocEx.Call(
    uintptr(hProcess), 
    0, 
    uintptr((len(path) + 1) * 2),
    windows.MEM_RESERVE | windows.MEM_COMMIT, 
    windows.PAGE_EXECUTE_READWRITE,
  )
 
  //Converts the file path to type LPCWSTR
  lpBuffer, err := windows.UTF16PtrFromString(path)
  if err != nil {
    return err
  }
 
 //Writes the filename to the previously allocated space
  lpNumberOfBytesWritten:= uintptr(0)
  err = windows.WriteProcessMemory(
    hProcess, 
    lpBaseAddress, 
    (*byte)(unsafe.Pointer(lpBuffer)),
    uintptr((len(path) + 1) * 2),
    &lpNumberOfBytesWritten,
  )
  if err != nil {
    return err
  }
 
 //Gets a pointer to the LoadLibrary function
  LoadLibAddr, err := windows.GetProcAddress(
    windows.Handle(kernel32.Handle()), 
    "LoadLibraryW",
  )
  if err != nil {
    return err
  }
 
 //Creates a remote thread that loads the DLL triggering it
  hThread, _, err := pCreateRemoteThread.Call(
    uintptr(hProcess), 
    0, 
    0, 
    LoadLibAddr, 
    lpBaseAddress, 
    0, 
    0,
  )
  if hThread == 0 {
    return err
  }
  defer windows.CloseHandle(windows.Handle(hThread))

  windows.WaitForSingleObject(windows.Handle(hThread), windows.INFINITE)

  pVirtualFreeEx.Call(
    uintptr(hProcess), 
    lpBaseAddress, 
    0,
    windows.MEM_RELEASE,
  )

  return nil
}

func ResumeThread(tid uint32) error {

  hThread, err := windows.OpenThread(windows.THREAD_SUSPEND_RESUME, false, tid)
  if err != nil {
    return err
  }
  defer windows.CloseHandle(windows.Handle(hThread))

  if _, err := windows.ResumeThread(hThread); err != nil {
    return err
  }
  
  windows.WaitForSingleObject(windows.Handle(hThread), windows.INFINITE)
  
  return nil
}

func ResumeMainThread(pid int) error {

  /*
  It is worth mentioning that this function resume the first thread found of the specified process.
  Which _should_ be the main thread. But technically this is not _"correct"_.
  
  Why using `CreateToolhelp32Snapshot()` then you might ask?
  Long story short, this is because `os/exec` does not return the handle of the main thread from `CreateProcessW()`.
  And for once, I didn't feel like re-inventing the wheel, ie: doing my own os/exec and/or wrapper of `CreateProcessW()`, 
  just to be able to create a suspended process and resume it.
  */

  hSnapshot, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPTHREAD, uint32(pid))
  if err != nil {
    return err
  }
  defer windows.CloseHandle(windows.Handle(hSnapshot))

  var entry windows.ThreadEntry32
  entry.Size = uint32(unsafe.Sizeof(entry))
  if err := windows.Thread32First(hSnapshot, &entry); err != nil {
    return err
  }

  for
  {
    if err := windows.Thread32Next(hSnapshot, &entry); err != nil {
      return err
    }
    
    if entry.OwnerProcessID == uint32(pid) && entry.ThreadID != 0 {
      return ResumeThread(entry.ThreadID)
    }
  }
}
```

`src/internal/trust/trust.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

//cf: https://github.com/xan105/node-win-verify-trust

package trust

import (
  "unsafe"
  "golang.org/x/sys/windows"
)

const (
  WTD_REVOKE_NONE                   = 0
  WTD_CHOICE_FILE                   = 1
  WTD_UI_NONE                       = 2
  WTD_STATEACTION_VERIFY            = 0x00000001
  WTD_STATEACTION_CLOSE             = 0x00000002
)

type WINTRUST_FILE_INFO struct {
  CbStruct                          uint32
  PcwszFilePath                     *uint16
  HFile                             windows.Handle
  PgKnownSubject                    *windows.GUID
}

type WINTRUST_DATA struct {
  CbStruct                          uint32
  PPolicyCallbackData               uintptr
  PSIPClientData                    uintptr
  DwUIChoice                        uint32
  FdwRevocationChecks               uint32
  DwUnionChoice                     uint32
  PFile                             *WINTRUST_FILE_INFO
  DwStateAction                     uint32
  H_WVTStateData                    windows.Handle
  PwszURLReference                  *uint16
  DwUIContext                       uint32
}

var (
  wintrust                          = windows.NewLazySystemDLL("wintrust.dll")
  pWinVerifyTrust                   = wintrust.NewProc("WinVerifyTrust")
  WINTRUST_ACTION_GENERIC_VERIFY_V2 = windows.GUID{
    Data1: 0xaac56b,
    Data2: 0xcd44,
    Data3: 0x11d0,
    Data4: [8]byte{0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee},
  }
)

func VerifySignature(filePath string) (bool, error) {
  filePathPtr, err := windows.UTF16PtrFromString(filePath)
  if err != nil {
    return false, err
  }

  fileInfo := WINTRUST_FILE_INFO{
    CbStruct:      uint32(unsafe.Sizeof(WINTRUST_FILE_INFO{})),
    PcwszFilePath: filePathPtr,
    HFile:         0,
    PgKnownSubject: nil,
  }

  winTrustData := WINTRUST_DATA{
    CbStruct:            uint32(unsafe.Sizeof(WINTRUST_DATA{})),
    PPolicyCallbackData: 0,
    PSIPClientData:      0,
    DwUIChoice:          WTD_UI_NONE,
    FdwRevocationChecks: WTD_REVOKE_NONE,
    DwUnionChoice:       WTD_CHOICE_FILE,
    PFile:               &fileInfo,
    DwStateAction:       WTD_STATEACTION_VERIFY,
    H_WVTStateData:      0,
    PwszURLReference:    nil,
    DwUIContext:         0,
  }

  ret, _, err := pWinVerifyTrust.Call(
    0, 
    uintptr(unsafe.Pointer(&WINTRUST_ACTION_GENERIC_VERIFY_V2)), 
    uintptr(unsafe.Pointer(&winTrustData)),
  )
  
  // Any H_WVTStateData must be released by a call with close.
  winTrustData.DwStateAction = WTD_STATEACTION_CLOSE
  pWinVerifyTrust.Call(
    0, 
    uintptr(unsafe.Pointer(&WINTRUST_ACTION_GENERIC_VERIFY_V2)), 
    uintptr(unsafe.Pointer(&winTrustData)),
  )

  if ret == 0 {
    return true, nil
  }
  
  return false, err
}
```

`src/internal/ui/gdi32.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package ui

import (
  "unsafe"
  "golang.org/x/sys/windows"
)

var (
  gdi32               = windows.NewLazySystemDLL("Gdi32.dll")
  pGetDeviceCaps      = gdi32.NewProc("GetDeviceCaps")
  pCreatePatternBrush = gdi32.NewProc("CreatePatternBrush")
  pGetObjectW         = gdi32.NewProc("GetObjectW")
)

const (
  HORZRES             = 8
  VERTRES             = 10
)

type BITMAP struct {
  bmType              uint32
  bmWidth             int32
  bmHeight            int32
  bmWidthBytes        uint32
  bmPlanes            uint16
  bmBitsPixel         uint16
  bmBits              uintptr
}

func getDeviceCaps(hDC windows.Handle, index int32) uint32 {
  ret, _, _ := pGetDeviceCaps.Call(
    uintptr(hDC),
    uintptr(index),
  )

  return uint32(ret)
}

func createPatternBrush(hbm windows.Handle) (windows.Handle, error) {
  ret, _, err := pCreatePatternBrush.Call(uintptr(hbm))
  if ret == 0 {
    return 0, err
  }
  return windows.Handle(ret), nil
}

func getObject(hBitmap windows.Handle) (BITMAP, error) {
  var bmp BITMAP
  
  ret, _, err := pGetObjectW.Call(
    uintptr(hBitmap), 
    uintptr(unsafe.Sizeof(bmp)), 
    uintptr(unsafe.Pointer(&bmp)),
  )
  if ret == 0 {
    return bmp, err
  }
  return bmp, nil
}
```

`src/internal/ui/kernel32.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package ui

import (
  "golang.org/x/sys/windows"
)

var (
  kernel32          = windows.NewLazySystemDLL("kernel32.dll")
  pGetModuleHandleW = kernel32.NewProc("GetModuleHandleW")
)

func getModuleHandle() (windows.Handle, error) {
  ret, _, err := pGetModuleHandleW.Call(uintptr(0))
  if ret == 0 {
    return 0, err
  }
  return windows.Handle(ret), nil
}


```

`src/internal/ui/menu.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package ui

import (
  "log/slog"
  "os"
  "unsafe"
  "runtime"
  "golang.org/x/sys/windows"
)

func createMenuWindow(labels []string, button chan int) { 
  runtime.LockOSThread() //GetMessageW() must be called in the same thread
  defer runtime.UnlockOSThread()
  
  slog.Info("Create Menu Window")
  
  const (
    classNameGUID   = "3949D435-2861-42B9-9E47-C721A71F85E9"  //Random GUID
    buttonClass     = "BUTTON"  //Windows predefined class
    titleBar        = 32
    charWidthMin    = 10
    borderOffset    = 20
    buttonHeight    = 50
    separator       = 20
    paddingY        = 60
    paddingX        = 100
  )

  lpfnWndProc := func(hwnd windows.Handle, msg uint32, wparam uintptr, lparam uintptr) uintptr {
    switch msg {
      case WM_DESTROY: 
        postQuitMessage(0)
      case WM_CLOSE:
        destroyWindow(hwnd)
        os.Exit(0)
      case WM_COMMAND:
        id := uint16(wparam)
        index := int(id)
        button <- index
        destroyWindow(hwnd)
      default:
        return defWindowProc(hwnd, msg, wparam, lparam)
    }
    return 0
  }
  
  instance, err := getModuleHandle()
  if err != nil {
    slog.Error(err.Error())
    button <- -1
    return
  }
  
  hIcon := extractIcon()
  wcx := WNDCLASSEXW{
    wndProc:    windows.NewCallback(lpfnWndProc),
    instance:   instance,
    background: COLOR_WINDOW,
    className:  windows.StringToUTF16Ptr(classNameGUID),
    icon:      windows.Handle(hIcon),
    iconSm:    windows.Handle(hIcon),
  }
  wcx.size = uint32(unsafe.Sizeof(wcx))
  
  if _, err := registerClassEx(&wcx); err != nil {
    slog.Error(err.Error())
    button <- -1
    return
  }
  
  screenWidth, screenHeight, err := getScreenResolution()
  if err != nil {
    slog.Error(err.Error())
    button <- -1
    return
  }

  charLen := 0
  for _, label := range labels {
    if len(label) > charLen {
      charLen = len(label)
    }
  }
  buttonWidth     := (charLen * charWidthMin) + borderOffset
  menuWidth       := buttonWidth + paddingX
  menuHeight      := titleBar + ((buttonHeight + separator) * len(labels)) + paddingY 
  buttonPosX      := paddingX / 2
  buttonPosY      := paddingY / 2 
  
  win, err := createWindow(
    classNameGUID,
    "Launcher",
    0,
    (WS_SYSMENU | WS_VISIBLE | WS_TABSTOP) &^ WS_MAXIMIZEBOX,
    (screenWidth - uint32(menuWidth)) / 2, //center X
    (screenHeight - uint32(menuHeight)) / 2, //center Y
    uint32(menuWidth),
    uint32(menuHeight),
    0,
    0,
    instance,
  )
  if err != nil {
    slog.Error(err.Error())
    button <- -1
    return
  }

  for i, label := range labels{
    if _, err := createWindow( 
      buttonClass,
      label,
      0,
      WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
      uint32(buttonPosX),
      uint32(buttonPosY),
      uint32(buttonWidth),
      uint32(buttonHeight),
      win,
      windows.Handle(uint16(i)),
      instance,
    ); err != nil {
      slog.Error(err.Error())
      button <- -1
      return
    }
    buttonPosY += buttonHeight + separator
  }

  for {
    msg := MSG{}
    gotMessage, err := getMessage(&msg, 0, 0, 0)
    if err != nil {
      slog.Error(err.Error())
      button <- -1
      return
    }

    if gotMessage {
      translateMessage(&msg)
      if msg.message == WM_QUIT {
        break
      }
      dispatchMessage(&msg)
    } else {
      break
    }
  }
  button <- -1
  return
}

func Menu(labels []string) chan int {
  button := make(chan int)
  go createMenuWindow(labels, button)
  return button
}
```

`src/internal/ui/shell32.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package ui

import (
  "os"
  "unsafe"
  "golang.org/x/sys/windows"
)

var (
  shell32           = windows.NewLazySystemDLL("shell32.dll")
  pExtractIcon      = shell32.NewProc("ExtractIconW")
)

func extractIcon() windows.Handle {
  exePath, err := os.Executable()
  if err != nil {
    return 0
  }
  hIcon, _, _ := pExtractIcon.Call(
    uintptr(0), 
    uintptr(unsafe.Pointer(windows.StringToUTF16Ptr(exePath))), 
    0,
  )
  return windows.Handle(hIcon)
}
```

`src/internal/ui/splash.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package ui

import (
  "log/slog"
  "os"
  "unsafe"
  "runtime"
  "golang.org/x/sys/windows"
)

func createSplashWindow(splashImage string, waitEvent string, pid int, exit chan bool) { 
  runtime.LockOSThread() //GetMessageW() must be called in the same thread
  defer runtime.UnlockOSThread()
  
  slog.Info("Create Splash Window")
  
  const classNameGUID = "D2FF2B71-7532-4BA6-8025-4D044372B710"  //Random GUID

  var win windows.Handle

  activeWinEventHook := func(hWinEventHook windows.Handle, event uint32, hwnd windows.HWND, idObject int32, idChild int32, idEventThread uint32, dwmsEventTime uint32) uintptr {
    if (waitEvent == "FOREGROUND" && (event == EVENT_SYSTEM_FOREGROUND && windows.IsWindowVisible(hwnd))) ||
       (waitEvent == "WINDOW" && (event == EVENT_OBJECT_SHOW && idObject == OBJID_WINDOW)) ||
       (waitEvent == "CURSOR" && (event == EVENT_OBJECT_SHOW && idObject == OBJID_CURSOR)) {
        slog.Info("Splash bye bye")
        destroyWindow(win)
        unhookWinEvent(hWinEventHook) 
    }
    return 0
  }

  lpfnWndProc := func(hwnd windows.Handle, msg uint32, wparam uintptr, lparam uintptr) uintptr {
    switch msg {
      case WM_DESTROY:
        postQuitMessage(0)
      case WM_SHOWWINDOW: {
        _, err := setWinEventHook(
          EVENT_SYSTEM_FOREGROUND,
          EVENT_OBJECT_SHOW,
          0, 
          windows.NewCallback(activeWinEventHook), 
          pid,
          0, 
          WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS,
        )
        if err != nil {
          slog.Error(err.Error())
          destroyWindow(hwnd)
        }
      }
      default:
        return defWindowProc(hwnd, msg, wparam, lparam)
    }
    return 0
  }
  
  instance, err := getModuleHandle()
  if err != nil {
    slog.Error(err.Error())
    exit <- true
    return
  }
  
  hbrush, image, err := createBrushFromBMP(splashImage)
  if err != nil {    
    slog.Error(err.Error())
    exit <- true
    return
  }
  
  wcx := WNDCLASSEXW{
    wndProc:    windows.NewCallback(lpfnWndProc),
    instance:   instance,
    background: hbrush,
    className:  windows.StringToUTF16Ptr(classNameGUID),
  }
  wcx.size = uint32(unsafe.Sizeof(wcx))
  
  if _, err := registerClassEx(&wcx); err != nil {
    slog.Error(err.Error())
    exit <- true
    return
  }
  
  screenWidth, screenHeight, err := getScreenResolution()
  if err != nil {
    slog.Error(err.Error())
    exit <- true
    return
  }
  
  //check process hasn't crashed since we started it
  if _, err = os.FindProcess(pid); err != nil { 
    slog.Error(err.Error())
    exit <- true
    return
  }
  
  win, err = createWindow(
    classNameGUID,
    "Launcher",
    WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
    WS_VISIBLE | WS_POPUP | WS_TABSTOP,
    (screenWidth - uint32(image.bmWidth)) / 2, //center X
    (screenHeight - uint32(image.bmHeight)) / 2, //center Y
    uint32(image.bmWidth),
    uint32(image.bmHeight),
    0,
    0,
    instance,
  )
  if err != nil {
    slog.Error(err.Error())
    exit <- true
    return
  }
  
  for {
    msg := MSG{}
    gotMessage, err := getMessage(&msg, 0, 0, 0)
    if err != nil {
      slog.Error(err.Error())
      exit <- true
      return
    }

    if gotMessage {
      translateMessage(&msg)
      if msg.message == WM_QUIT {
        break
      }
      dispatchMessage(&msg)
    } else {
      break
    }
  }
  exit <- true
  return
}

func Splash(splashImage string, waitEvent string, pid int) chan bool {
  exit := make(chan bool)
  go createSplashWindow(splashImage, waitEvent, pid, exit)
  return exit
}
```

`src/internal/ui/user32.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package ui

import (
  "unsafe"
  "golang.org/x/sys/windows"
)

var (
  user32                    = windows.NewLazySystemDLL("user32.dll")
  pCreateWindowExW          = user32.NewProc("CreateWindowExW")
  pDefWindowProcW           = user32.NewProc("DefWindowProcW")
  pDestroyWindow            = user32.NewProc("DestroyWindow")
  pDispatchMessageW         = user32.NewProc("DispatchMessageW")
  pGetMessageW              = user32.NewProc("GetMessageW")
  pPostQuitMessage          = user32.NewProc("PostQuitMessage")
  pRegisterClassExW         = user32.NewProc("RegisterClassExW")
  pTranslateMessage         = user32.NewProc("TranslateMessage")
  pLoadImageW               = user32.NewProc("LoadImageW")
  pSetWinEventHook          = user32.NewProc("SetWinEventHook")
  pUnhookWinEvent           = user32.NewProc("UnhookWinEvent")
  pGetDC                    = user32.NewProc("GetDC")
  pReleaseDC                = user32.NewProc("ReleaseDC")
)

const (
  WM_CREATE                 = 0x0001
  WM_DESTROY                = 0x0002
  WM_SHOWWINDOW             = 0x0018
  WM_CLOSE                  = 0x0010
  WM_COMMAND                = 0x0111
  WM_QUIT                   = 0x0012
  WS_CHILD                  = 0x40000000
  WS_VISIBLE                = 0x10000000
  WS_EX_TOPMOST             = 0x00000008
  WS_POPUP                  = 0x80000000
  WS_EX_TOOLWINDOW          = 0x000000080
  WS_TABSTOP                = 0x00010000
  WS_CAPTION                = 0x00C00000
  WS_OVERLAPPEDWINDOW       = 0x00CF0000
  WS_SYSMENU                = 0x00080000
  WS_THICKFRAME             = 0x00040000
  WS_MINIMIZEBOX            = 0x20000
  WS_MAXIMIZEBOX            = 0x10000
  EVENT_SYSTEM_FOREGROUND   = 0x0003
  EVENT_OBJECT_CREATE       = 0x8000
  EVENT_OBJECT_SHOW         = 0x8002
  WINEVENT_OUTOFCONTEXT     = 0x0000
  WINEVENT_INCONTEXT        = 0x0004
  WINEVENT_SKIPOWNPROCESS   = 0x0002
  WINEVENT_SKIPOWNTHREAD    = 0x0001
  OBJID_WINDOW              = 0
  OBJID_CURSOR              = -9
  OBJID_CLIENT              = -4;
  IMAGE_BITMAP              = 0x00
  LR_LOADFROMFILE           = 0x00000010
  COLOR_WINDOW              = 5
  BS_DEFPUSHBUTTON          = 0x01
)

type POINT struct {
  x                         int32
  y                         int32
}

type MSG struct {
  hwnd                      windows.Handle
  message                   uint32
  wParam                    uintptr
  lParam                    uintptr
  time                      uint32
  pt                        POINT
}

type WNDCLASSEXW struct {
  size                      uint32
  style                     uint32
  wndProc                   uintptr
  clsExtra                  int32
  wndExtra                  int32
  instance                  windows.Handle
  icon                      windows.Handle
  cursor                    windows.Handle
  background                windows.Handle
  menuName                  *uint16
  className                 *uint16
  iconSm                    windows.Handle
}

func getDC(hWnd windows.Handle) (windows.Handle, error) {
  ret, _, err := pGetDC.Call(
    uintptr(hWnd),
  )
  if ret == 0 {
    return 0, err
  }
  return windows.Handle(ret), nil
}

func releaseDC(hWnd windows.Handle, hDC windows.Handle) bool {
  ret, _, _ := pReleaseDC.Call(
    uintptr(hWnd),
    uintptr(hDC),
  )
  return ret != 0
} 

func createWindow(className string, windowName string, style, style_ext uint32, x, y, width, height uint32, parent, menu, instance windows.Handle) (windows.Handle, error) {
  ret, _, err := pCreateWindowExW.Call(
    uintptr(style),
    uintptr(unsafe.Pointer(windows.StringToUTF16Ptr(className))),
    uintptr(unsafe.Pointer(windows.StringToUTF16Ptr(windowName))),
    uintptr(style_ext),
    uintptr(x),
    uintptr(y),
    uintptr(width),
    uintptr(height),
    uintptr(parent),
    uintptr(menu),
    uintptr(instance),
    uintptr(0),
  )
  if ret == 0 {
    return 0, err
  }
  return windows.Handle(ret), nil
}

func setWinEventHook(eventMin uint32, eventMax uint32, hmodWinEventProc windows.Handle, pfnWinEventProc uintptr, idProcess int, idThread, dwFlags uint32) (windows.Handle, error) {
  ret, _, err := pSetWinEventHook.Call(
    uintptr(eventMin),
    uintptr(eventMax),
    uintptr(hmodWinEventProc),
    pfnWinEventProc,
    uintptr(idProcess),
    uintptr(idThread),
    uintptr(dwFlags),
  )
  if ret == 0 {
    return 0, err
  }
  return windows.Handle(ret), nil
}

func unhookWinEvent(hWinEventHook windows.Handle) bool {
  ret, _, _ := pUnhookWinEvent.Call(
    uintptr(hWinEventHook),
  )
  return ret != 0
}

func loadImage(imagePath string) (windows.Handle, error) {
  ret, _, err := pLoadImageW.Call(
    uintptr(0),
    uintptr(unsafe.Pointer(windows.StringToUTF16Ptr(imagePath))),
    uintptr(IMAGE_BITMAP),
    uintptr(0),
    uintptr(0),
    uintptr(LR_LOADFROMFILE),
  )
  if ret == 0 {
    return 0, err
  }
  return windows.Handle(ret), nil
}

func defWindowProc(hwnd windows.Handle, msg uint32, wparam, lparam uintptr) uintptr {
  ret, _, _ := pDefWindowProcW.Call(
    uintptr(hwnd),
    uintptr(msg),
    uintptr(wparam),
    uintptr(lparam),
  )
  return uintptr(ret)
}

func destroyWindow(hwnd windows.Handle) error {
  ret, _, err := pDestroyWindow.Call(uintptr(hwnd))
  if ret == 0 {
    return err
  }
  return nil
}

func registerClassEx(wcx *WNDCLASSEXW) (uint16, error) {
  ret, _, err := pRegisterClassExW.Call(
    uintptr(unsafe.Pointer(wcx)),
  )
  if ret == 0 {
    return 0, err
  }
  return uint16(ret), nil
}

func dispatchMessage(msg *MSG) {
  pDispatchMessageW.Call(uintptr(unsafe.Pointer(msg)))
}

func getMessage(msg *MSG, hwnd windows.Handle, msgFilterMin, msgFilterMax uint32) (bool, error) {
  ret, _, err := pGetMessageW.Call(
    uintptr(unsafe.Pointer(msg)),
    uintptr(hwnd),
    uintptr(msgFilterMin),
    uintptr(msgFilterMax),
  )
  if int32(ret) == -1 {
    return false, err
  }
  return int32(ret) != 0, nil
}

func postQuitMessage(exitCode int32) {
  pPostQuitMessage.Call(uintptr(exitCode))
}

func translateMessage(msg *MSG) {
  pTranslateMessage.Call(uintptr(unsafe.Pointer(msg)))
}
```

`src/internal/ui/util.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package ui

import (
  "golang.org/x/sys/windows"
)

func getScreenResolution() (uint32, uint32, error){
  hDC, err := getDC(0)
  if err != nil {
    return 0, 0, err
  }
  defer releaseDC(0, hDC)
  
  width := getDeviceCaps(hDC, HORZRES)
  height := getDeviceCaps(hDC, VERTRES)
  return width, height, nil
}

func createBrushFromBMP(splashImage string) (windows.Handle, BITMAP, error) {
  hbm, err := loadImage(splashImage)
  if err != nil {    
    return 0, BITMAP{}, err
  } 
   
  hbrush, err := createPatternBrush(hbm)
  if err != nil {    
    return 0, BITMAP{}, err
  }
  
  //Get Image dimension
  image, err:= getObject(hbm)
  if err != nil {
    return hbrush, image, err
  }

  return hbrush, image, nil
}
```

`src/internal/version/version.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package version

import (
  "unsafe"
  "golang.org/x/sys/windows"
)

type FileVersion struct {
  Major                   uint16
  Minor                   uint16
  Build                   uint16
  Revision                uint16
}

func FromFile(filePath string) (FileVersion, error) {

  size, err := windows.GetFileVersionInfoSize(filePath, nil)
  if err != nil {
    return FileVersion{}, err
  }

  buf := make([]byte, size)
  if err := windows.GetFileVersionInfo(
    filePath, 
    0,
    size,
    unsafe.Pointer(&buf[0]),
  ); err != nil {
    return FileVersion{}, err
  }

  var versionInfo *windows.VS_FIXEDFILEINFO
  var versionInfoSize uint32
  if err := windows.VerQueryValue(unsafe.Pointer(
    &buf[0]), 
    "\\", 
    unsafe.Pointer(&versionInfo), 
    &versionInfoSize,
  ); err != nil {
    return FileVersion{}, err
  }

  version := FileVersion{
    Major:    uint16(versionInfo.FileVersionMS >> 16),
    Minor:    uint16(versionInfo.FileVersionMS & 0xFFFF),
    Build:    uint16(versionInfo.FileVersionLS >> 16),
    Revision: uint16(versionInfo.FileVersionLS & 0xFFFF),
  }

  return version, nil
}
```

`src/internal/video/video.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

//Ported to Go From https://github.com/xan105/node-win-screen-resolution (MIT)

package video

import (
  "unsafe"
  "errors"
  "golang.org/x/sys/windows"
)

var (
  user32                                     = windows.NewLazySystemDLL("user32.dll")
  gdi32                                      = windows.NewLazySystemDLL("gdi32.dll")
  shcore                                     = windows.NewLazySystemDLL("shcore.dll")
  pSetThreadDpiAwarenessContext              = user32.NewProc("SetThreadDpiAwarenessContext")
  pGetDC                                     = user32.NewProc("GetDC")
  pReleaseDC                                 = user32.NewProc("ReleaseDC")
  pMonitorFromPoint                          = user32.NewProc("MonitorFromPoint")
  pGetDeviceCaps                             = gdi32.NewProc("GetDeviceCaps")
  pGetDpiForMonitor                          = shcore.NewProc("GetDpiForMonitor")
)

const (
  HORZRES                                    = 8
  VERTRES                                    = 10
  VREFRESH                                   = 116
  MDT_EFFECTIVE_DPI                          = 0
  MONITOR_DEFAULTTOPRIMARY                   = 0x00000001
  // DPI awareness
  USER_DEFAULT_SCREEN_DPI                    = 96
  DPI_AWARENESS_CONTEXT_UNAWARE              = ^uintptr(1) + 1
  DPI_AWARENESS_CONTEXT_SYSTEM_AWARE         = ^uintptr(2) + 1
  DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE    = ^uintptr(3) + 1
  DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 = ^uintptr(4) + 1
  DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED    = ^uintptr(5) + 1
)

type VideoMode struct {
  Width   uint64
  Height  uint64
  Hz      uint64
  Scale   uint64
}

func GetCurrentDisplayMode() (VideoMode, error) {

  pSetThreadDpiAwarenessContext.Call(uintptr(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2)) //>=Win10

  var mode VideoMode

  hdc, _, err := pGetDC.Call(0)
  if hdc == 0 {
    return mode, err
  }
  defer pReleaseDC.Call(0, hdc)

  width, _, _  := pGetDeviceCaps.Call(hdc, HORZRES)
  height, _, _ := pGetDeviceCaps.Call(hdc, VERTRES)
  hz, _, _     := pGetDeviceCaps.Call(hdc, VREFRESH)

  mode.Width = uint64(width)
  mode.Height = uint64(height)
  mode.Hz = uint64(hz)
  
  var dpiX, dpiY uint32 = 96, 96 // Default DPI
  hMonitor, _, err := pMonitorFromPoint.Call(
    0, 
    0, 
    uintptr(MONITOR_DEFAULTTOPRIMARY),
  )
  if hMonitor == 0 {
    return mode, err
  }
  
  pGetDpiForMonitor.Call(
    hMonitor, 
    uintptr(MDT_EFFECTIVE_DPI), 
    uintptr(unsafe.Pointer(&dpiX)), 
    uintptr(unsafe.Pointer(&dpiY)),
  )
  
  //NB: Microsoft states that dpiX == dpiY and just to pick one
  mode.Scale = uint64((float64(dpiX) / 96.0) * 100.0)
  if dpiX != dpiY {
    return mode, errors.New("DPI X should equal DPI Y !!")
  }

  return mode, nil
}
```

`src/internal/wine/wine.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package wine

import (
  "golang.org/x/sys/windows"
)

var (
  checked = false
  wine    = false
)

func IsWineOrProton() bool { //Check for wine_get_version() to detect Wine/Proton

  if checked {
    return wine
  }

  ntdll, err := windows.LoadLibrary("ntdll.dll")
  if err != nil {
    checked = true
    return wine
  }
  defer windows.FreeLibrary(ntdll)

  procAddr, err := windows.GetProcAddress(ntdll, "wine_get_version")
  if err == nil && procAddr != 0 {
    wine = true
  }
  
  checked = true
  return wine
}
```

`src/launcher.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "os"
  "os/exec"
  "strings"
  "syscall"
  "path/filepath"
  "golang.org/x/sys/windows"
  "launcher/lua"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/internal/priority"
  "launcher/internal/affinity"
  "launcher/internal/thread"
)

func buildCommand(binary string, config Config) *exec.Cmd {
  
  var cmd *exec.Cmd
  
  if config.Shell != nil && *config.Shell {
    shell := os.Getenv("COMSPEC")
    if len(shell) == 0 {
      shell = filepath.Join(os.Getenv("WINDIR") + "System32/cmd.exe")
    }
    cmd = exec.Command(shell)
    argv := []string{ "\"" + shell + "\"" } //argv0
    argv = append(argv, "/D", "/C", "\"\"" + binary + "\"")
    if len(config.Args) > 0 {
      argv = append(argv, expand.ExpandVariables(config.Args))
    }
    last := len(argv)-1
    argv[last] = argv[last] + "\""
    cmd.SysProcAttr = &syscall.SysProcAttr{
      CmdLine: strings.Join(argv, " "), //verbatim arguments
    }
  } else {
    cmd = exec.Command(binary)
    argv := []string{ "\"" + binary + "\"" } //argv0
    if len(config.Args) > 0 {
      argv = append(argv, expand.ExpandVariables(config.Args))
    }
    cmd.SysProcAttr = &syscall.SysProcAttr{
      CmdLine: strings.Join(argv, " "), //verbatim arguments
    }
  }
    
  flags := priority.GetPriorityClass(config.Priority)
  if config.Suspended != nil && *config.Suspended {
    flags = flags | windows.CREATE_SUSPENDED
  }
  
  cmd.SysProcAttr.CreationFlags = flags
  cmd.SysProcAttr.HideWindow = config.Hide != nil && *config.Hide
  
  cmd.Dir = filepath.Dir(binary)
  if len(config.Cwd) > 0 {
    cmd.Dir = fs.Resolve(config.Cwd)
  }

  cmd.Env = os.Environ()
  if len(config.Env) > 0 {
    for key, value := range config.Env {
      if len(key) > 0 && len(value) > 0 {
        cmd.Env = append(cmd.Env, key + "=" + expand.ExpandVariables(value))
      }
    }
  }
  
  cmd.Stdin = nil
  cmd.Stdout = nil
  cmd.Stderr = nil
  
  return cmd
}

func main(){

  cmdLine := parseArgs()
  configFile := fs.Resolve(cmdLine.ConfigPath)
  config, err := fs.ReadJSON[Config](configFile)
  if err != nil { panic("JSON Parser", err.Error()) }

  if path := displayMenuOverride(config.Menu, cmdLine.ConfigPath); len(path) > 0 {
    overrideFile := fs.Resolve(path)
    if (configFile != overrideFile) {
      override, err := fs.ReadJSON[Config](overrideFile)
      if err != nil { panic("JSON Parser", err.Error()) }
      mergeConfig(&config, &override)
    }
  }

  binary := fs.Resolve(expand.ExpandVariables(config.Bin))
  cmd := buildCommand(binary, config)
  
  applyPatches(binary, config.Patch)
  verifyIntegrity(binary, config.Integrity)
  makeLink(config.Symlink)
  applyFileAttributes(config.Attrib)
  setCompatFlags(binary, config.Compatibility)
  updatePrefixSettings(config.Prefix)
  makeShortcut(binary, config.Shortcut)

  if len(config.Script.Path) > 0 {
    script := fs.Resolve(expand.ExpandVariables(config.Script.Path))
    ext := filepath.Ext(script)
    switch ext {
      case ".lua": {
        if err := lua.LoadLua(script, lua.Permissions{
          Fs: config.Script.Fs != nil && *config.Script.Fs,
          Net: config.Script.Net != nil && *config.Script.Net,
          Reg: config.Script.Reg != nil && *config.Script.Reg,
          Exec: config.Script.Exec != nil && *config.Script.Exec,
          Import: config.Script.Import != nil && *config.Script.Import,
        }); err != nil {
          panic("Lua", err.Error())
        }
      }
      /*
      case ".wasm": {
        //wazero ? (Pure Go -- does NOT require CGO)
      }
      */
      default: {
        panic("Launcher", "Unsupported script: \""+ ext +"\"")  
      }
    } 
  }

  if cmdLine.DryRun { 
    lua.CloseLua()
    os.Exit(0) 
  }
  
  if err := cmd.Start(); err != nil { 
    panic("Launcher", err.Error()) 
  }
  
  if config.Suspended != nil && *config.Suspended {
    if config.Affinity != nil && len(config.Affinity) > 0 {
      if err := affinity.SetProcessAffinity(cmd.Process.Pid, config.Affinity); err != nil {
        alert("Launcher", "Failed to set process affinity: " + err.Error())
      }
    }
  }
  
  loadAddons(binary, cmd.Process, config.Addons)
  
  if config.Suspended != nil && *config.Suspended {
    if err := thread.ResumeMainThread(cmd.Process.Pid); err != nil {
      cmd.Process.Kill()
      panic("Launcher", "Failed to resume process main thread: " + err.Error())
    }
  }

  displaySplash(cmd.Process.Pid, config.Splash)
  
  if config.Wait != nil && *config.Wait {
    cmd.Wait()
  }
  
  if err := lua.TriggerEvent("process", "will-quit"); err != nil {
    panic("Lua", err.Error())
  }
  
  lua.CloseLua()
}
```

`src/lua/global/array/array.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package array

import (
  "github.com/yuin/gopher-lua"
)

func Find(L *lua.LState) int {
  table := L.CheckTable(1)
  fn := L.CheckFunction(2)

  for i := 1; i <= table.Len(); i++ {
    value := table.RawGetInt(i)

    L.Push(fn)
    L.Push(value)
    err := L.PCall(1, 1, nil)
    if err != nil {
      L.RaiseError("Error calling function: %v", err)
    }

    if L.ToBool(-1) {
      L.Push(value)
      return 1
    }

    L.Pop(1)
  }

  L.Push(lua.LNil)
  return 1
}

func Some(L *lua.LState) int {
  table := L.CheckTable(1)
  fn := L.CheckFunction(2)

  for i := 1; i <= table.Len(); i++ {
    value := table.RawGetInt(i)

    L.Push(fn)
    L.Push(value)
    err := L.PCall(1, 1, nil)
    if err != nil {
      L.RaiseError("Error calling function: %v", err)
    }

    if L.ToBool(-1) {
      L.Push(lua.LTrue)
      return 1
    }

    L.Pop(1)
  }

  L.Push(lua.LFalse)
  return 1
}

func Includes(L *lua.LState) int {
  table := L.CheckTable(1)
  searchElement := L.CheckAny(2)

  for i := 1; i <= table.Len(); i++ {
    value := table.RawGetInt(i)

    if value == searchElement {
      L.Push(lua.LTrue)
      return 1
    }
  }

  L.Push(lua.LFalse)
  return 1
}
```

`src/lua/global/console.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package global

import (
  "log/slog"
  "strings"
  "github.com/yuin/gopher-lua"
)

//cf: https://nodejs.org/api/util.html#customizing-utilinspect-colors
const (
  reset     = "\033[0m"
  yellow    = "\033[33m"  // Bigint, Boolean, Number
  magenta   = "\033[35m"  // Date
  underline = "\033[4m"   // Module
  green     = "\033[32m"  // String, Symbol
  cyan      = "\033[36m"  // Special (e.g., Proxies)
  red       = "\033[31m"  // RegExp
  bold      = "\033[1m"   // Null
  grey      = "\033[90m"  // Undefined
)

func format(L *lua.LState, val lua.LValue, depth int) string {
  switch v := val.(type) {
  case *lua.LTable:
    msg := []string{"{"}
    indent := strings.Repeat("  ", depth + 1)
    L.ForEach(v, func(key lua.LValue, value lua.LValue) {
      msg = append(msg, indent + key.String() + ": "+ format(L, value, depth + 1) + ",")
    })
    last := len(msg)-1
    msg[last] = strings.TrimRight(msg[last], ",")
    msg = append(msg, strings.Repeat("  ", depth) + "}")
    return strings.Join(msg, "\n")
  case lua.LString:
    return green + "\"" + v.String() + "\"" + reset
  case lua.LNumber:
    return yellow + v.String() + reset
  case lua.LBool:
    return yellow + v.String() + reset
  case *lua.LNilType:
    return bold + "nil" + reset
  case *lua.LFunction, *lua.LState, *lua.LChannel:
    return cyan + v.String() + reset
  case *lua.LUserData:
    meta := L.ToStringMeta(val).String() //`ToStringMeta` call `__tostring` metamethod
    if meta == v.String() { 
        return cyan + meta + reset
    } else { 
        return green + "\"" + meta + "\"" + reset 
    }
  default:
    return grey + val.String() + reset
  }
}

func Log(L *lua.LState) int {
  var output []string
  args := L.GetTop()

  for i := 1; i <= args; i++ {
    val := L.Get(i)
    output = append(output, format(L, val, 0))
  }

  slog.Info(strings.Join(output, " "))
  return 0
}

func Warn(L *lua.LState) int {
  var output []string
  args := L.GetTop()

  for i := 1; i <= args; i++ {
    val := L.Get(i)
    output = append(output, format(L, val, 0))
  }

  slog.Warn(strings.Join(output, " "))
  return 0
}

func Error(L *lua.LState) int {
  var output []string
  args := L.GetTop()

  for i := 1; i <= args; i++ {
    val := L.Get(i)
    output = append(output, format(L, val, 0))
  }

  slog.Error(strings.Join(output, " "))
  return 0
}
```

`src/lua/global/sleep.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package global

import (
  "time"
  "github.com/yuin/gopher-lua"
)

func Sleep(L *lua.LState) int {
  interval := L.CheckInt(1)
  
  wait := make(chan struct{})
  go func() {
      time.Sleep(time.Millisecond * time.Duration(interval))
      close(wait)
  }()
  <-wait

  return 0
}
```

`src/lua/lua.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package lua

import (
  "github.com/yuin/gopher-lua"
  "launcher/lua/type/failure"
  "launcher/lua/global"
  "launcher/lua/global/array"
  "launcher/lua/module/regedit"
  "launcher/lua/module/random"
  "launcher/lua/module/file"
  "launcher/lua/module/archive"
  "launcher/lua/module/user"
  "launcher/lua/module/video"
  "launcher/lua/module/http"
  "launcher/lua/module/config/json"
  "launcher/lua/module/config/ini"
  "launcher/lua/module/config/toml"
  "launcher/lua/module/config/yaml"
  "launcher/lua/module/config/xml"
  "launcher/lua/module/process"
  "launcher/lua/module/shell"
  "launcher/lua/module/time"
  "launcher/lua/module/steamid"
  "launcher/lua/script"
)

type Permissions struct {
  Fs      bool  //Filesystem
  Net     bool  //Network request
  Reg     bool  //Windows registry
  Exec    bool  //Exec shell command
  Import  bool  //Load external Lua code
}

var L *lua.LState

var EventRegistry = map[string]map[string]*lua.LFunction{ 
  "process": process.EventRegistry,
}

func LoadLua(filePath string, perm Permissions) error {

  if L != nil { return nil }
  
  L = lua.NewState(lua.Options{ SkipOpenLibs: true })
  
  //Opening a subset of built-in modules
  for _, builtin := range []struct {
    name string
    function lua.LGFunction
  }{
    { lua.LoadLibName, lua.OpenPackage }, //Must be first
    { lua.BaseLibName, lua.OpenBase },
    { lua.TabLibName, lua.OpenTable },
    { lua.StringLibName, lua.OpenString },
    { lua.MathLibName, lua.OpenMath },
    { lua.CoroutineLibName, lua.OpenCoroutine },
  } {
    if err := L.CallByParam(lua.P{
      Fn:      L.NewFunction(builtin.function),
      NRet:    0,
      Protect: true,
    }, lua.LString(builtin.name)); err != nil {
      return err
    }
  }

  if !perm.Import {
    packageTbl := L.GetGlobal("package").(*lua.LTable)
    packageTbl.RawSetString("path", lua.LString("")) //overwrite default package path search
    loadersTbl := packageTbl.RawGetString("loaders").(*lua.LTable)
    loadersTbl.RawSetInt(2, L.NewFunction(permissionStub)) //overwrite 2nd package loader (fs load)
    //overwrite loading methods
    L.SetGlobal("dofile", L.NewFunction(permissionStub))
    L.SetGlobal("load", L.NewFunction(permissionStub))
    L.SetGlobal("loadfile", L.NewFunction(permissionStub))
    L.SetGlobal("loadstring", L.NewFunction(permissionStub))
  }

  //Custom Type (Global)
  failure.RegisterType(L)
  
  //Globals
  L.SetGlobal("sleep", L.NewFunction(global.Sleep))
  L.SetGlobal("print", L.NewFunction(global.Log)) //override built-in and alias it to console.log
  L.SetGlobal("console", L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
    "log": global.Log,
    "warn": global.Warn,
    "error": global.Error,
  }))
  L.SetGlobal("Array", L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
    "find": array.Find,
    "some": array.Some,
    "includes": array.Includes,
  }))

  //Module
  if perm.Reg {
    L.PreloadModule("regedit", regedit.Loader)
  } else {
    L.PreloadModule("regedit", permissionStub)
  }
  if perm.Fs {
    L.PreloadModule("file", file.Loader)
    L.PreloadModule("archive", archive.Loader)
  } else {
    L.PreloadModule("file", permissionStub)
    L.PreloadModule("archive", permissionStub)
  }
  if perm.Net {
    L.PreloadModule("http", http.Loader)
  } else {
    L.PreloadModule("http", permissionStub)
  }
  if perm.Exec {
    L.PreloadModule("shell", shell.Loader)
  } else {
    L.PreloadModule("shell", permissionStub)
  }
  L.PreloadModule("random", random.Loader)
  L.PreloadModule("user", user.Loader)
  L.PreloadModule("video", video.Loader)
  L.PreloadModule("config/json", json.Loader)
  L.PreloadModule("config/ini", ini.Loader)
  L.PreloadModule("config/toml", toml.Loader)
  L.PreloadModule("config/yaml", yaml.Loader)
  L.PreloadModule("config/xml", xml.Loader)
  L.PreloadModule("process", process.Loader)
  L.PreloadModule("time", time.Loader)
  L.PreloadModule("SteamID", steamid.Loader)

  if err := script.ImportEmbeddedLuaScript(L); err != nil {
    return err
  }
  
  //Exec
  return L.DoFile(filePath);
}

func CloseLua() {
  if L != nil { 
    L.Close()
  }
}

func TriggerEvent(module string, event string) error {
  if L == nil { return nil }
  
  events, exists := EventRegistry[module]
  if !exists { return nil }
  
  callback, exists := events[event]
  if !exists { return nil }
  
  L.Push(callback)
  return L.PCall(0, 0, nil)
}

func permissionStub(L *lua.LState) int {
  if ar, ok := L.GetStack(1); ok {
    if _, err := L.GetInfo("n", ar, lua.LNil); err == nil && ar.Name == "require" {
      if name, ok := L.Get(1).(lua.LString); ok && len(name) > 0 {
        L.RaiseError("Module \"%s\" unavailable due to lack of permission!", name)
        return 0
      }
    }
  }
  L.RaiseError("Operation unavailable due to lack of permission!")
  return 0
}

```

`src/lua/module/archive/7z.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package archive

import (
  "os"
  "io"
  "strings"
  "path/filepath"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/lua/type/failure"
  "github.com/yuin/gopher-lua"
  "github.com/bodgit/sevenzip"
)

func Un7z(L *lua.LState) int {

  path := L.CheckString(1)
  if len(path) > 0 {
    path = fs.Resolve(expand.ExpandVariables(path))
    if filepath.Ext(path) != ".7z" {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", "Not a .7z file !"))
      return 1
    }
  } else {
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", "Archive file path is empty!"))
    return 1
  }

  destDir := L.CheckString(2)
  if len(destDir) > 0{
    destDir = fs.Resolve(expand.ExpandVariables(destDir))
  } else {
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", "Destination dir is empty!"))
    return 1
  }

  excludeList := []string{}
  if L.GetTop() >= 3 {
    list := L.CheckTable(3)
    list.ForEach(func(_, value lua.LValue) {
      if str, ok := value.(lua.LString); ok {
        excludeList = append(excludeList, filepath.FromSlash(string(str)))
      }
    })
  }

  r, err := sevenzip.OpenReader(path)
  if err != nil {
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 1
  }
  defer r.Close()

  for _, file := range r.File {
    fpath := filepath.Join(destDir, file.Name)

    skip := false
    for _, exclude := range excludeList {
      if strings.HasPrefix(filepath.FromSlash(file.Name), exclude) {
        skip = true
        break
      }
    }
    if skip { continue }
    
    if file.FileInfo().IsDir() {
      os.MkdirAll(fpath, os.ModePerm)
      continue
    }

    if !strings.HasPrefix(fpath, filepath.Clean(destDir) + string(os.PathSeparator)) {
      continue
    }

    if err := os.MkdirAll(filepath.Dir(fpath), os.ModePerm); err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    }

    outFile, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
    if err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    }
    defer outFile.Close()

    rc, err := file.Open()
    if err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    }
    
    _, err = io.Copy(outFile, rc)
    rc.Close()
    if err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    } 
  }

  return 0
}
```

`src/lua/module/archive/archive.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package archive

import (
  "github.com/yuin/gopher-lua"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Unzip": Unzip,
    "Un7z": Un7z,
  }
    
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}
```

`src/lua/module/archive/zip.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package archive

import (
  "os"
  "io"
  "strings"
  "archive/zip"
  "path/filepath"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/lua/type/failure"
  "github.com/yuin/gopher-lua"
)

func Unzip(L *lua.LState) int {

  path := L.CheckString(1)
  if len(path) > 0 {
    path = fs.Resolve(expand.ExpandVariables(path))
    if filepath.Ext(path) != ".zip" {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", "Not a .zip file !"))
      return 1
    }
  } else {
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", "Archive file path is empty!"))
    return 1
  }

  destDir := L.CheckString(2)
  if len(destDir) > 0{
    destDir = fs.Resolve(expand.ExpandVariables(destDir))
  } else {
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", "Destination dir is empty!"))
    return 1
  }

  excludeList := []string{}
  if L.GetTop() >= 3 {
    list := L.CheckTable(3)
    list.ForEach(func(_, value lua.LValue) {
      if str, ok := value.(lua.LString); ok {
        excludeList = append(excludeList, filepath.FromSlash(string(str)))
      }
    })
  }

  r, err := zip.OpenReader(path)
  if err != nil {
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 1
  }
  defer r.Close()

  for _, file := range r.File {
    fpath := filepath.Join(destDir, file.Name)

    skip := false
    for _, exclude := range excludeList {
      if strings.HasPrefix(filepath.FromSlash(file.Name), exclude) {
        skip = true
        break
      }
    }
    if skip { continue }
    
    if file.FileInfo().IsDir() {
      os.MkdirAll(fpath, os.ModePerm)
      continue
    }

    if !strings.HasPrefix(fpath, filepath.Clean(destDir) + string(os.PathSeparator)) {
      continue
    }

    if err := os.MkdirAll(filepath.Dir(fpath), os.ModePerm); err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    }

    outFile, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
    if err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    }
    defer outFile.Close()

    rc, err := file.Open()
    if err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    }
    defer rc.Close()

    _, err = io.Copy(outFile, rc)
    if err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    }
  }

  return 0
}
```

`src/lua/module/config/config.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package config

import (
  "github.com/yuin/gopher-lua"
)

func ToLuaValue(L *lua.LState, value interface{}) lua.LValue {
  switch v := value.(type) {
    case string:
      return lua.LString(v)
    case bool:
      return lua.LBool(v)
    case float64:
      return lua.LNumber(v)
    case map[string]interface{}:
      return ToLuaTable(L, v)
    case []interface{}:
      arrayTable := L.NewTable()
      for i, item := range v {
        arrayTable.RawSetInt(i+1, ToLuaValue(L, item))
      }
    return arrayTable
    default:
      return lua.LNil
  }
}

func ToLuaTable(L *lua.LState, data map[string]interface{}) *lua.LTable {
  table := L.NewTable()
  for key, value := range data {
    switch v := value.(type) {
      case map[string]interface{}:
        table.RawSetString(key, ToLuaTable(L, v))
      case []interface{}:
        arrayTable := L.NewTable()
        for i, item := range v {
          arrayTable.RawSetInt(i+1, ToLuaValue(L, item))
        }
        table.RawSetString(key, arrayTable)
      default:
        table.RawSetString(key, ToLuaValue(L, v))
    }
  }
  return table
}

func ToGoMap(luaTable *lua.LTable) map[string]interface{} {
  data := make(map[string]interface{})
  luaTable.ForEach(func(key lua.LValue, value lua.LValue) {
    switch v := value.(type) {
    case *lua.LTable:
      data[key.String()] = ToGoMap(v)
    case lua.LString:
        data[key.String()] = v.String()
    case lua.LNumber:
        data[key.String()] = float64(v)
    case lua.LBool:
        data[key.String()] = bool(v)
    default:
      data[key.String()] = v.String()
    }
  })
  return data
}
```

`src/lua/module/config/ini/ini.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package ini

import (
  "github.com/yuin/gopher-lua"
  "launcher/internal/ini"
  "launcher/lua/module/config"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Parse": Parse,
    "Stringify": Stringify,
  }
  
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}

func Parse(L *lua.LState) int {
  iniStr := L.CheckString(1)

  options := ini.ParserOptions{
    Filter:  []string{},
    Global:  true,
    Unquote: true,
    Boolean: true,
    Number:  true,
  }

  if L.GetTop() >= 2 {
    table := L.CheckTable(2)
    
    table.ForEach(func(key lua.LValue, value lua.LValue) {
      switch key.String() {
      case "filter":
        if arr, ok := value.(*lua.LTable); ok {
          filter := []string{}
          arr.ForEach(func(_, v lua.LValue) {
            filter = append(filter, v.String())
          })
          options.Filter = filter
        }
      case "global":
        if b, ok := value.(lua.LBool); ok {
          options.Global = bool(b)
        }
      case "unquote":
        if b, ok := value.(lua.LBool); ok {
          options.Unquote = bool(b)
        }
      case "boolean":
        if b, ok := value.(lua.LBool); ok {
          options.Boolean = bool(b)
        }
      case "number":
        if b, ok := value.(lua.LBool); ok {
          options.Number = bool(b)
        }
      }
    })
  }

  data := ini.Parse(iniStr, &options)
  luaTable := config.ToLuaTable(L, data)
  L.Push(luaTable)
  return 1
}

func Stringify(L *lua.LState) int {
  luaTable := L.CheckTable(1)
  
  options := ini.StringifyOptions{
    Whitespace: true,
    BlankLine: false,
    Quote: false,
  }
  
  if L.GetTop() >= 2 {
    table := L.CheckTable(2)
    
    table.ForEach(func(key lua.LValue, value lua.LValue) {
      switch key.String() {
      case "whitespace":
        if b, ok := value.(lua.LBool); ok {
          options.Whitespace = bool(b)
        }
      case "blankLine":
        if b, ok := value.(lua.LBool); ok {
          options.BlankLine = bool(b)
        }
      case "quote":
        if b, ok := value.(lua.LBool); ok {
          options.Quote = bool(b)
        }
      }
    })
  }

  data := config.ToGoMap(luaTable)
  iniStr := ini.Stringify(data, &options)
  L.Push(lua.LString(iniStr))
  return 1
}
```

`src/lua/module/config/json/json.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package json

import (
  "encoding/json"
  "github.com/yuin/gopher-lua"
  "launcher/lua/module/config"
  "launcher/lua/type/failure"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Parse": Parse,
    "Stringify": Stringify,
  }
  
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}

func Parse(L *lua.LState) int {
  jsonStr := L.CheckString(1)

  var data map[string]interface{}
  if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_JSON_PARSE", err.Error()))
    return 2
  }

  luaTable := config.ToLuaTable(L, data)
  L.Push(luaTable)
  return 1
}

func Stringify(L *lua.LState) int {
  luaTable := L.CheckTable(1)
  pretty := true
  if L.GetTop() > 1 {
    pretty = L.CheckBool(2)
  }
  
  indent := ""
  if pretty {
    indent = "  "
  }
  
  data := config.ToGoMap(luaTable)
  jsonBytes, err := json.MarshalIndent(data, "", indent)
  if err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_JSON_PARSE", err.Error()))
    return 2
  }

  L.Push(lua.LString(jsonBytes))
  return 1
}
```

`src/lua/module/config/toml/toml.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package toml

import (
  "github.com/pelletier/go-toml/v2"
  "github.com/yuin/gopher-lua"
  "launcher/lua/module/config"
  "launcher/lua/type/failure"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Parse": Parse,
    "Stringify": Stringify,
  }
  
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}

func Parse(L *lua.LState) int {
  tomlStr := L.CheckString(1)

  var data map[string]interface{}
  if err := toml.Unmarshal([]byte(tomlStr), &data); err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_TOML_PARSE", err.Error()))
    return 2
  }

  luaTable := config.ToLuaTable(L, data)
  L.Push(luaTable)
  return 1
}

func Stringify(L *lua.LState) int {
  luaTable := L.CheckTable(1)

  data := config.ToGoMap(luaTable)
  tomlBytes, err := toml.Marshal(data)
  if err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_TOML_PARSE", err.Error()))
    return 2
  }

  L.Push(lua.LString(tomlBytes))
  return 1
}
```

`src/lua/module/config/xml/xml.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package xml

import (
  "github.com/clbanning/mxj/v2"
  "github.com/yuin/gopher-lua"
  "launcher/lua/module/config"
  "launcher/lua/type/failure"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Parse": Parse,
    "Stringify": Stringify,
  }
  
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}

func Parse(L *lua.LState) int {
  xmlStr := L.CheckString(1)

  data, err := mxj.NewMapXml([]byte(xmlStr)) 
  if err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_XML_PARSE", err.Error()))
    return 2
  }

  luaTable := config.ToLuaTable(L, data)
  L.Push(luaTable)
  return 1
}

func Stringify(L *lua.LState) int {
  luaTable := L.CheckTable(1)
  pretty := true
  if L.GetTop() > 1 {
    pretty = L.CheckBool(2)
  }
  
  indent := ""
  if pretty {
    indent = "  "
  }
  
  data := config.ToGoMap(luaTable)
  m := mxj.Map(data)
  
  xmlBytes, err := m.XmlIndent("", indent)
  if err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_XML_PARSE", err.Error()))
    return 2
  }

  L.Push(lua.LString(xmlBytes))
  return 1
}
```

`src/lua/module/config/yaml/yaml.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package yaml

import (
  "gopkg.in/yaml.v3"
  "github.com/yuin/gopher-lua"
  "launcher/lua/module/config"
  "launcher/lua/type/failure"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Parse": Parse,
    "Stringify": Stringify,
  }
  
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}

func Parse(L *lua.LState) int {
  yamlStr := L.CheckString(1)

  var data map[string]interface{}
  if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_YAML_PARSE", err.Error()))
    return 2
  }

  luaTable := config.ToLuaTable(L, data)
  L.Push(luaTable)
  return 1
}

func Stringify(L *lua.LState) int {
  luaTable := L.CheckTable(1)

  data := config.ToGoMap(luaTable)
  yamlBytes, err := yaml.Marshal(data)
  if err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_YAML_PARSE", err.Error()))
    return 2
  }

  L.Push(lua.LString(yamlBytes))
  return 1
}
```

`src/lua/module/file/file.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package file

import (
  "os"
  "strings"
  "syscall"
  "path/filepath"
  "github.com/yuin/gopher-lua"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/internal/version"
  "launcher/internal/trust"
  "launcher/lua/type/failure"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Write": Write,
    "Read": Read,
    "Remove": Remove,
    "Info": Info,
    "Glob": Glob,
    "Basename": Basename,
    "SetAttributes": SetAttributes,
  }
    
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}

func Write(L *lua.LState) int {
  filename := L.CheckString(1)  
  data     := L.CheckString(2)
  format   := L.ToString(3)

  if len(format) == 0 {
    format = "utf8"
  } 
 
  err := fs.WriteFile(
    fs.Resolve(expand.ExpandVariables(filename)), 
    data, 
    format,
  )
  if err != nil {
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 1
  }
    
  return 0
}

func Read(L *lua.LState) int {
  filename := L.CheckString(1)  
  format   := L.ToString(2)

  if len(format) == 0 {
    format = "utf8"
  } 
  
  data, err := fs.ReadFile(
    fs.Resolve(expand.ExpandVariables(filename)), 
    format,
  )
  if err != nil {
    L.Push(lua.LString(""))
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 2
  }

  L.Push(lua.LString(data))
  return 1
}

func Remove(L *lua.LState) int {
  path := L.CheckString(1)
  
  err := fs.Remove(fs.Resolve(expand.ExpandVariables(path)))
  if err != nil {
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 1
  }
  
  return 0
}

func Info(L *lua.LState) int {
  filename := L.CheckString(1)
  filePath := fs.Resolve(expand.ExpandVariables(filename))
  
  info := L.NewTable()
  fileInfo, err := os.Stat(filePath)
  if err != nil {
    L.Push(info)
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 2
  }
  L.SetField(info, "size", lua.LNumber(fileInfo.Size()))
  
  time := L.NewTable()
  L.SetField(time, "modification", lua.LNumber(fileInfo.ModTime().Unix()))
  if sysInfo, ok := fileInfo.Sys().(*syscall.Win32FileAttributeData); ok {
    L.SetField(time, "creation", lua.LNumber(sysInfo.CreationTime.Nanoseconds() / 1e9))
    L.SetField(time, "access", lua.LNumber(sysInfo.LastAccessTime.Nanoseconds() / 1e9))
  }
  L.SetField(info, "time", time)

  if fileInfo.IsDir() {
    L.Push(info)
    return 1
  }

  fileVersionInfo, err := version.FromFile(filePath)
  if err == nil {
    version := L.NewTable()
    L.SetField(version, "major", lua.LNumber(fileVersionInfo.Major))
    L.SetField(version, "minor", lua.LNumber(fileVersionInfo.Minor))
    L.SetField(version, "build", lua.LNumber(fileVersionInfo.Build))
    L.SetField(version, "revision", lua.LNumber(fileVersionInfo.Revision))
    L.SetField(info, "version", version)
  }
  
  signed, _ := trust.VerifySignature(filePath)
  L.SetField(info, "signed", lua.LBool(signed))

  L.Push(info)
  return 1
}

func Glob(L *lua.LState) int {
  root := L.CheckString(1)
  pattern := L.CheckString(2)
  recursive := false
  absolute := false
  if L.GetTop() >= 3 {
    table := L.CheckTable(3)
    table.ForEach(func(key lua.LValue, value lua.LValue) {
      switch key.String() {
      case "recursive":
        if b, ok := value.(lua.LBool); ok {
          recursive = bool(b)
        }
      case "absolute":
        if b, ok := value.(lua.LBool); ok {
          absolute = bool(b)
        }
      }
    })
  }
  
  table := L.NewTable()    
  matches, err := fs.Glob(fs.Resolve(expand.ExpandVariables(root)), pattern, recursive, absolute)
  if err != nil {
    L.Push(table)
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 2
  }

  if matches != nil {
    for _, match := range matches {
      table.Append(lua.LString(match))
    }
  }

  L.Push(table)
  return 1
}

func Basename(L *lua.LState) int {
  path := L.CheckString(1)
  suffix := L.OptBool(2, true)
 
  filename := filepath.Base(path)
  if !suffix {
    filename = strings.TrimSuffix(filename, filepath.Ext(filename))
  }
  
  L.Push(lua.LString(filename))
  return 1
}

func SetAttributes(L *lua.LState) int {
  filename := L.CheckString(1)
  filePath := fs.Resolve(expand.ExpandVariables(filename))
  readonly := false
  hidden   := false
  if L.GetTop() >= 2 {
    table := L.CheckTable(2)
    table.ForEach(func(key lua.LValue, value lua.LValue) {
      switch key.String() {
      case "readonly":
        if b, ok := value.(lua.LBool); ok {
          readonly = bool(b)
        }
      case "hidden":
        if b, ok := value.(lua.LBool); ok {
          hidden = bool(b)
        }
      }
    })
  }

  if ok, _ := fs.FileExist(filePath); ok {   
    err := fs.SetFileAttributes(filePath, readonly, hidden)
    if err != nil {
      L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
      return 1
    }
  }

  return 0
}
```

`src/lua/module/http/download.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package http

import (
  "io"
  "os"
  "mime"
  "strings"
  "net/http"
  "path/filepath"
  "github.com/yuin/gopher-lua"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/lua/type/failure"
)

func Download(L *lua.LState) int {
  url := L.CheckString(1)
  
  destDir := L.CheckString(2)
  if len(destDir) > 0{
    destDir = fs.Resolve(expand.ExpandVariables(destDir))
  } else {
    L.Push(lua.LString(""))
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", "Destination dir is empty!"))
    return 1
  }
  
  resp, err := http.Get(url)
  if err != nil {
    L.Push(lua.LString(""))
    L.Push(failure.LValue(L, "ERR_NET_HTTP", err.Error()))
    return 2
  }
  defer resp.Body.Close()

  //Determine the filename
  parts := strings.Split(url, "/")
  last := len(parts)-1
  filename := parts[last]
  if cd := resp.Header.Get("Content-Disposition"); cd != "" {
    if _, params, err := mime.ParseMediaType(cd); err == nil {
      if name, ok := params["filename"]; ok {
        filename = name
      }
    }
  }

  //Create
  if err := os.MkdirAll(destDir, 0755); err != nil {
    L.Push(lua.LString(""))
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 2
  }
  filePath := filepath.Join(destDir, filename)
  out, err := os.Create(filePath)
  if err != nil {
    L.Push(lua.LString(""))
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 2
  }
  defer out.Close()

  //Write the body to file
  _, err = io.Copy(out, resp.Body)
  if err != nil {
    L.Push(lua.LString(""))
    L.Push(failure.LValue(L, "ERR_FILE_SYSTEM", err.Error()))
    return 2
  }

  L.Push(lua.LString(filePath))
  return 1
}
```

`src/lua/module/http/fetch.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package http

import (
  "io"
  "bytes"
  "net/http"
  "github.com/yuin/gopher-lua"
  "launcher/lua/type/failure"
)

func Fetch(L *lua.LState) int {
  url := L.CheckString(1)

  //Default options
  method := "GET"
  headers := make(map[string]string)
  var body io.Reader

  //Optional 'options' table
  if L.GetTop() >= 2 {
    options := L.CheckTable(2)
    options.ForEach(func(key lua.LValue, value lua.LValue) {
      if keyName, ok := key.(lua.LString); ok {
        switch string(keyName) {
          case "method":
            if methodStr, ok := value.(lua.LString); ok {
              method = string(methodStr)
            }
          case "body":
            if payload, ok := value.(lua.LString); ok {
              body = bytes.NewBuffer([]byte(payload))
            }
          case "headers":
            if headersTable, ok := value.(*lua.LTable); ok {
              headersTable.ForEach(func(hKey lua.LValue, hValue lua.LValue) {
                if hKeyStr, ok := hKey.(lua.LString); ok {
                  if hValueStr, ok := hValue.(lua.LString); ok {
                    headers[string(hKeyStr)] = string(hValueStr)
                  }
                }
              })
            }
        }
      }
    })
  }

  //Create HTTP request
  req, err := http.NewRequest(method, url, body)
  if err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_NET_HTTP", err.Error()))
    return 2
  }

  //Set headers
  for key, value := range headers {
    req.Header.Set(key, value)
  }

  //Make the request
  client := &http.Client{}
  resp, err := client.Do(req)
  if err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_NET_HTTP", err.Error()))
    return 2
  }
  defer resp.Body.Close()

  //Read response body
  respBody, err := io.ReadAll(resp.Body)
  if err != nil {
    L.Push(lua.LNil)
    L.Push(failure.LValue(L, "ERR_NET_HTTP", err.Error()))
    return 2
  }

  //Create response table
  result := L.NewTable()
  L.SetField(result, "status", lua.LNumber(resp.StatusCode))
  L.SetField(result, "body", lua.LString(string(respBody)))
  headersTable := L.NewTable()

  //Extract headers
  for key, values := range resp.Header {
    if len(values) > 0 {
      L.SetField(headersTable, key, lua.LString(values[0]))
    }
  }
  L.SetField(result, "headers", headersTable)

  L.Push(result)
  return 1
}
```

`src/lua/module/http/http.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package http

import (
  "github.com/yuin/gopher-lua"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Fetch": Fetch,
    "Download": Download,
  }
  
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}
```

`src/lua/module/process/process.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package process

import (
  "os"
  "runtime"
  "github.com/yuin/gopher-lua"
)

var EventRegistry = make(map[string]*lua.LFunction)

func Loader(L *lua.LState) int {

  mod := L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
    "Cwd": Getwd,
    "ExecPath": ExecPath,
    "On": On,
  })
  
  L.SetField(mod, "platform", lua.LString(runtime.GOOS))
  L.SetField(mod, "arch", lua.LString(runtime.GOARCH))
  L.SetField(mod, "pid", lua.LNumber(os.Getpid()))
  L.Push(mod)
  return 1
}

func On(L *lua.LState) int {
  name     := L.CheckString(1)
  callback := L.CheckFunction(2)

  EventRegistry[name] = callback
  return 0
}

func Getwd(L *lua.LState) int {
  cwd, _ := os.Getwd()
  L.Push(lua.LString(cwd))
  return 1
}

func ExecPath(L *lua.LState) int {
  path, _ := os.Executable()
  L.Push(lua.LString(path))
  return 1
}
```

`src/lua/module/random/alphanum.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package random

import (
  "github.com/yuin/gopher-lua"
  "math/rand"
)

func randAlphaNumString(length int) string {
  //cf: https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go
  
  const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  const IdxBits = 6
  const IdxMask = 1<<IdxBits - 1
  const IdxMax = 63 / IdxBits

  bytes := make([]byte, length)
  for i, cache, remain := length-1, rand.Int63(), IdxMax; i >= 0; {
    if remain == 0 {
      cache, remain = rand.Int63(), IdxMax
    }
    if idx := int(cache & IdxMask); idx < len(charset) {
      bytes[i] = charset[idx]
      i--
    }
    cache >>= IdxBits
    remain--
  }
  return string(bytes)
}

func AlphaNumString(L *lua.LState) int {
  length := L.CheckInt(1)  

  value := randAlphaNumString(length)
  L.Push(lua.LString(value))
  return 1
}
```

`src/lua/module/random/random.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package random

import (
  "github.com/yuin/gopher-lua"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "AlphaNumString": AlphaNumString,
    "UserPID": GetRandomUserPID,
    "SteamID": SteamID,
  }
    
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}
```

`src/lua/module/random/steamid.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package random

import (
  "time"
  "math/rand"
  "strconv"
  "github.com/yuin/gopher-lua"
  "launcher/internal/steam"
)

func SteamID(L *lua.LState) int {
  rand.Seed(time.Now().UnixNano())
  accountid := strconv.FormatUint(uint64(rand.Uint32()), 10)
  sid, _ := steam.ParseSteamID("[U:1:" + accountid +"]")
  L.Push(lua.LString(sid.AsSteam64()))
  return 1
}



```

`src/lua/module/random/userprocess.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package random

import (
  "math/rand"
  "unsafe"
  "time"
  "golang.org/x/sys/windows"
  "github.com/yuin/gopher-lua"
)

func getCurrentUserSID() (string, error) {

  hProcess, err := windows.GetCurrentProcess()
  if err != nil {
    return "", err
  }

  var token windows.Token
  if err := windows.OpenProcessToken(hProcess, windows.TOKEN_QUERY, &token); err != nil {
    return "", err
  }
  defer token.Close()

  user, err := token.GetTokenUser()
  if err != nil {
    return "", err
  }
  
  return user.User.Sid.String(), nil
}

func getProcessOwnerSID(pid uint32) (string, error) {
  hProcess, err := windows.OpenProcess(windows.PROCESS_QUERY_LIMITED_INFORMATION, false, pid)
  if err != nil {
    return "", err
  }
  defer windows.CloseHandle(hProcess)

  var token windows.Token
  err = windows.OpenProcessToken(hProcess, windows.TOKEN_QUERY, &token)
  if err != nil {
    return "", err
  }
  defer token.Close()

  user, err := token.GetTokenUser()
  if err != nil {
    return "", err
  }

  return user.User.Sid.String(), nil
}

func listUserProcesses() ([]uint32, error) {
  handle, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPPROCESS, 0)
  if err != nil {
    return nil, err
  }
  defer windows.CloseHandle(handle)

  var entry windows.ProcessEntry32
  entry.Size = uint32(unsafe.Sizeof(entry))

  currentSID, err := getCurrentUserSID()
  if err != nil {
    return nil, err
  }

  var userPIDs []uint32
  if err := windows.Process32First(handle, &entry); err != nil {
    return nil, err
  }

  for {
    processSID, err := getProcessOwnerSID(entry.ProcessID)
    if err == nil && processSID == currentSID {
      userPIDs = append(userPIDs, entry.ProcessID)
    }
    if err := windows.Process32Next(handle, &entry); err != nil {
      break
    }
  }

  return userPIDs, nil
}

func GetRandomUserPID(L *lua.LState) int {
  pids, err := listUserProcesses()
  if err != nil {
    L.Push(lua.LNumber(0))
    return 1
  }
  
  if len(pids) == 0 {
    L.Push(lua.LNumber(0))
    return 1
  }

  rand.Seed(time.Now().UnixNano())
  pid := pids[rand.Intn(len(pids))]
  
  L.Push(lua.LNumber(pid))
  return 1
}
```

`src/lua/module/regedit/regedit.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

//ref: https://github.com/xan105/node-cgo-regodit

package regedit

import (
  "strconv"
  "encoding/hex"
  "github.com/yuin/gopher-lua"
  "launcher/internal/regedit"
  "launcher/internal/expand"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "KeyExists": KeyExists,
    "ListAllSubkeys": ListAllSubkeys,
    "ListAllValues": ListAllValues,
    "QueryValueType": QueryValueType,
    "QueryStringValue": QueryStringValue,
    "QueryMultiStringValue": QueryMultiStringValue,
    "QueryBinaryValue": QueryBinaryValue,
    "QueryIntegerValue": QueryIntegerValue,
    "Create": Create,
    "Delete": Delete,
    "WriteStringValue": WriteStringValue,
    "WriteExpandStringValue": WriteExpandStringValue,
    "WriteMultiStringValue": WriteMultiStringValue,
    "WriteBinaryValue": WriteBinaryValue,
    "WriteDwordValue": WriteDwordValue,
    "WriteQwordValue": WriteQwordValue,
    "DeleteValue": DeleteValue,
  }
    
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}

func KeyExists(L *lua.LState) int {
  root := L.CheckString(1)  
  path := L.CheckString(2)

  L.Push(lua.LBool(regedit.KeyExists(root, path)))
  return 1
}

func ListAllSubkeys(L *lua.LState) int {
  root := L.CheckString(1)  
  path := L.CheckString(2)
  
  values := regedit.ListAllSubkeys(root, path)
  table := L.NewTable()
  for _, value := range values {
    table.Append(lua.LString(value))
  }
  
  L.Push(table)
  return 1
}

func ListAllValues(L *lua.LState) int {
  root := L.CheckString(1)  
  path := L.CheckString(2)
  
  values := regedit.ListAllValues(root, path)
  table := L.NewTable()
  for _, value := range values {
    table.Append(lua.LString(value))
  }
  
  L.Push(table)
  return 1
}

func QueryValueType(L *lua.LState) int {
  root := L.CheckString(1)  
  path := L.CheckString(2)
  key  := L.CheckString(3)  

  value := regedit.QueryValueType(root, path, key)          
  L.Push(lua.LString(value))
  return 1
}

func QueryStringValue(L *lua.LState) int {
  root := L.CheckString(1)  
  path := L.CheckString(2)
  key  := L.CheckString(3)  

  value := regedit.QueryStringValue(root, path, key)          
  L.Push(lua.LString(value))
  return 1
}

func QueryMultiStringValue(L *lua.LState) int {
  root := L.CheckString(1)  
  path := L.CheckString(2)
  key  := L.CheckString(3)  

  values := regedit.QueryMultiStringValue(root, path, key)   
  table := L.NewTable()
  for _, value := range values {
    table.Append(lua.LString(value))
  }
  
  L.Push(table)
  return 1
}

func QueryBinaryValue(L *lua.LState) int {
  root := L.CheckString(1)  
  path := L.CheckString(2)
  key  := L.CheckString(3)  

  value := regedit.QueryBinaryValue(root, path, key)          
  L.Push(lua.LString(hex.EncodeToString(value)))
  return 1
}

func QueryIntegerValue(L *lua.LState) int {
  root := L.CheckString(1)  
  path := L.CheckString(2)
  key  := L.CheckString(3)  

  value := regedit.QueryIntegerValue(root, path, key)
  L.Push(lua.LString(strconv.FormatUint(value, 10)))
  return 1
}

func Create(L *lua.LState) int {
  root  := L.CheckString(1)  
  path  := L.CheckString(2)

  regedit.Create(root, path)   
  return 0
}

func Delete(L *lua.LState) int {
  root  := L.CheckString(1)  
  path  := L.CheckString(2)

  regedit.Delete(root, path)   
  return 0
}

func WriteStringValue(L *lua.LState) int {
  root  := L.CheckString(1)  
  path  := L.CheckString(2)
  key   := L.CheckString(3)
  value := L.CheckString(4)

  regedit.WriteStringValue(root, path, key, expand.ExpandVariables(value))   
  return 0
}

func WriteExpandStringValue(L *lua.LState) int {
  root  := L.CheckString(1)  
  path  := L.CheckString(2)
  key   := L.CheckString(3)
  value := L.CheckString(4)

  regedit.WriteExpandStringValue(root, path, key, value)   
  return 0
}

func WriteMultiStringValue(L *lua.LState) int {
  root   := L.CheckString(1)  
  path   := L.CheckString(2)
  key    := L.CheckString(3)
  table  := L.ToTable(4)
  
  var values []string
  table.ForEach(func(_, value lua.LValue) {
    if str, ok := value.(lua.LString); ok {
      values = append(values, string(str))
    }
  })

  regedit.WriteMultiStringValue(root, path, key, values)   
  return 0
}

func WriteBinaryValue(L *lua.LState) int {
  root  := L.CheckString(1)  
  path  := L.CheckString(2)
  key   := L.CheckString(3)
  value := L.CheckString(4)

  x, _ := hex.DecodeString(value)
  regedit.WriteBinaryValue(root, path, key, x)   
  return 0
}

func WriteDwordValue(L *lua.LState) int {
  root  := L.CheckString(1)  
  path  := L.CheckString(2)
  key   := L.CheckString(3)
  value := L.CheckString(4)

  i, _ := strconv.ParseUint(value, 10, 32)
  regedit.WriteDwordValue(root, path, key, uint32(i))   
  return 0
}

func WriteQwordValue(L *lua.LState) int {
  root  := L.CheckString(1)  
  path  := L.CheckString(2)
  key   := L.CheckString(3)
  value := L.CheckString(4)

  i, _ := strconv.ParseUint(value, 10, 64)
  regedit.WriteQwordValue(root, path, key, i)   
  return 0
}

func DeleteValue(L *lua.LState) int {
  root  := L.CheckString(1)  
  path  := L.CheckString(2)
  key   := L.CheckString(3)

  regedit.DeleteValue(root, path, key)   
  return 0
}
```

`src/lua/module/shell/shell.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package shell

import (
  "os"
  "os/exec"
  "syscall"
  "bytes"
  "path/filepath"
  "github.com/yuin/gopher-lua"
  "launcher/lua/type/failure"
)

func Loader(L *lua.LState) int {
  mod := L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
    "Run": Run,
  })
  L.Push(mod)
  return 1
}

func Run(L *lua.LState) int {
  command := L.CheckString(1)
  
  shell := os.Getenv("COMSPEC")
  if len(shell) == 0 {
    shell = filepath.Join(os.Getenv("WINDIR") + "System32/cmd.exe")
  }
  cmd := exec.Command(shell, "/C", command)
  cmd.SysProcAttr = &syscall.SysProcAttr{ HideWindow: true }
  
  stdout := bytes.Buffer{}
  stderr := bytes.Buffer{}
  cmd.Stdout = &stdout
  cmd.Stderr = &stderr
  
  result := L.NewTable()
  if err := cmd.Start(); err != nil {
    L.Push(result)
    L.Push(failure.LValue(L, "ERR_SPAWN_PROCESS", err.Error()))
    return 2
  }
  
  wait := make(chan error)
  go func(){
    wait <- cmd.Wait()
  }()
  <- wait
  
  L.SetField(result, "stdout", lua.LString(stdout.String()))
  L.SetField(result, "stderr", lua.LString(stderr.String()))
  L.Push(result)
  return 1
}
```

`src/lua/module/steamid/steamid.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package steamid

import (
  "github.com/yuin/gopher-lua"
  "launcher/lua/type/steamid"
)

func Loader(L *lua.LState) int {
  steamid.RegisterType(L)
  L.Push(L.NewFunction(steamid.Constructor))
  return 1
}
```

`src/lua/module/time/time.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package time

import (
  "fmt"
  "time"
  "github.com/yuin/gopher-lua"
  "launcher/lua/type/failure"
)

func Loader(L *lua.LState) int {
  mod := L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
    "Current": Current,
    "HumanizeDuration": HumanizeDuration,
    "ToUnix": ToUnix,
    "ToIso8601": ToIso8601,
  })
  L.Push(mod)
  return 1
}

func Current(L *lua.LState) int {
  L.Push(lua.LNumber(time.Now().Unix()))
  return 1
}

func HumanizeDuration(L *lua.LState) int {
  seconds := L.CheckInt64(1)
  duration := time.Duration(seconds) * time.Second
  switch {
    case duration < time.Minute:
      L.Push(lua.LString(fmt.Sprintf("%d seconds", seconds)))
    case duration < time.Hour:
      L.Push(lua.LString(fmt.Sprintf("%d minutes", seconds/60)))
    case duration < time.Hour*24:
      L.Push(lua.LString(fmt.Sprintf("%d hours", seconds/3600)))
    case duration < time.Hour*24*30:
      L.Push(lua.LString(fmt.Sprintf("%d days", seconds/86400)))
    case duration < time.Hour*24*365:
      L.Push(lua.LString(fmt.Sprintf("%d months", seconds/(86400*30))))
    default:
      L.Push(lua.LString(fmt.Sprintf("%d years", seconds/(86400*365))))
  }
  return 1
}

func ToUnix(L *lua.LState) int {
  timestamp := L.CheckString(1)
  format := L.ToString(2)
  if len(format) == 0 {
    format = "ISO8601"
  }

  //cf: https://pkg.go.dev/time#pkg-constants
  var formats = map[string]string{
    "ISO8601":     time.RFC3339,
    "YYYY-MM-DD":  time.DateOnly,
    "YYYY/MM/DD":  "2006/01/02",
    "YYYY_MM_DD":  "2006_01_02",
    "DD-MM-YYYY":  "02-01-2006",
    "DD/MM/YYYY":  "02/01/2006",
    "MM-DD-YYYY":  "01-02-2006",
    "MM/DD/YYYY":  "01/02/2006",
    "YYYY-MM-DD HH:MM:SS": time.DateTime,
    "YYYY/MM/DD HH:MM:SS": "2006/01/02 15:04:05",
  }
  
  layout, supported := formats[format]
  if !supported {
    L.Push(lua.LNumber(0))
    L.Push(failure.LValue(L, "ERR_TIME_CONVERSION", "Unsupported format: "+ format))
    return 1
  }

  t, err := time.Parse(layout, timestamp)
  if err != nil {
    L.Push(lua.LNumber(0))
    L.Push(failure.LValue(L, "ERR_TIME_CONVERSION", err.Error()))
    return 1
  }

  L.Push(lua.LNumber(t.Unix()))
  return 1
}

func ToIso8601(L *lua.LState) int {
  unixTime := L.CheckInt64(1)

  t := time.Unix(unixTime, 0).UTC()
  iso8601 := t.Format(time.RFC3339)

  L.Push(lua.LString(iso8601))
  return 1
}
```

`src/lua/module/user/user.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package user

import (
  "os/user"
  "errors"
  "strings"
  "github.com/yuin/gopher-lua"
  "launcher/internal/locale"
  "launcher/internal/elevated"
)

func getUserName() (string, error) {
  user, err := user.Current()
  if err != nil {
    return "", err
  }
  parts := strings.Split(user.Username, "\\")
  last := len(parts)-1
  return parts[last], nil
}

func getUserLang() (string, string, string, error) {
  localeName, err := locale.GetUserLocale()
  if err != nil {
     return "", "", "", err
  }
  
  if !strings.Contains(localeName, "-") {
     return "", "", "", errors.New("Unexpected local ISO 639: \"" + localeName + "\"")
  }
  loc := strings.SplitN(localeName, "-", 2)
  if len(loc) != 2 { 
    return "", "", "", errors.New("Unexpected local ISO 639: \"" + localeName + "\"") 
  }
  
  code, region := loc[0], loc[1]
  lang, err := locale.GetLanguageFromLocale(localeName)
  if err != nil {
    return code, region, "", err
  }
  
  return code, region, lang, nil
}

func Loader(L *lua.LState) int {
  name, _ := getUserName()
  code, region, lang, _ := getUserLang()
  
  locale := L.NewTable()
  L.SetField(locale, "code", lua.LString(code))
  L.SetField(locale, "region", lua.LString(region))
  
  mod := L.NewTable()
  L.SetField(mod, "name", lua.LString(name))
  L.SetField(mod, "admin", lua.LBool(elevated.IsElevated()))
  L.SetField(mod, "language", lua.LString(lang))
  L.SetField(mod, "locale", locale)
  L.Push(mod)
  return 1
}
```

`src/lua/module/video/video.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package video

import (
  "launcher/internal/video"
  "github.com/yuin/gopher-lua"
  "launcher/lua/type/failure"
)

func Loader(L *lua.LState) int {
  var exports = map[string]lua.LGFunction{
    "Current": Current,
  }
    
  mod := L.SetFuncs(L.NewTable(), exports)
  L.Push(mod)
  return 1
}

func Current(L *lua.LState) int {
  
  displayMode := L.NewTable()
  display, err := video.GetCurrentDisplayMode()
  if err != nil {
    L.Push(displayMode)
    L.Push(failure.LValue(L, "ERR_WIN32_API", err.Error()))
    return 2
  }

  L.SetField(displayMode, "width", lua.LNumber(display.Width))
  L.SetField(displayMode, "height", lua.LNumber(display.Height))
  L.SetField(displayMode, "hz", lua.LNumber(display.Hz))
  L.SetField(displayMode, "scale", lua.LNumber(display.Scale))
  L.Push(displayMode)
  return 1
}
```

`src/lua/script/lua_modules/README.md`:

```md
Lua modules **written in Lua** located in the `lua_modules` folder are embedded into the Go executable using [Go's embed](https://pkg.go.dev/embed) feature.

- The filename _(without `.lua`)_ is used as the module name:

  ```lua
  foo.lua â†’ local foo = require("foo")
  ```
  
- Go modules are preloaded first, followed by embedded Lua modules. Any dependencies on Go-preloaded modules will work.

### Lua module example:

```lua
local foo = {}

function foo.bar()
  -- do something
end

return foo
```
```

`src/lua/script/lua_modules/steamclient.lua`:

```lua
-- Copyright (c) Anthony Beaumont
-- This source code is licensed under the MIT License
-- found in the LICENSE file in the root directory of this source tree.

local file = require("file")
local regedit = require("regedit")
local process = require("process")

local steamclient = {}

function steamclient.HasGenuineDLL(root)
  root = root or process.Cwd()
  assert(type(root) == "string" and root ~= "", "Expected a non-empty string!")
  
  local dlls = {"steam_api64.dll", "steam_api.dll"}
  for _, dll in ipairs(dlls) do
    local path = file.Glob(root, dll, { recursive = true })
    if path[1] and path[1] ~= "" then
      local info = file.Info(path[1])
      return info.signed
    end
  end
  return false
end

function steamclient.Backup()
  local backup = {}
  backup["ActiveUser"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser")
  backup["pid"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid")
  backup["SteamClientDll"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll")
  backup["SteamClientDll64"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64")
  backup["Universe"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe")
  backup["RunningAppID"] = regedit.QueryIntegerValue("HKCU", "Software/Valve/Steam", "RunningAppID")
  backup["SteamExe"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam", "SteamExe")
  backup["SteamPath"] = regedit.QueryStringValue("HKCU", "Software/Valve/Steam", "SteamPath")
  return backup
end

function steamclient.Restore(backup)
  assert(type(backup) == "table" and next(backup) ~= nil, "Expected non-empty table!")
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser", backup["ActiveUser"])
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid", backup["pid"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll", backup["SteamClientDll"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64", backup["SteamClientDll64"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe", backup["Universe"])
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam", "RunningAppID", backup["RunningAppID"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamExe", backup["SteamExe"])
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamPath", backup["SteamPath"])
end

function steamclient.Load(client)
  client = client or {}
  assert(type(client) == "table", "Expected table!")

  if not client.appid ~= "" then
    local paths = file.Glob(process.Cwd(), "steam_appid.txt", {
      recursive = true
    })
    for _, path in ipairs(paths) do
      client.appid = file.Read(path)
      if client.appid ~= "" then
        break
      end
    end  
  end

  if not client.dll ~= "" then
    local paths, err = file.Glob(process.Cwd(), "steamclient.dll", {
      recursive = true,
      absolute = true
    })
    for _, path in ipairs(paths) do
        local info = file.Info(path)
        if not info.signed then
          client.dll = path
          break
        end
      end
    end

  if not client.dll64 ~= "" then
    local paths = file.Glob(process.Cwd(), "steamclient64.dll", {
      recursive = true,
      absolute = true
    })
    for _, path in ipairs(paths) do
      local info = file.Info(path)
      if not info.signed then
        client.dll64 = path
        break
      end
    end
  end
  
  if type(client.user) ~= "number" or client.user % 1 ~= 0 or client.user == 0 then
    client.user = 1999874061
  end

  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "ActiveUser", tostring(client.user))
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam/ActiveProcess", "pid", tostring(process.pid))
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll", client.dll)
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "SteamClientDll64", client.dll64)
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam/ActiveProcess", "Universe", "Public")
  regedit.WriteDwordValue("HKCU", "Software/Valve/Steam", "RunningAppID", client.appid)
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamExe", process.ExecPath())
  regedit.WriteStringValue("HKCU", "Software/Valve/Steam", "SteamPath", process.Cwd())  
end

return steamclient
```

`src/lua/script/lua_modules/types.lua`:

```lua
-- Copyright (c) Anthony Beaumont
-- This source code is licensed under the MIT License
-- found in the LICENSE file in the root directory of this source tree.

local types = {}

local test = {}
test["string"]   = function(v) return type(v) == "string" end
test["str"]      = test["string"]
test["number"]   = function(v) return type(v) == "number" end
test["nbr"]      = test["number"]
test["int"]      = function(v) return type(v) == "number" and v % 1 == 0 end
test["integer"]  = test["int"] 
test["uint"]     = function(v) return test["int"](v) and v >= 0 end
test["boolean"]  = function(v) return type(v) == "boolean" end
test["bool"]     = test["boolean"]
test["table"]    = function(v) return type(v) == "table" end
test["array"]    = test["table"]
test["arr"]      = test["table"]
test["function"] = function(v) return type(v) == "function" end
test["func"]     = test["function"]
test["fn"]       = test["function"]
test["userdata"] = function(v) return type(v) == "userdata" end
test["thread"]   = function(v) return type(v) == "thread" end

local function isArrayOf(tbl, test, length)
  if type(tbl) ~= "table" then return false end
  if length and #tbl ~= length then return false end
  for _, v in ipairs(tbl) do
    if not test(v) then return false end
  end
  return true
end

local function parse(typeString)
  assert(type(typeString) == "string" and #typeString > 0,
         "typeString must be a non-empty string")

  local typeName, lenStr = typeString:match("^(%w+)%s*%[?(%d*)%]?$")
  if not typeName then
    error("Unable to parse type string: " .. typeString)
  end

  local array = typeString:find("%[") ~= nil
  local length = tonumber(lenStr)

  return typeName:lower(), array, length
end

local function translate(name)
  local fn = test[name]
  if not fn then
    error("Unknown type: " .. name)
  end
  return fn
end

function types.is(typeString, value)
  local name, array, length = parse(typeString)
  local test = translate(name)

  if array then
    return isArrayOf(value, test, length)
  else
    return test(value)
  end
end

function types.as(typeString, value)
  return types.is(typeString, value) and value or nil
end

function types.should(typeString, value)
  if not types.is(typeString, value) then
    error("Expected value of type: " .. typeString)
  end
  return value
end

return types
```

`src/lua/script/script.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package script

import (
  "embed"
  "path/filepath"
  "strings"
  "github.com/yuin/gopher-lua"
)

//go:embed lua_modules/*.lua
var luaFS embed.FS

func loader(src string) lua.LGFunction {
  return func(L *lua.LState) int {
    if err := L.DoString(src); err != nil {
      L.RaiseError(err.Error())
    }
    return 1
  }
}

func ImportEmbeddedLuaScript(L *lua.LState) error {
  entries, err := luaFS.ReadDir("lua_modules")
  if err != nil {
    return err
  }
  
  for _, entry := range entries {
    if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".lua") {
      continue
    }

    ext := filepath.Ext(entry.Name())
    name := strings.TrimSuffix(entry.Name(), ext)

    data, err := luaFS.ReadFile("lua_modules/" + entry.Name())
    if err != nil {
      return err
    }
    L.PreloadModule(name, loader(string(data)))
  }
  
  return nil
}
```

`src/lua/type/failure/failure.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package failure

import (
  "github.com/yuin/gopher-lua"
)

const Name = "Failure"

type Failure struct {
  Code    string
  Message string
}

func LValue(L *lua.LState, code string, message string) lua.LValue {
  ud := L.NewUserData()
  ud.Value = &Failure{Code: code, Message: message}
  L.SetMetatable(ud, L.GetTypeMetatable(Name))
  return ud
}

func LCheckFailure(L *lua.LState, n int) *Failure {
  ud := L.CheckUserData(n)
  if err, ok := ud.Value.(*Failure); ok {
    return err
  }
  L.ArgError(n, "UserData<Failure> type expected!")
  return nil
}

func constructor(L *lua.LState) int {
  code := L.ToString(1)
  if len(code) == 0 { code = "ERR_UNKNOWN" }
  
  message := L.ToString(2)
  if len(message) == 0 { message = "An unknown error occurred" }

  L.Push(LValue(L, code, message))
  return 1
}

func index(L *lua.LState) int {
  err := LCheckFailure(L, 1)
  key := L.ToString(2)
  switch key {
    case "code":
      L.Push(lua.LString(err.Code))
    case "message":
      L.Push(lua.LString(err.Message))
    default:
      L.Push(lua.LNil)
  }
  return 1
}

func tostring(L *lua.LState) int {
  err := LCheckFailure(L, 1)
  L.Push(lua.LString("[" + err.Code + "]: " + err.Message))
  return 1
}

func RegisterType(L *lua.LState) {
  mt := L.NewTypeMetatable(Name)
  L.SetField(mt, "__call", L.NewFunction(constructor))
  L.SetField(mt, "__index", L.NewFunction(index))
  L.SetField(mt, "__tostring", L.NewFunction(tostring))
  L.SetField(mt, "__metatable", lua.LString("Protected metatable!"))
  L.SetGlobal(Name, mt)
  L.SetMetatable(mt, mt) //https://github.com/yuin/gopher-lua/issues/36#issuecomment-113885402
}
```

`src/lua/type/steamid/steamid.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package steamid

import (
  "launcher/internal/steam"
  "github.com/yuin/gopher-lua"
)

const Name = "SteamID"

func LValue(L *lua.LState, sid *steam.SteamID) lua.LValue {
  ud := L.NewUserData()
  ud.Value = sid
  L.SetMetatable(ud, L.GetTypeMetatable(Name))
  return ud
}

func LCheckSteamID(L *lua.LState, n int) *steam.SteamID {
  ud := L.CheckUserData(n)
  if v, ok := ud.Value.(*steam.SteamID); ok {
    return v
  }
  L.ArgError(n, "UserData<SteamID> type expected!")
  return nil
}

func Constructor(L *lua.LState) int {
  val := L.Get(1)
  id, ok := val.(lua.LString)
  if !ok {
    L.RaiseError("A SteamID requires an explicit String type to avoid 64bits precision loss")
  }
  sid, err := steam.ParseSteamID(string(id))
  if err != nil {
    L.RaiseError(err.Error())
    return 0
  }
  L.Push(LValue(L, sid))
  return 1
}

func index(L *lua.LState) int {
  sid := LCheckSteamID(L, 1)
  key := L.ToString(2)
  switch key {
    case "universe":
      L.Push(lua.LNumber(uint32(sid.Universe)))
    case "type":
      L.Push(lua.LNumber(uint32(sid.Type)))
    case "instance":
      L.Push(lua.LNumber(uint32(sid.Instance)))
    case "accountid":
      L.Push(lua.LNumber(uint32(sid.AccountID)))
    case "asSteam2":
      L.Push(L.NewFunction(func(L *lua.LState) int {
        sid := LCheckSteamID(L, 1)
        L.Push(lua.LString(sid.AsSteam2()))
        return 1
      }))
    case "asSteam3":
      L.Push(L.NewFunction(func(L *lua.LState) int {
        sid := LCheckSteamID(L, 1)
        L.Push(lua.LString(sid.AsSteam3()))
        return 1
      }))
    case "asSteam64":
      L.Push(L.NewFunction(func(L *lua.LState) int {
        sid := LCheckSteamID(L, 1)
        L.Push(lua.LString(sid.AsSteam64()))
        return 1
      }))
    default:
      L.Push(lua.LNil)
  }
  return 1
}

func tostring(L *lua.LState) int {
  sid := LCheckSteamID(L, 1)
  L.Push(lua.LString(sid.AsSteam2()))
  return 1
}

func RegisterType(L *lua.LState) {
  mt := L.NewTypeMetatable(Name)
  L.SetField(mt, "__index", L.NewFunction(index))
  L.SetField(mt, "__tostring", L.NewFunction(tostring))
  L.SetField(mt, "__metatable", lua.LString("Protected metatable!"))
  L.SetMetatable(mt, mt)
}
```

`src/menu.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "sort"
  "launcher/internal/ui"
)
  
func displayMenuOverride(menu map[string]string, defaultPath string) string {
  if len(menu) > 0 {
    labels := []string{}
    for label, _ := range menu {
      if len(label) > 0 {
        labels = append(labels, label)
      }
    }
    if len(labels) > 0 {
      sort.Strings(labels)
      button := ui.Menu(labels)
      index := <- button
      if index >= 0 && index <= len(labels) {
        name := labels[index]
        path := menu[name]
        if len(path) == 0 { path = defaultPath }
        return path
      }
    }
  }
  return ""
}
```

`src/patches.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "path/filepath"
  "launcher/internal/pe"
)

func applyPatches(binary string, patches Patch) {
  if patches.LAA != nil {
    if err := pe.PatchLargeAddress(binary, *patches.LAA); err != nil {
      panic("Patch (Large Address Aware)", "\"" + filepath.Base(binary) + "\": " + err.Error())
    }
  }
}
```

`src/shortcut.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "os"
  "path/filepath"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/internal/shortcut"
)

func makeShortcut(binary string, s Shortcut) {
  if len(s.Name) > 0 {
    
    self, err := os.Executable()
    if err != nil { 
      panic("Creating Shortcut", err.Error()) 
    }
    
    if s.StartMenu != nil && *s.StartMenu {
      path := fs.Resolve(expand.ExpandVariables("%APPDATA%/Microsoft/Windows/Start Menu/Programs/" + s.Name + ".lnk"))
      if ok, err := fs.FileExist(path); !ok {
        if err != nil { 
          panic("Creating Shortcut ()", "Start Menu: " + err.Error())
        }

        mslink := shortcut.Shortcut{
          Path: path,
          TargetPath: self,
          WorkingDirectory: filepath.Dir(self),
          IconLocation: binary + ",0",
        }

        if err := shortcut.CreateShortcut(mslink); err != nil {
          panic("Creating Shortcut ()", "Start Menu: " + err.Error()) 
        }
      }
    }

    if s.Desktop != nil && *s.Desktop {
      path := fs.Resolve(expand.ExpandVariables("%DESKTOP%/" + s.Name + ".lnk"))
      if ok, err := fs.FileExist(path); !ok {
        if err != nil { 
          panic("Creating Shortcut ()", "Desktop: " + err.Error())
        }

        mslink := shortcut.Shortcut{
          Path: path,
          TargetPath: self,
          WorkingDirectory: filepath.Dir(self),
          IconLocation: binary + ",0",
        }

        if err := shortcut.CreateShortcut(mslink); err != nil {
          panic("Creating Shortcut ()", "Desktop: " + err.Error()) 
        }
      }
    }
    
  }
}
```

`src/splash.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "time"
  "slices"
  "strings"
  "math/rand"
  "path/filepath"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/internal/ui"
)

func displaySplash(pid int, screen Splash) {
  if screen.Show != nil && *screen.Show && screen.Images != nil && len(screen.Images) > 0 {
    image := screen.Images[rand.Intn(len(screen.Images))]
    if len(image) > 0 {
      image = fs.Resolve(expand.ExpandVariables(image))
      if strings.ToLower(filepath.Ext(image)) == ".bmp" {
        if ok, _ := fs.FileExist(image); ok {
        
          var timeout uint = 10
          if screen.Timeout > 0 {
            timeout = screen.Timeout
          }

          events := []string{"FOREGROUND", "WINDOW", "CURSOR"}
          var wait string = events[0]
          if slices.Contains(events, strings.ToUpper(screen.Wait)) {
            wait = strings.ToUpper(screen.Wait)
          }

          splashScreen := ui.Splash(image, wait, pid)
          select {
            case <-splashScreen:
              return
            case <-time.After(time.Second * time.Duration(timeout)):
              return
          }
        }
      }
    }
  }
}
```

`src/symlink.go`:

```go
/*
Copyright (c) Anthony Beaumont
This source code is licensed under the MIT License
found in the LICENSE file in the root directory of this source tree.
*/

package main

import(
  "os"
  "errors"
  "golang.org/x/sys/windows"
  "launcher/internal/fs"
  "launcher/internal/expand"
  "launcher/internal/wine"
  "launcher/internal/elevated"
)

func makeLink(links []Link) {
  if links != nil && len(links) > 0 {
    for _, link := range links {
      if len(link.Origin) > 0 && len(link.Destination) > 0 {
        err := fs.CreateFolderSymlink(
          fs.Resolve(expand.ExpandVariables(link.Origin)),
          fs.Resolve(expand.ExpandVariables(link.Destination)),
        )
        if err != nil {
          if linkErr, ok := err.(*os.LinkError); ok {
            if linkErr.Op == "symlink" {
              if !wine.IsWineOrProton() { //We don't do that here
                if errors.Is(linkErr.Err, windows.Errno(windows.ERROR_ACCESS_DENIED)) || 
                  errors.Is(linkErr.Err, windows.Errno(windows.ERROR_PRIVILEGE_NOT_HELD)) { 
                  if !elevated.IsElevated(){
                      elevated.RestartElevated()
                  }
                }
              }
            }
          }
          panic("Symlink", err.Error())
        } 
      }
    }
  } 
}
```

`update.cmd`:

```cmd
@echo off
cd %~dp0src
go get -u
go mod edit -go 1.26.0
go mod tidy
```

`update.sh`:

```sh
#!/bin/sh
cd "$(dirname "$0")/src"
go get -u
go mod edit -go 1.26.0
go mod tidy
```

`winres/winres.json`:

```json
{
  "RT_GROUP_ICON": {
    "#42": {
      "0409": "icon.ico"
    }
  },
  "RT_MANIFEST": {
    "#1": {
      "0409": {
        "identity": {
          "name": "",
          "version": ""
        },
        "description": "Mini-Launcher",
        "minimum-os": "win10",
        "execution-level": "as invoker",
        "ui-access": false,
        "auto-elevate": false,
        "dpi-awareness": "per monitor v2",
        "disable-theming": false,
        "disable-window-filtering": false,
        "high-resolution-scrolling-aware": false,
        "ultra-high-resolution-scrolling-aware": false,
        "long-path-aware": false,
        "printer-driver-isolation": false,
        "gdi-scaling": false,
        "segment-heap": false,
        "use-common-controls-v6": false
      }
    }
  },
  "RT_VERSION": {
    "#1": {
      "0000": {
        "fixed": {
          "file_version": "1.7.1.0",
          "product_version": "1.7.1.0"
        },
        "info": {
          "0409": {
            "Comments": "https://github.com/xan105/Mini-Launcher",
            "CompanyName": "Xan (Anthony Beaumont)",
            "FileDescription": "Mini-Launcher",
            "FileVersion": "1.7.1.0",
            "ProductVersion": "1.7.1.0",
            "InternalName": "Launcher.exe",
            "LegalCopyright": "Copyright (C) Anthony Beaumont",
            "LegalTrademarks": "",
            "OriginalFilename": "Launcher.exe",
            "PrivateBuild": "",
            "ProductName": "Mini-Launcher",
            "SpecialBuild": ""
          }
        }
      }
    }
  }
}
```