Project Path: arc_illegal-instruction-co_processhacker-mcp_dtal6pl5

Source Tree:

```txt
arc_illegal-instruction-co_processhacker-mcp_dtal6pl5
├── CMakeLists.txt
├── LICENSE
├── README.md
├── build-native.bat
├── extensions
│   ├── auto_compiler_ext
│   │   └── AutoCompilerExt.cpp
│   ├── builtin_ext
│   │   ├── BuiltinExt.cpp
│   │   └── BuiltinExt.h
│   ├── freezer_ext
│   │   └── FreezerExt.cpp
│   ├── memory_patcher_ext
│   │   └── MemoryPatcherExt.cpp
│   ├── pattern_scanner_ext
│   │   └── PatternScannerExt.cpp
│   ├── rtti_dumper_ext
│   │   └── RttiDumperExt.cpp
│   ├── sample_ext
│   │   └── SampleExt.cpp
│   └── vehbutnot_ext
│       ├── Types.h
│       ├── VehButNot.cpp
│       ├── VehButNot.h
│       └── VehButNotExt.cpp
├── include
│   ├── McpExtensionApi.h
│   └── McpServer.h
├── src
│   ├── Main.cpp
│   └── McpServer.cpp
├── third_party
│   └── tinycc
└── wrapper.bat

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(ProcessHackerMCP VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_EXE_LINKER_FLAGS "-static-libgcc -static-libstdc++ -static -Wl,-Bstatic -lstdc++ -lpthread")
set(CMAKE_SHARED_LINKER_FLAGS "-static-libgcc -static-libstdc++ -static")

# nlohmann/json for JSON-RPC
include(FetchContent)
FetchContent_Declare(
    json
    URL https://github.com/nlohmann/json/releases/download/v3.11.3/json.tar.xz
)
FetchContent_MakeAvailable(json)

include_directories(include)

# Add the main MCP Router Executable
add_executable(ProcessHackerMCP
    src/Main.cpp
    src/McpServer.cpp
)

target_include_directories(ProcessHackerMCP PRIVATE include)
target_link_libraries(ProcessHackerMCP PRIVATE nlohmann_json::nlohmann_json)

# Tiny C Compiler (TCC) Local Source Build
set(TCC_SRC_DIR "${CMAKE_SOURCE_DIR}/third_party/tinycc/win32")
set(TCC_BUILD_OUTPUT "${TCC_SRC_DIR}/tcc.exe")
set(TCC_TARGET_DIR "${CMAKE_BINARY_DIR}/tcc")

add_custom_command(
    OUTPUT "${TCC_BUILD_OUTPUT}"
    COMMAND cmd.exe /c "build-tcc.bat -c cl"
    WORKING_DIRECTORY "${TCC_SRC_DIR}"
    COMMENT "Compiling Tiny C Compiler (TCC) from source using MSVC..."
)

add_custom_target(tcc_build ALL
    DEPENDS "${TCC_BUILD_OUTPUT}"
)

# Copy TCC artifacts (executable, libs, includes) to build dir so the router can use it dynamically
add_custom_command(
    TARGET tcc_build POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E make_directory "${TCC_TARGET_DIR}"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different "${TCC_SRC_DIR}/tcc.exe" "${TCC_TARGET_DIR}/tcc.exe"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different "${TCC_SRC_DIR}/libtcc.dll" "${TCC_TARGET_DIR}/libtcc.dll"
    COMMAND ${CMAKE_COMMAND} -E copy_directory "${TCC_SRC_DIR}/include" "${TCC_TARGET_DIR}/include"
    COMMAND ${CMAKE_COMMAND} -E copy_directory "${TCC_SRC_DIR}/lib" "${TCC_TARGET_DIR}/lib"
    COMMENT "Deploying TCC to ${TCC_TARGET_DIR}..."
)

# Build the Built-in Extension DLL
add_library(builtin_ext SHARED 
    extensions/builtin_ext/BuiltinExt.cpp
)
target_include_directories(builtin_ext PRIVATE include)
target_link_libraries(builtin_ext PRIVATE nlohmann_json::nlohmann_json)
set_target_properties(builtin_ext PROPERTIES
    PREFIX ""
    SUFFIX ".dll"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
)

# Build the Sample Extension DLL
add_library(sample_ext SHARED 
    extensions/sample_ext/SampleExt.cpp
)
target_include_directories(sample_ext PRIVATE include)
set_target_properties(sample_ext PROPERTIES
    PREFIX ""
    SUFFIX ".dll"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
)

# Build the VehButNot Stealth Extension DLL
add_library(vehbutnot_ext SHARED 
    extensions/vehbutnot_ext/VehButNotExt.cpp
    extensions/vehbutnot_ext/VehButNot.cpp
)
target_include_directories(vehbutnot_ext PRIVATE include extensions/vehbutnot_ext)
target_link_libraries(vehbutnot_ext PRIVATE nlohmann_json::nlohmann_json ntdll)
set_target_properties(vehbutnot_ext PROPERTIES
    PREFIX ""
    SUFFIX ".dll"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
)

# Build the Pattern Scanner Extension DLL
add_library(pattern_scanner_ext SHARED 
    extensions/pattern_scanner_ext/PatternScannerExt.cpp
)
target_include_directories(pattern_scanner_ext PRIVATE include)
target_link_libraries(pattern_scanner_ext PRIVATE nlohmann_json::nlohmann_json psapi)
set_target_properties(pattern_scanner_ext PROPERTIES
    PREFIX ""
    SUFFIX ".dll"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
)

# Build the Freezer Extension DLL
add_library(freezer_ext SHARED 
    extensions/freezer_ext/FreezerExt.cpp
)
target_include_directories(freezer_ext PRIVATE include)
target_link_libraries(freezer_ext PRIVATE nlohmann_json::nlohmann_json)
set_target_properties(freezer_ext PROPERTIES
    PREFIX ""
    SUFFIX ".dll"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
)

# Build the RTTI Dumper Extension DLL
add_library(rtti_dumper_ext SHARED 
    extensions/rtti_dumper_ext/RttiDumperExt.cpp
)
target_include_directories(rtti_dumper_ext PRIVATE include)
target_link_libraries(rtti_dumper_ext PRIVATE nlohmann_json::nlohmann_json psapi)
set_target_properties(rtti_dumper_ext PROPERTIES
    PREFIX ""
    SUFFIX ".dll"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
)

# Build the Memory Patcher Extension DLL
add_library(memory_patcher_ext SHARED 
    extensions/memory_patcher_ext/MemoryPatcherExt.cpp
)
target_include_directories(memory_patcher_ext PRIVATE include)
target_link_libraries(memory_patcher_ext PRIVATE nlohmann_json::nlohmann_json psapi)
set_target_properties(memory_patcher_ext PROPERTIES
    PREFIX ""
    SUFFIX ".dll"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
)

# Build the Auto Compiler Extension DLL
add_library(auto_compiler_ext SHARED 
    extensions/auto_compiler_ext/AutoCompilerExt.cpp
)
target_include_directories(auto_compiler_ext PRIVATE include)
target_link_libraries(auto_compiler_ext PRIVATE nlohmann_json::nlohmann_json psapi)
set_target_properties(auto_compiler_ext PROPERTIES
    PREFIX ""
    SUFFIX ".dll"
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/extensions"
)

```

`LICENSE`:

```
MIT License

Copyright (c) 2026 machinetherapist

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# processhacker mcp

<img width="1024" height="559" alt="image" src="https://github.com/user-attachments/assets/018bd9d5-ed66-43e7-b19d-f5331fb1481a" />

this is dynamic mcp server for runtime analysis and process hacking. it is like processhacker but for ai agents.

## setup
1. open folder in visual studio (it has cmakelists)
2. build all (ctrl+shift+b)
3. it makes `ProcessHackerMCP.exe` and `extensions/` folder.
4. run exe. it communicates via stdin/stdout.

## editor integration
you can configure your ai agent/editor to use this server. below are the `mcp_config.json` (or equivalent) settings. **make sure to put the absolute path to the `.exe`.**

### cursor / gemini (antigravity) / claude desktop
add this to your mcp configuration file:
```json
{
  "mcpServers": {
    "processhacker": {
      "command": "C:\\absolute\\path\\to\\ProcessHackerMCP.exe",
      "args": []
    }
  }
}
```

### vscode (cline)
go to cline settings -> mcp servers and add:
```json
{
  "mcpServers": {
    "processhacker": {
      "command": "C:\\absolute\\path\\to\\ProcessHackerMCP.exe",
      "args": []
    }
  }
}
```

> **note:** some editors might freeze if the mcp server sends a huge payload (e.g. reading 1GB of memory). the core now has a 2MB payload protection limit, but try to use `limit` and `offset` arguments when querying big processes.

## agent guardrails & telemetry (new in v1.1.0)
we added some enterprise-grade agent logic to stop rogue bots from nuking your host machine.

- **Read-Only Mode:** change `"args": []` to `"args": ["--read-only"]` in your mcp config. if the ai tries to write memory or suspend threads (destructive actions), the core blocks it.
- **Audit Log:** all tool calls (and their args) are saved to `processhacker_audit.log`. destructive actions are tagged with `[WARNING: DESTRUCTIVE]`.
- **Loop Breaker (Rate Limit):** if an ai agent panics and calls 50 tools in 1 minute (brute-forcing memory), the core locks it out for 30 seconds. write a c++ extension for heavy scanning, don't spam rpc.
- **Loud Failures:** if reading unmapped memory fails, the ai gets a clear hint to use `ph_query_memory_regions` instead of just a generic error.

## how to make extension (for bypass etc)
core is just router. all tools are in dll plugins.

if u want make stealth bypass (like vehbutnot or direct syscall):
1. copy `extensions/sample_ext` folder.
2. write your code in c or c++.
3. setup `McpToolRegistration` and set `isDestructive = true` if your tool mutates state (writes memory, sets hooks).
4. u must export `InitMcpExtension`.
5. put your compiled `.dll` inside `extensions/` folder.
6. exe will auto load your dll on start and ai agent will see your new tool.

> **new in v1.6.0:** the ai agent can now write its own extensions dynamically! by using the `ext_auto_compiler` tool, the agent can send raw C code which the router compiles using a bundled TCC (Tiny C Compiler) and hot-loads directly into active memory. you can literally ask the ai to write its own custom bypass and it will compile itself on the fly!

## contribute
if u write good stealth extension and think it can bypass anything or help others, please send pull request (pr). we need more plugins for stealth. 

## just wondering... (faq)
i was thinking about this architecture and had a weird thought:

**could someone actually use this to create autonomous malware or game cheats just by writing prompts?**
like asking the ai: "inject here, find the decryption routine, and dump the keys as json". since the actual "malware behavior" isn't in the compiled c++ code but in the prompt text, no classic anti-virus could catch the payload statically. 

and if an anti-cheat updates, the ai could just read the new memory layout and adapt its logic instantly without needing a recompile.

is this genuinely possible now or just a weird architectural nightmare? lol 
if u have thoughts on this, hit me up or open an issue.

## disclaimer

**educational and research purposes only.** published to document the technique, not to hand it out as a toolkit.

what you do with this is your problem. no warranty, no support, no liability.

## license

MIT. do whatever. don't blame us.

```

`build-native.bat`:

```bat
@echo off
echo [*] Initializing MSVC x64 Environment...
call "C:\Program Files\Microsoft Visual Studio\18\Community\VC\Auxiliary\Build\vcvars64.bat"
echo [*] Executing CMake Build...
"C:\Program Files\Microsoft Visual Studio\18\Community\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe" --build build --config Release
exit /b %ERRORLEVEL%

```

`extensions/auto_compiler_ext/AutoCompilerExt.cpp`:

```cpp
#include "../../include/McpExtensionApi.h"

#include <nlohmann/json.hpp>
#include <windows.h>

#include <string>
#include <fstream>
#include <sstream>
#include <vector>
#include <iostream>

using nlohmann::json;
using namespace std;

const char* AutoCompilerHandler(const char* jsonArgs)
{
    auto createResponse = [](const string& msg, bool isError = false, const json& contentData = json::object()) {
        json resp;
        if (contentData.empty()) {
            resp["content"] = json::array({json{{"type", "text"}, {"text", msg}}});
        } else {
            resp["content"] = json::array({json{{"type", "text"}, {"text", contentData.dump(4)}}});
        }
        if (isError) resp["isError"] = true;
        string resStr = resp.dump();
#pragma warning(suppress : 28183)
        char* result = new char[resStr.size() + 1];
        strcpy_s(result, resStr.size() + 1, resStr.c_str());
        return result;
    };

    try {
        json payload = json::parse(jsonArgs);
        string extName = payload.at("extension_name").get<string>();
        string cCode = payload.at("c_code").get<string>();

        string workspaceDir = "extensions/dynamic_exts";
        CreateDirectoryA("extensions", NULL);
        CreateDirectoryA(workspaceDir.c_str(), NULL);
        
        string cPath = workspaceDir + "/" + extName + ".c";
        string dllPath = workspaceDir + "/" + extName + ".dll";

        ofstream outFile(cPath);
        if (!outFile) return createResponse("Error: Could not write C file to disk.", true);
        outFile << cCode;
        outFile.close();

        char exePath[MAX_PATH];
        GetModuleFileNameA(NULL, exePath, MAX_PATH);
        string exeDir = exePath;
        exeDir = exeDir.substr(0, exeDir.find_last_of("\\/"));
        string tccPath = exeDir + "\\tcc\\tcc.exe";

        ostringstream cmd;
        cmd << "\"" << tccPath << "\" -shared -o " << extName << ".dll " << extName << ".c";

        SECURITY_ATTRIBUTES saAttr; 
        saAttr.nLength = sizeof(SECURITY_ATTRIBUTES); 
        saAttr.bInheritHandle = TRUE; 
        saAttr.lpSecurityDescriptor = NULL; 

        HANDLE hChildStd_OUT_Rd = NULL;
        HANDLE hChildStd_OUT_Wr = NULL;

        if (!CreatePipe(&hChildStd_OUT_Rd, &hChildStd_OUT_Wr, &saAttr, 0)) {
            return createResponse("Error: CreatePipe failed.", true);
        }
        if (!SetHandleInformation(hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0)) {
            return createResponse("Error: Stdout SetHandleInformation failed.", true);
        }

        STARTUPINFOA si;
        PROCESS_INFORMATION pi;
        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        si.hStdError = hChildStd_OUT_Wr;
        si.hStdOutput = hChildStd_OUT_Wr;
        si.dwFlags |= STARTF_USESTDHANDLES;
        ZeroMemory(&pi, sizeof(pi));

        string cmdStr = cmd.str();
        vector<char> cmdBuffer(cmdStr.begin(), cmdStr.end());
        cmdBuffer.push_back('\0');

        if (!CreateProcessA(NULL, cmdBuffer.data(), NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, workspaceDir.c_str(), &si, &pi)) {
            CloseHandle(hChildStd_OUT_Wr);
            CloseHandle(hChildStd_OUT_Rd);
            return createResponse("Error: Failed to launch TCC Compiler.", true);
        }

        CloseHandle(hChildStd_OUT_Wr);

        string compilerOutput = "";
        DWORD dwRead; 
        CHAR chBuf[4096]; 
        BOOL bSuccess = FALSE;
        for (;;) { 
            bSuccess = ReadFile(hChildStd_OUT_Rd, chBuf, 4096 - 1, &dwRead, NULL);
            if (!bSuccess || dwRead == 0) break; 
            chBuf[dwRead] = '\0';
            compilerOutput += chBuf;
        } 
        CloseHandle(hChildStd_OUT_Rd);

        WaitForSingleObject(pi.hProcess, 15000);

        DWORD exitCode;
        GetExitCodeProcess(pi.hProcess, &exitCode);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);

        if (exitCode != 0) {
            string errMessage = "Error: Compilation failed. TCC Output:\n" + compilerOutput;
            return createResponse(errMessage, true);
        }

        HMODULE hModule = LoadLibraryA(dllPath.c_str());
        if (!hModule) {
            return createResponse("Error: Compiled dynamically but LoadLibraryA failed. Code: " + to_string(GetLastError()), true);
        }

        using InitMcpExtFn = bool(*)(const McpServerApi*);
        auto initFn = reinterpret_cast<InitMcpExtFn>(GetProcAddress(hModule, "InitMcpExtension"));
        
        if (!initFn) {
            return createResponse("Error: Library loaded but missing InitMcpExtension export.", true);
        }

        return createResponse("", false, json::object({
            {"status", "success"},
            {"message", "Extension compiled with TCC and hot-loaded into active memory!"},
            {"dll_path", dllPath}
        }));

    } catch (const exception& e) {
        return createResponse(string("Error: ") + e.what(), true);
    }
}

void AutoCompilerFreeResult(const char* resultStr)
{
    delete[] resultStr;
}

extern "C" __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api)
{
    if (!api || !api->registerTool) {
        return false;
    }

    McpToolRegistration tReg{};
    tReg.name = "ext_auto_compiler";
    tReg.description = "DANGEROUS: Core capability to allow the AI to compile raw C code into a self-loading Extension DLL dynamically. DO NOT RUN WITHOUT EXPLICIT USER CONSENT.";
    tReg.version = "1.0.0";
    tReg.inputSchemaJson = "{\"type\":\"object\",\"properties\":{\"extension_name\":{\"type\":\"string\",\"description\":\"Unique short name without .dll\"},\"c_code\":{\"type\":\"string\",\"description\":\"Full C source code adhering to McpExtensionApi.h template\"}},\"required\":[\"extension_name\",\"c_code\"]}";
    tReg.handler = AutoCompilerHandler;
    tReg.freeResult = AutoCompilerFreeResult;

    api->registerTool(api->serverContext, &tReg);
    return true;
}

BOOL APIENTRY DllMain(HMODULE, DWORD, LPVOID)
{
    return TRUE;
}

```

`extensions/builtin_ext/BuiltinExt.cpp`:

```cpp
#include "BuiltinExt.h"

#include "../../include/McpExtensionApi.h"

#include <format>
#include <iomanip>
#include <sstream>
#include <string>
#include <vector>

#include <windows.h>
#include <tlhelp32.h>

using namespace std;

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define SystemExtendedHandleInformation 64

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
	PVOID Object;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
	ULONG_PTR NumberOfHandles;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef NTSTATUS(NTAPI* NtQuerySystemInformationFn)(ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength,
													PULONG ReturnLength);

namespace machinetherapist {

	// Helper to convert C++ std::string responses to C-string allocated for MCP Server
	static const char* AllocateResult(const json& result)
	{
		string response = result.dump();
		char* buf = new char[response.size() + 1];
		strcpy_s(buf, response.size() + 1, response.c_str());
		return buf;
	}

	static void BuiltinFreeResult(const char* resultStr)
	{
		delete[] resultStr;
	}

	// C-API Wrappers
	static const char* WrapListProcesses(const char* args)
	{
		return AllocateResult(BuiltinExt::ListProcesses(json::parse(args)));
	}
	static const char* WrapListModules(const char* args)
	{
		return AllocateResult(BuiltinExt::ListModules(json::parse(args)));
	}
	static const char* WrapReadMemory(const char* args)
	{
		return AllocateResult(BuiltinExt::ReadMemory(json::parse(args)));
	}
	static const char* WrapListThreads(const char* args)
	{
		return AllocateResult(BuiltinExt::ListThreads(json::parse(args)));
	}
	static const char* WrapSuspendResumeThread(const char* args)
	{
		return AllocateResult(BuiltinExt::SuspendResumeThread(json::parse(args)));
	}
	static const char* WrapQueryMemoryRegions(const char* args)
	{
		return AllocateResult(BuiltinExt::QueryMemoryRegions(json::parse(args)));
	}
	static const char* WrapListHandles(const char* args)
	{
		return AllocateResult(BuiltinExt::ListHandles(json::parse(args)));
	}

	extern "C" __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api)
	{
		if (!api || !api->registerTool)
			return false;

		McpToolRegistration t_proc = {
			"ph_list_processes", "Lists all running processes on the system.", "1.0.0",
			R"({"type": "object", "properties": {"offset": {"type": "integer"}, "limit": {"type": "integer"}}})",
			WrapListProcesses,
			BuiltinFreeResult, false};
		api->registerTool(api->serverContext, &t_proc);

		McpToolRegistration t_mod = {
			"ph_list_modules",
			"Lists all loaded modules (DLLs) for a specific process ID.",
			"1.0.0",
			R"({"type": "object", "properties": {"pid": {"type": "integer", "description": "The Process ID to inspect"}, "offset": {"type": "integer"}, "limit": {"type": "integer"}}, "required": ["pid"]})",
			WrapListModules,
			BuiltinFreeResult, false};
		api->registerTool(api->serverContext, &t_mod);

		McpToolRegistration t_mem = {
			"ph_read_memory",
			"Reads memory from a specific process given an address and size, returning a hex string.",
			"1.0.0",
			R"({"type": "object", "properties": {"pid": {"type": "integer"}, "address": {"type": "string"}, "size": {"type": "integer"}}, "required": ["pid", "address", "size"]})",
			WrapReadMemory,
			BuiltinFreeResult, false};
		api->registerTool(api->serverContext, &t_mem);

		McpToolRegistration t_threads = {"ph_list_threads", "Lists all threads for a specific process ID.",
										 "1.0.0",			R"({"type": "object", "properties": {"pid": {"type": "integer"}}, "required": ["pid"]})",
										 WrapListThreads,	BuiltinFreeResult, false};
		api->registerTool(api->serverContext, &t_threads);

		McpToolRegistration t_suspend = {
			"ph_suspend_resume_thread",
			"Suspends or resumes a specific thread ID.",
			"1.0.0",
			R"({"type": "object", "properties": {"tid": {"type": "integer"}, "action": {"type": "string"}}, "required": ["tid", "action"]})",
			WrapSuspendResumeThread,
			BuiltinFreeResult, true}; // Mutes state, mark as destructive
		api->registerTool(api->serverContext, &t_suspend);

		McpToolRegistration t_regions = {"ph_query_memory_regions",
										 "Lists memory regions (VirtualQueryEx) for a specific process ID.",
										 "1.0.0",
										 R"({"type": "object", "properties": {"pid": {"type": "integer"}, "offset": {"type": "integer"}, "limit": {"type": "integer"}}, "required": ["pid"]})",
										 WrapQueryMemoryRegions,
										 BuiltinFreeResult, false};
		api->registerTool(api->serverContext, &t_regions);

		McpToolRegistration t_handles = {"ph_list_handles", "Lists all handles opened by a specific process ID.",
										 "1.0.0",			R"({"type": "object", "properties": {"pid": {"type": "integer"}, "offset": {"type": "integer"}, "limit": {"type": "integer"}}, "required": ["pid"]})",
										 WrapListHandles,	BuiltinFreeResult, false};
		api->registerTool(api->serverContext, &t_handles);

		return true;
	}

	BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
	{
		return TRUE;
	}

	static json FormatToolResult(const string& text)
	{
		return {{"content", json::array({{{"type", "text"}, {"text", text}}})}};
	}

	json BuiltinExt::ListProcesses(const json& args)
	{
		size_t offset = args.value("offset", 0);
		size_t limit = args.value("limit", 1000);

		HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (snap == INVALID_HANDLE_VALUE) {
			return FormatToolResult("Failed to create snapshot");
		}

		PROCESSENTRY32 pe32{};
		pe32.dwSize = sizeof(pe32);

		json procs = json::array();
		size_t currentIndex = 0;

		if (Process32First(snap, &pe32)) {
			do {
				if (currentIndex >= offset && procs.size() < limit) {
					procs.push_back({{"pid", pe32.th32ProcessID},
									 {"name", pe32.szExeFile},
									 {"threads", pe32.cntThreads},
									 {"parentPid", pe32.th32ParentProcessID}});
				}
				currentIndex++;
				if (procs.size() >= limit) {
					break;
				}
			} while (Process32Next(snap, &pe32));
		}

		CloseHandle(snap);
		return FormatToolResult(procs.dump(2));
	}

	json BuiltinExt::ListModules(const json& args)
	{
		if (!args.contains("pid") || !args["pid"].is_number_integer()) {
			return FormatToolResult("Invalid 'pid' argument.");
		}

		DWORD pid = args["pid"].get<DWORD>();
		size_t offset = args.value("offset", 0);
		size_t limit = args.value("limit", 1000);

		HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
		if (snap == INVALID_HANDLE_VALUE) {
			return FormatToolResult(format("Failed to create snapshot for PID {}, error: {}", pid, GetLastError()));
		}

		MODULEENTRY32 me32{};
		me32.dwSize = sizeof(me32);

		json mods = json::array();
		size_t currentIndex = 0;

		if (Module32First(snap, &me32)) {
			do {
				if (currentIndex >= offset && mods.size() < limit) {
					mods.push_back({{"name", me32.szModule},
									{"path", me32.szExePath},
									{"baseAddress", format("0x{:X}", reinterpret_cast<uintptr_t>(me32.modBaseAddr))},
									{"size", me32.modBaseSize}});
				}
				currentIndex++;
				if (mods.size() >= limit) {
					break;
				}
			} while (Module32Next(snap, &me32));
		}

		CloseHandle(snap);
		return FormatToolResult(mods.dump(2));
	}

	json BuiltinExt::ReadMemory(const json& args)
	{
		if (!args.contains("pid") || !args.contains("address") || !args.contains("size")) {
			return FormatToolResult("Missing arguments");
		}

		DWORD pid = args["pid"].get<DWORD>();
		string addrStr = args["address"].get<string>();
		size_t size = args["size"].get<size_t>();

		if (size == 0 || size > 4096) {
			return FormatToolResult("Size must be between 1 and 4096.");
		}

		uintptr_t address = 0;
		try {
			address = stoull(addrStr, nullptr, 16);
		}
		catch (...) {
			return FormatToolResult("Invalid address format. Use hex.");
		}

		HANDLE hProc = OpenProcess(PROCESS_VM_READ, FALSE, pid);
		if (!hProc) {
			return FormatToolResult(format("Failed to OpenProcess for read, error: {}", GetLastError()));
		}

		vector<uint8_t> buffer(size);
		SIZE_T bytesRead = 0;

		if (ReadProcessMemory(hProc, reinterpret_cast<LPCVOID>(address), buffer.data(), size, &bytesRead)) {
			ostringstream oss;
			for (SIZE_T i = 0; i < bytesRead; ++i) {
				oss << hex << setw(2) << setfill('0') << static_cast<int>(buffer[i]);
			}
			CloseHandle(hProc);
			return FormatToolResult(oss.str());
		}

		DWORD error = GetLastError();
		CloseHandle(hProc);

		string errorMsg = format("ReadProcessMemory failed, error: {}", error);
		if (error == ERROR_PARTIAL_COPY || error == ERROR_NOACCESS || error == ERROR_INVALID_ADDRESS) {
			errorMsg += ". LOUD FAILURE HINT: The address is unmapped or protected. Stop brute-forcing! Use 'ph_query_memory_regions' first to find valid, committed memory ranges.";
		}
		
		return FormatToolResult(errorMsg);
	}

	json BuiltinExt::ListThreads(const json& args)
	{
		if (!args.contains("pid") || !args["pid"].is_number_integer()) {
			return FormatToolResult("Invalid 'pid' argument.");
		}

		DWORD pid = args["pid"].get<DWORD>();
		HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
		if (snap == INVALID_HANDLE_VALUE) {
			return FormatToolResult(format("Failed to create snapshot, error: {}", GetLastError()));
		}

		THREADENTRY32 te32{};
		te32.dwSize = sizeof(te32);

		json threads = json::array();
		if (Thread32First(snap, &te32)) {
			do {
				if (te32.th32OwnerProcessID == pid) {
					threads.push_back(json{{"tid", te32.th32ThreadID}, {"basePriority", te32.tpBasePri}});
				}
			} while (Thread32Next(snap, &te32));
		}

		CloseHandle(snap);
		return FormatToolResult(threads.dump(2));
	}

	json BuiltinExt::SuspendResumeThread(const json& args)
	{
		if (!args.contains("tid") || !args.contains("action")) {
			return FormatToolResult("Missing 'tid' or 'action' arguments.");
		}

		DWORD tid = args["tid"].get<DWORD>();
		string action = args["action"].get<string>();

		HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, tid);
		if (!hThread) {
			return FormatToolResult(format("Failed to OpenThread {}, error: {}", tid, GetLastError()));
		}

		DWORD result = (DWORD)-1;
		if (action == "suspend") {
			result = SuspendThread(hThread);
		}
		else if (action == "resume") {
			result = ResumeThread(hThread);
		}
		else {
			CloseHandle(hThread);
			return FormatToolResult("Invalid action. Use 'suspend' or 'resume'.");
		}

		CloseHandle(hThread);

		if (result == (DWORD)-1) {
			return FormatToolResult(format("Failed to {} thread, error: {}", action, GetLastError()));
		}

		return FormatToolResult(format("Successfully performed {} on thread {}. Previous count: {}", action, tid, result));
	}

	json BuiltinExt::QueryMemoryRegions(const json& args)
	{
		if (!args.contains("pid") || !args["pid"].is_number_integer()) {
			return FormatToolResult("Invalid 'pid' argument.");
		}

		DWORD pid = args["pid"].get<DWORD>();
		size_t offset = args.value("offset", 0);
		size_t limit = args.value("limit", 1000);

		HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
		if (!hProc) {
			return FormatToolResult(format("Failed to OpenProcess for query, error: {}", GetLastError()));
		}

		json regions = json::array();
		MEMORY_BASIC_INFORMATION mbi{};
		uintptr_t currentAddress = 0;
		size_t currentIndex = 0;

		while (VirtualQueryEx(hProc, reinterpret_cast<LPCVOID>(currentAddress), &mbi, sizeof(mbi)) == sizeof(mbi)) {
			if (mbi.State != MEM_FREE) {
				if (currentIndex >= offset && regions.size() < limit) {
					string stateStr, typeStr, protectStr;

					switch (mbi.State) {
					case MEM_COMMIT:
						stateStr = "Commit";
						break;
					case MEM_RESERVE:
						stateStr = "Reserve";
						break;
					default:
						stateStr = "Unknown";
						break;
					}

					switch (mbi.Type) {
					case MEM_IMAGE:
						typeStr = "Image";
						break;
					case MEM_MAPPED:
						typeStr = "Mapped";
						break;
					case MEM_PRIVATE:
						typeStr = "Private";
						break;
					default:
						typeStr = "Unknown";
						break;
					}

					DWORD p = mbi.Protect;
					if (p & PAGE_EXECUTE) protectStr += "X";
					if (p & PAGE_EXECUTE_READ) protectStr += "RX";
					if (p & PAGE_EXECUTE_READWRITE) protectStr += "RWX";
					if (p & PAGE_EXECUTE_WRITECOPY) protectStr += "WCX";
					if (p & PAGE_NOACCESS) protectStr += "NA";
					if (p & PAGE_READONLY) protectStr += "R";
					if (p & PAGE_READWRITE) protectStr += "RW";
					if (p & PAGE_WRITECOPY) protectStr += "WC";

					regions.push_back({{"baseAddress", format("0x{:X}", reinterpret_cast<uintptr_t>(mbi.BaseAddress))},
									   {"size", mbi.RegionSize},
									   {"state", stateStr},
									   {"type", typeStr},
									   {"protection", protectStr.empty() ? to_string(mbi.Protect) : protectStr}});
				}
				currentIndex++;
			}

			if (regions.size() >= limit) {
				break;
			}

			currentAddress = reinterpret_cast<uintptr_t>(mbi.BaseAddress) + mbi.RegionSize;
		}

		CloseHandle(hProc);
		return FormatToolResult(regions.dump(2));
	}

	json BuiltinExt::ListHandles(const json& args)
	{
		if (!args.contains("pid") || !args["pid"].is_number_integer()) {
			return FormatToolResult("Invalid 'pid' argument.");
		}

		DWORD targetPid = args["pid"].get<DWORD>();
		size_t offset = args.value("offset", 0);
		size_t limit = args.value("limit", 1000);

		HMODULE ntdll = GetModuleHandleW(L"ntdll.dll");
		if (!ntdll) {
			return FormatToolResult("Failed to get ntdll.dll");
		}

		auto NtQuerySystemInformation = reinterpret_cast<NtQuerySystemInformationFn>(GetProcAddress(ntdll, "NtQuerySystemInformation"));
		if (!NtQuerySystemInformation) {
			return FormatToolResult("Failed to resolve NtQuerySystemInformation");
		}

		ULONG returnLength = 0;
		ULONG bufferSize = 0x10000;
		vector<uint8_t> buffer(bufferSize);
		NTSTATUS status = 0;

		do {
			status = NtQuerySystemInformation(SystemExtendedHandleInformation, buffer.data(), bufferSize, &returnLength);
			if (status == (NTSTATUS)0xC0000004) {
				bufferSize = returnLength + 0x10000;
				buffer.resize(bufferSize);
			}
		} while (status == (NTSTATUS)0xC0000004);

		if (!NT_SUCCESS(status)) {
			return FormatToolResult(format("NtQuerySystemInformation failed with status 0x{:X}", status));
		}

		auto* handleInfo = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION_EX>(buffer.data());
		json handles = json::array();
		size_t currentIndex = 0;

		for (ULONG_PTR i = 0; i < handleInfo->NumberOfHandles; i++) {
			const auto& handle = handleInfo->Handles[i];

			if (handle.UniqueProcessId == targetPid) {
				if (currentIndex >= offset && handles.size() < limit) {
					handles.push_back({{"handle", format("0x{:X}", handle.HandleValue)},
									   {"objectAddress", format("0x{:X}", reinterpret_cast<uintptr_t>(handle.Object))},
									   {"access", format("0x{:X}", handle.GrantedAccess)},
									   {"typeIndex", handle.ObjectTypeIndex}});
				}
				currentIndex++;

				if (handles.size() >= limit) {
					break;
				}
			}
		}

		return FormatToolResult(handles.dump(2));
	}

} // namespace machinetherapist

```

`extensions/builtin_ext/BuiltinExt.h`:

```h
#pragma once

#include <nlohmann/json.hpp>

namespace machinetherapist {

	using json = nlohmann::json;

	class BuiltinExt {
	public:
		static json ListProcesses(const json& args);
		static json ListModules(const json& args);
		static json ReadMemory(const json& args);

		static json ListThreads(const json& args);
		static json QueryMemoryRegions(const json& args);
		static json SuspendResumeThread(const json& args);
		// Handle listing requires NtQuerySystemInformation, will add barebones struct
		static json ListHandles(const json& args);
	};

} // namespace machinetherapist

```

`extensions/freezer_ext/FreezerExt.cpp`:

```cpp
#include "../../include/McpExtensionApi.h"

#include <nlohmann/json.hpp>

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

#include <windows.h>
#include <tlhelp32.h>

using nlohmann::json;

using namespace std;

bool SetProcessThreadsState(DWORD pid, bool suspend)
{
    HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hThreadSnap == INVALID_HANDLE_VALUE) return false;

    THREADENTRY32 te32;
    te32.dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(hThreadSnap, &te32)) {
        CloseHandle(hThreadSnap);
        return false;
    }

    bool success = false;
    do {
        if (te32.th32OwnerProcessID == pid) {
            HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te32.th32ThreadID);
            if (hThread) {
                suspend ? SuspendThread(hThread) : ResumeThread(hThread);
                CloseHandle(hThread);
                success = true;
            }
        }
    } while (Thread32Next(hThreadSnap, &te32));

    CloseHandle(hThreadSnap);
    return success;
}

const char* SuspendToolHandler(const char* jsonArgs)
{
    auto createResponse = [](const string& msg, bool isError = false) {
        json resp;
        resp["content"] = json::array({json{{"type", "text"}, {"text", msg}}});
        if (isError) resp["isError"] = true;
        string resStr = resp.dump();
#pragma warning(suppress : 28183)
        char* result = new char[resStr.size() + 1];
        strcpy_s(result, resStr.size() + 1, resStr.c_str());
        return result;
    };

    try {
        json j = json::parse(jsonArgs);
        auto pid = j.at("pid").get<DWORD>();
        string action = j.at("action").get<string>();

        if (action != "suspend" && action != "resume") {
            return createResponse("Error: invalid action (must be 'suspend' or 'resume')", true);
        }

        if (SetProcessThreadsState(pid, action == "suspend")) {
            return createResponse(string("Success: process threads ") + action + "ed");
        } else {
            return createResponse("Error: failed to interact with process threads", true);
        }

    } catch (const exception& e) {
        return createResponse(string("Error: ") + e.what(), true);
    }
}

void SuspendFreeResult(const char* resultStr)
{
    delete[] resultStr;
}

extern "C" __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api)
{
    if (!api || !api->registerTool) {
        return false;
    }

    McpToolRegistration tool{};
    tool.name = "ext_process_freezer";
    tool.description = "Suspends or resumes all threads in a process (Time Stopper).";
    tool.version = "1.0.0";
    tool.inputSchemaJson = R"({
        "type": "object",
        "properties": {
            "pid": {"type": "integer", "description": "Process ID"},
            "action": {"type": "string", "description": "'suspend' to freeze, 'resume' to unfreeze"}
        },
        "required": ["pid", "action"]
    })";
    tool.handler = SuspendToolHandler;
    tool.freeResult = SuspendFreeResult;
    tool.isDestructive = true;

    api->registerTool(api->serverContext, &tool);
    return true;
}

BOOL APIENTRY DllMain(HMODULE, DWORD, LPVOID)
{
    return TRUE;
}

```

`extensions/memory_patcher_ext/MemoryPatcherExt.cpp`:

```cpp
#include "../../include/McpExtensionApi.h"

#include <nlohmann/json.hpp>

#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <iomanip>

#include <windows.h>

using nlohmann::json;
using namespace std;

const char* MemoryPatcherHandler(const char* jsonArgs)
{
    auto createResponse = [](const string& msg, bool isError = false, const json& contentData = json::object()) {
        json resp;
        if (contentData.empty()) {
            resp["content"] = json::array({json{{"type", "text"}, {"text", msg}}});
        } else {
            resp["content"] = json::array({json{{"type", "text"}, {"text", contentData.dump(4)}}});
        }
        if (isError) resp["isError"] = true;
        string resStr = resp.dump();
#pragma warning(suppress : 28183)
        char* result = new char[resStr.size() + 1];
        strcpy_s(result, resStr.size() + 1, resStr.c_str());
        return result;
    };

    try {
        json j = json::parse(jsonArgs);
        auto pid = j.at("pid").get<DWORD>();
        string addrStr = j.at("address").get<string>();
        string hexStr = j.at("hex_bytes").get<string>();

        auto parseAddress = [](const string& addr) -> uintptr_t {
            uintptr_t result = 0;
            istringstream iss(addr);
            if (addr.find("0x") == 0 || addr.find("0X") == 0) {
                iss >> hex >> result;
            } else {
                iss >> result;
            }
            return result;
        };

        auto parseHexBytes = [](const string& hexData) -> vector<uint8_t> {
            vector<uint8_t> bytes;
            string cleanHex = hexData;
            cleanHex.erase(remove_if(cleanHex.begin(), cleanHex.end(), ::isspace), cleanHex.end());

            for (size_t i = 0; i < cleanHex.length(); i += 2) {
                string byteString = cleanHex.substr(i, 2);
                uint8_t byte = static_cast<uint8_t>(stoul(byteString, nullptr, 16));
                bytes.push_back(byte);
            }
            return bytes;
        };

        uintptr_t targetAddress = parseAddress(addrStr);
        if (targetAddress == 0) return createResponse("Error: Invalid address format", true);

        vector<uint8_t> patchBytes = parseHexBytes(hexStr);
        if (patchBytes.empty()) return createResponse("Error: Empty or invalid hex_bytes", true);

        HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, pid);
        if (!hProcess) return createResponse("Error: Cannot open process for writing. Ensure it's not protected by Anti-Cheat or run as Admin.", true);

        auto cleanup = [&]() { CloseHandle(hProcess); };

        DWORD oldProtect;
        if (!VirtualProtectEx(hProcess, reinterpret_cast<LPVOID>(targetAddress), patchBytes.size(), PAGE_EXECUTE_READWRITE, &oldProtect)) {
            cleanup();
            return createResponse("Error: VirtualProtectEx failed. OS blocked protection change.", true);
        }

        SIZE_T bytesWritten = 0;
        bool writeSuccess = WriteProcessMemory(hProcess, reinterpret_cast<LPVOID>(targetAddress), patchBytes.data(), patchBytes.size(), &bytesWritten);

        DWORD tempProtect;
        VirtualProtectEx(hProcess, reinterpret_cast<LPVOID>(targetAddress), patchBytes.size(), oldProtect, &tempProtect);

        if (!writeSuccess || bytesWritten != patchBytes.size()) {
            cleanup();
            return createResponse("Error: WriteProcessMemory failed or incomplete write.", true);
        }

        cleanup();

        json results = json::object();
        results["status"] = "success";
        results["bytes_written"] = bytesWritten;
        results["patched_address"] = (ostringstream() << hex << "0x" << targetAddress).str();

        return createResponse("", false, results);

    } catch (const exception& e) {
        return createResponse(string("Error: ") + e.what(), true);
    }
}

void MemoryPatcherFreeResult(const char* resultStr)
{
    delete[] resultStr;
}

extern "C" __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api)
{
    if (!api || !api->registerTool) {
        return false;
    }

    McpToolRegistration tReg{};
    tReg.name = "ext_memory_patcher";
    tReg.description = "Writes arbitrary hex bytes to a specified memory address in a target process.";
    tReg.version = "1.0.0";
    tReg.inputSchemaJson = "{\"type\":\"object\",\"properties\":{\"pid\":{\"type\":\"integer\",\"description\":\"Target Process ID\"},\"address\":{\"type\":\"string\",\"description\":\"Memory address\"},\"hex_bytes\":{\"type\":\"string\",\"description\":\"Bytes to write\"}},\"required\":[\"pid\",\"address\",\"hex_bytes\"]}";
    tReg.handler = MemoryPatcherHandler;
    tReg.freeResult = MemoryPatcherFreeResult;

    api->registerTool(api->serverContext, &tReg);
    return true;
}

BOOL APIENTRY DllMain(HMODULE, DWORD, LPVOID)
{
    return TRUE;
}

```

`extensions/pattern_scanner_ext/PatternScannerExt.cpp`:

```cpp
#include "../../include/McpExtensionApi.h"

#include <nlohmann/json.hpp>

#include <algorithm>
#include <cstdint>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include <windows.h>
#include <psapi.h>

using nlohmann::json;

using namespace std;

struct PatternByte {
    uint8_t value;
    bool isWildcard;
};

vector<PatternByte> ParsePattern(const string& signature)
{
    vector<PatternByte> patternBytes;
    istringstream iss(signature);
    string token;

    auto pushWildcard = [&]() { patternBytes.push_back({0, true}); };
    auto pushByte = [&](const string& t) { 
        patternBytes.push_back({static_cast<uint8_t>(strtoul(t.c_str(), nullptr, 16)), false}); 
    };

    while (iss >> token) {
        (token == "?" || token == "??") ? pushWildcard() : pushByte(token);
    }
    return patternBytes;
}

size_t FindPatternInBuffer(const vector<uint8_t>& buffer, const vector<PatternByte>& pattern)
{
    if (pattern.size() > buffer.size() || pattern.empty()) {
        return static_cast<size_t>(-1);
    }

    auto matcher = [](uint8_t memByte, const PatternByte& pb) {
        return pb.isWildcard || memByte == pb.value;
    };

    auto it = search(buffer.begin(), buffer.end(), pattern.begin(), pattern.end(), matcher);
    return (it != buffer.end()) ? distance(buffer.begin(), it) : static_cast<size_t>(-1);
}

const char* PatternScannerToolHandler(const char* jsonArgs)
{
    auto createErrorResponse = [](const exception& e) {
        json errBlock = { {"type", "text"}, {"text", string("Error: ") + e.what()} };
        json errResp;
        errResp["content"] = json::array({errBlock});
        errResp["isError"] = true;
        string resStr = errResp.dump();
#pragma warning(suppress : 28183)
        char* result = new char[resStr.size() + 1];
        strcpy_s(result, resStr.size() + 1, resStr.c_str());
        return result;
    };

    try {
        json j = json::parse(jsonArgs);
        auto pid = j.at("pid").get<DWORD>();
        string patternStr = j.at("pattern").get<string>();
        string moduleName = j.value("module", "");

        auto pattern = ParsePattern(patternStr);
        if (pattern.empty()) {
            throw runtime_error("Invalid pattern format");
        }

        HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pid);
        if (!hProcess) {
            throw runtime_error("Failed to open process");
        }

        uintptr_t searchStart = 0;
        uintptr_t searchEnd = 0x7FFFFFFFFFFF;

        auto resolveModuleBounds = [&]() {
            if (moduleName.empty()) return true;
            HMODULE hMods[1024];
            DWORD cbNeeded;
            if (!EnumProcessModulesEx(hProcess, hMods, sizeof(hMods), &cbNeeded, LIST_MODULES_ALL)) return false;

            size_t numModules = cbNeeded / sizeof(HMODULE);
            vector<HMODULE> modsVec(hMods, hMods + numModules);

            auto it = find_if(modsVec.begin(), modsVec.end(), [&](HMODULE hMod) {
                char szModName[MAX_PATH];
                return GetModuleBaseNameA(hProcess, hMod, szModName, sizeof(szModName)) && (moduleName == szModName);
            });

            if (it != modsVec.end()) {
                MODULEINFO modInfo;
                if (GetModuleInformation(hProcess, *it, &modInfo, sizeof(modInfo))) {
                    searchStart = reinterpret_cast<uintptr_t>(modInfo.lpBaseOfDll);
                    searchEnd = searchStart + modInfo.SizeOfImage;
                    return true;
                }
            }
            return false;
        };

        if (!resolveModuleBounds()) {
            CloseHandle(hProcess);
            throw runtime_error("Module not found: " + moduleName);
        }

        uintptr_t currentAddr = searchStart;
        vector<uintptr_t> foundAddresses;

        auto extractPatternMatches = [&](const vector<uint8_t>& buffer, size_t bytesRead, uintptr_t baseAddr) {
            size_t offset = 0;
            auto scanNext = [&]() -> bool {
                if (offset >= buffer.size()) return false;
                vector<uint8_t> subBuffer(buffer.begin() + offset, buffer.end());
                size_t match = FindPatternInBuffer(subBuffer, pattern);
                if (match != static_cast<size_t>(-1)) {
                    foundAddresses.push_back(baseAddr + offset + match);
                    offset += match + 1;
                    return foundAddresses.size() < 50;
                }
                return false;
            };
            while (scanNext());
        };

        auto processMemoryRegion = [&]() -> bool {
            MEMORY_BASIC_INFORMATION mbi;
            if (!VirtualQueryEx(hProcess, reinterpret_cast<LPCVOID>(currentAddr), &mbi, sizeof(mbi))) return false;

            bool isCommit = (mbi.State == MEM_COMMIT);
            bool isReadable = (mbi.Protect & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE));
            
            if (isCommit && isReadable) {
                size_t regionSize = mbi.RegionSize;
                if (currentAddr + regionSize > searchEnd && searchEnd != 0x7FFFFFFFFFFF) {
                    regionSize = searchEnd - currentAddr;
                }

                vector<uint8_t> buffer(regionSize);
                SIZE_T bytesRead;
                if (ReadProcessMemory(hProcess, reinterpret_cast<LPCVOID>(currentAddr), buffer.data(), regionSize, &bytesRead)) {
                    buffer.resize(bytesRead);
                    extractPatternMatches(buffer, bytesRead, currentAddr);
                }
            }
            currentAddr += mbi.RegionSize;
            return foundAddresses.size() < 50 && currentAddr < searchEnd;
        };

        while (processMemoryRegion());

        CloseHandle(hProcess);

        json resultObj = json::object();
        json addresses = json::array();
        
        for_each(foundAddresses.begin(), foundAddresses.end(), [&addresses](uintptr_t addr) {
            stringstream ss;
            ss << "0x" << hex << uppercase << addr;
            addresses.push_back(ss.str());
        });

        resultObj["found_count"] = foundAddresses.size();
        resultObj["addresses"] = addresses;
        
        json responseObj;
        responseObj["content"] = json::array({json{{"type", "text"}, {"text", resultObj.dump(4)}}});

        string resStr = responseObj.dump();
#pragma warning(suppress : 28183)
        char* result = new char[resStr.size() + 1];
        strcpy_s(result, resStr.size() + 1, resStr.c_str());
        return result;

    } catch (const exception& e) {
        return createErrorResponse(e);
    }
}

void PatternScannerFreeResult(const char* resultStr)
{
    delete[] resultStr;
}

extern "C" __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api)
{
    if (!api || !api->registerTool) {
        return false;
    }

    McpToolRegistration tool{};
    tool.name = "ext_pattern_scanner";
    tool.description = "Scans process memory for a byte signature/pattern. Bypasses static offsets.";
    tool.version = "1.0.0";
    tool.inputSchemaJson = R"({
        "type": "object",
        "properties": {
            "pid": {"type": "integer", "description": "Process ID"},
            "pattern": {"type": "string", "description": "Byte pattern e.g. '48 8B 05 ? ? ? ? 48 85 C0'"},
            "module": {"type": "string", "description": "Optional: Only scan specific module e.g. 'client.dll'"}
        },
        "required": ["pid", "pattern"]
    })";
    tool.handler = PatternScannerToolHandler;
    tool.freeResult = PatternScannerFreeResult;
    tool.isDestructive = false;

    api->registerTool(api->serverContext, &tool);
    return true;
}

BOOL APIENTRY DllMain(HMODULE, DWORD, LPVOID)
{
    return TRUE;
}

```

`extensions/rtti_dumper_ext/RttiDumperExt.cpp`:

```cpp
#include "../../include/McpExtensionApi.h"

#include <nlohmann/json.hpp>

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

#include <windows.h>
#include <psapi.h>

using nlohmann::json;

using namespace std;

struct RTTICompleteObjectLocator {
    DWORD signature;
    DWORD offset;
    DWORD cdOffset;
    DWORD pTypeDescriptor;
    DWORD pClassDescriptor;
    DWORD pSelf;
};

const char* RttiToolHandler(const char* jsonArgs)
{
    auto createResponse = [](const string& msg, bool isError = false, const json& contentData = json::object()) {
        json resp;
        if (contentData.empty()) {
            resp["content"] = json::array({json{{"type", "text"}, {"text", msg}}});
        } else {
            resp["content"] = json::array({json{{"type", "text"}, {"text", contentData.dump(4)}}});
        }
        if (isError) resp["isError"] = true;
        string resStr = resp.dump();
#pragma warning(suppress : 28183)
        char* result = new char[resStr.size() + 1];
        strcpy_s(result, resStr.size() + 1, resStr.c_str());
        return result;
    };

    try {
        json j = json::parse(jsonArgs);
        auto pid = j.at("pid").get<DWORD>();
        string moduleName = j.value("module", "");

        HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pid);
        if (!hProcess) return createResponse("Error: cannot open process", true);

        auto cleanup = [&]() { CloseHandle(hProcess); };

        HMODULE hMods[1024];
        DWORD cbNeeded;
        if (!EnumProcessModulesEx(hProcess, hMods, sizeof(hMods), &cbNeeded, LIST_MODULES_ALL)) {
            cleanup();
            return createResponse("Error: cannot enumerate modules", true);
        }

        uintptr_t targetModuleBase = 0;
        DWORD targetModuleSize = 0;

        auto findModule = [&]() {
            vector<HMODULE> modules(hMods, hMods + (cbNeeded / sizeof(HMODULE)));
            for (auto hMod : modules) {
                char szModName[MAX_PATH];
                if (GetModuleBaseNameA(hProcess, hMod, szModName, sizeof(szModName))) {
                    if (moduleName.empty() || _stricmp(szModName, moduleName.c_str()) == 0) {
                        MODULEINFO modInfo;
                        if (GetModuleInformation(hProcess, hMod, &modInfo, sizeof(modInfo))) {
                            targetModuleBase = reinterpret_cast<uintptr_t>(modInfo.lpBaseOfDll);
                            targetModuleSize = modInfo.SizeOfImage;
                            return true;
                        }
                    }
                }
            }
            return false;
        };

        if (!findModule()) {
            cleanup();
            return createResponse("Error: target module not found", true);
        }

        vector<uint8_t> moduleMemory(targetModuleSize);
        SIZE_T bytesRead = 0;
        if (!ReadProcessMemory(hProcess, reinterpret_cast<LPCVOID>(targetModuleBase), moduleMemory.data(), targetModuleSize, &bytesRead) || bytesRead == 0) {
            cleanup();
            return createResponse("Error: cannot read module memory", true);
        }

        IMAGE_DOS_HEADER* pDosHeader = reinterpret_cast<IMAGE_DOS_HEADER*>(moduleMemory.data());
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            cleanup();
            return createResponse("Error: invalid DOS signature", true);
        }

        IMAGE_NT_HEADERS64* pNtHeaders = reinterpret_cast<IMAGE_NT_HEADERS64*>(moduleMemory.data() + pDosHeader->e_lfanew);
        if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
            cleanup();
            return createResponse("Error: invalid NT signature", true);
        }

        IMAGE_SECTION_HEADER* pSection = IMAGE_FIRST_SECTION(pNtHeaders);
        uintptr_t rdataStart = 0;
        DWORD rdataSize = 0;

        for (WORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++, pSection++) {
            if (strncmp(reinterpret_cast<const char*>(pSection->Name), ".rdata", 6) == 0) {
                rdataStart = pSection->VirtualAddress;
                rdataSize = pSection->Misc.VirtualSize;
                break;
            }
        }

        if (rdataStart == 0) {
            cleanup();
            return createResponse("Error: .rdata section not found", true);
        }

        json results = json::object();
        results["found_classes"] = json::array();

        auto parseRtti = [&]() {
            auto processLocator = [&](DWORD offset) {
                RTTICompleteObjectLocator* pLocator = reinterpret_cast<RTTICompleteObjectLocator*>(moduleMemory.data() + offset);
                if (pLocator->signature != 1 || pLocator->pSelf != offset) return;
                
                uintptr_t typeDescOffset = pLocator->pTypeDescriptor;
                if (typeDescOffset <= rdataStart || typeDescOffset >= (rdataStart + rdataSize)) return;
                
                uintptr_t nameOffset = typeDescOffset + 16; 
                if (nameOffset >= targetModuleSize) return;

                string className = reinterpret_cast<const char*>(moduleMemory.data() + nameOffset);
                if (className.length() <= 2 || className.substr(0, 2) != ".?") return;

                json classInfo;
                classInfo["name"] = className;
                classInfo["rva_locator"] = offset;
                classInfo["address_locator"] = (ostringstream() << hex << "0x" << (targetModuleBase + offset)).str();
                results["found_classes"].push_back(classInfo);
            };

            for (DWORD offset = rdataStart; offset < rdataStart + rdataSize - sizeof(RTTICompleteObjectLocator); offset += 4) {
                processLocator(offset);
            }
        };

        parseRtti();
        cleanup();

        results["status"] = "success";
        results["module"] = moduleName.empty() ? "main_module" : moduleName;
        results["base_address"] = (ostringstream() << hex << "0x" << targetModuleBase).str();
        results["total_found"] = results["found_classes"].size();

        return createResponse("", false, results);

    } catch (const exception& e) {
        return createResponse(string("Error: ") + e.what(), true);
    }
}

void RttiFreeResult(const char* resultStr)
{
    delete[] resultStr;
}

extern "C" __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api)
{
    if (!api || !api->registerTool) {
        return false;
    }

    McpToolRegistration tReg{};
    tReg.name = "ext_rtti_dumper";
    tReg.description = "Scans memory for exactly x64 MSVC RTTI locators and dumps Class Names (Reverse Engineering).";
    tReg.version = "1.0.0";
    tReg.inputSchemaJson = "{\"type\":\"object\",\"properties\":{\"pid\":{\"type\":\"integer\",\"description\":\"Process ID\"},\"module\":{\"type\":\"string\",\"description\":\"Optional module name\"}},\"required\":[\"pid\"]}";
    tReg.handler = RttiToolHandler;
    tReg.freeResult = RttiFreeResult;

    api->registerTool(api->serverContext, &tReg);
    return true;
}

BOOL APIENTRY DllMain(HMODULE, DWORD, LPVOID)
{
    return TRUE;
}

```

`extensions/sample_ext/SampleExt.cpp`:

```cpp
#include "../../include/McpExtensionApi.h"

#include <iostream>
#include <string>

#include <windows.h>

using namespace std;

const char* SampleMemoryToolHandler(const char* jsonArgs)
{
	string response = R"({
        "content": [{
            "type": "text",
            "text": "[SampleExt] Read 8 bytes (Mocked Direct Syscall): 48 89 5C 24 08"
        }]
    })";

	char* result = new char[response.size() + 1];
	strcpy_s(result, response.size() + 1, response.c_str());
	return result;
}

void SampleFreeResult(const char* resultStr)
{
	delete[] resultStr;
}

extern "C" __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api)
{
	if (!api || !api->registerTool) {
		return false;
	}

	cerr << "[SampleExt] Initializing direct syscall extension...\n";

	McpToolRegistration tool{};
	tool.name = "ext_sample_read_memory_syscall";
	tool.description = "Reads memory using direct assembly syscalls, bypassing ntdll.dll user-mode hooks.";
	tool.version = "1.0.0";
	tool.inputSchemaJson = R"({
        "type": "object",
        "properties": {
            "pid": {"type": "integer", "description": "Process ID"},
            "address": {"type": "string", "description": "Target hex address"}
        },
        "required": ["pid", "address"]
    })";
	tool.handler = SampleMemoryToolHandler;
	tool.freeResult = SampleFreeResult;
	tool.isDestructive = false;

	api->registerTool(api->serverContext, &tool);

	return true;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	return TRUE;
}

```

`extensions/vehbutnot_ext/Types.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>

#include <Windows.h>

namespace machinetherapist {

	using WnfStateName = uint64_t;
	using WnfChangeStamp = uint32_t;

	struct WnfTypeId final {
		GUID typeId;
	};

	inline constexpr NTSTATUS StatusSingleStep = 0x80000004;
	inline constexpr uint32_t EflagsResume = 0x00010000;
	inline constexpr uint64_t Dr7ArmDr0Execute = 0x01;
	inline constexpr uint64_t Dr7Dr0Mask = 0x000F0003;
	inline constexpr uint64_t Dr7ArmDr1Execute = 0x04;
	inline constexpr uint64_t Dr7Dr1Mask = 0x00F0000C;
	inline constexpr WnfStateName WnfShelApplicationStarted = 0x0D83063EA3BDF875ULL;

	using WnfUserCallback = NTSTATUS(NTAPI*)(WnfStateName, WnfChangeStamp, WnfTypeId*, PVOID, PVOID, ULONG);
	using KiUedCallback = void(NTAPI*)(PEXCEPTION_RECORD, PCONTEXT);
	using RtlRestoreContextFn = void(NTAPI*)(PCONTEXT, PEXCEPTION_RECORD);
	using RtlSubscribeWnfFn = NTSTATUS(NTAPI*)(PVOID*, WnfStateName, WnfChangeStamp, WnfUserCallback, PVOID, WnfTypeId*, ULONG, ULONG);
	using RtlUnsubscribeWnfFn = NTSTATUS(NTAPI*)(PVOID);
	using NtUpdateWnfStateFn = NTSTATUS(NTAPI*)(WnfStateName*, PVOID, ULONG, WnfTypeId*, PVOID, WnfChangeStamp, ULONG);
	using NtGetContextThreadFn = NTSTATUS(NTAPI*)(HANDLE, PCONTEXT);

	struct RtlBalancedNode final {
		RtlBalancedNode* children[2];
		union {
			uint8_t red;
			uintptr_t parentValue;
		};
	};

	// size 0xA0, magic = 0xA00914
	struct WnfUserSubscription final {
		uint32_t magic;				// +0x00  0xA00914
		uint32_t padding0;			// +0x04
		LIST_ENTRY listEntry;		// +0x08
		PVOID nameSubscription;		// +0x18
		uint64_t refCount;			// +0x20
		WnfUserCallback callback;	// +0x28
		PVOID callbackContext;		// +0x30
		PVOID subProcessTag;		// +0x38
		WnfChangeStamp changeStamp; // +0x40
		uint32_t flags;				// +0x44
		uint32_t deliveryOptions;	// +0x48
	};

	static_assert(offsetof(WnfUserSubscription, callback) == 0x28);
	static_assert(offsetof(WnfUserSubscription, listEntry) == 0x08);

	// size 0x98, magic = 0x980912
	// RB node at +0x20, inserted via RtlRbInsertNodeEx(table+0x10, ...)
	struct WnfNameSubscription final {
		uint32_t magic;					   // +0x00  0x980912
		uint32_t padding0;				   // +0x04
		uint64_t reserved0;				   // +0x08
		WnfStateName stateName;			   // +0x10
		WnfChangeStamp currentChangeStamp; // +0x18
		uint32_t padding1;				   // +0x1C
		RtlBalancedNode rbNode;			   // +0x20  (0x18 bytes)
		uint64_t reserved1;				   // +0x38
		SRWLOCK subscriptionLock;		   // +0x40
		LIST_ENTRY userSubscriptionsHead;  // +0x48
		uint64_t refCount;				   // +0x58
		uint32_t totalSubscriptions;	   // +0x60
		uint32_t activeSubscriptions;	   // +0x64
		uint32_t deliveryCounters[5];	   // +0x68
		uint32_t flags;					   // +0x7C
	};

	static_assert(offsetof(WnfNameSubscription, stateName) == 0x10);
	static_assert(offsetof(WnfNameSubscription, rbNode) == 0x20);
	static_assert(offsetof(WnfNameSubscription, subscriptionLock) == 0x40);
	static_assert(offsetof(WnfNameSubscription, userSubscriptionsHead) == 0x48);
	static_assert(offsetof(WnfNameSubscription, totalSubscriptions) == 0x60);

	// size 0x58, magic = 0x580911
	// RB-tree root at +0x10, names list (legacy) at +0x20
	// RtlpWnfProcessSubscriptions @ 0x1801ce200
	struct WnfSubscriptionTable final {
		uint32_t magic;				// +0x00  0x580911
		uint32_t padding0;			// +0x04
		SRWLOCK tableLock;			// +0x08
		uint8_t* rbTreeRoot;		// +0x10  RTL_RB_TREE root
		uintptr_t rbTreeFlags;		// +0x18  encoded XOR flag
		LIST_ENTRY namesTableEntry; // +0x20  (legacy linked list)
		uint64_t reserved0;			// +0x30
		uint32_t timerDelayMs;		// +0x38
		uint32_t timerPeriodMs;		// +0x3C
		uint32_t timerMaxMs;		// +0x40
		uint32_t timerMaxCount;		// +0x44
		PVOID tpTimer;				// +0x48
		uint64_t reserved1;			// +0x50
	};

	static_assert(offsetof(WnfSubscriptionTable, tableLock) == 0x08);
	static_assert(offsetof(WnfSubscriptionTable, rbTreeRoot) == 0x10);
	static_assert(offsetof(WnfSubscriptionTable, namesTableEntry) == 0x20);
	static_assert(sizeof(WnfSubscriptionTable) == 0x58);

}

```

`extensions/vehbutnot_ext/VehButNot.cpp`:

```cpp
#include "VehButNot.h"

#include <format>
#include <iostream>

#include <TlHelp32.h>

using namespace std;

using namespace machinetherapist;

VehButNot* VehButNot::_instance = nullptr;

VehButNot::~VehButNot()
{
	Shutdown();
	if (_instance == this)
		_instance = nullptr;
}

KiUedCallback* VehButNot::FindKiUedCallbackPointer(HMODULE ntdll)
{
	auto* base = reinterpret_cast<uint8_t*>(GetProcAddress(ntdll, "KiUserExceptionDispatcher"));
	if (!base)
		return nullptr;

	for (int i = 0; i < 64; i++) {
		const auto match =
			base[i] == 0x48 && base[i + 1] == 0x8B && base[i + 2] == 0x05 && base[i + 7] == 0x48 && base[i + 8] == 0x85 && base[i + 9] == 0xC0;
		if (!match)
			continue;

		const auto disp = *reinterpret_cast<int32_t*>(&base[i + 3]);
		auto* resolved = &base[i] + 7 + disp;
		return reinterpret_cast<KiUedCallback*>(resolved);
	}

	return nullptr;
}

WnfSubscriptionTable** VehButNot::FindWnfSubscriptionTable(HMODULE ntdll)
{
	auto* peBase = reinterpret_cast<uint8_t*>(ntdll);
	const auto* dosHdr = reinterpret_cast<PIMAGE_DOS_HEADER>(peBase);
	const auto* ntHdrs = reinterpret_cast<PIMAGE_NT_HEADERS>(peBase + dosHdr->e_lfanew);
	const auto* sections = IMAGE_FIRST_SECTION(ntHdrs);

	uint8_t* dataStart = nullptr;
	uint8_t* dataEnd = nullptr;

	for (WORD s = 0; s < ntHdrs->FileHeader.NumberOfSections; s++) {
		if (memcmp(sections[s].Name, ".data", 5) == 0) {
			dataStart = peBase + sections[s].VirtualAddress;
			dataEnd = dataStart + sections[s].Misc.VirtualSize;
			break;
		}
	}

	if (!dataStart)
		return nullptr;

	auto* exportAddr = reinterpret_cast<uint8_t*>(GetProcAddress(ntdll, "RtlSubscribeWnfStateChangeNotification"));
	if (!exportAddr)
		return nullptr;

	uint8_t* innerFunc = nullptr;
	for (int i = 0; i < 64; i++) {
		if (exportAddr[i] == 0xE8) {
			const auto callDisp = *reinterpret_cast<int32_t*>(&exportAddr[i + 1]);
			innerFunc = &exportAddr[i] + 5 + callDisp;
			break;
		}
	}

	if (!innerFunc)
		return nullptr;

	for (int i = 0; i < _maxPatternScan; i++) {
		if (innerFunc[i] != 0x48 || innerFunc[i + 1] != 0x8D)
			continue;

		if ((innerFunc[i + 2] & 0x07) != 0x05)
			continue;

		const auto disp = *reinterpret_cast<int32_t*>(&innerFunc[i + 3]);
		auto* target = &innerFunc[i] + 7 + disp;

		if (target >= dataStart && target < dataEnd)
			return reinterpret_cast<WnfSubscriptionTable**>(target + 8);
	}

	return nullptr;
}

void NTAPI VehButNot::OnException(PEXCEPTION_RECORD exceptionRecord, PCONTEXT context)
{
	auto* self = _instance;
	if (!self)
		return;

	if (exceptionRecord->ExceptionCode != StatusSingleStep)
		return;

	if ((context->Dr6 & 0x01) && reinterpret_cast<PVOID>(context->Rip) == self->_config.targetApi) {
		self->_interceptionCount.fetch_add(1);

		if (self->_config.handler)
			self->_config.handler(self->_config.targetApi, context, self->_config.userData);

		context->EFlags |= EflagsResume;
		context->Dr6 = 0;

		if (!self->_config.persistentHook) {
			context->Dr0 = 0;
			context->Dr7 &= ~Dr7ArmDr0Execute;
		}

		self->_rtlRestoreContext(context, nullptr);
		return;
	}

	if ((context->Dr6 & 0x02) && reinterpret_cast<PVOID>(context->Rip) == reinterpret_cast<PVOID>(self->_ntGetContextThread)) {
		static atomic<bool> scrubGuard{false};

		if (!self->_drHidingActive.load() || scrubGuard.exchange(true)) {
			context->EFlags |= EflagsResume;
			context->Dr6 = 0;
			self->_rtlRestoreContext(context, nullptr);
			return;
		}

		auto threadHandle = reinterpret_cast<HANDLE>(context->Rcx);
		auto* outCtx = reinterpret_cast<PCONTEXT>(context->Rdx);

		const auto status = self->_ntGetContextThread(threadHandle, outCtx);

		if (status >= 0 && outCtx && (outCtx->ContextFlags & 0x00100010)) {
			outCtx->Dr0 = 0;
			outCtx->Dr1 = 0;
			outCtx->Dr2 = 0;
			outCtx->Dr3 = 0;
			outCtx->Dr6 = 0;
			outCtx->Dr7 = 0;
		}

		context->Rax = static_cast<DWORD64>(status);
		context->Rip = *reinterpret_cast<uint64_t*>(context->Rsp);
		context->Rsp += 8;
		context->EFlags |= EflagsResume;
		context->Dr6 = 0;

		scrubGuard.store(false);
		self->_rtlRestoreContext(context, nullptr);
		return;
	}
}

NTSTATUS NTAPI VehButNot::OnWnfStateChange(WnfStateName, WnfChangeStamp, WnfTypeId*, PVOID callbackContext, PVOID, ULONG)
{
	auto* self = reinterpret_cast<VehButNot*>(callbackContext);
	if (!self || !self->_config.targetApi)
		return 0;

	auto expected = false;
	if (!self->_armed.compare_exchange_strong(expected, true))
		return 0;

	self->ArmAllThreads(self->_config.targetApi);
	return 0;
}

bool VehButNot::SetHardwareBreakpoint(HANDLE thread, PVOID address)
{
	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

	if (!GetThreadContext(thread, &ctx))
		return false;

	ctx.Dr0 = reinterpret_cast<DWORD64>(address);
	ctx.Dr7 &= ~Dr7Dr0Mask;
	ctx.Dr7 |= Dr7ArmDr0Execute;

	if (_config.enableDrHiding && _ntGetContextThread) {
		ctx.Dr1 = reinterpret_cast<DWORD64>(_ntGetContextThread);
		ctx.Dr7 &= ~Dr7Dr1Mask;
		ctx.Dr7 |= Dr7ArmDr1Execute;
	}

	ctx.Dr6 = 0;
	return SetThreadContext(thread, &ctx);
}

bool VehButNot::ClearHardwareBreakpoint(HANDLE thread)
{
	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

	if (!GetThreadContext(thread, &ctx))
		return false;

	ctx.Dr0 = 0;
	ctx.Dr1 = 0;
	ctx.Dr7 &= ~(Dr7ArmDr0Execute | Dr7ArmDr1Execute);
	ctx.Dr6 = 0;
	return SetThreadContext(thread, &ctx);
}

void VehButNot::ArmAllThreads(PVOID address)
{
	const auto pid = GetCurrentProcessId();
	const auto snap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (snap == INVALID_HANDLE_VALUE)
		return;

	THREADENTRY32 te{};
	te.dwSize = sizeof(te);

	if (Thread32First(snap, &te)) {
		do {
			if (te.th32OwnerProcessID != pid)
				continue;

			const auto hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT, FALSE, te.th32ThreadID);
			if (!hThread)
				continue;

			static_cast<void>(SetHardwareBreakpoint(hThread, address));
			CloseHandle(hThread);
		} while (Thread32Next(snap, &te));
	}

	CloseHandle(snap);
}

void VehButNot::DisarmAllThreads()
{
	const auto pid = GetCurrentProcessId();
	const auto snap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (snap == INVALID_HANDLE_VALUE)
		return;

	THREADENTRY32 te{};
	te.dwSize = sizeof(te);

	if (Thread32First(snap, &te)) {
		do {
			if (te.th32OwnerProcessID != pid)
				continue;

			const auto hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT, FALSE, te.th32ThreadID);
			if (!hThread)
				continue;

			static_cast<void>(ClearHardwareBreakpoint(hThread));
			CloseHandle(hThread);
		} while (Thread32Next(snap, &te));
	}

	CloseHandle(snap);
}

bool VehButNot::InstallExceptionPreFilter()
{
	_kiUedCallbackPtr = FindKiUedCallbackPointer(_ntdll);
	if (!_kiUedCallbackPtr)
		return false;

	_originalCallback = *_kiUedCallbackPtr;

	DWORD oldProtect = 0;
	if (!VirtualProtect(_kiUedCallbackPtr, sizeof(KiUedCallback), PAGE_READWRITE, &oldProtect))
		return false;

	*_kiUedCallbackPtr = &VehButNot::OnException;

	VirtualProtect(_kiUedCallbackPtr, sizeof(KiUedCallback), oldProtect, &oldProtect);
	return true;
}

bool VehButNot::SetupWnfSubscription()
{
	const auto subscribe = reinterpret_cast<RtlSubscribeWnfFn>(GetProcAddress(_ntdll, "RtlSubscribeWnfStateChangeNotification"));
	if (!subscribe)
		return false;

	const auto status = subscribe(&_wnfSubscription, _config.wnfStateName, 0, &VehButNot::OnWnfStateChange, this, nullptr, 0, 0);
	return status >= 0;
}

bool VehButNot::Initialize(const VehButNotConfig& config)
{
	if (_initialized)
		return false;

	_config = config;
	_instance = this;

	_ntdll = GetModuleHandleW(L"ntdll.dll");
	if (!_ntdll)
		return false;

	_rtlRestoreContext = reinterpret_cast<RtlRestoreContextFn>(GetProcAddress(_ntdll, "RtlRestoreContext"));
	_ntUpdateWnfState = reinterpret_cast<NtUpdateWnfStateFn>(GetProcAddress(_ntdll, "NtUpdateWnfStateData"));

	if (_config.enableDrHiding)
		_ntGetContextThread = reinterpret_cast<NtGetContextThreadFn>(GetProcAddress(_ntdll, "NtGetContextThread"));

	if (!_rtlRestoreContext)
		return false;

	if (!InstallExceptionPreFilter())
		return false;

	if (!SetupWnfSubscription()) {
		DWORD oldP;
		VirtualProtect(_kiUedCallbackPtr, sizeof(PVOID), PAGE_READWRITE, &oldP);
		*_kiUedCallbackPtr = _originalCallback;
		VirtualProtect(_kiUedCallbackPtr, sizeof(PVOID), oldP, &oldP);
		return false;
	}

	_initialized = true;
	return true;
}

bool VehButNot::ArmViaWnf()
{
	if (!_initialized || !_ntUpdateWnfState)
		return ArmDirect();

	auto stateName = _config.wnfStateName;
	uint32_t dummy = 0xDEADBEEF;
	const auto status = _ntUpdateWnfState(&stateName, &dummy, sizeof(dummy), nullptr, nullptr, 0, 0);

	if (status < 0)
		return ArmDirect();

	Sleep(100);
	const auto armed = _armed.load() ? true : ArmDirect();

	if (armed) {
		CleanupWnfSubscription();
		if (_config.enableDrHiding && _ntGetContextThread)
			_drHidingActive.store(true);
	}

	return armed;
}

bool VehButNot::ArmDirect()
{
	auto expected = false;
	if (!_armed.compare_exchange_strong(expected, true))
		return true;

	return SetHardwareBreakpoint(GetCurrentThread(), _config.targetApi);
}

void VehButNot::Shutdown()
{
	if (!_initialized)
		return;

	_drHidingActive.store(false);

	DisarmAllThreads();
	_armed.store(false);

	if (_kiUedCallbackPtr) {
		DWORD oldP;
		VirtualProtect(_kiUedCallbackPtr, sizeof(PVOID), PAGE_READWRITE, &oldP);
		*_kiUedCallbackPtr = _originalCallback;
		VirtualProtect(_kiUedCallbackPtr, sizeof(PVOID), oldP, &oldP);
		_kiUedCallbackPtr = nullptr;
	}

	CleanupWnfSubscription();
	_initialized = false;
}

void VehButNot::CleanupWnfSubscription()
{
	if (!_wnfSubscription)
		return;

	const auto unsub = reinterpret_cast<RtlUnsubscribeWnfFn>(GetProcAddress(_ntdll, "RtlUnsubscribeWnfNotificationWaitForCompletion"));
	if (unsub)
		unsub(_wnfSubscription);
	_wnfSubscription = nullptr;
}

bool VehButNot::DumpSubscriptions(HMODULE ntdll)
{
	auto** ppTable = FindWnfSubscriptionTable(ntdll);
	if (!ppTable || !*ppTable)
		return false;

	const auto* table = *ppTable;
	cout << format("[*] WnfSubscriptionTable @ 0x{:016X}\n", reinterpret_cast<uintptr_t>(table)) << format("[*] Magic: 0x{:08X}\n", table->magic);

	const auto xorFlag = table->rbTreeFlags & 1;
	const auto treeRootAddr = reinterpret_cast<uintptr_t>(&table->rbTreeRoot);
	auto* rawRoot = table->rbTreeRoot;

	if (xorFlag && rawRoot)
		rawRoot = reinterpret_cast<uint8_t*>(reinterpret_cast<uintptr_t>(rawRoot) ^ treeRootAddr);

	if (!rawRoot) {
		cout << "[*] RB-tree is empty\n";
		return true;
	}

	const auto decode = [xorFlag](RtlBalancedNode* parent, RtlBalancedNode* encoded) -> RtlBalancedNode* {
		if (!encoded)
			return nullptr;
		if (xorFlag)
			return reinterpret_cast<RtlBalancedNode*>(reinterpret_cast<uintptr_t>(encoded) ^ reinterpret_cast<uintptr_t>(parent));
		return encoded;
	};

	const auto rbNodeToNameSub = [](RtlBalancedNode* node) -> const WnfNameSubscription* {
		return reinterpret_cast<const WnfNameSubscription*>(reinterpret_cast<uint8_t*>(node) - offsetof(WnfNameSubscription, rbNode));
	};

	const auto treeMinimum = [&decode](RtlBalancedNode* node) -> RtlBalancedNode* {
		auto* parent = static_cast<RtlBalancedNode*>(nullptr);
		while (true) {
			auto* left = decode(parent, node->children[0]);
			if (!left)
				return node;
			parent = node;
			node = left;
		}
	};

	const auto treeSuccessor = [&decode](RtlBalancedNode* node) -> RtlBalancedNode* {
		auto* right = decode(node, node->children[1]);
		if (right) {
			auto* cursor = right;
			while (true) {
				auto* left = decode(node, cursor->children[0]);
				if (!left)
					return cursor;
				node = cursor;
				cursor = left;
			}
		}
		return nullptr;
	};

	auto* rbRoot = reinterpret_cast<RtlBalancedNode*>(rawRoot);
	auto* current = treeMinimum(rbRoot);
	int nameCount = 0;

	while (current && nameCount < _maxListWalk) {
		const auto* nameSub = rbNodeToNameSub(current);

		cout << format("\n  [{}] StateName: 0x{:016X}  Subs: {}\n", nameCount, nameSub->stateName, nameSub->totalSubscriptions);

		const auto* userHead = &nameSub->userSubscriptionsHead;
		auto* userEntry = userHead->Flink;
		int userCount = 0;

		while (userEntry != userHead && userCount < 256) {
			const auto* userSub =
				reinterpret_cast<const WnfUserSubscription*>(reinterpret_cast<const uint8_t*>(userEntry) - offsetof(WnfUserSubscription, listEntry));

			cout << format("      Callback: 0x{:016X}  Context: 0x{:016X}\n", reinterpret_cast<uintptr_t>(userSub->callback),
						   reinterpret_cast<uintptr_t>(userSub->callbackContext));

			userEntry = userEntry->Flink;
			userCount++;
		}

		current = treeSuccessor(current);
		nameCount++;
	}

	cout << format("\n[*] Total: {} name subscriptions\n", nameCount);
	return true;
}

```

`extensions/vehbutnot_ext/VehButNot.h`:

```h
#pragma once

#include "Types.h"

#include <atomic>
#include <cstdint>

namespace machinetherapist {

	using InterceptionCallback = bool (*)(PVOID targetAddress, PCONTEXT context, PVOID userData);

	struct VehButNotConfig final {
		PVOID targetApi = nullptr;
		InterceptionCallback handler = nullptr;
		PVOID userData = nullptr;
		WnfStateName wnfStateName = WnfShelApplicationStarted;
		bool persistentHook = true;
		bool enableDrHiding = true;
	};

	class VehButNot final {
	public:
		~VehButNot();

		VehButNot() = default;
		VehButNot(const VehButNot&) = delete;
		VehButNot& operator=(const VehButNot&) = delete;

		[[nodiscard]] inline int32_t GetInterceptionCount() const noexcept
		{
			return _interceptionCount.load();
		}

		[[nodiscard]] bool Initialize(const VehButNotConfig& config);
		[[nodiscard]] bool ArmViaWnf();
		[[nodiscard]] bool ArmDirect();
		void Shutdown();

		[[nodiscard]] static bool DumpSubscriptions(HMODULE ntdll);

	private:
		static constexpr int32_t _maxPatternScan = 512;
		static constexpr int32_t _maxListWalk = 1024;

		static VehButNot* _instance;

		VehButNotConfig _config{};
		HMODULE _ntdll = nullptr;
		KiUedCallback* _kiUedCallbackPtr = nullptr;
		KiUedCallback _originalCallback = nullptr;
		PVOID _wnfSubscription = nullptr;
		RtlRestoreContextFn _rtlRestoreContext = nullptr;
		NtUpdateWnfStateFn _ntUpdateWnfState = nullptr;
		NtGetContextThreadFn _ntGetContextThread = nullptr;
		std::atomic<int32_t> _interceptionCount{0};
		std::atomic<bool> _armed{false};
		std::atomic<bool> _drHidingActive{false};
		bool _initialized = false;

		[[nodiscard]] static KiUedCallback* FindKiUedCallbackPointer(HMODULE ntdll);
		[[nodiscard]] static WnfSubscriptionTable** FindWnfSubscriptionTable(HMODULE ntdll);

		static void NTAPI OnException(PEXCEPTION_RECORD exceptionRecord, PCONTEXT context);
		static NTSTATUS NTAPI OnWnfStateChange(WnfStateName, WnfChangeStamp, WnfTypeId*, PVOID, PVOID, ULONG);

		[[nodiscard]] bool InstallExceptionPreFilter();
		[[nodiscard]] bool SetupWnfSubscription();
		[[nodiscard]] bool SetHardwareBreakpoint(HANDLE thread, PVOID address);
		[[nodiscard]] bool ClearHardwareBreakpoint(HANDLE thread);
		void ArmAllThreads(PVOID address);
		void DisarmAllThreads();
		void CleanupWnfSubscription();
	};

}

```

`extensions/vehbutnot_ext/VehButNotExt.cpp`:

```cpp
#include "VehButNot.h"

#include "../../include/McpExtensionApi.h"

#include <nlohmann/json.hpp>

#include <format>
#include <iostream>
#include <memory>
#include <string>

using namespace std;

using namespace machinetherapist;

using json = nlohmann::json;

// Global instance to keep the engine alive
static unique_ptr<VehButNot> g_VehEngine = nullptr;

// This string is allocated and returned to the MCP server
static const char* AllocateResult(const json& result)
{
	string response = result.dump();
	char* buf = new char[response.size() + 1];
	strcpy_s(buf, response.size() + 1, response.c_str());
	return buf;
}

static void VehFreeResult(const char* resultStr)
{
	delete[] resultStr;
}

// Our custom interception handler for the Target API
static bool OnVehInterception(PVOID targetAddress, PCONTEXT ctx, PVOID userData)
{
	cerr << format("\n[VEHBUTNOT EXTENSION] Intercepted Execution at 0x{:016X}\n", reinterpret_cast<uintptr_t>(targetAddress));

	// Log registers to stderr (visible in MCP terminal)
	cerr << format("  RIP: 0x{:016X}\n", ctx->Rip);
	cerr << format("  RCX: 0x{:016X} (Arg 1)\n", ctx->Rcx);
	cerr << format("  RDX: 0x{:016X} (Arg 2)\n", ctx->Rdx);
	cerr << format("  R8:  0x{:016X} (Arg 3)\n", ctx->R8);
	cerr << format("  R9:  0x{:016X} (Arg 4)\n", ctx->R9);

	// Allow original function to execute
	return true;
}

// The Tool Handler: setups a hardware breakpoint hook on a specific API
static const char* VehInstallHookHandler(const char* jsonArgs)
{
	try {
		json args = json::parse(jsonArgs);
		string library = args.value("library", "ntdll.dll");
		string function = args.value("function", "NtReadVirtualMemory");

		HMODULE hModule = GetModuleHandleA(library.c_str());
		if (!hModule) {
			return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", "Failed to get module handle."}}})}});
		}

		PVOID targetApi = reinterpret_cast<PVOID>(GetProcAddress(hModule, function.c_str()));
		if (!targetApi) {
			return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", "Failed to get API address."}}})}});
		}

		if (g_VehEngine) {
			g_VehEngine->Shutdown();
			g_VehEngine.reset();
		}

		g_VehEngine = make_unique<VehButNot>();

		VehButNotConfig config{.targetApi = targetApi, .handler = OnVehInterception, .persistentHook = true, .enableDrHiding = true};

		if (!g_VehEngine->Initialize(config)) {
			return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", "VehButNot Init failed."}}})}});
		}

		if (!g_VehEngine->ArmViaWnf()) {
			return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", "VehButNot Arm failed."}}})}});
		}

		return AllocateResult(
			{{"content", json::array({{{"type", "text"}, {"text", format("Successfully installed VehButNot HWBP hook on {}!{}", library, function)}}})}});
	}
	catch (const exception& e) {
		return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", e.what()}}})}});
	}
}

static const char* VehShutdownHandler(const char* jsonArgs)
{
	if (g_VehEngine) {
		g_VehEngine->Shutdown();
		g_VehEngine.reset();
		return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", "VehButNot engine shut down."}}})}});
	}
	return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", "VehButNot engine not running."}}})}});
}

static const char* VehStatusHandler(const char* jsonArgs)
{
	if (g_VehEngine) {
		int count = g_VehEngine->GetInterceptionCount();
		return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", format("Active. Interceptions so far: {}", count)}}})}});
	}
	return AllocateResult({{"content", json::array({{{"type", "text"}, {"text", "Inactive."}}})}});
}

extern "C" __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api)
{
	if (!api || !api->registerTool)
		return false;

	// 1. Install Hook Tool
	McpToolRegistration t_install = {
		"ext_vehbutnot_install",
		"Installs a stealth hardware breakpoint hook on an API via VehButNot to intercept calls.",
		"1.0.0",
		R"({"type": "object", "properties": {"library": {"type": "string", "default": "ntdll.dll"}, "function": {"type": "string", "default": "NtReadVirtualMemory"}}, "required": ["library", "function"]})",
		VehInstallHookHandler,
		VehFreeResult, true}; // Mutes system flow
	api->registerTool(api->serverContext, &t_install);

	// 2. Status Tool
	McpToolRegistration t_status = {"ext_vehbutnot_status",
									"Checks if VehButNot is active and returns the interception count.",
									"1.0.0",
									R"({"type": "object", "properties": {}})",
									VehStatusHandler,
									VehFreeResult, false};
	api->registerTool(api->serverContext, &t_status);

	// 3. Shutdown Tool
	McpToolRegistration t_shutdown = {"ext_vehbutnot_shutdown",
									  "Removes the hardware breakpoints and shuts down VehButNot.",
									  "1.0.0",
									  R"({"type": "object", "properties": {}})",
									  VehShutdownHandler,
									  VehFreeResult, false};
	api->registerTool(api->serverContext, &t_shutdown);

	return true;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	return TRUE;
}

```

`include/McpExtensionApi.h`:

```h
#pragma once

// Pure C-API for ABI compatibility across different compilers
// This allows anyone to write an extension DLL in C, C++, Rust, Zig, etc.
#include <stdbool.h>
#ifdef __cplusplus
extern "C" {
#endif

// Function pointer for the extension's tool handler
// Takes a JSON string of arguments, returns a JSON string of results
typedef const char* (*ExtToolHandlerFn)(const char* jsonArgs);

// Function pointer to free the result string (since the DLL allocated it)
typedef void (*ExtFreeResultFn)(const char* resultStr);

// Structure passed back to the main MCP server to register a tool
struct McpToolRegistration {
	const char* name;
	const char* description;
	const char* version;
	const char* inputSchemaJson;
	ExtToolHandlerFn handler;
	ExtFreeResultFn freeResult;
	bool isDestructive; // Guardrail: does this tool mutate/harm system state?
};

// Callback provided to the DLL by the MCP Server
typedef void (*RegisterToolCallback)(void* serverContext, const struct McpToolRegistration* tool);

// The Core API structure given to the DLL when it initializes
struct McpServerApi {
	void* serverContext;
	RegisterToolCallback registerTool;
};

// =========================================================================
// REQUIRED EXPORT FOR DLLs
// Every extension DLL MUST export this function:
//
// __declspec(dllexport) bool InitMcpExtension(const McpServerApi* api);
// =========================================================================

typedef bool (*InitMcpExtensionFn)(const struct McpServerApi* api);

#ifdef __cplusplus
}
#endif

```

`include/McpServer.h`:

```h
#pragma once

#include <chrono>
#include <fstream>
#include <functional>
#include <nlohmann/json.hpp>
#include <string>
#include <unordered_map>
#include <vector>

namespace machinetherapist {

	using json = nlohmann::json;

	class McpServer {
	public:
		using ToolHandler = std::function<json(const json&)>;

		McpServer();
		~McpServer() = default;

		void Start();
		void Stop();

		void RegisterTool(const std::string& name, const std::string& description, const json& inputSchema, bool isDestructive, ToolHandler handler);
		void LoadExtensions(const std::string& directory);

	private:
		void HandleMessage(const json& message);
		void SendResponse(const json& id, const json& result);
		void SendError(const json& id, int code, const std::string& message);
		void SendNotification(const std::string& method, const json& params);

		struct ToolInfo {
			std::string name;
			std::string description;
			json inputSchema;
			bool isDestructive;
			ToolHandler handler;
		};

		std::unordered_map<std::string, ToolInfo> _tools;
		std::vector<void*> _loadedModules; // HMODULEs
		bool _running = false;
		bool _readOnlyMode = false; // Guardrail flag

		struct RateLimitState {
			int callsInWindow = 0;
			std::chrono::steady_clock::time_point windowStart;
			std::chrono::steady_clock::time_point lockoutEnd;
		};
		RateLimitState _rateLimit;
		std::ofstream _auditLog;
	};

} // namespace machinetherapist

```

`src/Main.cpp`:

```cpp
#include "McpServer.h"

#include <iostream>
#include <filesystem>

#include <fcntl.h>
#include <io.h>

#include <windows.h>

using namespace std;

using namespace machinetherapist;

int main(int argc, char* argv[])
{
#ifdef _WIN32
	_setmode(_fileno(stdin), _O_BINARY);
	_setmode(_fileno(stdout), _O_BINARY);
	_setmode(_fileno(stderr), _O_BINARY);
#endif

	McpServer server;

	cerr << "[*] ProcessHacker MCP router started\n";

	WCHAR exePath[MAX_PATH];
	GetModuleFileNameW(nullptr, exePath, MAX_PATH);
	filesystem::path basePath = filesystem::path(exePath).parent_path();
	filesystem::path extPath = basePath / "extensions";

	server.LoadExtensions(extPath.string());

	server.Start();

	return 0;
}

```

`src/McpServer.cpp`:

```cpp
#include "McpServer.h"
#include "McpExtensionApi.h"

#include <filesystem>
#include <format>
#include <iostream>
#include <vector>
#include <algorithm>

#include <ctime>

#include <windows.h>

using namespace std;
namespace fs = filesystem;

namespace machinetherapist {

	McpServer::McpServer()
	{
		_auditLog.open("processhacker_audit.log", ios::app);
		_rateLimit.windowStart = chrono::steady_clock::now();
		_rateLimit.lockoutEnd = chrono::steady_clock::now();
	}

	void McpServer::RegisterTool(const string& name, const string& description, const json& inputSchema, bool isDestructive, ToolHandler handler)
	{
		_tools[name] = {name, description, inputSchema, isDestructive, move(handler)};
	}

	static void ExtensionRegisterToolCallback(void* serverContext, const McpToolRegistration* extTool)
	{
		auto* server = static_cast<McpServer*>(serverContext);

		string name = extTool->name ? extTool->name : "";
		string desc = extTool->description ? extTool->description : "";
		string version = extTool->version ? extTool->version : "1.0.0";

		string fullDesc = format("[v{}] {}", version, desc);

		json schema = json::object();
		if (extTool->inputSchemaJson) {
			try {
				schema = json::parse(extTool->inputSchemaJson);
			}
			catch (...) {
			}
		}

		auto handlerFn = extTool->handler;
		auto freeFn = extTool->freeResult;
		bool isDestructive = extTool->isDestructive;

		server->RegisterTool(name, fullDesc, schema, isDestructive, [handlerFn, freeFn](const json& args) -> json {
			if (!handlerFn) {
				return {{"content", json::array({{{"type", "text"}, {"text", "Missing handler"}}})}};
			}

			string argsStr = args.dump();
			const char* resultCStr = handlerFn(argsStr.c_str());

			json finalResult = json::object();
			if (resultCStr) {
				try {
					finalResult = json::parse(resultCStr);
				}
				catch (...) {
					finalResult = {{"content", json::array({{{"type", "text"}, {"text", resultCStr}}})}};
				}
				if (freeFn) {
					freeFn(resultCStr);
				}
			}
			else {
				finalResult = {{"content", json::array({{{"type", "text"}, {"text", "Extension returned null"}}})}};
			}

			return finalResult;
		});
	}

	void McpServer::LoadExtensions(const string& directory)
	{
		if (!fs::exists(directory)) {
			return;
		}

		McpServerApi api{};
		api.serverContext = this;
		api.registerTool = ExtensionRegisterToolCallback;

		for (const auto& entry : fs::directory_iterator(directory)) {
			if (!entry.is_regular_file() || entry.path().extension() != ".dll") {
				continue;
			}
			HMODULE hMod = LoadLibraryW(entry.path().c_str());
			if (!hMod) {
				cerr << "[!] Failed to load DLL: " << entry.path().filename().string() << "\n";
				continue;
			}
			auto initExt = reinterpret_cast<InitMcpExtensionFn>(GetProcAddress(hMod, "InitMcpExtension"));
			if (!initExt) {
				cerr << "[-] Missing InitMcpExtension export in: " << entry.path().filename().string() << "\n";
				FreeLibrary(hMod);
				continue;
			}
			if (initExt(&api)) {
				_loadedModules.push_back(hMod);
				cerr << "[+] Loaded Stealth Extension: " << entry.path().filename().string() << "\n";
			}
			else {
				cerr << "[-] Extension initialization failed: " << entry.path().filename().string() << "\n";
				FreeLibrary(hMod);
			}
		}
	}

	void McpServer::Start()
	{
		// Parse read-only mode from command line (naive check for now, args can be passed to constructor later if needed)
		int argc = __argc;
		char** argv = __argv;
		if (any_of(argv + 1, argv + argc, [](const char* arg) { return string(arg) == "--read-only"; })) {
			_readOnlyMode = true;
			cerr << "[!] Guardrails ACTIVE: Read-only mode enabled. Destructive tools are blocked.\n";
		}

		_running = true;
		string line;

		while (_running && getline(cin, line)) {
			if (line.empty()) {
				continue;
			}

			try {
				auto message = json::parse(line);
				HandleMessage(message);
			}
			catch (const exception& e) {
				cerr << "[!] JSON parse error: " << e.what() << "\n";
				SendError(json(nullptr), -32700, "Parse error");
			}
		}
	}

	void McpServer::Stop()
	{
		_running = false;
	}

	void McpServer::HandleMessage(const json& message)
	{
		if (!message.contains("jsonrpc") || message["jsonrpc"] != "2.0") {
			SendError(message.contains("id") ? message["id"] : json(nullptr), -32600, "Invalid Request");
			return;
		}

		string method = message.value("method", "");
		json id = message.value("id", json(nullptr));
		json params = message.value("params", json::object());

		if (method == "initialize") {
			json result = {{"protocolVersion", "2024-11-05"},
						   {"capabilities", {{"tools", json::object()}}},
						   {"serverInfo", {{"name", "machinetherapist-processhacker"}, {"version", "1.0.0"}}}};
			SendResponse(id, result);
		}
		else if (method == "notifications/initialized") {
			cerr << "[+] MCP Server Initialized\n";
		}
		else if (method == "tools/list") {
			json toolsArray = json::array();
			for (const auto& [name, info] : _tools) {
				toolsArray.push_back({{"name", info.name}, {"description", info.description}, {"inputSchema", info.inputSchema}});
			}
			SendResponse(id, {{"tools", toolsArray}});
		}
		else if (method == "tools/call") {
			string name = params.value("name", "");
			json arguments = params.value("arguments", json::object());

			if (_tools.contains(name)) {
				// 1. Loop Breaker (Rate Limiting) Check
				auto now = chrono::steady_clock::now();
				if (now < _rateLimit.lockoutEnd) {
					auto remaining = chrono::duration_cast<chrono::seconds>(_rateLimit.lockoutEnd - now).count();
					string msg = format("Guardrail Violation: AI Rate Limit active. You are making too many requests (loop breaker). Wait {} seconds. Hint: Write a C++ DLL extension for heavy operations instead of brute-forcing via JSON-RPC.", remaining);
					SendResponse(id, {{"content", json::array({{{"type", "text"}, {"text", msg}}})}, {"isError", true}});
					return;
				}

				if (chrono::duration_cast<chrono::seconds>(now - _rateLimit.windowStart).count() > 60) {
					_rateLimit.callsInWindow = 0;
					_rateLimit.windowStart = now;
				}

				_rateLimit.callsInWindow++;

				if (_rateLimit.callsInWindow > 50) { // 50 requests per minute limit
					_rateLimit.lockoutEnd = now + chrono::seconds(30); // 30s timeout
					string msg = "Guardrail Violation: AI Rate Limit triggered (> 50 calls/min). Brute-forcing memory is blocked to save tokens and prevent crashes. System locked for 30 seconds. Write an extension.";
					SendResponse(id, {{"content", json::array({{{"type", "text"}, {"text", msg}}})}, {"isError", true}});
					return;
				}

				// 2. Audit Logging
				if (_auditLog.is_open()) {
					auto t = time(nullptr);
					char timebuf[100];
					if (strftime(timebuf, sizeof(timebuf), "%Y-%m-%d %H:%M:%S", localtime(&t))) {
						_auditLog << "[" << timebuf << "] ";
						if (_tools[name].isDestructive) _auditLog << "[WARNING: DESTRUCTIVE] ";
						_auditLog << "Tool: " << name << " | Args: " << arguments.dump() << endl;
					}
				}

				// 3. Read-Only Guardrail Check
				if (_readOnlyMode && _tools[name].isDestructive) {
					json errorResult = {
						{"content", json::array({{{"type", "text"}, {"text", "Guardrail Violation: This server is running in --read-only mode. Destructive actions like suspending threads or writing memory are blocked."}}})},
						{"isError", true}};
					cerr << "[-] Blocked destructive tool call: " << name << " (Read-only mode)\n";
					SendResponse(id, errorResult);
					return;
				}

				try {
					// Telemetry (Tracing) Start
					auto startTime = chrono::high_resolution_clock::now();
					
					json result = _tools[name].handler(arguments);
					
					// Telemetry (Tracing) End
					auto endTime = chrono::high_resolution_clock::now();
					auto durationMs = chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count();
					
					cerr << "[Trace] Tool '" << name << "' executed in " << durationMs << "ms.\n";

					SendResponse(id, result);
				}
				catch (const exception& e) {
					json errorResult = {{"content", json::array({{{"type", "text"}, {"text", format("Error executing tool: {}", e.what())}}})},
										{"isError", true}};
					SendResponse(id, errorResult);
				}
			}
			else {
				SendError(id, -32601, "Method not found");
			}
		}
		else if (!id.is_null()) {
			SendError(id, -32601, "Method not found");
		}
	}

	void McpServer::SendResponse(const json& id, const json& result)
	{
		if (id.is_null()) {
			return;
		}

		json response = {{"jsonrpc", "2.0"}, {"id", id}, {"result", result}};
		string responseStr = response.dump();

		// Prevent massive payloads from crashing the client (e.g. LLM context / editor OOM)
		// Limit set to 2 MB (2 * 1024 * 1024 bytes)
		const size_t MAX_PAYLOAD_SIZE = 2 * 1024 * 1024;

		if (responseStr.length() > MAX_PAYLOAD_SIZE) {
			cerr << "[-] Response payload too large: " << responseStr.length() << " bytes. Blocking to prevent client crash.\n";
			
			// Try to send a clean error response instead
			SendError(id, -32603, format("Response payload too large ({} bytes). Maximum allowed is {} bytes. Please narrow down your request (e.g., using smaller limit/size parameters).", responseStr.length(), MAX_PAYLOAD_SIZE));
			return;
		}

		cout << responseStr << "\n" << flush;
	}

	void McpServer::SendError(const json& id, int code, const string& message)
	{
		if (id.is_null()) {
			return;
		}

		json error = {{"jsonrpc", "2.0"}, {"id", id}, {"error", {{"code", code}, {"message", message}}}};
		cout << error.dump() << "\n" << flush;
	}

	void McpServer::SendNotification(const string& method, const json& params)
	{
		json notification = {{"jsonrpc", "2.0"}, {"method", method}, {"params", params}};
		cout << notification.dump() << "\n" << flush;
	}

} // namespace machinetherapist

```

`wrapper.bat`:

```bat
@echo off
set LOGFILE=C:\Users\machi\Desktop\lab\ProcessHackerMCP\mcp_debug.log
echo [WRAPPER START] %DATE% %TIME% >> %LOGFILE%

REM Pipe stdin to the exe, and tee stdout and stderr to the log
C:\Users\machi\Desktop\lab\ProcessHackerMCP\build\ProcessHackerMCP.exe >> %LOGFILE% 2>&1

```