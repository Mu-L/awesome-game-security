Project Path: arc_guided-hacking_GH_D3D11_Hook_sws3vc23

Source Tree:

```txt
arc_guided-hacking_GH_D3D11_Hook_sws3vc23
├── GH_D3D11_Hook
│   ├── D3D_VMT_Indices.h
│   ├── DllMain.cpp
│   ├── GH_D3D11_Hook.vcxproj
│   ├── GH_D3D11_Hook.vcxproj.filters
│   └── shadez.h
├── GH_D3D11_Hook.sln
├── README.md
└── ss.png

```

`GH_D3D11_Hook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GH_D3D11_Hook", "GH_D3D11_Hook\GH_D3D11_Hook.vcxproj", "{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}.Debug|x64.ActiveCfg = Debug|x64
		{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}.Debug|x64.Build.0 = Debug|x64
		{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}.Debug|x86.ActiveCfg = Debug|Win32
		{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}.Debug|x86.Build.0 = Debug|Win32
		{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}.Release|x64.ActiveCfg = Release|x64
		{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}.Release|x64.Build.0 = Release|x64
		{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}.Release|x86.ActiveCfg = Release|Win32
		{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F249AAB7-C986-4D42-8ACF-B0BE37FD2DD7}
	EndGlobalSection
EndGlobal

```

`GH_D3D11_Hook/D3D_VMT_Indices.h`:

```h
#pragma once

enum class IDXGISwapChainVMT {
	QueryInterface,
	AddRef,
	Release,
	SetPrivateData,
	SetPrivateDataInterface,
	GetPrivateData,
	GetParent,
	GetDevice,
	Present,
	GetBuffer,
	SetFullscreenState,
	GetFullscreenState,
	GetDesc,
	ResizeBuffers,
	ResizeTarget,
	GetContainingOutput,
	GetFrameStatistics,
	GetLastPresentCount,
};

enum class ID3D11DeviceVMT {
	QueryInterface,
	AddRef,
	Release,
	CreateVideoDecoder,
	CreateVideoProcessor,
	CreateAuthenticatedChannel,
	CreateCryptoSession,
	CreateVideoDecoderOutputView,
	CreateVideoProcessorInputView,
	CreateVideoProcessorOutputView,
	CreateVideoProcessorEnumerator,
	GetVideoDecoderProfileCount,
	GetVideoDecoderProfile,
	CheckVideoDecoderFormat,
	GetVideoDecoderConfigCount,
	GetVideoDecoderConfig,
	GetContentProtectionCaps,
	CheckCryptoKeyExchange,
	SetPrivateData,
	SetPrivateDataInterface,
};

enum class ID3D11DeviceContextVMT {
	QueryInterface,
	AddRef,
	Release,
	GetDevice,
	GetPrivateData,
	SetPrivateData,
	SetPrivateDataInterface,
	VSSetConstantBuffers,
	PSSetShaderResources,
	PSSetShader,
	PSSetSamplers,
	VSSetShader,
	DrawIndexed,
	Draw,
	Map,
	Unmap,
	PSSetConstantBuffers,
	IASetInputLayout,
	IASetVertexBuffers,
	IASetIndexBuffer,
	DrawIndexedInstanced,
	DrawInstanced,
	GSSetConstantBuffers,
	GSSetShader,
	IASetPrimitiveTopology,
	VSSetShaderResources,
	VSSetSamplers,
	Begin,
	End,
	GetData,
	SetPredication,
	GSSetShaderResources,
	GSSetSamplers,
	OMSetRenderTargets,
	OMSetRenderTargetsAndUnorderedAccessViews,
	OMSetBlendState,
	OMSetDepthStencilState,
	SOSetTargets,
	DrawAuto,
	DrawIndexedInstancedIndirect,
	DrawInstancedIndirect,
	Dispatch,
	DispatchIndirect,
	RSSetState,
	RSSetViewports,
	RSSetScissorRects,
	CopySubresourceRegion,
	CopyResource,
	UpdateSubresource,
	CopyStructureCount,
	ClearRenderTargetView,
	ClearUnorderedAccessViewUint,
	ClearUnorderedAccessViewFloat,
	ClearDepthStencilView,
	GenerateMips,
	SetResourceMinLOD,
	GetResourceMinLOD,
	ResolveSubresource,
	ExecuteCommandList,
	HSSetShaderResources,
	HSSetShader,
	HSSetSamplers,
	HSSetConstantBuffers,
	DSSetShaderResources,
	DSSetShader,
	DSSetSamplers,
	DSSetConstantBuffers,
	CSSetShaderResources,
	CSSetUnorderedAccessViews,
	CSSetShader,
	CSSetSamplers,
	CSSetConstantBuffers,
	VSGetConstantBuffers,
	PSGetShaderResources,
	PSGetShader,
	PSGetSamplers,
	VSGetShader,
	PSGetConstantBuffers,
	IAGetInputLayout,
	IAGetVertexBuffers,
	IAGetIndexBuffer,
	GSGetConstantBuffers,
	GSGetShader,
	IAGetPrimitiveTopology,
	VSGetShaderResources,
	VSGetSamplers,
	GetPredication,
	GSGetShaderResources,
	GSGetSamplers,
	OMGetRenderTargets,
	OMGetRenderTargetsAndUnorderedAccessViews,
	OMGetBlendState,
	OMGetDepthStencilState,
	SOGetTargets,
	RSGetState,
	RSGetViewports,
	RSGetScissorRects,
	HSGetShaderResources,
	HSGetShader,
	HSGetSamplers,
	HSGetConstantBuffers,
	DSGetShaderResources,
	DSGetShader,
	DSGetSamplers,
	DSGetConstantBuffers,
	CSGetShaderResources,
	CSGetUnorderedAccessViews,
	CSGetShader,
	CSGetSamplers,
	CSGetConstantBuffers,
	ClearState,
	Flush,
	GetType,
	GetContextFlags,
	FinishCommandList,
};
```

`GH_D3D11_Hook/DllMain.cpp`:

```cpp
#include <Windows.h>
#include <d3d11.h>
#include <d3dcompiler.h>
#include <DirectXMath.h>
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d3dcompiler.lib")

#define safe_release(p) if (p) { p->Release(); p = nullptr; } 

#include "shadez.h"
#include "D3D_VMT_Indices.h"
#define VMT_PRESENT (UINT)IDXGISwapChainVMT::Present
#define PRESENT_STUB_SIZE 5

// d3d11 related object ptrs
using namespace DirectX;

ID3D11Device* pDevice = nullptr;
IDXGISwapChain* pSwapchain = nullptr;
ID3D11DeviceContext* pContext = nullptr;
ID3D11RenderTargetView* pRenderTargetView = nullptr;
ID3D11VertexShader* pVertexShader = nullptr;
ID3D11InputLayout* pVertexLayout = nullptr;
ID3D11PixelShader* pPixelShader = nullptr;
ID3D11Buffer* pVertexBuffer = nullptr;
ID3D11Buffer* pIndexBuffer = nullptr;
ID3D11Buffer* pConstantBuffer = nullptr;

// Changing this to an array of viewports
#define MAINVP 0
D3D11_VIEWPORT pViewports[D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE]{ 0 };
XMMATRIX mOrtho;

struct ConstantBuffer
{
	XMMATRIX mProjection;
};

struct Vertex
{
	XMFLOAT3 pos;
	XMFLOAT4 color;
};

HRESULT __stdcall hkPresent( IDXGISwapChain* pThis, UINT SyncInterval, UINT Flags );
using fnPresent = HRESULT( __stdcall* )(IDXGISwapChain* pThis, UINT SyncInterval, UINT Flags);
void* ogPresent;					// Pointer to the original Present function
fnPresent ogPresentTramp;			// Function pointer that calls the Present stub in our trampoline
void* pTrampoline = nullptr;		// Pointer to jmp instruction in our trampoline that leads to hkPresent
char ogBytes[PRESENT_STUB_SIZE];	// Buffer to store original bytes from Present

bool Hook( void* pSrc, void* pDst, size_t size );
bool WriteMem( void* pDst, char* pBytes, size_t size );
bool HookD3D();
bool CompileShader( const char* szShader, const char * szEntrypoint, const char * szTarget, ID3D10Blob ** pBlob );
bool InitD3DHook( IDXGISwapChain* pSwapchain );
void CleanupD3D();
void Render();

// adding this code ripped off SO to find the "main window" as a fallback to RSGetViewports
struct HandleData
{
	DWORD pid;
	HWND hWnd;
};
HWND FindMainWindow( DWORD dwPID );
BOOL CALLBACK EnumWindowsCallback( HWND hWnd, LPARAM lParam );

void MainThread( void* pHandle )
{
	// Hook d3d
	if (HookD3D())
	{
		// END key to unload
		while (!GetAsyncKeyState( VK_END ));
	}

	// Cleanup and unload dll
	CleanupD3D();
	WriteMem( ogPresent, ogBytes, PRESENT_STUB_SIZE );
	VirtualFree( (void*)ogPresentTramp, 0x1000, MEM_RELEASE );
	CreateThread( 0, 0, (LPTHREAD_START_ROUTINE)FreeLibrary, pHandle, 0, 0 );
}

BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved )
{
	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls( hinstDLL );
			CreateThread( nullptr, 0, (LPTHREAD_START_ROUTINE)MainThread, hinstDLL, 0, nullptr );
			break;
		case DLL_PROCESS_DETACH:

			break;
	}
	return TRUE;
}

bool Hook( void* pSrc, void* pDst, size_t size )
{
	DWORD dwOld;
	uintptr_t src = (uintptr_t)pSrc;
	uintptr_t dst = (uintptr_t)pDst;

	if (!VirtualProtect( pSrc, size, PAGE_EXECUTE_READWRITE, &dwOld ))
		return false;

	*(char*)src = (char)0xE9;
	*(int*)(src + 1) = (int)(dst - src - 5);

	VirtualProtect( pSrc, size, dwOld, &dwOld );
	return true;
}

bool WriteMem( void* pDst, char* pBytes, size_t size )
{
	DWORD dwOld;
	if (!VirtualProtect( pDst, size, PAGE_EXECUTE_READWRITE, &dwOld ))
		return false;

	memcpy( pDst, pBytes, PRESENT_STUB_SIZE );

	VirtualProtect( pDst, size, dwOld, &dwOld );
	return true;
}

bool HookD3D()
{
	// Create a dummy device, get swapchain vmt, hook present.
	D3D_FEATURE_LEVEL featLevel;
	DXGI_SWAP_CHAIN_DESC sd{ 0 };
	sd.BufferCount = 1;
	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	sd.BufferDesc.Height = 800;
	sd.BufferDesc.Width = 600;
	sd.BufferDesc.RefreshRate = { 60, 1 };
	sd.OutputWindow = GetForegroundWindow();
	sd.Windowed = TRUE;
	sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
	sd.SampleDesc.Count = 1;
	sd.SampleDesc.Quality = 0;
	HRESULT hr = D3D11CreateDeviceAndSwapChain( nullptr, D3D_DRIVER_TYPE_REFERENCE, nullptr, 0, nullptr, 0, D3D11_SDK_VERSION, &sd, &pSwapchain, &pDevice, &featLevel, nullptr );
	if (FAILED( hr )) 
		return false;

	// Get swapchain vmt
	void** pVMT = *(void***)pSwapchain;
	
	// Get Present's address out of vmt
	ogPresent = (fnPresent)(pVMT[VMT_PRESENT]);

	// got what we need, we can release device and swapchain now
	// we'll be stealing the game's.
	safe_release( pSwapchain );
	safe_release( pDevice );

	// Create a code cave to trampoline to our hook
	// We'll try to do this close to present to make sure we'll be able to use a 5 byte jmp (important for x64)
	void* pLoc = (void*)((uintptr_t)ogPresent - 0x2000);
	void* pTrampLoc = nullptr;
	while (!pTrampLoc)
	{
		pTrampLoc = VirtualAlloc( pLoc, 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
		pLoc = (void*)((uintptr_t)pLoc + 0x200);
	}
	ogPresentTramp = (fnPresent)pTrampLoc;

	// write original bytes to trampoline
	// write jmp to hook
	memcpy( ogBytes, ogPresent, PRESENT_STUB_SIZE );
	memcpy( pTrampLoc, ogBytes, PRESENT_STUB_SIZE );
	
	pTrampLoc = (void*)((uintptr_t)pTrampLoc + PRESENT_STUB_SIZE);
	
	// write the jmp back into present
	*(char*)pTrampLoc = (char)0xE9;
	pTrampLoc = (void*)((uintptr_t)pTrampLoc + 1);
	uintptr_t ogPresRet = (uintptr_t)ogPresent + 5;
	*(int*)pTrampLoc = (int)(ogPresRet - (uintptr_t)pTrampLoc - 4);
	
	// write the jmp to our hook
	pTrampoline = pTrampLoc = (void*)((uintptr_t)pTrampLoc + 4);
#ifdef _WIN64
	// if x64, gazzillion byte absolute jmp
	char pJmp[] = { 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 };
	WriteMem( pTrampLoc, pJmp, ARRAYSIZE( pJmp ) );
	pTrampLoc = (void*)((uintptr_t)pTrampLoc + ARRAYSIZE( pJmp ));
	*(uintptr_t*)pTrampLoc = (uintptr_t)hkPresent;
#else
	// if x86, normal 0xE9 jmp
	*(char*)pTrampLoc = (char)0xE9;
	pTrampLoc = (void*)((uintptr_t)pTrampLoc + 1);
	*(int*)pTrampLoc = (uintptr_t)hkPresent - (uintptr_t)pTrampLoc - 4;
#endif

	// hook present, place a normal mid-function at the beginning of the Present function
	return Hook(ogPresent, pTrampoline, PRESENT_STUB_SIZE);
}

bool CompileShader( const char* szShader, const char * szEntrypoint, const char * szTarget, ID3D10Blob ** pBlob )
{
	ID3D10Blob* pErrorBlob = nullptr;

	auto hr = D3DCompile( szShader, strlen( szShader ), 0, nullptr, nullptr, szEntrypoint, szTarget, D3DCOMPILE_ENABLE_STRICTNESS, 0, pBlob, &pErrorBlob );
	if (FAILED( hr ))
	{
		if (pErrorBlob)
		{
			char szError[256]{ 0 };
			memcpy( szError, pErrorBlob->GetBufferPointer(), pErrorBlob->GetBufferSize() );
			MessageBoxA( nullptr, szError, "Error", MB_OK );
		}
		return false;
	}
	return true;
}

bool InitD3DHook( IDXGISwapChain * pSwapchain )
{
	HRESULT hr = pSwapchain->GetDevice( __uuidof(ID3D11Device), (void**)&pDevice );
	if (FAILED( hr ))
		return false;

	pDevice->GetImmediateContext( &pContext );
	pContext->OMGetRenderTargets( 1, &pRenderTargetView, nullptr );

	// If for some reason we fail to get a render target, create one.
	// This will probably never happen with a real game but maybe certain test environments... :P
	if (!pRenderTargetView)
	{
		// Get a pointer to the back buffer for the render target view
		ID3D11Texture2D* pBackbuffer = nullptr;
		hr = pSwapchain->GetBuffer( 0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&pBackbuffer) );
		if (FAILED( hr ))
			return false;

		// Create render target view
		hr = pDevice->CreateRenderTargetView( pBackbuffer, nullptr, &pRenderTargetView );
		pBackbuffer->Release();
		if (FAILED( hr ))
			return false;

		// Make sure our render target is set.
		pContext->OMSetRenderTargets( 1, &pRenderTargetView, nullptr );
	}
	
	// initialize shaders
	ID3D10Blob* pBlob = nullptr;

	// create vertex shader
	if (!CompileShader( szShadez, "VS", "vs_5_0", &pBlob ))
		return false;

	hr = pDevice->CreateVertexShader( pBlob->GetBufferPointer(), pBlob->GetBufferSize(), nullptr, &pVertexShader );
	if (FAILED( hr ))
		return false;

	// Define/create the input layout for the vertex shader
	D3D11_INPUT_ELEMENT_DESC layout[2] = {
	{"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
	{"COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0}
	};
	UINT numElements = ARRAYSIZE( layout );

	hr = pDevice->CreateInputLayout( layout, numElements, pBlob->GetBufferPointer(), pBlob->GetBufferSize(), &pVertexLayout );
	if (FAILED( hr ))
		return false;

	safe_release( pBlob );

	// create pixel shader
	if (!CompileShader( szShadez, "PS", "ps_5_0", &pBlob ))
		return false;

	hr = pDevice->CreatePixelShader( pBlob->GetBufferPointer(), pBlob->GetBufferSize(), nullptr, &pPixelShader );
	if (FAILED( hr ))
		return false;

	UINT numViewports = D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;
	float fWidth =  0;
	float fHeight = 0;

	// Apparently this isn't universal. Works on some games
	pContext->RSGetViewports( &numViewports, pViewports );
	
	//
	if (!numViewports || !pViewports[MAINVP].Width)
	{
		// This should be retrieved dynamically
		//HWND hWnd0 = FindWindowA( "W2ViewportClass", nullptr );
		HWND hWnd = FindMainWindow( GetCurrentProcessId() );
		RECT rc{ 0 };
		if (!GetClientRect( hWnd, &rc ))
			return false;

		//fWidth = 1600.0f;
		//fHeight = 900.0f;
		fWidth = (float)rc.right;
		fHeight = (float)rc.bottom;

		// Setup viewport
		pViewports[MAINVP].Width = (float)fWidth;
		pViewports[MAINVP].Height = (float)fHeight;
		pViewports[MAINVP].MinDepth = 0.0f;
		pViewports[MAINVP].MaxDepth = 1.0f;

		// Set viewport to context
		pContext->RSSetViewports( 1, pViewports );
	}
	else
	{
		fWidth = (float)pViewports[MAINVP].Width;
		fHeight = (float)pViewports[MAINVP].Height;
	}
	// Create the constant buffer
	D3D11_BUFFER_DESC bd{ 0 };
	bd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	bd.ByteWidth = sizeof( ConstantBuffer );
	bd.Usage = D3D11_USAGE_DEFAULT;
	
	// Setup orthographic projection
	mOrtho = XMMatrixOrthographicLH( fWidth, fHeight, 0.0f, 1.0f );
	ConstantBuffer cb;
	cb.mProjection = mOrtho;
	
	D3D11_SUBRESOURCE_DATA sr{ 0 };
	sr.pSysMem = &cb;
	hr = pDevice->CreateBuffer( &bd, &sr, &pConstantBuffer );
	if (FAILED( hr ))
		return false;

	// Create a triangle to render
	// Create a vertex buffer, start by setting up a description.
	ZeroMemory( &bd, sizeof( bd ) );
	bd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	bd.Usage = D3D11_USAGE_DEFAULT;
	bd.ByteWidth = 3 * sizeof( Vertex );
	bd.StructureByteStride = sizeof( Vertex );

	// left and top edge of window
	float left = fWidth / -2;
	float top = fHeight / 2;

	// Width and height of triangle
	float w = 50;
	float h = 50;
	
	// Center position of triangle, this should center it in the screen.
	float fPosX = -1 * left;
	float fPosY = top;

	// Setup vertices of triangle
	Vertex pVerts[3] = {
		{ XMFLOAT3( left + fPosX,			top - fPosY + h / 2,	1.0f ),	XMFLOAT4( 1.0f, 0.0f, 0.0f, 1.0f ) },
		{ XMFLOAT3( left + fPosX + w / 2,	top - fPosY - h / 2,	1.0f ),	XMFLOAT4( 0.0f, 0.0f, 1.0f, 1.0f ) },
		{ XMFLOAT3( left + fPosX - w / 2,	top - fPosY - h / 2,	1.0f ),	XMFLOAT4( 0.0f, 1.0f, 0.0f, 1.0f ) },
	};	  

	// create the buffer.
	ZeroMemory( &sr, sizeof( sr ) );
	sr.pSysMem = &pVerts;
	hr = pDevice->CreateBuffer( &bd, &sr, &pVertexBuffer );
	if (FAILED( hr ))
		return false;

	// Create an index buffer
	ZeroMemory( &bd, sizeof( bd ) );
	ZeroMemory( &sr, sizeof( sr ) );

	UINT pIndices[3] = { 0, 1, 2 };
	bd.BindFlags = D3D11_BIND_INDEX_BUFFER;
	bd.Usage = D3D11_USAGE_DEFAULT;
	bd.ByteWidth = sizeof( UINT ) * 3;
	bd.StructureByteStride = sizeof( UINT );

	sr.pSysMem = &pIndices;
	hr = pDevice->CreateBuffer( &bd, &sr, &pIndexBuffer );
	if (FAILED( hr ))
		return false;

	return true;
}

void CleanupD3D()
{
	safe_release( pVertexBuffer );
	safe_release( pIndexBuffer );
	safe_release( pConstantBuffer );
	safe_release( pPixelShader );
	safe_release( pVertexShader );
	safe_release( pVertexLayout );
}

void Render()
{	
	// Make sure our render target is set.
	pContext->OMSetRenderTargets( 1, &pRenderTargetView, nullptr );

	// Update view
	ConstantBuffer cb;
	cb.mProjection = XMMatrixTranspose( mOrtho );
	pContext->UpdateSubresource( pConstantBuffer, 0, nullptr, &cb, 0, 0 );
	pContext->VSSetConstantBuffers( 0, 1, &pConstantBuffer );

	// Make sure the input assembler knows how to process our verts/indices
	UINT stride = sizeof( Vertex );
	UINT offset = 0;
	pContext->IASetVertexBuffers( 0, 1, &pVertexBuffer, &stride, &offset );
	pContext->IASetInputLayout( pVertexLayout );
	pContext->IASetIndexBuffer( pIndexBuffer, DXGI_FORMAT_R32_UINT, 0 );
	pContext->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST );
	
	// Set the shaders we need to render our triangle
	pContext->VSSetShader( pVertexShader, nullptr, 0 );
	pContext->PSSetShader( pPixelShader, nullptr, 0 );

	// Set viewport to context
	pContext->RSSetViewports( 1, pViewports );

	// Draw our triangle
	pContext->DrawIndexed( 3, 0, 0 );
}

HRESULT __stdcall hkPresent( IDXGISwapChain * pThis, UINT SyncInterval, UINT Flags )
{
	pSwapchain = pThis;

	if (!pDevice)
	{
		if (!InitD3DHook( pThis ))
			return false;
	}

	Render();
	return ogPresentTramp( pThis, SyncInterval, Flags );
}

HWND FindMainWindow( DWORD dwPID )
{
	HandleData handleData{ 0 };
	handleData.pid = dwPID;
	EnumWindows( EnumWindowsCallback, (LPARAM)&handleData );
	return handleData.hWnd;
}

BOOL CALLBACK EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	HandleData& data = *(HandleData*)lParam;
	DWORD pid = 0;
	GetWindowThreadProcessId( hWnd, &pid );
	if (pid == data.pid && GetWindow( hWnd, GW_OWNER ) == HWND( 0 ) && IsWindowVisible( hWnd ))
	{
		data.hWnd = hWnd;
		return FALSE;
	}

	return TRUE;
}
```

`GH_D3D11_Hook/GH_D3D11_Hook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{A8FB3836-0DEF-44D2-9E70-F4BA3360E43F}</ProjectGuid>
    <RootNamespace>GHD3D11Hook</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="DllMain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="D3D_VMT_Indices.h" />
    <ClInclude Include="shadez.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GH_D3D11_Hook/GH_D3D11_Hook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DllMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="D3D_VMT_Indices.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="shadez.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`GH_D3D11_Hook/shadez.h`:

```h
#pragma once

constexpr const char* szShadez = R"(
// Constant buffer
cbuffer ConstantBuffer : register(b0)
{
	matrix projection;
}

// PSI (PixelShaderInput)
struct PSI
{
	float4 pos : SV_POSITION;
	float4 color : COLOR;
};

// VertexShader
PSI VS( float4 pos : POSITION, float4 color : COLOR )
{
	PSI psi;
	psi.color = color;
	pos = mul( pos, projection );
	psi.pos = pos;
	return psi;
}

// PixelShader
float4 PS(PSI psi) : SV_TARGET
{
	return psi.color;
}
)";
```

`README.md`:

```md
# GH D3D11 Hook

Barebones D3D11 hook.
x86/x64 Compatible

![screenshot](https://github.com/guided-hacking/GH_D3D11_Hook/blob/master/ss.png "FarCry5 Example")

[BareBones D3D11 Hook Thread on GH](https://guidedhacking.com/threads/d3d11-barebones-hook-poc.11939/)

This is about the simplest example I could create for hooking DirectX 11.
The code is heavily commented and doesn't rely on any external libraries.
As long as you have a recent version of the Windows SDK then this code should run.

The example is a DLL that you inject into a game using DirectX 11 and it should render a triangle in the top left corner of the screen.

The code creates a dummy device and swapchain to get the address of Present out of the dummy swapchain's virtual method table. Then we create a simple trampoline hook to detour Present and render our triangle.

While the code isn't extremely elegant, it's not meant to be.
This is just a simple PoC to demonstrate one way, a fairly decent way imo, of hooking
direct3d 11 and rendering our own simple geometry.

This project is a Direct3D 11 hook, which is essentially a way to intercept and manipulate the rendering of 3D graphics in a game or other 3D application. This is a powerful tool for game modding, reverse engineering, and cheat development.

Features
--------

The GH_D3D11_Hook project provides the following features:

1.  DirectX Hooking: This project uses a technique known as "hooking" to intercept the DirectX 11 API calls, allowing you to manipulate the rendering process.

2.  Shader Compilation: The project includes functionality for compiling shaders, which are programs that run on the GPU to perform graphics calculations.

3.  Rendering: The project includes code for rendering a basic triangle using the hooked DirectX 11 API. This serves as an example of how you can use the hook to modify the rendering process.

4.  Memory Management: The project includes robust memory management, with safe release macros for DirectX objects.

Code Overview
-------------

The main file of the project is `DllMain.cpp`, which contains the implementation of the DirectX 11 hook. Here's a brief overview of some key parts of the code:

-   `hkPresent`: This is the hooked version of the `Present` function, which is a DirectX function that updates the screen with the rendered frame. This function is where the magic happens: it's where we intercept the `Present` call and add our own rendering code.

-   `HookD3D`: This function sets up the hook by creating a dummy DirectX device and swap chain, getting the virtual method table (VMT) of the swap chain, and replacing the `Present` function in the VMT with our own function.

-   `InitD3DHook`: This function initializes the hook by getting the DirectX device and context, setting up the render target view, and initializing the shaders and buffers for rendering.

-   `Render`: This function is where we add our own rendering code. In this case, it renders a simple triangle.

-   `CompileShader`: This function compiles a shader from source code.

-   `FindMainWindow` and `EnumWindowsCallback`: These functions are used to find the main window of the process, which is needed to create the dummy DirectX device and swap chain.


Frequently Asked Questions
--------------------------

Q: What is DirectX?

A: DirectX is a collection of APIs (Application Programming Interfaces) for handling tasks related to multimedia, especially game programming and video, on Microsoft platforms.

Q: What is a DirectX hook?

A: A DirectX hook is a technique that allows you to intercept and manipulate the DirectX API calls made by an application. This can be used for a variety of purposes, such as modifying the rendering process, capturing frames, or injecting custom shaders.

Q: What is a shader?

A: A shader is a type of program that is run on the GPU (Graphics Processing Unit). Shaders are used to perform calculations related to rendering, such as vertex transformations, lighting calculations, or pixel coloring.

Q: What is a VMT (Virtual Method Table)?

A: A VMT, or Virtual Method Table, is a mechanism used in C++ to support dynamic dispatch (or runtime method binding). Each class with virtual functions (or an inherited interface) has its own VMT. A VMT is essentially an array of function pointers that the compiler creates for us. When we declare a class with some virtual methods, the compiler silently writes some code to create the VMT for that class.

Prerequisites
-------------

To use this code, you should have a good understanding of C++ and Windows programming. You should also be familiar with DirectX 11 and graphics programming concepts. Knowledge of reverse engineering techniques and assembly language will also be helpful.

End Goal
--------

The end goal of this project is to provide a robust and flexible DirectX 11 hook that can be used as a starting point for game modding, reverse engineering, or cheat development. The provided code demonstrates how to set up the hook and use it to modify the rendering process, but it can be extended to perform more complex tasks.

Key Pieces of Code
------------------

The key pieces of this project are the hooking mechanism (`HookD3D` function), the hooked `Present` function (`hkPresent`), and the rendering code in the `Render` function. These pieces of code demonstrate the core functionality of the DirectX 11 hook.

Associated Resources​
---------------------

-   [Source Code - D3D11 X64 Present Hook](https://guidedhacking.com/threads/d3d11-x64-present-hook.15283/)
-   [Source Code - D3D11 Barebones hook PoC](https://guidedhacking.com/threads/d3d11-barebones-hook-poc.11939/)
-   [Source Code - D3D11 SWBF2 Cheats ( 2017 )](https://guidedhacking.com/threads/star-wars-battlefront-ii-hacks-swbf2-cheats-2017.15348/)
-   [DirectX11 Hook and Logger](https://guidedhacking.com/threads/directx11-hook-and-logger.11910/)

```