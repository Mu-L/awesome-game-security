Project Path: arc_lainswork_shellcode-factory_4k88xr0o

Source Tree:

```txt
arc_lainswork_shellcode-factory_4k88xr0o
├── README.md
├── shellcode-actuator
│   ├── main.cpp
│   ├── shellcode-actuator.vcxproj
│   └── shellcode-actuator.vcxproj.filters
├── shellcode-factory.sln
├── shellcode-generator
│   ├── coff.cpp
│   ├── coff.h
│   ├── main.cpp
│   ├── misc.hpp
│   ├── pecoff(microsoft可移植可执行文件和通用目标文件格式文件规范).pdf
│   ├── rang.hpp
│   ├── rang_impl.hpp
│   ├── shellcode-generator.vcxproj
│   ├── shellcode-generator.vcxproj.filters
│   └── span.hpp
└── shellcode-payload
    ├── call-extern-demo.cpp
    ├── dwm-capture.h
    ├── dwm-screen-shot-demo.cpp
    ├── lazy_importer.hpp
    ├── main-demo.cpp
    ├── shellcode-payload.vcxproj
    ├── shellcode-payload.vcxproj.filters
    ├── shellcode.h
    └── xorstr.hpp

```

`README.md`:

```md
# [shellcode-factory](https://github.com/lainswork/shellcode-factory)
## 一个简单`shellcode`生成框架，使用后可以变得开心。（开发中...）

[![LICENSE](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![](https://img.shields.io/badge/OS-any-brightgreen)]()
[![](https://img.shields.io/badge/compiler-any-brightgreen)]()

<br />

# shellcode特点
> 位置无关，在执行或注入前无需进行任何额外的处理。

> 简洁小巧，可以轻松的在不同的功能中实现通用的功能。

# 更新

> - 加入了DWM屏幕截图 demo
> - 更新了一些bug 现在框架能作为生产工具安全使用 

# 使用方法

```shell
// 确保你已经安装了VS2019或以上 Make sure u have installed Visual Studio 2019 or later version
// 打开PowerShell并进入一个为项目准备的文件夹,依次输入以下命令, Enter the following commands in PowerShell

> git clone https://github.com/lainswork/shellcode-factory.git

> cd shellcode-factory

> devenv shellcode-factory.sln /build "Debug|x64" /Project shellcode-generator

> cd ./x64/Debug

> .\shellcode-generator

// 现在你得到了 ./x64/Debug/payload.hpp     Now, u get ./x64/Debug/payload.hpp

```
> MessageBox演示

![image](https://user-images.githubusercontent.com/36320938/159157628-21b95fcc-cb2c-409f-ad04-dbb889efc735.png)

> dwm截屏演示

https://user-images.githubusercontent.com/46841563/159622629-b337380b-7ca2-4f3a-b043-d278be75a08f.mp4

# 起因与经过
21年中旬朋友在windows的dwm进程中发现一段异常执行的 "恶意代码",
在使用ida进行简单分析后得出结论：“该代码在dwm中 hook 相关渲染函数，恶意截取用户桌面画面”。
这段代码的来源指向了一款曾在2017年爆火网络的多人射击游戏，我们猜测其目的为：“截取用户游戏画面以判断用户是否在作弊”。
该shellcode引起了我的兴趣，它大概有如下特点：
|  data types | ranges  |
| ------- | ------- |
| .api  | 0x0000 - 0x1D00 |
| .text | 0x1D00 - 0x2100 |
| .data | 0x2100 - 0x5000 |


在这个shellcode中，存在一些只会被链接进exe的清单文件，我猜测：“该shellcode的开发者先使用编译器编译并链接了一个不带crt的exe
之后对该exe进行加壳，最后使用exe to shellcode类的工具生成该代码。”

# 反思
类似的 shellcode 的生成过程似乎不是很可靠 (将无意义的清单文件留存在shellcode中与我们编写shellcode的目的相背离)，好奇心驱使下，我搜寻了 windows 下 的 shellcode 编写方法,结果不如人意。  
有的人使用dll to shellcode框架或工具
有的人直接在c++代码中写下两个“标记函数”，之后将两个“标记函数”地址之间的bytes复制出来。
下面是一些常见的框架：

[Cobalt Strike 生成 shellcode](https://bbs.pediy.com/thread-271048.htm)

[MSVC 配合 Get-PEHeader生成shellcode](https://zeronohacker.com/1544.html)

[Win PE系列之导出表解析与ShellCode的编写及应用](https://bbs.pediy.com/thread-269753.htm)

[基于C++的shellcode框架](https://bbs.pediy.com/thread-268639.htm)

我的目标是建立一个可以满足如下条件的shellcode生成框架：
<<<<<<< HEAD

* 不要让我用二进制编辑器来手动提取bytes
* 它应该有扩展的可能性
* 生成的shellcode应该与位置无关，在使用时只需要进行： 映射-执行
* 要能使用全局变量（静态变量），因为我们可能使用静态字符串
* 尽可能的支持新的c++标准

我们可以选择从编译链接入手，但是徒手撸编译器太难了，撸个小链接器却很容易
=======
```sh
1.不要让我用二进制编辑器来手动提取bytes
2.它应该有扩展的可能性
3.生成的shellcode应该与位置无关，在使用时只需要进行： 映射-执行
4.要能使用全局变量（静态变量），因为我们可能使用静态字符串
5.尽可能的支持新的c++标准
```

# 原理
### coff
coff全称 通用对象文件格式(Common Object File Format)，我们常用的PE（exe，dll，sys，lib，obj）文件都属于coff，但我们这里要说的，是lib。  
当我们在VS中将编译目标设置为lib时，.lib文件其实是个.obj文件的文件包，其中包含了你编译的所有.obj文件（也就是我们c++源代码.cpp所编译后的文件）。

### obj 
.obj是 coff的一种，obj文件中包含我们编写的源代码编译后的字节码，其中包含了极其详细的符号信息：每个函数的名称、函数的字节码、静态数据的字节码、重定位信息、等等。

### shellcode 链接方法
其实我们要做的事情很简单，将所有bytes从obj中提取出来，对相对寻址进行重定位就可以生成我们要的shellcode

# payload 代码
> 使用 SC_EXPORT 标志公开函数

```C++

SC_EXPORT 
DWORD ShellCodeEntryPoint(LPVOID lpParameter) {
    CHAR buf[256] = {0};
    LI_FN(sprintf)(buf, xorstr_( "函数%s 线程参数0x%p"), __FUNCDNAME__, lpParameter);
    LI_FN(MessageBoxA)(HWND(0), buf, xorstr_("来自shellcode的展示"), MB_OK);
    return 0;
}

SC_EXPORT 
DWORD ShellCodeEntryPoint2(LPVOID lpParameter) {
    CHAR buf[256] = {0};
    LI_FN(sprintf)(buf, xorstr_("函数%s 线程参数0x%p"), __FUNCDNAME__, lpParameter);
    LI_FN(MessageBoxA)(HWND(0), buf, xorstr_("来自shellcode的展示"), MB_OK);
    return 0;
}

SC_EXPORT
DWORD ShellCodeEntryPoint3(LPVOID lpParameter) {
    CHAR buf[256] = {0};
    LI_FN(sprintf)(buf,xorstr_( "函数%s 线程参数0x%p"), __FUNCDNAME__, lpParameter);
    LI_FN(MessageBoxA)(HWND(0), buf, xorstr_("来自shellcode的展示"), MB_OK);
    return 0;
}
```
> 使用 SC_EXPORT_DATA 公开全局变量 不要在 .h 中使用SC_EXPORT_DATA
```C++
SC_EXPORT_DATA(int, Xxxx)
```

> 使用内嵌函数 内嵌函数的具体规则请自己查询, 
```C++
//使用内嵌函数 这个东西只在本cpp起作用，不要写在.h里面 写在每个cpp的最开头部分
extern "C" {
#pragma function(memset)
void *__cdecl memset(void *dest, int value, size_t num) {
    __stosb(static_cast<unsigned char *>(dest), static_cast<unsigned char>(value), num);
    return dest;
}
#pragma function(memcpy)
void *__cdecl memcpy(void *dest, const void *src, size_t num) {
    __movsb(static_cast<unsigned char *>(dest), static_cast<const unsigned char *>(src), num);
    return dest;
}
}
```

##### 你可以在 payload 中做什么:

- 使用新标准的c++代码，包括但不限于初始化列表、Lamda表达式、模板函数

- 使用多个.cpp文件，这代表你可以将不同的代码写在不同的cpp中

- 使用字符串、全局变量、导出全局变量相对shellcode的偏移

- 使用面向对象与C++ STL模板

- 使用开源库[xorstr](https://github.com/JustasMasiulis/xorstr) ,加密常量字符串

##### 你无法在 payload 中使用什么:

- 不要使用全局初始化，因为shellcode不能进行 CRT init

- 无法直接调用 系统API（这将在本框架优化后解决），暂时的调用api方法是 使用lazy_importer

- 无法使用 __declspec(thread) Tls线程局部储存关键字（但可以使用windows apiTlsAlloc TlsSetValue TlsGetValue）来解决

- 异常 try catch (没啥用，请忽略)

- SDL检查(没啥用，请忽略)

- 基本运行时检查(没啥用，请忽略)

# 依赖
- [lazy_importer](https://github.com/JustasMasiulis/lazy_importer)
# 优势
- 开启C++优化 /O1
- 开发方便
# 缺陷:
### 该框架只支持 X64  
原因是目前没有好办法解决x86下的.data数据重定位问题，在x86下.data数据重定位类型为IMAGE_REL_I386_DIR32，意为"RVA 绝对虚拟地址"
但是假如你不在代码中使用静态字符串或者全局变量，你仍然可以使用x86编译 shellcode-payload.lib，并用 x86 shellcode-generator.exe生成相应的代码

对x86的支持，后面可能会通过硬编码插入来解决
# Todo:
修改api导入策略，摆脱lazy_importer，实现可以在payload中直接使用api函数和crt函数的方法。

实现链接时混淆和虚拟化，这样我们可以将shellcode-generator(链接生成器)作为服务器功能，将payload.lib储存于服务器，每次执行shellcode获取都会生成完全不同的代码。（这个比较困难）


```mermaid
graph TB
    di{C/C++ project <br/> shellcode-payload.lib} --> sq[shellcode-generator.exe]
    
    sq[shellcode-generator.exe]--> e0((Vm/Obfuscator))-.->f0(shellcode 1)
    sq[shellcode-generator.exe]--> e1((Vm/Obfuscator))-.-> f1(shellcode 2)
    sq[shellcode-generator.exe]--> e2((Vm/Obfuscator))-.->f2(shellcode 3)
    sq[shellcode-generator.exe]--> e3((Vm/Obfuscator))-.-> f3(shellcode 4)
    sq[shellcode-generator.exe]--> e4((Vm/Obfuscator))-.->f4(shellcode 5)
    sq[shellcode-generator.exe]--> e5((Vm/Obfuscator))-.-> f..(shellcode ...)
```



```

`shellcode-actuator/main.cpp`:

```cpp
#ifdef _WIN64
#ifdef _DEBUG
#include "../x64/Debug/payload.hpp"
#else
#include "../x64/Release/payload.hpp"
#endif
#else
#ifdef _DEBUG
#include "../Debug/payload.hpp"
#else
#include "../Release/payload.hpp"
#endif
#endif // _WIN64

#include <Windows.h>
int main() {
    LoadLibraryA("user32.dll");
    LoadLibraryA("kernel32.dll");
    LoadLibraryA("KernelBase.dll");
    LoadLibraryA("msvcrt.dll");
    LoadLibraryA("gdi32.dll");

    auto shell_address = VirtualAlloc(0, sizeof(shellcode::payload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(shell_address, shellcode::payload, sizeof(shellcode::payload));

    reinterpret_cast<LPTHREAD_START_ROUTINE>(reinterpret_cast<char *>(shell_address) +
                                             shellcode::rva::ShellCodeEntryPoint)((void *)0x9999999);

    reinterpret_cast<LPTHREAD_START_ROUTINE>(reinterpret_cast<char *>(shell_address) +
                                             shellcode::rva::ShellCodeEntryPoint2)((void *)0x9999999);
    reinterpret_cast<LPTHREAD_START_ROUTINE>(reinterpret_cast<char *>(shell_address) +
                                             shellcode::rva::ShellCodeEntryPoint3)((void *)0x9999999);

    return 0;
}
```

`shellcode-actuator/shellcode-actuator.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{29b7af0a-f9f1-45a1-a662-af9b7fb704d4}</ProjectGuid>
    <RootNamespace>shellcodeactuator</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`shellcode-actuator/shellcode-actuator.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`shellcode-factory.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31025.194
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shellcode-generator", "shellcode-generator\shellcode-generator.vcxproj", "{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}"
	ProjectSection(ProjectDependencies) = postProject
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39} = {BD5CA44B-BF4B-4F32-81DE-9C7890585F39}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shellcode-payload", "shellcode-payload\shellcode-payload.vcxproj", "{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4A874537-D946-47C6-8AE0-00FB57A89FBF}"
	ProjectSection(SolutionItems) = preProject
		.clang-format = .clang-format
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shellcode-actuator", "shellcode-actuator\shellcode-actuator.vcxproj", "{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}.Debug|x64.ActiveCfg = Debug|x64
		{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}.Debug|x64.Build.0 = Debug|x64
		{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}.Debug|x86.ActiveCfg = Debug|Win32
		{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}.Debug|x86.Build.0 = Debug|Win32
		{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}.Release|x64.ActiveCfg = Release|x64
		{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}.Release|x64.Build.0 = Release|x64
		{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}.Release|x86.ActiveCfg = Release|Win32
		{7ADA88EB-A76B-4854-9DFB-CAA17412A6DE}.Release|x86.Build.0 = Release|Win32
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}.Debug|x64.ActiveCfg = Debug|x64
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}.Debug|x64.Build.0 = Debug|x64
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}.Debug|x86.ActiveCfg = Debug|Win32
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}.Debug|x86.Build.0 = Debug|Win32
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}.Release|x64.ActiveCfg = Release|x64
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}.Release|x64.Build.0 = Release|x64
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}.Release|x86.ActiveCfg = Release|Win32
		{BD5CA44B-BF4B-4F32-81DE-9C7890585F39}.Release|x86.Build.0 = Release|Win32
		{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}.Debug|x64.ActiveCfg = Debug|x64
		{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}.Debug|x64.Build.0 = Debug|x64
		{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}.Debug|x86.ActiveCfg = Debug|Win32
		{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}.Debug|x86.Build.0 = Debug|Win32
		{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}.Release|x64.ActiveCfg = Release|x64
		{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}.Release|x64.Build.0 = Release|x64
		{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}.Release|x86.ActiveCfg = Release|Win32
		{29B7AF0A-F9F1-45A1-A662-AF9B7FB704D4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BE2178CD-2DD8-4A1A-9145-4B496D6A93F5}
	EndGlobalSection
EndGlobal

```

`shellcode-generator/coff.cpp`:

```cpp
#include "coff.h"
#include <regex>
namespace coff {

PIMAGE_SYMBOL obj::get_symbol(string name) {
    auto &symbols = this->symbols();

    // 遍历所有符号
    for (size_t idx = 0; idx < symbols.size(); idx++) {
        auto &      symbol      = symbols[idx];
        const char *symbol_name = this->symbol_name(symbol);
        if (name == symbol_name) {
            return &symbol;
        }

        if (symbol.NumberOfAuxSymbols) {
            idx += symbol.NumberOfAuxSymbols;
        }
    }

    return 0;
}

std::string obj::name() { return _lib->obj_name(*this); }
void                obj::for_each_symbols(std::function<void(IMAGE_SYMBOL &)> _call) {
    auto &symbols = this->symbols();
    // 遍历所有符号
    for (size_t idx = 0; idx < symbols.size(); idx++) {
        _call(symbols[idx]);
        if (symbols[idx].NumberOfAuxSymbols) {
            idx += symbols[idx].NumberOfAuxSymbols;
        }
    }
}
span<IMAGE_SYMBOL> &obj::symbols() {
    if (syms.empty()) {
        PIMAGE_FILE_HEADER obj          = reinterpret_cast<PIMAGE_FILE_HEADER>(pObjBuffer);
        PIMAGE_SYMBOL      symbol_table = reinterpret_cast<PIMAGE_SYMBOL>(obj->PointerToSymbolTable + (byte *)obj);
        syms = span<IMAGE_SYMBOL>(symbol_table, static_cast<std::size_t>(obj->NumberOfSymbols));
    }
    return syms;
}

const char *obj::symbol_name(IMAGE_SYMBOL &symbol) {

    if (symbol.N.Name.Short != 0)
        return (reinterpret_cast<char *>(symbol.N.ShortName));
    else {
        if (!strings) {
            PIMAGE_FILE_HEADER    obj = reinterpret_cast<PIMAGE_FILE_HEADER>(pObjBuffer);
            PIMAGE_SECTION_HEADER section_headers =
                reinterpret_cast<PIMAGE_SECTION_HEADER>((byte *)obj + sizeof IMAGE_FILE_HEADER);

            PIMAGE_SYMBOL symbol_table = reinterpret_cast<PIMAGE_SYMBOL>(obj->PointerToSymbolTable + (byte *)obj);

            strings = reinterpret_cast<const char *>(reinterpret_cast<std::uintptr_t>(symbol_table) +
                                                     (obj->NumberOfSymbols * sizeof IMAGE_SYMBOL));
        }
        return (strings + symbol.N.Name.Long);
    }
}

span<IMAGE_SECTION_HEADER> &obj::sections() {
    if (_sections.empty()) {
        PIMAGE_FILE_HEADER    obj = reinterpret_cast<PIMAGE_FILE_HEADER>(pObjBuffer);
        PIMAGE_SECTION_HEADER section_headers =
            reinterpret_cast<PIMAGE_SECTION_HEADER>((byte *)obj + sizeof IMAGE_FILE_HEADER);
        _sections = span<IMAGE_SECTION_HEADER>(section_headers, static_cast<std::size_t>(obj->NumberOfSections));
    }
    return _sections;
}
vector<string> &obj::exports() {
    if (_exports.empty()) {
        PIMAGE_FILE_HEADER obj             = reinterpret_cast<PIMAGE_FILE_HEADER>(pObjBuffer);
        auto               symbols         = this->symbols();
        auto               section_headers = this->sections();

        for (size_t idx = 0; idx < symbols.size(); idx++) {

            auto &symbol = symbols[idx];

            if (symbol.SectionNumber > 0) {
                auto &section = section_headers[static_cast<size_t>(symbol.SectionNumber) - 1];

                // IMAGE_SCN_LNK_INFO
                if (coff::same_str((char *)section.Name, ".drectve")) {
                    // printf("%s\n", coff::obj::section_name(section.Name, string_table).c_str());
                    const char *data = section.PointerToRawData + (char *)obj;
                    // printf("%s\n", section.PointerToRawData + (char *)obj.data);
                    auto strs = coff::split_str(std::string(data, static_cast<size_t>(section.SizeOfRawData)), ' ');
                    for (auto str : strs) {

                        // msvc /EXPORT:?main2@@YAHXZ
                        // llvm /EXPORT:"?main2@@YAHXZ"
                        std::smatch base_match;
                        if (std::regex_match(str, base_match, std::regex("^(/EXPORT:)(.*?)|(\".*?\")"))) {
                            std::string export_name = base_match[2].str();
                            if (std::regex_match(export_name, base_match, std::regex("^\"(.*?)\""))) {
                                export_name = base_match[1].str();
                            }
                            if (std::regex_match(export_name, base_match, std::regex("(.*?),DATA$"))) {
                                export_name = base_match[1].str();
                            }
                            _exports.push_back(export_name);
                        }

                        // printf("%s\n",str.c_str());
                    }
                }
            }

            // NumberOfAuxSymbols 附加记录的数量。 也就是本 symbol 后面的附加symbol的数量
            if (symbol.NumberOfAuxSymbols)
                idx += symbol.NumberOfAuxSymbols;
        }
    }
    return _exports;
}

bool obj::has_relocations(PIMAGE_SECTION_HEADER section_header) {
    PIMAGE_FILE_HEADER obj = reinterpret_cast<PIMAGE_FILE_HEADER>(pObjBuffer);
    if (section_header->PointerToRelocations) {
        PIMAGE_RELOCATION reloc_dir =
            reinterpret_cast<PIMAGE_RELOCATION>(section_header->PointerToRelocations + reinterpret_cast<byte *>(obj));
        span<IMAGE_RELOCATION> relocation(reloc_dir, static_cast<std::size_t>(section_header->NumberOfRelocations));

        _relocations[section_header] = relocation;
        return true;
    } else {
        return false;
    }
}

span<IMAGE_RELOCATION> &obj::relocations(PIMAGE_SECTION_HEADER section_header) {
    auto iter = _relocations.find(section_header);
    if (iter != _relocations.end()) {
        return iter->second;
    } else {
        PIMAGE_FILE_HEADER obj = reinterpret_cast<PIMAGE_FILE_HEADER>(pObjBuffer);
        if (section_header->PointerToRelocations) {
            PIMAGE_RELOCATION reloc_dir = reinterpret_cast<PIMAGE_RELOCATION>(section_header->PointerToRelocations +
                                                                              reinterpret_cast<byte *>(obj));

            // 一种特殊情况，单个函数的依赖函数(重定位信息)超过 65535 时 ，这个 if 会生效
            // https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header
            if (section_header->NumberOfRelocations == 0xffff &&
                (section_header->Characteristics & IMAGE_SCN_LNK_NRELOC_OVFL)) {
                span<IMAGE_RELOCATION> relocation(reloc_dir, static_cast<std::size_t>(reloc_dir->RelocCount));
                _relocations[section_header] = relocation;
                return _relocations[section_header];
            }

            span<IMAGE_RELOCATION> relocation(reloc_dir, static_cast<std::size_t>(section_header->NumberOfRelocations));

            _relocations[section_header] = relocation;
            return _relocations[section_header];
        }
    }
    return empty_relocations;
}

std::string lib::obj_name(obj &obj) {

    PIMAGE_ARCHIVE_MEMBER_HEADER coff_obj_header =
        reinterpret_cast<PIMAGE_ARCHIVE_MEMBER_HEADER>(obj.pObjBuffer - sizeof(IMAGE_ARCHIVE_MEMBER_HEADER));

    const char *pSlash = strchr(reinterpret_cast<const char *>(coff_obj_header->Name), '/');

    /*经典名称*/
    /* "name/" */
    if (pSlash && pSlash > reinterpret_cast<const char *>(coff_obj_header->Name)) {
        return string(reinterpret_cast<const char *>(coff_obj_header->Name),
                      pSlash - reinterpret_cast<const char *>(coff_obj_header->Name));
    }

    /*长名称 */
    /* "/xxx" */
    if (pSlash == reinterpret_cast<const char *>(coff_obj_header->Name) && coff_obj_header->Name[1] != 0x00) {

        size_t name_offset = std::atoi(
            string(reinterpret_cast<const char *>(&(coff_obj_header->Name[1])), sizeof(coff_obj_header->Name) - 1)
                .c_str());

        string      ret;
        const char *start = (char *)pLongName_header + sizeof(IMAGE_ARCHIVE_MEMBER_HEADER) + name_offset;
        for (size_t i = 0;; i++) {
            if (start[i] != '\n' && start[i] != '\0')
                ret.push_back(start[i]);
            else
                return ret;
        }

        return string((char *)pLongName_header + sizeof(IMAGE_ARCHIVE_MEMBER_HEADER) + name_offset);
    }

    return "";
}

vector<obj> &lib::objs() {
    if (_objs.empty()) {
        if (is_valid_lib()) {
            byte *cursor = pLibBuffer;

            auto step = [](PIMAGE_ARCHIVE_MEMBER_HEADER header) -> size_t {
                size_t member_size =
                    std::atoi(string(reinterpret_cast<const char *>(header->Size), sizeof(header->Size)).c_str());

                return sizeof(IMAGE_ARCHIVE_MEMBER_HEADER) + member_size + member_size % 2;
            };

            cursor += sizeof(IMAGE_ARCHIVE_START) - 1;

            while (cursor < pLibBuffer + bufferSize) {

                PIMAGE_ARCHIVE_MEMBER_HEADER coff_obj_header = reinterpret_cast<PIMAGE_ARCHIVE_MEMBER_HEADER>(cursor);
                /* '/' The archive member is one of the two linker members. Both of the
                 * linker members have this name. */
                /* '/' 存档成员是两个链接器成员之一。两个链接器成员都有此名称. */
                if (coff_obj_header->Name[0] == '/' &&
                    (coff_obj_header->Name[1] == 0x00 || coff_obj_header->Name[1] == ' ')) {
                    cursor += step(coff_obj_header);
                    continue;
                }

                /* '//' The longnames member is the third archive member and is
                 * optional.*/
                /* '//' longnames成员是第三个存档成员，是可选的.*/
                if (0 == std::memcmp(coff_obj_header->Name, "//", sizeof("//") - 1)) {
                    pLongName_header = coff_obj_header;
                    cursor += step(pLongName_header);
                    continue;
                }

                int obj_size = std::atoi(
                    string(reinterpret_cast<const char *>(coff_obj_header->Size), sizeof(coff_obj_header->Size))
                        .c_str());

                _objs.push_back(
                    {((byte *)coff_obj_header) + sizeof(IMAGE_ARCHIVE_MEMBER_HEADER), static_cast<size_t>(obj_size)});
                _objs.back()._lib = this;
                cursor += step(coff_obj_header);
            }
        }
    }

    return _objs;
}

bool lib::is_valid_lib() {
    if (strncmp(reinterpret_cast<const char *>(pLibBuffer), IMAGE_ARCHIVE_START, sizeof IMAGE_ARCHIVE_START - 1))
        return false;
    else
        return true;
}

} // namespace coff
```

`shellcode-generator/coff.h`:

```h
#pragma once
#include "span.hpp"

#include <Windows.h>
#include <winternl.h>

#include <string>
#include <string_view>
#include <tuple>
#include <unordered_map>
#include <vector>
#include <regex>
#include <functional>
// /*https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#archive-library-file-format*/

namespace coff {
template <typename T>
using vector = std::vector<T>;

template <typename K, typename V>
using map = std::unordered_map<K, V>;

template <typename... T>
using pair = std::pair<T...>;

template <typename... T>
using tuple = std::tuple<T...>;

template <typename  T>
using span = tcb::span<T>;

using dword         = unsigned long;
using byte          = std::uint8_t;
using buffer_t      = std::vector<byte>;

struct buffer_view {
    buffer_view(byte *data, size_t size) : data(data), size(size) {}
    byte * data = 0;
    size_t size = 0;
};

using string        = std::string;
using coff_obj_info = tuple<string, buffer_view>;

template <size_t N>
constexpr bool same_str(const char *str, const char (&str_c)[N]) {
    return (strncmp(str, str_c, N - 1) == 0);
}
template <size_t N>
constexpr bool same_str(const char (&str_c)[N], const char *str) {
    return (strncmp(str, str_c, N - 1) == 0);
}


inline 
vector<string> split_str(const string &s, char delim = ' ') {
    vector<string> tokens;
    auto string_find_first_not = [s, delim](size_t pos = 0) -> size_t {
        for (size_t i = pos; i < s.size(); i++) {
            if (s[i] != delim)
                return i;
        }
        return string::npos;
    };
    size_t lastPos = string_find_first_not(0);
    size_t pos     = s.find(delim, lastPos);
    while (lastPos != string::npos) {
        tokens.emplace_back(s.substr(lastPos, pos - lastPos));
        lastPos = string_find_first_not(pos);
        pos     = s.find(delim, lastPos);
    }
    return tokens;
}


class lib;
class obj {
    friend class lib;

public:
    obj(byte *pObjBuffer, size_t bufferSize) : pObjBuffer(pObjBuffer), bufferSize(bufferSize) {}
    ~obj() {}
    byte *                obj_data() { return pObjBuffer; }
    PIMAGE_SYMBOL               get_symbol(string name);
    std::string                 name();
    void                        for_each_symbols(std::function<void(IMAGE_SYMBOL&)>);
    span<IMAGE_SYMBOL> &        symbols();
    const char *                symbol_name(IMAGE_SYMBOL &symbol);
    span<IMAGE_SECTION_HEADER> &sections();
    vector<string> &            exports();
    bool                        has_relocations(PIMAGE_SECTION_HEADER section_header);
    span<IMAGE_RELOCATION> &    relocations(PIMAGE_SECTION_HEADER section_header);

private:
    byte *                                             pObjBuffer;
    size_t                                             bufferSize;
    span<IMAGE_SYMBOL>                                 syms;
    span<IMAGE_SECTION_HEADER>                         _sections;
    vector<string>                                     _exports;
    map<PIMAGE_SECTION_HEADER, span<IMAGE_RELOCATION>> _relocations;
    span<IMAGE_RELOCATION>                             empty_relocations;
    const char *                                       strings = 0;
    lib *                                              _lib    = 0;
};

class lib {
public:
    lib(byte *pLibBuffer, size_t bufferSize) : pLibBuffer(pLibBuffer), bufferSize(bufferSize) {}
    ~lib() {}
    std::string  obj_name(obj &obj);
    vector<obj> &objs();

private:
    bool                         is_valid_lib();
    PIMAGE_ARCHIVE_MEMBER_HEADER pLongName_header = 0;
    byte *                       pLibBuffer;
    size_t                       bufferSize;
    vector<obj>                  _objs;
};
}; // namespace llnk

```

`shellcode-generator/main.cpp`:

```cpp
#include "coff.h"
#include "rang_impl.hpp"
#include "misc.hpp"

#include <fstream>
#include <functional>
#include <cstdint>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <regex>
#include <iomanip>
#include <exception>

#include <intrin.h>

struct section_mapped_info {
    uint32_t maped_va;
    uint32_t maped_size; // maped_size 好像用不到 先留着吧
};

void recursive_lookup_relocations(std::vector<coff::lib> &libs,
                                  std::tuple<PIMAGE_SYMBOL, coff::obj *>
                                                                                        sym,
                                  std::map<PIMAGE_SECTION_HEADER, section_mapped_info> &section_mapped,
                                  std::map<std::string, int> &                          sym_mapped,
                                  std::vector<uint8_t> &                                shellcodebytes);

void print_shellcode_hpp_file(std::string                                                    resource_name,
                              std::map<std::string, int> &                                   sym_mapped,
                              std::vector<uint8_t> &                                         shellcodebytes,
                              std::map<std::string, std::tuple<PIMAGE_SYMBOL, coff::obj *>> &export_syms);

constexpr char payload_lib_name[] = {"shellcode-payload.lib"};
constexpr char out_bin_name[]     = {"shellcode-payload.bin"};
constexpr char out_hpp_name[]     = {"payload"};
int  main() {

    try {
        // 未来会支持lib互相依赖，所以这里可能会载入多个lib
        std::vector<coff::lib> libs;
        // 读取的lib数据应保持其生命周期 因为coff.cpp中的所有方法都是使用的指针与引用
        std::vector<uint8_t> data;
        open_binary_file(payload_lib_name, data);
        coff::lib payload(data.data(), data.size());
        // todo: 框架当前不支持多个lib 但在未来应支持
        libs.push_back(payload);

        // 遍历获取所有obj中的导出符号
        std::map<std::string, std::tuple<PIMAGE_SYMBOL, coff::obj *>> export_syms;
        for (auto &lib : libs) {
            for (auto &obj : lib.objs()) {
                // obj.exports() 得到obj文件中的所有导出符号名称 ，接下来还需要借助名称寻找对应的 PIMAGE_SYMBOL
                for (auto &exp : obj.exports()) {
                    INF("find export %s", exp.c_str());
                    // for_each_symbols会跳过一些不必要的符号 .obj中很多符号并无实际意义
                    obj.for_each_symbols([&](IMAGE_SYMBOL &Sym) {
                        // 找到对应导出名称的符号 PIMAGE_SYMBOL
                        if (exp == obj.symbol_name(Sym)) {
                            if (export_syms.find(exp) == export_syms.end()) {
                                export_syms.insert({exp, {&Sym, &obj}});
                            } else {
                                throw std::exception("Duplicate export symbol:\"%s\"");
                            }
                        }
                    });
                }
            }
        }

        //从导出函数开始，顺着每个导出函数查找重定位以及重定位的重定位......
        std::vector<uint8_t>                                 shellcodebytes; //储存映射数据的内存
        std::map<PIMAGE_SECTION_HEADER, section_mapped_info> section_mapped; //所有被映射的节
        std::map<std::string, int>                           sym_mapped;     //所有被映射的符号
        for (auto &exp : export_syms) {
            recursive_lookup_relocations(libs, exp.second, section_mapped, sym_mapped, shellcodebytes);
        }

        //打印
        for (auto &i : sym_mapped)
            INF("[ 0x%06x ] for %s", i.second, i.first.c_str());

        //打印
        IMP("----------");
        for (auto &exp : export_syms)
            IMP("Export at [ 0x%06x ] for %s", sym_mapped[exp.first], exp.first.c_str());
        IMP("----------");

        //写出 bin
        buffer_to_file_bin(shellcodebytes.data(), shellcodebytes.size(), out_bin_name);
        //写出 hpp
        print_shellcode_hpp_file(out_hpp_name, sym_mapped, shellcodebytes, export_syms);

        SUC("shellcode generator success!");

    } catch (const std::exception & ex) {
        ERO(ex.what());
    }
    

    std::system("pause");
    return 0;
}


void recursive_lookup_relocations(std::vector<coff::lib> &libs,
                                  std::tuple<PIMAGE_SYMBOL, coff::obj *>
                                                                                                 sym,
                                  std::map<PIMAGE_SECTION_HEADER, section_mapped_info> &         section_mapped,
                                  std::map<std::string, int> &                                   sym_mapped,
                                  std::vector<uint8_t> &                                         shellcodebytes) {

    const char *pSymName = std::get<coff::obj *>(sym)->symbol_name(*std::get<PIMAGE_SYMBOL>(sym));

    if (sym_mapped.find(pSymName) != sym_mapped.end()) {
        return;
    }

    if (std::get<PIMAGE_SYMBOL>(sym)->SectionNumber > IMAGE_SYM_UNDEFINED) {

        IMAGE_SECTION_HEADER &section =
            std::get<coff::obj *>(sym)
                ->sections()[static_cast<size_t>(std::get<PIMAGE_SYMBOL>(sym)->SectionNumber) - 1];


        // STATIC 类型的一个节就是符号
        if (std::get<PIMAGE_SYMBOL>(sym)->Value == 0) {
            if (section_mapped.find(&section) == section_mapped.end()) {
                auto oldSize = shellcodebytes.size();
                shellcodebytes.resize(oldSize + section.SizeOfRawData, 0x00);
                sym_mapped[pSymName] = oldSize;
                memcpy(shellcodebytes.data() + oldSize,
                       static_cast<size_t>(section.PointerToRawData) + std::get<coff::obj *>(sym)->obj_data(),
                       section.SizeOfRawData);
                if (section.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
                    memset(shellcodebytes.data() + oldSize, 0x00, section.SizeOfRawData);
                }
                section_mapped_info smi{};
                smi.maped_va             = oldSize;
                smi.maped_size           = section.SizeOfRawData;
                section_mapped[&section] = smi;
                //INF("符号:\"%s\" Va:0x%x/Size:0x%x ", pSymName, oldSize, section.SizeOfRawData);
            }
            

           

            // 重定位
            for (auto &reloca : std::get<coff::obj *>(sym)->relocations(&section)) {

                // 重定位符号
                auto &      reloc_symbol = std::get<coff::obj *>(sym)->symbols()[reloca.SymbolTableIndex];
                std::string reloc_name   = std::get<coff::obj *>(sym)->symbol_name(reloc_symbol);

                recursive_lookup_relocations(libs, {&reloc_symbol, std::get<coff::obj *>(sym)}, section_mapped, sym_mapped, shellcodebytes);

                // INF("\t\t\t重定位符号:\"%s\" Va:0x%x", reloc_name.c_str(), sym_mapped[reloc_name]);
#ifdef _WIN64
                if (reloca.Type == IMAGE_REL_AMD64_REL32) {
                    *reinterpret_cast<int *>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                                             sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                                         (sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                } else if (reloca.Type == IMAGE_REL_AMD64_REL32_1) {
                    *reinterpret_cast<int *>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                                             sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                                         (1 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                } else if (reloca.Type == IMAGE_REL_AMD64_REL32_2) {
                    *reinterpret_cast<int *>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                                             sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                                         (2 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                } else if (reloca.Type == IMAGE_REL_AMD64_REL32_3) {
                    *reinterpret_cast<int *>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                                             sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                                         (3 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                } else if (reloca.Type == IMAGE_REL_AMD64_REL32_4) {
                    *reinterpret_cast<int *>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                                             sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                                         (4 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));
                } else if (reloca.Type == IMAGE_REL_AMD64_REL32_5) {
                    *reinterpret_cast<int *>(static_cast<size_t>(reloca.VirtualAddress) + shellcodebytes.data() +
                                             sym_mapped[pSymName]) =
                        static_cast<int>(sym_mapped[reloc_name] -
                                         (5 + sym_mapped[pSymName] + reloca.VirtualAddress + sizeof(uint32_t)));

                }
#else
                if (reloca.Type == IMAGE_REL_I386_REL32) {
                    *reinterpret_cast<int *>(static_cast<size_t>(reloca.va) + shellcodebytes.data() +
                                             symbol_info.second.maped_va) =
                        static_cast<int>(involves[reloca.sym_name].maped_va -
                                         (symbol_info.second.maped_va + reloca.va + sizeof(uint32_t)));
                }
#endif // _WIN64
                else {
                    if (reloca.Type == IMAGE_REL_I386_DIR32) {
                        throw std::exception("Relocation Type IMAGE_REL_I386_DIR32 !");
                    }
                    throw std::exception("There is a CPU relocation mode that cannot be processed , Link stop!");
                }
            }
        } else {
            if (section_mapped.find(&section) != section_mapped.end()) {
                auto section_maped_va = section_mapped[&section].maped_va;
                auto _sym_va          = std::get<PIMAGE_SYMBOL>(sym)->Value;
                sym_mapped[pSymName]  = section_maped_va + _sym_va;
                // IMP("静态数据\"%s\" Va:0x%x", pSymName, sym_mapped[pSymName]);
            } else {
                auto oldSize = shellcodebytes.size();
                shellcodebytes.resize(oldSize + section.SizeOfRawData, 0x00);

                memcpy(shellcodebytes.data() + oldSize,
                       static_cast<size_t>(section.PointerToRawData) + std::get<coff::obj *>(sym)->obj_data(),
                       section.SizeOfRawData);
                if (section.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
                    memset(shellcodebytes.data() + oldSize, 0x00, section.SizeOfRawData);
                }
                section_mapped_info smi{};
                smi.maped_va             = oldSize;
                smi.maped_size           = section.SizeOfRawData;
                section_mapped[&section] = smi;

                recursive_lookup_relocations(libs, {std::get<PIMAGE_SYMBOL>(sym), std::get<coff::obj *>(sym)},
                                             section_mapped, sym_mapped, shellcodebytes);
            }
        }

    } else {
        if (std::get<PIMAGE_SYMBOL>(sym)->StorageClass == IMAGE_SYM_CLASS_EXTERNAL &&
            std::get<PIMAGE_SYMBOL>(sym)->Value > 0) {
            if (sym_mapped.find(pSymName) == sym_mapped.end()) {
                auto oldSize = shellcodebytes.size();
                shellcodebytes.resize(oldSize + std::get<PIMAGE_SYMBOL>(sym)->Value, 0x00);
                sym_mapped[pSymName] = oldSize;
                IMP("External:\"%s\" Va:0x%x/Size:0x%x", pSymName, oldSize, std::get<PIMAGE_SYMBOL>(sym)->Value);
            }
        } else {

            //跨obj调用
            bool canResolve = false;
            for (auto &lib : libs) {
                for (auto &obj : lib.objs()) {
                    obj.for_each_symbols([&](IMAGE_SYMBOL &Sym) {
                        if (strcmp(pSymName, obj.symbol_name(Sym)) == 0) {
                            if (Sym.SectionNumber > IMAGE_SYM_UNDEFINED ||
                                (Sym.StorageClass == IMAGE_SYM_CLASS_EXTERNAL && Sym.Value > 0)) {
                                canResolve = true;
                                recursive_lookup_relocations(libs, {&Sym, &obj},section_mapped, sym_mapped, shellcodebytes);
                            }
                        }
                    });
                }
            }

            if (!canResolve) {
                ERO("Unresolved symbols \"%s\" ", pSymName);
                throw std::exception("Unresolved symbols");
            }
        }
    }
}

void print_shellcode_hpp_file(std::string                                                    resource_name,
                              std::map<std::string, int> &                                   sym_mapped,
                              std::vector<uint8_t> &                                         shellcodebytes,
                              std::map<std::string, std::tuple<PIMAGE_SYMBOL, coff::obj *>> &export_syms) {
    //打开输出文件
    std::ofstream outFile;
    outFile.open(resource_name + ".hpp", std::ios::out);

    if (outFile.is_open()) {
        //输出头部信息
        outFile << "#pragma once" << std::endl;
        outFile << "#include <cstdint>" << std::endl;
        outFile << "namespace shellcode\n{" << std::endl;

        outFile << "namespace rva\n{" << std::endl;

        for (auto &iter : export_syms) {
#ifdef _M_IX86 // 32位模式下 编译器会在函数前面加一个 _
            uint32_t    maped_va = sym_mapped[iter.first];
            std::string exp      = iter.first;
            if (exp.front() == '_') {
                exp.erase(exp.begin());
            }
            outFile << "const size_t " << exp << " = 0x" << std::hex << maped_va << ";\n";
#else
            outFile << "const size_t " << iter.first << " = 0x" << std::hex << sym_mapped[iter.first] << ";\n";
#endif // _M_IX86
        }
        outFile << "\n}\n" << std::endl;

        outFile << "unsigned char " + resource_name + " [] = " << std::endl;
        outFile << "\t{" << std::endl << "\t";

        for (size_t idx = 0; idx < shellcodebytes.size(); idx++) {
            if (idx % 80 == 0)
                outFile << "\n";
            uint8_t code_byte = shellcodebytes[idx];
            outFile << "0x" << std::hex << std::setw(2) << std::setfill('0') << (int)code_byte << ",";
        }

        outFile << "\t};" << std::endl;

        outFile << "\n};\n" << std::endl;
        outFile.close();
    } else {
        throw std::exception("Cannot open hpp file!");
    }

   
}
```

`shellcode-generator/misc.hpp`:

```hpp
#pragma once
#include <fstream>
#include <cstdint>
#include <string>
#include <vector>
inline std::string &replace_all(std::string &str, const std::string &old_value, const std::string &new_value) {
    while (true) {
        std::string::size_type pos(0);
        if ((pos = str.find(old_value)) != std::string::npos)
            str.replace(pos, old_value.length(), new_value);
        else
            break;
    }
    return str;
}
inline void buffer_to_file_bin(unsigned char *buffer, size_t buffer_size, const std::string &filename) {
    std::ofstream file(filename, std::ios_base::out | std::ios_base::binary);
    file.write((const char *)buffer, buffer_size);
    file.close();
}
inline void open_binary_file(const std::string &file, std::vector<uint8_t> &data) {
    std::ifstream fstr(file, std::ios::binary);
    fstr.unsetf(std::ios::skipws);
    fstr.seekg(0, std::ios::end);

    const auto file_size = fstr.tellg();

    fstr.seekg(NULL, std::ios::beg);
    data.reserve(static_cast<uint32_t>(file_size));
    data.insert(data.begin(), std::istream_iterator<uint8_t>(fstr), std::istream_iterator<uint8_t>());
}
```

`shellcode-generator/rang.hpp`:

```hpp
#ifndef RANG_DOT_HPP
#define RANG_DOT_HPP

#if defined(__unix__) || defined(__unix) || defined(__linux__)
#define OS_LINUX
#elif defined(WIN32) || defined(_WIN32) || defined(_WIN64)
#define OS_WIN
#elif defined(__APPLE__) || defined(__MACH__)
#define OS_MAC
#else
#error Unknown Platform
#endif

#if defined(OS_LINUX) || defined(OS_MAC)
#include <unistd.h>

#elif defined(OS_WIN)

#if defined(_WIN32_WINNT) && (_WIN32_WINNT < 0x0600)
#error                                                                         \
  "Please include rang.hpp before any windows system headers or set _WIN32_WINNT at least to _WIN32_WINNT_VISTA"
#elif !defined(_WIN32_WINNT)
#define _WIN32_WINNT _WIN32_WINNT_VISTA
#endif

#include <windows.h>
#include <io.h>
#include <memory>

// Only defined in windows 10 onwards, redefining in lower windows since it
// doesn't gets used in lower versions
// https://docs.microsoft.com/en-us/windows/console/getconsolemode
#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
#endif

#endif

#include <algorithm>
#include <atomic>
#include <cstdlib>
#include <cstring>
#include <iostream>

namespace rang {

/* For better compability with most of terminals do not use any style settings
 * except of reset, bold and reversed.
 * Note that on Windows terminals bold style is same as fgB color.
 */
enum class style {
    reset     = 0,
    bold      = 1,
    dim       = 2,
    italic    = 3,
    underline = 4,
    blink     = 5,
    rblink    = 6,
    reversed  = 7,
    conceal   = 8,
    crossed   = 9
};

enum class fg {
    black   = 30,
    red     = 31,
    green   = 32,
    yellow  = 33,
    blue    = 34,
    magenta = 35,
    cyan    = 36,
    gray    = 37,
    reset   = 39
};

enum class bg {
    black   = 40,
    red     = 41,
    green   = 42,
    yellow  = 43,
    blue    = 44,
    magenta = 45,
    cyan    = 46,
    gray    = 47,
    reset   = 49
};

enum class fgB {
    black   = 90,
    red     = 91,
    green   = 92,
    yellow  = 93,
    blue    = 94,
    magenta = 95,
    cyan    = 96,
    gray    = 97
};

enum class bgB {
    black   = 100,
    red     = 101,
    green   = 102,
    yellow  = 103,
    blue    = 104,
    magenta = 105,
    cyan    = 106,
    gray    = 107
};

enum class control {  // Behaviour of rang function calls
    Off   = 0,  // toggle off rang style/color calls
    Auto  = 1,  // (Default) autodect terminal and colorize if needed
    Force = 2  // force ansi color output to non terminal streams
};
// Use rang::setControlMode to set rang control mode

enum class winTerm {  // Windows Terminal Mode
    Auto   = 0,  // (Default) automatically detects wheter Ansi or Native API
    Ansi   = 1,  // Force use Ansi API
    Native = 2  // Force use Native API
};
// Use rang::setWinTermMode to explicitly set terminal API for Windows
// Calling rang::setWinTermMode have no effect on other OS

namespace rang_implementation {

    inline std::atomic<control> &controlMode() noexcept
    {
        static std::atomic<control> value(control::Auto);
        return value;
    }

    inline std::atomic<winTerm> &winTermMode() noexcept
    {
        static std::atomic<winTerm> termMode(winTerm::Auto);
        return termMode;
    }

    inline bool supportsColor() noexcept
    {
#if defined(OS_LINUX) || defined(OS_MAC)

        static const bool result = [] {
            const char *Terms[]
              = { "ansi",    "color",  "console", "cygwin", "gnome",
                  "konsole", "kterm",  "linux",   "msys",   "putty",
                  "rxvt",    "screen", "vt100",   "xterm" };

            const char *env_p = std::getenv("TERM");
            if (env_p == nullptr) {
                return false;
            }
            return std::any_of(std::begin(Terms), std::end(Terms),
                               [&](const char *term) {
                                   return std::strstr(env_p, term) != nullptr;
                               });
        }();

#elif defined(OS_WIN)
        // All windows versions support colors through native console methods
        static constexpr bool result = true;
#endif
        return result;
    }

#ifdef OS_WIN


    inline bool isMsysPty(int fd) noexcept
    {
        // Dynamic load for binary compability with old Windows
        const auto ptrGetFileInformationByHandleEx
          = reinterpret_cast<decltype(&GetFileInformationByHandleEx)>(
            GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")),
                           "GetFileInformationByHandleEx"));
        if (!ptrGetFileInformationByHandleEx) {
            return false;
        }

        HANDLE h = reinterpret_cast<HANDLE>(_get_osfhandle(fd));
        if (h == INVALID_HANDLE_VALUE) {
            return false;
        }

        // Check that it's a pipe:
        if (GetFileType(h) != FILE_TYPE_PIPE) {
            return false;
        }

        // POD type is binary compatible with FILE_NAME_INFO from WinBase.h
        // It have the same alignment and used to avoid UB in caller code
        struct MY_FILE_NAME_INFO {
            DWORD FileNameLength;
            WCHAR FileName[MAX_PATH];
        };

        auto pNameInfo = std::unique_ptr<MY_FILE_NAME_INFO>(
          new (std::nothrow) MY_FILE_NAME_INFO());
        if (!pNameInfo) {
            return false;
        }

        // Check pipe name is template of
        // {"cygwin-","msys-"}XXXXXXXXXXXXXXX-ptyX-XX
        if (!ptrGetFileInformationByHandleEx(h, FileNameInfo, pNameInfo.get(),
                                             sizeof(MY_FILE_NAME_INFO))) {
            return false;
        }
        std::wstring name(pNameInfo->FileName, pNameInfo->FileNameLength / sizeof(WCHAR));
        if ((name.find(L"msys-") == std::wstring::npos
             && name.find(L"cygwin-") == std::wstring::npos)
            || name.find(L"-pty") == std::wstring::npos) {
            return false;
        }

        return true;
    }

#endif

    inline bool isTerminal(const std::streambuf *osbuf) noexcept
    {
        using std::cerr;
        using std::clog;
        using std::cout;
#if defined(OS_LINUX) || defined(OS_MAC)
        if (osbuf == cout.rdbuf()) {
            static const bool cout_term = isatty(fileno(stdout)) != 0;
            return cout_term;
        } else if (osbuf == cerr.rdbuf() || osbuf == clog.rdbuf()) {
            static const bool cerr_term = isatty(fileno(stderr)) != 0;
            return cerr_term;
        }
#elif defined(OS_WIN)
        if (osbuf == cout.rdbuf()) {
            static const bool cout_term
              = (_isatty(_fileno(stdout)) || isMsysPty(_fileno(stdout)));
            return cout_term;
        } else if (osbuf == cerr.rdbuf() || osbuf == clog.rdbuf()) {
            static const bool cerr_term
              = (_isatty(_fileno(stderr)) || isMsysPty(_fileno(stderr)));
            return cerr_term;
        }
#endif
        return false;
    }

    template <typename T>
    using enableStd = typename std::enable_if<
      std::is_same<T, rang::style>::value || std::is_same<T, rang::fg>::value
        || std::is_same<T, rang::bg>::value || std::is_same<T, rang::fgB>::value
        || std::is_same<T, rang::bgB>::value,
      std::ostream &>::type;


#ifdef OS_WIN

    struct SGR {  // Select Graphic Rendition parameters for Windows console
        BYTE fgColor;  // foreground color (0-15) lower 3 rgb bits + intense bit
        BYTE bgColor;  // background color (0-15) lower 3 rgb bits + intense bit
        BYTE bold;  // emulated as FOREGROUND_INTENSITY bit
        BYTE underline;  // emulated as BACKGROUND_INTENSITY bit
        BOOLEAN inverse;  // swap foreground/bold & background/underline
        BOOLEAN conceal;  // set foreground/bold to background/underline
    };

    enum class AttrColor : BYTE {  // Color attributes for console screen buffer
        black   = 0,
        red     = 4,
        green   = 2,
        yellow  = 6,
        blue    = 1,
        magenta = 5,
        cyan    = 3,
        gray    = 7
    };

    inline HANDLE getConsoleHandle(const std::streambuf *osbuf) noexcept
    {
        if (osbuf == std::cout.rdbuf()) {
            static const HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
            return hStdout;
        } else if (osbuf == std::cerr.rdbuf() || osbuf == std::clog.rdbuf()) {
            static const HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);
            return hStderr;
        }
        return INVALID_HANDLE_VALUE;
    }

    inline bool setWinTermAnsiColors(const std::streambuf *osbuf) noexcept
    {
        HANDLE h = getConsoleHandle(osbuf);
        if (h == INVALID_HANDLE_VALUE) {
            return false;
        }
        DWORD dwMode = 0;
        if (!GetConsoleMode(h, &dwMode)) {
            return false;
        }
        dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
        if (!SetConsoleMode(h, dwMode)) {
            return false;
        }
        return true;
    }

    inline bool supportsAnsi(const std::streambuf *osbuf) noexcept
    {
        using std::cerr;
        using std::clog;
        using std::cout;
        if (osbuf == cout.rdbuf()) {
            static const bool cout_ansi
              = (isMsysPty(_fileno(stdout)) || setWinTermAnsiColors(osbuf));
            return cout_ansi;
        } else if (osbuf == cerr.rdbuf() || osbuf == clog.rdbuf()) {
            static const bool cerr_ansi
              = (isMsysPty(_fileno(stderr)) || setWinTermAnsiColors(osbuf));
            return cerr_ansi;
        }
        return false;
    }

    inline const SGR &defaultState() noexcept
    {
        static const SGR defaultSgr = []() -> SGR {
            CONSOLE_SCREEN_BUFFER_INFO info;
            WORD attrib = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
            if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                                           &info)
                || GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE),
                                              &info)) {
                attrib = info.wAttributes;
            }
            SGR sgr     = { 0, 0, 0, 0, FALSE, FALSE };
            sgr.fgColor = attrib & 0x0F;
            sgr.bgColor = (attrib & 0xF0) >> 4;
            return sgr;
        }();
        return defaultSgr;
    }

    inline BYTE ansi2attr(BYTE rgb) noexcept
    {
        static const AttrColor rev[8]
          = { AttrColor::black,  AttrColor::red,  AttrColor::green,
              AttrColor::yellow, AttrColor::blue, AttrColor::magenta,
              AttrColor::cyan,   AttrColor::gray };
        return static_cast<BYTE>(rev[rgb]);
    }

    inline void setWinSGR(rang::bg col, SGR &state) noexcept
    {
        if (col != rang::bg::reset) {
            state.bgColor = ansi2attr(static_cast<BYTE>(col) - 40);
        } else {
            state.bgColor = defaultState().bgColor;
        }
    }

    inline void setWinSGR(rang::fg col, SGR &state) noexcept
    {
        if (col != rang::fg::reset) {
            state.fgColor = ansi2attr(static_cast<BYTE>(col) - 30);
        } else {
            state.fgColor = defaultState().fgColor;
        }
    }

    inline void setWinSGR(rang::bgB col, SGR &state) noexcept
    {
        state.bgColor = (BACKGROUND_INTENSITY >> 4)
          | ansi2attr(static_cast<BYTE>(col) - 100);
    }

    inline void setWinSGR(rang::fgB col, SGR &state) noexcept
    {
        state.fgColor
          = FOREGROUND_INTENSITY | ansi2attr(static_cast<BYTE>(col) - 90);
    }

    inline void setWinSGR(rang::style style, SGR &state) noexcept
    {
        switch (style) {
            case rang::style::reset: state = defaultState(); break;
            case rang::style::bold: state.bold = FOREGROUND_INTENSITY; break;
            case rang::style::underline:
            case rang::style::blink:
                state.underline = BACKGROUND_INTENSITY;
                break;
            case rang::style::reversed: state.inverse = TRUE; break;
            case rang::style::conceal: state.conceal = TRUE; break;
            default: break;
        }
    }

    inline SGR &current_state() noexcept
    {
        static SGR state = defaultState();
        return state;
    }

    inline WORD SGR2Attr(const SGR &state) noexcept
    {
        WORD attrib = 0;
        if (state.conceal) {
            if (state.inverse) {
                attrib = (state.fgColor << 4) | state.fgColor;
                if (state.bold)
                    attrib |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
            } else {
                attrib = (state.bgColor << 4) | state.bgColor;
                if (state.underline)
                    attrib |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
            }
        } else if (state.inverse) {
            attrib = (state.fgColor << 4) | state.bgColor;
            if (state.bold) attrib |= BACKGROUND_INTENSITY;
            if (state.underline) attrib |= FOREGROUND_INTENSITY;
        } else {
            attrib = state.fgColor | (state.bgColor << 4) | state.bold
              | state.underline;
        }
        return attrib;
    }

    template <typename T>
    inline void setWinColorAnsi(std::ostream &os, T const value)
    {
        os << "\033[" << static_cast<int>(value) << "m";
    }

    template <typename T>
    inline void setWinColorNative(std::ostream &os, T const value)
    {
        const HANDLE h = getConsoleHandle(os.rdbuf());
        if (h != INVALID_HANDLE_VALUE) {
            setWinSGR(value, current_state());
            // Out all buffered text to console with previous settings:
            os.flush();
            SetConsoleTextAttribute(h, SGR2Attr(current_state()));
        }
    }

    template <typename T>
    inline enableStd<T> setColor(std::ostream &os, T const value)
    {
        if (winTermMode() == winTerm::Auto) {
            if (supportsAnsi(os.rdbuf())) {
                setWinColorAnsi(os, value);
            } else {
                setWinColorNative(os, value);
            }
        } else if (winTermMode() == winTerm::Ansi) {
            setWinColorAnsi(os, value);
        } else {
            setWinColorNative(os, value);
        }
        return os;
    }
#else
    template <typename T>
    inline enableStd<T> setColor(std::ostream &os, T const value)
    {
        return os << "\033[" << static_cast<int>(value) << "m";
    }
#endif
}  // namespace rang_implementation

template <typename T>
inline rang_implementation::enableStd<T> operator<<(std::ostream &os,
                                                    const T value)
{
    const control option = rang_implementation::controlMode();
    switch (option) {
        case control::Auto:
            return rang_implementation::supportsColor()
                && rang_implementation::isTerminal(os.rdbuf())
              ? rang_implementation::setColor(os, value)
              : os;
        case control::Force: return rang_implementation::setColor(os, value);
        default: return os;
    }
}

inline void setWinTermMode(const rang::winTerm value) noexcept
{
    rang_implementation::winTermMode() = value;
}

inline void setControlMode(const control value) noexcept
{
    rang_implementation::controlMode() = value;
}

}  // namespace rang

#undef OS_LINUX
#undef OS_WIN
#undef OS_MAC

#endif /* ifndef RANG_DOT_HPP */

```

`shellcode-generator/rang_impl.hpp`:

```hpp
#pragma once
#include "rang.hpp"
template <typename... Args>
void __DbgPrint(const char *identifier, rang::fg color, const char *format, Args... args) {

    char buffer[2500] = {'\0'};
    sprintf_s(buffer + strlen(buffer), 2500 - strlen(buffer), format, args...);
    sprintf_s(buffer + strlen(buffer), 2500 - strlen(buffer), "\n");
    std::cout << "[ " << rang::style::bold << color << identifier << rang::style::reset << rang::fg::reset << " ]"
              << buffer;
}

#define erro(...) __DbgPrint("erro", rang::fg::red, __VA_ARGS__)
#define info(...) __DbgPrint("info", rang::fg::blue, __VA_ARGS__)
#define important(...) __DbgPrint("important", rang::fg::magenta, __VA_ARGS__)
#define success(...) __DbgPrint("success", rang::fg::green, __VA_ARGS__)

#define ERO(...) erro(__VA_ARGS__)
#define INF(...) info( __VA_ARGS__)
#define IMP(...) important(__VA_ARGS__)
#define SUC(...) success(__VA_ARGS__)
```

`shellcode-generator/shellcode-generator.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="coff.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="coff.h" />
    <ClInclude Include="misc.hpp" />
    <ClInclude Include="rang.hpp" />
    <ClInclude Include="rang_impl.hpp" />
    <ClInclude Include="span.hpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7ada88eb-a76b-4854-9dfb-caa17412a6de}</ProjectGuid>
    <RootNamespace>shellcodegenerator</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`shellcode-generator/shellcode-generator.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="coff.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="coff.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="rang.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="rang_impl.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="span.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="misc.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`shellcode-generator/span.hpp`:

```hpp

/*
This is an implementation of C++20's std::span
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4820.pdf
*/

//          Copyright Tristan Brindle 2018.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../../LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)

#ifndef TCB_SPAN_HPP_INCLUDED
#define TCB_SPAN_HPP_INCLUDED

#include <array>
#include <cstddef>
#include <cstdint>
#include <type_traits>

#ifndef TCB_SPAN_NO_EXCEPTIONS
// Attempt to discover whether we're being compiled with exception support
#if !(defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND))
#define TCB_SPAN_NO_EXCEPTIONS
#endif
#endif

#ifndef TCB_SPAN_NO_EXCEPTIONS
#include <cstdio>
#include <stdexcept>
#endif

// Various feature test macros

#ifndef TCB_SPAN_NAMESPACE_NAME
#define TCB_SPAN_NAMESPACE_NAME tcb
#endif

#if __cplusplus >= 201703L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
#define TCB_SPAN_HAVE_CPP17
#endif

#if __cplusplus >= 201402L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
#define TCB_SPAN_HAVE_CPP14
#endif

namespace TCB_SPAN_NAMESPACE_NAME {

// Establish default contract checking behavior
#if !defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION) &&                          \
    !defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION) &&                      \
    !defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#if defined(NDEBUG) || !defined(TCB_SPAN_HAVE_CPP14)
#define TCB_SPAN_NO_CONTRACT_CHECKING
#else
#define TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION
#endif
#endif

#if defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION)
struct contract_violation_error : std::logic_error {
    explicit contract_violation_error(const char* msg) : std::logic_error(msg)
    {}
};

inline void contract_violation(const char* msg)
{
    throw contract_violation_error(msg);
}

#elif defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION)
[[noreturn]] inline void contract_violation(const char* /*unused*/)
{
    std::terminate();
}
#endif

#if !defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#define TCB_SPAN_STRINGIFY(cond) #cond
#define TCB_SPAN_EXPECT(cond)                                                  \
    cond ? (void) 0 : contract_violation("Expected " TCB_SPAN_STRINGIFY(cond))
#else
#define TCB_SPAN_EXPECT(cond)
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_inline_variables)
#define TCB_SPAN_INLINE_VAR inline
#else
#define TCB_SPAN_INLINE_VAR
#endif

#if defined(TCB_SPAN_HAVE_CPP14) ||                                            \
    (defined(__cpp_constexpr) && __cpp_constexpr >= 201304)
#define TCB_SPAN_HAVE_CPP14_CONSTEXPR
#endif

#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR)
#define TCB_SPAN_CONSTEXPR14 constexpr
#else
#define TCB_SPAN_CONSTEXPR14
#endif

#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR) &&                                  \
    (!defined(_MSC_VER) || _MSC_VER > 1900)
#define TCB_SPAN_CONSTEXPR_ASSIGN constexpr
#else
#define TCB_SPAN_CONSTEXPR_ASSIGN
#endif

#if defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#define TCB_SPAN_CONSTEXPR11 constexpr
#else
#define TCB_SPAN_CONSTEXPR11 TCB_SPAN_CONSTEXPR14
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_deduction_guides)
#define TCB_SPAN_HAVE_DEDUCTION_GUIDES
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_byte)
#define TCB_SPAN_HAVE_STD_BYTE
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_array_constexpr)
#define TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC
#endif

#if defined(TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC)
#define TCB_SPAN_ARRAY_CONSTEXPR constexpr
#else
#define TCB_SPAN_ARRAY_CONSTEXPR
#endif

#ifdef TCB_SPAN_HAVE_STD_BYTE
using byte = std::byte;
#else
using byte = unsigned char;
#endif

#if defined(TCB_SPAN_HAVE_CPP17)
#define TCB_SPAN_NODISCARD [[nodiscard]]
#else
#define TCB_SPAN_NODISCARD
#endif

TCB_SPAN_INLINE_VAR constexpr std::size_t dynamic_extent = SIZE_MAX;

template <typename ElementType, std::size_t Extent = dynamic_extent>
class span;

namespace detail {

template <typename E, std::size_t S>
struct span_storage {
    constexpr span_storage() noexcept = default;

    constexpr span_storage(E* p_ptr, std::size_t /*unused*/) noexcept
       : ptr(p_ptr)
    {}

    E* ptr = nullptr;
    static constexpr std::size_t size = S;
};

template <typename E>
struct span_storage<E, dynamic_extent> {
    constexpr span_storage() noexcept = default;

    constexpr span_storage(E* p_ptr, std::size_t p_size) noexcept
        : ptr(p_ptr), size(p_size)
    {}

    E* ptr = nullptr;
    std::size_t size = 0;
};

// Reimplementation of C++17 std::size() and std::data()
#if defined(TCB_SPAN_HAVE_CPP17) ||                                            \
    defined(__cpp_lib_nonmember_container_access)
using std::data;
using std::size;
#else
template <class C>
constexpr auto size(const C& c) -> decltype(c.size())
{
    return c.size();
}

template <class T, std::size_t N>
constexpr std::size_t size(const T (&)[N]) noexcept
{
    return N;
}

template <class C>
constexpr auto data(C& c) -> decltype(c.data())
{
    return c.data();
}

template <class C>
constexpr auto data(const C& c) -> decltype(c.data())
{
    return c.data();
}

template <class T, std::size_t N>
constexpr T* data(T (&array)[N]) noexcept
{
    return array;
}

template <class E>
constexpr const E* data(std::initializer_list<E> il) noexcept
{
    return il.begin();
}
#endif // TCB_SPAN_HAVE_CPP17

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_void_t)
using std::void_t;
#else
template <typename...>
using void_t = void;
#endif

template <typename T>
using uncvref_t =
    typename std::remove_cv<typename std::remove_reference<T>::type>::type;

template <typename>
struct is_span : std::false_type {};

template <typename T, std::size_t S>
struct is_span<span<T, S>> : std::true_type {};

template <typename>
struct is_std_array : std::false_type {};

template <typename T, std::size_t N>
struct is_std_array<std::array<T, N>> : std::true_type {};

template <typename, typename = void>
struct has_size_and_data : std::false_type {};

template <typename T>
struct has_size_and_data<T, void_t<decltype(detail::size(std::declval<T>())),
                                   decltype(detail::data(std::declval<T>()))>>
    : std::true_type {};

template <typename C, typename U = uncvref_t<C>>
struct is_container {
    static constexpr bool value =
        !is_span<U>::value && !is_std_array<U>::value &&
        !std::is_array<U>::value && has_size_and_data<C>::value;
};

template <typename T>
using remove_pointer_t = typename std::remove_pointer<T>::type;

template <typename, typename, typename = void>
struct is_container_element_type_compatible : std::false_type {};

template <typename T, typename E>
struct is_container_element_type_compatible<
    T, E,
    typename std::enable_if<
        !std::is_same<
            typename std::remove_cv<decltype(detail::data(std::declval<T>()))>::type,
            void>::value &&
        std::is_convertible<
            remove_pointer_t<decltype(detail::data(std::declval<T>()))> (*)[],
            E (*)[]>::value
        >::type>
    : std::true_type {};

template <typename, typename = size_t>
struct is_complete : std::false_type {};

template <typename T>
struct is_complete<T, decltype(sizeof(T))> : std::true_type {};

} // namespace detail

template <typename ElementType, std::size_t Extent>
class span {
    static_assert(std::is_object<ElementType>::value,
                  "A span's ElementType must be an object type (not a "
                  "reference type or void)");
    static_assert(detail::is_complete<ElementType>::value,
                  "A span's ElementType must be a complete type (not a forward "
                  "declaration)");
    static_assert(!std::is_abstract<ElementType>::value,
                  "A span's ElementType cannot be an abstract class type");

    using storage_type = detail::span_storage<ElementType, Extent>;

public:
    // constants and types
    using element_type = ElementType;
    using value_type = typename std::remove_cv<ElementType>::type;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using pointer = element_type*;
    using const_pointer = const element_type*;
    using reference = element_type&;
    using const_reference = const element_type&;
    using iterator = pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;

    static constexpr size_type extent = Extent;

    // [span.cons], span constructors, copy, assignment, and destructor
    template <
        std::size_t E = Extent,
        typename std::enable_if<(E == dynamic_extent || E <= 0), int>::type = 0>
    constexpr span() noexcept
    {}

    TCB_SPAN_CONSTEXPR11 span(pointer ptr, size_type count)
        : storage_(ptr, count)
    {
        TCB_SPAN_EXPECT(extent == dynamic_extent || count == extent);
    }

    TCB_SPAN_CONSTEXPR11 span(pointer first_elem, pointer last_elem)
        : storage_(first_elem, last_elem - first_elem)
    {
        TCB_SPAN_EXPECT(extent == dynamic_extent ||
                        last_elem - first_elem ==
                            static_cast<std::ptrdiff_t>(extent));
    }

    template <std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          element_type (&)[N], ElementType>::value,
                  int>::type = 0>
    constexpr span(element_type (&arr)[N]) noexcept : storage_(arr, N)
    {}

    template <std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          std::array<value_type, N>&, ElementType>::value,
                  int>::type = 0>
    TCB_SPAN_ARRAY_CONSTEXPR span(std::array<value_type, N>& arr) noexcept
        : storage_(arr.data(), N)
    {}

    template <std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          const std::array<value_type, N>&, ElementType>::value,
                  int>::type = 0>
    TCB_SPAN_ARRAY_CONSTEXPR span(const std::array<value_type, N>& arr) noexcept
        : storage_(arr.data(), N)
    {}

    template <
        typename Container, std::size_t E = Extent,
        typename std::enable_if<
            E == dynamic_extent && detail::is_container<Container>::value &&
                detail::is_container_element_type_compatible<
                    Container&, ElementType>::value,
            int>::type = 0>
    constexpr span(Container& cont)
        : storage_(detail::data(cont), detail::size(cont))
    {}

    template <
        typename Container, std::size_t E = Extent,
        typename std::enable_if<
            E == dynamic_extent && detail::is_container<Container>::value &&
                detail::is_container_element_type_compatible<
                    const Container&, ElementType>::value,
            int>::type = 0>
    constexpr span(const Container& cont)
        : storage_(detail::data(cont), detail::size(cont))
    {}

    constexpr span(const span& other) noexcept = default;

    template <typename OtherElementType, std::size_t OtherExtent,
              typename std::enable_if<
                  (Extent == OtherExtent || Extent == dynamic_extent) &&
                      std::is_convertible<OtherElementType (*)[],
                                          ElementType (*)[]>::value,
                  int>::type = 0>
    constexpr span(const span<OtherElementType, OtherExtent>& other) noexcept
        : storage_(other.data(), other.size())
    {}

    ~span() noexcept = default;

    TCB_SPAN_CONSTEXPR_ASSIGN span&
    operator=(const span& other) noexcept = default;

    // [span.sub], span subviews
    template <std::size_t Count>
    TCB_SPAN_CONSTEXPR11 span<element_type, Count> first() const
    {
        TCB_SPAN_EXPECT(Count <= size());
        return {data(), Count};
    }

    template <std::size_t Count>
    TCB_SPAN_CONSTEXPR11 span<element_type, Count> last() const
    {
        TCB_SPAN_EXPECT(Count <= size());
        return {data() + (size() - Count), Count};
    }

    template <std::size_t Offset, std::size_t Count = dynamic_extent>
    using subspan_return_t =
        span<ElementType, Count != dynamic_extent
                              ? Count
                              : (Extent != dynamic_extent ? Extent - Offset
                                                          : dynamic_extent)>;

    template <std::size_t Offset, std::size_t Count = dynamic_extent>
    TCB_SPAN_CONSTEXPR11 subspan_return_t<Offset, Count> subspan() const
    {
        TCB_SPAN_EXPECT(Offset <= size() &&
                        (Count == dynamic_extent || Offset + Count <= size()));
        return {data() + Offset,
                Count != dynamic_extent ? Count : size() - Offset};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    first(size_type count) const
    {
        TCB_SPAN_EXPECT(count <= size());
        return {data(), count};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    last(size_type count) const
    {
        TCB_SPAN_EXPECT(count <= size());
        return {data() + (size() - count), count};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    subspan(size_type offset, size_type count = dynamic_extent) const
    {
        TCB_SPAN_EXPECT(offset <= size() &&
                        (count == dynamic_extent || offset + count <= size()));
        return {data() + offset,
                count == dynamic_extent ? size() - offset : count};
    }

    // [span.obs], span observers
    constexpr size_type size() const noexcept { return storage_.size; }

    constexpr size_type size_bytes() const noexcept
    {
        return size() * sizeof(element_type);
    }

    TCB_SPAN_NODISCARD constexpr bool empty() const noexcept
    {
        return size() == 0;
    }

    // [span.elem], span element access
    TCB_SPAN_CONSTEXPR11 reference operator[](size_type idx) const
    {
        TCB_SPAN_EXPECT(idx < size());
        return *(data() + idx);
    }

    TCB_SPAN_CONSTEXPR11 reference front() const
    {
        TCB_SPAN_EXPECT(!empty());
        return *data();
    }

    TCB_SPAN_CONSTEXPR11 reference back() const
    {
        TCB_SPAN_EXPECT(!empty());
        return *(data() + (size() - 1));
    }

    constexpr pointer data() const noexcept { return storage_.ptr; }

    // [span.iterators], span iterator support
    constexpr iterator begin() const noexcept { return data(); }

    constexpr iterator end() const noexcept { return data() + size(); }

    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rbegin() const noexcept
    {
        return reverse_iterator(end());
    }

    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rend() const noexcept
    {
        return reverse_iterator(begin());
    }

private:
    storage_type storage_{};
};

#ifdef TCB_SPAN_HAVE_DEDUCTION_GUIDES

/* Deduction Guides */
template <class T, size_t N>
span(T (&)[N])->span<T, N>;

template <class T, size_t N>
span(std::array<T, N>&)->span<T, N>;

template <class T, size_t N>
span(const std::array<T, N>&)->span<const T, N>;

template <class Container>
span(Container&)->span<typename Container::value_type>;

template <class Container>
span(const Container&)->span<const typename Container::value_type>;

#endif // TCB_HAVE_DEDUCTION_GUIDES

template <typename ElementType, std::size_t Extent>
constexpr span<ElementType, Extent>
make_span(span<ElementType, Extent> s) noexcept
{
    return s;
}

template <typename T, std::size_t N>
constexpr span<T, N> make_span(T (&arr)[N]) noexcept
{
    return {arr};
}

template <typename T, std::size_t N>
TCB_SPAN_ARRAY_CONSTEXPR span<T, N> make_span(std::array<T, N>& arr) noexcept
{
    return {arr};
}

template <typename T, std::size_t N>
TCB_SPAN_ARRAY_CONSTEXPR span<const T, N>
make_span(const std::array<T, N>& arr) noexcept
{
    return {arr};
}

template <typename Container>
constexpr span<typename Container::value_type> make_span(Container& cont)
{
    return {cont};
}

template <typename Container>
constexpr span<const typename Container::value_type>
make_span(const Container& cont)
{
    return {cont};
}

template <typename ElementType, std::size_t Extent>
span<const byte, ((Extent == dynamic_extent) ? dynamic_extent
                                             : sizeof(ElementType) * Extent)>
as_bytes(span<ElementType, Extent> s) noexcept
{
    return {reinterpret_cast<const byte*>(s.data()), s.size_bytes()};
}

template <
    class ElementType, size_t Extent,
    typename std::enable_if<!std::is_const<ElementType>::value, int>::type = 0>
span<byte, ((Extent == dynamic_extent) ? dynamic_extent
                                       : sizeof(ElementType) * Extent)>
as_writable_bytes(span<ElementType, Extent> s) noexcept
{
    return {reinterpret_cast<byte*>(s.data()), s.size_bytes()};
}

template <std::size_t N, typename E, std::size_t S>
constexpr auto get(span<E, S> s) -> decltype(s[N])
{
    return s[N];
}

} // namespace TCB_SPAN_NAMESPACE_NAME

namespace std {

template <typename ElementType, size_t Extent>
class tuple_size<TCB_SPAN_NAMESPACE_NAME::span<ElementType, Extent>>
    : public integral_constant<size_t, Extent> {};

template <typename ElementType>
class tuple_size<TCB_SPAN_NAMESPACE_NAME::span<
    ElementType, TCB_SPAN_NAMESPACE_NAME::dynamic_extent>>; // not defined

template <size_t I, typename ElementType, size_t Extent>
class tuple_element<I, TCB_SPAN_NAMESPACE_NAME::span<ElementType, Extent>> {
public:
    static_assert(Extent != TCB_SPAN_NAMESPACE_NAME::dynamic_extent &&
                      I < Extent,
                  "");
    using type = ElementType;
};

} // end namespace std

#endif // TCB_SPAN_HPP_INCLUDED

```

`shellcode-payload/call-extern-demo.cpp`:

```cpp
#include "shellcode.h"


void ShellcodeFunctionCallExternExample(void) {

    //使用系统 API
    LI_FN(MessageBoxA)(HWND(0), "Shellcode Function Call Extern Example", xorstr_("Display from shellcode!"), MB_OK | MB_TOPMOST);

    return;
}
```

`shellcode-payload/dwm-capture.h`:

```h
#pragma once
```

`shellcode-payload/dwm-screen-shot-demo.cpp`:

```cpp
#include "dwm-capture.h"
#include "shellcode.h"
#include <dxgi.h>
#include <d3d11.h>
#include <wrl.h>
#define _GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)                                                     \
    GUID name = {l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8};

// 这里直接把 Nt函数的定义给出来，取个巧，依靠 lazy_importer 获取函数并调用
PVOID NTAPI RtlAddVectoredExceptionHandler(IN ULONG FirstHandler, IN PVECTORED_EXCEPTION_HANDLER VectoredHandler);
ULONG NTAPI RtlRemoveVectoredExceptionHandler(IN PVOID VectoredHandlerHandle);

LONG WINAPI VehHandler(EXCEPTION_POINTERS *pExceptionInfo);
void        TakeDxgiCapture(IUnknown *pDXGISwapChain);
__int64 __fastcall HookFunCallBack(IUnknown *pDXGISwapChain, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6,
                                   __int64 a7, __int64 a8);

//可以将优化开到最大，那全局变量最好使用 volatile 修饰

//使用公开的静态和导出变量
SC_EXPORT_DATA(volatile __int64, hook_offsets[4]) // hook符号偏移，由注入器在注入shellcode前修正
SC_EXPORT_DATA(volatile __int64, CaptureBitmapPointer) // 公开变量 目的是让注入器确定偏移位置
SC_EXPORT_DATA(volatile unsigned int, CaptureWidth)
SC_EXPORT_DATA(volatile unsigned int, CaptureHeight)

// 使用全局和静态变量
volatile unsigned long hook_fun_execute      = 0; // hook函数是否执行
volatile unsigned long  hook_fun_done         = 0; //截图函数是否执行
volatile DWORD          hook_fun_memory_proct = 0; //被hook函数内存属性
volatile DWORD64         hook_fun_address      = 0; // hook函数地址

//使用内嵌函数 这个东西只在本cpp起作用，不要写在.h里面 写在每个cpp的最开头部分
extern "C" {
#pragma function(memset)
void *__cdecl memset(void *dest, int value, size_t num) {
    __stosb(static_cast<unsigned char *>(dest), static_cast<unsigned char>(value), num);
    return dest;
}
#pragma function(memcpy)
void *__cdecl memcpy(void *dest, const void *src, size_t num) {
    __movsb(static_cast<unsigned char *>(dest), static_cast<const unsigned char *>(src), num);
    return dest;
}
}

SC_EXPORT DWORD DwmCaptureScreen(LPVOID lpParameter) {

    DbgPrint("Dwm Capture Screen Thread Entered!");

#ifdef _DEBUG
    for (size_t idx = 0; idx < ArrNum(hook_offsets); idx++) {
        if (hook_offsets[idx] == 0) {
            DbgPrint("Null offset");
            return -1;
        } else {
            HMODULE hDxgi = LI_FN(GetModuleHandleA)("dxgi.dll");
            DbgPrint("Hook Offset 0x%p address 0x%p", hook_offsets[idx], hook_offsets[idx] + (DWORD64)hDxgi);
        }
    }
#endif // _DEBUG


    PVOID veh_hanle = LI_FN(RtlAddVectoredExceptionHandler)(1, VehHandler);
    if (!veh_hanle) {
        DbgPrint("veh erro !");
        return -1;
    }

    for (size_t idx = 0; idx < ArrNum(hook_offsets); idx++) {

        hook_fun_address = 0;

        HMODULE hDxgi = LI_FN(GetModuleHandleA)("dxgi.dll");

        hook_fun_address = (DWORD64)hDxgi + hook_offsets[idx];

        MEMORY_BASIC_INFORMATION mem_info;
        memset(&mem_info, 0, sizeof(mem_info));
        LI_FN(VirtualQuery)((LPCVOID)hook_fun_address, &mem_info, sizeof(mem_info));
        hook_fun_memory_proct = mem_info.Protect;

        DbgPrint("set hook at 0x%p\t ", hook_fun_address);

        LI_FN(VirtualProtect)((LPVOID)hook_fun_address, 1, mem_info.Protect | PAGE_GUARD, (PDWORD)&hook_fun_memory_proct);

        for (size_t i = 0;; i++) {
            LI_FN(Sleep)(100);
            if (i > 50 ) {
                DbgPrint("hook time out ");
                if (_InterlockedCompareExchange(&hook_fun_execute, 1, 1) == 0) {
                    break;
                }
            }
            if (_InterlockedCompareExchange(&hook_fun_done, 1, 1) == 1)
                break;
        }

        LI_FN(VirtualProtect)((LPVOID)hook_fun_address, 1, mem_info.Protect, (PDWORD)&hook_fun_memory_proct);

        if (_InterlockedCompareExchange(&hook_fun_execute, 1, 1) == 1)
            break;
        else
            continue;
    }

    LI_FN(RtlRemoveVectoredExceptionHandler)(veh_hanle);


    DbgPrint("fun_execute:[%d]\t fun_done:[%d]\t ", _InterlockedCompareExchange(&hook_fun_execute, 1, 1),
             _InterlockedCompareExchange(&hook_fun_done, 1, 1));

    if (_InterlockedCompareExchange(&hook_fun_execute, 1, 1) == 1 &&
        _InterlockedCompareExchange(&hook_fun_done, 1, 1) == 1) {
        return 1;
    }

    return -1;
}


LONG WINAPI VehHandler(EXCEPTION_POINTERS *pExceptionInfo) {

    DWORD64 page_start = ((DWORD64)(hook_fun_address)) & 0xFFFFFFFFFFFFF000;
    DWORD64 page_end   = page_start + 0x1000;

    LONG result;
    if (pExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_GUARD_PAGE_VIOLATION) //
    {
        if ((pExceptionInfo->ContextRecord->Rip >= page_start) && (pExceptionInfo->ContextRecord->Rip <= page_end)) {

            if (pExceptionInfo->ContextRecord->Rip == (DWORD64)(hook_fun_address)) {

                _InterlockedExchange(&hook_fun_execute, 1 );

                pExceptionInfo->ContextRecord->Rip = (DWORD64)&HookFunCallBack;

                return EXCEPTION_CONTINUE_EXECUTION;
            }

            pExceptionInfo->ContextRecord->EFlags |= 0x100;
        }

        result = EXCEPTION_CONTINUE_EXECUTION;
    }

    else if (pExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) {
        DWORD dwOld;
        LI_FN(VirtualProtect)((LPVOID)hook_fun_address, 1, hook_fun_memory_proct | PAGE_GUARD, &dwOld);
        result = EXCEPTION_CONTINUE_EXECUTION;
    }

    else {
        result = EXCEPTION_CONTINUE_SEARCH;
    }

    return result;
}

__int64 __fastcall HookFunCallBack(IUnknown *pDXGISwapChain, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7,
                                   __int64 a8) {
   
    DbgPrint("HookFunCallBack IUnknown* [0x%p]", pDXGISwapChain);

    auto ret = // 调用原 hook 函数
        reinterpret_cast<decltype(HookFunCallBack) *>(hook_fun_address)(pDXGISwapChain, a2, a3, a4, a5, a6, a7, a8);
    
    //保存 dxgi 画面
    TakeDxgiCapture(pDXGISwapChain);

    return ret;
}

/*
从交换链获取D3D设备、上下文、和后备缓冲区（纹理），
将 和后备缓冲区 拷贝至我们创建的 pCaptureD3D11Texture2D(CPU可访问的)
map pCaptureD3D11Texture2D 然后将bitmap拷贝出来
*/
void TakeDxgiCapture(IUnknown *pDXGISwapChain) {

    // 使用 comptr 模板来避免手动管理 com资源
    Microsoft::WRL::ComPtr<ID3D11Device>        pD3D11Device;
    Microsoft::WRL::ComPtr<ID3D11DeviceContext> pID3D11DeviceContext;
    Microsoft::WRL::ComPtr<ID3D11Texture2D>     pD3D11Texture2D;
    Microsoft::WRL::ComPtr<ID3D11Texture2D>     pCaptureD3D11Texture2D;
    D3D11_TEXTURE2D_DESC                        SwapChanDesc{};

    // 不要直接使用 D3D SDK中的 IID_ID3D11Device 等全局变量，这些变量储存在dx系列的 lib和 dll中 
    _GUID(IID_ID3D11Device, 0xdb6f6ddb, 0xac77, 0x4e88, 0x82, 0x53, 0x81, 0x9d, 0xf9, 0xbb, 0xf1, 0x40);
    auto hr = reinterpret_cast<IDXGISwapChain*>(pDXGISwapChain)
                  ->GetDevice(IID_ID3D11Device, (void **)pD3D11Device.ReleaseAndGetAddressOf());

    if (hr == S_OK) {
        _GUID(IID_ID3D11Texture2D, 0x6f15aaf2, 0xd208, 0x4e89, 0x9a, 0xb4, 0x48, 0x95, 0x35, 0xd3, 0x4f, 0x9c);
        hr = reinterpret_cast<IDXGISwapChain *>(pDXGISwapChain)
                 ->GetBuffer(0,IID_ID3D11Texture2D, (void **)pD3D11Texture2D.ReleaseAndGetAddressOf());

        if (hr == S_OK) {
            pD3D11Texture2D->GetDesc(&SwapChanDesc);
            SwapChanDesc.BindFlags      = 0;
            SwapChanDesc.MiscFlags      = 0;
            // CPU可访问的纹理
            SwapChanDesc.CPUAccessFlags = 0x30000;
            SwapChanDesc.Usage          = D3D11_USAGE_STAGING;
            hr = pD3D11Device->CreateTexture2D(&SwapChanDesc, 0, pCaptureD3D11Texture2D.ReleaseAndGetAddressOf());

            if (hr == S_OK) {
                pD3D11Device->GetImmediateContext(pID3D11DeviceContext.ReleaseAndGetAddressOf());

                pID3D11DeviceContext->CopyResource(pCaptureD3D11Texture2D.Get(), pD3D11Texture2D.Get());

                D3D11_MAPPED_SUBRESOURCE MappedResource{};
                hr = pID3D11DeviceContext->Map(pCaptureD3D11Texture2D.Get(), 0, D3D11_MAP_READ_WRITE, 0,
                                               &MappedResource);

                if (hr == S_OK) {
                    LPVOID buffer =
                        LI_FN(VirtualAlloc)((LPVOID)0,
                                            static_cast<SIZE_T>(sizeof(D3D11_TEXTURE2D_DESC) +
                                            (static_cast<SIZE_T>(SwapChanDesc.Height) * SwapChanDesc.Width * 0x4)),
                                            MEM_COMMIT,
                                            PAGE_READWRITE);

                    // 申请的内存是 Height * Width * 4  + sizeof(D3D11_TEXTURE2D_DESC) 也就是把 desc也直接一起复制到了申请的内存中，这样我们在  dwm-screen-shot.exe中省了很多麻烦
                    memcpy(buffer, &SwapChanDesc, sizeof(D3D11_TEXTURE2D_DESC));
                    memcpy((char *)buffer + sizeof(D3D11_TEXTURE2D_DESC), MappedResource.pData,
                           (static_cast<SIZE_T>(SwapChanDesc.Height) * SwapChanDesc.Width * 0x4));
                    CaptureBitmapPointer = (__int64)buffer;
                    CaptureWidth         = SwapChanDesc.Width;
                    CaptureHeight        = SwapChanDesc.Height;
                    pID3D11DeviceContext->Unmap(pCaptureD3D11Texture2D.Get(), 0);

                    DbgPrint("Success at 0x%p [ %d * %d ]", CaptureBitmapPointer, CaptureWidth, CaptureHeight);

                    _InterlockedExchange(&hook_fun_done, 1);
                    return;

                } else {
                    goto Fail;
                }
            } else {
                goto Fail;
            }
        } else {
            goto Fail;
        }
    } else {
        goto Fail;
    }

    //由于过程不复杂，并且使用了智能指针，所以我们 goto！
Fail:
    DbgPrint("TakeDxgiCapture Fail !");
    _InterlockedExchange(&hook_fun_done, 1);
}
```

`shellcode-payload/lazy_importer.hpp`:

```hpp
/*
 * Copyright 2018-2022 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// === FAQ === documentation is available at https://github.com/JustasMasiulis/lazy_importer
// * Code doesn't compile with errors about pointer conversion:
//  - Try using `nullptr` instead of `NULL` or call `get()` instead of using the overloaded operator()
// * Lazy importer can't find the function I want:
//   - Double check that the module in which it's located in is actually loaded
//   - Try #define LAZY_IMPORTER_CASE_INSENSITIVE
//     This will start using case insensitive comparison globally
//   - Try #define LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
//     This will enable forwarded export resolution globally instead of needing explicit `forwarded()` calls

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP


#define LI_FN(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<LAZY_IMPORTER_KHASH(name)>()

#ifndef LAZY_IMPORTER_CPP_FORWARD
#ifdef LAZY_IMPORTER_NO_CPP_FORWARD
#define LAZY_IMPORTER_CPP_FORWARD(t, v) v
#else
#include <utility>
#define LAZY_IMPORTER_CPP_FORWARD(t, v) std::forward<t>( v )
#endif
#endif

#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif


#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_CASE_SENSITIVITY false
#else
#define LAZY_IMPORTER_CASE_SENSITIVITY true
#endif

#define LAZY_IMPORTER_STRINGIZE(x) #x
#define LAZY_IMPORTER_STRINGIZE_EXPAND(x) LAZY_IMPORTER_STRINGIZE(x)

#define LAZY_IMPORTER_KHASH(str) ::li::detail::khash(str, \
    ::li::detail::khash_impl( __TIME__ __DATE__ LAZY_IMPORTER_STRINGIZE_EXPAND(__LINE__) LAZY_IMPORTER_STRINGIZE_EXPAND(__COUNTER__), 2166136261 ))

namespace li { namespace detail {

    namespace win {

        struct LIST_ENTRY_T {
            const char* Flink;
            const char* Blink;
        };

        struct UNICODE_STRING_T {
            unsigned short Length;
            unsigned short MaximumLength;
            wchar_t*       Buffer;
        };

        struct PEB_LDR_DATA_T {
            unsigned long Length;
            unsigned long Initialized;
            const char*   SsHandle;
            LIST_ENTRY_T  InLoadOrderModuleList;
        };

        struct PEB_T {
            unsigned char   Reserved1[2];
            unsigned char   BeingDebugged;
            unsigned char   Reserved2[1];
            const char*     Reserved3[2];
            PEB_LDR_DATA_T* Ldr;
        };

        struct LDR_DATA_TABLE_ENTRY_T {
            LIST_ENTRY_T InLoadOrderLinks;
            LIST_ENTRY_T InMemoryOrderLinks;
            LIST_ENTRY_T InInitializationOrderLinks;
            const char*  DllBase;
            const char*  EntryPoint;
            union {
                unsigned long SizeOfImage;
                const char*   _dummy;
            };
            UNICODE_STRING_T FullDllName;
            UNICODE_STRING_T BaseDllName;

            LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                                            load_order_next() const noexcept
            {
                return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                    InLoadOrderLinks.Flink);
            }
        };

        struct IMAGE_DOS_HEADER { // DOS .EXE header
            unsigned short e_magic; // Magic number
            unsigned short e_cblp; // Bytes on last page of file
            unsigned short e_cp; // Pages in file
            unsigned short e_crlc; // Relocations
            unsigned short e_cparhdr; // Size of header in paragraphs
            unsigned short e_minalloc; // Minimum extra paragraphs needed
            unsigned short e_maxalloc; // Maximum extra paragraphs needed
            unsigned short e_ss; // Initial (relative) SS value
            unsigned short e_sp; // Initial SP value
            unsigned short e_csum; // Checksum
            unsigned short e_ip; // Initial IP value
            unsigned short e_cs; // Initial (relative) CS value
            unsigned short e_lfarlc; // File address of relocation table
            unsigned short e_ovno; // Overlay number
            unsigned short e_res[4]; // Reserved words
            unsigned short e_oemid; // OEM identifier (for e_oeminfo)
            unsigned short e_oeminfo; // OEM information; e_oemid specific
            unsigned short e_res2[10]; // Reserved words
            long           e_lfanew; // File address of new exe header
        };

        struct IMAGE_FILE_HEADER {
            unsigned short Machine;
            unsigned short NumberOfSections;
            unsigned long  TimeDateStamp;
            unsigned long  PointerToSymbolTable;
            unsigned long  NumberOfSymbols;
            unsigned short SizeOfOptionalHeader;
            unsigned short Characteristics;
        };

        struct IMAGE_EXPORT_DIRECTORY {
            unsigned long  Characteristics;
            unsigned long  TimeDateStamp;
            unsigned short MajorVersion;
            unsigned short MinorVersion;
            unsigned long  Name;
            unsigned long  Base;
            unsigned long  NumberOfFunctions;
            unsigned long  NumberOfNames;
            unsigned long  AddressOfFunctions; // RVA from base of image
            unsigned long  AddressOfNames; // RVA from base of image
            unsigned long  AddressOfNameOrdinals; // RVA from base of image
        };

        struct IMAGE_DATA_DIRECTORY {
            unsigned long VirtualAddress;
            unsigned long Size;
        };

        struct IMAGE_OPTIONAL_HEADER64 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long long   ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long long   SizeOfStackReserve;
            unsigned long long   SizeOfStackCommit;
            unsigned long long   SizeOfHeapReserve;
            unsigned long long   SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_OPTIONAL_HEADER32 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long        BaseOfData;
            unsigned long        ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long        SizeOfStackReserve;
            unsigned long        SizeOfStackCommit;
            unsigned long        SizeOfHeapReserve;
            unsigned long        SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_NT_HEADERS {
            unsigned long     Signature;
            IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
            IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
            IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
        };

    } // namespace win

    struct forwarded_hashes {
       unsigned module_hash;
       unsigned function_hash;
    };

    // 64 bit integer where 32 bits are used for the hash offset
    // and remaining 32 bits are used for the hash computed using it
    using offset_hash_pair = unsigned long long;

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_hash(offset_hash_pair pair) noexcept { return ( pair & 0xFFFFFFFF ); }

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_offset(offset_hash_pair pair) noexcept { return ( pair >> 32 ); }

    template<bool CaseSensitive = LAZY_IMPORTER_CASE_SENSITIVITY>
    LAZY_IMPORTER_FORCEINLINE constexpr unsigned hash_single(unsigned value, char c) noexcept
    {
        return static_cast<unsigned int>(
            (value ^ ((CaseSensitive && c >= 'A' && c <= 'Z') ? (c | (1 << 5)) : c)) *
            static_cast<unsigned long long>(16777619));
    }

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned
        khash_impl(const char* str, unsigned value) noexcept
    {
        return (*str ? khash_impl(str + 1, hash_single(value, *str)) : value);
    }

    LAZY_IMPORTER_FORCEINLINE constexpr offset_hash_pair khash(
        const char* str, unsigned offset) noexcept
    {
        return ((offset_hash_pair{ offset } << 32) | khash_impl(str, offset));
    }

    template<class CharT = char>
    LAZY_IMPORTER_FORCEINLINE unsigned hash(const CharT* str, unsigned offset) noexcept
    {
        unsigned value = offset;

        for(;;) {
            char c = *str++;
            if(!c)
                return value;
            value = hash_single(value, c);
        }
    }

    LAZY_IMPORTER_FORCEINLINE unsigned hash(
       const win::UNICODE_STRING_T& str, unsigned offset) noexcept
    {
        auto       first = str.Buffer;
        const auto last  = first + (str.Length / sizeof(wchar_t));
        auto       value = offset;
        for(; first != last; ++first)
            value = hash_single(value, static_cast<char>(*first));

        return value;
    }

    LAZY_IMPORTER_FORCEINLINE forwarded_hashes hash_forwarded(
        const char* str, unsigned offset) noexcept
    {
        forwarded_hashes res{ offset, offset };

        for(; *str != '.'; ++str)
            res.module_hash = hash_single<true>(res.module_hash, *str);

        ++str;

        for(; *str; ++str)
            res.function_hash = hash_single(res.function_hash, *str);

        return res;
    }

    // some helper functions
    LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
    {
#if defined(_M_X64) || defined(__amd64__)
        return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
        return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
        return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
        return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
        return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
    }

    LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
    {
        return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
            base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
            base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
    }

    LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
    {
        return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
            ldr()->InLoadOrderModuleList.Flink);
    }

    struct exports_directory {
        const char*                        _base;
        const win::IMAGE_EXPORT_DIRECTORY* _ied;
        unsigned long                      _ied_size;

    public:
        using size_type = unsigned long;

        LAZY_IMPORTER_FORCEINLINE
        exports_directory(const char* base) noexcept : _base(base)
        {
            const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
            _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + ied_data_dir.VirtualAddress);
            _ied_size = ied_data_dir.Size;
        }

        LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
        {
            return reinterpret_cast<const char*>(_ied) != _base;
        }

        LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
        {
            return _ied->NumberOfNames;
        }

        LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
        {
            return _ied;
        }

        LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
        {
            return reinterpret_cast<const char*>(
                _base + reinterpret_cast<const unsigned long*>(
                            _base + _ied->AddressOfNames)[index]);
        }

        LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
        {
            const auto* const rva_table =
                reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

            const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                _base + _ied->AddressOfNameOrdinals);

            return _base + rva_table[ord_table[index]];
        }

        LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
            const char* export_address) const noexcept
        {
            const auto ui_ied = reinterpret_cast<const char*>(_ied);
            return (export_address > ui_ied && export_address < ui_ied + _ied_size);
        }
    };

    struct safe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
        value_type* value;
        value_type* head;

        LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
            : safe_module_enumerator(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE
        safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
            : value(ldr->load_order_next()), head(value)
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept
        {
            value = head->load_order_next();
        }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();

            return value != head && value->DllBase;
        }
    };

    struct unsafe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
        value_type value;

        LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
            : value(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();
            return true;
        }
    };

    // provides the cached functions which use Derive classes methods
    template<class Derived, class DefaultType = void*>
    class lazy_base {
    protected:
        // This function is needed because every templated function
        // with different args has its own static buffer
        LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
        {
            static void* value = nullptr;
            return value;
        }

    public:
        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
        {
            return Derived::template get<T, safe_module_enumerator>();
        }

        template<class T = DefaultType, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
        {
            auto& cached = _cache();
            if(!cached)
                cached = Derived::template get<void*, Enum>();

            return (T)(cached);
        }

        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
        {
            return cached<T, safe_module_enumerator>();
        }
    };

    template<offset_hash_pair OHP>
    struct lazy_module : lazy_base<lazy_module<OHP>> {
        template<class T = void*, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T get() noexcept
        {
            Enum e;
            do {
                if(hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }

        template<class T = void*, class Ldr>
        LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
        {
            safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
            do {
                if(hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }

        template<class T = void*, class Ldr>
        LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
        {
            auto& cached = lazy_base<lazy_module<OHP>>::_cache();
            if(!cached)
                cached = in(ldr);

            return (T)(cached);
        }
    };

    template<offset_hash_pair OHP, class T>
    struct lazy_function : lazy_base<lazy_function<OHP, T>, T> {
        using base_type = lazy_base<lazy_function<OHP, T>, T>;

        template<class... Args>
        LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
        {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
            return get()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#else
            return this->cached()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F get() noexcept
        {
            // for backwards compatability.
            // Before 2.0 it was only possible to resolve forwarded exports when
            // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
            return forwarded<F, Enum>();
#else

            Enum e;

            do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                if(!e.value->DllBase || !e.value->FullDllName.Length)
                    continue;
#endif

                const exports_directory exports(e.value->DllBase);

                if(exports) {
                    auto export_index = exports.size();
                    while(export_index--)
                        if(hash(exports.name(export_index), get_offset(OHP)) == get_hash(OHP))
                            return (F)(exports.address(export_index));
                }
            } while(e.next());
            return {};
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
        {
            detail::win::UNICODE_STRING_T name;
            forwarded_hashes              hashes{ 0, get_hash(OHP) };

            Enum e;
            do {
                name = e.value->BaseDllName;
                name.Length -= 8; // get rid of .dll extension

                if(!hashes.module_hash || hash(name, get_offset(OHP)) == hashes.module_hash) {
                    const exports_directory exports(e.value->DllBase);

                    if(exports) {
                        auto export_index = exports.size();
                        while(export_index--)
                            if(hash(exports.name(export_index), get_offset(OHP)) == hashes.function_hash) {
                                const auto addr = exports.address(export_index);

                                if(exports.is_forwarded(addr)) {
                                    hashes = hash_forwarded(
                                        reinterpret_cast<const char*>(addr),
                                        get_offset(OHP));

                                    e.reset();
                                    break;
                                }
                                return (F)(addr);
                            }
                    }
                }
            } while(e.next());
            return {};
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
        {
            return forwarded<F, safe_module_enumerator>();
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = forwarded<void*, Enum>();
            return (F)(value);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
        {
            return forwarded_cached<F, safe_module_enumerator>();
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
        {
            if(IsSafe && !m)
                return {};

            const exports_directory exports((const char*)(m));
            if(IsSafe && !exports)
                return {};

            for(unsigned long i{};; ++i) {
                if(IsSafe && i == exports.size())
                    break;

                if(hash(exports.name(i), get_offset(OHP)) == get_hash(OHP))
                    return (F)(exports.address(i));
            }
            return {};
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
        {
            return in<F, true>(m);
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = in<void*, IsSafe>(m);
            return (F)(value);
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
        {
            return in_cached<F, true>(m);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
        {
            return in<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
        {
            return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
        {
            return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
        {
            return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }
    };

}} // namespace li::detail

#endif // include guard

```

`shellcode-payload/main-demo.cpp`:

```cpp
#include "shellcode.h"


extern void ShellcodeFunctionCallExternExample(void);

/* shallcode 入口示例 */
SC_EXPORT DWORD ShellcodeFunctionEntryPointExample(LPVOID lpParameter) {

    // 调试输出
    DbgPrint("Thread lpParameter 0x%p", lpParameter);

    // 使用 sprintf 、 字符串 、 以及编译器常量 
    CHAR buf[512] = {0};
    LI_FN(sprintf)(buf, "Hello The thread parameter is 0x%p and The function name is %s", lpParameter,__FUNCTION__);

    //使用系统 API
    LI_FN(MessageBoxA)(HWND(0), buf, xorstr_("Display from shellcode!"), MB_OK | MB_TOPMOST);

    //跨.cpp调用函数 可以通过 extern，也可以通过在共同头文件中给出声明
    ShellcodeFunctionCallExternExample();

    return 0;
}


/* shallcode VEH 示例  */
LONG WINAPI VehExampleHandler(EXCEPTION_POINTERS *pExceptionInfo) { return EXCEPTION_CONTINUE_SEARCH; }
SC_EXPORT DWORD ShellcodeVehExample(LPVOID lpParameter) {
    PVOID veh_hanle = LI_FN(AddVectoredExceptionHandler)(1, &VehExampleHandler);
    if (veh_hanle) {
        LI_FN(RemoveVectoredExceptionHandler)(veh_hanle);
    }
    return 0;
}


```

`shellcode-payload/shellcode-payload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{bd5ca44b-bf4b-4f32-81de-9c7890585f39}</ProjectGuid>
    <RootNamespace>shellcodepayload</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <SupportJustMyCode>false</SupportJustMyCode>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <Optimization>MinSpace</Optimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <ControlFlowGuard>false</ControlFlowGuard>
      <SupportJustMyCode>false</SupportJustMyCode>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <Optimization>MinSpace</Optimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <ControlFlowGuard>false</ControlFlowGuard>
      <SupportJustMyCode>false</SupportJustMyCode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="call-extern-demo.cpp" />
    <ClCompile Include="dwm-screen-shot-demo.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="main-demo.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dwm-capture.h" />
    <ClInclude Include="lazy_importer.hpp" />
    <ClInclude Include="shellcode.h" />
    <ClInclude Include="xorstr.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`shellcode-payload/shellcode-payload.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main-demo.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="dwm-screen-shot-demo.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="call-extern-demo.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lazy_importer.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="xorstr.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="dwm-capture.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="shellcode.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`shellcode-payload/shellcode.h`:

```h
#pragma once
#include "lazy_importer.hpp"
#ifndef _M_IX86
#include "xorstr.hpp"
#else
#define xorstr_(str) (str)
#endif //

#include <Windows.h>
#include <cstdio>
#define SC_EXPORT extern "C" _declspec(dllexport)
#define SC_EXPORT_DATA(type, data)                                                                                     \
    extern "C" _declspec(dllexport) type data;                                                                         \
    type                                 data;

template <typename T, size_t N>
constexpr size_t ArrNum(T (&A)[N]) {
    return N;
}

template <typename... Args>
void __DbgPrint(const char *format, Args... args) {
    CHAR buf[512] = {0};
    LI_FN(sprintf)
    (buf, format, args...);
    LI_FN(OutputDebugStringA)(buf);
}

#ifdef _DEBUG
#define DbgPrint(format, ...) __DbgPrint("[ payload ]" format "\t --line: %05d \n", __VA_ARGS__, __LINE__)
#else
#define DbgPrint(format, ...)
#endif // _DEBUG


```

`shellcode-payload/xorstr.hpp`:

```hpp
/*
 * Copyright 2017 - 2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP
#define JM_XORSTR_DISABLE_AVX_INTRINSICS
#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>
#include <type_traits>

#define xorstr(str) ::jm::xor_string([]() { return str; }, std::integral_constant<std::size_t, sizeof(str) / sizeof(*str)>{}, std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline)) inline
#endif

#if defined(__clang__) || defined(__GNUC__)
#define JM_XORSTR_LOAD_FROM_REG(x) ::jm::detail::load_from_reg(x)
#else
#define JM_XORSTR_LOAD_FROM_REG(x) (x)
#endif

namespace jm {

    namespace detail {

        template<std::size_t Size>
        XORSTR_FORCEINLINE constexpr std::size_t _buffer_size()
        {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<std::uint32_t Seed>
        XORSTR_FORCEINLINE constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for(char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        XORSTR_FORCEINLINE constexpr std::uint64_t key8()
        {
            constexpr auto first_part  = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // loads up to 8 characters of string into uint64 and xors it with the key
        template<std::size_t N, class CharT>
        XORSTR_FORCEINLINE constexpr std::uint64_t
        load_xored_str8(std::uint64_t key, std::size_t idx, const CharT* str) noexcept
        {
            using cast_type = typename std::make_unsigned<CharT>::type;
            constexpr auto value_size = sizeof(CharT);
            constexpr auto idx_offset = 8 / value_size;

            std::uint64_t value = key;
            for(std::size_t i = 0; i < idx_offset && i + idx * idx_offset < N; ++i)
                value ^=
                    (std::uint64_t{ static_cast<cast_type>(str[i + idx * idx_offset]) }
                     << ((i % idx_offset) * 8 * value_size));

            return value;
        }

        // forces compiler to use registers instead of stuffing constants in rdata
        XORSTR_FORCEINLINE std::uint64_t load_from_reg(std::uint64_t value) noexcept
        {
#if defined(__clang__) || defined(__GNUC__)
            asm("" : "=r"(value) : "0"(value) :);
#endif
            return value;
        }

        template<std::uint64_t V>
        struct uint64_v {
            constexpr static std::uint64_t value = V;
        };

    } // namespace detail

    template<class CharT, std::size_t Size, class Keys, class Indices>
    class xor_string;

    template<class CharT, std::size_t Size, std::uint64_t... Keys, std::size_t... Indices>
    class xor_string<CharT, Size, std::integer_sequence<std::uint64_t, Keys...>, std::index_sequence<Indices...>> {
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
        constexpr static inline std::uint64_t alignment = ((Size > 16) ? 32 : 16);    
#else
        constexpr static inline std::uint64_t alignment = 16;
#endif

        alignas(alignment) std::uint64_t _storage[sizeof...(Keys)];

    public:
        using value_type    = CharT;
        using size_type     = std::size_t;
        using pointer       = CharT*;
        using const_pointer = const CharT*;

        template<class L>
        XORSTR_FORCEINLINE xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) noexcept
            : _storage{ JM_XORSTR_LOAD_FROM_REG(detail::uint64_v<detail::load_xored_str8<Size>(Keys, Indices, l())>::value)... }
        {}

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return Size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
            std::uint64_t*    keys =
                (std::uint64_t*)JM_XORSTR_LOAD_FROM_REG((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr(sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                                  _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
        ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
            reinterpret_cast<__m128i*>(_storage) + Indices,
            _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                          _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer get() noexcept
        {
            return reinterpret_cast<pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer crypt_get() noexcept
        {
            // crypt() function inlined by hand, because MSVC linker chokes when you have a lot of strings
            // on 32 bit builds, so don't blame me for shit code :pepekms:
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
            std::uint64_t*    keys =
                (std::uint64_t*)JM_XORSTR_LOAD_FROM_REG((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr(sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                                  _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
        ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
            reinterpret_cast<__m128i*>(_storage) + Indices,
            _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                          _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
            return (pointer)(_storage);
        }
    };

    template<class L, std::size_t Size, std::size_t... Indices>
    xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) -> xor_string<
                std::remove_const_t<std::remove_reference_t<decltype(l()[0])>>,
                Size,
                std::integer_sequence<std::uint64_t, detail::key8<Indices>()...>,
                std::index_sequence<Indices...>>;

} // namespace jm

#endif // include guard

```