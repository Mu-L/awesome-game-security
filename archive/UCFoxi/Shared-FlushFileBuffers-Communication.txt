Project Path: arc_UCFoxi_Shared-FlushFileBuffers-Communication_8w6mxfk4

Source Tree:

```txt
arc_UCFoxi_Shared-FlushFileBuffers-Communication_8w6mxfk4
├── README.md
├── SharedBufferComm.sln
├── kernel
│   ├── CallbackHandler.cpp
│   ├── CallbackHandler.h
│   ├── DriverMain.cpp
│   ├── Utils.cpp
│   ├── Utils.h
│   ├── kernel.inf
│   ├── kernel.vcxproj
│   ├── kernel.vcxproj.filters
│   ├── kernel.vcxproj.user
│   └── stdafx.h
└── usermode
    ├── UserMain.cpp
    ├── driver.h
    ├── stdafx.h
    ├── usermode.vcxproj
    ├── usermode.vcxproj.filters
    ├── usermode.vcxproj.user
    └── utils.h

```

`README.md`:

```md
# Shared-FlushFileBuffers-Communication
Cool kernel communication method.

unknowncheats post: https://www.unknowncheats.me/forum/anti-cheat-bypass/448472-shared-buffer-flushfilebuffers-communication-driverbase.html#post3110503

Hello my friends, i would like to share a cool kernel communication method.
This method abuse FlushFileBuffers because it calls in kernel IRP_MJ_FLUSH_BUFFERS and this is a sexy MajorFunction you can hook without any issues. Iv not tested this on any anticheat but far as i know IRP_MJ_FLUSH_BUFFERS is not checked for most drivers!
Even iv its getting checked with basic checks we can getaround this by hooking the MajorFunction and set the hook to a other unknown MajorFunction of a legit driver that we also hooked. 
I know shared buffer stuff is nothing new but the idea of processing the call without any running thread or something else is quite cool ;)

atm this is not thread safe, but you can get it done with something like this:
https://www.unknowncheats.me/forum/c-and-c-/391107-discuss-shared-buffer-synchonization.html


```

`SharedBufferComm.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kernel", "kernel\kernel.vcxproj", "{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "usermode", "usermode\usermode.vcxproj", "{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|ARM.ActiveCfg = Debug|ARM
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|ARM.Build.0 = Debug|ARM
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|ARM.Deploy.0 = Debug|ARM
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|ARM64.Build.0 = Debug|ARM64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|x64.ActiveCfg = Debug|x64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|x64.Build.0 = Debug|x64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|x64.Deploy.0 = Debug|x64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|x86.ActiveCfg = Debug|Win32
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|x86.Build.0 = Debug|Win32
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Debug|x86.Deploy.0 = Debug|Win32
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|ARM.ActiveCfg = Release|ARM
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|ARM.Build.0 = Release|ARM
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|ARM.Deploy.0 = Release|ARM
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|ARM64.ActiveCfg = Release|ARM64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|ARM64.Build.0 = Release|ARM64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|ARM64.Deploy.0 = Release|ARM64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|x64.ActiveCfg = Release|x64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|x64.Build.0 = Release|x64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|x64.Deploy.0 = Release|x64
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|x86.ActiveCfg = Release|Win32
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|x86.Build.0 = Release|Win32
		{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}.Release|x86.Deploy.0 = Release|Win32
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Debug|ARM.ActiveCfg = Debug|Win32
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Debug|ARM64.ActiveCfg = Debug|Win32
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Debug|x64.ActiveCfg = Debug|x64
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Debug|x64.Build.0 = Debug|x64
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Debug|x86.ActiveCfg = Debug|Win32
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Debug|x86.Build.0 = Debug|Win32
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Release|ARM.ActiveCfg = Release|Win32
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Release|ARM64.ActiveCfg = Release|Win32
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Release|x64.ActiveCfg = Release|x64
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Release|x64.Build.0 = Release|x64
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Release|x86.ActiveCfg = Release|Win32
		{90824B2A-2B07-40E1-9C0A-DB31D6BAAAAB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0E26C68B-6BB2-4B1F-8B45-6AEB96454037}
	EndGlobalSection
EndGlobal

```

`kernel/CallbackHandler.cpp`:

```cpp
#include "stdafx.h"

//Some stuff from: https://github.com/btbd/modmap/blob/master/driver/core.c
NTSTATUS CallbackWRITE(PREQUEST_WRITE args)
{
	if (((PBYTE)args->Src + args->Size < (PBYTE)args->Src) ||
		((PBYTE)args->Dest + args->Size < (PBYTE)args->Dest) ||
		((PVOID)((PBYTE)args->Src + args->Size) > MM_HIGHEST_USER_ADDRESS) ||
		((PVOID)((PBYTE)args->Dest + args->Size) > MM_HIGHEST_USER_ADDRESS)) {
		return STATUS_ACCESS_VIOLATION;
	}

	if (args->bPhysicalMem) {
		PEPROCESS pProcess = NULL;
		if (args->ProcessId == 0) 
			return STATUS_UNSUCCESSFUL;

		NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &pProcess);
		if (NtRet != STATUS_SUCCESS) return NtRet;

		ULONG_PTR process_dirbase = Utils::PhysicalMemory::GetProcessCr3(pProcess);
		ObDereferenceObject(pProcess);

		SIZE_T CurOffset = 0;
		SIZE_T TotalSize = args->Size;
		while (TotalSize)
		{
			INT64 CurPhysAddr = Utils::PhysicalMemory::TranslateLinearAddress(process_dirbase, (ULONG64)args->Src + CurOffset);
			if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

			ULONG64 WriteSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
			SIZE_T BytesWritten = 0;
			NtRet = Utils::PhysicalMemory::WritePhysicalAddress(PVOID(CurPhysAddr), (PVOID)((ULONG64)args->Dest+ CurOffset), WriteSize, &BytesWritten);
			TotalSize -= BytesWritten;
			CurOffset += BytesWritten;
			if (NtRet != STATUS_SUCCESS) break;
			if (BytesWritten == 0) break;
		}
		//*args-> = CurOffset;
		return NtRet;
	}
	else {
		PEPROCESS process = NULL;
		NTSTATUS status = (PsLookupProcessByProcessId)((HANDLE)args->ProcessId, &process);
		if (NT_SUCCESS(status)) {
			SIZE_T outSize = 0;
			status = (MmCopyVirtualMemory)((PsGetCurrentProcess)(), args->Src, process, args->Dest, (SIZE_T)args->Size, KernelMode, &outSize);
			(ObfDereferenceObject)(process);
		}
		return status;
	}
	return STATUS_UNSUCCESSFUL;
}

NTSTATUS CallbackREAD(PREQUEST_READ args)
{
	if (((PBYTE)args->Src + args->Size < (PBYTE)args->Src) ||
		((PBYTE)args->Dest + args->Size < (PBYTE)args->Dest) ||
		((PVOID)((PBYTE)args->Src + args->Size) > MM_HIGHEST_USER_ADDRESS) ||
		((PVOID)((PBYTE)args->Dest + args->Size) > MM_HIGHEST_USER_ADDRESS)) {

		return STATUS_ACCESS_VIOLATION;
	}

	if (args->bPhysicalMem) {
		PEPROCESS pProcess = NULL;
		if (args->ProcessId == 0) return STATUS_UNSUCCESSFUL;

		NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &pProcess);
		if (NtRet != STATUS_SUCCESS) return NtRet;

		ULONG_PTR process_dirbase = Utils::PhysicalMemory::GetProcessCr3(pProcess);
		ObDereferenceObject(pProcess);

		SIZE_T CurOffset = 0;
		SIZE_T TotalSize = args->Size;
		while (TotalSize)
		{

			INT64 CurPhysAddr = Utils::PhysicalMemory::TranslateLinearAddress(process_dirbase, (ULONG64)args->Src + CurOffset);
			if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

			ULONG64 ReadSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
			SIZE_T BytesRead = 0;
			NtRet = Utils::PhysicalMemory::ReadPhysicalAddress(PVOID(CurPhysAddr), (PVOID)((ULONG64)args->Dest + CurOffset), ReadSize, &BytesRead);
			TotalSize -= BytesRead;
			CurOffset += BytesRead;
			if (NtRet != STATUS_SUCCESS) break;
			if (BytesRead == 0) break;
		}
		//*read = CurOffset;
		return NtRet;
	}
	else {
		PEPROCESS process = NULL;
		NTSTATUS status = (PsLookupProcessByProcessId)((HANDLE)args->ProcessId, &process);
		if (NT_SUCCESS(status)) {
			SIZE_T outSize = 0;
			status = (MmCopyVirtualMemory)(process, args->Src, (PsGetCurrentProcess)(), args->Dest, (SIZE_T)args->Size, KernelMode, &outSize);
			(ObfDereferenceObject)(process);
		}
		return status;
	}

	return STATUS_UNSUCCESSFUL;
}

NTSTATUS CallbackPROTECT(PREQUEST_PROTECT args)
{
	if (!args->ProcessId || !args->Address || !args->Size || !args->InOutProtect)
		return STATUS_INVALID_PARAMETER;

	NTSTATUS status = STATUS_SUCCESS;
	PEPROCESS target_process = NULL;

	if (!NT_SUCCESS((PsLookupProcessByProcessId)((HANDLE)args->ProcessId, &target_process)))
	{
		return STATUS_NOT_FOUND;
	}
	SIZE_T size = args->Size;
	DWORD protect = 0;
	RtlCopyMemory(&protect, args->InOutProtect, sizeof(protect));

	(KeAttachProcess)((PKPROCESS)target_process);
	status = (ZwProtectVirtualMemory)(NtCurrentProcess(), &args->Address, &size, protect, &protect);
	(KeDetachProcess)();
	if (NT_SUCCESS(status))
		RtlCopyMemory(args->InOutProtect, &protect, sizeof(protect));

	(ObfDereferenceObject)(target_process);
	return status;
}

NTSTATUS CallbackALLOC(PREQUEST_ALLOC args)
{
	PEPROCESS process = NULL;
	NTSTATUS status = (PsLookupProcessByProcessId)((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		PVOID address = NULL;
		SIZE_T size = args->Size;

		(KeAttachProcess)(process);
		(ZwAllocateVirtualMemory)(NtCurrentProcess(), &address, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		(KeDetachProcess)();

		RtlCopyMemory(args->OutAddress, &address, sizeof(address));

		(ObfDereferenceObject)(process);
	}
	return status;
}

NTSTATUS CallbackFREE(PREQUEST_FREE args)
{
	PEPROCESS process = NULL;
	NTSTATUS status = (PsLookupProcessByProcessId)((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		SIZE_T size = 0;

		(KeAttachProcess)(process);
		(ZwFreeVirtualMemory)(NtCurrentProcess(), &args->Address, &size, MEM_RELEASE);
		(KeDetachProcess)();

		(ObfDereferenceObject)(process);
	}
	return status;
}

NTSTATUS CallbackMODULE(PREQUEST_MODULE args)
{
	PEPROCESS process = NULL;
	NTSTATUS status = (PsLookupProcessByProcessId)((HANDLE)args->ProcessId, &process);
	if (NT_SUCCESS(status)) {
		PVOID base = NULL;
		DWORD size = 0;
		(KeAttachProcess)(process);
		PLDR_DATA_TABLE_ENTRY module = Utils::GetModuleByName(process, args->Module);//L"ReadAndWriteMe.exe");//args->Module);
		if (module) {
			base = module->DllBase;
			size = module->SizeOfImage;
		}
		else {
			status = STATUS_NOT_FOUND;
		}
		(KeDetachProcess)();
		if (NT_SUCCESS(status)) {
			RtlCopyMemory(args->OutAddress, &base, sizeof(base));
			RtlCopyMemory(args->OutSize, &size, sizeof(size));
		}
		(ObfDereferenceObject)(process);
	}
	return status;
}

NTSTATUS CallbackMAINBASE(PREQUEST_MAINBASE args)
{
	PEPROCESS pProcess = NULL;
	if (args->ProcessId == 0)
		return STATUS_UNSUCCESSFUL;

	NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)args->ProcessId, &pProcess);
	if (NtRet != STATUS_SUCCESS)
		return STATUS_UNSUCCESSFUL;

	auto base = PsGetProcessSectionBaseAddress(pProcess);
	RtlCopyMemory(args->OutAddress, &base, sizeof(base));
	ObDereferenceObject(pProcess);
	return STATUS_SUCCESS;
}

```

`kernel/CallbackHandler.h`:

```h
#pragma once
#define DEFAULT_MAGGICCODE 0x59002360218c1e2dul //length 16 max

#define CallbackHandler(name)												\
 case REQUEST_TYPE::name: {													\
		REQUEST_##name args;												\
        RtlCopyMemory(&args, data.Arguments, sizeof(args));					\
        *data.Status = Callback##name(&args);								\
        break;																\
    }

typedef enum _REQUEST_TYPE : UINT{
	WRITE,
	READ,
	PROTECT,
	ALLOC,
	FREE,
	MODULE,
	MAINBASE,
	THREADCALL,
} REQUEST_TYPE;

typedef struct _REQUEST_DATA {
	ULONG64* MaggicCode;
	UINT Type;
	PVOID Arguments;
	NTSTATUS* Status;
} REQUEST_DATA, * PREQUEST_DATA;

typedef struct _REQUEST_WRITE {
	DWORD ProcessId;
	PVOID Dest;
	PVOID Src;
	DWORD Size;
	BOOL bPhysicalMem;
} REQUEST_WRITE, * PREQUEST_WRITE;

typedef struct _REQUEST_READ {
	DWORD ProcessId;
	PVOID Dest;
	PVOID Src;
	DWORD Size;
	BOOL bPhysicalMem;
} REQUEST_READ, * PREQUEST_READ;

typedef struct _REQUEST_PROTECT {
	DWORD ProcessId;
	PVOID Address;
	DWORD Size;
	PDWORD InOutProtect;
} REQUEST_PROTECT, * PREQUEST_PROTECT;

typedef struct _REQUEST_ALLOC {
	DWORD ProcessId;
	PVOID OutAddress;
	DWORD Size;
	DWORD Protect;
} REQUEST_ALLOC, * PREQUEST_ALLOC;

typedef struct _REQUEST_FREE {
	DWORD ProcessId;
	PVOID Address;
} REQUEST_FREE, * PREQUEST_FREE;

typedef struct _REQUEST_MODULE {
	DWORD ProcessId;
	WCHAR Module[0xFF];
	PBYTE* OutAddress;
	DWORD* OutSize;
} REQUEST_MODULE, * PREQUEST_MODULE;

typedef struct _REQUEST_MAINBASE {
	DWORD ProcessId;
	PBYTE* OutAddress;
} REQUEST_MAINBASE, * PREQUEST_MAINBASE;

NTSTATUS CallbackWRITE(PREQUEST_WRITE args);
NTSTATUS CallbackREAD(PREQUEST_READ args);
NTSTATUS CallbackPROTECT(PREQUEST_PROTECT args);
NTSTATUS CallbackALLOC(PREQUEST_ALLOC args);
NTSTATUS CallbackFREE(PREQUEST_FREE args);
NTSTATUS CallbackMODULE(PREQUEST_MODULE args);
NTSTATUS CallbackMAINBASE(PREQUEST_MAINBASE args);
```

`kernel/DriverMain.cpp`:

```cpp
#include "stdafx.h"

UNICODE_STRING RegPath = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\SOFTWARE\\ucflash");
typedef NTSTATUS(*HookControl_t)(void* a1, void* a2);
HookControl_t OriginalPtr;
PVOID SharedBuffer = 0;
UINT SharedPid = 0;
ULONG64 NewMaggicCode = DEFAULT_MAGGICCODE;

NTSTATUS HookControl(PDEVICE_OBJECT device, PIRP irp) {
	static bool retry = false;
	retry:
	PEPROCESS process = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)SharedPid, &process);
	if (NT_SUCCESS(status) && process) {
		retry = false;
		REQUEST_DATA data;
		SIZE_T outSize = 0; //need to, if not == crash!
		if (NT_SUCCESS(MmCopyVirtualMemory(process, (void*)SharedBuffer, PsGetCurrentProcess(), &data, (SIZE_T)sizeof(REQUEST_DATA), KernelMode, &outSize))) {
			if (*data.MaggicCode == NewMaggicCode) {
				if (NewMaggicCode == DEFAULT_MAGGICCODE) { //reset maggicode to fuck with bad devs ;)
					ULONG time = 0;
					KeQuerySystemTime(&time);
					NewMaggicCode = RtlRandomEx(&time) % MAXULONG64;
					*data.MaggicCode = NewMaggicCode;
					Utils::Registry::WriteRegistry(RegPath, RTL_CONSTANT_STRING(L"xxxx"), &NewMaggicCode, REG_QWORD, 8);
					//print("NewMaggicCode: 0x%llX\n", NewMaggicCode);
				}
				switch (data.Type)
				{
					CallbackHandler(WRITE);
					CallbackHandler(READ);
					CallbackHandler(PROTECT);
					CallbackHandler(ALLOC);
					CallbackHandler(FREE);
					CallbackHandler(MODULE);
					CallbackHandler(MAINBASE);
				case THREADCALL: {
					break;
				}
				case 99:
					print("NewMaggicCode: 0x%llX\n", NewMaggicCode);
					break;
				default:
					break;
				}
				ObfDereferenceObject(process);
				IofCompleteRequest(irp, 0);
				return 0;
			}
		}
		ObfDereferenceObject(process);
	}
	else {
		SharedBuffer = (PVOID)Utils::Registry::ReadRegistry<LONG64>(RegPath, RTL_CONSTANT_STRING(L"xxx"));
		SharedPid = (UINT)Utils::Registry::ReadRegistry<LONG64>(RegPath, RTL_CONSTANT_STRING(L"xx"));
		print("[+] New SharedBuffer: 0x%llX", SharedBuffer);
		print("[+] New SharedPid: 0x%llX", SharedPid);
		if (!retry) {
			retry = true;
			goto retry;
		}
	}
	return OriginalPtr(device, irp);
}

INT64 driver_main() {
	print("[!] UC-Driver start loading!");
	PDRIVER_OBJECT DriverObject = nullptr;
	UNICODE_STRING DriverObjectName = RTL_CONSTANT_STRING(L"\\Driver\\PEAUTH");
	ObReferenceObjectByName(&DriverObjectName, (ULONG)OBJ_CASE_INSENSITIVE, (PACCESS_STATE)0, (ACCESS_MASK)0, *IoDriverObjectType, KernelMode, (PVOID)0, (PVOID*)&DriverObject);
	if (DriverObject) {
		*(PVOID*)&OriginalPtr = InterlockedExchangePointer((void**)&DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS], HookControl);
		SharedBuffer = (PVOID)Utils::Registry::ReadRegistry<LONG64>(RegPath, RTL_CONSTANT_STRING(L"xxx"));
		SharedPid = (UINT)Utils::Registry::ReadRegistry<LONG64>(RegPath, RTL_CONSTANT_STRING(L"xx"));
		print("[!] Old SharedBuffer: 0x%llX", SharedBuffer);
		print("[!] Old SharedPid: 0x%llX", SharedPid);
		print("[+] Driver Loaded!");
		return 0;
	}
	return 1;
}

NTSTATUS DriversMaain(PVOID lpBaseAddress, DWORD32 dwSize) {
	driver_main();
	return -1;
}
```

`kernel/Utils.cpp`:

```cpp
#include "stdafx.h"

PLDR_DATA_TABLE_ENTRY Utils::GetModuleByName(PEPROCESS process, PWCHAR moduleName)
{
	UNICODE_STRING moduleNameStr = { 0 };
	RtlInitUnicodeString((PUNICODE_STRING)&moduleNameStr, (PCWSTR)moduleName);

	PLIST_ENTRY list = &((PsGetProcessPeb)(process)->Ldr->InLoadOrderModuleList);
	for (PLIST_ENTRY entry = list->Flink; entry != list; ) {
		PLDR_DATA_TABLE_ENTRY module = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		if ((RtlCompareUnicodeString)(&module->BaseDllName, &moduleNameStr, TRUE) == 0) {
			return module;
		}
		entry = module->InLoadOrderLinks.Flink;
	}
	return NULL;
}

const DWORD Utils::PhysicalMemory::GetUserDirectoryTableBaseOffset()
{
	RTL_OSVERSIONINFOW ver = { 0 };
	RtlGetVersion(&ver);
	switch (ver.dwBuildNumber)
	{
	case WINDOWS_1803:
		return 0x0278;
		break;
	case WINDOWS_1809:
		return 0x0278;
		break;
	case WINDOWS_1903:
		return 0x0280;
		break;
	case WINDOWS_1909:
		return 0x0280;
		break;
	case WINDOWS_2004:
		return 0x0388;
		break;
	case WINDOWS_20H2:
		return 0x0388;
		break;
	case WINDOWS_21H1:
		return 0x0388;
		break;
	default:
		return 0x0388;
	}
}

const UINT64 Utils::PhysicalMemory::GetProcessCr3(const PEPROCESS pProcess)
{
	PUCHAR process = (PUCHAR)pProcess;
	ULONG_PTR process_dirbase = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
	if (process_dirbase == 0)
	{
		DWORD UserDirOffset = GetUserDirectoryTableBaseOffset();
		ULONG_PTR process_userdirbase = *(PULONG_PTR)(process + UserDirOffset);
		return process_userdirbase;
	}
	return process_dirbase;
}

const UINT64 Utils::PhysicalMemory::GetKernelDirBase()
{
	PUCHAR process = (PUCHAR)PsGetCurrentProcess();
	ULONG_PTR cr3 = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
	return cr3;
}

#define PAGE_OFFSET_SIZE 12
static const UINT64 PMASK = (~0xfull << 8) & 0xfffffffffull;
const UINT64 Utils::PhysicalMemory::TranslateLinearAddress(UINT64 directoryTableBase, UINT64 virtualAddress)
{
	directoryTableBase &= ~0xf;

	UINT64 pageOffset = virtualAddress & ~(~0ul << PAGE_OFFSET_SIZE);
	UINT64 pte = ((virtualAddress >> 12) & (0x1ffll));
	UINT64 pt = ((virtualAddress >> 21) & (0x1ffll));
	UINT64 pd = ((virtualAddress >> 30) & (0x1ffll));
	UINT64 pdp = ((virtualAddress >> 39) & (0x1ffll));

	SIZE_T readsize = 0;
	UINT64 pdpe = 0;
	ReadPhysicalAddress(PVOID(directoryTableBase + 8 * pdp), &pdpe, sizeof(pdpe), &readsize);
	if (~pdpe & 1)
		return 0;

	UINT64 pde = 0;
	ReadPhysicalAddress(PVOID((pdpe & PMASK) + 8 * pd), &pde, sizeof(pde), &readsize);
	if (~pde & 1)
		return 0;

	/* 1GB large page, use pde's 12-34 bits */
	if (pde & 0x80)
		return (pde & (~0ull << 42 >> 12)) + (virtualAddress & ~(~0ull << 30));

	UINT64 pteAddr = 0;
	ReadPhysicalAddress(PVOID((pde & PMASK) + 8 * pt), &pteAddr, sizeof(pteAddr), &readsize);
	if (~pteAddr & 1)
		return 0;

	/* 2MB large page */
	if (pteAddr & 0x80)
		return (pteAddr & PMASK) + (virtualAddress & ~(~0ull << 21));

	virtualAddress = 0;
	ReadPhysicalAddress(PVOID((pteAddr & PMASK) + 8 * pte), &virtualAddress, sizeof(virtualAddress), &readsize);
	virtualAddress &= PMASK;

	if (!virtualAddress)
		return 0;

	return virtualAddress + pageOffset;
}

NTSTATUS Utils::PhysicalMemory::ReadVirtual(UINT64 dirbase, UINT64 address, UINT8* buffer, SIZE_T size, SIZE_T* read)
{
	UINT64 paddress = TranslateLinearAddress(dirbase, address);
	return ReadPhysicalAddress(PVOID(paddress), buffer, size, read);
}

NTSTATUS Utils::PhysicalMemory::WriteVirtual(UINT64 dirbase, UINT64 address, UINT8* buffer, SIZE_T size, SIZE_T* written)
{
	UINT64 paddress = TranslateLinearAddress(dirbase, address);
	return WritePhysicalAddress(PVOID(paddress), buffer, size, written);
}

NTSTATUS Utils::PhysicalMemory::ReadPhysicalAddress(PVOID TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesRead)
{
	MM_COPY_ADDRESS AddrToRead = { 0 };
	AddrToRead.PhysicalAddress.QuadPart = (LONGLONG)TargetAddress;
	return MmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, BytesRead);
}

NTSTATUS Utils::PhysicalMemory::WritePhysicalAddress(PVOID TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesWritten)
{
	if (!TargetAddress)
		return STATUS_UNSUCCESSFUL;

	PHYSICAL_ADDRESS AddrToWrite = { 0 };
	AddrToWrite.QuadPart = LONGLONG(TargetAddress);

	PVOID pmapped_mem = MmMapIoSpaceEx(AddrToWrite, Size, PAGE_READWRITE);

	if (!pmapped_mem)
		return STATUS_UNSUCCESSFUL;

	memcpy(pmapped_mem, lpBuffer, Size);

	*BytesWritten = Size;
	MmUnmapIoSpace(pmapped_mem, Size);
	return STATUS_SUCCESS;
}

ULONG Utils::Registry::GetKeyInfoSize(HANDLE hKey, PUNICODE_STRING Key)
{
	NTSTATUS Status;
	ULONG KeySize;

	Status = ZwQueryValueKey(hKey, Key, KeyValueFullInformation, 0, 0, &KeySize);

	if (Status == STATUS_BUFFER_TOO_SMALL || Status == STATUS_BUFFER_OVERFLOW)
		return KeySize;

	return 0;
}

bool Utils::Registry::WriteRegistry(UNICODE_STRING RegPath, UNICODE_STRING Key, PVOID Address, ULONG Type, ULONG Size)
{
	bool Success = false;
	HANDLE hKey;
	OBJECT_ATTRIBUTES ObjAttr;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	InitializeObjectAttributes(&ObjAttr, &RegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

	Status = ZwOpenKey(&hKey, KEY_ALL_ACCESS, &ObjAttr);

	if (NT_SUCCESS(Status))
	{
		Status = ZwSetValueKey(hKey, &Key, NULL, Type, Address, Size);

		if (NT_SUCCESS(Status))
			Success = true;

		ZwClose(hKey);
	}

	return Success;
}

```

`kernel/Utils.h`:

```h
#pragma once
#define RVA(addr, size) (uint64_t)((PBYTE)((UINT_PTR)(addr) + *(PINT)((UINT_PTR)(addr) + ((size) - sizeof(INT))) + (size)))

//https://ntdiff.github.io/
#define WINDOWS_1803 17134
#define WINDOWS_1809 17763
#define WINDOWS_1903 18362
#define WINDOWS_1909 18363
#define WINDOWS_2004 19041
#define WINDOWS_20H2 19569
#define WINDOWS_21H1 20180

typedef struct _PEB_LDR_DATA {
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _PEB {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, * PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

extern "C" POBJECT_TYPE * IoDriverObjectType;
extern "C" {
	NTSTATUS NTAPI MmCopyVirtualMemory(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize);
	NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(PUNICODE_STRING ObjectPath, ULONG Attributes, PACCESS_STATE PassedAccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID ParseContext, PVOID* ObjectPtr);
	NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(PEPROCESS Process);
	NTKERNELAPI PPEB  NTAPI PsGetProcessPeb(IN PEPROCESS Process);
	NTSTATUS NTAPI ZwProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, SIZE_T* NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection);
}

namespace Utils {
	namespace Registry //https://www.unknowncheats.me/forum/3108590-post2.html
	{
		ULONG GetKeyInfoSize(HANDLE hKey, PUNICODE_STRING Key);
		template <typename type>
		type ReadRegistry(UNICODE_STRING RegPath, UNICODE_STRING Key);
		bool WriteRegistry(UNICODE_STRING RegPath, UNICODE_STRING Key, PVOID Address, ULONG Type, ULONG Size);
		template<typename type>
		static type ReadRegistry(UNICODE_STRING RegPath, UNICODE_STRING Key)
		{
			HANDLE hKey;
			OBJECT_ATTRIBUTES ObjAttr;
			NTSTATUS Status = STATUS_UNSUCCESSFUL;

			InitializeObjectAttributes(&ObjAttr, &RegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

			Status = ZwOpenKey(&hKey, KEY_ALL_ACCESS, &ObjAttr);

			if (NT_SUCCESS(Status))
			{
				ULONG KeyInfoSize = GetKeyInfoSize(hKey, &Key);
				ULONG KeyInfoSizeNeeded;

				if (KeyInfoSize == NULL)
				{
					ZwClose(hKey);
					return 0;
				}

				PKEY_VALUE_FULL_INFORMATION pKeyInfo = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePool(NonPagedPool, KeyInfoSize);
				RtlZeroMemory(pKeyInfo, KeyInfoSize);

				Status = ZwQueryValueKey(hKey, &Key, KeyValueFullInformation, pKeyInfo, KeyInfoSize, &KeyInfoSizeNeeded);

				if (!NT_SUCCESS(Status) || (KeyInfoSize != KeyInfoSizeNeeded))
				{
					ZwClose(hKey);
					ExFreePoolWithTag(pKeyInfo, 0);
					return 0;
				}

				ZwClose(hKey);
				ExFreePoolWithTag(pKeyInfo, 0);

				return *(type*)((LONG64)pKeyInfo + pKeyInfo->DataOffset);
			}

			return 0;
		}
	}
	//Defaults:
	//const bool bCheckMask(PCHAR base, PCHAR pattern, PCHAR mask);
	//const UINT64 FindPattern(const UINT64 dwAddress, const UINT dwLen, const PCHAR bMask, const PCHAR szMask);
	PLDR_DATA_TABLE_ENTRY GetModuleByName(PEPROCESS process, PWCHAR moduleName);
	//Physical Memory:
	namespace PhysicalMemory { //https://www.unknowncheats.me/forum/anti-cheat-bypass/444289-read-process-physical-memory-attach.html
		const DWORD GetUserDirectoryTableBaseOffset();
		const UINT64 GetProcessCr3(const PEPROCESS pProcess);
		const UINT64 GetKernelDirBase();
		const UINT64 TranslateLinearAddress(UINT64 directoryTableBase, UINT64 virtualAddress);
		NTSTATUS ReadVirtual(UINT64 dirbase, UINT64 address, UINT8* buffer, SIZE_T size, SIZE_T* read);
		NTSTATUS WriteVirtual(UINT64 dirbase, UINT64 address, UINT8* buffer, SIZE_T size, SIZE_T* written);
		NTSTATUS ReadPhysicalAddress(PVOID TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesRead);
		NTSTATUS WritePhysicalAddress(PVOID TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesWritten);
	}
	//Protection:

}

```

`kernel/kernel.inf`:

```inf
;
; kernel.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=kernel.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
kernel_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
kernel.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%kernel.DeviceDesc%=kernel_Device, Root\kernel ; TODO: edit hw-id

[kernel_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
kernel.sys

;-------------- Service installation
[kernel_Device.NT.Services]
AddService = kernel,%SPSVCINST_ASSOCSERVICE%, kernel_Service_Inst

; -------------- kernel driver install sections
[kernel_Service_Inst]
DisplayName    = %kernel.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\kernel.sys

;
;--- kernel_Device Coinstaller installation ------
;

[kernel_Device.NT.CoInstallers]
AddReg=kernel_Device_CoInstaller_AddReg
CopyFiles=kernel_Device_CoInstaller_CopyFiles

[kernel_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[kernel_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[kernel_Device.NT.Wdf]
KmdfService =  kernel, kernel_wdfsect
[kernel_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "kernel Installation Disk"
kernel.DeviceDesc = "kernel Device"
kernel.SVCDESC = "kernel Service"

```

`kernel/kernel.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A0EDB9A2-26D0-45CA-8F7D-D881C768E4D9}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>kernel</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriversMaain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CallbackHandler.cpp" />
    <ClCompile Include="DriverMain.cpp" />
    <ClCompile Include="Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CallbackHandler.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kernel/kernel.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Handler">
      <UniqueIdentifier>{687f9b15-2f0d-414f-b596-b8bfe7af80f6}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CallbackHandler.cpp">
      <Filter>Handler</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CallbackHandler.h">
      <Filter>Handler</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`kernel/kernel.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`kernel/stdafx.h`:

```h
#pragma once
#pragma warning( disable : 4099 )

#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <wdf.h>
#include <ntimage.h>
#include <intrin.h>

#include "Utils.h"
#include "CallbackHandler.h"

#define print(fmt, ...) DbgPrintEx(0, 0, fmt, ##__VA_ARGS__) //dont use "\n"

```

`usermode/UserMain.cpp`:

```cpp
#include "stdafx.h"

int main() {
	printf("[!] Open driver connection: ");
	if (driver->Init(FALSE)) {
		printf("Success!\n");
		driver->Attach(L"explorer.exe");
		while (true)
		{
			clock_t begin = clock();
			auto module = driver->GetModuleBase(L"explorer.exe");
			clock_t end = clock();
			double time_spent = (double)(end - begin);
			printf("Request took: %f | %fs\n", time_spent, time_spent / CLOCKS_PER_SEC);
			printf("base.addr: 0x%llX\n", module.addr);
			printf("base.size: 0x%llX\n", module.size);
			Sleep(2000);
		}
		return 0;
	}
	printf("Failed!\n");
	system("pause");
	return 1;
}
```

`usermode/driver.h`:

```h
#pragma once

class Driver
{
public:
	UINT ProcessId;
	/*
	This is not thread safe! 
	So dont call the driver from a thread!
	*/
	const bool Init(const BOOL PhysicalMode) {
		this->bPhysicalMode = PhysicalMode;
		this->hDriver = CreateFileA(("\\\\.\\\PEAuth"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
		if (this->hDriver != INVALID_HANDLE_VALUE) {
			if (this->SharedBuffer = VirtualAlloc(0, sizeof(REQUEST_DATA), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) {
				UNICODE_STRING RegPath = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\SOFTWARE\\ucflash");
				RegistryUtils::WriteRegistry(RegPath, RTL_CONSTANT_STRING(L"xxx"), &this->SharedBuffer, REG_QWORD, 8);
				PVOID pid = (PVOID)GetCurrentProcessId();
				RegistryUtils::WriteRegistry(RegPath, RTL_CONSTANT_STRING(L"xx"), &pid, REG_QWORD, 8);
				auto OLD_MAGGICCODE = this->MAGGICCODE;
				SendRequest(99, 0);
				if(this->MAGGICCODE == OLD_MAGGICCODE)
					this->MAGGICCODE = (ULONG64)RegistryUtils::ReadRegistry<LONG64>(RegPath, RTL_CONSTANT_STRING(L"xxxx"));
				return true;
			}
		}
		return false;
	}

	const NTSTATUS SendRequest(const UINT type, const PVOID args) {
		REQUEST_DATA req;
		NTSTATUS status;
		req.MaggicCode = &this->MAGGICCODE;
		req.Type = type;
		req.Arguments = args;
		req.Status = &status;
		memcpy(this->SharedBuffer, &req, sizeof(REQUEST_DATA));
		FlushFileBuffers(this->hDriver);
		return status;
	}

	const UINT GetProcessId(const wchar_t* process_name) {
		UINT pid = 0;
		// Create toolhelp snapshot.
		HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		PROCESSENTRY32 process;
		ZeroMemory(&process, sizeof(process));
		process.dwSize = sizeof(process);
		// Walkthrough all processes.
		if (Process32First(snapshot, &process))
		{
			do
			{
				if (wcsstr(process.szExeFile, process_name))
				{
					pid = process.th32ProcessID;
					break;
				}
			} while (Process32Next(snapshot, &process));
		}
		CloseHandle(snapshot);
		return pid;
	}

	const bool Attach(const wchar_t* Processname, const wchar_t* Classname = 0) {
		if (Classname) {
			while (!FindWindowW(Classname, 0)){ Sleep(50); }
		}
		if (this->ProcessId = this->GetProcessId(Processname))
			return true;
		return false;
	}
	//If PhysicalMode is Aktive ModuleName is not used because it only gets Gamebase! 
	typedef struct Module { uint64_t addr; DWORD size; };
	const Module GetModuleBase(const wchar_t* ModuleName = 0) {
		if (bPhysicalMode) {
			REQUEST_MAINBASE req;
			uint64_t base = NULL;
			req.ProcessId = this->ProcessId;
			req.OutAddress = (PBYTE*)&base;
			this->SendRequest(REQUEST_TYPE::MAINBASE, &req);
			return { base, 0 };
		}
		else {
			if (!ModuleName)
				return { 0, 0 };
			REQUEST_MODULE req;
			uint64_t base = NULL;
			DWORD size = NULL;
			req.ProcessId = this->ProcessId;
			req.OutAddress = (PBYTE*)&base;
			req.OutSize = &size;
			wcscpy_s(req.Module, sizeof(req.Module) / sizeof(req.Module[0]), ModuleName);
			this->SendRequest(REQUEST_TYPE::MODULE, &req);
			return { base, size };
		}
	}


private:
	PVOID SharedBuffer;
	HANDLE hDriver;
	ULONG64 MAGGICCODE = 0x59002360218c1e2dul;
	BOOL bPhysicalMode = FALSE;
	typedef enum _REQUEST_TYPE : UINT {
		WRITE,
		READ,
		PROTECT,
		ALLOC,
		FREE,
		MODULE,
		MAINBASE,
		THREADCALL,
	} REQUEST_TYPE;

	typedef struct _REQUEST_DATA {
		ULONG64* MaggicCode;
		UINT Type;
		PVOID Arguments;
		NTSTATUS* Status;
	} REQUEST_DATA, * PREQUEST_DATA;

	typedef struct _REQUEST_WRITE {
		DWORD ProcessId;
		PVOID Dest;
		PVOID Src;
		DWORD Size;
		BOOL bPhysicalMem;
	} REQUEST_WRITE, * PREQUEST_WRITE;

	typedef struct _REQUEST_READ {
		DWORD ProcessId;
		PVOID Dest;
		PVOID Src;
		DWORD Size;
		BOOL bPhysicalMem;
	} REQUEST_READ, * PREQUEST_READ;

	typedef struct _REQUEST_PROTECT {
		DWORD ProcessId;
		PVOID Address;
		DWORD Size;
		PDWORD InOutProtect;
	} REQUEST_PROTECT, * PREQUEST_PROTECT;

	typedef struct _REQUEST_ALLOC {
		DWORD ProcessId;
		PVOID OutAddress;
		DWORD Size;
		DWORD Protect;
	} REQUEST_ALLOC, * PREQUEST_ALLOC;

	typedef struct _REQUEST_FREE {
		DWORD ProcessId;
		PVOID Address;
	} REQUEST_FREE, * PREQUEST_FREE;

	typedef struct _REQUEST_MODULE {
		DWORD ProcessId;
		WCHAR Module[0xFF];
		PBYTE* OutAddress;
		DWORD* OutSize;
	} REQUEST_MODULE, * PREQUEST_MODULE;

	typedef struct _REQUEST_MAINBASE {
		DWORD ProcessId;
		PBYTE* OutAddress;
	} REQUEST_MAINBASE, * PREQUEST_MAINBASE;
};

static Driver* driver = new Driver;
```

`usermode/stdafx.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <winternl.h>
#include <ntstatus.h>
#include <atomic>
#include <mutex>
#include <TlHelp32.h>

#include "utils.h"
#include "driver.h"

#pragma comment(lib, "ntdll.lib")
```

`usermode/usermode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{90824b2a-2b07-40e1-9c0a-db31d6baaaab}</ProjectGuid>
    <RootNamespace>usermode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WINDOWS_IGNORE_PACKING_MISMATCH;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="UserMain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`usermode/usermode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UserMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`usermode/usermode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`usermode/utils.h`:

```h
#pragma once

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64,
	KeyValueLayerInformation,
	MaxKeyValueInfoClass  // MaxKeyValueInfoClass should always be the last enum
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_FULL_INFORMATION {
	ULONG   TitleIndex;
	ULONG   Type;
	ULONG   DataOffset;
	ULONG   DataLength;
	ULONG   NameLength;
	WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, * PKEY_VALUE_FULL_INFORMATION;


#ifdef __cplusplus
extern "C++"
{
	char _RTL_CONSTANT_STRING_type_check(const char* s);
	char _RTL_CONSTANT_STRING_type_check(const WCHAR* s);
	// __typeof would be desirable here instead of sizeof.
	template <size_t N> class _RTL_CONSTANT_STRING_remove_const_template_class;
template <> class _RTL_CONSTANT_STRING_remove_const_template_class<sizeof(char)> { public: typedef  char T; };
template <> class _RTL_CONSTANT_STRING_remove_const_template_class<sizeof(WCHAR)> { public: typedef WCHAR T; };
#define _RTL_CONSTANT_STRING_remove_const_macro(s) \
    (const_cast<_RTL_CONSTANT_STRING_remove_const_template_class<sizeof((s)[0])>::T*>(s))
}
#else
char _RTL_CONSTANT_STRING_type_check(const void* s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#endif
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}

extern "C" {
	NTSYSAPI
		NTSTATUS
		NTAPI
		ZwQueryValueKey(
			_In_ HANDLE KeyHandle,
			_In_ PUNICODE_STRING ValueName,
			_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
			_Out_writes_bytes_to_opt_(Length, *ResultLength) PVOID KeyValueInformation,
			_In_ ULONG Length,
			_Out_ PULONG ResultLength
		);

	NTSYSAPI
		NTSTATUS
		NTAPI
		ZwClose(
			_In_ HANDLE Handle
		);

	NTSYSAPI
		NTSTATUS
		NTAPI
		ZwOpenKey(
			_Out_ PHANDLE KeyHandle,
			_In_ ACCESS_MASK DesiredAccess,
			_In_ POBJECT_ATTRIBUTES ObjectAttributes
		);

	NTSYSAPI
		NTSTATUS
		NTAPI
		ZwQueryValueKey(
			_In_ HANDLE KeyHandle,
			_In_ PUNICODE_STRING ValueName,
			_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
			_Out_writes_bytes_to_opt_(Length, *ResultLength) PVOID KeyValueInformation,
			_In_ ULONG Length,
			_Out_ PULONG ResultLength
		);

	NTSYSAPI
		NTSTATUS
		NTAPI
		ZwSetValueKey(
			_In_ HANDLE KeyHandle,
			_In_ PUNICODE_STRING ValueName,
			_In_opt_ ULONG TitleIndex,
			_In_ ULONG Type,
			_In_reads_bytes_opt_(DataSize) PVOID Data,
			_In_ ULONG DataSize
		);

	NTSYSAPI NTSTATUS ZwCreateKey(
		PHANDLE            KeyHandle,
		ACCESS_MASK        DesiredAccess,
		POBJECT_ATTRIBUTES ObjectAttributes,
		ULONG              TitleIndex,
		PUNICODE_STRING    Class,
		ULONG              CreateOptions,
		PULONG             Disposition
	);
}

namespace RegistryUtils
{
	__forceinline ULONG GetKeyInfoSize(HANDLE hKey, PUNICODE_STRING Key)
	{
		NTSTATUS Status;
		ULONG KeySize;

		Status = ZwQueryValueKey(hKey, Key, KeyValueFullInformation, 0, 0, &KeySize);

		if (Status == STATUS_BUFFER_TOO_SMALL || Status == STATUS_BUFFER_OVERFLOW)
			return KeySize;

		return 0;
	}

	template <typename type>
	__forceinline type ReadRegistry(UNICODE_STRING RegPath, UNICODE_STRING Key)
	{
		HANDLE hKey;
		OBJECT_ATTRIBUTES ObjAttr;
		NTSTATUS Status = STATUS_UNSUCCESSFUL;

		InitializeObjectAttributes(&ObjAttr, &RegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

		Status = ZwOpenKey(&hKey, KEY_ALL_ACCESS, &ObjAttr);

		if (NT_SUCCESS(Status))
		{
			ULONG KeyInfoSize = GetKeyInfoSize(hKey, &Key);
			ULONG KeyInfoSizeNeeded;

			if (KeyInfoSize == NULL)
			{
				ZwClose(hKey);
				return 0;
			}

			PKEY_VALUE_FULL_INFORMATION pKeyInfo = (PKEY_VALUE_FULL_INFORMATION)malloc(KeyInfoSize);
			RtlZeroMemory(pKeyInfo, KeyInfoSize);

			Status = ZwQueryValueKey(hKey, &Key, KeyValueFullInformation, pKeyInfo, KeyInfoSize, &KeyInfoSizeNeeded);

			if (!NT_SUCCESS(Status) || (KeyInfoSize != KeyInfoSizeNeeded))
			{
				ZwClose(hKey);
				free(pKeyInfo);
				return 0;
			}

			ZwClose(hKey);
			free(pKeyInfo);

			return *(type*)((LONG64)pKeyInfo + pKeyInfo->DataOffset);
		}

		return 0;
	}

	__forceinline bool WriteRegistry(UNICODE_STRING RegPath, UNICODE_STRING Key, PVOID Address, ULONG Type, ULONG Size)
	{
		bool Success = false;
		HANDLE hKey;
		OBJECT_ATTRIBUTES ObjAttr;
		NTSTATUS Status = STATUS_UNSUCCESSFUL;

		InitializeObjectAttributes(&ObjAttr, &RegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

		Status = ZwOpenKey(&hKey, KEY_ALL_ACCESS, &ObjAttr);

		if (NT_SUCCESS(Status))
		{
			Status = ZwSetValueKey(hKey, &Key, NULL, Type, Address, Size);

			if (NT_SUCCESS(Status))
				Success = true;

			ZwClose(hKey);
		}
		else {
			Status = ZwCreateKey(&hKey, KEY_ALL_ACCESS, &ObjAttr, 0, &RegPath, 0, 0);

			if (NT_SUCCESS(Status))
			{
				Status = ZwSetValueKey(hKey, &Key, NULL, Type, Address, Size);

				if (NT_SUCCESS(Status))
					Success = true;
			}
			ZwClose(hKey);
		}

		return Success;
	}
}

```